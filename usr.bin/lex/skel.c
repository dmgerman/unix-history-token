begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* File created from flex.skel via mkskel.sh */
end_comment

begin_include
include|#
directive|include
file|"flexdef.h"
end_include

begin_decl_stmt
name|char
modifier|*
name|skel
index|[]
init|=
block|{
literal|"/* A lexical scanner generated by flex */"
block|,
literal|""
block|,
literal|"/* Scanner skeleton version:"
block|,
literal|" * $Header: /home/daffy/u0/vern/flex/flex-2.4.7/RCS/flex.skl,v 1.2 94/08/03 11:13:24 vern Exp $"
block|,
literal|" */"
block|,
literal|""
block|,
literal|"#define FLEX_SCANNER"
block|,
literal|""
block|,
literal|"%-"
block|,
literal|"#include<stdio.h>"
block|,
literal|"%*"
block|,
literal|""
block|,
literal|""
block|,
literal|"/* cfront 1.2 defines \"c_plusplus\" instead of \"__cplusplus\" */"
block|,
literal|"#ifdef c_plusplus"
block|,
literal|"#ifndef __cplusplus"
block|,
literal|"#define __cplusplus"
block|,
literal|"#endif"
block|,
literal|"#endif"
block|,
literal|""
block|,
literal|""
block|,
literal|"#ifdef __cplusplus"
block|,
literal|""
block|,
literal|"#include<stdlib.h>"
block|,
literal|"%+"
block|,
literal|"class istream;"
block|,
literal|"%*"
block|,
literal|"#include<unistd.h>"
block|,
literal|""
block|,
literal|"/* Use prototypes in function declarations. */"
block|,
literal|"#define YY_USE_PROTOS"
block|,
literal|""
block|,
literal|"/* The \"const\" storage-class-modifier is valid. */"
block|,
literal|"#define YY_USE_CONST"
block|,
literal|""
block|,
literal|"#else	/* ! __cplusplus */"
block|,
literal|""
block|,
literal|"#ifdef __STDC__"
block|,
literal|""
block|,
literal|"#define YY_USE_PROTOS"
block|,
literal|"#define YY_USE_CONST"
block|,
literal|""
block|,
literal|"#endif	/* __STDC__ */"
block|,
literal|"#endif	/* ! __cplusplus */"
block|,
literal|""
block|,
literal|""
block|,
literal|"#ifdef __TURBOC__"
block|,
literal|"#define YY_USE_CONST"
block|,
literal|"#endif"
block|,
literal|""
block|,
literal|""
block|,
literal|"#ifndef YY_USE_CONST"
block|,
literal|"#ifndef const"
block|,
literal|"#define const"
block|,
literal|"#endif"
block|,
literal|"#endif"
block|,
literal|""
block|,
literal|""
block|,
literal|"#ifdef YY_USE_PROTOS"
block|,
literal|"#define YY_PROTO(proto) proto"
block|,
literal|"#else"
block|,
literal|"#define YY_PROTO(proto) ()"
block|,
literal|"#endif"
block|,
literal|""
block|,
literal|"/* Returned upon end-of-file. */"
block|,
literal|"#define YY_NULL 0"
block|,
literal|""
block|,
literal|"/* Promotes a possibly negative, possibly signed char to an unsigned"
block|,
literal|" * integer for use as an array index.  If the signed char is negative,"
block|,
literal|" * we want to instead treat it as an 8-bit unsigned char, hence the"
block|,
literal|" * double cast."
block|,
literal|" */"
block|,
literal|"#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)"
block|,
literal|""
block|,
literal|"/* Enter a start condition.  This macro really ought to take a parameter,"
block|,
literal|" * but we do it the disgusting crufty way forced on us by the ()-less"
block|,
literal|" * definition of BEGIN."
block|,
literal|" */"
block|,
literal|"#define BEGIN yy_start = 1 + 2 *"
block|,
literal|""
block|,
literal|"/* Translate the current start state into a value that can be later handed"
block|,
literal|" * to BEGIN to return to the state."
block|,
literal|" */"
block|,
literal|"#define YY_START ((yy_start - 1) / 2)"
block|,
literal|""
block|,
literal|"/* Action number for EOF rule of a given start state. */"
block|,
literal|"#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)"
block|,
literal|""
block|,
literal|"/* Special action meaning \"start processing a new file\".  Now included"
block|,
literal|" * only for backward compatibility with previous versions of flex."
block|,
literal|" */"
block|,
literal|"#define YY_NEW_FILE yyrestart( yyin )"
block|,
literal|""
block|,
literal|"#define YY_END_OF_BUFFER_CHAR 0"
block|,
literal|""
block|,
literal|"/* Size of default input buffer. */"
block|,
literal|"#define YY_BUF_SIZE 16384"
block|,
literal|""
block|,
literal|"typedef struct yy_buffer_state *YY_BUFFER_STATE;"
block|,
literal|""
block|,
literal|"extern int yyleng;"
block|,
literal|"%-"
block|,
literal|"extern FILE *yyin, *yyout;"
block|,
literal|"%*"
block|,
literal|""
block|,
literal|"#ifdef __cplusplus"
block|,
literal|"extern \"C\" {"
block|,
literal|"#endif"
block|,
literal|"	extern int yywrap YY_PROTO(( void ));"
block|,
literal|"#ifdef __cplusplus"
block|,
literal|"	}"
block|,
literal|"#endif"
block|,
literal|""
block|,
literal|"#define EOB_ACT_CONTINUE_SCAN 0"
block|,
literal|"#define EOB_ACT_END_OF_FILE 1"
block|,
literal|"#define EOB_ACT_LAST_MATCH 2"
block|,
literal|""
block|,
literal|"/* The funky do-while in the following #define is used to turn the definition"
block|,
literal|" * int a single C statement (which needs a semi-colon terminator).  This"
block|,
literal|" * avoids problems with code like:"
block|,
literal|" *"
block|,
literal|" * 	if ( condition_holds )"
block|,
literal|" *		yyless( 5 );"
block|,
literal|" *	else"
block|,
literal|" *		do_something_else();"
block|,
literal|" *"
block|,
literal|" * Prior to using the do-while the compiler would get upset at the"
block|,
literal|" * \"else\" because it interpreted the \"if\" statement as being all"
block|,
literal|" * done when it reached the ';' after the yyless() call."
block|,
literal|" */"
block|,
literal|""
block|,
literal|"/* Return all but the first 'n' matched characters back to the input stream. */"
block|,
literal|""
block|,
literal|"#define yyless(n) \\"
block|,
literal|"	do \\"
block|,
literal|"		{ \\"
block|,
literal|"		/* Undo effects of setting up yytext. */ \\"
block|,
literal|"		*yy_cp = yy_hold_char; \\"
block|,
literal|"		yy_c_buf_p = yy_cp = yy_bp + n - YY_MORE_ADJ; \\"
block|,
literal|"		YY_DO_BEFORE_ACTION; /* set up yytext again */ \\"
block|,
literal|"		} \\"
block|,
literal|"	while ( 0 )"
block|,
literal|""
block|,
literal|"#define unput(c) yyunput( c, yytext_ptr )"
block|,
literal|""
block|,
literal|""
block|,
literal|"struct yy_buffer_state"
block|,
literal|"	{"
block|,
literal|"%-"
block|,
literal|"	FILE *yy_input_file;"
block|,
literal|"%+"
block|,
literal|"	istream* yy_input_file;"
block|,
literal|"%*"
block|,
literal|""
block|,
literal|"	char *yy_ch_buf;		/* input buffer */"
block|,
literal|"	char *yy_buf_pos;		/* current position in input buffer */"
block|,
literal|""
block|,
literal|"	/* Size of input buffer in bytes, not including room for EOB"
block|,
literal|"	 * characters."
block|,
literal|"	 */"
block|,
literal|"	int yy_buf_size;"
block|,
literal|""
block|,
literal|"	/* Number of characters read into yy_ch_buf, not including EOB"
block|,
literal|"	 * characters."
block|,
literal|"	 */"
block|,
literal|"	int yy_n_chars;"
block|,
literal|""
block|,
literal|"	/* Whether this is an \"interactive\" input source; if so, and"
block|,
literal|"	 * if we're using stdio for input, then we want to use getc()"
block|,
literal|"	 * instead of fread(), to make sure we stop fetching input after"
block|,
literal|"	 * each newline."
block|,
literal|"	 */"
block|,
literal|"	int yy_is_interactive;"
block|,
literal|""
block|,
literal|"	/* Whether to try to fill the input buffer when we reach the"
block|,
literal|"	 * end of it."
block|,
literal|"	 */"
block|,
literal|"	int yy_fill_buffer;"
block|,
literal|""
block|,
literal|"	int yy_buffer_status;"
block|,
literal|"#define YY_BUFFER_NEW 0"
block|,
literal|"#define YY_BUFFER_NORMAL 1"
block|,
literal|"	/* When an EOF's been seen but there's still some text to process"
block|,
literal|"	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we"
block|,
literal|"	 * shouldn't try reading from the input source any more.  We might"
block|,
literal|"	 * still have a bunch of tokens to match, though, because of"
block|,
literal|"	 * possible backing-up."
block|,
literal|"	 *"
block|,
literal|"	 * When we actually see the EOF, we change the status to \"new\""
block|,
literal|"	 * (via yyrestart()), so that the user can continue scanning by"
block|,
literal|"	 * just pointing yyin at a new input file."
block|,
literal|"	 */"
block|,
literal|"#define YY_BUFFER_EOF_PENDING 2"
block|,
literal|"	};"
block|,
literal|""
block|,
literal|"%- Standard (non-C++) definition"
block|,
literal|"static YY_BUFFER_STATE yy_current_buffer = 0;"
block|,
literal|"%*"
block|,
literal|""
block|,
literal|"/* We provide macros for accessing buffer states in case in the"
block|,
literal|" * future we want to put the buffer states in a more general"
block|,
literal|" * \"scanner state\"."
block|,
literal|" */"
block|,
literal|"#define YY_CURRENT_BUFFER yy_current_buffer"
block|,
literal|""
block|,
literal|""
block|,
literal|"%- Standard (non-C++) definition"
block|,
literal|"/* yy_hold_char holds the character lost when yytext is formed. */"
block|,
literal|"static char yy_hold_char;"
block|,
literal|""
block|,
literal|"static int yy_n_chars;		/* number of characters read into yy_ch_buf */"
block|,
literal|""
block|,
literal|""
block|,
literal|"int yyleng;"
block|,
literal|""
block|,
literal|"/* Points to current character in buffer. */"
block|,
literal|"static char *yy_c_buf_p = (char *) 0;"
block|,
literal|"static int yy_init = 1;		/* whether we need to initialize */"
block|,
literal|"static int yy_start = 0;	/* start state number */"
block|,
literal|""
block|,
literal|"/* Flag which is used to allow yywrap()'s to do buffer switches"
block|,
literal|" * instead of setting up a fresh yyin.  A bit of a hack ..."
block|,
literal|" */"
block|,
literal|"static int yy_did_buffer_switch_on_eof;"
block|,
literal|""
block|,
literal|"static void yyunput YY_PROTO(( int c, char *buf_ptr ));"
block|,
literal|"void yyrestart YY_PROTO(( FILE *input_file ));"
block|,
literal|"void yy_switch_to_buffer YY_PROTO(( YY_BUFFER_STATE new_buffer ));"
block|,
literal|"void yy_load_buffer_state YY_PROTO(( void ));"
block|,
literal|"YY_BUFFER_STATE yy_create_buffer YY_PROTO(( FILE *file, int size ));"
block|,
literal|"void yy_delete_buffer YY_PROTO(( YY_BUFFER_STATE b ));"
block|,
literal|"void yy_init_buffer YY_PROTO(( YY_BUFFER_STATE b, FILE *file ));"
block|,
literal|""
block|,
literal|"static int yy_start_stack_ptr = 0;"
block|,
literal|"static int yy_start_stack_depth = 0;"
block|,
literal|"static int *yy_start_stack = 0;"
block|,
literal|"static void yy_push_state YY_PROTO(( int new_state ));"
block|,
literal|"static void yy_pop_state YY_PROTO(( void ));"
block|,
literal|"static int yy_top_state YY_PROTO(( void ));"
block|,
literal|"%*"
block|,
literal|""
block|,
literal|"static void *yy_flex_alloc YY_PROTO(( unsigned int ));"
block|,
literal|"static void *yy_flex_realloc YY_PROTO(( void *, unsigned int ));"
block|,
literal|"static void yy_flex_free YY_PROTO(( void * ));"
block|,
literal|""
block|,
literal|"#define yy_new_buffer yy_create_buffer"
block|,
literal|""
block|,
literal|"%% yytext/yyin/yyout/yy_state_type/yylineno etc. def's& init go here"
block|,
literal|""
block|,
literal|"#ifndef yytext_ptr"
block|,
literal|"static void yy_flex_strncpy YY_PROTO(( char *, const char *, int ));"
block|,
literal|"#endif"
block|,
literal|""
block|,
literal|"%- Standard (non-C++) definition"
block|,
literal|"#ifdef __cplusplus"
block|,
literal|"static int yyinput YY_PROTO(( void ));"
block|,
literal|"#else"
block|,
literal|"static int input YY_PROTO(( void ));"
block|,
literal|"#endif"
block|,
literal|"%*"
block|,
literal|""
block|,
literal|"%- Standard (non-C++) definition"
block|,
literal|"static yy_state_type yy_get_previous_state YY_PROTO(( void ));"
block|,
literal|"static yy_state_type yy_try_NUL_trans YY_PROTO(( yy_state_type current_state ));"
block|,
literal|"static int yy_get_next_buffer YY_PROTO(( void ));"
block|,
literal|"static void yy_fatal_error YY_PROTO(( const char msg[] ));"
block|,
literal|"%*"
block|,
literal|""
block|,
literal|"/* Done after the current pattern has been matched and before the"
block|,
literal|" * corresponding action - sets up yytext."
block|,
literal|" */"
block|,
literal|"#define YY_DO_BEFORE_ACTION \\"
block|,
literal|"	yytext_ptr = yy_bp; \\"
block|,
literal|"%% code to fiddle yytext and yyleng for yymore() goes here"
block|,
literal|"	yy_hold_char = *yy_cp; \\"
block|,
literal|"	*yy_cp = '\\0'; \\"
block|,
literal|"%% code to copy yytext_ptr to yytext[] goes here, if %array"
block|,
literal|"	yy_c_buf_p = yy_cp;"
block|,
literal|""
block|,
literal|"%% data tables for the DFA and the user's section 1 definitions go here"
block|,
literal|""
block|,
literal|"/* Macros after this point can all be overridden by user definitions in"
block|,
literal|" * section 1."
block|,
literal|" */"
block|,
literal|""
block|,
literal|"#ifdef YY_MALLOC_DECL"
block|,
literal|"YY_MALLOC_DECL"
block|,
literal|"#else"
block|,
literal|"#if __STDC__"
block|,
literal|"#ifndef __cplusplus"
block|,
literal|"#include<stdlib.h>"
block|,
literal|"#endif"
block|,
literal|"#else"
block|,
literal|"/* Just try to get by without declaring the routines.  This will fail"
block|,
literal|" * miserably on non-ANSI systems for which sizeof(size_t) != sizeof(int)"
block|,
literal|" * or sizeof(void*) != sizeof(int)."
block|,
literal|" */"
block|,
literal|"#endif"
block|,
literal|"#endif"
block|,
literal|""
block|,
literal|"/* Amount of stuff to slurp up with each read. */"
block|,
literal|"#ifndef YY_READ_BUF_SIZE"
block|,
literal|"#define YY_READ_BUF_SIZE 8192"
block|,
literal|"#endif"
block|,
literal|""
block|,
literal|"/* Copy whatever the last rule matched to the standard output. */"
block|,
literal|""
block|,
literal|"#ifndef ECHO"
block|,
literal|"%- Standard (non-C++) definition"
block|,
literal|"/* This used to be an fputs(), but since the string might contain NUL's,"
block|,
literal|" * we now use fwrite()."
block|,
literal|" */"
block|,
literal|"#define ECHO (void) fwrite( yytext, yyleng, 1, yyout )"
block|,
literal|"%+ C++ definition"
block|,
literal|"#define ECHO LexerOutput( yytext, yyleng )"
block|,
literal|"%*"
block|,
literal|"#endif"
block|,
literal|""
block|,
literal|"/* Gets input and stuffs it into \"buf\".  number of characters read, or YY_NULL,"
block|,
literal|" * is returned in \"result\"."
block|,
literal|" */"
block|,
literal|"#ifndef YY_INPUT"
block|,
literal|"#define YY_INPUT(buf,result,max_size) \\"
block|,
literal|"%% fread()/read() definition of YY_INPUT goes here unless we're doing C++"
block|,
literal|"%+ C++ definition"
block|,
literal|"	if ( (result = LexerInput( (char *) buf, max_size ))< 0 ) \\"
block|,
literal|"		YY_FATAL_ERROR( \"input in flex scanner failed\" );"
block|,
literal|"%*"
block|,
literal|"#endif"
block|,
literal|""
block|,
literal|"/* No semi-colon after return; correct usage is to write \"yyterminate();\" -"
block|,
literal|" * we don't want an extra ';' after the \"return\" because that will cause"
block|,
literal|" * some compilers to complain about unreachable statements."
block|,
literal|" */"
block|,
literal|"#ifndef yyterminate"
block|,
literal|"#define yyterminate() return YY_NULL"
block|,
literal|"#endif"
block|,
literal|""
block|,
literal|"/* Number of entries by which start-condition stack grows. */"
block|,
literal|"#ifndef YY_START_STACK_INCR"
block|,
literal|"#define YY_START_STACK_INCR 25"
block|,
literal|"#endif"
block|,
literal|""
block|,
literal|"/* Report a fatal error. */"
block|,
literal|"#ifndef YY_FATAL_ERROR"
block|,
literal|"%-"
block|,
literal|"#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )"
block|,
literal|"%+"
block|,
literal|"#define YY_FATAL_ERROR(msg) LexerError( msg )"
block|,
literal|"%*"
block|,
literal|"#endif"
block|,
literal|""
block|,
literal|"/* Default declaration of generated scanner - a define so the user can"
block|,
literal|" * easily add parameters."
block|,
literal|" */"
block|,
literal|"#ifndef YY_DECL"
block|,
literal|"%- Standard (non-C++) definition"
block|,
literal|"#define YY_DECL int yylex YY_PROTO(( void ))"
block|,
literal|"%+ C++ definition"
block|,
literal|"#define YY_DECL int yyFlexLexer::yylex()"
block|,
literal|"%*"
block|,
literal|"#endif"
block|,
literal|""
block|,
literal|"/* Code executed at the beginning of each rule, after yytext and yyleng"
block|,
literal|" * have been set up."
block|,
literal|" */"
block|,
literal|"#ifndef YY_USER_ACTION"
block|,
literal|"#define YY_USER_ACTION"
block|,
literal|"#endif"
block|,
literal|""
block|,
literal|"/* Code executed at the end of each rule. */"
block|,
literal|"#ifndef YY_BREAK"
block|,
literal|"#define YY_BREAK break;"
block|,
literal|"#endif"
block|,
literal|""
block|,
literal|"YY_DECL"
block|,
literal|"	{"
block|,
literal|"	register yy_state_type yy_current_state;"
block|,
literal|"	register char *yy_cp, *yy_bp;"
block|,
literal|"	register int yy_act;"
block|,
literal|""
block|,
literal|"%% user's declarations go here"
block|,
literal|""
block|,
literal|"	if ( yy_init )"
block|,
literal|"		{"
block|,
literal|"#ifdef YY_USER_INIT"
block|,
literal|"		YY_USER_INIT;"
block|,
literal|"#endif"
block|,
literal|""
block|,
literal|"		if ( ! yy_start )"
block|,
literal|"			yy_start = 1;	/* first start state */"
block|,
literal|""
block|,
literal|"		if ( ! yyin )"
block|,
literal|"%-"
block|,
literal|"			yyin = stdin;"
block|,
literal|"%+"
block|,
literal|"			yyin =&cin;"
block|,
literal|"%*"
block|,
literal|""
block|,
literal|"		if ( ! yyout )"
block|,
literal|"%-"
block|,
literal|"			yyout = stdout;"
block|,
literal|"%+"
block|,
literal|"			yyout =&cout;"
block|,
literal|"%*"
block|,
literal|""
block|,
literal|"		if ( yy_current_buffer )"
block|,
literal|"			yy_init_buffer( yy_current_buffer, yyin );"
block|,
literal|"		else"
block|,
literal|"			yy_current_buffer ="
block|,
literal|"				yy_create_buffer( yyin, YY_BUF_SIZE );"
block|,
literal|""
block|,
literal|"		yy_load_buffer_state();"
block|,
literal|""
block|,
literal|"		yy_init = 0;"
block|,
literal|"		}"
block|,
literal|""
block|,
literal|"	while ( 1 )		/* loops until end-of-file is reached */"
block|,
literal|"		{"
block|,
literal|"%% yymore()-related code goes here"
block|,
literal|"		yy_cp = yy_c_buf_p;"
block|,
literal|""
block|,
literal|"		/* Support of yytext. */"
block|,
literal|"		*yy_cp = yy_hold_char;"
block|,
literal|""
block|,
literal|"		/* yy_bp points to the position in yy_ch_buf of the start of"
block|,
literal|"		 * the current run."
block|,
literal|"		 */"
block|,
literal|"		yy_bp = yy_cp;"
block|,
literal|""
block|,
literal|"%% code to set up and find next match goes here"
block|,
literal|""
block|,
literal|"yy_find_action:"
block|,
literal|"%% code to find the action number goes here"
block|,
literal|""
block|,
literal|"		YY_DO_BEFORE_ACTION;"
block|,
literal|""
block|,
literal|"%% code for yylineno update goes here, if -l option"
block|,
literal|""
block|,
literal|"do_action:	/* This label is used only to access EOF actions. */"
block|,
literal|""
block|,
literal|"%% debug code goes here"
block|,
literal|""
block|,
literal|"		switch ( yy_act )"
block|,
literal|"	{ /* beginning of action switch */"
block|,
literal|"%% actions go here"
block|,
literal|""
block|,
literal|"	case YY_END_OF_BUFFER:"
block|,
literal|"		{"
block|,
literal|"		/* Amount of text matched not including the EOB char. */"
block|,
literal|"		int yy_amount_of_matched_text = yy_cp - yytext_ptr - 1;"
block|,
literal|""
block|,
literal|"		/* Undo the effects of YY_DO_BEFORE_ACTION. */"
block|,
literal|"		*yy_cp = yy_hold_char;"
block|,
literal|""
block|,
literal|"		if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_NEW )"
block|,
literal|"			{"
block|,
literal|"			/* We're scanning a new file or input source.  It's"
block|,
literal|"			 * possible that this happened because the user"
block|,
literal|"			 * just pointed yyin at a new source and called"
block|,
literal|"			 * yylex().  If so, then we have to assure"
block|,
literal|"			 * consistency between yy_current_buffer and our"
block|,
literal|"			 * globals.  Here is the right place to do so, because"
block|,
literal|"			 * this is the first action (other than possibly a"
block|,
literal|"			 * back-up) that will match for the new input source."
block|,
literal|"			 */"
block|,
literal|"			yy_n_chars = yy_current_buffer->yy_n_chars;"
block|,
literal|"			yy_current_buffer->yy_input_file = yyin;"
block|,
literal|"			yy_current_buffer->yy_buffer_status = YY_BUFFER_NORMAL;"
block|,
literal|"			}"
block|,
literal|""
block|,
literal|"		/* Note that here we test for yy_c_buf_p \"<=\" to the position"
block|,
literal|"		 * of the first EOB in the buffer, since yy_c_buf_p will"
block|,
literal|"		 * already have been incremented past the NUL character"
block|,
literal|"		 * (since all states make transitions on EOB to the"
block|,
literal|"		 * end-of-buffer state).  Contrast this with the test"
block|,
literal|"		 * in input()."
block|,
literal|"		 */"
block|,
literal|"		if ( yy_c_buf_p<=&yy_current_buffer->yy_ch_buf[yy_n_chars] )"
block|,
literal|"			{ /* This was really a NUL. */"
block|,
literal|"			yy_state_type yy_next_state;"
block|,
literal|""
block|,
literal|"			yy_c_buf_p = yytext_ptr + yy_amount_of_matched_text;"
block|,
literal|""
block|,
literal|"			yy_current_state = yy_get_previous_state();"
block|,
literal|""
block|,
literal|"			/* Okay, we're now positioned to make the NUL"
block|,
literal|"			 * transition.  We couldn't have"
block|,
literal|"			 * yy_get_previous_state() go ahead and do it"
block|,
literal|"			 * for us because it doesn't know how to deal"
block|,
literal|"			 * with the possibility of jamming (and we don't"
block|,
literal|"			 * want to build jamming into it because then it"
block|,
literal|"			 * will run more slowly)."
block|,
literal|"			 */"
block|,
literal|""
block|,
literal|"			yy_next_state = yy_try_NUL_trans( yy_current_state );"
block|,
literal|""
block|,
literal|"			yy_bp = yytext_ptr + YY_MORE_ADJ;"
block|,
literal|""
block|,
literal|"			if ( yy_next_state )"
block|,
literal|"				{"
block|,
literal|"				/* Consume the NUL. */"
block|,
literal|"				yy_cp = ++yy_c_buf_p;"
block|,
literal|"				yy_current_state = yy_next_state;"
block|,
literal|"				goto yy_match;"
block|,
literal|"				}"
block|,
literal|""
block|,
literal|"			else"
block|,
literal|"				{"
block|,
literal|"%% code to do back-up for compressed tables and set up yy_cp goes here"
block|,
literal|"				goto yy_find_action;"
block|,
literal|"				}"
block|,
literal|"			}"
block|,
literal|""
block|,
literal|"		else switch ( yy_get_next_buffer() )"
block|,
literal|"			{"
block|,
literal|"			case EOB_ACT_END_OF_FILE:"
block|,
literal|"				{"
block|,
literal|"				yy_did_buffer_switch_on_eof = 0;"
block|,
literal|""
block|,
literal|"				if ( yywrap() )"
block|,
literal|"					{"
block|,
literal|"					/* Note: because we've taken care in"
block|,
literal|"					 * yy_get_next_buffer() to have set up"
block|,
literal|"					 * yytext, we can now set up"
block|,
literal|"					 * yy_c_buf_p so that if some total"
block|,
literal|"					 * hoser (like flex itself) wants to"
block|,
literal|"					 * call the scanner after we return the"
block|,
literal|"					 * YY_NULL, it'll still work - another"
block|,
literal|"					 * YY_NULL will get returned."
block|,
literal|"					 */"
block|,
literal|"					yy_c_buf_p = yytext_ptr + YY_MORE_ADJ;"
block|,
literal|""
block|,
literal|"					yy_act = YY_STATE_EOF(YY_START);"
block|,
literal|"					goto do_action;"
block|,
literal|"					}"
block|,
literal|""
block|,
literal|"				else"
block|,
literal|"					{"
block|,
literal|"					if ( ! yy_did_buffer_switch_on_eof )"
block|,
literal|"						YY_NEW_FILE;"
block|,
literal|"					}"
block|,
literal|"				break;"
block|,
literal|"				}"
block|,
literal|""
block|,
literal|"			case EOB_ACT_CONTINUE_SCAN:"
block|,
literal|"				yy_c_buf_p ="
block|,
literal|"					yytext_ptr + yy_amount_of_matched_text;"
block|,
literal|""
block|,
literal|"				yy_current_state = yy_get_previous_state();"
block|,
literal|""
block|,
literal|"				yy_cp = yy_c_buf_p;"
block|,
literal|"				yy_bp = yytext_ptr + YY_MORE_ADJ;"
block|,
literal|"				goto yy_match;"
block|,
literal|""
block|,
literal|"			case EOB_ACT_LAST_MATCH:"
block|,
literal|"				yy_c_buf_p ="
block|,
literal|"&yy_current_buffer->yy_ch_buf[yy_n_chars];"
block|,
literal|""
block|,
literal|"				yy_current_state = yy_get_previous_state();"
block|,
literal|""
block|,
literal|"				yy_cp = yy_c_buf_p;"
block|,
literal|"				yy_bp = yytext_ptr + YY_MORE_ADJ;"
block|,
literal|"				goto yy_find_action;"
block|,
literal|"			}"
block|,
literal|"		break;"
block|,
literal|"		}"
block|,
literal|""
block|,
literal|"	default:"
block|,
literal|"		YY_FATAL_ERROR("
block|,
literal|"			\"fatal flex scanner internal error--no action found\" );"
block|,
literal|"	} /* end of action switch */"
block|,
literal|"		} /* end of scanning one token */"
block|,
literal|"	} /* end of yylex */"
block|,
literal|""
block|,
literal|"%+"
block|,
literal|"#ifdef YY_INTERACTIVE"
block|,
literal|"int yyFlexLexer::LexerInput( char* buf, int /* max_size */ )"
block|,
literal|"#else"
block|,
literal|"int yyFlexLexer::LexerInput( char* buf, int max_size )"
block|,
literal|"#endif"
block|,
literal|"	{"
block|,
literal|"	if ( yyin->eof() || yyin->fail() )"
block|,
literal|"		return 0;"
block|,
literal|""
block|,
literal|"#ifdef YY_INTERACTIVE"
block|,
literal|"	yyin->get( buf[0] );"
block|,
literal|""
block|,
literal|"	if ( yyin->eof() )"
block|,
literal|"		return 0;"
block|,
literal|""
block|,
literal|"	if ( yyin->bad() )"
block|,
literal|"		return -1;"
block|,
literal|""
block|,
literal|"	return 1;"
block|,
literal|""
block|,
literal|"#else"
block|,
literal|"	(void) yyin->read( buf, max_size );"
block|,
literal|""
block|,
literal|"	if ( yyin->bad() )"
block|,
literal|"		return -1;"
block|,
literal|"	else"
block|,
literal|"		return yyin->gcount();"
block|,
literal|"#endif"
block|,
literal|"	}"
block|,
literal|""
block|,
literal|"void yyFlexLexer::LexerOutput( const char* buf, int size )"
block|,
literal|"	{"
block|,
literal|"	(void) yyout->write( buf, size );"
block|,
literal|"	}"
block|,
literal|"%*"
block|,
literal|""
block|,
literal|"/* yy_get_next_buffer - try to read in a new buffer"
block|,
literal|" *"
block|,
literal|" * Returns a code representing an action:"
block|,
literal|" *	EOB_ACT_LAST_MATCH -"
block|,
literal|" *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position"
block|,
literal|" *	EOB_ACT_END_OF_FILE - end of file"
block|,
literal|" */"
block|,
literal|""
block|,
literal|"%-"
block|,
literal|"static int yy_get_next_buffer()"
block|,
literal|"%+"
block|,
literal|"int yyFlexLexer::yy_get_next_buffer()"
block|,
literal|"%*"
block|,
literal|"	{"
block|,
literal|"	register char *dest = yy_current_buffer->yy_ch_buf;"
block|,
literal|"	register char *source = yytext_ptr - 1; /* copy prev. char, too */"
block|,
literal|"	register int number_to_move, i;"
block|,
literal|"	int ret_val;"
block|,
literal|""
block|,
literal|"	if ( yy_c_buf_p>&yy_current_buffer->yy_ch_buf[yy_n_chars + 1] )"
block|,
literal|"		YY_FATAL_ERROR("
block|,
literal|"		\"fatal flex scanner internal error--end of buffer missed\" );"
block|,
literal|""
block|,
literal|"	if ( yy_current_buffer->yy_fill_buffer == 0 )"
block|,
literal|"		{ /* Don't try to fill the buffer, so this is an EOF. */"
block|,
literal|"		if ( yy_c_buf_p - yytext_ptr - YY_MORE_ADJ == 1 )"
block|,
literal|"			{"
block|,
literal|"			/* We matched a singled characater, the EOB, so"
block|,
literal|"			 * treat this as a final EOF."
block|,
literal|"			 */"
block|,
literal|"			return EOB_ACT_END_OF_FILE;"
block|,
literal|"			}"
block|,
literal|""
block|,
literal|"		else"
block|,
literal|"			{"
block|,
literal|"			/* We matched some text prior to the EOB, first"
block|,
literal|"			 * process it."
block|,
literal|"			 */"
block|,
literal|"			return EOB_ACT_LAST_MATCH;"
block|,
literal|"			}"
block|,
literal|"		}"
block|,
literal|""
block|,
literal|"	/* Try to read more data. */"
block|,
literal|""
block|,
literal|"	/* First move last chars to start of buffer. */"
block|,
literal|"	number_to_move = yy_c_buf_p - yytext_ptr;"
block|,
literal|""
block|,
literal|"	for ( i = 0; i< number_to_move; ++i )"
block|,
literal|"		*(dest++) = *(source++);"
block|,
literal|""
block|,
literal|"	if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_EOF_PENDING )"
block|,
literal|"		/* don't do the read, it's not guaranteed to return an EOF,"
block|,
literal|"		 * just force an EOF"
block|,
literal|"		 */"
block|,
literal|"		yy_n_chars = 0;"
block|,
literal|""
block|,
literal|"	else"
block|,
literal|"		{"
block|,
literal|"		int num_to_read ="
block|,
literal|"			yy_current_buffer->yy_buf_size - number_to_move - 1;"
block|,
literal|""
block|,
literal|"		while ( num_to_read<= 0 )"
block|,
literal|"			{ /* Not enough room in the buffer - grow it. */"
block|,
literal|"#ifdef YY_USES_REJECT"
block|,
literal|"			YY_FATAL_ERROR("
block|,
literal|"\"input buffer overflow, can't enlarge buffer because scanner uses REJECT\" );"
block|,
literal|"#else"
block|,
literal|""
block|,
literal|"			/* just a shorter name for the current buffer */"
block|,
literal|"			YY_BUFFER_STATE b = yy_current_buffer;"
block|,
literal|""
block|,
literal|"			int yy_c_buf_p_offset = yy_c_buf_p - b->yy_ch_buf;"
block|,
literal|""
block|,
literal|"			b->yy_buf_size *= 2;"
block|,
literal|"			b->yy_ch_buf = (char *)"
block|,
literal|"				yy_flex_realloc( (void *) b->yy_ch_buf,"
block|,
literal|"						 b->yy_buf_size );"
block|,
literal|""
block|,
literal|"			if ( ! b->yy_ch_buf )"
block|,
literal|"				YY_FATAL_ERROR("
block|,
literal|"				\"fatal error - scanner input buffer overflow\" );"
block|,
literal|""
block|,
literal|"			yy_c_buf_p =&b->yy_ch_buf[yy_c_buf_p_offset];"
block|,
literal|""
block|,
literal|"			num_to_read = yy_current_buffer->yy_buf_size -"
block|,
literal|"						number_to_move - 1;"
block|,
literal|"#endif"
block|,
literal|"			}"
block|,
literal|""
block|,
literal|"		if ( num_to_read> YY_READ_BUF_SIZE )"
block|,
literal|"			num_to_read = YY_READ_BUF_SIZE;"
block|,
literal|""
block|,
literal|"		/* Read in more data. */"
block|,
literal|"		YY_INPUT( (&yy_current_buffer->yy_ch_buf[number_to_move]),"
block|,
literal|"			yy_n_chars, num_to_read );"
block|,
literal|"		}"
block|,
literal|""
block|,
literal|"	if ( yy_n_chars == 0 )"
block|,
literal|"		{"
block|,
literal|"		if ( number_to_move - YY_MORE_ADJ == 1 )"
block|,
literal|"			{"
block|,
literal|"			ret_val = EOB_ACT_END_OF_FILE;"
block|,
literal|"			yyrestart( yyin );"
block|,
literal|"			}"
block|,
literal|""
block|,
literal|"		else"
block|,
literal|"			{"
block|,
literal|"			ret_val = EOB_ACT_LAST_MATCH;"
block|,
literal|"			yy_current_buffer->yy_buffer_status ="
block|,
literal|"				YY_BUFFER_EOF_PENDING;"
block|,
literal|"			}"
block|,
literal|"		}"
block|,
literal|""
block|,
literal|"	else"
block|,
literal|"		ret_val = EOB_ACT_CONTINUE_SCAN;"
block|,
literal|""
block|,
literal|"	yy_n_chars += number_to_move;"
block|,
literal|"	yy_current_buffer->yy_ch_buf[yy_n_chars] = YY_END_OF_BUFFER_CHAR;"
block|,
literal|"	yy_current_buffer->yy_ch_buf[yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;"
block|,
literal|""
block|,
literal|"	/* yytext begins at the second character in yy_ch_buf; the first"
block|,
literal|"	 * character is the one which preceded it before reading in the latest"
block|,
literal|"	 * buffer; it needs to be kept around in case it's a newline, so"
block|,
literal|"	 * yy_get_previous_state() will have with '^' rules active."
block|,
literal|"	 */"
block|,
literal|""
block|,
literal|"	yytext_ptr =&yy_current_buffer->yy_ch_buf[1];"
block|,
literal|""
block|,
literal|"	return ret_val;"
block|,
literal|"	}"
block|,
literal|""
block|,
literal|""
block|,
literal|"/* yy_get_previous_state - get the state just before the EOB char was reached */"
block|,
literal|""
block|,
literal|"%-"
block|,
literal|"static yy_state_type yy_get_previous_state()"
block|,
literal|"%+"
block|,
literal|"yy_state_type yyFlexLexer::yy_get_previous_state()"
block|,
literal|"%*"
block|,
literal|"	{"
block|,
literal|"	register yy_state_type yy_current_state;"
block|,
literal|"	register char *yy_cp;"
block|,
literal|""
block|,
literal|"%% code to get the start state into yy_current_state goes here"
block|,
literal|""
block|,
literal|"	for ( yy_cp = yytext_ptr + YY_MORE_ADJ; yy_cp< yy_c_buf_p; ++yy_cp )"
block|,
literal|"		{"
block|,
literal|"%% code to find the next state goes here"
block|,
literal|"		}"
block|,
literal|""
block|,
literal|"	return yy_current_state;"
block|,
literal|"	}"
block|,
literal|""
block|,
literal|""
block|,
literal|"/* yy_try_NUL_trans - try to make a transition on the NUL character"
block|,
literal|" *"
block|,
literal|" * synopsis"
block|,
literal|" *	next_state = yy_try_NUL_trans( current_state );"
block|,
literal|" */"
block|,
literal|""
block|,
literal|"%-"
block|,
literal|"#ifdef YY_USE_PROTOS"
block|,
literal|"static yy_state_type yy_try_NUL_trans( yy_state_type yy_current_state )"
block|,
literal|"#else"
block|,
literal|"static yy_state_type yy_try_NUL_trans( yy_current_state )"
block|,
literal|"yy_state_type yy_current_state;"
block|,
literal|"#endif"
block|,
literal|"%+"
block|,
literal|"yy_state_type yyFlexLexer::yy_try_NUL_trans( yy_state_type yy_current_state )"
block|,
literal|"%*"
block|,
literal|"	{"
block|,
literal|"	register int yy_is_jam;"
block|,
literal|"%% code to find the next state, and perhaps do backing up, goes here"
block|,
literal|""
block|,
literal|"	return yy_is_jam ? 0 : yy_current_state;"
block|,
literal|"	}"
block|,
literal|""
block|,
literal|""
block|,
literal|"%-"
block|,
literal|"#ifdef YY_USE_PROTOS"
block|,
literal|"static void yyunput( int c, register char *yy_bp )"
block|,
literal|"#else"
block|,
literal|"static void yyunput( c, yy_bp )"
block|,
literal|"int c;"
block|,
literal|"register char *yy_bp;"
block|,
literal|"#endif"
block|,
literal|"%+"
block|,
literal|"void yyFlexLexer::yyunput( int c, register char* yy_bp )"
block|,
literal|"%*"
block|,
literal|"	{"
block|,
literal|"	register char *yy_cp = yy_c_buf_p;"
block|,
literal|""
block|,
literal|"	/* undo effects of setting up yytext */"
block|,
literal|"	*yy_cp = yy_hold_char;"
block|,
literal|""
block|,
literal|"	if ( yy_cp< yy_current_buffer->yy_ch_buf + 2 )"
block|,
literal|"		{ /* need to shift things up to make room */"
block|,
literal|"		/* +2 for EOB chars. */"
block|,
literal|"		register int number_to_move = yy_n_chars + 2;"
block|,
literal|"		register char *dest =&yy_current_buffer->yy_ch_buf["
block|,
literal|"					yy_current_buffer->yy_buf_size + 2];"
block|,
literal|"		register char *source ="
block|,
literal|"&yy_current_buffer->yy_ch_buf[number_to_move];"
block|,
literal|""
block|,
literal|"		while ( source> yy_current_buffer->yy_ch_buf )"
block|,
literal|"			*--dest = *--source;"
block|,
literal|""
block|,
literal|"		yy_cp += dest - source;"
block|,
literal|"		yy_bp += dest - source;"
block|,
literal|"		yy_n_chars = yy_current_buffer->yy_buf_size;"
block|,
literal|""
block|,
literal|"		if ( yy_cp< yy_current_buffer->yy_ch_buf + 2 )"
block|,
literal|"			YY_FATAL_ERROR( \"flex scanner push-back overflow\" );"
block|,
literal|"		}"
block|,
literal|""
block|,
literal|"	if ( yy_cp> yy_bp&& yy_cp[-1] == '\\n' )"
block|,
literal|"		yy_cp[-2] = '\\n';"
block|,
literal|""
block|,
literal|"	*--yy_cp = (char) c;"
block|,
literal|""
block|,
literal|"%% update yylineno here, if doing -l"
block|,
literal|""
block|,
literal|"	/* Note: the formal parameter *must* be called \"yy_bp\" for this"
block|,
literal|"	 * macro to now work correctly."
block|,
literal|"	 */"
block|,
literal|"	YY_DO_BEFORE_ACTION; /* set up yytext again */"
block|,
literal|"	}"
block|,
literal|""
block|,
literal|""
block|,
literal|"%-"
block|,
literal|"#ifdef __cplusplus"
block|,
literal|"static int yyinput()"
block|,
literal|"#else"
block|,
literal|"static int input()"
block|,
literal|"#endif"
block|,
literal|"%+"
block|,
literal|"int yyFlexLexer::yyinput()"
block|,
literal|"%*"
block|,
literal|"	{"
block|,
literal|"	int c;"
block|,
literal|""
block|,
literal|"	*yy_c_buf_p = yy_hold_char;"
block|,
literal|""
block|,
literal|"	if ( *yy_c_buf_p == YY_END_OF_BUFFER_CHAR )"
block|,
literal|"		{"
block|,
literal|"		/* yy_c_buf_p now points to the character we want to return."
block|,
literal|"		 * If this occurs *before* the EOB characters, then it's a"
block|,
literal|"		 * valid NUL; if not, then we've hit the end of the buffer."
block|,
literal|"		 */"
block|,
literal|"		if ( yy_c_buf_p<&yy_current_buffer->yy_ch_buf[yy_n_chars] )"
block|,
literal|"			/* This was really a NUL. */"
block|,
literal|"			*yy_c_buf_p = '\\0';"
block|,
literal|""
block|,
literal|"		else"
block|,
literal|"			{ /* need more input */"
block|,
literal|"			yytext_ptr = yy_c_buf_p;"
block|,
literal|"			++yy_c_buf_p;"
block|,
literal|""
block|,
literal|"			switch ( yy_get_next_buffer() )"
block|,
literal|"				{"
block|,
literal|"				case EOB_ACT_END_OF_FILE:"
block|,
literal|"					{"
block|,
literal|"					if ( yywrap() )"
block|,
literal|"						{"
block|,
literal|"						yy_c_buf_p ="
block|,
literal|"						yytext_ptr + YY_MORE_ADJ;"
block|,
literal|"						return EOF;"
block|,
literal|"						}"
block|,
literal|""
block|,
literal|"					YY_NEW_FILE;"
block|,
literal|"#ifdef __cplusplus"
block|,
literal|"					return yyinput();"
block|,
literal|"#else"
block|,
literal|"					return input();"
block|,
literal|"#endif"
block|,
literal|"					}"
block|,
literal|""
block|,
literal|"				case EOB_ACT_CONTINUE_SCAN:"
block|,
literal|"					yy_c_buf_p = yytext_ptr + YY_MORE_ADJ;"
block|,
literal|"					break;"
block|,
literal|""
block|,
literal|"				case EOB_ACT_LAST_MATCH:"
block|,
literal|"#ifdef __cplusplus"
block|,
literal|"					YY_FATAL_ERROR("
block|,
literal|"					\"unexpected last match in yyinput()\" );"
block|,
literal|"#else"
block|,
literal|"					YY_FATAL_ERROR("
block|,
literal|"					\"unexpected last match in input()\" );"
block|,
literal|"#endif"
block|,
literal|"				}"
block|,
literal|"			}"
block|,
literal|"		}"
block|,
literal|""
block|,
literal|"	c = *(unsigned char *) yy_c_buf_p;	/* cast for 8-bit char's */"
block|,
literal|"	*yy_c_buf_p = '\\0';	/* preserve yytext */"
block|,
literal|"	yy_hold_char = *++yy_c_buf_p;"
block|,
literal|""
block|,
literal|"	return c;"
block|,
literal|"	}"
block|,
literal|""
block|,
literal|""
block|,
literal|"%-"
block|,
literal|"#ifdef YY_USE_PROTOS"
block|,
literal|"void yyrestart( FILE *input_file )"
block|,
literal|"#else"
block|,
literal|"void yyrestart( input_file )"
block|,
literal|"FILE *input_file;"
block|,
literal|"#endif"
block|,
literal|"%+"
block|,
literal|"void yyFlexLexer::yyrestart( istream* input_file )"
block|,
literal|"%*"
block|,
literal|"	{"
block|,
literal|"	if ( ! yy_current_buffer )"
block|,
literal|"		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE );"
block|,
literal|""
block|,
literal|"	yy_init_buffer( yy_current_buffer, input_file );"
block|,
literal|"	yy_load_buffer_state();"
block|,
literal|"	}"
block|,
literal|""
block|,
literal|""
block|,
literal|"%-"
block|,
literal|"#ifdef YY_USE_PROTOS"
block|,
literal|"void yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )"
block|,
literal|"#else"
block|,
literal|"void yy_switch_to_buffer( new_buffer )"
block|,
literal|"YY_BUFFER_STATE new_buffer;"
block|,
literal|"#endif"
block|,
literal|"%+"
block|,
literal|"void yyFlexLexer::yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )"
block|,
literal|"%*"
block|,
literal|"	{"
block|,
literal|"	if ( yy_current_buffer == new_buffer )"
block|,
literal|"		return;"
block|,
literal|""
block|,
literal|"	if ( yy_current_buffer )"
block|,
literal|"		{"
block|,
literal|"		/* Flush out information for old buffer. */"
block|,
literal|"		*yy_c_buf_p = yy_hold_char;"
block|,
literal|"		yy_current_buffer->yy_buf_pos = yy_c_buf_p;"
block|,
literal|"		yy_current_buffer->yy_n_chars = yy_n_chars;"
block|,
literal|"		}"
block|,
literal|""
block|,
literal|"	yy_current_buffer = new_buffer;"
block|,
literal|"	yy_load_buffer_state();"
block|,
literal|""
block|,
literal|"	/* We don't actually know whether we did this switch during"
block|,
literal|"	 * EOF (yywrap()) processing, but the only time this flag"
block|,
literal|"	 * is looked at is after yywrap() is called, so it's safe"
block|,
literal|"	 * to go ahead and always set it."
block|,
literal|"	 */"
block|,
literal|"	yy_did_buffer_switch_on_eof = 1;"
block|,
literal|"	}"
block|,
literal|""
block|,
literal|""
block|,
literal|"%-"
block|,
literal|"#ifdef YY_USE_PROTOS"
block|,
literal|"void yy_load_buffer_state( void )"
block|,
literal|"#else"
block|,
literal|"void yy_load_buffer_state()"
block|,
literal|"#endif"
block|,
literal|"%+"
block|,
literal|"void yyFlexLexer::yy_load_buffer_state()"
block|,
literal|"%*"
block|,
literal|"	{"
block|,
literal|"	yy_n_chars = yy_current_buffer->yy_n_chars;"
block|,
literal|"	yytext_ptr = yy_c_buf_p = yy_current_buffer->yy_buf_pos;"
block|,
literal|"	yyin = yy_current_buffer->yy_input_file;"
block|,
literal|"	yy_hold_char = *yy_c_buf_p;"
block|,
literal|"	}"
block|,
literal|""
block|,
literal|""
block|,
literal|"%-"
block|,
literal|"#ifdef YY_USE_PROTOS"
block|,
literal|"YY_BUFFER_STATE yy_create_buffer( FILE *file, int size )"
block|,
literal|"#else"
block|,
literal|"YY_BUFFER_STATE yy_create_buffer( file, size )"
block|,
literal|"FILE *file;"
block|,
literal|"int size;"
block|,
literal|"#endif"
block|,
literal|"%+"
block|,
literal|"YY_BUFFER_STATE yyFlexLexer::yy_create_buffer( istream* file, int size )"
block|,
literal|"%*"
block|,
literal|"	{"
block|,
literal|"	YY_BUFFER_STATE b;"
block|,
literal|""
block|,
literal|"	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );"
block|,
literal|""
block|,
literal|"	if ( ! b )"
block|,
literal|"		YY_FATAL_ERROR( \"out of dynamic memory in yy_create_buffer()\" );"
block|,
literal|""
block|,
literal|"	b->yy_buf_size = size;"
block|,
literal|""
block|,
literal|"	/* yy_ch_buf has to be 2 characters longer than the size given because"
block|,
literal|"	 * we need to put in 2 end-of-buffer characters."
block|,
literal|"	 */"
block|,
literal|"	b->yy_ch_buf = (char *) yy_flex_alloc( b->yy_buf_size + 2 );"
block|,
literal|""
block|,
literal|"	if ( ! b->yy_ch_buf )"
block|,
literal|"		YY_FATAL_ERROR( \"out of dynamic memory in yy_create_buffer()\" );"
block|,
literal|""
block|,
literal|"	yy_init_buffer( b, file );"
block|,
literal|""
block|,
literal|"	return b;"
block|,
literal|"	}"
block|,
literal|""
block|,
literal|""
block|,
literal|"%-"
block|,
literal|"#ifdef YY_USE_PROTOS"
block|,
literal|"void yy_delete_buffer( YY_BUFFER_STATE b )"
block|,
literal|"#else"
block|,
literal|"void yy_delete_buffer( b )"
block|,
literal|"YY_BUFFER_STATE b;"
block|,
literal|"#endif"
block|,
literal|"%+"
block|,
literal|"void yyFlexLexer::yy_delete_buffer( YY_BUFFER_STATE b )"
block|,
literal|"%*"
block|,
literal|"	{"
block|,
literal|"	if ( b == yy_current_buffer )"
block|,
literal|"		yy_current_buffer = (YY_BUFFER_STATE) 0;"
block|,
literal|""
block|,
literal|"	yy_flex_free( (void *) b->yy_ch_buf );"
block|,
literal|"	yy_flex_free( (void *) b );"
block|,
literal|"	}"
block|,
literal|""
block|,
literal|""
block|,
literal|"%-"
block|,
literal|"#ifdef YY_USE_PROTOS"
block|,
literal|"void yy_init_buffer( YY_BUFFER_STATE b, FILE *file )"
block|,
literal|"#else"
block|,
literal|"void yy_init_buffer( b, file )"
block|,
literal|"YY_BUFFER_STATE b;"
block|,
literal|"FILE *file;"
block|,
literal|"#endif"
block|,
literal|"%+"
block|,
literal|"void yyFlexLexer::yy_init_buffer( YY_BUFFER_STATE b, istream* file )"
block|,
literal|"%*"
block|,
literal|"	{"
block|,
literal|"	b->yy_input_file = file;"
block|,
literal|""
block|,
literal|"	/* We put in the '\\n' and start reading from [1] so that an"
block|,
literal|"	 * initial match-at-newline will be true."
block|,
literal|"	 */"
block|,
literal|""
block|,
literal|"	b->yy_ch_buf[0] = '\\n';"
block|,
literal|"	b->yy_n_chars = 1;"
block|,
literal|""
block|,
literal|"	/* We always need two end-of-buffer characters.  The first causes"
block|,
literal|"	 * a transition to the end-of-buffer state.  The second causes"
block|,
literal|"	 * a jam in that state."
block|,
literal|"	 */"
block|,
literal|"	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;"
block|,
literal|"	b->yy_ch_buf[2] = YY_END_OF_BUFFER_CHAR;"
block|,
literal|""
block|,
literal|"	b->yy_buf_pos =&b->yy_ch_buf[1];"
block|,
literal|""
block|,
literal|"%-"
block|,
literal|"	b->yy_is_interactive = file ? isatty( fileno(file) ) : 0;"
block|,
literal|"%+"
block|,
literal|"	b->yy_is_interactive = 0;"
block|,
literal|"%*"
block|,
literal|""
block|,
literal|"	b->yy_fill_buffer = 1;"
block|,
literal|""
block|,
literal|"	b->yy_buffer_status = YY_BUFFER_NEW;"
block|,
literal|"	}"
block|,
literal|""
block|,
literal|""
block|,
literal|"%-"
block|,
literal|"#ifdef YY_USE_PROTOS"
block|,
literal|"static void yy_push_state( int new_state )"
block|,
literal|"#else"
block|,
literal|"static void yy_push_state( new_state )"
block|,
literal|"int new_state;"
block|,
literal|"#endif"
block|,
literal|"%+"
block|,
literal|"void yyFlexLexer::yy_push_state( int new_state )"
block|,
literal|"%*"
block|,
literal|"	{"
block|,
literal|"	if ( yy_start_stack_ptr>= yy_start_stack_depth )"
block|,
literal|"		{"
block|,
literal|"		int new_size;"
block|,
literal|""
block|,
literal|"		yy_start_stack_depth += YY_START_STACK_INCR;"
block|,
literal|"		new_size = yy_start_stack_depth * sizeof( int );"
block|,
literal|""
block|,
literal|"		if ( ! yy_start_stack )"
block|,
literal|"			yy_start_stack = (int *) yy_flex_alloc( new_size );"
block|,
literal|""
block|,
literal|"		else"
block|,
literal|"			yy_start_stack = (int *) yy_flex_realloc("
block|,
literal|"					(void *) yy_start_stack, new_size );"
block|,
literal|""
block|,
literal|"		if ( ! yy_start_stack )"
block|,
literal|"			YY_FATAL_ERROR("
block|,
literal|"			\"out of memory expanding start-condition stack\" );"
block|,
literal|"		}"
block|,
literal|""
block|,
literal|"	yy_start_stack[yy_start_stack_ptr++] = YY_START;"
block|,
literal|""
block|,
literal|"	BEGIN(new_state);"
block|,
literal|"	}"
block|,
literal|""
block|,
literal|""
block|,
literal|"%-"
block|,
literal|"static void yy_pop_state()"
block|,
literal|"%+"
block|,
literal|"void yyFlexLexer::yy_pop_state()"
block|,
literal|"%*"
block|,
literal|"	{"
block|,
literal|"	if ( --yy_start_stack_ptr< 0 )"
block|,
literal|"		YY_FATAL_ERROR( \"start-condition stack underflow\" );"
block|,
literal|""
block|,
literal|"	BEGIN(yy_start_stack[yy_start_stack_ptr]);"
block|,
literal|"	}"
block|,
literal|""
block|,
literal|""
block|,
literal|"%-"
block|,
literal|"static int yy_top_state()"
block|,
literal|"%+"
block|,
literal|"int yyFlexLexer::yy_top_state()"
block|,
literal|"%*"
block|,
literal|"	{"
block|,
literal|"	return yy_start_stack[yy_start_stack_ptr - 1];"
block|,
literal|"	}"
block|,
literal|""
block|,
literal|""
block|,
literal|"%-"
block|,
literal|"#ifdef YY_USE_PROTOS"
block|,
literal|"static void yy_fatal_error( const char msg[] )"
block|,
literal|"#else"
block|,
literal|"static void yy_fatal_error( msg )"
block|,
literal|"char msg[];"
block|,
literal|"#endif"
block|,
literal|"	{"
block|,
literal|"	(void) fprintf( stderr, \"%s\\n\", msg );"
block|,
literal|"	exit( 1 );"
block|,
literal|"	}"
block|,
literal|""
block|,
literal|"%+"
block|,
literal|""
block|,
literal|"void yyFlexLexer::LexerError( const char msg[] )"
block|,
literal|"	{"
block|,
literal|"	cerr<< msg<< '\\n';"
block|,
literal|"	exit( 1 );"
block|,
literal|"	}"
block|,
literal|"%*"
block|,
literal|""
block|,
literal|""
block|,
literal|"/* Redefine yyless() so it works in section 3 code. */"
block|,
literal|""
block|,
literal|"#undef yyless"
block|,
literal|"#define yyless(n) \\"
block|,
literal|"	do \\"
block|,
literal|"		{ \\"
block|,
literal|"		/* Undo effects of setting up yytext. */ \\"
block|,
literal|"		yytext[yyleng] = yy_hold_char; \\"
block|,
literal|"		yy_c_buf_p = yytext + n - YY_MORE_ADJ; \\"
block|,
literal|"		yy_hold_char = *yy_c_buf_p; \\"
block|,
literal|"		*yy_c_buf_p = '\\0'; \\"
block|,
literal|"		yyleng = n; \\"
block|,
literal|"		} \\"
block|,
literal|"	while ( 0 )"
block|,
literal|""
block|,
literal|""
block|,
literal|"/* Internal utility routines. */"
block|,
literal|""
block|,
literal|"#ifndef yytext_ptr"
block|,
literal|"#ifdef YY_USE_PROTOS"
block|,
literal|"static void yy_flex_strncpy( char *s1, const char *s2, int n )"
block|,
literal|"#else"
block|,
literal|"static void yy_flex_strncpy( s1, s2, n )"
block|,
literal|"char *s1;"
block|,
literal|"const char *s2;"
block|,
literal|"int n;"
block|,
literal|"#endif"
block|,
literal|"	{"
block|,
literal|"	register int i;"
block|,
literal|"	for ( i = 0; i< n; ++i )"
block|,
literal|"		s1[i] = s2[i];"
block|,
literal|"	}"
block|,
literal|"#endif"
block|,
literal|""
block|,
literal|""
block|,
literal|"#ifdef YY_USE_PROTOS"
block|,
literal|"static void *yy_flex_alloc( unsigned int size )"
block|,
literal|"#else"
block|,
literal|"static void *yy_flex_alloc( size )"
block|,
literal|"unsigned int size;"
block|,
literal|"#endif"
block|,
literal|"	{"
block|,
literal|"	return (void *) malloc( size );"
block|,
literal|"	}"
block|,
literal|""
block|,
literal|"#ifdef YY_USE_PROTOS"
block|,
literal|"static void *yy_flex_realloc( void *ptr, unsigned int size )"
block|,
literal|"#else"
block|,
literal|"static void *yy_flex_realloc( ptr, size )"
block|,
literal|"void *ptr;"
block|,
literal|"unsigned int size;"
block|,
literal|"#endif"
block|,
literal|"	{"
block|,
literal|"	return (void *) realloc( ptr, size );"
block|,
literal|"	}"
block|,
literal|""
block|,
literal|"#ifdef YY_USE_PROTOS"
block|,
literal|"static void yy_flex_free( void *ptr )"
block|,
literal|"#else"
block|,
literal|"static void yy_flex_free( ptr )"
block|,
literal|"void *ptr;"
block|,
literal|"#endif"
block|,
literal|"	{"
block|,
literal|"	free( ptr );"
block|,
literal|"	}"
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

end_unit

