begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* dfa - DFA construction routines */
end_comment

begin_comment
comment|/*-  * Copyright (c) 1990 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Vern Paxson.  *  * The United States Government has rights in this work pursuant  * to contract no. DE-AC03-76SF00098 between the United States  * Department of Energy and the University of California.  *  * Redistribution and use in source and binary forms are permitted provided  * that: (1) source distributions retain this entire copyright notice and  * comment, and (2) distributions including binaries display the following  * acknowledgement:  ``This product includes software developed by the  * University of California, Berkeley and its contributors'' in the  * documentation or other materials provided with the distribution and in  * all advertising materials mentioning features or use of this software.  * Neither the name of the University nor the names of its contributors may  * be used to endorse or promote products derived from this software without  * specific prior written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED  * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  */
end_comment

begin_comment
comment|/* $Header: /pub/FreeBSD/FreeBSD-CVS/src/usr.bin/lex/dfa.c,v 1.2 1995/05/30 06:31:08 rgrimes Exp $ */
end_comment

begin_include
include|#
directive|include
file|"flexdef.h"
end_include

begin_comment
comment|/* declare functions that have forward references */
end_comment

begin_decl_stmt
name|void
name|dump_associated_rules
name|PROTO
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|dump_transitions
name|PROTO
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|int
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|sympartition
name|PROTO
argument_list|(
operator|(
name|int
index|[]
operator|,
name|int
operator|,
name|int
index|[]
operator|,
name|int
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|symfollowset
name|PROTO
argument_list|(
operator|(
name|int
index|[]
operator|,
name|int
operator|,
name|int
operator|,
name|int
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* check_for_backing_up - check a DFA state for backing up  *  * synopsis  *     void check_for_backing_up( int ds, int state[numecs] );  *  * ds is the number of the state to check and state[] is its out-transitions,  * indexed by equivalence class.  */
end_comment

begin_function
name|void
name|check_for_backing_up
parameter_list|(
name|ds
parameter_list|,
name|state
parameter_list|)
name|int
name|ds
decl_stmt|;
name|int
name|state
index|[]
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|reject
operator|&&
operator|!
name|dfaacc
index|[
name|ds
index|]
operator|.
name|dfaacc_set
operator|)
operator|||
operator|(
operator|!
name|reject
operator|&&
operator|!
name|dfaacc
index|[
name|ds
index|]
operator|.
name|dfaacc_state
operator|)
condition|)
block|{
comment|/* state is non-accepting */
operator|++
name|num_backing_up
expr_stmt|;
if|if
condition|(
name|backing_up_report
condition|)
block|{
name|fprintf
argument_list|(
name|backing_up_file
argument_list|,
literal|"State #%d is non-accepting -\n"
argument_list|,
name|ds
argument_list|)
expr_stmt|;
comment|/* identify the state */
name|dump_associated_rules
argument_list|(
name|backing_up_file
argument_list|,
name|ds
argument_list|)
expr_stmt|;
comment|/* Now identify it further using the out- and 			 * jam-transitions. 			 */
name|dump_transitions
argument_list|(
name|backing_up_file
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|backing_up_file
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* check_trailing_context - check to see if NFA state set constitutes  *                          "dangerous" trailing context  *  * synopsis  *    void check_trailing_context( int nfa_states[num_states+1], int num_states,  *				int accset[nacc+1], int nacc );  *  * NOTES  *  Trailing context is "dangerous" if both the head and the trailing  *  part are of variable size \and/ there's a DFA state which contains  *  both an accepting state for the head part of the rule and NFA states  *  which occur after the beginning of the trailing context.  *  *  When such a rule is matched, it's impossible to tell if having been  *  in the DFA state indicates the beginning of the trailing context or  *  further-along scanning of the pattern.  In these cases, a warning  *  message is issued.  *  *    nfa_states[1 .. num_states] is the list of NFA states in the DFA.  *    accset[1 .. nacc] is the list of accepting numbers for the DFA state.  */
end_comment

begin_function
name|void
name|check_trailing_context
parameter_list|(
name|nfa_states
parameter_list|,
name|num_states
parameter_list|,
name|accset
parameter_list|,
name|nacc
parameter_list|)
name|int
modifier|*
name|nfa_states
decl_stmt|,
name|num_states
decl_stmt|;
name|int
modifier|*
name|accset
decl_stmt|;
specifier|register
name|int
name|nacc
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|num_states
condition|;
operator|++
name|i
control|)
block|{
name|int
name|ns
init|=
name|nfa_states
index|[
name|i
index|]
decl_stmt|;
specifier|register
name|int
name|type
init|=
name|state_type
index|[
name|ns
index|]
decl_stmt|;
specifier|register
name|int
name|ar
init|=
name|assoc_rule
index|[
name|ns
index|]
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|STATE_NORMAL
operator|||
name|rule_type
index|[
name|ar
index|]
operator|!=
name|RULE_VARIABLE
condition|)
block|{
comment|/* do nothing */
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|STATE_TRAILING_CONTEXT
condition|)
block|{
comment|/* Potential trouble.  Scan set of accepting numbers 			 * for the one marking the end of the "head".  We 			 * assume that this looping will be fairly cheap 			 * since it's rare that an accepting number set 			 * is large. 			 */
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<=
name|nacc
condition|;
operator|++
name|j
control|)
if|if
condition|(
name|accset
index|[
name|j
index|]
operator|&
name|YY_TRAILING_HEAD_MASK
condition|)
block|{
name|line_warning
argument_list|(
literal|"dangerous trailing context"
argument_list|,
name|rule_linenum
index|[
name|ar
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* dump_associated_rules - list the rules associated with a DFA state  *  * Goes through the set of NFA states associated with the DFA and  * extracts the first MAX_ASSOC_RULES unique rules, sorts them,  * and writes a report to the given file.  */
end_comment

begin_function
name|void
name|dump_associated_rules
parameter_list|(
name|file
parameter_list|,
name|ds
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|int
name|ds
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|register
name|int
name|num_associated_rules
init|=
literal|0
decl_stmt|;
name|int
name|rule_set
index|[
name|MAX_ASSOC_RULES
operator|+
literal|1
index|]
decl_stmt|;
name|int
modifier|*
name|dset
init|=
name|dss
index|[
name|ds
index|]
decl_stmt|;
name|int
name|size
init|=
name|dfasiz
index|[
name|ds
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|size
condition|;
operator|++
name|i
control|)
block|{
specifier|register
name|int
name|rule_num
init|=
name|rule_linenum
index|[
name|assoc_rule
index|[
name|dset
index|[
name|i
index|]
index|]
index|]
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<=
name|num_associated_rules
condition|;
operator|++
name|j
control|)
if|if
condition|(
name|rule_num
operator|==
name|rule_set
index|[
name|j
index|]
condition|)
break|break;
if|if
condition|(
name|j
operator|>
name|num_associated_rules
condition|)
block|{
comment|/* new rule */
if|if
condition|(
name|num_associated_rules
operator|<
name|MAX_ASSOC_RULES
condition|)
name|rule_set
index|[
operator|++
name|num_associated_rules
index|]
operator|=
name|rule_num
expr_stmt|;
block|}
block|}
name|bubble
argument_list|(
name|rule_set
argument_list|,
name|num_associated_rules
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" associated rule line numbers:"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|num_associated_rules
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|i
operator|%
literal|8
operator|==
literal|1
condition|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t%d"
argument_list|,
name|rule_set
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* dump_transitions - list the transitions associated with a DFA state  *  * synopsis  *     dump_transitions( FILE *file, int state[numecs] );  *  * Goes through the set of out-transitions and lists them in human-readable  * form (i.e., not as equivalence classes); also lists jam transitions  * (i.e., all those which are not out-transitions, plus EOF).  The dump  * is done to the given file.  */
end_comment

begin_function
name|void
name|dump_transitions
parameter_list|(
name|file
parameter_list|,
name|state
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|int
name|state
index|[]
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|ec
decl_stmt|;
name|int
name|out_char_set
index|[
name|CSIZE
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|csize
condition|;
operator|++
name|i
control|)
block|{
name|ec
operator|=
name|ABS
argument_list|(
name|ecgroup
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|out_char_set
index|[
name|i
index|]
operator|=
name|state
index|[
name|ec
index|]
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" out-transitions: "
argument_list|)
expr_stmt|;
name|list_character_set
argument_list|(
name|file
argument_list|,
name|out_char_set
argument_list|)
expr_stmt|;
comment|/* now invert the members of the set to get the jam transitions */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|csize
condition|;
operator|++
name|i
control|)
name|out_char_set
index|[
name|i
index|]
operator|=
operator|!
name|out_char_set
index|[
name|i
index|]
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n jam-transitions: EOF "
argument_list|)
expr_stmt|;
name|list_character_set
argument_list|(
name|file
argument_list|,
name|out_char_set
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* epsclosure - construct the epsilon closure of a set of ndfa states  *  * synopsis  *    int *epsclosure( int t[num_states], int *numstates_addr,  *			int accset[num_rules+1], int *nacc_addr,  *			int *hashval_addr );  *  * NOTES  *  The epsilon closure is the set of all states reachable by an arbitrary  *  number of epsilon transitions, which themselves do not have epsilon  *  transitions going out, unioned with the set of states which have non-null  *  accepting numbers.  t is an array of size numstates of nfa state numbers.  *  Upon return, t holds the epsilon closure and *numstates_addr is updated.  *  accset holds a list of the accepting numbers, and the size of accset is  *  given by *nacc_addr.  t may be subjected to reallocation if it is not  *  large enough to hold the epsilon closure.  *  *  hashval is the hash value for the dfa corresponding to the state set.  */
end_comment

begin_decl_stmt
name|int
modifier|*
name|epsclosure
argument_list|(
name|t
argument_list|,
name|ns_addr
argument_list|,
name|accset
argument_list|,
name|nacc_addr
argument_list|,
name|hv_addr
argument_list|)
name|int
modifier|*
name|t
decl_stmt|,
modifier|*
name|ns_addr
decl_stmt|,
name|accset
index|[]
decl_stmt|,
modifier|*
name|nacc_addr
decl_stmt|,
modifier|*
name|hv_addr
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|stkpos
decl_stmt|,
name|ns
decl_stmt|,
name|tsp
decl_stmt|;
name|int
name|numstates
init|=
operator|*
name|ns_addr
decl_stmt|,
name|nacc
decl_stmt|,
name|hashval
decl_stmt|,
name|transsym
decl_stmt|,
name|nfaccnum
decl_stmt|;
name|int
name|stkend
decl_stmt|,
name|nstate
decl_stmt|;
specifier|static
name|int
name|did_stk_init
init|=
name|false
decl_stmt|,
modifier|*
name|stk
decl_stmt|;
define|#
directive|define
name|MARK_STATE
parameter_list|(
name|state
parameter_list|)
define|\
value|trans1[state] = trans1[state] - MARKER_DIFFERENCE;
define|#
directive|define
name|IS_MARKED
parameter_list|(
name|state
parameter_list|)
value|(trans1[state]< 0)
define|#
directive|define
name|UNMARK_STATE
parameter_list|(
name|state
parameter_list|)
define|\
value|trans1[state] = trans1[state] + MARKER_DIFFERENCE;
define|#
directive|define
name|CHECK_ACCEPT
parameter_list|(
name|state
parameter_list|)
define|\
value|{ \ nfaccnum = accptnum[state]; \ if ( nfaccnum != NIL ) \ accset[++nacc] = nfaccnum; \ }
define|#
directive|define
name|DO_REALLOCATION
define|\
value|{ \ current_max_dfa_size += MAX_DFA_SIZE_INCREMENT; \ ++num_reallocs; \ t = reallocate_integer_array( t, current_max_dfa_size ); \ stk = reallocate_integer_array( stk, current_max_dfa_size ); \ } \  #define PUT_ON_STACK(state) \ { \ if ( ++stkend>= current_max_dfa_size ) \ DO_REALLOCATION \ stk[stkend] = state; \ MARK_STATE(state) \ }
define|#
directive|define
name|ADD_STATE
parameter_list|(
name|state
parameter_list|)
define|\
value|{ \ if ( ++numstates>= current_max_dfa_size ) \ DO_REALLOCATION \ t[numstates] = state; \ hashval += state; \ }
define|#
directive|define
name|STACK_STATE
parameter_list|(
name|state
parameter_list|)
define|\
value|{ \ PUT_ON_STACK(state) \ CHECK_ACCEPT(state) \ if ( nfaccnum != NIL || transchar[state] != SYM_EPSILON ) \ ADD_STATE(state) \ }
if|if
condition|(
operator|!
name|did_stk_init
condition|)
block|{
name|stk
operator|=
name|allocate_integer_array
argument_list|(
name|current_max_dfa_size
argument_list|)
expr_stmt|;
name|did_stk_init
operator|=
name|true
expr_stmt|;
block|}
name|nacc
operator|=
name|stkend
operator|=
name|hashval
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|nstate
operator|=
literal|1
init|;
name|nstate
operator|<=
name|numstates
condition|;
operator|++
name|nstate
control|)
block|{
name|ns
operator|=
name|t
index|[
name|nstate
index|]
expr_stmt|;
comment|/* The state could be marked if we've already pushed it onto 		 * the stack. 		 */
if|if
condition|(
operator|!
name|IS_MARKED
argument_list|(
name|ns
argument_list|)
condition|)
block|{
name|PUT_ON_STACK
argument_list|(
argument|ns
argument_list|)
name|CHECK_ACCEPT
argument_list|(
argument|ns
argument_list|)
name|hashval
operator|+=
name|ns
expr_stmt|;
block|}
block|}
for|for
control|(
name|stkpos
operator|=
literal|1
init|;
name|stkpos
operator|<=
name|stkend
condition|;
operator|++
name|stkpos
control|)
block|{
name|ns
operator|=
name|stk
index|[
name|stkpos
index|]
expr_stmt|;
name|transsym
operator|=
name|transchar
index|[
name|ns
index|]
expr_stmt|;
if|if
condition|(
name|transsym
operator|==
name|SYM_EPSILON
condition|)
block|{
name|tsp
operator|=
name|trans1
index|[
name|ns
index|]
operator|+
name|MARKER_DIFFERENCE
expr_stmt|;
if|if
condition|(
name|tsp
operator|!=
name|NO_TRANSITION
condition|)
block|{
if|if
condition|(
operator|!
name|IS_MARKED
argument_list|(
name|tsp
argument_list|)
condition|)
name|STACK_STATE
argument_list|(
argument|tsp
argument_list|)
name|tsp
operator|=
name|trans2
index|[
name|ns
index|]
expr_stmt|;
if|if
condition|(
name|tsp
operator|!=
name|NO_TRANSITION
operator|&&
operator|!
name|IS_MARKED
argument_list|(
name|tsp
argument_list|)
condition|)
name|STACK_STATE
argument_list|(
argument|tsp
argument_list|)
block|}
block|}
block|}
comment|/* Clear out "visit" markers. */
for|for
control|(
name|stkpos
operator|=
literal|1
init|;
name|stkpos
operator|<=
name|stkend
condition|;
operator|++
name|stkpos
control|)
block|{
if|if
condition|(
name|IS_MARKED
argument_list|(
name|stk
index|[
name|stkpos
index|]
argument_list|)
condition|)
name|UNMARK_STATE
argument_list|(
argument|stk[stkpos]
argument_list|)
else|else
name|flexfatal
argument_list|(
literal|"consistency check failed in epsclosure()"
argument_list|)
expr_stmt|;
block|}
operator|*
name|ns_addr
operator|=
name|numstates
expr_stmt|;
operator|*
name|hv_addr
operator|=
name|hashval
expr_stmt|;
operator|*
name|nacc_addr
operator|=
name|nacc
expr_stmt|;
return|return
name|t
return|;
block|}
end_block

begin_comment
comment|/* increase_max_dfas - increase the maximum number of DFAs */
end_comment

begin_function
name|void
name|increase_max_dfas
parameter_list|()
block|{
name|current_max_dfas
operator|+=
name|MAX_DFAS_INCREMENT
expr_stmt|;
operator|++
name|num_reallocs
expr_stmt|;
name|base
operator|=
name|reallocate_integer_array
argument_list|(
name|base
argument_list|,
name|current_max_dfas
argument_list|)
expr_stmt|;
name|def
operator|=
name|reallocate_integer_array
argument_list|(
name|def
argument_list|,
name|current_max_dfas
argument_list|)
expr_stmt|;
name|dfasiz
operator|=
name|reallocate_integer_array
argument_list|(
name|dfasiz
argument_list|,
name|current_max_dfas
argument_list|)
expr_stmt|;
name|accsiz
operator|=
name|reallocate_integer_array
argument_list|(
name|accsiz
argument_list|,
name|current_max_dfas
argument_list|)
expr_stmt|;
name|dhash
operator|=
name|reallocate_integer_array
argument_list|(
name|dhash
argument_list|,
name|current_max_dfas
argument_list|)
expr_stmt|;
name|dss
operator|=
name|reallocate_int_ptr_array
argument_list|(
name|dss
argument_list|,
name|current_max_dfas
argument_list|)
expr_stmt|;
name|dfaacc
operator|=
name|reallocate_dfaacc_union
argument_list|(
name|dfaacc
argument_list|,
name|current_max_dfas
argument_list|)
expr_stmt|;
if|if
condition|(
name|nultrans
condition|)
name|nultrans
operator|=
name|reallocate_integer_array
argument_list|(
name|nultrans
argument_list|,
name|current_max_dfas
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ntod - convert an ndfa to a dfa  *  * Creates the dfa corresponding to the ndfa we've constructed.  The  * dfa starts out in state #1.  */
end_comment

begin_function
name|void
name|ntod
parameter_list|()
block|{
name|int
modifier|*
name|accset
decl_stmt|,
name|ds
decl_stmt|,
name|nacc
decl_stmt|,
name|newds
decl_stmt|;
name|int
name|sym
decl_stmt|,
name|hashval
decl_stmt|,
name|numstates
decl_stmt|,
name|dsize
decl_stmt|;
name|int
name|num_full_table_rows
decl_stmt|;
comment|/* used only for -f */
name|int
modifier|*
name|nset
decl_stmt|,
modifier|*
name|dset
decl_stmt|;
name|int
name|targptr
decl_stmt|,
name|totaltrans
decl_stmt|,
name|i
decl_stmt|,
name|comstate
decl_stmt|,
name|comfreq
decl_stmt|,
name|targ
decl_stmt|;
name|int
modifier|*
name|epsclosure
argument_list|()
decl_stmt|,
name|snstods
argument_list|()
decl_stmt|,
name|symlist
index|[
name|CSIZE
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|num_start_states
decl_stmt|;
name|int
name|todo_head
decl_stmt|,
name|todo_next
decl_stmt|;
comment|/* Note that the following are indexed by *equivalence classes* 	 * and not by characters.  Since equivalence classes are indexed 	 * beginning with 1, even if the scanner accepts NUL's, this 	 * means that (since every character is potentially in its own 	 * equivalence class) these arrays must have room for indices 	 * from 1 to CSIZE, so their size must be CSIZE + 1. 	 */
name|int
name|duplist
index|[
name|CSIZE
operator|+
literal|1
index|]
decl_stmt|,
name|state
index|[
name|CSIZE
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|targfreq
index|[
name|CSIZE
operator|+
literal|1
index|]
decl_stmt|,
name|targstate
index|[
name|CSIZE
operator|+
literal|1
index|]
decl_stmt|;
name|accset
operator|=
name|allocate_integer_array
argument_list|(
name|num_rules
operator|+
literal|1
argument_list|)
expr_stmt|;
name|nset
operator|=
name|allocate_integer_array
argument_list|(
name|current_max_dfa_size
argument_list|)
expr_stmt|;
comment|/* The "todo" queue is represented by the head, which is the DFA 	 * state currently being processed, and the "next", which is the 	 * next DFA state number available (not in use).  We depend on the 	 * fact that snstods() returns DFA's \in increasing order/, and thus 	 * need only know the bounds of the dfas to be processed. 	 */
name|todo_head
operator|=
name|todo_next
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|csize
condition|;
operator|++
name|i
control|)
block|{
name|duplist
index|[
name|i
index|]
operator|=
name|NIL
expr_stmt|;
name|symlist
index|[
name|i
index|]
operator|=
name|false
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|num_rules
condition|;
operator|++
name|i
control|)
name|accset
index|[
name|i
index|]
operator|=
name|NIL
expr_stmt|;
if|if
condition|(
name|trace
condition|)
block|{
name|dumpnfa
argument_list|(
name|scset
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\n\nDFA Dump:\n\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
name|inittbl
argument_list|()
expr_stmt|;
comment|/* Check to see whether we should build a separate table for 	 * transitions on NUL characters.  We don't do this for full-speed 	 * (-F) scanners, since for them we don't have a simple state 	 * number lying around with which to index the table.  We also 	 * don't bother doing it for scanners unless (1) NUL is in its own 	 * equivalence class (indicated by a positive value of 	 * ecgroup[NUL]), (2) NUL's equivalence class is the last 	 * equivalence class, and (3) the number of equivalence classes is 	 * the same as the number of characters.  This latter case comes 	 * about when useecs is false or when it's true but every character 	 * still manages to land in its own class (unlikely, but it's 	 * cheap to check for).  If all these things are true then the 	 * character code needed to represent NUL's equivalence class for 	 * indexing the tables is going to take one more bit than the 	 * number of characters, and therefore we won't be assured of 	 * being able to fit it into a YY_CHAR variable.  This rules out 	 * storing the transitions in a compressed table, since the code 	 * for interpreting them uses a YY_CHAR variable (perhaps it 	 * should just use an integer, though; this is worth pondering ... 	 * ###). 	 * 	 * Finally, for full tables, we want the number of entries in the 	 * table to be a power of two so the array references go fast (it 	 * will just take a shift to compute the major index).  If 	 * encoding NUL's transitions in the table will spoil this, we 	 * give it its own table (note that this will be the case if we're 	 * not using equivalence classes). 	 */
comment|/* Note that the test for ecgroup[0] == numecs below accomplishes 	 * both (1) and (2) above 	 */
if|if
condition|(
operator|!
name|fullspd
operator|&&
name|ecgroup
index|[
literal|0
index|]
operator|==
name|numecs
condition|)
block|{
comment|/* NUL is alone in its equivalence class, which is the 		 * last one. 		 */
name|int
name|use_NUL_table
init|=
operator|(
name|numecs
operator|==
name|csize
operator|)
decl_stmt|;
if|if
condition|(
name|fulltbl
operator|&&
operator|!
name|use_NUL_table
condition|)
block|{
comment|/* We still may want to use the table if numecs 			 * is a power of 2. 			 */
name|int
name|power_of_two
decl_stmt|;
for|for
control|(
name|power_of_two
operator|=
literal|1
init|;
name|power_of_two
operator|<=
name|csize
condition|;
name|power_of_two
operator|*=
literal|2
control|)
if|if
condition|(
name|numecs
operator|==
name|power_of_two
condition|)
block|{
name|use_NUL_table
operator|=
name|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|use_NUL_table
condition|)
name|nultrans
operator|=
name|allocate_integer_array
argument_list|(
name|current_max_dfas
argument_list|)
expr_stmt|;
comment|/* From now on, nultrans != nil indicates that we're 		 * saving null transitions for later, separate encoding. 		 */
block|}
if|if
condition|(
name|fullspd
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|numecs
condition|;
operator|++
name|i
control|)
name|state
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|place_state
argument_list|(
name|state
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dfaacc
index|[
name|i
index|]
operator|.
name|dfaacc_state
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fulltbl
condition|)
block|{
if|if
condition|(
name|nultrans
condition|)
comment|/* We won't be including NUL's transitions in the 			 * table, so build it for entries from 0 .. numecs - 1. 			 */
name|num_full_table_rows
operator|=
name|numecs
expr_stmt|;
else|else
comment|/* Take into account the fact that we'll be including 			 * the NUL entries in the transition table.  Build it 			 * from 0 .. numecs. 			 */
name|num_full_table_rows
operator|=
name|numecs
operator|+
literal|1
expr_stmt|;
comment|/* Unless -Ca, declare it "short" because it's a real 		 * long-shot that that won't be large enough. 		 */
name|printf
argument_list|(
literal|"static const %s yy_nxt[][%d] =\n    {\n"
argument_list|,
comment|/* '}' so vi doesn't get too confused */
name|long_align
condition|?
literal|"long"
else|:
literal|"short"
argument_list|,
name|num_full_table_rows
argument_list|)
expr_stmt|;
comment|/* Generate 0 entries for state #0. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_full_table_rows
condition|;
operator|++
name|i
control|)
name|mk2data
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Force ',' and dataflush() next call to mk2data().*/
name|datapos
operator|=
name|NUMDATAITEMS
expr_stmt|;
comment|/* Force extra blank line next dataflush(). */
name|dataline
operator|=
name|NUMDATALINES
expr_stmt|;
block|}
comment|/* Create the first states. */
name|num_start_states
operator|=
name|lastsc
operator|*
literal|2
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|num_start_states
condition|;
operator|++
name|i
control|)
block|{
name|numstates
operator|=
literal|1
expr_stmt|;
comment|/* For each start condition, make one state for the case when 		 * we're at the beginning of the line (the '^' operator) and 		 * one for the case when we're not. 		 */
if|if
condition|(
name|i
operator|%
literal|2
operator|==
literal|1
condition|)
name|nset
index|[
name|numstates
index|]
operator|=
name|scset
index|[
operator|(
name|i
operator|/
literal|2
operator|)
operator|+
literal|1
index|]
expr_stmt|;
else|else
name|nset
index|[
name|numstates
index|]
operator|=
name|mkbranch
argument_list|(
name|scbol
index|[
name|i
operator|/
literal|2
index|]
argument_list|,
name|scset
index|[
name|i
operator|/
literal|2
index|]
argument_list|)
expr_stmt|;
name|nset
operator|=
name|epsclosure
argument_list|(
name|nset
argument_list|,
operator|&
name|numstates
argument_list|,
name|accset
argument_list|,
operator|&
name|nacc
argument_list|,
operator|&
name|hashval
argument_list|)
expr_stmt|;
if|if
condition|(
name|snstods
argument_list|(
name|nset
argument_list|,
name|numstates
argument_list|,
name|accset
argument_list|,
name|nacc
argument_list|,
name|hashval
argument_list|,
operator|&
name|ds
argument_list|)
condition|)
block|{
name|numas
operator|+=
name|nacc
expr_stmt|;
name|totnst
operator|+=
name|numstates
expr_stmt|;
operator|++
name|todo_next
expr_stmt|;
if|if
condition|(
name|variable_trailing_context_rules
operator|&&
name|nacc
operator|>
literal|0
condition|)
name|check_trailing_context
argument_list|(
name|nset
argument_list|,
name|numstates
argument_list|,
name|accset
argument_list|,
name|nacc
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|fullspd
condition|)
block|{
if|if
condition|(
operator|!
name|snstods
argument_list|(
name|nset
argument_list|,
literal|0
argument_list|,
name|accset
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|end_of_buffer_state
argument_list|)
condition|)
name|flexfatal
argument_list|(
literal|"could not create unique end-of-buffer state"
argument_list|)
expr_stmt|;
operator|++
name|numas
expr_stmt|;
operator|++
name|num_start_states
expr_stmt|;
operator|++
name|todo_next
expr_stmt|;
block|}
while|while
condition|(
name|todo_head
operator|<
name|todo_next
condition|)
block|{
name|targptr
operator|=
literal|0
expr_stmt|;
name|totaltrans
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|numecs
condition|;
operator|++
name|i
control|)
name|state
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|ds
operator|=
operator|++
name|todo_head
expr_stmt|;
name|dset
operator|=
name|dss
index|[
name|ds
index|]
expr_stmt|;
name|dsize
operator|=
name|dfasiz
index|[
name|ds
index|]
expr_stmt|;
if|if
condition|(
name|trace
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"state # %d:\n"
argument_list|,
name|ds
argument_list|)
expr_stmt|;
name|sympartition
argument_list|(
name|dset
argument_list|,
name|dsize
argument_list|,
name|symlist
argument_list|,
name|duplist
argument_list|)
expr_stmt|;
for|for
control|(
name|sym
operator|=
literal|1
init|;
name|sym
operator|<=
name|numecs
condition|;
operator|++
name|sym
control|)
block|{
if|if
condition|(
name|symlist
index|[
name|sym
index|]
condition|)
block|{
name|symlist
index|[
name|sym
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|duplist
index|[
name|sym
index|]
operator|==
name|NIL
condition|)
block|{
comment|/* Symbol has unique out-transitions. */
name|numstates
operator|=
name|symfollowset
argument_list|(
name|dset
argument_list|,
name|dsize
argument_list|,
name|sym
argument_list|,
name|nset
argument_list|)
expr_stmt|;
name|nset
operator|=
name|epsclosure
argument_list|(
name|nset
argument_list|,
operator|&
name|numstates
argument_list|,
name|accset
argument_list|,
operator|&
name|nacc
argument_list|,
operator|&
name|hashval
argument_list|)
expr_stmt|;
if|if
condition|(
name|snstods
argument_list|(
name|nset
argument_list|,
name|numstates
argument_list|,
name|accset
argument_list|,
name|nacc
argument_list|,
name|hashval
argument_list|,
operator|&
name|newds
argument_list|)
condition|)
block|{
name|totnst
operator|=
name|totnst
operator|+
name|numstates
expr_stmt|;
operator|++
name|todo_next
expr_stmt|;
name|numas
operator|+=
name|nacc
expr_stmt|;
if|if
condition|(
name|variable_trailing_context_rules
operator|&&
name|nacc
operator|>
literal|0
condition|)
name|check_trailing_context
argument_list|(
name|nset
argument_list|,
name|numstates
argument_list|,
name|accset
argument_list|,
name|nacc
argument_list|)
expr_stmt|;
block|}
name|state
index|[
name|sym
index|]
operator|=
name|newds
expr_stmt|;
if|if
condition|(
name|trace
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t%d\t%d\n"
argument_list|,
name|sym
argument_list|,
name|newds
argument_list|)
expr_stmt|;
name|targfreq
index|[
operator|++
name|targptr
index|]
operator|=
literal|1
expr_stmt|;
name|targstate
index|[
name|targptr
index|]
operator|=
name|newds
expr_stmt|;
operator|++
name|numuniq
expr_stmt|;
block|}
else|else
block|{
comment|/* sym's equivalence class has the same 					 * transitions as duplist(sym)'s 					 * equivalence class. 					 */
name|targ
operator|=
name|state
index|[
name|duplist
index|[
name|sym
index|]
index|]
expr_stmt|;
name|state
index|[
name|sym
index|]
operator|=
name|targ
expr_stmt|;
if|if
condition|(
name|trace
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t%d\t%d\n"
argument_list|,
name|sym
argument_list|,
name|targ
argument_list|)
expr_stmt|;
comment|/* Update frequency count for 					 * destination state. 					 */
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|targstate
index|[
operator|++
name|i
index|]
operator|!=
name|targ
condition|)
empty_stmt|;
operator|++
name|targfreq
index|[
name|i
index|]
expr_stmt|;
operator|++
name|numdup
expr_stmt|;
block|}
operator|++
name|totaltrans
expr_stmt|;
name|duplist
index|[
name|sym
index|]
operator|=
name|NIL
expr_stmt|;
block|}
block|}
name|numsnpairs
operator|=
name|numsnpairs
operator|+
name|totaltrans
expr_stmt|;
if|if
condition|(
name|caseins
operator|&&
operator|!
name|useecs
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|'A'
operator|,
name|j
operator|=
literal|'a'
init|;
name|i
operator|<=
literal|'Z'
condition|;
operator|++
name|i
operator|,
operator|++
name|j
control|)
name|state
index|[
name|i
index|]
operator|=
name|state
index|[
name|j
index|]
expr_stmt|;
block|}
if|if
condition|(
name|ds
operator|>
name|num_start_states
condition|)
name|check_for_backing_up
argument_list|(
name|ds
argument_list|,
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|nultrans
condition|)
block|{
name|nultrans
index|[
name|ds
index|]
operator|=
name|state
index|[
name|NUL_ec
index|]
expr_stmt|;
name|state
index|[
name|NUL_ec
index|]
operator|=
literal|0
expr_stmt|;
comment|/* remove transition */
block|}
if|if
condition|(
name|fulltbl
condition|)
block|{
comment|/* Supply array's 0-element. */
if|if
condition|(
name|ds
operator|==
name|end_of_buffer_state
condition|)
name|mk2data
argument_list|(
operator|-
name|end_of_buffer_state
argument_list|)
expr_stmt|;
else|else
name|mk2data
argument_list|(
name|end_of_buffer_state
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|num_full_table_rows
condition|;
operator|++
name|i
control|)
comment|/* Jams are marked by negative of state 				 * number. 				 */
name|mk2data
argument_list|(
name|state
index|[
name|i
index|]
condition|?
name|state
index|[
name|i
index|]
else|:
operator|-
name|ds
argument_list|)
expr_stmt|;
comment|/* Force ',' and dataflush() next call to mk2data().*/
name|datapos
operator|=
name|NUMDATAITEMS
expr_stmt|;
comment|/* Force extra blank line next dataflush(). */
name|dataline
operator|=
name|NUMDATALINES
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fullspd
condition|)
name|place_state
argument_list|(
name|state
argument_list|,
name|ds
argument_list|,
name|totaltrans
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ds
operator|==
name|end_of_buffer_state
condition|)
comment|/* Special case this state to make sure it does what 			 * it's supposed to, i.e., jam on end-of-buffer. 			 */
name|stack1
argument_list|(
name|ds
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|JAMSTATE
argument_list|)
expr_stmt|;
else|else
comment|/* normal, compressed state */
block|{
comment|/* Determine which destination state is the most 			 * common, and how many transitions to it there are. 			 */
name|comfreq
operator|=
literal|0
expr_stmt|;
name|comstate
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|targptr
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|targfreq
index|[
name|i
index|]
operator|>
name|comfreq
condition|)
block|{
name|comfreq
operator|=
name|targfreq
index|[
name|i
index|]
expr_stmt|;
name|comstate
operator|=
name|targstate
index|[
name|i
index|]
expr_stmt|;
block|}
name|bldtbl
argument_list|(
name|state
argument_list|,
name|ds
argument_list|,
name|totaltrans
argument_list|,
name|comstate
argument_list|,
name|comfreq
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fulltbl
condition|)
name|dataend
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|fullspd
condition|)
block|{
name|cmptmps
argument_list|()
expr_stmt|;
comment|/* create compressed template entries */
comment|/* Create tables for all the states with only one 		 * out-transition. 		 */
while|while
condition|(
name|onesp
operator|>
literal|0
condition|)
block|{
name|mk1tbl
argument_list|(
name|onestate
index|[
name|onesp
index|]
argument_list|,
name|onesym
index|[
name|onesp
index|]
argument_list|,
name|onenext
index|[
name|onesp
index|]
argument_list|,
name|onedef
index|[
name|onesp
index|]
argument_list|)
expr_stmt|;
operator|--
name|onesp
expr_stmt|;
block|}
name|mkdeftbl
argument_list|()
expr_stmt|;
block|}
name|flex_free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|accset
argument_list|)
expr_stmt|;
name|flex_free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|nset
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* snstods - converts a set of ndfa states into a dfa state  *  * synopsis  *    is_new_state = snstods( int sns[numstates], int numstates,  *				int accset[num_rules+1], int nacc,  *				int hashval, int *newds_addr );  *  * On return, the dfa state number is in newds.  */
end_comment

begin_decl_stmt
name|int
name|snstods
argument_list|(
name|sns
argument_list|,
name|numstates
argument_list|,
name|accset
argument_list|,
name|nacc
argument_list|,
name|hashval
argument_list|,
name|newds_addr
argument_list|)
name|int
name|sns
index|[]
decl_stmt|,
name|numstates
decl_stmt|,
name|accset
index|[]
decl_stmt|,
name|nacc
decl_stmt|,
name|hashval
decl_stmt|,
modifier|*
name|newds_addr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|didsort
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|newds
decl_stmt|,
modifier|*
name|oldsns
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|lastdfa
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|hashval
operator|==
name|dhash
index|[
name|i
index|]
condition|)
block|{
if|if
condition|(
name|numstates
operator|==
name|dfasiz
index|[
name|i
index|]
condition|)
block|{
name|oldsns
operator|=
name|dss
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|didsort
condition|)
block|{
comment|/* We sort the states in sns so we 					 * can compare it to oldsns quickly. 					 * We use bubble because there probably 					 * aren't very many states. 					 */
name|bubble
argument_list|(
name|sns
argument_list|,
name|numstates
argument_list|)
expr_stmt|;
name|didsort
operator|=
literal|1
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<=
name|numstates
condition|;
operator|++
name|j
control|)
if|if
condition|(
name|sns
index|[
name|j
index|]
operator|!=
name|oldsns
index|[
name|j
index|]
condition|)
break|break;
if|if
condition|(
name|j
operator|>
name|numstates
condition|)
block|{
operator|++
name|dfaeql
expr_stmt|;
operator|*
name|newds_addr
operator|=
name|i
expr_stmt|;
return|return
literal|0
return|;
block|}
operator|++
name|hshcol
expr_stmt|;
block|}
else|else
operator|++
name|hshsave
expr_stmt|;
block|}
comment|/* Make a new dfa. */
if|if
condition|(
operator|++
name|lastdfa
operator|>=
name|current_max_dfas
condition|)
name|increase_max_dfas
argument_list|()
expr_stmt|;
name|newds
operator|=
name|lastdfa
expr_stmt|;
name|dss
index|[
name|newds
index|]
operator|=
name|allocate_integer_array
argument_list|(
name|numstates
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* If we haven't already sorted the states in sns, we do so now, 	 * so that future comparisons with it can be made quickly. 	 */
if|if
condition|(
operator|!
name|didsort
condition|)
name|bubble
argument_list|(
name|sns
argument_list|,
name|numstates
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|numstates
condition|;
operator|++
name|i
control|)
name|dss
index|[
name|newds
index|]
index|[
name|i
index|]
operator|=
name|sns
index|[
name|i
index|]
expr_stmt|;
name|dfasiz
index|[
name|newds
index|]
operator|=
name|numstates
expr_stmt|;
name|dhash
index|[
name|newds
index|]
operator|=
name|hashval
expr_stmt|;
if|if
condition|(
name|nacc
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|reject
condition|)
name|dfaacc
index|[
name|newds
index|]
operator|.
name|dfaacc_set
operator|=
operator|(
name|int
operator|*
operator|)
literal|0
expr_stmt|;
else|else
name|dfaacc
index|[
name|newds
index|]
operator|.
name|dfaacc_state
operator|=
literal|0
expr_stmt|;
name|accsiz
index|[
name|newds
index|]
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|reject
condition|)
block|{
comment|/* We sort the accepting set in increasing order so the 		 * disambiguating rule that the first rule listed is considered 		 * match in the event of ties will work.  We use a bubble 		 * sort since the list is probably quite small. 		 */
name|bubble
argument_list|(
name|accset
argument_list|,
name|nacc
argument_list|)
expr_stmt|;
name|dfaacc
index|[
name|newds
index|]
operator|.
name|dfaacc_set
operator|=
name|allocate_integer_array
argument_list|(
name|nacc
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Save the accepting set for later */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|nacc
condition|;
operator|++
name|i
control|)
block|{
name|dfaacc
index|[
name|newds
index|]
operator|.
name|dfaacc_set
index|[
name|i
index|]
operator|=
name|accset
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|accset
index|[
name|i
index|]
operator|<=
name|num_rules
condition|)
comment|/* Who knows, perhaps a REJECT can yield 				 * this rule. 				 */
name|rule_useful
index|[
name|accset
index|[
name|i
index|]
index|]
operator|=
name|true
expr_stmt|;
block|}
name|accsiz
index|[
name|newds
index|]
operator|=
name|nacc
expr_stmt|;
block|}
else|else
block|{
comment|/* Find lowest numbered rule so the disambiguating rule 		 * will work. 		 */
name|j
operator|=
name|num_rules
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|nacc
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|accset
index|[
name|i
index|]
operator|<
name|j
condition|)
name|j
operator|=
name|accset
index|[
name|i
index|]
expr_stmt|;
name|dfaacc
index|[
name|newds
index|]
operator|.
name|dfaacc_state
operator|=
name|j
expr_stmt|;
if|if
condition|(
name|j
operator|<=
name|num_rules
condition|)
name|rule_useful
index|[
name|j
index|]
operator|=
name|true
expr_stmt|;
block|}
operator|*
name|newds_addr
operator|=
name|newds
expr_stmt|;
return|return
literal|1
return|;
block|}
end_block

begin_comment
comment|/* symfollowset - follow the symbol transitions one step  *  * synopsis  *    numstates = symfollowset( int ds[current_max_dfa_size], int dsize,  *				int transsym, int nset[current_max_dfa_size] );  */
end_comment

begin_decl_stmt
name|int
name|symfollowset
argument_list|(
name|ds
argument_list|,
name|dsize
argument_list|,
name|transsym
argument_list|,
name|nset
argument_list|)
name|int
name|ds
index|[]
decl_stmt|,
name|dsize
decl_stmt|,
name|transsym
decl_stmt|,
name|nset
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|ns
decl_stmt|,
name|tsp
decl_stmt|,
name|sym
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|,
name|lenccl
decl_stmt|,
name|ch
decl_stmt|,
name|numstates
decl_stmt|,
name|ccllist
decl_stmt|;
name|numstates
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|dsize
condition|;
operator|++
name|i
control|)
block|{
comment|/* for each nfa state ns in the state set of ds */
name|ns
operator|=
name|ds
index|[
name|i
index|]
expr_stmt|;
name|sym
operator|=
name|transchar
index|[
name|ns
index|]
expr_stmt|;
name|tsp
operator|=
name|trans1
index|[
name|ns
index|]
expr_stmt|;
if|if
condition|(
name|sym
operator|<
literal|0
condition|)
block|{
comment|/* it's a character class */
name|sym
operator|=
operator|-
name|sym
expr_stmt|;
name|ccllist
operator|=
name|cclmap
index|[
name|sym
index|]
expr_stmt|;
name|lenccl
operator|=
name|ccllen
index|[
name|sym
index|]
expr_stmt|;
if|if
condition|(
name|cclng
index|[
name|sym
index|]
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|lenccl
condition|;
operator|++
name|j
control|)
block|{
comment|/* Loop through negated character 					 * class. 					 */
name|ch
operator|=
name|ccltbl
index|[
name|ccllist
operator|+
name|j
index|]
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|0
condition|)
name|ch
operator|=
name|NUL_ec
expr_stmt|;
if|if
condition|(
name|ch
operator|>
name|transsym
condition|)
comment|/* Transsym isn't in negated 						 * ccl. 						 */
break|break;
elseif|else
if|if
condition|(
name|ch
operator|==
name|transsym
condition|)
comment|/* next 2 */
goto|goto
name|bottom
goto|;
block|}
comment|/* Didn't find transsym in ccl. */
name|nset
index|[
operator|++
name|numstates
index|]
operator|=
name|tsp
expr_stmt|;
block|}
else|else
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|lenccl
condition|;
operator|++
name|j
control|)
block|{
name|ch
operator|=
name|ccltbl
index|[
name|ccllist
operator|+
name|j
index|]
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|0
condition|)
name|ch
operator|=
name|NUL_ec
expr_stmt|;
if|if
condition|(
name|ch
operator|>
name|transsym
condition|)
break|break;
elseif|else
if|if
condition|(
name|ch
operator|==
name|transsym
condition|)
block|{
name|nset
index|[
operator|++
name|numstates
index|]
operator|=
name|tsp
expr_stmt|;
break|break;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|sym
operator|>=
literal|'A'
operator|&&
name|sym
operator|<=
literal|'Z'
operator|&&
name|caseins
condition|)
name|flexfatal
argument_list|(
literal|"consistency check failed in symfollowset"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sym
operator|==
name|SYM_EPSILON
condition|)
block|{
comment|/* do nothing */
block|}
elseif|else
if|if
condition|(
name|ABS
argument_list|(
name|ecgroup
index|[
name|sym
index|]
argument_list|)
operator|==
name|transsym
condition|)
name|nset
index|[
operator|++
name|numstates
index|]
operator|=
name|tsp
expr_stmt|;
name|bottom
label|:
empty_stmt|;
block|}
return|return
name|numstates
return|;
block|}
end_block

begin_comment
comment|/* sympartition - partition characters with same out-transitions  *  * synopsis  *    sympartition( int ds[current_max_dfa_size], int numstates,  *			int symlist[numecs], int duplist[numecs] );  */
end_comment

begin_decl_stmt
name|void
name|sympartition
argument_list|(
name|ds
argument_list|,
name|numstates
argument_list|,
name|symlist
argument_list|,
name|duplist
argument_list|)
name|int
name|ds
index|[]
decl_stmt|,
name|numstates
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|symlist
index|[]
decl_stmt|,
name|duplist
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|tch
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|ns
decl_stmt|,
name|dupfwd
index|[
name|CSIZE
operator|+
literal|1
index|]
decl_stmt|,
name|lenccl
decl_stmt|,
name|cclp
decl_stmt|,
name|ich
decl_stmt|;
comment|/* Partitioning is done by creating equivalence classes for those 	 * characters which have out-transitions from the given state.  Thus 	 * we are really creating equivalence classes of equivalence classes. 	 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|numecs
condition|;
operator|++
name|i
control|)
block|{
comment|/* initialize equivalence class list */
name|duplist
index|[
name|i
index|]
operator|=
name|i
operator|-
literal|1
expr_stmt|;
name|dupfwd
index|[
name|i
index|]
operator|=
name|i
operator|+
literal|1
expr_stmt|;
block|}
name|duplist
index|[
literal|1
index|]
operator|=
name|NIL
expr_stmt|;
name|dupfwd
index|[
name|numecs
index|]
operator|=
name|NIL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|numstates
condition|;
operator|++
name|i
control|)
block|{
name|ns
operator|=
name|ds
index|[
name|i
index|]
expr_stmt|;
name|tch
operator|=
name|transchar
index|[
name|ns
index|]
expr_stmt|;
if|if
condition|(
name|tch
operator|!=
name|SYM_EPSILON
condition|)
block|{
if|if
condition|(
name|tch
operator|<
operator|-
name|lastccl
operator|||
name|tch
operator|>=
name|csize
condition|)
block|{
name|flexfatal
argument_list|(
literal|"bad transition character detected in sympartition()"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tch
operator|>=
literal|0
condition|)
block|{
comment|/* character transition */
name|int
name|ec
init|=
name|ecgroup
index|[
name|tch
index|]
decl_stmt|;
name|mkechar
argument_list|(
name|ec
argument_list|,
name|dupfwd
argument_list|,
name|duplist
argument_list|)
expr_stmt|;
name|symlist
index|[
name|ec
index|]
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* character class */
name|tch
operator|=
operator|-
name|tch
expr_stmt|;
name|lenccl
operator|=
name|ccllen
index|[
name|tch
index|]
expr_stmt|;
name|cclp
operator|=
name|cclmap
index|[
name|tch
index|]
expr_stmt|;
name|mkeccl
argument_list|(
name|ccltbl
operator|+
name|cclp
argument_list|,
name|lenccl
argument_list|,
name|dupfwd
argument_list|,
name|duplist
argument_list|,
name|numecs
argument_list|,
name|NUL_ec
argument_list|)
expr_stmt|;
if|if
condition|(
name|cclng
index|[
name|tch
index|]
condition|)
block|{
name|j
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|lenccl
condition|;
operator|++
name|k
control|)
block|{
name|ich
operator|=
name|ccltbl
index|[
name|cclp
operator|+
name|k
index|]
expr_stmt|;
if|if
condition|(
name|ich
operator|==
literal|0
condition|)
name|ich
operator|=
name|NUL_ec
expr_stmt|;
for|for
control|(
operator|++
name|j
init|;
name|j
operator|<
name|ich
condition|;
operator|++
name|j
control|)
name|symlist
index|[
name|j
index|]
operator|=
literal|1
expr_stmt|;
block|}
for|for
control|(
operator|++
name|j
init|;
name|j
operator|<=
name|numecs
condition|;
operator|++
name|j
control|)
name|symlist
index|[
name|j
index|]
operator|=
literal|1
expr_stmt|;
block|}
else|else
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|lenccl
condition|;
operator|++
name|k
control|)
block|{
name|ich
operator|=
name|ccltbl
index|[
name|cclp
operator|+
name|k
index|]
expr_stmt|;
if|if
condition|(
name|ich
operator|==
literal|0
condition|)
name|ich
operator|=
name|NUL_ec
expr_stmt|;
name|symlist
index|[
name|ich
index|]
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_block

end_unit

