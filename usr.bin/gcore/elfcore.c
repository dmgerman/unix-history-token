begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1998 John D. Polstra  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/procfs.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/linker_set.h>
end_include

begin_include
include|#
directive|include
file|<machine/elf.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"extern.h"
end_include

begin_comment
comment|/*  * Code for generating ELF core dumps.  */
end_comment

begin_typedef
typedef|typedef
name|void
function_decl|(
modifier|*
name|segment_callback
function_decl|)
parameter_list|(
name|vm_map_entry_t
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_typedef

begin_comment
comment|/* Closure for cb_put_phdr(). */
end_comment

begin_struct
struct|struct
name|phdr_closure
block|{
name|Elf_Phdr
modifier|*
name|phdr
decl_stmt|;
comment|/* Program header to fill in */
name|Elf_Off
name|offset
decl_stmt|;
comment|/* Offset of segment in core file */
block|}
struct|;
end_struct

begin_comment
comment|/* Closure for cb_size_segment(). */
end_comment

begin_struct
struct|struct
name|sseg_closure
block|{
name|int
name|count
decl_stmt|;
comment|/* Count of writable segments. */
name|size_t
name|size
decl_stmt|;
comment|/* Total size of all writable segments. */
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|void
name|cb_put_phdr
parameter_list|(
name|vm_map_entry_t
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cb_size_segment
parameter_list|(
name|vm_map_entry_t
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|each_writable_segment
parameter_list|(
name|vm_map_entry_t
parameter_list|,
name|segment_callback
parameter_list|,
name|void
modifier|*
name|closure
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|elf_corehdr
parameter_list|(
name|int
name|fd
parameter_list|,
name|pid_t
parameter_list|,
name|vm_map_entry_t
parameter_list|,
name|int
name|numsegs
parameter_list|,
name|void
modifier|*
name|hdr
parameter_list|,
name|size_t
name|hdrsize
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|elf_puthdr
parameter_list|(
name|vm_map_entry_t
parameter_list|,
name|void
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|,
specifier|const
name|prstatus_t
modifier|*
parameter_list|,
specifier|const
name|prfpregset_t
modifier|*
parameter_list|,
specifier|const
name|prpsinfo_t
modifier|*
parameter_list|,
name|int
name|numsegs
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|elf_putnote
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
modifier|*
name|off
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|type
parameter_list|,
specifier|const
name|void
modifier|*
name|desc
parameter_list|,
name|size_t
name|descsz
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|freemap
parameter_list|(
name|vm_map_entry_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|readhdrinfo
parameter_list|(
name|pid_t
parameter_list|,
name|prstatus_t
modifier|*
parameter_list|,
name|prfpregset_t
modifier|*
parameter_list|,
name|prpsinfo_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|vm_map_entry_t
name|readmap
parameter_list|(
name|pid_t
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|elf_ident
parameter_list|(
name|int
name|efd
parameter_list|,
name|pid_t
name|pid
name|__unused
parameter_list|,
name|char
modifier|*
name|binfile
name|__unused
parameter_list|)
block|{
name|Elf_Ehdr
name|hdr
decl_stmt|;
name|int
name|cnt
decl_stmt|;
name|cnt
operator|=
name|read
argument_list|(
name|efd
argument_list|,
operator|&
name|hdr
argument_list|,
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnt
operator|!=
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|IS_ELF
argument_list|(
name|hdr
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Write an ELF coredump for the given pid to the given fd.  */
end_comment

begin_function
specifier|static
name|void
name|elf_coredump
parameter_list|(
name|int
name|efd
name|__unused
parameter_list|,
name|int
name|fd
parameter_list|,
name|pid_t
name|pid
parameter_list|)
block|{
name|vm_map_entry_t
name|map
decl_stmt|;
name|struct
name|sseg_closure
name|seginfo
decl_stmt|;
name|void
modifier|*
name|hdr
decl_stmt|;
name|size_t
name|hdrsize
decl_stmt|;
name|char
name|memname
index|[
literal|64
index|]
decl_stmt|;
name|int
name|memfd
decl_stmt|;
name|Elf_Phdr
modifier|*
name|php
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Get the program's memory map. */
name|map
operator|=
name|readmap
argument_list|(
name|pid
argument_list|)
expr_stmt|;
comment|/* Size the program segments. */
name|seginfo
operator|.
name|count
operator|=
literal|0
expr_stmt|;
name|seginfo
operator|.
name|size
operator|=
literal|0
expr_stmt|;
name|each_writable_segment
argument_list|(
name|map
argument_list|,
name|cb_size_segment
argument_list|,
operator|&
name|seginfo
argument_list|)
expr_stmt|;
comment|/* 	 * Calculate the size of the core file header area by making 	 * a dry run of generating it.  Nothing is written, but the 	 * size is calculated. 	 */
name|hdrsize
operator|=
literal|0
expr_stmt|;
name|elf_puthdr
argument_list|(
name|map
argument_list|,
operator|(
name|void
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|hdrsize
argument_list|,
operator|(
specifier|const
name|prstatus_t
operator|*
operator|)
name|NULL
argument_list|,
operator|(
specifier|const
name|prfpregset_t
operator|*
operator|)
name|NULL
argument_list|,
operator|(
specifier|const
name|prpsinfo_t
operator|*
operator|)
name|NULL
argument_list|,
name|seginfo
operator|.
name|count
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate memory for building the header, fill it up, 	 * and write it out. 	 */
name|hdr
operator|=
name|malloc
argument_list|(
name|hdrsize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|hdr
operator|=
name|malloc
argument_list|(
name|hdrsize
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
name|elf_corehdr
argument_list|(
name|fd
argument_list|,
name|pid
argument_list|,
name|map
argument_list|,
name|seginfo
operator|.
name|count
argument_list|,
name|hdr
argument_list|,
name|hdrsize
argument_list|)
expr_stmt|;
comment|/* Write the contents of all of the writable segments. */
name|snprintf
argument_list|(
name|memname
argument_list|,
sizeof|sizeof
name|memname
argument_list|,
literal|"/proc/%d/mem"
argument_list|,
name|pid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|memfd
operator|=
name|open
argument_list|(
name|memname
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"cannot open %s"
argument_list|,
name|memname
argument_list|)
expr_stmt|;
name|php
operator|=
operator|(
name|Elf_Phdr
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|hdr
operator|+
sizeof|sizeof
argument_list|(
name|Elf_Ehdr
argument_list|)
operator|)
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|seginfo
operator|.
name|count
condition|;
name|i
operator|++
control|)
block|{
name|uintmax_t
name|nleft
init|=
name|php
operator|->
name|p_filesz
decl_stmt|;
name|lseek
argument_list|(
name|memfd
argument_list|,
operator|(
name|off_t
operator|)
name|php
operator|->
name|p_vaddr
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
while|while
condition|(
name|nleft
operator|>
literal|0
condition|)
block|{
name|char
name|buf
index|[
literal|8
operator|*
literal|1024
index|]
decl_stmt|;
name|size_t
name|nwant
decl_stmt|;
name|ssize_t
name|ngot
decl_stmt|;
if|if
condition|(
name|nleft
operator|>
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
condition|)
name|nwant
operator|=
sizeof|sizeof
name|buf
expr_stmt|;
else|else
name|nwant
operator|=
name|nleft
expr_stmt|;
name|ngot
operator|=
name|read
argument_list|(
name|memfd
argument_list|,
name|buf
argument_list|,
name|nwant
argument_list|)
expr_stmt|;
if|if
condition|(
name|ngot
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"read from %s"
argument_list|,
name|memname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|size_t
operator|)
name|ngot
operator|<
name|nwant
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"short read from %s:"
literal|" wanted %d, got %d"
argument_list|,
name|memname
argument_list|,
name|nwant
argument_list|,
name|ngot
argument_list|)
expr_stmt|;
name|ngot
operator|=
name|write
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
name|nwant
argument_list|)
expr_stmt|;
if|if
condition|(
name|ngot
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"write of segment %d failed"
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|size_t
operator|)
name|ngot
operator|!=
name|nwant
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"short write"
argument_list|)
expr_stmt|;
name|nleft
operator|-=
name|nwant
expr_stmt|;
block|}
name|php
operator|++
expr_stmt|;
block|}
name|close
argument_list|(
name|memfd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|hdr
argument_list|)
expr_stmt|;
name|freemap
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * A callback for each_writable_segment() to write out the segment's  * program header entry.  */
end_comment

begin_function
specifier|static
name|void
name|cb_put_phdr
parameter_list|(
name|vm_map_entry_t
name|entry
parameter_list|,
name|void
modifier|*
name|closure
parameter_list|)
block|{
name|struct
name|phdr_closure
modifier|*
name|phc
init|=
operator|(
expr|struct
name|phdr_closure
operator|*
operator|)
name|closure
decl_stmt|;
name|Elf_Phdr
modifier|*
name|phdr
init|=
name|phc
operator|->
name|phdr
decl_stmt|;
name|phc
operator|->
name|offset
operator|=
name|round_page
argument_list|(
name|phc
operator|->
name|offset
argument_list|)
expr_stmt|;
name|phdr
operator|->
name|p_type
operator|=
name|PT_LOAD
expr_stmt|;
name|phdr
operator|->
name|p_offset
operator|=
name|phc
operator|->
name|offset
expr_stmt|;
name|phdr
operator|->
name|p_vaddr
operator|=
name|entry
operator|->
name|start
expr_stmt|;
name|phdr
operator|->
name|p_paddr
operator|=
literal|0
expr_stmt|;
name|phdr
operator|->
name|p_filesz
operator|=
name|phdr
operator|->
name|p_memsz
operator|=
name|entry
operator|->
name|end
operator|-
name|entry
operator|->
name|start
expr_stmt|;
name|phdr
operator|->
name|p_align
operator|=
name|PAGE_SIZE
expr_stmt|;
name|phdr
operator|->
name|p_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|protection
operator|&
name|VM_PROT_READ
condition|)
name|phdr
operator|->
name|p_flags
operator||=
name|PF_R
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|protection
operator|&
name|VM_PROT_WRITE
condition|)
name|phdr
operator|->
name|p_flags
operator||=
name|PF_W
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|protection
operator|&
name|VM_PROT_EXECUTE
condition|)
name|phdr
operator|->
name|p_flags
operator||=
name|PF_X
expr_stmt|;
name|phc
operator|->
name|offset
operator|+=
name|phdr
operator|->
name|p_filesz
expr_stmt|;
name|phc
operator|->
name|phdr
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * A callback for each_writable_segment() to gather information about  * the number of segments and their total size.  */
end_comment

begin_function
specifier|static
name|void
name|cb_size_segment
parameter_list|(
name|vm_map_entry_t
name|entry
parameter_list|,
name|void
modifier|*
name|closure
parameter_list|)
block|{
name|struct
name|sseg_closure
modifier|*
name|ssc
init|=
operator|(
expr|struct
name|sseg_closure
operator|*
operator|)
name|closure
decl_stmt|;
name|ssc
operator|->
name|count
operator|++
expr_stmt|;
name|ssc
operator|->
name|size
operator|+=
name|entry
operator|->
name|end
operator|-
name|entry
operator|->
name|start
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * For each segment in the given memory map, call the given function  * with a pointer to the map entry and some arbitrary caller-supplied  * data.  */
end_comment

begin_function
specifier|static
name|void
name|each_writable_segment
parameter_list|(
name|vm_map_entry_t
name|map
parameter_list|,
name|segment_callback
name|func
parameter_list|,
name|void
modifier|*
name|closure
parameter_list|)
block|{
name|vm_map_entry_t
name|entry
decl_stmt|;
for|for
control|(
name|entry
operator|=
name|map
init|;
name|entry
operator|!=
name|NULL
condition|;
name|entry
operator|=
name|entry
operator|->
name|next
control|)
call|(
modifier|*
name|func
call|)
argument_list|(
name|entry
argument_list|,
name|closure
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Write the core file header to the file, including padding up to  * the page boundary.  */
end_comment

begin_function
specifier|static
name|void
name|elf_corehdr
parameter_list|(
name|int
name|fd
parameter_list|,
name|pid_t
name|pid
parameter_list|,
name|vm_map_entry_t
name|map
parameter_list|,
name|int
name|numsegs
parameter_list|,
name|void
modifier|*
name|hdr
parameter_list|,
name|size_t
name|hdrsize
parameter_list|)
block|{
name|size_t
name|off
decl_stmt|;
name|prstatus_t
name|status
decl_stmt|;
name|prfpregset_t
name|fpregset
decl_stmt|;
name|prpsinfo_t
name|psinfo
decl_stmt|;
comment|/* Gather the information for the header. */
name|readhdrinfo
argument_list|(
name|pid
argument_list|,
operator|&
name|status
argument_list|,
operator|&
name|fpregset
argument_list|,
operator|&
name|psinfo
argument_list|)
expr_stmt|;
comment|/* Fill in the header. */
name|memset
argument_list|(
name|hdr
argument_list|,
literal|0
argument_list|,
name|hdrsize
argument_list|)
expr_stmt|;
name|off
operator|=
literal|0
expr_stmt|;
name|elf_puthdr
argument_list|(
name|map
argument_list|,
name|hdr
argument_list|,
operator|&
name|off
argument_list|,
operator|&
name|status
argument_list|,
operator|&
name|fpregset
argument_list|,
operator|&
name|psinfo
argument_list|,
name|numsegs
argument_list|)
expr_stmt|;
comment|/* Write it to the core file. */
if|if
condition|(
name|write
argument_list|(
name|fd
argument_list|,
name|hdr
argument_list|,
name|hdrsize
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"write"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Generate the ELF coredump header into the buffer at "dst".  "dst" may  * be NULL, in which case the header is sized but not actually generated.  */
end_comment

begin_function
specifier|static
name|void
name|elf_puthdr
parameter_list|(
name|vm_map_entry_t
name|map
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
modifier|*
name|off
parameter_list|,
specifier|const
name|prstatus_t
modifier|*
name|status
parameter_list|,
specifier|const
name|prfpregset_t
modifier|*
name|fpregset
parameter_list|,
specifier|const
name|prpsinfo_t
modifier|*
name|psinfo
parameter_list|,
name|int
name|numsegs
parameter_list|)
block|{
name|size_t
name|ehoff
decl_stmt|;
name|size_t
name|phoff
decl_stmt|;
name|size_t
name|noteoff
decl_stmt|;
name|size_t
name|notesz
decl_stmt|;
name|ehoff
operator|=
operator|*
name|off
expr_stmt|;
operator|*
name|off
operator|+=
sizeof|sizeof
argument_list|(
name|Elf_Ehdr
argument_list|)
expr_stmt|;
name|phoff
operator|=
operator|*
name|off
expr_stmt|;
operator|*
name|off
operator|+=
operator|(
name|numsegs
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|Elf_Phdr
argument_list|)
expr_stmt|;
name|noteoff
operator|=
operator|*
name|off
expr_stmt|;
name|elf_putnote
argument_list|(
name|dst
argument_list|,
name|off
argument_list|,
literal|"FreeBSD"
argument_list|,
name|NT_PRSTATUS
argument_list|,
name|status
argument_list|,
sizeof|sizeof
expr|*
name|status
argument_list|)
expr_stmt|;
name|elf_putnote
argument_list|(
name|dst
argument_list|,
name|off
argument_list|,
literal|"FreeBSD"
argument_list|,
name|NT_FPREGSET
argument_list|,
name|fpregset
argument_list|,
sizeof|sizeof
expr|*
name|fpregset
argument_list|)
expr_stmt|;
name|elf_putnote
argument_list|(
name|dst
argument_list|,
name|off
argument_list|,
literal|"FreeBSD"
argument_list|,
name|NT_PRPSINFO
argument_list|,
name|psinfo
argument_list|,
sizeof|sizeof
expr|*
name|psinfo
argument_list|)
expr_stmt|;
name|notesz
operator|=
operator|*
name|off
operator|-
name|noteoff
expr_stmt|;
comment|/* Align up to a page boundary for the program segments. */
operator|*
name|off
operator|=
name|round_page
argument_list|(
operator|*
name|off
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst
operator|!=
name|NULL
condition|)
block|{
name|Elf_Ehdr
modifier|*
name|ehdr
decl_stmt|;
name|Elf_Phdr
modifier|*
name|phdr
decl_stmt|;
name|struct
name|phdr_closure
name|phc
decl_stmt|;
comment|/* 		 * Fill in the ELF header. 		 */
name|ehdr
operator|=
operator|(
name|Elf_Ehdr
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|dst
operator|+
name|ehoff
operator|)
expr_stmt|;
name|ehdr
operator|->
name|e_ident
index|[
name|EI_MAG0
index|]
operator|=
name|ELFMAG0
expr_stmt|;
name|ehdr
operator|->
name|e_ident
index|[
name|EI_MAG1
index|]
operator|=
name|ELFMAG1
expr_stmt|;
name|ehdr
operator|->
name|e_ident
index|[
name|EI_MAG2
index|]
operator|=
name|ELFMAG2
expr_stmt|;
name|ehdr
operator|->
name|e_ident
index|[
name|EI_MAG3
index|]
operator|=
name|ELFMAG3
expr_stmt|;
name|ehdr
operator|->
name|e_ident
index|[
name|EI_CLASS
index|]
operator|=
name|ELF_CLASS
expr_stmt|;
name|ehdr
operator|->
name|e_ident
index|[
name|EI_DATA
index|]
operator|=
name|ELF_DATA
expr_stmt|;
name|ehdr
operator|->
name|e_ident
index|[
name|EI_VERSION
index|]
operator|=
name|EV_CURRENT
expr_stmt|;
name|ehdr
operator|->
name|e_ident
index|[
name|EI_OSABI
index|]
operator|=
name|ELFOSABI_FREEBSD
expr_stmt|;
name|ehdr
operator|->
name|e_ident
index|[
name|EI_ABIVERSION
index|]
operator|=
literal|0
expr_stmt|;
name|ehdr
operator|->
name|e_ident
index|[
name|EI_PAD
index|]
operator|=
literal|0
expr_stmt|;
name|ehdr
operator|->
name|e_type
operator|=
name|ET_CORE
expr_stmt|;
name|ehdr
operator|->
name|e_machine
operator|=
name|ELF_ARCH
expr_stmt|;
name|ehdr
operator|->
name|e_version
operator|=
name|EV_CURRENT
expr_stmt|;
name|ehdr
operator|->
name|e_entry
operator|=
literal|0
expr_stmt|;
name|ehdr
operator|->
name|e_phoff
operator|=
name|phoff
expr_stmt|;
name|ehdr
operator|->
name|e_flags
operator|=
literal|0
expr_stmt|;
name|ehdr
operator|->
name|e_ehsize
operator|=
sizeof|sizeof
argument_list|(
name|Elf_Ehdr
argument_list|)
expr_stmt|;
name|ehdr
operator|->
name|e_phentsize
operator|=
sizeof|sizeof
argument_list|(
name|Elf_Phdr
argument_list|)
expr_stmt|;
name|ehdr
operator|->
name|e_phnum
operator|=
name|numsegs
operator|+
literal|1
expr_stmt|;
name|ehdr
operator|->
name|e_shentsize
operator|=
sizeof|sizeof
argument_list|(
name|Elf_Shdr
argument_list|)
expr_stmt|;
name|ehdr
operator|->
name|e_shnum
operator|=
literal|0
expr_stmt|;
name|ehdr
operator|->
name|e_shstrndx
operator|=
name|SHN_UNDEF
expr_stmt|;
comment|/* 		 * Fill in the program header entries. 		 */
name|phdr
operator|=
operator|(
name|Elf_Phdr
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|dst
operator|+
name|phoff
operator|)
expr_stmt|;
comment|/* The note segment. */
name|phdr
operator|->
name|p_type
operator|=
name|PT_NOTE
expr_stmt|;
name|phdr
operator|->
name|p_offset
operator|=
name|noteoff
expr_stmt|;
name|phdr
operator|->
name|p_vaddr
operator|=
literal|0
expr_stmt|;
name|phdr
operator|->
name|p_paddr
operator|=
literal|0
expr_stmt|;
name|phdr
operator|->
name|p_filesz
operator|=
name|notesz
expr_stmt|;
name|phdr
operator|->
name|p_memsz
operator|=
literal|0
expr_stmt|;
name|phdr
operator|->
name|p_flags
operator|=
literal|0
expr_stmt|;
name|phdr
operator|->
name|p_align
operator|=
literal|0
expr_stmt|;
name|phdr
operator|++
expr_stmt|;
comment|/* All the writable segments from the program. */
name|phc
operator|.
name|phdr
operator|=
name|phdr
expr_stmt|;
name|phc
operator|.
name|offset
operator|=
operator|*
name|off
expr_stmt|;
name|each_writable_segment
argument_list|(
name|map
argument_list|,
name|cb_put_phdr
argument_list|,
operator|&
name|phc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Emit one note section to "dst", or just size it if "dst" is NULL.  */
end_comment

begin_function
specifier|static
name|void
name|elf_putnote
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
modifier|*
name|off
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|type
parameter_list|,
specifier|const
name|void
modifier|*
name|desc
parameter_list|,
name|size_t
name|descsz
parameter_list|)
block|{
name|Elf_Note
name|note
decl_stmt|;
name|note
operator|.
name|n_namesz
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
expr_stmt|;
name|note
operator|.
name|n_descsz
operator|=
name|descsz
expr_stmt|;
name|note
operator|.
name|n_type
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|dst
operator|!=
name|NULL
condition|)
name|bcopy
argument_list|(
operator|&
name|note
argument_list|,
operator|(
name|char
operator|*
operator|)
name|dst
operator|+
operator|*
name|off
argument_list|,
sizeof|sizeof
name|note
argument_list|)
expr_stmt|;
operator|*
name|off
operator|+=
sizeof|sizeof
name|note
expr_stmt|;
if|if
condition|(
name|dst
operator|!=
name|NULL
condition|)
name|bcopy
argument_list|(
name|name
argument_list|,
operator|(
name|char
operator|*
operator|)
name|dst
operator|+
operator|*
name|off
argument_list|,
name|note
operator|.
name|n_namesz
argument_list|)
expr_stmt|;
operator|*
name|off
operator|+=
name|roundup2
argument_list|(
name|note
operator|.
name|n_namesz
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf_Size
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst
operator|!=
name|NULL
condition|)
name|bcopy
argument_list|(
name|desc
argument_list|,
operator|(
name|char
operator|*
operator|)
name|dst
operator|+
operator|*
name|off
argument_list|,
name|note
operator|.
name|n_descsz
argument_list|)
expr_stmt|;
operator|*
name|off
operator|+=
name|roundup2
argument_list|(
name|note
operator|.
name|n_descsz
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf_Size
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Free the memory map.  */
end_comment

begin_function
specifier|static
name|void
name|freemap
parameter_list|(
name|vm_map_entry_t
name|map
parameter_list|)
block|{
while|while
condition|(
name|map
operator|!=
name|NULL
condition|)
block|{
name|vm_map_entry_t
name|next
init|=
name|map
operator|->
name|next
decl_stmt|;
name|free
argument_list|(
name|map
argument_list|)
expr_stmt|;
name|map
operator|=
name|next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Read the process information necessary to fill in the core file's header.  */
end_comment

begin_function
specifier|static
name|void
name|readhdrinfo
parameter_list|(
name|pid_t
name|pid
parameter_list|,
name|prstatus_t
modifier|*
name|status
parameter_list|,
name|prfpregset_t
modifier|*
name|fpregset
parameter_list|,
name|prpsinfo_t
modifier|*
name|psinfo
parameter_list|)
block|{
name|char
name|name
index|[
literal|64
index|]
decl_stmt|;
name|char
name|line
index|[
literal|256
index|]
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|n
decl_stmt|;
name|memset
argument_list|(
name|status
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|status
argument_list|)
expr_stmt|;
name|status
operator|->
name|pr_version
operator|=
name|PRSTATUS_VERSION
expr_stmt|;
name|status
operator|->
name|pr_statussz
operator|=
sizeof|sizeof
argument_list|(
name|prstatus_t
argument_list|)
expr_stmt|;
name|status
operator|->
name|pr_gregsetsz
operator|=
sizeof|sizeof
argument_list|(
name|gregset_t
argument_list|)
expr_stmt|;
name|status
operator|->
name|pr_fpregsetsz
operator|=
sizeof|sizeof
argument_list|(
name|fpregset_t
argument_list|)
expr_stmt|;
name|status
operator|->
name|pr_osreldate
operator|=
name|__FreeBSD_version
expr_stmt|;
name|status
operator|->
name|pr_pid
operator|=
name|pid
expr_stmt|;
name|memset
argument_list|(
name|fpregset
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|fpregset
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|psinfo
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|psinfo
argument_list|)
expr_stmt|;
name|psinfo
operator|->
name|pr_version
operator|=
name|PRPSINFO_VERSION
expr_stmt|;
name|psinfo
operator|->
name|pr_psinfosz
operator|=
sizeof|sizeof
argument_list|(
name|prpsinfo_t
argument_list|)
expr_stmt|;
comment|/* Read the general registers. */
name|snprintf
argument_list|(
name|name
argument_list|,
sizeof|sizeof
name|name
argument_list|,
literal|"/proc/%d/regs"
argument_list|,
name|pid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|name
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"cannot open %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|read
argument_list|(
name|fd
argument_list|,
operator|&
name|status
operator|->
name|pr_reg
argument_list|,
sizeof|sizeof
name|status
operator|->
name|pr_reg
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"read error from %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|size_t
operator|)
name|n
operator|<
sizeof|sizeof
argument_list|(
name|status
operator|->
name|pr_reg
argument_list|)
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"short read from %s: wanted %u, got %d"
argument_list|,
name|name
argument_list|,
sizeof|sizeof
name|status
operator|->
name|pr_reg
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
comment|/* Read the floating point registers. */
name|snprintf
argument_list|(
name|name
argument_list|,
sizeof|sizeof
name|name
argument_list|,
literal|"/proc/%d/fpregs"
argument_list|,
name|pid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|name
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"cannot open %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|fpregset
argument_list|,
sizeof|sizeof
expr|*
name|fpregset
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"read error from %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|size_t
operator|)
name|n
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|fpregset
argument_list|)
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"short read from %s: wanted %u, got %d"
argument_list|,
name|name
argument_list|,
sizeof|sizeof
expr|*
name|fpregset
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
comment|/* Read and parse the process status. */
name|snprintf
argument_list|(
name|name
argument_list|,
sizeof|sizeof
name|name
argument_list|,
literal|"/proc/%d/status"
argument_list|,
name|pid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|name
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"cannot open %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|line
argument_list|,
sizeof|sizeof
name|line
operator|-
literal|1
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"read error from %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|MAXCOMLEN
condition|)
name|n
operator|=
name|MAXCOMLEN
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
operator|&&
name|line
index|[
name|i
index|]
operator|!=
literal|' '
condition|;
name|i
operator|++
control|)
name|psinfo
operator|->
name|pr_fname
index|[
name|i
index|]
operator|=
name|line
index|[
name|i
index|]
expr_stmt|;
name|strncpy
argument_list|(
name|psinfo
operator|->
name|pr_psargs
argument_list|,
name|psinfo
operator|->
name|pr_fname
argument_list|,
name|PRARGSZ
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Read the process's memory map using procfs, and return a list of  * VM map entries.  Only the non-device read/writable segments are  * returned.  The map entries in the list aren't fully filled in; only  * the items we need are present.  */
end_comment

begin_function
specifier|static
name|vm_map_entry_t
name|readmap
parameter_list|(
name|pid_t
name|pid
parameter_list|)
block|{
name|char
name|mapname
index|[
literal|64
index|]
decl_stmt|;
name|int
name|mapfd
decl_stmt|;
name|ssize_t
name|mapsize
decl_stmt|;
name|size_t
name|bufsize
decl_stmt|;
name|char
modifier|*
name|mapbuf
decl_stmt|;
name|int
name|pos
decl_stmt|;
name|vm_map_entry_t
name|map
decl_stmt|;
name|vm_map_entry_t
modifier|*
name|linkp
decl_stmt|;
name|snprintf
argument_list|(
name|mapname
argument_list|,
sizeof|sizeof
name|mapname
argument_list|,
literal|"/proc/%d/map"
argument_list|,
name|pid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mapfd
operator|=
name|open
argument_list|(
name|mapname
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"cannot open %s"
argument_list|,
name|mapname
argument_list|)
expr_stmt|;
comment|/* 	 * Procfs requires (for consistency) that the entire memory map 	 * be read with a single read() call.  Start with a reasonably sized 	 * buffer, and double it until it is big enough. 	 */
name|bufsize
operator|=
literal|8
operator|*
literal|1024
expr_stmt|;
name|mapbuf
operator|=
name|NULL
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|mapbuf
operator|=
name|realloc
argument_list|(
name|mapbuf
argument_list|,
name|bufsize
operator|+
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
name|mapsize
operator|=
name|read
argument_list|(
name|mapfd
argument_list|,
name|mapbuf
argument_list|,
name|bufsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|mapsize
operator|!=
operator|-
literal|1
operator|||
name|errno
operator|!=
name|EFBIG
condition|)
break|break;
name|bufsize
operator|*=
literal|2
expr_stmt|;
comment|/* This lseek shouldn't be necessary, but it is. */
name|lseek
argument_list|(
name|mapfd
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mapsize
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"read error from %s"
argument_list|,
name|mapname
argument_list|)
expr_stmt|;
if|if
condition|(
name|mapsize
operator|==
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"empty map file %s"
argument_list|,
name|mapname
argument_list|)
expr_stmt|;
name|mapbuf
index|[
name|mapsize
index|]
operator|=
literal|0
expr_stmt|;
name|close
argument_list|(
name|mapfd
argument_list|)
expr_stmt|;
name|pos
operator|=
literal|0
expr_stmt|;
name|map
operator|=
name|NULL
expr_stmt|;
name|linkp
operator|=
operator|&
name|map
expr_stmt|;
while|while
condition|(
name|pos
operator|<
name|mapsize
condition|)
block|{
name|vm_map_entry_t
name|ent
decl_stmt|;
name|u_long
name|start
decl_stmt|;
name|u_long
name|end
decl_stmt|;
name|char
name|prot
index|[
literal|4
index|]
decl_stmt|;
name|char
name|type
index|[
literal|16
index|]
decl_stmt|;
name|int
name|n
decl_stmt|;
name|int
name|len
decl_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
name|n
operator|=
name|sscanf
argument_list|(
name|mapbuf
operator|+
name|pos
argument_list|,
literal|"%lx %lx %*d %*d %*x %3[-rwx]"
literal|" %*d %*d %*x %*s %*s %16s %*s%*[\n]%n"
argument_list|,
operator|&
name|start
argument_list|,
operator|&
name|end
argument_list|,
name|prot
argument_list|,
name|type
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
literal|4
operator|||
name|len
operator|==
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"ill-formed line in %s starting at character %d"
argument_list|,
name|mapname
argument_list|,
name|pos
operator|+
literal|1
argument_list|)
expr_stmt|;
name|pos
operator|+=
name|len
expr_stmt|;
comment|/* Ignore segments of the wrong kind, and unwritable ones */
if|if
condition|(
name|strncmp
argument_list|(
name|prot
argument_list|,
literal|"rw"
argument_list|,
literal|2
argument_list|)
operator|!=
literal|0
operator|||
operator|(
name|strcmp
argument_list|(
name|type
argument_list|,
literal|"default"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|type
argument_list|,
literal|"vnode"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|type
argument_list|,
literal|"swap"
argument_list|)
operator|!=
literal|0
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
name|ent
operator|=
operator|(
name|vm_map_entry_t
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|ent
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
name|ent
operator|->
name|start
operator|=
name|start
expr_stmt|;
name|ent
operator|->
name|end
operator|=
name|end
expr_stmt|;
name|ent
operator|->
name|protection
operator|=
name|VM_PROT_READ
operator||
name|VM_PROT_WRITE
expr_stmt|;
if|if
condition|(
name|prot
index|[
literal|2
index|]
operator|==
literal|'x'
condition|)
name|ent
operator|->
name|protection
operator||=
name|VM_PROT_EXECUTE
expr_stmt|;
operator|*
name|linkp
operator|=
name|ent
expr_stmt|;
name|linkp
operator|=
operator|&
name|ent
operator|->
name|next
expr_stmt|;
block|}
name|free
argument_list|(
name|mapbuf
argument_list|)
expr_stmt|;
return|return
name|map
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|dumpers
name|elfdump
init|=
block|{
name|elf_ident
block|,
name|elf_coredump
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TEXT_SET
argument_list|(
name|dumpset
argument_list|,
name|elfdump
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

