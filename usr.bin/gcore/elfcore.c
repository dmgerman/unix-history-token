begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2007 Sandvine Incorporated  * Copyright (c) 1998 John D. Polstra  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/procfs.h>
end_include

begin_include
include|#
directive|include
file|<sys/ptrace.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/linker_set.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<machine/elf.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<libutil.h>
end_include

begin_include
include|#
directive|include
file|"extern.h"
end_include

begin_comment
comment|/*  * Code for generating ELF core dumps.  */
end_comment

begin_typedef
typedef|typedef
name|void
function_decl|(
modifier|*
name|segment_callback
function_decl|)
parameter_list|(
name|vm_map_entry_t
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_typedef

begin_comment
comment|/* Closure for cb_put_phdr(). */
end_comment

begin_struct
struct|struct
name|phdr_closure
block|{
name|Elf_Phdr
modifier|*
name|phdr
decl_stmt|;
comment|/* Program header to fill in */
name|Elf_Off
name|offset
decl_stmt|;
comment|/* Offset of segment in core file */
block|}
struct|;
end_struct

begin_comment
comment|/* Closure for cb_size_segment(). */
end_comment

begin_struct
struct|struct
name|sseg_closure
block|{
name|int
name|count
decl_stmt|;
comment|/* Count of writable segments. */
name|size_t
name|size
decl_stmt|;
comment|/* Total size of all writable segments. */
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|void
name|cb_put_phdr
parameter_list|(
name|vm_map_entry_t
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cb_size_segment
parameter_list|(
name|vm_map_entry_t
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|each_writable_segment
parameter_list|(
name|vm_map_entry_t
parameter_list|,
name|segment_callback
parameter_list|,
name|void
modifier|*
name|closure
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|elf_detach
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* atexit() handler. */
end_comment

begin_function_decl
specifier|static
name|void
name|elf_puthdr
parameter_list|(
name|pid_t
parameter_list|,
name|vm_map_entry_t
parameter_list|,
name|void
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|,
name|int
name|numsegs
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|elf_putnote
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
modifier|*
name|off
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|type
parameter_list|,
specifier|const
name|void
modifier|*
name|desc
parameter_list|,
name|size_t
name|descsz
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|freemap
parameter_list|(
name|vm_map_entry_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|vm_map_entry_t
name|readmap
parameter_list|(
name|pid_t
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|pid_t
name|g_pid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pid being dumped, global for elf_detach */
end_comment

begin_function
specifier|static
name|int
name|elf_ident
parameter_list|(
name|int
name|efd
parameter_list|,
name|pid_t
name|pid
name|__unused
parameter_list|,
name|char
modifier|*
name|binfile
name|__unused
parameter_list|)
block|{
name|Elf_Ehdr
name|hdr
decl_stmt|;
name|int
name|cnt
decl_stmt|;
name|cnt
operator|=
name|read
argument_list|(
name|efd
argument_list|,
operator|&
name|hdr
argument_list|,
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnt
operator|!=
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|IS_ELF
argument_list|(
name|hdr
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|elf_detach
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|g_pid
operator|!=
literal|0
condition|)
name|ptrace
argument_list|(
name|PT_DETACH
argument_list|,
name|g_pid
argument_list|,
operator|(
name|caddr_t
operator|)
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Write an ELF coredump for the given pid to the given fd.  */
end_comment

begin_function
specifier|static
name|void
name|elf_coredump
parameter_list|(
name|int
name|efd
name|__unused
parameter_list|,
name|int
name|fd
parameter_list|,
name|pid_t
name|pid
parameter_list|)
block|{
name|vm_map_entry_t
name|map
decl_stmt|;
name|struct
name|sseg_closure
name|seginfo
decl_stmt|;
name|void
modifier|*
name|hdr
decl_stmt|;
name|size_t
name|hdrsize
decl_stmt|;
name|Elf_Phdr
modifier|*
name|php
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Attach to process to dump. */
name|g_pid
operator|=
name|pid
expr_stmt|;
if|if
condition|(
name|atexit
argument_list|(
name|elf_detach
argument_list|)
operator|!=
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"atexit"
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|ptrace
argument_list|(
name|PT_ATTACH
argument_list|,
name|pid
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"PT_ATTACH"
argument_list|)
expr_stmt|;
if|if
condition|(
name|waitpid
argument_list|(
name|pid
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"waitpid"
argument_list|)
expr_stmt|;
comment|/* Get the program's memory map. */
name|map
operator|=
name|readmap
argument_list|(
name|pid
argument_list|)
expr_stmt|;
comment|/* Size the program segments. */
name|seginfo
operator|.
name|count
operator|=
literal|0
expr_stmt|;
name|seginfo
operator|.
name|size
operator|=
literal|0
expr_stmt|;
name|each_writable_segment
argument_list|(
name|map
argument_list|,
name|cb_size_segment
argument_list|,
operator|&
name|seginfo
argument_list|)
expr_stmt|;
comment|/* 	 * Calculate the size of the core file header area by making 	 * a dry run of generating it.  Nothing is written, but the 	 * size is calculated. 	 */
name|hdrsize
operator|=
literal|0
expr_stmt|;
name|elf_puthdr
argument_list|(
name|pid
argument_list|,
name|map
argument_list|,
name|NULL
argument_list|,
operator|&
name|hdrsize
argument_list|,
name|seginfo
operator|.
name|count
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate memory for building the header, fill it up, 	 * and write it out. 	 */
if|if
condition|(
operator|(
name|hdr
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
name|hdrsize
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
comment|/* Fill in the header. */
name|hdrsize
operator|=
literal|0
expr_stmt|;
name|elf_puthdr
argument_list|(
name|pid
argument_list|,
name|map
argument_list|,
name|hdr
argument_list|,
operator|&
name|hdrsize
argument_list|,
name|seginfo
operator|.
name|count
argument_list|)
expr_stmt|;
comment|/* Write it to the core file. */
if|if
condition|(
name|write
argument_list|(
name|fd
argument_list|,
name|hdr
argument_list|,
name|hdrsize
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"write"
argument_list|)
expr_stmt|;
comment|/* Write the contents of all of the writable segments. */
name|php
operator|=
operator|(
name|Elf_Phdr
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|hdr
operator|+
sizeof|sizeof
argument_list|(
name|Elf_Ehdr
argument_list|)
operator|)
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|seginfo
operator|.
name|count
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ptrace_io_desc
name|iorequest
decl_stmt|;
name|uintmax_t
name|nleft
init|=
name|php
operator|->
name|p_filesz
decl_stmt|;
name|iorequest
operator|.
name|piod_op
operator|=
name|PIOD_READ_D
expr_stmt|;
name|iorequest
operator|.
name|piod_offs
operator|=
operator|(
name|caddr_t
operator|)
name|php
operator|->
name|p_vaddr
expr_stmt|;
while|while
condition|(
name|nleft
operator|>
literal|0
condition|)
block|{
name|char
name|buf
index|[
literal|8
operator|*
literal|1024
index|]
decl_stmt|;
name|size_t
name|nwant
decl_stmt|;
name|ssize_t
name|ngot
decl_stmt|;
if|if
condition|(
name|nleft
operator|>
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
condition|)
name|nwant
operator|=
sizeof|sizeof
name|buf
expr_stmt|;
else|else
name|nwant
operator|=
name|nleft
expr_stmt|;
name|iorequest
operator|.
name|piod_addr
operator|=
name|buf
expr_stmt|;
name|iorequest
operator|.
name|piod_len
operator|=
name|nwant
expr_stmt|;
name|ptrace
argument_list|(
name|PT_IO
argument_list|,
name|pid
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|iorequest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ngot
operator|=
name|iorequest
operator|.
name|piod_len
expr_stmt|;
if|if
condition|(
operator|(
name|size_t
operator|)
name|ngot
operator|<
name|nwant
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"short read wanted %d, got %d"
argument_list|,
name|nwant
argument_list|,
name|ngot
argument_list|)
expr_stmt|;
name|ngot
operator|=
name|write
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
name|nwant
argument_list|)
expr_stmt|;
if|if
condition|(
name|ngot
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"write of segment %d failed"
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|size_t
operator|)
name|ngot
operator|!=
name|nwant
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"short write"
argument_list|)
expr_stmt|;
name|nleft
operator|-=
name|nwant
expr_stmt|;
name|iorequest
operator|.
name|piod_offs
operator|+=
name|ngot
expr_stmt|;
block|}
name|php
operator|++
expr_stmt|;
block|}
name|free
argument_list|(
name|hdr
argument_list|)
expr_stmt|;
name|freemap
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * A callback for each_writable_segment() to write out the segment's  * program header entry.  */
end_comment

begin_function
specifier|static
name|void
name|cb_put_phdr
parameter_list|(
name|vm_map_entry_t
name|entry
parameter_list|,
name|void
modifier|*
name|closure
parameter_list|)
block|{
name|struct
name|phdr_closure
modifier|*
name|phc
init|=
operator|(
expr|struct
name|phdr_closure
operator|*
operator|)
name|closure
decl_stmt|;
name|Elf_Phdr
modifier|*
name|phdr
init|=
name|phc
operator|->
name|phdr
decl_stmt|;
name|phc
operator|->
name|offset
operator|=
name|round_page
argument_list|(
name|phc
operator|->
name|offset
argument_list|)
expr_stmt|;
name|phdr
operator|->
name|p_type
operator|=
name|PT_LOAD
expr_stmt|;
name|phdr
operator|->
name|p_offset
operator|=
name|phc
operator|->
name|offset
expr_stmt|;
name|phdr
operator|->
name|p_vaddr
operator|=
name|entry
operator|->
name|start
expr_stmt|;
name|phdr
operator|->
name|p_paddr
operator|=
literal|0
expr_stmt|;
name|phdr
operator|->
name|p_filesz
operator|=
name|phdr
operator|->
name|p_memsz
operator|=
name|entry
operator|->
name|end
operator|-
name|entry
operator|->
name|start
expr_stmt|;
name|phdr
operator|->
name|p_align
operator|=
name|PAGE_SIZE
expr_stmt|;
name|phdr
operator|->
name|p_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|protection
operator|&
name|VM_PROT_READ
condition|)
name|phdr
operator|->
name|p_flags
operator||=
name|PF_R
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|protection
operator|&
name|VM_PROT_WRITE
condition|)
name|phdr
operator|->
name|p_flags
operator||=
name|PF_W
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|protection
operator|&
name|VM_PROT_EXECUTE
condition|)
name|phdr
operator|->
name|p_flags
operator||=
name|PF_X
expr_stmt|;
name|phc
operator|->
name|offset
operator|+=
name|phdr
operator|->
name|p_filesz
expr_stmt|;
name|phc
operator|->
name|phdr
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * A callback for each_writable_segment() to gather information about  * the number of segments and their total size.  */
end_comment

begin_function
specifier|static
name|void
name|cb_size_segment
parameter_list|(
name|vm_map_entry_t
name|entry
parameter_list|,
name|void
modifier|*
name|closure
parameter_list|)
block|{
name|struct
name|sseg_closure
modifier|*
name|ssc
init|=
operator|(
expr|struct
name|sseg_closure
operator|*
operator|)
name|closure
decl_stmt|;
name|ssc
operator|->
name|count
operator|++
expr_stmt|;
name|ssc
operator|->
name|size
operator|+=
name|entry
operator|->
name|end
operator|-
name|entry
operator|->
name|start
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * For each segment in the given memory map, call the given function  * with a pointer to the map entry and some arbitrary caller-supplied  * data.  */
end_comment

begin_function
specifier|static
name|void
name|each_writable_segment
parameter_list|(
name|vm_map_entry_t
name|map
parameter_list|,
name|segment_callback
name|func
parameter_list|,
name|void
modifier|*
name|closure
parameter_list|)
block|{
name|vm_map_entry_t
name|entry
decl_stmt|;
for|for
control|(
name|entry
operator|=
name|map
init|;
name|entry
operator|!=
name|NULL
condition|;
name|entry
operator|=
name|entry
operator|->
name|next
control|)
call|(
modifier|*
name|func
call|)
argument_list|(
name|entry
argument_list|,
name|closure
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|elf_getstatus
parameter_list|(
name|pid_t
name|pid
parameter_list|,
name|prpsinfo_t
modifier|*
name|psinfo
parameter_list|)
block|{
name|struct
name|kinfo_proc
name|kobj
decl_stmt|;
name|int
name|name
index|[
literal|4
index|]
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|name
index|[
literal|0
index|]
operator|=
name|CTL_KERN
expr_stmt|;
name|name
index|[
literal|1
index|]
operator|=
name|KERN_PROC
expr_stmt|;
name|name
index|[
literal|2
index|]
operator|=
name|KERN_PROC_PID
expr_stmt|;
name|name
index|[
literal|3
index|]
operator|=
name|pid
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
name|kobj
argument_list|)
expr_stmt|;
if|if
condition|(
name|sysctl
argument_list|(
name|name
argument_list|,
literal|4
argument_list|,
operator|&
name|kobj
argument_list|,
operator|&
name|len
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"error accessing kern.proc.pid.%u sysctl"
argument_list|,
name|pid
argument_list|)
expr_stmt|;
if|if
condition|(
name|kobj
operator|.
name|ki_pid
operator|!=
name|pid
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"error accessing kern.proc.pid.%u sysctl datas"
argument_list|,
name|pid
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|psinfo
operator|->
name|pr_fname
argument_list|,
name|kobj
operator|.
name|ki_comm
argument_list|,
name|MAXCOMLEN
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|psinfo
operator|->
name|pr_psargs
argument_list|,
name|psinfo
operator|->
name|pr_fname
argument_list|,
name|PRARGSZ
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Generate the ELF coredump header into the buffer at "dst".  "dst" may  * be NULL, in which case the header is sized but not actually generated.  */
end_comment

begin_function
specifier|static
name|void
name|elf_puthdr
parameter_list|(
name|pid_t
name|pid
parameter_list|,
name|vm_map_entry_t
name|map
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
modifier|*
name|off
parameter_list|,
name|int
name|numsegs
parameter_list|)
block|{
struct|struct
block|{
name|prstatus_t
name|status
decl_stmt|;
name|prfpregset_t
name|fpregset
decl_stmt|;
name|prpsinfo_t
name|psinfo
decl_stmt|;
block|}
modifier|*
name|tempdata
struct|;
name|size_t
name|ehoff
decl_stmt|;
name|size_t
name|phoff
decl_stmt|;
name|size_t
name|noteoff
decl_stmt|;
name|size_t
name|notesz
decl_stmt|;
name|size_t
name|threads
decl_stmt|;
name|lwpid_t
modifier|*
name|tids
decl_stmt|;
name|int
name|i
decl_stmt|;
name|prstatus_t
modifier|*
name|status
decl_stmt|;
name|prfpregset_t
modifier|*
name|fpregset
decl_stmt|;
name|prpsinfo_t
modifier|*
name|psinfo
decl_stmt|;
name|ehoff
operator|=
operator|*
name|off
expr_stmt|;
operator|*
name|off
operator|+=
sizeof|sizeof
argument_list|(
name|Elf_Ehdr
argument_list|)
expr_stmt|;
name|phoff
operator|=
operator|*
name|off
expr_stmt|;
operator|*
name|off
operator|+=
operator|(
name|numsegs
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|Elf_Phdr
argument_list|)
expr_stmt|;
name|noteoff
operator|=
operator|*
name|off
expr_stmt|;
if|if
condition|(
name|dst
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|tempdata
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|tempdata
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
name|status
operator|=
operator|&
name|tempdata
operator|->
name|status
expr_stmt|;
name|fpregset
operator|=
operator|&
name|tempdata
operator|->
name|fpregset
expr_stmt|;
name|psinfo
operator|=
operator|&
name|tempdata
operator|->
name|psinfo
expr_stmt|;
block|}
else|else
block|{
name|tempdata
operator|=
name|NULL
expr_stmt|;
name|status
operator|=
name|NULL
expr_stmt|;
name|fpregset
operator|=
name|NULL
expr_stmt|;
name|psinfo
operator|=
name|NULL
expr_stmt|;
block|}
name|errno
operator|=
literal|0
expr_stmt|;
name|threads
operator|=
name|ptrace
argument_list|(
name|PT_GETNUMLWPS
argument_list|,
name|pid
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"PT_GETNUMLWPS"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst
operator|!=
name|NULL
condition|)
block|{
name|psinfo
operator|->
name|pr_version
operator|=
name|PRPSINFO_VERSION
expr_stmt|;
name|psinfo
operator|->
name|pr_psinfosz
operator|=
sizeof|sizeof
argument_list|(
name|prpsinfo_t
argument_list|)
expr_stmt|;
name|elf_getstatus
argument_list|(
name|pid
argument_list|,
name|psinfo
argument_list|)
expr_stmt|;
block|}
name|elf_putnote
argument_list|(
name|dst
argument_list|,
name|off
argument_list|,
literal|"FreeBSD"
argument_list|,
name|NT_PRPSINFO
argument_list|,
name|psinfo
argument_list|,
sizeof|sizeof
expr|*
name|psinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst
operator|!=
name|NULL
condition|)
block|{
name|tids
operator|=
name|malloc
argument_list|(
name|threads
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|tids
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tids
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|ptrace
argument_list|(
name|PT_GETLWPLIST
argument_list|,
name|pid
argument_list|,
operator|(
name|void
operator|*
operator|)
name|tids
argument_list|,
name|threads
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"PT_GETLWPLIST"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|threads
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|dst
operator|!=
name|NULL
condition|)
block|{
name|status
operator|->
name|pr_version
operator|=
name|PRSTATUS_VERSION
expr_stmt|;
name|status
operator|->
name|pr_statussz
operator|=
sizeof|sizeof
argument_list|(
name|prstatus_t
argument_list|)
expr_stmt|;
name|status
operator|->
name|pr_gregsetsz
operator|=
sizeof|sizeof
argument_list|(
name|gregset_t
argument_list|)
expr_stmt|;
name|status
operator|->
name|pr_fpregsetsz
operator|=
sizeof|sizeof
argument_list|(
name|fpregset_t
argument_list|)
expr_stmt|;
name|status
operator|->
name|pr_osreldate
operator|=
name|__FreeBSD_version
expr_stmt|;
name|status
operator|->
name|pr_pid
operator|=
name|tids
index|[
name|i
index|]
expr_stmt|;
name|ptrace
argument_list|(
name|PT_GETREGS
argument_list|,
name|tids
index|[
name|i
index|]
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|status
operator|->
name|pr_reg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ptrace
argument_list|(
name|PT_GETFPREGS
argument_list|,
name|tids
index|[
name|i
index|]
argument_list|,
operator|(
name|void
operator|*
operator|)
name|fpregset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|elf_putnote
argument_list|(
name|dst
argument_list|,
name|off
argument_list|,
literal|"FreeBSD"
argument_list|,
name|NT_PRSTATUS
argument_list|,
name|status
argument_list|,
sizeof|sizeof
expr|*
name|status
argument_list|)
expr_stmt|;
name|elf_putnote
argument_list|(
name|dst
argument_list|,
name|off
argument_list|,
literal|"FreeBSD"
argument_list|,
name|NT_FPREGSET
argument_list|,
name|fpregset
argument_list|,
sizeof|sizeof
expr|*
name|fpregset
argument_list|)
expr_stmt|;
block|}
name|notesz
operator|=
operator|*
name|off
operator|-
name|noteoff
expr_stmt|;
if|if
condition|(
name|dst
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|tids
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tempdata
argument_list|)
expr_stmt|;
block|}
comment|/* Align up to a page boundary for the program segments. */
operator|*
name|off
operator|=
name|round_page
argument_list|(
operator|*
name|off
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst
operator|!=
name|NULL
condition|)
block|{
name|Elf_Ehdr
modifier|*
name|ehdr
decl_stmt|;
name|Elf_Phdr
modifier|*
name|phdr
decl_stmt|;
name|struct
name|phdr_closure
name|phc
decl_stmt|;
comment|/* 		 * Fill in the ELF header. 		 */
name|ehdr
operator|=
operator|(
name|Elf_Ehdr
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|dst
operator|+
name|ehoff
operator|)
expr_stmt|;
name|ehdr
operator|->
name|e_ident
index|[
name|EI_MAG0
index|]
operator|=
name|ELFMAG0
expr_stmt|;
name|ehdr
operator|->
name|e_ident
index|[
name|EI_MAG1
index|]
operator|=
name|ELFMAG1
expr_stmt|;
name|ehdr
operator|->
name|e_ident
index|[
name|EI_MAG2
index|]
operator|=
name|ELFMAG2
expr_stmt|;
name|ehdr
operator|->
name|e_ident
index|[
name|EI_MAG3
index|]
operator|=
name|ELFMAG3
expr_stmt|;
name|ehdr
operator|->
name|e_ident
index|[
name|EI_CLASS
index|]
operator|=
name|ELF_CLASS
expr_stmt|;
name|ehdr
operator|->
name|e_ident
index|[
name|EI_DATA
index|]
operator|=
name|ELF_DATA
expr_stmt|;
name|ehdr
operator|->
name|e_ident
index|[
name|EI_VERSION
index|]
operator|=
name|EV_CURRENT
expr_stmt|;
name|ehdr
operator|->
name|e_ident
index|[
name|EI_OSABI
index|]
operator|=
name|ELFOSABI_FREEBSD
expr_stmt|;
name|ehdr
operator|->
name|e_ident
index|[
name|EI_ABIVERSION
index|]
operator|=
literal|0
expr_stmt|;
name|ehdr
operator|->
name|e_ident
index|[
name|EI_PAD
index|]
operator|=
literal|0
expr_stmt|;
name|ehdr
operator|->
name|e_type
operator|=
name|ET_CORE
expr_stmt|;
name|ehdr
operator|->
name|e_machine
operator|=
name|ELF_ARCH
expr_stmt|;
name|ehdr
operator|->
name|e_version
operator|=
name|EV_CURRENT
expr_stmt|;
name|ehdr
operator|->
name|e_entry
operator|=
literal|0
expr_stmt|;
name|ehdr
operator|->
name|e_phoff
operator|=
name|phoff
expr_stmt|;
name|ehdr
operator|->
name|e_flags
operator|=
literal|0
expr_stmt|;
name|ehdr
operator|->
name|e_ehsize
operator|=
sizeof|sizeof
argument_list|(
name|Elf_Ehdr
argument_list|)
expr_stmt|;
name|ehdr
operator|->
name|e_phentsize
operator|=
sizeof|sizeof
argument_list|(
name|Elf_Phdr
argument_list|)
expr_stmt|;
name|ehdr
operator|->
name|e_phnum
operator|=
name|numsegs
operator|+
literal|1
expr_stmt|;
name|ehdr
operator|->
name|e_shentsize
operator|=
sizeof|sizeof
argument_list|(
name|Elf_Shdr
argument_list|)
expr_stmt|;
name|ehdr
operator|->
name|e_shnum
operator|=
literal|0
expr_stmt|;
name|ehdr
operator|->
name|e_shstrndx
operator|=
name|SHN_UNDEF
expr_stmt|;
comment|/* 		 * Fill in the program header entries. 		 */
name|phdr
operator|=
operator|(
name|Elf_Phdr
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|dst
operator|+
name|phoff
operator|)
expr_stmt|;
comment|/* The note segment. */
name|phdr
operator|->
name|p_type
operator|=
name|PT_NOTE
expr_stmt|;
name|phdr
operator|->
name|p_offset
operator|=
name|noteoff
expr_stmt|;
name|phdr
operator|->
name|p_vaddr
operator|=
literal|0
expr_stmt|;
name|phdr
operator|->
name|p_paddr
operator|=
literal|0
expr_stmt|;
name|phdr
operator|->
name|p_filesz
operator|=
name|notesz
expr_stmt|;
name|phdr
operator|->
name|p_memsz
operator|=
literal|0
expr_stmt|;
name|phdr
operator|->
name|p_flags
operator|=
literal|0
expr_stmt|;
name|phdr
operator|->
name|p_align
operator|=
literal|0
expr_stmt|;
name|phdr
operator|++
expr_stmt|;
comment|/* All the writable segments from the program. */
name|phc
operator|.
name|phdr
operator|=
name|phdr
expr_stmt|;
name|phc
operator|.
name|offset
operator|=
operator|*
name|off
expr_stmt|;
name|each_writable_segment
argument_list|(
name|map
argument_list|,
name|cb_put_phdr
argument_list|,
operator|&
name|phc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Emit one note section to "dst", or just size it if "dst" is NULL.  */
end_comment

begin_function
specifier|static
name|void
name|elf_putnote
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
modifier|*
name|off
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|type
parameter_list|,
specifier|const
name|void
modifier|*
name|desc
parameter_list|,
name|size_t
name|descsz
parameter_list|)
block|{
name|Elf_Note
name|note
decl_stmt|;
name|note
operator|.
name|n_namesz
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
expr_stmt|;
name|note
operator|.
name|n_descsz
operator|=
name|descsz
expr_stmt|;
name|note
operator|.
name|n_type
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|dst
operator|!=
name|NULL
condition|)
name|bcopy
argument_list|(
operator|&
name|note
argument_list|,
operator|(
name|char
operator|*
operator|)
name|dst
operator|+
operator|*
name|off
argument_list|,
sizeof|sizeof
name|note
argument_list|)
expr_stmt|;
operator|*
name|off
operator|+=
sizeof|sizeof
name|note
expr_stmt|;
if|if
condition|(
name|dst
operator|!=
name|NULL
condition|)
name|bcopy
argument_list|(
name|name
argument_list|,
operator|(
name|char
operator|*
operator|)
name|dst
operator|+
operator|*
name|off
argument_list|,
name|note
operator|.
name|n_namesz
argument_list|)
expr_stmt|;
operator|*
name|off
operator|+=
name|roundup2
argument_list|(
name|note
operator|.
name|n_namesz
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf_Size
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst
operator|!=
name|NULL
condition|)
name|bcopy
argument_list|(
name|desc
argument_list|,
operator|(
name|char
operator|*
operator|)
name|dst
operator|+
operator|*
name|off
argument_list|,
name|note
operator|.
name|n_descsz
argument_list|)
expr_stmt|;
operator|*
name|off
operator|+=
name|roundup2
argument_list|(
name|note
operator|.
name|n_descsz
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf_Size
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Free the memory map.  */
end_comment

begin_function
specifier|static
name|void
name|freemap
parameter_list|(
name|vm_map_entry_t
name|map
parameter_list|)
block|{
while|while
condition|(
name|map
operator|!=
name|NULL
condition|)
block|{
name|vm_map_entry_t
name|next
init|=
name|map
operator|->
name|next
decl_stmt|;
name|free
argument_list|(
name|map
argument_list|)
expr_stmt|;
name|map
operator|=
name|next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Read the process's memory map using kinfo_getvmmap(), and return a list of  * VM map entries.  Only the non-device read/writable segments are  * returned.  The map entries in the list aren't fully filled in; only  * the items we need are present.  */
end_comment

begin_function
specifier|static
name|vm_map_entry_t
name|readmap
parameter_list|(
name|pid_t
name|pid
parameter_list|)
block|{
name|vm_map_entry_t
name|ent
decl_stmt|,
modifier|*
name|linkp
decl_stmt|,
name|map
decl_stmt|;
name|struct
name|kinfo_vmentry
modifier|*
name|vmentl
decl_stmt|,
modifier|*
name|kve
decl_stmt|;
name|int
name|i
decl_stmt|,
name|nitems
decl_stmt|;
name|vmentl
operator|=
name|kinfo_getvmmap
argument_list|(
name|pid
argument_list|,
operator|&
name|nitems
argument_list|)
expr_stmt|;
if|if
condition|(
name|vmentl
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"cannot retrieve mappings for %u process"
argument_list|,
name|pid
argument_list|)
expr_stmt|;
name|map
operator|=
name|NULL
expr_stmt|;
name|linkp
operator|=
operator|&
name|map
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitems
condition|;
name|i
operator|++
control|)
block|{
name|kve
operator|=
operator|&
name|vmentl
index|[
name|i
index|]
expr_stmt|;
comment|/* 		 * Ignore segments of the wrong kind and ones which are not 		 * readable and writable. 		 */
if|if
condition|(
operator|(
name|kve
operator|->
name|kve_protection
operator|&
name|KVME_PROT_WRITE
operator|)
operator|==
literal|0
operator|||
operator|(
name|kve
operator|->
name|kve_protection
operator|&
name|KVME_PROT_READ
operator|)
operator|==
literal|0
operator|||
operator|(
name|kve
operator|->
name|kve_type
operator|!=
name|KVME_TYPE_DEFAULT
operator|&&
name|kve
operator|->
name|kve_type
operator|!=
name|KVME_TYPE_VNODE
operator|&&
name|kve
operator|->
name|kve_type
operator|!=
name|KVME_TYPE_SWAP
operator|)
condition|)
continue|continue;
name|ent
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ent
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ent
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
name|ent
operator|->
name|start
operator|=
operator|(
name|vm_offset_t
operator|)
name|kve
operator|->
name|kve_start
expr_stmt|;
name|ent
operator|->
name|end
operator|=
operator|(
name|vm_offset_t
operator|)
name|kve
operator|->
name|kve_end
expr_stmt|;
name|ent
operator|->
name|protection
operator|=
name|VM_PROT_READ
operator||
name|VM_PROT_WRITE
expr_stmt|;
if|if
condition|(
operator|(
name|kve
operator|->
name|kve_protection
operator|&
name|KVME_PROT_EXEC
operator|)
operator|!=
literal|0
condition|)
name|ent
operator|->
name|protection
operator||=
name|VM_PROT_EXECUTE
expr_stmt|;
operator|*
name|linkp
operator|=
name|ent
expr_stmt|;
name|linkp
operator|=
operator|&
name|ent
operator|->
name|next
expr_stmt|;
block|}
name|free
argument_list|(
name|vmentl
argument_list|)
expr_stmt|;
return|return
operator|(
name|map
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|dumpers
name|elfdump
init|=
block|{
name|elf_ident
block|,
name|elf_coredump
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TEXT_SET
argument_list|(
name|dumpset
argument_list|,
name|elfdump
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

