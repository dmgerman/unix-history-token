begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2007 Sandvine Incorporated  * Copyright (c) 1998 John D. Polstra  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/procfs.h>
end_include

begin_include
include|#
directive|include
file|<sys/ptrace.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/linker_set.h>
end_include

begin_include
include|#
directive|include
file|<sys/sbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<machine/elf.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<stdbool.h>
end_include

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<libutil.h>
end_include

begin_include
include|#
directive|include
file|"extern.h"
end_include

begin_comment
comment|/*  * Code for generating ELF core dumps.  */
end_comment

begin_typedef
typedef|typedef
name|void
function_decl|(
modifier|*
name|segment_callback
function_decl|)
parameter_list|(
name|vm_map_entry_t
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_typedef

begin_comment
comment|/* Closure for cb_put_phdr(). */
end_comment

begin_struct
struct|struct
name|phdr_closure
block|{
name|Elf_Phdr
modifier|*
name|phdr
decl_stmt|;
comment|/* Program header to fill in */
name|Elf_Off
name|offset
decl_stmt|;
comment|/* Offset of segment in core file */
block|}
struct|;
end_struct

begin_comment
comment|/* Closure for cb_size_segment(). */
end_comment

begin_struct
struct|struct
name|sseg_closure
block|{
name|int
name|count
decl_stmt|;
comment|/* Count of writable segments. */
name|size_t
name|size
decl_stmt|;
comment|/* Total size of all writable segments. */
block|}
struct|;
end_struct

begin_ifdef
ifdef|#
directive|ifdef
name|ELFCORE_COMPAT_32
end_ifdef

begin_typedef
typedef|typedef
name|struct
name|fpreg32
name|elfcore_fpregset_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|reg32
name|elfcore_gregset_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|prpsinfo32
name|elfcore_prpsinfo_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|prstatus32
name|elfcore_prstatus_t
typedef|;
end_typedef

begin_function_decl
specifier|static
name|void
name|elf_convert_gregset
parameter_list|(
name|elfcore_gregset_t
modifier|*
name|rd
parameter_list|,
name|struct
name|reg
modifier|*
name|rs
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|elf_convert_fpregset
parameter_list|(
name|elfcore_fpregset_t
modifier|*
name|rd
parameter_list|,
name|struct
name|fpreg
modifier|*
name|rs
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_typedef
typedef|typedef
name|fpregset_t
name|elfcore_fpregset_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|gregset_t
name|elfcore_gregset_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|prpsinfo_t
name|elfcore_prpsinfo_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|prstatus_t
name|elfcore_prstatus_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|elf_convert_gregset
parameter_list|(
name|d
parameter_list|,
name|s
parameter_list|)
value|*d = *s
end_define

begin_define
define|#
directive|define
name|elf_convert_fpregset
parameter_list|(
name|d
parameter_list|,
name|s
parameter_list|)
value|*d = *s
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_typedef
typedef|typedef
name|void
modifier|*
function_decl|(
modifier|*
name|notefunc_t
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|)
function_decl|;
end_typedef

begin_function_decl
specifier|static
name|void
name|cb_put_phdr
parameter_list|(
name|vm_map_entry_t
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cb_size_segment
parameter_list|(
name|vm_map_entry_t
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|each_writable_segment
parameter_list|(
name|vm_map_entry_t
parameter_list|,
name|segment_callback
parameter_list|,
name|void
modifier|*
name|closure
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|elf_detach
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* atexit() handler. */
end_comment

begin_function_decl
specifier|static
name|void
modifier|*
name|elf_note_fpregset
parameter_list|(
name|void
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|elf_note_prpsinfo
parameter_list|(
name|void
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|elf_note_prstatus
parameter_list|(
name|void
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|elf_note_thrmisc
parameter_list|(
name|void
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__i386__
argument_list|)
operator|||
name|defined
argument_list|(
name|__amd64__
argument_list|)
end_if

begin_function_decl
specifier|static
name|void
modifier|*
name|elf_note_x86_xstate
parameter_list|(
name|void
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__powerpc__
argument_list|)
end_if

begin_function_decl
specifier|static
name|void
modifier|*
name|elf_note_powerpc_vmx
parameter_list|(
name|void
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
modifier|*
name|elf_note_procstat_auxv
parameter_list|(
name|void
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|elf_note_procstat_files
parameter_list|(
name|void
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|elf_note_procstat_groups
parameter_list|(
name|void
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|elf_note_procstat_osrel
parameter_list|(
name|void
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|elf_note_procstat_proc
parameter_list|(
name|void
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|elf_note_procstat_psstrings
parameter_list|(
name|void
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|elf_note_procstat_rlimit
parameter_list|(
name|void
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|elf_note_procstat_umask
parameter_list|(
name|void
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|elf_note_procstat_vmmap
parameter_list|(
name|void
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|elf_puthdr
parameter_list|(
name|int
parameter_list|,
name|pid_t
parameter_list|,
name|vm_map_entry_t
parameter_list|,
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|size_t
parameter_list|,
name|size_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|elf_putnote
parameter_list|(
name|int
parameter_list|,
name|notefunc_t
parameter_list|,
name|void
modifier|*
parameter_list|,
name|struct
name|sbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|elf_putnotes
parameter_list|(
name|pid_t
parameter_list|,
name|struct
name|sbuf
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|freemap
parameter_list|(
name|vm_map_entry_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|vm_map_entry_t
name|readmap
parameter_list|(
name|pid_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|procstat_sysctl
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|,
name|size_t
parameter_list|,
name|size_t
modifier|*
name|sizep
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|pid_t
name|g_pid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pid being dumped, global for elf_detach */
end_comment

begin_decl_stmt
specifier|static
name|int
name|g_status
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* proc status after ptrace attach */
end_comment

begin_function
specifier|static
name|int
name|elf_ident
parameter_list|(
name|int
name|efd
parameter_list|,
name|pid_t
name|pid
name|__unused
parameter_list|,
name|char
modifier|*
name|binfile
name|__unused
parameter_list|)
block|{
name|Elf_Ehdr
name|hdr
decl_stmt|;
name|int
name|cnt
decl_stmt|;
name|uint16_t
name|machine
decl_stmt|;
name|cnt
operator|=
name|read
argument_list|(
name|efd
argument_list|,
operator|&
name|hdr
argument_list|,
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnt
operator|!=
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
name|IS_ELF
argument_list|(
name|hdr
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
switch|switch
condition|(
name|hdr
operator|.
name|e_ident
index|[
name|EI_DATA
index|]
condition|)
block|{
case|case
name|ELFDATA2LSB
case|:
name|machine
operator|=
name|le16toh
argument_list|(
name|hdr
operator|.
name|e_machine
argument_list|)
expr_stmt|;
break|break;
case|case
name|ELFDATA2MSB
case|:
name|machine
operator|=
name|be16toh
argument_list|(
name|hdr
operator|.
name|e_machine
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|ELF_MACHINE_OK
argument_list|(
name|machine
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Looks good. */
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|elf_detach
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|sig
decl_stmt|;
if|if
condition|(
name|g_pid
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Forward any pending signals. SIGSTOP is generated by ptrace 		 * itself, so ignore it. 		 */
name|sig
operator|=
name|WIFSTOPPED
argument_list|(
name|g_status
argument_list|)
condition|?
name|WSTOPSIG
argument_list|(
name|g_status
argument_list|)
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|sig
operator|==
name|SIGSTOP
condition|)
name|sig
operator|=
literal|0
expr_stmt|;
name|ptrace
argument_list|(
name|PT_DETACH
argument_list|,
name|g_pid
argument_list|,
operator|(
name|caddr_t
operator|)
literal|1
argument_list|,
name|sig
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Write an ELF coredump for the given pid to the given fd.  */
end_comment

begin_function
specifier|static
name|void
name|elf_coredump
parameter_list|(
name|int
name|efd
parameter_list|,
name|int
name|fd
parameter_list|,
name|pid_t
name|pid
parameter_list|)
block|{
name|vm_map_entry_t
name|map
decl_stmt|;
name|struct
name|sseg_closure
name|seginfo
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|sb
decl_stmt|;
name|void
modifier|*
name|hdr
decl_stmt|;
name|size_t
name|hdrsize
decl_stmt|,
name|notesz
decl_stmt|,
name|segoff
decl_stmt|;
name|ssize_t
name|n
decl_stmt|,
name|old_len
decl_stmt|;
name|Elf_Phdr
modifier|*
name|php
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Attach to process to dump. */
name|g_pid
operator|=
name|pid
expr_stmt|;
if|if
condition|(
name|atexit
argument_list|(
name|elf_detach
argument_list|)
operator|!=
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"atexit"
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|ptrace
argument_list|(
name|PT_ATTACH
argument_list|,
name|pid
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"PT_ATTACH"
argument_list|)
expr_stmt|;
if|if
condition|(
name|waitpid
argument_list|(
name|pid
argument_list|,
operator|&
name|g_status
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"waitpid"
argument_list|)
expr_stmt|;
comment|/* Get the program's memory map. */
name|map
operator|=
name|readmap
argument_list|(
name|pid
argument_list|)
expr_stmt|;
comment|/* Size the program segments. */
name|seginfo
operator|.
name|count
operator|=
literal|0
expr_stmt|;
name|seginfo
operator|.
name|size
operator|=
literal|0
expr_stmt|;
name|each_writable_segment
argument_list|(
name|map
argument_list|,
name|cb_size_segment
argument_list|,
operator|&
name|seginfo
argument_list|)
expr_stmt|;
comment|/* 	 * Build the header and the notes using sbuf and write to the file. 	 */
name|sb
operator|=
name|sbuf_new_auto
argument_list|()
expr_stmt|;
name|hdrsize
operator|=
sizeof|sizeof
argument_list|(
name|Elf_Ehdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|Elf_Phdr
argument_list|)
operator|*
operator|(
literal|1
operator|+
name|seginfo
operator|.
name|count
operator|)
expr_stmt|;
comment|/* Start header + notes section. */
name|sbuf_start_section
argument_list|(
name|sb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Make empty header subsection. */
name|sbuf_start_section
argument_list|(
name|sb
argument_list|,
operator|&
name|old_len
argument_list|)
expr_stmt|;
name|sbuf_putc
argument_list|(
name|sb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sbuf_end_section
argument_list|(
name|sb
argument_list|,
name|old_len
argument_list|,
name|hdrsize
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Put notes. */
name|elf_putnotes
argument_list|(
name|pid
argument_list|,
name|sb
argument_list|,
operator|&
name|notesz
argument_list|)
expr_stmt|;
comment|/* Align up to a page boundary for the program segments. */
name|sbuf_end_section
argument_list|(
name|sb
argument_list|,
operator|-
literal|1
argument_list|,
name|PAGE_SIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sbuf_finish
argument_list|(
name|sb
argument_list|)
operator|!=
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"sbuf_finish"
argument_list|)
expr_stmt|;
name|hdr
operator|=
name|sbuf_data
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|segoff
operator|=
name|sbuf_len
argument_list|(
name|sb
argument_list|)
expr_stmt|;
comment|/* Fill in the header. */
name|elf_puthdr
argument_list|(
name|efd
argument_list|,
name|pid
argument_list|,
name|map
argument_list|,
name|hdr
argument_list|,
name|hdrsize
argument_list|,
name|notesz
argument_list|,
name|segoff
argument_list|,
name|seginfo
operator|.
name|count
argument_list|)
expr_stmt|;
name|n
operator|=
name|write
argument_list|(
name|fd
argument_list|,
name|hdr
argument_list|,
name|segoff
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"write"
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
name|segoff
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"short write"
argument_list|)
expr_stmt|;
comment|/* Write the contents of all of the writable segments. */
name|php
operator|=
operator|(
name|Elf_Phdr
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|hdr
operator|+
sizeof|sizeof
argument_list|(
name|Elf_Ehdr
argument_list|)
operator|)
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|seginfo
operator|.
name|count
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ptrace_io_desc
name|iorequest
decl_stmt|;
name|uintmax_t
name|nleft
init|=
name|php
operator|->
name|p_filesz
decl_stmt|;
name|iorequest
operator|.
name|piod_op
operator|=
name|PIOD_READ_D
expr_stmt|;
name|iorequest
operator|.
name|piod_offs
operator|=
operator|(
name|caddr_t
operator|)
operator|(
name|uintptr_t
operator|)
name|php
operator|->
name|p_vaddr
expr_stmt|;
while|while
condition|(
name|nleft
operator|>
literal|0
condition|)
block|{
name|char
name|buf
index|[
literal|8
operator|*
literal|1024
index|]
decl_stmt|;
name|size_t
name|nwant
decl_stmt|;
name|ssize_t
name|ngot
decl_stmt|;
if|if
condition|(
name|nleft
operator|>
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
condition|)
name|nwant
operator|=
sizeof|sizeof
name|buf
expr_stmt|;
else|else
name|nwant
operator|=
name|nleft
expr_stmt|;
name|iorequest
operator|.
name|piod_addr
operator|=
name|buf
expr_stmt|;
name|iorequest
operator|.
name|piod_len
operator|=
name|nwant
expr_stmt|;
name|ptrace
argument_list|(
name|PT_IO
argument_list|,
name|pid
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|iorequest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ngot
operator|=
name|iorequest
operator|.
name|piod_len
expr_stmt|;
if|if
condition|(
operator|(
name|size_t
operator|)
name|ngot
operator|<
name|nwant
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"short read wanted %zu, got %zd"
argument_list|,
name|nwant
argument_list|,
name|ngot
argument_list|)
expr_stmt|;
name|ngot
operator|=
name|write
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
name|nwant
argument_list|)
expr_stmt|;
if|if
condition|(
name|ngot
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"write of segment %d failed"
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|size_t
operator|)
name|ngot
operator|!=
name|nwant
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"short write"
argument_list|)
expr_stmt|;
name|nleft
operator|-=
name|nwant
expr_stmt|;
name|iorequest
operator|.
name|piod_offs
operator|+=
name|ngot
expr_stmt|;
block|}
name|php
operator|++
expr_stmt|;
block|}
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|freemap
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * A callback for each_writable_segment() to write out the segment's  * program header entry.  */
end_comment

begin_function
specifier|static
name|void
name|cb_put_phdr
parameter_list|(
name|vm_map_entry_t
name|entry
parameter_list|,
name|void
modifier|*
name|closure
parameter_list|)
block|{
name|struct
name|phdr_closure
modifier|*
name|phc
init|=
operator|(
expr|struct
name|phdr_closure
operator|*
operator|)
name|closure
decl_stmt|;
name|Elf_Phdr
modifier|*
name|phdr
init|=
name|phc
operator|->
name|phdr
decl_stmt|;
name|phc
operator|->
name|offset
operator|=
name|round_page
argument_list|(
name|phc
operator|->
name|offset
argument_list|)
expr_stmt|;
name|phdr
operator|->
name|p_type
operator|=
name|PT_LOAD
expr_stmt|;
name|phdr
operator|->
name|p_offset
operator|=
name|phc
operator|->
name|offset
expr_stmt|;
name|phdr
operator|->
name|p_vaddr
operator|=
name|entry
operator|->
name|start
expr_stmt|;
name|phdr
operator|->
name|p_paddr
operator|=
literal|0
expr_stmt|;
name|phdr
operator|->
name|p_filesz
operator|=
name|phdr
operator|->
name|p_memsz
operator|=
name|entry
operator|->
name|end
operator|-
name|entry
operator|->
name|start
expr_stmt|;
name|phdr
operator|->
name|p_align
operator|=
name|PAGE_SIZE
expr_stmt|;
name|phdr
operator|->
name|p_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|protection
operator|&
name|VM_PROT_READ
condition|)
name|phdr
operator|->
name|p_flags
operator||=
name|PF_R
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|protection
operator|&
name|VM_PROT_WRITE
condition|)
name|phdr
operator|->
name|p_flags
operator||=
name|PF_W
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|protection
operator|&
name|VM_PROT_EXECUTE
condition|)
name|phdr
operator|->
name|p_flags
operator||=
name|PF_X
expr_stmt|;
name|phc
operator|->
name|offset
operator|+=
name|phdr
operator|->
name|p_filesz
expr_stmt|;
name|phc
operator|->
name|phdr
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * A callback for each_writable_segment() to gather information about  * the number of segments and their total size.  */
end_comment

begin_function
specifier|static
name|void
name|cb_size_segment
parameter_list|(
name|vm_map_entry_t
name|entry
parameter_list|,
name|void
modifier|*
name|closure
parameter_list|)
block|{
name|struct
name|sseg_closure
modifier|*
name|ssc
init|=
operator|(
expr|struct
name|sseg_closure
operator|*
operator|)
name|closure
decl_stmt|;
name|ssc
operator|->
name|count
operator|++
expr_stmt|;
name|ssc
operator|->
name|size
operator|+=
name|entry
operator|->
name|end
operator|-
name|entry
operator|->
name|start
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * For each segment in the given memory map, call the given function  * with a pointer to the map entry and some arbitrary caller-supplied  * data.  */
end_comment

begin_function
specifier|static
name|void
name|each_writable_segment
parameter_list|(
name|vm_map_entry_t
name|map
parameter_list|,
name|segment_callback
name|func
parameter_list|,
name|void
modifier|*
name|closure
parameter_list|)
block|{
name|vm_map_entry_t
name|entry
decl_stmt|;
for|for
control|(
name|entry
operator|=
name|map
init|;
name|entry
operator|!=
name|NULL
condition|;
name|entry
operator|=
name|entry
operator|->
name|next
control|)
call|(
modifier|*
name|func
call|)
argument_list|(
name|entry
argument_list|,
name|closure
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|elf_putnotes
parameter_list|(
name|pid_t
name|pid
parameter_list|,
name|struct
name|sbuf
modifier|*
name|sb
parameter_list|,
name|size_t
modifier|*
name|sizep
parameter_list|)
block|{
name|lwpid_t
modifier|*
name|tids
decl_stmt|;
name|size_t
name|threads
decl_stmt|,
name|old_len
decl_stmt|;
name|ssize_t
name|size
decl_stmt|;
name|int
name|i
decl_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|threads
operator|=
name|ptrace
argument_list|(
name|PT_GETNUMLWPS
argument_list|,
name|pid
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"PT_GETNUMLWPS"
argument_list|)
expr_stmt|;
name|tids
operator|=
name|malloc
argument_list|(
name|threads
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|tids
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tids
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|ptrace
argument_list|(
name|PT_GETLWPLIST
argument_list|,
name|pid
argument_list|,
operator|(
name|void
operator|*
operator|)
name|tids
argument_list|,
name|threads
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"PT_GETLWPLIST"
argument_list|)
expr_stmt|;
name|sbuf_start_section
argument_list|(
name|sb
argument_list|,
operator|&
name|old_len
argument_list|)
expr_stmt|;
name|elf_putnote
argument_list|(
name|NT_PRPSINFO
argument_list|,
name|elf_note_prpsinfo
argument_list|,
operator|&
name|pid
argument_list|,
name|sb
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|threads
condition|;
operator|++
name|i
control|)
block|{
name|elf_putnote
argument_list|(
name|NT_PRSTATUS
argument_list|,
name|elf_note_prstatus
argument_list|,
name|tids
operator|+
name|i
argument_list|,
name|sb
argument_list|)
expr_stmt|;
name|elf_putnote
argument_list|(
name|NT_FPREGSET
argument_list|,
name|elf_note_fpregset
argument_list|,
name|tids
operator|+
name|i
argument_list|,
name|sb
argument_list|)
expr_stmt|;
name|elf_putnote
argument_list|(
name|NT_THRMISC
argument_list|,
name|elf_note_thrmisc
argument_list|,
name|tids
operator|+
name|i
argument_list|,
name|sb
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__i386__
argument_list|)
operator|||
name|defined
argument_list|(
name|__amd64__
argument_list|)
name|elf_putnote
argument_list|(
name|NT_X86_XSTATE
argument_list|,
name|elf_note_x86_xstate
argument_list|,
name|tids
operator|+
name|i
argument_list|,
name|sb
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|__powerpc__
argument_list|)
name|elf_putnote
argument_list|(
name|NT_PPC_VMX
argument_list|,
name|elf_note_powerpc_vmx
argument_list|,
name|tids
operator|+
name|i
argument_list|,
name|sb
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
ifndef|#
directive|ifndef
name|ELFCORE_COMPAT_32
name|elf_putnote
argument_list|(
name|NT_PROCSTAT_PROC
argument_list|,
name|elf_note_procstat_proc
argument_list|,
operator|&
name|pid
argument_list|,
name|sb
argument_list|)
expr_stmt|;
name|elf_putnote
argument_list|(
name|NT_PROCSTAT_FILES
argument_list|,
name|elf_note_procstat_files
argument_list|,
operator|&
name|pid
argument_list|,
name|sb
argument_list|)
expr_stmt|;
name|elf_putnote
argument_list|(
name|NT_PROCSTAT_VMMAP
argument_list|,
name|elf_note_procstat_vmmap
argument_list|,
operator|&
name|pid
argument_list|,
name|sb
argument_list|)
expr_stmt|;
name|elf_putnote
argument_list|(
name|NT_PROCSTAT_GROUPS
argument_list|,
name|elf_note_procstat_groups
argument_list|,
operator|&
name|pid
argument_list|,
name|sb
argument_list|)
expr_stmt|;
name|elf_putnote
argument_list|(
name|NT_PROCSTAT_UMASK
argument_list|,
name|elf_note_procstat_umask
argument_list|,
operator|&
name|pid
argument_list|,
name|sb
argument_list|)
expr_stmt|;
name|elf_putnote
argument_list|(
name|NT_PROCSTAT_RLIMIT
argument_list|,
name|elf_note_procstat_rlimit
argument_list|,
operator|&
name|pid
argument_list|,
name|sb
argument_list|)
expr_stmt|;
name|elf_putnote
argument_list|(
name|NT_PROCSTAT_OSREL
argument_list|,
name|elf_note_procstat_osrel
argument_list|,
operator|&
name|pid
argument_list|,
name|sb
argument_list|)
expr_stmt|;
name|elf_putnote
argument_list|(
name|NT_PROCSTAT_PSSTRINGS
argument_list|,
name|elf_note_procstat_psstrings
argument_list|,
operator|&
name|pid
argument_list|,
name|sb
argument_list|)
expr_stmt|;
name|elf_putnote
argument_list|(
name|NT_PROCSTAT_AUXV
argument_list|,
name|elf_note_procstat_auxv
argument_list|,
operator|&
name|pid
argument_list|,
name|sb
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|size
operator|=
name|sbuf_end_section
argument_list|(
name|sb
argument_list|,
name|old_len
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"sbuf_end_section"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tids
argument_list|)
expr_stmt|;
operator|*
name|sizep
operator|=
name|size
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Emit one note section to sbuf.  */
end_comment

begin_function
specifier|static
name|void
name|elf_putnote
parameter_list|(
name|int
name|type
parameter_list|,
name|notefunc_t
name|notefunc
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|sbuf
modifier|*
name|sb
parameter_list|)
block|{
name|Elf_Note
name|note
decl_stmt|;
name|size_t
name|descsz
decl_stmt|;
name|ssize_t
name|old_len
decl_stmt|;
name|void
modifier|*
name|desc
decl_stmt|;
name|desc
operator|=
name|notefunc
argument_list|(
name|arg
argument_list|,
operator|&
name|descsz
argument_list|)
expr_stmt|;
name|note
operator|.
name|n_namesz
operator|=
literal|8
expr_stmt|;
comment|/* strlen("FreeBSD") + 1 */
name|note
operator|.
name|n_descsz
operator|=
name|descsz
expr_stmt|;
name|note
operator|.
name|n_type
operator|=
name|type
expr_stmt|;
name|sbuf_bcat
argument_list|(
name|sb
argument_list|,
operator|&
name|note
argument_list|,
sizeof|sizeof
argument_list|(
name|note
argument_list|)
argument_list|)
expr_stmt|;
name|sbuf_start_section
argument_list|(
name|sb
argument_list|,
operator|&
name|old_len
argument_list|)
expr_stmt|;
name|sbuf_bcat
argument_list|(
name|sb
argument_list|,
literal|"FreeBSD"
argument_list|,
name|note
operator|.
name|n_namesz
argument_list|)
expr_stmt|;
name|sbuf_end_section
argument_list|(
name|sb
argument_list|,
name|old_len
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf32_Size
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|descsz
operator|==
literal|0
condition|)
return|return;
name|sbuf_start_section
argument_list|(
name|sb
argument_list|,
operator|&
name|old_len
argument_list|)
expr_stmt|;
name|sbuf_bcat
argument_list|(
name|sb
argument_list|,
name|desc
argument_list|,
name|descsz
argument_list|)
expr_stmt|;
name|sbuf_end_section
argument_list|(
name|sb
argument_list|,
name|old_len
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf32_Size
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|desc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Generate the ELF coredump header.  */
end_comment

begin_function
specifier|static
name|void
name|elf_puthdr
parameter_list|(
name|int
name|efd
parameter_list|,
name|pid_t
name|pid
parameter_list|,
name|vm_map_entry_t
name|map
parameter_list|,
name|void
modifier|*
name|hdr
parameter_list|,
name|size_t
name|hdrsize
parameter_list|,
name|size_t
name|notesz
parameter_list|,
name|size_t
name|segoff
parameter_list|,
name|int
name|numsegs
parameter_list|)
block|{
name|Elf_Ehdr
modifier|*
name|ehdr
decl_stmt|,
name|binhdr
decl_stmt|;
name|Elf_Phdr
modifier|*
name|phdr
decl_stmt|;
name|struct
name|phdr_closure
name|phc
decl_stmt|;
name|ssize_t
name|cnt
decl_stmt|;
name|cnt
operator|=
name|read
argument_list|(
name|efd
argument_list|,
operator|&
name|binhdr
argument_list|,
sizeof|sizeof
argument_list|(
name|binhdr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnt
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"Failed to re-read ELF header"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cnt
operator|!=
sizeof|sizeof
argument_list|(
name|binhdr
argument_list|)
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Failed to re-read ELF header"
argument_list|)
expr_stmt|;
name|ehdr
operator|=
operator|(
name|Elf_Ehdr
operator|*
operator|)
name|hdr
expr_stmt|;
name|phdr
operator|=
operator|(
name|Elf_Phdr
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|hdr
operator|+
sizeof|sizeof
argument_list|(
name|Elf_Ehdr
argument_list|)
operator|)
expr_stmt|;
name|ehdr
operator|->
name|e_ident
index|[
name|EI_MAG0
index|]
operator|=
name|ELFMAG0
expr_stmt|;
name|ehdr
operator|->
name|e_ident
index|[
name|EI_MAG1
index|]
operator|=
name|ELFMAG1
expr_stmt|;
name|ehdr
operator|->
name|e_ident
index|[
name|EI_MAG2
index|]
operator|=
name|ELFMAG2
expr_stmt|;
name|ehdr
operator|->
name|e_ident
index|[
name|EI_MAG3
index|]
operator|=
name|ELFMAG3
expr_stmt|;
name|ehdr
operator|->
name|e_ident
index|[
name|EI_CLASS
index|]
operator|=
name|ELF_CLASS
expr_stmt|;
name|ehdr
operator|->
name|e_ident
index|[
name|EI_DATA
index|]
operator|=
name|ELF_DATA
expr_stmt|;
name|ehdr
operator|->
name|e_ident
index|[
name|EI_VERSION
index|]
operator|=
name|EV_CURRENT
expr_stmt|;
name|ehdr
operator|->
name|e_ident
index|[
name|EI_OSABI
index|]
operator|=
name|ELFOSABI_FREEBSD
expr_stmt|;
name|ehdr
operator|->
name|e_ident
index|[
name|EI_ABIVERSION
index|]
operator|=
literal|0
expr_stmt|;
name|ehdr
operator|->
name|e_ident
index|[
name|EI_PAD
index|]
operator|=
literal|0
expr_stmt|;
name|ehdr
operator|->
name|e_type
operator|=
name|ET_CORE
expr_stmt|;
name|ehdr
operator|->
name|e_machine
operator|=
name|binhdr
operator|.
name|e_machine
expr_stmt|;
name|ehdr
operator|->
name|e_version
operator|=
name|EV_CURRENT
expr_stmt|;
name|ehdr
operator|->
name|e_entry
operator|=
literal|0
expr_stmt|;
name|ehdr
operator|->
name|e_phoff
operator|=
sizeof|sizeof
argument_list|(
name|Elf_Ehdr
argument_list|)
expr_stmt|;
name|ehdr
operator|->
name|e_flags
operator|=
name|binhdr
operator|.
name|e_flags
expr_stmt|;
name|ehdr
operator|->
name|e_ehsize
operator|=
sizeof|sizeof
argument_list|(
name|Elf_Ehdr
argument_list|)
expr_stmt|;
name|ehdr
operator|->
name|e_phentsize
operator|=
sizeof|sizeof
argument_list|(
name|Elf_Phdr
argument_list|)
expr_stmt|;
name|ehdr
operator|->
name|e_phnum
operator|=
name|numsegs
operator|+
literal|1
expr_stmt|;
name|ehdr
operator|->
name|e_shentsize
operator|=
sizeof|sizeof
argument_list|(
name|Elf_Shdr
argument_list|)
expr_stmt|;
name|ehdr
operator|->
name|e_shnum
operator|=
literal|0
expr_stmt|;
name|ehdr
operator|->
name|e_shstrndx
operator|=
name|SHN_UNDEF
expr_stmt|;
comment|/* 	 * Fill in the program header entries. 	 */
comment|/* The note segement. */
name|phdr
operator|->
name|p_type
operator|=
name|PT_NOTE
expr_stmt|;
name|phdr
operator|->
name|p_offset
operator|=
name|hdrsize
expr_stmt|;
name|phdr
operator|->
name|p_vaddr
operator|=
literal|0
expr_stmt|;
name|phdr
operator|->
name|p_paddr
operator|=
literal|0
expr_stmt|;
name|phdr
operator|->
name|p_filesz
operator|=
name|notesz
expr_stmt|;
name|phdr
operator|->
name|p_memsz
operator|=
literal|0
expr_stmt|;
name|phdr
operator|->
name|p_flags
operator|=
name|PF_R
expr_stmt|;
name|phdr
operator|->
name|p_align
operator|=
sizeof|sizeof
argument_list|(
name|Elf32_Size
argument_list|)
expr_stmt|;
name|phdr
operator|++
expr_stmt|;
comment|/* All the writable segments from the program. */
name|phc
operator|.
name|phdr
operator|=
name|phdr
expr_stmt|;
name|phc
operator|.
name|offset
operator|=
name|segoff
expr_stmt|;
name|each_writable_segment
argument_list|(
name|map
argument_list|,
name|cb_put_phdr
argument_list|,
operator|&
name|phc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Free the memory map.  */
end_comment

begin_function
specifier|static
name|void
name|freemap
parameter_list|(
name|vm_map_entry_t
name|map
parameter_list|)
block|{
while|while
condition|(
name|map
operator|!=
name|NULL
condition|)
block|{
name|vm_map_entry_t
name|next
init|=
name|map
operator|->
name|next
decl_stmt|;
name|free
argument_list|(
name|map
argument_list|)
expr_stmt|;
name|map
operator|=
name|next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Read the process's memory map using kinfo_getvmmap(), and return a list of  * VM map entries.  Only the non-device read/writable segments are  * returned.  The map entries in the list aren't fully filled in; only  * the items we need are present.  */
end_comment

begin_function
specifier|static
name|vm_map_entry_t
name|readmap
parameter_list|(
name|pid_t
name|pid
parameter_list|)
block|{
name|vm_map_entry_t
name|ent
decl_stmt|,
modifier|*
name|linkp
decl_stmt|,
name|map
decl_stmt|;
name|struct
name|kinfo_vmentry
modifier|*
name|vmentl
decl_stmt|,
modifier|*
name|kve
decl_stmt|;
name|int
name|i
decl_stmt|,
name|nitems
decl_stmt|;
name|vmentl
operator|=
name|kinfo_getvmmap
argument_list|(
name|pid
argument_list|,
operator|&
name|nitems
argument_list|)
expr_stmt|;
if|if
condition|(
name|vmentl
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"cannot retrieve mappings for %u process"
argument_list|,
name|pid
argument_list|)
expr_stmt|;
name|map
operator|=
name|NULL
expr_stmt|;
name|linkp
operator|=
operator|&
name|map
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitems
condition|;
name|i
operator|++
control|)
block|{
name|kve
operator|=
operator|&
name|vmentl
index|[
name|i
index|]
expr_stmt|;
comment|/* 		 * Ignore 'malformed' segments or ones representing memory 		 * mapping with MAP_NOCORE on. 		 * If the 'full' support is disabled, just dump the most 		 * meaningful data segments. 		 */
if|if
condition|(
operator|(
name|kve
operator|->
name|kve_protection
operator|&
name|KVME_PROT_READ
operator|)
operator|==
literal|0
operator|||
operator|(
name|kve
operator|->
name|kve_flags
operator|&
name|KVME_FLAG_NOCOREDUMP
operator|)
operator|!=
literal|0
operator|||
name|kve
operator|->
name|kve_type
operator|==
name|KVME_TYPE_DEAD
operator|||
name|kve
operator|->
name|kve_type
operator|==
name|KVME_TYPE_UNKNOWN
operator|||
operator|(
operator|(
name|pflags
operator|&
name|PFLAGS_FULL
operator|)
operator|==
literal|0
operator|&&
name|kve
operator|->
name|kve_type
operator|!=
name|KVME_TYPE_DEFAULT
operator|&&
name|kve
operator|->
name|kve_type
operator|!=
name|KVME_TYPE_VNODE
operator|&&
name|kve
operator|->
name|kve_type
operator|!=
name|KVME_TYPE_SWAP
operator|&&
name|kve
operator|->
name|kve_type
operator|!=
name|KVME_TYPE_PHYS
operator|)
condition|)
continue|continue;
name|ent
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ent
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ent
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
name|ent
operator|->
name|start
operator|=
operator|(
name|vm_offset_t
operator|)
name|kve
operator|->
name|kve_start
expr_stmt|;
name|ent
operator|->
name|end
operator|=
operator|(
name|vm_offset_t
operator|)
name|kve
operator|->
name|kve_end
expr_stmt|;
name|ent
operator|->
name|protection
operator|=
name|VM_PROT_READ
operator||
name|VM_PROT_WRITE
expr_stmt|;
if|if
condition|(
operator|(
name|kve
operator|->
name|kve_protection
operator|&
name|KVME_PROT_EXEC
operator|)
operator|!=
literal|0
condition|)
name|ent
operator|->
name|protection
operator||=
name|VM_PROT_EXECUTE
expr_stmt|;
operator|*
name|linkp
operator|=
name|ent
expr_stmt|;
name|linkp
operator|=
operator|&
name|ent
operator|->
name|next
expr_stmt|;
block|}
name|free
argument_list|(
name|vmentl
argument_list|)
expr_stmt|;
return|return
operator|(
name|map
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Miscellaneous note out functions.  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|elf_note_prpsinfo
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|size_t
modifier|*
name|sizep
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|pid_t
name|pid
decl_stmt|;
name|elfcore_prpsinfo_t
modifier|*
name|psinfo
decl_stmt|;
name|struct
name|kinfo_proc
name|kip
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|int
name|name
index|[
literal|4
index|]
decl_stmt|;
name|pid
operator|=
operator|*
operator|(
name|pid_t
operator|*
operator|)
name|arg
expr_stmt|;
name|psinfo
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|psinfo
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|psinfo
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
name|psinfo
operator|->
name|pr_version
operator|=
name|PRPSINFO_VERSION
expr_stmt|;
name|psinfo
operator|->
name|pr_psinfosz
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|psinfo
argument_list|)
expr_stmt|;
name|name
index|[
literal|0
index|]
operator|=
name|CTL_KERN
expr_stmt|;
name|name
index|[
literal|1
index|]
operator|=
name|KERN_PROC
expr_stmt|;
name|name
index|[
literal|2
index|]
operator|=
name|KERN_PROC_PID
expr_stmt|;
name|name
index|[
literal|3
index|]
operator|=
name|pid
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
name|kip
argument_list|)
expr_stmt|;
if|if
condition|(
name|sysctl
argument_list|(
name|name
argument_list|,
literal|4
argument_list|,
operator|&
name|kip
argument_list|,
operator|&
name|len
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"kern.proc.pid.%u"
argument_list|,
name|pid
argument_list|)
expr_stmt|;
if|if
condition|(
name|kip
operator|.
name|ki_pid
operator|!=
name|pid
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"kern.proc.pid.%u"
argument_list|,
name|pid
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|psinfo
operator|->
name|pr_fname
argument_list|,
name|kip
operator|.
name|ki_comm
argument_list|,
sizeof|sizeof
argument_list|(
name|psinfo
operator|->
name|pr_fname
argument_list|)
argument_list|)
expr_stmt|;
name|name
index|[
literal|2
index|]
operator|=
name|KERN_PROC_ARGS
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
name|psinfo
operator|->
name|pr_psargs
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|sysctl
argument_list|(
name|name
argument_list|,
literal|4
argument_list|,
name|psinfo
operator|->
name|pr_psargs
argument_list|,
operator|&
name|len
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
operator|&&
name|len
operator|>
literal|0
condition|)
block|{
name|cp
operator|=
name|psinfo
operator|->
name|pr_psargs
expr_stmt|;
name|end
operator|=
name|cp
operator|+
name|len
operator|-
literal|1
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|cp
operator|=
name|memchr
argument_list|(
name|cp
argument_list|,
literal|'\0'
argument_list|,
name|end
operator|-
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
break|break;
operator|*
name|cp
operator|=
literal|' '
expr_stmt|;
block|}
block|}
else|else
name|strlcpy
argument_list|(
name|psinfo
operator|->
name|pr_psargs
argument_list|,
name|kip
operator|.
name|ki_comm
argument_list|,
sizeof|sizeof
argument_list|(
name|psinfo
operator|->
name|pr_psargs
argument_list|)
argument_list|)
expr_stmt|;
name|psinfo
operator|->
name|pr_pid
operator|=
name|pid
expr_stmt|;
operator|*
name|sizep
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|psinfo
argument_list|)
expr_stmt|;
return|return
operator|(
name|psinfo
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|elf_note_prstatus
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|size_t
modifier|*
name|sizep
parameter_list|)
block|{
name|lwpid_t
name|tid
decl_stmt|;
name|elfcore_prstatus_t
modifier|*
name|status
decl_stmt|;
name|struct
name|reg
name|greg
decl_stmt|;
name|tid
operator|=
operator|*
operator|(
name|lwpid_t
operator|*
operator|)
name|arg
expr_stmt|;
name|status
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|status
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
name|status
operator|->
name|pr_version
operator|=
name|PRSTATUS_VERSION
expr_stmt|;
name|status
operator|->
name|pr_statussz
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|status
argument_list|)
expr_stmt|;
name|status
operator|->
name|pr_gregsetsz
operator|=
sizeof|sizeof
argument_list|(
name|elfcore_gregset_t
argument_list|)
expr_stmt|;
name|status
operator|->
name|pr_fpregsetsz
operator|=
sizeof|sizeof
argument_list|(
name|elfcore_fpregset_t
argument_list|)
expr_stmt|;
name|status
operator|->
name|pr_osreldate
operator|=
name|__FreeBSD_version
expr_stmt|;
name|status
operator|->
name|pr_pid
operator|=
name|tid
expr_stmt|;
name|ptrace
argument_list|(
name|PT_GETREGS
argument_list|,
name|tid
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|greg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|elf_convert_gregset
argument_list|(
operator|&
name|status
operator|->
name|pr_reg
argument_list|,
operator|&
name|greg
argument_list|)
expr_stmt|;
operator|*
name|sizep
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|status
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|elf_note_fpregset
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|size_t
modifier|*
name|sizep
parameter_list|)
block|{
name|lwpid_t
name|tid
decl_stmt|;
name|elfcore_fpregset_t
modifier|*
name|fpregset
decl_stmt|;
name|fpregset_t
name|fpreg
decl_stmt|;
name|tid
operator|=
operator|*
operator|(
name|lwpid_t
operator|*
operator|)
name|arg
expr_stmt|;
name|fpregset
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|fpregset
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fpregset
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
name|ptrace
argument_list|(
name|PT_GETFPREGS
argument_list|,
name|tid
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|fpreg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|elf_convert_fpregset
argument_list|(
name|fpregset
argument_list|,
operator|&
name|fpreg
argument_list|)
expr_stmt|;
operator|*
name|sizep
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|fpregset
argument_list|)
expr_stmt|;
return|return
operator|(
name|fpregset
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|elf_note_thrmisc
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|size_t
modifier|*
name|sizep
parameter_list|)
block|{
name|lwpid_t
name|tid
decl_stmt|;
name|struct
name|ptrace_lwpinfo
name|lwpinfo
decl_stmt|;
name|thrmisc_t
modifier|*
name|thrmisc
decl_stmt|;
name|tid
operator|=
operator|*
operator|(
name|lwpid_t
operator|*
operator|)
name|arg
expr_stmt|;
name|thrmisc
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|thrmisc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|thrmisc
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
name|ptrace
argument_list|(
name|PT_LWPINFO
argument_list|,
name|tid
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|lwpinfo
argument_list|,
sizeof|sizeof
argument_list|(
name|lwpinfo
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|thrmisc
operator|->
name|_pad
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|thrmisc
operator|->
name|_pad
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|thrmisc
operator|->
name|pr_tname
argument_list|,
name|lwpinfo
operator|.
name|pl_tdname
argument_list|)
expr_stmt|;
operator|*
name|sizep
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|thrmisc
argument_list|)
expr_stmt|;
return|return
operator|(
name|thrmisc
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__i386__
argument_list|)
operator|||
name|defined
argument_list|(
name|__amd64__
argument_list|)
end_if

begin_function
specifier|static
name|void
modifier|*
name|elf_note_x86_xstate
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|size_t
modifier|*
name|sizep
parameter_list|)
block|{
name|lwpid_t
name|tid
decl_stmt|;
name|char
modifier|*
name|xstate
decl_stmt|;
specifier|static
name|bool
name|xsave_checked
init|=
name|false
decl_stmt|;
specifier|static
name|struct
name|ptrace_xstate_info
name|info
decl_stmt|;
name|tid
operator|=
operator|*
operator|(
name|lwpid_t
operator|*
operator|)
name|arg
expr_stmt|;
if|if
condition|(
operator|!
name|xsave_checked
condition|)
block|{
if|if
condition|(
name|ptrace
argument_list|(
name|PT_GETXSTATE_INFO
argument_list|,
name|tid
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|info
argument_list|,
sizeof|sizeof
argument_list|(
name|info
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
name|info
operator|.
name|xsave_len
operator|=
literal|0
expr_stmt|;
name|xsave_checked
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|info
operator|.
name|xsave_len
operator|==
literal|0
condition|)
block|{
operator|*
name|sizep
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|xstate
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
name|info
operator|.
name|xsave_len
argument_list|)
expr_stmt|;
name|ptrace
argument_list|(
name|PT_GETXSTATE
argument_list|,
name|tid
argument_list|,
name|xstate
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
operator|(
name|uint64_t
operator|*
operator|)
operator|(
name|xstate
operator|+
name|X86_XSTATE_XCR0_OFFSET
operator|)
operator|=
name|info
operator|.
name|xsave_mask
expr_stmt|;
operator|*
name|sizep
operator|=
name|info
operator|.
name|xsave_len
expr_stmt|;
return|return
operator|(
name|xstate
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__powerpc__
argument_list|)
end_if

begin_function
specifier|static
name|void
modifier|*
name|elf_note_powerpc_vmx
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|size_t
modifier|*
name|sizep
parameter_list|)
block|{
name|lwpid_t
name|tid
decl_stmt|;
name|struct
name|vmxreg
modifier|*
name|vmx
decl_stmt|;
specifier|static
name|bool
name|has_vmx
init|=
name|true
decl_stmt|;
name|struct
name|vmxreg
name|info
decl_stmt|;
name|tid
operator|=
operator|*
operator|(
name|lwpid_t
operator|*
operator|)
name|arg
expr_stmt|;
if|if
condition|(
name|has_vmx
condition|)
block|{
if|if
condition|(
name|ptrace
argument_list|(
name|PT_GETVRREGS
argument_list|,
name|tid
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|info
argument_list|,
sizeof|sizeof
argument_list|(
name|info
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
name|has_vmx
operator|=
name|false
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|has_vmx
condition|)
block|{
operator|*
name|sizep
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|vmx
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|vmx
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|vmx
argument_list|,
operator|&
name|info
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|vmx
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|sizep
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|vmx
argument_list|)
expr_stmt|;
return|return
operator|(
name|vmx
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
modifier|*
name|procstat_sysctl
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|what
parameter_list|,
name|size_t
name|structsz
parameter_list|,
name|size_t
modifier|*
name|sizep
parameter_list|)
block|{
name|size_t
name|len
decl_stmt|;
name|pid_t
name|pid
decl_stmt|;
name|int
name|name
index|[
literal|4
index|]
decl_stmt|,
name|structsize
decl_stmt|;
name|void
modifier|*
name|buf
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|pid
operator|=
operator|*
operator|(
name|pid_t
operator|*
operator|)
name|arg
expr_stmt|;
name|structsize
operator|=
name|structsz
expr_stmt|;
name|name
index|[
literal|0
index|]
operator|=
name|CTL_KERN
expr_stmt|;
name|name
index|[
literal|1
index|]
operator|=
name|KERN_PROC
expr_stmt|;
name|name
index|[
literal|2
index|]
operator|=
name|what
expr_stmt|;
name|name
index|[
literal|3
index|]
operator|=
name|pid
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sysctl
argument_list|(
name|name
argument_list|,
literal|4
argument_list|,
name|NULL
argument_list|,
operator|&
name|len
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"kern.proc.%d.%u"
argument_list|,
name|what
argument_list|,
name|pid
argument_list|)
expr_stmt|;
name|buf
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|structsize
argument_list|)
operator|+
name|len
operator|*
literal|4
operator|/
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|structsize
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|structsize
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|buf
operator|+
sizeof|sizeof
argument_list|(
name|structsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|sysctl
argument_list|(
name|name
argument_list|,
literal|4
argument_list|,
name|p
argument_list|,
operator|&
name|len
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"kern.proc.%d.%u"
argument_list|,
name|what
argument_list|,
name|pid
argument_list|)
expr_stmt|;
operator|*
name|sizep
operator|=
sizeof|sizeof
argument_list|(
name|structsize
argument_list|)
operator|+
name|len
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|elf_note_procstat_proc
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|size_t
modifier|*
name|sizep
parameter_list|)
block|{
return|return
operator|(
name|procstat_sysctl
argument_list|(
name|arg
argument_list|,
name|KERN_PROC_PID
operator||
name|KERN_PROC_INC_THREAD
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|kinfo_proc
argument_list|)
argument_list|,
name|sizep
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|elf_note_procstat_files
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|size_t
modifier|*
name|sizep
parameter_list|)
block|{
return|return
operator|(
name|procstat_sysctl
argument_list|(
name|arg
argument_list|,
name|KERN_PROC_FILEDESC
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|kinfo_file
argument_list|)
argument_list|,
name|sizep
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|elf_note_procstat_vmmap
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|size_t
modifier|*
name|sizep
parameter_list|)
block|{
return|return
operator|(
name|procstat_sysctl
argument_list|(
name|arg
argument_list|,
name|KERN_PROC_VMMAP
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|kinfo_vmentry
argument_list|)
argument_list|,
name|sizep
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|elf_note_procstat_groups
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|size_t
modifier|*
name|sizep
parameter_list|)
block|{
return|return
operator|(
name|procstat_sysctl
argument_list|(
name|arg
argument_list|,
name|KERN_PROC_GROUPS
argument_list|,
sizeof|sizeof
argument_list|(
name|gid_t
argument_list|)
argument_list|,
name|sizep
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|elf_note_procstat_umask
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|size_t
modifier|*
name|sizep
parameter_list|)
block|{
return|return
operator|(
name|procstat_sysctl
argument_list|(
name|arg
argument_list|,
name|KERN_PROC_UMASK
argument_list|,
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|,
name|sizep
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|elf_note_procstat_osrel
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|size_t
modifier|*
name|sizep
parameter_list|)
block|{
return|return
operator|(
name|procstat_sysctl
argument_list|(
name|arg
argument_list|,
name|KERN_PROC_OSREL
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
name|sizep
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|elf_note_procstat_psstrings
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|size_t
modifier|*
name|sizep
parameter_list|)
block|{
return|return
operator|(
name|procstat_sysctl
argument_list|(
name|arg
argument_list|,
name|KERN_PROC_PS_STRINGS
argument_list|,
sizeof|sizeof
argument_list|(
name|vm_offset_t
argument_list|)
argument_list|,
name|sizep
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|elf_note_procstat_auxv
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|size_t
modifier|*
name|sizep
parameter_list|)
block|{
return|return
operator|(
name|procstat_sysctl
argument_list|(
name|arg
argument_list|,
name|KERN_PROC_AUXV
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf_Auxinfo
argument_list|)
argument_list|,
name|sizep
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|elf_note_procstat_rlimit
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|size_t
modifier|*
name|sizep
parameter_list|)
block|{
name|pid_t
name|pid
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|int
name|i
decl_stmt|,
name|name
index|[
literal|5
index|]
decl_stmt|,
name|structsize
decl_stmt|;
name|void
modifier|*
name|buf
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|pid
operator|=
operator|*
operator|(
name|pid_t
operator|*
operator|)
name|arg
expr_stmt|;
name|structsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|rlimit
argument_list|)
operator|*
name|RLIM_NLIMITS
expr_stmt|;
name|buf
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|structsize
argument_list|)
operator|+
name|structsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|structsize
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|structsize
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|buf
operator|+
sizeof|sizeof
argument_list|(
name|structsize
argument_list|)
expr_stmt|;
name|name
index|[
literal|0
index|]
operator|=
name|CTL_KERN
expr_stmt|;
name|name
index|[
literal|1
index|]
operator|=
name|KERN_PROC
expr_stmt|;
name|name
index|[
literal|2
index|]
operator|=
name|KERN_PROC_RLIMIT
expr_stmt|;
name|name
index|[
literal|3
index|]
operator|=
name|pid
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|rlimit
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RLIM_NLIMITS
condition|;
name|i
operator|++
control|)
block|{
name|name
index|[
literal|4
index|]
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|sysctl
argument_list|(
name|name
argument_list|,
literal|5
argument_list|,
name|p
argument_list|,
operator|&
name|len
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"kern.proc.rlimit.%u"
argument_list|,
name|pid
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|rlimit
argument_list|)
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"kern.proc.rlimit.%u: short read"
argument_list|,
name|pid
argument_list|)
expr_stmt|;
name|p
operator|+=
name|len
expr_stmt|;
block|}
operator|*
name|sizep
operator|=
sizeof|sizeof
argument_list|(
name|structsize
argument_list|)
operator|+
name|structsize
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_function_decl
name|struct
name|dumpers
name|__elfN
parameter_list|(
name|dump
parameter_list|)
init|=
block|{
name|elf_ident
operator|,
function_decl|elf_coredump
end_function_decl

begin_expr_stmt
unit|};
name|TEXT_SET
argument_list|(
name|dumpset
argument_list|,
name|__elfN
argument_list|(
name|dump
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

