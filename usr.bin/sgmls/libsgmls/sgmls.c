begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* sgmls.c:    Library for reading output of sgmls.     Written by James Clark (jjc@jclark.com). */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"std.h"
end_include

begin_include
include|#
directive|include
file|"sgmls.h"
end_include

begin_include
include|#
directive|include
file|"lineout.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|USE_PROTOTYPES
end_ifdef

begin_define
define|#
directive|define
name|P
parameter_list|(
name|parms
parameter_list|)
value|parms
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|P
parameter_list|(
name|parms
parameter_list|)
value|()
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_typedef
typedef|typedef
name|struct
name|sgmls_data
name|data_s
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|sgmls_notation
name|notation_s
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|sgmls_internal_entity
name|internal_entity_s
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|sgmls_external_entity
name|external_entity_s
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|sgmls_entity
name|entity_s
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|sgmls_attribute
name|attribute_s
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|sgmls_event
name|event_s
typedef|;
end_typedef

begin_comment
comment|/* lists are sorted in reverse order of level */
end_comment

begin_struct
struct|struct
name|list
block|{
name|int
name|subdoc_level
decl_stmt|;
comment|/* -1 if associated with finished subdoc */
name|struct
name|list
modifier|*
name|next
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|entity_list
block|{
name|int
name|subdoc_level
decl_stmt|;
name|struct
name|entity_list
modifier|*
name|next
decl_stmt|;
name|entity_s
name|entity
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|notation_list
block|{
name|int
name|subdoc_level
decl_stmt|;
name|struct
name|notation_list
modifier|*
name|next
decl_stmt|;
name|notation_s
name|notation
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|sgmls
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|unsigned
name|buf_size
decl_stmt|;
name|struct
name|entity_list
modifier|*
name|entities
decl_stmt|;
name|struct
name|notation_list
modifier|*
name|notations
decl_stmt|;
name|attribute_s
modifier|*
name|attributes
decl_stmt|;
name|unsigned
name|long
name|lineno
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
name|unsigned
name|filename_size
decl_stmt|;
name|unsigned
name|long
name|input_lineno
decl_stmt|;
name|int
name|subdoc_level
decl_stmt|;
name|char
modifier|*
modifier|*
name|files
decl_stmt|;
comment|/* from `f' commands */
name|int
name|nfiles
decl_stmt|;
name|char
modifier|*
name|sysid
decl_stmt|;
comment|/* from `s' command */
name|char
modifier|*
name|pubid
decl_stmt|;
comment|/* from `p' command */
block|}
struct|;
end_struct

begin_enum
enum|enum
name|error_code
block|{
name|E_ZERO
block|,
comment|/* Not an error */
name|E_NOMEM
block|,
comment|/* Out of memory */
name|E_BADESCAPE
block|,
comment|/* Bad escape */
name|E_NULESCAPE
block|,
comment|/* \000 other than in data */
name|E_NUL
block|,
comment|/* A null input character */
name|E_BADENTITY
block|,
comment|/* Reference to undefined entity */
name|E_INTERNALENTITY
block|,
comment|/* Internal entity when external was needed */
name|E_SYSTEM
block|,
comment|/* System input error */
name|E_COMMAND
block|,
comment|/* Bad command letter */
name|E_MISSING
block|,
comment|/* Missing arguments */
name|E_NUMBER
block|,
comment|/* Not a number */
name|E_ATTR
block|,
comment|/* Bad attribute type */
name|E_BADNOTATION
block|,
comment|/* Reference to undefined notation */
name|E_BADINTERNAL
block|,
comment|/* Bad internal entity type */
name|E_BADEXTERNAL
block|,
comment|/* Bad external entity type */
name|E_EOF
block|,
comment|/* EOF in middle of line */
name|E_SDATA
block|,
comment|/* \| other than in data */
name|E_LINELENGTH
comment|/* line longer than UNSIGNED_MAX */
block|}
enum|;
end_enum

begin_decl_stmt
specifier|static
name|char
modifier|*
name|errlist
index|[]
init|=
block|{
literal|0
block|,
literal|"Out of memory"
block|,
literal|"Bad escape"
block|,
literal|"\\0 escape not in data"
block|,
literal|"Nul character in input"
block|,
literal|"Reference to undefined entity"
block|,
literal|"Internal entity when external was needed"
block|,
literal|"System input error"
block|,
literal|"Bad command letter"
block|,
literal|"Missing arguments"
block|,
literal|"Not a number"
block|,
literal|"Bad attribute type"
block|,
literal|"Reference to undefined notation"
block|,
literal|"Bad internal entity type"
block|,
literal|"Bad external entity type"
block|,
literal|"EOF in middle of line"
block|,
literal|"\\| other than in data"
block|,
literal|"Too many V commands"
block|,
literal|"Input line too long"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|error
name|P
argument_list|(
operator|(
expr|enum
name|error_code
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|parse_data
name|P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|unsigned
name|long
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|parse_location
name|P
argument_list|(
operator|(
name|char
operator|*
operator|,
expr|struct
name|sgmls
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|parse_notation
name|P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|notation_s
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|parse_internal_entity
name|P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|internal_entity_s
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|parse_external_entity
name|P
argument_list|(
operator|(
name|char
operator|*
operator|,
expr|struct
name|sgmls
operator|*
operator|,
name|external_entity_s
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|parse_subdoc_entity
name|P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|external_entity_s
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|attribute_s
modifier|*
name|parse_attribute
name|P
argument_list|(
operator|(
expr|struct
name|sgmls
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|grow_datav
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|unescape
name|P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|unescape_file
name|P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|unescape1
name|P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|scan_token
name|P
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|count_args
name|P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|list
modifier|*
name|list_find
name|P
argument_list|(
operator|(
expr|struct
name|list
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|UNIV
name|xmalloc
name|P
argument_list|(
operator|(
name|unsigned
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|UNIV
name|xrealloc
name|P
argument_list|(
operator|(
name|UNIV
operator|,
name|unsigned
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|strsave
name|P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|read_line
name|P
argument_list|(
operator|(
expr|struct
name|sgmls
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|notation_s
modifier|*
name|lookup_notation
name|P
argument_list|(
operator|(
expr|struct
name|sgmls
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|entity_s
modifier|*
name|lookup_entity
name|P
argument_list|(
operator|(
expr|struct
name|sgmls
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|external_entity_s
modifier|*
name|lookup_external_entity
name|P
argument_list|(
operator|(
expr|struct
name|sgmls
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|define_external_entity
name|P
argument_list|(
operator|(
expr|struct
name|sgmls
operator|*
operator|,
name|external_entity_s
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|define_internal_entity
name|P
argument_list|(
operator|(
expr|struct
name|sgmls
operator|*
operator|,
name|internal_entity_s
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|define_notation
name|P
argument_list|(
operator|(
expr|struct
name|sgmls
operator|*
operator|,
name|notation_s
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|data_s
modifier|*
name|copy_data
name|P
argument_list|(
operator|(
name|data_s
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|list_finish_level
name|P
argument_list|(
operator|(
expr|struct
name|list
operator|*
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_attribute
name|P
argument_list|(
operator|(
name|attribute_s
operator|*
operator|*
operator|,
name|attribute_s
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|default_errhandler
name|P
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|xfree
parameter_list|(
name|s
parameter_list|)
value|do { if (s) free(s); } while (0)
end_define

begin_decl_stmt
specifier|static
name|sgmls_errhandler
modifier|*
name|errhandler
init|=
name|default_errhandler
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|input_lineno
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|data_s
modifier|*
name|datav
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|datav_size
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|struct
name|sgmls
modifier|*
name|sgmls_create
parameter_list|(
name|fp
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
name|struct
name|sgmls
modifier|*
name|sp
decl_stmt|;
name|sp
operator|=
operator|(
expr|struct
name|sgmls
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sgmls
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sp
condition|)
return|return
literal|0
return|;
name|sp
operator|->
name|fp
operator|=
name|fp
expr_stmt|;
name|sp
operator|->
name|entities
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|notations
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|attributes
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|lineno
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|filename
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|filename_size
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|input_lineno
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|buf_size
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|buf
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|subdoc_level
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|files
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|nfiles
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|sysid
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|pubid
operator|=
literal|0
expr_stmt|;
return|return
name|sp
return|;
block|}
end_function

begin_function
name|void
name|sgmls_free
parameter_list|(
name|sp
parameter_list|)
name|struct
name|sgmls
modifier|*
name|sp
decl_stmt|;
block|{
name|struct
name|entity_list
modifier|*
name|ep
decl_stmt|;
name|struct
name|notation_list
modifier|*
name|np
decl_stmt|;
if|if
condition|(
operator|!
name|sp
condition|)
return|return;
name|xfree
argument_list|(
name|sp
operator|->
name|filename
argument_list|)
expr_stmt|;
name|sgmls_free_attributes
argument_list|(
name|sp
operator|->
name|attributes
argument_list|)
expr_stmt|;
for|for
control|(
name|ep
operator|=
name|sp
operator|->
name|entities
init|;
name|ep
condition|;
control|)
block|{
name|struct
name|entity_list
modifier|*
name|tem
init|=
name|ep
operator|->
name|next
decl_stmt|;
if|if
condition|(
name|ep
operator|->
name|entity
operator|.
name|is_internal
condition|)
block|{
name|xfree
argument_list|(
name|ep
operator|->
name|entity
operator|.
name|u
operator|.
name|internal
operator|.
name|data
operator|.
name|s
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ep
operator|->
name|entity
operator|.
name|u
operator|.
name|internal
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ep
operator|->
name|entity
operator|.
name|u
operator|.
name|external
operator|.
name|nfilenames
condition|;
name|i
operator|++
control|)
name|xfree
argument_list|(
name|ep
operator|->
name|entity
operator|.
name|u
operator|.
name|external
operator|.
name|filenames
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|ep
operator|->
name|entity
operator|.
name|u
operator|.
name|external
operator|.
name|filenames
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|ep
operator|->
name|entity
operator|.
name|u
operator|.
name|external
operator|.
name|sysid
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|ep
operator|->
name|entity
operator|.
name|u
operator|.
name|external
operator|.
name|pubid
argument_list|)
expr_stmt|;
name|sgmls_free_attributes
argument_list|(
name|ep
operator|->
name|entity
operator|.
name|u
operator|.
name|external
operator|.
name|attributes
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ep
operator|->
name|entity
operator|.
name|u
operator|.
name|internal
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|ep
argument_list|)
expr_stmt|;
name|ep
operator|=
name|tem
expr_stmt|;
block|}
for|for
control|(
name|np
operator|=
name|sp
operator|->
name|notations
init|;
name|np
condition|;
control|)
block|{
name|struct
name|notation_list
modifier|*
name|tem
init|=
name|np
operator|->
name|next
decl_stmt|;
name|xfree
argument_list|(
name|np
operator|->
name|notation
operator|.
name|sysid
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|np
operator|->
name|notation
operator|.
name|pubid
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|np
operator|->
name|notation
operator|.
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|np
argument_list|)
expr_stmt|;
name|np
operator|=
name|tem
expr_stmt|;
block|}
name|xfree
argument_list|(
name|sp
operator|->
name|buf
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|sp
operator|->
name|pubid
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|sp
operator|->
name|sysid
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|files
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sp
operator|->
name|nfiles
condition|;
name|i
operator|++
control|)
name|free
argument_list|(
name|sp
operator|->
name|files
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sp
operator|->
name|files
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|datav
argument_list|)
expr_stmt|;
name|datav
operator|=
literal|0
expr_stmt|;
name|datav_size
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|sgmls_errhandler
modifier|*
name|sgmls_set_errhandler
parameter_list|(
name|handler
parameter_list|)
name|sgmls_errhandler
modifier|*
name|handler
decl_stmt|;
block|{
name|sgmls_errhandler
modifier|*
name|old
init|=
name|errhandler
decl_stmt|;
if|if
condition|(
name|handler
condition|)
name|errhandler
operator|=
name|handler
expr_stmt|;
return|return
name|old
return|;
block|}
end_function

begin_function
name|int
name|sgmls_next
parameter_list|(
name|sp
parameter_list|,
name|e
parameter_list|)
name|struct
name|sgmls
modifier|*
name|sp
decl_stmt|;
name|event_s
modifier|*
name|e
decl_stmt|;
block|{
while|while
condition|(
name|read_line
argument_list|(
name|sp
argument_list|)
condition|)
block|{
name|char
modifier|*
name|buf
init|=
name|sp
operator|->
name|buf
decl_stmt|;
name|e
operator|->
name|filename
operator|=
name|sp
operator|->
name|filename
expr_stmt|;
name|e
operator|->
name|lineno
operator|=
name|sp
operator|->
name|lineno
expr_stmt|;
switch|switch
condition|(
name|buf
index|[
literal|0
index|]
condition|)
block|{
case|case
name|DATA_CODE
case|:
name|e
operator|->
name|u
operator|.
name|data
operator|.
name|n
operator|=
name|parse_data
argument_list|(
name|buf
operator|+
literal|1
argument_list|,
operator|&
name|sp
operator|->
name|lineno
argument_list|)
expr_stmt|;
name|e
operator|->
name|u
operator|.
name|data
operator|.
name|v
operator|=
name|datav
expr_stmt|;
name|e
operator|->
name|type
operator|=
name|SGMLS_EVENT_DATA
expr_stmt|;
return|return
literal|1
return|;
case|case
name|START_CODE
case|:
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|e
operator|->
name|u
operator|.
name|start
operator|.
name|attributes
operator|=
name|sp
operator|->
name|attributes
expr_stmt|;
name|sp
operator|->
name|attributes
operator|=
literal|0
expr_stmt|;
name|e
operator|->
name|type
operator|=
name|SGMLS_EVENT_START
expr_stmt|;
name|p
operator|=
name|buf
operator|+
literal|1
expr_stmt|;
name|e
operator|->
name|u
operator|.
name|start
operator|.
name|gi
operator|=
name|scan_token
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
case|case
name|END_CODE
case|:
block|{
name|char
modifier|*
name|p
init|=
name|buf
operator|+
literal|1
decl_stmt|;
name|e
operator|->
name|type
operator|=
name|SGMLS_EVENT_END
expr_stmt|;
name|e
operator|->
name|u
operator|.
name|end
operator|.
name|gi
operator|=
name|scan_token
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
case|case
name|START_SUBDOC_CODE
case|:
case|case
name|END_SUBDOC_CODE
case|:
block|{
name|char
modifier|*
name|p
init|=
name|buf
operator|+
literal|1
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|scan_token
argument_list|(
operator|&
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
name|START_SUBDOC_CODE
condition|)
block|{
name|e
operator|->
name|u
operator|.
name|entity
operator|=
name|lookup_external_entity
argument_list|(
name|sp
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|sp
operator|->
name|subdoc_level
operator|++
expr_stmt|;
name|e
operator|->
name|type
operator|=
name|SGMLS_EVENT_SUBSTART
expr_stmt|;
block|}
else|else
block|{
name|e
operator|->
name|type
operator|=
name|SGMLS_EVENT_SUBEND
expr_stmt|;
name|list_finish_level
argument_list|(
operator|(
expr|struct
name|list
operator|*
operator|*
operator|)
operator|&
name|sp
operator|->
name|entities
argument_list|,
name|sp
operator|->
name|subdoc_level
argument_list|)
expr_stmt|;
name|list_finish_level
argument_list|(
operator|(
expr|struct
name|list
operator|*
operator|*
operator|)
operator|&
name|sp
operator|->
name|notations
argument_list|,
name|sp
operator|->
name|subdoc_level
argument_list|)
expr_stmt|;
name|sp
operator|->
name|subdoc_level
operator|--
expr_stmt|;
name|e
operator|->
name|u
operator|.
name|entity
operator|=
name|lookup_external_entity
argument_list|(
name|sp
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
case|case
name|ATTRIBUTE_CODE
case|:
name|add_attribute
argument_list|(
operator|&
name|sp
operator|->
name|attributes
argument_list|,
name|parse_attribute
argument_list|(
name|sp
argument_list|,
name|buf
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_ATTRIBUTE_CODE
case|:
block|{
name|char
modifier|*
name|p
init|=
name|buf
operator|+
literal|1
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|attribute_s
modifier|*
name|a
decl_stmt|;
name|external_entity_s
modifier|*
name|ext
decl_stmt|;
name|name
operator|=
name|scan_token
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
name|a
operator|=
name|parse_attribute
argument_list|(
name|sp
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|ext
operator|=
name|lookup_external_entity
argument_list|(
name|sp
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|add_attribute
argument_list|(
operator|&
name|ext
operator|->
name|attributes
argument_list|,
name|a
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|REFERENCE_ENTITY_CODE
case|:
block|{
name|char
modifier|*
name|p
init|=
name|buf
operator|+
literal|1
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
name|scan_token
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
name|e
operator|->
name|u
operator|.
name|entity
operator|=
name|lookup_external_entity
argument_list|(
name|sp
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|e
operator|->
name|type
operator|=
name|SGMLS_EVENT_ENTITY
expr_stmt|;
return|return
literal|1
return|;
block|}
case|case
name|DEFINE_NOTATION_CODE
case|:
block|{
name|notation_s
name|notation
decl_stmt|;
name|parse_notation
argument_list|(
name|buf
operator|+
literal|1
argument_list|,
operator|&
name|notation
argument_list|)
expr_stmt|;
name|define_notation
argument_list|(
name|sp
argument_list|,
operator|&
name|notation
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DEFINE_EXTERNAL_ENTITY_CODE
case|:
block|{
name|external_entity_s
name|external
decl_stmt|;
name|parse_external_entity
argument_list|(
name|buf
operator|+
literal|1
argument_list|,
name|sp
argument_list|,
operator|&
name|external
argument_list|)
expr_stmt|;
name|define_external_entity
argument_list|(
name|sp
argument_list|,
operator|&
name|external
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DEFINE_SUBDOC_ENTITY_CODE
case|:
block|{
name|external_entity_s
name|external
decl_stmt|;
name|parse_subdoc_entity
argument_list|(
name|buf
operator|+
literal|1
argument_list|,
operator|&
name|external
argument_list|)
expr_stmt|;
name|define_external_entity
argument_list|(
name|sp
argument_list|,
operator|&
name|external
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DEFINE_INTERNAL_ENTITY_CODE
case|:
block|{
name|internal_entity_s
name|internal
decl_stmt|;
name|parse_internal_entity
argument_list|(
name|buf
operator|+
literal|1
argument_list|,
operator|&
name|internal
argument_list|)
expr_stmt|;
name|define_internal_entity
argument_list|(
name|sp
argument_list|,
operator|&
name|internal
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PI_CODE
case|:
name|e
operator|->
name|u
operator|.
name|pi
operator|.
name|len
operator|=
name|unescape1
argument_list|(
name|buf
operator|+
literal|1
argument_list|)
expr_stmt|;
name|e
operator|->
name|u
operator|.
name|pi
operator|.
name|s
operator|=
name|buf
operator|+
literal|1
expr_stmt|;
name|e
operator|->
name|type
operator|=
name|SGMLS_EVENT_PI
expr_stmt|;
return|return
literal|1
return|;
case|case
name|LOCATION_CODE
case|:
name|parse_location
argument_list|(
name|buf
operator|+
literal|1
argument_list|,
name|sp
argument_list|)
expr_stmt|;
break|break;
case|case
name|APPINFO_CODE
case|:
name|e
operator|->
name|u
operator|.
name|appinfo
operator|=
name|unescape
argument_list|(
name|buf
operator|+
literal|1
argument_list|)
expr_stmt|;
name|e
operator|->
name|type
operator|=
name|SGMLS_EVENT_APPINFO
expr_stmt|;
return|return
literal|1
return|;
case|case
name|SYSID_CODE
case|:
name|sp
operator|->
name|sysid
operator|=
name|strsave
argument_list|(
name|unescape
argument_list|(
name|buf
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|PUBID_CODE
case|:
name|sp
operator|->
name|pubid
operator|=
name|strsave
argument_list|(
name|unescape
argument_list|(
name|buf
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FILE_CODE
case|:
name|sp
operator|->
name|files
operator|=
name|xrealloc
argument_list|(
name|sp
operator|->
name|files
argument_list|,
operator|(
name|sp
operator|->
name|nfiles
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|sp
operator|->
name|files
index|[
name|sp
operator|->
name|nfiles
index|]
operator|=
name|strsave
argument_list|(
name|unescape_file
argument_list|(
name|buf
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|sp
operator|->
name|nfiles
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
name|CONFORMING_CODE
case|:
name|e
operator|->
name|type
operator|=
name|SGMLS_EVENT_CONFORMING
expr_stmt|;
return|return
literal|1
return|;
default|default:
name|error
argument_list|(
name|E_COMMAND
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|parse_data
parameter_list|(
name|p
parameter_list|,
name|linenop
parameter_list|)
name|char
modifier|*
name|p
decl_stmt|;
name|unsigned
name|long
modifier|*
name|linenop
decl_stmt|;
block|{
name|int
name|n
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|start
init|=
name|p
decl_stmt|;
name|char
modifier|*
name|q
decl_stmt|;
name|int
name|is_sdata
init|=
literal|0
decl_stmt|;
comment|/* No need to copy before first escape. */
for|for
control|(
init|;
operator|*
name|p
operator|!=
literal|'\\'
operator|&&
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
empty_stmt|;
name|q
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\\'
condition|)
block|{
switch|switch
condition|(
operator|*
operator|++
name|p
condition|)
block|{
case|case
literal|'\\'
case|:
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
operator|*
name|q
operator|++
operator|=
name|RECHAR
expr_stmt|;
operator|*
name|linenop
operator|+=
literal|1
expr_stmt|;
name|p
operator|++
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
block|{
name|int
name|val
init|=
operator|*
name|p
operator|++
operator|-
literal|'0'
decl_stmt|;
if|if
condition|(
operator|*
name|p
operator|>=
literal|'0'
operator|&&
operator|*
name|p
operator|<=
literal|'7'
condition|)
block|{
name|val
operator|=
name|val
operator|*
literal|8
operator|+
operator|(
operator|*
name|p
operator|++
operator|-
literal|'0'
operator|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|>=
literal|'0'
operator|&&
operator|*
name|p
operator|<=
literal|'7'
condition|)
name|val
operator|=
name|val
operator|*
literal|8
operator|+
operator|(
operator|*
name|p
operator|++
operator|-
literal|'0'
operator|)
expr_stmt|;
block|}
operator|*
name|q
operator|++
operator|=
operator|(
name|char
operator|)
name|val
expr_stmt|;
block|}
break|break;
case|case
literal|'|'
case|:
if|if
condition|(
name|q
operator|>
name|start
operator|||
name|is_sdata
condition|)
block|{
if|if
condition|(
name|n
operator|>=
name|datav_size
condition|)
name|grow_datav
argument_list|()
expr_stmt|;
name|datav
index|[
name|n
index|]
operator|.
name|s
operator|=
name|start
expr_stmt|;
name|datav
index|[
name|n
index|]
operator|.
name|len
operator|=
name|q
operator|-
name|start
expr_stmt|;
name|datav
index|[
name|n
index|]
operator|.
name|is_sdata
operator|=
name|is_sdata
expr_stmt|;
name|n
operator|++
expr_stmt|;
block|}
name|is_sdata
operator|=
operator|!
name|is_sdata
expr_stmt|;
name|start
operator|=
name|q
expr_stmt|;
name|p
operator|++
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
name|E_BADESCAPE
argument_list|)
expr_stmt|;
block|}
block|}
else|else
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|q
operator|>
name|start
operator|||
name|is_sdata
condition|)
block|{
if|if
condition|(
name|n
operator|>=
name|datav_size
condition|)
name|grow_datav
argument_list|()
expr_stmt|;
name|datav
index|[
name|n
index|]
operator|.
name|s
operator|=
name|start
expr_stmt|;
name|datav
index|[
name|n
index|]
operator|.
name|len
operator|=
name|q
operator|-
name|start
expr_stmt|;
name|datav
index|[
name|n
index|]
operator|.
name|is_sdata
operator|=
name|is_sdata
expr_stmt|;
name|n
operator|++
expr_stmt|;
block|}
return|return
name|n
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|grow_datav
parameter_list|()
block|{
name|unsigned
name|size
init|=
name|datav_size
condition|?
literal|2
operator|*
name|datav_size
else|:
literal|2
decl_stmt|;
name|datav
operator|=
operator|(
name|data_s
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|UNIV
operator|)
name|datav
argument_list|,
name|size
operator|*
sizeof|sizeof
argument_list|(
name|data_s
argument_list|)
argument_list|)
expr_stmt|;
name|datav_size
operator|=
name|size
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|parse_location
parameter_list|(
name|s
parameter_list|,
name|sp
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|struct
name|sgmls
modifier|*
name|sp
decl_stmt|;
block|{
name|unsigned
name|size
decl_stmt|;
if|if
condition|(
operator|*
name|s
operator|<
literal|'0'
operator|||
operator|*
name|s
operator|>
literal|'9'
operator|||
name|sscanf
argument_list|(
name|s
argument_list|,
literal|"%lu"
argument_list|,
operator|&
name|sp
operator|->
name|lineno
argument_list|)
operator|!=
literal|1
condition|)
name|error
argument_list|(
name|E_NUMBER
argument_list|)
expr_stmt|;
do|do
block|{
operator|++
name|s
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|s
operator|>=
literal|'0'
operator|&&
operator|*
name|s
operator|<=
literal|'9'
condition|)
do|;
if|if
condition|(
operator|*
name|s
operator|!=
literal|' '
condition|)
return|return;
name|s
operator|++
expr_stmt|;
name|s
operator|=
name|unescape_file
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|size
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|size
operator|<=
name|sp
operator|->
name|filename_size
condition|)
name|strcpy
argument_list|(
name|sp
operator|->
name|filename
argument_list|,
name|s
argument_list|)
expr_stmt|;
else|else
block|{
name|sp
operator|->
name|filename
operator|=
name|xrealloc
argument_list|(
name|sp
operator|->
name|filename
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|sp
operator|->
name|filename
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|sp
operator|->
name|filename_size
operator|=
name|size
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|parse_notation
parameter_list|(
name|s
parameter_list|,
name|n
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|notation_s
modifier|*
name|n
decl_stmt|;
block|{
name|n
operator|->
name|name
operator|=
name|strsave
argument_list|(
name|scan_token
argument_list|(
operator|&
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|parse_internal_entity
parameter_list|(
name|s
parameter_list|,
name|e
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|internal_entity_s
modifier|*
name|e
decl_stmt|;
block|{
name|char
modifier|*
name|type
decl_stmt|;
name|e
operator|->
name|name
operator|=
name|strsave
argument_list|(
name|scan_token
argument_list|(
operator|&
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|scan_token
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|type
argument_list|,
literal|"CDATA"
argument_list|)
operator|==
literal|0
condition|)
name|e
operator|->
name|data
operator|.
name|is_sdata
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|type
argument_list|,
literal|"SDATA"
argument_list|)
operator|==
literal|0
condition|)
name|e
operator|->
name|data
operator|.
name|is_sdata
operator|=
literal|1
expr_stmt|;
else|else
name|error
argument_list|(
name|E_BADINTERNAL
argument_list|)
expr_stmt|;
name|e
operator|->
name|data
operator|.
name|len
operator|=
name|unescape1
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|data
operator|.
name|len
operator|==
literal|0
condition|)
name|e
operator|->
name|data
operator|.
name|s
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|e
operator|->
name|data
operator|.
name|s
operator|=
name|xmalloc
argument_list|(
name|e
operator|->
name|data
operator|.
name|len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|e
operator|->
name|data
operator|.
name|s
argument_list|,
name|s
argument_list|,
name|e
operator|->
name|data
operator|.
name|len
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|parse_external_entity
parameter_list|(
name|s
parameter_list|,
name|sp
parameter_list|,
name|e
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|struct
name|sgmls
modifier|*
name|sp
decl_stmt|;
name|external_entity_s
modifier|*
name|e
decl_stmt|;
block|{
name|char
modifier|*
name|type
decl_stmt|;
name|char
modifier|*
name|notation
decl_stmt|;
name|e
operator|->
name|name
operator|=
name|strsave
argument_list|(
name|scan_token
argument_list|(
operator|&
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|scan_token
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|type
argument_list|,
literal|"CDATA"
argument_list|)
operator|==
literal|0
condition|)
name|e
operator|->
name|type
operator|=
name|SGMLS_ENTITY_CDATA
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|type
argument_list|,
literal|"SDATA"
argument_list|)
operator|==
literal|0
condition|)
name|e
operator|->
name|type
operator|=
name|SGMLS_ENTITY_SDATA
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|type
argument_list|,
literal|"NDATA"
argument_list|)
operator|==
literal|0
condition|)
name|e
operator|->
name|type
operator|=
name|SGMLS_ENTITY_NDATA
expr_stmt|;
else|else
name|error
argument_list|(
name|E_BADEXTERNAL
argument_list|)
expr_stmt|;
name|notation
operator|=
name|scan_token
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
name|e
operator|->
name|notation
operator|=
name|lookup_notation
argument_list|(
name|sp
argument_list|,
name|notation
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|parse_subdoc_entity
parameter_list|(
name|s
parameter_list|,
name|e
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|external_entity_s
modifier|*
name|e
decl_stmt|;
block|{
name|e
operator|->
name|name
operator|=
name|strsave
argument_list|(
name|scan_token
argument_list|(
operator|&
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|e
operator|->
name|type
operator|=
name|SGMLS_ENTITY_SUBDOC
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|attribute_s
modifier|*
name|parse_attribute
parameter_list|(
name|sp
parameter_list|,
name|s
parameter_list|)
name|struct
name|sgmls
modifier|*
name|sp
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|attribute_s
modifier|*
name|a
decl_stmt|;
name|char
modifier|*
name|type
decl_stmt|;
name|a
operator|=
operator|(
name|attribute_s
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|a
argument_list|)
argument_list|)
expr_stmt|;
name|a
operator|->
name|name
operator|=
name|strsave
argument_list|(
name|scan_token
argument_list|(
operator|&
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|scan_token
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|type
argument_list|,
literal|"CDATA"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|unsigned
name|long
name|lineno
init|=
literal|0
decl_stmt|;
name|a
operator|->
name|type
operator|=
name|SGMLS_ATTR_CDATA
expr_stmt|;
name|a
operator|->
name|value
operator|.
name|data
operator|.
name|n
operator|=
name|parse_data
argument_list|(
name|s
argument_list|,
operator|&
name|lineno
argument_list|)
expr_stmt|;
name|a
operator|->
name|value
operator|.
name|data
operator|.
name|v
operator|=
name|copy_data
argument_list|(
name|datav
argument_list|,
name|a
operator|->
name|value
operator|.
name|data
operator|.
name|n
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|type
argument_list|,
literal|"IMPLIED"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|a
operator|->
name|type
operator|=
name|SGMLS_ATTR_IMPLIED
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|type
argument_list|,
literal|"NOTATION"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|a
operator|->
name|type
operator|=
name|SGMLS_ATTR_NOTATION
expr_stmt|;
name|a
operator|->
name|value
operator|.
name|notation
operator|=
name|lookup_notation
argument_list|(
name|sp
argument_list|,
name|scan_token
argument_list|(
operator|&
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|type
argument_list|,
literal|"ENTITY"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|n
decl_stmt|,
name|i
decl_stmt|;
name|a
operator|->
name|type
operator|=
name|SGMLS_ATTR_ENTITY
expr_stmt|;
name|n
operator|=
name|count_args
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
name|error
argument_list|(
name|E_MISSING
argument_list|)
expr_stmt|;
name|a
operator|->
name|value
operator|.
name|entity
operator|.
name|v
operator|=
operator|(
name|entity_s
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|n
operator|*
sizeof|sizeof
argument_list|(
name|entity_s
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|a
operator|->
name|value
operator|.
name|entity
operator|.
name|n
operator|=
name|n
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
name|a
operator|->
name|value
operator|.
name|entity
operator|.
name|v
index|[
name|i
index|]
operator|=
name|lookup_entity
argument_list|(
name|sp
argument_list|,
name|scan_token
argument_list|(
operator|&
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|type
argument_list|,
literal|"TOKEN"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|n
decl_stmt|,
name|i
decl_stmt|;
name|a
operator|->
name|type
operator|=
name|SGMLS_ATTR_TOKEN
expr_stmt|;
name|n
operator|=
name|count_args
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
name|error
argument_list|(
name|E_MISSING
argument_list|)
expr_stmt|;
name|a
operator|->
name|value
operator|.
name|token
operator|.
name|v
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|n
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
name|a
operator|->
name|value
operator|.
name|token
operator|.
name|v
index|[
name|i
index|]
operator|=
name|strsave
argument_list|(
name|scan_token
argument_list|(
operator|&
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|a
operator|->
name|value
operator|.
name|token
operator|.
name|n
operator|=
name|n
expr_stmt|;
block|}
else|else
name|error
argument_list|(
name|E_ATTR
argument_list|)
expr_stmt|;
return|return
name|a
return|;
block|}
end_function

begin_function
name|void
name|sgmls_free_attributes
parameter_list|(
name|p
parameter_list|)
name|attribute_s
modifier|*
name|p
decl_stmt|;
block|{
while|while
condition|(
name|p
condition|)
block|{
name|attribute_s
modifier|*
name|nextp
init|=
name|p
operator|->
name|next
decl_stmt|;
switch|switch
condition|(
name|p
operator|->
name|type
condition|)
block|{
case|case
name|SGMLS_ATTR_CDATA
case|:
if|if
condition|(
name|p
operator|->
name|value
operator|.
name|data
operator|.
name|v
condition|)
block|{
name|free
argument_list|(
name|p
operator|->
name|value
operator|.
name|data
operator|.
name|v
index|[
literal|0
index|]
operator|.
name|s
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
operator|->
name|value
operator|.
name|data
operator|.
name|v
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SGMLS_ATTR_TOKEN
case|:
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p
operator|->
name|value
operator|.
name|token
operator|.
name|n
condition|;
name|i
operator|++
control|)
name|free
argument_list|(
name|p
operator|->
name|value
operator|.
name|token
operator|.
name|v
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|p
operator|->
name|value
operator|.
name|token
operator|.
name|v
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SGMLS_ATTR_ENTITY
case|:
name|xfree
argument_list|(
name|p
operator|->
name|value
operator|.
name|entity
operator|.
name|v
argument_list|)
expr_stmt|;
break|break;
case|case
name|SGMLS_ATTR_IMPLIED
case|:
case|case
name|SGMLS_ATTR_NOTATION
case|:
break|break;
block|}
name|free
argument_list|(
name|p
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|nextp
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|data_s
modifier|*
name|copy_data
parameter_list|(
name|v
parameter_list|,
name|n
parameter_list|)
name|data_s
modifier|*
name|v
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
if|if
condition|(
name|n
operator|==
literal|0
condition|)
return|return
literal|0
return|;
else|else
block|{
name|int
name|i
decl_stmt|;
name|unsigned
name|total
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|data_s
modifier|*
name|result
decl_stmt|;
name|result
operator|=
operator|(
name|data_s
operator|*
operator|)
name|xmalloc
argument_list|(
name|n
operator|*
sizeof|sizeof
argument_list|(
name|data_s
argument_list|)
argument_list|)
expr_stmt|;
name|total
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
name|total
operator|+=
name|v
index|[
name|i
index|]
operator|.
name|len
expr_stmt|;
if|if
condition|(
operator|!
name|total
condition|)
name|total
operator|++
expr_stmt|;
name|p
operator|=
name|xmalloc
argument_list|(
name|total
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|result
index|[
name|i
index|]
operator|.
name|s
operator|=
name|p
expr_stmt|;
name|memcpy
argument_list|(
name|result
index|[
name|i
index|]
operator|.
name|s
argument_list|,
name|v
index|[
name|i
index|]
operator|.
name|s
argument_list|,
name|v
index|[
name|i
index|]
operator|.
name|len
argument_list|)
expr_stmt|;
name|result
index|[
name|i
index|]
operator|.
name|len
operator|=
name|v
index|[
name|i
index|]
operator|.
name|len
expr_stmt|;
name|p
operator|+=
name|v
index|[
name|i
index|]
operator|.
name|len
expr_stmt|;
name|result
index|[
name|i
index|]
operator|.
name|is_sdata
operator|=
name|v
index|[
name|i
index|]
operator|.
name|is_sdata
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
block|}
end_function

begin_comment
comment|/* Unescape s, and return nul-terminated data.  Give an error if the data contains 0. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|unescape
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|int
name|len
init|=
name|unescape1
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
ifdef|#
directive|ifdef
name|__BORLANDC__
name|len
operator|>
literal|0
operator|&&
endif|#
directive|endif
name|memchr
argument_list|(
name|s
argument_list|,
literal|'\0'
argument_list|,
name|len
argument_list|)
condition|)
name|error
argument_list|(
name|E_NULESCAPE
argument_list|)
expr_stmt|;
name|s
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/* Like unescape(), but REs are represented by 012 not 015. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|unescape_file
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|s
operator|=
name|unescape
argument_list|(
name|s
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
name|RECHAR
argument_list|)
operator|)
operator|!=
literal|0
condition|)
operator|*
name|p
operator|++
operator|=
literal|'\n'
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/* Unescape s, and return length of data.  The data may contain 0. */
end_comment

begin_function
specifier|static
name|int
name|unescape1
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|q
decl_stmt|;
name|q
operator|=
name|strchr
argument_list|(
name|s
argument_list|,
literal|'\\'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|q
condition|)
return|return
name|strlen
argument_list|(
name|s
argument_list|)
return|;
name|p
operator|=
name|q
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\\'
condition|)
block|{
switch|switch
condition|(
operator|*
operator|++
name|p
condition|)
block|{
case|case
literal|'\\'
case|:
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
operator|*
name|q
operator|++
operator|=
name|RECHAR
expr_stmt|;
name|p
operator|++
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
block|{
name|int
name|val
init|=
operator|*
name|p
operator|++
operator|-
literal|'0'
decl_stmt|;
if|if
condition|(
operator|*
name|p
operator|>=
literal|'0'
operator|&&
operator|*
name|p
operator|<=
literal|'7'
condition|)
block|{
name|val
operator|=
name|val
operator|*
literal|8
operator|+
operator|(
operator|*
name|p
operator|++
operator|-
literal|'0'
operator|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|>=
literal|'0'
operator|&&
operator|*
name|p
operator|<=
literal|'7'
condition|)
name|val
operator|=
name|val
operator|*
literal|8
operator|+
operator|(
operator|*
name|p
operator|++
operator|-
literal|'0'
operator|)
expr_stmt|;
block|}
operator|*
name|q
operator|++
operator|=
operator|(
name|char
operator|)
name|val
expr_stmt|;
block|}
break|break;
case|case
literal|'|'
case|:
name|error
argument_list|(
name|E_SDATA
argument_list|)
expr_stmt|;
default|default:
name|error
argument_list|(
name|E_BADESCAPE
argument_list|)
expr_stmt|;
block|}
block|}
else|else
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
return|return
name|q
operator|-
name|s
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|scan_token
parameter_list|(
name|pp
parameter_list|)
name|char
modifier|*
modifier|*
name|pp
decl_stmt|;
block|{
name|char
modifier|*
name|start
init|=
operator|*
name|pp
decl_stmt|;
while|while
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|*
operator|*
name|pp
operator|==
literal|' '
condition|)
block|{
operator|*
operator|*
name|pp
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|pp
operator|+=
literal|1
expr_stmt|;
break|break;
block|}
operator|*
name|pp
operator|+=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|*
name|start
condition|)
name|error
argument_list|(
name|E_MISSING
argument_list|)
expr_stmt|;
return|return
name|start
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|count_args
parameter_list|(
name|p
parameter_list|)
name|char
modifier|*
name|p
decl_stmt|;
block|{
name|int
name|n
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
name|n
operator|++
expr_stmt|;
do|do
block|{
operator|++
name|p
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|' '
condition|)
block|{
name|p
operator|++
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
do|;
block|}
return|return
name|n
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|read_line
parameter_list|(
name|sp
parameter_list|)
name|struct
name|sgmls
modifier|*
name|sp
decl_stmt|;
block|{
name|unsigned
name|i
init|=
literal|0
decl_stmt|;
name|FILE
modifier|*
name|fp
init|=
name|sp
operator|->
name|fp
decl_stmt|;
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|sp
operator|->
name|buf
decl_stmt|;
name|unsigned
name|buf_size
init|=
name|sp
operator|->
name|buf_size
decl_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
name|input_lineno
operator|=
name|sp
operator|->
name|input_lineno
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
name|error
argument_list|(
name|E_SYSTEM
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|sp
operator|->
name|input_lineno
operator|++
expr_stmt|;
name|input_lineno
operator|=
name|sp
operator|->
name|input_lineno
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|i
operator|>=
name|buf_size
condition|)
block|{
if|if
condition|(
name|buf_size
operator|==
literal|0
condition|)
name|buf_size
operator|=
literal|24
expr_stmt|;
elseif|else
if|if
condition|(
name|buf_size
operator|>
operator|(
name|unsigned
operator|)
name|UINT_MAX
operator|/
literal|2
condition|)
block|{
if|if
condition|(
name|buf_size
operator|==
operator|(
name|unsigned
operator|)
name|UINT_MAX
condition|)
name|error
argument_list|(
name|E_LINELENGTH
argument_list|)
expr_stmt|;
name|buf_size
operator|=
operator|(
name|unsigned
operator|)
name|UINT_MAX
expr_stmt|;
block|}
else|else
name|buf_size
operator|*=
literal|2
expr_stmt|;
name|buf
operator|=
name|xrealloc
argument_list|(
name|buf
argument_list|,
name|buf_size
argument_list|)
expr_stmt|;
name|sp
operator|->
name|buf
operator|=
name|buf
expr_stmt|;
name|sp
operator|->
name|buf_size
operator|=
name|buf_size
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
name|error
argument_list|(
name|E_NUL
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
name|buf
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
name|buf
index|[
name|i
operator|++
index|]
operator|=
name|c
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
name|error
argument_list|(
name|E_SYSTEM
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
name|E_EOF
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|notation_s
modifier|*
name|lookup_notation
parameter_list|(
name|sp
parameter_list|,
name|name
parameter_list|)
name|struct
name|sgmls
modifier|*
name|sp
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|notation_list
modifier|*
name|p
init|=
operator|(
expr|struct
name|notation_list
operator|*
operator|)
name|list_find
argument_list|(
operator|(
expr|struct
name|list
operator|*
operator|)
name|sp
operator|->
name|notations
argument_list|,
name|name
argument_list|,
name|sp
operator|->
name|subdoc_level
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
name|error
argument_list|(
name|E_BADNOTATION
argument_list|)
expr_stmt|;
return|return
operator|&
name|p
operator|->
name|notation
return|;
block|}
end_function

begin_function
specifier|static
name|entity_s
modifier|*
name|lookup_entity
parameter_list|(
name|sp
parameter_list|,
name|name
parameter_list|)
name|struct
name|sgmls
modifier|*
name|sp
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|entity_list
modifier|*
name|p
init|=
operator|(
expr|struct
name|entity_list
operator|*
operator|)
name|list_find
argument_list|(
operator|(
expr|struct
name|list
operator|*
operator|)
name|sp
operator|->
name|entities
argument_list|,
name|name
argument_list|,
name|sp
operator|->
name|subdoc_level
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
name|error
argument_list|(
name|E_BADENTITY
argument_list|)
expr_stmt|;
return|return
operator|&
name|p
operator|->
name|entity
return|;
block|}
end_function

begin_function
specifier|static
name|external_entity_s
modifier|*
name|lookup_external_entity
parameter_list|(
name|sp
parameter_list|,
name|name
parameter_list|)
name|struct
name|sgmls
modifier|*
name|sp
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|entity_s
modifier|*
name|p
init|=
name|lookup_entity
argument_list|(
name|sp
argument_list|,
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|is_internal
condition|)
name|error
argument_list|(
name|E_INTERNALENTITY
argument_list|)
expr_stmt|;
return|return
operator|&
name|p
operator|->
name|u
operator|.
name|external
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|define_external_entity
parameter_list|(
name|sp
parameter_list|,
name|e
parameter_list|)
name|struct
name|sgmls
modifier|*
name|sp
decl_stmt|;
name|external_entity_s
modifier|*
name|e
decl_stmt|;
block|{
name|struct
name|entity_list
modifier|*
name|p
decl_stmt|;
name|e
operator|->
name|attributes
operator|=
literal|0
expr_stmt|;
name|e
operator|->
name|filenames
operator|=
name|sp
operator|->
name|files
expr_stmt|;
name|e
operator|->
name|nfilenames
operator|=
name|sp
operator|->
name|nfiles
expr_stmt|;
name|sp
operator|->
name|files
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|nfiles
operator|=
literal|0
expr_stmt|;
name|e
operator|->
name|pubid
operator|=
name|sp
operator|->
name|pubid
expr_stmt|;
name|sp
operator|->
name|pubid
operator|=
literal|0
expr_stmt|;
name|e
operator|->
name|sysid
operator|=
name|sp
operator|->
name|sysid
expr_stmt|;
name|sp
operator|->
name|sysid
operator|=
literal|0
expr_stmt|;
name|p
operator|=
operator|(
expr|struct
name|entity_list
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|entity_list
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|UNIV
operator|)
operator|&
name|p
operator|->
name|entity
operator|.
name|u
operator|.
name|external
argument_list|,
operator|(
name|UNIV
operator|)
name|e
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|e
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|entity
operator|.
name|is_internal
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|subdoc_level
operator|=
name|sp
operator|->
name|subdoc_level
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|sp
operator|->
name|entities
expr_stmt|;
name|sp
operator|->
name|entities
operator|=
name|p
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|define_internal_entity
parameter_list|(
name|sp
parameter_list|,
name|e
parameter_list|)
name|struct
name|sgmls
modifier|*
name|sp
decl_stmt|;
name|internal_entity_s
modifier|*
name|e
decl_stmt|;
block|{
name|struct
name|entity_list
modifier|*
name|p
decl_stmt|;
name|p
operator|=
operator|(
expr|struct
name|entity_list
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|entity_list
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|UNIV
operator|)
operator|&
name|p
operator|->
name|entity
operator|.
name|u
operator|.
name|internal
argument_list|,
operator|(
name|UNIV
operator|)
name|e
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|e
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|entity
operator|.
name|is_internal
operator|=
literal|1
expr_stmt|;
name|p
operator|->
name|subdoc_level
operator|=
name|sp
operator|->
name|subdoc_level
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|sp
operator|->
name|entities
expr_stmt|;
name|sp
operator|->
name|entities
operator|=
name|p
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|define_notation
parameter_list|(
name|sp
parameter_list|,
name|np
parameter_list|)
name|struct
name|sgmls
modifier|*
name|sp
decl_stmt|;
name|notation_s
modifier|*
name|np
decl_stmt|;
block|{
name|struct
name|notation_list
modifier|*
name|p
decl_stmt|;
name|np
operator|->
name|sysid
operator|=
name|sp
operator|->
name|sysid
expr_stmt|;
name|sp
operator|->
name|sysid
operator|=
literal|0
expr_stmt|;
name|np
operator|->
name|pubid
operator|=
name|sp
operator|->
name|pubid
expr_stmt|;
name|sp
operator|->
name|pubid
operator|=
literal|0
expr_stmt|;
name|p
operator|=
operator|(
expr|struct
name|notation_list
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|notation_list
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|UNIV
operator|)
operator|&
name|p
operator|->
name|notation
argument_list|,
operator|(
name|UNIV
operator|)
name|np
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|np
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|subdoc_level
operator|=
name|sp
operator|->
name|subdoc_level
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|sp
operator|->
name|notations
expr_stmt|;
name|sp
operator|->
name|notations
operator|=
name|p
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|list
modifier|*
name|list_find
parameter_list|(
name|p
parameter_list|,
name|name
parameter_list|,
name|level
parameter_list|)
name|struct
name|list
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|level
decl_stmt|;
block|{
for|for
control|(
init|;
name|p
operator|&&
name|p
operator|->
name|subdoc_level
operator|==
name|level
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|p
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|p
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Move all the items in the list whose subdoc level is level to the end of the list and make their subdoc_level -1. */
end_comment

begin_function
specifier|static
name|void
name|list_finish_level
parameter_list|(
name|listp
parameter_list|,
name|level
parameter_list|)
name|struct
name|list
modifier|*
modifier|*
name|listp
decl_stmt|;
name|int
name|level
decl_stmt|;
block|{
name|struct
name|list
modifier|*
modifier|*
name|pp
decl_stmt|,
modifier|*
name|next_level
decl_stmt|,
modifier|*
name|old_level
decl_stmt|;
for|for
control|(
name|pp
operator|=
name|listp
init|;
operator|*
name|pp
operator|&&
operator|(
operator|*
name|pp
operator|)
operator|->
name|subdoc_level
operator|==
name|level
condition|;
name|pp
operator|=
operator|&
operator|(
operator|*
name|pp
operator|)
operator|->
name|next
control|)
operator|(
operator|*
name|pp
operator|)
operator|->
name|subdoc_level
operator|=
operator|-
literal|1
expr_stmt|;
name|next_level
operator|=
operator|*
name|pp
expr_stmt|;
operator|*
name|pp
operator|=
literal|0
expr_stmt|;
name|old_level
operator|=
operator|*
name|listp
expr_stmt|;
operator|*
name|listp
operator|=
name|next_level
expr_stmt|;
for|for
control|(
name|pp
operator|=
name|listp
init|;
operator|*
name|pp
condition|;
name|pp
operator|=
operator|&
operator|(
operator|*
name|pp
operator|)
operator|->
name|next
control|)
empty_stmt|;
operator|*
name|pp
operator|=
name|old_level
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|add_attribute
parameter_list|(
name|pp
parameter_list|,
name|a
parameter_list|)
name|attribute_s
modifier|*
modifier|*
name|pp
decl_stmt|,
decl|*
name|a
decl_stmt|;
end_function

begin_block
block|{
if|#
directive|if
literal|0
block|for (; *pp&& strcmp((*pp)->name, a->name)< 0; pp =&(*pp)->next)     ;
endif|#
directive|endif
name|a
operator|->
name|next
operator|=
operator|*
name|pp
expr_stmt|;
operator|*
name|pp
operator|=
name|a
expr_stmt|;
block|}
end_block

begin_function
specifier|static
name|char
modifier|*
name|strsave
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|s
condition|)
return|return
name|s
return|;
else|else
block|{
name|char
modifier|*
name|p
init|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|p
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|UNIV
name|xmalloc
parameter_list|(
name|n
parameter_list|)
name|unsigned
name|n
decl_stmt|;
block|{
name|UNIV
name|p
init|=
name|malloc
argument_list|(
name|n
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
name|error
argument_list|(
name|E_NOMEM
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* ANSI C says first argument to realloc can be NULL, but not everybody    appears to support this. */
end_comment

begin_function
specifier|static
name|UNIV
name|xrealloc
parameter_list|(
name|p
parameter_list|,
name|n
parameter_list|)
name|UNIV
name|p
decl_stmt|;
name|unsigned
name|n
decl_stmt|;
block|{
name|p
operator|=
name|p
condition|?
name|realloc
argument_list|(
name|p
argument_list|,
name|n
argument_list|)
else|:
name|malloc
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
name|error
argument_list|(
name|E_NOMEM
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|error
parameter_list|(
name|num
parameter_list|)
name|enum
name|error_code
name|num
decl_stmt|;
block|{
call|(
modifier|*
name|errhandler
call|)
argument_list|(
operator|(
name|int
operator|)
name|num
argument_list|,
name|errlist
index|[
name|num
index|]
argument_list|,
name|input_lineno
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|default_errhandler
parameter_list|(
name|num
parameter_list|,
name|msg
parameter_list|,
name|lineno
parameter_list|)
name|int
name|num
decl_stmt|;
name|char
modifier|*
name|msg
decl_stmt|;
name|unsigned
name|long
name|lineno
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Line %lu: %s\n"
argument_list|,
name|lineno
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

