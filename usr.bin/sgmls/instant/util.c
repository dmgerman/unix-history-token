begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  Copyright 1993 Open Software Foundation, Inc., Cambridge, Massachusetts.  *  All rights reserved.  */
end_comment

begin_comment
comment|/*  * Copyright (c) 1994    * Open Software Foundation, Inc.   *    * Permission is hereby granted to use, copy, modify and freely distribute   * the software in this file and its documentation for any purpose without   * fee, provided that the above copyright notice appears in all copies and   * that both the copyright notice and this permission notice appear in   * supporting documentation.  Further, provided that the name of Open   * Software Foundation, Inc. ("OSF") not be used in advertising or   * publicity pertaining to distribution of the software without prior   * written permission from OSF.  OSF makes no representations about the   * suitability of this software for any purpose.  It is provided "as is"   * without express or implied warranty.   */
end_comment

begin_comment
comment|/*  * Copyright (c) 1996 X Consortium  * Copyright (c) 1995, 1996 Dalrymple Consulting  *   * Permission is hereby granted, free of charge, to any person obtaining a copy  * of this software and associated documentation files (the "Software"), to deal  * in the Software without restriction, including without limitation the rights  * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell  * copies of the Software, and to permit persons to whom the Software is  * furnished to do so, subject to the following conditions:  *   * The above copyright notice and this permission notice shall be included in  * all copies or substantial portions of the Software.  *   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE  * X CONSORTIUM OR DALRYMPLE CONSULTING BE LIABLE FOR ANY CLAIM, DAMAGES OR  * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,  * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR  * OTHER DEALINGS IN THE SOFTWARE.  *   * Except as contained in this notice, the names of the X Consortium and  * Dalrymple Consulting shall not be used in advertising or otherwise to  * promote the sale, use or other dealings in this Software without prior  * written authorization.  */
end_comment

begin_comment
comment|/* ________________________________________________________________________  *  *  General utility functions for 'instant' program.  These are used  *  throughout the rest of the program.  *  *  Entry points for this module:  *	Split(s,&n, flags)		split string into n tokens  *	NewMap(slot_incr)		create a new mapping structure  *	FindMapping(map, name)		find mapping by name; return mapping  *	FindMappingVal(map, name)	find mapping by name; return value  *	SetMapping(map, s)		set mapping based on string  *	OpenFile(filename)		open file, looking in inst path  *	FilePath(filename)		find path to a file  *	FindElementPath(elem, s)	find path to element  *	PrintLocation(ele, fp)		print location of element in tree  *	NearestOlderElem(elem, name)	find prev elem up tree with name  *	OutputString(s, fp, track_pos)	output string  *	AddElemName(name)		add elem to list of known elements  *	AddAttName(name)		add att name to list of known atts  *	FindAttByName(elem, name)	find an elem's att by name  *	FindContext(elem, lev, context)	find context of elem  *	QRelation(elem, name, rel_flag)	find relation elem has to named elem  *	DescendTree(elem, enter_f, leave_f, data_f, dp)	descend doc tree,  *					calling functions for each elem/node  * ________________________________________________________________________  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|RCSid
init|=
literal|"$Header: /usr/src/docbook-to-man/Instant/RCS/util.c,v 1.4 1996/06/02 21:47:32 fld Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<memory.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<regexp.h>
end_include

begin_comment
comment|/* CSS don't have it and I don't see where it's used #include<values.h> */
end_comment

begin_include
include|#
directive|include
file|"general.h"
end_include

begin_include
include|#
directive|include
file|"translate.h"
end_include

begin_comment
comment|/* ______________________________________________________________________ */
end_comment

begin_comment
comment|/*  "Split" a string into tokens.  Given a string that has space-separated  *  (space/tab) tokens, return a pointer to an array of pointers to the  *  tokens.  Like what the shell does with *argv[].  The array can be is  *  static or allocated.  Space can be allocated for string, or allocated.  *  Arguments:  *	Pointer to string to pick apart.  *	Pointer to max number of tokens to find; actual number found is  *	  returned. If 0 or null pointer, use a 'sane' maximum number (hard-  *	  code). If more tokens than the number specified, make last token be  *	  a single string composed of the rest of the tokens (includes spaces).  *	Flag. Bit 0 says whether to make a copy of input string (since we'll  *	  clobber parts of it).  To free the string, use the pointer to  *	  the first token returned by the function (or *ret_value).  *	  Bit 1 says whether to allocate the vector itself.  If not, use  *	  (and return) a static vector.  *  Return:  *	Pointer to the provided string (for convenience of caller).  */
end_comment

begin_function
name|char
modifier|*
modifier|*
name|Split
parameter_list|(
name|char
modifier|*
name|s
parameter_list|,
comment|/* input string */
name|int
modifier|*
name|ntok
parameter_list|,
comment|/* # of tokens desired (input)/found (return) */
name|int
name|flag
comment|/* dup string? allocate a vector? */
parameter_list|)
block|{
name|int
name|maxnt
decl_stmt|,
name|i
init|=
literal|0
decl_stmt|;
name|int
name|n_alloc
decl_stmt|;
name|char
modifier|*
modifier|*
name|tokens
decl_stmt|;
specifier|static
name|char
modifier|*
name|local_tokens
index|[
literal|100
index|]
decl_stmt|;
comment|/* Figure max number of tokens (maxnt) to find.  0 means find them all. */
if|if
condition|(
name|ntok
operator|==
name|NULL
condition|)
name|maxnt
operator|=
literal|100
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|*
name|ntok
operator|<=
literal|0
operator|||
operator|*
name|ntok
operator|>
literal|100
condition|)
name|maxnt
operator|=
literal|100
expr_stmt|;
comment|/* arbitrary size */
else|else
name|maxnt
operator|=
operator|*
name|ntok
expr_stmt|;
operator|*
name|ntok
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|s
condition|)
return|return
literal|0
return|;
comment|/* no string */
comment|/* Point to 1st token (there may be initial space) */
while|while
condition|(
operator|*
name|s
operator|&&
name|IsWhite
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
comment|/* skip initial space, if any */
if|if
condition|(
operator|*
name|s
operator|==
name|EOS
condition|)
return|return
literal|0
return|;
comment|/* none found? */
comment|/* See if caller wants us to copy the input string. */
if|if
condition|(
name|flag
operator|&
name|S_STRDUP
condition|)
name|s
operator|=
name|strdup
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* See if caller wants us to allocate the returned vector. */
if|if
condition|(
name|flag
operator|&
name|S_ALVEC
condition|)
block|{
name|n_alloc
operator|=
literal|20
expr_stmt|;
name|Malloc
argument_list|(
name|n_alloc
argument_list|,
name|tokens
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
comment|/* if caller did not specify max tokens to find, set to more than 	 * there will possibly ever be */
if|if
condition|(
operator|!
name|ntok
operator|||
operator|!
operator|(
operator|*
name|ntok
operator|)
condition|)
name|maxnt
operator|=
literal|10000
expr_stmt|;
block|}
else|else
name|tokens
operator|=
name|local_tokens
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
comment|/* index into vector */
name|tokens
index|[
literal|0
index|]
operator|=
name|s
expr_stmt|;
comment|/* s already points to 1st token */
while|while
condition|(
name|i
operator|<
name|maxnt
condition|)
block|{
name|tokens
index|[
name|i
index|]
operator|=
name|s
expr_stmt|;
comment|/* point vector member at start of token */
name|i
operator|++
expr_stmt|;
comment|/* If we allocated vector, see if we need more space. */
if|if
condition|(
operator|(
name|flag
operator|&
name|S_ALVEC
operator|)
operator|&&
name|i
operator|>=
name|n_alloc
condition|)
block|{
name|n_alloc
operator|+=
literal|20
expr_stmt|;
name|Realloc
argument_list|(
name|n_alloc
argument_list|,
name|tokens
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>=
name|maxnt
condition|)
break|break;
comment|/* is this the last one? */
while|while
condition|(
operator|*
name|s
operator|&&
operator|!
name|IsWhite
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
comment|/* skip past end of token */
if|if
condition|(
operator|*
name|s
operator|==
name|EOS
condition|)
break|break;
comment|/* at end of input string? */
if|if
condition|(
operator|*
name|s
condition|)
operator|*
name|s
operator|++
operator|=
name|EOS
expr_stmt|;
comment|/* terminate token string */
while|while
condition|(
operator|*
name|s
operator|&&
name|IsWhite
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
comment|/* skip space - to next token */
block|}
if|if
condition|(
name|ntok
condition|)
operator|*
name|ntok
operator|=
name|i
expr_stmt|;
comment|/* return number of tokens found */
name|tokens
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
comment|/* null-terminate vector */
return|return
name|tokens
return|;
block|}
end_function

begin_comment
comment|/* ______________________________________________________________________ */
end_comment

begin_comment
comment|/*  Mapping routines.  These are used for name-value pairs, like attributes,  *  variables, and counters.  A "Map" is an opaque data structure used  *  internally by these routines.  The caller gets one when creating a new  *  map, then hands it to other routines that need it.  A "Mapping" is a  *  name/value pair.  The user has access to this.  *  Here's some sample usage:  *  *	Map *V;  *	V = NewMap(20);  *	SetMappingNV(V, "home", "/users/bowe");  *	printf("Home: %s\n", FindMappingVal(V, "home");  */
end_comment

begin_comment
comment|/*  Allocate new map structure.  Only done once for each map/variable list.  *  Arg:  *	Number of initial slots to allocate space for.  This is also the  *	"chunk size" - how much to allocate when we use up the given space.  *  Return:  *	Pointer to the (opaque) map structure. (User passes this to other  *	mapping routines.)  */
end_comment

begin_function
name|Map_t
modifier|*
name|NewMap
parameter_list|(
name|int
name|slot_increment
parameter_list|)
block|{
name|Map_t
modifier|*
name|M
decl_stmt|;
name|Calloc
argument_list|(
literal|1
argument_list|,
name|M
argument_list|,
name|Map_t
argument_list|)
expr_stmt|;
comment|/* should really do the memset's in Calloc/Malloc/Realloc        macros, but that will have to wait until time permits -CSS */
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|M
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|Map_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|slot_increment
condition|)
name|slot_increment
operator|=
literal|1
expr_stmt|;
name|M
operator|->
name|slot_incr
operator|=
name|slot_increment
expr_stmt|;
return|return
name|M
return|;
block|}
end_function

begin_comment
comment|/*  Given pointer to a Map and a name, find the mapping.  *  Arguments:  *	Pointer to map structure (as returned by NewMap().  *	Variable name.  *  Return:  *	Pointer to the matching mapping structure, or null if not found.  */
end_comment

begin_function
name|Mapping_t
modifier|*
name|FindMapping
parameter_list|(
name|Map_t
modifier|*
name|M
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|Mapping_t
modifier|*
name|m
decl_stmt|;
if|if
condition|(
operator|!
name|M
operator|||
name|M
operator|->
name|n_used
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
for|for
control|(
name|m
operator|=
name|M
operator|->
name|maps
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|M
operator|->
name|n_used
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|m
index|[
name|i
index|]
operator|.
name|name
index|[
literal|0
index|]
operator|==
name|name
index|[
literal|0
index|]
operator|&&
operator|!
name|strcmp
argument_list|(
name|m
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|name
argument_list|)
condition|)
return|return
operator|&
name|m
index|[
name|i
index|]
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  Given pointer to a Map and a name, return string value of the mapping.  *  Arguments:  *	Pointer to map structure (as returned by NewMap().  *	Variable name.  *  Return:  *	Pointer to the value (string), or null if not found.  */
end_comment

begin_function
name|char
modifier|*
name|FindMappingVal
parameter_list|(
name|Map_t
modifier|*
name|M
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|Mapping_t
modifier|*
name|m
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"each_A"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"each_C"
argument_list|)
condition|)
block|{
return|return
name|Get_A_C_value
argument_list|(
name|name
argument_list|)
return|;
block|}
comment|/*     if (!M || M->n_used == 0) return NULL;     if ((m = FindMapping(M, name))) return m->sval;     return NULL;     */
if|if
condition|(
operator|!
name|M
operator|||
name|M
operator|->
name|n_used
operator|==
literal|0
condition|)
block|{
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|(
name|m
operator|=
name|FindMapping
argument_list|(
name|M
argument_list|,
name|name
argument_list|)
operator|)
condition|)
block|{
return|return
name|m
operator|->
name|sval
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  Set a mapping/variable in Map M.  Input string is a name-value pair where  *  there is some amount of space after the name.  The correct mapping is done.  *  Arguments:  *	Pointer to map structure (as returned by NewMap().  *	Pointer to variable name (string).  *	Pointer to variable value (string).  */
end_comment

begin_function
name|void
name|SetMappingNV
parameter_list|(
name|Map_t
modifier|*
name|M
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|)
block|{
name|FILE
modifier|*
name|pp
decl_stmt|;
name|char
name|buf
index|[
name|LINESIZE
index|]
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|Mapping_t
modifier|*
name|m
decl_stmt|;
comment|/* First, look to see if it's a "well-known" variable. */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"verbose"
argument_list|)
condition|)
block|{
name|verbose
operator|=
name|atoi
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"warnings"
argument_list|)
condition|)
block|{
name|warnings
operator|=
name|atoi
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"foldcase"
argument_list|)
condition|)
block|{
name|fold_case
operator|=
name|atoi
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return;
block|}
name|m
operator|=
name|FindMapping
argument_list|(
name|M
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* find existing mapping (if set) */
comment|/* OK, we have a string mapping */
if|if
condition|(
name|m
condition|)
block|{
comment|/* exists - just replace value */
name|free
argument_list|(
name|m
operator|->
name|sval
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
condition|)
name|m
operator|->
name|sval
operator|=
name|strdup
argument_list|(
name|value
argument_list|)
expr_stmt|;
else|else
name|m
operator|->
name|sval
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|name
condition|)
block|{
comment|/* just in case */
comment|/* Need more slots for mapping structures?  Allocate in clumps. */
if|if
condition|(
name|M
operator|->
name|n_used
operator|==
literal|0
condition|)
block|{
name|M
operator|->
name|n_alloc
operator|=
name|M
operator|->
name|slot_incr
expr_stmt|;
name|Malloc
argument_list|(
name|M
operator|->
name|n_alloc
argument_list|,
name|M
operator|->
name|maps
argument_list|,
name|Mapping_t
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|M
operator|->
name|n_used
operator|>=
name|M
operator|->
name|n_alloc
condition|)
block|{
name|M
operator|->
name|n_alloc
operator|+=
name|M
operator|->
name|slot_incr
expr_stmt|;
name|Realloc
argument_list|(
name|M
operator|->
name|n_alloc
argument_list|,
name|M
operator|->
name|maps
argument_list|,
name|Mapping_t
argument_list|)
expr_stmt|;
block|}
name|m
operator|=
operator|&
name|M
operator|->
name|maps
index|[
name|M
operator|->
name|n_used
index|]
expr_stmt|;
name|M
operator|->
name|n_used
operator|++
expr_stmt|;
name|m
operator|->
name|name
operator|=
name|strdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
condition|)
name|m
operator|->
name|sval
operator|=
name|strdup
argument_list|(
name|value
argument_list|)
expr_stmt|;
else|else
name|m
operator|->
name|sval
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|value
condition|)
block|{
comment|/* See if the value is a command to run.  If so, run the command 	 * and replace the value with the output. 	 */
if|if
condition|(
operator|*
name|value
operator|==
literal|'!'
condition|)
block|{
if|if
condition|(
operator|(
name|pp
operator|=
name|popen
argument_list|(
name|value
operator|+
literal|1
argument_list|,
literal|"r"
argument_list|)
operator|)
condition|)
block|{
comment|/* run cmd, read its output */
name|i
operator|=
literal|0
expr_stmt|;
name|cp
operator|=
name|buf
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|cp
argument_list|,
name|LINESIZE
operator|-
name|i
argument_list|,
name|pp
argument_list|)
condition|)
block|{
name|i
operator|+=
name|strlen
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|=
operator|&
name|buf
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|LINESIZE
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Prog execution of variable '%s' too long.\n"
argument_list|,
name|m
operator|->
name|name
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|free
argument_list|(
name|m
operator|->
name|sval
argument_list|)
expr_stmt|;
name|stripNL
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|m
operator|->
name|sval
operator|=
name|strdup
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|pclose
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"Could not start program '%s'"
argument_list|,
name|value
operator|+
literal|1
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  Separate name and value from input string, then pass to SetMappingNV.  *  Arguments:  *	Pointer to map structure (as returned by NewMap().  *	Pointer to variable name and value (string), in form "name value".  */
end_comment

begin_function
name|void
name|SetMapping
parameter_list|(
name|Map_t
modifier|*
name|M
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
name|char
name|buf
index|[
name|LINESIZE
index|]
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|val
decl_stmt|;
if|if
condition|(
operator|!
name|M
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"SetMapping: Map not initialized.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|strcpy
argument_list|(
name|buf
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|name
operator|=
name|val
operator|=
name|buf
expr_stmt|;
while|while
condition|(
operator|*
name|val
operator|&&
operator|!
name|IsWhite
argument_list|(
operator|*
name|val
argument_list|)
condition|)
name|val
operator|++
expr_stmt|;
comment|/* point past end of name */
if|if
condition|(
operator|*
name|val
condition|)
block|{
operator|*
name|val
operator|++
operator|=
name|EOS
expr_stmt|;
comment|/* terminate name */
while|while
condition|(
operator|*
name|val
operator|&&
name|IsWhite
argument_list|(
operator|*
name|val
argument_list|)
condition|)
name|val
operator|++
expr_stmt|;
comment|/* point to value */
block|}
if|if
condition|(
name|name
condition|)
name|SetMappingNV
argument_list|(
name|M
argument_list|,
name|name
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ______________________________________________________________________ */
end_comment

begin_comment
comment|/*  Opens a file for reading.  If not found in current directory, try  *  lib directories (from TPT_LIB env variable, or -l option).  *  Arguments:  *	Filename (string).  *  Return:  *	FILE pointer to open file, or null if it not found or can't open.  */
end_comment

begin_function
name|FILE
modifier|*
name|OpenFile
parameter_list|(
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|filename
operator|=
name|FilePath
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
operator|)
condition|)
return|return
name|fp
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* ______________________________________________________________________ */
end_comment

begin_comment
comment|/*  Opens a file for reading.  If not found in current directory, try  *  lib directories (from TPT_LIB env variable, or -l option).  *  Arguments:  *	Filename (string).  *  Return:  *	FILE pointer to open file, or null if it not found or can't open.  */
end_comment

begin_function
name|char
modifier|*
name|FilePath
parameter_list|(
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
specifier|static
name|char
name|buf
index|[
name|LINESIZE
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|static
name|char
modifier|*
modifier|*
name|libdirs
decl_stmt|;
specifier|static
name|int
name|nlibdirs
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
operator|)
condition|)
block|{
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|buf
argument_list|,
name|filename
argument_list|,
name|LINESIZE
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
if|if
condition|(
operator|*
name|filename
operator|==
literal|'/'
condition|)
return|return
name|NULL
return|;
comment|/* full path specified? */
if|if
condition|(
name|nlibdirs
operator|<
literal|0
condition|)
block|{
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|tpt_lib
condition|)
block|{
name|s
operator|=
name|strdup
argument_list|(
name|tpt_lib
argument_list|)
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|s
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
if|if
condition|(
operator|*
name|cp
operator|==
literal|':'
condition|)
operator|*
name|cp
operator|=
literal|' '
expr_stmt|;
name|nlibdirs
operator|=
literal|0
expr_stmt|;
name|libdirs
operator|=
name|Split
argument_list|(
name|s
argument_list|,
operator|&
name|nlibdirs
argument_list|,
name|S_ALVEC
argument_list|)
expr_stmt|;
block|}
else|else
name|nlibdirs
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nlibdirs
condition|;
name|i
operator|++
control|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s/%s"
argument_list|,
name|libdirs
index|[
name|i
index|]
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|buf
argument_list|,
literal|"r"
argument_list|)
operator|)
condition|)
block|{
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* ______________________________________________________________________ */
end_comment

begin_comment
comment|/*  This will find the path to an tag.  The format is the:  *	tag1(n1):tag2(n2):tag3  *  where the tags are going down the tree and the numbers indicate which  *  child (the first is numbered 1) the next tag is.  *  Returns pointer to the string just written to (so you can use this  *  function as a printf arg).  *  Arguments:  *	Pointer to element under consideration.  *	String to write path into (provided by caller).  *  Return:  *	Pointer to the provided string (for convenience of caller).  */
end_comment

begin_function
name|char
modifier|*
name|FindElementPath
parameter_list|(
name|Element_t
modifier|*
name|e
parameter_list|,
name|char
modifier|*
name|s
parameter_list|)
block|{
name|Element_t
modifier|*
name|ep
decl_stmt|;
name|int
name|i
decl_stmt|,
name|e_path
index|[
name|MAX_DEPTH
index|]
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* Move up the tree, noting "birth order" of each element encountered */
for|for
control|(
name|ep
operator|=
name|e
init|;
name|ep
condition|;
name|ep
operator|=
name|ep
operator|->
name|parent
control|)
name|e_path
index|[
name|ep
operator|->
name|depth
operator|-
literal|1
index|]
operator|=
name|ep
operator|->
name|my_eorder
expr_stmt|;
comment|/* Move down the tree, printing the element names to the string. */
for|for
control|(
name|cp
operator|=
name|s
operator|,
name|i
operator|=
literal|0
operator|,
name|ep
operator|=
name|DocTree
init|;
name|i
operator|<
name|e
operator|->
name|depth
condition|;
name|ep
operator|=
name|ep
operator|->
name|econt
index|[
name|e_path
index|[
name|i
index|]
index|]
operator|,
name|i
operator|++
control|)
block|{
name|sprintf
argument_list|(
name|cp
argument_list|,
literal|"%s(%d) "
argument_list|,
name|ep
operator|->
name|gi
argument_list|,
name|e_path
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|strlen
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|cp
argument_list|,
literal|"%s"
argument_list|,
name|e
operator|->
name|gi
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/* ______________________________________________________________________ */
end_comment

begin_comment
comment|/*  Print some location info about a tag.  Helps user locate error.  *  Messages are indented 2 spaces (convention for multi-line messages).  *  Arguments:  *	Pointer to element under consideration.  *	FILE pointer of where to print.  */
end_comment

begin_function
name|void
name|PrintLocation
parameter_list|(
name|Element_t
modifier|*
name|e
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|char
modifier|*
name|s
decl_stmt|,
name|buf
index|[
name|LINESIZE
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|e
operator|||
operator|!
name|fp
condition|)
return|return;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"  Path: %s\n"
argument_list|,
name|FindElementPath
argument_list|(
name|e
argument_list|,
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|NearestOlderElem
argument_list|(
name|e
argument_list|,
literal|"TITLE"
argument_list|)
operator|)
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"  Position hint: TITLE='%s'\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|lineno
condition|)
block|{
if|if
condition|(
name|e
operator|->
name|infile
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"  At or near instance file: %s, line: %d\n"
argument_list|,
name|e
operator|->
name|infile
argument_list|,
name|e
operator|->
name|lineno
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"  At or near instance line: %d\n"
argument_list|,
name|e
operator|->
name|lineno
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|e
operator|->
name|id
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"  ID: %s\n"
argument_list|,
name|e
operator|->
name|id
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ______________________________________________________________________ */
end_comment

begin_comment
comment|/*  Finds the data part of the nearest "older" tag (up the tree, and  *  preceding) whose tag name matches the argument, or "TITLE", if null.  *  Returns a pointer to the first chunk of character data.  *  Arguments:  *	Pointer to element under consideration.  *	Name (GI) of element we'll return data from.  *  Return:  *	Pointer to that element's data content.  */
end_comment

begin_function
name|char
modifier|*
name|NearestOlderElem
parameter_list|(
name|Element_t
modifier|*
name|e
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|Element_t
modifier|*
name|ep
decl_stmt|;
if|if
condition|(
operator|!
name|e
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|name
condition|)
name|name
operator|=
literal|"TITLE"
expr_stmt|;
comment|/* useful default */
for|for
control|(
init|;
name|e
operator|->
name|parent
condition|;
name|e
operator|=
name|e
operator|->
name|parent
control|)
comment|/* move up tree */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|e
operator|->
name|my_eorder
condition|;
name|i
operator|++
control|)
block|{
comment|/* check preceding sibs */
name|ep
operator|=
name|e
operator|->
name|parent
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
name|ep
operator|->
name|econt
index|[
name|i
index|]
operator|->
name|gi
argument_list|)
condition|)
return|return
name|ep
operator|->
name|econt
index|[
name|i
index|]
operator|->
name|ndcont
condition|?
name|ep
operator|->
name|econt
index|[
name|i
index|]
operator|->
name|dcont
index|[
literal|0
index|]
else|:
literal|"-empty-"
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* ______________________________________________________________________ */
end_comment

begin_comment
comment|/*  Expands escaped strings in the input buffer (things like tabs, newlines,  *  octal characters - using C style escapes).  */
end_comment

begin_function
name|char
modifier|*
name|ExpandString
parameter_list|(
name|char
modifier|*
name|s
parameter_list|)
block|{
name|char
name|c
decl_stmt|,
modifier|*
name|sdata
decl_stmt|,
modifier|*
name|cp
decl_stmt|,
modifier|*
name|ns
decl_stmt|;
name|int
name|len
decl_stmt|,
name|pos
decl_stmt|,
name|addn
decl_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
return|return
name|s
return|;
name|len
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|pos
operator|=
literal|0
expr_stmt|;
name|Malloc
argument_list|(
name|len
operator|+
literal|1
argument_list|,
name|ns
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|ns
index|[
name|pos
index|]
operator|=
name|EOS
expr_stmt|;
for|for
control|(
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
block|{
name|c
operator|=
operator|*
name|s
expr_stmt|;
name|cp
operator|=
name|NULL
expr_stmt|;
comment|/* Check for escaped characters from sgmls. */
if|if
condition|(
operator|*
name|s
operator|==
literal|'\\'
condition|)
block|{
name|s
operator|++
expr_stmt|;
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|'n'
case|:
name|c
operator|=
name|NL
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
name|c
operator|=
literal|'\\'
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
comment|/* for octal numbers (C style) of the form \012 */
name|c
operator|=
operator|*
name|s
operator|++
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|>=
literal|'0'
operator|&&
operator|*
name|s
operator|<=
literal|'7'
condition|)
block|{
name|c
operator|=
name|c
operator|*
literal|8
operator|+
operator|(
operator|*
name|s
operator|++
operator|-
literal|'0'
operator|)
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|>=
literal|'0'
operator|&&
operator|*
name|s
operator|<=
literal|'7'
condition|)
name|c
operator|=
name|c
operator|*
literal|8
operator|+
operator|(
operator|*
name|s
operator|-
literal|'0'
operator|)
expr_stmt|;
block|}
break|break;
case|case
literal|'|'
case|:
comment|/* SDATA */
name|s
operator|++
expr_stmt|;
comment|/* point past \| */
name|sdata
operator|=
name|s
expr_stmt|;
comment|/* find matching/closing \| */
name|cp
operator|=
name|s
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|&&
operator|*
name|cp
operator|!=
literal|'\\'
operator|&&
name|cp
index|[
literal|1
index|]
operator|!=
literal|'|'
condition|)
name|cp
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|cp
condition|)
break|break;
operator|*
name|cp
operator|=
name|EOS
expr_stmt|;
comment|/* terminate sdata string */
name|cp
operator|++
expr_stmt|;
name|s
operator|=
name|cp
expr_stmt|;
comment|/* s now points to | */
name|cp
operator|=
name|LookupSDATA
argument_list|(
name|sdata
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cp
condition|)
name|cp
operator|=
name|sdata
expr_stmt|;
name|c
operator|=
literal|0
expr_stmt|;
break|break;
comment|/* This shouldn't happen. */
default|default:
name|s
operator|--
expr_stmt|;
break|break;
block|}
block|}
comment|/* Check for character re-mappings. */
if|if
condition|(
name|nCharMap
operator|&&
name|c
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nCharMap
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|c
operator|!=
name|CharMap
index|[
name|i
index|]
operator|.
name|name
index|[
literal|0
index|]
condition|)
continue|continue;
name|cp
operator|=
name|CharMap
index|[
name|i
index|]
operator|.
name|sval
expr_stmt|;
name|c
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
comment|/* See if there is enough space for the data. */
comment|/* XXX this should be MUCH smarter about predicting     	   how much extra memory it should allocate */
if|if
condition|(
name|c
condition|)
name|addn
operator|=
literal|1
expr_stmt|;
else|else
name|addn
operator|=
name|strlen
argument_list|(
name|cp
argument_list|)
expr_stmt|;
comment|/* If not, make some. */
if|if
condition|(
name|addn
operator|>
name|len
operator|-
name|pos
condition|)
block|{
name|len
operator|+=
name|addn
operator|-
operator|(
name|len
operator|-
name|pos
operator|)
expr_stmt|;
name|Realloc
argument_list|(
name|len
operator|+
literal|1
argument_list|,
name|ns
argument_list|,
name|char
argument_list|)
expr_stmt|;
block|}
comment|/* Then copy the data. */
if|if
condition|(
name|c
condition|)
name|ns
index|[
name|pos
index|]
operator|=
name|c
expr_stmt|;
else|else
name|strcpy
argument_list|(
operator|&
name|ns
index|[
name|pos
index|]
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|pos
operator|+=
name|addn
expr_stmt|;
name|ns
index|[
name|pos
index|]
operator|=
name|EOS
expr_stmt|;
block|}
return|return
operator|(
name|ns
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ______________________________________________________________________ */
end_comment

begin_comment
comment|/*  Expands escaped strings in the input buffer (things like tabs, newlines,  *  octal characters - using C style escapes) and outputs buffer to specified  *  fp.  The hat/anchor character forces that position to appear at the  *  beginning of a line.  The cursor position is kept track of (optionally)  *  so that this can be done.  *  Arguments:  *	Pointer to element under consideration.  *	FILE pointer of where to print.  *	Flag saying whether or not to keep track of our position in the output  *	  stream. (We want to when writing to a file, but not for stderr.)  */
end_comment

begin_function
name|void
name|OutputString
parameter_list|(
name|char
modifier|*
name|s
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
name|int
name|track_pos
parameter_list|)
block|{
name|char
name|c
decl_stmt|;
specifier|static
name|int
name|char_pos
init|=
literal|0
decl_stmt|;
comment|/* remembers our character position */
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|!
name|fp
condition|)
return|return;
if|if
condition|(
operator|!
name|s
condition|)
name|s
operator|=
literal|"^"
expr_stmt|;
comment|/* no string - go to start of line */
for|for
control|(
name|p
operator|=
name|s
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
block|{
name|c
operator|=
operator|*
name|p
expr_stmt|;
comment|/* If caller wants us to track position, see if it's an anchor 	 * (ie, align at a newline). */
if|if
condition|(
name|track_pos
condition|)
block|{
if|if
condition|(
name|c
operator|==
name|ANCHOR
operator|&&
operator|(
name|p
operator|==
name|s
operator|||
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
operator|==
name|EOS
operator|)
condition|)
block|{
comment|/* If we're already at the start of a line, don't do 		 * another newline. */
if|if
condition|(
name|char_pos
operator|!=
literal|0
condition|)
name|c
operator|=
name|NL
expr_stmt|;
else|else
name|c
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|char_pos
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|NL
condition|)
name|char_pos
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|ANCHOR
operator|&&
operator|(
name|p
operator|==
name|s
operator|||
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
operator|==
name|EOS
operator|)
condition|)
name|c
operator|=
name|NL
expr_stmt|;
if|if
condition|(
name|c
condition|)
name|putc
argument_list|(
name|c
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ______________________________________________________________________ */
end_comment

begin_comment
comment|/* Figure out value of SDATA entity.  * We rememeber lookup hits in a "cache" (a shorter list), and look in  * cache before general list.  Typically there will be LOTS of entries  * in the general list and only a handful in the hit list.  Often, if an  * entity is used once, it'll be used again.  *  Arguments:  *	Pointer to SDATA entity token in ESIS.  *  Return:  *	Mapped value of the SDATA entity.  */
end_comment

begin_function
name|char
modifier|*
name|LookupSDATA
parameter_list|(
name|char
modifier|*
name|s
parameter_list|)
block|{
name|char
modifier|*
name|v
decl_stmt|;
specifier|static
name|Map_t
modifier|*
name|Hits
decl_stmt|;
comment|/* remember lookup hits */
comment|/* If we have a hit list, check it. */
if|if
condition|(
name|Hits
condition|)
block|{
if|if
condition|(
operator|(
name|v
operator|=
name|FindMappingVal
argument_list|(
name|Hits
argument_list|,
name|s
argument_list|)
operator|)
condition|)
return|return
name|v
return|;
block|}
name|v
operator|=
name|FindMappingVal
argument_list|(
name|SDATAmap
argument_list|,
name|s
argument_list|)
expr_stmt|;
comment|/* If mapping found, remember it, then return it. */
if|if
condition|(
operator|(
name|v
operator|=
name|FindMappingVal
argument_list|(
name|SDATAmap
argument_list|,
name|s
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|Hits
condition|)
name|Hits
operator|=
name|NewMap
argument_list|(
name|IMS_sdatacache
argument_list|)
expr_stmt|;
name|SetMappingNV
argument_list|(
name|Hits
argument_list|,
name|s
argument_list|,
name|v
argument_list|)
expr_stmt|;
return|return
name|v
return|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error: Could not find SDATA substitution '%s'.\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* ______________________________________________________________________ */
end_comment

begin_comment
comment|/*  Add tag 'name' of length 'len' to list of tag names (if not there).  *  This is a list of null-terminated strings so that we don't have to  *  keep using the name length.  *  Arguments:  *	Pointer to element name (GI) to remember.  *  Return:  *	Pointer to the SAVED element name (GI).  */
end_comment

begin_function
name|char
modifier|*
name|AddElemName
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
specifier|static
name|int
name|n_alloc
init|=
literal|0
decl_stmt|;
comment|/* number of slots allocated so far */
comment|/* See if it's already in the list. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nUsedElem
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|UsedElem
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
name|name
index|[
literal|0
index|]
operator|&&
operator|!
name|strcmp
argument_list|(
name|UsedElem
index|[
name|i
index|]
argument_list|,
name|name
argument_list|)
condition|)
return|return
name|UsedElem
index|[
name|i
index|]
return|;
comment|/* Allocate slots in blocks of N, so we don't have to call malloc      * so many times. */
if|if
condition|(
name|n_alloc
operator|==
literal|0
condition|)
block|{
name|n_alloc
operator|=
name|IMS_elemnames
expr_stmt|;
name|Calloc
argument_list|(
name|n_alloc
argument_list|,
name|UsedElem
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nUsedElem
operator|>=
name|n_alloc
condition|)
block|{
name|n_alloc
operator|+=
name|IMS_elemnames
expr_stmt|;
name|Realloc
argument_list|(
name|n_alloc
argument_list|,
name|UsedElem
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
block|}
name|UsedElem
index|[
name|nUsedElem
index|]
operator|=
name|strdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
name|UsedElem
index|[
name|nUsedElem
operator|++
index|]
return|;
block|}
end_function

begin_comment
comment|/* ______________________________________________________________________ */
end_comment

begin_comment
comment|/*  Add attrib name to list of attrib names (if not there).  *  This is a list of null-terminated strings so that we don't have to  *  keep using the name length.  *  Arguments:  *	Pointer to attr name to remember.  *  Return:  *	Pointer to the SAVED attr name.  */
end_comment

begin_function
name|char
modifier|*
name|AddAttName
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
specifier|static
name|int
name|n_alloc
init|=
literal|0
decl_stmt|;
comment|/* number of slots allocated so far */
comment|/* See if it's already in the list. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nUsedAtt
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|UsedAtt
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
name|name
index|[
literal|0
index|]
operator|&&
operator|!
name|strcmp
argument_list|(
name|UsedAtt
index|[
name|i
index|]
argument_list|,
name|name
argument_list|)
condition|)
return|return
name|UsedAtt
index|[
name|i
index|]
return|;
comment|/* Allocate slots in blocks of N, so we don't have to call malloc      * so many times. */
if|if
condition|(
name|n_alloc
operator|==
literal|0
condition|)
block|{
name|n_alloc
operator|=
name|IMS_attnames
expr_stmt|;
name|Calloc
argument_list|(
name|n_alloc
argument_list|,
name|UsedAtt
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nUsedAtt
operator|>=
name|n_alloc
condition|)
block|{
name|n_alloc
operator|+=
name|IMS_attnames
expr_stmt|;
name|Realloc
argument_list|(
name|n_alloc
argument_list|,
name|UsedAtt
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
block|}
name|UsedAtt
index|[
name|nUsedAtt
index|]
operator|=
name|strdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
name|UsedAtt
index|[
name|nUsedAtt
operator|++
index|]
return|;
block|}
end_function

begin_comment
comment|/* ______________________________________________________________________ */
end_comment

begin_comment
comment|/*  Find an element's attribute value given element pointer and attr name.  *  Typical use:   *	a=FindAttByName("TYPE", t);   *	do something with a->val;  *  Arguments:  *	Pointer to element under consideration.  *	Pointer to attribute name.  *  Return:  *	Pointer to the value of the attribute.  */
end_comment

begin_comment
comment|/* Mapping_t * FindAttByName(     Element_t	*e,     char	*name ) {     int		i;     if (!e) return NULL;     for (i=0; i<e->natts; i++) 	if (e->atts[i].name[0] == name[0]&& !strcmp(e->atts[i].name, name)) 		return&(e->atts[i]);     return NULL; } */
end_comment

begin_function
name|char
modifier|*
name|FindAttValByName
parameter_list|(
name|Element_t
modifier|*
name|e
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|e
condition|)
return|return
name|NULL
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|e
operator|->
name|natts
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|e
operator|->
name|atts
index|[
name|i
index|]
operator|.
name|name
index|[
literal|0
index|]
operator|==
name|name
index|[
literal|0
index|]
operator|&&
operator|!
name|strcmp
argument_list|(
name|e
operator|->
name|atts
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|name
argument_list|)
condition|)
return|return
name|e
operator|->
name|atts
index|[
name|i
index|]
operator|.
name|sval
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* ______________________________________________________________________ */
end_comment

begin_comment
comment|/*  Find context of a tag, 'levels' levels up the tree.  *  Space for string is passed by caller.  *  Arguments:  *	Pointer to element under consideration.  *	Number of levels to look up tree.  *	String to write path into (provided by caller).  *  Return:  *	Pointer to the provided string (for convenience of caller).  */
end_comment

begin_function
name|char
modifier|*
name|FindContext
parameter_list|(
name|Element_t
modifier|*
name|e
parameter_list|,
name|int
name|levels
parameter_list|,
name|char
modifier|*
name|con
parameter_list|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|Element_t
modifier|*
name|ep
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|e
condition|)
return|return
name|NULL
return|;
name|s
operator|=
name|con
expr_stmt|;
operator|*
name|s
operator|=
name|EOS
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|ep
operator|=
name|e
operator|->
name|parent
init|;
name|ep
operator|&&
name|levels
condition|;
name|ep
operator|=
name|ep
operator|->
name|parent
operator|,
name|i
operator|++
operator|,
name|levels
operator|--
control|)
block|{
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
operator|*
name|s
operator|++
operator|=
literal|' '
expr_stmt|;
name|strcpy
argument_list|(
name|s
argument_list|,
name|ep
operator|->
name|gi
argument_list|)
expr_stmt|;
name|s
operator|+=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
return|return
name|con
return|;
block|}
end_function

begin_comment
comment|/* ______________________________________________________________________ */
end_comment

begin_comment
comment|/*  Tests relationship (specified by argument/flag) between given element  *  (structure pointer) and named element.  *  Returns pointer to matching tag if found, null otherwise.  *  Arguments:  *	Pointer to element under consideration.  *	Pointer to name of elem whose relationsip we are trying to determine.  *	Relationship we are testing.  *  Return:  *	Pointer to the provided string (for convenience of caller).  */
end_comment

begin_function
name|Element_t
modifier|*
name|QRelation
parameter_list|(
name|Element_t
modifier|*
name|e
parameter_list|,
name|char
modifier|*
name|s
parameter_list|,
name|Relation_t
name|rel
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|Element_t
modifier|*
name|ep
decl_stmt|;
if|if
condition|(
operator|!
name|e
condition|)
return|return
literal|0
return|;
comment|/* we'll call e the "given element" */
switch|switch
condition|(
name|rel
condition|)
block|{
case|case
name|REL_Parent
case|:
if|if
condition|(
operator|!
name|e
operator|->
name|parent
operator|||
operator|!
name|e
operator|->
name|parent
operator|->
name|gi
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|e
operator|->
name|parent
operator|->
name|gi
argument_list|,
name|s
argument_list|)
condition|)
return|return
name|e
operator|->
name|parent
return|;
break|break;
case|case
name|REL_Child
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|e
operator|->
name|necont
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|s
argument_list|,
name|e
operator|->
name|econt
index|[
name|i
index|]
operator|->
name|gi
argument_list|)
condition|)
return|return
name|e
operator|->
name|econt
index|[
name|i
index|]
return|;
break|break;
case|case
name|REL_Ancestor
case|:
if|if
condition|(
operator|!
name|e
operator|->
name|parent
operator|||
operator|!
name|e
operator|->
name|parent
operator|->
name|gi
condition|)
return|return
literal|0
return|;
for|for
control|(
name|ep
operator|=
name|e
operator|->
name|parent
init|;
name|ep
condition|;
name|ep
operator|=
name|ep
operator|->
name|parent
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ep
operator|->
name|gi
argument_list|,
name|s
argument_list|)
condition|)
return|return
name|ep
return|;
break|break;
case|case
name|REL_Descendant
case|:
if|if
condition|(
name|e
operator|->
name|necont
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* check immediate children first */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|e
operator|->
name|necont
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|s
argument_list|,
name|e
operator|->
name|econt
index|[
name|i
index|]
operator|->
name|gi
argument_list|)
condition|)
return|return
name|e
operator|->
name|econt
index|[
name|i
index|]
return|;
comment|/* then children's children (recursively) */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|e
operator|->
name|necont
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|ep
operator|=
name|QRelation
argument_list|(
name|e
operator|->
name|econt
index|[
name|i
index|]
argument_list|,
name|s
argument_list|,
name|REL_Descendant
argument_list|)
operator|)
condition|)
return|return
name|ep
return|;
break|break;
case|case
name|REL_Sibling
case|:
if|if
condition|(
operator|!
name|e
operator|->
name|parent
condition|)
return|return
literal|0
return|;
name|ep
operator|=
name|e
operator|->
name|parent
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ep
operator|->
name|necont
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|s
argument_list|,
name|ep
operator|->
name|econt
index|[
name|i
index|]
operator|->
name|gi
argument_list|)
operator|&&
name|i
operator|!=
name|e
operator|->
name|my_eorder
condition|)
return|return
name|ep
operator|->
name|econt
index|[
name|i
index|]
return|;
break|break;
case|case
name|REL_Preceding
case|:
if|if
condition|(
operator|!
name|e
operator|->
name|parent
operator|||
name|e
operator|->
name|my_eorder
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|ep
operator|=
name|e
operator|->
name|parent
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|e
operator|->
name|my_eorder
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|s
argument_list|,
name|ep
operator|->
name|econt
index|[
name|i
index|]
operator|->
name|gi
argument_list|)
condition|)
return|return
name|ep
operator|->
name|econt
index|[
name|i
index|]
return|;
break|break;
case|case
name|REL_ImmPreceding
case|:
if|if
condition|(
operator|!
name|e
operator|->
name|parent
operator|||
name|e
operator|->
name|my_eorder
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|ep
operator|=
name|e
operator|->
name|parent
operator|->
name|econt
index|[
name|e
operator|->
name|my_eorder
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|s
argument_list|,
name|ep
operator|->
name|gi
argument_list|)
condition|)
return|return
name|ep
return|;
break|break;
case|case
name|REL_Following
case|:
if|if
condition|(
operator|!
name|e
operator|->
name|parent
operator|||
name|e
operator|->
name|my_eorder
operator|==
operator|(
name|e
operator|->
name|parent
operator|->
name|necont
operator|-
literal|1
operator|)
condition|)
return|return
literal|0
return|;
comment|/* last? */
name|ep
operator|=
name|e
operator|->
name|parent
expr_stmt|;
for|for
control|(
name|i
operator|=
operator|(
name|e
operator|->
name|my_eorder
operator|+
literal|1
operator|)
init|;
name|i
operator|<
name|ep
operator|->
name|necont
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|s
argument_list|,
name|ep
operator|->
name|econt
index|[
name|i
index|]
operator|->
name|gi
argument_list|)
condition|)
return|return
name|ep
operator|->
name|econt
index|[
name|i
index|]
return|;
break|break;
case|case
name|REL_ImmFollowing
case|:
if|if
condition|(
operator|!
name|e
operator|->
name|parent
operator|||
name|e
operator|->
name|my_eorder
operator|==
operator|(
name|e
operator|->
name|parent
operator|->
name|necont
operator|-
literal|1
operator|)
condition|)
return|return
literal|0
return|;
comment|/* last? */
name|ep
operator|=
name|e
operator|->
name|parent
operator|->
name|econt
index|[
name|e
operator|->
name|my_eorder
operator|+
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|s
argument_list|,
name|ep
operator|->
name|gi
argument_list|)
condition|)
return|return
name|ep
return|;
break|break;
case|case
name|REL_Cousin
case|:
if|if
condition|(
operator|!
name|e
operator|->
name|parent
condition|)
return|return
literal|0
return|;
comment|/* Now, see if element's parent has that thing as a child. */
return|return
name|QRelation
argument_list|(
name|e
operator|->
name|parent
argument_list|,
name|s
argument_list|,
name|REL_Child
argument_list|)
return|;
break|break;
case|case
name|REL_None
case|:
case|case
name|REL_Unknown
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"You can not query 'REL_None' or 'REL_Unknown'.\n"
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  Given a relationship name (string), determine enum symbol for it.  *  Arguments:  *	Pointer to relationship name.  *  Return:  *	Relation_t enum.  */
end_comment

begin_function
name|Relation_t
name|FindRelByName
parameter_list|(
name|char
modifier|*
name|relname
parameter_list|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|relname
argument_list|,
literal|"?"
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Supported query/relationships %s\n%s.\n"
argument_list|,
literal|"child, parent, ancestor, descendant,"
argument_list|,
literal|"sibling, sibling+, sibling+1, sibling-, sibling-1"
argument_list|)
expr_stmt|;
return|return
name|REL_None
return|;
block|}
elseif|else
if|if
condition|(
name|StrEq
argument_list|(
name|relname
argument_list|,
literal|"child"
argument_list|)
condition|)
return|return
name|REL_Child
return|;
elseif|else
if|if
condition|(
name|StrEq
argument_list|(
name|relname
argument_list|,
literal|"parent"
argument_list|)
condition|)
return|return
name|REL_Parent
return|;
elseif|else
if|if
condition|(
name|StrEq
argument_list|(
name|relname
argument_list|,
literal|"ancestor"
argument_list|)
condition|)
return|return
name|REL_Ancestor
return|;
elseif|else
if|if
condition|(
name|StrEq
argument_list|(
name|relname
argument_list|,
literal|"descendant"
argument_list|)
condition|)
return|return
name|REL_Descendant
return|;
elseif|else
if|if
condition|(
name|StrEq
argument_list|(
name|relname
argument_list|,
literal|"sibling"
argument_list|)
condition|)
return|return
name|REL_Sibling
return|;
elseif|else
if|if
condition|(
name|StrEq
argument_list|(
name|relname
argument_list|,
literal|"sibling-"
argument_list|)
condition|)
return|return
name|REL_Preceding
return|;
elseif|else
if|if
condition|(
name|StrEq
argument_list|(
name|relname
argument_list|,
literal|"sibling-1"
argument_list|)
condition|)
return|return
name|REL_ImmPreceding
return|;
elseif|else
if|if
condition|(
name|StrEq
argument_list|(
name|relname
argument_list|,
literal|"sibling+"
argument_list|)
condition|)
return|return
name|REL_Following
return|;
elseif|else
if|if
condition|(
name|StrEq
argument_list|(
name|relname
argument_list|,
literal|"sibling+1"
argument_list|)
condition|)
return|return
name|REL_ImmFollowing
return|;
elseif|else
if|if
condition|(
name|StrEq
argument_list|(
name|relname
argument_list|,
literal|"cousin"
argument_list|)
condition|)
return|return
name|REL_Cousin
return|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unknown relationship: %s\n"
argument_list|,
name|relname
argument_list|)
expr_stmt|;
return|return
name|REL_Unknown
return|;
block|}
end_function

begin_comment
comment|/* ______________________________________________________________________ */
end_comment

begin_comment
comment|/*  This will descend the element tree in-order. (enter_f)() is called  *  upon entering the node.  Then all children (data and child elements)  *  are operated on, calling either DescendTree() with a pointer to  *  the child element or (data_f)() for each non-element child node.  *  Before leaving the node (ascending), (leave_f)() is called.  enter_f  *  and leave_f are passed a pointer to this node and data_f is passed  *  a pointer to the data/content (which includes the data itself and  *  type information).  dp is an opaque pointer to any data the caller  *  wants to pass.  *  Arguments:  *	Pointer to element under consideration.  *	Pointer to procedure to call when entering element.  *	Pointer to procedure to call when leaving element.  *	Pointer to procedure to call for each "chunk" of content data.  *	Void data pointer, passed to the avobe 3 procedures.  */
end_comment

begin_function
name|void
name|DescendTree
parameter_list|(
name|Element_t
modifier|*
name|e
parameter_list|,
name|void
function_decl|(
modifier|*
name|enter_f
function_decl|)
parameter_list|()
parameter_list|,
name|void
function_decl|(
modifier|*
name|leave_f
function_decl|)
parameter_list|()
parameter_list|,
name|void
function_decl|(
modifier|*
name|data_f
function_decl|)
parameter_list|()
parameter_list|,
name|void
modifier|*
name|dp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|enter_f
condition|)
call|(
name|enter_f
call|)
argument_list|(
name|e
argument_list|,
name|dp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|e
operator|->
name|ncont
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|e
operator|->
name|cont
index|[
name|i
index|]
operator|.
name|type
operator|==
name|CMD_OPEN
condition|)
name|DescendTree
argument_list|(
name|e
operator|->
name|cont
index|[
name|i
index|]
operator|.
name|ch
operator|.
name|elem
argument_list|,
name|enter_f
argument_list|,
name|leave_f
argument_list|,
name|data_f
argument_list|,
name|dp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|data_f
condition|)
call|(
name|data_f
call|)
argument_list|(
operator|&
name|e
operator|->
name|cont
index|[
name|i
index|]
argument_list|,
name|dp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|leave_f
condition|)
call|(
name|leave_f
call|)
argument_list|(
name|e
argument_list|,
name|dp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ______________________________________________________________________ */
end_comment

begin_comment
comment|/*  Add element, 'e', whose ID is 'idval', to a list of IDs.  *  This makes it easier to find an element by ID later.  *  Arguments:  *	Pointer to element under consideration.  *	Element's ID attribute value (a string).  */
end_comment

begin_function
name|void
name|AddID
parameter_list|(
name|Element_t
modifier|*
name|e
parameter_list|,
name|char
modifier|*
name|idval
parameter_list|)
block|{
specifier|static
name|ID_t
modifier|*
name|id_last
decl_stmt|;
if|if
condition|(
operator|!
name|IDList
condition|)
block|{
name|Malloc
argument_list|(
literal|1
argument_list|,
name|id_last
argument_list|,
name|ID_t
argument_list|)
expr_stmt|;
name|IDList
operator|=
name|id_last
expr_stmt|;
block|}
else|else
block|{
name|Malloc
argument_list|(
literal|1
argument_list|,
name|id_last
operator|->
name|next
argument_list|,
name|ID_t
argument_list|)
expr_stmt|;
name|id_last
operator|=
name|id_last
operator|->
name|next
expr_stmt|;
block|}
name|id_last
operator|->
name|elem
operator|=
name|e
expr_stmt|;
name|id_last
operator|->
name|id
operator|=
name|idval
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ______________________________________________________________________ */
end_comment

begin_comment
comment|/*  Return pointer to element who's ID is given.  *  Arguments:  *	Element's ID attribute value (a string).  *  Return:  *	Pointer to element whose ID matches.  */
end_comment

begin_function
name|Element_t
modifier|*
name|FindElemByID
parameter_list|(
name|char
modifier|*
name|idval
parameter_list|)
block|{
name|ID_t
modifier|*
name|id
decl_stmt|;
for|for
control|(
name|id
operator|=
name|IDList
init|;
name|id
condition|;
name|id
operator|=
name|id
operator|->
name|next
control|)
if|if
condition|(
name|id
operator|->
name|id
index|[
literal|0
index|]
operator|==
name|idval
index|[
literal|0
index|]
operator|&&
operator|!
name|strcmp
argument_list|(
name|id
operator|->
name|id
argument_list|,
name|idval
argument_list|)
condition|)
return|return
name|id
operator|->
name|elem
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ______________________________________________________________________ */
end_comment

end_unit

