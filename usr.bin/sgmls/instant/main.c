begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  Copyright 1993 Open Software Foundation, Inc., Cambridge, Massachusetts.  *  All rights reserved.  */
end_comment

begin_comment
comment|/*  * Copyright (c) 1994    * Open Software Foundation, Inc.   *    * Permission is hereby granted to use, copy, modify and freely distribute   * the software in this file and its documentation for any purpose without   * fee, provided that the above copyright notice appears in all copies and   * that both the copyright notice and this permission notice appear in   * supporting documentation.  Further, provided that the name of Open   * Software Foundation, Inc. ("OSF") not be used in advertising or   * publicity pertaining to distribution of the software without prior   * written permission from OSF.  OSF makes no representations about the   * suitability of this software for any purpose.  It is provided "as is"   * without express or implied warranty.   */
end_comment

begin_comment
comment|/*  * Copyright (c) 1996 X Consortium  * Copyright (c) 1995, 1996 Dalrymple Consulting  *   * Permission is hereby granted, free of charge, to any person obtaining a copy  * of this software and associated documentation files (the "Software"), to deal  * in the Software without restriction, including without limitation the rights  * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell  * copies of the Software, and to permit persons to whom the Software is  * furnished to do so, subject to the following conditions:  *   * The above copyright notice and this permission notice shall be included in  * all copies or substantial portions of the Software.  *   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE  * X CONSORTIUM OR DALRYMPLE CONSULTING BE LIABLE FOR ANY CLAIM, DAMAGES OR  * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,  * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR  * OTHER DEALINGS IN THE SOFTWARE.  *   * Except as contained in this notice, the names of the X Consortium and  * Dalrymple Consulting shall not be used in advertising or otherwise to  * promote the sale, use or other dealings in this Software without prior  * written authorization.  */
end_comment

begin_comment
comment|/* ________________________________________________________________________  *  *  Program to read an SGML document instance, creating any of several things:  *  *	"translated" output for formatting applications (given a trans. spec)  *	validation report (given a appropriate trans spec)  *	tree of the document's structure  *	statistics about the element usage  *	summary of the elements used  *	context of each element used  *	IDs of each element  *  *  A C structure is created for each element, which includes:  *	name, attributes, parent, children, content  *  The tree is descended, and the desired actions performed.  *  *  Takes input from James Clark's "sgmls" program (v. 1.1).  * ________________________________________________________________________  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|RCSid
init|=
literal|"$Header: /usr/src/docbook-to-man/Instant/RCS/main.c,v 1.8 1996/06/12 03:32:48 fld Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<memory.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<locale.h>
end_include

begin_define
define|#
directive|define
name|STORAGE
end_define

begin_include
include|#
directive|include
file|"general.h"
end_include

begin_decl_stmt
specifier|static
name|int
name|do_context
decl_stmt|,
name|do_tree
decl_stmt|,
name|do_summ
decl_stmt|,
name|do_stats
decl_stmt|,
name|do_validate
decl_stmt|,
name|do_idlist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|do_DATAhack
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|this_prog
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|in_file
decl_stmt|,
modifier|*
name|out_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|tranfile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|start_id
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|last_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|last_lineno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|BOFTTextThresh
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* forward references */
end_comment

begin_function_decl
specifier|static
name|void
name|HandleArgs
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
index|[]
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|Initialize1
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|Initialize2
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ReadInstance
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|DoHelpMessage
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|Browse
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* external reference to version number */
end_comment

begin_decl_stmt
name|char
name|_HeadVeRsIoN_
index|[]
init|=
literal|"1.0 (FreeBSD)"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ______________________________________________________________________ */
end_comment

begin_comment
comment|/*  Program entry point.  Look at args, read instance, dispatch to the  *  correct routines to do the work, and finish.  */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|int
name|ac
parameter_list|,
name|char
modifier|*
name|av
index|[]
parameter_list|)
block|{
name|setlocale
argument_list|(
name|LC_ALL
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|Initialize1
argument_list|(
name|av
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|HandleArgs
argument_list|(
name|ac
argument_list|,
name|av
argument_list|)
expr_stmt|;
name|Initialize2
argument_list|()
expr_stmt|;
if|if
condition|(
name|tranfile
condition|)
name|ReadTransSpec
argument_list|(
name|tranfile
argument_list|)
expr_stmt|;
name|ReadInstance
argument_list|(
name|in_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|interactive
condition|)
block|{
name|Browse
argument_list|()
expr_stmt|;
comment|/* this will handle interactive commands */
block|}
else|else
block|{
comment|/* Perform tasks based on command line flags... */
if|if
condition|(
name|tranfile
condition|)
block|{
name|Element_t
modifier|*
name|e
decl_stmt|;
comment|/* If user wants to start at a particular ID, point to that 	     * element.  Else, point to the top of the tree. */
if|if
condition|(
name|start_id
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|e
operator|=
name|FindElemByID
argument_list|(
name|start_id
argument_list|)
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error: Can not find element with ID %s\n"
argument_list|,
name|start_id
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|e
operator|=
name|DocTree
expr_stmt|;
comment|/* If we're doing validation, make output file pointer null. 	     * This means that we generate no output, except error messages. */
if|if
condition|(
name|do_validate
condition|)
name|outfp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|tranfile
condition|)
name|DoTranslate
argument_list|(
name|e
argument_list|,
name|outfp
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Translation spec file not specified. Skipping translation.\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|do_summ
condition|)
name|PrintElemSummary
argument_list|(
name|DocTree
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_tree
condition|)
name|PrintElemTree
argument_list|(
name|DocTree
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_stats
condition|)
name|PrintStats
argument_list|(
name|DocTree
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_context
condition|)
name|PrintContext
argument_list|(
name|DocTree
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_idlist
condition|)
name|PrintIDList
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|out_file
operator|&&
name|outfp
condition|)
name|fclose
argument_list|(
name|outfp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ______________________________________________________________________ */
end_comment

begin_comment
comment|/* Initialization stuff done before dealing with args.  *  Arguments:  *	Name of program (string).  */
end_comment

begin_function
specifier|static
name|void
name|Initialize1
parameter_list|(
name|char
modifier|*
name|myname
parameter_list|)
block|{
name|time_t
name|tnow
decl_stmt|;
name|struct
name|tm
modifier|*
name|nowtm
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
name|buf
index|[
literal|100
index|]
decl_stmt|;
specifier|extern
name|int
name|gethostname
argument_list|(
name|char
operator|*
argument_list|,
name|int
argument_list|)
decl_stmt|;
comment|/* not in a system .h file... */
comment|/* where we try to find data/library files */
if|if
condition|(
operator|!
operator|(
name|tpt_lib
operator|=
name|getenv
argument_list|(
name|TPT_LIB
argument_list|)
operator|)
condition|)
name|tpt_lib
operator|=
name|DEF_TPT_LIB
expr_stmt|;
comment|/* set some global variables */
name|warnings
operator|=
literal|1
expr_stmt|;
name|fold_case
operator|=
literal|1
expr_stmt|;
name|this_prog
operator|=
name|myname
expr_stmt|;
comment|/* setup global variable mapping */
name|Variables
operator|=
name|NewMap
argument_list|(
name|IMS_variables
argument_list|)
expr_stmt|;
comment|/* set some pre-defined variables */
name|SetMappingNV
argument_list|(
name|Variables
argument_list|,
literal|"user"
argument_list|,
operator|(
name|cp
operator|=
name|getenv
argument_list|(
literal|"USER"
argument_list|)
operator|)
condition|?
name|cp
else|:
literal|"UnknownUser"
argument_list|)
expr_stmt|;
name|time
argument_list|(
operator|&
name|tnow
argument_list|)
expr_stmt|;
name|nowtm
operator|=
name|localtime
argument_list|(
operator|&
name|tnow
argument_list|)
expr_stmt|;
name|strftime
argument_list|(
name|buf
argument_list|,
literal|100
argument_list|,
literal|"%a %d %b %Y, %R"
argument_list|,
name|nowtm
argument_list|)
expr_stmt|;
name|SetMappingNV
argument_list|(
name|Variables
argument_list|,
literal|"date"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|gethostname
argument_list|(
name|buf
argument_list|,
literal|100
argument_list|)
operator|<
literal|0
condition|)
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"unknown-host"
argument_list|)
expr_stmt|;
name|SetMappingNV
argument_list|(
name|Variables
argument_list|,
literal|"host"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|SetMappingNV
argument_list|(
name|Variables
argument_list|,
literal|"transpec"
argument_list|,
name|tranfile
condition|?
name|tranfile
else|:
literal|"??"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialization stuff done after dealing with args. */
end_comment

begin_function
specifier|static
name|void
name|Initialize2
parameter_list|()
block|{
name|SetMappingNV
argument_list|(
name|Variables
argument_list|,
literal|"transpec"
argument_list|,
name|tranfile
condition|?
name|tranfile
else|:
literal|"??"
argument_list|)
expr_stmt|;
comment|/* If user wants to send output to a file, open the file, and set      * the file pointer.  Else we send output to standard out. */
if|if
condition|(
name|out_file
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|outfp
operator|=
name|fopen
argument_list|(
name|out_file
argument_list|,
literal|"w"
argument_list|)
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Could not open output '%s' file for writing.\n%s"
argument_list|,
name|out_file
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|outfp
operator|=
name|stdout
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ______________________________________________________________________ */
end_comment

begin_comment
comment|/*  Set a variable.  If it is one of the "known" variables, set the  *  variable in the C code (this program).  *  Arguments:  *	Variable name/value string - separated by an '=' (eg, "myname=Sally").  */
end_comment

begin_function
specifier|static
name|void
name|CmdLineSetVariable
parameter_list|(
name|char
modifier|*
name|var
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|,
name|buf
index|[
literal|100
index|]
decl_stmt|,
modifier|*
modifier|*
name|tok
decl_stmt|;
name|int
name|n
decl_stmt|;
comment|/* Turn '=' into a space, to isolate the name.  Then set variable. */
name|strcpy
argument_list|(
name|buf
argument_list|,
name|var
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|strchr
argument_list|(
name|buf
argument_list|,
literal|'='
argument_list|)
operator|)
condition|)
block|{
comment|/* we have "var=value" */
operator|*
name|cp
operator|=
literal|' '
expr_stmt|;
name|n
operator|=
literal|2
expr_stmt|;
name|tok
operator|=
name|Split
argument_list|(
name|buf
argument_list|,
operator|&
name|n
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* see if variable name matches one of our internal ones */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|tok
index|[
literal|0
index|]
argument_list|,
literal|"verbose"
argument_list|)
condition|)
name|verbose
operator|=
name|atoi
argument_list|(
name|tok
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|tok
index|[
literal|0
index|]
argument_list|,
literal|"warnings"
argument_list|)
condition|)
name|warnings
operator|=
name|atoi
argument_list|(
name|tok
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|tok
index|[
literal|0
index|]
argument_list|,
literal|"foldcase"
argument_list|)
condition|)
name|fold_case
operator|=
name|atoi
argument_list|(
name|tok
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
name|SetMappingNV
argument_list|(
name|Variables
argument_list|,
name|tok
index|[
literal|0
index|]
argument_list|,
name|tok
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Expected an '=' in variable assignment: %s. Ignored\n"
argument_list|,
name|var
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ______________________________________________________________________ */
end_comment

begin_comment
comment|/*  Bounce through arguments, setting variables and flags.  *  Arguments:  *	Argc and Argv, as passed to main().  */
end_comment

begin_function
specifier|static
name|void
name|HandleArgs
parameter_list|(
name|int
name|ac
parameter_list|,
name|char
modifier|*
name|av
index|[]
parameter_list|)
block|{
name|int
name|c
decl_stmt|,
name|errflag
init|=
literal|0
decl_stmt|;
specifier|extern
name|char
modifier|*
name|optarg
decl_stmt|;
specifier|extern
name|int
name|optind
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|ac
argument_list|,
name|av
argument_list|,
literal|"df:t:v:o:huSxIl:bHVWi:D:Z"
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'t'
case|:
name|tranfile
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|do_validate
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|do_tree
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|do_summ
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|do_stats
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|do_context
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
name|do_idlist
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|tpt_lib
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|start_id
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|out_file
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|do_DATAhack
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|BOFTTextThresh
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|interactive
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'W'
case|:
name|warnings
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
name|verbose
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'Z'
case|:
name|slave
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
name|DoHelpMessage
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|CmdLineSetVariable
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
name|errflag
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|errflag
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Try '%s -H' for help.\n"
argument_list|,
name|this_prog
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* input (ESIS) file name */
if|if
condition|(
name|optind
operator|<
name|ac
condition|)
name|in_file
operator|=
name|av
index|[
name|optind
index|]
expr_stmt|;
comment|/* If doing interactive/browsing, we can't take ESIS from stdin. */
if|if
condition|(
name|interactive
operator|&&
operator|!
name|in_file
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"You must specify ESIS file on cmd line for browser mode.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ______________________________________________________________________ */
end_comment

begin_comment
comment|/*  Simply print out a help/usage message.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|help_msg
index|[]
init|=
block|{
literal|""
block|,
literal|"  -t file   Print translated output using translation spec in<file>"
block|,
literal|"  -v        Validate using translation spec specified with -t"
block|,
literal|"  -i id     Consider only subtree starting at element with ID<id>"
block|,
literal|"  -b        Interactive browser"
block|,
literal|"  -S        Print statistics (how often elements occur, etc.)"
block|,
literal|"  -u        Print element usage summary (# of children, depth, etc.)"
block|,
literal|"  -x        Print context of each element"
block|,
literal|"  -h        Print document hierarchy as a tree"
block|,
literal|"  -o file   Write output to<file>.  Default is standard output."
block|,
literal|"  -l dir    Set library directory to<dir>. (or env. variable TPT_LIB)"
block|,
literal|"  -I        List all IDs used in the instance"
block|,
literal|"  -W        Do not print warning messages"
block|,
literal|"  -H        Print this help message"
block|,
literal|"  -Dvar=val Set variable 'var' to value 'val'"
block|,
literal|"  file      Take input from named file.  If not specified, assume stdin."
block|,
literal|"            File should be output from the 'sgmls' program (ESIS)."
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|DoHelpMessage
parameter_list|()
block|{
name|char
modifier|*
modifier|*
name|s
init|=
name|help_msg
decl_stmt|;
name|printf
argument_list|(
literal|"usage: %s [option ...] [file]"
argument_list|,
name|this_prog
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
name|puts
argument_list|(
operator|*
name|s
operator|++
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\nVersion: %s\n"
argument_list|,
name|_HeadVeRsIoN_
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ______________________________________________________________________ */
end_comment

begin_comment
comment|/*  Remember an external entity for future reference.  *  Arguments:  *	Pointer to entity structure to remember.  */
end_comment

begin_function
specifier|static
name|void
name|AddEntity
parameter_list|(
name|Entity_t
modifier|*
name|ent
parameter_list|)
block|{
specifier|static
name|Entity_t
modifier|*
name|last_ent
decl_stmt|;
if|if
condition|(
operator|!
name|Entities
condition|)
block|{
name|Malloc
argument_list|(
literal|1
argument_list|,
name|Entities
argument_list|,
name|Entity_t
argument_list|)
expr_stmt|;
name|last_ent
operator|=
name|Entities
expr_stmt|;
block|}
else|else
block|{
name|Malloc
argument_list|(
literal|1
argument_list|,
name|last_ent
operator|->
name|next
argument_list|,
name|Entity_t
argument_list|)
expr_stmt|;
name|last_ent
operator|=
name|last_ent
operator|->
name|next
expr_stmt|;
block|}
operator|*
name|last_ent
operator|=
operator|*
name|ent
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  Find an entity, given its entity name.  *  Arguments:  *	Name of entity to retrieve.  */
end_comment

begin_function
specifier|static
name|Entity_t
modifier|*
name|FindEntity
parameter_list|(
name|char
modifier|*
name|ename
parameter_list|)
block|{
name|Entity_t
modifier|*
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
name|Entities
init|;
name|n
condition|;
name|n
operator|=
name|n
operator|->
name|next
control|)
if|if
condition|(
name|StrEq
argument_list|(
name|ename
argument_list|,
name|n
operator|->
name|ename
argument_list|)
condition|)
return|return
name|n
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  Accumulate lines up to the open tag.  Attributes, line number,  *  entity info, notation info, etc., all come before the open tag.  */
end_comment

begin_function
specifier|static
name|Element_t
modifier|*
name|AccumElemInfo
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|char
name|buf
index|[
name|LINESIZE
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|c
decl_stmt|;
name|int
name|i
decl_stmt|,
name|na
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|atval
decl_stmt|;
name|Mapping_t
name|a
index|[
literal|100
index|]
decl_stmt|;
name|Element_t
modifier|*
name|e
decl_stmt|;
name|Entity_t
name|ent
decl_stmt|,
modifier|*
name|ent2
decl_stmt|;
name|char
modifier|*
modifier|*
name|tok
decl_stmt|;
specifier|static
name|int
name|Index
init|=
literal|0
decl_stmt|;
specifier|static
name|Element_t
modifier|*
name|last_e
decl_stmt|;
name|Calloc
argument_list|(
literal|1
argument_list|,
name|e
argument_list|,
name|Element_t
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|ent
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|ent
argument_list|)
expr_stmt|;
comment|/* clean space for entity info */
comment|/* Also, keep a linked list of elements, so we can easily scan through */
if|if
condition|(
name|last_e
condition|)
name|last_e
operator|->
name|next
operator|=
name|e
expr_stmt|;
name|last_e
operator|=
name|e
expr_stmt|;
name|e
operator|->
name|index
operator|=
name|Index
operator|++
expr_stmt|;
comment|/* just a unique number for identification */
comment|/* in case these are not set for this element in the ESIS */
name|e
operator|->
name|lineno
operator|=
name|last_lineno
expr_stmt|;
name|e
operator|->
name|infile
operator|=
name|last_file
expr_stmt|;
name|na
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|==
name|EOF
condition|)
break|break;
name|fgets
argument_list|(
name|buf
argument_list|,
name|LINESIZE
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|stripNL
argument_list|(
name|buf
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|EOF
case|:
comment|/* End of input */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error: Unexpectedly reached end of ESIS.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMD_OPEN
case|:
comment|/* (gi */
name|e
operator|->
name|gi
operator|=
name|AddElemName
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|na
operator|>
literal|0
condition|)
block|{
name|Malloc
argument_list|(
name|na
argument_list|,
name|e
operator|->
name|atts
argument_list|,
name|Mapping_t
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|e
operator|->
name|atts
argument_list|,
name|a
argument_list|,
name|na
operator|*
sizeof|sizeof
argument_list|(
name|Mapping_t
argument_list|)
argument_list|)
expr_stmt|;
name|e
operator|->
name|natts
operator|=
name|na
expr_stmt|;
name|na
operator|=
literal|0
expr_stmt|;
block|}
comment|/*  Check if this elem has a notation attr.  If yes, and there 		    is no notation specified, recall the previous one. (feature 		    of sgmls - it does not repeat notation stuff if we the same 		    is used twice in a row) */
if|if
condition|(
operator|(
operator|(
name|atval
operator|=
name|FindAttValByName
argument_list|(
name|e
argument_list|,
literal|"NAME"
argument_list|)
operator|)
operator|||
operator|(
name|atval
operator|=
name|FindAttValByName
argument_list|(
name|e
argument_list|,
literal|"ENTITYREF"
argument_list|)
operator|)
operator|||
operator|(
name|atval
operator|=
name|FindAttValByName
argument_list|(
name|e
argument_list|,
literal|"EXTERNAL"
argument_list|)
operator|)
operator|)
operator|&&
comment|/* HACK */
operator|(
name|ent2
operator|=
name|FindEntity
argument_list|(
name|atval
argument_list|)
operator|)
condition|)
block|{
name|e
operator|->
name|entity
operator|=
name|ent2
expr_stmt|;
block|}
return|return
name|e
return|;
break|break;
case|case
name|CMD_ATT
case|:
comment|/* Aname val */
name|i
operator|=
literal|3
expr_stmt|;
name|tok
operator|=
name|Split
argument_list|(
name|buf
argument_list|,
operator|&
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|tok
index|[
literal|1
index|]
argument_list|,
literal|"IMPLIED"
argument_list|)
condition|)
break|break;
comment|/* skip IMPLIED atts. */
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|tok
index|[
literal|1
index|]
argument_list|,
literal|"CDATA"
argument_list|)
condition|)
block|{
comment|/* CDATA attributes must have ESIS escape     	    	       sequences and SDATA entities expanded. */
name|char
modifier|*
name|val
init|=
name|ExpandString
argument_list|(
name|tok
index|[
literal|2
index|]
argument_list|)
decl_stmt|;
name|a
index|[
name|na
index|]
operator|.
name|name
operator|=
name|AddAttName
argument_list|(
name|tok
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|a
index|[
name|na
index|]
operator|.
name|sval
operator|=
name|AddAttName
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|na
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|tok
index|[
literal|1
index|]
argument_list|,
literal|"TOKEN"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|tok
index|[
literal|1
index|]
argument_list|,
literal|"ENTITY"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|tok
index|[
literal|1
index|]
argument_list|,
literal|"NOTATION"
argument_list|)
condition|)
block|{
name|a
index|[
name|na
index|]
operator|.
name|name
operator|=
name|AddAttName
argument_list|(
name|tok
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|a
index|[
name|na
index|]
operator|.
name|sval
operator|=
name|AddAttName
argument_list|(
name|tok
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|na
operator|++
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error: Bad attr line (%d): A%s %s...\n"
argument_list|,
name|e
operator|->
name|lineno
argument_list|,
name|tok
index|[
literal|0
index|]
argument_list|,
name|tok
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CMD_LINE
case|:
comment|/* Llineno */
comment|/* These lines come in 2 forms: "L123" and "L123 file.sgml". 		 * Filename is given only at 1st occurance. Remember it. 		 */
if|if
condition|(
operator|(
name|cp
operator|=
name|strchr
argument_list|(
name|buf
argument_list|,
literal|' '
argument_list|)
operator|)
condition|)
block|{
name|cp
operator|++
expr_stmt|;
name|last_file
operator|=
name|strdup
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
name|last_lineno
operator|=
name|e
operator|->
name|lineno
operator|=
name|atoi
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|e
operator|->
name|infile
operator|=
name|last_file
expr_stmt|;
break|break;
case|case
name|CMD_DATA
case|:
comment|/* -data */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error: Data in AccumElemInfo, line %d:\n%c%s\n"
argument_list|,
name|e
operator|->
name|lineno
argument_list|,
name|c
argument_list|,
name|buf
argument_list|)
expr_stmt|;
comment|/*return e;*/
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMD_D_ATT
case|:
comment|/* Dename name val */
case|case
name|CMD_NOTATION
case|:
comment|/* Nnname */
case|case
name|CMD_PI
case|:
comment|/* ?pi */
comment|/* This should be reworked soon, as it  				   forces all PI's before the first GI 				   to be ignored. -CSS */
break|break;
case|case
name|CMD_EXT_ENT
case|:
comment|/* Eename typ nname */
name|i
operator|=
literal|3
expr_stmt|;
name|tok
operator|=
name|Split
argument_list|(
name|buf
argument_list|,
operator|&
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ent
operator|.
name|ename
operator|=
name|strdup
argument_list|(
name|tok
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ent
operator|.
name|type
operator|=
name|strdup
argument_list|(
name|tok
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ent
operator|.
name|nname
operator|=
name|strdup
argument_list|(
name|tok
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|AddEntity
argument_list|(
operator|&
name|ent
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMD_INT_ENT
case|:
comment|/* Iename typ text */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error: Got CMD_INT_ENT in AccumElemInfo: %s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMD_SYSID
case|:
comment|/* ssysid */
name|ent
operator|.
name|sysid
operator|=
name|strdup
argument_list|(
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMD_PUBID
case|:
comment|/* ppubid */
name|ent
operator|.
name|pubid
operator|=
name|strdup
argument_list|(
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMD_FILENAME
case|:
comment|/* ffilename */
name|ent
operator|.
name|fname
operator|=
name|strdup
argument_list|(
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMD_CLOSE
case|:
comment|/* )gi */
case|case
name|CMD_SUBDOC
case|:
comment|/* Sename */
case|case
name|CMD_SUBDOC_S
case|:
comment|/* {ename */
case|case
name|CMD_SUBDOC_E
case|:
comment|/* }ename */
case|case
name|CMD_EXT_REF
case|:
comment|/*&name */
case|case
name|CMD_APPINFO
case|:
comment|/* #text */
case|case
name|CMD_CONFORM
case|:
comment|/* C */
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error: Unexpected input in AccumElemInfo, %d:\n%c%s\n"
argument_list|,
name|e
operator|->
name|lineno
argument_list|,
name|c
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error: End of AccumElemInfo - should not be here: %s\n"
argument_list|,
name|e
operator|->
name|gi
argument_list|)
expr_stmt|;
comment|/*    return e;*/
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  Read ESIS lines.  *  Limitation?  Max 5000 children per node.  (done for efficiency --  *  should do some malloc and bookkeeping games later).  */
end_comment

begin_function
specifier|static
name|Element_t
modifier|*
name|ReadESIS
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|int
name|depth
parameter_list|)
block|{
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|i
decl_stmt|,
name|c
decl_stmt|,
name|ncont
decl_stmt|;
name|Element_t
modifier|*
name|e
decl_stmt|;
name|Content_t
name|cont
index|[
literal|5000
index|]
decl_stmt|;
name|Malloc
argument_list|(
name|LINESIZE
operator|+
literal|1
argument_list|,
name|buf
argument_list|,
name|char
argument_list|)
expr_stmt|;
comment|/* Read input stream - the output of "sgmls", called "ESIS".  */
name|e
operator|=
name|AccumElemInfo
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|e
operator|->
name|depth
operator|=
name|depth
expr_stmt|;
name|ncont
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|==
name|EOF
condition|)
break|break;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|EOF
case|:
comment|/* End of input */
break|break;
case|case
name|CMD_DATA
case|:
comment|/* -data */
name|fgets
argument_list|(
name|buf
argument_list|,
name|LINESIZE
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|stripNL
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_DATAhack
operator|&&
operator|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'\\'
operator|)
operator|&&
operator|(
name|buf
index|[
literal|1
index|]
operator|==
literal|'n'
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|buf
index|[
literal|2
index|]
condition|)
break|break;
name|buf
index|[
literal|0
index|]
operator|=
literal|' '
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|buf
index|[
literal|1
index|]
argument_list|,
operator|&
name|buf
index|[
literal|2
index|]
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|cont
index|[
name|ncont
index|]
operator|.
name|ch
operator|.
name|data
operator|=
name|ExpandString
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|cont
index|[
name|ncont
index|]
operator|.
name|type
operator|=
name|CMD_DATA
expr_stmt|;
name|ncont
operator|++
expr_stmt|;
break|break;
case|case
name|CMD_PI
case|:
comment|/* ?pi */
name|fgets
argument_list|(
name|buf
argument_list|,
name|LINESIZE
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|stripNL
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|cont
index|[
name|ncont
index|]
operator|.
name|type
operator|=
name|CMD_PI
expr_stmt|;
name|cont
index|[
name|ncont
index|]
operator|.
name|ch
operator|.
name|data
operator|=
name|strdup
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|ncont
operator|++
expr_stmt|;
break|break;
case|case
name|CMD_CLOSE
case|:
comment|/* )gi */
name|fgets
argument_list|(
name|buf
argument_list|,
name|LINESIZE
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|stripNL
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ncont
condition|)
block|{
name|e
operator|->
name|ncont
operator|=
name|ncont
expr_stmt|;
name|Malloc
argument_list|(
name|ncont
argument_list|,
name|e
operator|->
name|cont
argument_list|,
name|Content_t
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ncont
condition|;
name|i
operator|++
control|)
name|e
operator|->
name|cont
index|[
name|i
index|]
operator|=
name|cont
index|[
name|i
index|]
expr_stmt|;
block|}
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|e
return|;
break|break;
case|case
name|CMD_OPEN
case|:
comment|/* (gi */
comment|/*fprintf(stderr, "+++++ OPEN +++\n");*/
comment|/*		break;*/
case|case
name|CMD_ATT
case|:
comment|/* Aname val */
case|case
name|CMD_D_ATT
case|:
comment|/* Dename name val */
case|case
name|CMD_NOTATION
case|:
comment|/* Nnname */
case|case
name|CMD_EXT_ENT
case|:
comment|/* Eename typ nname */
case|case
name|CMD_INT_ENT
case|:
comment|/* Iename typ text */
case|case
name|CMD_SYSID
case|:
comment|/* ssysid */
case|case
name|CMD_PUBID
case|:
comment|/* ppubid */
case|case
name|CMD_FILENAME
case|:
comment|/* ffilename */
name|ungetc
argument_list|(
name|c
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|cont
index|[
name|ncont
index|]
operator|.
name|ch
operator|.
name|elem
operator|=
name|ReadESIS
argument_list|(
name|fp
argument_list|,
name|depth
operator|+
literal|1
argument_list|)
expr_stmt|;
name|cont
index|[
name|ncont
index|]
operator|.
name|type
operator|=
name|CMD_OPEN
expr_stmt|;
name|cont
index|[
name|ncont
index|]
operator|.
name|ch
operator|.
name|elem
operator|->
name|parent
operator|=
name|e
expr_stmt|;
name|ncont
operator|++
expr_stmt|;
break|break;
case|case
name|CMD_LINE
case|:
comment|/* Llineno */
name|fgets
argument_list|(
name|buf
argument_list|,
name|LINESIZE
argument_list|,
name|fp
argument_list|)
expr_stmt|;
break|break;
comment|/* ignore these here */
case|case
name|CMD_SUBDOC
case|:
comment|/* Sename */
case|case
name|CMD_SUBDOC_S
case|:
comment|/* {ename */
case|case
name|CMD_SUBDOC_E
case|:
comment|/* }ename */
case|case
name|CMD_EXT_REF
case|:
comment|/*&name */
case|case
name|CMD_APPINFO
case|:
comment|/* #text */
case|case
name|CMD_CONFORM
case|:
comment|/* C */
default|default:
name|fgets
argument_list|(
name|buf
argument_list|,
name|LINESIZE
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error: Unexpected input at %d: '%c%s'\n"
argument_list|,
name|e
operator|->
name|lineno
argument_list|,
name|c
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error: End of ReadESIS - should not be here: %s\n"
argument_list|,
name|e
operator|->
name|gi
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* ______________________________________________________________________ */
end_comment

begin_comment
comment|/*  Read input stream, creating a tree in memory of the elements and data.  *  Arguments:  *	Filename where instance's ESIS is.  */
end_comment

begin_function
specifier|static
name|void
name|ReadInstance
parameter_list|(
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|Element_t
modifier|*
name|e
decl_stmt|;
name|char
modifier|*
name|idatt
decl_stmt|;
if|if
condition|(
name|filename
condition|)
block|{
comment|/* if we specified input file.  else stdin */
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|fp
operator|=
name|stdin
expr_stmt|;
name|last_file
operator|=
name|filename
expr_stmt|;
name|DocTree
operator|=
name|ReadESIS
argument_list|(
name|fp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|filename
condition|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
comment|/* Traverse tree, filling in econt and figuring out which child      * (ie. what birth order) each element is. */
name|DocTree
operator|->
name|my_eorder
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|e
operator|=
name|DocTree
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|next
control|)
block|{
comment|/* count element children */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|n
operator|=
literal|0
init|;
name|i
operator|<
name|e
operator|->
name|ncont
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|IsContElem
argument_list|(
name|e
argument_list|,
name|i
argument_list|)
condition|)
name|n
operator|++
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
condition|)
name|Calloc
argument_list|(
name|n
argument_list|,
name|e
operator|->
name|econt
argument_list|,
name|Element_t
operator|*
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|e
operator|->
name|ncont
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|IsContElem
argument_list|(
name|e
argument_list|,
name|i
argument_list|)
condition|)
name|e
operator|->
name|econt
index|[
name|e
operator|->
name|necont
operator|++
index|]
operator|=
name|ContElem
argument_list|(
name|e
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* count data children */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|n
operator|=
literal|0
init|;
name|i
operator|<
name|e
operator|->
name|ncont
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|IsContData
argument_list|(
name|e
argument_list|,
name|i
argument_list|)
condition|)
name|n
operator|++
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
condition|)
name|Calloc
argument_list|(
name|n
argument_list|,
name|e
operator|->
name|dcont
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|e
operator|->
name|ncont
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|IsContData
argument_list|(
name|e
argument_list|,
name|i
argument_list|)
condition|)
name|e
operator|->
name|dcont
index|[
name|e
operator|->
name|ndcont
operator|++
index|]
operator|=
name|ContData
argument_list|(
name|e
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* where in child order order */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|e
operator|->
name|necont
condition|;
name|i
operator|++
control|)
name|e
operator|->
name|econt
index|[
name|i
index|]
operator|->
name|my_eorder
operator|=
name|i
expr_stmt|;
comment|/* Does this element have an ID? */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|e
operator|->
name|natts
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|idatt
operator|=
name|FindAttValByName
argument_list|(
name|e
argument_list|,
literal|"ID"
argument_list|)
operator|)
condition|)
block|{
name|AddID
argument_list|(
name|e
argument_list|,
name|idatt
argument_list|)
expr_stmt|;
comment|/* remember ID value for quick reference */
name|e
operator|->
name|id
operator|=
name|idatt
expr_stmt|;
break|break;
block|}
block|}
block|}
return|return;
block|}
end_function

begin_comment
comment|/* ______________________________________________________________________ */
end_comment

end_unit

