begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  Copyright 1993 Open Software Foundation, Inc., Cambridge, Massachusetts.  *  All rights reserved.  */
end_comment

begin_comment
comment|/*  * Copyright (c) 1994    * Open Software Foundation, Inc.   *    * Permission is hereby granted to use, copy, modify and freely distribute   * the software in this file and its documentation for any purpose without   * fee, provided that the above copyright notice appears in all copies and   * that both the copyright notice and this permission notice appear in   * supporting documentation.  Further, provided that the name of Open   * Software Foundation, Inc. ("OSF") not be used in advertising or   * publicity pertaining to distribution of the software without prior   * written permission from OSF.  OSF makes no representations about the   * suitability of this software for any purpose.  It is provided "as is"   * without express or implied warranty.   */
end_comment

begin_comment
comment|/*  * Copyright (c) 1996 X Consortium  * Copyright (c) 1995, 1996 Dalrymple Consulting  *   * Permission is hereby granted, free of charge, to any person obtaining a copy  * of this software and associated documentation files (the "Software"), to deal  * in the Software without restriction, including without limitation the rights  * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell  * copies of the Software, and to permit persons to whom the Software is  * furnished to do so, subject to the following conditions:  *   * The above copyright notice and this permission notice shall be included in  * all copies or substantial portions of the Software.  *   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE  * X CONSORTIUM OR DALRYMPLE CONSULTING BE LIABLE FOR ANY CLAIM, DAMAGES OR  * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,  * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR  * OTHER DEALINGS IN THE SOFTWARE.  *   * Except as contained in this notice, the names of the X Consortium and  * Dalrymple Consulting shall not be used in advertising or otherwise to  * promote the sale, use or other dealings in this Software without prior  * written authorization.  */
end_comment

begin_comment
comment|/* ________________________________________________________________________  *  *  instant - a program to manipulate SGML instances.  *  *  This module is for handling "special variables".  These act a lot like  *  procedure calls  * ________________________________________________________________________  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|RCSid
init|=
literal|"$Header: /home/ncvs/src/usr.bin/sgmls/instant/tranvar.c,v 1.2 1997/01/08 01:40:52 jfieber Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<memory.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<regexp.h>
end_include

begin_include
include|#
directive|include
file|"general.h"
end_include

begin_include
include|#
directive|include
file|"translate.h"
end_include

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|idrefs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list of IDREF att names to follow */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|def_idrefs
index|[]
init|=
block|{
literal|"LINKEND"
block|,
literal|"LINKENDS"
block|,
literal|"IDREF"
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|each_A
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* last seen _eachatt */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|each_C
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* last seen _eachcon */
end_comment

begin_comment
comment|/* forward references */
end_comment

begin_function_decl
name|void
name|ChaseIDRefs
parameter_list|(
name|Element_t
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|Find
parameter_list|(
name|Element_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|GetIDREFnames
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* ______________________________________________________________________ */
end_comment

begin_comment
comment|/*  Handle "special" variable - read file, run command, do action, etc.  *  Arguments:  *	Name of special variable to expand.  *	Pointer to element under consideration.  *	FILE pointer to where to write output.  *	Flag saying whether to track the character position we're on  *	  (passed to OutputString).  */
end_comment

begin_function
name|void
name|ExpandSpecialVar
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|Element_t
modifier|*
name|e
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
name|int
name|track_pos
parameter_list|)
block|{
name|FILE
modifier|*
name|infile
decl_stmt|;
name|char
name|buf
index|[
name|LINESIZE
index|]
decl_stmt|,
modifier|*
name|cp
decl_stmt|,
modifier|*
name|atval
decl_stmt|;
name|char
modifier|*
modifier|*
name|tok
decl_stmt|;
name|int
name|ntok
decl_stmt|,
name|n
decl_stmt|,
name|i
decl_stmt|,
name|actioni
decl_stmt|;
name|char
modifier|*
name|action
decl_stmt|,
modifier|*
name|action1
decl_stmt|;
name|Element_t
modifier|*
name|ep
decl_stmt|;
name|Trans_t
modifier|*
name|t
decl_stmt|,
modifier|*
name|tt
decl_stmt|;
comment|/* Run a command.      * Format: _! command args ... */
if|if
condition|(
operator|*
name|name
operator|==
literal|'!'
condition|)
block|{
name|name
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|infile
operator|=
name|popen
argument_list|(
name|name
argument_list|,
literal|"r"
argument_list|)
operator|)
condition|)
block|{
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
name|LINESIZE
argument_list|,
name|infile
argument_list|)
condition|)
name|fputs
argument_list|(
name|buf
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|pclose
argument_list|(
name|infile
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Could not start program '%s': %s"
argument_list|,
name|name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|/* See if caller wants one of the tokens from _eachatt or _eachcon.      * If so, output it and return.  (Yes, I admit that this is a hack.)      */
if|if
condition|(
operator|*
name|name
operator|==
literal|'A'
operator|&&
name|name
index|[
literal|1
index|]
operator|==
name|EOS
operator|&&
name|each_A
condition|)
block|{
name|OutputString
argument_list|(
name|each_A
argument_list|,
name|fp
argument_list|,
name|track_pos
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|*
name|name
operator|==
literal|'C'
operator|&&
name|name
index|[
literal|1
index|]
operator|==
name|EOS
operator|&&
name|each_C
condition|)
block|{
name|OutputString
argument_list|(
name|each_C
argument_list|,
name|fp
argument_list|,
name|track_pos
argument_list|)
expr_stmt|;
return|return;
block|}
name|ntok
operator|=
literal|0
expr_stmt|;
name|tok
operator|=
name|Split
argument_list|(
name|name
argument_list|,
operator|&
name|ntok
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Include another file.      * Format: _include filename */
if|if
condition|(
name|StrEq
argument_list|(
name|tok
index|[
literal|0
index|]
argument_list|,
literal|"include"
argument_list|)
condition|)
block|{
name|name
operator|=
name|tok
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|ntok
operator|>
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|infile
operator|=
name|OpenFile
argument_list|(
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"Can not open included file '%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
name|LINESIZE
argument_list|,
name|infile
argument_list|)
condition|)
name|fputs
argument_list|(
name|buf
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|infile
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No file name specified for include\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Print location (nearest title, line no, path).      * Format: _location */
elseif|else
if|if
condition|(
name|StrEq
argument_list|(
name|tok
index|[
literal|0
index|]
argument_list|,
literal|"location"
argument_list|)
condition|)
block|{
name|PrintLocation
argument_list|(
name|e
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
comment|/* Print path to this element.      * Format: _path */
elseif|else
if|if
condition|(
name|StrEq
argument_list|(
name|tok
index|[
literal|0
index|]
argument_list|,
literal|"path"
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|FindElementPath
argument_list|(
name|e
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|OutputString
argument_list|(
name|buf
argument_list|,
name|fp
argument_list|,
name|track_pos
argument_list|)
expr_stmt|;
block|}
comment|/* Print name of this element (gi).      * Format: _gi [M|L|U] */
elseif|else
if|if
condition|(
name|StrEq
argument_list|(
name|tok
index|[
literal|0
index|]
argument_list|,
literal|"gi"
argument_list|)
condition|)
block|{
name|strcpy
argument_list|(
name|buf
argument_list|,
name|e
operator|->
name|gi
argument_list|)
expr_stmt|;
if|if
condition|(
name|ntok
operator|>=
literal|2
condition|)
block|{
if|if
condition|(
operator|*
name|tok
index|[
literal|1
index|]
operator|==
literal|'L'
operator|||
operator|*
name|tok
index|[
literal|1
index|]
operator|==
literal|'l'
operator|||
operator|*
name|tok
index|[
literal|1
index|]
operator|==
literal|'M'
operator|||
operator|*
name|tok
index|[
literal|1
index|]
operator|==
literal|'m'
condition|)
block|{
for|for
control|(
name|cp
operator|=
name|buf
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
if|if
condition|(
name|isupper
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
operator|*
name|cp
operator|=
name|tolower
argument_list|(
operator|*
name|cp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|tok
index|[
literal|1
index|]
operator|==
literal|'M'
operator|||
operator|*
name|tok
index|[
literal|1
index|]
operator|==
literal|'m'
condition|)
if|if
condition|(
name|islower
argument_list|(
name|buf
index|[
literal|0
index|]
argument_list|)
condition|)
name|buf
index|[
literal|0
index|]
operator|=
name|toupper
argument_list|(
name|buf
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
name|OutputString
argument_list|(
name|buf
argument_list|,
name|fp
argument_list|,
name|track_pos
argument_list|)
expr_stmt|;
block|}
comment|/* Print filename of this element's associated external entity.      * Format: _filename */
elseif|else
if|if
condition|(
name|StrEq
argument_list|(
name|tok
index|[
literal|0
index|]
argument_list|,
literal|"filename"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|e
operator|->
name|entity
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Expected ext entity (internal error? bug?):\n"
argument_list|)
expr_stmt|;
name|PrintLocation
argument_list|(
name|e
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|e
operator|->
name|entity
operator|->
name|fname
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Expected filename (internal error? bug?):\n"
argument_list|)
expr_stmt|;
name|PrintLocation
argument_list|(
name|e
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
return|return;
block|}
name|OutputString
argument_list|(
name|e
operator|->
name|entity
operator|->
name|fname
argument_list|,
name|fp
argument_list|,
name|track_pos
argument_list|)
expr_stmt|;
block|}
comment|/* Value of parent's attribute, by attr name.      * Format: _pattr attname */
elseif|else
if|if
condition|(
name|StrEq
argument_list|(
name|tok
index|[
literal|0
index|]
argument_list|,
literal|"pattr"
argument_list|)
condition|)
block|{
name|ep
operator|=
name|e
operator|->
name|parent
expr_stmt|;
if|if
condition|(
operator|!
name|ep
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Element does not have a parent:\n"
argument_list|)
expr_stmt|;
name|PrintLocation
argument_list|(
name|ep
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|atval
operator|=
name|FindAttValByName
argument_list|(
name|ep
argument_list|,
name|tok
index|[
literal|1
index|]
argument_list|)
operator|)
condition|)
block|{
name|OutputString
argument_list|(
name|atval
argument_list|,
name|fp
argument_list|,
name|track_pos
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Use an action, given transpec's SID.      * Format: _action action */
elseif|else
if|if
condition|(
name|StrEq
argument_list|(
name|tok
index|[
literal|0
index|]
argument_list|,
literal|"action"
argument_list|)
condition|)
block|{
name|TranTByAction
argument_list|(
name|e
argument_list|,
name|tok
index|[
literal|1
index|]
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
comment|/* Number of child elements of this element.      * Format: _nchild */
elseif|else
if|if
condition|(
name|StrEq
argument_list|(
name|tok
index|[
literal|0
index|]
argument_list|,
literal|"nchild"
argument_list|)
condition|)
block|{
if|if
condition|(
name|ntok
operator|>
literal|1
condition|)
block|{
for|for
control|(
name|n
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|e
operator|->
name|necont
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|StrEq
argument_list|(
name|e
operator|->
name|econt
index|[
name|i
index|]
operator|->
name|gi
argument_list|,
name|tok
index|[
literal|1
index|]
argument_list|)
condition|)
name|n
operator|++
expr_stmt|;
block|}
else|else
name|n
operator|=
name|e
operator|->
name|necont
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|OutputString
argument_list|(
name|buf
argument_list|,
name|fp
argument_list|,
name|track_pos
argument_list|)
expr_stmt|;
block|}
comment|/* number of 1st child's child elements (grandchildren from first child).      * Format: _n1gchild */
elseif|else
if|if
condition|(
name|StrEq
argument_list|(
name|tok
index|[
literal|0
index|]
argument_list|,
literal|"n1gchild"
argument_list|)
condition|)
block|{
if|if
condition|(
name|e
operator|->
name|necont
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d"
argument_list|,
name|e
operator|->
name|econt
index|[
literal|0
index|]
operator|->
name|necont
argument_list|)
expr_stmt|;
name|OutputString
argument_list|(
name|buf
argument_list|,
name|fp
argument_list|,
name|track_pos
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Chase this element's pointers until we hit the named GI.      * Do the action if it matches.      * Format: _chasetogi gi action */
elseif|else
if|if
condition|(
name|StrEq
argument_list|(
name|tok
index|[
literal|0
index|]
argument_list|,
literal|"chasetogi"
argument_list|)
condition|)
block|{
if|if
condition|(
name|ntok
operator|<
literal|3
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error: Not enough args for _chasetogi.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|actioni
operator|=
name|atoi
argument_list|(
name|tok
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|actioni
condition|)
name|ChaseIDRefs
argument_list|(
name|e
argument_list|,
name|tok
index|[
literal|1
index|]
argument_list|,
name|tok
index|[
literal|2
index|]
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
comment|/* Follow link to element pointed to, then do action.      * Format: _followlink [attname] action. */
elseif|else
if|if
condition|(
name|StrEq
argument_list|(
name|tok
index|[
literal|0
index|]
argument_list|,
literal|"followlink"
argument_list|)
condition|)
block|{
name|char
modifier|*
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|ntok
operator|>
literal|2
condition|)
block|{
if|if
condition|(
operator|(
name|atval
operator|=
name|FindAttValByName
argument_list|(
name|e
argument_list|,
name|tok
index|[
literal|1
index|]
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|ep
operator|=
name|FindElemByID
argument_list|(
name|atval
argument_list|)
operator|)
condition|)
block|{
name|TranTByAction
argument_list|(
name|ep
argument_list|,
name|tok
index|[
literal|2
index|]
argument_list|,
name|fp
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error: Did not find attr: %s.\n"
argument_list|,
name|tok
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
name|GetIDREFnames
argument_list|()
expr_stmt|;
for|for
control|(
name|s
operator|=
name|idrefs
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
block|{
comment|/* is this IDREF attr set? */
if|if
condition|(
operator|(
name|atval
operator|=
name|FindAttValByName
argument_list|(
name|e
argument_list|,
operator|*
name|s
argument_list|)
operator|)
condition|)
block|{
name|ntok
operator|=
literal|0
expr_stmt|;
name|tok
operator|=
name|Split
argument_list|(
name|atval
argument_list|,
operator|&
name|ntok
argument_list|,
name|S_STRDUP
argument_list|)
expr_stmt|;
comment|/* we'll follow the first one... */
if|if
condition|(
operator|(
name|ep
operator|=
name|FindElemByID
argument_list|(
name|tok
index|[
literal|0
index|]
argument_list|)
operator|)
condition|)
block|{
name|TranTByAction
argument_list|(
name|ep
argument_list|,
name|tok
index|[
literal|1
index|]
argument_list|,
name|fp
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error: Can not find elem for ID: %s.\n"
argument_list|,
name|tok
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error: Element does not have IDREF attribute set:\n"
argument_list|)
expr_stmt|;
name|PrintLocation
argument_list|(
name|e
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Starting at this element, decend tree (in-order), finding GI.      * Do the action if it matches.      * Format: _find args ... */
elseif|else
if|if
condition|(
name|StrEq
argument_list|(
name|tok
index|[
literal|0
index|]
argument_list|,
literal|"find"
argument_list|)
condition|)
block|{
name|Find
argument_list|(
name|e
argument_list|,
name|ntok
argument_list|,
name|tok
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
comment|/* Starting at this element's parent, decend tree (in-order), finding GI.      * Do the action if it matches.      * Format: _pfind args ... */
elseif|else
if|if
condition|(
name|StrEq
argument_list|(
name|tok
index|[
literal|0
index|]
argument_list|,
literal|"pfind"
argument_list|)
condition|)
block|{
name|Find
argument_list|(
name|e
operator|->
name|parent
condition|?
name|e
operator|->
name|parent
else|:
name|e
argument_list|,
name|ntok
argument_list|,
name|tok
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
comment|/* Content is supposed to be a list of IDREFs.  Follow each, doing action.      * If 2 actions are specified, use 1st for the 1st ID, 2nd for the rest.      * Format: _namelist action [action2] */
elseif|else
if|if
condition|(
name|StrEq
argument_list|(
name|tok
index|[
literal|0
index|]
argument_list|,
literal|"namelist"
argument_list|)
condition|)
block|{
name|int
name|id
decl_stmt|;
name|action1
operator|=
name|tok
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|ntok
operator|>
literal|2
condition|)
name|action
operator|=
name|tok
index|[
literal|2
index|]
expr_stmt|;
else|else
name|action
operator|=
name|action1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|e
operator|->
name|ndcont
condition|;
name|i
operator|++
control|)
block|{
name|n
operator|=
literal|0
expr_stmt|;
name|tok
operator|=
name|Split
argument_list|(
name|e
operator|->
name|dcont
index|[
name|i
index|]
argument_list|,
operator|&
name|n
argument_list|,
name|S_STRDUP
argument_list|)
expr_stmt|;
for|for
control|(
name|id
operator|=
literal|0
init|;
name|id
operator|<
name|n
condition|;
name|id
operator|++
control|)
block|{
if|if
condition|(
name|fold_case
condition|)
for|for
control|(
name|cp
operator|=
name|tok
index|[
name|id
index|]
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
if|if
condition|(
name|islower
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
operator|*
name|cp
operator|=
name|toupper
argument_list|(
operator|*
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|e
operator|=
name|FindElemByID
argument_list|(
name|tok
index|[
name|id
index|]
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|id
condition|)
name|TranTByAction
argument_list|(
name|e
argument_list|,
name|action
argument_list|,
name|fp
argument_list|)
expr_stmt|;
else|else
name|TranTByAction
argument_list|(
name|e
argument_list|,
name|action1
argument_list|,
name|fp
argument_list|)
expr_stmt|;
comment|/* first one */
block|}
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error: Can not find ID: %s.\n"
argument_list|,
name|tok
index|[
name|id
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* For each word in the element's content, do action.      * Format: _eachcon action [action] */
elseif|else
if|if
condition|(
name|StrEq
argument_list|(
name|tok
index|[
literal|0
index|]
argument_list|,
literal|"eachcon"
argument_list|)
condition|)
block|{
name|int
name|id
decl_stmt|;
name|action1
operator|=
name|tok
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|ntok
operator|>
literal|3
condition|)
name|action
operator|=
name|tok
index|[
literal|2
index|]
expr_stmt|;
else|else
name|action
operator|=
name|action1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|e
operator|->
name|ndcont
condition|;
name|i
operator|++
control|)
block|{
name|n
operator|=
literal|0
expr_stmt|;
name|tok
operator|=
name|Split
argument_list|(
name|e
operator|->
name|dcont
index|[
name|i
index|]
argument_list|,
operator|&
name|n
argument_list|,
name|S_STRDUP
operator||
name|S_ALVEC
argument_list|)
expr_stmt|;
for|for
control|(
name|id
operator|=
literal|0
init|;
name|id
operator|<
name|n
condition|;
name|id
operator|++
control|)
block|{
name|each_C
operator|=
name|tok
index|[
name|id
index|]
expr_stmt|;
name|TranTByAction
argument_list|(
name|e
argument_list|,
name|action
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
operator|*
name|tok
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* For each word in the given attribute's value, do action.      * Format: _eachatt attname action [action] */
elseif|else
if|if
condition|(
name|StrEq
argument_list|(
name|tok
index|[
literal|0
index|]
argument_list|,
literal|"eachatt"
argument_list|)
condition|)
block|{
name|int
name|id
decl_stmt|;
name|action1
operator|=
name|tok
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|ntok
operator|>
literal|3
condition|)
name|action
operator|=
name|tok
index|[
literal|3
index|]
expr_stmt|;
else|else
name|action
operator|=
name|action1
expr_stmt|;
if|if
condition|(
operator|(
name|atval
operator|=
name|FindAttValByName
argument_list|(
name|e
argument_list|,
name|tok
index|[
literal|1
index|]
argument_list|)
operator|)
condition|)
block|{
name|n
operator|=
literal|0
expr_stmt|;
name|tok
operator|=
name|Split
argument_list|(
name|atval
argument_list|,
operator|&
name|n
argument_list|,
name|S_STRDUP
operator||
name|S_ALVEC
argument_list|)
expr_stmt|;
for|for
control|(
name|id
operator|=
literal|0
init|;
name|id
operator|<
name|n
condition|;
name|id
operator|++
control|)
block|{
name|each_A
operator|=
name|tok
index|[
name|id
index|]
expr_stmt|;
if|if
condition|(
name|id
condition|)
name|TranTByAction
argument_list|(
name|e
argument_list|,
name|action
argument_list|,
name|fp
argument_list|)
expr_stmt|;
else|else
name|TranTByAction
argument_list|(
name|e
argument_list|,
name|action1
argument_list|,
name|fp
argument_list|)
expr_stmt|;
comment|/* first one */
block|}
name|free
argument_list|(
operator|*
name|tok
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Do action on this element if element has [relationship] with gi.      * Format: _relation relationship gi action [action] */
elseif|else
if|if
condition|(
name|StrEq
argument_list|(
name|tok
index|[
literal|0
index|]
argument_list|,
literal|"relation"
argument_list|)
condition|)
block|{
if|if
condition|(
name|ntok
operator|>=
literal|4
condition|)
block|{
if|if
condition|(
operator|!
name|CheckRelation
argument_list|(
name|e
argument_list|,
name|tok
index|[
literal|1
index|]
argument_list|,
name|tok
index|[
literal|2
index|]
argument_list|,
name|tok
index|[
literal|3
index|]
argument_list|,
name|fp
argument_list|,
name|RA_Current
argument_list|)
condition|)
block|{
comment|/* action not done, see if alt action specified */
if|if
condition|(
name|ntok
operator|>=
literal|5
condition|)
name|TranTByAction
argument_list|(
name|e
argument_list|,
name|tok
index|[
literal|4
index|]
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Do action on followed element if element has [relationship] with gi.      * If [relationship] is not met, do alternate action on this element.      * Format: _followrel relationship gi action [action] */
elseif|else
if|if
condition|(
name|StrEq
argument_list|(
name|tok
index|[
literal|0
index|]
argument_list|,
literal|"followrel"
argument_list|)
condition|)
block|{
if|if
condition|(
name|ntok
operator|>=
literal|4
condition|)
block|{
if|if
condition|(
operator|!
name|CheckRelation
argument_list|(
name|e
argument_list|,
name|tok
index|[
literal|1
index|]
argument_list|,
name|tok
index|[
literal|2
index|]
argument_list|,
name|tok
index|[
literal|3
index|]
argument_list|,
name|fp
argument_list|,
name|RA_Related
argument_list|)
condition|)
block|{
comment|/* action not done, see if an alt action specified */
if|if
condition|(
name|ntok
operator|>=
literal|5
condition|)
name|TranTByAction
argument_list|(
name|e
argument_list|,
name|tok
index|[
literal|4
index|]
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Find element with matching ID and do action.  If action not specified,      * choose the right one appropriate for its context.      * Format: _id id [action] */
elseif|else
if|if
condition|(
name|StrEq
argument_list|(
name|tok
index|[
literal|0
index|]
argument_list|,
literal|"id"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|ep
operator|=
name|FindElemByID
argument_list|(
name|tok
index|[
literal|1
index|]
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|ntok
operator|>
literal|2
condition|)
name|TranTByAction
argument_list|(
name|ep
argument_list|,
name|tok
index|[
literal|2
index|]
argument_list|,
name|fp
argument_list|)
expr_stmt|;
else|else
block|{
name|t
operator|=
name|FindTrans
argument_list|(
name|ep
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TransElement
argument_list|(
name|ep
argument_list|,
name|fp
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Set variable to value.      * Format: _set name value */
elseif|else
if|if
condition|(
name|StrEq
argument_list|(
name|tok
index|[
literal|0
index|]
argument_list|,
literal|"set"
argument_list|)
condition|)
block|{
name|SetMappingNV
argument_list|(
name|Variables
argument_list|,
name|tok
index|[
literal|1
index|]
argument_list|,
name|tok
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Do action if variable is set, optionally to value.      * If not set, do nothing.      * Format: _isset varname [value] action */
elseif|else
if|if
condition|(
name|StrEq
argument_list|(
name|tok
index|[
literal|0
index|]
argument_list|,
literal|"isset"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|cp
operator|=
name|FindMappingVal
argument_list|(
name|Variables
argument_list|,
name|tok
index|[
literal|1
index|]
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|ntok
operator|==
literal|3
condition|)
name|TranTByAction
argument_list|(
name|e
argument_list|,
name|tok
index|[
literal|2
index|]
argument_list|,
name|fp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ntok
operator|>
literal|3
operator|&&
operator|!
name|strcmp
argument_list|(
name|cp
argument_list|,
name|tok
index|[
literal|2
index|]
argument_list|)
condition|)
name|TranTByAction
argument_list|(
name|e
argument_list|,
name|tok
index|[
literal|3
index|]
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Insert a node into the tree at start/end, pointing to action to perform.      * Format: _insertnode S|E action */
elseif|else
if|if
condition|(
name|StrEq
argument_list|(
name|tok
index|[
literal|0
index|]
argument_list|,
literal|"insertnode"
argument_list|)
condition|)
block|{
name|actioni
operator|=
name|atoi
argument_list|(
name|tok
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|tok
index|[
literal|1
index|]
operator|==
literal|'S'
condition|)
name|e
operator|->
name|gen_trans
index|[
literal|0
index|]
operator|=
name|actioni
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|tok
index|[
literal|1
index|]
operator|==
literal|'E'
condition|)
name|e
operator|->
name|gen_trans
index|[
literal|1
index|]
operator|=
name|actioni
expr_stmt|;
block|}
comment|/* Do an CALS DTD table spec for TeX or troff.  Looks through attributes      * and determines what to output. "check" means to check consistency,      * and print error messages.      * This is (hopefully) the only hard-coded part of instant.      *      * This was originally written for the OSF DTDs and recoded by FLD for      * CALS tables (since no one will ever use the OSF tables).  Although      * TeX was addressed first, it seems that a fresh approach was required,      * and so, tbl is the first to be really *fixed*.  Once tbl is stable,      * and there is a need for TeX again, that part will be recoded.      *      * *Obsolete* form (viz, for TeX):      *    Format: _calstable [clear|check|tex]      *			  [cellstart|cellend|rowstart|rowend|top|bottom]      *      * New, good form:      *      *    Format: _calstable [tbl]      *			  [tablestart|tableend|tablegroup|tablefoot|rowstart|      *			   rowend|entrystart|entryend]      */
elseif|else
if|if
condition|(
name|StrEq
argument_list|(
name|tok
index|[
literal|0
index|]
argument_list|,
literal|"calstable"
argument_list|)
condition|)
block|{
name|CALStable
argument_list|(
name|e
argument_list|,
name|fp
argument_list|,
name|tok
argument_list|,
name|ntok
argument_list|)
expr_stmt|;
block|}
comment|/* Do action if element's attr is set, optionally to value.      * If not set, do nothing.      * Format: _attval att [value] action */
elseif|else
if|if
condition|(
name|StrEq
argument_list|(
name|tok
index|[
literal|0
index|]
argument_list|,
literal|"attval"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|atval
operator|=
name|FindAttValByName
argument_list|(
name|e
argument_list|,
name|tok
index|[
literal|1
index|]
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|ntok
operator|==
literal|3
condition|)
name|TranTByAction
argument_list|(
name|e
argument_list|,
name|tok
index|[
literal|2
index|]
argument_list|,
name|fp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ntok
operator|>
literal|3
operator|&&
operator|!
name|strcmp
argument_list|(
name|atval
argument_list|,
name|tok
index|[
literal|2
index|]
argument_list|)
condition|)
name|TranTByAction
argument_list|(
name|e
argument_list|,
name|tok
index|[
literal|3
index|]
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Same thing, but look at parent */
elseif|else
if|if
condition|(
name|StrEq
argument_list|(
name|tok
index|[
literal|0
index|]
argument_list|,
literal|"pattval"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|atval
operator|=
name|FindAttValByName
argument_list|(
name|e
operator|->
name|parent
argument_list|,
name|tok
index|[
literal|1
index|]
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|ntok
operator|==
literal|3
condition|)
block|{
name|TranTByAction
argument_list|(
name|e
argument_list|,
name|tok
index|[
literal|2
index|]
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ntok
operator|>
literal|3
operator|&&
operator|!
name|strcmp
argument_list|(
name|atval
argument_list|,
name|tok
index|[
literal|2
index|]
argument_list|)
condition|)
name|TranTByAction
argument_list|(
name|e
argument_list|,
name|tok
index|[
literal|3
index|]
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Print each attribute and value for the current element, hopefully      * in a legal sgml form:<elem-name att1="value1" att2="value2:> .      * Format: _allatts */
elseif|else
if|if
condition|(
name|StrEq
argument_list|(
name|tok
index|[
literal|0
index|]
argument_list|,
literal|"allatts"
argument_list|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|e
operator|->
name|natts
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
name|putc
argument_list|(
literal|' '
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|e
operator|->
name|atts
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"=\""
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|e
operator|->
name|atts
index|[
name|i
index|]
operator|.
name|sval
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'"'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Print the element's input filename, and optionally, the line number.      * Format: _infile [line] */
elseif|else
if|if
condition|(
name|StrEq
argument_list|(
name|tok
index|[
literal|0
index|]
argument_list|,
literal|"infile"
argument_list|)
condition|)
block|{
if|if
condition|(
name|e
operator|->
name|infile
condition|)
block|{
if|if
condition|(
name|ntok
operator|>
literal|1
operator|&&
operator|!
name|strcmp
argument_list|(
name|tok
index|[
literal|1
index|]
argument_list|,
literal|"root"
argument_list|)
condition|)
block|{
name|strcpy
argument_list|(
name|buf
argument_list|,
name|e
operator|->
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|strrchr
argument_list|(
name|buf
argument_list|,
literal|'.'
argument_list|)
operator|)
condition|)
operator|*
name|cp
operator|=
name|EOS
expr_stmt|;
name|fputs
argument_list|(
name|buf
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fputs
argument_list|(
name|e
operator|->
name|infile
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ntok
operator|>
literal|1
operator|&&
operator|!
name|strcmp
argument_list|(
name|tok
index|[
literal|1
index|]
argument_list|,
literal|"line"
argument_list|)
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" %d"
argument_list|,
name|e
operator|->
name|lineno
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
else|else
name|fputs
argument_list|(
literal|"input-file??"
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
comment|/* Get value of an environement variable */
elseif|else
if|if
condition|(
name|StrEq
argument_list|(
name|tok
index|[
literal|0
index|]
argument_list|,
literal|"env"
argument_list|)
condition|)
block|{
if|if
condition|(
name|ntok
operator|>
literal|1
operator|&&
operator|(
name|cp
operator|=
name|getenv
argument_list|(
name|tok
index|[
literal|1
index|]
argument_list|)
operator|)
condition|)
block|{
name|OutputString
argument_list|(
name|cp
argument_list|,
name|fp
argument_list|,
name|track_pos
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If the element is not empty do specid.      * Format: _notempty spec-id */
elseif|else
if|if
condition|(
name|StrEq
argument_list|(
name|tok
index|[
literal|0
index|]
argument_list|,
literal|"notempty"
argument_list|)
condition|)
block|{
if|if
condition|(
name|ntok
operator|>
literal|1
operator|&&
name|e
operator|->
name|ncont
condition|)
block|{
name|TranTByAction
argument_list|(
name|e
argument_list|,
name|tok
index|[
literal|1
index|]
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Something unknown */
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unknown special variable: %s\n"
argument_list|,
name|tok
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|tt
operator|=
name|e
operator|->
name|trans
expr_stmt|;
if|if
condition|(
name|tt
operator|&&
name|tt
operator|->
name|lineno
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Used in transpec, line %d\n"
argument_list|,
name|tt
operator|->
name|lineno
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* ______________________________________________________________________ */
end_comment

begin_comment
comment|/*  return the value for the special variables _A (last processed _eachatt)  *  and _C (last processed _eachcon)  */
end_comment

begin_function
name|char
modifier|*
name|Get_A_C_value
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"each_A"
argument_list|)
condition|)
block|{
if|if
condition|(
name|each_A
condition|)
block|{
return|return
name|each_A
return|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Requested value for unset _A variable\n"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"each_C"
argument_list|)
condition|)
block|{
if|if
condition|(
name|each_C
condition|)
block|{
return|return
name|each_C
return|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Requested value for unset _C variable\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Requested value for unknown special variable '%s'\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
return|return
literal|""
return|;
block|}
end_function

begin_comment
comment|/* ______________________________________________________________________ */
end_comment

begin_comment
comment|/*  Chase IDs until we find an element whose GI matches.  We also check  *  child element names, not just the names of elements directly pointed  *  at (by IDREF attributes).  */
end_comment

begin_function
name|void
name|GetIDREFnames
parameter_list|()
block|{
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
operator|!
name|idrefs
condition|)
block|{
comment|/* did user or transpec set the variable */
if|if
condition|(
operator|(
name|cp
operator|=
name|FindMappingVal
argument_list|(
name|Variables
argument_list|,
literal|"link_atts"
argument_list|)
operator|)
condition|)
name|idrefs
operator|=
name|Split
argument_list|(
name|cp
argument_list|,
literal|0
argument_list|,
name|S_STRDUP
operator||
name|S_ALVEC
argument_list|)
expr_stmt|;
else|else
name|idrefs
operator|=
name|def_idrefs
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ______________________________________________________________________ */
end_comment

begin_comment
comment|/*  Chase ID references - follow IDREF(s) attributes until we find  *  a GI named 'gi', then perform given action on that GI.  *  Arguments:  *	Pointer to element under consideration.  *	Name of GI we're looking for.  *	Spec ID of action to take.  *	FILE pointer to where to write output.  */
end_comment

begin_function
name|void
name|ChaseIDRefs
parameter_list|(
name|Element_t
modifier|*
name|e
parameter_list|,
name|char
modifier|*
name|gi
parameter_list|,
name|char
modifier|*
name|action
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|int
name|ntok
decl_stmt|,
name|i
decl_stmt|,
name|ei
decl_stmt|;
name|char
modifier|*
modifier|*
name|tok
decl_stmt|,
modifier|*
modifier|*
name|s
decl_stmt|,
modifier|*
name|atval
decl_stmt|;
comment|/* First, see if we got what we came for with this element */
if|if
condition|(
name|StrEq
argument_list|(
name|e
operator|->
name|gi
argument_list|,
name|gi
argument_list|)
condition|)
block|{
name|TranTByAction
argument_list|(
name|e
argument_list|,
name|action
argument_list|,
name|fp
argument_list|)
expr_stmt|;
return|return;
block|}
name|GetIDREFnames
argument_list|()
expr_stmt|;
comment|/* loop for each attribute of type IDREF(s) */
for|for
control|(
name|s
operator|=
name|idrefs
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
block|{
comment|/* is this IDREF attr set? */
if|if
condition|(
operator|(
name|atval
operator|=
name|FindAttValByName
argument_list|(
name|e
argument_list|,
operator|*
name|s
argument_list|)
operator|)
condition|)
block|{
name|ntok
operator|=
literal|0
expr_stmt|;
name|tok
operator|=
name|Split
argument_list|(
name|atval
argument_list|,
operator|&
name|ntok
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ntok
condition|;
name|i
operator|++
control|)
block|{
comment|/* get element pointed to */
if|if
condition|(
operator|(
name|e
operator|=
name|FindElemByID
argument_list|(
name|tok
index|[
name|i
index|]
argument_list|)
operator|)
condition|)
block|{
comment|/* OK, we found a matching GI name */
if|if
condition|(
name|StrEq
argument_list|(
name|e
operator|->
name|gi
argument_list|,
name|gi
argument_list|)
condition|)
block|{
comment|/* process using named action */
name|TranTByAction
argument_list|(
name|e
argument_list|,
name|action
argument_list|,
name|fp
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
comment|/* this elem itself did not match, try its children */
for|for
control|(
name|ei
operator|=
literal|0
init|;
name|ei
operator|<
name|e
operator|->
name|necont
condition|;
name|ei
operator|++
control|)
block|{
if|if
condition|(
name|StrEq
argument_list|(
name|e
operator|->
name|econt
index|[
name|ei
index|]
operator|->
name|gi
argument_list|,
name|gi
argument_list|)
condition|)
block|{
name|TranTByAction
argument_list|(
name|e
operator|->
name|econt
index|[
name|ei
index|]
argument_list|,
name|action
argument_list|,
name|fp
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* try this elem's IDREF attributes */
name|ChaseIDRefs
argument_list|(
name|e
argument_list|,
name|gi
argument_list|,
name|action
argument_list|,
name|fp
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
comment|/* should not happen, since parser checks ID/IDREFs */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error: Could not find ID %s\n"
argument_list|,
name|atval
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
block|}
comment|/* if the pointers didn't lead to the GI, give error */
if|if
condition|(
operator|!
name|s
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error: Could not find '%s'\n"
argument_list|,
name|gi
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ______________________________________________________________________ */
end_comment

begin_comment
comment|/* state to pass to recursive routines - so we don't have to use  * global variables. */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|char
modifier|*
name|gi
decl_stmt|;
name|char
modifier|*
name|gi2
decl_stmt|;
name|char
name|action
index|[
literal|10
index|]
decl_stmt|;
name|Element_t
modifier|*
name|elem
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
block|}
name|Descent_t
typedef|;
end_typedef

begin_function
specifier|static
name|void
name|tr_find_gi
parameter_list|(
name|Element_t
modifier|*
name|e
parameter_list|,
name|Descent_t
modifier|*
name|ds
parameter_list|)
block|{
if|if
condition|(
name|StrEq
argument_list|(
name|ds
operator|->
name|gi
argument_list|,
name|e
operator|->
name|gi
argument_list|)
condition|)
if|if
condition|(
name|ds
operator|->
name|action
index|[
literal|0
index|]
condition|)
name|TranTByAction
argument_list|(
name|e
argument_list|,
name|ds
operator|->
name|action
argument_list|,
name|ds
operator|->
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|tr_find_gipar
parameter_list|(
name|Element_t
modifier|*
name|e
parameter_list|,
name|Descent_t
modifier|*
name|ds
parameter_list|)
block|{
if|if
condition|(
name|StrEq
argument_list|(
name|ds
operator|->
name|gi
argument_list|,
name|e
operator|->
name|gi
argument_list|)
operator|&&
name|e
operator|->
name|parent
operator|&&
name|StrEq
argument_list|(
name|ds
operator|->
name|gi2
argument_list|,
name|e
operator|->
name|parent
operator|->
name|gi
argument_list|)
condition|)
if|if
condition|(
name|ds
operator|->
name|action
index|[
literal|0
index|]
condition|)
name|TranTByAction
argument_list|(
name|e
argument_list|,
name|ds
operator|->
name|action
argument_list|,
name|ds
operator|->
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|tr_find_attr
parameter_list|(
name|Element_t
modifier|*
name|e
parameter_list|,
name|Descent_t
modifier|*
name|ds
parameter_list|)
block|{
name|char
modifier|*
name|atval
decl_stmt|;
if|if
condition|(
operator|(
name|atval
operator|=
name|FindAttValByName
argument_list|(
name|e
argument_list|,
name|ds
operator|->
name|gi
argument_list|)
operator|)
operator|&&
name|StrEq
argument_list|(
name|ds
operator|->
name|gi2
argument_list|,
name|atval
argument_list|)
condition|)
name|TranTByAction
argument_list|(
name|e
argument_list|,
name|ds
operator|->
name|action
argument_list|,
name|ds
operator|->
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|tr_find_parent
parameter_list|(
name|Element_t
modifier|*
name|e
parameter_list|,
name|Descent_t
modifier|*
name|ds
parameter_list|)
block|{
if|if
condition|(
name|QRelation
argument_list|(
name|e
argument_list|,
name|ds
operator|->
name|gi
argument_list|,
name|REL_Parent
argument_list|)
condition|)
block|{
if|if
condition|(
name|ds
operator|->
name|action
index|[
literal|0
index|]
condition|)
name|TranTByAction
argument_list|(
name|e
argument_list|,
name|ds
operator|->
name|action
argument_list|,
name|ds
operator|->
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ______________________________________________________________________ */
end_comment

begin_comment
comment|/*  Descend tree, finding elements that match criteria, then perform  *  given action.  *  Arguments:  *	Pointer to element under consideration.  *	Number of tokens in special variable.  *	Vector of tokens in special variable (eg, "find" "gi" "TITLE")  *	FILE pointer to where to write output.  */
end_comment

begin_function
name|void
name|Find
parameter_list|(
name|Element_t
modifier|*
name|e
parameter_list|,
name|int
name|ac
parameter_list|,
name|char
modifier|*
modifier|*
name|av
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|Descent_t
name|DS
decl_stmt|;
comment|/* state passed to recursive routine */
name|memset
argument_list|(
operator|&
name|DS
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|Descent_t
argument_list|)
argument_list|)
expr_stmt|;
name|DS
operator|.
name|elem
operator|=
name|e
expr_stmt|;
name|DS
operator|.
name|fp
operator|=
name|fp
expr_stmt|;
comment|/* see if we should start at the top of instance tree */
if|if
condition|(
name|StrEq
argument_list|(
name|av
index|[
literal|1
index|]
argument_list|,
literal|"top"
argument_list|)
condition|)
block|{
name|av
operator|++
expr_stmt|;
name|ac
operator|--
expr_stmt|;
name|e
operator|=
name|DocTree
expr_stmt|;
block|}
if|if
condition|(
name|ac
operator|<
literal|4
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Bad '_find' specification - missing args.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Find elem whose GI is av[2] */
if|if
condition|(
name|StrEq
argument_list|(
name|av
index|[
literal|1
index|]
argument_list|,
literal|"gi"
argument_list|)
condition|)
block|{
name|DS
operator|.
name|gi
operator|=
name|av
index|[
literal|2
index|]
expr_stmt|;
name|strcpy
argument_list|(
name|DS
operator|.
name|action
argument_list|,
name|av
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|DescendTree
argument_list|(
name|e
argument_list|,
name|tr_find_gi
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|DS
argument_list|)
expr_stmt|;
block|}
comment|/* Find elem whose GI is av[2] and whose parent GI is av[3] */
elseif|else
if|if
condition|(
name|StrEq
argument_list|(
name|av
index|[
literal|1
index|]
argument_list|,
literal|"gi-parent"
argument_list|)
condition|)
block|{
name|DS
operator|.
name|gi
operator|=
name|av
index|[
literal|2
index|]
expr_stmt|;
name|DS
operator|.
name|gi2
operator|=
name|av
index|[
literal|3
index|]
expr_stmt|;
name|strcpy
argument_list|(
name|DS
operator|.
name|action
argument_list|,
name|av
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
name|DescendTree
argument_list|(
name|e
argument_list|,
name|tr_find_gipar
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|DS
argument_list|)
expr_stmt|;
block|}
comment|/* Find elem whose parent GI is av[2] */
elseif|else
if|if
condition|(
name|StrEq
argument_list|(
name|av
index|[
literal|0
index|]
argument_list|,
literal|"parent"
argument_list|)
condition|)
block|{
name|DS
operator|.
name|gi
operator|=
name|av
index|[
literal|2
index|]
expr_stmt|;
name|strcpy
argument_list|(
name|DS
operator|.
name|action
argument_list|,
name|av
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|DescendTree
argument_list|(
name|e
argument_list|,
name|tr_find_parent
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|DS
argument_list|)
expr_stmt|;
block|}
comment|/* Find elem whose attribute av[2] has value av[3] */
elseif|else
if|if
condition|(
name|StrEq
argument_list|(
name|av
index|[
literal|0
index|]
argument_list|,
literal|"attr"
argument_list|)
condition|)
block|{
name|DS
operator|.
name|gi
operator|=
name|av
index|[
literal|2
index|]
expr_stmt|;
name|DS
operator|.
name|gi2
operator|=
name|av
index|[
literal|3
index|]
expr_stmt|;
name|strcpy
argument_list|(
name|DS
operator|.
name|action
argument_list|,
name|av
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
name|DescendTree
argument_list|(
name|e
argument_list|,
name|tr_find_attr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|DS
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ______________________________________________________________________ */
end_comment

end_unit

