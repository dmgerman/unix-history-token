begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  Copyright 1993 Open Software Foundation, Inc., Cambridge, Massachusetts.  *  All rights reserved.  */
end_comment

begin_comment
comment|/*  * Copyright (c) 1994    * Open Software Foundation, Inc.   *    * Permission is hereby granted to use, copy, modify and freely distribute   * the software in this file and its documentation for any purpose without   * fee, provided that the above copyright notice appears in all copies and   * that both the copyright notice and this permission notice appear in   * supporting documentation.  Further, provided that the name of Open   * Software Foundation, Inc. ("OSF") not be used in advertising or   * publicity pertaining to distribution of the software without prior   * written permission from OSF.  OSF makes no representations about the   * suitability of this software for any purpose.  It is provided "as is"   * without express or implied warranty.   */
end_comment

begin_comment
comment|/*  * Copyright (c) 1996 X Consortium  * Copyright (c) 1995, 1996 Dalrymple Consulting  *   * Permission is hereby granted, free of charge, to any person obtaining a copy  * of this software and associated documentation files (the "Software"), to deal  * in the Software without restriction, including without limitation the rights  * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell  * copies of the Software, and to permit persons to whom the Software is  * furnished to do so, subject to the following conditions:  *   * The above copyright notice and this permission notice shall be included in  * all copies or substantial portions of the Software.  *   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE  * X CONSORTIUM OR DALRYMPLE CONSULTING BE LIABLE FOR ANY CLAIM, DAMAGES OR  * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,  * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR  * OTHER DEALINGS IN THE SOFTWARE.  *   * Except as contained in this notice, the names of the X Consortium and  * Dalrymple Consulting shall not be used in advertising or otherwise to  * promote the sale, use or other dealings in this Software without prior  * written authorization.  */
end_comment

begin_comment
comment|/* ________________________________________________________________________  *  *  Program to manipulate SGML instances.  *  *  This module contains the initialization routines for translation module.  *  They mostly deal with reading data files (translation specs, SDATA  *  mappings, character mappings).  *  *  Entry points:  *	ReadTransSpec(transfile)	read/store translation spec from file  * ________________________________________________________________________  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|RCSid
init|=
literal|"$Header: /usr/local/home/jfieber/src/cvsroot/nsgmlfmt/traninit.c,v 1.1.1.1 1996/01/16 05:14:10 jfieber Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<memory.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<regexp.h>
end_include

begin_include
include|#
directive|include
file|"general.h"
end_include

begin_include
include|#
directive|include
file|"translate.h"
end_include

begin_include
include|#
directive|include
file|"sgmls.h"
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"std.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|TRUE
end_ifndef

begin_define
define|#
directive|define
name|TRUE
value|(1 == 1)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|MAX
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)> (b) ? (a) : (b))
end_define

begin_define
define|#
directive|define
name|MIN
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)< (b) ? (a) : (b))
end_define

begin_comment
comment|/* forward references */
end_comment

begin_function_decl
name|void
name|RememberTransSpec
parameter_list|(
name|Trans_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_data
parameter_list|(
name|char
modifier|*
name|gi
parameter_list|,
name|struct
name|sgmls_data
modifier|*
name|v
parameter_list|,
name|int
name|n
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|build_ts
parameter_list|(
name|char
modifier|*
name|gi
parameter_list|,
name|char
modifier|*
name|cp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|AddCharMap
parameter_list|(
specifier|const
name|char
modifier|*
name|from
parameter_list|,
specifier|const
name|char
modifier|*
name|to
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|AddSDATA
parameter_list|(
specifier|const
name|char
modifier|*
name|from
parameter_list|,
specifier|const
name|char
modifier|*
name|to
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* ______________________________________________________________________ */
end_comment

begin_comment
comment|/*  Read the translation specs from the input file, storing in memory.  *  Arguments:  *	Name of translation spec file.  */
end_comment

begin_decl_stmt
specifier|static
name|Trans_t
name|T
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|input_error
parameter_list|(
name|num
parameter_list|,
name|str
parameter_list|,
name|lineno
parameter_list|)
name|int
name|num
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|unsigned
name|long
name|lineno
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error at input line %lu: %s\n"
argument_list|,
name|lineno
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ReadTransSpec
parameter_list|(
name|char
modifier|*
name|transfile
parameter_list|)
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|struct
name|sgmls
modifier|*
name|sp
decl_stmt|;
name|struct
name|sgmls_event
name|e
decl_stmt|;
name|char
name|gi
index|[
name|LINESIZE
index|]
decl_stmt|;
name|char
name|buf
index|[
name|LINESIZE
index|]
decl_stmt|;
name|char
name|buf2
index|[
name|LINESIZE
index|]
decl_stmt|;
name|char
modifier|*
name|command
decl_stmt|;
name|char
modifier|*
name|sgmls
init|=
literal|"sgmls "
decl_stmt|;
name|char
name|maptype
init|=
literal|'\0'
decl_stmt|;
operator|(
name|void
operator|)
name|sgmls_set_errhandler
argument_list|(
name|input_error
argument_list|)
expr_stmt|;
name|transfile
operator|=
name|FilePath
argument_list|(
name|transfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|transfile
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error: Could not locate specified transfile\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* XXX this is a quick, gross hack.  Should write a parse() function. */
name|Malloc
argument_list|(
name|strlen
argument_list|(
name|sgmls
argument_list|)
operator|+
name|strlen
argument_list|(
name|transfile
argument_list|)
operator|+
literal|2
argument_list|,
name|command
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|command
argument_list|,
literal|"%s %s"
argument_list|,
name|sgmls
argument_list|,
name|transfile
argument_list|)
expr_stmt|;
name|fp
operator|=
name|popen
argument_list|(
name|command
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|sp
operator|=
name|sgmls_create
argument_list|(
name|fp
argument_list|)
expr_stmt|;
while|while
condition|(
name|sgmls_next
argument_list|(
name|sp
argument_list|,
operator|&
name|e
argument_list|)
condition|)
switch|switch
condition|(
name|e
operator|.
name|type
condition|)
block|{
case|case
name|SGMLS_EVENT_DATA
case|:
name|do_data
argument_list|(
name|gi
argument_list|,
name|e
operator|.
name|u
operator|.
name|data
operator|.
name|v
argument_list|,
name|e
operator|.
name|u
operator|.
name|data
operator|.
name|n
argument_list|)
expr_stmt|;
break|break;
case|case
name|SGMLS_EVENT_ENTITY
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Hm... got an entity\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SGMLS_EVENT_PI
case|:
break|break;
case|case
name|SGMLS_EVENT_START
case|:
if|if
condition|(
name|strncmp
argument_list|(
literal|"RULE"
argument_list|,
name|e
operator|.
name|u
operator|.
name|start
operator|.
name|gi
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* A new transpec, so clear the data structure     	    	 * and look for an ID attribute.     	    	 */
name|struct
name|sgmls_attribute
modifier|*
name|attr
init|=
name|e
operator|.
name|u
operator|.
name|start
operator|.
name|attributes
decl_stmt|;
name|memset
argument_list|(
operator|&
name|T
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|T
argument_list|)
expr_stmt|;
while|while
condition|(
name|attr
condition|)
block|{
if|if
condition|(
name|attr
operator|->
name|type
operator|==
name|SGMLS_ATTR_CDATA
operator|&&
name|strncmp
argument_list|(
literal|"ID"
argument_list|,
name|attr
operator|->
name|name
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|strncpy
argument_list|(
name|buf
argument_list|,
name|attr
operator|->
name|value
operator|.
name|data
operator|.
name|v
operator|->
name|s
argument_list|,
name|MIN
argument_list|(
name|attr
operator|->
name|value
operator|.
name|data
operator|.
name|v
operator|->
name|len
argument_list|,
name|LINESIZE
argument_list|)
argument_list|)
expr_stmt|;
name|buf
index|[
name|MIN
argument_list|(
name|attr
operator|->
name|value
operator|.
name|data
operator|.
name|v
operator|->
name|len
argument_list|,
name|LINESIZE
operator|-
literal|1
argument_list|)
index|]
operator|=
literal|'\0'
expr_stmt|;
name|T
operator|.
name|my_id
operator|=
name|atoi
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
name|attr
operator|=
name|attr
operator|->
name|next
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
literal|"CMAP"
argument_list|,
name|e
operator|.
name|u
operator|.
name|start
operator|.
name|gi
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
name|maptype
operator|=
literal|'c'
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
literal|"SMAP"
argument_list|,
name|e
operator|.
name|u
operator|.
name|start
operator|.
name|gi
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
name|maptype
operator|=
literal|'s'
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
literal|"MAP"
argument_list|,
name|e
operator|.
name|u
operator|.
name|start
operator|.
name|gi
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|struct
name|sgmls_attribute
modifier|*
name|attr
init|=
name|e
operator|.
name|u
operator|.
name|start
operator|.
name|attributes
decl_stmt|;
name|char
modifier|*
name|from
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|to
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|attr
condition|)
block|{
if|if
condition|(
name|attr
operator|->
name|value
operator|.
name|data
operator|.
name|v
operator|&&
name|strncmp
argument_list|(
literal|"FROM"
argument_list|,
name|attr
operator|->
name|name
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|strncpy
argument_list|(
name|buf
argument_list|,
name|attr
operator|->
name|value
operator|.
name|data
operator|.
name|v
operator|->
name|s
argument_list|,
name|MIN
argument_list|(
name|attr
operator|->
name|value
operator|.
name|data
operator|.
name|v
operator|->
name|len
argument_list|,
name|LINESIZE
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|buf
index|[
name|MIN
argument_list|(
name|attr
operator|->
name|value
operator|.
name|data
operator|.
name|v
operator|->
name|len
argument_list|,
name|LINESIZE
operator|-
literal|1
argument_list|)
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|attr
operator|->
name|value
operator|.
name|data
operator|.
name|v
operator|&&
name|strncmp
argument_list|(
literal|"TO"
argument_list|,
name|attr
operator|->
name|name
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|strncpy
argument_list|(
name|buf2
argument_list|,
name|attr
operator|->
name|value
operator|.
name|data
operator|.
name|v
operator|->
name|s
argument_list|,
name|MIN
argument_list|(
name|attr
operator|->
name|value
operator|.
name|data
operator|.
name|v
operator|->
name|len
argument_list|,
name|LINESIZE
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|buf2
index|[
name|MIN
argument_list|(
name|attr
operator|->
name|value
operator|.
name|data
operator|.
name|v
operator|->
name|len
argument_list|,
name|LINESIZE
operator|-
literal|1
argument_list|)
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|attr
operator|=
name|attr
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|maptype
operator|==
literal|'c'
condition|)
name|AddCharMap
argument_list|(
name|buf
argument_list|,
name|buf2
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|maptype
operator|==
literal|'s'
condition|)
name|AddSDATA
argument_list|(
name|buf
argument_list|,
name|buf2
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unknown map type!\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strncpy
argument_list|(
name|gi
argument_list|,
name|e
operator|.
name|u
operator|.
name|start
operator|.
name|gi
argument_list|,
literal|512
argument_list|)
expr_stmt|;
name|sgmls_free_attributes
argument_list|(
name|e
operator|.
name|u
operator|.
name|start
operator|.
name|attributes
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SGMLS_EVENT_END
case|:
if|if
condition|(
name|strncmp
argument_list|(
literal|"RULE"
argument_list|,
name|e
operator|.
name|u
operator|.
name|start
operator|.
name|gi
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
name|RememberTransSpec
argument_list|(
operator|&
name|T
argument_list|,
name|e
operator|.
name|lineno
argument_list|)
expr_stmt|;
break|break;
case|case
name|SGMLS_EVENT_SUBSTART
case|:
break|break;
case|case
name|SGMLS_EVENT_SUBEND
case|:
break|break;
case|case
name|SGMLS_EVENT_APPINFO
case|:
break|break;
case|case
name|SGMLS_EVENT_CONFORMING
case|:
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|sgmls_free
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|pclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|command
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_data
parameter_list|(
name|char
modifier|*
name|gi
parameter_list|,
name|struct
name|sgmls_data
modifier|*
name|v
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
specifier|static
name|char
modifier|*
name|buf
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|buf_size
init|=
literal|0
decl_stmt|;
name|int
name|buf_pos
init|=
literal|0
decl_stmt|;
comment|/* figure out how much space this element will really         take, inculding expanded sdata entities. */
if|if
condition|(
operator|!
name|buf
condition|)
block|{
name|buf_size
operator|=
literal|1024
expr_stmt|;
name|Malloc
argument_list|(
name|buf_size
argument_list|,
name|buf
argument_list|,
name|char
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|len
decl_stmt|;
comment|/* Mark the current position.  If this is SDATA     	   we will have to return here. */
name|int
name|tmp_buf_pos
init|=
name|buf_pos
decl_stmt|;
comment|/* Make sure the buffer is big enough. */
if|if
condition|(
name|buf_size
operator|-
name|buf_pos
operator|<=
name|v
index|[
name|i
index|]
operator|.
name|len
condition|)
block|{
name|buf_size
operator|+=
name|v
index|[
name|i
index|]
operator|.
name|len
operator|*
operator|(
name|n
operator|-
name|i
operator|)
expr_stmt|;
name|Realloc
argument_list|(
name|buf_size
argument_list|,
name|buf
argument_list|,
name|char
argument_list|)
expr_stmt|;
block|}
name|s
operator|=
name|v
index|[
name|i
index|]
operator|.
name|s
expr_stmt|;
name|len
operator|=
name|v
index|[
name|i
index|]
operator|.
name|len
expr_stmt|;
for|for
control|(
init|;
name|len
operator|>
literal|0
condition|;
name|len
operator|--
operator|,
name|s
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|s
operator|!=
name|RSCHAR
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
name|RECHAR
condition|)
name|buf
index|[
name|buf_pos
index|]
operator|=
literal|'\n'
expr_stmt|;
else|else
name|buf
index|[
name|buf_pos
index|]
operator|=
operator|*
name|s
expr_stmt|;
name|buf_pos
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|v
index|[
name|i
index|]
operator|.
name|is_sdata
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|buf
index|[
name|buf_pos
index|]
operator|=
literal|'\0'
expr_stmt|;
name|p
operator|=
name|LookupSDATA
argument_list|(
name|buf
operator|+
name|tmp_buf_pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
block|{
if|if
condition|(
name|buf_size
operator|-
name|tmp_buf_pos
operator|<=
name|strlen
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|buf_size
operator|+=
name|strlen
argument_list|(
name|p
argument_list|)
operator|*
operator|(
name|n
operator|-
name|i
operator|)
expr_stmt|;
name|Realloc
argument_list|(
name|buf_size
argument_list|,
name|buf
argument_list|,
name|char
argument_list|)
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|buf
operator|+
name|tmp_buf_pos
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|buf_pos
operator|=
name|tmp_buf_pos
operator|+
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Clean up the trailing end of the data. */
name|buf
index|[
name|buf_pos
index|]
operator|=
literal|'\0'
expr_stmt|;
name|buf_pos
operator|--
expr_stmt|;
while|while
condition|(
name|buf_pos
operator|>
literal|0
operator|&&
name|isspace
argument_list|(
name|buf
index|[
name|buf_pos
index|]
argument_list|)
operator|&&
name|buf
index|[
name|buf_pos
index|]
operator|!=
literal|'\n'
condition|)
name|buf_pos
operator|--
expr_stmt|;
if|if
condition|(
name|buf
index|[
name|buf_pos
index|]
operator|==
literal|'\n'
condition|)
name|buf
index|[
name|buf_pos
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Skip over whitespace at the beginning of the data. */
name|cp
operator|=
name|buf
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|&&
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|cp
operator|++
expr_stmt|;
name|build_ts
argument_list|(
name|gi
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ______________________________________________________________________ */
end_comment

begin_comment
comment|/*  Set a transpec parameter  *  Arguments:  *	gi - the parameter to set  *	cp - the value of the parameter  */
end_comment

begin_function
specifier|static
name|void
name|build_ts
parameter_list|(
name|char
modifier|*
name|gi
parameter_list|,
name|char
modifier|*
name|cp
parameter_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
literal|"GI"
argument_list|,
name|gi
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|cp2
decl_stmt|;
comment|/* if we are folding the case of GIs, make all upper (unless 	   it's an internal pseudo-GI name, which starts with '_') */
if|if
condition|(
name|fold_case
operator|&&
name|cp
index|[
literal|0
index|]
operator|!=
literal|'_'
operator|&&
name|cp
index|[
literal|0
index|]
operator|!=
literal|'#'
condition|)
block|{
for|for
control|(
name|cp2
operator|=
name|cp
init|;
operator|*
name|cp2
condition|;
name|cp2
operator|++
control|)
if|if
condition|(
name|islower
argument_list|(
operator|*
name|cp2
argument_list|)
condition|)
operator|*
name|cp2
operator|=
name|toupper
argument_list|(
operator|*
name|cp2
argument_list|)
expr_stmt|;
block|}
name|T
operator|.
name|gi
operator|=
name|AddElemName
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
literal|"START"
argument_list|,
name|gi
argument_list|)
operator|==
literal|0
condition|)
name|T
operator|.
name|starttext
operator|=
name|strdup
argument_list|(
name|cp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
literal|"END"
argument_list|,
name|gi
argument_list|)
operator|==
literal|0
condition|)
name|T
operator|.
name|endtext
operator|=
name|strdup
argument_list|(
name|cp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
literal|"RELATION"
argument_list|,
name|gi
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|T
operator|.
name|relations
condition|)
name|T
operator|.
name|relations
operator|=
name|NewMap
argument_list|(
name|IMS_relations
argument_list|)
expr_stmt|;
name|SetMapping
argument_list|(
name|T
operator|.
name|relations
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
literal|"REPLACE"
argument_list|,
name|gi
argument_list|)
operator|==
literal|0
condition|)
name|T
operator|.
name|replace
operator|=
name|strdup
argument_list|(
name|cp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
literal|"ATTVAL"
argument_list|,
name|gi
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|T
operator|.
name|nattpairs
condition|)
block|{
name|Malloc
argument_list|(
literal|1
argument_list|,
name|T
operator|.
name|attpair
argument_list|,
name|AttPair_t
argument_list|)
expr_stmt|;
block|}
else|else
name|Realloc
argument_list|(
operator|(
name|T
operator|.
name|nattpairs
operator|+
literal|1
operator|)
argument_list|,
name|T
operator|.
name|attpair
argument_list|,
name|AttPair_t
argument_list|)
expr_stmt|;
comment|/* we'll split name/value pairs later */
name|T
operator|.
name|attpair
index|[
name|T
operator|.
name|nattpairs
index|]
operator|.
name|name
operator|=
name|strdup
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|T
operator|.
name|nattpairs
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
literal|"CONTEXT"
argument_list|,
name|gi
argument_list|)
operator|==
literal|0
condition|)
name|T
operator|.
name|context
operator|=
name|strdup
argument_list|(
name|cp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
literal|"MESSAGE"
argument_list|,
name|gi
argument_list|)
operator|==
literal|0
condition|)
name|T
operator|.
name|message
operator|=
name|strdup
argument_list|(
name|cp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
literal|"DO"
argument_list|,
name|gi
argument_list|)
operator|==
literal|0
condition|)
name|T
operator|.
name|use_id
operator|=
name|atoi
argument_list|(
name|cp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
literal|"CONTENT"
argument_list|,
name|gi
argument_list|)
operator|==
literal|0
condition|)
name|T
operator|.
name|content
operator|=
name|strdup
argument_list|(
name|cp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
literal|"PATTSET"
argument_list|,
name|gi
argument_list|)
operator|==
literal|0
condition|)
name|T
operator|.
name|pattrset
operator|=
name|strdup
argument_list|(
name|cp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
literal|"VERBATIM"
argument_list|,
name|gi
argument_list|)
operator|==
literal|0
condition|)
name|T
operator|.
name|verbatim
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
literal|"IGNORE"
argument_list|,
name|gi
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|cp
argument_list|,
literal|"all"
argument_list|)
condition|)
name|T
operator|.
name|ignore
operator|=
name|IGN_ALL
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|cp
argument_list|,
literal|"data"
argument_list|)
condition|)
name|T
operator|.
name|ignore
operator|=
name|IGN_DATA
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|cp
argument_list|,
literal|"children"
argument_list|)
condition|)
name|T
operator|.
name|ignore
operator|=
name|IGN_CHILDREN
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Bad 'Ignore:' arg in transpec %s: %s\n"
argument_list|,
name|gi
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
literal|"VARVAL"
argument_list|,
name|gi
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
modifier|*
name|tok
decl_stmt|;
name|int
name|i
init|=
literal|2
decl_stmt|;
name|tok
operator|=
name|Split
argument_list|(
name|cp
argument_list|,
operator|&
name|i
argument_list|,
name|S_STRDUP
argument_list|)
expr_stmt|;
name|T
operator|.
name|var_name
operator|=
name|tok
index|[
literal|0
index|]
expr_stmt|;
name|T
operator|.
name|var_value
operator|=
name|tok
index|[
literal|1
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
literal|"VARREVAL"
argument_list|,
name|gi
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
name|buf
index|[
literal|1000
index|]
decl_stmt|;
name|char
modifier|*
modifier|*
name|tok
decl_stmt|;
name|int
name|i
init|=
literal|2
decl_stmt|;
name|tok
operator|=
name|Split
argument_list|(
name|cp
argument_list|,
operator|&
name|i
argument_list|,
name|S_STRDUP
argument_list|)
expr_stmt|;
name|T
operator|.
name|var_RE_name
operator|=
name|tok
index|[
literal|0
index|]
expr_stmt|;
name|ExpandVariables
argument_list|(
name|tok
index|[
literal|1
index|]
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|T
operator|.
name|var_RE_value
operator|=
name|regcomp
argument_list|(
name|buf
argument_list|)
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Regex error in VarREValue Content: %s\n"
argument_list|,
name|tok
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
literal|"SET"
argument_list|,
name|gi
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|T
operator|.
name|set_var
condition|)
name|T
operator|.
name|set_var
operator|=
name|NewMap
argument_list|(
name|IMS_setvar
argument_list|)
expr_stmt|;
name|SetMapping
argument_list|(
name|T
operator|.
name|set_var
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
literal|"INCR"
argument_list|,
name|gi
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|T
operator|.
name|incr_var
condition|)
name|T
operator|.
name|incr_var
operator|=
name|NewMap
argument_list|(
name|IMS_incvar
argument_list|)
expr_stmt|;
name|SetMapping
argument_list|(
name|T
operator|.
name|incr_var
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
literal|"NTHCHILD"
argument_list|,
name|gi
argument_list|)
operator|==
literal|0
condition|)
name|T
operator|.
name|nth_child
operator|=
name|atoi
argument_list|(
name|cp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
literal|"VAR"
argument_list|,
name|gi
argument_list|)
operator|==
literal|0
condition|)
name|SetMapping
argument_list|(
name|Variables
argument_list|,
name|cp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
literal|"QUIT"
argument_list|,
name|gi
argument_list|)
operator|==
literal|0
condition|)
name|T
operator|.
name|quit
operator|=
name|strdup
argument_list|(
name|cp
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unknown translation spec (skipping it): %s\n"
argument_list|,
name|gi
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ______________________________________________________________________ */
end_comment

begin_comment
comment|/*  Store translation spec 't' in memory.  *  Arguments:  *	Pointer to translation spec to remember.  *	Line number where translation spec ends.  */
end_comment

begin_function
name|void
name|RememberTransSpec
parameter_list|(
name|Trans_t
modifier|*
name|t
parameter_list|,
name|int
name|lineno
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|do_regex
decl_stmt|;
specifier|static
name|Trans_t
modifier|*
name|last_t
decl_stmt|;
name|char
name|buf
index|[
literal|1000
index|]
decl_stmt|;
comment|/* If context testing, check some details and set things up for later. */
if|if
condition|(
name|t
operator|->
name|context
condition|)
block|{
comment|/* See if the context specified is a regular expression. 	 * If so, compile the reg expr.  It is assumed to be a regex if 	 * it contains a character other than what's allowed for GIs in the 	 * OSF sgml declaration (alphas, nums, '-', and '.'). 	 */
for|for
control|(
name|do_regex
operator|=
literal|0
operator|,
name|cp
operator|=
name|t
operator|->
name|context
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|isalnum
argument_list|(
operator|*
name|cp
argument_list|)
operator|&&
operator|*
name|cp
operator|!=
literal|'-'
operator|&&
operator|*
name|cp
operator|!=
literal|'.'
operator|&&
operator|*
name|cp
operator|!=
literal|' '
condition|)
block|{
name|do_regex
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|do_regex
condition|)
block|{
name|t
operator|->
name|depth
operator|=
name|MAX_DEPTH
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|t
operator|->
name|context_re
operator|=
name|regcomp
argument_list|(
name|t
operator|->
name|context
argument_list|)
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Regex error in Context: %s\n"
argument_list|,
name|t
operator|->
name|context
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* If there's only one item in context, it's the parent.  Treat 	     * it specially, since it's faster to just check parent gi. 	     */
name|cp
operator|=
name|t
operator|->
name|context
expr_stmt|;
if|if
condition|(
operator|!
name|strchr
argument_list|(
name|cp
argument_list|,
literal|' '
argument_list|)
condition|)
block|{
name|t
operator|->
name|parent
operator|=
name|t
operator|->
name|context
expr_stmt|;
name|t
operator|->
name|context
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* Figure out depth of context string */
name|t
operator|->
name|depth
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|cp
condition|)
block|{
if|if
condition|(
operator|*
name|cp
condition|)
name|t
operator|->
name|depth
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|&&
operator|!
name|IsWhite
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|cp
operator|++
expr_stmt|;
comment|/* find end of gi */
while|while
condition|(
operator|*
name|cp
operator|&&
name|IsWhite
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|cp
operator|++
expr_stmt|;
comment|/* skip space */
block|}
block|}
block|}
block|}
comment|/* Compile regular expressions for each attribute */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|t
operator|->
name|nattpairs
condition|;
name|i
operator|++
control|)
block|{
comment|/* Initially, name points to "name value".  Split them... */
name|cp
operator|=
name|t
operator|->
name|attpair
index|[
name|i
index|]
operator|.
name|name
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|&&
operator|!
name|IsWhite
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|cp
operator|++
expr_stmt|;
comment|/* point past end of name */
if|if
condition|(
operator|*
name|cp
condition|)
block|{
comment|/* value found */
operator|*
name|cp
operator|++
operator|=
name|EOS
expr_stmt|;
comment|/* terminate name */
while|while
condition|(
operator|*
name|cp
operator|&&
name|IsWhite
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|cp
operator|++
expr_stmt|;
comment|/* point to value */
name|ExpandVariables
argument_list|(
name|cp
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* expand any variables */
name|t
operator|->
name|attpair
index|[
name|i
index|]
operator|.
name|val
operator|=
name|strdup
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* value not found */
name|t
operator|->
name|attpair
index|[
name|i
index|]
operator|.
name|val
operator|=
literal|"."
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|t
operator|->
name|attpair
index|[
name|i
index|]
operator|.
name|rex
operator|=
name|regcomp
argument_list|(
name|t
operator|->
name|attpair
index|[
name|i
index|]
operator|.
name|val
argument_list|)
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Regex error in AttValue: %s %s\n"
argument_list|,
name|t
operator|->
name|attpair
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|t
operator|->
name|attpair
index|[
name|i
index|]
operator|.
name|val
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Compile regular expression for content */
name|t
operator|->
name|content_re
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|content
condition|)
block|{
name|ExpandVariables
argument_list|(
name|t
operator|->
name|content
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|t
operator|->
name|content_re
operator|=
name|regcomp
argument_list|(
name|buf
argument_list|)
operator|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Regex error in Content: %s\n"
argument_list|,
name|t
operator|->
name|content
argument_list|)
expr_stmt|;
block|}
comment|/* If multiple GIs, break up into a vector, then remember it.  We either      * sture the individual, or the list - not both. */
if|if
condition|(
name|t
operator|->
name|gi
operator|&&
name|strchr
argument_list|(
name|t
operator|->
name|gi
argument_list|,
literal|' '
argument_list|)
condition|)
block|{
name|t
operator|->
name|gilist
operator|=
name|Split
argument_list|(
name|t
operator|->
name|gi
argument_list|,
literal|0
argument_list|,
name|S_ALVEC
argument_list|)
expr_stmt|;
name|t
operator|->
name|gi
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Now, store structure in linked list. */
if|if
condition|(
operator|!
name|TrSpecs
condition|)
block|{
name|Malloc
argument_list|(
literal|1
argument_list|,
name|TrSpecs
argument_list|,
name|Trans_t
argument_list|)
expr_stmt|;
name|last_t
operator|=
name|TrSpecs
expr_stmt|;
block|}
else|else
block|{
name|Malloc
argument_list|(
literal|1
argument_list|,
name|last_t
operator|->
name|next
argument_list|,
name|Trans_t
argument_list|)
expr_stmt|;
name|last_t
operator|=
name|last_t
operator|->
name|next
expr_stmt|;
block|}
operator|*
name|last_t
operator|=
operator|*
name|t
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ______________________________________________________________________ */
end_comment

begin_comment
comment|/*  Add an entry to the character mapping table, allocating or  *  expanding the table if necessary.  *  Arguments:  *	Character to map  *      String to map the character to  *  	A 'c' or an 's' for character or sdata map  */
end_comment

begin_function
name|void
name|AddCharMap
parameter_list|(
specifier|const
name|char
modifier|*
name|from
parameter_list|,
specifier|const
name|char
modifier|*
name|to
parameter_list|)
block|{
specifier|static
name|int
name|n_alloc
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|from
operator|&&
name|to
condition|)
block|{
if|if
condition|(
name|nCharMap
operator|>=
name|n_alloc
condition|)
block|{
name|n_alloc
operator|+=
literal|32
expr_stmt|;
if|if
condition|(
operator|!
name|CharMap
condition|)
block|{
name|Malloc
argument_list|(
name|n_alloc
argument_list|,
name|CharMap
argument_list|,
name|Mapping_t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Realloc
argument_list|(
name|n_alloc
argument_list|,
name|CharMap
argument_list|,
name|Mapping_t
argument_list|)
expr_stmt|;
block|}
block|}
name|CharMap
index|[
name|nCharMap
index|]
operator|.
name|name
operator|=
name|strdup
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|CharMap
index|[
name|nCharMap
index|]
operator|.
name|sval
operator|=
name|strdup
argument_list|(
name|to
argument_list|)
expr_stmt|;
name|nCharMap
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ______________________________________________________________________ */
end_comment

begin_comment
comment|/*  Add an entry to the SDATA mapping table.  *  Arguments:  *	String to map  *      String to map to  */
end_comment

begin_function
name|void
name|AddSDATA
parameter_list|(
specifier|const
name|char
modifier|*
name|from
parameter_list|,
specifier|const
name|char
modifier|*
name|to
parameter_list|)
block|{
if|if
condition|(
name|from
operator|&&
name|to
condition|)
block|{
if|if
condition|(
operator|!
name|SDATAmap
condition|)
name|SDATAmap
operator|=
name|NewMap
argument_list|(
name|IMS_sdata
argument_list|)
expr_stmt|;
name|SetMappingNV
argument_list|(
name|SDATAmap
argument_list|,
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ______________________________________________________________________ */
end_comment

end_unit

