begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  Copyright 1993 Open Software Foundation, Inc., Cambridge, Massachusetts.  *  All rights reserved.  */
end_comment

begin_comment
comment|/*  * Copyright (c) 1994    * Open Software Foundation, Inc.   *    * Permission is hereby granted to use, copy, modify and freely distribute   * the software in this file and its documentation for any purpose without   * fee, provided that the above copyright notice appears in all copies and   * that both the copyright notice and this permission notice appear in   * supporting documentation.  Further, provided that the name of Open   * Software Foundation, Inc. ("OSF") not be used in advertising or   * publicity pertaining to distribution of the software without prior   * written permission from OSF.  OSF makes no representations about the   * suitability of this software for any purpose.  It is provided "as is"   * without express or implied warranty.   */
end_comment

begin_comment
comment|/*  * Copyright (c) 1996 X Consortium  * Copyright (c) 1995, 1996 Dalrymple Consulting  *   * Permission is hereby granted, free of charge, to any person obtaining a copy  * of this software and associated documentation files (the "Software"), to deal  * in the Software without restriction, including without limitation the rights  * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell  * copies of the Software, and to permit persons to whom the Software is  * furnished to do so, subject to the following conditions:  *   * The above copyright notice and this permission notice shall be included in  * all copies or substantial portions of the Software.  *   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE  * X CONSORTIUM OR DALRYMPLE CONSULTING BE LIABLE FOR ANY CLAIM, DAMAGES OR  * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,  * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR  * OTHER DEALINGS IN THE SOFTWARE.  *   * Except as contained in this notice, the names of the X Consortium and  * Dalrymple Consulting shall not be used in advertising or otherwise to  * promote the sale, use or other dealings in this Software without prior  * written authorization.  */
end_comment

begin_comment
comment|/* ________________________________________________________________________  *  *  Functions for printing information about an instance in the 'instant'  *  program.  Most of these are fairly short and simple.  *  *  Entry points for this module:  *	PrintElemSummary(elem)	print summary info of each element  *	PrintContext(elem)	print context of each element  *	PrintElemTree(elem)	print tree of document  *	PrintStats(elem)	print statistics about doc tree  *	PrintIDList(elem)	print list of IDs and element context  *  Most Print*() functions start at subtree pointed to by 'elem'.  * ________________________________________________________________________  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|RCSid
init|=
literal|"$Header: /usr/src/docbook-to-man/Instant/RCS/info.c,v 1.2 1996/06/02 21:46:10 fld Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"general.h"
end_include

begin_comment
comment|/* ______________________________________________________________________ */
end_comment

begin_comment
comment|/*  Print a summary of each tag use in the instance.  Things like depth in  *  the tree, number of children, parent, attributes.  */
end_comment

begin_comment
comment|/*  Do the actual printing.  Print the info about the node.  If null,  *  print a header for the columns.  *  Arguments:  *	Pointer to element structure of the node to print.  */
end_comment

begin_function
specifier|static
name|void
name|print_summ
parameter_list|(
name|Element_t
modifier|*
name|e
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|n
decl_stmt|,
name|dsize
decl_stmt|;
name|char
modifier|*
name|hfmt
init|=
literal|"%-18.18s %4s %5s %4s %4s %s\n"
decl_stmt|;
name|char
modifier|*
name|fmt
init|=
literal|"%-18.18s %4d %5d %4d %4d %s\n"
decl_stmt|;
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|outfp
argument_list|,
name|hfmt
argument_list|,
literal|"Element"
argument_list|,
literal|"Att"
argument_list|,
literal|"Data"
argument_list|,
literal|"Chd"
argument_list|,
literal|"Dep"
argument_list|,
literal|"Parent"
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|n
operator|=
literal|0
init|;
name|i
operator|<
name|e
operator|->
name|ncont
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|IsContElem
argument_list|(
name|e
argument_list|,
name|i
argument_list|)
condition|)
name|n
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|dsize
operator|=
literal|0
init|;
name|i
operator|<
name|e
operator|->
name|ncont
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|IsContElem
argument_list|(
name|e
argument_list|,
name|i
argument_list|)
condition|)
name|dsize
operator|+=
name|strlen
argument_list|(
name|e
operator|->
name|cont
index|[
name|i
index|]
operator|.
name|ch
operator|.
name|data
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfp
argument_list|,
name|fmt
argument_list|,
name|e
operator|->
name|gi
argument_list|,
name|e
operator|->
name|natts
argument_list|,
name|dsize
argument_list|,
name|n
argument_list|,
name|e
operator|->
name|depth
argument_list|,
name|e
operator|->
name|parent
condition|?
name|e
operator|->
name|parent
operator|->
name|gi
else|:
literal|"-"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|e
operator|->
name|natts
condition|;
name|i
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|outfp
argument_list|,
literal|"%45d: %s = %s\n"
argument_list|,
name|i
argument_list|,
name|e
operator|->
name|atts
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|e
operator|->
name|atts
index|[
name|i
index|]
operator|.
name|sval
condition|?
name|e
operator|->
name|atts
index|[
name|i
index|]
operator|.
name|sval
else|:
literal|"empty"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  Descend the tree, calling processing routine.  *  Arguments:  *	Pointer to element structure at top of tree to traverse.  */
end_comment

begin_function
name|void
name|PrintElemSummary
parameter_list|(
name|Element_t
modifier|*
name|e
parameter_list|)
block|{
name|print_summ
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|DescendTree
argument_list|(
name|e
argument_list|,
name|print_summ
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ______________________________________________________________________ */
end_comment

begin_comment
comment|/*  Print the context of each tag in the instance (i.e. the tag with its  *  ancestors).  */
end_comment

begin_comment
comment|/*  Do the actual printing.  Print the context of the node.  *  Arguments:  *	Pointer to element structure of the node to print.  */
end_comment

begin_function
specifier|static
name|void
name|print_context
parameter_list|(
name|Element_t
modifier|*
name|e
parameter_list|)
block|{
name|char
name|buf
index|[
name|LINESIZE
index|]
decl_stmt|;
name|fprintf
argument_list|(
name|outfp
argument_list|,
literal|"%-22s %s\n"
argument_list|,
name|e
operator|->
name|gi
argument_list|,
name|FindContext
argument_list|(
name|e
argument_list|,
literal|10
argument_list|,
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  Descend the tree, calling processing routine.  *  Arguments:  *	Pointer to element structure at top of tree to traverse.  */
end_comment

begin_function
name|void
name|PrintContext
parameter_list|(
name|Element_t
modifier|*
name|e
parameter_list|)
block|{
name|fprintf
argument_list|(
name|outfp
argument_list|,
literal|"%-22s %s\n"
argument_list|,
literal|"Element"
argument_list|,
literal|"Context"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfp
argument_list|,
literal|"%-22s %s\n"
argument_list|,
literal|"---------------"
argument_list|,
literal|"-----------"
argument_list|)
expr_stmt|;
name|DescendTree
argument_list|(
name|e
argument_list|,
name|print_context
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|putc
argument_list|(
name|NL
argument_list|,
name|outfp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ______________________________________________________________________ */
end_comment

begin_comment
comment|/*  Print tree of the instance.  GI's are printed indented by their depth  *  in the tree.  */
end_comment

begin_comment
comment|/*  Do the actual printing.  Print the element name, indented the right amount.  *  Arguments:  *	Pointer to element structure of the node to print.  */
end_comment

begin_function
specifier|static
name|void
name|print_indent
parameter_list|(
name|Element_t
modifier|*
name|e
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|ne
decl_stmt|,
name|nd
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|e
operator|->
name|depth
condition|;
name|i
operator|++
control|)
name|fputs
argument_list|(
literal|".  "
argument_list|,
name|outfp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|ne
operator|=
literal|0
init|;
name|i
operator|<
name|e
operator|->
name|ncont
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|IsContElem
argument_list|(
name|e
argument_list|,
name|i
argument_list|)
condition|)
name|ne
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|nd
operator|=
literal|0
init|;
name|i
operator|<
name|e
operator|->
name|ncont
condition|;
name|i
operator|++
control|)
if|if IsContData
condition|(
name|e
operator|,
name|i
condition|)
name|nd
operator|++
expr_stmt|;
name|fprintf
argument_list|(
name|outfp
argument_list|,
literal|"%s  (%d,%d)\n"
argument_list|,
name|e
operator|->
name|gi
argument_list|,
name|ne
argument_list|,
name|nd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  Descend the tree, calling processing routine.  *  Arguments:  *	Pointer to element structure at top of tree to traverse.  */
end_comment

begin_function
name|void
name|PrintElemTree
parameter_list|(
name|Element_t
modifier|*
name|e
parameter_list|)
block|{
name|DescendTree
argument_list|(
name|e
argument_list|,
name|print_indent
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|putc
argument_list|(
name|NL
argument_list|,
name|outfp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ______________________________________________________________________ */
end_comment

begin_comment
comment|/*  Print some statistics about the instance.  */
end_comment

begin_comment
comment|/*  Accumulate the totals for the statistics.  *  Arguments:  *	Pointer to element structure of the node to print.  *	Pointer to the total number of elements.  *	Pointer to the total amount of content data.  *	Pointer to the maximum depth of tree.  */
end_comment

begin_function
specifier|static
name|void
name|acc_tots
parameter_list|(
name|Element_t
modifier|*
name|e
parameter_list|,
name|int
modifier|*
name|tot_el
parameter_list|,
name|int
modifier|*
name|tot_data
parameter_list|,
name|int
modifier|*
name|max_depth
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|e
operator|->
name|necont
condition|;
name|i
operator|++
control|)
name|acc_tots
argument_list|(
name|e
operator|->
name|econt
index|[
name|i
index|]
argument_list|,
name|tot_el
argument_list|,
name|tot_data
argument_list|,
name|max_depth
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|e
operator|->
name|necont
condition|;
name|i
operator|++
control|)
operator|(
operator|*
name|tot_el
operator|)
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|e
operator|->
name|ndcont
condition|;
name|i
operator|++
control|)
operator|(
operator|*
name|tot_data
operator|)
operator|+=
name|strlen
argument_list|(
name|e
operator|->
name|dcont
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|depth
operator|>
operator|(
operator|*
name|max_depth
operator|)
condition|)
operator|*
name|max_depth
operator|=
name|e
operator|->
name|depth
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  Descend the tree (recursively), collecting the statistics.  *  Arguments:  *	Pointer to element structure of the node to print.  *	Pointer to the total number of elements.  *	Pointer to the total amount of content data.  *	Pointer to the maximum depth of tree.  */
end_comment

begin_function
specifier|static
name|void
name|elem_usage
parameter_list|(
name|Element_t
modifier|*
name|e
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|int
modifier|*
name|n_used
parameter_list|,
name|int
modifier|*
name|nchars
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
name|e
operator|->
name|gi
argument_list|)
condition|)
block|{
operator|(
operator|*
name|n_used
operator|)
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|e
operator|->
name|ncont
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|IsContData
argument_list|(
name|e
argument_list|,
name|i
argument_list|)
condition|)
operator|(
operator|*
name|nchars
operator|)
operator|+=
name|strlen
argument_list|(
name|ContData
argument_list|(
name|e
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|e
operator|->
name|necont
condition|;
name|i
operator|++
control|)
name|elem_usage
argument_list|(
name|e
operator|->
name|econt
index|[
name|i
index|]
argument_list|,
name|name
argument_list|,
name|n_used
argument_list|,
name|nchars
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  Descend the tree, calling processing routine.  *  Arguments:  *	Pointer to element structure at top of tree to traverse.  */
end_comment

begin_function
name|void
name|PrintStats
parameter_list|(
name|Element_t
modifier|*
name|top
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
name|int
name|dif_el
init|=
literal|0
decl_stmt|,
name|tot_el
init|=
literal|0
decl_stmt|,
name|tot_data
init|=
literal|0
decl_stmt|,
name|nchars
decl_stmt|,
name|max_depth
init|=
literal|0
decl_stmt|;
name|float
name|pct
decl_stmt|;
name|fprintf
argument_list|(
name|outfp
argument_list|,
literal|"%-22s %s   %s\n"
argument_list|,
literal|"Element name"
argument_list|,
literal|"Occurrances"
argument_list|,
literal|"Character Content"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfp
argument_list|,
literal|"%-22s %s   %s\n"
argument_list|,
literal|"---------------"
argument_list|,
literal|"-----------"
argument_list|,
literal|"-----------------"
argument_list|)
expr_stmt|;
name|acc_tots
argument_list|(
name|top
argument_list|,
operator|&
name|tot_el
argument_list|,
operator|&
name|tot_data
argument_list|,
operator|&
name|max_depth
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nUsedElem
condition|;
name|i
operator|++
control|)
block|{
name|n
operator|=
literal|0
expr_stmt|;
name|nchars
operator|=
literal|0
expr_stmt|;
name|elem_usage
argument_list|(
name|top
argument_list|,
name|UsedElem
index|[
name|i
index|]
argument_list|,
operator|&
name|n
argument_list|,
operator|&
name|nchars
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|pct
operator|=
literal|100.0
operator|*
operator|(
name|float
operator|)
name|n
operator|/
operator|(
name|float
operator|)
name|tot_el
expr_stmt|;
name|fprintf
argument_list|(
name|outfp
argument_list|,
literal|"%-22s %4d  %4.1f%%   %6d  %4d\n"
argument_list|,
name|UsedElem
index|[
name|i
index|]
argument_list|,
name|n
argument_list|,
name|pct
argument_list|,
name|nchars
argument_list|,
operator|(
name|nchars
operator|/
name|n
operator|)
argument_list|)
expr_stmt|;
name|dif_el
operator|++
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|outfp
argument_list|,
literal|"\nTotal of %d elements used, %d different ones.\n"
argument_list|,
name|tot_el
argument_list|,
name|dif_el
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfp
argument_list|,
literal|"Total character data: %d.\n"
argument_list|,
name|tot_data
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfp
argument_list|,
literal|"Maximum element depth: %d.\n"
argument_list|,
name|max_depth
argument_list|)
expr_stmt|;
name|putc
argument_list|(
name|NL
argument_list|,
name|outfp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ______________________________________________________________________ */
end_comment

begin_comment
comment|/* Print list of: ID, GI, input file, line number, separated by colons.  * This is better for other programs to manipulate (like for keeping a  * database of IDs in documents) than humans to read.  */
end_comment

begin_function
name|void
name|PrintIDList
parameter_list|()
block|{
name|ID_t
modifier|*
name|id
decl_stmt|;
name|Element_t
modifier|*
name|ep
decl_stmt|;
for|for
control|(
name|id
operator|=
name|IDList
init|;
name|id
condition|;
name|id
operator|=
name|id
operator|->
name|next
control|)
block|{
name|ep
operator|=
name|id
operator|->
name|elem
expr_stmt|;
name|fprintf
argument_list|(
name|outfp
argument_list|,
literal|"%s:%s:%s:%d\n"
argument_list|,
name|id
operator|->
name|id
argument_list|,
name|ep
operator|->
name|gi
argument_list|,
name|ep
operator|->
name|infile
condition|?
name|ep
operator|->
name|infile
else|:
literal|"-"
argument_list|,
name|ep
operator|->
name|lineno
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ______________________________________________________________________ */
end_comment

end_unit

