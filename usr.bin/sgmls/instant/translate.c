begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  Copyright 1993 Open Software Foundation, Inc., Cambridge, Massachusetts.  *  All rights reserved.  */
end_comment

begin_comment
comment|/*  * Copyright (c) 1994    * Open Software Foundation, Inc.   *    * Permission is hereby granted to use, copy, modify and freely distribute   * the software in this file and its documentation for any purpose without   * fee, provided that the above copyright notice appears in all copies and   * that both the copyright notice and this permission notice appear in   * supporting documentation.  Further, provided that the name of Open   * Software Foundation, Inc. ("OSF") not be used in advertising or   * publicity pertaining to distribution of the software without prior   * written permission from OSF.  OSF makes no representations about the   * suitability of this software for any purpose.  It is provided "as is"   * without express or implied warranty.   */
end_comment

begin_comment
comment|/*  * Copyright (c) 1996 X Consortium  * Copyright (c) 1995, 1996 Dalrymple Consulting  *   * Permission is hereby granted, free of charge, to any person obtaining a copy  * of this software and associated documentation files (the "Software"), to deal  * in the Software without restriction, including without limitation the rights  * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell  * copies of the Software, and to permit persons to whom the Software is  * furnished to do so, subject to the following conditions:  *   * The above copyright notice and this permission notice shall be included in  * all copies or substantial portions of the Software.  *   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE  * X CONSORTIUM OR DALRYMPLE CONSULTING BE LIABLE FOR ANY CLAIM, DAMAGES OR  * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,  * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR  * OTHER DEALINGS IN THE SOFTWARE.  *   * Except as contained in this notice, the names of the X Consortium and  * Dalrymple Consulting shall not be used in advertising or otherwise to  * promote the sale, use or other dealings in this Software without prior  * written authorization.  */
end_comment

begin_comment
comment|/* ________________________________________________________________________  *  *  Program to manipulate SGML instances.  *  *  This module is for "translating" an instance to another form, usually  *  suitable for a formatting application.  *  *  Entry points for this module:  *	DoTranslate(elem, fp)  *      ExpandVariables(in, out, e)  * ________________________________________________________________________  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|RCSid
init|=
literal|"$Header: /usr/src/docbook-to-man/Instant/RCS/translate.c,v 1.11 1996/06/15 22:49:00 fld Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<memory.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<regexp.h>
end_include

begin_include
include|#
directive|include
file|"general.h"
end_include

begin_define
define|#
directive|define
name|STORAGE
end_define

begin_include
include|#
directive|include
file|"translate.h"
end_include

begin_decl_stmt
specifier|static
name|Trans_t
name|NullTrans
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* an empty one */
end_comment

begin_comment
comment|/* forward references */
end_comment

begin_function_decl
name|void
name|ProcesOutputSpec
parameter_list|(
name|char
modifier|*
parameter_list|,
name|Element_t
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|WasProcessed
parameter_list|(
name|Element_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* ______________________________________________________________________ */
end_comment

begin_comment
comment|/*  Translate the subtree starting at 'e'. Output goes to 'fp'.  *  This is the entry point for translating an instance.  *  Arguments:  *	Pointer to element under consideration.  *	FILE pointer to where to write output.  */
end_comment

begin_function
name|void
name|DoTranslate
parameter_list|(
name|Element_t
modifier|*
name|e
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|Trans_t
modifier|*
name|t
decl_stmt|,
modifier|*
name|tn
decl_stmt|;
comment|/* Find transpec for each node. */
name|DescendTree
argument_list|(
name|e
argument_list|,
name|PrepTranspecs
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Stuff to do at start of processing */
if|if
condition|(
operator|(
name|t
operator|=
name|FindTransByName
argument_list|(
literal|"_Start"
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|t
operator|->
name|starttext
condition|)
name|ProcesOutputSpec
argument_list|(
name|t
operator|->
name|starttext
argument_list|,
literal|0
argument_list|,
name|fp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|replace
condition|)
name|ProcesOutputSpec
argument_list|(
name|t
operator|->
name|replace
argument_list|,
literal|0
argument_list|,
name|fp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|message
condition|)
name|ProcesOutputSpec
argument_list|(
name|t
operator|->
name|message
argument_list|,
literal|0
argument_list|,
name|stderr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|endtext
condition|)
name|ProcesOutputSpec
argument_list|(
name|t
operator|->
name|endtext
argument_list|,
literal|0
argument_list|,
name|fp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Translate topmost/first element.  This is recursive. */
name|TransElement
argument_list|(
name|e
argument_list|,
name|fp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Stuff to do at end of processing */
if|if
condition|(
operator|(
name|t
operator|=
name|FindTransByName
argument_list|(
literal|"_End"
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|t
operator|->
name|starttext
condition|)
name|ProcesOutputSpec
argument_list|(
name|t
operator|->
name|starttext
argument_list|,
literal|0
argument_list|,
name|fp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|replace
condition|)
name|ProcesOutputSpec
argument_list|(
name|t
operator|->
name|replace
argument_list|,
literal|0
argument_list|,
name|fp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|message
condition|)
name|ProcesOutputSpec
argument_list|(
name|t
operator|->
name|message
argument_list|,
literal|0
argument_list|,
name|stderr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|endtext
condition|)
name|ProcesOutputSpec
argument_list|(
name|t
operator|->
name|endtext
argument_list|,
literal|0
argument_list|,
name|fp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Warn about unprocessed elements in this doc tree, if verbose mode. */
if|if
condition|(
name|verbose
condition|)
name|DescendTree
argument_list|(
name|e
argument_list|,
name|WasProcessed
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Clean up. This is not yet complete, which is no big deal (since the      * program is normally done at this point anyway.  */
for|for
control|(
name|t
operator|=
name|TrSpecs
init|;
name|t
condition|;
control|)
block|{
name|tn
operator|=
name|t
operator|->
name|next
expr_stmt|;
comment|/* free the contents of t here ... */
operator|(
name|void
operator|)
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
name|tn
expr_stmt|;
block|}
name|TrSpecs
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ______________________________________________________________________ */
end_comment

begin_comment
comment|/*  Print warning about unprocessed elements in this doc tree (if they  *  were not explicitely ignored).  *  Arguments:  *	Pointer to element under consideration.  */
end_comment

begin_function
specifier|static
name|void
name|WasProcessed
parameter_list|(
name|Element_t
modifier|*
name|e
parameter_list|)
block|{
name|Trans_t
modifier|*
name|t
decl_stmt|;
name|t
operator|=
name|e
operator|->
name|trans
expr_stmt|;
if|if
condition|(
operator|!
name|e
operator|->
name|processed
operator|&&
operator|(
name|t
operator|&&
operator|!
name|t
operator|->
name|ignore
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Warning: element '%s' was not processed:\n"
argument_list|,
name|e
operator|->
name|gi
argument_list|)
expr_stmt|;
name|PrintLocation
argument_list|(
name|e
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ______________________________________________________________________ */
end_comment

begin_comment
comment|/*  For each element find transpec.  *  Arguments:  *	Pointer to element under consideration.  */
end_comment

begin_function
name|void
name|PrepTranspecs
parameter_list|(
name|Element_t
modifier|*
name|e
parameter_list|)
block|{
name|Trans_t
modifier|*
name|t
decl_stmt|;
name|t
operator|=
name|FindTrans
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|e
operator|->
name|trans
operator|=
name|t
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ______________________________________________________________________ */
end_comment

begin_comment
comment|/*  Copy a buffer/string into another, expanding regular variables and immediate  *  variables. (Special variables are done later.)  *  Arguments:  *	Pointer to string to expand.  *	Pointer to expanded string. (return)  *	Pointer to element under consideration.  */
end_comment

begin_function
name|void
name|ExpandVariables
parameter_list|(
name|char
modifier|*
name|in
parameter_list|,
name|char
modifier|*
name|out
parameter_list|,
name|Element_t
modifier|*
name|e
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|char
modifier|*
name|ip
decl_stmt|,
modifier|*
name|vp
decl_stmt|,
modifier|*
name|op
decl_stmt|;
name|char
modifier|*
name|def_val
decl_stmt|,
modifier|*
name|s
decl_stmt|,
modifier|*
name|atval
decl_stmt|,
modifier|*
name|modifier
decl_stmt|;
name|char
name|vbuf
index|[
literal|500
index|]
decl_stmt|;
name|int
name|lev
decl_stmt|;
name|ip
operator|=
name|in
expr_stmt|;
name|op
operator|=
name|out
expr_stmt|;
while|while
condition|(
operator|*
name|ip
condition|)
block|{
comment|/* start of regular variable? */
if|if
condition|(
operator|*
name|ip
operator|==
literal|'$'
operator|&&
operator|*
operator|(
name|ip
operator|+
literal|1
operator|)
operator|==
name|L_CURLY
operator|&&
operator|*
operator|(
name|ip
operator|+
literal|2
operator|)
operator|!=
literal|'_'
condition|)
block|{
name|ip
operator|++
expr_stmt|;
name|ip
operator|++
expr_stmt|;
comment|/* point at variable name */
name|vp
operator|=
name|vbuf
expr_stmt|;
comment|/*	Look for matching (closing) curly. (watch for nesting) 	     *	We store the variable content in a tmp buffer, so we don't 	     *	clobber the input buffer. 	     */
name|lev
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|ip
condition|)
block|{
if|if
condition|(
operator|*
name|ip
operator|==
name|L_CURLY
condition|)
name|lev
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|ip
operator|==
name|R_CURLY
condition|)
block|{
if|if
condition|(
name|lev
operator|==
literal|0
condition|)
block|{
name|ip
operator|++
expr_stmt|;
break|break;
block|}
else|else
name|lev
operator|--
expr_stmt|;
block|}
operator|*
name|vp
operator|++
operator|=
operator|*
name|ip
operator|++
expr_stmt|;
comment|/* copy to variable buffer */
block|}
operator|*
name|vp
operator|=
name|EOS
expr_stmt|;
comment|/* vbuf now contains the variable name (stuff between curlys). */
if|if
condition|(
name|lev
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Botched variable use: %s\n"
argument_list|,
name|in
argument_list|)
expr_stmt|;
comment|/* copy rest of string if we can't recover  ?? */
return|return;
block|}
comment|/* Now, expand variable. */
name|vp
operator|=
name|vbuf
expr_stmt|;
comment|/* Check for immediate variables -- like _special variables but 	     * interpreted right now.  These start with a "+" */
if|if
condition|(
operator|*
name|vp
operator|==
literal|'+'
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|vp
argument_list|,
literal|"+content"
argument_list|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|e
operator|->
name|ncont
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|IsContData
argument_list|(
name|e
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|j
operator|=
name|strlen
argument_list|(
name|ContData
argument_list|(
name|e
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|op
argument_list|,
name|ContData
argument_list|(
name|e
argument_list|,
name|i
argument_list|)
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|op
operator|+=
name|j
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"warning: ${+current} skipped element content\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"unknown immediate variable: %s\n"
argument_list|,
name|vp
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* See if this variable has a default [ format: ${varname def} ] */
name|def_val
operator|=
name|vp
expr_stmt|;
while|while
condition|(
operator|*
name|def_val
operator|&&
operator|*
name|def_val
operator|!=
literal|' '
condition|)
name|def_val
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|def_val
condition|)
operator|*
name|def_val
operator|++
operator|=
name|EOS
expr_stmt|;
else|else
name|def_val
operator|=
literal|0
expr_stmt|;
comment|/* def_val now points to default, if it exists, null if not. */
name|modifier
operator|=
name|vp
expr_stmt|;
while|while
condition|(
operator|*
name|modifier
operator|&&
operator|*
name|modifier
operator|!=
literal|':'
condition|)
name|modifier
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|modifier
condition|)
operator|*
name|modifier
operator|++
operator|=
name|EOS
expr_stmt|;
else|else
name|modifier
operator|=
literal|0
expr_stmt|;
comment|/* modifier now points to modifier if it exists, null if not. */
name|s
operator|=
literal|0
expr_stmt|;
comment|/* if attribute of current elem with this name found, use value */
if|if
condition|(
name|e
operator|&&
operator|(
name|atval
operator|=
name|FindAttValByName
argument_list|(
name|e
argument_list|,
name|vp
argument_list|)
operator|)
condition|)
name|s
operator|=
name|atval
expr_stmt|;
else|else
comment|/* else try for (global) variable with this name */
name|s
operator|=
name|FindMappingVal
argument_list|(
name|Variables
argument_list|,
name|vp
argument_list|)
expr_stmt|;
comment|/* If we found a value, copy it to the output buffer. */
if|if
condition|(
name|s
condition|)
block|{
if|if
condition|(
name|modifier
operator|&&
operator|*
name|modifier
operator|==
literal|'l'
condition|)
block|{
while|while
condition|(
operator|*
name|s
condition|)
block|{
operator|*
name|op
operator|=
name|tolower
argument_list|(
operator|*
name|s
argument_list|)
expr_stmt|;
name|op
operator|++
operator|,
operator|*
name|s
operator|++
expr_stmt|;
block|}
block|}
else|else
while|while
condition|(
operator|*
name|s
condition|)
operator|*
name|op
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|def_val
condition|)
block|{
while|while
condition|(
operator|*
name|def_val
condition|)
operator|*
name|op
operator|++
operator|=
operator|*
name|def_val
operator|++
expr_stmt|;
block|}
block|}
continue|continue;
block|}
operator|*
name|op
operator|++
operator|=
operator|*
name|ip
operator|++
expr_stmt|;
block|}
operator|*
name|op
operator|=
name|EOS
expr_stmt|;
comment|/* terminate string */
block|}
end_function

begin_comment
comment|/* ______________________________________________________________________ */
end_comment

begin_comment
comment|/*  Process an "output" translation spec - one of StartText, EndText,  *  Replace, Message.  (These are the ones that produce output.)  *  Steps done:  *	Expand attributes and regular varaibles in input string.  *	Pass thru string, accumulating chars to be sent to output stream.  *	If we find the start of a special variable, output what we've  *	  accumulated, then find the special variable's "bounds" (ie, the  *	  stuff between the curly brackets), and expand that by passing to  *	  ExpandSpecialVar().  Continue until done the input string.  *  Arguments:  *	Input buffer (string) to be expanded and output.  *	Pointer to element under consideration.  *	FILE pointer to where to write output.  *	Flag saying whether to track the character position we're on  *	  (passed to OutputString).  */
end_comment

begin_function
name|void
name|ProcesOutputSpec
parameter_list|(
name|char
modifier|*
name|ib
parameter_list|,
name|Element_t
modifier|*
name|e
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
name|int
name|track_pos
parameter_list|)
block|{
name|char
name|obuf
index|[
name|LINESIZE
index|]
decl_stmt|;
name|char
name|vbuf
index|[
name|LINESIZE
index|]
decl_stmt|;
name|char
modifier|*
name|dest
decl_stmt|,
name|vname
index|[
name|LINESIZE
index|]
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|int
name|esc
decl_stmt|;
name|obuf
index|[
literal|0
index|]
operator|=
name|EOS
expr_stmt|;
comment|/* start with empty output buffer */
name|ExpandVariables
argument_list|(
name|ib
argument_list|,
name|vbuf
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|/* expand regular variables */
name|ib
operator|=
name|vbuf
expr_stmt|;
name|dest
operator|=
name|obuf
expr_stmt|;
name|esc
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|ib
condition|)
block|{
comment|/* If not a $, it's a regular char.  Just copy it and go to next. */
if|if
condition|(
operator|*
name|ib
operator|!=
literal|'$'
condition|)
block|{
comment|/* look for att/variable marker */
operator|*
name|dest
operator|++
operator|=
operator|*
name|ib
operator|++
expr_stmt|;
comment|/* it's not. just copy character */
continue|continue;
block|}
comment|/* We have a $.  What we have must be a "special variable" since 	 * regular variables have already been expanded, or just a lone $. */
if|if
condition|(
name|ib
index|[
literal|1
index|]
operator|!=
name|L_CURLY
condition|)
block|{
comment|/* just a stray dollar sign (no variable) */
operator|*
name|dest
operator|++
operator|=
operator|*
name|ib
operator|++
expr_stmt|;
continue|continue;
block|}
name|ib
operator|++
expr_stmt|;
comment|/* point past $ */
comment|/* Output what we have in buffer so far. */
operator|*
name|dest
operator|=
name|EOS
expr_stmt|;
comment|/* terminate string */
if|if
condition|(
name|obuf
index|[
literal|0
index|]
condition|)
name|OutputString
argument_list|(
name|obuf
argument_list|,
name|fp
argument_list|,
name|track_pos
argument_list|)
expr_stmt|;
name|dest
operator|=
name|obuf
expr_stmt|;
comment|/* ready for new stuff in buffer */
if|if
condition|(
operator|!
name|strchr
argument_list|(
name|ib
argument_list|,
name|R_CURLY
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Mismatched braces in TranSpec: %s\n"
argument_list|,
name|ib
argument_list|)
expr_stmt|;
comment|/* how do we recover from this? */
block|}
name|ib
operator|++
expr_stmt|;
name|cp
operator|=
name|vname
expr_stmt|;
while|while
condition|(
operator|*
name|ib
operator|&&
operator|*
name|ib
operator|!=
name|R_CURLY
condition|)
operator|*
name|cp
operator|++
operator|=
operator|*
name|ib
operator|++
expr_stmt|;
operator|*
name|cp
operator|=
name|EOS
expr_stmt|;
comment|/* terminate att/var name */
name|ib
operator|++
expr_stmt|;
comment|/* point past closing curly */
comment|/* we now have special variable name (stuff in curly {}'s) in vname */
name|ExpandSpecialVar
argument_list|(
operator|&
name|vname
index|[
literal|1
index|]
argument_list|,
name|e
argument_list|,
name|fp
argument_list|,
name|track_pos
argument_list|)
expr_stmt|;
block|}
operator|*
name|dest
operator|=
name|EOS
expr_stmt|;
comment|/* terminate string in output buffer */
if|if
condition|(
name|obuf
index|[
literal|0
index|]
condition|)
name|OutputString
argument_list|(
name|obuf
argument_list|,
name|fp
argument_list|,
name|track_pos
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ______________________________________________________________________ */
end_comment

begin_comment
comment|/*  Find the translation spec for the given tag.  *  Returns pointer to first spec that matches (name, depth, etc., of tag).  *  Arguments:  *	e -- Pointer to element under consideration.  *	specID -- name of specid that we're looking for  *  Return:  *	Pointer to translation spec that matches given element's context.  */
end_comment

begin_function
name|Trans_t
modifier|*
name|FindTrans
parameter_list|(
name|Element_t
modifier|*
name|e
parameter_list|,
name|int
name|specID
parameter_list|)
block|{
name|char
name|context
index|[
name|LINESIZE
index|]
decl_stmt|,
name|buf
index|[
name|LINESIZE
index|]
decl_stmt|,
modifier|*
name|cp
decl_stmt|,
modifier|*
modifier|*
name|vec
decl_stmt|,
modifier|*
name|atval
decl_stmt|;
name|int
name|i
decl_stmt|,
name|a
decl_stmt|,
name|match
decl_stmt|;
name|Trans_t
modifier|*
name|t
decl_stmt|,
modifier|*
name|tt
decl_stmt|;
comment|/* loop through all transpecs */
for|for
control|(
name|t
operator|=
name|TrSpecs
init|;
name|t
condition|;
name|t
operator|=
name|t
operator|->
name|next
control|)
block|{
comment|/* Only one of gi or gilist will be set. */
comment|/* Check if elem name matches */
if|if
condition|(
name|t
operator|->
name|gi
operator|&&
operator|!
name|StrEq
argument_list|(
name|t
operator|->
name|gi
argument_list|,
name|e
operator|->
name|gi
argument_list|)
operator|&&
operator|!
name|specID
condition|)
continue|continue;
comment|/* test if we're looking for a specific specID and then if 	 * this is it.. */
if|if
condition|(
name|specID
condition|)
if|if
condition|(
operator|!
name|t
operator|->
name|my_id
operator|||
operator|(
name|specID
operator|!=
name|t
operator|->
name|my_id
operator|)
condition|)
continue|continue;
comment|/* Match one in the list of GIs? */
if|if
condition|(
name|t
operator|->
name|gilist
condition|)
block|{
for|for
control|(
name|match
operator|=
literal|0
operator|,
name|vec
operator|=
name|t
operator|->
name|gilist
init|;
operator|*
name|vec
condition|;
name|vec
operator|++
control|)
block|{
if|if
condition|(
name|StrEq
argument_list|(
operator|*
name|vec
argument_list|,
name|e
operator|->
name|gi
argument_list|)
condition|)
block|{
name|match
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|match
condition|)
continue|continue;
block|}
comment|/* Check context */
comment|/* Special case of context */
if|if
condition|(
name|t
operator|->
name|parent
condition|)
if|if
condition|(
operator|!
name|QRelation
argument_list|(
name|e
argument_list|,
name|t
operator|->
name|parent
argument_list|,
name|REL_Parent
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|t
operator|->
name|context
condition|)
block|{
comment|/* no context specified -> a match */
name|FindContext
argument_list|(
name|e
argument_list|,
name|t
operator|->
name|depth
argument_list|,
name|context
argument_list|)
expr_stmt|;
comment|/* If reg expr set, do regex compare; else just string compare. */
if|if
condition|(
name|t
operator|->
name|context_re
condition|)
block|{
if|if
condition|(
operator|!
name|regexec
argument_list|(
name|t
operator|->
name|context_re
argument_list|,
name|context
argument_list|)
condition|)
continue|continue;
block|}
else|else
block|{
comment|/* Is depth of spec deeper than element's depth? */
if|if
condition|(
name|t
operator|->
name|depth
operator|>
name|e
operator|->
name|depth
condition|)
continue|continue;
comment|/* See if context of element matches "context" of transpec */
name|match
operator|=
operator|(
operator|(
name|t
operator|->
name|context
index|[
literal|0
index|]
operator|==
name|context
index|[
literal|0
index|]
operator|)
operator|&&
operator|!
name|strcmp
argument_list|(
name|t
operator|->
name|context
argument_list|,
name|context
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|match
condition|)
continue|continue;
block|}
block|}
comment|/* Check attributes.  Loop through list, comparing each. */
if|if
condition|(
name|t
operator|->
name|nattpairs
condition|)
block|{
comment|/* no att specified -> a match */
for|for
control|(
name|match
operator|=
literal|1
operator|,
name|a
operator|=
literal|0
init|;
name|a
operator|<
name|t
operator|->
name|nattpairs
condition|;
name|a
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|atval
operator|=
name|FindAttValByName
argument_list|(
name|e
argument_list|,
name|t
operator|->
name|attpair
index|[
name|a
index|]
operator|.
name|name
argument_list|)
operator|)
condition|)
block|{
name|match
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|regexec
argument_list|(
name|t
operator|->
name|attpair
index|[
name|a
index|]
operator|.
name|rex
argument_list|,
name|atval
argument_list|)
condition|)
name|match
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|match
condition|)
continue|continue;
block|}
comment|/* Check relationships:  child, parent, ancestor, sib, ...  */
if|if
condition|(
name|t
operator|->
name|relations
condition|)
block|{
name|Mapping_t
modifier|*
name|r
decl_stmt|;
name|match
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|r
operator|=
name|t
operator|->
name|relations
operator|->
name|maps
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|t
operator|->
name|relations
operator|->
name|n_used
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|CheckRelation
argument_list|(
name|e
argument_list|,
name|r
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|r
index|[
name|i
index|]
operator|.
name|sval
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|RA_Current
argument_list|)
condition|)
block|{
name|match
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|match
condition|)
continue|continue;
block|}
comment|/* check this element's parent's attribute */
if|if
condition|(
name|t
operator|->
name|pattrset
operator|&&
name|e
operator|->
name|parent
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
modifier|*
name|tok
decl_stmt|;
name|i
operator|=
literal|2
expr_stmt|;
name|match
operator|=
literal|1
expr_stmt|;
name|tok
operator|=
name|Split
argument_list|(
name|t
operator|->
name|pattrset
argument_list|,
operator|&
name|i
argument_list|,
name|S_STRDUP
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|2
condition|)
block|{
name|p
operator|=
name|FindAttValByName
argument_list|(
name|e
operator|->
name|parent
argument_list|,
name|tok
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ExpandVariables
argument_list|(
name|tok
index|[
literal|1
index|]
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
operator|||
name|strcmp
argument_list|(
name|p
argument_list|,
name|buf
argument_list|)
condition|)
name|match
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|FindAttValByName
argument_list|(
name|e
operator|->
name|parent
argument_list|,
name|t
operator|->
name|pattrset
argument_list|)
condition|)
name|match
operator|=
literal|0
expr_stmt|;
block|}
name|free
argument_list|(
name|tok
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|match
condition|)
continue|continue;
block|}
comment|/* check this element's "birth order" */
if|if
condition|(
name|t
operator|->
name|nth_child
condition|)
block|{
comment|/* First one is called "1" by the user.  Internally called "0". */
name|i
operator|=
name|t
operator|->
name|nth_child
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
comment|/* positive # -- count from beginning */
if|if
condition|(
name|e
operator|->
name|my_eorder
operator|!=
operator|(
name|i
operator|-
literal|1
operator|)
condition|)
continue|continue;
block|}
else|else
block|{
comment|/* negative # -- count from end */
name|i
operator|=
name|e
operator|->
name|parent
operator|->
name|necont
operator|-
name|i
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|my_eorder
operator|!=
name|i
condition|)
continue|continue;
block|}
block|}
comment|/* check that variables match */
if|if
condition|(
name|t
operator|->
name|var_name
condition|)
block|{
name|cp
operator|=
name|FindMappingVal
argument_list|(
name|Variables
argument_list|,
name|t
operator|->
name|var_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cp
operator|||
name|strcmp
argument_list|(
name|cp
argument_list|,
name|t
operator|->
name|var_value
argument_list|)
condition|)
continue|continue;
block|}
comment|/* check for variable regular expression match */
if|if
condition|(
name|t
operator|->
name|var_RE_name
condition|)
block|{
name|cp
operator|=
name|FindMappingVal
argument_list|(
name|Variables
argument_list|,
name|t
operator|->
name|var_RE_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cp
operator|||
operator|!
name|regexec
argument_list|(
name|t
operator|->
name|var_RE_value
argument_list|,
name|cp
argument_list|)
condition|)
continue|continue;
block|}
comment|/* check content */
if|if
condition|(
name|t
operator|->
name|content
condition|)
block|{
comment|/* no att specified -> a match */
for|for
control|(
name|match
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|e
operator|->
name|ndcont
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|regexec
argument_list|(
name|t
operator|->
name|content_re
argument_list|,
name|e
operator|->
name|dcont
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|match
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|match
condition|)
continue|continue;
block|}
comment|/* -------- at this point we've passed all criteria -------- */
comment|/* See if we should be using another transpec's actions. */
if|if
condition|(
name|t
operator|->
name|use_id
condition|)
block|{
if|if
condition|(
name|t
operator|->
name|use_id
operator|<
literal|0
condition|)
return|return
operator|&
name|NullTrans
return|;
comment|/* missing? */
comment|/* see if we have a pointer to that transpec */
if|if
condition|(
name|t
operator|->
name|use_trans
condition|)
return|return
name|t
operator|->
name|use_trans
return|;
for|for
control|(
name|tt
operator|=
name|TrSpecs
init|;
name|tt
condition|;
name|tt
operator|=
name|tt
operator|->
name|next
control|)
block|{
if|if
condition|(
name|t
operator|->
name|use_id
operator|==
name|tt
operator|->
name|my_id
condition|)
block|{
comment|/* remember pointer for next time */
name|t
operator|->
name|use_trans
operator|=
name|tt
expr_stmt|;
return|return
name|t
operator|->
name|use_trans
return|;
block|}
block|}
name|t
operator|->
name|use_id
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* flag it as missing */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Warning: transpec ID (%d) not found for %s.\n"
argument_list|,
name|t
operator|->
name|use_id
argument_list|,
name|e
operator|->
name|gi
argument_list|)
expr_stmt|;
return|return
operator|&
name|NullTrans
return|;
block|}
return|return
name|t
return|;
block|}
comment|/* At this point, we have not found a matching spec.  See if there      * is a wildcard, and if so, use it. (Wildcard GI is named "*".) */
if|if
condition|(
operator|(
name|t
operator|=
name|FindTransByName
argument_list|(
literal|"*"
argument_list|)
operator|)
condition|)
return|return
name|t
return|;
if|if
condition|(
name|warnings
operator|&&
operator|!
name|specID
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Warning: transpec not found for %s\n"
argument_list|,
name|e
operator|->
name|gi
argument_list|)
expr_stmt|;
comment|/* default spec - pass character data and descend node */
return|return
operator|&
name|NullTrans
return|;
block|}
end_function

begin_comment
comment|/* ______________________________________________________________________ */
end_comment

begin_comment
comment|/*  Find translation spec by (GI) name.  Returns the first one that matches.  *  Arguments:  *	Pointer to name of transpec (the "gi" field of the Trans structure).  *  Return:  *	Pointer to translation spec that matches name.  */
end_comment

begin_function
name|Trans_t
modifier|*
name|FindTransByName
parameter_list|(
name|char
modifier|*
name|s
parameter_list|)
block|{
name|Trans_t
modifier|*
name|t
decl_stmt|;
for|for
control|(
name|t
operator|=
name|TrSpecs
init|;
name|t
condition|;
name|t
operator|=
name|t
operator|->
name|next
control|)
block|{
comment|/* check if tag name matches (first check 1st char, for efficiency) */
if|if
condition|(
name|t
operator|->
name|gi
condition|)
block|{
if|if
condition|(
operator|*
operator|(
name|t
operator|->
name|gi
operator|)
operator|!=
operator|*
name|s
condition|)
continue|continue;
comment|/* check 1st character */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|t
operator|->
name|gi
argument_list|,
name|s
argument_list|)
condition|)
return|return
name|t
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  Find translation spec by its ID (SpecID).  *  Arguments:  *	Spec ID (an int).  *  Return:  *	Pointer to translation spec that matches name.  */
end_comment

begin_function
name|Trans_t
modifier|*
name|FindTranByID
parameter_list|(
name|int
name|n
parameter_list|)
block|{
name|Trans_t
modifier|*
name|t
decl_stmt|;
for|for
control|(
name|t
operator|=
name|TrSpecs
init|;
name|t
condition|;
name|t
operator|=
name|t
operator|->
name|next
control|)
if|if
condition|(
name|n
operator|==
name|t
operator|->
name|my_id
condition|)
return|return
name|t
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* ______________________________________________________________________ */
end_comment

begin_comment
comment|/*  Process a "chunk" of content data of an element.  *  Arguments:  *	Pointer to data content to process  *	FILE pointer to where to write output.  */
end_comment

begin_function
name|void
name|DoData
parameter_list|(
name|char
modifier|*
name|data
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
name|int
name|verbatim
parameter_list|)
block|{
if|if
condition|(
operator|!
name|fp
condition|)
return|return;
name|OutputString
argument_list|(
name|data
argument_list|,
name|fp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ______________________________________________________________________ */
end_comment

begin_comment
comment|/*  Handle a processing instruction.  This is done similarly to elements,  *  where we find a transpec, then do what it says.  Differences: PI names  *  start with '_' in the spec file (if a GI does not start with '_', it  *  may be forced to upper case, sgmls keeps PIs as mixed case); the args  *  to the PI are treated as the data of an element.  Note that a PI wildcard  *  is "_*"  *  Arguments:  *	Pointer to the PI.  *	FILE pointer to where to write output.  */
end_comment

begin_function
name|void
name|DoPI
parameter_list|(
name|char
modifier|*
name|pi
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|char
name|buf
index|[
literal|250
index|]
decl_stmt|,
modifier|*
modifier|*
name|tok
decl_stmt|;
name|int
name|n
decl_stmt|;
name|Trans_t
modifier|*
name|t
decl_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
literal|'_'
expr_stmt|;
name|strcpy
argument_list|(
operator|&
name|buf
index|[
literal|1
index|]
argument_list|,
name|pi
argument_list|)
expr_stmt|;
name|n
operator|=
literal|2
expr_stmt|;
name|tok
operator|=
name|Split
argument_list|(
name|buf
argument_list|,
operator|&
name|n
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|t
operator|=
name|FindTransByName
argument_list|(
name|tok
index|[
literal|0
index|]
argument_list|)
operator|)
operator|||
operator|(
name|t
operator|=
name|FindTransByName
argument_list|(
literal|"_*"
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|t
operator|->
name|replace
condition|)
name|ProcesOutputSpec
argument_list|(
name|t
operator|->
name|replace
argument_list|,
literal|0
argument_list|,
name|fp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|t
operator|->
name|starttext
condition|)
name|ProcesOutputSpec
argument_list|(
name|t
operator|->
name|starttext
argument_list|,
literal|0
argument_list|,
name|fp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|ignore
operator|!=
name|IGN_DATA
condition|)
comment|/* skip data nodes? */
if|if
condition|(
name|n
operator|>
literal|1
condition|)
name|OutputString
argument_list|(
name|tok
index|[
literal|1
index|]
argument_list|,
name|fp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|endtext
condition|)
name|ProcesOutputSpec
argument_list|(
name|t
operator|->
name|endtext
argument_list|,
literal|0
argument_list|,
name|fp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|->
name|message
condition|)
name|ProcesOutputSpec
argument_list|(
name|t
operator|->
name|message
argument_list|,
literal|0
argument_list|,
name|stderr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* If not found, just print the PI in square brackets, along 	 * with a warning message. */
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"[%s]"
argument_list|,
name|pi
argument_list|)
expr_stmt|;
if|if
condition|(
name|warnings
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Warning: Unrecognized PI: [%s]\n"
argument_list|,
name|pi
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ______________________________________________________________________ */
end_comment

begin_comment
comment|/*  Set and increment variables, as appropriate, if the transpec says to.  *  Arguments:  *	Pointer to translation spec for current element.  */
end_comment

begin_function
specifier|static
name|void
name|set_and_increment
parameter_list|(
name|Trans_t
modifier|*
name|t
parameter_list|,
name|Element_t
modifier|*
name|e
parameter_list|)
block|{
name|Mapping_t
modifier|*
name|m
decl_stmt|;
name|int
name|i
decl_stmt|,
name|inc
decl_stmt|,
name|n
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
name|buf
index|[
literal|50
index|]
decl_stmt|;
name|char
name|ebuf
index|[
literal|500
index|]
decl_stmt|;
comment|/* set/reset variables */
if|if
condition|(
name|t
operator|->
name|set_var
condition|)
block|{
for|for
control|(
name|m
operator|=
name|t
operator|->
name|set_var
operator|->
name|maps
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|t
operator|->
name|set_var
operator|->
name|n_used
condition|;
name|i
operator|++
control|)
block|{
name|ExpandVariables
argument_list|(
name|m
index|[
name|i
index|]
operator|.
name|sval
argument_list|,
name|ebuf
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|/* do some expansion */
name|SetMappingNV
argument_list|(
name|Variables
argument_list|,
name|m
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|ebuf
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* increment counters */
if|if
condition|(
name|t
operator|->
name|incr_var
condition|)
block|{
for|for
control|(
name|m
operator|=
name|t
operator|->
name|incr_var
operator|->
name|maps
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|t
operator|->
name|incr_var
operator|->
name|n_used
condition|;
name|i
operator|++
control|)
block|{
name|cp
operator|=
name|FindMappingVal
argument_list|(
name|Variables
argument_list|,
name|m
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
comment|/* if not set at all, set to 1 */
if|if
condition|(
operator|!
name|cp
condition|)
name|SetMappingNV
argument_list|(
name|Variables
argument_list|,
name|m
index|[
name|i
index|]
operator|.
name|name
argument_list|,
literal|"1"
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|cp
argument_list|)
operator|||
operator|(
operator|*
name|cp
operator|==
literal|'-'
operator|&&
name|isdigit
argument_list|(
name|cp
index|[
literal|1
index|]
argument_list|)
operator|)
condition|)
block|{
name|n
operator|=
name|atoi
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
index|[
name|i
index|]
operator|.
name|sval
operator|&&
name|isdigit
argument_list|(
operator|*
name|m
index|[
name|i
index|]
operator|.
name|sval
argument_list|)
condition|)
name|inc
operator|=
name|atoi
argument_list|(
name|m
index|[
name|i
index|]
operator|.
name|sval
argument_list|)
expr_stmt|;
else|else
name|inc
operator|=
literal|1
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d"
argument_list|,
operator|(
name|n
operator|+
name|inc
operator|)
argument_list|)
expr_stmt|;
name|SetMappingNV
argument_list|(
name|Variables
argument_list|,
name|m
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|*
operator|(
name|cp
operator|+
literal|1
operator|)
operator|&&
name|isalpha
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
block|{
name|buf
index|[
literal|0
index|]
operator|=
operator|*
name|cp
operator|+
literal|1
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|SetMappingNV
argument_list|(
name|Variables
argument_list|,
name|m
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* ______________________________________________________________________ */
end_comment

begin_comment
comment|/*  Translate one element.  *  Arguments:  *	Pointer to element under consideration.  *	FILE pointer to where to write output.  *	Pointer to translation spec for current element, or null.  */
end_comment

begin_function
name|void
name|TransElement
parameter_list|(
name|Element_t
modifier|*
name|e
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
name|Trans_t
modifier|*
name|t
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|t
condition|)
name|t
operator|=
operator|(
operator|(
name|e
operator|&&
name|e
operator|->
name|trans
operator|)
condition|?
name|e
operator|->
name|trans
else|:
operator|&
name|NullTrans
operator|)
expr_stmt|;
comment|/* see if we should quit. */
if|if
condition|(
name|t
operator|->
name|quit
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Quitting at location:\n"
argument_list|)
expr_stmt|;
name|PrintLocation
argument_list|(
name|e
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|t
operator|->
name|quit
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* See if we want to replace subtree (do text, don't descend subtree) */
if|if
condition|(
name|t
operator|->
name|replace
condition|)
block|{
name|ProcesOutputSpec
argument_list|(
name|t
operator|->
name|replace
argument_list|,
name|e
argument_list|,
name|fp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|message
condition|)
name|ProcesOutputSpec
argument_list|(
name|t
operator|->
name|message
argument_list|,
name|e
argument_list|,
name|stderr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_and_increment
argument_list|(
name|t
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|/* adjust variables, if appropriate */
return|return;
block|}
if|if
condition|(
name|t
operator|->
name|starttext
condition|)
name|ProcesOutputSpec
argument_list|(
name|t
operator|->
name|starttext
argument_list|,
name|e
argument_list|,
name|fp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|message
condition|)
name|ProcesOutputSpec
argument_list|(
name|t
operator|->
name|message
argument_list|,
name|e
argument_list|,
name|stderr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Process data for this node and descend child elements/nodes. */
if|if
condition|(
name|t
operator|->
name|ignore
operator|!=
name|IGN_ALL
condition|)
block|{
comment|/* Is there a "generated" node at the front of this one? */
if|if
condition|(
name|e
operator|->
name|gen_trans
index|[
literal|0
index|]
condition|)
block|{
name|Trans_t
modifier|*
name|tp
decl_stmt|;
if|if
condition|(
operator|(
name|tp
operator|=
name|FindTranByID
argument_list|(
name|e
operator|->
name|gen_trans
index|[
literal|0
index|]
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|tp
operator|->
name|starttext
condition|)
name|ProcesOutputSpec
argument_list|(
name|tp
operator|->
name|starttext
argument_list|,
name|e
argument_list|,
name|fp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|message
condition|)
name|ProcesOutputSpec
argument_list|(
name|tp
operator|->
name|message
argument_list|,
name|e
argument_list|,
name|stderr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|endtext
condition|)
name|ProcesOutputSpec
argument_list|(
name|tp
operator|->
name|endtext
argument_list|,
name|e
argument_list|,
name|fp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Loop thruthe "nodes", whether data, child element, or PI. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|e
operator|->
name|ncont
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|IsContElem
argument_list|(
name|e
argument_list|,
name|i
argument_list|)
condition|)
block|{
if|if
condition|(
name|t
operator|->
name|ignore
operator|!=
name|IGN_CHILDREN
condition|)
comment|/* skip child nodes? */
name|TransElement
argument_list|(
name|ContElem
argument_list|(
name|e
argument_list|,
name|i
argument_list|)
argument_list|,
name|fp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IsContData
argument_list|(
name|e
argument_list|,
name|i
argument_list|)
condition|)
block|{
if|if
condition|(
name|t
operator|->
name|ignore
operator|!=
name|IGN_DATA
condition|)
comment|/* skip data nodes? */
name|DoData
argument_list|(
name|ContData
argument_list|(
name|e
argument_list|,
name|i
argument_list|)
argument_list|,
name|fp
argument_list|,
name|t
operator|->
name|verbatim
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IsContPI
argument_list|(
name|e
argument_list|,
name|i
argument_list|)
condition|)
name|DoPI
argument_list|(
name|e
operator|->
name|cont
index|[
name|i
index|]
operator|.
name|ch
operator|.
name|data
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
comment|/* Is there a "generated" node at the end of this one? */
if|if
condition|(
name|e
operator|->
name|gen_trans
index|[
literal|1
index|]
condition|)
block|{
name|Trans_t
modifier|*
name|tp
decl_stmt|;
if|if
condition|(
operator|(
name|tp
operator|=
name|FindTranByID
argument_list|(
name|e
operator|->
name|gen_trans
index|[
literal|1
index|]
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|tp
operator|->
name|starttext
condition|)
name|ProcesOutputSpec
argument_list|(
name|tp
operator|->
name|starttext
argument_list|,
name|e
argument_list|,
name|fp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|message
condition|)
name|ProcesOutputSpec
argument_list|(
name|tp
operator|->
name|message
argument_list|,
name|e
argument_list|,
name|stderr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|endtext
condition|)
name|ProcesOutputSpec
argument_list|(
name|tp
operator|->
name|endtext
argument_list|,
name|e
argument_list|,
name|fp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|set_and_increment
argument_list|(
name|t
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|/* adjust variables, if appropriate */
if|if
condition|(
name|t
operator|->
name|endtext
condition|)
name|ProcesOutputSpec
argument_list|(
name|t
operator|->
name|endtext
argument_list|,
name|e
argument_list|,
name|fp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|e
operator|->
name|processed
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ______________________________________________________________________ */
end_comment

begin_comment
comment|/* Check if element matches specified relationship, and, if it does, perform  * action on either current element or matching element (depends on flag).  *  Arguments:  *	Pointer to element under consideration.  *	Pointer to relationship name.  *	Pointer to related element name (GI).  *	Pointer to action to take (string - turned into an int).  *	FILE pointer to where to write output.  *	Flag saying whether to do action on related element (RA_Related)  *		or on current element (RA_Current).  *  Return:  *	Bool, saying whether (1) or not (0) relationship matches.  */
end_comment

begin_function
name|int
name|CheckRelation
parameter_list|(
name|Element_t
modifier|*
name|e
parameter_list|,
name|char
modifier|*
name|relname
parameter_list|,
comment|/* relationship name */
name|char
modifier|*
name|related
parameter_list|,
comment|/* related element */
name|char
modifier|*
name|actname
parameter_list|,
comment|/* action to take */
name|FILE
modifier|*
name|fp
parameter_list|,
name|RelAction_t
name|flag
parameter_list|)
block|{
name|Element_t
modifier|*
name|ep
decl_stmt|;
name|Relation_t
name|r
decl_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|FindRelByName
argument_list|(
name|relname
argument_list|)
operator|)
operator|==
name|REL_Unknown
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
operator|(
name|ep
operator|=
name|QRelation
argument_list|(
name|e
argument_list|,
name|related
argument_list|,
name|r
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|actname
condition|)
return|return
literal|1
return|;
comment|/* no action - return what we found */
switch|switch
condition|(
name|flag
condition|)
block|{
case|case
name|RA_Related
case|:
name|TranTByAction
argument_list|(
name|ep
argument_list|,
name|actname
argument_list|,
name|fp
argument_list|)
expr_stmt|;
break|break;
case|case
name|RA_Current
case|:
name|TranTByAction
argument_list|(
name|e
argument_list|,
name|actname
argument_list|,
name|fp
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* ______________________________________________________________________ */
end_comment

begin_comment
comment|/* Perform action given by a SpecID on the given element.  *  Arguments:  *	Pointer to element under consideration.  *	SpecID of action to perform.  *	FILE pointer to where to write output.  *  */
end_comment

begin_function
name|void
name|TranByAction
parameter_list|(
name|Element_t
modifier|*
name|e
parameter_list|,
name|int
name|n
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|Trans_t
modifier|*
name|t
decl_stmt|;
name|t
operator|=
name|FindTranByID
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|t
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Could not find named action for %d.\n"
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return;
block|}
name|TransElement
argument_list|(
name|e
argument_list|,
name|fp
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ______________________________________________________________________ */
end_comment

begin_comment
comment|/* Perhaps perform action given by a SpecID on the given element.  *  Arguments:  *	Pointer to element under consideration.  *	SpecID of action to perform.  Unlike TranByAction, this is the argument  *	  as it occurred in the transpec (ASCII) and may end with the letter  *	  "t" which means that the transpec mustpass criteria selection.  *	FILE pointer to where to write output.  */
end_comment

begin_function
name|void
name|TranTByAction
parameter_list|(
name|Element_t
modifier|*
name|e
parameter_list|,
name|char
modifier|*
name|strn
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
name|Trans_t
modifier|*
name|t
decl_stmt|;
name|n
operator|=
name|atoi
argument_list|(
name|strn
argument_list|)
expr_stmt|;
if|if
condition|(
name|strn
index|[
name|strlen
argument_list|(
name|strn
argument_list|)
operator|-
literal|1
index|]
operator|!=
literal|'t'
condition|)
block|{
name|t
operator|=
name|FindTranByID
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|t
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Could not find named action for %d.\n"
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
name|t
operator|=
name|FindTrans
argument_list|(
name|e
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|t
operator|||
operator|!
name|t
operator|->
name|my_id
condition|)
return|return;
block|}
name|TransElement
argument_list|(
name|e
argument_list|,
name|fp
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ______________________________________________________________________ */
end_comment

end_unit

