begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  Copyright 1993 Open Software Foundation, Inc., Cambridge, Massachusetts.  *  All rights reserved.  */
end_comment

begin_comment
comment|/*  * Copyright (c) 1994    * Open Software Foundation, Inc.   *    * Permission is hereby granted to use, copy, modify and freely distribute   * the software in this file and its documentation for any purpose without   * fee, provided that the above copyright notice appears in all copies and   * that both the copyright notice and this permission notice appear in   * supporting documentation.  Further, provided that the name of Open   * Software Foundation, Inc. ("OSF") not be used in advertising or   * publicity pertaining to distribution of the software without prior   * written permission from OSF.  OSF makes no representations about the   * suitability of this software for any purpose.  It is provided "as is"   * without express or implied warranty.   */
end_comment

begin_comment
comment|/*  * Copyright (c) 1996 X Consortium  * Copyright (c) 1995, 1996 Dalrymple Consulting  *   * Permission is hereby granted, free of charge, to any person obtaining a copy  * of this software and associated documentation files (the "Software"), to deal  * in the Software without restriction, including without limitation the rights  * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell  * copies of the Software, and to permit persons to whom the Software is  * furnished to do so, subject to the following conditions:  *   * The above copyright notice and this permission notice shall be included in  * all copies or substantial portions of the Software.  *   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE  * X CONSORTIUM OR DALRYMPLE CONSULTING BE LIABLE FOR ANY CLAIM, DAMAGES OR  * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,  * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR  * OTHER DEALINGS IN THE SOFTWARE.  *   * Except as contained in this notice, the names of the X Consortium and  * Dalrymple Consulting shall not be used in advertising or otherwise to  * promote the sale, use or other dealings in this Software without prior  * written authorization.  */
end_comment

begin_comment
comment|/* ________________________________________________________________________  *  *  Program to manipulate SGML instances.  *  * Originally coded for OSF DTD tables, now recoded (fld 3/27/95)  * for CALS-type tables (fragment taken from the DocBook DTD).  Then,  * *really* upgraded to CALS tables by FLD on 5/28/96.  *  *  This module is for handling table markup, printing TeX or tbl  *  (tbl) markup to the output stream.  Also, table markup checking is  *  done here.  Yes, this depends on the DTD, but it makes translation  *  specs much cleaner (and makes some things possible).  *  *  Incomplete / not implemented / limitations / notes:  *	vertical alignment (valign attr)  *	vertical spanning  *	row separators are for the whole line, not per cell (the prog looks  *		at rowsep for the 1st cell and applies it to the whole row)  *	trusts that units in colwidths are acceptable to LaTeX and tbl  *	"s" is an acceptable shorthand for "span" in model attributes  *  *  A note on use of OutputString():  Strings with backslashes (\) need lots  *  of backslashes.  You have to escape them for the C compiler, and escape  *  them again for OutputString() itself.  * ________________________________________________________________________  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|RCSid
init|=
literal|"$Header: /usr/src/docbook-to-man/Instant/RCS/tables.c,v 1.11 1996/06/15 03:45:02 fld Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<memory.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<regexp.h>
end_include

begin_include
include|#
directive|include
file|"general.h"
end_include

begin_include
include|#
directive|include
file|"translate.h"
end_include

begin_comment
comment|/* text width of page, in inches */
end_comment

begin_define
define|#
directive|define
name|TEXTWIDTH
value|5.5
end_define

begin_define
define|#
directive|define
name|MAXCOLS
value|100
end_define

begin_define
define|#
directive|define
name|SPAN_NOT
value|0
end_define

begin_define
define|#
directive|define
name|SPAN_START
value|1
end_define

begin_define
define|#
directive|define
name|SPAN_CONT
value|2
end_define

begin_comment
comment|/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
end_comment

begin_comment
comment|/*table parameters */
end_comment

begin_define
define|#
directive|define
name|TBLMAXCOL
value|30
end_define

begin_comment
comment|/* max number of columns in tbl table */
end_comment

begin_define
define|#
directive|define
name|NAMELEN
value|40
end_define

begin_comment
comment|/* max length of a name */
end_comment

begin_define
define|#
directive|define
name|BOFTTHRESHOLD
value|35
end_define

begin_comment
comment|/* text length over which to consider 				 * generating a block of filled text */
end_comment

begin_comment
comment|/* handy declarations */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|Left
block|,
name|Right
block|,
name|Center
block|,
name|Justify
block|,
name|Char
block|,
name|Span
block|}
name|tblalign
typedef|;
end_typedef

begin_typedef
typedef|typedef
enum|enum
block|{
name|TGroup
block|,
name|THead
block|,
name|TFoot
block|,
name|TBody
block|}
name|tblsource
typedef|;
end_typedef

begin_comment
comment|/* source of a spec */
end_comment

begin_comment
comment|/* table line format information structures */
end_comment

begin_struct
struct|struct
name|tblcolspec
block|{
name|char
name|name
index|[
name|NAMELEN
index|]
decl_stmt|;
comment|/* colspec's name */
name|short
name|num
decl_stmt|;
comment|/* column number */
name|tblsource
name|source
decl_stmt|;
comment|/* where defined */
name|tblalign
name|align
decl_stmt|;
comment|/* column's alignment */
name|char
name|alignchar
decl_stmt|;
comment|/* character for alignment */
name|short
name|aligncharoff
decl_stmt|;
comment|/* offset for alignment */
name|char
name|colwidth
index|[
literal|10
index|]
decl_stmt|;
comment|/* width for column */
name|char
name|colpwidth
index|[
literal|10
index|]
decl_stmt|;
comment|/* proportional widths for column */
name|bool
name|colsep
decl_stmt|;
comment|/* separator to right of column? */
name|bool
name|rowsep
decl_stmt|;
comment|/* separator to bottom of column? */
name|short
name|moreRows
decl_stmt|;
comment|/* value for Morerows */
name|struct
name|tblcolspec
modifier|*
name|next
decl_stmt|;
comment|/* next colspec */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|tblspanspec
block|{
name|char
name|name
index|[
name|NAMELEN
index|]
decl_stmt|;
comment|/* spanspec's name */
name|tblsource
name|source
decl_stmt|;
comment|/* where defined */
name|struct
name|tblcolspec
modifier|*
name|start
decl_stmt|;
comment|/* start column */
name|struct
name|tblcolspec
modifier|*
name|end
decl_stmt|;
comment|/* end column */
name|tblalign
name|align
decl_stmt|;
comment|/* span's alignment */
name|char
name|alignchar
decl_stmt|;
comment|/* character for alignment */
name|short
name|aligncharoff
decl_stmt|;
comment|/* offset for alignment */
name|bool
name|colsep
decl_stmt|;
comment|/* separator to right of column? */
name|bool
name|rowsep
decl_stmt|;
comment|/* separator to bottom of column? */
name|struct
name|tblspanspec
modifier|*
name|next
decl_stmt|;
comment|/* next spanspec */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|tblformat
block|{
name|short
name|count
decl_stmt|;
comment|/* count of rows matching this spec */
name|short
name|cols
decl_stmt|;
comment|/* # of columns */
name|short
name|rowNum
decl_stmt|;
comment|/* row number */
name|char
name|colformat
index|[
name|TBLMAXCOL
index|]
decl_stmt|;
comment|/* per-column formats */
name|char
name|colwidth
index|[
name|TBLMAXCOL
index|]
index|[
literal|10
index|]
decl_stmt|;
comment|/* per-column widths */
name|char
name|colpwidth
index|[
name|TBLMAXCOL
index|]
index|[
literal|10
index|]
decl_stmt|;
comment|/* per-column proportional widths */
name|char
name|font
index|[
name|TBLMAXCOL
index|]
index|[
literal|3
index|]
decl_stmt|;
comment|/* column fonts (headers) */
name|bool
name|colsep
index|[
name|TBLMAXCOL
index|]
decl_stmt|;
comment|/* column separators */
name|bool
name|rowsep
index|[
name|TBLMAXCOL
index|]
decl_stmt|;
comment|/* row separators */
name|short
name|moreRows
index|[
name|TBLMAXCOL
index|]
decl_stmt|;
comment|/* moreRows indicator */
name|struct
name|tblformat
modifier|*
name|next
decl_stmt|;
comment|/* for the next row */
block|}
struct|;
end_struct

begin_comment
comment|/* table state info */
end_comment

begin_decl_stmt
specifier|static
name|short
name|tblcols
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of columns in the table */
end_comment

begin_decl_stmt
specifier|static
name|short
name|tblrow
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the current row in the table */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|tblTGroupSeen
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* seen a TGroup in this table yet? */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|tblFrame
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* table frame info */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|tblgcolsep
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* global colsep (in table) */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|tblgrowsep
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* global rowsep (in table) */
end_comment

begin_decl_stmt
specifier|static
name|int
name|tblBOFTCount
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* count of bofts that we've created 					 * (per table) */
end_comment

begin_decl_stmt
name|int
name|BOFTTextThresh
init|=
name|BOFTTHRESHOLD
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* length of text before we 					 * call it a BOFT */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|tblboft
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* within a block of filled text? */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|tblinBOFT
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* within a boft now? */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|tblformat
modifier|*
name|formP
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* THead/TBody format lines */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|tblcolspec
modifier|*
name|tblColSpec
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* colspec structure for table */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|tblspanspec
modifier|*
name|tblSpanSpec
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* spanspec structure for table */
end_comment

begin_comment
comment|/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
end_comment

begin_comment
comment|/* these cover the attributes on the Table, TGroup, Colspec elements */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|char
modifier|*
name|cols
decl_stmt|;
name|char
modifier|*
name|align
decl_stmt|,
modifier|*
modifier|*
name|align_v
decl_stmt|;
name|char
modifier|*
name|colwidth
decl_stmt|,
modifier|*
modifier|*
name|colwidth_v
decl_stmt|;
name|char
modifier|*
name|colsep
decl_stmt|,
modifier|*
modifier|*
name|colsep_v
decl_stmt|;
name|char
modifier|*
name|rowsep
decl_stmt|,
modifier|*
modifier|*
name|rowsep_v
decl_stmt|;
name|char
modifier|*
name|frame
decl_stmt|;
name|char
modifier|*
name|orient
decl_stmt|;
name|int
name|pgwide
decl_stmt|;
name|int
name|n_align
decl_stmt|,
name|n_model
decl_stmt|,
name|n_colwidth
decl_stmt|,
name|n_colsep
decl_stmt|;
name|int
name|nc
decl_stmt|;
block|}
name|TableInfo
typedef|;
end_typedef

begin_comment
comment|/* some flags, set when the table tag is processed, used later */
end_comment

begin_decl_stmt
specifier|static
name|int
name|rowsep
decl_stmt|,
name|siderules
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|frametop
decl_stmt|,
name|framebot
decl_stmt|,
name|frameall
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|basemodel
index|[
literal|128
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* model for table (in formatting language) */
end_comment

begin_decl_stmt
specifier|static
name|int
name|spaninfo
index|[
name|MAXCOLS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 100 columns, max */
end_comment

begin_decl_stmt
specifier|static
name|TableInfo
name|TheTab
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* forward references */
end_comment

begin_function_decl
name|void
name|SetTabAtts
parameter_list|(
name|Element_t
modifier|*
parameter_list|,
name|TableInfo
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|FreeTabAtts
parameter_list|(
name|TableInfo
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|ClearTable
parameter_list|(
name|TableInfo
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|CheckTable
parameter_list|(
name|Element_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|TblTStart
parameter_list|(
name|Element_t
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|TblTEnd
parameter_list|(
name|Element_t
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|TblTGroup
parameter_list|(
name|Element_t
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|TblTGroupEnd
parameter_list|(
name|Element_t
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|TblTFoot
parameter_list|(
name|Element_t
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|TblBuildFormat
parameter_list|(
name|Element_t
modifier|*
parameter_list|,
name|struct
name|tblformat
modifier|*
modifier|*
parameter_list|,
name|tblsource
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|tblformat
modifier|*
name|TblBuild1Format
parameter_list|(
name|Element_t
modifier|*
parameter_list|,
name|bool
parameter_list|,
name|tblsource
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|char
name|TblGetAlign
parameter_list|(
name|short
parameter_list|,
name|Element_t
modifier|*
parameter_list|,
name|tblsource
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|TblGetWidth
parameter_list|(
name|short
parameter_list|,
name|Element_t
modifier|*
parameter_list|,
name|bool
parameter_list|,
name|tblsource
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|TblGetFont
parameter_list|(
name|short
parameter_list|,
name|Element_t
modifier|*
parameter_list|,
name|tblsource
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|bool
name|TblGetColSep
parameter_list|(
name|short
parameter_list|,
name|Element_t
modifier|*
parameter_list|,
name|tblsource
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|bool
name|TblGetRowSep
parameter_list|(
name|short
parameter_list|,
name|Element_t
modifier|*
parameter_list|,
name|tblsource
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|short
name|TblGetMoreRows
parameter_list|(
name|short
parameter_list|,
name|Element_t
modifier|*
parameter_list|,
name|tblsource
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|bool
name|TblColAdv
parameter_list|(
name|short
parameter_list|,
name|Element_t
modifier|*
parameter_list|,
name|struct
name|tblformat
modifier|*
parameter_list|,
name|tblsource
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|tblcolspec
modifier|*
name|TblEntryColSpec
parameter_list|(
name|short
parameter_list|,
name|Element_t
modifier|*
parameter_list|,
name|tblsource
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|tblspanspec
modifier|*
name|TblEntrySpanSpec
parameter_list|(
name|short
parameter_list|,
name|Element_t
modifier|*
parameter_list|,
name|tblsource
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|bool
name|TblFormatMatch
parameter_list|(
name|struct
name|tblformat
modifier|*
parameter_list|,
name|struct
name|tblformat
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|TblPrintFormat
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|struct
name|tblformat
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|TblTRowStart
parameter_list|(
name|Element_t
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|TblTRowEnd
parameter_list|(
name|Element_t
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|TblTCellStart
parameter_list|(
name|Element_t
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|TblCountContent
parameter_list|(
name|Element_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|TblTCellEnd
parameter_list|(
name|Element_t
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|tblcolspec
modifier|*
name|TblDoColSpec
parameter_list|(
name|short
parameter_list|,
name|Element_t
modifier|*
parameter_list|,
name|struct
name|tblcolspec
modifier|*
parameter_list|,
name|tblsource
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|tblspanspec
modifier|*
name|TblDoSpanSpec
parameter_list|(
name|Element_t
modifier|*
parameter_list|,
name|struct
name|tblspanspec
modifier|*
parameter_list|,
name|tblsource
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|tblcolspec
modifier|*
name|TblFindColSpec
parameter_list|(
name|char
modifier|*
parameter_list|,
name|tblsource
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|tblcolspec
modifier|*
name|TblFindColNum
parameter_list|(
name|short
parameter_list|,
name|tblsource
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|tblspanspec
modifier|*
name|TblFindSpanSpec
parameter_list|(
name|char
modifier|*
parameter_list|,
name|tblsource
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|TexTable
parameter_list|(
name|Element_t
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|TexTableCellStart
parameter_list|(
name|Element_t
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|TexTableCellEnd
parameter_list|(
name|Element_t
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|TexTableRowStart
parameter_list|(
name|Element_t
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|TexTableRowEnd
parameter_list|(
name|Element_t
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|TexTableTop
parameter_list|(
name|Element_t
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|TexTableBottom
parameter_list|(
name|Element_t
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* ______________________________________________________________________ */
end_comment

begin_comment
comment|/*  Hard-coded stuff for CALS-style DTD tables.  *  Here are the TABLE attributes (for handy reference):  *  *  Table/InformalTable:  *	Colsep	   NUMBER	separate all columns in table?  *	Frame	   (Top|Bottom|Topbot|All|Sides|None)	frame style  *	Orient	   (Port | Land)	orientation  *	Pgwide	   NUMBER	wide table?  *	Rowsep	   NUMBER	separate all rows in the table?  *	Tabstyle   NMTOKEN	FOSI table style  *  *  TGroup:  *	Align	   (Left|Right|Center|Justify|Char)	alignment of cols  *	Char	   CDATA	Alignment specifier  *	Charoff	   NUTOKEN	    ""       ""  *	Cols	   NUMBER	number of columns  *	Colsep	   NUMBER	separate all columns in tgroup?  *	Rowsep	   NUMBER	separate all rows in tgroup?  *	TGroupstyle NMTOKEN	FOSI table group style  *  *  Colspec:  *	Align      (Left|Right|Center|Justify|Char)	entry align  *	Char       CDATA	Alignment specifier  *	Charoff    NUTOKEN	    ""       ""  *	Colname    NMTOKEN	Column identifier  *	Colnum	   NUMBER	number of column  *	Colsep     NUMBER	separate this col from next?  *	Colwidth   CDATA	width spec  *	Rowsep     NUMBER	serarate entry from following row?  *  *  SpanSpec:  *	Align      (Left|Right|Center|Justify|Char)	entry align  *	Char       CDATA	Alignment specifier  *	Charoff    NUTOKEN	    ""       ""  *	Colsep     NUMBER	separate this col from next?  *	Nameend    NMTOKEN	name of rightmost col of a span  *	Namest     NMTOKEN	name of leftmost col of a span  *	Rowsep     NUMBER	serarate entry from following row?  *	Spanname   NMTOKEN	name of a horiz. span  *  *  THead/TFoot/TBody:  *	VAlign	   (Top | Middle | Bottom)	group placement  *  *  Row:  *	Rowsep	   NUMBER	separate this row from next?  *	VAlign	   (Top | Middle | Bottom)	row placement  *  *  Entry:  *	Align      (Left|Right|Center|Justify|Char)	entry align  *	Char       CDATA	Alignment specifier  *	Charoff    NUTOKEN	    ""       ""  *	Colname    NMTOKEN	Column identifier  *	Colsep     NUMBER	separate this col from next?  *	Morerows   NUMBER	number of addn'l rows in vert straddle  *	Nameend    NMTOKEN	name of rightmost col of a span  *	Namest     NMTOKEN	name of leftmost col of a span  *	Rotate     NUMBER	90 degree rotation counterclockwise to table?  *	Rowsep     NUMBER	serarate entry from following row?  *	Spanname   NMTOKEN	name of a horiz. span  *	VAlign     (Top | Middle | Bottom)	text vert alignment  *    *  ** OBSOLETE OSF DTD FORM (still used for TeX form):  **  Usage in transpec: _calstable [tex|check|clear] ['aspect']  **  where 'aspect' is:  **	rowstart	stuff to do at start of a row (tests for spanning)  **	rowend		stuff to do at end of a row (eg, rules, etc.)  **	cellstart	stuff to do at start of a cell (eg, handle actual  **			spanning instructions, etc.)  **	cellend		stuff to do at end of a cell  (eg, cell separator)  **	top		stuff to do at top of the table  **			(like whether or not it needs a starting horiz rule)  **	bottom		stuff to do at bottom of the table  **			(like whether or not it needs an ending horiz rule)  **	(nothing)	the 'cols' param to LaTeX's \begin{tabular}[pos]{cols}  **			or 'options' and 'formats' part in tbl  *  *  * New tbl form:  *  Usage in transpec: _calstable [tbl] ['aspect']  *  where 'aspect' is:  *	tablestart	start a table and do style info  *	tableend	end the table and clean up  *	tablegroup	table TGroup (.T& if not 1st, line format info)  *	tablegroupend	end a TGroup  *	tablefoot	TFoot within a TGroup  *	rowstart	start of a row  *	rowend		end of a row  *	entrystart	start of an entry (block of filled text, if  *				appropriate)  *	entryend	end of a cell  (eg, cell separator)  */
end_comment

begin_comment
comment|/*  Procedure to  *  Arguments:  *	Pointer to element under consideration.  *	FILE pointer to where to write output.  *	Vector of args to _osftable  *	Count of args to _osftable  */
end_comment

begin_function
name|void
name|CALStable
parameter_list|(
name|Element_t
modifier|*
name|e
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
name|char
modifier|*
modifier|*
name|av
parameter_list|,
name|int
name|ac
parameter_list|)
block|{
comment|/* Check params and dispatch to appropriate routine */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|av
index|[
literal|1
index|]
argument_list|,
literal|"tbl"
argument_list|)
condition|)
block|{
if|if
condition|(
name|ac
operator|>
literal|2
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|av
index|[
literal|2
index|]
argument_list|,
literal|"tablestart"
argument_list|)
condition|)
name|TblTStart
argument_list|(
name|e
argument_list|,
name|fp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|av
index|[
literal|2
index|]
argument_list|,
literal|"tableend"
argument_list|)
condition|)
name|TblTEnd
argument_list|(
name|e
argument_list|,
name|fp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|av
index|[
literal|2
index|]
argument_list|,
literal|"tablegroup"
argument_list|)
condition|)
name|TblTGroup
argument_list|(
name|e
argument_list|,
name|fp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|av
index|[
literal|2
index|]
argument_list|,
literal|"tablegroupend"
argument_list|)
condition|)
name|TblTGroupEnd
argument_list|(
name|e
argument_list|,
name|fp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|av
index|[
literal|2
index|]
argument_list|,
literal|"tablefoot"
argument_list|)
condition|)
name|TblTFoot
argument_list|(
name|e
argument_list|,
name|fp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|av
index|[
literal|2
index|]
argument_list|,
literal|"rowstart"
argument_list|)
condition|)
name|TblTRowStart
argument_list|(
name|e
argument_list|,
name|fp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|av
index|[
literal|2
index|]
argument_list|,
literal|"rowend"
argument_list|)
condition|)
name|TblTRowEnd
argument_list|(
name|e
argument_list|,
name|fp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|av
index|[
literal|2
index|]
argument_list|,
literal|"entrystart"
argument_list|)
condition|)
name|TblTCellStart
argument_list|(
name|e
argument_list|,
name|fp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|av
index|[
literal|2
index|]
argument_list|,
literal|"entryend"
argument_list|)
condition|)
name|TblTCellEnd
argument_list|(
name|e
argument_list|,
name|fp
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unknown %s table instruction: %s\n"
argument_list|,
name|av
index|[
literal|1
index|]
argument_list|,
name|av
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Incomplete %s table instruction\n"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|av
index|[
literal|1
index|]
argument_list|,
literal|"tex"
argument_list|)
condition|)
block|{
if|if
condition|(
name|ac
operator|>
literal|1
operator|&&
operator|!
name|strcmp
argument_list|(
name|av
index|[
literal|1
index|]
argument_list|,
literal|"check"
argument_list|)
condition|)
name|CheckTable
argument_list|(
name|e
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ac
operator|>
literal|1
operator|&&
operator|!
name|strcmp
argument_list|(
name|av
index|[
literal|1
index|]
argument_list|,
literal|"clear"
argument_list|)
condition|)
name|ClearTable
argument_list|(
operator|&
name|TheTab
argument_list|)
expr_stmt|;
if|if
condition|(
name|ac
operator|>
literal|2
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|av
index|[
literal|2
index|]
argument_list|,
literal|"cellstart"
argument_list|)
condition|)
name|TexTableCellStart
argument_list|(
name|e
argument_list|,
name|fp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|av
index|[
literal|2
index|]
argument_list|,
literal|"cellend"
argument_list|)
condition|)
name|TexTableCellEnd
argument_list|(
name|e
argument_list|,
name|fp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|av
index|[
literal|2
index|]
argument_list|,
literal|"rowstart"
argument_list|)
condition|)
name|TexTableRowStart
argument_list|(
name|e
argument_list|,
name|fp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|av
index|[
literal|2
index|]
argument_list|,
literal|"rowend"
argument_list|)
condition|)
name|TexTableRowEnd
argument_list|(
name|e
argument_list|,
name|fp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|av
index|[
literal|2
index|]
argument_list|,
literal|"top"
argument_list|)
condition|)
name|TexTableTop
argument_list|(
name|e
argument_list|,
name|fp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|av
index|[
literal|2
index|]
argument_list|,
literal|"bottom"
argument_list|)
condition|)
name|TexTableBottom
argument_list|(
name|e
argument_list|,
name|fp
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unknown %s table instruction: %s\n"
argument_list|,
name|av
index|[
literal|1
index|]
argument_list|,
name|av
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
else|else
name|TexTable
argument_list|(
name|e
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unknown table type: %s\n"
argument_list|,
name|av
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  ClearTable -- start a new table process  *  */
end_comment

begin_function
name|void
name|ClearTable
parameter_list|(
name|TableInfo
modifier|*
name|t
parameter_list|)
block|{
name|memset
argument_list|(
name|t
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|TableInfo
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ______________________________________________________________________ */
end_comment

begin_comment
comment|/*  Set values of the our internal table structure based on the table's  *  attributes.  (This is called for tables, tgroups, colspecs, and rows,  *  since tables and rows share many of the same attributes.)  *  Arguments:  *	Pointer to element under consideration.  *	Pointer table info structure which will be filled in.  *	Flag saying whether or not to set global variables based on attrs.  */
end_comment

begin_function
name|void
name|SetTabAtts
parameter_list|(
name|Element_t
modifier|*
name|e
parameter_list|,
name|TableInfo
modifier|*
name|t
parameter_list|,
name|int
name|set_globals
parameter_list|)
block|{
name|char
modifier|*
name|at
decl_stmt|;
name|Element_t
modifier|*
name|ep
decl_stmt|;
comment|/* remember values of attributes */
if|if
condition|(
operator|(
name|at
operator|=
name|FindAttValByName
argument_list|(
name|e
argument_list|,
literal|"ALIGN"
argument_list|)
operator|)
condition|)
name|t
operator|->
name|align
operator|=
name|at
expr_stmt|;
if|if
condition|(
operator|(
name|at
operator|=
name|FindAttValByName
argument_list|(
name|e
argument_list|,
literal|"COLWIDTH"
argument_list|)
operator|)
condition|)
name|t
operator|->
name|colwidth
operator|=
name|at
expr_stmt|;
if|if
condition|(
operator|(
name|at
operator|=
name|FindAttValByName
argument_list|(
name|e
argument_list|,
literal|"COLSEP"
argument_list|)
operator|)
condition|)
name|t
operator|->
name|colsep
operator|=
name|at
expr_stmt|;
if|if
condition|(
operator|(
name|at
operator|=
name|FindAttValByName
argument_list|(
name|e
argument_list|,
literal|"FRAME"
argument_list|)
operator|)
condition|)
name|t
operator|->
name|frame
operator|=
name|at
expr_stmt|;
if|if
condition|(
operator|(
name|at
operator|=
name|FindAttValByName
argument_list|(
name|e
argument_list|,
literal|"COLS"
argument_list|)
operator|)
condition|)
name|t
operator|->
name|cols
operator|=
name|at
expr_stmt|;
comment|/* Set some things for later when processing this table */
if|if
condition|(
name|set_globals
condition|)
block|{
name|rowsep
operator|=
literal|1
expr_stmt|;
name|frametop
operator|=
name|framebot
operator|=
literal|1
expr_stmt|;
comment|/* default style */
comment|/* For now we look at the first number of rowsep - it controls the 	 * horiz rule for then entire row.  (not easy to specify lines that 	 * span only some columns in tex or tbl. */
if|if
condition|(
operator|(
name|at
operator|=
name|FindAttValByName
argument_list|(
name|e
argument_list|,
literal|"ROWSEP"
argument_list|)
operator|)
condition|)
name|rowsep
operator|=
name|atoi
argument_list|(
name|at
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|->
name|frame
condition|)
block|{
comment|/* Top|Bottom|Topbot|All|Sides|None */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|t
operator|->
name|frame
argument_list|,
literal|"NONE"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|t
operator|->
name|frame
argument_list|,
literal|"SIDES"
argument_list|)
condition|)
name|frametop
operator|=
name|framebot
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|t
operator|->
name|frame
argument_list|,
literal|"TOP"
argument_list|)
condition|)
name|framebot
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|t
operator|->
name|frame
argument_list|,
literal|"BOTTOM"
argument_list|)
condition|)
name|frametop
operator|=
literal|0
expr_stmt|;
block|}
comment|/* tbl and tex like lower case for units. convert. */
if|if
condition|(
name|t
operator|->
name|colwidth
condition|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
for|for
control|(
name|cp
operator|=
name|t
operator|->
name|colwidth
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
if|if
condition|(
name|isupper
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
operator|*
name|cp
operator|=
name|tolower
argument_list|(
operator|*
name|cp
argument_list|)
expr_stmt|;
block|}
comment|/* Now, split (space-separated) strings into vectors.  Hopefully, the      * number of elements in each vector matches the number of columns.      */
name|t
operator|->
name|align_v
operator|=
name|Split
argument_list|(
name|t
operator|->
name|align
argument_list|,
operator|&
name|t
operator|->
name|n_align
argument_list|,
name|S_STRDUP
operator||
name|S_ALVEC
argument_list|)
expr_stmt|;
name|t
operator|->
name|colwidth_v
operator|=
name|Split
argument_list|(
name|t
operator|->
name|colwidth
argument_list|,
operator|&
name|t
operator|->
name|n_colwidth
argument_list|,
name|S_STRDUP
operator||
name|S_ALVEC
argument_list|)
expr_stmt|;
name|t
operator|->
name|colsep_v
operator|=
name|Split
argument_list|(
name|t
operator|->
name|colsep
argument_list|,
operator|&
name|t
operator|->
name|n_colsep
argument_list|,
name|S_STRDUP
operator||
name|S_ALVEC
argument_list|)
expr_stmt|;
comment|/* Determin the _numeric_ number of columns, "nc".  MUST be specified      * in Cols attribute of TGroup element.      */
if|if
condition|(
name|t
operator|->
name|cols
condition|)
name|t
operator|->
name|nc
operator|=
name|atoi
argument_list|(
name|t
operator|->
name|cols
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ______________________________________________________________________ */
end_comment

begin_comment
comment|/*  Free the storage of info use by the table info structure.  (not the  *  structure itself, but the strings its elements point to)  *  Arguments:  *	Pointer table info structure to be freed.  */
end_comment

begin_function
name|void
name|FreeTabAtts
parameter_list|(
name|TableInfo
modifier|*
name|t
parameter_list|)
block|{
if|if
condition|(
operator|!
name|t
condition|)
return|return;
if|if
condition|(
name|t
operator|->
name|align_v
condition|)
name|free
argument_list|(
operator|*
name|t
operator|->
name|align_v
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|colwidth_v
condition|)
name|free
argument_list|(
operator|*
name|t
operator|->
name|colwidth_v
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|colsep_v
condition|)
name|free
argument_list|(
operator|*
name|t
operator|->
name|colsep_v
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ______________________________________________________________________ */
end_comment

begin_comment
comment|/*  Check the attributes and children of the table pointed to by e.  *  Report problems and inconsistencies to stderr.  *  Arguments:  *	Pointer to element (table) under consideration.  */
end_comment

begin_function
name|void
name|CheckTable
parameter_list|(
name|Element_t
modifier|*
name|e
parameter_list|)
block|{
name|int
name|pr_loc
init|=
literal|0
decl_stmt|;
comment|/* flag to say if we printed location */
name|int
name|i
decl_stmt|,
name|r
decl_stmt|,
name|c
decl_stmt|;
name|Element_t
modifier|*
name|ep
decl_stmt|,
modifier|*
name|ep2
decl_stmt|;
name|float
name|wt
decl_stmt|;
name|char
modifier|*
name|tpref
init|=
literal|"Table Check"
decl_stmt|;
comment|/* prefix for err messages */
name|char
modifier|*
name|ncolchk
init|=
literal|"Table Check: %s ('%s') has wrong number of tokens.  Expecting %d.\n"
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|e
operator|->
name|gi
argument_list|,
literal|"TABLE"
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|e
operator|->
name|gi
argument_list|,
literal|"INFORMALTABLE"
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|e
operator|->
name|gi
argument_list|,
literal|"TGROUP"
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|e
operator|->
name|gi
argument_list|,
literal|"COLSPEC"
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|e
operator|->
name|gi
argument_list|,
literal|"ROW"
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Not pointing to a table element(%s)!\n"
argument_list|,
name|tpref
argument_list|,
name|e
operator|->
name|gi
argument_list|)
expr_stmt|;
return|return;
block|}
name|FreeTabAtts
argument_list|(
operator|&
name|TheTab
argument_list|)
expr_stmt|;
comment|/* free storage, if allocated earlier */
name|SetTabAtts
argument_list|(
name|e
argument_list|,
operator|&
name|TheTab
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* look at attributes */
if|#
directive|if
name|FALSE
comment|/* NCOLS attribute set? */
if|if
condition|(
operator|!
name|TheTab
operator|.
name|ncols
condition|)
block|{
name|pr_loc
operator|++
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: NCOLS attribute missing. Inferred as %d.\n"
argument_list|,
name|tpref
argument_list|,
name|TheTab
operator|.
name|nc
argument_list|)
expr_stmt|;
block|}
comment|/* ALIGN attribute set? */
if|if
condition|(
operator|!
name|TheTab
operator|.
name|align
condition|)
block|{
name|pr_loc
operator|++
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: ALIGN attribute missing.\n"
argument_list|,
name|tpref
argument_list|)
expr_stmt|;
block|}
comment|/* See if the number of cells in each row matches */
for|for
control|(
name|r
operator|=
literal|0
init|;
name|r
operator|<
name|e
operator|->
name|necont
operator|&&
operator|(
name|ep
operator|=
name|e
operator|->
name|econt
index|[
name|r
index|]
operator|)
condition|;
name|r
operator|++
control|)
block|{
comment|/* each TGroup */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ep
operator|->
name|necont
operator|&&
operator|(
name|ep2
operator|=
name|ep
operator|->
name|econt
index|[
name|i
index|]
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|ep2
operator|->
name|gi
argument_list|,
literal|"TBODY"
argument_list|)
condition|)
comment|/* only TBodys */
continue|continue;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|ep2
operator|->
name|necont
condition|;
name|c
operator|++
control|)
block|{
if|if
condition|(
name|ep2
operator|->
name|econt
index|[
name|c
index|]
operator|->
name|necont
operator|!=
name|TheTab
operator|.
name|nc
condition|)
block|{
name|pr_loc
operator|++
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: COLS (%d) differs from actual number of cells (%d) in row %d.\n"
argument_list|,
name|tpref
argument_list|,
name|TheTab
operator|.
name|nc
argument_list|,
name|ep2
operator|->
name|econt
index|[
name|c
index|]
operator|->
name|necont
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
endif|#
directive|endif
comment|/* Check ALIGN */
if|if
condition|(
name|TheTab
operator|.
name|align
condition|)
block|{
if|if
condition|(
name|TheTab
operator|.
name|nc
operator|!=
name|TheTab
operator|.
name|n_align
condition|)
block|{
comment|/* number of tokens OK? */
name|pr_loc
operator|++
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|ncolchk
argument_list|,
literal|"ALIGN"
argument_list|,
name|TheTab
operator|.
name|align
argument_list|,
name|TheTab
operator|.
name|nc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* values OK? */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TheTab
operator|.
name|nc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|TheTab
operator|.
name|align_v
index|[
name|i
index|]
operator|!=
literal|'C'
operator|&&
operator|*
name|TheTab
operator|.
name|align_v
index|[
name|i
index|]
operator|!=
literal|'L'
operator|&&
operator|*
name|TheTab
operator|.
name|align_v
index|[
name|i
index|]
operator|!=
literal|'R'
condition|)
block|{
name|pr_loc
operator|++
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: ALIGN (%d) value wrong: %s\n"
argument_list|,
name|tpref
argument_list|,
name|i
argument_list|,
name|TheTab
operator|.
name|align_v
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* check COLWIDTH */
if|if
condition|(
name|TheTab
operator|.
name|colwidth
condition|)
block|{
if|if
condition|(
name|TheTab
operator|.
name|nc
operator|!=
name|TheTab
operator|.
name|n_colwidth
condition|)
block|{
comment|/* number of tokens OK? */
name|pr_loc
operator|++
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|ncolchk
argument_list|,
literal|"COLWIDTH"
argument_list|,
name|TheTab
operator|.
name|colwidth
argument_list|,
name|TheTab
operator|.
name|nc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* values OK? */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TheTab
operator|.
name|nc
condition|;
name|i
operator|++
control|)
block|{
comment|/* check that the units after the numbers are OK 		    we want "in", "cm". 		 */
block|}
block|}
block|}
comment|/* check COLSEP */
if|if
condition|(
name|TheTab
operator|.
name|colsep
condition|)
block|{
if|if
condition|(
name|TheTab
operator|.
name|nc
operator|!=
name|TheTab
operator|.
name|n_colsep
condition|)
block|{
comment|/* number of tokens OK? */
name|pr_loc
operator|++
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|ncolchk
argument_list|,
literal|"COLSEP"
argument_list|,
name|TheTab
operator|.
name|colsep
argument_list|,
name|TheTab
operator|.
name|nc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* values OK? */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TheTab
operator|.
name|nc
condition|;
name|i
operator|++
control|)
block|{ 	    }
block|}
block|}
if|if
condition|(
name|pr_loc
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Above problem in table located at:\n"
argument_list|,
name|tpref
argument_list|)
expr_stmt|;
name|PrintLocation
argument_list|(
name|e
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ______________________________________________________________________ */
end_comment

begin_comment
comment|/*  Look at colspec attribute for spanning.  If set, remember info for when  *  doing the cells.  Called by TblTableRowStart() and TexTableRowStart().  *  Arguments:  *	Pointer to element (row) under consideration.  */
end_comment

begin_function
name|int
name|check_for_spans
parameter_list|(
name|Element_t
modifier|*
name|e
parameter_list|)
block|{
name|char
modifier|*
name|at
decl_stmt|;
name|char
modifier|*
modifier|*
name|spans
decl_stmt|;
name|int
name|n
decl_stmt|,
name|i
decl_stmt|,
name|inspan
decl_stmt|;
if|#
directive|if
name|FALSE
comment|/* NOT IMPLEMENTED RIGHT NOW */
comment|/* See if COLSPEC element present */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|e
operator|->
name|necont
condition|;
name|i
operator|++
control|)
block|{ 	     }
if|if
condition|(
operator|(
name|at
operator|=
name|FindAttValByName
argument_list|(
name|e
argument_list|,
literal|"MODEL"
argument_list|)
operator|)
condition|)
block|{
comment|/* Split into tokens, then look at each for the word "span" */
name|n
operator|=
name|TheTab
operator|.
name|nc
expr_stmt|;
name|spans
operator|=
name|Split
argument_list|(
name|at
argument_list|,
operator|&
name|n
argument_list|,
name|S_STRDUP
operator||
name|S_ALVEC
argument_list|)
expr_stmt|;
comment|/* Mark columns as start-of-span, in-span, or not spanned.  Remember 	 * in at list, "spaningo".  (Span does not make sense in 1st column.) 	 */
for|for
control|(
name|i
operator|=
literal|1
operator|,
name|inspan
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|StrEq
argument_list|(
name|spans
index|[
name|i
index|]
argument_list|,
literal|"span"
argument_list|)
operator|||
name|StrEq
argument_list|(
name|spans
index|[
name|i
index|]
argument_list|,
literal|"s"
argument_list|)
condition|)
block|{
if|if
condition|(
name|inspan
operator|==
literal|0
condition|)
name|spaninfo
index|[
name|i
operator|-
literal|1
index|]
operator|=
name|SPAN_START
expr_stmt|;
name|spaninfo
index|[
name|i
index|]
operator|=
name|SPAN_CONT
expr_stmt|;
name|inspan
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|spaninfo
index|[
name|i
index|]
operator|=
name|SPAN_NOT
expr_stmt|;
name|inspan
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|free
argument_list|(
operator|*
name|spans
argument_list|)
expr_stmt|;
comment|/* free string */
name|free
argument_list|(
name|spans
argument_list|)
expr_stmt|;
comment|/* free vector */
name|spaninfo
index|[
name|TheTab
operator|.
name|nc
index|]
operator|=
name|SPAN_NOT
expr_stmt|;
comment|/* after last cell */
return|return
literal|1
return|;
block|}
comment|/* if model not set, mark all as not spanning */
else|else
endif|#
directive|endif
comment|/* NOT CURRENTLY IMPLEMENTED */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXCOLS
condition|;
name|i
operator|++
control|)
name|spaninfo
index|[
name|i
index|]
operator|=
name|SPAN_NOT
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ______________________________________________________________________ */
end_comment

begin_comment
comment|/* Do the "right thing" for the table spec for TeX tables.  This will  * generate the arg to \begin{tabular}[xxx].  *  Arguments:  *	Pointer to element (table) under consideration.  *	FILE pointer to where to write output.  */
end_comment

begin_function
name|void
name|TexTable
parameter_list|(
name|Element_t
modifier|*
name|e
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
name|float
name|tot
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
name|wbuf
index|[
literal|1500
index|]
decl_stmt|,
modifier|*
modifier|*
name|widths
init|=
literal|0
decl_stmt|,
modifier|*
modifier|*
name|widths_v
init|=
literal|0
decl_stmt|;
name|FreeTabAtts
argument_list|(
operator|&
name|TheTab
argument_list|)
expr_stmt|;
comment|/* free storage, if allocated earlier */
name|SetTabAtts
argument_list|(
name|e
argument_list|,
operator|&
name|TheTab
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* look at attributes */
name|SetTabAtts
argument_list|(
name|e
operator|->
name|econt
index|[
literal|0
index|]
argument_list|,
operator|&
name|TheTab
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* attrs of TGroup */
comment|/* Figure out the widths, based either on "colwidth".      */
if|if
condition|(
name|TheTab
operator|.
name|colwidth
operator|&&
name|TheTab
operator|.
name|nc
operator|==
name|TheTab
operator|.
name|n_colwidth
condition|)
block|{
name|widths
operator|=
name|TheTab
operator|.
name|colwidth_v
expr_stmt|;
block|}
name|siderules
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TheTab
operator|.
name|frame
condition|)
if|if
condition|(
name|strcmp
argument_list|(
name|TheTab
operator|.
name|frame
argument_list|,
literal|"ALL"
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|TheTab
operator|.
name|frame
argument_list|,
literal|"SIDES"
argument_list|)
condition|)
name|siderules
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|siderules
condition|)
name|OutputString
argument_list|(
literal|"|"
argument_list|,
name|fp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TheTab
operator|.
name|nc
condition|;
name|i
operator|++
control|)
block|{
comment|/* If width specified, use it; else if align set, use it; else left. */
if|if
condition|(
name|widths
operator|&&
name|widths
index|[
name|i
index|]
index|[
literal|0
index|]
operator|!=
literal|'0'
operator|&&
name|widths
index|[
name|i
index|]
index|[
literal|1
index|]
operator|!=
name|EOS
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%sp{%s}"
argument_list|,
operator|(
name|i
condition|?
literal|" "
else|:
literal|""
operator|)
argument_list|,
name|widths
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TheTab
operator|.
name|align
operator|&&
name|TheTab
operator|.
name|nc
operator|==
name|TheTab
operator|.
name|n_align
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s%s"
argument_list|,
operator|(
name|i
condition|?
literal|" "
else|:
literal|""
operator|)
argument_list|,
name|TheTab
operator|.
name|align_v
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%sl"
argument_list|,
operator|(
name|i
condition|?
literal|" "
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
comment|/* See if we want column separators. */
if|if
condition|(
name|TheTab
operator|.
name|colsep
condition|)
block|{
if|if
condition|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|<
name|TheTab
operator|.
name|nc
condition|)
block|{
if|if
condition|(
operator|*
name|TheTab
operator|.
name|colsep_v
index|[
name|i
index|]
operator|==
literal|'1'
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" |"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|TheTab
operator|.
name|colsep_v
index|[
name|i
index|]
operator|==
literal|'2'
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" ||"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|siderules
condition|)
name|OutputString
argument_list|(
literal|"|"
argument_list|,
name|fp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|widths_v
condition|)
name|free
argument_list|(
name|widths_v
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  Arguments:  *	Pointer to element (cell) under consideration.  *	FILE pointer to where to write output.  */
end_comment

begin_function
name|void
name|TexTableCellStart
parameter_list|(
name|Element_t
modifier|*
name|e
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|int
name|n
decl_stmt|,
name|i
decl_stmt|;
name|char
name|buf
index|[
literal|50
index|]
decl_stmt|,
modifier|*
name|at
decl_stmt|;
if|if
condition|(
name|spaninfo
index|[
name|e
operator|->
name|my_eorder
index|]
operator|==
name|SPAN_START
condition|)
block|{
for|for
control|(
name|i
operator|=
name|e
operator|->
name|my_eorder
operator|+
literal|1
operator|,
name|n
operator|=
literal|1
init|;
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|spaninfo
index|[
name|i
index|]
operator|==
name|SPAN_CONT
condition|)
name|n
operator|++
expr_stmt|;
else|else
break|break;
block|}
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"\\\\multicolumn{%d}{%sc%s}"
argument_list|,
name|n
argument_list|,
operator|(
name|siderules
condition|?
literal|"|"
else|:
literal|""
operator|)
argument_list|,
operator|(
name|siderules
condition|?
literal|"|"
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
name|OutputString
argument_list|(
name|buf
argument_list|,
name|fp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|New
if|if
condition|(
operator|(
name|at
operator|=
name|FindAttValByName
argument_list|(
name|e
operator|->
name|parent
argument_list|,
literal|"ALIGN"
argument_list|)
operator|)
condition|)
block|{
comment|/* no span, but user wants to change the alignment */
name|h_v
operator|=
name|Split
argument_list|(
name|wbuf
argument_list|,
literal|0
argument_list|,
name|S_ALVEC
operator||
name|S_STRDUP
argument_list|)
expr_stmt|;
name|OutputString
argument_list|(
literal|"\\\\multicolumn{1}{%sc%s}"
argument_list|,
name|n
argument_list|,
name|fp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|spaninfo
index|[
name|e
operator|->
name|my_eorder
index|]
operator|!=
name|SPAN_CONT
condition|)
name|OutputString
argument_list|(
literal|"{"
argument_list|,
name|fp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  Arguments:  *	Pointer to element (cell) under consideration.  *	FILE pointer to where to write output.  */
end_comment

begin_function
name|void
name|TexTableCellEnd
parameter_list|(
name|Element_t
modifier|*
name|e
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
if|if
condition|(
name|spaninfo
index|[
name|e
operator|->
name|my_eorder
index|]
operator|!=
name|SPAN_CONT
condition|)
name|OutputString
argument_list|(
literal|"} "
argument_list|,
name|fp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* do cell/col separators */
if|if
condition|(
name|e
operator|->
name|my_eorder
operator|<
operator|(
name|TheTab
operator|.
name|nc
operator|-
literal|1
operator|)
condition|)
block|{
if|if
condition|(
name|spaninfo
index|[
name|e
operator|->
name|my_eorder
index|]
operator|==
name|SPAN_NOT
operator|||
name|spaninfo
index|[
name|e
operator|->
name|my_eorder
operator|+
literal|1
index|]
operator|!=
name|SPAN_CONT
condition|)
name|OutputString
argument_list|(
literal|"& "
argument_list|,
name|fp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  Look at model for spanning.  If set, remember it for when doing the cells.  *  Arguments:  *	Pointer to element (row) under consideration.  *	FILE pointer to where to write output.  */
end_comment

begin_function
name|void
name|TexTableRowStart
parameter_list|(
name|Element_t
modifier|*
name|e
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|check_for_spans
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  Arguments:  *	Pointer to element (row) under consideration.  *	FILE pointer to where to write output.  */
end_comment

begin_function
name|void
name|TexTableRowEnd
parameter_list|(
name|Element_t
modifier|*
name|e
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|char
modifier|*
name|at
decl_stmt|;
comment|/* check this row's attributes */
if|if
condition|(
operator|(
name|at
operator|=
name|FindAttValByName
argument_list|(
name|e
argument_list|,
literal|"ROWSEP"
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|at
index|[
literal|0
index|]
operator|==
literal|'1'
condition|)
name|OutputString
argument_list|(
literal|"\\\\\\\\[2mm] \\\\hline "
argument_list|,
name|fp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rowsep
condition|)
name|OutputString
argument_list|(
literal|"\\\\\\\\ "
argument_list|,
name|fp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|OutputString
argument_list|(
literal|"\\\\\\\\ "
argument_list|,
name|fp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  Arguments:  *	Pointer to element (table) under consideration.  *	FILE pointer to where to write output.  */
end_comment

begin_function
name|void
name|TexTableTop
parameter_list|(
name|Element_t
modifier|*
name|e
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
if|if
condition|(
name|frametop
condition|)
name|OutputString
argument_list|(
literal|"\\\\hline"
argument_list|,
name|fp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|TexTableBottom
parameter_list|(
name|Element_t
modifier|*
name|e
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
if|if
condition|(
name|framebot
condition|)
name|OutputString
argument_list|(
literal|"\\\\hline"
argument_list|,
name|fp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ______________________________________________________________________ */
end_comment

begin_comment
comment|/* ______________________________________________________________________ */
end_comment

begin_comment
comment|/* ______________________________________________________________________ */
end_comment

begin_comment
comment|/* ______________________________________________________________________ */
end_comment

begin_comment
comment|/* ______________________________________________________________________ */
end_comment

begin_comment
comment|/* ___________________________|             |____________________________ */
end_comment

begin_comment
comment|/* ___________________________|  TBL STUFF  |____________________________ */
end_comment

begin_comment
comment|/* ___________________________|             |____________________________ */
end_comment

begin_comment
comment|/* ___________________________|_____________|____________________________ */
end_comment

begin_comment
comment|/* ______________________________________________________________________ */
end_comment

begin_comment
comment|/* ______________________________________________________________________ */
end_comment

begin_comment
comment|/* ______________________________________________________________________ */
end_comment

begin_comment
comment|/* ______________________________________________________________________ */
end_comment

begin_comment
comment|/*	TblTStart()  --  start a table and do style information  *  *  TO DO:  *  *	do .TS  *	find global rowsep and colsep  */
end_comment

begin_function
name|void
name|TblTStart
parameter_list|(
name|Element_t
modifier|*
name|ep
parameter_list|,
name|FILE
modifier|*
name|fP
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|struct
name|Element_t
modifier|*
name|ep2
decl_stmt|;
name|OutputString
argument_list|(
literal|"^.TS^"
argument_list|,
name|fP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tblTGroupSeen
operator|=
name|FALSE
expr_stmt|;
name|tblinBOFT
operator|=
name|FALSE
expr_stmt|;
comment|/* within a boft? */
name|tblBOFTCount
operator|=
literal|0
expr_stmt|;
comment|/* count of Blocks of Filled Text that 				 * we've created */
name|tblgcolsep
operator|=
operator|(
name|cp
operator|=
name|FindAttValByName
argument_list|(
name|ep
argument_list|,
literal|"COLSEP"
argument_list|)
operator|)
operator|&&
operator|!
name|strcmp
argument_list|(
name|cp
argument_list|,
literal|"1"
argument_list|)
expr_stmt|;
name|tblgrowsep
operator|=
operator|(
name|cp
operator|=
name|FindAttValByName
argument_list|(
name|ep
argument_list|,
literal|"ROWSEP"
argument_list|)
operator|)
operator|&&
operator|!
name|strcmp
argument_list|(
name|cp
argument_list|,
literal|"1"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*      TblTEnd()  --  end a table and do any cleanup  *  *  TO DO:  *  *	do .TE  *  *	deallocate format line info  */
end_comment

begin_function
name|void
name|TblTEnd
parameter_list|(
name|Element_t
modifier|*
name|ep
parameter_list|,
name|FILE
modifier|*
name|fP
parameter_list|)
block|{
specifier|register
name|struct
name|tblformat
modifier|*
name|ffp
decl_stmt|,
modifier|*
name|ffp2
decl_stmt|;
if|if
condition|(
name|tblBOFTCount
operator|>
literal|31
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"# warning, line %d: created %d blocks of filled text in one table\n"
argument_list|,
name|ep
operator|->
name|lineno
argument_list|,
name|tblBOFTCount
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"#\t\t(31 is the limit in some systems)\n"
argument_list|)
expr_stmt|;
block|}
name|OutputString
argument_list|(
literal|"^.TE^"
argument_list|,
name|fP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|ffp
operator|=
name|formP
init|;
name|ffp
condition|;
name|ffp
operator|=
name|ffp2
control|)
block|{
name|ffp2
operator|=
name|ffp
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|ffp
argument_list|)
expr_stmt|;
comment|/* clear entire list */
block|}
name|formP
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*      TblTTGroup()  --  do body work (row format info)  *  *  TO DO:  *  *	set number of columns  *  *	if this is the first TGroup of this table, do style info:  *	   a. alignment  *	   b. defaults:  tab  *	   c. box vx allbox  *  *	do format info:  *	   a. generate tableformat structure  *	   b. output it  *  *	prepare structures for colspecs and spanspecs  *  */
end_comment

begin_function
name|void
name|TblTGroup
parameter_list|(
name|Element_t
modifier|*
name|ep
parameter_list|,
name|FILE
modifier|*
name|fP
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|cp2
decl_stmt|;
specifier|register
name|Element_t
modifier|*
name|ep2
decl_stmt|,
name|ep3
decl_stmt|;
specifier|register
name|struct
name|tblcolspec
modifier|*
name|tcsp
decl_stmt|,
modifier|*
name|tcsp2
decl_stmt|;
specifier|register
name|struct
name|tblspanspec
modifier|*
name|tssp
decl_stmt|,
modifier|*
name|tssp2
decl_stmt|;
name|tblColSpec
operator|=
literal|0
expr_stmt|;
comment|/* make sure they're clear */
name|tblSpanSpec
operator|=
literal|0
expr_stmt|;
comment|/* set the number of columns */
name|tblcols
operator|=
name|atoi
argument_list|(
name|FindAttValByName
argument_list|(
name|ep
argument_list|,
literal|"COLS"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* do colspecs */
name|tblColSpec
operator|=
name|tcsp
operator|=
name|TblDoColSpec
argument_list|(
literal|0
argument_list|,
name|ep
argument_list|,
literal|0
argument_list|,
name|TGroup
argument_list|)
expr_stmt|;
comment|/* do TGroup first -- it becomes the default */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|k
operator|=
literal|1
init|;
name|i
operator|<
name|ep
operator|->
name|necont
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ep
operator|->
name|econt
index|[
name|i
index|]
operator|->
name|gi
argument_list|,
literal|"COLSPEC"
argument_list|)
condition|)
block|{
name|tcsp2
operator|=
name|TblDoColSpec
argument_list|(
name|k
argument_list|,
name|ep
operator|->
name|econt
index|[
name|i
index|]
argument_list|,
name|tblColSpec
argument_list|,
name|TGroup
argument_list|)
expr_stmt|;
name|tcsp
operator|->
name|next
operator|=
name|tcsp2
expr_stmt|;
comment|/* put into list */
name|tcsp
operator|=
name|tcsp2
expr_stmt|;
name|k
operator|=
name|tcsp2
operator|->
name|num
operator|+
literal|1
expr_stmt|;
comment|/* next column number */
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ep
operator|->
name|econt
index|[
name|i
index|]
operator|->
name|gi
argument_list|,
literal|"THEAD"
argument_list|)
condition|)
block|{
name|ep2
operator|=
name|ep
operator|->
name|econt
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|k
operator|=
literal|1
init|;
name|j
operator|<
name|ep2
operator|->
name|necont
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ep2
operator|->
name|econt
index|[
name|j
index|]
operator|->
name|gi
argument_list|,
literal|"COLSPEC"
argument_list|)
condition|)
block|{
name|tcsp2
operator|=
name|TblDoColSpec
argument_list|(
name|k
argument_list|,
name|ep2
operator|->
name|econt
index|[
name|j
index|]
argument_list|,
name|tblColSpec
argument_list|,
name|THead
argument_list|)
expr_stmt|;
name|tcsp
operator|->
name|next
operator|=
name|tcsp2
expr_stmt|;
comment|/* put into list */
name|tcsp
operator|=
name|tcsp2
expr_stmt|;
name|k
operator|=
name|tcsp2
operator|->
name|num
operator|+
literal|1
expr_stmt|;
comment|/* next column number */
block|}
block|}
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ep
operator|->
name|econt
index|[
name|i
index|]
operator|->
name|gi
argument_list|,
literal|"TFOOT"
argument_list|)
condition|)
block|{
name|ep2
operator|=
name|ep
operator|->
name|econt
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|k
operator|=
literal|1
init|;
name|j
operator|<
name|ep2
operator|->
name|necont
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ep2
operator|->
name|econt
index|[
name|j
index|]
operator|->
name|gi
argument_list|,
literal|"COLSPEC"
argument_list|)
condition|)
block|{
name|tcsp2
operator|=
name|TblDoColSpec
argument_list|(
name|k
argument_list|,
name|ep2
operator|->
name|econt
index|[
name|j
index|]
argument_list|,
name|tblColSpec
argument_list|,
name|TFoot
argument_list|)
expr_stmt|;
name|tcsp
operator|->
name|next
operator|=
name|tcsp2
expr_stmt|;
comment|/* put into list */
name|tcsp
operator|=
name|tcsp2
expr_stmt|;
name|k
operator|=
name|tcsp2
operator|->
name|num
operator|+
literal|1
expr_stmt|;
comment|/* next column number */
block|}
block|}
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ep
operator|->
name|econt
index|[
name|i
index|]
operator|->
name|gi
argument_list|,
literal|"TBODY"
argument_list|)
condition|)
block|{
name|ep2
operator|=
name|ep
operator|->
name|econt
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|k
operator|=
literal|1
init|;
name|j
operator|<
name|ep2
operator|->
name|necont
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ep2
operator|->
name|econt
index|[
name|j
index|]
operator|->
name|gi
argument_list|,
literal|"COLSPEC"
argument_list|)
condition|)
block|{
name|tcsp2
operator|=
name|TblDoColSpec
argument_list|(
name|k
argument_list|,
name|ep2
operator|->
name|econt
index|[
name|j
index|]
argument_list|,
name|tblColSpec
argument_list|,
name|TBody
argument_list|)
expr_stmt|;
name|tcsp
operator|->
name|next
operator|=
name|tcsp2
expr_stmt|;
comment|/* put into list */
name|tcsp
operator|=
name|tcsp2
expr_stmt|;
name|k
operator|=
name|tcsp2
operator|->
name|num
operator|+
literal|1
expr_stmt|;
comment|/* next column number */
block|}
block|}
block|}
block|}
comment|/* do spanspecs */
name|tblSpanSpec
operator|=
name|tssp
operator|=
name|TblDoSpanSpec
argument_list|(
name|ep
argument_list|,
literal|0
argument_list|,
name|TGroup
argument_list|)
expr_stmt|;
comment|/* do TGroup first -- it becomes the default */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ep
operator|->
name|necont
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ep
operator|->
name|econt
index|[
name|i
index|]
operator|->
name|gi
argument_list|,
literal|"SPANSPEC"
argument_list|)
condition|)
block|{
name|tssp2
operator|=
name|TblDoSpanSpec
argument_list|(
name|ep
operator|->
name|econt
index|[
name|i
index|]
argument_list|,
name|tblSpanSpec
argument_list|,
name|TGroup
argument_list|)
expr_stmt|;
name|tssp
operator|->
name|next
operator|=
name|tssp2
expr_stmt|;
comment|/* put into list */
name|tssp
operator|=
name|tssp2
expr_stmt|;
block|}
block|}
comment|/* if this is the first TGroup in this table, do style stuff */
if|if
condition|(
operator|!
name|tblTGroupSeen
condition|)
block|{
name|OutputString
argument_list|(
literal|"tab(\007)"
argument_list|,
name|fP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ep2
operator|=
name|ep
operator|->
name|parent
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tblFrame
operator|=
name|FindAttValByName
argument_list|(
name|ep2
argument_list|,
literal|"FRAME"
argument_list|)
operator|)
condition|)
name|tblFrame
operator|=
literal|""
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|tblFrame
argument_list|,
literal|"ALL"
argument_list|)
condition|)
block|{
if|if
condition|(
name|tcsp
operator|->
name|colsep
operator|&&
name|tcsp
operator|->
name|rowsep
condition|)
name|OutputString
argument_list|(
literal|" allbox"
argument_list|,
name|fP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|OutputString
argument_list|(
literal|" box"
argument_list|,
name|fP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|cp
operator|=
name|FindAttValByName
argument_list|(
name|ep
argument_list|,
literal|"ALIGN"
argument_list|)
operator|)
operator|&&
operator|!
name|strcmp
argument_list|(
name|cp
argument_list|,
literal|"CENTER"
argument_list|)
condition|)
block|{
name|OutputString
argument_list|(
literal|" center"
argument_list|,
name|fP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|OutputString
argument_list|(
literal|";\n"
argument_list|,
name|fP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tblTGroupSeen
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* do format stuff -- step through all THead rows then all TBody      * rows.  Build a list of tblformats that describe all of them.      * then output the resulting list.      */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ep
operator|->
name|necont
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ep
operator|->
name|econt
index|[
name|i
index|]
operator|->
name|gi
argument_list|,
literal|"THEAD"
argument_list|)
condition|)
block|{
name|TblBuildFormat
argument_list|(
name|ep
operator|->
name|econt
index|[
name|i
index|]
argument_list|,
operator|&
name|formP
argument_list|,
name|THead
argument_list|)
expr_stmt|;
comment|/* add in those rows */
break|break;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ep
operator|->
name|necont
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ep
operator|->
name|econt
index|[
name|i
index|]
operator|->
name|gi
argument_list|,
literal|"TBODY"
argument_list|)
condition|)
block|{
name|TblBuildFormat
argument_list|(
name|ep
operator|->
name|econt
index|[
name|i
index|]
argument_list|,
operator|&
name|formP
argument_list|,
name|TBody
argument_list|)
expr_stmt|;
comment|/* add in those rows */
break|break;
block|}
block|}
name|TblPrintFormat
argument_list|(
name|fP
argument_list|,
name|formP
argument_list|)
expr_stmt|;
name|tblrow
operator|=
literal|0
expr_stmt|;
comment|/* the current row within this format */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*      TblTGroupEnd()  --  end a TGroup  *  *  TO DO:  *  *	deallocate colspecs and spanspecs  */
end_comment

begin_function
name|void
name|TblTGroupEnd
parameter_list|(
name|Element_t
modifier|*
name|ep
parameter_list|,
name|FILE
modifier|*
name|fP
parameter_list|)
block|{
specifier|register
name|struct
name|tblcolspec
modifier|*
name|tcsp
decl_stmt|,
modifier|*
name|tcsp2
decl_stmt|;
specifier|register
name|struct
name|tblspanspec
modifier|*
name|tssp
decl_stmt|,
modifier|*
name|tssp2
decl_stmt|;
for|for
control|(
name|tcsp
operator|=
name|tblColSpec
init|;
name|tcsp
condition|;
name|tcsp
operator|=
name|tcsp2
control|)
block|{
name|tcsp2
operator|=
name|tcsp
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|tcsp
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|tssp
operator|=
name|tblSpanSpec
init|;
name|tssp
condition|;
name|tssp
operator|=
name|tssp2
control|)
block|{
name|tssp2
operator|=
name|tssp
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|tssp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*      TblTTFoot()  --  do body foot work (row format info)  *  *  TO DO:  *  *	do format info:  *	   a. generate tableformat structure  *	      i. if it is only 1 line long and matches the  *		 prevailing format, just output rows.  *	     ii. else, output a .T& and the new format specs  */
end_comment

begin_function
name|void
name|TblTFoot
parameter_list|(
name|Element_t
modifier|*
name|ep
parameter_list|,
name|FILE
modifier|*
name|fP
parameter_list|)
block|{
specifier|register
name|struct
name|tblformat
modifier|*
name|ffp
decl_stmt|,
modifier|*
name|ffp2
decl_stmt|;
specifier|static
name|struct
name|tblformat
modifier|*
name|tfp
decl_stmt|,
modifier|*
name|tfp2
decl_stmt|;
name|TblBuildFormat
argument_list|(
name|ep
argument_list|,
operator|&
name|tfp
argument_list|,
name|TFoot
argument_list|)
expr_stmt|;
comment|/* gen format for the foot */
for|for
control|(
name|tfp2
operator|=
name|formP
init|;
name|tfp2
operator|&&
name|tfp2
operator|->
name|next
condition|;
name|tfp2
operator|=
name|tfp2
operator|->
name|next
control|)
empty_stmt|;
if|if
condition|(
name|tfp
operator|->
name|next
operator|||
operator|!
name|TblFormatMatch
argument_list|(
name|tfp
argument_list|,
name|tfp2
argument_list|)
condition|)
block|{
for|for
control|(
name|ffp
operator|=
name|formP
init|;
name|ffp
condition|;
name|ffp
operator|=
name|ffp2
control|)
block|{
name|ffp2
operator|=
name|ffp
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|ffp
argument_list|)
expr_stmt|;
comment|/* clear entire list */
block|}
name|formP
operator|=
name|tfp
expr_stmt|;
comment|/* this becomes the prevailing format */
name|OutputString
argument_list|(
literal|"^.T&^"
argument_list|,
name|fP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|TblPrintFormat
argument_list|(
name|fP
argument_list|,
name|formP
argument_list|)
expr_stmt|;
block|}
name|tblrow
operator|=
literal|0
expr_stmt|;
comment|/* the current row within this format */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*	TblBuildFormat()  --  build a format structure out of a set of  *				rows and columns  *  */
end_comment

begin_function
name|void
name|TblBuildFormat
parameter_list|(
name|Element_t
modifier|*
name|ep
parameter_list|,
comment|/* parent of rows.. */
name|struct
name|tblformat
modifier|*
modifier|*
name|fp
parameter_list|,
comment|/* pointer to head of struct we're 	       				 * building */
name|tblsource
name|source
parameter_list|)
comment|/* type of record */
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|tblformat
modifier|*
name|lfp
decl_stmt|;
comment|/* "current" format */
specifier|register
name|struct
name|tblformat
modifier|*
name|nfp
decl_stmt|;
comment|/* the next format */
for|for
control|(
name|lfp
operator|=
operator|*
name|fp
init|;
name|lfp
operator|&&
name|lfp
operator|->
name|next
condition|;
name|lfp
operator|=
name|lfp
operator|->
name|next
control|)
empty_stmt|;
comment|/* find end of format list */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ep
operator|->
name|necont
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ep
operator|->
name|econt
index|[
name|i
index|]
operator|->
name|gi
argument_list|,
literal|"ROW"
argument_list|)
condition|)
break|break;
comment|/* find where rows start */
for|for
control|(
init|;
name|i
operator|<
name|ep
operator|->
name|necont
condition|;
name|i
operator|++
control|)
block|{
name|nfp
operator|=
name|TblBuild1Format
argument_list|(
name|ep
operator|->
name|econt
index|[
name|i
index|]
argument_list|,
name|FALSE
argument_list|,
name|source
argument_list|)
expr_stmt|;
comment|/* do one row */
if|if
condition|(
operator|!
name|lfp
condition|)
name|lfp
operator|=
operator|*
name|fp
operator|=
name|nfp
expr_stmt|;
comment|/* first one */
elseif|else
if|if
condition|(
name|TblFormatMatch
argument_list|(
name|lfp
argument_list|,
name|nfp
argument_list|)
condition|)
name|lfp
operator|->
name|count
operator|++
expr_stmt|;
comment|/* matches */
else|else
block|{
name|lfp
operator|->
name|count
operator|=
literal|1
expr_stmt|;
comment|/* only 1 so far */
name|lfp
operator|->
name|next
operator|=
name|nfp
expr_stmt|;
comment|/* new one */
name|lfp
operator|=
name|nfp
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*	TblBuild1Format()  --  build one row's worth of format information  *  */
end_comment

begin_function
name|struct
name|tblformat
modifier|*
name|TblBuild1Format
parameter_list|(
name|Element_t
modifier|*
name|rp
parameter_list|,
comment|/* the row to deal with */
name|bool
name|addinRowsep
parameter_list|,
comment|/* insert rowsep into model? */
name|tblsource
name|source
parameter_list|)
comment|/* type type of row */
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|bool
name|allProp
decl_stmt|;
name|float
name|totalProp
decl_stmt|;
specifier|register
name|struct
name|tblformat
modifier|*
name|tfp
decl_stmt|;
specifier|register
name|Element_t
modifier|*
name|ep
decl_stmt|;
comment|/* entry pointer */
name|Calloc
argument_list|(
literal|1
argument_list|,
name|tfp
argument_list|,
expr|struct
name|tblformat
argument_list|)
expr_stmt|;
name|tfp
operator|->
name|cols
operator|=
name|tblcols
expr_stmt|;
name|ep
operator|=
operator|(
name|rp
operator|->
name|necont
operator|)
condition|?
name|rp
operator|->
name|econt
index|[
literal|0
index|]
else|:
literal|0
expr_stmt|;
comment|/* first entry */
name|allProp
operator|=
name|TRUE
expr_stmt|;
name|totalProp
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|tblcols
condition|;
name|i
operator|++
control|)
block|{
name|tfp
operator|->
name|colformat
index|[
name|i
index|]
operator|=
name|TblGetAlign
argument_list|(
name|i
argument_list|,
name|ep
argument_list|,
name|source
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|tfp
operator|->
name|colwidth
index|[
name|i
index|]
argument_list|,
name|TblGetWidth
argument_list|(
name|i
argument_list|,
name|ep
argument_list|,
name|TRUE
argument_list|,
name|source
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|tfp
operator|->
name|colpwidth
index|[
name|i
index|]
argument_list|,
name|TblGetWidth
argument_list|(
name|i
argument_list|,
name|ep
argument_list|,
name|FALSE
argument_list|,
name|source
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|allProp
condition|)
block|{
name|allProp
operator|=
name|tfp
operator|->
name|colpwidth
index|[
name|i
index|]
index|[
literal|0
index|]
expr_stmt|;
name|totalProp
operator|+=
name|atof
argument_list|(
name|tfp
operator|->
name|colpwidth
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|tfp
operator|->
name|font
index|[
name|i
index|]
argument_list|,
name|TblGetFont
argument_list|(
name|i
argument_list|,
name|ep
argument_list|,
name|source
argument_list|)
argument_list|)
expr_stmt|;
name|tfp
operator|->
name|colsep
index|[
name|i
index|]
operator|=
name|tblgcolsep
operator|||
name|TblGetColSep
argument_list|(
name|i
argument_list|,
name|ep
argument_list|,
name|source
argument_list|)
expr_stmt|;
if|if
condition|(
name|addinRowsep
condition|)
name|tfp
operator|->
name|rowsep
index|[
name|i
index|]
operator|=
name|tblgrowsep
operator|||
name|TblGetRowSep
argument_list|(
name|i
argument_list|,
name|ep
argument_list|,
name|source
argument_list|)
expr_stmt|;
name|tfp
operator|->
name|moreRows
index|[
name|i
index|]
operator|=
name|TblGetMoreRows
argument_list|(
name|i
argument_list|,
name|ep
argument_list|,
name|source
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|<
name|rp
operator|->
name|necont
operator|)
operator|&&
name|TblColAdv
argument_list|(
name|i
argument_list|,
name|ep
argument_list|,
name|tfp
argument_list|,
name|source
argument_list|)
condition|)
block|{
name|ep
operator|=
name|rp
operator|->
name|econt
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
comment|/* turn proportional widths into real widths */
if|if
condition|(
name|allProp
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|tblcols
condition|;
name|i
operator|++
control|)
block|{
name|sprintf
argument_list|(
name|tfp
operator|->
name|colwidth
index|[
name|i
index|]
argument_list|,
literal|"%fi"
argument_list|,
operator|(
name|atof
argument_list|(
name|tfp
operator|->
name|colpwidth
index|[
name|i
index|]
argument_list|)
operator|/
name|totalProp
operator|)
operator|*
name|TEXTWIDTH
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|tfp
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*	TblGetAlign()  --  get alignment spec for a entry  *  */
end_comment

begin_function
name|char
name|TblGetAlign
parameter_list|(
name|short
name|col
parameter_list|,
comment|/* column number */
name|Element_t
modifier|*
name|entry
parameter_list|,
comment|/* the entry */
name|tblsource
name|source
parameter_list|)
comment|/* context */
block|{
specifier|register
name|struct
name|tblcolspec
modifier|*
name|tcsp
decl_stmt|;
specifier|register
name|struct
name|tblspanspec
modifier|*
name|tssp
decl_stmt|;
specifier|register
name|tblalign
name|talign
decl_stmt|;
if|if
condition|(
name|entry
operator|&&
operator|(
name|tssp
operator|=
name|TblEntrySpanSpec
argument_list|(
name|col
argument_list|,
name|entry
argument_list|,
name|source
argument_list|)
operator|)
condition|)
block|{
name|talign
operator|=
name|tssp
operator|->
name|align
expr_stmt|;
name|free
argument_list|(
name|tssp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|entry
operator|&&
operator|(
name|tcsp
operator|=
name|TblEntryColSpec
argument_list|(
name|col
argument_list|,
name|entry
argument_list|,
name|source
argument_list|)
operator|)
condition|)
block|{
name|talign
operator|=
name|tcsp
operator|->
name|align
expr_stmt|;
name|free
argument_list|(
name|tcsp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return
literal|'l'
return|;
block|}
switch|switch
condition|(
name|talign
condition|)
block|{
case|case
name|Left
case|:
return|return
literal|'l'
return|;
case|case
name|Right
case|:
return|return
literal|'r'
return|;
case|case
name|Center
case|:
return|return
literal|'c'
return|;
case|case
name|Justify
case|:
return|return
literal|'l'
return|;
case|case
name|Char
case|:
return|return
literal|'d'
return|;
case|case
name|Span
case|:
return|return
literal|'s'
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*	TblGetWidth()  --  get width spec, if any, for a entry  *  */
end_comment

begin_function
name|char
modifier|*
name|TblGetWidth
parameter_list|(
name|short
name|col
parameter_list|,
comment|/* column number */
name|Element_t
modifier|*
name|entry
parameter_list|,
comment|/* the entry */
name|bool
name|literal
parameter_list|,
comment|/* literal (or proportional) */
name|tblsource
name|source
parameter_list|)
comment|/* context */
block|{
specifier|register
name|struct
name|tblcolspec
modifier|*
name|tcsp
decl_stmt|;
specifier|register
name|struct
name|tblspanspec
modifier|*
name|tssp
decl_stmt|;
specifier|static
name|char
name|colWidth
index|[
literal|10
index|]
decl_stmt|;
name|colWidth
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|entry
operator|&&
operator|(
name|tcsp
operator|=
name|TblEntryColSpec
argument_list|(
name|col
argument_list|,
name|entry
argument_list|,
name|source
argument_list|)
operator|)
operator|&&
name|tcsp
operator|->
name|colwidth
index|[
literal|0
index|]
condition|)
block|{
if|if
condition|(
operator|!
name|strstr
argument_list|(
name|tcsp
operator|->
name|colwidth
argument_list|,
literal|"*"
argument_list|)
condition|)
block|{
if|if
condition|(
name|literal
condition|)
name|strcpy
argument_list|(
name|colWidth
argument_list|,
name|tcsp
operator|->
name|colwidth
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|literal
condition|)
name|strcpy
argument_list|(
name|colWidth
argument_list|,
name|tcsp
operator|->
name|colwidth
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|tcsp
argument_list|)
expr_stmt|;
block|}
return|return
name|colWidth
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*	TblGetFont()  --  get font spec, if any, for a entry  *  */
end_comment

begin_function
name|char
modifier|*
name|TblGetFont
parameter_list|(
name|short
name|col
parameter_list|,
comment|/* column number */
name|Element_t
modifier|*
name|entry
parameter_list|,
comment|/* the entry */
name|tblsource
name|source
parameter_list|)
comment|/* context */
block|{
specifier|register
name|struct
name|tblcolspec
modifier|*
name|tcsp
decl_stmt|;
specifier|register
name|struct
name|tblspanspec
modifier|*
name|tssp
decl_stmt|;
return|return
literal|""
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*	TblGetColSep()  --  get column separater spec, if any, for a entry  *  */
end_comment

begin_function
name|bool
name|TblGetColSep
parameter_list|(
name|short
name|col
parameter_list|,
comment|/* column number */
name|Element_t
modifier|*
name|entry
parameter_list|,
comment|/* the entry */
name|tblsource
name|source
parameter_list|)
comment|/* context */
block|{
specifier|register
name|struct
name|tblcolspec
modifier|*
name|tcsp
decl_stmt|;
specifier|register
name|struct
name|tblspanspec
modifier|*
name|tssp
decl_stmt|;
specifier|register
name|bool
name|colsep
decl_stmt|;
if|if
condition|(
name|entry
operator|&&
operator|(
name|tssp
operator|=
name|TblEntrySpanSpec
argument_list|(
name|col
argument_list|,
name|entry
argument_list|,
name|source
argument_list|)
operator|)
condition|)
block|{
name|colsep
operator|=
name|tssp
operator|->
name|colsep
expr_stmt|;
name|free
argument_list|(
name|tssp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|entry
operator|&&
operator|(
name|tcsp
operator|=
name|TblEntryColSpec
argument_list|(
name|col
argument_list|,
name|entry
argument_list|,
name|source
argument_list|)
operator|)
condition|)
block|{
name|colsep
operator|=
name|tcsp
operator|->
name|colsep
expr_stmt|;
name|free
argument_list|(
name|tcsp
argument_list|)
expr_stmt|;
block|}
else|else
name|colsep
operator|=
name|FALSE
expr_stmt|;
return|return
name|colsep
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*	TblGetRowSep()  --  get row separater spec, if any, for a entry  *  */
end_comment

begin_function
name|bool
name|TblGetRowSep
parameter_list|(
name|short
name|col
parameter_list|,
comment|/* column number */
name|Element_t
modifier|*
name|entry
parameter_list|,
comment|/* the entry */
name|tblsource
name|source
parameter_list|)
comment|/* context */
block|{
specifier|register
name|struct
name|tblcolspec
modifier|*
name|tcsp
decl_stmt|;
specifier|register
name|struct
name|tblspanspec
modifier|*
name|tssp
decl_stmt|;
specifier|register
name|bool
name|rowsep
decl_stmt|;
if|if
condition|(
name|entry
operator|&&
operator|(
name|tssp
operator|=
name|TblEntrySpanSpec
argument_list|(
name|col
argument_list|,
name|entry
argument_list|,
name|source
argument_list|)
operator|)
condition|)
block|{
name|rowsep
operator|=
name|tssp
operator|->
name|rowsep
expr_stmt|;
name|free
argument_list|(
name|tssp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|entry
operator|&&
operator|(
name|tcsp
operator|=
name|TblEntryColSpec
argument_list|(
name|col
argument_list|,
name|entry
argument_list|,
name|source
argument_list|)
operator|)
condition|)
block|{
name|rowsep
operator|=
name|tcsp
operator|->
name|rowsep
expr_stmt|;
name|free
argument_list|(
name|tcsp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rowsep
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|rowsep
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*	TblGetmoreRows()  --  get moreRows value  *  */
end_comment

begin_function
name|bool
name|TblGetMoreRows
parameter_list|(
name|short
name|col
parameter_list|,
comment|/* column number */
name|Element_t
modifier|*
name|entry
parameter_list|,
comment|/* the entry */
name|tblsource
name|source
parameter_list|)
comment|/* context */
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|cp
operator|=
name|FindAttValByName
argument_list|(
name|entry
argument_list|,
literal|"MOREROWS"
argument_list|)
condition|)
return|return
name|atoi
argument_list|(
name|cp
argument_list|)
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*	TblColAdv()  --  advance pointer to next entry, if appropriate  *  */
end_comment

begin_function
name|bool
name|TblColAdv
parameter_list|(
name|short
name|col
parameter_list|,
comment|/* the current column */
name|Element_t
modifier|*
name|ep
parameter_list|,
comment|/* pointer to entry */
name|struct
name|tblformat
modifier|*
name|tfp
parameter_list|,
comment|/* pointer to prevailing format */
name|tblsource
name|source
parameter_list|)
comment|/* context */
block|{
specifier|register
name|bool
name|bump
decl_stmt|;
specifier|register
name|struct
name|tblspanspec
modifier|*
name|tssp
decl_stmt|;
name|bump
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|tssp
operator|=
name|TblEntrySpanSpec
argument_list|(
name|col
argument_list|,
name|ep
argument_list|,
name|source
argument_list|)
condition|)
block|{
name|bump
operator|=
name|tssp
operator|->
name|align
operator|!=
name|Span
expr_stmt|;
name|free
argument_list|(
name|tssp
argument_list|)
expr_stmt|;
block|}
return|return
name|bump
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*	TblEntryColSpec()  --  get a completely localized colspec for an entry  *  */
end_comment

begin_function
name|struct
name|tblcolspec
modifier|*
name|TblEntryColSpec
parameter_list|(
name|short
name|num
parameter_list|,
comment|/* column number */
name|Element_t
modifier|*
name|ep
parameter_list|,
comment|/* entry */
name|tblsource
name|source
parameter_list|)
comment|/* context */
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|bool
name|throwAway
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|struct
name|tblcolspec
modifier|*
name|tcsp
decl_stmt|,
modifier|*
name|tcsp2
decl_stmt|;
name|tcsp
operator|=
name|tcsp2
operator|=
literal|0
expr_stmt|;
name|throwAway
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|FindAttValByName
argument_list|(
name|ep
argument_list|,
literal|"COLNAME"
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|tcsp
operator|=
name|TblFindColSpec
argument_list|(
name|cp
argument_list|,
name|source
argument_list|)
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"? can't find column name '%s'\n"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tcsp2
operator|=
name|TblFindColNum
argument_list|(
name|num
argument_list|,
name|source
argument_list|)
condition|)
block|{
name|tcsp
operator|=
name|TblDoColSpec
argument_list|(
name|num
argument_list|,
name|ep
argument_list|,
name|tcsp2
argument_list|,
name|source
argument_list|)
expr_stmt|;
name|throwAway
operator|=
name|TRUE
expr_stmt|;
block|}
name|tcsp2
operator|=
name|TblDoColSpec
argument_list|(
name|num
argument_list|,
name|ep
argument_list|,
name|tcsp
argument_list|,
name|source
argument_list|)
expr_stmt|;
if|if
condition|(
name|throwAway
condition|)
name|free
argument_list|(
name|tcsp
argument_list|)
expr_stmt|;
return|return
name|tcsp2
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*	TblEntrySpanSpec()  --  get a completely localized spanspec for an entry  *  */
end_comment

begin_function
name|struct
name|tblspanspec
modifier|*
name|TblEntrySpanSpec
parameter_list|(
name|short
name|num
parameter_list|,
comment|/* column number */
name|Element_t
modifier|*
name|ep
parameter_list|,
comment|/* entry */
name|tblsource
name|source
parameter_list|)
comment|/* context */
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|cp2
decl_stmt|;
specifier|register
name|struct
name|tblspanspec
modifier|*
name|tssp
decl_stmt|,
modifier|*
name|tssp2
decl_stmt|;
name|tssp2
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|cp
operator|=
name|FindAttValByName
argument_list|(
name|ep
argument_list|,
literal|"SPANNAME"
argument_list|)
operator|)
operator|||
operator|!
operator|(
name|tssp2
operator|=
name|TblFindSpanSpec
argument_list|(
name|cp
argument_list|,
name|source
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|FindAttValByName
argument_list|(
name|ep
argument_list|,
literal|"NAMEST"
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
name|tssp
operator|=
name|TblDoSpanSpec
argument_list|(
name|ep
argument_list|,
name|tssp2
argument_list|,
name|source
argument_list|)
expr_stmt|;
if|if
condition|(
name|tssp
operator|->
name|start
operator|&&
name|tssp
operator|->
name|end
operator|&&
operator|(
name|tssp
operator|->
name|start
operator|->
name|num
operator|<
name|num
operator|)
operator|&&
operator|(
name|tssp
operator|->
name|end
operator|->
name|num
operator|>=
name|num
operator|)
condition|)
block|{
name|tssp
operator|->
name|align
operator|=
name|Span
expr_stmt|;
block|}
return|return
name|tssp
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*	TblFormatMatch()  --  compare two format rows for consistency  *  */
end_comment

begin_function
name|bool
name|TblFormatMatch
parameter_list|(
name|struct
name|tblformat
modifier|*
name|tf1
parameter_list|,
comment|/* one row */
name|struct
name|tblformat
modifier|*
name|tf2
parameter_list|)
comment|/* the other */
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|tf1
operator|->
name|cols
operator|!=
name|tf2
operator|->
name|cols
condition|)
block|{
return|return
name|FALSE
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|tf1
operator|->
name|cols
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|tf1
operator|->
name|colformat
index|[
name|i
index|]
operator|!=
name|tf2
operator|->
name|colformat
index|[
name|i
index|]
condition|)
block|{
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|tf1
operator|->
name|colwidth
index|[
name|i
index|]
argument_list|,
name|tf2
operator|->
name|colwidth
index|[
name|i
index|]
argument_list|)
condition|)
block|{
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|tf1
operator|->
name|font
index|[
name|i
index|]
argument_list|,
name|tf2
operator|->
name|font
index|[
name|i
index|]
argument_list|)
condition|)
block|{
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|tf1
operator|->
name|colsep
index|[
name|i
index|]
operator|!=
name|tf2
operator|->
name|colsep
index|[
name|i
index|]
condition|)
block|{
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|tf1
operator|->
name|rowsep
index|[
name|i
index|]
operator|!=
name|tf2
operator|->
name|rowsep
index|[
name|i
index|]
condition|)
block|{
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|tf1
operator|->
name|moreRows
index|[
name|i
index|]
operator|||
name|tf2
operator|->
name|moreRows
index|[
name|i
index|]
condition|)
block|{
return|return
name|FALSE
return|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*	TblPrintFormat()  --  print a tbl format structure  *  */
end_comment

begin_function
name|void
name|TblPrintFormat
parameter_list|(
name|FILE
modifier|*
name|fP
parameter_list|,
comment|/* where to print */
name|struct
name|tblformat
modifier|*
name|tfp
parameter_list|)
comment|/* the structure */
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|tblformat
modifier|*
name|tfp2
decl_stmt|,
modifier|*
name|tfp3
decl_stmt|;
specifier|static
name|char
name|buf
index|[
literal|3
index|]
init|=
literal|"\000\000"
decl_stmt|;
for|for
control|(
name|tfp2
operator|=
name|tfp
operator|,
name|tfp3
operator|=
literal|0
init|;
name|tfp2
condition|;
name|tfp2
operator|=
name|tfp2
operator|->
name|next
control|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|tfp
operator|->
name|cols
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|1
condition|)
name|OutputString
argument_list|(
literal|" "
argument_list|,
name|fP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tfp3
operator|&&
name|tfp3
operator|->
name|moreRows
index|[
name|i
index|]
condition|)
name|OutputString
argument_list|(
literal|"\\^"
argument_list|,
name|fP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
name|buf
index|[
literal|0
index|]
operator|=
name|tfp2
operator|->
name|colformat
index|[
name|i
index|]
expr_stmt|;
name|OutputString
argument_list|(
name|buf
argument_list|,
name|fP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tfp2
operator|->
name|colwidth
index|[
name|i
index|]
index|[
literal|0
index|]
condition|)
block|{
name|OutputString
argument_list|(
literal|"w("
argument_list|,
name|fP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|OutputString
argument_list|(
name|tfp2
operator|->
name|colwidth
index|[
name|i
index|]
argument_list|,
name|fP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|OutputString
argument_list|(
literal|")"
argument_list|,
name|fP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tfp2
operator|->
name|font
index|[
name|i
index|]
index|[
literal|0
index|]
condition|)
name|OutputString
argument_list|(
name|tfp2
operator|->
name|font
index|[
name|i
index|]
argument_list|,
name|fP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tfp2
operator|->
name|colsep
index|[
name|i
index|]
condition|)
name|OutputString
argument_list|(
literal|"|"
argument_list|,
name|fP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|tfp2
operator|->
name|next
condition|)
name|OutputString
argument_list|(
literal|"."
argument_list|,
name|fP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|OutputString
argument_list|(
literal|"^"
argument_list|,
name|fP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tfp3
operator|=
name|tfp2
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*      TblTRowStart()  --  start a row (not much to do)  *  *  TO DO:  *  *	nothing..  *  */
end_comment

begin_function
name|void
name|TblTRowStart
parameter_list|(
name|Element_t
modifier|*
name|ep
parameter_list|,
name|FILE
modifier|*
name|fP
parameter_list|)
block|{
comment|/* nothing to do */
name|tblrow
operator|++
expr_stmt|;
comment|/* except note that we're within a new row */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*      TblTRowEnd()  --  end a row  *  *  TO DO:  *  *	output a row end character (newline)  *	if the current row had a rowsep, then output a "fake" row  *	with underlines in the proper place(s).  */
end_comment

begin_function
name|void
name|TblTRowEnd
parameter_list|(
name|Element_t
modifier|*
name|ep
parameter_list|,
name|FILE
modifier|*
name|fP
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|k
decl_stmt|;
specifier|register
name|tblsource
name|source
decl_stmt|;
specifier|register
name|bool
name|startedRow
decl_stmt|,
name|didSep
decl_stmt|;
specifier|register
name|struct
name|tblformat
modifier|*
name|rfp
decl_stmt|;
name|OutputString
argument_list|(
literal|"^"
argument_list|,
name|fP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* get the format for this row */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ep
operator|->
name|parent
operator|->
name|gi
argument_list|,
literal|"TFoot"
argument_list|)
condition|)
name|source
operator|=
name|TFoot
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ep
operator|->
name|parent
operator|->
name|gi
argument_list|,
literal|"THead"
argument_list|)
condition|)
name|source
operator|=
name|THead
expr_stmt|;
else|else
name|source
operator|=
name|TBody
expr_stmt|;
name|rfp
operator|=
name|TblBuild1Format
argument_list|(
name|ep
argument_list|,
name|TRUE
argument_list|,
name|source
argument_list|)
expr_stmt|;
name|startedRow
operator|=
name|FALSE
expr_stmt|;
name|didSep
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|formP
operator|->
name|cols
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|rfp
operator|->
name|rowsep
index|[
name|i
index|]
operator|||
operator|(
name|didSep
operator|&&
operator|(
name|rfp
operator|->
name|colformat
index|[
name|i
index|]
operator|==
literal|'s'
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|startedRow
condition|)
block|{
name|OutputString
argument_list|(
literal|"^"
argument_list|,
name|fP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|1
init|;
name|k
operator|<
name|i
condition|;
name|k
operator|++
control|)
name|OutputString
argument_list|(
literal|"\007"
argument_list|,
name|fP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|startedRow
operator|=
name|TRUE
expr_stmt|;
block|}
name|OutputString
argument_list|(
literal|"_\007"
argument_list|,
name|fP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|didSep
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|startedRow
condition|)
name|OutputString
argument_list|(
literal|"\007"
argument_list|,
name|fP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|didSep
operator|=
name|FALSE
expr_stmt|;
block|}
name|free
argument_list|(
name|rfp
argument_list|)
expr_stmt|;
comment|/* clear that row.. */
if|if
condition|(
name|startedRow
condition|)
name|OutputString
argument_list|(
literal|"^"
argument_list|,
name|fP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*      TblTEntryStart()  --  start an entry (block of filled text if  *				appropriate)  *  *  TO DO:  *  *	if text length> BOFTTextThresh or there is PI,  *	then output "T{\n", else do nothing  *  */
end_comment

begin_function
name|void
name|TblTCellStart
parameter_list|(
name|Element_t
modifier|*
name|ep
parameter_list|,
name|FILE
modifier|*
name|fP
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|Element_t
modifier|*
name|ep2
decl_stmt|;
specifier|register
name|bool
name|sawPI
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|sawPI
operator|=
name|FALSE
init|;
operator|(
name|i
operator|<
name|ep
operator|->
name|ncont
operator|)
operator|&&
operator|!
name|sawPI
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|ep
operator|->
name|cont
index|[
name|i
index|]
operator|.
name|type
operator|==
literal|'?'
condition|)
name|sawPI
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|sawPI
operator|||
operator|(
name|TblCountContent
argument_list|(
name|ep
argument_list|)
operator|>
name|BOFTTextThresh
operator|)
condition|)
block|{
name|tblBOFTCount
operator|++
expr_stmt|;
name|OutputString
argument_list|(
literal|"T{^"
argument_list|,
name|fP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tblinBOFT
operator|=
name|TRUE
expr_stmt|;
comment|/* within a boft now */
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*	TblCountContent()  --  count all content below the given element  *  *  */
end_comment

begin_function
name|int
name|TblCountContent
parameter_list|(
name|Element_t
modifier|*
name|ep
parameter_list|)
comment|/* the element to look under */
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|count
decl_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ep
operator|->
name|ncont
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ep
operator|->
name|cont
index|[
name|i
index|]
operator|.
name|type
operator|==
literal|'-'
condition|)
block|{
name|count
operator|+=
name|strlen
argument_list|(
name|ep
operator|->
name|cont
index|[
name|i
index|]
operator|.
name|ch
operator|.
name|data
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ep
operator|->
name|cont
index|[
name|i
index|]
operator|.
name|type
operator|==
literal|'('
condition|)
block|{
name|count
operator|+=
name|TblCountContent
argument_list|(
name|ep
operator|->
name|cont
index|[
name|i
index|]
operator|.
name|ch
operator|.
name|elem
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|count
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*      TblTEntryEnd()  --  end an entry  *  *  TO DO:  *  *	if within BOFT, output "T}"  *	if not last entry, output tab character  *  */
end_comment

begin_function
name|void
name|TblTCellEnd
parameter_list|(
name|Element_t
modifier|*
name|ep
parameter_list|,
name|FILE
modifier|*
name|fP
parameter_list|)
block|{
specifier|register
name|Element_t
modifier|*
name|ep2
decl_stmt|;
if|if
condition|(
name|tblinBOFT
condition|)
block|{
name|OutputString
argument_list|(
literal|"^T}"
argument_list|,
name|fP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tblinBOFT
operator|=
name|FALSE
expr_stmt|;
comment|/* back out again */
block|}
for|for
control|(
name|ep2
operator|=
name|ep
operator|->
name|next
init|;
name|ep2
condition|;
name|ep2
operator|=
name|ep2
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ep2
operator|->
name|gi
argument_list|,
literal|"ENTRY"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|ep2
operator|->
name|gi
argument_list|,
literal|"ENTRYTBL"
argument_list|)
condition|)
block|{
name|OutputString
argument_list|(
literal|"\007"
argument_list|,
name|fP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ep2
operator|->
name|gi
argument_list|,
literal|"ROW"
argument_list|)
condition|)
break|break;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*	TblDoColSpec()  --  process one element to create a new colspec  *  *  */
end_comment

begin_function
name|struct
name|tblcolspec
modifier|*
name|TblDoColSpec
parameter_list|(
name|short
name|number
parameter_list|,
comment|/* this column number */
name|Element_t
modifier|*
name|ep
parameter_list|,
comment|/* element containing colspec stuff */
name|struct
name|tblcolspec
modifier|*
name|pcsp
parameter_list|,
comment|/* prevailing colspec (with defaults) */
name|tblsource
name|source
parameter_list|)
comment|/* precedence level of the resulting spec */
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|struct
name|tblcolspec
modifier|*
name|tcsp
decl_stmt|;
name|Calloc
argument_list|(
literal|1
argument_list|,
name|tcsp
argument_list|,
expr|struct
name|tblcolspec
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|=
name|FindAttValByName
argument_list|(
name|ep
argument_list|,
literal|"COLNAME"
argument_list|)
condition|)
name|strcpy
argument_list|(
name|tcsp
operator|->
name|name
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|tcsp
operator|->
name|num
operator|=
name|number
expr_stmt|;
name|tcsp
operator|->
name|source
operator|=
name|source
expr_stmt|;
if|if
condition|(
name|cp
operator|=
name|FindAttValByName
argument_list|(
name|ep
argument_list|,
literal|"ALIGN"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|cp
argument_list|,
literal|"LEFT"
argument_list|)
condition|)
name|tcsp
operator|->
name|align
operator|=
name|Left
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|cp
argument_list|,
literal|"RIGHT"
argument_list|)
condition|)
name|tcsp
operator|->
name|align
operator|=
name|Right
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|cp
argument_list|,
literal|"CENTER"
argument_list|)
condition|)
name|tcsp
operator|->
name|align
operator|=
name|Center
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|cp
argument_list|,
literal|"JUSTIFY"
argument_list|)
condition|)
name|tcsp
operator|->
name|align
operator|=
name|Justify
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|cp
argument_list|,
literal|"CHAR"
argument_list|)
condition|)
name|tcsp
operator|->
name|align
operator|=
name|Char
expr_stmt|;
block|}
else|else
name|tcsp
operator|->
name|align
operator|=
operator|(
name|pcsp
operator|)
condition|?
name|pcsp
operator|->
name|align
else|:
name|Left
expr_stmt|;
if|if
condition|(
name|cp
operator|=
name|FindAttValByName
argument_list|(
name|ep
argument_list|,
literal|"CHAR"
argument_list|)
condition|)
name|tcsp
operator|->
name|alignchar
operator|=
name|cp
index|[
literal|0
index|]
expr_stmt|;
else|else
name|tcsp
operator|->
name|alignchar
operator|=
operator|(
name|pcsp
operator|)
condition|?
name|pcsp
operator|->
name|alignchar
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|cp
operator|=
name|FindAttValByName
argument_list|(
name|ep
argument_list|,
literal|"CHAROFF"
argument_list|)
condition|)
name|tcsp
operator|->
name|aligncharoff
operator|=
name|atoi
argument_list|(
name|cp
argument_list|)
expr_stmt|;
else|else
name|tcsp
operator|->
name|aligncharoff
operator|=
operator|(
name|pcsp
operator|)
condition|?
name|pcsp
operator|->
name|aligncharoff
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|cp
operator|=
name|FindAttValByName
argument_list|(
name|ep
argument_list|,
literal|"COLWIDTH"
argument_list|)
condition|)
name|strcpy
argument_list|(
name|tcsp
operator|->
name|colwidth
argument_list|,
name|cp
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|tcsp
operator|->
name|colwidth
argument_list|,
operator|(
name|pcsp
operator|)
condition|?
name|pcsp
operator|->
name|colwidth
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|=
name|FindAttValByName
argument_list|(
name|ep
argument_list|,
literal|"COLSEP"
argument_list|)
condition|)
name|tcsp
operator|->
name|colsep
operator|=
operator|!
name|strcmp
argument_list|(
name|cp
argument_list|,
literal|"1"
argument_list|)
expr_stmt|;
else|else
name|tcsp
operator|->
name|colsep
operator|=
operator|(
name|pcsp
operator|)
condition|?
name|pcsp
operator|->
name|colsep
else|:
name|FALSE
expr_stmt|;
if|if
condition|(
name|cp
operator|=
name|FindAttValByName
argument_list|(
name|ep
argument_list|,
literal|"ROWSEP"
argument_list|)
condition|)
name|tcsp
operator|->
name|rowsep
operator|=
operator|!
name|strcmp
argument_list|(
name|cp
argument_list|,
literal|"1"
argument_list|)
expr_stmt|;
else|else
name|tcsp
operator|->
name|rowsep
operator|=
operator|(
name|pcsp
operator|)
condition|?
name|pcsp
operator|->
name|rowsep
else|:
name|FALSE
expr_stmt|;
return|return
name|tcsp
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*	TblDoSpanSpec()  --  process one element to create a new spanspec  *  *	Note that there's a hack inside here...  NameSt and NameEnd are  *	supposed to point at colnames, but if no colname is found, this  *	code will look for a colnum by the same value.  */
end_comment

begin_function
name|struct
name|tblspanspec
modifier|*
name|TblDoSpanSpec
parameter_list|(
name|Element_t
modifier|*
name|ep
parameter_list|,
comment|/* element containing spanspec stuff */
name|struct
name|tblspanspec
modifier|*
name|pssp
parameter_list|,
comment|/* prevailing spanspec (with defaults) */
name|tblsource
name|source
parameter_list|)
comment|/* precedence level of the resulting spec */
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|struct
name|tblspanspec
modifier|*
name|tssp
decl_stmt|;
specifier|register
name|struct
name|tblcolspec
modifier|*
name|tcsp
decl_stmt|;
name|Calloc
argument_list|(
literal|1
argument_list|,
name|tssp
argument_list|,
expr|struct
name|tblspanspec
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|=
name|FindAttValByName
argument_list|(
name|ep
argument_list|,
literal|"SPANNAME"
argument_list|)
condition|)
name|strcpy
argument_list|(
name|tssp
operator|->
name|name
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|tssp
operator|->
name|source
operator|=
name|source
expr_stmt|;
if|if
condition|(
name|cp
operator|=
name|FindAttValByName
argument_list|(
name|ep
argument_list|,
literal|"NAMEST"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|tcsp
operator|=
name|TblFindColSpec
argument_list|(
name|cp
argument_list|,
name|source
argument_list|)
operator|)
operator|||
operator|(
name|tcsp
operator|=
name|TblFindColNum
argument_list|(
name|atoi
argument_list|(
name|cp
argument_list|)
argument_list|,
name|source
argument_list|)
operator|)
condition|)
block|{
name|tssp
operator|->
name|start
operator|=
name|tcsp
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"? spanspec namest points to unknown column '%s'\n"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|tssp
operator|->
name|start
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|pssp
operator|&&
name|pssp
operator|->
name|start
condition|)
block|{
name|tssp
operator|->
name|start
operator|=
name|pssp
operator|->
name|start
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cp
operator|=
name|FindAttValByName
argument_list|(
name|ep
argument_list|,
literal|"NAMEEND"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|tcsp
operator|=
name|TblFindColSpec
argument_list|(
name|cp
argument_list|,
name|source
argument_list|)
operator|)
operator|||
operator|(
name|tcsp
operator|=
name|TblFindColNum
argument_list|(
name|atoi
argument_list|(
name|cp
argument_list|)
argument_list|,
name|source
argument_list|)
operator|)
condition|)
block|{
name|tssp
operator|->
name|end
operator|=
name|tcsp
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"? spanspec nameend points to unknown column '%s'\n"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|tssp
operator|->
name|end
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|pssp
operator|&&
name|pssp
operator|->
name|end
condition|)
block|{
name|tssp
operator|->
name|end
operator|=
name|pssp
operator|->
name|end
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cp
operator|=
name|FindAttValByName
argument_list|(
name|ep
argument_list|,
literal|"ALIGN"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|cp
argument_list|,
literal|"LEFT"
argument_list|)
condition|)
name|tssp
operator|->
name|align
operator|=
name|Left
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|cp
argument_list|,
literal|"RIGHT"
argument_list|)
condition|)
name|tssp
operator|->
name|align
operator|=
name|Right
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|cp
argument_list|,
literal|"CENTER"
argument_list|)
condition|)
name|tssp
operator|->
name|align
operator|=
name|Center
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|cp
argument_list|,
literal|"JUSTIFY"
argument_list|)
condition|)
name|tssp
operator|->
name|align
operator|=
name|Justify
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|cp
argument_list|,
literal|"CHAR"
argument_list|)
condition|)
name|tssp
operator|->
name|align
operator|=
name|Char
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|pssp
condition|)
name|tssp
operator|->
name|align
operator|=
name|pssp
operator|->
name|align
expr_stmt|;
block|}
if|if
condition|(
name|cp
operator|=
name|FindAttValByName
argument_list|(
name|ep
argument_list|,
literal|"CHAR"
argument_list|)
condition|)
name|tssp
operator|->
name|alignchar
operator|=
name|cp
index|[
literal|0
index|]
expr_stmt|;
else|else
block|{
if|if
condition|(
name|pssp
condition|)
name|tssp
operator|->
name|alignchar
operator|=
name|pssp
operator|->
name|alignchar
expr_stmt|;
block|}
if|if
condition|(
name|cp
operator|=
name|FindAttValByName
argument_list|(
name|ep
argument_list|,
literal|"CHAROFF"
argument_list|)
condition|)
name|tssp
operator|->
name|aligncharoff
operator|=
name|atoi
argument_list|(
name|cp
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|pssp
condition|)
name|tssp
operator|->
name|alignchar
operator|=
name|pssp
operator|->
name|alignchar
expr_stmt|;
block|}
if|if
condition|(
name|cp
operator|=
name|FindAttValByName
argument_list|(
name|ep
argument_list|,
literal|"COLSEP"
argument_list|)
condition|)
name|tssp
operator|->
name|colsep
operator|=
operator|!
name|strcmp
argument_list|(
name|cp
argument_list|,
literal|"1"
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|pssp
condition|)
name|tssp
operator|->
name|colsep
operator|=
name|pssp
operator|->
name|colsep
expr_stmt|;
block|}
if|if
condition|(
name|cp
operator|=
name|FindAttValByName
argument_list|(
name|ep
argument_list|,
literal|"ROWSEP"
argument_list|)
condition|)
name|tssp
operator|->
name|rowsep
operator|=
operator|!
name|strcmp
argument_list|(
name|cp
argument_list|,
literal|"1"
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|pssp
condition|)
name|tssp
operator|->
name|rowsep
operator|=
name|pssp
operator|->
name|rowsep
expr_stmt|;
block|}
return|return
name|tssp
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*	TblFindColSpec()  --  find a table colspec by name (colname)  *  */
end_comment

begin_function
name|struct
name|tblcolspec
modifier|*
name|TblFindColSpec
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
comment|/* the name we're looking for */
name|tblsource
name|source
parameter_list|)
comment|/* the context in which to find it */
block|{
specifier|register
name|struct
name|tblcolspec
modifier|*
name|tcsp
decl_stmt|;
comment|/* first, try to find the one in the right "source" */
for|for
control|(
name|tcsp
operator|=
name|tblColSpec
init|;
name|tcsp
condition|;
name|tcsp
operator|=
name|tcsp
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|tcsp
operator|->
name|source
operator|==
name|source
operator|)
operator|&&
operator|!
name|strcmp
argument_list|(
name|tcsp
operator|->
name|name
argument_list|,
name|name
argument_list|)
condition|)
return|return
name|tcsp
return|;
block|}
comment|/* else, try to find one from a TGroup.. */
for|for
control|(
name|tcsp
operator|=
name|tblColSpec
init|;
name|tcsp
condition|;
name|tcsp
operator|=
name|tcsp
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|tcsp
operator|->
name|source
operator|==
name|TGroup
operator|)
operator|&&
operator|!
name|strcmp
argument_list|(
name|tcsp
operator|->
name|name
argument_list|,
name|name
argument_list|)
condition|)
return|return
name|tcsp
return|;
block|}
comment|/* else not found.. */
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*	TblFindColNum()  --  find a table colspec by number  *  */
end_comment

begin_function
name|struct
name|tblcolspec
modifier|*
name|TblFindColNum
parameter_list|(
name|short
name|number
parameter_list|,
comment|/* the number we're looking for */
name|tblsource
name|source
parameter_list|)
comment|/* the context in which to find it */
block|{
specifier|register
name|struct
name|tblcolspec
modifier|*
name|tcsp
decl_stmt|;
comment|/* first, try to find the one in the right "source" */
for|for
control|(
name|tcsp
operator|=
name|tblColSpec
init|;
name|tcsp
condition|;
name|tcsp
operator|=
name|tcsp
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|tcsp
operator|->
name|num
operator|==
name|number
operator|)
operator|&&
operator|(
operator|(
name|tcsp
operator|->
name|source
operator|==
name|source
operator|)
operator|||
operator|(
operator|(
name|source
operator|==
name|THead
operator|)
operator|&&
operator|(
name|tcsp
operator|->
name|source
operator|==
name|TGroup
operator|)
operator|)
operator|)
condition|)
return|return
name|tcsp
return|;
block|}
comment|/* else, try to find one from a TGroup.. */
for|for
control|(
name|tcsp
operator|=
name|tblColSpec
init|;
name|tcsp
condition|;
name|tcsp
operator|=
name|tcsp
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|tcsp
operator|->
name|source
operator|==
name|TGroup
operator|)
operator|&&
operator|(
name|tcsp
operator|->
name|num
operator|==
name|number
operator|)
condition|)
return|return
name|tcsp
return|;
block|}
comment|/* else not found.. */
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*	TblFindSpanSpec()  --  find a table spanspec by name (spanname)  *  */
end_comment

begin_function
name|struct
name|tblspanspec
modifier|*
name|TblFindSpanSpec
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
comment|/* the name we're looking for */
name|tblsource
name|source
parameter_list|)
comment|/* the context in which to find it */
block|{
specifier|register
name|struct
name|tblspanspec
modifier|*
name|tssp
decl_stmt|;
comment|/* first, try to find the one in the right "source" */
for|for
control|(
name|tssp
operator|=
name|tblSpanSpec
init|;
name|tssp
condition|;
name|tssp
operator|=
name|tssp
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|tssp
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|&&
operator|(
operator|(
name|tssp
operator|->
name|source
operator|==
name|source
operator|)
operator|||
operator|(
operator|(
name|source
operator|==
name|THead
operator|)
operator|&&
operator|(
name|tssp
operator|->
name|source
operator|==
name|TGroup
operator|)
operator|)
operator|)
condition|)
return|return
name|tssp
return|;
block|}
comment|/* else not found.. */
return|return
literal|0
return|;
block|}
end_function

end_unit

