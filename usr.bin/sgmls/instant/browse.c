begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  Copyright 1993 Open Software Foundation, Inc., Cambridge, Massachusetts.  *  All rights reserved.  */
end_comment

begin_comment
comment|/*  * Copyright (c) 1994    * Open Software Foundation, Inc.   *    * Permission is hereby granted to use, copy, modify and freely distribute   * the software in this file and its documentation for any purpose without   * fee, provided that the above copyright notice appears in all copies and   * that both the copyright notice and this permission notice appear in   * supporting documentation.  Further, provided that the name of Open   * Software Foundation, Inc. ("OSF") not be used in advertising or   * publicity pertaining to distribution of the software without prior   * written permission from OSF.  OSF makes no representations about the   * suitability of this software for any purpose.  It is provided "as is"   * without express or implied warranty.   */
end_comment

begin_comment
comment|/*  * Copyright (c) 1996 X Consortium  * Copyright (c) 1995, 1996 Dalrymple Consulting  *   * Permission is hereby granted, free of charge, to any person obtaining a copy  * of this software and associated documentation files (the "Software"), to deal  * in the Software without restriction, including without limitation the rights  * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell  * copies of the Software, and to permit persons to whom the Software is  * furnished to do so, subject to the following conditions:  *   * The above copyright notice and this permission notice shall be included in  * all copies or substantial portions of the Software.  *   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE  * X CONSORTIUM OR DALRYMPLE CONSULTING BE LIABLE FOR ANY CLAIM, DAMAGES OR  * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,  * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR  * OTHER DEALINGS IN THE SOFTWARE.  *   * Except as contained in this notice, the names of the X Consortium and  * Dalrymple Consulting shall not be used in advertising or otherwise to  * promote the sale, use or other dealings in this Software without prior  * written authorization.  */
end_comment

begin_comment
comment|/* ________________________________________________________________________  *  *  Module for interactive browsing.  *  *  Entry points for this module:  *	Browse()		interactive browser  * ________________________________________________________________________  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|RCSid
init|=
literal|"$Header: /usr/src/docbook-to-man/Instant/RCS/browse.c,v 1.2 1996/06/02 21:46:10 fld Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"general.h"
end_include

begin_function_decl
specifier|static
name|void
name|PrElemPlusID
parameter_list|(
name|Element_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ls_node
parameter_list|(
name|Element_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_query
parameter_list|(
name|Element_t
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_find
parameter_list|(
name|Element_t
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* ______________________________________________________________________ */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|br_help_msg
index|[]
init|=
block|{
literal|"  ls            List info about current element in tree"
block|,
literal|"                (context, children, attributes, etc.)"
block|,
literal|"  cd N ...      Change to Nth elememt child, where N is shown by 'ls'."
block|,
literal|"                N may also be '/' (top) or '..' (up)."
block|,
literal|"  cd id I       Change to elememt whose ID is I"
block|,
literal|"  data N        Show data of Nth data node"
block|,
literal|"  where         Show current position in the tree"
block|,
literal|"  id I          Show path to element with id I"
block|,
literal|"                (using '?' for I will lists all IDs and their paths)"
block|,
literal|"  find S        Find elements matching spec S. Recognized syntaxes:"
block|,
literal|"                  find attr<name><value>"
block|,
literal|"                  find cont<string>"
block|,
literal|"                  find parent<gi-name>"
block|,
literal|"                  find child<gi-name>"
block|,
literal|"                  find gi<gi-name>"
block|,
literal|"  q rel gi      Query: report if elem 'gi' has relation to current elem"
block|,
literal|"                ('rel' is one of 'child parent ancestor descendant"
block|,
literal|"                  sibling sibling+ sibling+1 sibling- sibling-1 cousin')"
block|,
literal|""
block|,
literal|"  tran [outfile]"
block|,
literal|"                Translate into 'outfile' (stdout)"
block|,
literal|"  stat          Print statistics (how often elements occur, etc.)"
block|,
literal|"  sum           Print elem usage summary (# of children, depth, etc.)"
block|,
literal|"  tree          Print document hierarchy as a tree"
block|,
literal|"  cont          Print context of each element"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ______________________________________________________________________ */
end_comment

begin_function
name|void
name|Browse
parameter_list|()
block|{
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|,
modifier|*
name|cmd
decl_stmt|,
modifier|*
modifier|*
name|av
decl_stmt|,
modifier|*
modifier|*
name|sv
decl_stmt|;
name|char
modifier|*
name|Prompt
decl_stmt|;
name|Element_t
modifier|*
name|ce
decl_stmt|;
comment|/* current element */
name|Element_t
modifier|*
name|e
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|,
name|ac
decl_stmt|;
if|if
condition|(
name|slave
condition|)
name|Prompt
operator|=
literal|"=>\n"
expr_stmt|;
else|else
name|Prompt
operator|=
literal|"=> "
expr_stmt|;
name|ce
operator|=
name|DocTree
expr_stmt|;
while|while
condition|(
name|fputs
argument_list|(
name|Prompt
argument_list|,
name|stdout
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|fgets
argument_list|(
name|buf
argument_list|,
literal|256
argument_list|,
name|stdin
argument_list|)
condition|)
break|break;
name|stripNL
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
name|EOS
condition|)
block|{
name|fputs
argument_list|(
name|Prompt
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|ac
operator|=
literal|20
expr_stmt|;
name|av
operator|=
name|Split
argument_list|(
name|buf
argument_list|,
operator|&
name|ac
argument_list|,
name|S_ALVEC
argument_list|)
expr_stmt|;
if|if
condition|(
name|ac
operator|>
literal|0
condition|)
name|cmd
operator|=
name|av
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|cmd
operator|||
operator|!
operator|(
operator|*
name|cmd
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|cmd
argument_list|,
literal|"ls"
argument_list|)
condition|)
name|ls_node
argument_list|(
name|ce
argument_list|,
name|ac
argument_list|,
name|av
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|cmd
argument_list|,
literal|"cd"
argument_list|)
condition|)
block|{
if|if
condition|(
name|av
index|[
literal|1
index|]
condition|)
block|{
if|if
condition|(
name|ac
operator|==
literal|3
operator|&&
operator|!
name|strcmp
argument_list|(
name|av
index|[
literal|1
index|]
argument_list|,
literal|"id"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|e
operator|=
name|FindElemByID
argument_list|(
name|av
index|[
literal|2
index|]
argument_list|)
operator|)
condition|)
name|ce
operator|=
name|e
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"Element with ID '%s' not found.\n"
argument_list|,
name|av
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
continue|continue;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|ac
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|av
index|[
name|i
index|]
argument_list|,
literal|".."
argument_list|)
condition|)
block|{
if|if
condition|(
name|ce
operator|->
name|parent
condition|)
name|ce
operator|=
name|ce
operator|->
name|parent
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|av
index|[
name|i
index|]
argument_list|,
literal|"/"
argument_list|)
condition|)
block|{
if|if
condition|(
name|ce
operator|->
name|parent
condition|)
name|ce
operator|=
name|DocTree
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
name|av
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Expecting digit, '..', or '/', got '%s'.\n"
argument_list|,
name|av
index|[
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
name|n
operator|=
name|atoi
argument_list|(
name|av
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
name|ce
operator|->
name|necont
condition|)
name|ce
operator|=
name|ce
operator|->
name|econt
index|[
name|n
index|]
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
literal|"Must be in range 0 - %d.\n"
argument_list|,
name|ce
operator|->
name|necont
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|cmd
argument_list|,
literal|"data"
argument_list|)
condition|)
block|{
if|if
condition|(
name|av
index|[
literal|1
index|]
operator|&&
name|isdigit
argument_list|(
operator|*
name|av
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|n
operator|=
name|atoi
argument_list|(
name|av
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
name|ce
operator|->
name|ndcont
condition|)
block|{
name|printf
argument_list|(
name|ce
operator|->
name|dcont
index|[
name|n
index|]
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ce
operator|->
name|ndcont
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"No data at this node.\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"Must be in range 0 - %d.\n"
argument_list|,
name|ce
operator|->
name|ndcont
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* show where we are in the tree */
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|cmd
argument_list|,
literal|"where"
argument_list|)
condition|)
name|PrintLocation
argument_list|(
name|ce
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
comment|/* show where we are in the tree */
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|cmd
argument_list|,
literal|"pwd"
argument_list|)
condition|)
name|PrElemPlusID
argument_list|(
name|ce
argument_list|)
expr_stmt|;
comment|/* perform query with yes/no answer */
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|cmd
argument_list|,
literal|"q"
argument_list|)
operator|&&
name|av
index|[
literal|1
index|]
operator|&&
name|av
index|[
literal|2
index|]
condition|)
name|do_query
argument_list|(
name|ce
argument_list|,
name|av
index|[
literal|1
index|]
argument_list|,
name|av
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
comment|/* perform query printing paths to matching elements */
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|cmd
argument_list|,
literal|"find"
argument_list|)
operator|&&
name|av
index|[
literal|1
index|]
operator|&&
name|av
index|[
literal|2
index|]
condition|)
name|do_find
argument_list|(
name|ce
argument_list|,
name|av
argument_list|)
expr_stmt|;
comment|/* list locations where specified ID(s) occur */
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|cmd
argument_list|,
literal|"id"
argument_list|)
condition|)
block|{
if|if
condition|(
name|ac
operator|<=
literal|1
condition|)
continue|continue;
if|if
condition|(
operator|*
name|av
index|[
literal|1
index|]
operator|==
literal|'?'
condition|)
name|PrintIDList
argument_list|()
expr_stmt|;
else|else
block|{
comment|/* short: "id i1 i2 ...", long: "id -l i1 i2 ..." */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|av
index|[
literal|1
index|]
argument_list|,
literal|"-l"
argument_list|)
condition|)
name|n
operator|=
literal|2
expr_stmt|;
else|else
name|n
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
name|n
init|;
name|i
operator|<
name|ac
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|e
operator|=
name|FindElemByID
argument_list|(
name|av
index|[
name|i
index|]
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|n
operator|==
literal|2
condition|)
block|{
comment|/* long (multiline) format */
if|if
condition|(
name|n
operator|!=
name|i
condition|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|PrintLocation
argument_list|(
name|e
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
else|else
name|PrElemPlusID
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"Element with ID '%s' not found.\n"
argument_list|,
name|av
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* show and set variables */
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|cmd
argument_list|,
literal|"show"
argument_list|)
operator|&&
name|av
index|[
literal|1
index|]
condition|)
block|{
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|FindMappingVal
argument_list|(
name|Variables
argument_list|,
name|av
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|cmd
argument_list|,
literal|"set"
argument_list|)
operator|&&
name|av
index|[
literal|1
index|]
operator|&&
name|av
index|[
literal|2
index|]
condition|)
block|{
name|SetMappingNV
argument_list|(
name|Variables
argument_list|,
name|av
index|[
literal|1
index|]
argument_list|,
name|av
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* print summary of tag usage */
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|cmd
argument_list|,
literal|"sum"
argument_list|)
condition|)
block|{
if|if
condition|(
name|ac
operator|>
literal|1
condition|)
name|PrintElemSummary
argument_list|(
name|ce
argument_list|)
expr_stmt|;
else|else
name|PrintElemSummary
argument_list|(
name|DocTree
argument_list|)
expr_stmt|;
block|}
comment|/* print element tree */
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|cmd
argument_list|,
literal|"tree"
argument_list|)
condition|)
block|{
if|if
condition|(
name|ac
operator|>
literal|1
condition|)
name|PrintElemTree
argument_list|(
name|ce
argument_list|)
expr_stmt|;
else|else
name|PrintElemTree
argument_list|(
name|DocTree
argument_list|)
expr_stmt|;
block|}
comment|/* print statistics */
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|cmd
argument_list|,
literal|"stat"
argument_list|)
condition|)
block|{
if|if
condition|(
name|ac
operator|>
literal|1
condition|)
name|PrintStats
argument_list|(
name|ce
argument_list|)
expr_stmt|;
else|else
name|PrintStats
argument_list|(
name|DocTree
argument_list|)
expr_stmt|;
block|}
comment|/* print context of each element of tree */
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|cmd
argument_list|,
literal|"cont"
argument_list|)
condition|)
block|{
if|if
condition|(
name|ac
operator|>
literal|1
condition|)
name|PrintContext
argument_list|(
name|ce
argument_list|)
expr_stmt|;
else|else
name|PrintContext
argument_list|(
name|DocTree
argument_list|)
expr_stmt|;
block|}
comment|/* print translation, given transpec */
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|cmd
argument_list|,
literal|"tran"
argument_list|)
condition|)
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
if|if
condition|(
name|ac
operator|>
literal|1
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|av
index|[
literal|1
index|]
argument_list|,
literal|"w"
argument_list|)
operator|)
condition|)
block|{
name|perror
argument_list|(
literal|"Can not open output file"
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
else|else
name|fp
operator|=
name|stdout
expr_stmt|;
name|DoTranslate
argument_list|(
name|ce
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ac
operator|>
literal|1
condition|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|cmd
argument_list|,
literal|"help"
argument_list|)
operator|||
operator|*
name|cmd
operator|==
literal|'?'
condition|)
block|{
name|sv
operator|=
name|br_help_msg
expr_stmt|;
while|while
condition|(
operator|*
name|sv
condition|)
name|puts
argument_list|(
operator|*
name|sv
operator|++
argument_list|)
expr_stmt|;
block|}
comment|/* quit (control-D also works) */
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|cmd
argument_list|,
literal|"quit"
argument_list|)
condition|)
break|break;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unknown command '%s' - ingored.\n"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
name|NL
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ______________________________________________________________________ */
end_comment

begin_comment
comment|/*  Do the "ls" command.  *  Arguments:  *	Pointer to element under consideration.  *	Arg count from command line (this command, not the shell command).  *	Arg vector.  */
end_comment

begin_function
specifier|static
name|void
name|ls_node
parameter_list|(
name|Element_t
modifier|*
name|e
parameter_list|,
name|int
name|ac
parameter_list|,
name|char
modifier|*
modifier|*
name|av
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|char
name|buf
index|[
name|LINESIZE
index|]
decl_stmt|;
if|if
condition|(
name|ac
operator|>
literal|1
operator|&&
operator|!
name|strcmp
argument_list|(
name|av
index|[
literal|1
index|]
argument_list|,
literal|"-n"
argument_list|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|e
operator|->
name|ncont
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|IsContElem
argument_list|(
name|e
argument_list|,
name|i
argument_list|)
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|ContElem
argument_list|(
name|e
argument_list|,
name|i
argument_list|)
operator|->
name|gi
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|IsContData
argument_list|(
name|e
argument_list|,
name|i
argument_list|)
condition|)
name|printf
argument_list|(
literal|"#data %s\n"
argument_list|,
name|ContData
argument_list|(
name|e
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|IsContPI
argument_list|(
name|e
argument_list|,
name|i
argument_list|)
condition|)
name|printf
argument_list|(
literal|"#pi %s\n"
argument_list|,
name|ContData
argument_list|(
name|e
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|printf
argument_list|(
literal|"Element: %s\tLineNumber: %d\n"
argument_list|,
name|e
operator|->
name|gi
argument_list|,
name|e
operator|->
name|lineno
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|parent
condition|)
name|printf
argument_list|(
literal|"Context: %s\n"
argument_list|,
name|FindContext
argument_list|(
name|e
argument_list|,
literal|20
argument_list|,
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|natts
condition|)
block|{
name|printf
argument_list|(
literal|"%d attributes:\n"
argument_list|,
name|e
operator|->
name|natts
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|e
operator|->
name|natts
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"\t%2d: %s = '%s'\n"
argument_list|,
name|i
argument_list|,
name|e
operator|->
name|atts
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|e
operator|->
name|atts
index|[
name|i
index|]
operator|.
name|sval
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|e
operator|->
name|entity
condition|)
block|{
name|printf
argument_list|(
literal|"Entity& notation information:\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|entity
operator|->
name|ename
condition|)
name|printf
argument_list|(
literal|"Entity name:   %s\n"
argument_list|,
name|e
operator|->
name|entity
operator|->
name|ename
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|entity
operator|->
name|nname
condition|)
name|printf
argument_list|(
literal|"Notation name: %s\n"
argument_list|,
name|e
operator|->
name|entity
operator|->
name|nname
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|entity
operator|->
name|sysid
condition|)
name|printf
argument_list|(
literal|"Sys id:        %s\n"
argument_list|,
name|e
operator|->
name|entity
operator|->
name|sysid
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|entity
operator|->
name|pubid
condition|)
name|printf
argument_list|(
literal|"Pub id:        %s\n"
argument_list|,
name|e
operator|->
name|entity
operator|->
name|pubid
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|entity
operator|->
name|fname
condition|)
name|printf
argument_list|(
literal|"Filename:      %s\n"
argument_list|,
name|e
operator|->
name|entity
operator|->
name|fname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|e
operator|->
name|my_eorder
operator|>=
literal|0
condition|)
name|printf
argument_list|(
literal|"My order among my siblings: %d\n"
argument_list|,
name|e
operator|->
name|my_eorder
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|necont
condition|)
block|{
name|printf
argument_list|(
literal|"%d child element nodes:\n"
argument_list|,
name|e
operator|->
name|necont
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|e
operator|->
name|necont
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"\t%2d: %s\n"
argument_list|,
name|i
argument_list|,
name|e
operator|->
name|econt
index|[
name|i
index|]
operator|->
name|gi
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|e
operator|->
name|ndcont
condition|)
block|{
name|printf
argument_list|(
literal|"%d child data nodes:\n"
argument_list|,
name|e
operator|->
name|ndcont
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|e
operator|->
name|ndcont
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strlen
argument_list|(
name|e
operator|->
name|dcont
index|[
name|i
index|]
argument_list|)
operator|<
literal|40
condition|)
name|printf
argument_list|(
literal|"\t%2d: %s\n"
argument_list|,
name|i
argument_list|,
name|e
operator|->
name|dcont
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"\t%2d: %-40.40s...\n"
argument_list|,
name|i
argument_list|,
name|e
operator|->
name|dcont
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* ______________________________________________________________________ */
end_comment

begin_comment
comment|/*  Perform query.  Syntax: find relationship gi.  Tells whether gi has  *  given relationship to current element.  Result (message) sent to stdout.  *  Args:  *	Pointer to element under consideration.  *	Pointer to name of relationship. (see FindRelByName() for names)  *	Pointer to GI to look for.  */
end_comment

begin_function
specifier|static
name|void
name|do_query
parameter_list|(
name|Element_t
modifier|*
name|e
parameter_list|,
name|char
modifier|*
name|rel
parameter_list|,
name|char
modifier|*
name|gi
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|Relation_t
name|r
decl_stmt|;
name|Element_t
modifier|*
name|ep
decl_stmt|;
for|for
control|(
name|cp
operator|=
name|gi
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
if|if
condition|(
name|islower
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
operator|*
name|cp
operator|=
name|toupper
argument_list|(
operator|*
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|FindRelByName
argument_list|(
name|rel
argument_list|)
operator|)
operator|==
name|REL_Unknown
condition|)
block|{
return|return;
block|}
name|ep
operator|=
name|QRelation
argument_list|(
name|e
argument_list|,
name|gi
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s, '%s' is%s %s of '%s'.\n"
argument_list|,
operator|(
name|ep
condition|?
literal|"Yes"
else|:
literal|"No"
operator|)
argument_list|,
name|gi
argument_list|,
operator|(
name|ep
condition|?
literal|""
else|:
literal|" not"
operator|)
argument_list|,
name|rel
argument_list|,
name|e
operator|->
name|gi
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ______________________________________________________________________ */
end_comment

begin_comment
comment|/* Print path to the element and its ID (if it has one) on a single line.  *  Arguments:  *	Pointer to element under consideration.  */
end_comment

begin_function
specifier|static
name|void
name|PrElemPlusID
parameter_list|(
name|Element_t
modifier|*
name|e
parameter_list|)
block|{
name|char
name|buf
index|[
name|LINESIZE
index|]
decl_stmt|;
if|if
condition|(
name|e
operator|->
name|id
condition|)
name|printf
argument_list|(
literal|"%s -- ID=%s\n"
argument_list|,
name|FindElementPath
argument_list|(
name|e
argument_list|,
name|buf
argument_list|)
argument_list|,
name|e
operator|->
name|id
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|FindElementPath
argument_list|(
name|e
argument_list|,
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ______________________________________________________________________ */
end_comment

begin_comment
comment|/* Print path to the element and its ID (if it has one) on a single line.  *  Arguments:  *	Pointer to element under consideration.  */
end_comment

begin_function
specifier|static
name|void
name|match_gi
parameter_list|(
name|Element_t
modifier|*
name|e
parameter_list|,
name|char
modifier|*
modifier|*
name|av
parameter_list|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|av
index|[
literal|1
index|]
argument_list|,
name|e
operator|->
name|gi
argument_list|)
condition|)
name|PrElemPlusID
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  Shorthand for defining simple finctions, which are just interfaces to  *  calling QRelation().  DescendTree() only passes ptr to element. */
end_comment

begin_define
define|#
directive|define
name|MATCH
parameter_list|(
name|Fun
parameter_list|,
name|Rel
parameter_list|)
define|\
value|static void Fun(Element_t *e, char **av) \ 	{ if (QRelation(e, av[1], Rel)) PrElemPlusID(e);  }
end_define

begin_macro
name|MATCH
argument_list|(
argument|match_parent
argument_list|,
argument|REL_Parent
argument_list|)
end_macro

begin_macro
name|MATCH
argument_list|(
argument|match_child
argument_list|,
argument|REL_Child
argument_list|)
end_macro

begin_macro
name|MATCH
argument_list|(
argument|match_anc
argument_list|,
argument|REL_Ancestor
argument_list|)
end_macro

begin_macro
name|MATCH
argument_list|(
argument|match_desc
argument_list|,
argument|REL_Descendant
argument_list|)
end_macro

begin_macro
name|MATCH
argument_list|(
argument|match_sib
argument_list|,
argument|REL_Sibling
argument_list|)
end_macro

begin_function
specifier|static
name|void
name|match_attr
parameter_list|(
name|Element_t
modifier|*
name|e
parameter_list|,
name|char
modifier|*
modifier|*
name|av
parameter_list|)
block|{
name|char
modifier|*
name|atval
decl_stmt|;
if|if
condition|(
operator|(
name|atval
operator|=
name|FindAttValByName
argument_list|(
name|e
argument_list|,
name|av
index|[
literal|1
index|]
argument_list|)
operator|)
operator|&&
operator|!
name|strcmp
argument_list|(
name|av
index|[
literal|2
index|]
argument_list|,
name|atval
argument_list|)
condition|)
name|PrElemPlusID
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|match_cont
parameter_list|(
name|Element_t
modifier|*
name|e
parameter_list|,
name|char
modifier|*
modifier|*
name|av
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|e
operator|->
name|ncont
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|IsContData
argument_list|(
name|e
argument_list|,
name|i
argument_list|)
operator|&&
name|strstr
argument_list|(
name|ContData
argument_list|(
name|e
argument_list|,
name|i
argument_list|)
argument_list|,
name|av
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|PrElemPlusID
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  Find an element, given the criteria on its command line.  *  Arguments:  *	Pointer to element under consideration.  */
end_comment

begin_function
specifier|static
name|void
name|do_find
parameter_list|(
name|Element_t
modifier|*
name|e
parameter_list|,
name|char
modifier|*
modifier|*
name|av
parameter_list|)
block|{
name|av
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|av
index|[
literal|0
index|]
argument_list|,
literal|"."
argument_list|)
condition|)
name|av
operator|++
expr_stmt|;
else|else
name|e
operator|=
name|DocTree
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|av
index|[
literal|0
index|]
argument_list|,
literal|"gi"
argument_list|)
condition|)
name|DescendTree
argument_list|(
name|e
argument_list|,
name|match_gi
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|av
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|av
index|[
literal|0
index|]
argument_list|,
literal|"attr"
argument_list|)
condition|)
name|DescendTree
argument_list|(
name|e
argument_list|,
name|match_attr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|av
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|av
index|[
literal|0
index|]
argument_list|,
literal|"parent"
argument_list|)
condition|)
name|DescendTree
argument_list|(
name|e
argument_list|,
name|match_parent
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|av
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|av
index|[
literal|0
index|]
argument_list|,
literal|"child"
argument_list|)
condition|)
name|DescendTree
argument_list|(
name|e
argument_list|,
name|match_child
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|av
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|av
index|[
literal|0
index|]
argument_list|,
literal|"cont"
argument_list|)
condition|)
name|DescendTree
argument_list|(
name|e
argument_list|,
name|match_cont
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|av
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|av
index|[
literal|0
index|]
argument_list|,
literal|"sib"
argument_list|)
condition|)
name|DescendTree
argument_list|(
name|e
argument_list|,
name|match_sib
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|av
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|av
index|[
literal|0
index|]
argument_list|,
literal|"desc"
argument_list|)
condition|)
name|DescendTree
argument_list|(
name|e
argument_list|,
name|match_desc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|av
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|av
index|[
literal|0
index|]
argument_list|,
literal|"anc"
argument_list|)
condition|)
name|DescendTree
argument_list|(
name|e
argument_list|,
name|match_anc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|av
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unknown find command: %s.\n"
argument_list|,
name|av
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ______________________________________________________________________ */
end_comment

end_unit

