begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* msgcat.c -    X/Open message catalogue functions and gencat utility.       Written by James Clark (jjc@jclark.com). */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_CAT
end_ifndef

begin_comment
comment|/* In this implementation the message catalogue format is the same as the message text source file format (see pp 42-43 of the X/Open Portability Guide, Issue 3, Volume 3.)  This means that you don't have to use the gencat utility, but it is still useful for checking and merging catalogues. */
end_comment

begin_comment
comment|/* Compile this with -DGENCAT to get the gencat utility. */
end_comment

begin_include
include|#
directive|include
file|"std.h"
end_include

begin_include
include|#
directive|include
file|"msgcat.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|USE_PROTOTYPES
end_ifdef

begin_define
define|#
directive|define
name|P
parameter_list|(
name|parms
parameter_list|)
value|parms
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|P
parameter_list|(
name|parms
parameter_list|)
value|()
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|USE_ISASCII
end_ifdef

begin_define
define|#
directive|define
name|ISASCII
parameter_list|(
name|c
parameter_list|)
value|isascii(c)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ISASCII
parameter_list|(
name|c
parameter_list|)
value|(1)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Default message set. */
end_comment

begin_define
define|#
directive|define
name|NL_SETD
value|1
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|PATH_FILE_SEP
end_ifndef

begin_define
define|#
directive|define
name|PATH_FILE_SEP
value|':'
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DEFAULT_NLSPATH
end_ifndef

begin_define
define|#
directive|define
name|DEFAULT_NLSPATH
value|""
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DEFAULT_LANG
end_ifndef

begin_define
define|#
directive|define
name|DEFAULT_LANG
value|"default"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|HASH_TAB_SIZE
value|251
end_define

begin_struct
struct|struct
name|message
block|{
name|struct
name|message
modifier|*
name|next
decl_stmt|;
name|unsigned
name|msgnum
decl_stmt|;
name|unsigned
name|setnum
decl_stmt|;
name|char
modifier|*
name|text
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|cat
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|loaded
decl_stmt|;
name|int
name|bad
decl_stmt|;
name|struct
name|message
modifier|*
name|table
index|[
name|HASH_TAB_SIZE
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|char
modifier|*
name|read_buf
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|read_buf_len
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Errors that can be generated by read_catalog. */
end_comment

begin_enum
enum|enum
name|cat_err
block|{
name|E_ZERO
block|,
comment|/* not an error */
name|E_BADARG
block|,
name|E_NOMEM
block|,
name|E_NOSUCHCOMMAND
block|,
name|E_INPUT
block|,
name|E_EOF
block|,
name|E_BADSEP
block|,
name|E_BADLINE
block|}
enum|;
end_enum

begin_ifdef
ifdef|#
directive|ifdef
name|GENCAT
end_ifdef

begin_comment
comment|/* These must match enum cat_err. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|cat_errlist
index|[]
init|=
block|{
literal|"Error 0"
block|,
literal|"Invalid argument to command"
block|,
literal|"Out of memory"
block|,
literal|"Unrecognized command"
block|,
literal|"Input error"
block|,
literal|"Unexpected end of file"
block|,
literal|"Space or tab expected after message number"
block|,
literal|"Invalid line"
block|, }
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* GENCAT */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|GENCAT
end_ifndef

begin_comment
comment|/* The value of NLSPATH. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|nlspath
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The value of LANG. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|lang
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not GENCAT */
end_comment

begin_decl_stmt
specifier|static
name|int
name|current_lineno
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|enum
name|cat_err
name|cat_errno
init|=
name|E_ZERO
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|GENCAT
end_ifndef

begin_decl_stmt
specifier|static
name|void
name|load_catalog
name|P
argument_list|(
operator|(
expr|struct
name|cat
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|find_catalog
name|P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|read_catalog
name|P
argument_list|(
operator|(
name|FILE
operator|*
operator|,
expr|struct
name|message
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|delete_set
name|P
argument_list|(
operator|(
expr|struct
name|message
operator|*
operator|*
operator|,
name|unsigned
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|delete_message
name|P
argument_list|(
operator|(
expr|struct
name|message
operator|*
operator|*
operator|,
name|unsigned
operator|,
name|unsigned
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|hash
name|P
argument_list|(
operator|(
name|unsigned
name|setnum
operator|,
name|unsigned
name|msgnum
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|parse_text
name|P
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|GENCAT
end_ifndef

begin_function
name|nl_catd
name|catopen
parameter_list|(
name|name
parameter_list|,
name|oflag
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|oflag
decl_stmt|;
block|{
name|struct
name|cat
modifier|*
name|catp
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|name
condition|)
return|return
literal|0
return|;
name|catp
operator|=
operator|(
expr|struct
name|cat
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|catp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|catp
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HASH_TAB_SIZE
condition|;
name|i
operator|++
control|)
name|catp
operator|->
name|table
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|catp
operator|->
name|name
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|catp
operator|->
name|loaded
operator|=
literal|0
expr_stmt|;
name|catp
operator|->
name|bad
operator|=
literal|0
expr_stmt|;
name|strcpy
argument_list|(
name|catp
operator|->
name|name
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|nl_catd
operator|)
name|catp
return|;
block|}
end_function

begin_function
name|int
name|catclose
parameter_list|(
name|catd
parameter_list|)
name|nl_catd
name|catd
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|struct
name|cat
modifier|*
name|catp
init|=
operator|(
expr|struct
name|cat
operator|*
operator|)
name|catd
decl_stmt|;
if|if
condition|(
operator|!
name|catp
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HASH_TAB_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|message
modifier|*
name|p
decl_stmt|,
modifier|*
name|nextp
decl_stmt|;
for|for
control|(
name|p
operator|=
name|catp
operator|->
name|table
index|[
name|i
index|]
init|;
name|p
condition|;
name|p
operator|=
name|nextp
control|)
block|{
name|nextp
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|p
operator|->
name|text
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|catp
operator|->
name|name
condition|)
name|free
argument_list|(
name|catp
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|catp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|catgets
parameter_list|(
name|catd
parameter_list|,
name|setnum
parameter_list|,
name|msgnum
parameter_list|,
name|dflt
parameter_list|)
name|nl_catd
name|catd
decl_stmt|;
name|int
name|setnum
decl_stmt|,
name|msgnum
decl_stmt|;
name|char
modifier|*
name|dflt
decl_stmt|;
block|{
name|struct
name|message
modifier|*
name|p
decl_stmt|;
name|struct
name|cat
modifier|*
name|catp
decl_stmt|;
comment|/* setnum and msgnum are required to be>= 1. */
if|if
condition|(
operator|!
name|catd
operator|||
name|setnum
operator|<=
literal|0
operator|||
name|msgnum
operator|<=
literal|0
condition|)
return|return
name|dflt
return|;
name|catp
operator|=
operator|(
expr|struct
name|cat
operator|*
operator|)
name|catd
expr_stmt|;
if|if
condition|(
operator|!
name|catp
operator|->
name|loaded
condition|)
name|load_catalog
argument_list|(
name|catp
argument_list|)
expr_stmt|;
if|if
condition|(
name|catp
operator|->
name|bad
condition|)
return|return
name|dflt
return|;
for|for
control|(
name|p
operator|=
name|catp
operator|->
name|table
index|[
name|hash
argument_list|(
name|setnum
argument_list|,
name|msgnum
argument_list|)
index|]
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
if|if
condition|(
name|p
operator|->
name|msgnum
operator|==
name|msgnum
operator|&&
name|p
operator|->
name|setnum
operator|==
name|setnum
condition|)
break|break;
if|if
condition|(
operator|!
name|p
condition|)
return|return
name|dflt
return|;
return|return
name|p
operator|->
name|text
return|;
block|}
end_function

begin_function
specifier|static
name|VOID
name|load_catalog
parameter_list|(
name|catp
parameter_list|)
name|struct
name|cat
modifier|*
name|catp
decl_stmt|;
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
modifier|*
name|path
decl_stmt|;
name|catp
operator|->
name|loaded
operator|=
literal|1
expr_stmt|;
name|fp
operator|=
name|find_catalog
argument_list|(
name|catp
operator|->
name|name
argument_list|,
operator|&
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fp
condition|)
block|{
name|catp
operator|->
name|bad
operator|=
literal|1
expr_stmt|;
return|return;
block|}
name|current_lineno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|read_catalog
argument_list|(
name|fp
argument_list|,
name|catp
operator|->
name|table
argument_list|)
operator|<
literal|0
condition|)
name|catp
operator|->
name|bad
operator|=
literal|1
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|read_buf
condition|)
block|{
name|free
argument_list|(
name|read_buf
argument_list|)
expr_stmt|;
name|read_buf
operator|=
literal|0
expr_stmt|;
block|}
name|read_buf_len
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|FILE
modifier|*
name|find_catalog
parameter_list|(
name|name
parameter_list|,
name|pathp
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
modifier|*
name|pathp
decl_stmt|;
block|{
name|char
modifier|*
name|path
decl_stmt|;
if|if
condition|(
operator|!
name|name
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|nlspath
condition|)
block|{
name|nlspath
operator|=
name|getenv
argument_list|(
literal|"NLSPATH"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nlspath
condition|)
name|nlspath
operator|=
name|DEFAULT_NLSPATH
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|lang
condition|)
block|{
name|lang
operator|=
name|getenv
argument_list|(
literal|"LANG"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lang
condition|)
name|lang
operator|=
name|DEFAULT_LANG
expr_stmt|;
block|}
name|path
operator|=
name|nlspath
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|unsigned
name|len
init|=
literal|0
decl_stmt|;
for|for
control|(
name|p
operator|=
name|path
init|;
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
operator|*
name|p
operator|!=
name|PATH_FILE_SEP
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'%'
condition|)
block|{
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|'N'
condition|)
block|{
name|p
operator|++
expr_stmt|;
name|len
operator|+=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|'L'
condition|)
block|{
name|p
operator|++
expr_stmt|;
name|len
operator|+=
name|strlen
argument_list|(
name|lang
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|'%'
condition|)
block|{
name|p
operator|++
expr_stmt|;
name|len
operator|++
expr_stmt|;
block|}
else|else
name|len
operator|++
expr_stmt|;
block|}
else|else
name|len
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|try
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|s
operator|=
name|try
operator|=
name|malloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
return|return
literal|0
return|;
for|for
control|(
name|p
operator|=
name|path
init|;
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
operator|*
name|p
operator|!=
name|PATH_FILE_SEP
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'%'
condition|)
block|{
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|'N'
condition|)
block|{
name|p
operator|++
expr_stmt|;
name|strcpy
argument_list|(
name|s
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|s
operator|+=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|'L'
condition|)
block|{
name|p
operator|++
expr_stmt|;
name|strcpy
argument_list|(
name|s
argument_list|,
name|lang
argument_list|)
expr_stmt|;
name|s
operator|+=
name|strlen
argument_list|(
name|lang
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|'%'
condition|)
block|{
name|p
operator|++
expr_stmt|;
operator|*
name|s
operator|++
operator|=
literal|'%'
expr_stmt|;
block|}
else|else
operator|*
name|s
operator|++
operator|=
operator|*
name|p
expr_stmt|;
block|}
else|else
operator|*
name|s
operator|++
operator|=
operator|*
name|p
expr_stmt|;
block|}
operator|*
name|s
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|fp
operator|=
name|fopen
argument_list|(
name|try
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
condition|)
block|{
operator|*
name|pathp
operator|=
name|try
expr_stmt|;
return|return
name|fp
return|;
block|}
name|free
argument_list|(
name|try
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
break|break;
name|path
operator|=
operator|++
name|p
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not GENCAT */
end_comment

begin_comment
comment|/* 0 success, -1 error */
end_comment

begin_function
specifier|static
name|int
name|parse_message
parameter_list|(
name|c
parameter_list|,
name|fp
parameter_list|,
name|table
parameter_list|,
name|setnum
parameter_list|,
name|quote
parameter_list|)
name|int
name|c
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|struct
name|message
modifier|*
modifier|*
name|table
decl_stmt|;
name|unsigned
name|setnum
decl_stmt|;
name|int
name|quote
decl_stmt|;
block|{
name|unsigned
name|msgnum
decl_stmt|;
name|struct
name|message
modifier|*
name|msgp
decl_stmt|;
name|char
modifier|*
name|text
decl_stmt|;
name|int
name|hc
decl_stmt|;
name|msgnum
operator|=
name|c
operator|-
literal|'0'
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
break|break;
name|msgnum
operator|=
name|msgnum
operator|*
literal|10
operator|+
operator|(
name|c
operator|-
literal|'0'
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
name|delete_message
argument_list|(
name|table
argument_list|,
name|setnum
argument_list|,
name|msgnum
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|c
operator|!=
literal|' '
operator|&&
name|c
operator|!=
literal|'\t'
condition|)
block|{
name|cat_errno
operator|=
name|E_BADSEP
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|text
operator|=
name|parse_text
argument_list|(
name|fp
argument_list|,
name|quote
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|text
condition|)
return|return
operator|-
literal|1
return|;
name|hc
operator|=
name|hash
argument_list|(
name|setnum
argument_list|,
name|msgnum
argument_list|)
expr_stmt|;
for|for
control|(
name|msgp
operator|=
name|table
index|[
name|hc
index|]
init|;
name|msgp
condition|;
name|msgp
operator|=
name|msgp
operator|->
name|next
control|)
if|if
condition|(
name|msgp
operator|->
name|setnum
operator|==
name|setnum
operator|&&
name|msgp
operator|->
name|msgnum
operator|==
name|msgnum
condition|)
break|break;
if|if
condition|(
name|msgp
condition|)
name|free
argument_list|(
name|msgp
operator|->
name|text
argument_list|)
expr_stmt|;
else|else
block|{
name|msgp
operator|=
operator|(
expr|struct
name|message
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|msgp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|msgp
condition|)
block|{
name|cat_errno
operator|=
name|E_NOMEM
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|msgp
operator|->
name|next
operator|=
name|table
index|[
name|hc
index|]
expr_stmt|;
name|table
index|[
name|hc
index|]
operator|=
name|msgp
expr_stmt|;
name|msgp
operator|->
name|msgnum
operator|=
name|msgnum
expr_stmt|;
name|msgp
operator|->
name|setnum
operator|=
name|setnum
expr_stmt|;
block|}
name|msgp
operator|->
name|text
operator|=
name|text
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|parse_text
parameter_list|(
name|fp
parameter_list|,
name|quote
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
name|int
name|quote
decl_stmt|;
block|{
name|unsigned
name|i
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|c
decl_stmt|;
name|int
name|quoted
decl_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|quote
condition|)
block|{
name|quoted
operator|=
literal|1
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
else|else
name|quoted
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
control|)
block|{
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
block|{
name|cat_errno
operator|=
name|E_INPUT
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
block|}
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
break|break;
comment|/* XXX  	     Can quotes be used in quoted message text if protected by \ ?  	     Is it illegal to omit the closing quote if there's an opening 	     quote?  	     Is it illegal to have anything after a closing quote?  	  */
if|if
condition|(
name|quoted
operator|&&
name|c
operator|==
name|quote
condition|)
block|{
comment|/* Skip the rest of the line. */
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
literal|'\n'
condition|)
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
block|{
name|cat_errno
operator|=
name|E_INPUT
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
block|}
break|break;
block|}
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
name|int
name|d
decl_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
break|break;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\n'
case|:
name|current_lineno
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'n'
case|:
name|c
operator|=
literal|'\n'
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|c
operator|=
literal|'\b'
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|c
operator|=
literal|'\f'
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|c
operator|=
literal|'\t'
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|c
operator|=
literal|'\v'
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|c
operator|=
literal|'\r'
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
name|c
operator|=
literal|'\\'
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
name|c
operator|-=
literal|'0'
expr_stmt|;
name|d
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|>=
literal|'0'
operator|&&
name|d
operator|<=
literal|'7'
condition|)
block|{
name|c
operator|=
name|c
operator|*
literal|8
operator|+
name|d
operator|-
literal|'0'
expr_stmt|;
name|d
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|>=
literal|'0'
operator|&&
name|d
operator|<=
literal|'7'
condition|)
name|c
operator|=
name|c
operator|*
literal|8
operator|+
name|d
operator|-
literal|'0'
expr_stmt|;
elseif|else
if|if
condition|(
name|d
operator|!=
name|EOF
condition|)
name|ungetc
argument_list|(
name|d
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|d
operator|!=
name|EOF
condition|)
name|ungetc
argument_list|(
name|d
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
continue|continue;
comment|/* XXX */
break|break;
default|default:
comment|/* Ignore the quote. */
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|>=
name|read_buf_len
condition|)
block|{
if|if
condition|(
operator|!
name|read_buf
condition|)
name|read_buf
operator|=
name|malloc
argument_list|(
name|read_buf_len
operator|=
literal|40
argument_list|)
expr_stmt|;
else|else
name|read_buf
operator|=
name|realloc
argument_list|(
name|read_buf
argument_list|,
name|read_buf_len
operator|*=
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|read_buf
condition|)
block|{
name|cat_errno
operator|=
name|E_NOMEM
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|read_buf
index|[
name|i
operator|++
index|]
operator|=
name|c
expr_stmt|;
block|}
name|p
operator|=
name|malloc
argument_list|(
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
block|{
name|cat_errno
operator|=
name|E_NOMEM
expr_stmt|;
return|return
literal|0
return|;
block|}
name|memcpy
argument_list|(
name|p
argument_list|,
name|read_buf
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|p
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* 0 success, -1 error */
end_comment

begin_function
specifier|static
name|int
name|parse_command
parameter_list|(
name|fp
parameter_list|,
name|table
parameter_list|,
name|setnump
parameter_list|,
name|quotep
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
name|struct
name|message
modifier|*
modifier|*
name|table
decl_stmt|;
name|unsigned
modifier|*
name|setnump
decl_stmt|;
name|int
modifier|*
name|quotep
decl_stmt|;
block|{
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|;
if|if
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
literal|128
argument_list|,
name|fp
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|cat_errno
operator|=
name|ferror
argument_list|(
name|fp
argument_list|)
condition|?
name|E_INPUT
else|:
name|E_EOF
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|' '
operator|||
name|buf
index|[
literal|0
index|]
operator|==
literal|'\t'
operator|||
name|buf
index|[
literal|0
index|]
operator|==
literal|'\n'
condition|)
comment|/* a comment */
empty_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|buf
argument_list|,
literal|"set"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|sscanf
argument_list|(
name|buf
operator|+
literal|3
argument_list|,
literal|"%u"
argument_list|,
name|setnump
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|cat_errno
operator|=
name|E_BADARG
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|buf
argument_list|,
literal|"delset"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
block|{
name|unsigned
name|num
decl_stmt|;
if|if
condition|(
name|sscanf
argument_list|(
name|buf
operator|+
literal|6
argument_list|,
literal|"%u"
argument_list|,
operator|&
name|num
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|cat_errno
operator|=
name|E_BADARG
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|delete_set
argument_list|(
name|table
argument_list|,
name|num
argument_list|)
expr_stmt|;
operator|*
name|setnump
operator|=
name|NL_SETD
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|buf
argument_list|,
literal|"quote"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|p
init|=
name|buf
operator|+
literal|5
decl_stmt|;
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
comment|/* XXX should \ be allowed as the quote character? */
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
operator|||
operator|*
name|p
operator|==
literal|'\n'
condition|)
operator|*
name|quotep
operator|=
operator|-
literal|1
expr_stmt|;
else|else
operator|*
name|quotep
operator|=
operator|*
name|p
expr_stmt|;
block|}
else|else
block|{
name|cat_errno
operator|=
name|E_NOSUCHCOMMAND
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|strchr
argument_list|(
name|buf
argument_list|,
literal|'\n'
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
name|EOF
condition|)
empty_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|VOID
name|delete_set
parameter_list|(
name|table
parameter_list|,
name|setnum
parameter_list|)
name|struct
name|message
modifier|*
modifier|*
name|table
decl_stmt|;
name|unsigned
name|setnum
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HASH_TAB_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|message
modifier|*
name|p
decl_stmt|,
modifier|*
name|nextp
decl_stmt|;
for|for
control|(
name|p
operator|=
name|table
index|[
name|i
index|]
operator|,
name|table
index|[
name|i
index|]
operator|=
literal|0
init|;
name|p
condition|;
name|p
operator|=
name|nextp
control|)
block|{
name|nextp
operator|=
name|p
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|setnum
operator|==
name|setnum
condition|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
argument_list|)
expr_stmt|;
else|else
block|{
name|p
operator|->
name|next
operator|=
name|table
index|[
name|i
index|]
expr_stmt|;
name|table
index|[
name|i
index|]
operator|=
name|p
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|VOID
name|delete_message
parameter_list|(
name|table
parameter_list|,
name|setnum
parameter_list|,
name|msgnum
parameter_list|)
name|struct
name|message
modifier|*
modifier|*
name|table
decl_stmt|;
name|unsigned
name|setnum
decl_stmt|,
name|msgnum
decl_stmt|;
block|{
name|struct
name|message
modifier|*
modifier|*
name|pp
decl_stmt|;
for|for
control|(
name|pp
operator|=
operator|&
name|table
index|[
name|hash
argument_list|(
name|setnum
argument_list|,
name|msgnum
argument_list|)
index|]
init|;
operator|*
name|pp
condition|;
name|pp
operator|=
operator|&
operator|(
operator|*
name|pp
operator|)
operator|->
name|next
control|)
if|if
condition|(
operator|(
operator|*
name|pp
operator|)
operator|->
name|setnum
operator|==
name|setnum
operator|&&
operator|(
operator|*
name|pp
operator|)
operator|->
name|msgnum
operator|==
name|msgnum
condition|)
block|{
name|struct
name|message
modifier|*
name|p
init|=
operator|*
name|pp
decl_stmt|;
operator|*
name|pp
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|p
operator|->
name|text
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* 0 success, -1 error. On error cat_errno is set to the error number. */
end_comment

begin_function
specifier|static
name|int
name|read_catalog
parameter_list|(
name|fp
parameter_list|,
name|table
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
name|struct
name|message
modifier|*
modifier|*
name|table
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
name|unsigned
name|setnum
init|=
name|NL_SETD
decl_stmt|;
name|int
name|quote_char
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* start of line */
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
break|break;
operator|++
name|current_lineno
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|parse_message
argument_list|(
name|c
argument_list|,
name|fp
argument_list|,
name|table
argument_list|,
name|setnum
argument_list|,
name|quote_char
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'$'
condition|)
block|{
if|if
condition|(
name|parse_command
argument_list|(
name|fp
argument_list|,
name|table
argument_list|,
operator|&
name|setnum
argument_list|,
operator|&
name|quote_char
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|c
operator|!=
literal|'\n'
condition|)
block|{
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
name|EOF
condition|)
if|if
condition|(
name|c
operator|!=
literal|' '
operator|&&
name|c
operator|!=
literal|'\t'
condition|)
block|{
name|cat_errno
operator|=
name|E_BADLINE
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
break|break;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hash
parameter_list|(
name|setnum
parameter_list|,
name|msgnum
parameter_list|)
name|unsigned
name|setnum
decl_stmt|,
name|msgnum
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|setnum
operator|<<
literal|8
operator|)
operator|+
name|msgnum
operator|)
operator|%
name|HASH_TAB_SIZE
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|GENCAT
end_ifdef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|program_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|message_compare
name|P
argument_list|(
operator|(
name|UNIV
operator|,
name|UNIV
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_text
name|P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|usage
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|VARARGS
end_ifdef

begin_function_decl
specifier|static
name|void
name|fatal
parameter_list|()
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|void
name|fatal
name|P
argument_list|(
operator|(
name|char
operator|*
operator|,
operator|...
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|nmessages
decl_stmt|;
name|struct
name|message
modifier|*
modifier|*
name|list
decl_stmt|;
name|unsigned
name|setnum
decl_stmt|;
name|struct
name|message
modifier|*
name|table
index|[
name|HASH_TAB_SIZE
index|]
decl_stmt|;
name|program_name
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|argc
operator|<
literal|3
condition|)
name|usage
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HASH_TAB_SIZE
condition|;
name|i
operator|++
control|)
name|table
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
name|fp
operator|=
name|fopen
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fp
condition|)
block|{
if|if
condition|(
name|i
operator|>
literal|1
condition|)
name|fatal
argument_list|(
literal|"can't open `%s': %s"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|current_lineno
operator|=
literal|0
expr_stmt|;
name|cat_errno
operator|=
name|E_ZERO
expr_stmt|;
if|if
condition|(
name|read_catalog
argument_list|(
name|fp
argument_list|,
name|table
argument_list|)
operator|<
literal|0
condition|)
block|{
name|assert
argument_list|(
name|cat_errno
operator|!=
name|E_ZERO
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|cat_errno
operator|<
sizeof|sizeof
argument_list|(
name|cat_errlist
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|cat_errlist
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|fatal
argument_list|(
literal|"%s:%d: %s"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|,
name|current_lineno
argument_list|,
name|cat_errlist
index|[
name|cat_errno
index|]
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
name|errno
operator|=
literal|0
expr_stmt|;
name|fp
operator|=
name|fopen
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fp
condition|)
name|fatal
argument_list|(
literal|"can't open `%s' for output: %s"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|nmessages
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HASH_TAB_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|message
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|table
index|[
name|i
index|]
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
name|nmessages
operator|++
expr_stmt|;
block|}
name|list
operator|=
operator|(
expr|struct
name|message
operator|*
operator|*
operator|)
name|malloc
argument_list|(
name|nmessages
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|message
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|list
condition|)
name|fatal
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HASH_TAB_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|message
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|table
index|[
name|i
index|]
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
name|list
index|[
name|j
operator|++
index|]
operator|=
name|p
expr_stmt|;
block|}
name|assert
argument_list|(
name|j
operator|==
name|nmessages
argument_list|)
expr_stmt|;
name|qsort
argument_list|(
operator|(
name|UNIV
operator|)
name|list
argument_list|,
name|nmessages
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|message
operator|*
argument_list|)
argument_list|,
name|message_compare
argument_list|)
expr_stmt|;
name|setnum
operator|=
name|NL_SETD
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nmessages
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|message
modifier|*
name|p
init|=
name|list
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|setnum
operator|!=
name|setnum
condition|)
block|{
name|setnum
operator|=
name|p
operator|->
name|setnum
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"$set %u\n"
argument_list|,
name|setnum
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%u "
argument_list|,
name|p
operator|->
name|msgnum
argument_list|)
expr_stmt|;
name|print_text
argument_list|(
name|p
operator|->
name|text
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fclose
argument_list|(
name|fp
argument_list|)
operator|==
name|EOF
condition|)
name|fatal
argument_list|(
literal|"error closing `%s'"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|VOID
name|usage
parameter_list|()
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: %s catfile msgfile...\n"
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
ifdef|#
directive|ifdef
name|VARARGS
name|VOID
name|fatal
argument_list|(
name|va_alist
argument_list|)
name|va_dcl
else|#
directive|else
comment|/* not VARARGS */
name|VOID
name|fatal
argument_list|(
name|char
operator|*
name|message
argument_list|,
operator|...
argument_list|)
endif|#
directive|endif
comment|/* not VARARGS */
block|{
name|va_list
name|ap
decl_stmt|;
ifdef|#
directive|ifdef
name|VARARGS
name|char
modifier|*
name|message
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|message
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* not VARARGS */
name|va_start
argument_list|(
name|ap
argument_list|,
name|message
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not VARARGS */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|message
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_function
specifier|static
name|int
name|message_compare
parameter_list|(
name|p1
parameter_list|,
name|p2
parameter_list|)
name|UNIV
name|p1
decl_stmt|;
name|UNIV
name|p2
decl_stmt|;
block|{
name|struct
name|message
modifier|*
name|m1
init|=
operator|*
operator|(
expr|struct
name|message
operator|*
operator|*
operator|)
name|p1
decl_stmt|;
name|struct
name|message
modifier|*
name|m2
init|=
operator|*
operator|(
expr|struct
name|message
operator|*
operator|*
operator|)
name|p2
decl_stmt|;
if|if
condition|(
name|m1
operator|->
name|setnum
operator|<
name|m2
operator|->
name|setnum
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|m1
operator|->
name|setnum
operator|>
name|m2
operator|->
name|setnum
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|m1
operator|->
name|msgnum
operator|<
name|m2
operator|->
name|msgnum
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|m1
operator|->
name|msgnum
operator|>
name|m2
operator|->
name|msgnum
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|VOID
name|print_text
parameter_list|(
name|s
parameter_list|,
name|fp
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
for|for
control|(
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'\\'
condition|)
name|fputs
argument_list|(
literal|"\\\\"
argument_list|,
name|fp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ISASCII
argument_list|(
operator|*
name|s
argument_list|)
operator|&&
name|isprint
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|s
argument_list|)
condition|)
name|putc
argument_list|(
operator|*
name|s
argument_list|,
name|fp
argument_list|)
expr_stmt|;
else|else
block|{
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|'\n'
case|:
name|fputs
argument_list|(
literal|"\\n"
argument_list|,
name|fp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\b'
case|:
name|fputs
argument_list|(
literal|"\\b"
argument_list|,
name|fp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\f'
case|:
name|fputs
argument_list|(
literal|"\\f"
argument_list|,
name|fp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\t'
case|:
name|fputs
argument_list|(
literal|"\\t"
argument_list|,
name|fp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\v'
case|:
name|fputs
argument_list|(
literal|"\\v"
argument_list|,
name|fp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\r'
case|:
name|fputs
argument_list|(
literal|"\\r"
argument_list|,
name|fp
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\\%03o"
argument_list|,
operator|(
name|unsigned
name|char
operator|)
operator|*
name|s
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* GENCAT */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TEST
end_ifdef

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|nl_catd
name|catd
decl_stmt|;
name|int
name|msgnum
decl_stmt|,
name|setnum
decl_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: %s catalogue\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|catd
operator|=
name|catopen
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Enter set number, message number pairs:\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
while|while
condition|(
name|scanf
argument_list|(
literal|"%d %d"
argument_list|,
operator|&
name|setnum
argument_list|,
operator|&
name|msgnum
argument_list|)
operator|==
literal|2
condition|)
block|{
name|char
modifier|*
name|msg
init|=
name|catgets
argument_list|(
name|catd
argument_list|,
name|setnum
argument_list|,
name|msgnum
argument_list|,
literal|"<default>"
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Returned \"%s\"\n"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TEST */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not HAVE_CAT */
end_comment

begin_comment
comment|/* Local Variables: c-indent-level: 5 c-continued-statement-offset: 5 c-brace-offset: -5 c-argdecl-indent: 0 c-label-offset: -5 End: */
end_comment

end_unit

