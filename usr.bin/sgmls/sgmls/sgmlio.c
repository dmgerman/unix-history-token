begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* sgmlio.c -    IO functions for core parser.     Written by James Clark (jjc@jclark.com). */
end_comment

begin_comment
comment|/* SGML must see a file in which records start with RS and end with    RE, and EOFCHAR (Ctl-Z) is present at the end.  This module must    supply these characters if they are not naturally present in the    file.  SGML will open two files at a time: when an entity is    nested, the new file is opened before closing the old in order to    make sure the open is successful. If it is, the original open file    is closed temporarily (IOPEND); when the stack is popped, the new    file is closed and the original file is re-opened (IOCONT). SGML    will check error returns for the initial open of a file and all    reads, and for re-openings when the stack is popped, but not for    closes.  Returning<0 indicates an error; 0 or more is a successful    operation, except for IOREAD where the return value is the number    of characters read, and must exceed 0 to be successful.  The first    READ must always be successful, and normally consists of just    priming the buffer with EOBCHAR (or RS EOBCHAR).  SGMLIO must    assure that there is an EOBCHAR at the end of each block read,    except for the last block of the entity, which must have an    EOFCHAR.     SGML views an entity as a contiguous whole, without regard to its    actual form of storage.  SGMLIO supports entities that are    equivalent to a single file of one or more records, or to a    concatenation of files. */
end_comment

begin_comment
comment|/* Uses only stream I/O.  This module should be portable to most ANSI    systems. */
end_comment

begin_comment
comment|/* We try to ensure that if an IO operation fails, then errno will contain    a meaningful value (although it may be zero.) */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_O_NOINHERIT
end_ifdef

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<io.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_O_NOINHERIT */
end_comment

begin_include
include|#
directive|include
file|"sgmlaux.h"
end_include

begin_comment
comment|/* Include files for auxiliary functions.. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_O_NOINHERIT
end_ifdef

begin_define
define|#
directive|define
name|FOPENR
parameter_list|(
name|file
parameter_list|)
value|nifopen(file)
end_define

begin_decl_stmt
name|FILE
modifier|*
name|nifopen
name|P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not HAVE_O_NOINHERIT */
end_comment

begin_define
define|#
directive|define
name|FOPENR
parameter_list|(
name|file
parameter_list|)
value|fopen((file), "r")
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not HAVE_O_NOINHERIT */
end_comment

begin_struct
struct|struct
name|iofcb
block|{
comment|/* I/O file control block. */
name|FILE
modifier|*
name|fp
decl_stmt|;
comment|/* File handle. */
name|fpos_t
name|off
decl_stmt|;
comment|/* Offset in file of current read block. */
name|char
modifier|*
name|next
decl_stmt|;
comment|/* Next file (NULL if no more). */
name|char
modifier|*
name|file
decl_stmt|;
comment|/* Current file (no length byte). */
name|int
name|pendoff
decl_stmt|;
comment|/* Offset into line when file suspended. */
name|char
name|bol
decl_stmt|;
comment|/* Non-zero if currently at beginning of line. */
name|char
name|first
decl_stmt|;
comment|/* Non-zero if the first read.  */
name|char
name|wasbol
decl_stmt|;
comment|/* Non-zero if current block was at beginning of line. */
name|char
name|canseek
decl_stmt|;
name|UNCH
modifier|*
name|pendbuf
decl_stmt|;
comment|/* Saved partial buffer for suspended file 				 that can't be closed and reopened. */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|char
modifier|*
name|lastfile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The name of the last file closed. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|bufsize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Size of buffer passed to ioread(). */
end_comment

begin_decl_stmt
specifier|static
name|char
name|ismagic
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Table of magic chars that need to be prefixed 				 by DELNONCH. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|stdinused
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|nextstr
name|P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Iterate over list of strings. */
end_comment

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|openfile
name|P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|closefile
name|P
argument_list|(
operator|(
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|isreg
name|P
argument_list|(
operator|(
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|VOID
name|ioinit
parameter_list|(
name|swp
parameter_list|)
name|struct
name|switches
modifier|*
name|swp
decl_stmt|;
block|{
name|ismagic
index|[
name|EOBCHAR
index|]
operator|=
literal|1
expr_stmt|;
name|ismagic
index|[
name|EOFCHAR
index|]
operator|=
literal|1
expr_stmt|;
name|ismagic
index|[
name|EOS
index|]
operator|=
literal|1
expr_stmt|;
name|ismagic
index|[
operator|(
name|UNCH
operator|)
name|DELNONCH
index|]
operator|=
literal|1
expr_stmt|;
name|ismagic
index|[
operator|(
name|UNCH
operator|)
name|GENRECHAR
index|]
operator|=
literal|1
expr_stmt|;
name|bufsize
operator|=
name|swp
operator|->
name|swbufsz
expr_stmt|;
block|}
end_function

begin_function
name|int
name|ioopen
parameter_list|(
name|id
parameter_list|,
name|pp
parameter_list|)
name|UNIV
name|id
decl_stmt|;
name|UNIV
modifier|*
name|pp
decl_stmt|;
block|{
name|struct
name|iofcb
modifier|*
name|f
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|id
condition|)
return|return
operator|-
literal|1
return|;
name|s
operator|=
name|id
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|s
condition|)
return|return
operator|-
literal|1
return|;
name|f
operator|=
operator|(
expr|struct
name|iofcb
operator|*
operator|)
name|rmalloc
argument_list|(
operator|(
name|UNS
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|iofcb
argument_list|)
argument_list|)
expr_stmt|;
name|f
operator|->
name|file
operator|=
name|s
expr_stmt|;
name|f
operator|->
name|next
operator|=
name|nextstr
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|f
operator|->
name|fp
operator|=
name|openfile
argument_list|(
name|f
operator|->
name|file
argument_list|,
operator|&
name|f
operator|->
name|canseek
argument_list|)
expr_stmt|;
name|f
operator|->
name|bol
operator|=
literal|1
expr_stmt|;
name|f
operator|->
name|first
operator|=
literal|1
expr_stmt|;
name|f
operator|->
name|pendbuf
operator|=
literal|0
expr_stmt|;
operator|*
name|pp
operator|=
operator|(
name|UNIV
operator|)
name|f
expr_stmt|;
return|return
name|f
operator|->
name|fp
condition|?
literal|1
else|:
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|VOID
name|ioclose
parameter_list|(
name|p
parameter_list|)
name|UNIV
name|p
decl_stmt|;
block|{
name|struct
name|iofcb
modifier|*
name|f
init|=
operator|(
expr|struct
name|iofcb
operator|*
operator|)
name|p
decl_stmt|;
if|if
condition|(
name|f
operator|->
name|fp
condition|)
name|closefile
argument_list|(
name|f
operator|->
name|fp
argument_list|)
expr_stmt|;
name|lastfile
operator|=
name|f
operator|->
name|file
expr_stmt|;
name|frem
argument_list|(
operator|(
name|UNIV
operator|)
name|f
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|VOID
name|iopend
parameter_list|(
name|p
parameter_list|,
name|off
parameter_list|,
name|buf
parameter_list|)
name|UNIV
name|p
decl_stmt|;
name|int
name|off
decl_stmt|;
name|UNCH
modifier|*
name|buf
decl_stmt|;
block|{
name|struct
name|iofcb
modifier|*
name|f
init|=
operator|(
expr|struct
name|iofcb
operator|*
operator|)
name|p
decl_stmt|;
if|if
condition|(
operator|!
name|f
operator|->
name|canseek
condition|)
block|{
name|UNCH
modifier|*
name|s
decl_stmt|;
for|for
control|(
name|s
operator|=
name|buf
operator|+
name|off
init|;
operator|*
name|s
operator|!=
name|EOFCHAR
operator|&&
operator|*
name|s
operator|!=
name|EOBCHAR
condition|;
name|s
operator|++
control|)
empty_stmt|;
name|s
operator|++
expr_stmt|;
name|f
operator|->
name|pendbuf
operator|=
operator|(
name|UNCH
operator|*
operator|)
name|rmalloc
argument_list|(
call|(
name|UNS
call|)
argument_list|(
name|s
operator|-
name|buf
operator|-
name|off
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|UNIV
operator|)
name|f
operator|->
name|pendbuf
argument_list|,
call|(
name|UNIV
call|)
argument_list|(
name|buf
operator|+
name|off
argument_list|)
argument_list|,
call|(
name|UNS
call|)
argument_list|(
name|s
operator|-
name|buf
operator|-
name|off
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|f
operator|->
name|bol
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|wasbol
condition|)
block|{
if|if
condition|(
name|off
operator|==
literal|0
condition|)
name|f
operator|->
name|bol
operator|=
literal|1
expr_stmt|;
else|else
name|off
operator|--
expr_stmt|;
block|}
name|f
operator|->
name|pendoff
operator|=
name|off
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|fp
condition|)
block|{
name|fclose
argument_list|(
name|f
operator|->
name|fp
argument_list|)
expr_stmt|;
name|f
operator|->
name|fp
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|iocont
parameter_list|(
name|p
parameter_list|)
name|UNIV
name|p
decl_stmt|;
block|{
name|struct
name|iofcb
modifier|*
name|f
init|=
operator|(
expr|struct
name|iofcb
operator|*
operator|)
name|p
decl_stmt|;
name|int
name|c
init|=
name|EOF
decl_stmt|;
name|int
name|off
init|=
name|f
operator|->
name|pendoff
decl_stmt|;
if|if
condition|(
operator|!
name|f
operator|->
name|canseek
condition|)
return|return
literal|0
return|;
name|errno
operator|=
literal|0
expr_stmt|;
name|f
operator|->
name|fp
operator|=
name|FOPENR
argument_list|(
name|f
operator|->
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|f
operator|->
name|fp
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|fsetpos
argument_list|(
name|f
operator|->
name|fp
argument_list|,
operator|&
name|f
operator|->
name|off
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
while|while
condition|(
operator|--
name|off
operator|>=
literal|0
condition|)
block|{
name|c
operator|=
name|getc
argument_list|(
name|f
operator|->
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|EOF
operator|&&
name|ismagic
index|[
name|c
index|]
condition|)
name|off
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
name|f
operator|->
name|bol
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|f
operator|->
name|fp
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return -1 on error, otherwise the number of bytes read.  The strategy is to concatenate the files, insert a RS at the beginning of each line, and change each '\n' into a RE.  The returned data shouldn't cross a file boundary, otherwise error messages might be inaccurate.  The first read must always succeed. */
end_comment

begin_function
name|int
name|ioread
parameter_list|(
name|p
parameter_list|,
name|buf
parameter_list|,
name|newfilep
parameter_list|)
name|UNIV
name|p
decl_stmt|;
name|UNCH
modifier|*
name|buf
decl_stmt|;
name|int
modifier|*
name|newfilep
decl_stmt|;
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|struct
name|iofcb
modifier|*
name|f
init|=
operator|(
expr|struct
name|iofcb
operator|*
operator|)
name|p
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|int
name|c
decl_stmt|;
operator|*
name|newfilep
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|first
condition|)
block|{
name|buf
index|[
name|i
index|]
operator|=
name|EOBCHAR
expr_stmt|;
name|f
operator|->
name|first
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|f
operator|->
name|pendbuf
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|buf
index|[
name|i
index|]
operator|=
name|f
operator|->
name|pendbuf
index|[
name|i
index|]
operator|)
operator|!=
name|EOBCHAR
operator|&&
name|buf
index|[
name|i
index|]
operator|!=
name|EOFCHAR
condition|;
name|i
operator|++
control|)
empty_stmt|;
name|frem
argument_list|(
operator|(
name|UNIV
operator|)
name|f
operator|->
name|pendbuf
argument_list|)
expr_stmt|;
name|f
operator|->
name|pendbuf
operator|=
literal|0
expr_stmt|;
return|return
name|i
operator|+
literal|1
return|;
block|}
name|fp
operator|=
name|f
operator|->
name|fp
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|canseek
operator|&&
name|fgetpos
argument_list|(
name|fp
argument_list|,
operator|&
name|f
operator|->
name|off
argument_list|)
condition|)
name|f
operator|->
name|canseek
operator|=
literal|0
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|EOF
condition|)
break|break;
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|closefile
argument_list|(
name|fp
argument_list|)
operator|==
name|EOF
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|!
name|f
operator|->
name|next
condition|)
block|{
name|f
operator|->
name|fp
operator|=
literal|0
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
name|EOFCHAR
expr_stmt|;
return|return
literal|1
return|;
block|}
name|f
operator|->
name|file
operator|=
name|f
operator|->
name|next
expr_stmt|;
name|f
operator|->
name|next
operator|=
name|nextstr
argument_list|(
name|f
operator|->
name|next
argument_list|)
expr_stmt|;
operator|*
name|newfilep
operator|=
literal|1
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|fp
operator|=
name|f
operator|->
name|fp
operator|=
name|openfile
argument_list|(
name|f
operator|->
name|file
argument_list|,
operator|&
name|f
operator|->
name|canseek
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fp
condition|)
return|return
operator|-
literal|1
return|;
name|f
operator|->
name|bol
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|f
operator|->
name|bol
condition|)
block|{
name|f
operator|->
name|bol
operator|=
literal|0
expr_stmt|;
name|buf
index|[
name|i
operator|++
index|]
operator|=
name|RSCHAR
expr_stmt|;
name|f
operator|->
name|wasbol
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|f
operator|->
name|wasbol
operator|=
literal|0
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
name|f
operator|->
name|bol
operator|=
literal|1
expr_stmt|;
name|buf
index|[
name|i
operator|++
index|]
operator|=
name|RECHAR
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ismagic
index|[
name|c
index|]
condition|)
block|{
name|buf
index|[
name|i
operator|++
index|]
operator|=
name|DELNONCH
expr_stmt|;
name|buf
index|[
name|i
operator|++
index|]
operator|=
name|SHIFTNON
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
else|else
name|buf
index|[
name|i
operator|++
index|]
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|bufsize
operator|-
literal|2
condition|)
break|break;
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* This is in the middle of a line. */
break|break;
block|}
block|}
name|buf
index|[
name|i
operator|++
index|]
operator|=
name|EOBCHAR
expr_stmt|;
return|return
name|i
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|nextstr
parameter_list|(
name|p
parameter_list|)
name|char
modifier|*
name|p
decl_stmt|;
block|{
name|p
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
return|return
operator|*
operator|++
name|p
condition|?
name|p
else|:
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return the filename associated with p.  If p is NULL, return the filename of the last file closed. */
end_comment

begin_function
name|char
modifier|*
name|ioflid
parameter_list|(
name|p
parameter_list|)
name|UNIV
name|p
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|p
condition|)
return|return
name|lastfile
return|;
return|return
operator|(
operator|(
expr|struct
name|iofcb
operator|*
operator|)
name|p
operator|)
operator|->
name|file
return|;
block|}
end_function

begin_function
specifier|static
name|FILE
modifier|*
name|openfile
parameter_list|(
name|name
parameter_list|,
name|seekp
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|seekp
decl_stmt|;
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|STDINNAME
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|stdinused
condition|)
return|return
literal|0
return|;
name|stdinused
operator|=
literal|1
expr_stmt|;
operator|*
name|seekp
operator|=
literal|0
expr_stmt|;
return|return
name|stdin
return|;
block|}
name|fp
operator|=
name|FOPENR
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
condition|)
operator|*
name|seekp
operator|=
name|isreg
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
name|fp
return|;
block|}
end_function

begin_comment
comment|/* Return -1 on error, 0 otherwise. */
end_comment

begin_function
specifier|static
name|int
name|closefile
parameter_list|(
name|fp
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
if|if
condition|(
name|fp
operator|==
name|stdin
condition|)
block|{
name|stdinused
operator|=
literal|0
expr_stmt|;
name|clearerr
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
return|return
name|fclose
argument_list|(
name|fp
argument_list|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_O_NOINHERIT
end_ifdef

begin_comment
comment|/* This is the same as fopen(name, "r") except that it tells DOS that the file descriptor should not be inherited by child processes.  */
end_comment

begin_function
name|FILE
modifier|*
name|nifopen
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|int
name|fd
init|=
name|open
argument_list|(
name|name
argument_list|,
name|O_RDONLY
operator||
name|O_NOINHERIT
operator||
name|O_TEXT
argument_list|)
decl_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
return|return
literal|0
return|;
return|return
name|fdopen
argument_list|(
name|fd
argument_list|,
literal|"r"
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_O_NOINHERIT */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_STAT_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|S_ISREG
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|S_IFMT
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|S_IFREG
end_ifdef

begin_define
define|#
directive|define
name|S_ISREG
parameter_list|(
name|m
parameter_list|)
value|(((m)& S_IFMT) == S_IFREG)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* S_IFREG */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* S_IFMT */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not S_ISREG */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_SYS_STAT_H */
end_comment

begin_comment
comment|/* Return 1 if fp might be associated with a regular file.  0 otherwise.  We check this because on many Unix systems lseek() will succeed on a (pseudo-)terminal although terminals aren't seekable in the way we need. */
end_comment

begin_function
specifier|static
name|int
name|isreg
parameter_list|(
name|fp
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|S_ISREG
name|struct
name|stat
name|sb
decl_stmt|;
comment|/* This assumes that a system that has S_ISREG will also have         fstat() and fileno(). */
if|if
condition|(
name|fstat
argument_list|(
name|fileno
argument_list|(
name|fp
argument_list|)
argument_list|,
operator|&
name|sb
argument_list|)
operator|==
literal|0
condition|)
return|return
name|S_ISREG
argument_list|(
name|sb
operator|.
name|st_mode
argument_list|)
return|;
endif|#
directive|endif
comment|/* S_ISREG */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Local Variables: c-indent-level: 5 c-continued-statement-offset: 5 c-brace-offset: -5 c-argdecl-indent: 0 c-label-offset: -5 comment-column: 30 End: */
end_comment

end_unit

