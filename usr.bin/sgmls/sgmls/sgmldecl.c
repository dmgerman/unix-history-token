begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* sgmldecl.c -    SGML declaration parsing.     Written by James Clark (jjc@jclark.com). */
end_comment

begin_include
include|#
directive|include
file|"sgmlincl.h"
end_include

begin_comment
comment|/* Symbolic names for the error numbers that are be generated only by this module. */
end_comment

begin_define
define|#
directive|define
name|E_SHUNCHAR
value|159
end_define

begin_define
define|#
directive|define
name|E_STANDARD
value|163
end_define

begin_define
define|#
directive|define
name|E_SIGNIFICANT
value|164
end_define

begin_define
define|#
directive|define
name|E_BADLIT
value|165
end_define

begin_define
define|#
directive|define
name|E_SCOPE
value|166
end_define

begin_define
define|#
directive|define
name|E_XNUM
value|167
end_define

begin_define
define|#
directive|define
name|E_BADVERSION
value|168
end_define

begin_define
define|#
directive|define
name|E_NMUNSUP
value|169
end_define

begin_define
define|#
directive|define
name|E_XNMLIT
value|170
end_define

begin_define
define|#
directive|define
name|E_CHARDESC
value|171
end_define

begin_define
define|#
directive|define
name|E_CHARDUP
value|172
end_define

begin_define
define|#
directive|define
name|E_CHARRANGE
value|173
end_define

begin_define
define|#
directive|define
name|E_7BIT
value|174
end_define

begin_define
define|#
directive|define
name|E_CHARMISSING
value|175
end_define

begin_define
define|#
directive|define
name|E_SHUNNED
value|176
end_define

begin_define
define|#
directive|define
name|E_NONSGML
value|177
end_define

begin_define
define|#
directive|define
name|E_CAPSET
value|178
end_define

begin_define
define|#
directive|define
name|E_CAPMISSING
value|179
end_define

begin_define
define|#
directive|define
name|E_SYNTAX
value|180
end_define

begin_define
define|#
directive|define
name|E_CHARNUM
value|181
end_define

begin_define
define|#
directive|define
name|E_SWITCHES
value|182
end_define

begin_define
define|#
directive|define
name|E_INSTANCE
value|183
end_define

begin_define
define|#
directive|define
name|E_ZEROFEATURE
value|184
end_define

begin_define
define|#
directive|define
name|E_YESNO
value|185
end_define

begin_define
define|#
directive|define
name|E_CAPACITY
value|186
end_define

begin_define
define|#
directive|define
name|E_NOTSUPPORTED
value|187
end_define

begin_define
define|#
directive|define
name|E_FORMAL
value|189
end_define

begin_define
define|#
directive|define
name|E_BADCLASS
value|190
end_define

begin_define
define|#
directive|define
name|E_MUSTBENON
value|191
end_define

begin_define
define|#
directive|define
name|E_BADBASECHAR
value|199
end_define

begin_define
define|#
directive|define
name|E_SYNREFUNUSED
value|200
end_define

begin_define
define|#
directive|define
name|E_SYNREFUNDESC
value|201
end_define

begin_define
define|#
directive|define
name|E_SYNREFUNKNOWN
value|202
end_define

begin_define
define|#
directive|define
name|E_SYNREFUNKNOWNSET
value|203
end_define

begin_define
define|#
directive|define
name|E_FUNDUP
value|204
end_define

begin_define
define|#
directive|define
name|E_BADFUN
value|205
end_define

begin_define
define|#
directive|define
name|E_FUNCHAR
value|206
end_define

begin_define
define|#
directive|define
name|E_GENDELIM
value|207
end_define

begin_define
define|#
directive|define
name|E_SRDELIM
value|208
end_define

begin_define
define|#
directive|define
name|E_BADKEY
value|209
end_define

begin_define
define|#
directive|define
name|E_BADQUANTITY
value|210
end_define

begin_define
define|#
directive|define
name|E_BADNAME
value|211
end_define

begin_define
define|#
directive|define
name|E_REFNAME
value|212
end_define

begin_define
define|#
directive|define
name|E_DUPNAME
value|213
end_define

begin_define
define|#
directive|define
name|E_QUANTITY
value|214
end_define

begin_define
define|#
directive|define
name|E_QTOOBIG
value|215
end_define

begin_define
define|#
directive|define
name|E_NMSTRTCNT
value|219
end_define

begin_define
define|#
directive|define
name|E_NMCHARCNT
value|220
end_define

begin_define
define|#
directive|define
name|E_NMDUP
value|221
end_define

begin_define
define|#
directive|define
name|E_NMBAD
value|222
end_define

begin_define
define|#
directive|define
name|E_NMMINUS
value|223
end_define

begin_define
define|#
directive|define
name|E_UNKNOWNSET
value|227
end_define

begin_define
define|#
directive|define
name|E_TOTALCAP
value|235
end_define

begin_define
define|#
directive|define
name|CANON_NMC
value|'.'
end_define

begin_comment
comment|/* Canonical name character. */
end_comment

begin_define
define|#
directive|define
name|CANON_NMS
value|'A'
end_define

begin_comment
comment|/* Canonical name start character. */
end_comment

begin_define
define|#
directive|define
name|CANON_MIN
value|':'
end_define

begin_comment
comment|/* Canonical minimum data character. */
end_comment

begin_define
define|#
directive|define
name|SUCCESS
value|1
end_define

begin_define
define|#
directive|define
name|FAIL
value|0
end_define

begin_define
define|#
directive|define
name|SIZEOF
parameter_list|(
name|v
parameter_list|)
value|(sizeof(v)/sizeof(v[0]))
end_define

begin_define
define|#
directive|define
name|matches
parameter_list|(
name|tok
parameter_list|,
name|str
parameter_list|)
value|(ustrcmp((tok)+1, (str)) == 0)
end_define

begin_decl_stmt
specifier|static
name|UNCH
name|standard
index|[]
init|=
literal|"ISO 8879:1986"
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|REFERENCE_SYNTAX
value|"ISO 8879:1986//SYNTAX Reference//EN"
end_define

begin_define
define|#
directive|define
name|CORE_SYNTAX
value|"ISO 8879:1986//SYNTAX Core//EN"
end_define

begin_expr_stmt
specifier|static
name|UNCH
argument_list|(
operator|*
name|newkey
argument_list|)
index|[
name|REFNAMELEN
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_struct
struct|struct
name|pmap
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|UNIV
name|value
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The reference capacity set. */
end_comment

begin_define
define|#
directive|define
name|REFCAPSET
define|\
value|{ 35000L, 35000L, 35000L, 35000L, 35000L, 35000L, 35000L, 35000L, 35000L, \ 35000L, 35000L, 35000L, 35000L, 35000L, 35000L, 35000L, 35000L }
end_define

begin_decl_stmt
name|long
name|refcapset
index|[
name|NCAPACITY
index|]
init|=
name|REFCAPSET
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A pmap of known capacity sets. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|pmap
name|capset_map
index|[]
init|=
block|{
block|{
literal|"ISO 8879:1986//CAPACITY Reference//EN"
block|,
operator|(
name|UNIV
operator|)
name|refcapset
block|}
block|,
block|{
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Table of capacity names.  Must match *CAP in sgmldecl.h. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|captab
index|[]
init|=
block|{
literal|"TOTALCAP"
block|,
literal|"ENTCAP"
block|,
literal|"ENTCHCAP"
block|,
literal|"ELEMCAP"
block|,
literal|"GRPCAP"
block|,
literal|"EXGRPCAP"
block|,
literal|"EXNMCAP"
block|,
literal|"ATTCAP"
block|,
literal|"ATTCHCAP"
block|,
literal|"AVGRPCAP"
block|,
literal|"NOTCAP"
block|,
literal|"NOTCHCAP"
block|,
literal|"IDCAP"
block|,
literal|"IDREFCAP"
block|,
literal|"MAPCAP"
block|,
literal|"LKSETCAP"
block|,
literal|"LKNMCAP"
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The default SGML declaration. */
end_comment

begin_define
define|#
directive|define
name|MAXNUMBER
value|99999999L
end_define

begin_comment
comment|/* Reference quantity set */
end_comment

begin_define
define|#
directive|define
name|REFATTCNT
value|40
end_define

begin_define
define|#
directive|define
name|REFATTSPLEN
value|960
end_define

begin_define
define|#
directive|define
name|REFBSEQLEN
value|960
end_define

begin_define
define|#
directive|define
name|REFDTAGLEN
value|16
end_define

begin_define
define|#
directive|define
name|REFDTEMPLEN
value|16
end_define

begin_define
define|#
directive|define
name|REFENTLVL
value|16
end_define

begin_define
define|#
directive|define
name|REFGRPCNT
value|32
end_define

begin_define
define|#
directive|define
name|REFGRPGTCNT
value|96
end_define

begin_define
define|#
directive|define
name|REFGRPLVL
value|16
end_define

begin_define
define|#
directive|define
name|REFNORMSEP
value|2
end_define

begin_define
define|#
directive|define
name|REFPILEN
value|240
end_define

begin_define
define|#
directive|define
name|REFTAGLEN
value|960
end_define

begin_define
define|#
directive|define
name|REFTAGLVL
value|24
end_define

begin_define
define|#
directive|define
name|ALLOC_MAX
value|65534
end_define

begin_define
define|#
directive|define
name|BIGINT
value|30000
end_define

begin_define
define|#
directive|define
name|MAXATTCNT
value|((ALLOC_MAX/sizeof(struct ad)) - 2)
end_define

begin_define
define|#
directive|define
name|MAXATTSPLEN
value|BIGINT
end_define

begin_define
define|#
directive|define
name|MAXBSEQLEN
value|BIGINT
end_define

begin_define
define|#
directive|define
name|MAXDTAGLEN
value|16
end_define

begin_define
define|#
directive|define
name|MAXDTEMPLEN
value|16
end_define

begin_define
define|#
directive|define
name|MAXENTLVL
value|((ALLOC_MAX/sizeof(struct source)) - 1)
end_define

begin_define
define|#
directive|define
name|MAXGRPCNT
value|MAXGRPGTCNT
end_define

begin_comment
comment|/* Must be between 96 and 253 */
end_comment

begin_define
define|#
directive|define
name|MAXGRPGTCNT
value|253
end_define

begin_define
define|#
directive|define
name|MAXGRPLVL
value|MAXGRPGTCNT
end_define

begin_define
define|#
directive|define
name|MAXLITLEN
value|BIGINT
end_define

begin_comment
comment|/* This guarantees that NAMELEN< LITLEN (ie there's always space for a name in a buffer intended for a literal.) */
end_comment

begin_define
define|#
directive|define
name|MAXNAMELEN
value|(REFLITLEN - 1)
end_define

begin_define
define|#
directive|define
name|MAXNORMSEP
value|2
end_define

begin_define
define|#
directive|define
name|MAXPILEN
value|BIGINT
end_define

begin_define
define|#
directive|define
name|MAXTAGLEN
value|BIGINT
end_define

begin_define
define|#
directive|define
name|MAXTAGLVL
value|((ALLOC_MAX/sizeof(struct tag)) - 1)
end_define

begin_comment
comment|/* Table of quantity names.  Must match Q* in sgmldecl.h. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|quantity_names
index|[]
init|=
block|{
literal|"ATTCNT"
block|,
literal|"ATTSPLEN"
block|,
literal|"BSEQLEN"
block|,
literal|"DTAGLEN"
block|,
literal|"DTEMPLEN"
block|,
literal|"ENTLVL"
block|,
literal|"GRPCNT"
block|,
literal|"GRPGTCNT"
block|,
literal|"GRPLVL"
block|,
literal|"LITLEN"
block|,
literal|"NAMELEN"
block|,
literal|"NORMSEP"
block|,
literal|"PILEN"
block|,
literal|"TAGLEN"
block|,
literal|"TAGLVL"
block|,     }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|max_quantity
index|[]
init|=
block|{
name|MAXATTCNT
block|,
name|MAXATTSPLEN
block|,
name|MAXBSEQLEN
block|,
name|MAXDTAGLEN
block|,
name|MAXDTEMPLEN
block|,
name|MAXENTLVL
block|,
name|MAXGRPCNT
block|,
name|MAXGRPGTCNT
block|,
name|MAXGRPLVL
block|,
name|MAXLITLEN
block|,
name|MAXNAMELEN
block|,
name|MAXNORMSEP
block|,
name|MAXPILEN
block|,
name|MAXTAGLEN
block|,
name|MAXTAGLVL
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|quantity_changed
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means the APPINFO parameter was not NONE. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|appinfosw
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|sgmldecl
name|sd
init|=
block|{
name|REFCAPSET
block|,
comment|/* capacity */
ifdef|#
directive|ifdef
name|SUPPORT_SUBDOC
name|MAXNUMBER
block|,
comment|/* subdoc */
else|#
directive|else
comment|/* not SUPPORT_SUBDOC */
literal|0
block|,
comment|/* subdoc */
endif|#
directive|endif
comment|/* not SUPPORT_SUBDOC */
literal|1
block|,
comment|/* formal */
literal|1
block|,
comment|/* omittag */
literal|1
block|,
comment|/* shorttag */
literal|1
block|,
comment|/* shortref */
block|{
literal|1
block|,
literal|0
block|}
block|,
comment|/* general/entity name case translation */
block|{
comment|/* reference quantity set */
name|REFATTCNT
block|,
name|REFATTSPLEN
block|,
name|REFBSEQLEN
block|,
name|REFDTAGLEN
block|,
name|REFDTEMPLEN
block|,
name|REFENTLVL
block|,
name|REFGRPCNT
block|,
name|REFGRPGTCNT
block|,
name|REFGRPLVL
block|,
name|REFLITLEN
block|,
name|REFNAMELEN
block|,
name|REFNORMSEP
block|,
name|REFPILEN
block|,
name|REFTAGLEN
block|,
name|REFTAGLVL
block|,      }
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|systemcharset
index|[]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|,
literal|15
block|,
literal|16
block|,
literal|17
block|,
literal|18
block|,
literal|19
block|,
literal|20
block|,
literal|21
block|,
literal|22
block|,
literal|23
block|,
literal|24
block|,
literal|25
block|,
literal|26
block|,
literal|27
block|,
literal|28
block|,
literal|29
block|,
literal|30
block|,
literal|31
block|,
literal|32
block|,
literal|33
block|,
literal|34
block|,
literal|35
block|,
literal|36
block|,
literal|37
block|,
literal|38
block|,
literal|39
block|,
literal|40
block|,
literal|41
block|,
literal|42
block|,
literal|43
block|,
literal|44
block|,
literal|45
block|,
literal|46
block|,
literal|47
block|,
literal|48
block|,
literal|49
block|,
literal|50
block|,
literal|51
block|,
literal|52
block|,
literal|53
block|,
literal|54
block|,
literal|55
block|,
literal|56
block|,
literal|57
block|,
literal|58
block|,
literal|59
block|,
literal|60
block|,
literal|61
block|,
literal|62
block|,
literal|63
block|,
literal|64
block|,
literal|65
block|,
literal|66
block|,
literal|67
block|,
literal|68
block|,
literal|69
block|,
literal|70
block|,
literal|71
block|,
literal|72
block|,
literal|73
block|,
literal|74
block|,
literal|75
block|,
literal|76
block|,
literal|77
block|,
literal|78
block|,
literal|79
block|,
literal|80
block|,
literal|81
block|,
literal|82
block|,
literal|83
block|,
literal|84
block|,
literal|85
block|,
literal|86
block|,
literal|87
block|,
literal|88
block|,
literal|89
block|,
literal|90
block|,
literal|91
block|,
literal|92
block|,
literal|93
block|,
literal|94
block|,
literal|95
block|,
literal|96
block|,
literal|97
block|,
literal|98
block|,
literal|99
block|,
literal|100
block|,
literal|101
block|,
literal|102
block|,
literal|103
block|,
literal|104
block|,
literal|105
block|,
literal|106
block|,
literal|107
block|,
literal|108
block|,
literal|109
block|,
literal|110
block|,
literal|111
block|,
literal|112
block|,
literal|113
block|,
literal|114
block|,
literal|115
block|,
literal|116
block|,
literal|117
block|,
literal|118
block|,
literal|119
block|,
literal|120
block|,
literal|121
block|,
literal|122
block|,
literal|123
block|,
literal|124
block|,
literal|125
block|,
literal|126
block|,
literal|127
block|,
literal|128
block|,
literal|129
block|,
literal|130
block|,
literal|131
block|,
literal|132
block|,
literal|133
block|,
literal|134
block|,
literal|135
block|,
literal|136
block|,
literal|137
block|,
literal|138
block|,
literal|139
block|,
literal|140
block|,
literal|141
block|,
literal|142
block|,
literal|143
block|,
literal|144
block|,
literal|145
block|,
literal|146
block|,
literal|147
block|,
literal|148
block|,
literal|149
block|,
literal|150
block|,
literal|151
block|,
literal|152
block|,
literal|153
block|,
literal|154
block|,
literal|155
block|,
literal|156
block|,
literal|157
block|,
literal|158
block|,
literal|159
block|,
literal|160
block|,
literal|161
block|,
literal|162
block|,
literal|163
block|,
literal|164
block|,
literal|165
block|,
literal|166
block|,
literal|167
block|,
literal|168
block|,
literal|169
block|,
literal|170
block|,
literal|171
block|,
literal|172
block|,
literal|173
block|,
literal|174
block|,
literal|175
block|,
literal|176
block|,
literal|177
block|,
literal|178
block|,
literal|179
block|,
literal|180
block|,
literal|181
block|,
literal|182
block|,
literal|183
block|,
literal|184
block|,
literal|185
block|,
literal|186
block|,
literal|187
block|,
literal|188
block|,
literal|189
block|,
literal|190
block|,
literal|191
block|,
literal|192
block|,
literal|193
block|,
literal|194
block|,
literal|195
block|,
literal|196
block|,
literal|197
block|,
literal|198
block|,
literal|199
block|,
literal|200
block|,
literal|201
block|,
literal|202
block|,
literal|203
block|,
literal|204
block|,
literal|205
block|,
literal|206
block|,
literal|207
block|,
literal|208
block|,
literal|209
block|,
literal|210
block|,
literal|211
block|,
literal|212
block|,
literal|213
block|,
literal|214
block|,
literal|215
block|,
literal|216
block|,
literal|217
block|,
literal|218
block|,
literal|219
block|,
literal|220
block|,
literal|221
block|,
literal|222
block|,
literal|223
block|,
literal|224
block|,
literal|225
block|,
literal|226
block|,
literal|227
block|,
literal|228
block|,
literal|229
block|,
literal|230
block|,
literal|231
block|,
literal|232
block|,
literal|233
block|,
literal|234
block|,
literal|235
block|,
literal|236
block|,
literal|237
block|,
literal|238
block|,
literal|239
block|,
literal|240
block|,
literal|241
block|,
literal|242
block|,
literal|243
block|,
literal|244
block|,
literal|245
block|,
literal|246
block|,
literal|247
block|,
literal|248
block|,
literal|249
block|,
literal|250
block|,
literal|251
block|,
literal|252
block|,
literal|253
block|,
literal|254
block|,
literal|255
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is a private use designating sequence that by convention refers to the whole system character set whatever it is. */
end_comment

begin_define
define|#
directive|define
name|SYSTEM_CHARSET_DESIGNATING_SEQUENCE
value|"ESC 2/5 2/15 3/0"
end_define

begin_decl_stmt
specifier|static
name|struct
name|pmap
name|charset_map
index|[]
init|=
block|{
block|{
literal|"ESC 2/5 4/0"
block|,
operator|(
name|UNIV
operator|)
name|iso646charset
block|}
block|,
comment|/* ISO 646 IRV */
block|{
literal|"ESC 2/8 4/2"
block|,
operator|(
name|UNIV
operator|)
name|iso646G0charset
block|}
block|,
comment|/* ISO Registration Number 6, ASCII */
block|{
literal|"ESC 2/8 4/0"
block|,
operator|(
name|UNIV
operator|)
name|iso646G0charset
block|}
block|,
comment|/* ISO Registration Number 6, ASCII */
block|{
literal|"ESC 2/13 4/1"
block|,
operator|(
name|UNIV
operator|)
name|iso8859_1charset
block|}
block|,
comment|/* Latin 1 */
block|{
literal|"ESC 2/1 4/0"
block|,
operator|(
name|UNIV
operator|)
name|iso646C0charset
block|}
block|,
comment|/* ISO 646, C0 */
block|{
literal|"ESC 2/2 4/3"
block|,
operator|(
name|UNIV
operator|)
name|iso6429C1charset
block|}
block|,
comment|/* ISO 6429, C1 */
block|{
name|SYSTEM_CHARSET_DESIGNATING_SEQUENCE
block|,
operator|(
name|UNIV
operator|)
name|systemcharset
block|}
block|,
comment|/* system character set */
block|{
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|synrefcharset
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the syntax reference character set */
end_comment

begin_define
define|#
directive|define
name|CHAR_NONSGML
value|01
end_define

begin_define
define|#
directive|define
name|CHAR_SIGNIFICANT
value|02
end_define

begin_define
define|#
directive|define
name|CHAR_MAGIC
value|04
end_define

begin_define
define|#
directive|define
name|CHAR_SHUNNED
value|010
end_define

begin_decl_stmt
specifier|static
name|UNCH
name|char_flags
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|done_nonsgml
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|UNCH
modifier|*
name|nlextoke
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* new lextoke */
end_comment

begin_decl_stmt
specifier|static
name|UNCH
modifier|*
name|nlextran
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* new lextran */
end_comment

begin_define
define|#
directive|define
name|MAX_SAVED_ERRS
value|4
end_define

begin_decl_stmt
specifier|static
name|UNIV
name|saved_errs
index|[
name|MAX_SAVED_ERRS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nsaved_errs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|UNCH
name|kcharset
index|[]
init|=
literal|"CHARSET"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|UNCH
name|kbaseset
index|[]
init|=
literal|"BASESET"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|UNCH
name|kdescset
index|[]
init|=
literal|"DESCSET"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|UNCH
name|kunused
index|[]
init|=
literal|"UNUSED"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|UNCH
name|kcapacity
index|[]
init|=
literal|"CAPACITY"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|UNCH
name|kpublic
index|[]
init|=
literal|"PUBLIC"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|UNCH
name|ksgmlref
index|[]
init|=
literal|"SGMLREF"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|UNCH
name|kscope
index|[]
init|=
literal|"SCOPE"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|UNCH
name|kdocument
index|[]
init|=
literal|"DOCUMENT"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|UNCH
name|kinstance
index|[]
init|=
literal|"INSTANCE"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|UNCH
name|ksyntax
index|[]
init|=
literal|"SYNTAX"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|UNCH
name|kswitches
index|[]
init|=
literal|"SWITCHES"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|UNCH
name|kfeatures
index|[]
init|=
literal|"FEATURES"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|UNCH
name|kminimize
index|[]
init|=
literal|"MINIMIZE"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|UNCH
name|kdatatag
index|[]
init|=
literal|"DATATAG"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|UNCH
name|komittag
index|[]
init|=
literal|"OMITTAG"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|UNCH
name|krank
index|[]
init|=
literal|"RANK"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|UNCH
name|kshorttag
index|[]
init|=
literal|"SHORTTAG"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|UNCH
name|klink
index|[]
init|=
literal|"LINK"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|UNCH
name|ksimple
index|[]
init|=
literal|"SIMPLE"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|UNCH
name|kimplicit
index|[]
init|=
literal|"IMPLICIT"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|UNCH
name|kexplicit
index|[]
init|=
literal|"EXPLICIT"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|UNCH
name|kother
index|[]
init|=
literal|"OTHER"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|UNCH
name|kconcur
index|[]
init|=
literal|"CONCUR"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|UNCH
name|ksubdoc
index|[]
init|=
literal|"SUBDOC"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|UNCH
name|kformal
index|[]
init|=
literal|"FORMAL"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|UNCH
name|kyes
index|[]
init|=
literal|"YES"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|UNCH
name|kno
index|[]
init|=
literal|"NO"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|UNCH
name|kappinfo
index|[]
init|=
literal|"APPINFO"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|UNCH
name|knone
index|[]
init|=
literal|"NONE"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|UNCH
name|kshunchar
index|[]
init|=
literal|"SHUNCHAR"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|UNCH
name|kcontrols
index|[]
init|=
literal|"CONTROLS"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|UNCH
name|kfunction
index|[]
init|=
literal|"FUNCTION"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|UNCH
name|krs
index|[]
init|=
literal|"RS"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|UNCH
name|kre
index|[]
init|=
literal|"RE"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|UNCH
name|kspace
index|[]
init|=
literal|"SPACE"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|UNCH
name|knaming
index|[]
init|=
literal|"NAMING"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|UNCH
name|klcnmstrt
index|[]
init|=
literal|"LCNMSTRT"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|UNCH
name|kucnmstrt
index|[]
init|=
literal|"UCNMSTRT"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|UNCH
name|klcnmchar
index|[]
init|=
literal|"LCNMCHAR"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|UNCH
name|kucnmchar
index|[]
init|=
literal|"UCNMCHAR"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|UNCH
name|knamecase
index|[]
init|=
literal|"NAMECASE"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|UNCH
name|kdelim
index|[]
init|=
literal|"DELIM"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|UNCH
name|kgeneral
index|[]
init|=
literal|"GENERAL"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|UNCH
name|kentity
index|[]
init|=
literal|"ENTITY"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|UNCH
name|kshortref
index|[]
init|=
literal|"SHORTREF"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|UNCH
name|knames
index|[]
init|=
literal|"NAMES"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|UNCH
name|kquantity
index|[]
init|=
literal|"QUANTITY"
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|sderr
value|mderr
end_define

begin_decl_stmt
specifier|static
name|UNIV
name|pmaplookup
name|P
argument_list|(
operator|(
expr|struct
name|pmap
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|UNCH
modifier|*
name|ltous
name|P
argument_list|(
operator|(
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|VOID
name|sdfixstandard
name|P
argument_list|(
operator|(
name|UNCH
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sdparm
name|P
argument_list|(
operator|(
name|UNCH
operator|*
operator|,
expr|struct
name|parse
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sdname
name|P
argument_list|(
operator|(
name|UNCH
operator|*
operator|,
name|UNCH
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sdckname
name|P
argument_list|(
operator|(
name|UNCH
operator|*
operator|,
name|UNCH
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sdversion
name|P
argument_list|(
operator|(
name|UNCH
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sdcharset
name|P
argument_list|(
operator|(
name|UNCH
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sdcsdesc
name|P
argument_list|(
operator|(
name|UNCH
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sdpubcapacity
name|P
argument_list|(
operator|(
name|UNCH
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sdcapacity
name|P
argument_list|(
operator|(
name|UNCH
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sdscope
name|P
argument_list|(
operator|(
name|UNCH
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|VOID
name|setlexical
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|VOID
name|noemptytag
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sdpubsyntax
name|P
argument_list|(
operator|(
name|UNCH
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sdsyntax
name|P
argument_list|(
operator|(
name|UNCH
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sdxsyntax
name|P
argument_list|(
operator|(
name|UNCH
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sdtranscharnum
name|P
argument_list|(
operator|(
name|UNCH
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sdtranschar
name|P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sdshunchar
name|P
argument_list|(
operator|(
name|UNCH
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sdsynref
name|P
argument_list|(
operator|(
name|UNCH
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sdfunction
name|P
argument_list|(
operator|(
name|UNCH
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sdnaming
name|P
argument_list|(
operator|(
name|UNCH
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sddelim
name|P
argument_list|(
operator|(
name|UNCH
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sdnames
name|P
argument_list|(
operator|(
name|UNCH
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sdquantity
name|P
argument_list|(
operator|(
name|UNCH
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sdfeatures
name|P
argument_list|(
operator|(
name|UNCH
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sdappinfo
name|P
argument_list|(
operator|(
name|UNCH
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|VOID
name|sdsaverr
name|P
argument_list|(
operator|(
name|UNS
operator|,
name|UNCH
operator|*
operator|,
name|UNCH
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|VOID
name|bufsalloc
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|VOID
name|bufsrealloc
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Parse the SGML declaration. Return non-zero if there was some appinfo. */
end_comment

begin_function
name|int
name|sgmldecl
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|int
name|errsw
init|=
literal|0
decl_stmt|;
name|UNCH
name|endbuf
index|[
name|REFNAMELEN
operator|+
literal|2
index|]
decl_stmt|;
comment|/* buffer for parsing terminating> */
specifier|static
name|int
argument_list|(
argument|*section[]
argument_list|)
name|P
argument_list|(
operator|(
name|UNCH
operator|*
operator|)
argument_list|)
operator|=
block|{
name|sdversion
block|,
name|sdcharset
block|,
name|sdcapacity
block|,
name|sdscope
block|,
name|sdsyntax
block|,
name|sdfeatures
block|,
name|sdappinfo
block|,      }
expr_stmt|;
comment|/* These are needed if we use mderr. */
name|parmno
operator|=
literal|0
expr_stmt|;
name|mdname
operator|=
name|sgmlkey
expr_stmt|;
name|subdcl
operator|=
name|NULL
expr_stmt|;
name|nsaved_errs
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SIZEOF
argument_list|(
name|section
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
call|(
modifier|*
name|section
index|[
name|i
index|]
call|)
argument_list|(
name|tbuf
argument_list|)
operator|==
name|FAIL
condition|)
block|{
name|errsw
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|sd
operator|.
name|formal
condition|)
block|{
comment|/* print saved errors */
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsaved_errs
condition|;
name|i
operator|++
control|)
name|svderr
argument_list|(
name|saved_errs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* free saved errors */
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsaved_errs
condition|;
name|i
operator|++
control|)
name|msgsfree
argument_list|(
name|saved_errs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|errsw
condition|)
name|setlexical
argument_list|()
expr_stmt|;
name|bufsrealloc
argument_list|()
expr_stmt|;
comment|/* Parse the>.  Don't overwrite the appinfo. */
if|if
condition|(
operator|!
name|errsw
condition|)
name|sdparm
argument_list|(
name|endbuf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* We must exit if we hit end of document. */
if|if
condition|(
name|pcbsd
operator|.
name|action
operator|==
name|EOD_
condition|)
name|exiterr
argument_list|(
literal|161
argument_list|,
operator|&
name|pcbsd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|errsw
operator|&&
name|pcbsd
operator|.
name|action
operator|!=
name|ESGD
condition|)
name|sderr
argument_list|(
literal|126
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
name|appinfosw
return|;
block|}
end_function

begin_comment
comment|/* Parse the literal (which should contain the version of the standard) at the beginning of a SGML declaration. */
end_comment

begin_function
specifier|static
name|int
name|sdversion
parameter_list|(
name|tbuf
parameter_list|)
name|UNCH
modifier|*
name|tbuf
decl_stmt|;
block|{
if|if
condition|(
name|sdparm
argument_list|(
name|tbuf
argument_list|,
operator|&
name|pcblitv
argument_list|)
operator|!=
name|LIT1
condition|)
block|{
name|sderr
argument_list|(
literal|123
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
name|sdfixstandard
argument_list|(
name|tbuf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ustrcmp
argument_list|(
name|tbuf
argument_list|,
name|standard
argument_list|)
operator|!=
literal|0
condition|)
name|sderr
argument_list|(
name|E_BADVERSION
argument_list|,
name|tbuf
argument_list|,
name|standard
argument_list|)
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* Parse the CHARSET section. Use one token lookahead. */
end_comment

begin_function
specifier|static
name|int
name|sdcharset
parameter_list|(
name|tbuf
parameter_list|)
name|UNCH
modifier|*
name|tbuf
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|status
index|[
literal|256
index|]
decl_stmt|;
if|if
condition|(
name|sdname
argument_list|(
name|tbuf
argument_list|,
name|kcharset
argument_list|)
operator|==
name|FAIL
condition|)
return|return
name|FAIL
return|;
operator|(
name|void
operator|)
name|sdparm
argument_list|(
name|tbuf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sdcsdesc
argument_list|(
name|tbuf
argument_list|,
name|status
argument_list|)
operator|==
name|FAIL
condition|)
return|return
name|FAIL
return|;
if|#
directive|if
literal|0
block|for (i = 128; i< 256; i++) 	  if (status[i] != UNDESC) 	       break;      if (i>= 256) {
comment|/* Only a 7-bit character set was described.  Fill it out to 8-bits. */
block|for (i = 128; i< 256; i++) 	       status[i] = UNUSED;
if|#
directive|if
literal|0
block|sderr(E_7BIT, (UNCH *)0, (UNCH *)0);
endif|#
directive|endif
block|}
endif|#
directive|endif
comment|/* Characters that are declared UNUSED in the document character set 	are assigned to non-SGML. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|status
index|[
name|i
index|]
operator|==
name|UNDESC
condition|)
block|{
if|#
directive|if
literal|0
block|sderr(E_CHARMISSING, ltous((long)i), (UNCH *)0);
endif|#
directive|endif
name|char_flags
index|[
name|i
index|]
operator||=
name|CHAR_NONSGML
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|status
index|[
name|i
index|]
operator|==
name|UNUSED
condition|)
name|char_flags
index|[
name|i
index|]
operator||=
name|CHAR_NONSGML
expr_stmt|;
block|}
name|done_nonsgml
operator|=
literal|1
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* Parse a character set description.   Uses one character lookahead. */
end_comment

begin_function
specifier|static
name|int
name|sdcsdesc
parameter_list|(
name|tbuf
parameter_list|,
name|status
parameter_list|)
name|UNCH
modifier|*
name|tbuf
decl_stmt|;
name|int
modifier|*
name|status
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|nsets
init|=
literal|0
decl_stmt|;
name|struct
name|fpi
name|fpi
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
name|status
index|[
name|i
index|]
operator|=
name|UNDESC
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|nchars
decl_stmt|;
name|int
modifier|*
name|baseset
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|pcbsd
operator|.
name|action
operator|!=
name|NAS1
condition|)
block|{
if|if
condition|(
name|nsets
operator|==
literal|0
condition|)
block|{
name|sderr
argument_list|(
literal|120
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
break|break;
block|}
if|if
condition|(
operator|!
name|matches
argument_list|(
name|tbuf
argument_list|,
name|kbaseset
argument_list|)
condition|)
block|{
if|if
condition|(
name|nsets
operator|==
literal|0
condition|)
block|{
name|sderr
argument_list|(
literal|118
argument_list|,
name|tbuf
operator|+
literal|1
argument_list|,
name|kbaseset
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
break|break;
block|}
name|nsets
operator|++
expr_stmt|;
name|MEMZERO
argument_list|(
operator|(
name|UNIV
operator|)
operator|&
name|fpi
argument_list|,
name|FPISZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|sdparm
argument_list|(
name|tbuf
argument_list|,
operator|&
name|pcblitv
argument_list|)
operator|!=
name|LIT1
condition|)
block|{
name|sderr
argument_list|(
literal|123
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
name|fpi
operator|.
name|fpipubis
operator|=
name|tbuf
expr_stmt|;
comment|/* Give a warning if it is not a CHARSET fpi. */
if|if
condition|(
name|parsefpi
argument_list|(
operator|&
name|fpi
argument_list|)
condition|)
name|sdsaverr
argument_list|(
name|E_FORMAL
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fpi
operator|.
name|fpic
operator|!=
name|FPICHARS
condition|)
name|sdsaverr
argument_list|(
name|E_BADCLASS
argument_list|,
name|kcharset
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|fpi
operator|.
name|fpipubis
index|[
name|fpi
operator|.
name|fpil
operator|+
name|fpi
operator|.
name|fpill
index|]
operator|=
literal|'\0'
expr_stmt|;
name|baseset
operator|=
operator|(
name|int
operator|*
operator|)
name|pmaplookup
argument_list|(
name|charset_map
argument_list|,
operator|(
name|char
operator|*
operator|)
name|fpi
operator|.
name|fpipubis
operator|+
name|fpi
operator|.
name|fpil
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|baseset
condition|)
name|sderr
argument_list|(
name|E_UNKNOWNSET
argument_list|,
name|fpi
operator|.
name|fpipubis
operator|+
name|fpi
operator|.
name|fpil
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sdname
argument_list|(
name|tbuf
argument_list|,
name|kdescset
argument_list|)
operator|==
name|FAIL
condition|)
return|return
name|FAIL
return|;
name|nchars
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|long
name|start
decl_stmt|,
name|count
decl_stmt|;
name|long
name|basenum
decl_stmt|;
if|if
condition|(
name|sdparm
argument_list|(
name|tbuf
argument_list|,
literal|0
argument_list|)
operator|!=
name|NUM1
condition|)
break|break;
name|start
operator|=
name|atol
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|sdparm
argument_list|(
name|tbuf
argument_list|,
literal|0
argument_list|)
operator|!=
name|NUM1
condition|)
block|{
name|sderr
argument_list|(
name|E_XNUM
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
name|count
operator|=
name|atol
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tbuf
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sdparm
argument_list|(
name|tbuf
argument_list|,
operator|&
name|pcblitv
argument_list|)
condition|)
block|{
case|case
name|NUM1
case|:
name|basenum
operator|=
name|atol
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tbuf
argument_list|)
expr_stmt|;
break|break;
case|case
name|LIT1
case|:
name|basenum
operator|=
name|UNKNOWN
expr_stmt|;
break|break;
case|case
name|NAS1
case|:
if|if
condition|(
name|matches
argument_list|(
name|tbuf
argument_list|,
name|kunused
argument_list|)
condition|)
block|{
name|basenum
operator|=
name|UNUSED
expr_stmt|;
break|break;
block|}
comment|/* fall through */
default|default:
name|sderr
argument_list|(
name|E_CHARDESC
argument_list|,
name|ltous
argument_list|(
name|start
argument_list|)
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
if|if
condition|(
name|start
operator|+
name|count
operator|>
literal|256
condition|)
name|sderr
argument_list|(
name|E_CHARRANGE
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|i
decl_stmt|;
name|int
name|lim
init|=
operator|(
name|int
operator|)
name|start
operator|+
name|count
decl_stmt|;
for|for
control|(
name|i
operator|=
operator|(
name|int
operator|)
name|start
init|;
name|i
operator|<
name|lim
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|status
index|[
name|i
index|]
operator|!=
name|UNDESC
condition|)
name|sderr
argument_list|(
name|E_CHARDUP
argument_list|,
name|ltous
argument_list|(
operator|(
name|long
operator|)
name|i
argument_list|)
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|basenum
operator|==
name|UNUSED
operator|||
name|basenum
operator|==
name|UNKNOWN
condition|)
name|status
index|[
name|i
index|]
operator|=
operator|(
name|int
operator|)
name|basenum
expr_stmt|;
elseif|else
if|if
condition|(
name|baseset
operator|==
literal|0
condition|)
name|status
index|[
name|i
index|]
operator|=
name|UNKNOWN_SET
expr_stmt|;
else|else
block|{
name|int
name|n
init|=
name|basenum
operator|+
operator|(
name|i
operator|-
name|start
operator|)
decl_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
operator|||
name|n
operator|>
literal|255
condition|)
name|sderr
argument_list|(
name|E_CHARRANGE
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|baseset
index|[
name|n
index|]
operator|==
name|UNUSED
condition|)
name|sderr
argument_list|(
name|E_BADBASECHAR
argument_list|,
name|ltous
argument_list|(
operator|(
name|long
operator|)
name|n
argument_list|)
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|status
index|[
name|i
index|]
operator|=
name|baseset
index|[
name|n
index|]
expr_stmt|;
block|}
block|}
block|}
block|}
name|nchars
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|nchars
operator|==
literal|0
condition|)
block|{
name|sderr
argument_list|(
name|E_XNUM
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
block|}
return|return
name|SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* Parse the CAPACITY section.  Uses one token lookahead. */
end_comment

begin_function
specifier|static
name|int
name|sdcapacity
parameter_list|(
name|tbuf
parameter_list|)
name|UNCH
modifier|*
name|tbuf
decl_stmt|;
block|{
name|int
name|ncap
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|sdckname
argument_list|(
name|tbuf
argument_list|,
name|kcapacity
argument_list|)
operator|==
name|FAIL
condition|)
return|return
name|FAIL
return|;
if|if
condition|(
name|sdparm
argument_list|(
name|tbuf
argument_list|,
literal|0
argument_list|)
operator|!=
name|NAS1
condition|)
block|{
name|sderr
argument_list|(
literal|120
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
if|if
condition|(
name|matches
argument_list|(
name|tbuf
argument_list|,
name|kpublic
argument_list|)
condition|)
return|return
name|sdpubcapacity
argument_list|(
name|tbuf
argument_list|)
return|;
if|if
condition|(
operator|!
name|matches
argument_list|(
name|tbuf
argument_list|,
name|ksgmlref
argument_list|)
condition|)
block|{
name|sderr
argument_list|(
name|E_CAPACITY
argument_list|,
name|tbuf
operator|+
literal|1
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
name|memcpy
argument_list|(
operator|(
name|UNIV
operator|)
name|sd
operator|.
name|capacity
argument_list|,
operator|(
name|UNIV
operator|)
name|refcapset
argument_list|,
sizeof|sizeof
argument_list|(
name|sd
operator|.
name|capacity
argument_list|)
argument_list|)
expr_stmt|;
name|ncap
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|capno
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|sdparm
argument_list|(
name|tbuf
argument_list|,
literal|0
argument_list|)
operator|!=
name|NAS1
condition|)
break|break;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SIZEOF
argument_list|(
name|captab
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|matches
argument_list|(
name|tbuf
argument_list|,
name|captab
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|capno
operator|=
name|i
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|capno
operator|<
literal|0
condition|)
break|break;
if|if
condition|(
name|sdparm
argument_list|(
name|tbuf
argument_list|,
literal|0
argument_list|)
operator|!=
name|NUM1
condition|)
block|{
name|sderr
argument_list|(
name|E_XNUM
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
name|sd
operator|.
name|capacity
index|[
name|capno
index|]
operator|=
name|atol
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tbuf
argument_list|)
expr_stmt|;
name|ncap
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|ncap
operator|==
literal|0
condition|)
block|{
name|sderr
argument_list|(
name|E_CAPMISSING
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|NCAPACITY
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sd
operator|.
name|capacity
index|[
name|i
index|]
operator|>
name|sd
operator|.
name|capacity
index|[
literal|0
index|]
condition|)
name|sderr
argument_list|(
name|E_TOTALCAP
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
name|captab
index|[
name|i
index|]
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* Parse a CAPACITY section that started with PUBLIC.  Must do one token lookahead, since sdcapacity() also does. */
end_comment

begin_function
specifier|static
name|int
name|sdpubcapacity
parameter_list|(
name|tbuf
parameter_list|)
name|UNCH
modifier|*
name|tbuf
decl_stmt|;
block|{
name|UNIV
name|ptr
decl_stmt|;
if|if
condition|(
name|sdparm
argument_list|(
name|tbuf
argument_list|,
operator|&
name|pcblitv
argument_list|)
operator|!=
name|LIT1
condition|)
block|{
name|sderr
argument_list|(
literal|123
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
name|sdfixstandard
argument_list|(
name|tbuf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|pmaplookup
argument_list|(
name|capset_map
argument_list|,
operator|(
name|char
operator|*
operator|)
name|tbuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ptr
condition|)
name|sderr
argument_list|(
name|E_CAPSET
argument_list|,
name|tbuf
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
else|else
name|memcpy
argument_list|(
operator|(
name|UNIV
operator|)
name|sd
operator|.
name|capacity
argument_list|,
operator|(
name|UNIV
operator|)
name|ptr
argument_list|,
sizeof|sizeof
argument_list|(
name|sd
operator|.
name|capacity
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sdparm
argument_list|(
name|tbuf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* Parse the SCOPE section. Uses no lookahead. */
end_comment

begin_function
specifier|static
name|int
name|sdscope
parameter_list|(
name|tbuf
parameter_list|)
name|UNCH
modifier|*
name|tbuf
decl_stmt|;
block|{
if|if
condition|(
name|sdckname
argument_list|(
name|tbuf
argument_list|,
name|kscope
argument_list|)
operator|==
name|FAIL
condition|)
return|return
name|FAIL
return|;
if|if
condition|(
name|sdparm
argument_list|(
name|tbuf
argument_list|,
literal|0
argument_list|)
operator|!=
name|NAS1
condition|)
block|{
name|sderr
argument_list|(
literal|120
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
if|if
condition|(
name|matches
argument_list|(
name|tbuf
argument_list|,
name|kdocument
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|matches
argument_list|(
name|tbuf
argument_list|,
name|kinstance
argument_list|)
condition|)
name|sderr
argument_list|(
name|E_INSTANCE
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|sderr
argument_list|(
name|E_SCOPE
argument_list|,
name|tbuf
operator|+
literal|1
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
return|return
name|SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* Parse the SYNTAX section.  Uses one token lookahead. */
end_comment

begin_function
specifier|static
name|int
name|sdsyntax
parameter_list|(
name|tbuf
parameter_list|)
name|UNCH
modifier|*
name|tbuf
decl_stmt|;
block|{
if|if
condition|(
name|sdname
argument_list|(
name|tbuf
argument_list|,
name|ksyntax
argument_list|)
operator|==
name|FAIL
condition|)
return|return
name|FAIL
return|;
if|if
condition|(
name|sdparm
argument_list|(
name|tbuf
argument_list|,
literal|0
argument_list|)
operator|!=
name|NAS1
condition|)
block|{
name|sderr
argument_list|(
literal|120
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
if|if
condition|(
name|matches
argument_list|(
name|tbuf
argument_list|,
name|kpublic
argument_list|)
condition|)
return|return
name|sdpubsyntax
argument_list|(
name|tbuf
argument_list|)
return|;
return|return
name|sdxsyntax
argument_list|(
name|tbuf
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Parse the SYNTAX section which starts with PUBLIC.  Uses one token lookahead. */
end_comment

begin_function
specifier|static
name|int
name|sdpubsyntax
parameter_list|(
name|tbuf
parameter_list|)
name|UNCH
modifier|*
name|tbuf
decl_stmt|;
block|{
name|int
name|nswitches
decl_stmt|;
if|if
condition|(
name|sdparm
argument_list|(
name|tbuf
argument_list|,
operator|&
name|pcblitv
argument_list|)
operator|!=
name|LIT1
condition|)
return|return
name|FAIL
return|;
name|sdfixstandard
argument_list|(
name|tbuf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ustrcmp
argument_list|(
name|tbuf
argument_list|,
name|CORE_SYNTAX
argument_list|)
operator|==
literal|0
condition|)
name|sd
operator|.
name|shortref
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|ustrcmp
argument_list|(
name|tbuf
argument_list|,
name|REFERENCE_SYNTAX
argument_list|)
operator|==
literal|0
condition|)
name|sd
operator|.
name|shortref
operator|=
literal|1
expr_stmt|;
else|else
name|sderr
argument_list|(
name|E_SYNTAX
argument_list|,
name|tbuf
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sdparm
argument_list|(
name|tbuf
argument_list|,
literal|0
argument_list|)
operator|!=
name|NAS1
condition|)
return|return
name|SUCCESS
return|;
if|if
condition|(
operator|!
name|matches
argument_list|(
name|tbuf
argument_list|,
name|kswitches
argument_list|)
condition|)
return|return
name|SUCCESS
return|;
name|nswitches
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|errsw
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|sdparm
argument_list|(
name|tbuf
argument_list|,
literal|0
argument_list|)
operator|!=
name|NUM1
condition|)
break|break;
if|if
condition|(
name|atol
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tbuf
argument_list|)
operator|>
literal|255
condition|)
block|{
name|sderr
argument_list|(
name|E_CHARNUM
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|errsw
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|sdparm
argument_list|(
name|tbuf
argument_list|,
literal|0
argument_list|)
operator|!=
name|NUM1
condition|)
block|{
name|sderr
argument_list|(
name|E_XNUM
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
if|if
condition|(
operator|!
name|errsw
condition|)
block|{
if|if
condition|(
name|atol
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tbuf
argument_list|)
operator|>
literal|255
condition|)
name|sderr
argument_list|(
name|E_CHARNUM
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
name|nswitches
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|nswitches
operator|==
literal|0
condition|)
block|{
name|sderr
argument_list|(
name|E_XNUM
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
name|sderr
argument_list|(
name|E_SWITCHES
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* Parse an explicit concrete syntax. Uses one token lookahead. */
end_comment

begin_function
specifier|static
name|int
name|sdxsyntax
parameter_list|(
name|tbuf
parameter_list|)
name|UNCH
modifier|*
name|tbuf
decl_stmt|;
block|{
specifier|static
name|int
argument_list|(
argument|*section[]
argument_list|)
name|P
argument_list|(
operator|(
name|UNCH
operator|*
operator|)
argument_list|)
operator|=
block|{
name|sdshunchar
block|,
name|sdsynref
block|,
name|sdfunction
block|,
name|sdnaming
block|,
name|sddelim
block|,
name|sdnames
block|,
name|sdquantity
block|,      }
expr_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SIZEOF
argument_list|(
name|section
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
call|(
modifier|*
name|section
index|[
name|i
index|]
call|)
argument_list|(
name|tbuf
argument_list|)
operator|==
name|FAIL
condition|)
return|return
name|FAIL
return|;
return|return
name|SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* Parse the SHUNCHAR section. Uses one token lookahead. */
end_comment

begin_function
specifier|static
name|int
name|sdshunchar
parameter_list|(
name|tbuf
parameter_list|)
name|UNCH
modifier|*
name|tbuf
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
name|char_flags
index|[
name|i
index|]
operator|&=
operator|~
name|CHAR_SHUNNED
expr_stmt|;
if|if
condition|(
name|sdckname
argument_list|(
name|tbuf
argument_list|,
name|kshunchar
argument_list|)
operator|==
name|FAIL
condition|)
return|return
name|FAIL
return|;
if|if
condition|(
name|sdparm
argument_list|(
name|tbuf
argument_list|,
literal|0
argument_list|)
operator|==
name|NAS1
condition|)
block|{
if|if
condition|(
name|matches
argument_list|(
name|tbuf
argument_list|,
name|knone
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|sdparm
argument_list|(
name|tbuf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
if|if
condition|(
name|matches
argument_list|(
name|tbuf
argument_list|,
name|kcontrols
argument_list|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|ISASCII
argument_list|(
name|i
argument_list|)
operator|&&
name|iscntrl
argument_list|(
name|i
argument_list|)
condition|)
name|char_flags
index|[
name|i
index|]
operator||=
name|CHAR_SHUNNED
expr_stmt|;
if|if
condition|(
name|sdparm
argument_list|(
name|tbuf
argument_list|,
literal|0
argument_list|)
operator|!=
name|NUM1
condition|)
return|return
name|SUCCESS
return|;
block|}
block|}
if|if
condition|(
name|pcbsd
operator|.
name|action
operator|!=
name|NUM1
condition|)
block|{
name|sderr
argument_list|(
name|E_SHUNCHAR
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
do|do
block|{
name|long
name|n
init|=
name|atol
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tbuf
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|>
literal|255
condition|)
name|sderr
argument_list|(
name|E_CHARNUM
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
else|else
name|char_flags
index|[
operator|(
name|int
operator|)
name|n
index|]
operator||=
name|CHAR_SHUNNED
expr_stmt|;
block|}
do|while
condition|(
name|sdparm
argument_list|(
name|tbuf
argument_list|,
literal|0
argument_list|)
operator|==
name|NUM1
condition|)
do|;
return|return
name|SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* Parse the syntax reference character set. Uses one token lookahead. */
end_comment

begin_function
specifier|static
name|int
name|sdsynref
parameter_list|(
name|tbuf
parameter_list|)
name|UNCH
modifier|*
name|tbuf
decl_stmt|;
block|{
return|return
name|sdcsdesc
argument_list|(
name|tbuf
argument_list|,
name|synrefcharset
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Translate a character number from the syntax reference character set to the system character set. If it can't be done, give an error message and return -1. */
end_comment

begin_function
specifier|static
name|int
name|sdtranscharnum
parameter_list|(
name|tbuf
parameter_list|)
name|UNCH
modifier|*
name|tbuf
decl_stmt|;
block|{
name|long
name|n
init|=
name|atol
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tbuf
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|>
literal|255
condition|)
block|{
name|sderr
argument_list|(
name|E_CHARNUM
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
name|sdtranschar
argument_list|(
operator|(
name|int
operator|)
name|n
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sdtranschar
parameter_list|(
name|n
parameter_list|)
name|int
name|n
decl_stmt|;
block|{
name|int
name|ch
init|=
name|synrefcharset
index|[
name|n
index|]
decl_stmt|;
if|if
condition|(
name|ch
operator|>=
literal|0
condition|)
return|return
name|ch
return|;
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
name|UNUSED
case|:
name|sderr
argument_list|(
name|E_SYNREFUNUSED
argument_list|,
name|ltous
argument_list|(
operator|(
name|long
operator|)
name|n
argument_list|)
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNDESC
case|:
name|sderr
argument_list|(
name|E_SYNREFUNDESC
argument_list|,
name|ltous
argument_list|(
operator|(
name|long
operator|)
name|n
argument_list|)
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNKNOWN
case|:
name|sderr
argument_list|(
name|E_SYNREFUNKNOWN
argument_list|,
name|ltous
argument_list|(
operator|(
name|long
operator|)
name|n
argument_list|)
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNKNOWN_SET
case|:
name|sderr
argument_list|(
name|E_SYNREFUNKNOWNSET
argument_list|,
name|ltous
argument_list|(
operator|(
name|long
operator|)
name|n
argument_list|)
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Parse the function section. Uses two tokens lookahead. "NAMING" could be a function name. */
end_comment

begin_function
specifier|static
name|int
name|sdfunction
parameter_list|(
name|tbuf
parameter_list|)
name|UNCH
modifier|*
name|tbuf
decl_stmt|;
block|{
specifier|static
name|UNCH
modifier|*
name|fun
index|[]
init|=
block|{
name|kre
block|,
name|krs
block|,
name|kspace
block|}
decl_stmt|;
specifier|static
name|int
name|funval
index|[]
init|=
block|{
name|RECHAR
block|,
name|RSCHAR
block|,
literal|' '
block|}
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|had_tab
init|=
literal|0
decl_stmt|;
name|int
name|changed
init|=
literal|0
decl_stmt|;
comment|/* attempted to change reference syntax */
if|if
condition|(
name|sdckname
argument_list|(
name|tbuf
argument_list|,
name|kfunction
argument_list|)
operator|==
name|FAIL
condition|)
return|return
name|FAIL
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SIZEOF
argument_list|(
name|fun
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|int
name|ch
decl_stmt|;
if|if
condition|(
name|sdname
argument_list|(
name|tbuf
argument_list|,
name|fun
index|[
name|i
index|]
argument_list|)
operator|==
name|FAIL
condition|)
return|return
name|FAIL
return|;
if|if
condition|(
name|sdparm
argument_list|(
name|tbuf
argument_list|,
literal|0
argument_list|)
operator|!=
name|NUM1
condition|)
block|{
name|sderr
argument_list|(
name|E_XNUM
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
name|ch
operator|=
name|sdtranscharnum
argument_list|(
name|tbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|>=
literal|0
operator|&&
name|ch
operator|!=
name|funval
index|[
name|i
index|]
condition|)
name|changed
operator|=
literal|1
expr_stmt|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|tabsw
init|=
literal|0
decl_stmt|;
name|int
name|namingsw
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|sdparm
argument_list|(
name|tbuf
argument_list|,
literal|0
argument_list|)
operator|!=
name|NAS1
condition|)
block|{
name|sderr
argument_list|(
literal|120
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
if|if
condition|(
name|matches
argument_list|(
name|tbuf
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|"TAB"
argument_list|)
condition|)
block|{
name|tabsw
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|had_tab
condition|)
name|sderr
argument_list|(
name|E_FUNDUP
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SIZEOF
argument_list|(
name|fun
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|matches
argument_list|(
name|tbuf
argument_list|,
name|fun
index|[
name|i
index|]
argument_list|)
condition|)
name|sderr
argument_list|(
name|E_BADFUN
argument_list|,
name|fun
index|[
name|i
index|]
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|matches
argument_list|(
name|tbuf
argument_list|,
name|knaming
argument_list|)
condition|)
name|namingsw
operator|=
literal|1
expr_stmt|;
else|else
name|changed
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|sdparm
argument_list|(
name|tbuf
argument_list|,
literal|0
argument_list|)
operator|!=
name|NAS1
condition|)
block|{
name|sderr
argument_list|(
literal|120
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
if|if
condition|(
name|namingsw
condition|)
block|{
if|if
condition|(
name|matches
argument_list|(
name|tbuf
argument_list|,
name|klcnmstrt
argument_list|)
condition|)
break|break;
name|changed
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|sdparm
argument_list|(
name|tbuf
argument_list|,
literal|0
argument_list|)
operator|!=
name|NUM1
condition|)
block|{
name|sderr
argument_list|(
name|E_XNUM
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
if|if
condition|(
name|tabsw
operator|&&
operator|!
name|had_tab
condition|)
block|{
name|int
name|ch
init|=
name|sdtranscharnum
argument_list|(
name|tbuf
argument_list|)
decl_stmt|;
if|if
condition|(
name|ch
operator|>=
literal|0
operator|&&
name|ch
operator|!=
name|TABCHAR
condition|)
name|changed
operator|=
literal|1
expr_stmt|;
name|had_tab
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|had_tab
condition|)
name|changed
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|changed
condition|)
name|sderr
argument_list|(
name|E_FUNCHAR
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* Parse the NAMING section.  Uses no lookahead. */
end_comment

begin_function
specifier|static
name|int
name|sdnaming
parameter_list|(
name|tbuf
parameter_list|)
name|UNCH
modifier|*
name|tbuf
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|bad
init|=
literal|0
decl_stmt|;
specifier|static
name|UNCH
modifier|*
name|classes
index|[]
init|=
block|{
name|klcnmstrt
block|,
name|kucnmstrt
block|,
name|klcnmchar
block|,
name|kucnmchar
block|}
decl_stmt|;
specifier|static
name|UNCH
modifier|*
name|types
index|[]
init|=
block|{
name|kgeneral
block|,
name|kentity
block|}
decl_stmt|;
define|#
directive|define
name|NCLASSES
value|SIZEOF(classes)
name|int
name|bufsize
init|=
literal|4
decl_stmt|;
comment|/* allocated size of buf */
name|UNCH
modifier|*
name|buf
init|=
operator|(
name|UNCH
operator|*
operator|)
name|rmalloc
argument_list|(
name|bufsize
argument_list|)
decl_stmt|;
comment|/* holds characters 					      in naming classes */
name|int
name|bufi
init|=
literal|0
decl_stmt|;
comment|/* next index into buf */
name|int
name|start
index|[
name|NCLASSES
index|]
decl_stmt|;
comment|/* index of first character for each class */
name|int
name|count
index|[
name|NCLASSES
index|]
decl_stmt|;
comment|/* number of characters for each class */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCLASSES
condition|;
name|i
operator|++
control|)
block|{
name|UNCH
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|sdckname
argument_list|(
name|tbuf
argument_list|,
name|classes
index|[
name|i
index|]
argument_list|)
operator|==
name|FAIL
condition|)
block|{
name|frem
argument_list|(
operator|(
name|UNIV
operator|)
name|buf
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
if|if
condition|(
name|sdparm
argument_list|(
name|tbuf
argument_list|,
operator|&
name|pcblitp
argument_list|)
operator|!=
name|LIT1
condition|)
block|{
name|sderr
argument_list|(
literal|123
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|frem
argument_list|(
operator|(
name|UNIV
operator|)
name|buf
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
name|start
index|[
name|i
index|]
operator|=
name|bufi
expr_stmt|;
for|for
control|(
name|s
operator|=
name|tbuf
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
block|{
name|int
name|c
init|=
operator|*
name|s
decl_stmt|;
if|if
condition|(
name|c
operator|==
name|DELNONCH
condition|)
block|{
name|c
operator|=
name|UNSHIFTNON
argument_list|(
operator|*
name|s
argument_list|)
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
name|c
operator|=
name|sdtranschar
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|0
condition|)
name|bad
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|char_flags
index|[
name|c
index|]
operator|&
operator|(
name|CHAR_SIGNIFICANT
operator||
name|CHAR_MAGIC
operator|)
operator|)
operator|&&
name|c
operator|!=
literal|'.'
operator|&&
name|c
operator|!=
literal|'-'
condition|)
block|{
name|int
name|class
init|=
name|lextoke
index|[
name|c
index|]
decl_stmt|;
if|if
condition|(
name|class
operator|==
name|SEP
operator|||
name|class
operator|==
name|SP
operator|||
name|class
operator|==
name|NMC
operator|||
name|class
operator|==
name|NMS
operator|||
name|class
operator|==
name|NU
condition|)
name|sderr
argument_list|(
name|E_NMBAD
argument_list|,
name|ltous
argument_list|(
operator|(
name|long
operator|)
name|c
argument_list|)
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
else|else
name|sderr
argument_list|(
name|E_NMUNSUP
argument_list|,
name|ltous
argument_list|(
operator|(
name|long
operator|)
name|c
argument_list|)
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|bad
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|bufi
operator|>=
name|bufsize
condition|)
name|buf
operator|=
operator|(
name|UNCH
operator|*
operator|)
name|rrealloc
argument_list|(
operator|(
name|UNIV
operator|)
name|buf
argument_list|,
name|bufsize
operator|*=
literal|2
argument_list|)
expr_stmt|;
name|buf
index|[
name|bufi
operator|++
index|]
operator|=
name|c
expr_stmt|;
block|}
name|count
index|[
name|i
index|]
operator|=
name|bufi
operator|-
name|start
index|[
name|i
index|]
expr_stmt|;
operator|(
name|void
operator|)
name|sdparm
argument_list|(
name|tbuf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|bad
operator|&&
name|count
index|[
literal|0
index|]
operator|!=
name|count
index|[
literal|1
index|]
condition|)
block|{
name|sderr
argument_list|(
name|E_NMSTRTCNT
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|bad
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|bad
operator|&&
name|count
index|[
literal|2
index|]
operator|!=
name|count
index|[
literal|3
index|]
condition|)
block|{
name|sderr
argument_list|(
name|E_NMCHARCNT
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|bad
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|bad
condition|)
block|{
name|nlextoke
operator|=
operator|(
name|UNCH
operator|*
operator|)
name|rmalloc
argument_list|(
literal|256
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|UNIV
operator|)
name|nlextoke
argument_list|,
name|lextoke
argument_list|,
literal|256
argument_list|)
expr_stmt|;
name|nlextoke
index|[
literal|'.'
index|]
operator|=
name|nlextoke
index|[
literal|'-'
index|]
operator|=
name|INV
expr_stmt|;
name|nlextran
operator|=
operator|(
name|UNCH
operator|*
operator|)
name|rmalloc
argument_list|(
literal|256
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|UNIV
operator|)
name|nlextran
argument_list|,
name|lextran
argument_list|,
literal|256
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
index|[
literal|0
index|]
condition|;
name|i
operator|++
control|)
block|{
name|UNCH
name|lc
init|=
name|buf
index|[
name|start
index|[
literal|0
index|]
operator|+
name|i
index|]
decl_stmt|;
name|UNCH
name|uc
init|=
name|buf
index|[
name|start
index|[
literal|1
index|]
operator|+
name|i
index|]
decl_stmt|;
name|nlextoke
index|[
name|lc
index|]
operator|=
name|NMS
expr_stmt|;
name|nlextoke
index|[
name|uc
index|]
operator|=
name|NMS
expr_stmt|;
name|nlextran
index|[
name|lc
index|]
operator|=
name|uc
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
index|[
literal|2
index|]
condition|;
name|i
operator|++
control|)
block|{
name|UNCH
name|lc
init|=
name|buf
index|[
name|start
index|[
literal|2
index|]
operator|+
name|i
index|]
decl_stmt|;
name|UNCH
name|uc
init|=
name|buf
index|[
name|start
index|[
literal|3
index|]
operator|+
name|i
index|]
decl_stmt|;
if|if
condition|(
name|nlextoke
index|[
name|lc
index|]
operator|==
name|NMS
condition|)
block|{
name|sderr
argument_list|(
name|E_NMDUP
argument_list|,
name|ltous
argument_list|(
operator|(
name|long
operator|)
name|lc
argument_list|)
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|bad
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nlextoke
index|[
name|uc
index|]
operator|==
name|NMS
condition|)
block|{
name|sderr
argument_list|(
name|E_NMDUP
argument_list|,
name|ltous
argument_list|(
operator|(
name|long
operator|)
name|uc
argument_list|)
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|bad
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|nlextoke
index|[
name|lc
index|]
operator|=
name|NMC
expr_stmt|;
name|nlextoke
index|[
name|uc
index|]
operator|=
name|NMC
expr_stmt|;
name|nlextran
index|[
name|lc
index|]
operator|=
name|uc
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nlextoke
index|[
literal|'-'
index|]
operator|!=
name|NMC
condition|)
block|{
name|sderr
argument_list|(
name|E_NMMINUS
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|bad
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|bad
condition|)
block|{
if|if
condition|(
name|nlextoke
condition|)
block|{
name|frem
argument_list|(
operator|(
name|UNIV
operator|)
name|nlextoke
argument_list|)
expr_stmt|;
name|nlextoke
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|nlextran
condition|)
block|{
name|frem
argument_list|(
operator|(
name|UNIV
operator|)
name|nlextran
argument_list|)
expr_stmt|;
name|nlextran
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
name|frem
argument_list|(
operator|(
name|UNIV
operator|)
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|sdckname
argument_list|(
name|tbuf
argument_list|,
name|knamecase
argument_list|)
operator|==
name|FAIL
condition|)
return|return
name|FAIL
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SIZEOF
argument_list|(
name|types
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|sdname
argument_list|(
name|tbuf
argument_list|,
name|types
index|[
name|i
index|]
argument_list|)
operator|==
name|FAIL
condition|)
return|return
name|FAIL
return|;
if|if
condition|(
name|sdparm
argument_list|(
name|tbuf
argument_list|,
literal|0
argument_list|)
operator|!=
name|NAS1
condition|)
block|{
name|sderr
argument_list|(
literal|120
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
if|if
condition|(
name|matches
argument_list|(
name|tbuf
argument_list|,
name|kyes
argument_list|)
condition|)
name|sd
operator|.
name|namecase
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|matches
argument_list|(
name|tbuf
argument_list|,
name|kno
argument_list|)
condition|)
name|sd
operator|.
name|namecase
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|sderr
argument_list|(
name|E_YESNO
argument_list|,
name|tbuf
operator|+
literal|1
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
block|}
return|return
name|SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* Parse the DELIM section. Uses one token lookahead. */
end_comment

begin_function
specifier|static
name|int
name|sddelim
parameter_list|(
name|tbuf
parameter_list|)
name|UNCH
modifier|*
name|tbuf
decl_stmt|;
block|{
name|int
name|changed
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|sdname
argument_list|(
name|tbuf
argument_list|,
name|kdelim
argument_list|)
operator|==
name|FAIL
operator|||
name|sdname
argument_list|(
name|tbuf
argument_list|,
name|kgeneral
argument_list|)
operator|==
name|FAIL
operator|||
name|sdname
argument_list|(
name|tbuf
argument_list|,
name|ksgmlref
argument_list|)
operator|==
name|FAIL
condition|)
return|return
name|FAIL
return|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|sdparm
argument_list|(
name|tbuf
argument_list|,
literal|0
argument_list|)
operator|!=
name|NAS1
condition|)
block|{
name|sderr
argument_list|(
literal|120
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
if|if
condition|(
name|matches
argument_list|(
name|tbuf
argument_list|,
name|kshortref
argument_list|)
condition|)
break|break;
if|if
condition|(
name|sdparm
argument_list|(
name|tbuf
argument_list|,
operator|&
name|pcblitp
argument_list|)
operator|!=
name|LIT1
condition|)
block|{
name|sderr
argument_list|(
literal|123
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
name|changed
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|changed
condition|)
block|{
name|sderr
argument_list|(
name|E_GENDELIM
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|changed
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|sdparm
argument_list|(
name|tbuf
argument_list|,
literal|0
argument_list|)
operator|!=
name|NAS1
condition|)
block|{
name|sderr
argument_list|(
literal|120
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
if|if
condition|(
name|matches
argument_list|(
name|tbuf
argument_list|,
name|ksgmlref
argument_list|)
condition|)
name|sd
operator|.
name|shortref
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|matches
argument_list|(
name|tbuf
argument_list|,
name|knone
argument_list|)
condition|)
name|sd
operator|.
name|shortref
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|sderr
argument_list|(
literal|118
argument_list|,
name|tbuf
operator|+
literal|1
argument_list|,
name|ksgmlref
argument_list|)
expr_stmt|;
comment|/* probably they forgot SGMLREF */
return|return
name|FAIL
return|;
block|}
while|while
condition|(
name|sdparm
argument_list|(
name|tbuf
argument_list|,
operator|&
name|pcblitp
argument_list|)
operator|==
name|LIT1
condition|)
name|changed
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|changed
condition|)
name|sderr
argument_list|(
name|E_SRDELIM
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* Parse the NAMES section. Uses one token lookahead. */
end_comment

begin_function
specifier|static
name|int
name|sdnames
parameter_list|(
name|tbuf
parameter_list|)
name|UNCH
modifier|*
name|tbuf
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|sdckname
argument_list|(
name|tbuf
argument_list|,
name|knames
argument_list|)
operator|==
name|FAIL
condition|)
return|return
name|FAIL
return|;
if|if
condition|(
name|sdname
argument_list|(
name|tbuf
argument_list|,
name|ksgmlref
argument_list|)
operator|==
name|FAIL
condition|)
return|return
name|FAIL
return|;
while|while
condition|(
name|sdparm
argument_list|(
name|tbuf
argument_list|,
literal|0
argument_list|)
operator|==
name|NAS1
condition|)
block|{
name|int
name|j
decl_stmt|;
if|if
condition|(
name|matches
argument_list|(
name|tbuf
argument_list|,
name|kquantity
argument_list|)
condition|)
break|break;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NKEYS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|matches
argument_list|(
name|tbuf
argument_list|,
name|key
index|[
name|i
index|]
argument_list|)
condition|)
break|break;
if|if
condition|(
name|i
operator|>=
name|NKEYS
condition|)
block|{
name|sderr
argument_list|(
name|E_BADKEY
argument_list|,
name|tbuf
operator|+
literal|1
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
if|if
condition|(
name|sdparm
argument_list|(
name|tbuf
argument_list|,
operator|&
name|pcblitp
argument_list|)
operator|!=
name|NAS1
condition|)
block|{
name|sderr
argument_list|(
literal|120
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
if|if
condition|(
operator|!
name|newkey
condition|)
block|{
name|newkey
operator|=
operator|(
name|UNCH
argument_list|(
operator|*
argument_list|)
index|[
name|REFNAMELEN
operator|+
literal|1
index|]
operator|)
name|rmalloc
argument_list|(
operator|(
name|REFNAMELEN
operator|+
literal|1
operator|)
operator|*
name|NKEYS
argument_list|)
expr_stmt|;
name|MEMZERO
argument_list|(
operator|(
name|UNIV
operator|)
name|newkey
argument_list|,
operator|(
name|REFNAMELEN
operator|+
literal|1
operator|)
operator|*
name|NKEYS
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|NKEYS
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|matches
argument_list|(
name|tbuf
argument_list|,
name|key
index|[
name|j
index|]
argument_list|)
condition|)
block|{
name|sderr
argument_list|(
name|E_REFNAME
argument_list|,
name|tbuf
operator|+
literal|1
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|matches
argument_list|(
name|tbuf
argument_list|,
name|newkey
index|[
name|j
index|]
argument_list|)
condition|)
block|{
name|sderr
argument_list|(
name|E_DUPNAME
argument_list|,
name|tbuf
operator|+
literal|1
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|j
operator|>=
name|NKEYS
condition|)
name|ustrcpy
argument_list|(
name|newkey
index|[
name|i
index|]
argument_list|,
name|tbuf
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Now install the new keys. */
if|if
condition|(
name|newkey
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NKEYS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|newkey
index|[
name|i
index|]
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|UNCH
name|temp
index|[
name|REFNAMELEN
operator|+
literal|1
index|]
decl_stmt|;
name|ustrcpy
argument_list|(
name|temp
argument_list|,
name|key
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ustrcpy
argument_list|(
name|key
index|[
name|i
index|]
argument_list|,
name|newkey
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ustrcpy
argument_list|(
name|newkey
index|[
name|i
index|]
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* Parse the QUANTITY section. Uses one token lookahead. */
end_comment

begin_function
specifier|static
name|int
name|sdquantity
parameter_list|(
name|tbuf
parameter_list|)
name|UNCH
modifier|*
name|tbuf
decl_stmt|;
block|{
name|int
name|quantity
index|[
name|NQUANTITY
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NQUANTITY
condition|;
name|i
operator|++
control|)
name|quantity
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|sdckname
argument_list|(
name|tbuf
argument_list|,
name|kquantity
argument_list|)
operator|==
name|FAIL
condition|)
return|return
name|FAIL
return|;
if|if
condition|(
name|sdname
argument_list|(
name|tbuf
argument_list|,
name|ksgmlref
argument_list|)
operator|==
name|FAIL
condition|)
return|return
name|FAIL
return|;
while|while
condition|(
name|sdparm
argument_list|(
name|tbuf
argument_list|,
literal|0
argument_list|)
operator|==
name|NAS1
operator|&&
operator|!
name|matches
argument_list|(
name|tbuf
argument_list|,
name|kfeatures
argument_list|)
condition|)
block|{
name|long
name|n
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SIZEOF
argument_list|(
name|quantity_names
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|matches
argument_list|(
name|tbuf
argument_list|,
name|quantity_names
index|[
name|i
index|]
argument_list|)
condition|)
break|break;
if|if
condition|(
name|i
operator|>=
name|SIZEOF
argument_list|(
name|quantity_names
argument_list|)
condition|)
block|{
name|sderr
argument_list|(
name|E_BADQUANTITY
argument_list|,
name|tbuf
operator|+
literal|1
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
if|if
condition|(
name|sdparm
argument_list|(
name|tbuf
argument_list|,
literal|0
argument_list|)
operator|!=
name|NUM1
condition|)
block|{
name|sderr
argument_list|(
name|E_XNUM
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
name|n
operator|=
name|atol
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
name|sd
operator|.
name|quantity
index|[
name|i
index|]
condition|)
name|sderr
argument_list|(
name|E_QUANTITY
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
name|quantity_names
index|[
name|i
index|]
argument_list|,
name|ltous
argument_list|(
operator|(
name|long
operator|)
name|sd
operator|.
name|quantity
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|n
operator|>
name|max_quantity
index|[
name|i
index|]
condition|)
block|{
name|sderr
argument_list|(
name|E_QTOOBIG
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
name|quantity_names
index|[
name|i
index|]
argument_list|,
name|ltous
argument_list|(
operator|(
name|long
operator|)
name|max_quantity
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|quantity
index|[
name|i
index|]
operator|=
name|max_quantity
index|[
name|i
index|]
expr_stmt|;
block|}
else|else
name|quantity
index|[
name|i
index|]
operator|=
operator|(
name|int
operator|)
name|n
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NQUANTITY
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|quantity
index|[
name|i
index|]
operator|>
literal|0
condition|)
block|{
name|sd
operator|.
name|quantity
index|[
name|i
index|]
operator|=
name|quantity
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|quantity_changed
condition|)
name|quantity_changed
operator|=
operator|(
name|char
operator|*
operator|)
name|rmalloc
argument_list|(
name|NQUANTITY
argument_list|)
expr_stmt|;
name|quantity_changed
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* Parse the FEATURES section.  Uses no lookahead. */
end_comment

begin_function
specifier|static
name|int
name|sdfeatures
parameter_list|(
name|tbuf
parameter_list|)
name|UNCH
modifier|*
name|tbuf
decl_stmt|;
block|{
specifier|static
struct|struct
block|{
name|UNCH
modifier|*
name|name
decl_stmt|;
name|UNCH
name|argtype
decl_stmt|;
comment|/* 0 = no argument, 1 = boolean, 2 = numeric */
name|UNIV
name|valp
decl_stmt|;
comment|/* UNCH * if boolean, long * if numeric. */
block|}
name|features
index|[]
init|=
block|{
block|{
name|kminimize
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|kdatatag
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
name|komittag
block|,
literal|1
block|,
operator|(
name|UNIV
operator|)
operator|&
name|sd
operator|.
name|omittag
block|}
block|,
block|{
name|krank
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
name|kshorttag
block|,
literal|1
block|,
operator|(
name|UNIV
operator|)
operator|&
name|sd
operator|.
name|shorttag
block|}
block|,
block|{
name|klink
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|ksimple
block|,
literal|2
block|,
literal|0
block|}
block|,
block|{
name|kimplicit
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
name|kexplicit
block|,
literal|2
block|,
literal|0
block|}
block|,
block|{
name|kother
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|kconcur
block|,
literal|2
block|,
literal|0
block|}
block|,
block|{
name|ksubdoc
block|,
literal|2
block|,
operator|(
name|UNIV
operator|)
operator|&
name|sd
operator|.
name|subdoc
block|}
block|,
block|{
name|kformal
block|,
literal|1
block|,
operator|(
name|UNIV
operator|)
operator|&
name|sd
operator|.
name|formal
block|}
block|,      }
struct|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|sdckname
argument_list|(
name|tbuf
argument_list|,
name|kfeatures
argument_list|)
operator|==
name|FAIL
condition|)
return|return
name|FAIL
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SIZEOF
argument_list|(
name|features
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sdname
argument_list|(
name|tbuf
argument_list|,
name|features
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|==
name|FAIL
condition|)
return|return
name|FAIL
return|;
if|if
condition|(
name|features
index|[
name|i
index|]
operator|.
name|argtype
operator|>
literal|0
condition|)
block|{
name|long
name|n
decl_stmt|;
if|if
condition|(
name|sdparm
argument_list|(
name|tbuf
argument_list|,
literal|0
argument_list|)
operator|!=
name|NAS1
condition|)
block|{
name|sderr
argument_list|(
literal|120
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
if|if
condition|(
name|matches
argument_list|(
name|tbuf
argument_list|,
name|kyes
argument_list|)
condition|)
block|{
if|if
condition|(
name|features
index|[
name|i
index|]
operator|.
name|argtype
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|sdparm
argument_list|(
name|tbuf
argument_list|,
literal|0
argument_list|)
operator|!=
name|NUM1
condition|)
block|{
name|sderr
argument_list|(
name|E_XNUM
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
name|n
operator|=
name|atol
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
name|sderr
argument_list|(
name|E_ZEROFEATURE
argument_list|,
name|features
index|[
name|i
index|]
operator|.
name|name
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|n
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|matches
argument_list|(
name|tbuf
argument_list|,
name|kno
argument_list|)
condition|)
name|n
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|sderr
argument_list|(
name|E_YESNO
argument_list|,
name|tbuf
operator|+
literal|1
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
if|if
condition|(
name|features
index|[
name|i
index|]
operator|.
name|valp
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|n
operator|>
literal|0
condition|)
name|sderr
argument_list|(
name|E_NOTSUPPORTED
argument_list|,
name|features
index|[
name|i
index|]
operator|.
name|name
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|features
index|[
name|i
index|]
operator|.
name|argtype
operator|>
literal|1
condition|)
operator|*
operator|(
name|long
operator|*
operator|)
name|features
index|[
name|i
index|]
operator|.
name|valp
operator|=
name|n
expr_stmt|;
else|else
operator|*
operator|(
name|UNCH
operator|*
operator|)
name|features
index|[
name|i
index|]
operator|.
name|valp
operator|=
operator|(
name|UNCH
operator|)
name|n
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|sd
operator|.
name|shorttag
condition|)
name|noemptytag
argument_list|()
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* Parse the APPINFO section.  Uses no lookahead. */
end_comment

begin_function
specifier|static
name|int
name|sdappinfo
parameter_list|(
name|tbuf
parameter_list|)
name|UNCH
modifier|*
name|tbuf
decl_stmt|;
block|{
if|if
condition|(
name|sdname
argument_list|(
name|tbuf
argument_list|,
name|kappinfo
argument_list|)
operator|==
name|FAIL
condition|)
return|return
name|FAIL
return|;
switch|switch
condition|(
name|sdparm
argument_list|(
name|tbuf
argument_list|,
operator|&
name|pcblitv
argument_list|)
condition|)
block|{
case|case
name|LIT1
case|:
name|appinfosw
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|NAS1
case|:
if|if
condition|(
name|matches
argument_list|(
name|tbuf
argument_list|,
name|knone
argument_list|)
condition|)
break|break;
name|sderr
argument_list|(
literal|118
argument_list|,
name|tbuf
operator|+
literal|1
argument_list|,
name|knone
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
default|default:
name|sderr
argument_list|(
name|E_XNMLIT
argument_list|,
name|knone
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
return|return
name|SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* Change a prefix of ISO 8879-1986 to ISO 8879:1986.  Amendment 1 to the standard requires the latter. */
end_comment

begin_function
specifier|static
name|VOID
name|sdfixstandard
parameter_list|(
name|tbuf
parameter_list|,
name|silently
parameter_list|)
name|UNCH
modifier|*
name|tbuf
decl_stmt|;
name|int
name|silently
decl_stmt|;
block|{
if|if
condition|(
name|strncmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tbuf
argument_list|,
literal|"ISO 8879-1986"
argument_list|,
literal|13
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|silently
condition|)
name|sderr
argument_list|(
name|E_STANDARD
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|tbuf
index|[
literal|8
index|]
operator|=
literal|':'
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|sdname
parameter_list|(
name|tbuf
parameter_list|,
name|key
parameter_list|)
name|UNCH
modifier|*
name|tbuf
decl_stmt|;
name|UNCH
modifier|*
name|key
decl_stmt|;
block|{
if|if
condition|(
name|sdparm
argument_list|(
name|tbuf
argument_list|,
literal|0
argument_list|)
operator|!=
name|NAS1
condition|)
block|{
name|sderr
argument_list|(
literal|120
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
if|if
condition|(
operator|!
name|matches
argument_list|(
name|tbuf
argument_list|,
name|key
argument_list|)
condition|)
block|{
name|sderr
argument_list|(
literal|118
argument_list|,
name|tbuf
operator|+
literal|1
argument_list|,
name|key
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
return|return
name|SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sdckname
parameter_list|(
name|tbuf
parameter_list|,
name|key
parameter_list|)
name|UNCH
modifier|*
name|tbuf
decl_stmt|;
name|UNCH
modifier|*
name|key
decl_stmt|;
block|{
if|if
condition|(
name|pcbsd
operator|.
name|action
operator|!=
name|NAS1
condition|)
block|{
name|sderr
argument_list|(
literal|120
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
if|if
condition|(
operator|!
name|matches
argument_list|(
name|tbuf
argument_list|,
name|key
argument_list|)
condition|)
block|{
name|sderr
argument_list|(
literal|118
argument_list|,
name|tbuf
operator|+
literal|1
argument_list|,
name|key
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
return|return
name|SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* Parse a SGML declaration parameter.  If lpcb is NULL, pt must be REFNAMELEN+2 characters long, otherwise at least LITLEN+2 characters long. LPCB should be NULL if a literal is not allowed. */
end_comment

begin_function
specifier|static
name|int
name|sdparm
parameter_list|(
name|pt
parameter_list|,
name|lpcb
parameter_list|)
name|UNCH
modifier|*
name|pt
decl_stmt|;
comment|/* Token buffer. */
name|struct
name|parse
modifier|*
name|lpcb
decl_stmt|;
comment|/* PCB for literal parse. */
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|parse
argument_list|(
operator|&
name|pcbsd
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcbsd
operator|.
name|action
operator|!=
name|ISIG
condition|)
break|break;
name|sderr
argument_list|(
name|E_SIGNIFICANT
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
operator|++
name|parmno
expr_stmt|;
switch|switch
condition|(
name|pcbsd
operator|.
name|action
condition|)
block|{
case|case
name|LIT1
case|:
if|if
condition|(
operator|!
name|lpcb
condition|)
block|{
name|sderr
argument_list|(
name|E_BADLIT
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|REPEATCC
expr_stmt|;
return|return
name|pcbsd
operator|.
name|action
operator|=
name|INV_
return|;
block|}
name|parselit
argument_list|(
name|pt
argument_list|,
name|lpcb
argument_list|,
name|REFLITLEN
argument_list|,
name|lex
operator|.
name|d
operator|.
name|lit
argument_list|)
expr_stmt|;
return|return
name|pcbsd
operator|.
name|action
return|;
case|case
name|LIT2
case|:
if|if
condition|(
operator|!
name|lpcb
condition|)
block|{
name|sderr
argument_list|(
name|E_BADLIT
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|REPEATCC
expr_stmt|;
return|return
name|pcbsd
operator|.
name|action
operator|=
name|INV_
return|;
block|}
name|parselit
argument_list|(
name|pt
argument_list|,
name|lpcb
argument_list|,
name|REFLITLEN
argument_list|,
name|lex
operator|.
name|d
operator|.
name|lita
argument_list|)
expr_stmt|;
return|return
name|pcbsd
operator|.
name|action
operator|=
name|LIT1
return|;
case|case
name|NAS1
case|:
name|parsenm
argument_list|(
name|pt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|pcbsd
operator|.
name|action
return|;
case|case
name|NUM1
case|:
name|parsetkn
argument_list|(
name|pt
argument_list|,
name|NU
argument_list|,
name|REFNAMELEN
argument_list|)
expr_stmt|;
return|return
name|pcbsd
operator|.
name|action
return|;
block|}
return|return
name|pcbsd
operator|.
name|action
return|;
block|}
end_function

begin_function
name|VOID
name|sdinit
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
comment|/* Shunned character numbers in the reference concrete syntax. */
specifier|static
name|UNCH
name|refshun
index|[]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|,
literal|15
block|,
literal|16
block|,
literal|17
block|,
literal|18
block|,
literal|19
block|,
literal|20
block|,
literal|21
block|,
literal|22
block|,
literal|23
block|,
literal|24
block|,
literal|25
block|,
literal|26
block|,
literal|27
block|,
literal|28
block|,
literal|29
block|,
literal|30
block|,
literal|31
block|,
literal|127
block|,
literal|255
block|}
decl_stmt|;
name|UNCH
modifier|*
modifier|*
name|p
decl_stmt|;
comment|/* A character is magic if it is a non-SGML character used for      some internal purpose in the parser. */
name|char_flags
index|[
name|EOS
index|]
operator||=
name|CHAR_MAGIC
expr_stmt|;
name|char_flags
index|[
name|EOBCHAR
index|]
operator||=
name|CHAR_MAGIC
expr_stmt|;
name|char_flags
index|[
name|EOFCHAR
index|]
operator||=
name|CHAR_MAGIC
expr_stmt|;
name|char_flags
index|[
name|GENRECHAR
index|]
operator||=
name|CHAR_MAGIC
expr_stmt|;
name|char_flags
index|[
name|DELNONCH
index|]
operator||=
name|CHAR_MAGIC
expr_stmt|;
name|char_flags
index|[
name|DELCDATA
index|]
operator||=
name|CHAR_MAGIC
expr_stmt|;
name|char_flags
index|[
name|DELSDATA
index|]
operator||=
name|CHAR_MAGIC
expr_stmt|;
comment|/* Figure out the significant SGML characters. */
for|for
control|(
name|p
operator|=
name|lextabs
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
block|{
name|UNCH
name|datclass
init|=
operator|(
operator|*
name|p
operator|)
index|[
name|CANON_DATACHAR
index|]
decl_stmt|;
name|UNCH
name|nonclass
init|=
operator|(
operator|*
name|p
operator|)
index|[
name|CANON_NONSGML
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
operator|(
name|char_flags
index|[
name|i
index|]
operator|&
name|CHAR_MAGIC
operator|)
operator|&&
operator|(
operator|*
name|p
operator|)
index|[
name|i
index|]
operator|!=
name|datclass
operator|&&
operator|(
operator|*
name|p
operator|)
index|[
name|i
index|]
operator|!=
name|nonclass
condition|)
name|char_flags
index|[
name|i
index|]
operator||=
name|CHAR_SIGNIFICANT
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SIZEOF
argument_list|(
name|refshun
argument_list|)
condition|;
name|i
operator|++
control|)
name|char_flags
index|[
name|refshun
index|[
name|i
index|]
index|]
operator||=
name|CHAR_SHUNNED
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|ISASCII
argument_list|(
name|i
argument_list|)
operator|&&
name|iscntrl
argument_list|(
name|i
argument_list|)
condition|)
name|char_flags
index|[
name|i
index|]
operator||=
name|CHAR_SHUNNED
expr_stmt|;
name|bufsalloc
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|VOID
name|bufsalloc
parameter_list|()
block|{
name|scbs
operator|=
operator|(
expr|struct
name|source
operator|*
operator|)
name|rmalloc
argument_list|(
operator|(
name|REFENTLVL
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|source
argument_list|)
argument_list|)
expr_stmt|;
name|tbuf
operator|=
operator|(
name|UNCH
operator|*
operator|)
name|rmalloc
argument_list|(
name|REFATTSPLEN
operator|+
name|REFLITLEN
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* entbuf is used for parsing numeric character references */
name|entbuf
operator|=
operator|(
name|UNCH
operator|*
operator|)
name|rmalloc
argument_list|(
name|REFNAMELEN
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|VOID
name|bufsrealloc
parameter_list|()
block|{
name|UNS
name|size
decl_stmt|;
if|if
condition|(
name|ENTLVL
operator|!=
name|REFENTLVL
condition|)
name|scbs
operator|=
operator|(
expr|struct
name|source
operator|*
operator|)
name|rrealloc
argument_list|(
operator|(
name|UNIV
operator|)
name|scbs
argument_list|,
operator|(
name|ENTLVL
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|source
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Calculate the size for tbuf. */
name|size
operator|=
name|LITLEN
operator|+
name|ATTSPLEN
expr_stmt|;
if|if
condition|(
name|PILEN
operator|>
name|size
condition|)
name|size
operator|=
name|PILEN
expr_stmt|;
if|if
condition|(
name|BSEQLEN
operator|>
name|size
condition|)
name|size
operator|=
name|BSEQLEN
expr_stmt|;
if|if
condition|(
name|size
operator|!=
name|REFATTSPLEN
operator|+
name|REFLITLEN
condition|)
name|tbuf
operator|=
operator|(
name|UNCH
operator|*
operator|)
name|rrealloc
argument_list|(
operator|(
name|UNIV
operator|)
name|tbuf
argument_list|,
name|size
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|NAMELEN
operator|!=
name|REFNAMELEN
condition|)
name|entbuf
operator|=
operator|(
name|UNCH
operator|*
operator|)
name|rrealloc
argument_list|(
operator|(
name|UNIV
operator|)
name|entbuf
argument_list|,
name|NAMELEN
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Check that the non-SGML characters are compatible with the concrete syntax and munge the lexical tables accordingly.  If IMPLIED is non-zero, then the SGML declaration was implied; in this case, don't give error messages about shunned characters not being declared non-SGML.  Also make any changes that are required by the NAMING section. */
end_comment

begin_function
specifier|static
name|VOID
name|setlexical
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|UNCH
modifier|*
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|nlextoke
condition|)
block|{
comment|/* Handle characters that were made significant by the 	     NAMING section. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|nlextoke
index|[
name|i
index|]
operator|==
name|NMC
operator|||
name|nlextoke
index|[
name|i
index|]
operator|==
name|NMS
condition|)
name|char_flags
index|[
name|i
index|]
operator||=
name|CHAR_SIGNIFICANT
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|char_flags
index|[
name|i
index|]
operator|&
name|CHAR_SIGNIFICANT
condition|)
block|{
comment|/* Significant SGML characters musn't be non-SGML. */
if|if
condition|(
name|char_flags
index|[
name|i
index|]
operator|&
name|CHAR_NONSGML
condition|)
block|{
name|UNCH
name|buf
index|[
literal|2
index|]
decl_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
name|i
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|sderr
argument_list|(
name|E_NONSGML
argument_list|,
name|buf
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|char_flags
index|[
name|i
index|]
operator|&=
operator|~
name|CHAR_NONSGML
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Shunned characters that are not significant SGML characters 		  must be non-SGML. */
if|if
condition|(
operator|(
name|char_flags
index|[
name|i
index|]
operator|&
operator|(
name|CHAR_SHUNNED
operator||
name|CHAR_NONSGML
operator|)
operator|)
operator|==
name|CHAR_SHUNNED
condition|)
block|{
name|sderr
argument_list|(
name|E_SHUNNED
argument_list|,
name|ltous
argument_list|(
operator|(
name|long
operator|)
name|i
argument_list|)
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|char_flags
index|[
name|i
index|]
operator||=
name|CHAR_NONSGML
expr_stmt|;
block|}
block|}
comment|/* Now munge the lexical tables. */
for|for
control|(
name|p
operator|=
name|lextabs
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
block|{
name|UNCH
name|nonclass
init|=
operator|(
operator|*
name|p
operator|)
index|[
name|CANON_NONSGML
index|]
decl_stmt|;
name|UNCH
name|datclass
init|=
operator|(
operator|*
name|p
operator|)
index|[
name|CANON_DATACHAR
index|]
decl_stmt|;
name|UNCH
name|nmcclass
init|=
operator|(
operator|*
name|p
operator|)
index|[
name|CANON_NMC
index|]
decl_stmt|;
name|UNCH
name|nmsclass
init|=
operator|(
operator|*
name|p
operator|)
index|[
name|CANON_NMS
index|]
decl_stmt|;
name|UNCH
name|minclass
init|=
operator|(
operator|*
name|p
operator|)
index|[
name|CANON_MIN
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|char_flags
index|[
name|i
index|]
operator|&
name|CHAR_NONSGML
condition|)
block|{
comment|/* We already know that it's not significant. */
if|if
condition|(
operator|!
operator|(
name|char_flags
index|[
name|i
index|]
operator|&
name|CHAR_MAGIC
operator|)
condition|)
operator|(
operator|*
name|p
operator|)
index|[
name|i
index|]
operator|=
name|nonclass
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|char_flags
index|[
name|i
index|]
operator|&
name|CHAR_MAGIC
condition|)
block|{
name|sderr
argument_list|(
name|E_MUSTBENON
argument_list|,
name|ltous
argument_list|(
operator|(
name|long
operator|)
name|i
argument_list|)
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|char_flags
index|[
name|i
index|]
operator|&
name|CHAR_SIGNIFICANT
operator|)
condition|)
operator|(
operator|*
name|p
operator|)
index|[
name|i
index|]
operator|=
name|datclass
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
name|lexmin
condition|)
block|{
comment|/* If it used to be NONSGML, but its now significant, 			    treat it like a datachar. */
if|if
condition|(
operator|(
operator|*
name|p
operator|)
index|[
name|i
index|]
operator|==
name|nonclass
condition|)
operator|(
operator|*
name|p
operator|)
index|[
name|i
index|]
operator|=
name|datclass
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nlextoke
comment|/* This relies on the fact that lextoke 				occurs last in lextabs. */
operator|&&
name|lextoke
index|[
name|i
index|]
operator|!=
name|nlextoke
index|[
name|i
index|]
condition|)
block|{
switch|switch
condition|(
name|nlextoke
index|[
name|i
index|]
condition|)
block|{
case|case
name|NMC
case|:
operator|(
operator|*
name|p
operator|)
index|[
name|i
index|]
operator|=
name|nmcclass
expr_stmt|;
break|break;
case|case
name|NMS
case|:
operator|(
operator|*
name|p
operator|)
index|[
name|i
index|]
operator|=
name|nmsclass
expr_stmt|;
break|break;
case|case
name|INV
case|:
comment|/* This will happen if period is not a 				 name character. */
operator|(
operator|*
name|p
operator|)
index|[
name|i
index|]
operator|=
name|minclass
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
if|if
condition|(
name|nlextran
condition|)
block|{
name|memcpy
argument_list|(
operator|(
name|UNIV
operator|)
name|lextran
argument_list|,
operator|(
name|UNIV
operator|)
name|nlextran
argument_list|,
literal|256
argument_list|)
expr_stmt|;
name|frem
argument_list|(
operator|(
name|UNIV
operator|)
name|nlextran
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nlextoke
condition|)
block|{
name|frem
argument_list|(
operator|(
name|UNIV
operator|)
name|nlextoke
argument_list|)
expr_stmt|;
name|nlextoke
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Munge parse tables so that empty start and end tags are not recognized. */
end_comment

begin_function
specifier|static
name|VOID
name|noemptytag
parameter_list|()
block|{
specifier|static
name|struct
name|parse
modifier|*
name|pcbs
index|[]
init|=
block|{
operator|&
name|pcbconm
block|,
operator|&
name|pcbcone
block|,
operator|&
name|pcbconr
block|,
operator|&
name|pcbconc
block|}
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SIZEOF
argument_list|(
name|pcbs
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|int
name|maxclass
decl_stmt|,
name|maxstate
decl_stmt|;
name|int
name|j
decl_stmt|,
name|k
decl_stmt|,
name|act
decl_stmt|;
name|UNCH
modifier|*
name|plex
init|=
name|pcbs
index|[
name|i
index|]
operator|->
name|plex
decl_stmt|;
name|UNCH
modifier|*
modifier|*
name|ptab
init|=
name|pcbs
index|[
name|i
index|]
operator|->
name|ptab
decl_stmt|;
comment|/* Figure out the maximum lexical class. */
name|maxclass
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|256
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|plex
index|[
name|j
index|]
operator|>
name|maxclass
condition|)
name|maxclass
operator|=
name|plex
index|[
name|j
index|]
expr_stmt|;
comment|/* Now figure out the maximum state number and at the same time 	     change actions. */
name|maxstate
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
name|maxstate
condition|;
name|j
operator|+=
literal|2
control|)
block|{
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<=
name|maxclass
condition|;
name|k
operator|++
control|)
if|if
condition|(
name|ptab
index|[
name|j
index|]
index|[
name|k
index|]
operator|>
name|maxstate
condition|)
name|maxstate
operator|=
name|ptab
index|[
name|j
index|]
index|[
name|k
index|]
expr_stmt|;
comment|/* If the '>' class has an empty start or end tag action, 		  change it to the action that the NMC class has. */
name|act
operator|=
name|ptab
index|[
name|j
operator|+
literal|1
index|]
index|[
name|plex
index|[
literal|'>'
index|]
index|]
expr_stmt|;
if|if
condition|(
name|act
operator|==
name|NET_
operator|||
name|act
operator|==
name|NST_
condition|)
name|ptab
index|[
name|j
operator|+
literal|1
index|]
index|[
name|plex
index|[
literal|'>'
index|]
index|]
operator|=
name|ptab
index|[
name|j
operator|+
literal|1
index|]
index|[
name|plex
index|[
literal|'_'
index|]
index|]
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Lookup the value of the entry in pmap PTR whose key is KEY. */
end_comment

begin_function
specifier|static
name|UNIV
name|pmaplookup
parameter_list|(
name|ptr
parameter_list|,
name|key
parameter_list|)
name|struct
name|pmap
modifier|*
name|ptr
decl_stmt|;
name|char
modifier|*
name|key
decl_stmt|;
block|{
for|for
control|(
init|;
name|ptr
operator|->
name|name
condition|;
name|ptr
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
name|ptr
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|ptr
operator|->
name|value
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return an ASCII representation of N. */
end_comment

begin_function
specifier|static
name|UNCH
modifier|*
name|ltous
parameter_list|(
name|n
parameter_list|)
name|long
name|n
decl_stmt|;
block|{
specifier|static
name|char
name|buf
index|[
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|*
literal|3
operator|+
literal|2
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%ld"
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
operator|(
name|UNCH
operator|*
operator|)
name|buf
return|;
block|}
end_function

begin_function
name|VOID
name|sgmlwrsd
parameter_list|(
name|fp
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|changed
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|uc
index|[
literal|256
index|]
decl_stmt|;
comment|/* upper case characters (with different lower 				   case characters) */
name|char
name|lcletter
index|[
literal|256
index|]
decl_stmt|;
comment|/* LC letters: a-z */
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"<!SGML \"%s\"\n"
argument_list|,
name|standard
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"CHARSET\nBASESET \"-//Dummy//CHARSET Dummy//%s\"\nDESCSET\n"
argument_list|,
name|SYSTEM_CHARSET_DESIGNATING_SEQUENCE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|done_nonsgml
condition|)
block|{
name|done_nonsgml
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|char_flags
index|[
name|i
index|]
operator|&
operator|(
name|CHAR_SIGNIFICANT
operator||
name|CHAR_SHUNNED
operator|)
operator|)
operator|==
name|CHAR_SHUNNED
condition|)
name|char_flags
index|[
name|i
index|]
operator||=
name|CHAR_NONSGML
expr_stmt|;
block|}
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
literal|256
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
literal|256
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|(
name|char_flags
index|[
name|j
index|]
operator|&
name|CHAR_NONSGML
operator|)
operator|!=
operator|(
name|char_flags
index|[
name|i
index|]
operator|&
name|CHAR_NONSGML
operator|)
condition|)
break|break;
if|if
condition|(
name|char_flags
index|[
name|i
index|]
operator|&
name|CHAR_NONSGML
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%d %d UNUSED\n"
argument_list|,
name|i
argument_list|,
name|j
operator|-
name|i
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%d %d %d\n"
argument_list|,
name|i
argument_list|,
name|j
operator|-
name|i
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|i
operator|=
name|j
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"CAPACITY\n"
argument_list|)
expr_stmt|;
name|changed
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCAPACITY
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|refcapset
index|[
name|i
index|]
operator|!=
name|sd
operator|.
name|capacity
index|[
name|i
index|]
condition|)
block|{
if|if
condition|(
operator|!
name|changed
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"SGMLREF\n"
argument_list|)
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s %ld\n"
argument_list|,
name|captab
index|[
name|i
index|]
argument_list|,
name|sd
operator|.
name|capacity
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|changed
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"PUBLIC \"%s\"\n"
argument_list|,
name|capset_map
index|[
literal|0
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"SCOPE DOCUMENT\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"SYNTAX\nSHUNCHAR"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|char_flags
index|[
name|i
index|]
operator|&
name|CHAR_SHUNNED
condition|)
break|break;
if|if
condition|(
name|i
operator|==
literal|256
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" NONE\n"
argument_list|)
expr_stmt|;
else|else
block|{
for|for
control|(
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|char_flags
index|[
name|i
index|]
operator|&
name|CHAR_SHUNNED
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"BASESET \"-//Dummy//CHARSET Dummy//%s\"\nDESCSET 0 256 0\n"
argument_list|,
name|SYSTEM_CHARSET_DESIGNATING_SEQUENCE
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"FUNCTION\nRE %d\nRS %d\nSPACE %d\nTAB SEPCHAR %d\n"
argument_list|,
name|RECHAR
argument_list|,
name|RSCHAR
argument_list|,
literal|' '
argument_list|,
name|TABCHAR
argument_list|)
expr_stmt|;
name|MEMZERO
argument_list|(
operator|(
name|UNIV
operator|)
name|uc
argument_list|,
literal|256
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|lextran
index|[
name|i
index|]
operator|!=
name|i
condition|)
name|uc
index|[
name|lextran
index|[
name|i
index|]
index|]
operator|=
literal|1
expr_stmt|;
name|MEMZERO
argument_list|(
operator|(
name|UNIV
operator|)
name|lcletter
argument_list|,
literal|256
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
literal|"abcdefghijklmnopqrstuvwxyz"
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
name|lcletter
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p
index|]
operator|=
literal|1
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"NAMING\n"
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"LCNMSTRT \""
argument_list|,
name|fp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|lextoke
index|[
name|i
index|]
operator|==
name|NMS
operator|&&
operator|!
name|uc
index|[
name|i
index|]
operator|&&
operator|!
name|lcletter
index|[
name|i
index|]
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"&#%d;"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\"\n"
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"UCNMSTRT \""
argument_list|,
name|fp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|lextoke
index|[
name|i
index|]
operator|==
name|NMS
operator|&&
operator|!
name|uc
index|[
name|i
index|]
operator|&&
operator|!
name|lcletter
index|[
name|i
index|]
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"&#%d;"
argument_list|,
name|lextran
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\"\n"
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"LCNMCHAR \""
argument_list|,
name|fp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|lextoke
index|[
name|i
index|]
operator|==
name|NMC
operator|&&
operator|!
name|uc
index|[
name|i
index|]
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"&#%d;"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\"\n"
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"UCNMCHAR \""
argument_list|,
name|fp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|lextoke
index|[
name|i
index|]
operator|==
name|NMC
operator|&&
operator|!
name|uc
index|[
name|i
index|]
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"&#%d;"
argument_list|,
name|lextran
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\"\n"
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"NAMECASE\nGENERAL %s\nENTITY %s\n"
argument_list|,
name|sd
operator|.
name|namecase
index|[
literal|0
index|]
condition|?
literal|"YES"
else|:
literal|"NO"
argument_list|,
name|sd
operator|.
name|namecase
index|[
literal|1
index|]
condition|?
literal|"YES"
else|:
literal|"NO"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"DELIM\nGENERAL SGMLREF\nSHORTREF %s\n"
argument_list|,
name|sd
operator|.
name|shortref
condition|?
literal|"SGMLREF"
else|:
literal|"NONE"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"NAMES SGMLREF\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|newkey
condition|)
block|{
comment|/* The reference key was saved in newkey. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NKEYS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|newkey
index|[
name|i
index|]
index|[
literal|0
index|]
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s %s\n"
argument_list|,
name|newkey
index|[
name|i
index|]
argument_list|,
name|key
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"QUANTITY SGMLREF\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|quantity_changed
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NQUANTITY
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|quantity_changed
index|[
name|i
index|]
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s %d\n"
argument_list|,
name|quantity_names
index|[
name|i
index|]
argument_list|,
name|sd
operator|.
name|quantity
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"FEATURES\nMINIMIZE\nDATATAG NO OMITTAG %s RANK NO SHORTTAG %s\n"
argument_list|,
name|sd
operator|.
name|omittag
condition|?
literal|"YES"
else|:
literal|"NO"
argument_list|,
name|sd
operator|.
name|shorttag
condition|?
literal|"YES"
else|:
literal|"NO"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"LINK SIMPLE NO IMPLICIT NO EXPLICIT NO\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"OTHER CONCUR NO "
argument_list|)
expr_stmt|;
if|if
condition|(
name|sd
operator|.
name|subdoc
operator|>
literal|0
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"SUBDOC YES %ld "
argument_list|,
name|sd
operator|.
name|subdoc
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"SUBDOC NO "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"FORMAL %s\n"
argument_list|,
name|sd
operator|.
name|formal
condition|?
literal|"YES"
else|:
literal|"NO"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"APPINFO NONE"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|">\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Save an error to be printed only if FORMAL is declared as YES. */
end_comment

begin_function
specifier|static
name|VOID
name|sdsaverr
parameter_list|(
name|number
parameter_list|,
name|parm1
parameter_list|,
name|parm2
parameter_list|)
name|UNS
name|number
decl_stmt|;
name|UNCH
modifier|*
name|parm1
decl_stmt|;
name|UNCH
modifier|*
name|parm2
decl_stmt|;
block|{
name|saved_errs
index|[
name|nsaved_errs
operator|++
index|]
operator|=
name|savmderr
argument_list|(
name|number
argument_list|,
name|parm1
argument_list|,
name|parm2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Local Variables: c-indent-level: 5 c-continued-statement-offset: 5 c-brace-offset: -5 c-argdecl-indent: 0 c-label-offset: -5 End: */
end_comment

end_unit

