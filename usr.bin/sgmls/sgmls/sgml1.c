begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"sgmlincl.h"
end_include

begin_comment
comment|/* #INCLUDE statements for SGML parser. */
end_comment

begin_define
define|#
directive|define
name|ETDCON
value|(tags[ts].tetd->etdmod->ttype)
end_define

begin_comment
comment|/* ETD content flags. */
end_comment

begin_comment
comment|/* SGML: Main SGML driver routine. */
end_comment

begin_function
name|enum
name|sgmlevent
name|sgmlnext
parameter_list|(
name|rcbdafp
parameter_list|,
name|rcbtagp
parameter_list|)
name|struct
name|rcbdata
modifier|*
name|rcbdafp
decl_stmt|;
name|struct
name|rcbtag
modifier|*
name|rcbtagp
decl_stmt|;
block|{
while|while
condition|(
name|prologsw
operator|&&
operator|!
name|conactsw
condition|)
block|{
name|int
name|oconact
decl_stmt|;
name|conact
operator|=
name|parsepro
argument_list|()
expr_stmt|;
name|conactsw
operator|=
literal|0
expr_stmt|;
comment|/* Assume sgmlact() will not be skipped. */
switch|switch
condition|(
name|conact
condition|)
block|{
case|case
name|PIS_
case|:
case|case
name|EOD_
case|:
case|case
name|APP_
case|:
comment|/* APPINFO */
name|conactsw
operator|=
literal|1
expr_stmt|;
comment|/* We can skip sgmlact() in opening state. */
break|break;
case|case
name|DAF_
case|:
name|newetd
operator|=
name|stagreal
operator|=
name|ETDCDATA
expr_stmt|;
name|conact
operator|=
name|stag
argument_list|(
name|datarc
operator|=
name|DAF_
argument_list|)
expr_stmt|;
name|conactsw
operator|=
literal|1
expr_stmt|;
comment|/* We can skip sgmlact() in opening state. */
name|prologsw
operator|=
literal|0
expr_stmt|;
comment|/* End the prolog. */
break|break;
case|case
name|DCE_
case|:
case|case
name|MSS_
case|:
comment|/* prcon[2].tu.thetd holds the etd for the document element. */
name|newetd
operator|=
name|stagreal
operator|=
name|prcon
index|[
literal|2
index|]
operator|.
name|tu
operator|.
name|thetd
expr_stmt|;
name|stagmin
operator|=
name|MINSTAG
expr_stmt|;
comment|/* This tag was minimized. */
comment|/* It's an error if the start tag of the document element 		  is not minimizable. */
if|if
condition|(
name|BITOFF
argument_list|(
name|newetd
operator|->
name|etdmin
argument_list|,
name|SMO
argument_list|)
condition|)
name|sgmlerr
argument_list|(
literal|226
argument_list|,
name|conpcb
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|oconact
operator|=
name|conact
expr_stmt|;
comment|/* Save conact. */
name|conact
operator|=
name|stag
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Start the document element. */
name|conactsw
operator|=
literal|1
expr_stmt|;
comment|/* conact needs processing. */
name|prologsw
operator|=
literal|0
expr_stmt|;
comment|/* The prolog is finished. */
if|if
condition|(
name|oconact
operator|==
name|MSS_
condition|)
block|{
if|if
condition|(
name|msplevel
operator|==
literal|0
condition|)
name|conpcb
operator|=
name|getpcb
argument_list|(
operator|(
name|int
operator|)
name|ETDCON
argument_list|)
expr_stmt|;
name|conpcb
operator|=
name|mdms
argument_list|(
name|tbuf
argument_list|,
name|conpcb
argument_list|)
expr_stmt|;
comment|/* Parse the marked section 						    start. */
block|}
break|break;
default|default:
comment|/* STE_: not defined in SGMLACT.H. */
if|if
condition|(
name|msplevel
operator|==
literal|0
condition|)
name|conpcb
operator|=
name|getpcb
argument_list|(
operator|(
name|int
operator|)
name|ETDCON
argument_list|)
expr_stmt|;
name|prologsw
operator|=
literal|0
expr_stmt|;
comment|/* End the prolog. */
break|break;
block|}
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|unsigned
name|swact
decl_stmt|;
comment|/* Switch action: saved conact, new, or sgmlact.*/
if|if
condition|(
name|conactsw
condition|)
block|{
name|conactsw
operator|=
literal|0
expr_stmt|;
name|swact
operator|=
name|conact
expr_stmt|;
name|contersw
operator|=
name|contersv
expr_stmt|;
block|}
else|else
block|{
name|conact
operator|=
name|parsecon
argument_list|(
name|tbuf
argument_list|,
name|conpcb
argument_list|)
expr_stmt|;
name|swact
operator|=
name|sgmlact
argument_list|(
call|(
name|UNCH
call|)
argument_list|(
name|conact
operator|!=
name|EOD_
condition|?
name|conact
else|:
name|LOP_
argument_list|)
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|swact
condition|)
block|{
case|case
name|MD_
case|:
comment|/* Process markup declaration. */
name|parsenm
argument_list|(
name|tbuf
argument_list|,
name|NAMECASE
argument_list|)
expr_stmt|;
comment|/* Get declaration name. */
if|if
condition|(
operator|!
name|ustrcmp
argument_list|(
name|tbuf
operator|+
literal|1
argument_list|,
name|key
index|[
name|KUSEMAP
index|]
argument_list|)
condition|)
name|mdsrmuse
argument_list|(
name|tbuf
argument_list|)
expr_stmt|;
else|else
name|sgmlerr
argument_list|(
name|E_MDNAME
argument_list|,
name|conpcb
argument_list|,
name|tbuf
operator|+
literal|1
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|MDC_
case|:
comment|/* Process markup declaration comment. */
if|if
condition|(
operator|*
name|FPOS
operator|!=
name|lex
operator|.
name|d
operator|.
name|mdc
condition|)
name|parsemd
argument_list|(
name|tbuf
argument_list|,
name|NAMECASE
argument_list|,
operator|(
expr|struct
name|parse
operator|*
operator|)
literal|0
argument_list|,
name|NAMELEN
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|MSS_
case|:
comment|/* Process marked section start. */
name|conpcb
operator|=
name|mdms
argument_list|(
name|tbuf
argument_list|,
name|conpcb
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|MSE_
case|:
comment|/* Process marked section end (drop to LOP_). */
if|if
condition|(
name|mdmse
argument_list|()
condition|)
name|conpcb
operator|=
name|getpcb
argument_list|(
operator|(
name|int
operator|)
name|ETDCON
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|PIS_
case|:
comment|/* Return processing instruction (string). */
if|if
condition|(
name|entpisw
condition|)
name|rcbdafp
operator|->
name|data
operator|=
name|data
expr_stmt|;
else|else
block|{
name|parselit
argument_list|(
name|tbuf
argument_list|,
operator|&
name|pcblitc
argument_list|,
name|PILEN
argument_list|,
name|lex
operator|.
name|d
operator|.
name|pic
argument_list|)
expr_stmt|;
name|rcbdafp
operator|->
name|data
operator|=
name|tbuf
expr_stmt|;
block|}
name|rcbdafp
operator|->
name|datalen
operator|=
name|datalen
expr_stmt|;
name|rcbdafp
operator|->
name|contersw
operator|=
name|entpisw
expr_stmt|;
name|entpisw
operator|=
literal|0
expr_stmt|;
comment|/* Reset for next time.*/
name|scbset
argument_list|()
expr_stmt|;
comment|/* Update location in current scb. */
return|return
name|SGMLPIS
return|;
case|case
name|APP_
case|:
name|rcbdafp
operator|->
name|data
operator|=
name|tbuf
expr_stmt|;
name|rcbdafp
operator|->
name|datalen
operator|=
name|ustrlen
argument_list|(
name|tbuf
argument_list|)
expr_stmt|;
name|rcbdafp
operator|->
name|contersw
operator|=
literal|0
expr_stmt|;
name|scbset
argument_list|()
expr_stmt|;
return|return
name|SGMLAPP
return|;
case|case
name|ETG_
case|:
comment|/* Return end-tag. */
name|charmode
operator|=
literal|0
expr_stmt|;
comment|/* Not in char mode unless CDATA or RCDATA.*/
if|if
condition|(
name|msplevel
operator|==
literal|0
condition|)
name|conpcb
operator|=
name|getpcb
argument_list|(
operator|(
name|int
operator|)
name|ETDCON
argument_list|)
expr_stmt|;
name|rcbtagp
operator|->
name|contersw
operator|=
name|tags
index|[
name|ts
operator|+
literal|1
index|]
operator|.
name|tflags
expr_stmt|;
name|rcbtagp
operator|->
name|tagmin
operator|=
name|etagimsw
condition|?
name|MINETAG
else|:
name|etagmin
expr_stmt|;
name|rcbtagp
operator|->
name|curgi
operator|=
name|tags
index|[
name|ts
operator|+
literal|1
index|]
operator|.
name|tetd
operator|->
name|etdgi
expr_stmt|;
name|rcbtagp
operator|->
name|ru
operator|.
name|oldgi
operator|=
name|tags
index|[
name|ts
index|]
operator|.
name|tetd
operator|->
name|etdgi
expr_stmt|;
if|if
condition|(
name|etagmin
operator|==
name|MINSTAG
condition|)
name|rcbtagp
operator|->
name|tagreal
operator|=
name|BADPTR
argument_list|(
name|stagreal
argument_list|)
condition|?
name|stagreal
else|:
operator|(
name|PETD
operator|)
name|stagreal
operator|->
name|etdgi
expr_stmt|;
else|else
name|rcbtagp
operator|->
name|tagreal
operator|=
name|BADPTR
argument_list|(
name|etagreal
argument_list|)
condition|?
name|etagreal
else|:
operator|(
name|PETD
operator|)
name|etagreal
operator|->
name|etdgi
expr_stmt|;
name|rcbtagp
operator|->
name|etictr
operator|=
name|etictr
expr_stmt|;
name|rcbtagp
operator|->
name|srmnm
operator|=
name|tags
index|[
name|ts
index|]
operator|.
name|tsrm
operator|!=
name|SRMNULL
condition|?
name|tags
index|[
name|ts
index|]
operator|.
name|tsrm
index|[
literal|0
index|]
operator|->
name|ename
else|:
literal|0
expr_stmt|;
name|scbset
argument_list|()
expr_stmt|;
comment|/* Update location in current scb. */
return|return
name|SGMLETG
return|;
case|case
name|STG_
case|:
comment|/* Return start-tag. */
name|charmode
operator|=
literal|0
expr_stmt|;
comment|/* Not in char mode unless CDATA or RCDATA.*/
if|if
condition|(
operator|!
name|conrefsw
operator|&&
name|msplevel
operator|==
literal|0
condition|)
name|conpcb
operator|=
name|getpcb
argument_list|(
operator|(
name|int
operator|)
name|ETDCON
argument_list|)
expr_stmt|;
name|rcbtagp
operator|->
name|contersw
operator|=
name|tags
index|[
name|ts
index|]
operator|.
name|tflags
expr_stmt|;
name|rcbtagp
operator|->
name|tagmin
operator|=
name|dostag
condition|?
name|MINSTAG
else|:
name|stagmin
expr_stmt|;
name|rcbtagp
operator|->
name|curgi
operator|=
name|tags
index|[
name|ts
index|]
operator|.
name|tetd
operator|->
name|etdgi
expr_stmt|;
comment|/* Get attribute list if one was defined for this element. */
name|rcbtagp
operator|->
name|ru
operator|.
name|al
operator|=
operator|!
name|tags
index|[
name|ts
index|]
operator|.
name|tetd
operator|->
name|adl
condition|?
literal|0
else|:
name|rcbtagp
operator|->
name|tagmin
operator|==
name|MINNONE
condition|?
name|al
else|:
name|tags
index|[
name|ts
index|]
operator|.
name|tetd
operator|->
name|adl
expr_stmt|;
name|rcbtagp
operator|->
name|tagreal
operator|=
name|BADPTR
argument_list|(
name|stagreal
argument_list|)
condition|?
name|stagreal
else|:
operator|(
name|PETD
operator|)
name|stagreal
operator|->
name|etdgi
expr_stmt|;
name|rcbtagp
operator|->
name|etictr
operator|=
name|etictr
expr_stmt|;
name|rcbtagp
operator|->
name|srmnm
operator|=
name|tags
index|[
name|ts
index|]
operator|.
name|tsrm
operator|!=
name|SRMNULL
condition|?
name|tags
index|[
name|ts
index|]
operator|.
name|tsrm
index|[
literal|0
index|]
operator|->
name|ename
else|:
literal|0
expr_stmt|;
name|scbset
argument_list|()
expr_stmt|;
comment|/* Update location in current scb. */
return|return
name|SGMLSTG
return|;
case|case
name|DAF_
case|:
comment|/* Return data in source entity buffer. */
name|charmode
operator|=
literal|1
expr_stmt|;
name|rcbdafp
operator|->
name|datalen
operator|=
name|datalen
expr_stmt|;
name|rcbdafp
operator|->
name|data
operator|=
name|data
expr_stmt|;
name|rcbdafp
operator|->
name|contersw
operator|=
name|contersw
operator||
name|entdatsw
expr_stmt|;
name|contersw
operator|=
name|entdatsw
operator|=
literal|0
expr_stmt|;
comment|/* Reset for next time.*/
name|scbset
argument_list|()
expr_stmt|;
comment|/* Update location in current scb. */
return|return
name|SGMLDAF
return|;
case|case
name|CON_
case|:
comment|/* Process conact after returning REF_. */
name|conactsw
operator|=
literal|1
expr_stmt|;
name|contersv
operator|=
name|contersw
expr_stmt|;
case|case
name|REF_
case|:
comment|/* Return RE found. */
if|if
condition|(
name|badresw
condition|)
block|{
name|badresw
operator|=
literal|0
expr_stmt|;
name|sgmlerr
argument_list|(
name|E_CHARS
argument_list|,
operator|&
name|pcbconm
argument_list|,
name|tags
index|[
name|ts
index|]
operator|.
name|tetd
operator|->
name|etdgi
operator|+
literal|1
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|charmode
operator|=
literal|1
expr_stmt|;
name|rcbdafp
operator|->
name|contersw
operator|=
name|contersw
expr_stmt|;
name|contersw
operator|=
literal|0
expr_stmt|;
comment|/* Reset for next time.*/
name|scbset
argument_list|()
expr_stmt|;
comment|/* Update location in current scb. */
return|return
name|SGMLREF
return|;
case|case
name|EOD_
case|:
comment|/* End of source document entity. */
if|if
condition|(
name|mslevel
operator|!=
literal|0
condition|)
name|sgmlerr
argument_list|(
literal|139
argument_list|,
name|conpcb
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|idrck
argument_list|()
expr_stmt|;
comment|/* Check idrefs. */
name|scbset
argument_list|()
expr_stmt|;
comment|/* Update location in current scb. */
return|return
name|SGMLEOD
return|;
default|default:
comment|/* LOP_: Loop again with no action. */
continue|continue;
block|}
block|}
block|}
end_function

begin_comment
comment|/* PCBSGML: State and action table for action codes returned to text processor             by SGML.C.             Columns are based on SGMLACT.H values minus DAF_, except that end             of document has input code LOP_, regardless of its action code. */
end_comment

begin_comment
comment|/* Symbols for state names (end with a number). */
end_comment

begin_define
define|#
directive|define
name|ST1
value|0
end_define

begin_comment
comment|/* Just had a start tag. */
end_comment

begin_define
define|#
directive|define
name|NR1
value|2
end_define

begin_comment
comment|/* Just had an RS or RE. */
end_comment

begin_define
define|#
directive|define
name|DA1
value|4
end_define

begin_comment
comment|/* Just had some data. */
end_comment

begin_define
define|#
directive|define
name|NR2
value|6
end_define

begin_comment
comment|/* Just had an RE; RE pending. */
end_comment

begin_define
define|#
directive|define
name|ST2
value|8
end_define

begin_comment
comment|/* Had only markup since last RE/RS; RE pending. */
end_comment

begin_decl_stmt
specifier|static
name|UNCH
name|sgmltab
index|[]
index|[
literal|11
index|]
init|=
block|{
comment|/*daf_ etg_ md_  mdc_ mss_ mse_ pis_ ref_ stg_ rsr_ eod  */
block|{
name|DA1
block|,
name|DA1
block|,
name|ST1
block|,
name|ST1
block|,
name|ST1
block|,
name|ST1
block|,
name|ST1
block|,
name|NR1
block|,
name|ST1
block|,
name|NR1
block|,
name|ST1
block|}
block|,
comment|/*st1*/
block|{
name|DAF_
block|,
name|ETG_
block|,
name|MD_
block|,
name|MDC_
block|,
name|MSS_
block|,
name|MSE_
block|,
name|PIS_
block|,
name|LOP_
block|,
name|STG_
block|,
name|LOP_
block|,
name|EOD_
block|}
block|,
block|{
name|DA1
block|,
name|DA1
block|,
name|ST1
block|,
name|ST1
block|,
name|ST1
block|,
name|ST1
block|,
name|ST1
block|,
name|NR2
block|,
name|ST1
block|,
name|NR1
block|,
name|ST1
block|}
block|,
comment|/*nr1*/
block|{
name|DAF_
block|,
name|ETG_
block|,
name|MD_
block|,
name|MDC_
block|,
name|MSS_
block|,
name|MSE_
block|,
name|PIS_
block|,
name|LOP_
block|,
name|STG_
block|,
name|LOP_
block|,
name|EOD_
block|}
block|,
block|{
name|DA1
block|,
name|DA1
block|,
name|DA1
block|,
name|DA1
block|,
name|DA1
block|,
name|DA1
block|,
name|DA1
block|,
name|NR2
block|,
name|ST1
block|,
name|NR1
block|,
name|ST1
block|}
block|,
comment|/*da1*/
block|{
name|DAF_
block|,
name|ETG_
block|,
name|MD_
block|,
name|MDC_
block|,
name|MSS_
block|,
name|MSE_
block|,
name|PIS_
block|,
name|LOP_
block|,
name|STG_
block|,
name|LOP_
block|,
name|EOD_
block|}
block|,
block|{
name|DA1
block|,
name|DA1
block|,
name|ST2
block|,
name|ST2
block|,
name|ST2
block|,
name|ST2
block|,
name|ST2
block|,
name|NR2
block|,
name|ST1
block|,
name|NR2
block|,
name|ST1
block|}
block|,
comment|/*nr2*/
block|{
name|CON_
block|,
name|ETG_
block|,
name|MD_
block|,
name|MDC_
block|,
name|MSS_
block|,
name|MSE_
block|,
name|PIS_
block|,
name|REF_
block|,
name|CON_
block|,
name|LOP_
block|,
name|EOD_
block|}
block|,
block|{
name|DA1
block|,
name|DA1
block|,
name|ST2
block|,
name|ST2
block|,
name|ST2
block|,
name|ST2
block|,
name|ST2
block|,
name|NR2
block|,
name|ST1
block|,
name|NR2
block|,
name|ST1
block|}
block|,
comment|/*st2*/
block|{
name|CON_
block|,
name|ETG_
block|,
name|MD_
block|,
name|MDC_
block|,
name|MSS_
block|,
name|MSE_
block|,
name|PIS_
block|,
name|LOP_
block|,
name|CON_
block|,
name|LOP_
block|,
name|EOD_
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|scbsgmst
init|=
name|ST1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* SCBSGML: trailing stag or markup; ignore RE. */
end_comment

begin_decl_stmt
name|int
name|scbsgmnr
init|=
name|NR1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* SCBSGML: new record; do not ignore RE. */
end_comment

begin_comment
comment|/* SGMLACT: Determine action to be taken by SGML.C based on current state and             specified input.             For start or end of a plus exception element, push or pop the             pcbsgml stack.             Return to caller with action code. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USE_PROTOTYPES
end_ifdef

begin_function
name|int
name|sgmlact
parameter_list|(
name|UNCH
name|conret
parameter_list|)
else|#
directive|else
function|int sgmlact
parameter_list|(
name|conret
parameter_list|)
name|UNCH
name|conret
decl_stmt|;
comment|/* Action returned to SGML.C by content parse. */
endif|#
directive|endif
block|{
name|int
name|action
decl_stmt|;
if|if
condition|(
name|conret
operator|==
name|STG_
operator|&&
name|GET
argument_list|(
name|tags
index|[
name|ts
index|]
operator|.
name|tflags
argument_list|,
name|TAGPEX
argument_list|)
condition|)
block|{
operator|++
name|pss
expr_stmt|;
name|scbsgml
index|[
name|pss
index|]
operator|.
name|snext
operator|=
name|ST1
expr_stmt|;
block|}
name|scbsgml
index|[
name|pss
index|]
operator|.
name|sstate
operator|=
name|scbsgml
index|[
name|pss
index|]
operator|.
name|snext
expr_stmt|;
name|scbsgml
index|[
name|pss
index|]
operator|.
name|snext
operator|=
name|sgmltab
index|[
name|scbsgml
index|[
name|pss
index|]
operator|.
name|sstate
index|]
index|[
name|scbsgml
index|[
name|pss
index|]
operator|.
name|sinput
operator|=
name|conret
operator|-
name|DAF_
index|]
expr_stmt|;
name|scbsgml
index|[
name|pss
index|]
operator|.
name|saction
operator|=
name|sgmltab
index|[
name|scbsgml
index|[
name|pss
index|]
operator|.
name|sstate
operator|+
literal|1
index|]
index|[
name|scbsgml
index|[
name|pss
index|]
operator|.
name|sinput
index|]
expr_stmt|;
name|TRACEGML
argument_list|(
name|scbsgml
argument_list|,
name|pss
argument_list|,
name|conactsw
argument_list|,
name|conact
argument_list|)
expr_stmt|;
name|action
operator|=
name|scbsgml
index|[
name|pss
index|]
operator|.
name|saction
expr_stmt|;
if|if
condition|(
name|conret
operator|==
name|ETG_
operator|&&
name|GET
argument_list|(
name|tags
index|[
name|ts
operator|+
literal|1
index|]
operator|.
name|tflags
argument_list|,
name|TAGPEX
argument_list|)
condition|)
block|{
name|pss
operator|--
expr_stmt|;
comment|/* An included subelement affects the enclosing state like a 	     processing instruction (or MDC_ or MD_), 	     that is to say NR1 is changed to ST1 and NR2 to ST2. */
name|scbsgml
index|[
name|pss
index|]
operator|.
name|sstate
operator|=
name|scbsgml
index|[
name|pss
index|]
operator|.
name|snext
expr_stmt|;
name|scbsgml
index|[
name|pss
index|]
operator|.
name|snext
operator|=
name|sgmltab
index|[
name|scbsgml
index|[
name|pss
index|]
operator|.
name|sstate
index|]
index|[
name|PIS_
operator|-
name|DAF_
index|]
expr_stmt|;
block|}
return|return
name|action
return|;
block|}
end_function

begin_comment
comment|/* GETPCB: Choose pcb for new or resumed element. */
end_comment

begin_function
name|struct
name|parse
modifier|*
name|getpcb
parameter_list|(
name|etdcon
parameter_list|)
name|int
name|etdcon
decl_stmt|;
comment|/* Content type of new or resumed element. */
block|{
if|if
condition|(
name|BITON
argument_list|(
name|etdcon
argument_list|,
name|MGI
argument_list|)
condition|)
block|{
return|return
operator|(
name|BITON
argument_list|(
name|etdcon
argument_list|,
name|MCHARS
argument_list|)
condition|?
operator|&
name|pcbconm
else|:
operator|&
name|pcbcone
operator|)
return|;
block|}
if|if
condition|(
name|BITON
argument_list|(
name|etdcon
argument_list|,
name|MCDATA
argument_list|)
operator|||
name|BITON
argument_list|(
name|etdcon
argument_list|,
name|MRCDATA
argument_list|)
condition|)
block|{
name|charmode
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|BITON
argument_list|(
name|etdcon
argument_list|,
name|MCDATA
argument_list|)
condition|?
operator|&
name|pcbconc
else|:
operator|(
name|rcessv
operator|=
name|es
operator|,
operator|&
name|pcbconr
operator|)
operator|)
return|;
block|}
return|return
operator|(
operator|&
name|pcbconm
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|markup
modifier|*
name|sgmlset
parameter_list|(
name|swp
parameter_list|)
name|struct
name|switches
modifier|*
name|swp
decl_stmt|;
block|{
comment|/* Initialize variables based on switches structure members. */
name|sw
operator|=
operator|*
name|swp
expr_stmt|;
name|rbufs
operator|=
operator|(
name|UNCH
operator|*
operator|)
name|rmalloc
argument_list|(
operator|(
name|UNS
operator|)
literal|3
operator|+
name|sw
operator|.
name|swbufsz
argument_list|)
operator|+
literal|3
expr_stmt|;
comment|/* DOS file read area. */
name|TRACEPRO
argument_list|()
expr_stmt|;
comment|/* Set trace switches for prolog. */
name|msginit
argument_list|(
name|swp
argument_list|)
expr_stmt|;
name|ioinit
argument_list|(
name|swp
argument_list|)
expr_stmt|;
name|entginit
argument_list|(
name|swp
argument_list|)
expr_stmt|;
name|sdinit
argument_list|()
expr_stmt|;
return|return
operator|&
name|lex
operator|.
name|m
return|;
block|}
end_function

begin_comment
comment|/* Points for each capacity, indexed by *CAP in sgmldecl.h.  We'll replace 2 with the real NAMELEN at run time. */
end_comment

begin_decl_stmt
specifier|static
name|UNCH
name|cappoints
index|[]
init|=
block|{
literal|1
block|,
literal|2
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|capnumber
index|[
name|NCAPACITY
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|maxsubcap
index|[
name|NCAPACITY
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|VOID
name|sgmlend
parameter_list|(
name|p
parameter_list|)
name|struct
name|sgmlcap
modifier|*
name|p
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
init|;
name|es
operator|>=
literal|0
condition|;
operator|--
name|es
control|)
if|if
condition|(
name|FILESW
condition|)
name|fileclos
argument_list|()
expr_stmt|;
name|capnumber
index|[
name|NOTCAP
index|]
operator|=
name|ds
operator|.
name|dcncnt
expr_stmt|;
name|capnumber
index|[
name|EXGRPCAP
index|]
operator|=
name|ds
operator|.
name|pmexgcnt
expr_stmt|;
name|capnumber
index|[
name|ELEMCAP
index|]
operator|=
name|ds
operator|.
name|etdcnt
operator|+
name|ds
operator|.
name|etdercnt
expr_stmt|;
name|capnumber
index|[
name|EXNMCAP
index|]
operator|=
name|ds
operator|.
name|pmexcnt
expr_stmt|;
name|capnumber
index|[
name|GRPCAP
index|]
operator|=
name|ds
operator|.
name|modcnt
expr_stmt|;
name|capnumber
index|[
name|ATTCAP
index|]
operator|=
name|ds
operator|.
name|attcnt
expr_stmt|;
name|capnumber
index|[
name|ATTCHCAP
index|]
operator|=
name|ds
operator|.
name|attdef
expr_stmt|;
name|capnumber
index|[
name|AVGRPCAP
index|]
operator|=
name|ds
operator|.
name|attgcnt
expr_stmt|;
name|capnumber
index|[
name|IDCAP
index|]
operator|=
name|ds
operator|.
name|idcnt
expr_stmt|;
name|capnumber
index|[
name|IDREFCAP
index|]
operator|=
name|ds
operator|.
name|idrcnt
expr_stmt|;
name|capnumber
index|[
name|ENTCAP
index|]
operator|=
name|ds
operator|.
name|ecbcnt
expr_stmt|;
name|capnumber
index|[
name|ENTCHCAP
index|]
operator|=
name|ds
operator|.
name|ecbtext
expr_stmt|;
name|capnumber
index|[
name|MAPCAP
index|]
operator|=
name|ds
operator|.
name|srcnt
operator|+
name|ds
operator|.
name|srcnt
operator|*
name|lex
operator|.
name|s
operator|.
name|dtb
index|[
literal|0
index|]
operator|.
name|mapdata
expr_stmt|;
name|capnumber
index|[
name|NOTCHCAP
index|]
operator|=
name|ds
operator|.
name|dcntext
expr_stmt|;
name|capnumber
index|[
name|TOTALCAP
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|NCAPACITY
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|cappoints
index|[
name|i
index|]
operator|>
literal|1
condition|)
name|cappoints
index|[
name|i
index|]
operator|=
name|NAMELEN
expr_stmt|;
name|capnumber
index|[
name|i
index|]
operator|+=
name|maxsubcap
index|[
name|i
index|]
operator|/
name|cappoints
index|[
name|i
index|]
expr_stmt|;
name|capnumber
index|[
name|TOTALCAP
index|]
operator|+=
operator|(
name|long
operator|)
name|capnumber
index|[
name|i
index|]
operator|*
name|cappoints
index|[
name|i
index|]
expr_stmt|;
block|}
name|p
operator|->
name|number
operator|=
name|capnumber
expr_stmt|;
name|p
operator|->
name|points
operator|=
name|cappoints
expr_stmt|;
name|p
operator|->
name|limit
operator|=
name|sd
operator|.
name|capacity
expr_stmt|;
name|p
operator|->
name|name
operator|=
name|captab
expr_stmt|;
if|if
condition|(
name|sw
operator|.
name|swcap
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCAPACITY
condition|;
name|i
operator|++
control|)
block|{
name|long
name|excess
init|=
name|capnumber
index|[
name|i
index|]
operator|*
name|cappoints
index|[
name|i
index|]
operator|-
name|sd
operator|.
name|capacity
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|excess
operator|>
literal|0
condition|)
block|{
name|char
name|buf
index|[
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|*
literal|3
operator|+
literal|1
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%ld"
argument_list|,
name|excess
argument_list|)
expr_stmt|;
name|sgmlerr
argument_list|(
literal|162
argument_list|,
operator|(
expr|struct
name|parse
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
name|captab
index|[
name|i
index|]
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
name|VOID
name|sgmlsubcap
parameter_list|(
name|v
parameter_list|)
name|long
modifier|*
name|v
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCAPACITY
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|v
index|[
name|i
index|]
operator|>
name|maxsubcap
index|[
name|i
index|]
condition|)
name|maxsubcap
index|[
name|i
index|]
operator|=
name|v
index|[
name|i
index|]
expr_stmt|;
block|}
end_function

begin_function
name|int
name|sgmlsdoc
parameter_list|(
name|ptr
parameter_list|)
name|UNIV
name|ptr
decl_stmt|;
block|{
name|struct
name|entity
modifier|*
name|e
decl_stmt|;
name|union
name|etext
name|etx
decl_stmt|;
name|etx
operator|.
name|x
operator|=
name|ptr
expr_stmt|;
name|e
operator|=
name|entdef
argument_list|(
name|indocent
argument_list|,
name|ESF
argument_list|,
operator|&
name|etx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|e
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|entopen
argument_list|(
name|e
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* SGMLGENT:  Get a data entity.               Returns: 	      -1 if the entity does not exist 	      -2 if it is not a data entity 	      1 if it is an external entity 	      2 if it is an internal cdata entity 	      3 if it is an internal sdata entity */
end_comment

begin_function
name|int
name|sgmlgent
parameter_list|(
name|iname
parameter_list|,
name|np
parameter_list|,
name|tp
parameter_list|)
name|UNCH
modifier|*
name|iname
decl_stmt|;
name|PNE
modifier|*
name|np
decl_stmt|;
name|UNCH
modifier|*
modifier|*
name|tp
decl_stmt|;
block|{
name|PECB
name|ep
decl_stmt|;
comment|/* Pointer to an entity control block. */
name|ep
operator|=
name|entfind
argument_list|(
name|iname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ep
condition|)
return|return
operator|-
literal|1
return|;
switch|switch
condition|(
name|ep
operator|->
name|estore
condition|)
block|{
case|case
name|ESN
case|:
if|if
condition|(
name|np
condition|)
operator|*
name|np
operator|=
name|ep
operator|->
name|etx
operator|.
name|n
expr_stmt|;
return|return
literal|1
return|;
case|case
name|ESC
case|:
if|if
condition|(
name|tp
condition|)
operator|*
name|tp
operator|=
name|ep
operator|->
name|etx
operator|.
name|c
expr_stmt|;
return|return
literal|2
return|;
case|case
name|ESX
case|:
if|if
condition|(
name|tp
condition|)
operator|*
name|tp
operator|=
name|ep
operator|->
name|etx
operator|.
name|c
expr_stmt|;
return|return
literal|3
return|;
block|}
return|return
operator|-
literal|2
return|;
block|}
end_function

begin_comment
comment|/* Mark an entity. */
end_comment

begin_function
name|int
name|sgmlment
parameter_list|(
name|iname
parameter_list|)
name|UNCH
modifier|*
name|iname
decl_stmt|;
block|{
name|PECB
name|ep
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|ep
operator|=
name|entfind
argument_list|(
name|iname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ep
condition|)
return|return
operator|-
literal|1
return|;
name|rc
operator|=
name|ep
operator|->
name|mark
expr_stmt|;
name|ep
operator|->
name|mark
operator|=
literal|1
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_function
name|int
name|sgmlgcnterr
parameter_list|()
block|{
return|return
name|msgcnterr
argument_list|()
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|getsubst
parameter_list|()
block|{
return|return
operator|(
name|char
operator|*
operator|)
name|lextran
return|;
block|}
end_function

begin_comment
comment|/* This is for error handling functions that want to print a gi backtrace. */
end_comment

begin_function
name|UNCH
modifier|*
name|getgi
parameter_list|(
name|i
parameter_list|)
name|int
name|i
decl_stmt|;
block|{
return|return
name|i
operator|>=
literal|0
operator|&&
name|i
operator|<=
name|ts
condition|?
name|tags
index|[
name|i
index|]
operator|.
name|tetd
operator|->
name|etdgi
operator|+
literal|1
else|:
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Returns the value of prologsw for the use by error handling functions. */
end_comment

begin_function
name|int
name|inprolog
parameter_list|()
block|{
return|return
name|prologsw
return|;
block|}
end_function

begin_comment
comment|/* Used by the error handling functions to access scbs. */
end_comment

begin_function
name|int
name|getlocation
parameter_list|(
name|level
parameter_list|,
name|locp
parameter_list|)
name|int
name|level
decl_stmt|;
name|struct
name|location
modifier|*
name|locp
decl_stmt|;
block|{
if|if
condition|(
name|level
operator|<
literal|0
operator|||
name|level
operator|>
name|es
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|locp
condition|)
block|{
name|int
name|es
init|=
name|level
decl_stmt|;
comment|/* source macros access a variable called `es' */
name|locp
operator|->
name|filesw
operator|=
name|FILESW
expr_stmt|;
name|locp
operator|->
name|rcnt
operator|=
name|RCNT
expr_stmt|;
name|locp
operator|->
name|ccnt
operator|=
name|CCNT
expr_stmt|;
name|locp
operator|->
name|ename
operator|=
name|ENTITY
operator|+
literal|1
expr_stmt|;
name|locp
operator|->
name|fcb
operator|=
name|SCBFCB
expr_stmt|;
name|locp
operator|->
name|curchar
operator|=
name|CC
expr_stmt|;
name|locp
operator|->
name|nextchar
operator|=
name|NEXTC
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|sgmlloc
parameter_list|(
name|linenop
parameter_list|,
name|filenamep
parameter_list|)
name|unsigned
name|long
modifier|*
name|linenop
decl_stmt|;
name|char
modifier|*
modifier|*
name|filenamep
decl_stmt|;
block|{
name|int
name|level
init|=
name|es
decl_stmt|;
name|int
name|es
decl_stmt|;
for|for
control|(
name|es
operator|=
name|level
init|;
name|es
operator|>=
literal|0
operator|&&
operator|!
name|FILESW
condition|;
name|es
operator|--
control|)
empty_stmt|;
if|if
condition|(
name|es
operator|<
literal|0
condition|)
return|return
literal|0
return|;
operator|*
name|linenop
operator|=
name|RCNT
expr_stmt|;
operator|*
name|filenamep
operator|=
name|ioflid
argument_list|(
name|SCBFCB
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Local Variables: c-indent-level: 5 c-continued-statement-offset: 5 c-brace-offset: -5 c-argdecl-indent: 0 c-label-offset: -5 End: */
end_comment

end_unit

