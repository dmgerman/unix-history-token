begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"sgmlincl.h"
end_include

begin_comment
comment|/* #INCLUDE statements for SGML parser. */
end_comment

begin_include
include|#
directive|include
file|"context.h"
end_include

begin_define
define|#
directive|define
name|GI
value|(tags[ts].tetd->etdgi+1)
end_define

begin_comment
comment|/* GI of current element. */
end_comment

begin_define
define|#
directive|define
name|NEWGI
value|(newetd->etdgi+1)
end_define

begin_comment
comment|/* GI of new tag. */
end_comment

begin_define
define|#
directive|define
name|STATUS
value|(*statuspt)
end_define

begin_comment
comment|/* Token status: RCHIT RCMISS RCEND RCREQ RCNREQ*/
end_comment

begin_define
define|#
directive|define
name|PEX
value|(-1)
end_define

begin_comment
comment|/* GI is a plus exception and not a minus. */
end_comment

begin_define
define|#
directive|define
name|ANYHIT
parameter_list|(
name|h
parameter_list|)
value|(grplongs == 1 ? ((h)[0] != 0) : anyhit(h))
end_define

begin_define
define|#
directive|define
name|HITSET
parameter_list|(
name|h
parameter_list|,
name|n
parameter_list|)
value|(h[(unsigned)(n-1)>>LONGPOW] \ 		      |= (1L<<((n-1)&(LONGBITS-1))))
end_define

begin_define
define|#
directive|define
name|HITON
parameter_list|(
name|h
parameter_list|,
name|n
parameter_list|)
value|(h[(unsigned)(n-1)>>LONGPOW]& (1L<<((n-1)&(LONGBITS-1))))
end_define

begin_define
define|#
directive|define
name|HITOFF
parameter_list|(
name|h
parameter_list|,
name|n
parameter_list|)
value|(!(HITON(h, n)))
end_define

begin_define
define|#
directive|define
name|TOKENHIT
value|HITON(H,T)
end_define

begin_function
specifier|static
name|VOID
name|copypos
parameter_list|(
name|to
parameter_list|,
name|from
parameter_list|)
name|struct
name|mpos
modifier|*
name|to
decl_stmt|,
decl|*
name|from
decl_stmt|;
end_function

begin_block
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
operator|(
name|int
operator|)
name|from
index|[
literal|0
index|]
operator|.
name|t
condition|;
name|i
operator|++
control|)
block|{
name|to
index|[
name|i
index|]
operator|.
name|g
operator|=
name|from
index|[
name|i
index|]
operator|.
name|g
expr_stmt|;
name|to
index|[
name|i
index|]
operator|.
name|t
operator|=
name|from
index|[
name|i
index|]
operator|.
name|t
expr_stmt|;
name|memcpy
argument_list|(
name|to
index|[
name|i
index|]
operator|.
name|h
argument_list|,
name|from
index|[
name|i
index|]
operator|.
name|h
argument_list|,
name|grplongs
operator|*
expr|sizeof
operator|(
name|unsigned
name|long
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* CONTEXT: Determine whether a GI is valid in the present structural context.             Returns RCHIT if valid, RCEND if element has ended, RCREQ if a             different element is required, and RCMISS if it is totally invalid.             On entry, pos points to the model token to be tested against the GI.             TO DO: Save allowed GIs for an error message on an RCMISS.                    Support a "query" mode (what is allowed now?) by working                    with a copy of pos. */
end_comment

begin_function
name|int
name|context
parameter_list|(
name|gi
parameter_list|,
name|mod
parameter_list|,
name|pos
parameter_list|,
name|statuspt
parameter_list|,
name|mexts
parameter_list|)
name|struct
name|etd
modifier|*
name|gi
decl_stmt|;
comment|/* ETD of new GI. */
name|struct
name|thdr
name|mod
index|[]
decl_stmt|;
comment|/* Model of current open element. */
name|struct
name|mpos
name|pos
index|[]
decl_stmt|;
comment|/* Position in open element's model. */
name|UNCH
modifier|*
name|statuspt
decl_stmt|;
comment|/* Token status: RCHIT RCMISS RCEND RCREQ RCNREQ*/
name|int
name|mexts
decl_stmt|;
comment|/*>0=stack level of minus grp; -1=plus; 0=none.*/
block|{
name|UNCH
name|toccsv
decl_stmt|,
name|gtypesv
decl_stmt|;
comment|/* Save token's TOCC and GTYPE in case grp ends.*/
if|if
condition|(
name|mexts
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|mexts
operator|==
operator|-
literal|1
operator|&&
name|STATUS
operator|==
name|RCEND
condition|)
return|return
name|RCPEX
return|;
name|copypos
argument_list|(
name|savedpos
argument_list|,
name|pos
argument_list|)
expr_stmt|;
block|}
name|Tstart
operator|=
name|T
expr_stmt|;
comment|/* Save starting token for AND group testing. */
while|while
condition|(
name|STATUS
operator|!=
name|RCMISS
operator|&&
name|STATUS
operator|!=
name|RCEND
condition|)
block|{
name|TRACEGI
argument_list|(
literal|"CONTEXT"
argument_list|,
name|gi
argument_list|,
name|mod
argument_list|,
name|pos
argument_list|)
expr_stmt|;
while|while
condition|(
name|TTYPE
operator|==
name|TTOR
operator|||
name|TTYPE
operator|==
name|TTSEQ
operator|||
name|TTYPE
operator|==
name|TTAND
condition|)
block|{
name|pos
index|[
name|P
operator|+
literal|1
index|]
operator|.
name|g
operator|=
name|M
operator|++
expr_stmt|;
name|pos
index|[
operator|++
name|P
index|]
operator|.
name|t
operator|=
literal|1
expr_stmt|;
name|HITCLEAR
argument_list|(
name|H
argument_list|)
expr_stmt|;
name|Tstart
operator|=
name|T
expr_stmt|;
comment|/* Save starting token for AND group testing. */
name|TRACEGI
argument_list|(
literal|"OPENGRP"
argument_list|,
name|gi
argument_list|,
name|mod
argument_list|,
name|pos
argument_list|)
expr_stmt|;
block|}
name|STATUS
operator|=
operator|(
name|UNCH
operator|)
name|tokenreq
argument_list|(
name|gi
argument_list|,
name|mod
argument_list|,
name|pos
argument_list|)
expr_stmt|;
name|TRACEGI
argument_list|(
literal|"STATUS"
argument_list|,
name|gi
argument_list|,
name|mod
argument_list|,
name|pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|gi
operator|==
name|TOKEN
operator|.
name|tu
operator|.
name|thetd
condition|)
block|{
comment|/* Hit in model. */
name|STATUS
operator|=
operator|(
name|UNCH
operator|)
name|RCHIT
expr_stmt|;
name|gtypesv
operator|=
name|GTYPE
expr_stmt|;
name|toccsv
operator|=
name|TOCC
expr_stmt|;
name|newtoken
argument_list|(
name|mod
argument_list|,
name|pos
argument_list|,
name|statuspt
argument_list|)
expr_stmt|;
if|if
condition|(
name|mexts
operator|<=
literal|0
condition|)
return|return
name|RCHIT
return|;
elseif|else
if|if
condition|(
name|gtypesv
operator|==
name|TTOR
operator|||
name|BITON
argument_list|(
name|toccsv
argument_list|,
name|TOPT
argument_list|)
condition|)
block|{
comment|/* restore position */
name|copypos
argument_list|(
name|pos
argument_list|,
name|savedpos
argument_list|)
expr_stmt|;
return|return
name|RCMEX
return|;
block|}
else|else
return|return
name|RCHITMEX
return|;
block|}
if|if
condition|(
name|STATUS
operator|==
name|RCREQ
condition|)
block|{
if|if
condition|(
name|mexts
operator|==
operator|-
literal|1
condition|)
break|break;
name|STATUS
operator|=
name|RCHIT
expr_stmt|;
name|nextetd
operator|=
name|TOKEN
operator|.
name|tu
operator|.
name|thetd
expr_stmt|;
name|newtoken
argument_list|(
name|mod
argument_list|,
name|pos
argument_list|,
name|statuspt
argument_list|)
expr_stmt|;
return|return
operator|(
name|RCREQ
operator|)
return|;
block|}
comment|/* else if (STATUS==RCNREQ) */
if|if
condition|(
name|mexts
operator|>
literal|0
condition|)
return|return
operator|(
name|RCMEX
operator|)
return|;
name|newtoken
argument_list|(
name|mod
argument_list|,
name|pos
argument_list|,
name|statuspt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mexts
operator|==
operator|-
literal|1
condition|)
block|{
name|copypos
argument_list|(
name|pos
argument_list|,
name|savedpos
argument_list|)
expr_stmt|;
return|return
name|STATUS
operator|=
name|RCPEX
return|;
block|}
return|return
operator|(
operator|(
name|int
operator|)
name|STATUS
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ECONTEXT: Determine whether the current element can be ended, or whether              non-optional tokens remain at the current level or higher.              Returns 1 if element can be ended, or 0 if tokens remain.              On entry, STATUS==RCEND if there are no tokens left; if not,              pos points to the next model token to be tested.              TO DO: Support a "query" mode (what is required now?) by working                     with a copy of pos. */
end_comment

begin_function
name|int
name|econtext
parameter_list|(
name|mod
parameter_list|,
name|pos
parameter_list|,
name|statuspt
parameter_list|)
name|struct
name|thdr
name|mod
index|[]
decl_stmt|;
comment|/* Model of current open element. */
name|struct
name|mpos
name|pos
index|[]
decl_stmt|;
comment|/* Position in open element's model. */
name|UNCH
modifier|*
name|statuspt
decl_stmt|;
comment|/* Token status: RCHIT RCMISS RCEND RCREQ RCNREQ*/
block|{
name|unsigned
name|next
decl_stmt|;
comment|/* Position in AND group of next testable token.*/
name|Tstart
operator|=
name|T
expr_stmt|;
name|TRACEEND
argument_list|(
literal|"ECONT"
argument_list|,
name|mod
argument_list|,
name|pos
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|P
operator|<=
literal|1
condition|)
block|{
name|nextetd
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|TOKENHIT
operator|||
name|BITON
argument_list|(
name|TOCC
argument_list|,
name|TOPT
argument_list|)
operator|)
return|;
block|}
name|nextetd
operator|=
name|TTYPE
operator|==
name|TTETD
condition|?
name|TOKEN
operator|.
name|tu
operator|.
name|thetd
else|:
literal|0
expr_stmt|;
while|while
condition|(
name|STATUS
operator|!=
name|RCMISS
operator|&&
name|STATUS
operator|!=
name|RCEND
condition|)
block|{
name|STATUS
operator|=
operator|(
name|UNCH
operator|)
name|testend
argument_list|(
name|mod
argument_list|,
name|pos
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TRACEEND
argument_list|(
literal|"ECONTEND"
argument_list|,
name|mod
argument_list|,
name|pos
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|nextetd
operator|=
name|P
operator|<=
literal|1
operator|||
name|TTYPE
operator|!=
name|TTETD
condition|?
literal|0
else|:
name|TOKEN
operator|.
name|tu
operator|.
name|thetd
expr_stmt|;
if|if
condition|(
name|STATUS
operator|==
name|RCEND
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|P
operator|<=
literal|1
condition|)
return|return
operator|(
name|TOKENHIT
operator|||
name|BITON
argument_list|(
name|TOCC
argument_list|,
name|TOPT
argument_list|)
operator|)
return|;
if|if
condition|(
name|STATUS
operator|==
name|RCMISS
condition|)
block|{
if|if
condition|(
name|BITON
argument_list|(
name|TOCC
argument_list|,
name|TOPT
argument_list|)
condition|)
name|nextetd
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|tokenopt
argument_list|(
name|mod
argument_list|,
name|pos
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|STATUS
operator|=
name|RCNREQ
expr_stmt|;
if|if
condition|(
name|GTYPE
operator|!=
name|TTAND
condition|)
operator|++
name|T
expr_stmt|;
comment|/* T!=GNUM or group would have ended. */
else|else
name|T
operator|=
call|(
name|UNCH
call|)
argument_list|(
operator|(
operator|(
name|next
operator|=
operator|(
name|UNS
operator|)
name|offbit
argument_list|(
name|H
argument_list|,
operator|(
name|int
operator|)
name|T
argument_list|,
name|GNUM
argument_list|)
operator|)
operator|!=
literal|0
operator|)
condition|?
name|next
else|:
name|offbit
argument_list|(
name|H
argument_list|,
literal|0
argument_list|,
name|GNUM
argument_list|)
argument_list|)
expr_stmt|;
name|M
operator|=
name|G
operator|+
name|grpsz
argument_list|(
operator|&
name|GHDR
argument_list|,
operator|(
name|int
operator|)
name|T
operator|-
literal|1
argument_list|)
operator|+
literal|1
expr_stmt|;
name|TRACEEND
argument_list|(
literal|"ECONTNEW"
argument_list|,
name|mod
argument_list|,
name|pos
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|STATUS
operator|==
name|RCMISS
condition|)
block|{
if|if
condition|(
name|BITON
argument_list|(
name|TOCC
argument_list|,
name|TOPT
argument_list|)
condition|)
name|nextetd
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
comment|/* STATUS==RCEND */
block|}
end_function

begin_comment
comment|/* NEWTOKEN: Find the next token to test.  Set STATUS to indicate results:                   RCEND  if element has ended (no more tokens to test);                   RCREQ  if required new token was found;                   RCNREQ if non-required new token was found;                   RCHIT  if a hit token was repeated (now non-required);               and RCMISS if a new token can't be found because current token               (which was not hit) was neither unconditionally required nor               optional. */
end_comment

begin_function
name|VOID
name|newtoken
parameter_list|(
name|mod
parameter_list|,
name|pos
parameter_list|,
name|statuspt
parameter_list|)
name|struct
name|thdr
name|mod
index|[]
decl_stmt|;
comment|/* Model of current open element. */
name|struct
name|mpos
name|pos
index|[]
decl_stmt|;
comment|/* Position in open element's model. */
name|UNCH
modifier|*
name|statuspt
decl_stmt|;
comment|/* Token status: RCHIT RCMISS RCEND RCREQ RCNREQ*/
block|{
name|unsigned
name|nextand
init|=
literal|0
decl_stmt|;
comment|/* Position in AND group of next testable token.*/
name|int
name|currhit
init|=
operator|(
name|STATUS
operator|==
name|RCHIT
operator|)
decl_stmt|;
comment|/* 1=current GI hit; 0=not. */
comment|/* If the GI was a hit, turn on the hit bit and set the status to         assume that the token to be tested against the next GI will         be non-required.  If the current token is repeatable, exit so         it will stand as the next token to test.      */
if|if
condition|(
name|STATUS
operator|==
name|RCHIT
condition|)
block|{
name|HITSET
argument_list|(
name|H
argument_list|,
name|T
argument_list|)
expr_stmt|;
name|STATUS
operator|=
name|RCNREQ
expr_stmt|;
if|if
condition|(
name|BITON
argument_list|(
name|TOCC
argument_list|,
name|TREP
argument_list|)
condition|)
return|return;
block|}
comment|/* At this point, we must determine the next token to test:         either against the next GI, if this one was a hit, or         against the same GI if conditions permit a retry.         To find the next token, we must first end the current group,         if possible, and any we can that contain it.         If the outermost group was a hit and is repeatable, or         if the element has ended, we exit now.         If it hasn't ended, or was optional and ended with a miss,         we can retry the GI against the next token.      */
if|if
condition|(
operator|(
name|STATUS
operator|=
operator|(
name|UNCH
operator|)
name|testend
argument_list|(
name|mod
argument_list|,
name|pos
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
operator|)
operator|!=
name|RCNREQ
condition|)
return|return;
comment|/* At this point, the "current token" is either the original one,         or the token for the highest level unhit group that it ended.         We will retry a missed GI, by testing it against the next         token, if the current token:         1. Is optional;         2. Was hit (i.e., because it is repeatable and was hit by a            previous GI or because it is a hit group that just ended);         3. Is in an AND or OR group and is not the last testable token.          It will be the next sequential one (unhit one, in an AND group);         if there are none left, use the first unhit token in the group.         In either case, set M to correspond to the new T.      */
name|retest
label|:
name|TRACEEND
argument_list|(
literal|"RETEST"
argument_list|,
name|mod
argument_list|,
name|pos
argument_list|,
operator|(
name|int
operator|)
name|nextand
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GTYPE
operator|==
name|TTAND
condition|)
block|{
name|nextand
operator|=
name|offbit
argument_list|(
name|H
argument_list|,
operator|(
name|int
operator|)
name|T
argument_list|,
name|GNUM
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nextand
condition|)
name|nextand
operator|=
name|offbit
argument_list|(
name|H
argument_list|,
literal|0
argument_list|,
name|GNUM
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|BITON
argument_list|(
name|TOCC
argument_list|,
name|TOPT
argument_list|)
operator|||
name|TOKENHIT
operator|||
name|GTYPE
operator|==
name|TTOR
comment|/* T!=GNUM or group would have ended. */
operator|||
name|nextand
condition|)
block|{
if|if
condition|(
name|GTYPE
operator|!=
name|TTAND
condition|)
operator|++
name|T
expr_stmt|;
comment|/* T!=GNUM or group would have ended. */
else|else
name|T
operator|=
name|nextand
expr_stmt|;
name|M
operator|=
name|G
operator|+
name|grpsz
argument_list|(
operator|&
name|GHDR
argument_list|,
operator|(
name|int
operator|)
name|T
operator|-
literal|1
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|GTYPE
operator|==
name|TTAND
condition|)
block|{
comment|/* If AND group wrapped, it can end if all non-optionals were 		  hit. */
if|if
condition|(
name|T
operator|==
name|Tstart
operator|&&
operator|!
name|currhit
condition|)
block|{
name|UNCH
name|Psave
init|=
name|P
decl_stmt|;
name|int
name|rc
init|=
name|testend
argument_list|(
name|mod
argument_list|,
name|pos
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|Psave
operator|!=
name|P
condition|)
block|{
if|if
condition|(
operator|(
name|STATUS
operator|=
operator|(
name|UNCH
operator|)
name|rc
operator|)
operator|==
name|RCNREQ
condition|)
goto|goto
name|retest
goto|;
block|}
else|else
name|STATUS
operator|=
name|RCMISS
expr_stmt|;
block|}
comment|/* We only test unhit tokens, so we must use an unhit token 		  as Tstart (which is used to detect when the AND group has 		  wrapped). */
elseif|else
if|if
condition|(
name|HITON
argument_list|(
name|H
argument_list|,
name|Tstart
argument_list|)
condition|)
name|Tstart
operator|=
name|T
expr_stmt|;
block|}
block|}
else|else
name|STATUS
operator|=
name|RCMISS
expr_stmt|;
name|TRACEEND
argument_list|(
literal|"NEWTOKEN"
argument_list|,
name|mod
argument_list|,
name|pos
argument_list|,
operator|(
name|int
operator|)
name|nextand
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* TESTEND: End the current group, if possible, and any that it is nested in.             The current token will either be a group header, or some token             that could not end its group.  Return 1 if the (possibly new)             current token is repeatable; 0 if it is not. */
end_comment

begin_function
name|int
name|testend
parameter_list|(
name|mod
parameter_list|,
name|pos
parameter_list|,
name|andoptsw
parameter_list|,
name|newtknsw
parameter_list|)
name|struct
name|thdr
name|mod
index|[]
decl_stmt|;
comment|/* Model of current open element. */
name|struct
name|mpos
name|pos
index|[]
decl_stmt|;
comment|/* Position in open element's model. */
name|int
name|andoptsw
decl_stmt|;
comment|/* 1=test optional AND members; 0=ignore. */
name|int
name|newtknsw
decl_stmt|;
comment|/* 1=new token test; 0=end element test. */
block|{
name|int
name|rc
init|=
literal|0
decl_stmt|;
comment|/* Return code: RCNREQ RCHIT RCMISS RCEND */
while|while
condition|(
operator|!
name|rc
condition|)
block|{
name|TRACEEND
argument_list|(
literal|"TRACEEND"
argument_list|,
name|mod
argument_list|,
name|pos
argument_list|,
name|rc
argument_list|,
name|andoptsw
argument_list|)
expr_stmt|;
comment|/* TESTMISS:              If we've hit no tokens yet in the current group, and              the current token is the last unhit one in the group we can test,              we will end the group (it may never really have started!)              because we might be able to try the token that follows it.              In any group, a token is the last testable unhit token if it              is the last sequential one, as the GI was already tested against              the preceding unhit tokens.  In addition,              in a SEQ group, it is the last testable unhit token if it isn't              optional, because we can't skip past it to the following ones.              If we end the group, before popping the level, set M to G, as this              level`s group header will be the next level's current token.           */
if|if
condition|(
operator|!
name|ANYHIT
argument_list|(
name|H
argument_list|)
operator|&&
operator|(
name|T
operator|==
name|GNUM
operator|||
operator|(
name|GTYPE
operator|==
name|TTSEQ
operator|&&
name|BITOFF
argument_list|(
name|TOCC
argument_list|,
name|TOPT
argument_list|)
operator|)
operator|)
condition|)
block|{
name|M
operator|=
name|G
expr_stmt|;
operator|--
name|P
expr_stmt|;
if|if
condition|(
name|P
operator|<=
literal|1
condition|)
block|{
if|if
condition|(
name|BITON
argument_list|(
name|TOCC
argument_list|,
name|TOPT
argument_list|)
operator|||
name|TOKENHIT
condition|)
name|rc
operator|=
name|RCEND
expr_stmt|;
else|else
name|rc
operator|=
name|RCMISS
expr_stmt|;
block|}
continue|continue;
block|}
comment|/* TESTHIT:              See if we've hit all the non-optional tokens in the group.              If so, pop to the previous level and set the group's hit bit.              If we were called from NEWTOKEN we are trying to find the token              to test against the next start-tag, so if the group is repeatable,              process it again.  (If not, we were called from ECONTEXT and              are testing whether the element can be ended.)              Otherwise, if we are at the first level, the element is over.           */
if|if
condition|(
operator|(
name|GTYPE
operator|==
name|TTOR
operator|&&
name|TOKENHIT
operator|)
operator|||
operator|(
name|GTYPE
operator|==
name|TTSEQ
operator|&&
name|T
operator|==
operator|(
name|UNCH
operator|)
name|GNUM
operator|&&
operator|(
name|TOKENHIT
operator|||
name|BITON
argument_list|(
name|TOCC
argument_list|,
name|TOPT
argument_list|)
operator|)
operator|)
operator|||
operator|(
name|GTYPE
operator|==
name|TTAND
operator|&&
name|allhit
argument_list|(
operator|&
name|GHDR
argument_list|,
name|H
argument_list|,
literal|0
argument_list|,
name|andoptsw
argument_list|)
operator|)
condition|)
block|{
name|M
operator|=
name|G
expr_stmt|;
operator|--
name|P
expr_stmt|;
name|HITSET
argument_list|(
name|H
argument_list|,
name|T
argument_list|)
expr_stmt|;
name|Tstart
operator|=
name|T
expr_stmt|;
if|if
condition|(
name|newtknsw
operator|&&
name|BITON
argument_list|(
name|TOCC
argument_list|,
name|TREP
argument_list|)
condition|)
name|rc
operator|=
name|RCHIT
expr_stmt|;
elseif|else
if|if
condition|(
name|P
operator|<=
literal|1
condition|)
name|rc
operator|=
name|RCEND
expr_stmt|;
comment|/* If we are looking for a new token to test against the next 		  start-tag, then we need to consider optional and members 		  in this group, even if we didn't need to consider them 		  in the group that we just ended because that group had 		  wrapped. */
elseif|else
if|if
condition|(
name|newtknsw
condition|)
name|andoptsw
operator|=
literal|1
expr_stmt|;
comment|/* Else loop to test new outer group. */
block|}
else|else
name|rc
operator|=
name|RCNREQ
expr_stmt|;
comment|/* No group ended this time, so return. */
block|}
name|TRACEEND
argument_list|(
literal|"ENDFOUND"
argument_list|,
name|mod
argument_list|,
name|pos
argument_list|,
name|rc
argument_list|,
name|andoptsw
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/* TOKENOPT: Return 1 if current token is contextually optional;              otherwise, return 0. */
end_comment

begin_function
name|int
name|tokenopt
parameter_list|(
name|mod
parameter_list|,
name|pos
parameter_list|)
name|struct
name|thdr
name|mod
index|[]
decl_stmt|;
comment|/* Model of current open element. */
name|struct
name|mpos
name|pos
index|[]
decl_stmt|;
comment|/* Position in open element's model. */
block|{
name|TRACEEND
argument_list|(
literal|"TOKENOPT"
argument_list|,
name|mod
argument_list|,
name|pos
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|BITON
argument_list|(
name|TOCC
argument_list|,
name|TOPT
argument_list|)
comment|/* Inherently optional. */
operator|||
name|TOKENHIT
comment|/* Was hit (handles "plus" suffix case). */
operator|||
operator|(
operator|!
name|ANYHIT
argument_list|(
name|H
argument_list|)
operator|&&
name|groupopt
argument_list|(
name|mod
argument_list|,
name|pos
argument_list|)
operator|)
operator|)
return|;
comment|/* In optional group with no hits. */
block|}
end_function

begin_comment
comment|/* GROUPOPT: Temporarily makes the current group be the current token so that              TOKENOPT() can be applied to it.  Returns the value returned              by TOKENOPT. */
end_comment

begin_function
name|int
name|groupopt
parameter_list|(
name|mod
parameter_list|,
name|pos
parameter_list|)
name|struct
name|thdr
name|mod
index|[]
decl_stmt|;
comment|/* Model of current open element. */
name|struct
name|mpos
name|pos
index|[]
decl_stmt|;
comment|/* Position in open element's model. */
block|{
name|UNCH
name|saveM
decl_stmt|;
comment|/* Save M when testing if group is not required.*/
name|int
name|rc
decl_stmt|;
comment|/* 1=contextually optional; 0=not. */
if|if
condition|(
name|P
operator|==
literal|1
condition|)
return|return
operator|(
name|BITON
argument_list|(
name|GOCC
argument_list|,
name|TOPT
argument_list|)
operator|||
name|TOKENHIT
operator|)
return|;
name|saveM
operator|=
name|M
expr_stmt|;
name|M
operator|=
name|G
expr_stmt|;
operator|--
name|P
expr_stmt|;
name|rc
operator|=
name|tokenopt
argument_list|(
name|mod
argument_list|,
name|pos
argument_list|)
expr_stmt|;
operator|++
name|P
expr_stmt|;
name|G
operator|=
name|M
expr_stmt|;
name|M
operator|=
name|saveM
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/* TOKENREQ: Returns RCREQ if the current token is "contextually required".              That is, it is not contextually optional and                  1) it is a member of a "seq" group that is either required                     or has at least 1 hit token.                  2) it is a member of an "and" group in which all other                     tokens were hit.                           Optional tokens are not counted                           if GI is ETDCDATA, as we are looking for an                           omitted start-tag.  Otherwise, they are counted,                           as the GI might match one of them.              Returns RCNREQ if the current token is "not required". */
end_comment

begin_function
name|int
name|tokenreq
parameter_list|(
name|gi
parameter_list|,
name|mod
parameter_list|,
name|pos
parameter_list|)
name|struct
name|etd
modifier|*
name|gi
decl_stmt|;
comment|/* ETD of new GI. */
name|struct
name|thdr
name|mod
index|[]
decl_stmt|;
comment|/* Model of current open element. */
name|struct
name|mpos
name|pos
index|[]
decl_stmt|;
comment|/* Position in open element's model. */
block|{
name|TRACEGI
argument_list|(
literal|"TOKENREQ"
argument_list|,
name|gi
argument_list|,
name|mod
argument_list|,
name|pos
argument_list|)
expr_stmt|;
return|return
operator|(
name|tokenopt
argument_list|(
name|mod
argument_list|,
name|pos
argument_list|)
condition|?
name|RCNREQ
else|:
operator|(
name|GTYPE
operator|==
name|TTSEQ
operator|&&
operator|(
name|ANYHIT
argument_list|(
name|H
argument_list|)
operator|||
name|groupreq
argument_list|(
name|gi
argument_list|,
name|mod
argument_list|,
name|pos
argument_list|)
operator|==
name|RCREQ
operator|)
if|#
directive|if
literal|0
expr||| (GTYPE==TTAND&& allhit(&GHDR, H, T, \*gi!=ETDCDATA*\ 1))
endif|#
directive|endif
operator|)
condition|?
name|RCREQ
else|:
name|RCNREQ
operator|)
return|;
block|}
end_function

begin_comment
comment|/* GROUPREQ: Temporarily makes the current group be the current token so that              TOKENREQ() can be applied to it.  Returns the value returned              by TOKENREQ. */
end_comment

begin_function
name|int
name|groupreq
parameter_list|(
name|gi
parameter_list|,
name|mod
parameter_list|,
name|pos
parameter_list|)
name|struct
name|etd
modifier|*
name|gi
decl_stmt|;
comment|/* ETD of new GI. */
name|struct
name|thdr
name|mod
index|[]
decl_stmt|;
comment|/* Model of current open element. */
name|struct
name|mpos
name|pos
index|[]
decl_stmt|;
comment|/* Position in open element's model. */
block|{
name|UNCH
name|saveM
decl_stmt|;
comment|/* Save M when testing if group is not required.*/
name|int
name|rc
decl_stmt|;
comment|/* Return code: RCREQ RCNREQ */
if|if
condition|(
name|P
operator|==
literal|1
condition|)
return|return
operator|(
name|BITOFF
argument_list|(
name|GOCC
argument_list|,
name|TOPT
argument_list|)
condition|?
name|RCREQ
else|:
name|RCNREQ
operator|)
return|;
name|saveM
operator|=
name|M
expr_stmt|;
name|M
operator|=
name|G
expr_stmt|;
operator|--
name|P
expr_stmt|;
name|rc
operator|=
name|tokenreq
argument_list|(
name|gi
argument_list|,
name|mod
argument_list|,
name|pos
argument_list|)
expr_stmt|;
operator|++
name|P
expr_stmt|;
name|G
operator|=
name|M
expr_stmt|;
name|M
operator|=
name|saveM
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/* GRPSZ: Returns the number of tokens spanned by a group in the model (M),           from the group's start (G) to a specified index within the group (T).           M = 0, plus 1 for each token in the group, plus the size of           any subgroups (gotten by calling GRPSZ recursively).  On entry,           M must be equal to G at the current level. */
end_comment

begin_function
name|int
name|grpsz
parameter_list|(
name|g
parameter_list|,
name|t
parameter_list|)
name|struct
name|thdr
modifier|*
name|g
decl_stmt|;
comment|/* mod[G]: Ptr to group in the model. */
name|int
name|t
decl_stmt|;
comment|/* T: Index of last token in the group. */
block|{
name|struct
name|thdr
modifier|*
name|p
init|=
name|g
decl_stmt|;
comment|/* Ptr to current token in the model. */
name|int
name|m
init|=
literal|0
decl_stmt|;
comment|/* Size of group (including nested groups). */
name|int
name|i
init|=
literal|0
decl_stmt|;
comment|/* Number of group members (loop counter). */
name|UNS
name|type
decl_stmt|;
comment|/* Token type (without TOREP bits). */
while|while
condition|(
operator|++
name|i
operator|<=
name|t
condition|)
block|{
operator|++
name|p
expr_stmt|;
operator|++
name|m
expr_stmt|;
name|type
operator|=
name|GET
argument_list|(
name|p
operator|->
name|ttype
argument_list|,
name|TTMASK
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|TTOR
operator|||
name|type
operator|==
name|TTSEQ
operator|||
name|type
operator|==
name|TTAND
condition|)
block|{
name|m
operator|+=
name|grpsz
argument_list|(
name|p
argument_list|,
name|p
operator|->
name|tu
operator|.
name|tnum
argument_list|)
expr_stmt|;
name|p
operator|=
name|g
operator|+
name|m
expr_stmt|;
block|}
block|}
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ALLHIT: Returns 1 if all hit bits for the specified group are turned on,            (other than those that correspond to optional tokens if "opt" is            0) and the "but" bit (all bits if "but" bit is zero).  Otherwise,            returns 0.  GRPSZ is used to skip past subgroup tokens. */
end_comment

begin_function
name|int
name|allhit
parameter_list|(
name|p
parameter_list|,
name|hits
parameter_list|,
name|but
parameter_list|,
name|opt
parameter_list|)
name|struct
name|thdr
modifier|*
name|p
decl_stmt|;
comment|/* mod[G]: Ptr to group in the model. */
name|unsigned
name|long
modifier|*
name|hits
decl_stmt|;
comment|/* H: Hit bits to be tested. */
name|int
name|but
decl_stmt|;
comment|/* Index of bit to ignore; 0=test all. */
name|int
name|opt
decl_stmt|;
comment|/* 1=optional tokens must be hit; 0=ignore. */
block|{
name|int
name|b
init|=
literal|0
decl_stmt|;
comment|/* Index of bit being tested in hits. */
name|int
name|e
init|=
name|p
operator|->
name|tu
operator|.
name|tnum
decl_stmt|;
comment|/* Ending index (number of bits to test). */
name|unsigned
name|type
decl_stmt|;
comment|/* Token type (without TOREP bits). */
while|while
condition|(
operator|++
name|p
operator|,
operator|++
name|b
operator|<=
name|e
condition|)
block|{
if|if
condition|(
name|HITOFF
argument_list|(
name|hits
argument_list|,
name|b
argument_list|)
operator|&&
operator|(
name|opt
operator|||
name|BITOFF
argument_list|(
name|p
operator|->
name|ttype
argument_list|,
name|TOPT
argument_list|)
operator|)
operator|&&
name|b
operator|!=
name|but
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|type
operator|=
name|GET
argument_list|(
name|p
operator|->
name|ttype
argument_list|,
name|TTMASK
argument_list|)
operator|)
operator|==
name|TTOR
operator|||
name|type
operator|==
name|TTSEQ
operator|||
name|type
operator|==
name|TTAND
condition|)
name|p
operator|+=
name|grpsz
argument_list|(
name|p
argument_list|,
name|p
operator|->
name|tu
operator|.
name|tnum
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* OFFBIT: Returns the index of the first unset bit after (i.e., not including)            the caller's "first" bit. If all bits through the            specified last bit are on, it returns 0. */
end_comment

begin_function
name|int
name|offbit
parameter_list|(
name|bits
parameter_list|,
name|first
parameter_list|,
name|last
parameter_list|)
name|unsigned
name|long
modifier|*
name|bits
decl_stmt|;
comment|/* Bits to be tested. */
name|int
name|first
decl_stmt|;
comment|/* Index of first bit to be tested in bits. */
name|int
name|last
decl_stmt|;
comment|/* Index of last bit to be tested in bits. */
block|{
while|while
condition|(
operator|++
name|first
operator|<=
name|last
condition|)
if|if
condition|(
name|HITOFF
argument_list|(
name|bits
argument_list|,
name|first
argument_list|)
condition|)
return|return
name|first
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ANYHIT: Return 1 if any bit is set. */
end_comment

begin_function
name|int
name|anyhit
parameter_list|(
name|bits
parameter_list|)
name|unsigned
name|long
modifier|*
name|bits
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|grplongs
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|bits
index|[
name|i
index|]
operator|!=
literal|0
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Local Variables: c-indent-level: 5 c-continued-statement-offset: 5 c-brace-offset: -5 c-argdecl-indent: 0 c-label-offset: -5 comment-column: 30 End: */
end_comment

end_unit

