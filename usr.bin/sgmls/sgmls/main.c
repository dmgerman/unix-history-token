begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* main.c -    Main program for sgmls.       Written by James Clark (jjc@jclark.com). */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"std.h"
end_include

begin_include
include|#
directive|include
file|"getopt.h"
end_include

begin_include
include|#
directive|include
file|"entity.h"
end_include

begin_comment
comment|/* Templates for entity control blocks. */
end_comment

begin_include
include|#
directive|include
file|"adl.h"
end_include

begin_comment
comment|/* Definitions for attribute list processing. */
end_comment

begin_include
include|#
directive|include
file|"sgmlmain.h"
end_include

begin_comment
comment|/* Main interface to SGML services. */
end_comment

begin_include
include|#
directive|include
file|"appl.h"
end_include

begin_include
include|#
directive|include
file|"alloc.h"
end_include

begin_define
define|#
directive|define
name|READCNT
value|512
end_define

begin_comment
comment|/* Before using argv[0] in error messages, strip off everything up to and including the last character in prog that occurs in PROG_PREFIX. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|PROG_PREFIX
end_ifndef

begin_define
define|#
directive|define
name|PROG_PREFIX
value|"/"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not PROG_PREFIX */
end_comment

begin_comment
comment|/* Message catalogue name. */
end_comment

begin_define
define|#
directive|define
name|CAT_NAME
value|"sgmls"
end_define

begin_comment
comment|/* Message set to use for application error messages. */
end_comment

begin_define
define|#
directive|define
name|APP_SET
value|4
end_define

begin_comment
comment|/* Message set to use for error messages from catalog.c. */
end_comment

begin_define
define|#
directive|define
name|CAT_SET
value|5
end_define

begin_define
define|#
directive|define
name|CATALOG_ERROR_HEADER_MSGNO
value|20
end_define

begin_define
define|#
directive|define
name|CATALOG_ERROR_HEADER_TEXT
value|"Catalog error at %s, line %lu"
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_EXTENDED_PRINTF
end_ifdef

begin_define
define|#
directive|define
name|xvfprintf
value|vfprintf
end_define

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|extern
name|int
name|xvfprintf
name|P
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|char
operator|*
operator|,
name|va_list
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|VOID
name|usage
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|VOID
name|fatal
name|VP
argument_list|(
operator|(
name|int
operator|,
operator|...
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|VOID
name|do_error
name|P
argument_list|(
operator|(
name|int
operator|,
name|va_list
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|VOID
name|swinit
name|P
argument_list|(
operator|(
expr|struct
name|switches
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|VOID
name|write_caps
name|P
argument_list|(
operator|(
name|char
operator|*
operator|,
expr|struct
name|sgmlcap
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|VOID
name|do_catalog_error
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|UNIV
name|make_docent
name|P
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|munge_program_name
name|P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|VOID
name|die
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|SUPPORT_SUBDOC
end_ifdef

begin_decl_stmt
specifier|static
name|VOID
name|build_subargv
name|P
argument_list|(
operator|(
expr|struct
name|switches
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|VOID
name|cleanup
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|create_subcap_file
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SUPPORT_SUBDOC */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|errlist
index|[]
init|=
block|{
literal|0
block|,
literal|"Out of memory"
block|,
literal|"Cannot open SGML document entity"
block|,
literal|"Cannot exec `%s': %s"
block|,
literal|"Cannot fork: %s"
block|,
literal|"Error waiting for process: %s"
block|,
literal|"Program %s got fatal signal %d"
block|,
literal|"Cannot open `%s': %s"
block|,
literal|"Subdocument capacity botch"
block|,
literal|"Non-existent subdocument entity `%s' not processed"
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|suppsw
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means suppress output. */
end_comment

begin_decl_stmt
name|int
name|locsw
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means generate location info. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|prog
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Program name (for error messages). */
end_comment

begin_decl_stmt
specifier|static
name|nl_catd
name|catd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Message catalogue descriptor. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|capfile
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* File for capacity report. */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|version_string
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CATALOG
name|catalog
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Entity catalog. */
end_comment

begin_decl_stmt
name|char
name|options
index|[]
init|=
block|{
literal|'c'
block|,
literal|':'
block|,
literal|'d'
block|,
literal|'e'
block|,
literal|'g'
block|,
literal|'i'
block|,
literal|':'
block|,
literal|'l'
block|,
literal|'o'
block|,
literal|':'
block|,
literal|'p'
block|,
literal|'r'
block|,
literal|'s'
block|,
literal|'u'
block|,
literal|'v'
block|,
literal|'m'
block|,
literal|':'
block|,
ifdef|#
directive|ifdef
name|CANT_REDIRECT_STDERR
literal|'f'
block|,
literal|':'
block|,
endif|#
directive|endif
comment|/* CANT_REDIRECT_STDERR */
ifdef|#
directive|ifdef
name|TRACE
literal|'x'
block|,
literal|':'
block|,
literal|'y'
block|,
literal|':'
block|,
endif|#
directive|endif
comment|/* TRACE */
literal|'\0'
block|}
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|SUPPORT_SUBDOC
end_ifdef

begin_decl_stmt
name|int
name|suberr
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Error in subdocument. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|subargv
index|[
sizeof|sizeof
argument_list|(
name|options
argument_list|)
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|subargc
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|nopenbuf
index|[
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|*
literal|3
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|sgmldecl_file
index|[
name|L_tmpnam
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|subcap_file
index|[
name|L_tmpnam
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
specifier|static
name|char
name|stderr_buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|int
name|opt
decl_stmt|;
ifdef|#
directive|ifdef
name|CANT_REDIRECT_STDERR
name|char
modifier|*
name|errfile
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
name|struct
name|sgmlcap
name|cap
decl_stmt|;
name|struct
name|switches
name|sw
decl_stmt|;
name|int
name|nincludes
init|=
literal|0
decl_stmt|;
comment|/* number of -i options */
name|setbuf
argument_list|(
name|stderr
argument_list|,
name|stderr_buf
argument_list|)
expr_stmt|;
comment|/* Define MAIN_HOOK in config.h if some function needs to be called here. */
ifdef|#
directive|ifdef
name|MAIN_HOOK
name|MAIN_HOOK
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SUPPORT_SUBDOC
name|subargv
index|[
name|subargc
operator|++
index|]
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
endif|#
directive|endif
name|prog
operator|=
name|argv
index|[
literal|0
index|]
operator|=
name|munge_program_name
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"sgmls"
argument_list|)
expr_stmt|;
name|catd
operator|=
name|catopen
argument_list|(
name|CAT_NAME
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|catalog
operator|=
name|catalog_create
argument_list|(
name|do_catalog_error
argument_list|)
expr_stmt|;
name|swinit
argument_list|(
operator|&
name|sw
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|opt
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|options
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|opt
condition|)
block|{
case|case
literal|'m'
case|:
name|catalog_load_file
argument_list|(
name|catalog
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
comment|/* Generate location information. */
name|locsw
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
comment|/* Print capacity usage. */
name|sw
operator|.
name|swcap
operator|=
literal|1
expr_stmt|;
name|capfile
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* Suppress output. */
name|suppsw
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
comment|/* Report duplicate entity declarations. */
name|sw
operator|.
name|swdupent
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
comment|/* Provide entity stack trace in error msg. */
name|sw
operator|.
name|swenttr
operator|=
literal|1
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|CANT_REDIRECT_STDERR
case|case
literal|'f'
case|:
comment|/* Redirect errors. */
name|errfile
operator|=
name|optarg
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* CANT_REDIRECT_STDERR */
case|case
literal|'g'
case|:
comment|/* Provide GI stack trace in error messages. */
name|sw
operator|.
name|sweltr
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
comment|/* Parse only the prolog. */
name|sw
operator|.
name|onlypro
operator|=
literal|1
expr_stmt|;
name|suppsw
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
comment|/* Give warning for defaulted references. */
name|sw
operator|.
name|swrefmsg
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|sw
operator|.
name|swundef
operator|=
literal|1
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|TRACE
case|case
literal|'x'
case|:
comment|/* Trace options for the document body. */
name|sw
operator|.
name|trace
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'y'
case|:
comment|/* Trace options for the prolog. */
name|sw
operator|.
name|ptrace
operator|=
name|optarg
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* TRACE */
case|case
literal|'v'
case|:
comment|/* Print the version number. */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"sgmls version %s\n"
argument_list|,
name|version_string
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|sw
operator|.
name|nopen
operator|=
name|atol
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|sw
operator|.
name|nopen
operator|<=
literal|0
condition|)
name|usage
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
comment|/* Define parameter entity as "INCLUDE". */
name|sw
operator|.
name|includes
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|UNIV
operator|)
name|sw
operator|.
name|includes
argument_list|,
operator|(
name|nincludes
operator|+
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|sw
operator|.
name|includes
index|[
name|nincludes
operator|++
index|]
operator|=
name|optarg
expr_stmt|;
name|sw
operator|.
name|includes
index|[
name|nincludes
index|]
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
name|usage
argument_list|()
expr_stmt|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|CANT_REDIRECT_STDERR
if|if
condition|(
name|errfile
condition|)
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|fp
operator|=
name|fopen
argument_list|(
name|errfile
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fp
condition|)
name|fatal
argument_list|(
name|E_OPEN
argument_list|,
name|errfile
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|freopen
argument_list|(
name|errfile
argument_list|,
literal|"w"
argument_list|,
name|stderr
argument_list|)
condition|)
block|{
comment|/* Can't use fatal() since stderr is now closed */
name|printf
argument_list|(
literal|"%s: "
argument_list|,
name|prog
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|errlist
index|[
name|E_OPEN
index|]
argument_list|,
name|errfile
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* CANT_REDIRECT_STDERR */
operator|(
name|void
operator|)
name|sgmlset
argument_list|(
operator|&
name|sw
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_SUBDOC
name|build_subargv
argument_list|(
operator|&
name|sw
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sgmlsdoc
argument_list|(
name|make_docent
argument_list|(
name|argc
operator|-
name|optind
argument_list|,
name|argv
operator|+
name|optind
argument_list|)
argument_list|)
condition|)
name|fatal
argument_list|(
name|E_DOC
argument_list|)
expr_stmt|;
name|process_document
argument_list|(
name|sw
operator|.
name|nopen
operator|>
literal|0
argument_list|)
expr_stmt|;
name|sgmlend
argument_list|(
operator|&
name|cap
argument_list|)
expr_stmt|;
if|if
condition|(
name|capfile
condition|)
name|write_caps
argument_list|(
name|capfile
argument_list|,
operator|&
name|cap
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_SUBDOC
name|cleanup
argument_list|()
expr_stmt|;
if|if
condition|(
name|suberr
condition|)
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SUPPORT_SUBDOC */
if|if
condition|(
name|sgmlgcnterr
argument_list|()
operator|>
literal|0
condition|)
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sw
operator|.
name|nopen
condition|)
name|output_conforming
argument_list|()
expr_stmt|;
name|exit
argument_list|(
name|EXIT_SUCCESS
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|munge_program_name
parameter_list|(
name|arg
parameter_list|,
name|dflt
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|,
decl|*
name|dflt
decl_stmt|;
end_function

begin_block
block|{
name|char
modifier|*
name|p
decl_stmt|;
ifdef|#
directive|ifdef
name|PROG_STRIP_EXTENSION
name|char
modifier|*
name|ext
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|arg
operator|||
operator|!
operator|*
name|arg
condition|)
return|return
name|dflt
return|;
name|p
operator|=
name|strchr
argument_list|(
name|arg
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|p
operator|==
name|arg
condition|)
break|break;
operator|--
name|p
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|PROG_PREFIX
argument_list|,
operator|*
name|p
argument_list|)
condition|)
block|{
name|p
operator|++
expr_stmt|;
break|break;
block|}
block|}
name|arg
operator|=
name|p
expr_stmt|;
ifdef|#
directive|ifdef
name|PROG_STRIP_EXTENSION
name|ext
operator|=
name|strrchr
argument_list|(
name|arg
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|ext
condition|)
block|{
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|ext
operator|-
name|arg
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|p
argument_list|,
name|arg
argument_list|,
name|ext
operator|-
name|arg
argument_list|)
expr_stmt|;
name|p
index|[
name|ext
operator|-
name|arg
index|]
operator|=
literal|'\0'
expr_stmt|;
name|arg
operator|=
name|p
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* PROG_STRIP_EXTENSION */
ifdef|#
directive|ifdef
name|PROG_FOLD
ifdef|#
directive|ifdef
name|PROG_STRIP_EXTENSION
if|if
condition|(
operator|!
name|ext
condition|)
block|{
endif|#
directive|endif
name|p
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|arg
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|p
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|arg
operator|=
name|p
expr_stmt|;
ifdef|#
directive|ifdef
name|PROG_STRIP_EXTENSION
block|}
endif|#
directive|endif
for|for
control|(
name|p
operator|=
name|arg
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
name|ISASCII
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p
argument_list|)
operator|&&
name|isupper
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p
argument_list|)
condition|)
operator|*
name|p
operator|=
name|tolower
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PROG_FOLD */
return|return
name|arg
return|;
block|}
end_block

begin_function
specifier|static
name|UNIV
name|make_docent
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|UNS
name|len
init|=
literal|1
decl_stmt|;
name|int
name|i
decl_stmt|;
name|UNIV
name|res
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
specifier|static
name|char
modifier|*
name|stdinname
init|=
name|STDINNAME
decl_stmt|;
if|if
condition|(
name|argc
operator|==
literal|0
condition|)
block|{
name|argv
operator|=
operator|&
name|stdinname
expr_stmt|;
name|argc
operator|=
literal|1
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
name|len
operator|+=
name|strlen
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
operator|+
literal|1
expr_stmt|;
name|res
operator|=
name|xmalloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|res
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|strcpy
argument_list|(
name|ptr
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|strchr
argument_list|(
name|ptr
argument_list|,
literal|'\0'
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
operator|*
name|ptr
operator|=
literal|'\0'
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_function
specifier|static
name|VOID
name|usage
parameter_list|()
block|{
comment|/* Don't mention -o since this are for internal use only. */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: %s [-deglprsuv]%s [-c file] [-i entity] [-m file]%s [filename ...]\n"
argument_list|,
name|prog
argument_list|,
ifdef|#
directive|ifdef
name|CANT_REDIRECT_STDERR
literal|" [-f file]"
argument_list|,
else|#
directive|else
comment|/* not CANT_REDIRECT_STDERR */
literal|""
argument_list|,
endif|#
directive|endif
comment|/* not CANT_REDIRECT_STDERR */
ifdef|#
directive|ifdef
name|TRACE
literal|" [-x flags] [-y flags]"
else|#
directive|else
comment|/* not TRACE */
literal|""
endif|#
directive|endif
comment|/* not TRACE */
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|VOID
name|die
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|SUPPORT_SUBDOC
name|cleanup
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* SUPPORT_SUBDOC */
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|VOID
name|swinit
parameter_list|(
name|swp
parameter_list|)
name|struct
name|switches
modifier|*
name|swp
decl_stmt|;
block|{
name|swp
operator|->
name|swenttr
operator|=
literal|0
expr_stmt|;
name|swp
operator|->
name|sweltr
operator|=
literal|0
expr_stmt|;
name|swp
operator|->
name|swbufsz
operator|=
name|READCNT
operator|+
literal|2
expr_stmt|;
name|swp
operator|->
name|prog
operator|=
name|prog
expr_stmt|;
name|swp
operator|->
name|swdupent
operator|=
literal|0
expr_stmt|;
name|swp
operator|->
name|swrefmsg
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|TRACE
name|swp
operator|->
name|trace
operator|=
literal|0
expr_stmt|;
name|swp
operator|->
name|ptrace
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* TRACE */
name|swp
operator|->
name|catd
operator|=
name|catd
expr_stmt|;
name|swp
operator|->
name|catalog
operator|=
name|catalog
expr_stmt|;
name|swp
operator|->
name|swambig
operator|=
literal|1
expr_stmt|;
comment|/* Always check for ambiguity. */
name|swp
operator|->
name|swundef
operator|=
literal|0
expr_stmt|;
name|swp
operator|->
name|swcap
operator|=
literal|0
expr_stmt|;
comment|/* Don't check capacities. */
name|swp
operator|->
name|nopen
operator|=
literal|0
expr_stmt|;
name|swp
operator|->
name|onlypro
operator|=
literal|0
expr_stmt|;
name|swp
operator|->
name|includes
operator|=
literal|0
expr_stmt|;
name|swp
operator|->
name|die
operator|=
name|die
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SUPPORT_SUBDOC
end_ifdef

begin_function
specifier|static
name|VOID
name|build_subargv
parameter_list|(
name|swp
parameter_list|)
name|struct
name|switches
modifier|*
name|swp
decl_stmt|;
block|{
if|if
condition|(
name|suppsw
condition|)
name|subargv
index|[
name|subargc
operator|++
index|]
operator|=
literal|"-s"
expr_stmt|;
if|if
condition|(
name|locsw
condition|)
name|subargv
index|[
name|subargc
operator|++
index|]
operator|=
literal|"-l"
expr_stmt|;
if|if
condition|(
name|swp
operator|->
name|swdupent
condition|)
name|subargv
index|[
name|subargc
operator|++
index|]
operator|=
literal|"-d"
expr_stmt|;
if|if
condition|(
name|swp
operator|->
name|swenttr
condition|)
name|subargv
index|[
name|subargc
operator|++
index|]
operator|=
literal|"-e"
expr_stmt|;
if|if
condition|(
name|swp
operator|->
name|sweltr
condition|)
name|subargv
index|[
name|subargc
operator|++
index|]
operator|=
literal|"-g"
expr_stmt|;
if|if
condition|(
name|swp
operator|->
name|swrefmsg
condition|)
name|subargv
index|[
name|subargc
operator|++
index|]
operator|=
literal|"-r"
expr_stmt|;
ifdef|#
directive|ifdef
name|TRACE
if|if
condition|(
name|swp
operator|->
name|trace
condition|)
block|{
name|subargv
index|[
name|subargc
operator|++
index|]
operator|=
literal|"-x"
expr_stmt|;
name|subargv
index|[
name|subargc
operator|++
index|]
operator|=
name|swp
operator|->
name|trace
expr_stmt|;
block|}
if|if
condition|(
name|swp
operator|->
name|ptrace
condition|)
block|{
name|subargv
index|[
name|subargc
operator|++
index|]
operator|=
literal|"-y"
expr_stmt|;
name|subargv
index|[
name|subargc
operator|++
index|]
operator|=
name|swp
operator|->
name|ptrace
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* TRACE */
name|subargv
index|[
name|subargc
operator|++
index|]
operator|=
literal|"-o"
expr_stmt|;
name|sprintf
argument_list|(
name|nopenbuf
argument_list|,
literal|"%ld"
argument_list|,
name|swp
operator|->
name|nopen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|subargv
index|[
name|subargc
operator|++
index|]
operator|=
name|nopenbuf
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|VOID
name|handler
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
name|signal
argument_list|(
name|sig
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|cleanup
argument_list|()
expr_stmt|;
name|raise
argument_list|(
name|sig
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|VOID
name|cleanup
parameter_list|()
block|{
if|if
condition|(
name|sgmldecl_file
index|[
literal|0
index|]
condition|)
block|{
operator|(
name|void
operator|)
name|remove
argument_list|(
name|sgmldecl_file
argument_list|)
expr_stmt|;
name|sgmldecl_file
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|subcap_file
index|[
literal|0
index|]
condition|)
block|{
operator|(
name|void
operator|)
name|remove
argument_list|(
name|subcap_file
argument_list|)
expr_stmt|;
name|subcap_file
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|store_sgmldecl
parameter_list|()
block|{
if|if
condition|(
operator|!
name|sgmldecl_file
index|[
literal|0
index|]
condition|)
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
if|if
condition|(
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|handler
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGTERM
if|if
condition|(
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|handler
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SIGTERM */
ifdef|#
directive|ifdef
name|SIGPIPE
if|if
condition|(
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|handler
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGHUP
if|if
condition|(
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|handler
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tmpnam
argument_list|(
name|sgmldecl_file
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|fp
operator|=
name|fopen
argument_list|(
name|sgmldecl_file
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fp
condition|)
name|fatal
argument_list|(
name|E_OPEN
argument_list|,
name|sgmldecl_file
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|sgmlwrsd
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
return|return
name|sgmldecl_file
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|create_subcap_file
parameter_list|()
block|{
if|if
condition|(
name|subcap_file
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|tmpnam
argument_list|(
name|subcap_file
argument_list|)
expr_stmt|;
name|fp
operator|=
name|fopen
argument_list|(
name|subcap_file
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fp
condition|)
name|fatal
argument_list|(
name|E_OPEN
argument_list|,
name|subcap_file
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
return|return
name|subcap_file
return|;
block|}
end_function

begin_function
name|char
modifier|*
modifier|*
name|make_argv
parameter_list|(
name|id
parameter_list|)
name|UNIV
name|id
decl_stmt|;
block|{
name|int
name|nfiles
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|id
operator|,
name|nfiles
operator|=
literal|0
init|;
operator|*
name|p
condition|;
name|p
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|'\0'
argument_list|)
operator|+
literal|1
control|)
name|nfiles
operator|++
expr_stmt|;
name|argv
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|subargc
operator|+
literal|2
operator|+
literal|1
operator|+
name|nfiles
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|UNIV
operator|)
name|argv
argument_list|,
operator|(
name|UNIV
operator|)
name|subargv
argument_list|,
name|subargc
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
name|subargc
expr_stmt|;
name|argv
index|[
name|i
operator|++
index|]
operator|=
literal|"-c"
expr_stmt|;
name|argv
index|[
name|i
operator|++
index|]
operator|=
name|create_subcap_file
argument_list|()
expr_stmt|;
name|argv
index|[
name|i
operator|++
index|]
operator|=
name|store_sgmldecl
argument_list|()
expr_stmt|;
for|for
control|(
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|id
init|;
operator|*
name|p
condition|;
name|p
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|'\0'
argument_list|)
operator|+
literal|1
control|)
name|argv
index|[
name|i
operator|++
index|]
operator|=
name|p
expr_stmt|;
name|argv
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|argv
return|;
block|}
end_function

begin_function
name|VOID
name|get_subcaps
parameter_list|()
block|{
name|long
name|cap
index|[
name|NCAPACITY
index|]
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|subcap_file
index|[
literal|0
index|]
condition|)
return|return;
name|errno
operator|=
literal|0
expr_stmt|;
name|fp
operator|=
name|fopen
argument_list|(
name|subcap_file
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fp
condition|)
name|fatal
argument_list|(
name|E_OPEN
argument_list|,
name|subcap_file
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCAPACITY
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%*s %ld"
argument_list|,
name|cap
operator|+
name|i
argument_list|)
operator|!=
literal|1
condition|)
name|fatal
argument_list|(
name|E_CAPBOTCH
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|sgmlsubcap
argument_list|(
name|cap
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SUPPORT_SUBDOC */
end_comment

begin_comment
comment|/* Print capacity statistics.*/
end_comment

begin_function
specifier|static
name|VOID
name|write_caps
parameter_list|(
name|name
parameter_list|,
name|p
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|sgmlcap
modifier|*
name|p
decl_stmt|;
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|fp
operator|=
name|fopen
argument_list|(
name|name
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fp
condition|)
name|fatal
argument_list|(
name|E_OPEN
argument_list|,
name|name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
comment|/* This is in RACT format. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCAPACITY
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s %ld\n"
argument_list|,
name|p
operator|->
name|name
index|[
name|i
index|]
argument_list|,
name|p
operator|->
name|number
index|[
name|i
index|]
operator|*
name|p
operator|->
name|points
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|UNIV
name|xmalloc
parameter_list|(
name|n
parameter_list|)
name|UNS
name|n
decl_stmt|;
block|{
name|UNIV
name|p
init|=
name|malloc
argument_list|(
name|n
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
name|fatal
argument_list|(
name|E_NOMEM
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_function
name|UNIV
name|xrealloc
parameter_list|(
name|s
parameter_list|,
name|n
parameter_list|)
name|UNIV
name|s
decl_stmt|;
name|UNS
name|n
decl_stmt|;
block|{
name|s
operator|=
name|s
condition|?
name|realloc
argument_list|(
name|s
argument_list|,
name|n
argument_list|)
else|:
name|malloc
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
name|fatal
argument_list|(
name|E_NOMEM
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_decl_stmt
specifier|static
ifdef|#
directive|ifdef
name|VARARGS
name|VOID
name|fatal
argument_list|(
name|va_alist
argument_list|)
name|va_dcl
else|#
directive|else
name|VOID
name|fatal
argument_list|(
name|int
name|errnum
argument_list|,
operator|...
argument_list|)
endif|#
directive|endif
block|{
ifdef|#
directive|ifdef
name|VARARGS
name|int
name|errnum
decl_stmt|;
endif|#
directive|endif
name|va_list
name|ap
decl_stmt|;
ifdef|#
directive|ifdef
name|VARARGS
name|va_start
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|errnum
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
else|#
directive|else
name|va_start
argument_list|(
name|ap
argument_list|,
name|errnum
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|do_error
argument_list|(
name|errnum
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|VARARGS
end_ifdef

begin_decl_stmt
name|VOID
name|appl_error
argument_list|(
name|va_alist
argument_list|)
name|va_dcl
else|#
directive|else
name|VOID
name|appl_error
argument_list|(
name|int
name|errnum
argument_list|,
operator|...
argument_list|)
endif|#
directive|endif
block|{
ifdef|#
directive|ifdef
name|VARARGS
name|int
name|errnum
decl_stmt|;
endif|#
directive|endif
name|va_list
name|ap
decl_stmt|;
ifdef|#
directive|ifdef
name|VARARGS
name|va_start
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|errnum
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
else|#
directive|else
name|va_start
argument_list|(
name|ap
argument_list|,
name|errnum
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|do_error
argument_list|(
name|errnum
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_function
specifier|static
name|VOID
name|do_error
parameter_list|(
name|errnum
parameter_list|,
name|ap
parameter_list|)
name|int
name|errnum
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
block|{
name|char
modifier|*
name|text
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|prog
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|errnum
operator|>
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|errnum
operator|<
sizeof|sizeof
argument_list|(
name|errlist
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|errlist
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|text
operator|=
name|catgets
argument_list|(
name|catd
argument_list|,
name|APP_SET
argument_list|,
name|errnum
argument_list|,
name|errlist
index|[
name|errnum
index|]
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|text
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|xvfprintf
argument_list|(
name|stderr
argument_list|,
name|text
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|VOID
name|do_catalog_error
parameter_list|(
name|filename
parameter_list|,
name|lineno
parameter_list|,
name|error_number
parameter_list|,
name|flags
parameter_list|,
name|sys_errno
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
name|unsigned
name|long
name|lineno
decl_stmt|;
name|int
name|error_number
decl_stmt|;
name|unsigned
name|flags
decl_stmt|;
name|int
name|sys_errno
decl_stmt|;
block|{
name|char
modifier|*
name|text
decl_stmt|;
name|unsigned
name|indent
decl_stmt|;
name|text
operator|=
name|catgets
argument_list|(
name|catd
argument_list|,
name|CAT_SET
argument_list|,
name|error_number
argument_list|,
operator|(
name|char
operator|*
operator|)
name|catalog_error_text
argument_list|(
name|error_number
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXX */
name|assert
argument_list|(
name|text
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|prog
argument_list|)
expr_stmt|;
name|indent
operator|=
name|strlen
argument_list|(
name|prog
argument_list|)
operator|+
literal|2
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|CATALOG_SYSTEM_ERROR
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|text
argument_list|,
name|filename
argument_list|,
name|strerror
argument_list|(
name|sys_errno
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|unsigned
name|i
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|catgets
argument_list|(
name|catd
argument_list|,
name|APP_SET
argument_list|,
name|CATALOG_ERROR_HEADER_MSGNO
argument_list|,
name|CATALOG_ERROR_HEADER_TEXT
argument_list|)
argument_list|,
name|filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|":\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|indent
condition|;
name|i
operator|++
control|)
name|putc
argument_list|(
literal|' '
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|text
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Local Variables: c-indent-level: 5 c-continued-statement-offset: 5 c-brace-offset: -5 c-argdecl-indent: 0 c-label-offset: -5 comment-column: 30 End: */
end_comment

end_unit

