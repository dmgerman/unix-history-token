begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"sgmlincl.h"
end_include

begin_comment
comment|/* #INCLUDE statements for SGML parser. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TRACE
end_ifdef

begin_include
include|#
directive|include
file|"context.h"
end_include

begin_comment
comment|/* Token status: RCHIT RCMISS RCEND RCREQ RCNREQ */
end_comment

begin_define
define|#
directive|define
name|STATUX
value|tags[ts].status
end_define

begin_comment
comment|/* Trace variables. */
end_comment

begin_decl_stmt
name|int
name|trace
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Switch: 1=trace state transitions; 0=don't. */
end_comment

begin_decl_stmt
name|int
name|atrace
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Switch: 1=trace attribute activity; 0=don't. */
end_comment

begin_decl_stmt
name|int
name|ctrace
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Switch: 1=trace context checking; 0=don't. */
end_comment

begin_decl_stmt
name|int
name|dtrace
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Switch: 1=trace declaration parsing; 0=don't.*/
end_comment

begin_decl_stmt
name|int
name|etrace
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Switch: 1=trace entity activity; 0=don't.*/
end_comment

begin_decl_stmt
name|int
name|gtrace
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Switch: 1=trace group creations; 0=don't. */
end_comment

begin_decl_stmt
name|int
name|itrace
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Switch: 1=trace ID activity; 0=don't. */
end_comment

begin_decl_stmt
name|int
name|mtrace
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Switch: 1=trace MS activity; 0=don't. */
end_comment

begin_decl_stmt
name|int
name|ntrace
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Switch: 1=trace notation activity; 0=don't. */
end_comment

begin_decl_stmt
name|char
name|emd
index|[]
init|=
literal|"EMD"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For "EMD" parameter type in dtrace calls. */
end_comment

begin_comment
comment|/* Return a printable representation of c. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|printable
parameter_list|(
name|c
parameter_list|)
name|int
name|c
decl_stmt|;
block|{
specifier|static
name|char
name|buf
index|[
literal|5
index|]
decl_stmt|;
if|if
condition|(
name|c
operator|>=
literal|040
operator|&&
name|c
operator|<
literal|0177
condition|)
block|{
name|buf
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"\\%03o"
argument_list|,
operator|(
name|UNCH
operator|)
name|c
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_function
specifier|static
name|VOID
name|dotrace
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|trace
operator|=
operator|(
name|s
operator|&&
name|strchr
argument_list|(
name|s
argument_list|,
literal|'t'
argument_list|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|atrace
operator|=
operator|(
name|s
operator|&&
name|strchr
argument_list|(
name|s
argument_list|,
literal|'a'
argument_list|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|ctrace
operator|=
operator|(
name|s
operator|&&
name|strchr
argument_list|(
name|s
argument_list|,
literal|'c'
argument_list|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|dtrace
operator|=
operator|(
name|s
operator|&&
name|strchr
argument_list|(
name|s
argument_list|,
literal|'d'
argument_list|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|etrace
operator|=
operator|(
name|s
operator|&&
name|strchr
argument_list|(
name|s
argument_list|,
literal|'e'
argument_list|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|gtrace
operator|=
operator|(
name|s
operator|&&
name|strchr
argument_list|(
name|s
argument_list|,
literal|'g'
argument_list|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|itrace
operator|=
operator|(
name|s
operator|&&
name|strchr
argument_list|(
name|s
argument_list|,
literal|'i'
argument_list|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|mtrace
operator|=
operator|(
name|s
operator|&&
name|strchr
argument_list|(
name|s
argument_list|,
literal|'m'
argument_list|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|ntrace
operator|=
operator|(
name|s
operator|&&
name|strchr
argument_list|(
name|s
argument_list|,
literal|'n'
argument_list|)
operator|!=
literal|0
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* TRACESET: Set switches for tracing body of document. */
end_comment

begin_function
name|VOID
name|traceset
parameter_list|()
block|{
name|dotrace
argument_list|(
name|sw
operator|.
name|trace
argument_list|)
expr_stmt|;
if|if
condition|(
name|trace
operator|||
name|atrace
operator|||
name|ctrace
operator|||
name|dtrace
operator|||
name|etrace
operator|||
name|gtrace
operator|||
name|itrace
operator|||
name|mtrace
operator|||
name|ntrace
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"TRACESET: state=%d;att=%d;con=%d;dcl=%d;ent=%d;grp=%d;id=%d;ms=%d;dcn=%d.\n"
argument_list|,
name|trace
argument_list|,
name|atrace
argument_list|,
name|ctrace
argument_list|,
name|dtrace
argument_list|,
name|etrace
argument_list|,
name|gtrace
argument_list|,
name|itrace
argument_list|,
name|mtrace
argument_list|,
name|ntrace
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* TRACEPRO: Set switches for tracing prolog.  */
end_comment

begin_function
name|VOID
name|tracepro
parameter_list|()
block|{
name|dotrace
argument_list|(
name|sw
operator|.
name|ptrace
argument_list|)
expr_stmt|;
if|if
condition|(
name|trace
operator|||
name|atrace
operator|||
name|dtrace
operator|||
name|etrace
operator|||
name|gtrace
operator|||
name|mtrace
operator|||
name|ntrace
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"TRACEPRO: state=%d; att=%d; dcl=%d; ent=%d; grp=%d; ms=%d; dcn=%d.\n"
argument_list|,
name|trace
argument_list|,
name|atrace
argument_list|,
name|dtrace
argument_list|,
name|etrace
argument_list|,
name|gtrace
argument_list|,
name|mtrace
argument_list|,
name|ntrace
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* TRACEPCB: Trace character just parsed and other pcb data.  */
end_comment

begin_function
name|VOID
name|tracepcb
parameter_list|(
name|pcb
parameter_list|)
name|struct
name|parse
modifier|*
name|pcb
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%-8s %2u-%2u-%2u-%2u from %s [%3d] in %s, %lu:%d.\n"
argument_list|,
name|pcb
operator|->
name|pname
argument_list|,
name|pcb
operator|->
name|state
argument_list|,
name|pcb
operator|->
name|input
argument_list|,
name|pcb
operator|->
name|action
argument_list|,
name|pcb
operator|->
name|newstate
argument_list|,
name|printable
argument_list|(
operator|*
name|FPOS
argument_list|)
argument_list|,
operator|*
name|FPOS
argument_list|,
name|ENTITY
operator|+
literal|1
argument_list|,
name|RCNT
argument_list|,
name|RSCC
operator|+
name|FPOS
operator|+
literal|1
operator|-
name|FBUF
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* TRACETKN: Trace character just read during token parse.  */
end_comment

begin_function
name|VOID
name|tracetkn
parameter_list|(
name|scope
parameter_list|,
name|lextoke
parameter_list|)
name|int
name|scope
decl_stmt|;
name|UNCH
name|lextoke
index|[]
decl_stmt|;
comment|/* Lexical table for token and name parses. */
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"TOKEN    %2d-%2d       from %s [%3d] in %s, %lu:%d.\n"
argument_list|,
name|scope
argument_list|,
name|lextoke
index|[
operator|*
name|FPOS
index|]
argument_list|,
name|printable
argument_list|(
operator|*
name|FPOS
argument_list|)
argument_list|,
operator|*
name|FPOS
argument_list|,
name|ENTITY
operator|+
literal|1
argument_list|,
name|RCNT
argument_list|,
name|RSCC
operator|+
name|FPOS
operator|+
literal|1
operator|-
name|FBUF
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* TRACEGML: Trace state of main SGML driver routine.  */
end_comment

begin_function
name|VOID
name|tracegml
parameter_list|(
name|scb
parameter_list|,
name|pss
parameter_list|,
name|conactsw
parameter_list|,
name|conact
parameter_list|)
name|struct
name|restate
modifier|*
name|scb
decl_stmt|;
name|int
name|pss
decl_stmt|,
name|conactsw
decl_stmt|,
name|conact
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"SGML%02d   %2d-%2d-%2d-%2d in main driver; conactsw=%d; conact=%d.\n"
argument_list|,
name|pss
argument_list|,
name|scb
index|[
name|pss
index|]
operator|.
name|sstate
argument_list|,
name|scb
index|[
name|pss
index|]
operator|.
name|sinput
argument_list|,
name|scb
index|[
name|pss
index|]
operator|.
name|saction
argument_list|,
name|scb
index|[
name|pss
index|]
operator|.
name|snext
argument_list|,
name|conactsw
argument_list|,
name|conact
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* TRACEVAL: Trace parse of an attribute value that is a token list.  */
end_comment

begin_function
name|VOID
name|traceval
parameter_list|(
name|pcb
parameter_list|,
name|atype
parameter_list|,
name|aval
parameter_list|,
name|tokencnt
parameter_list|)
name|struct
name|parse
modifier|*
name|pcb
decl_stmt|;
name|UNS
name|atype
decl_stmt|;
comment|/* Type of token list expected. */
name|UNCH
modifier|*
name|aval
decl_stmt|;
comment|/* Value string to be parsed as token list. */
name|int
name|tokencnt
decl_stmt|;
comment|/* Number of tokens found in attribute value. */
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%-8s %2d-%2d-%2d-%2d at %p, atype=%02x, tokencnt=%d: "
argument_list|,
name|pcb
operator|->
name|pname
argument_list|,
name|pcb
operator|->
name|state
argument_list|,
name|pcb
operator|->
name|input
argument_list|,
name|pcb
operator|->
name|action
argument_list|,
name|pcb
operator|->
name|newstate
argument_list|,
operator|(
name|UNIV
operator|)
name|aval
argument_list|,
name|atype
argument_list|,
name|tokencnt
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|aval
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* TRACESTK: Trace entry just placed on tag stack.  */
end_comment

begin_function
name|VOID
name|tracestk
parameter_list|(
name|pts
parameter_list|,
name|ts2
parameter_list|,
name|etictr
parameter_list|)
name|struct
name|tag
modifier|*
name|pts
decl_stmt|;
comment|/* Stack entry for this tag. */
name|int
name|ts2
decl_stmt|;
comment|/* Stack depth. */
name|int
name|etictr
decl_stmt|;
comment|/* Number of "netok" tags on stack. */
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"STACK    %s begun; stack depth %d; tflag=%02x; etictr=%d"
argument_list|,
name|pts
operator|->
name|tetd
operator|->
name|etdgi
operator|+
literal|1
argument_list|,
name|ts2
argument_list|,
name|pts
operator|->
name|tflags
argument_list|,
name|etictr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" srm=%s.\n"
argument_list|,
name|pts
operator|->
name|tsrm
operator|!=
name|SRMNULL
condition|?
operator|(
name|char
operator|*
operator|)
operator|(
name|pts
operator|->
name|tsrm
index|[
literal|0
index|]
operator|->
name|ename
operator|+
literal|1
operator|)
else|:
literal|"#EMPTY"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* TRACEDSK: Trace entry just removed from tag stack.  */
end_comment

begin_function
name|VOID
name|tracedsk
parameter_list|(
name|pts
parameter_list|,
name|ptso
parameter_list|,
name|ts3
parameter_list|,
name|etictr
parameter_list|)
name|struct
name|tag
modifier|*
name|pts
decl_stmt|;
comment|/* Stack entry for new open tag. */
name|struct
name|tag
modifier|*
name|ptso
decl_stmt|;
comment|/* Stack entry for tag just ended. */
name|int
name|ts3
decl_stmt|;
comment|/* Stack depth. */
name|int
name|etictr
decl_stmt|;
comment|/* Number of "netok" tags on stack. */
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"DESTACK  %s ended; otflag=%02x; %s resumed; depth=%d; tflag=%02x; etictr=%d"
argument_list|,
name|ptso
operator|->
name|tetd
operator|->
name|etdgi
operator|+
literal|1
argument_list|,
name|ptso
operator|->
name|tflags
argument_list|,
name|pts
operator|->
name|tetd
operator|->
name|etdgi
operator|+
literal|1
argument_list|,
name|ts3
argument_list|,
name|pts
operator|->
name|tflags
argument_list|,
name|etictr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" srm=%s.\n"
argument_list|,
name|pts
operator|->
name|tsrm
operator|!=
name|SRMNULL
condition|?
operator|(
name|char
operator|*
operator|)
operator|(
name|pts
operator|->
name|tsrm
index|[
literal|0
index|]
operator|->
name|ename
operator|+
literal|1
operator|)
else|:
literal|"#EMPTY"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* TRACECON: Trace interactions between content parse and stag/context    processing.    */
end_comment

begin_function
name|VOID
name|tracecon
parameter_list|(
name|etagimct
parameter_list|,
name|dostag
parameter_list|,
name|datarc
parameter_list|,
name|pcb
parameter_list|,
name|conrefsw
parameter_list|,
name|didreq
parameter_list|)
name|int
name|etagimct
decl_stmt|;
comment|/* Implicitly ended elements left on stack. */
name|int
name|dostag
decl_stmt|;
comment|/* 1=retry newetd instead of parsing; 0=parse. */
name|int
name|datarc
decl_stmt|;
comment|/* Return code for data: DAF_ or REF_ or zero. */
name|struct
name|parse
modifier|*
name|pcb
decl_stmt|;
comment|/* Parse control block for this parse. */
name|int
name|conrefsw
decl_stmt|;
comment|/* 1=content reference att specified; 0=no. */
name|int
name|didreq
decl_stmt|;
comment|/* 1=required implied empty tag processed; 0=no.*/
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"CONTENT  etagimct=%d dostag=%d datarc=%d pname=%s action=%d \ conrefsw=%d didreq=%d\n"
argument_list|,
name|etagimct
argument_list|,
name|dostag
argument_list|,
name|datarc
argument_list|,
name|pcb
operator|->
name|pname
argument_list|,
name|pcb
operator|->
name|action
argument_list|,
name|conrefsw
argument_list|,
name|didreq
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* TRACESTG: Trace start-tag context validation input and results.  */
end_comment

begin_function
name|VOID
name|tracestg
parameter_list|(
name|curetd
parameter_list|,
name|dataret
parameter_list|,
name|rc
parameter_list|,
name|nextetd
parameter_list|,
name|mexts
parameter_list|)
name|struct
name|etd
modifier|*
name|curetd
decl_stmt|;
comment|/* The etd for this tag. */
name|int
name|dataret
decl_stmt|;
comment|/* Data pending: DAF_ REF_ 0=not #PCDATA. */
name|int
name|rc
decl_stmt|;
comment|/* Return code from context or other test. */
name|struct
name|etd
modifier|*
name|nextetd
decl_stmt|;
comment|/* The etd for a forced start-tag (if rc==2). */
name|int
name|mexts
decl_stmt|;
comment|/*>0=stack level of minus grp; -1=plus; 0=none.*/
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"STARTTAG newetd=%p; dataret=%d; rc=%d; nextetd=%p; mexts=%d.\n"
argument_list|,
operator|(
name|UNIV
operator|)
name|curetd
argument_list|,
name|dataret
argument_list|,
name|rc
argument_list|,
operator|(
name|UNIV
operator|)
name|nextetd
argument_list|,
name|mexts
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* TRACEETG: Trace end-tag matching test on stack.  */
end_comment

begin_function
name|VOID
name|traceetg
parameter_list|(
name|pts
parameter_list|,
name|curetd
parameter_list|,
name|tsl
parameter_list|,
name|etagimct
parameter_list|)
name|struct
name|tag
modifier|*
name|pts
decl_stmt|;
comment|/* Stack entry for this tag. */
name|struct
name|etd
modifier|*
name|curetd
decl_stmt|;
comment|/* The etd for this tag. */
name|int
name|tsl
decl_stmt|;
comment|/* Temporary stack level for looping. */
name|int
name|etagimct
decl_stmt|;
comment|/* Num of implicitly ended tags left on stack. */
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ENDTAG   tsl=%d; newetd=%p; stacketd=%p; tflags=%02x; etagimct=%d.\n"
argument_list|,
name|tsl
argument_list|,
operator|(
name|UNIV
operator|)
name|curetd
argument_list|,
operator|(
name|UNIV
operator|)
name|pts
operator|->
name|tetd
argument_list|,
name|pts
operator|->
name|tflags
argument_list|,
name|etagimct
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* TRACEECB: Trace entity control block activity.  */
end_comment

begin_function
name|VOID
name|traceecb
parameter_list|(
name|action
parameter_list|,
name|p
parameter_list|)
name|char
modifier|*
name|action
decl_stmt|;
name|struct
name|entity
modifier|*
name|p
decl_stmt|;
block|{
specifier|static
name|char
name|estype1
index|[]
init|=
literal|" TMMMSEIXCNFPDLK"
decl_stmt|;
specifier|static
name|char
name|estype2
index|[]
init|=
literal|"  DS            "
decl_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
return|return;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%-8s (es=%d) type %c%c entity %s at %p containing "
argument_list|,
name|action
argument_list|,
name|es
argument_list|,
name|estype1
index|[
name|p
operator|->
name|estore
index|]
argument_list|,
name|estype2
index|[
name|p
operator|->
name|estore
index|]
argument_list|,
name|p
operator|->
name|ename
operator|+
literal|1
argument_list|,
operator|(
name|UNIV
operator|)
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|estore
operator|==
name|ESN
operator|&&
name|strcmp
argument_list|(
name|action
argument_list|,
literal|"ENTDEF"
argument_list|)
condition|)
name|traceesn
argument_list|(
name|p
operator|->
name|etx
operator|.
name|n
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|->
name|etx
operator|.
name|x
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"[NOTHING]"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s"
argument_list|,
name|p
operator|->
name|etx
operator|.
name|c
index|[
literal|0
index|]
condition|?
operator|(
name|char
operator|*
operator|)
name|p
operator|->
name|etx
operator|.
name|c
else|:
literal|"[EMPTY]"
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* TRACEDCN: Trace data content notation activity.  */
end_comment

begin_function
name|VOID
name|tracedcn
parameter_list|(
name|p
parameter_list|)
name|struct
name|dcncb
modifier|*
name|p
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"DCN      dcn=%p; adl=%p; notation is %s\n"
argument_list|,
operator|(
name|UNIV
operator|)
name|p
argument_list|,
operator|(
name|UNIV
operator|)
name|p
operator|->
name|adl
argument_list|,
name|p
operator|->
name|ename
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|adl
condition|)
name|traceadl
argument_list|(
name|p
operator|->
name|adl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* TRACEESN: Print a data entity control block.  */
end_comment

begin_function
name|VOID
name|traceesn
parameter_list|(
name|p
parameter_list|)
name|PNE
name|p
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ESN      Entity name is %s; entity type is %s.\n"
argument_list|,
operator|(
name|NEENAME
argument_list|(
name|p
argument_list|)
operator|!=
literal|0
operator|)
condition|?
operator|(
operator|(
name|char
operator|*
operator|)
name|NEENAME
argument_list|(
name|p
argument_list|)
operator|)
operator|+
literal|1
else|:
literal|"[UNDEFINED]"
argument_list|,
comment|/* NEXTYPE(p)); */
operator|(
name|NEXTYPE
argument_list|(
name|p
argument_list|)
operator|==
literal|1
condition|?
literal|"CDATA"
else|:
operator|(
name|NEXTYPE
argument_list|(
name|p
argument_list|)
operator|==
literal|2
condition|?
literal|"NDATA"
else|:
literal|"SDATA"
operator|)
operator|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"         System ID is %s\n"
argument_list|,
operator|(
name|NEID
argument_list|(
name|p
argument_list|)
operator|!=
literal|0
operator|)
condition|?
operator|(
name|char
operator|*
operator|)
name|NEID
argument_list|(
name|p
argument_list|)
else|:
literal|"[UNDEFINED]"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|nedcn
operator|!=
literal|0
condition|)
name|tracedcn
argument_list|(
name|p
operator|->
name|nedcn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* TRACESRM: Print the members of a short reference map.  */
end_comment

begin_function
name|VOID
name|tracesrm
parameter_list|(
name|action
parameter_list|,
name|pg
parameter_list|,
name|gi
parameter_list|)
name|char
modifier|*
name|action
decl_stmt|;
name|TECB
name|pg
decl_stmt|;
name|UNCH
modifier|*
name|gi
decl_stmt|;
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
comment|/* Loop counter. */
if|if
condition|(
name|pg
operator|==
name|SRMNULL
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%-8s SHORTREF table empty for %s.\n"
argument_list|,
name|action
argument_list|,
name|gi
argument_list|)
expr_stmt|;
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%-8s %s at %p mapped for %s.\n"
argument_list|,
name|action
argument_list|,
name|pg
index|[
literal|0
index|]
operator|->
name|ename
operator|+
literal|1
argument_list|,
operator|(
name|UNIV
operator|)
name|pg
argument_list|,
name|gi
condition|?
operator|(
name|char
operator|*
operator|)
name|gi
else|:
literal|"definition"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|++
name|i
operator|<=
name|lex
operator|.
name|s
operator|.
name|dtb
index|[
literal|0
index|]
operator|.
name|mapdata
condition|)
if|if
condition|(
name|pg
index|[
name|i
index|]
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%14s%02u %p %s\n"
argument_list|,
literal|"SR"
argument_list|,
name|i
argument_list|,
operator|(
name|UNIV
operator|)
name|pg
index|[
name|i
index|]
argument_list|,
name|pg
index|[
name|i
index|]
operator|->
name|ename
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* TRACEADL: Print an attribute definition list.  */
end_comment

begin_function
name|VOID
name|traceadl
parameter_list|(
name|al
parameter_list|)
name|struct
name|ad
name|al
index|[]
decl_stmt|;
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ADLIST   %p %d membe%s; %d attribut%s\n"
argument_list|,
operator|(
name|UNIV
operator|)
name|al
argument_list|,
name|ADN
argument_list|(
name|al
argument_list|)
argument_list|,
name|ADN
argument_list|(
name|al
argument_list|)
operator|==
literal|1
condition|?
literal|"r"
else|:
literal|"rs"
argument_list|,
name|AN
argument_list|(
name|al
argument_list|)
argument_list|,
name|AN
argument_list|(
name|al
argument_list|)
operator|==
literal|1
condition|?
literal|"e"
else|:
literal|"es"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|++
name|i
operator|<=
name|ADN
argument_list|(
name|al
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
operator|(
name|BITOFF
argument_list|(
name|ADFLAGS
argument_list|(
name|al
argument_list|,
name|i
argument_list|)
argument_list|,
name|AGROUP
argument_list|)
operator|&&
name|ADTYPE
argument_list|(
name|al
argument_list|,
name|i
argument_list|)
operator|<=
name|ANOTEGRP
operator|)
condition|?
literal|"          %p %-8s %02x %02x %2d %2d %p %p\n"
else|:
literal|"    %p %-8s %02x %02x %2d %2d %p %p\n"
argument_list|,
operator|&
name|al
index|[
name|i
index|]
argument_list|,
name|ADNAME
argument_list|(
name|al
argument_list|,
name|i
argument_list|)
argument_list|,
name|ADFLAGS
argument_list|(
name|al
argument_list|,
name|i
argument_list|)
argument_list|,
name|ADTYPE
argument_list|(
name|al
argument_list|,
name|i
argument_list|)
argument_list|,
name|ADNUM
argument_list|(
name|al
argument_list|,
name|i
argument_list|)
argument_list|,
name|ADLEN
argument_list|(
name|al
argument_list|,
name|i
argument_list|)
argument_list|,
name|ADVAL
argument_list|(
name|al
argument_list|,
name|i
argument_list|)
argument_list|,
name|ADDATA
argument_list|(
name|al
argument_list|,
name|i
argument_list|)
operator|.
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|ADVAL
argument_list|(
name|al
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s"
argument_list|,
name|ADVAL
argument_list|(
name|al
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ADTYPE
argument_list|(
name|al
argument_list|,
name|i
argument_list|)
operator|==
name|AENTITY
operator|&&
name|ADDATA
argument_list|(
name|al
argument_list|,
name|i
argument_list|)
operator|.
name|n
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"=>"
argument_list|)
expr_stmt|;
name|traceesn
argument_list|(
name|ADDATA
argument_list|(
name|al
argument_list|,
name|i
argument_list|)
operator|.
name|n
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ADTYPE
argument_list|(
name|al
argument_list|,
name|i
argument_list|)
operator|==
name|ANOTEGRP
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"=>"
argument_list|)
expr_stmt|;
name|tracedcn
argument_list|(
name|ADDATA
argument_list|(
name|al
argument_list|,
name|i
argument_list|)
operator|.
name|x
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"[%s]"
argument_list|,
name|GET
argument_list|(
name|ADFLAGS
argument_list|(
name|al
argument_list|,
name|i
argument_list|)
argument_list|,
name|AREQ
argument_list|)
condition|?
literal|"REQUIRED"
else|:
operator|(
name|GET
argument_list|(
name|ADFLAGS
argument_list|(
name|al
argument_list|,
name|i
argument_list|)
argument_list|,
name|ACURRENT
argument_list|)
condition|?
literal|"CURRENT"
else|:
literal|"NULL"
operator|)
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* TRACEMOD: Print the members of a model.  */
end_comment

begin_function
name|VOID
name|tracemod
parameter_list|(
name|pg
parameter_list|)
name|struct
name|thdr
name|pg
index|[]
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"MODEL    %p %02x %d\n"
argument_list|,
operator|(
name|UNIV
operator|)
operator|&
name|pg
index|[
literal|0
index|]
argument_list|,
name|pg
index|[
literal|0
index|]
operator|.
name|ttype
argument_list|,
name|pg
index|[
literal|0
index|]
operator|.
name|tu
operator|.
name|tnum
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pg
index|[
literal|0
index|]
operator|.
name|ttype
operator|&
name|MKEYWORD
operator|)
operator|==
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|pg
index|[
literal|0
index|]
operator|.
name|tu
operator|.
name|tnum
operator|+
literal|2
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|GET
argument_list|(
name|pg
index|[
name|i
index|]
operator|.
name|ttype
argument_list|,
name|TTMASK
argument_list|)
operator|==
name|TTETD
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"                      %p %02x %s\n"
argument_list|,
operator|(
name|UNIV
operator|)
operator|&
name|pg
index|[
name|i
index|]
argument_list|,
name|pg
index|[
name|i
index|]
operator|.
name|ttype
argument_list|,
name|pg
index|[
name|i
index|]
operator|.
name|tu
operator|.
name|thetd
operator|->
name|etdgi
operator|+
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET
argument_list|(
name|pg
index|[
name|i
index|]
operator|.
name|ttype
argument_list|,
name|TTMASK
argument_list|)
operator|==
name|TTCHARS
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"                      %p %02x %s\n"
argument_list|,
operator|(
name|UNIV
operator|)
operator|&
name|pg
index|[
name|i
index|]
argument_list|,
name|pg
index|[
name|i
index|]
operator|.
name|ttype
argument_list|,
literal|"#PCDATA"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"         %p %02x %d\n"
argument_list|,
operator|(
name|UNIV
operator|)
operator|&
name|pg
index|[
name|i
index|]
argument_list|,
name|pg
index|[
name|i
index|]
operator|.
name|ttype
argument_list|,
name|pg
index|[
name|i
index|]
operator|.
name|tu
operator|.
name|tnum
argument_list|)
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* TRACEGRP: Print the members of a name (i.e., etd) group.  */
end_comment

begin_function
name|VOID
name|tracegrp
parameter_list|(
name|pg
parameter_list|)
name|struct
name|etd
modifier|*
name|pg
index|[]
decl_stmt|;
block|{
name|int
name|i
init|=
operator|-
literal|1
decl_stmt|;
comment|/* Loop counter. */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ETDGRP   %p\n"
argument_list|,
operator|(
name|UNIV
operator|)
name|pg
argument_list|)
expr_stmt|;
while|while
condition|(
name|pg
index|[
operator|++
name|i
index|]
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"         %p %s\n"
argument_list|,
operator|(
name|UNIV
operator|)
name|pg
index|[
name|i
index|]
argument_list|,
name|pg
index|[
name|i
index|]
operator|->
name|etdgi
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* TRACENGR: Print the members of a notation (i.e., dcncb) group.  */
end_comment

begin_function
name|VOID
name|tracengr
parameter_list|(
name|pg
parameter_list|)
name|struct
name|dcncb
modifier|*
name|pg
index|[]
decl_stmt|;
block|{
name|int
name|i
init|=
operator|-
literal|1
decl_stmt|;
comment|/* Loop counter. */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"DCNGRP   %p\n"
argument_list|,
operator|(
name|UNIV
operator|)
name|pg
argument_list|)
expr_stmt|;
while|while
condition|(
name|pg
index|[
operator|++
name|i
index|]
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"         %p %s\n"
argument_list|,
operator|(
name|UNIV
operator|)
name|pg
index|[
name|i
index|]
argument_list|,
name|pg
index|[
name|i
index|]
operator|->
name|ename
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* TRACEETD: Print an element type definition.  */
end_comment

begin_function
name|VOID
name|traceetd
parameter_list|(
name|p
parameter_list|)
name|struct
name|etd
modifier|*
name|p
decl_stmt|;
comment|/* Pointer to an etd. */
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ETD      etd=%p %s min=%02x cmod=%p ttype=%02x mex=%p, pex=%p, "
argument_list|,
operator|(
name|UNIV
operator|)
name|p
argument_list|,
name|p
operator|->
name|etdgi
operator|+
literal|1
argument_list|,
name|p
operator|->
name|etdmin
argument_list|,
operator|(
name|UNIV
operator|)
name|p
operator|->
name|etdmod
argument_list|,
name|p
operator|->
name|etdmod
operator|->
name|ttype
argument_list|,
operator|(
name|UNIV
operator|)
name|p
operator|->
name|etdmex
argument_list|,
operator|(
name|UNIV
operator|)
name|p
operator|->
name|etdpex
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"adl=%p, srm=%s.\n"
argument_list|,
operator|(
name|UNIV
operator|)
name|p
operator|->
name|adl
argument_list|,
operator|(
name|p
operator|->
name|etdsrm
operator|==
name|SRMNULL
operator|)
condition|?
literal|"#EMPTY"
else|:
operator|(
name|p
operator|->
name|etdsrm
operator|)
condition|?
operator|(
name|char
operator|*
operator|)
operator|(
name|p
operator|->
name|etdsrm
index|[
literal|0
index|]
operator|->
name|ename
operator|+
literal|1
operator|)
else|:
literal|"#CURRENT"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* TRACEID: Print an ID control block.  */
end_comment

begin_function
name|VOID
name|traceid
parameter_list|(
name|action
parameter_list|,
name|p
parameter_list|)
name|char
modifier|*
name|action
decl_stmt|;
name|struct
name|id
modifier|*
name|p
decl_stmt|;
comment|/* Pointer to an ID. */
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%-8s %s at %p is %s; "
argument_list|,
name|action
argument_list|,
name|p
operator|->
name|idname
operator|+
literal|1
argument_list|,
operator|(
name|UNIV
operator|)
name|p
argument_list|,
name|p
operator|->
name|iddefed
condition|?
literal|"defined"
else|:
literal|"undefined"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"last ref=%p\n"
argument_list|,
operator|(
name|UNIV
operator|)
name|p
operator|->
name|idrl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* TRACEMD: Trace a markup declaration parameter.  */
end_comment

begin_function
name|VOID
name|tracemd
parameter_list|(
name|parmid
parameter_list|)
name|char
modifier|*
name|parmid
decl_stmt|;
comment|/* Parameter identifier. */
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"MDPARM   %-8s for %-8s, token %02d, type %02u, %s.\n"
argument_list|,
name|mdname
argument_list|,
name|subdcl
condition|?
operator|(
name|char
operator|*
operator|)
name|subdcl
else|:
literal|"[NONE]"
argument_list|,
name|parmno
argument_list|,
name|pcbmd
operator|.
name|action
argument_list|,
name|parmid
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* TRACEMS: Trace marked section activity.  */
end_comment

begin_function
name|VOID
name|tracems
parameter_list|(
name|action
parameter_list|,
name|code
parameter_list|,
name|mslevel
parameter_list|,
name|msplevel
parameter_list|)
name|int
name|action
decl_stmt|;
comment|/* 1=began new level; 0=resumed previous. */
name|int
name|code
decl_stmt|;
name|int
name|mslevel
decl_stmt|;
comment|/* Nesting level of marked sections. */
name|int
name|msplevel
decl_stmt|;
comment|/* Nested MS levels subject to special parse. */
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"MS%c      %2d                 %s nesting level %d (msp %d).\n"
argument_list|,
operator|(
name|action
condition|?
literal|' '
else|:
literal|'E'
operator|)
argument_list|,
name|code
argument_list|,
operator|(
name|action
condition|?
literal|"began"
else|:
literal|"resumed"
operator|)
argument_list|,
name|mslevel
argument_list|,
name|msplevel
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|VOID
name|tracehits
parameter_list|(
name|h
parameter_list|)
name|unsigned
name|long
modifier|*
name|h
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" H="
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|grplongs
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%0*lx"
argument_list|,
name|LONGBITS
operator|/
literal|4
argument_list|,
name|h
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* TRACEGI: Trace GI testing stages in CONTEXT.C processing.  */
end_comment

begin_function
name|VOID
name|tracegi
parameter_list|(
name|stagenm
parameter_list|,
name|gi
parameter_list|,
name|mod
parameter_list|,
name|pos
parameter_list|)
name|char
modifier|*
name|stagenm
decl_stmt|;
name|struct
name|etd
modifier|*
name|gi
decl_stmt|;
comment|/* ETD of new GI. */
name|struct
name|thdr
name|mod
index|[]
decl_stmt|;
comment|/* Model of current open element. */
name|struct
name|mpos
name|pos
index|[]
decl_stmt|;
comment|/* Position in open element's model. */
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
comment|/* Loop counter. */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%-10s %d:"
argument_list|,
name|stagenm
argument_list|,
name|P
argument_list|)
expr_stmt|;
while|while
condition|(
operator|++
name|i
operator|<=
name|P
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %d-%d"
argument_list|,
name|pos
index|[
name|i
index|]
operator|.
name|g
argument_list|,
name|pos
index|[
name|i
index|]
operator|.
name|t
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" (%u) gocc=%02x gtype=%02x gnum=%d"
argument_list|,
name|M
argument_list|,
name|GOCC
argument_list|,
name|GTYPE
argument_list|,
name|GNUM
argument_list|)
expr_stmt|;
name|tracehits
argument_list|(
name|H
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" status=%d Tstart=%d\n"
argument_list|,
name|STATUX
argument_list|,
name|Tstart
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"=>%-8s tocc=%02x ttype=%02x thetd=%p (%s) gietd=%p (%s)\n"
argument_list|,
name|tags
index|[
name|ts
index|]
operator|.
name|tetd
operator|->
name|etdgi
operator|+
literal|1
argument_list|,
name|TOCC
argument_list|,
name|TTYPE
argument_list|,
operator|(
name|UNIV
operator|)
name|TOKEN
operator|.
name|tu
operator|.
name|thetd
argument_list|,
operator|(
name|TTYPE
condition|?
operator|(
name|TTYPE
operator|==
name|TTETD
condition|?
operator|(
name|char
operator|*
operator|)
operator|(
name|TOKEN
operator|.
name|tu
operator|.
name|thetd
operator|->
name|etdgi
operator|+
literal|1
operator|)
else|:
literal|"#GROUP"
operator|)
else|:
literal|"#PCDATA"
operator|)
argument_list|,
operator|(
name|UNIV
operator|)
name|gi
argument_list|,
operator|(
name|gi
operator|==
name|ETDCDATA
condition|?
literal|"#PCDATA"
else|:
operator|(
name|char
operator|*
operator|)
operator|(
name|gi
operator|->
name|etdgi
operator|+
literal|1
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* TRACEEND: Trace testing for end of group in CONTEXT.C processing.  */
end_comment

begin_function
name|VOID
name|traceend
parameter_list|(
name|stagenm
parameter_list|,
name|mod
parameter_list|,
name|pos
parameter_list|,
name|rc
parameter_list|,
name|opt
parameter_list|)
name|char
modifier|*
name|stagenm
decl_stmt|;
name|struct
name|thdr
name|mod
index|[]
decl_stmt|;
comment|/* Model of current open element. */
name|struct
name|mpos
name|pos
index|[]
decl_stmt|;
comment|/* Position in open element's model. */
name|int
name|rc
decl_stmt|;
comment|/* Return code: RCNREQ RCHIT RCMISS RCEND */
name|int
name|opt
decl_stmt|;
comment|/* ALLHIT parm: 1=test optionals; 0=ignore. */
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
comment|/* Loop counter. */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%-10s %d:"
argument_list|,
name|stagenm
argument_list|,
name|P
argument_list|)
expr_stmt|;
while|while
condition|(
operator|++
name|i
operator|<=
name|P
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %d-%d"
argument_list|,
name|pos
index|[
name|i
index|]
operator|.
name|g
argument_list|,
name|pos
index|[
name|i
index|]
operator|.
name|t
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" (%u) gocc=%02x gtype=%02x gnum=%d"
argument_list|,
name|M
argument_list|,
name|GOCC
argument_list|,
name|GTYPE
argument_list|,
name|GNUM
argument_list|)
expr_stmt|;
name|tracehits
argument_list|(
name|H
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" status=%d Tstart=%d\n"
argument_list|,
name|STATUX
argument_list|,
name|Tstart
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"=>%-8s tocc=%02x ttype=%02x thetd=%p (%s)"
argument_list|,
name|tags
index|[
name|ts
index|]
operator|.
name|tetd
operator|->
name|etdgi
operator|+
literal|1
argument_list|,
name|TOCC
argument_list|,
name|TTYPE
argument_list|,
operator|(
name|UNIV
operator|)
name|TOKEN
operator|.
name|tu
operator|.
name|thetd
argument_list|,
operator|(
name|TTYPE
condition|?
operator|(
name|TTYPE
operator|==
name|TTETD
condition|?
operator|(
name|char
operator|*
operator|)
operator|(
name|TOKEN
operator|.
name|tu
operator|.
name|thetd
operator|->
name|etdgi
operator|+
literal|1
operator|)
else|:
literal|"#GROUP"
operator|)
else|:
literal|"#PCDATA"
operator|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" rc=%d offbitT=%d allhit=%d\n"
argument_list|,
name|rc
argument_list|,
name|offbit
argument_list|(
name|H
argument_list|,
operator|(
name|int
operator|)
name|T
argument_list|,
name|GNUM
argument_list|)
argument_list|,
name|allhit
argument_list|(
operator|&
name|GHDR
argument_list|,
name|H
argument_list|,
literal|0
argument_list|,
name|opt
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TRACE */
end_comment

begin_comment
comment|/* Local Variables: c-indent-level: 5 c-continued-statement-offset: 5 c-brace-offset: -5 c-argdecl-indent: 0 c-label-offset: -5 End: */
end_comment

end_unit

