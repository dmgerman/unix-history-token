begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Added exiterr() for terminal errors to prevent SGML.MSG errors.            */
end_comment

begin_include
include|#
directive|include
file|"sgmlincl.h"
end_include

begin_comment
comment|/* #INCLUDE statements for SGML parser. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|iorc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return code from io* functions */
end_comment

begin_comment
comment|/* ENTDEF: Process an entity definition and return the pointer to it.            The entity text must be in permanent storage.            There is no checking to see if the entity already exists;            the caller must have done that. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USE_PROTOTYPES
end_ifdef

begin_function
name|PECB
name|entdef
parameter_list|(
name|UNCH
modifier|*
name|ename
parameter_list|,
name|UNCH
name|estore
parameter_list|,
name|union
name|etext
modifier|*
name|petx
parameter_list|)
else|#
directive|else
function|PECB entdef
parameter_list|(
name|ename
parameter_list|,
name|estore
parameter_list|,
name|petx
parameter_list|)
name|UNCH
modifier|*
name|ename
decl_stmt|;
comment|/* Entity name (with length and EOS). */
name|UNCH
name|estore
decl_stmt|;
comment|/* Entity storage class. */
name|union
name|etext
modifier|*
name|petx
decl_stmt|;
comment|/* Ptr to entity text union. */
endif|#
directive|endif
block|{
name|PECB
name|p
decl_stmt|;
name|p
operator|=
operator|(
name|PECB
operator|)
name|hin
argument_list|(
operator|(
name|THASH
operator|)
name|etab
argument_list|,
name|ename
argument_list|,
name|hash
argument_list|(
name|ename
argument_list|,
name|ENTHASH
argument_list|)
argument_list|,
name|ENTSZ
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|UNIV
operator|)
operator|&
name|p
operator|->
name|etx
argument_list|,
operator|(
name|UNIV
operator|)
name|petx
argument_list|,
name|ETEXTSZ
argument_list|)
expr_stmt|;
name|p
operator|->
name|estore
operator|=
name|estore
expr_stmt|;
name|TRACEECB
argument_list|(
literal|"ENTDEF"
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ENTFIND: If an entity exists, return ptr to its ecb.             Return NULL if it is not defined. */
end_comment

begin_function
name|PECB
name|entfind
parameter_list|(
name|ename
parameter_list|)
name|UNCH
modifier|*
name|ename
decl_stmt|;
comment|/* Entity name (with length and EOS). */
block|{
name|PECB
name|p
decl_stmt|;
name|p
operator|=
operator|(
name|PECB
operator|)
name|hfind
argument_list|(
operator|(
name|THASH
operator|)
name|etab
argument_list|,
name|ename
argument_list|,
name|hash
argument_list|(
name|ename
argument_list|,
name|ENTHASH
argument_list|)
argument_list|)
expr_stmt|;
name|TRACEECB
argument_list|(
literal|"ENTFIND"
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* ENTREF: Process a general or parameter entity reference.            If the entity is defined it returns the return code from ENTOPEN.            It returns ENTUNDEF for undefined parameter entity references            and for general entity references when defaulting is not allowed.            Otherwise, it uses the default entity text. */
end_comment

begin_function
name|int
name|entref
parameter_list|(
name|ename
parameter_list|)
name|UNCH
modifier|*
name|ename
decl_stmt|;
comment|/* Entity name (with length and EOS). */
block|{
name|PECB
name|ecb
decl_stmt|;
comment|/* Entity control block. */
comment|/* Get the entity control block, if the entity has been defined. */
if|if
condition|(
operator|(
name|ecb
operator|=
operator|(
name|PECB
operator|)
name|hfind
argument_list|(
operator|(
name|THASH
operator|)
name|etab
argument_list|,
name|ename
argument_list|,
name|hash
argument_list|(
name|ename
argument_list|,
name|ENTHASH
argument_list|)
argument_list|)
operator|)
operator|==
literal|0
operator|||
name|ecb
operator|->
name|estore
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ename
index|[
literal|1
index|]
operator|==
name|lex
operator|.
name|d
operator|.
name|pero
operator|||
name|ecbdeflt
operator|==
literal|0
condition|)
block|{
name|sgmlerr
argument_list|(
literal|35
argument_list|,
operator|(
expr|struct
name|parse
operator|*
operator|)
literal|0
argument_list|,
name|ename
operator|+
literal|1
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENTUNDEF
operator|)
return|;
block|}
else|else
name|ecb
operator|=
name|usedef
argument_list|(
name|ename
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|entopen
argument_list|(
name|ecb
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ENTOPEN: Open a newly referenced entity.             Increment the stack pointer (es) and initialize the new entry.             ENTDATA if entity is CDATA or SDATA, ENTPI if it is PI,             0 if normal and all o.k.;<0 if not. */
end_comment

begin_function
name|int
name|entopen
parameter_list|(
name|ecb
parameter_list|)
name|struct
name|entity
modifier|*
name|ecb
decl_stmt|;
comment|/* Entity control block. */
block|{
name|int
name|i
decl_stmt|;
comment|/* Loop counter. */
comment|/* See if we have exceeded the entity nesting level. */
if|if
condition|(
name|es
operator|>=
name|ENTLVL
condition|)
block|{
name|sgmlerr
argument_list|(
literal|34
argument_list|,
operator|(
expr|struct
name|parse
operator|*
operator|)
literal|0
argument_list|,
name|ecb
operator|->
name|ename
operator|+
literal|1
argument_list|,
name|ntoa
argument_list|(
name|ENTLVL
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENTMAX
operator|)
return|;
block|}
if|if
condition|(
name|docelsw
condition|)
name|sgmlerr
argument_list|(
literal|234
argument_list|,
operator|(
expr|struct
name|parse
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* If entity is an etd, pi, or data, return it without creating an scb. */
switch|switch
condition|(
name|ecb
operator|->
name|estore
condition|)
block|{
case|case
name|ESN
case|:
if|if
condition|(
name|NEXTYPE
argument_list|(
name|ecb
operator|->
name|etx
operator|.
name|n
argument_list|)
operator|!=
name|ESNSUB
condition|)
block|{
if|if
condition|(
operator|!
name|NEDCNDEFINED
argument_list|(
name|ecb
operator|->
name|etx
operator|.
name|n
argument_list|)
condition|)
name|sgmlerr
argument_list|(
literal|78
argument_list|,
operator|(
expr|struct
name|parse
operator|*
operator|)
literal|0
argument_list|,
name|NEDCN
argument_list|(
name|ecb
operator|->
name|etx
operator|.
name|n
argument_list|)
operator|+
literal|1
argument_list|,
name|ecb
operator|->
name|ename
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|#
directive|if
literal|0
block|if (!NEID(ecb->etx.n)) { 		    sgmlerr(149, (struct parse *)0, ecb->ename + 1, (UNCH *)0); 		    return ENTFILE; 	       }
endif|#
directive|endif
if|if
condition|(
name|sw
operator|.
name|nopen
operator|>=
name|sd
operator|.
name|subdoc
condition|)
name|sgmlerr
argument_list|(
literal|188
argument_list|,
operator|(
expr|struct
name|parse
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
name|data
operator|=
operator|(
name|UNCH
operator|*
operator|)
name|ecb
operator|->
name|etx
operator|.
name|n
expr_stmt|;
name|entdatsw
operator|=
name|NDECONT
expr_stmt|;
return|return
operator|(
name|ENTDATA
operator|)
return|;
case|case
name|ESC
case|:
case|case
name|ESX
case|:
name|datalen
operator|=
name|ustrlen
argument_list|(
name|ecb
operator|->
name|etx
operator|.
name|c
argument_list|)
expr_stmt|;
comment|/* Ignore reference to empty CDATA entity. */
if|if
condition|(
name|datalen
operator|==
literal|0
operator|&&
name|ecb
operator|->
name|estore
operator|==
name|ESC
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|data
operator|=
name|ecb
operator|->
name|etx
operator|.
name|c
expr_stmt|;
name|entdatsw
operator|=
operator|(
name|ecb
operator|->
name|estore
operator|==
name|ESC
operator|)
condition|?
name|CDECONT
else|:
name|SDECONT
expr_stmt|;
return|return
operator|(
name|ENTDATA
operator|)
return|;
case|case
name|ESI
case|:
name|datalen
operator|=
name|ustrlen
argument_list|(
name|ecb
operator|->
name|etx
operator|.
name|c
argument_list|)
expr_stmt|;
name|data
operator|=
name|ecb
operator|->
name|etx
operator|.
name|c
expr_stmt|;
name|entpisw
operator|=
literal|4
expr_stmt|;
return|return
operator|(
name|ENTPI
operator|)
return|;
block|}
comment|/* If the same entity is already open, send msg and ignore it.         Level 0 needn't be tested, as its entity name is always *DOC.      */
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|++
name|i
operator|<=
name|es
condition|;
control|)
if|if
condition|(
name|scbs
index|[
name|i
index|]
operator|.
name|ecb
operator|.
name|enext
operator|==
name|ecb
condition|)
block|{
name|sgmlerr
argument_list|(
literal|36
argument_list|,
operator|(
expr|struct
name|parse
operator|*
operator|)
literal|0
argument_list|,
name|ecb
operator|->
name|ename
operator|+
literal|1
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENTLOOP
operator|)
return|;
block|}
comment|/* Update SCB if entity trace is wanted in messages or entity is a file.         (Avoid this at start when es==-1 or memory will be corrupted.)      */
if|if
condition|(
name|es
operator|>=
literal|0
operator|&&
operator|(
name|sw
operator|.
name|swenttr
operator|||
name|FILESW
operator|)
condition|)
name|scbset
argument_list|()
expr_stmt|;
comment|/* Stack the new source control block (we know there is room). */
operator|++
name|es
expr_stmt|;
comment|/* Increment scbs index. */
name|RCNT
operator|=
name|CCO
operator|=
name|RSCC
operator|=
literal|0
expr_stmt|;
comment|/* No records or chars yet. */
name|COPIEDSW
operator|=
literal|0
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|UNIV
operator|)
operator|&
name|ECB
argument_list|,
operator|(
name|UNIV
operator|)
name|ecb
argument_list|,
operator|(
name|UNS
operator|)
name|ENTSZ
argument_list|)
expr_stmt|;
comment|/* Copy the ecb into the scb. */
name|ECBPTR
operator|=
name|ecb
expr_stmt|;
comment|/* Save the ecb pointer in scb.ecb.enext. */
name|TRACEECB
argument_list|(
literal|"ENTOPEN"
argument_list|,
name|ECBPTR
argument_list|)
expr_stmt|;
comment|/* For memory entities, the read buffer is the entity text.         The text starts at FBUF, so FPOS should be FBUF-1         because it is bumped before each character is read.      */
if|if
condition|(
name|ECB
operator|.
name|estore
operator|<
name|ESFM
condition|)
block|{
name|FPOS
operator|=
operator|(
name|FBUF
operator|=
name|ECB
operator|.
name|etx
operator|.
name|c
operator|)
operator|-
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* For file entities, suspend any open file and do first read. */
if|if
condition|(
name|ECB
operator|.
name|etx
operator|.
name|x
operator|==
literal|0
condition|)
block|{
operator|--
name|es
expr_stmt|;
switch|switch
condition|(
name|ecb
operator|->
name|estore
condition|)
block|{
case|case
name|ESF
case|:
name|sgmlerr
argument_list|(
literal|149
argument_list|,
operator|(
expr|struct
name|parse
operator|*
operator|)
literal|0
argument_list|,
name|ecb
operator|->
name|ename
operator|+
literal|1
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|ESP
case|:
name|sgmlerr
argument_list|(
literal|229
argument_list|,
operator|(
expr|struct
name|parse
operator|*
operator|)
literal|0
argument_list|,
name|ecb
operator|->
name|ename
operator|+
literal|2
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
name|ENTFILE
return|;
block|}
name|fileopen
argument_list|()
expr_stmt|;
comment|/* Open new external file. */
if|if
condition|(
name|iorc
operator|<
literal|0
condition|)
block|{
comment|/* If open not successful: */
name|FPOS
operator|=
name|FBUF
operator|-
literal|1
expr_stmt|;
comment|/* Clean CCNT for OPEN error msg.*/
name|filerr
argument_list|(
literal|32
argument_list|,
name|ecb
operator|->
name|ename
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|--
name|es
expr_stmt|;
comment|/* Pop the stack. */
return|return
operator|(
name|ENTFILE
operator|)
return|;
block|}
name|filepend
argument_list|(
name|es
argument_list|)
expr_stmt|;
comment|/* Suspend any open file. */
name|fileread
argument_list|()
expr_stmt|;
comment|/* First read of file must be ok.*/
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ENTGET: Get next record of entity (if there is one).            Otherwise, close the file (if entity is a file) and            pop the entity stack.  If nothing else is on the stack,            return -1 to advise the caller. */
end_comment

begin_function
name|int
name|entget
parameter_list|()
block|{
name|RSCC
operator|+=
operator|(
name|CCO
operator|=
name|FPOS
operator|-
name|FBUF
operator|)
expr_stmt|;
comment|/* Characters-in-record (ignore EOB/EOF). */
if|if
condition|(
name|es
operator|==
name|tages
condition|)
name|tagctr
operator|+=
name|CCO
expr_stmt|;
comment|/* Update tag length counter. */
switch|switch
condition|(
operator|*
name|FPOS
condition|)
block|{
case|case
name|EOBCHAR
case|:
comment|/* End of file buffer: refill it. */
name|rbufs
index|[
operator|-
literal|2
index|]
operator|=
name|FPOS
index|[
operator|-
literal|2
index|]
expr_stmt|;
name|rbufs
index|[
operator|-
literal|1
index|]
operator|=
name|FPOS
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|fileread
argument_list|()
expr_stmt|;
comment|/* Read the file. */
if|if
condition|(
name|iorc
operator|>
literal|0
condition|)
break|break;
name|readerr
label|:
name|filerr
argument_list|(
literal|31
argument_list|,
name|ENTITY
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Treat error as EOF. */
case|case
name|EOFCHAR
case|:
comment|/* End of file: close it. */
name|fileclos
argument_list|()
expr_stmt|;
comment|/* Call SGMLIO to close file. */
name|conterr
label|:
if|if
condition|(
name|es
operator|==
literal|0
condition|)
block|{
comment|/* Report if it is primary file. */
name|FPOS
operator|=
name|FBUF
operator|-
literal|1
expr_stmt|;
comment|/* Preserve CCNT for omitted end-tags. */
return|return
operator|-
literal|1
return|;
block|}
case|case
name|EOS
case|:
comment|/* End of memory entity: pop the stack. */
name|TRACEECB
argument_list|(
literal|"ENTPOP"
argument_list|,
name|ECBPTR
argument_list|)
expr_stmt|;
if|if
condition|(
name|COPIEDSW
condition|)
block|{
name|frem
argument_list|(
call|(
name|UNIV
call|)
argument_list|(
name|FBUF
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|COPIEDSW
operator|=
literal|0
expr_stmt|;
block|}
operator|--
name|es
expr_stmt|;
comment|/* Pop the SCB stack. */
if|if
condition|(
name|FBUF
condition|)
break|break;
comment|/* Not a PEND file. */
name|filecont
argument_list|()
expr_stmt|;
comment|/* Resume previous file. */
if|if
condition|(
name|iorc
operator|<
literal|0
condition|)
block|{
comment|/* If CONT not successful: */
name|filerr
argument_list|(
literal|94
argument_list|,
name|ENTITY
operator|+
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|conterr
goto|;
block|}
name|fileread
argument_list|()
expr_stmt|;
comment|/* Read the file. */
if|if
condition|(
name|iorc
operator|<=
literal|0
condition|)
goto|goto
name|readerr
goto|;
comment|/* If READ not successful: */
name|rbufs
index|[
operator|-
literal|1
index|]
operator|=
name|SCB
operator|.
name|pushback
expr_stmt|;
name|FPOS
operator|+=
name|CCO
expr_stmt|;
name|CCO
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|delmscsw
operator|&&
name|es
operator|==
literal|0
condition|)
block|{
comment|/* End of DTD. */
name|delmscsw
operator|=
literal|0
expr_stmt|;
operator|*
name|rbufs
operator|=
name|lex
operator|.
name|d
operator|.
name|msc
expr_stmt|;
block|}
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* USEDEF: Use the default value for an entity reference.            Returns the ECB for the defaulted entity. */
end_comment

begin_function
name|PECB
name|usedef
parameter_list|(
name|ename
parameter_list|)
name|UNCH
modifier|*
name|ename
decl_stmt|;
comment|/* Entity name (with length and EOS). */
block|{
name|union
name|etext
name|etx
decl_stmt|;
comment|/* Save return from entgen. */
name|PECB
name|ecb
decl_stmt|;
comment|/* Entity control block. */
name|PNE
name|pne
init|=
literal|0
decl_stmt|;
comment|/* Ptr to NDATA entity control block. */
name|UNCH
name|estore
decl_stmt|;
comment|/* Default entity storage type. */
if|if
condition|(
operator|(
name|estore
operator|=
name|ecbdeflt
operator|->
name|estore
operator|)
operator|<
name|ESFM
condition|)
comment|/* Default is an internal string. */
name|etx
operator|.
name|c
operator|=
name|ecbdeflt
operator|->
name|etx
operator|.
name|c
expr_stmt|;
else|else
block|{
comment|/* Move entity name into fpi. */
name|fpidf
operator|.
name|fpinm
operator|=
name|ename
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|etx
operator|.
name|x
operator|=
name|entgen
argument_list|(
operator|&
name|fpidf
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|sgmlerr
argument_list|(
literal|150
argument_list|,
operator|(
expr|struct
name|parse
operator|*
operator|)
literal|0
argument_list|,
name|ename
operator|+
literal|1
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|estore
operator|==
name|ESN
condition|)
block|{
name|memcpy
argument_list|(
call|(
name|UNIV
call|)
argument_list|(
name|pne
operator|=
operator|(
name|PNE
operator|)
name|rmalloc
argument_list|(
operator|(
name|UNS
operator|)
name|NESZ
argument_list|)
argument_list|)
argument_list|,
operator|(
name|UNIV
operator|)
name|ecbdeflt
operator|->
name|etx
operator|.
name|n
argument_list|,
operator|(
name|UNS
operator|)
name|NESZ
argument_list|)
expr_stmt|;
name|NEID
argument_list|(
name|pne
argument_list|)
operator|=
name|etx
operator|.
name|x
expr_stmt|;
name|etx
operator|.
name|n
operator|=
name|pne
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sw
operator|.
name|swrefmsg
condition|)
name|sgmlerr
argument_list|(
literal|45
argument_list|,
operator|(
expr|struct
name|parse
operator|*
operator|)
literal|0
argument_list|,
name|ename
operator|+
literal|1
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
operator|++
name|ds
operator|.
name|ecbcnt
expr_stmt|;
name|ecb
operator|=
name|entdef
argument_list|(
name|ename
argument_list|,
name|estore
argument_list|,
operator|&
name|etx
argument_list|)
expr_stmt|;
name|ecb
operator|->
name|dflt
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|pne
condition|)
name|NEENAME
argument_list|(
name|pne
argument_list|)
operator|=
name|ecb
operator|->
name|ename
expr_stmt|;
return|return
operator|(
name|ecb
operator|)
return|;
block|}
end_function

begin_comment
comment|/* SCBSET: Set source control block to current location in the current entity.            This routine is called by SGML when it returns to the text            processor and by ERROR when it reports an error. */
end_comment

begin_function
name|VOID
name|scbset
parameter_list|()
block|{
if|if
condition|(
name|es
operator|>=
literal|0
operator|&&
name|FBUF
condition|)
block|{
name|CC
operator|=
operator|*
name|FPOS
expr_stmt|;
if|if
condition|(
operator|*
name|FPOS
operator|==
name|DELNONCH
condition|)
name|NEXTC
operator|=
name|FPOS
index|[
literal|1
index|]
expr_stmt|;
else|else
name|NEXTC
operator|=
literal|0
expr_stmt|;
name|CCO
operator|=
name|FPOS
operator|+
literal|1
operator|-
name|FBUF
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* FILEOPEN: Call IOOPEN to open an external entity (file). */
end_comment

begin_function
name|VOID
name|fileopen
parameter_list|()
comment|/* Open an external entity's file. */
block|{
name|iorc
operator|=
name|ioopen
argument_list|(
name|ECB
operator|.
name|etx
operator|.
name|x
argument_list|,
operator|&
name|SCBFCB
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* FILEREAD: Call IOREAD to read an open external entity (file). */
end_comment

begin_function
name|VOID
name|fileread
parameter_list|()
comment|/* Read the current external entity's file. */
block|{
name|int
name|newfile
decl_stmt|;
name|iorc
operator|=
name|ioread
argument_list|(
name|SCBFCB
argument_list|,
name|rbufs
argument_list|,
operator|&
name|newfile
argument_list|)
expr_stmt|;
name|FPOS
operator|=
operator|(
name|FBUF
operator|=
name|rbufs
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* Actual read buffer. */
if|if
condition|(
name|newfile
condition|)
name|RCNT
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* FILEPEND: Call IOPEND to close an open external entity (file) temporarily. */
end_comment

begin_function
name|VOID
name|filepend
parameter_list|(
name|es
parameter_list|)
comment|/* Close the current external entity's file. */
name|int
name|es
decl_stmt|;
comment|/* Local index to scbs. */
block|{
while|while
condition|(
operator|--
name|es
operator|>=
literal|0
condition|)
block|{
comment|/* Find last external file on stack. */
name|int
name|off
decl_stmt|;
if|if
condition|(
operator|!
name|FILESW
condition|)
continue|continue;
comment|/* Not an external file. */
if|if
condition|(
operator|!
name|FBUF
condition|)
continue|continue;
comment|/* Already suspended. */
name|off
operator|=
name|CCO
expr_stmt|;
name|assert
argument_list|(
name|off
operator|>=
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|off
operator|<
literal|0
condition|)
name|off
operator|=
literal|0
expr_stmt|;
else|else
name|CCO
operator|=
literal|0
expr_stmt|;
name|FPOS
operator|-=
name|CCO
expr_stmt|;
name|SCB
operator|.
name|pushback
operator|=
name|FPOS
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|FBUF
operator|=
literal|0
expr_stmt|;
comment|/* Indicate pending file. */
name|RSCC
operator|+=
name|off
expr_stmt|;
comment|/* Update characters-in-record counter. */
if|if
condition|(
name|es
operator|==
name|tages
condition|)
name|tagctr
operator|+=
name|off
expr_stmt|;
comment|/* Update tag length counter. */
name|iopend
argument_list|(
name|SCBFCB
argument_list|,
name|off
argument_list|,
name|rbufs
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_comment
comment|/* FILECONT: Call IOCONT to reopen an external entity (file). */
end_comment

begin_function
name|VOID
name|filecont
parameter_list|()
comment|/* Open an external entity's file. */
block|{
name|iorc
operator|=
name|iocont
argument_list|(
name|SCBFCB
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* FILECLOS: Call IOCLOSE to close an open external entity (file). */
end_comment

begin_function
name|VOID
name|fileclos
parameter_list|()
comment|/* Close the current external entity's file. */
block|{
if|if
condition|(
operator|!
name|SCBFCB
condition|)
return|return;
name|ioclose
argument_list|(
name|SCBFCB
argument_list|)
expr_stmt|;
comment|/* The fcb will have been freed by sgmlio. 	Make sure we don't access it again. */
name|SCBFCB
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ERROR: Interface to text processor SGML I/O services for error handling. */
end_comment

begin_function
name|VOID
name|error
parameter_list|(
name|e
parameter_list|)
name|struct
name|error
modifier|*
name|e
decl_stmt|;
block|{
name|scbset
argument_list|()
expr_stmt|;
comment|/* Update location in source control block. */
name|msgprint
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* PTRSRCH: Find a pointer in a list and return its index.             Search key must be on list as there is no limit test.             This routine is internal only -- not for user data. */
end_comment

begin_decl_stmt
name|UNIV
name|mdnmtab
index|[]
init|=
block|{
operator|(
name|UNIV
operator|)
name|key
index|[
name|KATTLIST
index|]
block|,
operator|(
name|UNIV
operator|)
name|key
index|[
name|KDOCTYPE
index|]
block|,
operator|(
name|UNIV
operator|)
name|key
index|[
name|KELEMENT
index|]
block|,
operator|(
name|UNIV
operator|)
name|key
index|[
name|KENTITY
index|]
block|,
operator|(
name|UNIV
operator|)
name|key
index|[
name|KLINKTYPE
index|]
block|,
operator|(
name|UNIV
operator|)
name|key
index|[
name|KLINK
index|]
block|,
operator|(
name|UNIV
operator|)
name|key
index|[
name|KNOTATION
index|]
block|,
operator|(
name|UNIV
operator|)
name|sgmlkey
block|,
operator|(
name|UNIV
operator|)
name|key
index|[
name|KSHORTREF
index|]
block|,
operator|(
name|UNIV
operator|)
name|key
index|[
name|KUSELINK
index|]
block|,
operator|(
name|UNIV
operator|)
name|key
index|[
name|KUSEMAP
index|]
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|UNIV
name|pcbtab
index|[]
init|=
block|{
operator|(
name|UNIV
operator|)
operator|&
name|pcbconc
block|,
operator|(
name|UNIV
operator|)
operator|&
name|pcbcone
block|,
operator|(
name|UNIV
operator|)
operator|&
name|pcbconm
block|,
operator|(
name|UNIV
operator|)
operator|&
name|pcbconr
block|,
operator|(
name|UNIV
operator|)
operator|&
name|pcbetag
block|,
operator|(
name|UNIV
operator|)
operator|&
name|pcbgrcm
block|,
operator|(
name|UNIV
operator|)
operator|&
name|pcbgrcs
block|,
operator|(
name|UNIV
operator|)
operator|&
name|pcbgrnm
block|,
operator|(
name|UNIV
operator|)
operator|&
name|pcbgrnt
block|,
operator|(
name|UNIV
operator|)
operator|&
name|pcblitc
block|,
operator|(
name|UNIV
operator|)
operator|&
name|pcblitp
block|,
operator|(
name|UNIV
operator|)
operator|&
name|pcblitr
block|,
operator|(
name|UNIV
operator|)
operator|&
name|pcblitt
block|,
operator|(
name|UNIV
operator|)
operator|&
name|pcblitv
block|,
operator|(
name|UNIV
operator|)
operator|&
name|pcbmd
block|,
operator|(
name|UNIV
operator|)
operator|&
name|pcbmdc
block|,
operator|(
name|UNIV
operator|)
operator|&
name|pcbmdi
block|,
operator|(
name|UNIV
operator|)
operator|&
name|pcbmds
block|,
operator|(
name|UNIV
operator|)
operator|&
name|pcbmsc
block|,
operator|(
name|UNIV
operator|)
operator|&
name|pcbmsi
block|,
operator|(
name|UNIV
operator|)
operator|&
name|pcbmsrc
block|,
operator|(
name|UNIV
operator|)
operator|&
name|pcbpro
block|,
operator|(
name|UNIV
operator|)
operator|&
name|pcbref
block|,
operator|(
name|UNIV
operator|)
operator|&
name|pcbstag
block|,
operator|(
name|UNIV
operator|)
operator|&
name|pcbval
block|,
operator|(
name|UNIV
operator|)
operator|&
name|pcbeal
block|,
operator|(
name|UNIV
operator|)
operator|&
name|pcbsd
block|, }
decl_stmt|;
end_decl_stmt

begin_function
name|UNS
name|ptrsrch
parameter_list|(
name|ptrtab
parameter_list|,
name|ptr
parameter_list|)
name|UNIV
name|ptrtab
index|[]
decl_stmt|;
name|UNIV
name|ptr
decl_stmt|;
block|{
name|UNS
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|ptrtab
index|[
name|i
index|]
operator|==
name|ptr
condition|)
break|break;
return|return
name|i
return|;
block|}
end_function

begin_comment
comment|/* MDERR: Process errors for markup declarations.           Prepare the special parameters that only exist for           markup declaration errors. */
end_comment

begin_function
name|VOID
name|mderr
parameter_list|(
name|number
parameter_list|,
name|parm1
parameter_list|,
name|parm2
parameter_list|)
name|UNS
name|number
decl_stmt|;
comment|/* Error number. */
name|UNCH
modifier|*
name|parm1
decl_stmt|;
comment|/* Additional parameters (or NULL). */
name|UNCH
modifier|*
name|parm2
decl_stmt|;
comment|/* Additional parameters (or NULL). */
block|{
name|struct
name|error
name|err
decl_stmt|;
name|errorinit
argument_list|(
operator|&
name|err
argument_list|,
name|subdcl
condition|?
name|MDERR
else|:
name|MDERR2
argument_list|,
name|number
argument_list|)
expr_stmt|;
name|err
operator|.
name|parmno
operator|=
name|parmno
expr_stmt|;
name|err
operator|.
name|subdcl
operator|=
name|subdcl
expr_stmt|;
name|err
operator|.
name|eparm
index|[
literal|0
index|]
operator|=
operator|(
name|UNIV
operator|)
name|parm1
expr_stmt|;
name|err
operator|.
name|eparm
index|[
literal|1
index|]
operator|=
operator|(
name|UNIV
operator|)
name|parm2
expr_stmt|;
name|err
operator|.
name|errsp
operator|=
operator|(
sizeof|sizeof
argument_list|(
name|pcbtab
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|pcbtab
index|[
literal|0
index|]
argument_list|)
operator|)
operator|+
name|ptrsrch
argument_list|(
name|mdnmtab
argument_list|,
operator|(
name|UNIV
operator|)
name|mdname
argument_list|)
expr_stmt|;
name|error
argument_list|(
operator|&
name|err
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* SGMLERR: Process errors for SGML parser. */
end_comment

begin_function
name|VOID
name|sgmlerr
parameter_list|(
name|number
parameter_list|,
name|pcb
parameter_list|,
name|parm1
parameter_list|,
name|parm2
parameter_list|)
name|UNS
name|number
decl_stmt|;
comment|/* Error number. */
name|struct
name|parse
modifier|*
name|pcb
decl_stmt|;
comment|/* Current parse control block. */
name|UNCH
modifier|*
name|parm1
decl_stmt|;
comment|/* Error message parameters. */
name|UNCH
modifier|*
name|parm2
decl_stmt|;
comment|/* Error message parameters. */
block|{
name|struct
name|error
name|err
decl_stmt|;
name|errorinit
argument_list|(
operator|&
name|err
argument_list|,
name|DOCERR
argument_list|,
name|number
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pcb
condition|)
name|pcb
operator|=
name|prologsw
condition|?
name|propcb
else|:
name|conpcb
expr_stmt|;
name|err
operator|.
name|errsp
operator|=
name|ptrsrch
argument_list|(
name|pcbtab
argument_list|,
operator|(
name|UNIV
operator|)
name|pcb
argument_list|)
expr_stmt|;
name|err
operator|.
name|eparm
index|[
literal|0
index|]
operator|=
operator|(
name|UNIV
operator|)
name|parm1
expr_stmt|;
name|err
operator|.
name|eparm
index|[
literal|1
index|]
operator|=
operator|(
name|UNIV
operator|)
name|parm2
expr_stmt|;
name|error
argument_list|(
operator|&
name|err
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* SAVERR: Save an error for possible later use. */
end_comment

begin_function
name|UNIV
name|saverr
parameter_list|(
name|number
parameter_list|,
name|pcb
parameter_list|,
name|parm1
parameter_list|,
name|parm2
parameter_list|)
name|UNS
name|number
decl_stmt|;
comment|/* Error number. */
name|struct
name|parse
modifier|*
name|pcb
decl_stmt|;
comment|/* Current parse control block. */
name|UNCH
modifier|*
name|parm1
decl_stmt|;
comment|/* Error message parameters. */
name|UNCH
modifier|*
name|parm2
decl_stmt|;
comment|/* Error message parameters. */
block|{
name|struct
name|error
name|err
decl_stmt|;
name|errorinit
argument_list|(
operator|&
name|err
argument_list|,
name|DOCERR
argument_list|,
name|number
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pcb
condition|)
name|pcb
operator|=
name|prologsw
condition|?
name|propcb
else|:
name|conpcb
expr_stmt|;
name|err
operator|.
name|errsp
operator|=
name|ptrsrch
argument_list|(
name|pcbtab
argument_list|,
operator|(
name|UNIV
operator|)
name|pcb
argument_list|)
expr_stmt|;
name|err
operator|.
name|eparm
index|[
literal|0
index|]
operator|=
operator|(
name|UNIV
operator|)
name|parm1
expr_stmt|;
name|err
operator|.
name|eparm
index|[
literal|1
index|]
operator|=
operator|(
name|UNIV
operator|)
name|parm2
expr_stmt|;
name|scbset
argument_list|()
expr_stmt|;
return|return
name|msgsave
argument_list|(
operator|&
name|err
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* SAVMDERR: Save an md error for possible later use. */
end_comment

begin_function
name|UNIV
name|savmderr
parameter_list|(
name|number
parameter_list|,
name|parm1
parameter_list|,
name|parm2
parameter_list|)
name|UNS
name|number
decl_stmt|;
comment|/* Error number. */
name|UNCH
modifier|*
name|parm1
decl_stmt|;
comment|/* Additional parameters (or NULL). */
name|UNCH
modifier|*
name|parm2
decl_stmt|;
comment|/* Additional parameters (or NULL). */
block|{
name|struct
name|error
name|err
decl_stmt|;
name|errorinit
argument_list|(
operator|&
name|err
argument_list|,
name|subdcl
condition|?
name|MDERR
else|:
name|MDERR2
argument_list|,
name|number
argument_list|)
expr_stmt|;
name|err
operator|.
name|parmno
operator|=
name|parmno
expr_stmt|;
name|err
operator|.
name|subdcl
operator|=
name|subdcl
expr_stmt|;
name|err
operator|.
name|eparm
index|[
literal|0
index|]
operator|=
operator|(
name|UNIV
operator|)
name|parm1
expr_stmt|;
name|err
operator|.
name|eparm
index|[
literal|1
index|]
operator|=
operator|(
name|UNIV
operator|)
name|parm2
expr_stmt|;
name|err
operator|.
name|errsp
operator|=
operator|(
sizeof|sizeof
argument_list|(
name|pcbtab
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|pcbtab
index|[
literal|0
index|]
argument_list|)
operator|)
operator|+
name|ptrsrch
argument_list|(
name|mdnmtab
argument_list|,
operator|(
name|UNIV
operator|)
name|mdname
argument_list|)
expr_stmt|;
name|scbset
argument_list|()
expr_stmt|;
return|return
name|msgsave
argument_list|(
operator|&
name|err
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* SVDERR: Print a saved error. */
end_comment

begin_function
name|VOID
name|svderr
parameter_list|(
name|p
parameter_list|)
name|UNIV
name|p
decl_stmt|;
block|{
name|msgsprint
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* EXITERR: Process terminal errors for SGML parser. */
end_comment

begin_function
name|VOID
name|exiterr
parameter_list|(
name|number
parameter_list|,
name|pcb
parameter_list|)
name|UNS
name|number
decl_stmt|;
comment|/* Error number. */
name|struct
name|parse
modifier|*
name|pcb
decl_stmt|;
comment|/* Current parse control block. */
block|{
name|struct
name|error
name|err
decl_stmt|;
name|errorinit
argument_list|(
operator|&
name|err
argument_list|,
name|EXITERR
argument_list|,
name|number
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pcb
condition|)
name|pcb
operator|=
name|prologsw
condition|?
name|propcb
else|:
name|conpcb
expr_stmt|;
name|err
operator|.
name|errsp
operator|=
name|ptrsrch
argument_list|(
name|pcbtab
argument_list|,
operator|(
name|UNIV
operator|)
name|pcb
argument_list|)
expr_stmt|;
name|error
argument_list|(
operator|&
name|err
argument_list|)
expr_stmt|;
comment|/* The error handler should have exited. */
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* SYNERR: Process syntax errors for SGML parser. */
end_comment

begin_function
name|VOID
name|synerr
parameter_list|(
name|number
parameter_list|,
name|pcb
parameter_list|)
name|UNS
name|number
decl_stmt|;
comment|/* Error number. */
name|struct
name|parse
modifier|*
name|pcb
decl_stmt|;
comment|/* Current parse control block. */
block|{
name|struct
name|error
name|err
decl_stmt|;
name|errorinit
argument_list|(
operator|&
name|err
argument_list|,
name|DOCERR
argument_list|,
name|number
argument_list|)
expr_stmt|;
name|err
operator|.
name|errsp
operator|=
name|ptrsrch
argument_list|(
name|pcbtab
argument_list|,
operator|(
name|UNIV
operator|)
name|pcb
argument_list|)
expr_stmt|;
name|error
argument_list|(
operator|&
name|err
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* FILERR: Process a file access error. */
end_comment

begin_function
name|VOID
name|filerr
parameter_list|(
name|number
parameter_list|,
name|parm
parameter_list|)
name|UNS
name|number
decl_stmt|;
name|UNCH
modifier|*
name|parm
decl_stmt|;
block|{
name|struct
name|error
name|err
decl_stmt|;
name|errorinit
argument_list|(
operator|&
name|err
argument_list|,
name|FILERR
argument_list|,
name|number
argument_list|)
expr_stmt|;
name|err
operator|.
name|eparm
index|[
literal|0
index|]
operator|=
operator|(
name|UNIV
operator|)
name|parm
expr_stmt|;
name|err
operator|.
name|sverrno
operator|=
name|errno
expr_stmt|;
name|error
argument_list|(
operator|&
name|err
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ERRORINIT: Constructor for struct error. */
end_comment

begin_function
name|VOID
name|errorinit
parameter_list|(
name|e
parameter_list|,
name|type
parameter_list|,
name|number
parameter_list|)
name|struct
name|error
modifier|*
name|e
decl_stmt|;
name|UNS
name|type
decl_stmt|;
name|UNS
name|number
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|e
operator|->
name|errtype
operator|=
name|type
expr_stmt|;
name|e
operator|->
name|errnum
operator|=
name|number
expr_stmt|;
name|e
operator|->
name|errsp
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXARGS
condition|;
name|i
operator|++
control|)
name|e
operator|->
name|eparm
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|e
operator|->
name|parmno
operator|=
literal|0
expr_stmt|;
name|e
operator|->
name|subdcl
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Local Variables: c-indent-level: 5 c-continued-statement-offset: 5 c-brace-offset: -5 c-argdecl-indent: 0 c-label-offset: -5 comment-column: 30 End: */
end_comment

end_unit

