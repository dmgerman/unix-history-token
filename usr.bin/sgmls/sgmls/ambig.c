begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ambig.c -    Content model ambiguity checking.       Written by James Clark (jjc@jclark.com). */
end_comment

begin_comment
comment|/* This uses the construction in pp8-9 of [1], extended to deal with AND groups.  Note that it is not correct for the purposes of ambiguity analysis to handle AND groups by turning them into an OR group of SEQ groups (consider (a&b?)).  We build an automaton for the entire content model by adding the following case for AND:  nullable(v) := nullable(left child) and nullable(right child) if nullable(right child) then     for each x in last(left child) do        follow(v,x) = follow(left child,x) U first(right child); if nullable(left child) then     for each x in last(right child) do         follow(v,x) = follow(right child,x) U first(left child); first(v) := first(left child) U first(right child); last(v) := first(left child) U first(right child);  We also build an automaton for each AND group by building automata for each of the members of the AND group using the above procedure and then combine the members using:  for each x in last(left child) do    follow(v,x) = follow(left child,x) U first(right child); for each x in last(right child) do    follow(v,x) = follow(right child,x) U first(left child); first(v) := first(left child) U first(right child);  The content model is ambiguous just in case one of these automata is non-deterministic.  (Note that when checking determinism we need to check the `first' set as well as all the `follow' sets.)  Why is this correct?  Consider a primitive token in a member of an AND group.  There are two worst cases for ambiguity: firstly, when none of the other members of AND group have been matched; secondly, when just the nullable members remain to be matched.  The first case is not affected by context of the AND group (unless the first case is identical to the second case.)  Note that inclusions are not relevant for the purposes of determining the ambiguity of content models. Otherwise the case in clause 11.2.5.1:     An element that can satisfy an element in the content model is    considered to do so, even if the element is also an inclusion.  could never arise.  [1] Anne Brueggemann-Klein, Regular Expressions into Finite Automata, Universitaet Freiburg, Institut fur Informatik, 33 July 1991. */
end_comment

begin_include
include|#
directive|include
file|"sgmlincl.h"
end_include

begin_comment
comment|/* Sets of states are represented by 0-terminated, ordered lists of indexes in gbuf. */
end_comment

begin_define
define|#
directive|define
name|MAXSTATES
value|(GRPGTCNT+2)
end_define

begin_define
define|#
directive|define
name|listcat
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|strcat((char *)(x), (char *)(y))
end_define

begin_define
define|#
directive|define
name|listcpy
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|strcpy((char *)(x), (char *)(y))
end_define

begin_comment
comment|/* Information about a content token. */
end_comment

begin_struct
struct|struct
name|contoken
block|{
name|UNCH
name|size
decl_stmt|;
name|UNCH
name|nullable
decl_stmt|;
name|UNCH
modifier|*
name|first
decl_stmt|;
name|UNCH
modifier|*
name|last
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|VOID
name|contoken
name|P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
expr|struct
name|contoken
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|VOID
name|andgroup
name|P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
expr|struct
name|contoken
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|VOID
name|orgroup
name|P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
expr|struct
name|contoken
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|VOID
name|seqgroup
name|P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
expr|struct
name|contoken
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|VOID
name|andambig
name|P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|listambig
name|P
argument_list|(
operator|(
name|UNCH
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|VOID
name|listmerge
name|P
argument_list|(
operator|(
name|UNCH
operator|*
operator|,
name|UNCH
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|contoken
modifier|*
name|newcontoken
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|VOID
name|freecontoken
name|P
argument_list|(
operator|(
expr|struct
name|contoken
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Dynamically allocated vector of follow sets. */
end_comment

begin_decl_stmt
specifier|static
name|UNCH
modifier|*
modifier|*
name|follow
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|UNCH
modifier|*
name|mergebuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for use by listmerge */
end_comment

begin_comment
comment|/* Set to non-zero if the content model is ambiguous. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ambigsw
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Check the current content model (in gbuf) for ambiguity. */
end_comment

begin_function
name|VOID
name|ambig
parameter_list|()
block|{
name|struct
name|contoken
modifier|*
name|s
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|follow
condition|)
block|{
comment|/* We can't allocate everything in one chunk, because that would 	     overflow a 16-bit unsigned if GRPGTCNT was 253. */
name|UNCH
modifier|*
name|ptr
decl_stmt|;
name|follow
operator|=
operator|(
name|UNCH
operator|*
operator|*
operator|)
name|rmalloc
argument_list|(
name|MAXSTATES
operator|*
sizeof|sizeof
argument_list|(
name|UNCH
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|follow
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|ptr
operator|=
operator|(
name|UNCH
operator|*
operator|)
name|rmalloc
argument_list|(
operator|(
name|MAXSTATES
operator|-
literal|1
operator|)
operator|*
name|MAXSTATES
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|MAXSTATES
condition|;
name|i
operator|++
control|)
block|{
name|follow
index|[
name|i
index|]
operator|=
name|ptr
expr_stmt|;
name|ptr
operator|+=
name|MAXSTATES
expr_stmt|;
block|}
name|mergebuf
operator|=
operator|(
name|UNCH
operator|*
operator|)
name|rmalloc
argument_list|(
name|MAXSTATES
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|MAXSTATES
condition|;
name|i
operator|++
control|)
name|follow
index|[
name|i
index|]
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|ambigsw
operator|=
literal|0
expr_stmt|;
name|s
operator|=
name|newcontoken
argument_list|()
expr_stmt|;
name|contoken
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|ambigsw
operator|=
name|ambigsw
operator|||
name|listambig
argument_list|(
name|s
operator|->
name|first
argument_list|)
expr_stmt|;
name|freecontoken
argument_list|(
name|s
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
operator|!
name|ambigsw
operator|&&
name|i
operator|<
name|MAXSTATES
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|listambig
argument_list|(
name|follow
index|[
name|i
index|]
argument_list|)
condition|)
name|ambigsw
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ambigsw
condition|)
name|mderr
argument_list|(
literal|137
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Free memory used for ambiguity checking. */
end_comment

begin_function
name|VOID
name|ambigfree
parameter_list|()
block|{
if|if
condition|(
name|follow
condition|)
block|{
name|frem
argument_list|(
operator|(
name|UNIV
operator|)
name|follow
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|frem
argument_list|(
operator|(
name|UNIV
operator|)
name|follow
argument_list|)
expr_stmt|;
name|frem
argument_list|(
operator|(
name|UNIV
operator|)
name|mergebuf
argument_list|)
expr_stmt|;
name|follow
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Determine whether a list of primitive content tokens (each represented by its index in gbuf) is ambiguous. */
end_comment

begin_function
specifier|static
name|int
name|listambig
parameter_list|(
name|list
parameter_list|)
name|UNCH
modifier|*
name|list
decl_stmt|;
block|{
name|UNCH
modifier|*
name|p
decl_stmt|;
name|int
name|chars
init|=
literal|0
decl_stmt|;
name|int
name|rc
init|=
literal|0
decl_stmt|;
for|for
control|(
name|p
operator|=
name|list
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|gbuf
index|[
operator|*
name|p
index|]
operator|.
name|ttype
operator|&
name|TTMASK
operator|)
operator|==
name|TTETD
condition|)
block|{
name|struct
name|etd
modifier|*
name|e
init|=
name|gbuf
index|[
operator|*
name|p
index|]
operator|.
name|tu
operator|.
name|thetd
decl_stmt|;
if|if
condition|(
name|e
operator|->
name|mark
condition|)
block|{
name|rc
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|e
operator|->
name|mark
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|assert
argument_list|(
operator|(
name|gbuf
index|[
operator|*
name|p
index|]
operator|.
name|ttype
operator|&
name|TTMASK
operator|)
operator|==
name|TTCHARS
argument_list|)
expr_stmt|;
if|if
condition|(
name|chars
condition|)
block|{
name|rc
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|chars
operator|=
literal|1
expr_stmt|;
block|}
block|}
for|for
control|(
name|p
operator|=
name|list
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|(
name|gbuf
index|[
operator|*
name|p
index|]
operator|.
name|ttype
operator|&
name|TTMASK
operator|)
operator|==
name|TTETD
condition|)
name|gbuf
index|[
operator|*
name|p
index|]
operator|.
name|tu
operator|.
name|thetd
operator|->
name|mark
operator|=
literal|0
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_comment
comment|/* Analyze a content token.  The `checkand' argument is needed to ensure that the algorithm is not exponential in the AND-group nesting depth. */
end_comment

begin_function
specifier|static
name|VOID
name|contoken
parameter_list|(
name|m
parameter_list|,
name|checkand
parameter_list|,
name|res
parameter_list|)
name|int
name|m
decl_stmt|;
comment|/* Index of content token in gbuf */
name|int
name|checkand
decl_stmt|;
comment|/* Non-zero if AND groups should be checked */
name|struct
name|contoken
modifier|*
name|res
decl_stmt|;
comment|/* Result */
block|{
name|UNCH
name|flags
init|=
name|gbuf
index|[
name|m
index|]
operator|.
name|ttype
decl_stmt|;
switch|switch
condition|(
name|flags
operator|&
name|TTMASK
condition|)
block|{
case|case
name|TTCHARS
case|:
case|case
name|TTETD
case|:
name|res
operator|->
name|first
index|[
literal|0
index|]
operator|=
name|m
expr_stmt|;
name|res
operator|->
name|first
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|res
operator|->
name|last
index|[
literal|0
index|]
operator|=
name|m
expr_stmt|;
name|res
operator|->
name|last
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|res
operator|->
name|size
operator|=
literal|1
expr_stmt|;
name|res
operator|->
name|nullable
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|TTAND
case|:
if|if
condition|(
name|checkand
condition|)
name|andambig
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|andgroup
argument_list|(
name|m
argument_list|,
name|checkand
argument_list|,
name|res
argument_list|)
expr_stmt|;
break|break;
case|case
name|TTOR
case|:
name|orgroup
argument_list|(
name|m
argument_list|,
name|checkand
argument_list|,
name|res
argument_list|)
expr_stmt|;
break|break;
case|case
name|TTSEQ
case|:
name|seqgroup
argument_list|(
name|m
argument_list|,
name|checkand
argument_list|,
name|res
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|TREP
condition|)
block|{
name|UNCH
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|res
operator|->
name|last
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
name|listmerge
argument_list|(
name|follow
index|[
operator|*
name|p
index|]
argument_list|,
name|res
operator|->
name|first
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|TOPT
condition|)
name|res
operator|->
name|nullable
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Check an AND group for ambiguity. */
end_comment

begin_function
specifier|static
name|VOID
name|andambig
parameter_list|(
name|m
parameter_list|)
name|int
name|m
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|tnum
decl_stmt|;
name|int
name|lim
decl_stmt|;
name|struct
name|contoken
modifier|*
name|curr
decl_stmt|;
name|struct
name|contoken
modifier|*
name|next
decl_stmt|;
name|tnum
operator|=
name|gbuf
index|[
name|m
index|]
operator|.
name|tu
operator|.
name|tnum
expr_stmt|;
name|assert
argument_list|(
name|tnum
operator|>
literal|0
argument_list|)
expr_stmt|;
name|curr
operator|=
name|newcontoken
argument_list|()
expr_stmt|;
name|next
operator|=
name|newcontoken
argument_list|()
expr_stmt|;
name|contoken
argument_list|(
name|m
operator|+
literal|1
argument_list|,
literal|0
argument_list|,
name|curr
argument_list|)
expr_stmt|;
name|i
operator|=
name|m
operator|+
literal|1
operator|+
name|curr
operator|->
name|size
expr_stmt|;
name|curr
operator|->
name|size
operator|+=
literal|1
expr_stmt|;
for|for
control|(
operator|--
name|tnum
init|;
name|tnum
operator|>
literal|0
condition|;
operator|--
name|tnum
control|)
block|{
name|UNCH
modifier|*
name|p
decl_stmt|;
name|contoken
argument_list|(
name|i
argument_list|,
literal|0
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|curr
operator|->
name|size
operator|+=
name|next
operator|->
name|size
expr_stmt|;
name|i
operator|+=
name|next
operator|->
name|size
expr_stmt|;
for|for
control|(
name|p
operator|=
name|curr
operator|->
name|last
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
name|listcat
argument_list|(
name|follow
index|[
operator|*
name|p
index|]
argument_list|,
name|next
operator|->
name|first
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|next
operator|->
name|last
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
name|listmerge
argument_list|(
name|follow
index|[
operator|*
name|p
index|]
argument_list|,
name|curr
operator|->
name|first
argument_list|)
expr_stmt|;
name|listcat
argument_list|(
name|curr
operator|->
name|first
argument_list|,
name|next
operator|->
name|first
argument_list|)
expr_stmt|;
name|listcat
argument_list|(
name|curr
operator|->
name|last
argument_list|,
name|next
operator|->
name|last
argument_list|)
expr_stmt|;
block|}
name|lim
operator|=
name|m
operator|+
name|curr
operator|->
name|size
expr_stmt|;
for|for
control|(
name|i
operator|=
name|m
operator|+
literal|1
init|;
name|i
operator|<
name|lim
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|listambig
argument_list|(
name|follow
index|[
name|i
index|]
argument_list|)
condition|)
name|ambigsw
operator|=
literal|1
expr_stmt|;
name|follow
index|[
name|i
index|]
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|freecontoken
argument_list|(
name|curr
argument_list|)
expr_stmt|;
name|freecontoken
argument_list|(
name|next
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle an AND group. */
end_comment

begin_function
specifier|static
name|VOID
name|andgroup
parameter_list|(
name|m
parameter_list|,
name|checkand
parameter_list|,
name|res
parameter_list|)
name|int
name|m
decl_stmt|;
name|int
name|checkand
decl_stmt|;
name|struct
name|contoken
modifier|*
name|res
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|tnum
decl_stmt|;
comment|/* union of the first sets of nullable members of the group */
name|UNCH
modifier|*
name|nullablefirst
decl_stmt|;
name|struct
name|contoken
modifier|*
name|next
decl_stmt|;
name|tnum
operator|=
name|gbuf
index|[
name|m
index|]
operator|.
name|tu
operator|.
name|tnum
expr_stmt|;
name|assert
argument_list|(
name|tnum
operator|>
literal|0
argument_list|)
expr_stmt|;
name|contoken
argument_list|(
name|m
operator|+
literal|1
argument_list|,
name|checkand
argument_list|,
name|res
argument_list|)
expr_stmt|;
name|nullablefirst
operator|=
operator|(
name|UNCH
operator|*
operator|)
name|rmalloc
argument_list|(
name|MAXSTATES
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|->
name|nullable
condition|)
name|listcpy
argument_list|(
name|nullablefirst
argument_list|,
name|res
operator|->
name|first
argument_list|)
expr_stmt|;
else|else
name|nullablefirst
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|i
operator|=
name|m
operator|+
literal|1
operator|+
name|res
operator|->
name|size
expr_stmt|;
name|res
operator|->
name|size
operator|+=
literal|1
expr_stmt|;
name|next
operator|=
name|newcontoken
argument_list|()
expr_stmt|;
for|for
control|(
operator|--
name|tnum
init|;
name|tnum
operator|>
literal|0
condition|;
operator|--
name|tnum
control|)
block|{
name|UNCH
modifier|*
name|p
decl_stmt|;
name|contoken
argument_list|(
name|i
argument_list|,
name|checkand
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|res
operator|->
name|size
operator|+=
name|next
operator|->
name|size
expr_stmt|;
name|i
operator|+=
name|next
operator|->
name|size
expr_stmt|;
if|if
condition|(
name|next
operator|->
name|nullable
condition|)
for|for
control|(
name|p
operator|=
name|res
operator|->
name|last
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
name|listcat
argument_list|(
name|follow
index|[
operator|*
name|p
index|]
argument_list|,
name|next
operator|->
name|first
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|next
operator|->
name|last
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
name|listmerge
argument_list|(
name|follow
index|[
operator|*
name|p
index|]
argument_list|,
name|nullablefirst
argument_list|)
expr_stmt|;
name|listcat
argument_list|(
name|res
operator|->
name|first
argument_list|,
name|next
operator|->
name|first
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|->
name|nullable
condition|)
name|listcat
argument_list|(
name|nullablefirst
argument_list|,
name|next
operator|->
name|first
argument_list|)
expr_stmt|;
name|listcat
argument_list|(
name|res
operator|->
name|last
argument_list|,
name|next
operator|->
name|last
argument_list|)
expr_stmt|;
name|res
operator|->
name|nullable
operator|&=
name|next
operator|->
name|nullable
expr_stmt|;
block|}
name|frem
argument_list|(
operator|(
name|UNIV
operator|)
name|nullablefirst
argument_list|)
expr_stmt|;
name|freecontoken
argument_list|(
name|next
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle a SEQ group. */
end_comment

begin_function
specifier|static
name|VOID
name|seqgroup
parameter_list|(
name|m
parameter_list|,
name|checkand
parameter_list|,
name|res
parameter_list|)
name|int
name|m
decl_stmt|;
name|int
name|checkand
decl_stmt|;
name|struct
name|contoken
modifier|*
name|res
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|tnum
decl_stmt|;
name|struct
name|contoken
modifier|*
name|next
decl_stmt|;
name|tnum
operator|=
name|gbuf
index|[
name|m
index|]
operator|.
name|tu
operator|.
name|tnum
expr_stmt|;
name|assert
argument_list|(
name|tnum
operator|>
literal|0
argument_list|)
expr_stmt|;
name|contoken
argument_list|(
name|m
operator|+
literal|1
argument_list|,
name|checkand
argument_list|,
name|res
argument_list|)
expr_stmt|;
name|i
operator|=
name|m
operator|+
literal|1
operator|+
name|res
operator|->
name|size
expr_stmt|;
name|res
operator|->
name|size
operator|+=
literal|1
expr_stmt|;
name|next
operator|=
name|newcontoken
argument_list|()
expr_stmt|;
for|for
control|(
operator|--
name|tnum
init|;
name|tnum
operator|>
literal|0
condition|;
operator|--
name|tnum
control|)
block|{
name|UNCH
modifier|*
name|p
decl_stmt|;
name|contoken
argument_list|(
name|i
argument_list|,
name|checkand
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|res
operator|->
name|size
operator|+=
name|next
operator|->
name|size
expr_stmt|;
name|i
operator|+=
name|next
operator|->
name|size
expr_stmt|;
for|for
control|(
name|p
operator|=
name|res
operator|->
name|last
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
name|listcat
argument_list|(
name|follow
index|[
operator|*
name|p
index|]
argument_list|,
name|next
operator|->
name|first
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|->
name|nullable
condition|)
name|listcat
argument_list|(
name|res
operator|->
name|first
argument_list|,
name|next
operator|->
name|first
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|->
name|nullable
condition|)
name|listcat
argument_list|(
name|res
operator|->
name|last
argument_list|,
name|next
operator|->
name|last
argument_list|)
expr_stmt|;
else|else
name|listcpy
argument_list|(
name|res
operator|->
name|last
argument_list|,
name|next
operator|->
name|last
argument_list|)
expr_stmt|;
name|res
operator|->
name|nullable
operator|&=
name|next
operator|->
name|nullable
expr_stmt|;
block|}
name|freecontoken
argument_list|(
name|next
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle an OR group. */
end_comment

begin_function
specifier|static
name|VOID
name|orgroup
parameter_list|(
name|m
parameter_list|,
name|checkand
parameter_list|,
name|res
parameter_list|)
name|int
name|m
decl_stmt|;
name|int
name|checkand
decl_stmt|;
name|struct
name|contoken
modifier|*
name|res
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|tnum
decl_stmt|;
name|struct
name|contoken
modifier|*
name|next
decl_stmt|;
name|tnum
operator|=
name|gbuf
index|[
name|m
index|]
operator|.
name|tu
operator|.
name|tnum
expr_stmt|;
name|assert
argument_list|(
name|tnum
operator|>
literal|0
argument_list|)
expr_stmt|;
name|contoken
argument_list|(
name|m
operator|+
literal|1
argument_list|,
name|checkand
argument_list|,
name|res
argument_list|)
expr_stmt|;
name|i
operator|=
name|m
operator|+
literal|1
operator|+
name|res
operator|->
name|size
expr_stmt|;
name|res
operator|->
name|size
operator|+=
literal|1
expr_stmt|;
name|next
operator|=
name|newcontoken
argument_list|()
expr_stmt|;
for|for
control|(
operator|--
name|tnum
init|;
name|tnum
operator|>
literal|0
condition|;
operator|--
name|tnum
control|)
block|{
name|contoken
argument_list|(
name|i
argument_list|,
name|checkand
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|res
operator|->
name|size
operator|+=
name|next
operator|->
name|size
expr_stmt|;
name|i
operator|+=
name|next
operator|->
name|size
expr_stmt|;
name|listcat
argument_list|(
name|res
operator|->
name|first
argument_list|,
name|next
operator|->
name|first
argument_list|)
expr_stmt|;
name|listcat
argument_list|(
name|res
operator|->
name|last
argument_list|,
name|next
operator|->
name|last
argument_list|)
expr_stmt|;
name|res
operator|->
name|nullable
operator||=
name|next
operator|->
name|nullable
expr_stmt|;
block|}
name|freecontoken
argument_list|(
name|next
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Merge the second ordered list into the first. */
end_comment

begin_function
specifier|static
name|VOID
name|listmerge
parameter_list|(
name|p
parameter_list|,
name|b
parameter_list|)
name|UNCH
modifier|*
name|p
decl_stmt|,
decl|*
name|b
decl_stmt|;
end_function

begin_block
block|{
name|UNCH
modifier|*
name|a
init|=
name|mergebuf
decl_stmt|;
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|a
argument_list|,
operator|(
name|char
operator|*
operator|)
name|p
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|*
name|a
condition|)
block|{
if|if
condition|(
operator|*
name|b
condition|)
block|{
if|if
condition|(
operator|*
name|a
operator|<
operator|*
name|b
condition|)
operator|*
name|p
operator|++
operator|=
operator|*
name|a
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|a
operator|>
operator|*
name|b
condition|)
operator|*
name|p
operator|++
operator|=
operator|*
name|b
operator|++
expr_stmt|;
else|else
name|a
operator|++
expr_stmt|;
block|}
else|else
operator|*
name|p
operator|++
operator|=
operator|*
name|a
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|b
condition|)
operator|*
name|p
operator|++
operator|=
operator|*
name|b
operator|++
expr_stmt|;
else|else
break|break;
block|}
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
block|}
end_block

begin_function
specifier|static
name|struct
name|contoken
modifier|*
name|newcontoken
parameter_list|()
block|{
name|struct
name|contoken
modifier|*
name|p
init|=
operator|(
expr|struct
name|contoken
operator|*
operator|)
name|rmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|contoken
argument_list|)
operator|+
name|MAXSTATES
operator|*
literal|2
argument_list|)
decl_stmt|;
name|p
operator|->
name|first
operator|=
operator|(
name|UNCH
operator|*
operator|)
operator|(
name|p
operator|+
literal|1
operator|)
expr_stmt|;
name|p
operator|->
name|last
operator|=
name|p
operator|->
name|first
operator|+
name|MAXSTATES
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_function
specifier|static
name|VOID
name|freecontoken
parameter_list|(
name|p
parameter_list|)
name|struct
name|contoken
modifier|*
name|p
decl_stmt|;
block|{
name|frem
argument_list|(
operator|(
name|UNIV
operator|)
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Local Variables: c-indent-level: 5 c-continued-statement-offset: 5 c-brace-offset: -5 c-argdecl-indent: 0 c-label-offset: -5 End: */
end_comment

end_unit

