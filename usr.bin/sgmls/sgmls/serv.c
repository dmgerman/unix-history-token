begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"sgmlincl.h"
end_include

begin_comment
comment|/* #INCLUDE statements for SGML parser. */
end_comment

begin_comment
comment|/* ETDDEF: Define an element type definition.            Use an existing one if there is one; otherwise create one, which            rmalloc initializes to zero which shows it is a virgin etd. */
end_comment

begin_function
name|PETD
name|etddef
parameter_list|(
name|ename
parameter_list|)
name|UNCH
modifier|*
name|ename
decl_stmt|;
comment|/* Element name (GI) with length byte. */
block|{
name|PETD
name|p
decl_stmt|;
comment|/* Pointer to an etd. */
name|int
name|hnum
decl_stmt|;
comment|/* Hash number for ename. */
if|if
condition|(
operator|(
name|p
operator|=
operator|(
name|PETD
operator|)
name|hfind
argument_list|(
operator|(
name|THASH
operator|)
name|etdtab
argument_list|,
name|ename
argument_list|,
name|hnum
operator|=
name|hash
argument_list|(
name|ename
argument_list|,
name|ETDHASH
argument_list|)
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|p
operator|=
operator|(
name|PETD
operator|)
name|hin
argument_list|(
operator|(
name|THASH
operator|)
name|etdtab
argument_list|,
name|ename
argument_list|,
name|hnum
argument_list|,
name|ETDSZ
argument_list|)
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* ETDSET: Store data in an element type definition.            The etd must be valid and virgin (except for adl and etdmin).            As an etd cannot be modified, there is no checking for existing            pointers and no freeing of their storage. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USE_PROTOTYPES
end_ifdef

begin_function
name|PETD
name|etdset
parameter_list|(
name|PETD
name|p
parameter_list|,
name|UNCH
name|fmin
parameter_list|,
name|struct
name|thdr
modifier|*
name|cmod
parameter_list|,
name|PETD
modifier|*
name|mexgrp
parameter_list|,
name|PETD
modifier|*
name|pexgrp
parameter_list|,
name|struct
name|entity
modifier|*
modifier|*
name|srm
parameter_list|)
else|#
directive|else
function|PETD etdset
parameter_list|(
name|p
parameter_list|,
name|fmin
parameter_list|,
name|cmod
parameter_list|,
name|mexgrp
parameter_list|,
name|pexgrp
parameter_list|,
name|srm
parameter_list|)
name|PETD
name|p
decl_stmt|;
comment|/* Pointer to an etd. */
name|UNCH
name|fmin
decl_stmt|;
comment|/* Minimization bit flags. */
name|struct
name|thdr
modifier|*
name|cmod
decl_stmt|;
comment|/* Pointer to content model. */
name|PETD
modifier|*
name|mexgrp
decl_stmt|;
comment|/* Pointers to minus and plus exception lists. */
name|PETD
modifier|*
name|pexgrp
decl_stmt|;
comment|/* Pointers to minus and plus exception lists. */
name|struct
name|entity
modifier|*
modifier|*
name|srm
decl_stmt|;
comment|/* Short reference map. */
endif|#
directive|endif
block|{
name|p
operator|->
name|etdmin
operator||=
name|fmin
expr_stmt|;
name|p
operator|->
name|etdmod
operator|=
name|cmod
expr_stmt|;
name|p
operator|->
name|etdmex
operator|=
name|mexgrp
expr_stmt|;
name|p
operator|->
name|etdpex
operator|=
name|pexgrp
expr_stmt|;
name|p
operator|->
name|etdsrm
operator|=
name|srm
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* ETDREF: Retrieve the pointer to an element type definition. */
end_comment

begin_function
name|PETD
name|etdref
parameter_list|(
name|ename
parameter_list|)
name|UNCH
modifier|*
name|ename
decl_stmt|;
comment|/* Element name (GI) with length byte.. */
block|{
return|return
operator|(
name|PETD
operator|)
name|hfind
argument_list|(
operator|(
name|THASH
operator|)
name|etdtab
argument_list|,
name|ename
argument_list|,
name|hash
argument_list|(
name|ename
argument_list|,
name|ETDHASH
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ETDCAN: Cancel an element definition.  The etd is freed and is removed            from the hash table, but its model and other pointers are not freed. */
end_comment

begin_function
name|VOID
name|etdcan
parameter_list|(
name|ename
parameter_list|)
name|UNCH
modifier|*
name|ename
decl_stmt|;
comment|/* GI name (with length and EOS). */
block|{
name|PETD
name|p
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
operator|(
name|PETD
operator|)
name|hout
argument_list|(
operator|(
name|THASH
operator|)
name|etdtab
argument_list|,
name|ename
argument_list|,
name|hash
argument_list|(
name|ename
argument_list|,
name|ETDHASH
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|frem
argument_list|(
operator|(
name|UNIV
operator|)
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* SYMBOL TABLE FUNCTIONS: These functions manage hash tables that are used    for entities, element type definitions, IDs, and other purposes.  The    interface will be expanded in the future to include multiple environments,    probably by creating arrays of the present hash tables with each table    in the array corresponding to an environment level. */
end_comment

begin_comment
comment|/* HASH: Form hash value for a string.          From the Dragon Book, p436. */
end_comment

begin_function
name|int
name|hash
parameter_list|(
name|s
parameter_list|,
name|hashsize
parameter_list|)
name|UNCH
modifier|*
name|s
decl_stmt|;
comment|/* String to be hashed. */
name|int
name|hashsize
decl_stmt|;
comment|/* Size of hash table array. */
block|{
name|unsigned
name|long
name|h
init|=
literal|0
decl_stmt|,
name|g
decl_stmt|;
while|while
condition|(
operator|*
name|s
operator|!=
literal|0
condition|)
block|{
name|h
operator|<<=
literal|4
expr_stmt|;
name|h
operator|+=
operator|*
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|g
operator|=
name|h
operator|&
literal|0xf0000000
operator|)
operator|!=
literal|0
condition|)
block|{
name|h
operator|^=
name|g
operator|>>
literal|24
expr_stmt|;
name|h
operator|^=
name|g
expr_stmt|;
block|}
block|}
return|return
call|(
name|int
call|)
argument_list|(
name|h
operator|%
name|hashsize
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* HFIND: Look for a name in a hash table. */
end_comment

begin_function
name|struct
name|hash
modifier|*
name|hfind
parameter_list|(
name|htab
parameter_list|,
name|s
parameter_list|,
name|h
parameter_list|)
name|struct
name|hash
modifier|*
name|htab
index|[]
decl_stmt|;
comment|/* Hash table. */
name|UNCH
modifier|*
name|s
decl_stmt|;
comment|/* Entity name. */
name|int
name|h
decl_stmt|;
comment|/* Hash value for entity name. */
block|{
name|struct
name|hash
modifier|*
name|np
decl_stmt|;
for|for
control|(
name|np
operator|=
name|htab
index|[
name|h
index|]
init|;
name|np
operator|!=
literal|0
condition|;
name|np
operator|=
name|np
operator|->
name|enext
control|)
if|if
condition|(
name|ustrcmp
argument_list|(
name|s
argument_list|,
name|np
operator|->
name|ename
argument_list|)
operator|==
literal|0
condition|)
return|return
name|np
return|;
comment|/* Found it. */
return|return
operator|(
expr|struct
name|hash
operator|*
operator|)
literal|0
return|;
comment|/* Not found. */
block|}
end_function

begin_comment
comment|/* HIN: Locates an entry in a hash table, or allocates a new one.         Returns a pointer to a structure containing a name         and a pointer to the next entry.  Other data in the         structure must be maintained by the caller. */
end_comment

begin_function
name|struct
name|hash
modifier|*
name|hin
parameter_list|(
name|htab
parameter_list|,
name|name
parameter_list|,
name|h
parameter_list|,
name|size
parameter_list|)
name|struct
name|hash
modifier|*
name|htab
index|[]
decl_stmt|;
comment|/* Hash table. */
name|UNCH
modifier|*
name|name
decl_stmt|;
comment|/* Entity name. */
name|int
name|h
decl_stmt|;
comment|/* Hash value for entity name. */
name|UNS
name|size
decl_stmt|;
comment|/* Size of structures pointed to by table. */
block|{
name|struct
name|hash
modifier|*
name|np
decl_stmt|;
if|if
condition|(
operator|(
name|np
operator|=
name|hfind
argument_list|(
name|htab
argument_list|,
name|name
argument_list|,
name|h
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|np
return|;
comment|/* Return if name found. */
comment|/* Allocate space for structure and name. */
name|np
operator|=
operator|(
expr|struct
name|hash
operator|*
operator|)
name|rmalloc
argument_list|(
name|size
operator|+
name|name
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|np
operator|->
name|ename
operator|=
operator|(
name|UNCH
operator|*
operator|)
name|np
operator|+
name|size
expr_stmt|;
name|memcpy
argument_list|(
name|np
operator|->
name|ename
argument_list|,
name|name
argument_list|,
name|name
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* Store name in it. */
name|np
operator|->
name|enext
operator|=
name|htab
index|[
name|h
index|]
expr_stmt|;
comment|/* 1st entry is now 2nd.*/
name|htab
index|[
name|h
index|]
operator|=
name|np
expr_stmt|;
comment|/* New entry is now 1st.*/
return|return
name|np
return|;
comment|/* Return new entry ptr. */
block|}
end_function

begin_comment
comment|/* HOUT: Remove an entry from a hash table and return its pointer.          The caller must free any pointers in the entry and then          free the entry itself if that is what is desired; this          routine does not free any storage. */
end_comment

begin_function
name|struct
name|hash
modifier|*
name|hout
parameter_list|(
name|htab
parameter_list|,
name|s
parameter_list|,
name|h
parameter_list|)
name|struct
name|hash
modifier|*
name|htab
index|[]
decl_stmt|;
comment|/* Hash table. */
name|UNCH
modifier|*
name|s
decl_stmt|;
comment|/* Search argument entry name. */
name|int
name|h
decl_stmt|;
comment|/* Hash value for search entry name. */
block|{
name|struct
name|hash
modifier|*
modifier|*
name|pp
decl_stmt|;
for|for
control|(
name|pp
operator|=
operator|&
name|htab
index|[
name|h
index|]
init|;
operator|*
name|pp
operator|!=
literal|0
condition|;
name|pp
operator|=
operator|&
operator|(
operator|*
name|pp
operator|)
operator|->
name|enext
control|)
if|if
condition|(
name|ustrcmp
argument_list|(
name|s
argument_list|,
operator|(
operator|*
name|pp
operator|)
operator|->
name|ename
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Found it. */
name|struct
name|hash
modifier|*
name|tem
init|=
operator|*
name|pp
decl_stmt|;
operator|*
name|pp
operator|=
operator|(
operator|*
name|pp
operator|)
operator|->
name|enext
expr_stmt|;
return|return
name|tem
return|;
block|}
return|return
literal|0
return|;
comment|/* NULL if not found; else ptr. */
block|}
end_function

begin_comment
comment|/* SAVESTR: Save a null-terminated string */
end_comment

begin_function
name|UNCH
modifier|*
name|savestr
parameter_list|(
name|s
parameter_list|)
name|UNCH
modifier|*
name|s
decl_stmt|;
block|{
name|UNCH
modifier|*
name|rp
decl_stmt|;
name|rp
operator|=
operator|(
name|UNCH
operator|*
operator|)
name|rmalloc
argument_list|(
name|ustrlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ustrcpy
argument_list|(
name|rp
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
name|rp
return|;
block|}
end_function

begin_comment
comment|/* SAVENM: Save a name (with length and EOS) */
end_comment

begin_function
name|UNCH
modifier|*
name|savenm
parameter_list|(
name|s
parameter_list|)
name|UNCH
modifier|*
name|s
decl_stmt|;
block|{
name|UNCH
modifier|*
name|p
decl_stmt|;
name|p
operator|=
operator|(
name|UNCH
operator|*
operator|)
name|rmalloc
argument_list|(
operator|*
name|s
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|p
argument_list|,
name|s
argument_list|,
operator|*
name|s
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* REPLACE: Free the storage for the old string (p) and store the new (s).             If the specified ptr is NULL, don't free it. */
end_comment

begin_function
name|UNCH
modifier|*
name|replace
parameter_list|(
name|p
parameter_list|,
name|s
parameter_list|)
name|UNCH
modifier|*
name|p
decl_stmt|;
name|UNCH
modifier|*
name|s
decl_stmt|;
block|{
if|if
condition|(
name|p
condition|)
name|frem
argument_list|(
operator|(
name|UNIV
operator|)
name|p
argument_list|)
expr_stmt|;
comment|/* Free old storage (if any). */
if|if
condition|(
operator|!
name|s
condition|)
return|return
operator|(
name|s
operator|)
return|;
comment|/* Return NULL if new string is NULL. */
return|return
name|savestr
argument_list|(
name|s
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* RMALLOC: Interface to memory allocation with error handling.             If storage is not available, fatal error message is issued.             Storage is initialized to zeros. */
end_comment

begin_function
name|UNIV
name|rmalloc
parameter_list|(
name|size
parameter_list|)
name|unsigned
name|size
decl_stmt|;
comment|/* Number of bytes of initialized storage. */
block|{
name|UNIV
name|p
init|=
operator|(
name|UNIV
operator|)
name|calloc
argument_list|(
name|size
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
name|exiterr
argument_list|(
literal|33
argument_list|,
operator|(
expr|struct
name|parse
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_function
name|UNIV
name|rrealloc
parameter_list|(
name|p
parameter_list|,
name|n
parameter_list|)
name|UNIV
name|p
decl_stmt|;
name|UNS
name|n
decl_stmt|;
block|{
name|UNIV
name|r
init|=
name|realloc
argument_list|(
name|p
argument_list|,
name|n
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
name|exiterr
argument_list|(
literal|33
argument_list|,
operator|(
expr|struct
name|parse
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_decl_stmt
name|UNCH
modifier|*
name|pt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* FREM: Free specified memory area gotten with rmalloc(). */
end_comment

begin_function
name|VOID
name|frem
parameter_list|(
name|ptr
parameter_list|)
name|UNIV
name|ptr
decl_stmt|;
comment|/* Memory area to be freed. */
block|{
name|free
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* MAPSRCH: Find a string in a table and return its associated value.             The last entry must be a dummy consisting of a NULL pointer for             the string and whatever return code is desired if the             string is not found in the table. */
end_comment

begin_function
name|int
name|mapsrch
parameter_list|(
name|maptab
parameter_list|,
name|name
parameter_list|)
name|struct
name|map
name|maptab
index|[]
decl_stmt|;
name|UNCH
modifier|*
name|name
decl_stmt|;
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
do|do
block|{
name|UNCH
modifier|*
name|mapnm
decl_stmt|,
modifier|*
name|nm
decl_stmt|;
for|for
control|(
name|mapnm
operator|=
name|maptab
index|[
name|i
index|]
operator|.
name|mapnm
operator|,
name|nm
operator|=
name|name
init|;
operator|*
name|nm
operator|==
operator|*
name|mapnm
condition|;
name|mapnm
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|*
name|nm
operator|++
condition|)
return|return
name|maptab
index|[
name|i
index|]
operator|.
name|mapdata
return|;
block|}
block|}
do|while
condition|(
name|maptab
index|[
operator|++
name|i
index|]
operator|.
name|mapnm
condition|)
do|;
return|return
name|maptab
index|[
name|i
index|]
operator|.
name|mapdata
return|;
block|}
end_function

begin_comment
comment|/* IDDEF: Define an ID control block; return -1 if it already exists. */
end_comment

begin_function
name|int
name|iddef
parameter_list|(
name|iname
parameter_list|)
name|UNCH
modifier|*
name|iname
decl_stmt|;
comment|/* ID name (with length and EOS). */
block|{
name|PID
name|p
decl_stmt|;
name|struct
name|fwdref
modifier|*
name|r
decl_stmt|;
name|p
operator|=
operator|(
name|PID
operator|)
name|hin
argument_list|(
operator|(
name|THASH
operator|)
name|itab
argument_list|,
name|iname
argument_list|,
name|hash
argument_list|(
name|iname
argument_list|,
name|IDHASH
argument_list|)
argument_list|,
name|IDSZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|iddefed
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|p
operator|->
name|iddefed
operator|=
literal|1
expr_stmt|;
name|TRACEID
argument_list|(
literal|"IDDEF"
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* Delete any forward references. */
name|r
operator|=
name|p
operator|->
name|idrl
expr_stmt|;
name|p
operator|->
name|idrl
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|r
condition|)
block|{
name|struct
name|fwdref
modifier|*
name|tem
init|=
name|r
operator|->
name|next
decl_stmt|;
if|if
condition|(
name|r
operator|->
name|msg
condition|)
name|msgsfree
argument_list|(
name|r
operator|->
name|msg
argument_list|)
expr_stmt|;
name|frem
argument_list|(
operator|(
name|UNIV
operator|)
name|r
argument_list|)
expr_stmt|;
name|r
operator|=
name|tem
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* IDREF: Store a reference to an ID and define the ID if it doesn't yet exist.           Return 0 if already defined, otherwise pointer to a fwdref. */
end_comment

begin_function
name|struct
name|fwdref
modifier|*
name|idref
parameter_list|(
name|iname
parameter_list|)
name|UNCH
modifier|*
name|iname
decl_stmt|;
comment|/* ID name (with length and EOS). */
block|{
name|PID
name|p
decl_stmt|;
name|int
name|hnum
decl_stmt|;
name|struct
name|fwdref
modifier|*
name|rp
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
operator|(
name|PID
operator|)
name|hfind
argument_list|(
operator|(
name|THASH
operator|)
name|itab
argument_list|,
name|iname
argument_list|,
operator|(
name|hnum
operator|=
name|hash
argument_list|(
name|iname
argument_list|,
name|IDHASH
argument_list|)
operator|)
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|p
operator|=
operator|(
name|PID
operator|)
name|hin
argument_list|(
operator|(
name|THASH
operator|)
name|itab
argument_list|,
name|iname
argument_list|,
name|hnum
argument_list|,
name|IDSZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|iddefed
condition|)
return|return
literal|0
return|;
name|rp
operator|=
operator|(
expr|struct
name|fwdref
operator|*
operator|)
name|rmalloc
argument_list|(
name|FWDREFSZ
argument_list|)
expr_stmt|;
name|rp
operator|->
name|next
operator|=
name|p
operator|->
name|idrl
expr_stmt|;
name|p
operator|->
name|idrl
operator|=
name|rp
expr_stmt|;
name|rp
operator|->
name|msg
operator|=
literal|0
expr_stmt|;
name|TRACEID
argument_list|(
literal|"IDREF"
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
name|rp
return|;
block|}
end_function

begin_comment
comment|/* IDRCK: Check idrefs. */
end_comment

begin_function
name|VOID
name|idrck
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|PID
name|p
decl_stmt|;
name|struct
name|fwdref
modifier|*
name|r
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IDHASH
condition|;
name|i
operator|++
control|)
for|for
control|(
name|p
operator|=
name|itab
index|[
name|i
index|]
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|idnext
control|)
if|if
condition|(
operator|!
name|p
operator|->
name|iddefed
condition|)
for|for
control|(
name|r
operator|=
name|p
operator|->
name|idrl
init|;
name|r
condition|;
name|r
operator|=
name|r
operator|->
name|next
control|)
name|svderr
argument_list|(
name|r
operator|->
name|msg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* NTOA: Converts a positive integer to an ASCII string (abuf)          No leading zeros are generated. */
end_comment

begin_function
name|UNCH
modifier|*
name|ntoa
parameter_list|(
name|i
parameter_list|)
name|int
name|i
decl_stmt|;
block|{
specifier|static
name|UNCH
name|buf
index|[
literal|1
operator|+
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|+
literal|1
index|]
decl_stmt|;
name|sprintf
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
literal|"%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_comment
comment|/* Local Variables: c-indent-level: 5 c-continued-statement-offset: 5 c-brace-offset: -5 c-argdecl-indent: 0 c-label-offset: -5 comment-column: 30 End: */
end_comment

end_unit

