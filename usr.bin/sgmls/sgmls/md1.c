begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"sgmlincl.h"
end_include

begin_comment
comment|/* #INCLUDE statements for SGML parser. */
end_comment

begin_comment
comment|/* MDADL: Process ATTLIST declaration. */
end_comment

begin_function
name|VOID
name|mdadl
parameter_list|(
name|tbuf
parameter_list|)
name|UNCH
modifier|*
name|tbuf
decl_stmt|;
comment|/* Work area for tokenization (tbuf). */
block|{
name|int
name|i
decl_stmt|;
comment|/* Loop counter; temporary variable. */
name|int
name|adlim
decl_stmt|;
comment|/* Number of unused ad slots in al. */
name|struct
name|ad
modifier|*
name|alperm
init|=
literal|0
decl_stmt|;
comment|/* Attribute definition list. */
name|int
name|stored
init|=
literal|0
decl_stmt|;
name|mdname
operator|=
name|key
index|[
name|KATTLIST
index|]
expr_stmt|;
comment|/* Identify declaration for messages. */
name|subdcl
operator|=
literal|0
expr_stmt|;
comment|/* No subject as yet. */
name|parmno
operator|=
literal|0
expr_stmt|;
comment|/* No parameters as yet. */
name|mdessv
operator|=
name|es
expr_stmt|;
comment|/* Save es level for entity nesting check. */
name|reqadn
operator|=
name|noteadn
operator|=
literal|0
expr_stmt|;
comment|/* No required attributes yet. */
name|idadn
operator|=
name|conradn
operator|=
literal|0
expr_stmt|;
comment|/* No special atts yet.*/
name|AN
argument_list|(
name|al
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Number of attributes defined. */
name|ADN
argument_list|(
name|al
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Number of ad's in al (atts + name vals).*/
comment|/* PARAMETER 1: Element name or a group of them.      */
name|parsemd
argument_list|(
name|tbuf
argument_list|,
name|NAMECASE
argument_list|,
operator|&
name|pcblitp
argument_list|,
name|NAMELEN
argument_list|)
expr_stmt|;
name|TRACEMD
argument_list|(
literal|"1: element name or group"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pcbmd
operator|.
name|action
condition|)
block|{
case|case
name|NAS
case|:
name|nmgrp
index|[
literal|0
index|]
operator|=
name|etddef
argument_list|(
name|tbuf
argument_list|)
expr_stmt|;
name|nmgrp
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|GRPS
case|:
name|parsegrp
argument_list|(
name|nmgrp
argument_list|,
operator|&
name|pcbgrnm
argument_list|,
name|tbuf
argument_list|)
expr_stmt|;
break|break;
case|case
name|RNS
case|:
comment|/* Reserved name started. */
if|if
condition|(
name|ustrcmp
argument_list|(
name|tbuf
operator|+
literal|1
argument_list|,
name|key
index|[
name|KNOTATION
index|]
argument_list|)
condition|)
block|{
name|mderr
argument_list|(
literal|118
argument_list|,
name|tbuf
operator|+
literal|1
argument_list|,
name|key
index|[
name|KNOTATION
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
name|mdnadl
argument_list|(
name|tbuf
argument_list|)
expr_stmt|;
return|return;
default|default:
name|mderr
argument_list|(
literal|121
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Save first GI for error msgs. */
if|if
condition|(
name|nmgrp
index|[
literal|0
index|]
condition|)
name|subdcl
operator|=
name|nmgrp
index|[
literal|0
index|]
operator|->
name|etdgi
operator|+
literal|1
expr_stmt|;
comment|/* PARAMETER 2: Attribute definition list.      */
name|parsemd
argument_list|(
name|tbuf
argument_list|,
name|NAMECASE
argument_list|,
operator|&
name|pcblitp
argument_list|,
name|NAMELEN
argument_list|)
expr_stmt|;
name|TRACEMD
argument_list|(
literal|"2: attribute list"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcbmd
operator|.
name|action
operator|!=
name|NAS
condition|)
block|{
name|mderr
argument_list|(
literal|120
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|pcbmd
operator|.
name|action
operator|==
name|NAS
condition|)
block|{
name|al
index|[
name|ADN
argument_list|(
name|al
argument_list|)
operator|+
literal|1
index|]
operator|.
name|adname
operator|=
name|savenm
argument_list|(
name|tbuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|adlim
operator|=
name|ATTCNT
operator|-
operator|(
operator|(
name|int
operator|)
operator|++
name|ADN
argument_list|(
name|al
argument_list|)
operator|)
operator|)
operator|<
literal|0
condition|)
block|{
name|mderr
argument_list|(
literal|111
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|adlfree
argument_list|(
name|al
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
operator|++
name|AN
argument_list|(
name|al
argument_list|)
expr_stmt|;
if|if
condition|(
name|mdattdef
argument_list|(
name|adlim
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|adlfree
argument_list|(
name|al
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
name|parsemd
argument_list|(
name|tbuf
argument_list|,
name|NAMECASE
argument_list|,
operator|&
name|pcblitp
argument_list|,
name|NAMELEN
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|AN
argument_list|(
name|al
argument_list|)
operator|>
literal|0
condition|)
block|{
comment|/*  Save list only if 1 or more good atts. */
if|if
condition|(
name|reqadn
condition|)
name|SET
argument_list|(
name|ADLF
argument_list|(
name|al
argument_list|)
argument_list|,
name|ADLREQ
argument_list|)
expr_stmt|;
comment|/* Element must have start-tag. */
if|if
condition|(
name|noteadn
condition|)
name|SET
argument_list|(
name|ADLF
argument_list|(
name|al
argument_list|)
argument_list|,
name|ADLNOTE
argument_list|)
expr_stmt|;
comment|/* Element cannot be EMPTY. */
if|if
condition|(
name|conradn
condition|)
name|SET
argument_list|(
name|ADLF
argument_list|(
name|al
argument_list|)
argument_list|,
name|ADLCONR
argument_list|)
expr_stmt|;
comment|/* Element cannot be EMPTY. */
name|alperm
operator|=
operator|(
expr|struct
name|ad
operator|*
operator|)
name|rmalloc
argument_list|(
operator|(
literal|1
operator|+
name|ADN
argument_list|(
name|al
argument_list|)
operator|)
operator|*
name|ADSZ
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|UNIV
operator|)
name|alperm
argument_list|,
operator|(
name|UNIV
operator|)
name|al
argument_list|,
operator|(
literal|1
operator|+
name|ADN
argument_list|(
name|al
argument_list|)
operator|)
operator|*
name|ADSZ
argument_list|)
expr_stmt|;
name|ds
operator|.
name|attcnt
operator|+=
name|AN
argument_list|(
name|al
argument_list|)
expr_stmt|;
comment|/* Number of attributes defined. */
name|ds
operator|.
name|attgcnt
operator|+=
name|ADN
argument_list|(
name|al
argument_list|)
operator|-
name|AN
argument_list|(
name|al
argument_list|)
expr_stmt|;
comment|/* Number of att grp members. */
name|TRACEADL
argument_list|(
name|alperm
argument_list|)
expr_stmt|;
block|}
comment|/* Clear attribute list for next declaration. */
name|MEMZERO
argument_list|(
operator|(
name|UNIV
operator|)
name|al
argument_list|,
operator|(
literal|1
operator|+
name|ADN
argument_list|(
name|al
argument_list|)
operator|)
operator|*
name|ADSZ
argument_list|)
expr_stmt|;
comment|/* PARAMETER 3: End of declaration.      */
comment|/* Next pcb.action was set during attribute definition loop. */
name|TRACEMD
argument_list|(
name|emd
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcbmd
operator|.
name|action
operator|!=
name|EMD
condition|)
block|{
name|mderr
argument_list|(
literal|126
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|es
operator|!=
name|mdessv
condition|)
name|synerr
argument_list|(
literal|37
argument_list|,
operator|&
name|pcbmd
argument_list|)
expr_stmt|;
comment|/* EXECUTE: Store the definition for each element name specified.      */
name|TRACEGRP
argument_list|(
name|nmgrp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|nmgrp
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|nmgrp
index|[
name|i
index|]
operator|->
name|adl
condition|)
block|{
comment|/* Error if an ADL exists. */
name|mderr
argument_list|(
literal|112
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|nmgrp
index|[
name|i
index|]
operator|->
name|adl
operator|=
name|alperm
expr_stmt|;
comment|/* If virgin, store the adl ptr. */
name|stored
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|alperm
operator|&&
name|nmgrp
index|[
name|i
index|]
operator|->
name|etdmod
condition|)
name|etdadl
argument_list|(
name|nmgrp
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* Check for conflicts with ETD. */
block|}
if|if
condition|(
operator|!
name|stored
operator|&&
name|alperm
condition|)
block|{
name|adlfree
argument_list|(
name|alperm
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|frem
argument_list|(
operator|(
name|UNIV
operator|)
name|alperm
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ETDADL: Check compatibility between ETD and ADL. */
end_comment

begin_function
name|VOID
name|etdadl
parameter_list|(
name|p
parameter_list|)
name|struct
name|etd
modifier|*
name|p
decl_stmt|;
comment|/* Pointer to element type definition. */
block|{
name|parmno
operator|=
literal|0
expr_stmt|;
comment|/* Minimizable element cannot have required attribute. */
if|if
condition|(
name|GET
argument_list|(
name|p
operator|->
name|etdmin
argument_list|,
name|SMO
argument_list|)
operator|&&
name|GET
argument_list|(
name|p
operator|->
name|adl
index|[
literal|0
index|]
operator|.
name|adflags
argument_list|,
name|ADLREQ
argument_list|)
condition|)
block|{
name|mderr
argument_list|(
literal|40
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|RESET
argument_list|(
name|p
operator|->
name|etdmin
argument_list|,
name|SMO
argument_list|)
expr_stmt|;
block|}
comment|/* Empty element cannot have NOTATION attribute.         Attribute is not removed (too much trouble), but we trap         attempts to specify it on the start-tag in adlval().      */
if|if
condition|(
name|GET
argument_list|(
name|p
operator|->
name|etdmod
operator|->
name|ttype
argument_list|,
name|MNONE
argument_list|)
condition|)
block|{
if|if
condition|(
name|GET
argument_list|(
name|p
operator|->
name|adl
index|[
literal|0
index|]
operator|.
name|adflags
argument_list|,
name|ADLNOTE
argument_list|)
condition|)
name|mderr
argument_list|(
literal|83
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* Empty element cannot have CONREF attribute.              Attribute is not removed because it just acts              like IMPLIED anyway.           */
if|if
condition|(
name|GET
argument_list|(
name|p
operator|->
name|adl
index|[
literal|0
index|]
operator|.
name|adflags
argument_list|,
name|ADLCONR
argument_list|)
condition|)
name|mderr
argument_list|(
literal|85
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* "-" should not be specified for the end-tag minimization if 	the element has a content reference attribute. */
block|if (GET(p->adl[0].adflags, ADLCONR)&& BITON(p->etdmin, EMM)) 	  mderr(153, (UNCH *)0, (UNCH *)0);
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* MDNADL: Process ATTLIST declaration for notation.            TO DO: Pass deftab and dvtab as parameters so            that prohibited types can be handled by leaving            them out of the tables. */
end_comment

begin_function
name|VOID
name|mdnadl
parameter_list|(
name|tbuf
parameter_list|)
name|UNCH
modifier|*
name|tbuf
decl_stmt|;
comment|/* Work area for tokenization (tbuf). */
block|{
name|int
name|i
decl_stmt|;
comment|/* Loop counter; temporary variable. */
name|int
name|adlim
decl_stmt|;
comment|/* Number of unused ad slots in al. */
name|struct
name|ad
modifier|*
name|alperm
init|=
literal|0
decl_stmt|;
comment|/* Attribute definition list. */
name|int
name|stored
init|=
literal|0
decl_stmt|;
comment|/* PARAMETER 1: Notation name or a group of them.      */
name|parsemd
argument_list|(
name|tbuf
argument_list|,
name|NAMECASE
argument_list|,
operator|&
name|pcblitp
argument_list|,
name|NAMELEN
argument_list|)
expr_stmt|;
name|TRACEMD
argument_list|(
literal|"1: notation name or group"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pcbmd
operator|.
name|action
condition|)
block|{
case|case
name|NAS
case|:
name|nnmgrp
index|[
literal|0
index|]
operator|=
name|dcndef
argument_list|(
name|tbuf
argument_list|)
expr_stmt|;
name|nnmgrp
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|GRPS
case|:
name|parsngrp
argument_list|(
name|nnmgrp
argument_list|,
operator|&
name|pcbgrnm
argument_list|,
name|tbuf
argument_list|)
expr_stmt|;
break|break;
default|default:
name|mderr
argument_list|(
literal|121
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|subdcl
operator|=
name|nnmgrp
index|[
literal|0
index|]
operator|->
name|ename
operator|+
literal|1
expr_stmt|;
comment|/* Save first name for error msgs. */
comment|/* PARAMETER 2: Attribute definition list.      */
name|parsemd
argument_list|(
name|tbuf
argument_list|,
name|NAMECASE
argument_list|,
operator|&
name|pcblitp
argument_list|,
name|NAMELEN
argument_list|)
expr_stmt|;
name|TRACEMD
argument_list|(
literal|"2: attribute list"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcbmd
operator|.
name|action
operator|!=
name|NAS
condition|)
block|{
name|mderr
argument_list|(
literal|120
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|pcbmd
operator|.
name|action
operator|==
name|NAS
condition|)
block|{
name|al
index|[
name|ADN
argument_list|(
name|al
argument_list|)
operator|+
literal|1
index|]
operator|.
name|adname
operator|=
name|savenm
argument_list|(
name|tbuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|adlim
operator|=
name|ATTCNT
operator|-
operator|(
operator|(
name|int
operator|)
name|ADN
argument_list|(
name|al
argument_list|)
operator|++
operator|)
operator|)
operator|<
literal|0
condition|)
block|{
name|mderr
argument_list|(
literal|111
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|adlfree
argument_list|(
name|al
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
operator|++
name|AN
argument_list|(
name|al
argument_list|)
expr_stmt|;
if|if
condition|(
name|mdattdef
argument_list|(
name|adlim
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|adlfree
argument_list|(
name|al
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
name|parsemd
argument_list|(
name|tbuf
argument_list|,
name|NAMECASE
argument_list|,
operator|&
name|pcblitp
argument_list|,
name|NAMELEN
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|AN
argument_list|(
name|al
argument_list|)
operator|>
literal|0
condition|)
block|{
comment|/*  Save list only if 1 or more good atts. */
name|alperm
operator|=
operator|(
expr|struct
name|ad
operator|*
operator|)
name|rmalloc
argument_list|(
operator|(
literal|1
operator|+
name|ADN
argument_list|(
name|al
argument_list|)
operator|)
operator|*
name|ADSZ
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|UNIV
operator|)
name|alperm
argument_list|,
operator|(
name|UNIV
operator|)
name|al
argument_list|,
operator|(
literal|1
operator|+
name|ADN
argument_list|(
name|al
argument_list|)
operator|)
operator|*
name|ADSZ
argument_list|)
expr_stmt|;
name|ds
operator|.
name|attcnt
operator|+=
name|AN
argument_list|(
name|al
argument_list|)
expr_stmt|;
comment|/* Number of attributes defined. */
name|ds
operator|.
name|attgcnt
operator|+=
name|ADN
argument_list|(
name|al
argument_list|)
operator|-
name|AN
argument_list|(
name|al
argument_list|)
expr_stmt|;
comment|/* Number of att grp members. */
name|TRACEADL
argument_list|(
name|alperm
argument_list|)
expr_stmt|;
block|}
comment|/* Clear attribute list for next declaration. */
name|MEMZERO
argument_list|(
operator|(
name|UNIV
operator|)
name|al
argument_list|,
operator|(
literal|1
operator|+
name|ADN
argument_list|(
name|al
argument_list|)
operator|)
operator|*
name|ADSZ
argument_list|)
expr_stmt|;
comment|/* PARAMETER 3: End of declaration.      */
comment|/* Next pcb.action was set during attribute definition loop. */
name|TRACEMD
argument_list|(
name|emd
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcbmd
operator|.
name|action
operator|!=
name|EMD
condition|)
block|{
name|mderr
argument_list|(
literal|126
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|es
operator|!=
name|mdessv
condition|)
name|synerr
argument_list|(
literal|37
argument_list|,
operator|&
name|pcbmd
argument_list|)
expr_stmt|;
comment|/* EXECUTE: Store the definition for each notation name specified.      */
name|TRACENGR
argument_list|(
name|nnmgrp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|nnmgrp
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|nnmgrp
index|[
name|i
index|]
operator|->
name|adl
condition|)
block|{
comment|/* Error if an ADL exists. */
name|mderr
argument_list|(
literal|112
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|nnmgrp
index|[
name|i
index|]
operator|->
name|adl
operator|=
name|alperm
expr_stmt|;
comment|/* If virgin, store the adl ptr. */
if|if
condition|(
name|nnmgrp
index|[
name|i
index|]
operator|->
name|entsw
condition|)
name|fixdatt
argument_list|(
name|nnmgrp
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|stored
operator|=
literal|1
expr_stmt|;
name|TRACEDCN
argument_list|(
name|nnmgrp
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|stored
operator|&&
name|alperm
condition|)
block|{
name|adlfree
argument_list|(
name|alperm
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|frem
argument_list|(
operator|(
name|UNIV
operator|)
name|alperm
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Data attributes have been specified for notation p, but entities have already been declared with notation p.  Fix up the definitions of all entities with notation p.  Generate an error for any data attribute that was required. */
end_comment

begin_function
name|VOID
name|fixdatt
parameter_list|(
name|p
parameter_list|)
name|struct
name|dcncb
modifier|*
name|p
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ENTHASH
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|entity
modifier|*
name|ep
decl_stmt|;
for|for
control|(
name|ep
operator|=
name|etab
index|[
name|i
index|]
init|;
name|ep
condition|;
name|ep
operator|=
name|ep
operator|->
name|enext
control|)
if|if
condition|(
name|ep
operator|->
name|estore
operator|==
name|ESN
operator|&&
name|ep
operator|->
name|etx
operator|.
name|n
operator|&&
name|ep
operator|->
name|etx
operator|.
name|n
operator|->
name|nedcn
operator|==
name|p
condition|)
block|{
name|int
name|adn
decl_stmt|;
name|initatt
argument_list|(
name|p
operator|->
name|adl
argument_list|)
expr_stmt|;
comment|/* Don't use adlval because if there were required 		       attributes the error message wouldn't say what 		       entity was involved. */
for|for
control|(
name|adn
operator|=
literal|1
init|;
name|adn
operator|<=
name|ADN
argument_list|(
name|al
argument_list|)
condition|;
name|adn
operator|++
control|)
block|{
if|if
condition|(
name|GET
argument_list|(
name|ADFLAGS
argument_list|(
name|al
argument_list|,
name|adn
argument_list|)
argument_list|,
name|AREQ
argument_list|)
condition|)
block|{
name|sgmlerr
argument_list|(
literal|218
argument_list|,
operator|&
name|pcbstag
argument_list|,
name|ADNAME
argument_list|(
name|al
argument_list|,
name|adn
argument_list|)
argument_list|,
name|ep
operator|->
name|ename
operator|+
literal|1
argument_list|)
expr_stmt|;
name|SET
argument_list|(
name|ADFLAGS
argument_list|(
name|al
argument_list|,
name|adn
argument_list|)
argument_list|,
name|AINVALID
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|BITON
argument_list|(
name|ADFLAGS
argument_list|(
name|al
argument_list|,
name|adn
argument_list|)
argument_list|,
name|AGROUP
argument_list|)
condition|)
name|adn
operator|+=
name|ADNUM
argument_list|(
name|al
argument_list|,
name|adn
argument_list|)
expr_stmt|;
block|}
name|storedatt
argument_list|(
name|ep
operator|->
name|etx
operator|.
name|n
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* MDATTDEF: Process an individual attribute definition.              The attribute name is parsed by the caller.              Duplicate attributes are parsed, but removed from list.              Returns 0 if successful, otherwise returns 1. */
end_comment

begin_function
name|int
name|mdattdef
parameter_list|(
name|adlim
parameter_list|,
name|datt
parameter_list|)
name|int
name|adlim
decl_stmt|;
comment|/* Remaining capacity of al (in tokens).*/
name|int
name|datt
decl_stmt|;
comment|/* Non-zero if a data attribute. */
block|{
name|int
name|deftype
decl_stmt|;
comment|/* Default value type: 0=not keyword. */
name|int
name|errsw
init|=
literal|0
decl_stmt|;
comment|/* 1=semantic error; ignore att. */
name|int
name|novalsw
init|=
literal|0
decl_stmt|;
comment|/* 1=semantic error; treat as IMPLIED. */
name|int
name|attadn
init|=
operator|(
name|int
operator|)
name|ADN
argument_list|(
name|al
argument_list|)
decl_stmt|;
comment|/* Save ad number of this attribute. */
name|struct
name|parse
modifier|*
name|grppcb
init|=
name|NULL
decl_stmt|;
comment|/* PCB for name/token grp parse. */
name|int
name|errcode
decl_stmt|;
comment|/* Error type returned by PARSEVAL, ANMTGRP. */
name|UNCH
modifier|*
name|advalsv
decl_stmt|;
comment|/* Save area for permanent value ptr. */
comment|/* PARAMETER 1: Attribute name (parsed by caller).      */
name|TRACEMD
argument_list|(
literal|"1: attribute name"
argument_list|)
expr_stmt|;
if|if
condition|(
name|anmget
argument_list|(
operator|(
name|int
operator|)
name|ADN
argument_list|(
name|al
argument_list|)
operator|-
literal|1
argument_list|,
name|al
index|[
name|attadn
index|]
operator|.
name|adname
argument_list|)
condition|)
block|{
name|errsw
operator|=
literal|1
expr_stmt|;
name|mderr
argument_list|(
literal|99
argument_list|,
name|ADNAME
argument_list|(
name|al
argument_list|,
name|attadn
argument_list|)
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
name|ADNUM
argument_list|(
name|al
argument_list|,
name|attadn
argument_list|)
operator|=
name|ADFLAGS
argument_list|(
name|al
argument_list|,
name|attadn
argument_list|)
operator|=
name|ADLEN
argument_list|(
name|al
argument_list|,
name|attadn
argument_list|)
operator|=
literal|0
expr_stmt|;
name|ADVAL
argument_list|(
name|al
argument_list|,
name|attadn
argument_list|)
operator|=
literal|0
expr_stmt|;
name|ADDATA
argument_list|(
name|al
argument_list|,
name|attadn
argument_list|)
operator|.
name|x
operator|=
literal|0
expr_stmt|;
name|ADTYPE
argument_list|(
name|al
argument_list|,
name|attadn
argument_list|)
operator|=
name|ANMTGRP
expr_stmt|;
comment|/* PARAMETER 2: Declared value.      */
name|parsemd
argument_list|(
name|lbuf
argument_list|,
name|NAMECASE
argument_list|,
operator|&
name|pcblitp
argument_list|,
name|NAMELEN
argument_list|)
expr_stmt|;
name|TRACEMD
argument_list|(
literal|"2: declared value"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pcbmd
operator|.
name|action
condition|)
block|{
case|case
name|NAS
case|:
comment|/* Keyword for value type. */
switch|switch
condition|(
name|ADTYPE
argument_list|(
name|al
argument_list|,
name|attadn
argument_list|)
operator|=
operator|(
name|UNCH
operator|)
name|mapsrch
argument_list|(
name|dvtab
argument_list|,
name|lbuf
operator|+
literal|1
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
name|mderr
argument_list|(
literal|100
argument_list|,
name|ADNAME
argument_list|(
name|al
argument_list|,
name|attadn
argument_list|)
argument_list|,
name|lbuf
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|ANOTEGRP
case|:
if|if
condition|(
name|datt
condition|)
block|{
name|errsw
operator|=
literal|1
expr_stmt|;
name|mderr
argument_list|(
literal|156
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|noteadn
condition|)
name|noteadn
operator|=
name|ADN
argument_list|(
name|al
argument_list|)
expr_stmt|;
else|else
block|{
name|errsw
operator|=
literal|1
expr_stmt|;
name|mderr
argument_list|(
literal|101
argument_list|,
name|ADNAME
argument_list|(
name|al
argument_list|,
name|attadn
argument_list|)
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
name|grppcb
operator|=
operator|&
name|pcbgrnm
expr_stmt|;
comment|/* NOTATION requires name grp. */
name|parsemd
argument_list|(
name|lbuf
argument_list|,
name|NAMECASE
argument_list|,
operator|&
name|pcblitp
argument_list|,
name|NAMELEN
argument_list|)
expr_stmt|;
comment|/* Get GRPO*/
break|break;
case|case
name|AID
case|:
if|if
condition|(
name|datt
condition|)
block|{
name|errsw
operator|=
literal|1
expr_stmt|;
name|mderr
argument_list|(
literal|144
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|idadn
condition|)
name|idadn
operator|=
name|attadn
expr_stmt|;
else|else
block|{
name|errsw
operator|=
literal|1
expr_stmt|;
name|mderr
argument_list|(
literal|102
argument_list|,
name|ADNAME
argument_list|(
name|al
argument_list|,
name|attadn
argument_list|)
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|AIDREF
case|:
case|case
name|AIDREFS
case|:
if|if
condition|(
name|datt
condition|)
block|{
name|errsw
operator|=
literal|1
expr_stmt|;
name|mderr
argument_list|(
literal|155
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|AENTITY
case|:
case|case
name|AENTITYS
case|:
if|if
condition|(
name|datt
condition|)
block|{
name|errsw
operator|=
literal|1
expr_stmt|;
name|mderr
argument_list|(
literal|154
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
break|break;
case|case
name|GRPS
case|:
name|grppcb
operator|=
operator|&
name|pcbgrnt
expr_stmt|;
comment|/* Normal grp is name token grp. */
break|break;
case|case
name|EMD
case|:
name|mderr
argument_list|(
literal|103
argument_list|,
name|ADNAME
argument_list|(
name|al
argument_list|,
name|attadn
argument_list|)
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
default|default:
name|mderr
argument_list|(
literal|104
argument_list|,
name|ADNAME
argument_list|(
name|al
argument_list|,
name|attadn
argument_list|)
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* PARAMETER 2A: Name token group.      */
if|if
condition|(
name|grppcb
operator|!=
name|NULL
condition|)
block|{
name|TRACEMD
argument_list|(
literal|"2A: name group"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pcbmd
operator|.
name|action
condition|)
block|{
case|case
name|GRPS
case|:
comment|/* Name token list. */
name|SET
argument_list|(
name|ADFLAGS
argument_list|(
name|al
argument_list|,
name|attadn
argument_list|)
argument_list|,
name|AGROUP
argument_list|)
expr_stmt|;
comment|/* Call routine to parse group, create ad entries in adl. */
name|errcode
operator|=
name|anmtgrp
argument_list|(
name|grppcb
argument_list|,
name|al
operator|+
name|attadn
argument_list|,
operator|(
name|GRPCNT
operator|<
name|adlim
condition|?
name|GRPCNT
operator|+
literal|1
else|:
name|adlim
operator|+
literal|1
operator|)
argument_list|,
operator|&
name|al
index|[
name|attadn
index|]
operator|.
name|adnum
argument_list|,
name|ADN
argument_list|(
name|al
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|errcode
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|adlim
operator|<
name|GRPCNT
condition|)
name|mderr
argument_list|(
literal|111
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
else|else
name|mderr
argument_list|(
literal|105
argument_list|,
name|ADNAME
argument_list|(
name|al
argument_list|,
name|attadn
argument_list|)
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|ADN
argument_list|(
name|al
argument_list|)
operator|+=
name|ADNUM
argument_list|(
name|al
argument_list|,
name|attadn
argument_list|)
expr_stmt|;
comment|/* Add grp size to total ad cnt.*/
break|break;
default|default:
name|mderr
argument_list|(
literal|106
argument_list|,
name|ADNAME
argument_list|(
name|al
argument_list|,
name|attadn
argument_list|)
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
comment|/* PARAMETER 3: Default value keyword.      */
name|parsemd
argument_list|(
name|lbuf
argument_list|,
name|AVALCASE
argument_list|,
operator|(
name|ADTYPE
argument_list|(
name|al
argument_list|,
name|attadn
argument_list|)
operator|==
name|ACHARS
operator|)
condition|?
operator|&
name|pcblitr
else|:
operator|&
name|pcblitt
argument_list|,
name|LITLEN
argument_list|)
expr_stmt|;
name|TRACEMD
argument_list|(
literal|"3: default keyword"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pcbmd
operator|.
name|action
condition|)
block|{
case|case
name|RNS
case|:
comment|/* Keyword. */
name|deftype
operator|=
name|mapsrch
argument_list|(
name|deftab
argument_list|,
name|lbuf
operator|+
literal|1
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|deftype
condition|)
block|{
case|case
name|DFIXED
case|:
comment|/* FIXED */
name|SET
argument_list|(
name|ADFLAGS
argument_list|(
name|al
argument_list|,
name|attadn
argument_list|)
argument_list|,
name|AFIXED
argument_list|)
expr_stmt|;
name|parsemd
argument_list|(
name|lbuf
argument_list|,
name|AVALCASE
argument_list|,
operator|(
name|ADTYPE
argument_list|(
name|al
argument_list|,
name|attadn
argument_list|)
operator|==
name|ACHARS
operator|)
condition|?
operator|&
name|pcblitr
else|:
operator|&
name|pcblitt
argument_list|,
name|LITLEN
argument_list|)
expr_stmt|;
comment|/* Real default. */
goto|goto
name|parm3x
goto|;
comment|/* Go process specified value. */
case|case
name|DCURR
case|:
comment|/* CURRENT: If ID, treat as IMPLIED. */
if|if
condition|(
name|ADTYPE
argument_list|(
name|al
argument_list|,
name|attadn
argument_list|)
operator|==
name|AID
condition|)
block|{
name|mderr
argument_list|(
literal|80
argument_list|,
name|ADNAME
argument_list|(
name|al
argument_list|,
name|attadn
argument_list|)
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|datt
condition|)
block|{
name|mderr
argument_list|(
literal|157
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
name|SET
argument_list|(
name|ADFLAGS
argument_list|(
name|al
argument_list|,
name|attadn
argument_list|)
argument_list|,
name|ACURRENT
argument_list|)
expr_stmt|;
break|break;
case|case
name|DREQ
case|:
comment|/* REQUIRED */
name|SET
argument_list|(
name|ADFLAGS
argument_list|(
name|al
argument_list|,
name|attadn
argument_list|)
argument_list|,
name|AREQ
argument_list|)
expr_stmt|;
operator|++
name|reqadn
expr_stmt|;
break|break;
case|case
name|DCONR
case|:
comment|/* CONREF */
if|if
condition|(
name|ADTYPE
argument_list|(
name|al
argument_list|,
name|attadn
argument_list|)
operator|==
name|AID
condition|)
block|{
name|mderr
argument_list|(
literal|107
argument_list|,
name|ADNAME
argument_list|(
name|al
argument_list|,
name|attadn
argument_list|)
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|datt
condition|)
block|{
name|mderr
argument_list|(
literal|158
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
name|SET
argument_list|(
name|ADFLAGS
argument_list|(
name|al
argument_list|,
name|attadn
argument_list|)
argument_list|,
name|ACONREF
argument_list|)
expr_stmt|;
name|conradn
operator|=
literal|1
expr_stmt|;
case|case
name|DNULL
case|:
comment|/* IMPLIED */
break|break;
default|default:
comment|/* Unknown keyword is an error. */
name|mderr
argument_list|(
literal|108
argument_list|,
name|ADNAME
argument_list|(
name|al
argument_list|,
name|attadn
argument_list|)
argument_list|,
name|lbuf
operator|+
literal|1
argument_list|)
expr_stmt|;
name|errsw
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|errsw
condition|)
block|{
comment|/* Ignore erroneous att. */
name|adlfree
argument_list|(
name|al
argument_list|,
name|attadn
argument_list|)
expr_stmt|;
operator|--
name|AN
argument_list|(
name|al
argument_list|)
expr_stmt|;
name|ADN
argument_list|(
name|al
argument_list|)
operator|=
operator|(
name|UNCH
operator|)
name|attadn
operator|-
literal|1
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
default|default:
break|break;
block|}
comment|/* PARAMETER 3x: Default value (non-keyword).      */
name|parm3x
label|:
name|TRACEMD
argument_list|(
literal|"3x: default (non-keyword)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ADTYPE
argument_list|(
name|al
argument_list|,
name|attadn
argument_list|)
operator|==
name|AID
condition|)
block|{
comment|/* If ID, treat as IMPLIED. */
name|mderr
argument_list|(
literal|81
argument_list|,
name|ADNAME
argument_list|(
name|al
argument_list|,
name|attadn
argument_list|)
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|novalsw
operator|=
literal|1
expr_stmt|;
comment|/* Keep parsing to keep things straight. */
block|}
switch|switch
condition|(
name|pcbmd
operator|.
name|action
condition|)
block|{
case|case
name|LIT
case|:
comment|/* Literal. */
case|case
name|LITE
case|:
comment|/* Literal. */
comment|/* Null string (except CDATA) is error: msg and treat as IMPLIED. */
if|if
condition|(
operator|*
name|lbuf
operator|==
literal|'\0'
operator|&&
name|ADTYPE
argument_list|(
name|al
argument_list|,
name|attadn
argument_list|)
operator|!=
name|ACHARS
condition|)
block|{
name|mderr
argument_list|(
literal|82
argument_list|,
name|ADNAME
argument_list|(
name|al
argument_list|,
name|attadn
argument_list|)
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|novalsw
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|NAS
case|:
comment|/* Name character string. */
case|case
name|NMT
case|:
comment|/* Name character string. */
case|case
name|NUM
case|:
comment|/* Number or number token string. */
comment|/* The name won't have a length byte because AVALCASE was specified. */
break|break;
case|case
name|CDR
case|:
name|parsetkn
argument_list|(
name|lbuf
argument_list|,
name|NMC
argument_list|,
name|LITLEN
argument_list|)
expr_stmt|;
break|break;
case|case
name|EMD
case|:
name|mderr
argument_list|(
literal|109
argument_list|,
name|ADNAME
argument_list|(
name|al
argument_list|,
name|attadn
argument_list|)
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
default|default:
name|mderr
argument_list|(
literal|110
argument_list|,
name|ADNAME
argument_list|(
name|al
argument_list|,
name|attadn
argument_list|)
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|errsw
condition|)
block|{
comment|/* Ignore erroneous att. */
name|adlfree
argument_list|(
name|al
argument_list|,
name|attadn
argument_list|)
expr_stmt|;
operator|--
name|AN
argument_list|(
name|al
argument_list|)
expr_stmt|;
name|ADN
argument_list|(
name|al
argument_list|)
operator|=
operator|(
name|UNCH
operator|)
name|attadn
operator|-
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|novalsw
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* PARAMETER 3y: Validate and store default value.      */
if|if
condition|(
name|ADTYPE
argument_list|(
name|al
argument_list|,
name|attadn
argument_list|)
operator|==
name|ACHARS
condition|)
block|{
name|UNS
name|len
init|=
name|vallen
argument_list|(
name|ACHARS
argument_list|,
literal|0
argument_list|,
name|lbuf
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|>
name|LITLEN
condition|)
block|{
comment|/* Treat as implied. */
name|sgmlerr
argument_list|(
literal|224
argument_list|,
operator|&
name|pcbmd
argument_list|,
name|ADNAME
argument_list|(
name|al
argument_list|,
name|attadn
argument_list|)
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* No more checking for CDATA value. */
name|ADNUM
argument_list|(
name|al
argument_list|,
name|attadn
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* CDATA is 0 tokens. */
name|ADVAL
argument_list|(
name|al
argument_list|,
name|attadn
argument_list|)
operator|=
name|savestr
argument_list|(
name|lbuf
argument_list|)
expr_stmt|;
comment|/* Store default; save ptr. */
name|ADLEN
argument_list|(
name|al
argument_list|,
name|attadn
argument_list|)
operator|=
name|len
expr_stmt|;
name|ds
operator|.
name|attdef
operator|+=
name|len
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Parse value and save token count (GROUP implies 1 token). */
name|advalsv
operator|=
operator|(
name|UNCH
operator|*
operator|)
name|rmalloc
argument_list|(
name|ustrlen
argument_list|(
name|lbuf
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
comment|/* Storage for tokenized value. */
name|errcode
operator|=
name|parseval
argument_list|(
name|lbuf
argument_list|,
operator|(
name|UNS
operator|)
name|ADTYPE
argument_list|(
name|al
argument_list|,
name|attadn
argument_list|)
argument_list|,
name|advalsv
argument_list|)
expr_stmt|;
if|if
condition|(
name|BITOFF
argument_list|(
name|ADFLAGS
argument_list|(
name|al
argument_list|,
name|attadn
argument_list|)
argument_list|,
name|AGROUP
argument_list|)
condition|)
name|ADNUM
argument_list|(
name|al
argument_list|,
name|attadn
argument_list|)
operator|=
operator|(
name|UNCH
operator|)
name|tokencnt
expr_stmt|;
comment|/* If value was invalid, or was a group member that was not in the group,         issue an appropriate message and set the error switch. */
if|if
condition|(
name|errcode
condition|)
block|{
name|sgmlerr
argument_list|(
operator|(
name|UNS
operator|)
name|errcode
argument_list|,
operator|&
name|pcbmd
argument_list|,
name|ADNAME
argument_list|(
name|al
argument_list|,
name|attadn
argument_list|)
argument_list|,
name|lbuf
argument_list|)
expr_stmt|;
name|errsw
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|BITON
argument_list|(
name|ADFLAGS
argument_list|(
name|al
argument_list|,
name|attadn
argument_list|)
argument_list|,
name|AGROUP
argument_list|)
operator|&&
operator|!
name|amemget
argument_list|(
operator|&
name|al
index|[
name|attadn
index|]
argument_list|,
operator|(
name|int
operator|)
name|ADNUM
argument_list|(
name|al
argument_list|,
name|attadn
argument_list|)
argument_list|,
name|advalsv
argument_list|)
condition|)
block|{
name|sgmlerr
argument_list|(
literal|79
argument_list|,
operator|&
name|pcbmd
argument_list|,
name|ADNAME
argument_list|(
name|al
argument_list|,
name|attadn
argument_list|)
argument_list|,
name|advalsv
operator|+
literal|1
argument_list|)
expr_stmt|;
name|errsw
operator|=
literal|1
expr_stmt|;
block|}
name|ADLEN
argument_list|(
name|al
argument_list|,
name|attadn
argument_list|)
operator|=
name|vallen
argument_list|(
name|ADTYPE
argument_list|(
name|al
argument_list|,
name|attadn
argument_list|)
argument_list|,
name|ADNUM
argument_list|(
name|al
argument_list|,
name|attadn
argument_list|)
argument_list|,
name|advalsv
argument_list|)
expr_stmt|;
if|if
condition|(
name|ADLEN
argument_list|(
name|al
argument_list|,
name|attadn
argument_list|)
operator|>
name|LITLEN
condition|)
block|{
name|sgmlerr
argument_list|(
literal|224
argument_list|,
operator|&
name|pcbmd
argument_list|,
name|ADNAME
argument_list|(
name|al
argument_list|,
name|attadn
argument_list|)
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|ADLEN
argument_list|(
name|al
argument_list|,
name|attadn
argument_list|)
operator|=
literal|0
expr_stmt|;
name|errsw
operator|=
literal|1
expr_stmt|;
block|}
comment|/* For valid tokenized value, save it and update statistics. */
if|if
condition|(
operator|!
name|errsw
condition|)
block|{
name|ADVAL
argument_list|(
name|al
argument_list|,
name|attadn
argument_list|)
operator|=
name|advalsv
expr_stmt|;
name|ds
operator|.
name|attdef
operator|+=
name|ADLEN
argument_list|(
name|al
argument_list|,
name|attadn
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* If value was bad, free the value's storage and treat as         IMPLIED or REQUIRED. */
name|frem
argument_list|(
operator|(
name|UNIV
operator|)
name|advalsv
argument_list|)
expr_stmt|;
comment|/* Release storage for value. */
name|ADVAL
argument_list|(
name|al
argument_list|,
name|attadn
argument_list|)
operator|=
name|NULL
expr_stmt|;
comment|/* And make value NULL. */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ANMTGRP: Parse a name or name token group, create attribute descriptors             for its members, and add them to the attribute descriptor list.             The parse either terminates or returns a good token, so no             switch is needed. */
end_comment

begin_function
name|int
name|anmtgrp
parameter_list|(
name|pcb
parameter_list|,
name|nt
parameter_list|,
name|grplim
parameter_list|,
name|adn
parameter_list|,
name|adsz
parameter_list|)
name|struct
name|parse
modifier|*
name|pcb
decl_stmt|;
comment|/* PCB for name or name token grp. */
name|struct
name|ad
name|nt
index|[]
decl_stmt|;
comment|/* Buffer for creating name token list. */
name|int
name|grplim
decl_stmt|;
comment|/* Maximum size of list (plus 1). */
name|UNS
modifier|*
name|adn
decl_stmt|;
comment|/* Ptr to number of names or tokens in grp. */
name|int
name|adsz
decl_stmt|;
comment|/* Size of att def list. */
block|{
name|UNCH
name|adtype
init|=
call|(
name|UNCH
call|)
argument_list|(
name|pcb
operator|==
operator|&
name|pcbgrnt
condition|?
name|ANMTGRP
else|:
name|ANOTEGRP
argument_list|)
decl_stmt|;
comment|/*Attribute type.*/
name|int
name|essv
init|=
name|es
decl_stmt|;
comment|/* Entity stack level when grp started. */
operator|*
name|adn
operator|=
literal|0
expr_stmt|;
comment|/* Group is empty to start. */
while|while
condition|(
name|parse
argument_list|(
name|pcb
argument_list|)
operator|!=
name|GRPE
operator|&&
operator|*
name|adn
operator|<
name|grplim
condition|)
block|{
switch|switch
condition|(
name|pcb
operator|->
name|action
condition|)
block|{
case|case
name|NAS_
case|:
comment|/* Name or name token (depending on pcb). */
case|case
name|NMT_
case|:
name|parsenm
argument_list|(
name|lbuf
argument_list|,
name|NAMECASE
argument_list|)
expr_stmt|;
name|nt
index|[
operator|*
name|adn
operator|+
literal|1
index|]
operator|.
name|adname
operator|=
name|savenm
argument_list|(
name|lbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|antvget
argument_list|(
call|(
name|int
call|)
argument_list|(
name|adsz
operator|+
operator|*
name|adn
argument_list|)
argument_list|,
name|nt
index|[
operator|*
name|adn
operator|+
literal|1
index|]
operator|.
name|adname
argument_list|,
operator|(
name|UNCH
operator|*
operator|*
operator|)
literal|0
argument_list|)
condition|)
name|mderr
argument_list|(
literal|98
argument_list|,
name|ntoa
argument_list|(
operator|(
name|int
operator|)
operator|*
name|adn
operator|+
literal|1
argument_list|)
argument_list|,
name|nt
index|[
operator|*
name|adn
operator|+
literal|1
index|]
operator|.
name|adname
operator|+
literal|1
argument_list|)
expr_stmt|;
name|nt
index|[
operator|++
operator|*
name|adn
index|]
operator|.
name|adtype
operator|=
name|adtype
expr_stmt|;
name|nt
index|[
operator|*
name|adn
index|]
operator|.
name|addef
operator|=
name|NULL
expr_stmt|;
continue|continue;
case|case
name|EE_
case|:
comment|/* Entity ended (correctly or incorrectly). */
if|if
condition|(
name|es
operator|<
name|essv
condition|)
block|{
name|synerr
argument_list|(
literal|37
argument_list|,
name|pcb
argument_list|)
expr_stmt|;
name|essv
operator|=
name|es
expr_stmt|;
block|}
continue|continue;
case|case
name|PIE_
case|:
comment|/* PI entity reference (invalid). */
name|entpisw
operator|=
literal|0
expr_stmt|;
comment|/* Reset PI entity indicator. */
name|synerr
argument_list|(
literal|59
argument_list|,
name|pcb
argument_list|)
expr_stmt|;
continue|continue;
default|default:
break|break;
block|}
break|break;
block|}
if|if
condition|(
name|es
operator|!=
name|essv
condition|)
name|synerr
argument_list|(
literal|37
argument_list|,
name|pcb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|adn
operator|==
name|grplim
condition|)
return|return
operator|-
literal|1
return|;
else|else
return|return
operator|*
name|adn
return|;
comment|/* Return number of tokens. */
block|}
end_function

begin_comment
comment|/* MDDTDS: Process start of DOCTYPE declaration (through MSO). */
end_comment

begin_function
name|VOID
name|mddtds
parameter_list|(
name|tbuf
parameter_list|)
name|UNCH
modifier|*
name|tbuf
decl_stmt|;
comment|/* Work area for tokenization[LITLEN+2]. */
block|{
name|struct
name|fpi
name|fpicb
decl_stmt|;
comment|/* Formal public identifier structure. */
name|union
name|etext
name|etx
decl_stmt|;
comment|/* Ptr to entity text. */
name|UNCH
name|estore
init|=
name|ESD
decl_stmt|;
comment|/* Entity storage class. */
name|int
name|emdsw
init|=
literal|0
decl_stmt|;
comment|/* 1=end of declaration found; 0=not yet. */
name|mdname
operator|=
name|key
index|[
name|KDOCTYPE
index|]
expr_stmt|;
comment|/* Identify declaration for messages. */
name|subdcl
operator|=
name|NULL
expr_stmt|;
comment|/* No subject as yet. */
name|parmno
operator|=
literal|0
expr_stmt|;
comment|/* No parameters as yet. */
name|mdessv
operator|=
name|es
expr_stmt|;
comment|/* Save es for checking entity nesting. */
name|dtdrefsw
operator|=
literal|0
expr_stmt|;
comment|/* No external DTD entity as yet. */
comment|/* PARAMETER 1: Document type name.      */
name|pcbmd
operator|.
name|newstate
operator|=
literal|0
expr_stmt|;
name|parsemd
argument_list|(
name|tbuf
argument_list|,
name|NAMECASE
argument_list|,
operator|&
name|pcblitp
argument_list|,
name|NAMELEN
argument_list|)
expr_stmt|;
name|TRACEMD
argument_list|(
literal|"1: doc type name"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcbmd
operator|.
name|action
operator|!=
name|NAS
condition|)
block|{
name|mderr
argument_list|(
literal|120
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|dtype
operator|=
name|savenm
argument_list|(
name|tbuf
argument_list|)
expr_stmt|;
name|subdcl
operator|=
name|dtype
operator|+
literal|1
expr_stmt|;
comment|/* Subject of declaration for error msgs. */
comment|/* PARAMETER 2: External identifier keyword or MDS.      */
name|parsemd
argument_list|(
name|tbuf
argument_list|,
name|NAMECASE
argument_list|,
operator|&
name|pcblitp
argument_list|,
name|NAMELEN
argument_list|)
expr_stmt|;
name|TRACEMD
argument_list|(
literal|"2: extid or MDS"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pcbmd
operator|.
name|action
condition|)
block|{
case|case
name|NAS
case|:
if|if
condition|(
name|mdextid
argument_list|(
name|tbuf
argument_list|,
operator|&
name|fpicb
argument_list|,
name|dtype
operator|+
literal|1
argument_list|,
operator|&
name|estore
argument_list|,
operator|(
name|PNE
operator|)
literal|0
argument_list|)
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
operator|(
name|etx
operator|.
name|x
operator|=
name|entgen
argument_list|(
operator|&
name|fpicb
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|mderr
argument_list|(
literal|146
argument_list|,
name|dtype
operator|+
literal|1
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
else|else
name|dtdrefsw
operator|=
literal|1
expr_stmt|;
comment|/* Signal external DTD entity. */
break|break;
case|case
name|MDS
case|:
goto|goto
name|execute
goto|;
default|default:
name|mderr
argument_list|(
literal|128
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* PARAMETER 3: MDS or end of declaration.      */
name|TRACEMD
argument_list|(
literal|"3: MDS or EMD"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pcbmd
operator|.
name|action
condition|)
block|{
default|default:
comment|/* Treat as end of declaration. */
name|mderr
argument_list|(
literal|126
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
case|case
name|EMD
case|:
name|emdsw
operator|=
literal|1
expr_stmt|;
case|case
name|MDS
case|:
break|break;
block|}
comment|/* EXECUTE: Store entity definition if an external ID was specified.      */
name|execute
label|:
if|if
condition|(
name|es
operator|!=
name|mdessv
condition|)
name|synerr
argument_list|(
literal|37
argument_list|,
operator|&
name|pcbmd
argument_list|)
expr_stmt|;
name|propcb
operator|=
operator|&
name|pcbmds
expr_stmt|;
comment|/* Prepare to parse doc type definition (MDS). */
if|if
condition|(
name|dtdrefsw
condition|)
block|{
comment|/* TO DO: If concurrent DTD's supported, free existing 	     etext for all but first DTD (or reuse it). */
name|entdef
argument_list|(
name|indtdent
argument_list|,
name|estore
argument_list|,
operator|&
name|etx
argument_list|)
expr_stmt|;
operator|++
name|ds
operator|.
name|ecbcnt
expr_stmt|;
name|ds
operator|.
name|ecbtext
operator|+=
name|entlen
expr_stmt|;
if|if
condition|(
name|emdsw
condition|)
block|{
name|REPEATCC
expr_stmt|;
comment|/* Push back the MDC. */
operator|*
name|FPOS
operator|=
name|lex
operator|.
name|d
operator|.
name|msc
expr_stmt|;
comment|/* Simulate end of DTD subset. */
name|REPEATCC
expr_stmt|;
comment|/* Back up to read MSC next. */
name|delmscsw
operator|=
literal|1
expr_stmt|;
comment|/* Insert MSC after referenced DTD. */
block|}
block|}
name|indtdsw
operator|=
literal|1
expr_stmt|;
comment|/* Allow "DTD only" parameters. */
return|return;
block|}
end_function

begin_comment
comment|/* MDDTDE: Process DOCTYPE declaration end. */
end_comment

begin_function
name|VOID
name|mddtde
parameter_list|(
name|tbuf
parameter_list|)
name|UNCH
modifier|*
name|tbuf
decl_stmt|;
comment|/* Work area for tokenization. */
block|{
name|mdessv
operator|=
name|es
expr_stmt|;
comment|/* Save es for checking entity nesting. */
name|propcb
operator|=
operator|&
name|pcbpro
expr_stmt|;
comment|/* Restore normal prolog parse. */
name|indtdsw
operator|=
literal|0
expr_stmt|;
comment|/* Prohibit "DTD only" parameters. */
name|mdname
operator|=
name|key
index|[
name|KDOCTYPE
index|]
expr_stmt|;
comment|/* Identify declaration for messages. */
name|subdcl
operator|=
name|dtype
operator|+
literal|1
expr_stmt|;
comment|/* Subject of declaration for error msgs. */
name|parmno
operator|=
literal|0
expr_stmt|;
comment|/* No parameters as yet. */
comment|/* PARAMETER 4: End of declaration.      */
name|pcbmd
operator|.
name|newstate
operator|=
name|pcbmdtk
expr_stmt|;
name|parsemd
argument_list|(
name|tbuf
argument_list|,
name|NAMECASE
argument_list|,
operator|&
name|pcblitp
argument_list|,
name|LITLEN
argument_list|)
expr_stmt|;
name|TRACEMD
argument_list|(
name|emd
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcbmd
operator|.
name|action
operator|!=
name|EMD
condition|)
name|mderr
argument_list|(
literal|126
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|es
operator|!=
name|mdessv
condition|)
name|synerr
argument_list|(
literal|37
argument_list|,
operator|&
name|pcbmd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* MDELEM: Process ELEMENT declaration. */
end_comment

begin_function
name|VOID
name|mdelem
parameter_list|(
name|tbuf
parameter_list|)
name|UNCH
modifier|*
name|tbuf
decl_stmt|;
comment|/* Work area for tokenization (tbuf). */
block|{
name|UNCH
modifier|*
name|ranksuff
init|=
name|lbuf
decl_stmt|;
comment|/* Rank suffix. */
name|UNS
name|dctype
init|=
literal|0
decl_stmt|;
comment|/* Declared content type (from dctab). */
name|UNCH
name|fmin
init|=
literal|0
decl_stmt|;
comment|/* Minimization bit flags. */
name|int
name|i
decl_stmt|;
comment|/* Loop counter. */
name|UNS
name|u
decl_stmt|;
comment|/* Temporary variable. */
name|struct
name|etd
modifier|*
modifier|*
name|mexgrp
decl_stmt|,
modifier|*
modifier|*
name|pexgrp
decl_stmt|;
comment|/* Ptr to model exceptions array. */
name|struct
name|thdr
modifier|*
name|cmod
decl_stmt|,
modifier|*
name|cmodsv
decl_stmt|;
comment|/* Ptr to content model. */
name|UNCH
modifier|*
name|etdgi
decl_stmt|;
comment|/* GI of current etd (when going through group).*/
name|int
name|minomitted
init|=
literal|0
decl_stmt|;
comment|/*  Tag minimization parameters omitted. */
name|mdname
operator|=
name|key
index|[
name|KELEMENT
index|]
expr_stmt|;
comment|/* Identify declaration for messages. */
name|subdcl
operator|=
name|NULL
expr_stmt|;
comment|/* No subject as yet. */
name|parmno
operator|=
literal|0
expr_stmt|;
comment|/* No parameters as yet. */
name|mdessv
operator|=
name|es
expr_stmt|;
comment|/* Save es level for entity nesting check. */
name|ranksuff
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|mexgrp
operator|=
name|pexgrp
operator|=
literal|0
expr_stmt|;
comment|/* PARAMETER 1: Element name or a group of them.      */
name|parsemd
argument_list|(
name|tbuf
argument_list|,
name|NAMECASE
argument_list|,
operator|&
name|pcblitp
argument_list|,
name|NAMELEN
argument_list|)
expr_stmt|;
name|TRACEMD
argument_list|(
literal|"1: element name or grp"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pcbmd
operator|.
name|action
condition|)
block|{
case|case
name|NAS
case|:
name|nmgrp
index|[
literal|0
index|]
operator|=
name|etddef
argument_list|(
name|tbuf
argument_list|)
expr_stmt|;
name|nmgrp
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|GRPS
case|:
name|parsegrp
argument_list|(
name|nmgrp
argument_list|,
operator|&
name|pcbgrnm
argument_list|,
name|tbuf
argument_list|)
expr_stmt|;
break|break;
default|default:
name|mderr
argument_list|(
literal|121
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Save first GI for trace and error messages. */
if|if
condition|(
name|nmgrp
index|[
literal|0
index|]
condition|)
name|subdcl
operator|=
name|nmgrp
index|[
literal|0
index|]
operator|->
name|etdgi
operator|+
literal|1
expr_stmt|;
comment|/* PARAMETER 1A: Rank suffix (optional).      */
name|parsemd
argument_list|(
name|tbuf
argument_list|,
name|NAMECASE
argument_list|,
operator|&
name|pcblitp
argument_list|,
name|NAMELEN
argument_list|)
expr_stmt|;
name|TRACEMD
argument_list|(
literal|"1A: rank suffix"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pcbmd
operator|.
name|action
condition|)
block|{
case|case
name|NUM
case|:
name|ustrcpy
argument_list|(
name|ranksuff
argument_list|,
name|tbuf
argument_list|)
expr_stmt|;
name|parsemd
argument_list|(
name|tbuf
argument_list|,
name|NAMECASE
argument_list|,
operator|&
name|pcblitp
argument_list|,
name|NAMELEN
argument_list|)
expr_stmt|;
default|default:
break|break;
block|}
comment|/* PARAMETER 2A: Start-tag minimization.      */
name|TRACEMD
argument_list|(
literal|"2A: start min"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pcbmd
operator|.
name|action
condition|)
block|{
case|case
name|CDR
case|:
break|break;
case|case
name|NAS
case|:
if|if
condition|(
operator|!
name|ustrcmp
argument_list|(
name|tbuf
operator|+
literal|1
argument_list|,
name|key
index|[
name|KO
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|OMITTAG
operator|==
name|YES
condition|)
name|SET
argument_list|(
name|fmin
argument_list|,
name|SMO
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* fall through */
default|default:
if|if
condition|(
name|OMITTAG
operator|==
name|NO
condition|)
block|{
name|minomitted
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|mderr
argument_list|(
literal|129
argument_list|,
name|tbuf
operator|+
literal|1
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Must omit omitted end-tag minimization, if omitted  	start-tag minimization was omitted (because OMITTAG == NO). */
if|if
condition|(
operator|!
name|minomitted
condition|)
block|{
comment|/* PARAMETER 2B: End-tag minimization. 	   */
name|parsemd
argument_list|(
name|tbuf
argument_list|,
name|NAMECASE
argument_list|,
operator|&
name|pcblitp
argument_list|,
name|NAMELEN
argument_list|)
expr_stmt|;
name|TRACEMD
argument_list|(
literal|"2B: end min"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pcbmd
operator|.
name|action
condition|)
block|{
case|case
name|NAS
case|:
if|if
condition|(
name|ustrcmp
argument_list|(
name|tbuf
operator|+
literal|1
argument_list|,
name|key
index|[
name|KO
index|]
argument_list|)
condition|)
block|{
name|mderr
argument_list|(
literal|129
argument_list|,
name|tbuf
operator|+
literal|1
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|OMITTAG
operator|==
name|YES
condition|)
name|SET
argument_list|(
name|fmin
argument_list|,
name|EMO
argument_list|)
expr_stmt|;
break|break;
case|case
name|MGRP
case|:
name|REPEATCC
expr_stmt|;
comment|/* fall through */
case|case
name|CDR
case|:
name|SET
argument_list|(
name|fmin
argument_list|,
name|EMM
argument_list|)
expr_stmt|;
break|break;
default|default:
name|mderr
argument_list|(
literal|129
argument_list|,
name|tbuf
operator|+
literal|1
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* PARAMETER 3: Declared content. 	   */
name|parsemd
argument_list|(
name|tbuf
argument_list|,
name|NAMECASE
argument_list|,
operator|&
name|pcblitp
argument_list|,
name|NAMELEN
argument_list|)
expr_stmt|;
block|}
name|TRACEMD
argument_list|(
literal|"3: declared content"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pcbmd
operator|.
name|action
condition|)
block|{
case|case
name|NAS
case|:
name|dctype
operator|=
name|mapsrch
argument_list|(
name|dctab
argument_list|,
name|tbuf
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dctype
condition|)
block|{
name|mderr
argument_list|(
literal|24
argument_list|,
name|tbuf
operator|+
literal|1
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Eliminate incompatibilities among parameters. */
if|if
condition|(
name|GET
argument_list|(
name|fmin
argument_list|,
name|SMO
argument_list|)
operator|&&
name|GET
argument_list|(
name|dctype
argument_list|,
name|MNONE
operator|+
name|MCDATA
operator|+
name|MRCDATA
argument_list|)
condition|)
block|{
name|mderr
argument_list|(
literal|58
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|RESET
argument_list|(
name|fmin
argument_list|,
name|SMO
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET
argument_list|(
name|dctype
argument_list|,
name|MNONE
argument_list|)
operator|&&
name|BITON
argument_list|(
name|fmin
argument_list|,
name|EMM
argument_list|)
condition|)
block|{
name|mderr
argument_list|(
literal|87
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|SET
argument_list|(
name|fmin
argument_list|,
name|EMO
argument_list|)
expr_stmt|;
block|}
comment|/* If valid, process like a content model. */
case|case
name|GRPS
case|:
name|cmodsv
operator|=
name|parsemod
argument_list|(
call|(
name|int
call|)
argument_list|(
name|pcbmd
operator|.
name|action
operator|==
name|GRPS
condition|?
literal|0
else|:
name|dctype
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmodsv
operator|==
literal|0
condition|)
return|return;
name|u
operator|=
operator|(
name|dctype
condition|?
literal|1
else|:
name|cmodsv
operator|->
name|tu
operator|.
name|tnum
operator|+
literal|2
operator|)
operator|*
name|THSZ
expr_stmt|;
name|cmod
operator|=
operator|(
expr|struct
name|thdr
operator|*
operator|)
name|rmalloc
argument_list|(
name|u
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|UNIV
operator|)
name|cmod
argument_list|,
operator|(
name|UNIV
operator|)
name|cmodsv
argument_list|,
name|u
argument_list|)
expr_stmt|;
name|ds
operator|.
name|modcnt
operator|+=
name|cmod
operator|->
name|tu
operator|.
name|tnum
expr_stmt|;
name|TRACEMOD
argument_list|(
name|cmod
argument_list|)
expr_stmt|;
break|break;
default|default:
name|mderr
argument_list|(
literal|130
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* PARAMETERS 3A, 3B: Exceptions or end.      */
name|parsemd
argument_list|(
name|tbuf
argument_list|,
name|NAMECASE
argument_list|,
operator|&
name|pcblitp
argument_list|,
name|NAMELEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|BITOFF
argument_list|(
name|cmod
operator|->
name|ttype
argument_list|,
name|MCDATA
operator|+
name|MRCDATA
operator|+
name|MNONE
argument_list|)
condition|)
block|{
comment|/* PARAMETER 3A: Minus exceptions.           */
name|TRACEMD
argument_list|(
literal|"3A: -grp"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pcbmd
operator|.
name|action
condition|)
block|{
case|case
name|MGRP
case|:
comment|/* We cheat and use nnmgrp for this. */
name|mexgrp
operator|=
name|copygrp
argument_list|(
operator|(
name|PETD
operator|*
operator|)
name|nnmgrp
argument_list|,
name|u
operator|=
name|parsegrp
argument_list|(
operator|(
name|PETD
operator|*
operator|)
name|nnmgrp
argument_list|,
operator|&
name|pcbgrnm
argument_list|,
name|tbuf
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|ds
operator|.
name|pmexgcnt
expr_stmt|;
name|ds
operator|.
name|pmexcnt
operator|+=
name|u
operator|-
literal|1
expr_stmt|;
name|TRACEGRP
argument_list|(
name|mexgrp
argument_list|)
expr_stmt|;
name|parsemd
argument_list|(
name|tbuf
argument_list|,
name|NAMECASE
argument_list|,
operator|&
name|pcblitp
argument_list|,
name|NAMELEN
argument_list|)
expr_stmt|;
default|default:
break|break;
block|}
comment|/* PARAMETER 3B: Plus exceptions.           */
name|TRACEMD
argument_list|(
literal|"3B: +grp"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pcbmd
operator|.
name|action
condition|)
block|{
case|case
name|PGRP
case|:
name|pexgrp
operator|=
name|copygrp
argument_list|(
operator|(
name|PETD
operator|*
operator|)
name|nnmgrp
argument_list|,
name|u
operator|=
name|parsegrp
argument_list|(
operator|(
name|PETD
operator|*
operator|)
name|nnmgrp
argument_list|,
operator|&
name|pcbgrnm
argument_list|,
name|tbuf
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|ds
operator|.
name|pmexgcnt
expr_stmt|;
name|ds
operator|.
name|pmexcnt
operator|+=
name|u
operator|-
literal|1
expr_stmt|;
name|TRACEGRP
argument_list|(
name|pexgrp
argument_list|)
expr_stmt|;
name|parsemd
argument_list|(
name|tbuf
argument_list|,
name|NAMECASE
argument_list|,
operator|&
name|pcblitp
argument_list|,
name|NAMELEN
argument_list|)
expr_stmt|;
default|default:
break|break;
block|}
block|}
comment|/* PARAMETER 4: End of declaration.      */
name|TRACEMD
argument_list|(
name|emd
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcbmd
operator|.
name|action
operator|!=
name|EMD
condition|)
name|mderr
argument_list|(
literal|126
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|es
operator|!=
name|mdessv
condition|)
name|synerr
argument_list|(
literal|37
argument_list|,
operator|&
name|pcbmd
argument_list|)
expr_stmt|;
comment|/* EXECUTE: Store the definition for each element name specified.      */
name|TRACEGRP
argument_list|(
name|nmgrp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
operator|-
literal|1
init|;
name|nmgrp
index|[
operator|++
name|i
index|]
condition|;
control|)
block|{
name|etdgi
operator|=
name|nmgrp
index|[
name|i
index|]
operator|->
name|etdgi
expr_stmt|;
if|if
condition|(
operator|*
name|ranksuff
condition|)
block|{
if|if
condition|(
operator|(
name|tbuf
index|[
literal|0
index|]
operator|=
operator|*
name|etdgi
operator|+
name|ustrlen
argument_list|(
name|ranksuff
argument_list|)
operator|)
operator|-
literal|2
operator|>
name|NAMELEN
condition|)
block|{
name|mderr
argument_list|(
literal|131
argument_list|,
name|etdgi
operator|+
literal|1
argument_list|,
name|ranksuff
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|memcpy
argument_list|(
name|tbuf
operator|+
literal|1
argument_list|,
name|etdgi
operator|+
literal|1
argument_list|,
operator|*
name|etdgi
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ustrcpy
argument_list|(
name|tbuf
operator|+
operator|*
name|etdgi
operator|-
literal|1
argument_list|,
name|ranksuff
argument_list|)
expr_stmt|;
name|etdcan
argument_list|(
name|etdgi
argument_list|)
expr_stmt|;
name|nmgrp
index|[
name|i
index|]
operator|=
name|etddef
argument_list|(
name|tbuf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nmgrp
index|[
name|i
index|]
operator|->
name|etdmod
condition|)
block|{
name|mderr
argument_list|(
literal|56
argument_list|,
name|etdgi
operator|+
literal|1
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|etdset
argument_list|(
name|nmgrp
index|[
name|i
index|]
argument_list|,
name|fmin
operator|+
name|ETDDCL
argument_list|,
name|cmod
argument_list|,
name|mexgrp
argument_list|,
name|pexgrp
argument_list|,
name|nmgrp
index|[
name|i
index|]
operator|->
name|etdsrm
argument_list|)
expr_stmt|;
operator|++
name|ds
operator|.
name|etdcnt
expr_stmt|;
if|if
condition|(
name|nmgrp
index|[
name|i
index|]
operator|->
name|adl
condition|)
name|etdadl
argument_list|(
name|nmgrp
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* Check ETD conflicts. */
name|TRACEETD
argument_list|(
name|nmgrp
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|VOID
name|adlfree
parameter_list|(
name|al
parameter_list|,
name|aln
parameter_list|)
name|struct
name|ad
modifier|*
name|al
decl_stmt|;
name|int
name|aln
decl_stmt|;
block|{
for|for
control|(
init|;
name|aln
operator|<=
name|ADN
argument_list|(
name|al
argument_list|)
condition|;
name|aln
operator|++
control|)
block|{
name|frem
argument_list|(
operator|(
name|UNIV
operator|)
name|al
index|[
name|aln
index|]
operator|.
name|adname
argument_list|)
expr_stmt|;
if|if
condition|(
name|ADVAL
argument_list|(
name|al
argument_list|,
name|aln
argument_list|)
condition|)
name|frem
argument_list|(
operator|(
name|UNIV
operator|)
name|ADVAL
argument_list|(
name|al
argument_list|,
name|aln
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|BITON
argument_list|(
name|ADFLAGS
argument_list|(
name|al
argument_list|,
name|aln
argument_list|)
argument_list|,
name|AGROUP
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ADNUM
argument_list|(
name|al
argument_list|,
name|aln
argument_list|)
condition|;
name|i
operator|++
control|)
name|frem
argument_list|(
operator|(
name|UNIV
operator|)
name|al
index|[
name|aln
operator|+
name|i
operator|+
literal|1
index|]
operator|.
name|adname
argument_list|)
expr_stmt|;
name|aln
operator|+=
name|ADNUM
argument_list|(
name|al
argument_list|,
name|aln
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Local Variables: c-indent-level: 5 c-continued-statement-offset: 5 c-brace-offset: -5 c-argdecl-indent: 0 c-label-offset: -5 comment-column: 30 End: */
end_comment

end_unit

