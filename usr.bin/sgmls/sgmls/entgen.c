begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* entgen.c -     Implement entgen() which generates a list of filenames from a struct fpi.        Written by James Clark (jjc@jclark.com). */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_ACCESS
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_UNISTD_H
end_ifdef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_comment
comment|/* For R_OK. */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_UNISTD_H */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|R_OK
end_ifndef

begin_define
define|#
directive|define
name|R_OK
value|4
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not R_OK */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_ACCESS */
end_comment

begin_include
include|#
directive|include
file|"sgmlaux.h"
end_include

begin_comment
comment|/* Environment variable that contains path. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|PATH_ENV_VAR
end_ifndef

begin_define
define|#
directive|define
name|PATH_ENV_VAR
value|"SGML_PATH"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Default search path.  See field() for interpretation of %*. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DEFAULT_PATH
end_ifndef

begin_define
define|#
directive|define
name|DEFAULT_PATH
value|"/usr/local/lib/sgml/%O/%C/%T:%N.%X:%N.%D"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PATH_FILE_SEP
end_ifndef

begin_define
define|#
directive|define
name|PATH_FILE_SEP
value|':'
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SYSID_FILE_SEP
end_ifndef

begin_define
define|#
directive|define
name|SYSID_FILE_SEP
value|':'
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This says: change space to underscore, slash to percent. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MIN_DAT_SUBS_FROM
end_ifndef

begin_define
define|#
directive|define
name|MIN_DAT_SUBS_FROM
value|" /"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MIN_DAT_SUBS_TO
end_ifndef

begin_define
define|#
directive|define
name|MIN_DAT_SUBS_TO
value|"_%"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|field
name|P
argument_list|(
operator|(
expr|struct
name|fpi
operator|*
operator|,
name|int
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mindatcpy
name|P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|testopen
name|P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|UNIV
name|sysidgen
name|P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|path
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero if searching should be performed when a system identifier is specified. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|sysidsrch
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|EMPTY_VERSION
value|"default"
end_define

begin_decl_stmt
specifier|static
name|char
modifier|*
name|classes
index|[]
init|=
block|{
literal|"capacity"
block|,
literal|"charset"
block|,
literal|"notation"
block|,
literal|"syntax"
block|,
literal|"document"
block|,
literal|"dtd"
block|,
literal|"elements"
block|,
literal|"entities"
block|,
literal|"lpd"
block|,
literal|"nonsgml"
block|,
literal|"shortref"
block|,
literal|"subdoc"
block|,
literal|"text"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is mainly for compatibility with arcsgml. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|genext
index|[]
init|=
block|{
literal|"nsd"
block|,
comment|/* Non-SGML data entity. */
literal|"gml"
block|,
comment|/* GML document or text entity. */
literal|"spe"
block|,
comment|/* System parameter entity. */
literal|"dtd"
block|,
comment|/* Document type definition. */
literal|"lpd"
block|,
comment|/* Link process definition. */
literal|"pns"
block|,
comment|/* Public non-SGML data entity. */
literal|"pge"
block|,
comment|/* Public general entity. */
literal|"ppe"
block|,
comment|/* Public parameter entity. */
literal|"pdt"
block|,
comment|/* Public document type definition. */
literal|"plp"
block|,
comment|/* Public link process definition. */
literal|"vns"
block|,
comment|/* Display version non-SGML data entity. */
literal|"vge"
block|,
comment|/* Display version general entity. */
literal|"vpe"
block|,
comment|/* Display version parameter entity. */
literal|"vdt"
block|,
comment|/* Display version document type definition.*/
literal|"vlp"
block|,
comment|/* Display version link process definition.*/
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ext
index|[]
init|=
block|{
literal|"sgml"
block|,
comment|/* SGML subdocument */
literal|"data"
block|,
comment|/* Data */
literal|"text"
block|,
comment|/* General text */
literal|"parm"
block|,
comment|/* Parameter entity */
literal|"dtd"
block|,
comment|/* Document type definition */
literal|"lpd"
block|,
comment|/* Link process definition */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Like memcpy, but substitute, fold to lower case (if fold is non-zero) and null terminate.  This is used both for minimum data and for names. If p is NULL, do nothing. Return len. */
end_comment

begin_function
specifier|static
name|int
name|mindatcpy
parameter_list|(
name|p
parameter_list|,
name|q
parameter_list|,
name|len
parameter_list|,
name|fold
parameter_list|)
name|char
modifier|*
name|p
decl_stmt|,
decl|*
name|q
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|len
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|fold
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|static
name|char
name|subsfrom
index|[]
init|=
name|MIN_DAT_SUBS_FROM
decl_stmt|;
specifier|static
name|char
name|substo
index|[]
init|=
name|MIN_DAT_SUBS_TO
decl_stmt|;
name|int
name|n
decl_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
return|return
name|len
return|;
for|for
control|(
name|n
operator|=
name|len
init|;
operator|--
name|n
operator|>=
literal|0
condition|;
name|q
operator|++
control|)
block|{
name|char
modifier|*
name|r
init|=
name|strchr
argument_list|(
name|subsfrom
argument_list|,
operator|*
name|q
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
block|{
if|if
condition|(
name|fold
operator|&&
name|ISASCII
argument_list|(
operator|*
name|q
argument_list|)
operator|&&
name|isupper
argument_list|(
operator|(
name|UNCH
operator|)
operator|*
name|q
argument_list|)
condition|)
operator|*
name|p
operator|++
operator|=
name|tolower
argument_list|(
operator|(
name|UNCH
operator|)
operator|*
name|q
argument_list|)
expr_stmt|;
else|else
operator|*
name|p
operator|++
operator|=
operator|*
name|q
expr_stmt|;
block|}
else|else
block|{
name|int
name|i
init|=
name|r
operator|-
name|subsfrom
decl_stmt|;
if|if
condition|(
name|i
operator|<
sizeof|sizeof
argument_list|(
name|substo
argument_list|)
operator|-
literal|1
condition|)
operator|*
name|p
operator|++
operator|=
name|substo
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
return|return
name|len
return|;
block|}
end_block

begin_comment
comment|/* Return length of field.  Copy into buf if non-NULL. */
end_comment

begin_function
specifier|static
name|int
name|field
parameter_list|(
name|f
parameter_list|,
name|c
parameter_list|,
name|buf
parameter_list|)
name|struct
name|fpi
modifier|*
name|f
decl_stmt|;
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
block|{
name|int
name|n
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'%'
case|:
if|if
condition|(
name|buf
condition|)
block|{
name|buf
index|[
literal|0
index|]
operator|=
literal|'%'
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
return|return
literal|1
return|;
case|case
literal|'N'
case|:
comment|/* the entity, document or dcn name */
return|return
name|mindatcpy
argument_list|(
name|buf
argument_list|,
operator|(
name|char
operator|*
operator|)
name|f
operator|->
name|fpinm
argument_list|,
name|ustrlen
argument_list|(
name|f
operator|->
name|fpinm
argument_list|)
argument_list|,
operator|(
name|f
operator|->
name|fpistore
operator|!=
literal|1
operator|&&
name|f
operator|->
name|fpistore
operator|!=
literal|2
operator|&&
name|f
operator|->
name|fpistore
operator|!=
literal|3
condition|?
name|NAMECASE
else|:
name|ENTCASE
operator|)
argument_list|)
return|;
case|case
literal|'D'
case|:
comment|/* dcn name */
if|if
condition|(
name|f
operator|->
name|fpistore
operator|!=
literal|1
condition|)
comment|/* not a external data entity */
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|f
operator|->
name|fpinedcn
operator|==
literal|0
condition|)
comment|/* it's a SUBDOC */
return|return
operator|-
literal|1
return|;
return|return
name|mindatcpy
argument_list|(
name|buf
argument_list|,
operator|(
name|char
operator|*
operator|)
name|f
operator|->
name|fpinedcn
argument_list|,
name|ustrlen
argument_list|(
name|f
operator|->
name|fpinedcn
argument_list|)
argument_list|,
name|NAMECASE
argument_list|)
return|;
case|case
literal|'X'
case|:
comment|/* This is for compatibility with arcsgml */
if|if
condition|(
name|f
operator|->
name|fpistore
operator|<
literal|1
operator|||
name|f
operator|->
name|fpistore
operator|>
literal|5
condition|)
return|return
operator|-
literal|1
return|;
name|n
operator|=
operator|(
name|f
operator|->
name|fpipubis
operator|!=
literal|0
operator|)
operator|*
operator|(
name|f
operator|->
name|fpiversw
operator|>
literal|0
condition|?
literal|2
else|:
literal|1
operator|)
operator|*
literal|5
operator|+
name|f
operator|->
name|fpistore
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|buf
condition|)
name|strcpy
argument_list|(
name|buf
argument_list|,
name|genext
index|[
name|n
index|]
argument_list|)
expr_stmt|;
return|return
name|strlen
argument_list|(
name|genext
index|[
name|n
index|]
argument_list|)
return|;
case|case
literal|'Y'
case|:
comment|/* tYpe */
name|n
operator|=
name|f
operator|->
name|fpistore
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|1
operator|||
name|n
operator|>
literal|5
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|n
operator|==
literal|1
operator|&&
name|f
operator|->
name|fpinedcn
operator|==
literal|0
condition|)
comment|/* it's a SUBDOC */
name|n
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|buf
condition|)
name|strcpy
argument_list|(
name|buf
argument_list|,
name|ext
index|[
name|n
index|]
argument_list|)
expr_stmt|;
return|return
name|strlen
argument_list|(
name|ext
index|[
name|n
index|]
argument_list|)
return|;
case|case
literal|'P'
case|:
comment|/* public identifier */
if|if
condition|(
operator|!
name|f
operator|->
name|fpipubis
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|mindatcpy
argument_list|(
name|buf
argument_list|,
operator|(
name|char
operator|*
operator|)
name|f
operator|->
name|fpipubis
argument_list|,
name|ustrlen
argument_list|(
name|f
operator|->
name|fpipubis
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
case|case
literal|'S'
case|:
comment|/* system identifier */
if|if
condition|(
operator|!
name|f
operator|->
name|fpisysis
condition|)
return|return
operator|-
literal|1
return|;
else|else
block|{
name|UNCH
modifier|*
name|p
decl_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|f
operator|->
name|fpisysis
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|!=
name|RSCHAR
condition|)
block|{
if|if
condition|(
name|buf
condition|)
name|buf
index|[
name|n
index|]
operator|=
operator|*
name|p
operator|==
name|RECHAR
condition|?
literal|'\n'
else|:
operator|*
name|p
expr_stmt|;
name|n
operator|++
expr_stmt|;
block|}
return|return
name|n
return|;
block|}
block|}
comment|/* Other fields need a formal public identifier. */
comment|/* return -1 if the formal public identifier was invalid or missing. */
if|if
condition|(
name|f
operator|->
name|fpiversw
operator|<
literal|0
operator|||
operator|!
name|f
operator|->
name|fpipubis
condition|)
return|return
operator|-
literal|1
return|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'A'
case|:
comment|/* Is it available? */
return|return
name|f
operator|->
name|fpitt
operator|==
literal|'+'
condition|?
literal|0
else|:
operator|-
literal|1
return|;
case|case
literal|'I'
case|:
comment|/* Is it ISO? */
return|return
name|f
operator|->
name|fpiot
operator|==
literal|'!'
condition|?
literal|0
else|:
operator|-
literal|1
return|;
case|case
literal|'R'
case|:
comment|/* Is it registered? */
return|return
name|f
operator|->
name|fpiot
operator|==
literal|'+'
condition|?
literal|0
else|:
operator|-
literal|1
return|;
case|case
literal|'U'
case|:
comment|/* Is it unregistered? */
return|return
name|f
operator|->
name|fpiot
operator|==
literal|'-'
condition|?
literal|0
else|:
operator|-
literal|1
return|;
case|case
literal|'L'
case|:
comment|/* public text language */
if|if
condition|(
name|f
operator|->
name|fpic
operator|==
name|FPICHARS
condition|)
return|return
operator|-
literal|1
return|;
comment|/* it's entered in all upper case letters */
return|return
name|mindatcpy
argument_list|(
name|buf
argument_list|,
operator|(
name|char
operator|*
operator|)
name|f
operator|->
name|fpipubis
operator|+
name|f
operator|->
name|fpil
argument_list|,
name|f
operator|->
name|fpill
argument_list|,
literal|1
argument_list|)
return|;
case|case
literal|'O'
case|:
comment|/* owner identifier */
return|return
name|mindatcpy
argument_list|(
name|buf
argument_list|,
operator|(
name|char
operator|*
operator|)
name|f
operator|->
name|fpipubis
operator|+
name|f
operator|->
name|fpio
argument_list|,
name|f
operator|->
name|fpiol
argument_list|,
literal|0
argument_list|)
return|;
case|case
literal|'C'
case|:
comment|/* public text class */
name|n
operator|=
name|f
operator|->
name|fpic
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
operator|||
name|n
operator|>=
sizeof|sizeof
argument_list|(
name|classes
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|classes
index|[
literal|0
index|]
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|buf
condition|)
name|strcpy
argument_list|(
name|buf
argument_list|,
name|classes
index|[
name|n
index|]
argument_list|)
expr_stmt|;
return|return
name|strlen
argument_list|(
name|classes
index|[
name|n
index|]
argument_list|)
return|;
case|case
literal|'T'
case|:
comment|/* text description */
return|return
name|mindatcpy
argument_list|(
name|buf
argument_list|,
operator|(
name|char
operator|*
operator|)
name|f
operator|->
name|fpipubis
operator|+
name|f
operator|->
name|fpit
argument_list|,
name|f
operator|->
name|fpitl
argument_list|,
literal|0
argument_list|)
return|;
case|case
literal|'V'
case|:
if|if
condition|(
name|f
operator|->
name|fpic
operator|<
name|FPICMINV
condition|)
comment|/* class doesn't have version */
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|f
operator|->
name|fpiversw
operator|>
literal|0
condition|)
comment|/* no version */
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|f
operator|->
name|fpivl
operator|==
literal|0
condition|)
block|{
comment|/* empty version: */
comment|/* use device-independent version*/
if|if
condition|(
name|buf
condition|)
name|strcpy
argument_list|(
name|buf
argument_list|,
name|EMPTY_VERSION
argument_list|)
expr_stmt|;
return|return
name|strlen
argument_list|(
name|EMPTY_VERSION
argument_list|)
return|;
block|}
return|return
name|mindatcpy
argument_list|(
name|buf
argument_list|,
operator|(
name|char
operator|*
operator|)
name|f
operator|->
name|fpipubis
operator|+
name|f
operator|->
name|fpiv
argument_list|,
name|f
operator|->
name|fpivl
argument_list|,
literal|0
argument_list|)
return|;
case|case
literal|'E'
case|:
comment|/* public text designating (escape) sequence */
if|if
condition|(
name|f
operator|->
name|fpic
operator|!=
name|FPICHARS
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|mindatcpy
argument_list|(
name|buf
argument_list|,
operator|(
name|char
operator|*
operator|)
name|f
operator|->
name|fpipubis
operator|+
name|f
operator|->
name|fpil
argument_list|,
name|f
operator|->
name|fpill
argument_list|,
literal|0
argument_list|)
return|;
default|default:
break|break;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|testopen
parameter_list|(
name|pathname
parameter_list|)
name|char
modifier|*
name|pathname
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|HAVE_ACCESS
return|return
name|access
argument_list|(
name|pathname
argument_list|,
name|R_OK
argument_list|)
operator|>=
literal|0
return|;
else|#
directive|else
comment|/* not HAVE_ACCESS */
name|FILE
modifier|*
name|fp
decl_stmt|;
name|fp
operator|=
name|fopen
argument_list|(
name|pathname
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fp
condition|)
return|return
literal|0
return|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
endif|#
directive|endif
comment|/* not HAVE_ACCESS */
block|}
end_function

begin_comment
comment|/* Return a pointer to an dynamically-allocated buffer that contains    the names of the files containing this entity, with each filename    terminated by a '\0', and with the list of filenames terminated by    another '\0'. */
end_comment

begin_function
name|UNIV
name|entgen
parameter_list|(
name|f
parameter_list|)
name|struct
name|fpi
modifier|*
name|f
decl_stmt|;
block|{
name|char
modifier|*
name|file
decl_stmt|;
name|assert
argument_list|(
name|f
operator|->
name|fpistore
operator|!=
literal|6
argument_list|)
expr_stmt|;
comment|/* Musn't call entgen for a notation. */
if|if
condition|(
operator|!
name|path
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|c
decl_stmt|;
name|path
operator|=
name|getenv
argument_list|(
name|PATH_ENV_VAR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|path
condition|)
name|path
operator|=
name|DEFAULT_PATH
expr_stmt|;
name|p
operator|=
name|path
expr_stmt|;
comment|/* Only search for system identifiers if path uses %S. */
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
if|if
condition|(
name|c
operator|==
literal|'%'
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'S'
condition|)
block|{
name|sysidsrch
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
operator|*
name|p
operator|!=
name|PATH_FILE_SEP
condition|)
name|p
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|f
operator|->
name|fpisysis
operator|&&
operator|(
operator|!
name|sysidsrch
operator|||
name|strchr
argument_list|(
operator|(
name|char
operator|*
operator|)
name|f
operator|->
name|fpisysis
argument_list|,
name|SYSID_FILE_SEP
argument_list|)
operator|||
name|strcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|f
operator|->
name|fpisysis
argument_list|,
name|STDINNAME
argument_list|)
operator|==
literal|0
operator|)
condition|)
return|return
name|sysidgen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|f
operator|->
name|fpisysis
argument_list|)
return|;
name|file
operator|=
name|path
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|len
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|fileend
init|=
name|strchr
argument_list|(
name|file
argument_list|,
name|PATH_FILE_SEP
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|fileend
condition|)
name|fileend
operator|=
name|strchr
argument_list|(
name|file
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
comment|/* Check that all substitutions are non-null, and calculate 	     the resulting total length of the filename. */
for|for
control|(
name|p
operator|=
name|file
init|;
name|p
operator|<
name|fileend
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|'%'
condition|)
block|{
name|int
name|n
decl_stmt|;
comment|/* Set len to -1 if a substitution is invalid. */
if|if
condition|(
operator|++
name|p
operator|>=
name|fileend
condition|)
block|{
name|len
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
name|n
operator|=
name|field
argument_list|(
name|f
argument_list|,
operator|*
name|p
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|len
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
name|len
operator|+=
name|n
expr_stmt|;
block|}
else|else
name|len
operator|++
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
comment|/* We've got a valid non-empty filename. */
name|char
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|s
operator|=
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|rmalloc
argument_list|(
name|len
operator|+
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|file
init|;
name|p
operator|<
name|fileend
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|'%'
condition|)
name|s
operator|+=
name|field
argument_list|(
name|f
argument_list|,
operator|*
operator|++
name|p
argument_list|,
name|s
argument_list|)
expr_stmt|;
else|else
operator|*
name|s
operator|++
operator|=
operator|*
name|p
expr_stmt|;
operator|*
name|s
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|testopen
argument_list|(
name|buf
argument_list|)
condition|)
block|{
comment|/* Terminate the array of filenames. */
operator|*
name|s
operator|++
operator|=
literal|'\0'
expr_stmt|;
return|return
name|buf
return|;
block|}
name|free
argument_list|(
operator|(
name|UNIV
operator|)
name|buf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|fileend
operator|==
literal|'\0'
condition|)
break|break;
name|file
operator|=
operator|++
name|fileend
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Handle a system identifier without searching. */
end_comment

begin_function
specifier|static
name|UNIV
name|sysidgen
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|char
modifier|*
name|buf
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|rmalloc
argument_list|(
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|buf
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
name|SYSID_FILE_SEP
condition|)
block|{
if|if
condition|(
name|p
operator|>
name|buf
operator|&&
name|p
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\0'
condition|)
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
name|RECHAR
condition|)
operator|*
name|p
operator|++
operator|=
literal|'\n'
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|s
operator|!=
name|RSCHAR
condition|)
operator|*
name|p
operator|++
operator|=
operator|*
name|s
expr_stmt|;
block|}
comment|/* Terminate this filename. */
if|if
condition|(
name|p
operator|>
name|buf
operator|&&
name|p
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\0'
condition|)
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|buf
condition|)
block|{
comment|/* No filenames. */
name|frem
argument_list|(
operator|(
name|UNIV
operator|)
name|buf
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Terminate the list. */
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_comment
comment|/* Local Variables: c-indent-level: 5 c-continued-statement-offset: 5 c-brace-offset: -5 c-argdecl-indent: 0 c-label-offset: -5 End: */
end_comment

end_unit

