begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* sgmlmsg.c -    message handling for core parser     Written by James Clark (jjc@jclark.com). */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"sgmlaux.h"
end_include

begin_include
include|#
directive|include
file|"msg.h"
end_include

begin_decl_stmt
specifier|static
name|nl_catd
name|catd
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|TEXT_SET
value|1
end_define

begin_comment
comment|/* message set number for text of messages */
end_comment

begin_define
define|#
directive|define
name|HEADER_SET
value|2
end_define

begin_comment
comment|/* message set number for header strings */
end_comment

begin_define
define|#
directive|define
name|PARM_SET
value|3
end_define

begin_comment
comment|/* message set number for special parameters */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_EXTENDED_PRINTF
end_ifdef

begin_define
define|#
directive|define
name|xfprintf
value|fprintf
end_define

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|extern
name|int
name|xfprintf
name|VP
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|char
operator|*
operator|,
operator|...
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|SIZEOF
parameter_list|(
name|v
parameter_list|)
value|(sizeof(v)/sizeof(v[0]))
end_define

begin_decl_stmt
specifier|static
name|char
modifier|*
name|gettext
name|P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|getheader
name|P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|getparm
name|P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|VOID
name|elttrace
name|P
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|printit
name|P
argument_list|(
operator|(
name|FILE
operator|*
operator|,
expr|struct
name|error
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|transparm
name|P
argument_list|(
operator|(
name|UNCH
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|VOID
name|spaces
name|P
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|PARMBUFSIZ
value|50
end_define

begin_decl_stmt
specifier|static
name|char
name|parmbuf
index|[
name|PARMBUFSIZ
operator|*
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|parmbuf1
init|=
name|parmbuf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|parmbuf2
init|=
name|parmbuf
operator|+
name|PARMBUFSIZ
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|prog
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* program name */
end_comment

begin_decl_stmt
specifier|static
name|int
name|sweltr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* non-zero means print an element trace */
end_comment

begin_decl_stmt
specifier|static
name|int
name|swenttr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* non-zero means print an entity trace */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cnterr
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|VOID
argument_list|(
argument|*die
argument_list|)
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|headers
index|[]
init|=
block|{
literal|"In file included"
block|,
literal|"SGML error"
block|,
comment|/* parameters: type, severity, number */
literal|"Unsupported feature"
block|,
comment|/* type U errors */
literal|"Error"
block|,
comment|/* for type R errors */
literal|"Warning"
block|,
comment|/* severity type I */
literal|" at %s, %.0sline %lu"
block|,
comment|/* ignore entity name and ccnt */
literal|" at entity %s, line %lu"
block|,
literal|"%.0s%.0s in declaration parameter %d"
block|,
comment|/* ignore first two parameters */
literal|"%.0s in declaration parameter %d"
block|,
comment|/* ignore first parameter */
literal|"%.0s"
block|,
comment|/* parse mode */
literal|" at end of file"
block|,
literal|" at end of entity"
block|,
literal|" at record start"
block|,
literal|" at record end"
block|,
literal|" at \"%c\""
block|,
literal|" at \"\\%03o\""
block|,
literal|" accessing \"%s\""
block|,
literal|"Element structure:"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexes into headers[] */
end_comment

begin_define
define|#
directive|define
name|HDRPFX
value|0
end_define

begin_define
define|#
directive|define
name|HDRALL
value|1
end_define

begin_define
define|#
directive|define
name|HDRUNSUP
value|2
end_define

begin_define
define|#
directive|define
name|HDRSYS
value|3
end_define

begin_define
define|#
directive|define
name|HDRWARN
value|4
end_define

begin_define
define|#
directive|define
name|HDRLOC
value|5
end_define

begin_define
define|#
directive|define
name|HDRELOC
value|6
end_define

begin_define
define|#
directive|define
name|HDRMD
value|7
end_define

begin_define
define|#
directive|define
name|HDRMD2
value|8
end_define

begin_define
define|#
directive|define
name|HDRMODE
value|9
end_define

begin_define
define|#
directive|define
name|HDREOF
value|10
end_define

begin_define
define|#
directive|define
name|HDREE
value|11
end_define

begin_define
define|#
directive|define
name|HDRRS
value|12
end_define

begin_define
define|#
directive|define
name|HDRRE
value|13
end_define

begin_define
define|#
directive|define
name|HDRPRT
value|14
end_define

begin_define
define|#
directive|define
name|HDRCTL
value|15
end_define

begin_define
define|#
directive|define
name|HDRFIL
value|16
end_define

begin_define
define|#
directive|define
name|HDRELT
value|17
end_define

begin_comment
comment|/* Special parameters (error::errsp) */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|parms
index|[]
init|=
block|{
literal|"character data"
block|,
literal|"element content"
block|,
literal|"mixed content"
block|,
literal|"replaceable character data"
block|,
literal|"tag close"
block|,
literal|"content model group"
block|,
literal|"content model occurrence indicator"
block|,
literal|"name group"
block|,
literal|"name token group"
block|,
literal|"system data"
block|,
literal|"parameter literal"
block|,
literal|"attribute value literal"
block|,
literal|"tokenized attribute value literal"
block|,
literal|"minimum literal"
block|,
literal|"markup declaration"
block|,
literal|"markup declaration comment"
block|,
literal|"ignored markup declaration"
block|,
literal|"declaration subset"
block|,
literal|"CDATA marked section"
block|,
literal|"IGNORE marked section"
block|,
literal|"RCDATA marked section"
block|,
literal|"prolog"
block|,
literal|"reference"
block|,
literal|"attribute specification list"
block|,
literal|"tokenized attribute value"
block|,
literal|"attribute specification list close"
block|,
literal|"SGML declaration"
block|,
literal|"attribute definition list"
block|,
literal|"document type"
block|,
literal|"element"
block|,
literal|"entity"
block|,
literal|"link type"
block|,
literal|"link set"
block|,
literal|"notation"
block|,
literal|"SGML"
block|,
literal|"short reference mapping"
block|,
literal|"link set use"
block|,
literal|"short reference use"
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|tfp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* temporary file for saved messages */
end_comment

begin_struct
struct|struct
name|saved
block|{
name|long
name|start
decl_stmt|;
name|long
name|end
decl_stmt|;
name|char
name|exiterr
decl_stmt|;
name|char
name|countit
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|VOID
name|msgprint
parameter_list|(
name|e
parameter_list|)
name|struct
name|error
modifier|*
name|e
decl_stmt|;
block|{
if|if
condition|(
name|printit
argument_list|(
name|stderr
argument_list|,
name|e
argument_list|)
condition|)
operator|++
name|cnterr
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|errtype
operator|==
name|EXITERR
condition|)
block|{
if|if
condition|(
name|die
condition|)
block|{
call|(
modifier|*
name|die
call|)
argument_list|()
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
else|else
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Save an error message. */
end_comment

begin_function
name|UNIV
name|msgsave
parameter_list|(
name|e
parameter_list|)
name|struct
name|error
modifier|*
name|e
decl_stmt|;
block|{
name|struct
name|saved
modifier|*
name|sv
decl_stmt|;
name|sv
operator|=
operator|(
expr|struct
name|saved
operator|*
operator|)
name|rmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|saved
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tfp
condition|)
block|{
name|tfp
operator|=
name|tmpfile
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|tfp
condition|)
name|exiterr
argument_list|(
literal|160
argument_list|,
operator|(
expr|struct
name|parse
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
name|sv
operator|->
name|start
operator|=
name|ftell
argument_list|(
name|tfp
argument_list|)
expr_stmt|;
name|sv
operator|->
name|countit
operator|=
operator|(
name|char
operator|)
name|printit
argument_list|(
name|tfp
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|sv
operator|->
name|end
operator|=
name|ftell
argument_list|(
name|tfp
argument_list|)
expr_stmt|;
name|sv
operator|->
name|exiterr
operator|=
call|(
name|char
call|)
argument_list|(
name|e
operator|->
name|errtype
operator|==
name|EXITERR
argument_list|)
expr_stmt|;
return|return
operator|(
name|UNIV
operator|)
name|sv
return|;
block|}
end_function

begin_comment
comment|/* Print a saved error message. */
end_comment

begin_function
name|VOID
name|msgsprint
parameter_list|(
name|p
parameter_list|)
name|UNIV
name|p
decl_stmt|;
block|{
name|struct
name|saved
modifier|*
name|sv
init|=
operator|(
expr|struct
name|saved
operator|*
operator|)
name|p
decl_stmt|;
name|long
name|cnt
decl_stmt|;
name|assert
argument_list|(
name|p
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|tfp
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fseek
argument_list|(
name|tfp
argument_list|,
name|sv
operator|->
name|start
argument_list|,
name|SEEK_SET
argument_list|)
operator|<
literal|0
condition|)
return|return;
comment|/* Temporary files are opened in binary mode, so this is portable. */
name|cnt
operator|=
name|sv
operator|->
name|end
operator|-
name|sv
operator|->
name|start
expr_stmt|;
while|while
condition|(
operator|--
name|cnt
operator|>=
literal|0
condition|)
block|{
name|int
name|c
init|=
name|getc
argument_list|(
name|tfp
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
break|break;
name|putc
argument_list|(
name|c
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|sv
operator|->
name|countit
condition|)
operator|++
name|cnterr
expr_stmt|;
if|if
condition|(
name|sv
operator|->
name|exiterr
condition|)
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Free a sved error message. */
end_comment

begin_function
name|VOID
name|msgsfree
parameter_list|(
name|p
parameter_list|)
name|UNIV
name|p
decl_stmt|;
block|{
name|frem
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return 1 if it should be counted as an error. */
end_comment

begin_function
specifier|static
name|int
name|printit
parameter_list|(
name|efp
parameter_list|,
name|e
parameter_list|)
name|FILE
modifier|*
name|efp
decl_stmt|;
name|struct
name|error
modifier|*
name|e
decl_stmt|;
block|{
name|int
name|indent
decl_stmt|;
name|int
name|countit
decl_stmt|;
name|int
name|hdrcode
decl_stmt|;
name|int
name|filelevel
init|=
operator|-
literal|1
decl_stmt|,
name|prevfilelevel
init|=
operator|-
literal|1
decl_stmt|,
name|toplevel
decl_stmt|;
name|struct
name|location
name|loc
decl_stmt|;
name|char
name|type
index|[
literal|2
index|]
decl_stmt|,
name|severity
index|[
literal|2
index|]
decl_stmt|;
name|assert
argument_list|(
name|e
operator|->
name|errnum
operator|<
name|SIZEOF
argument_list|(
name|messages
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|messages
index|[
name|e
operator|->
name|errnum
index|]
operator|.
name|text
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|prog
condition|)
block|{
name|fprintf
argument_list|(
name|efp
argument_list|,
literal|"%s: "
argument_list|,
name|prog
argument_list|)
expr_stmt|;
name|indent
operator|=
name|strlen
argument_list|(
name|prog
argument_list|)
operator|+
literal|2
expr_stmt|;
comment|/* don't rely on return value of fprintf */
comment|/* Don't want to waste too much space on indenting. */
if|if
condition|(
name|indent
operator|>
literal|10
condition|)
name|indent
operator|=
literal|4
expr_stmt|;
block|}
else|else
name|indent
operator|=
literal|4
expr_stmt|;
for|for
control|(
name|toplevel
operator|=
literal|0
init|;
name|getlocation
argument_list|(
name|toplevel
argument_list|,
operator|&
name|loc
argument_list|)
condition|;
name|toplevel
operator|++
control|)
if|if
condition|(
name|loc
operator|.
name|filesw
condition|)
block|{
name|prevfilelevel
operator|=
name|filelevel
expr_stmt|;
name|filelevel
operator|=
name|toplevel
expr_stmt|;
block|}
name|toplevel
operator|--
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|errtype
operator|==
name|FILERR
condition|)
block|{
name|toplevel
operator|--
expr_stmt|;
name|filelevel
operator|=
name|prevfilelevel
expr_stmt|;
block|}
if|if
condition|(
name|swenttr
operator|&&
name|filelevel
operator|>
literal|0
condition|)
block|{
name|int
name|level
init|=
literal|0
decl_stmt|;
name|int
name|middle
init|=
literal|0
decl_stmt|;
comment|/* in the middle of a line */
do|do
block|{
operator|(
name|void
operator|)
name|getlocation
argument_list|(
name|level
argument_list|,
operator|&
name|loc
argument_list|)
expr_stmt|;
if|if
condition|(
name|loc
operator|.
name|filesw
condition|)
block|{
if|if
condition|(
name|middle
condition|)
block|{
name|fputs
argument_list|(
literal|":\n"
argument_list|,
name|efp
argument_list|)
expr_stmt|;
name|spaces
argument_list|(
name|efp
argument_list|,
name|indent
argument_list|)
expr_stmt|;
block|}
else|else
name|middle
operator|=
literal|1
expr_stmt|;
name|xfprintf
argument_list|(
name|efp
argument_list|,
name|getheader
argument_list|(
name|HDRPFX
argument_list|)
argument_list|)
expr_stmt|;
name|xfprintf
argument_list|(
name|efp
argument_list|,
name|getheader
argument_list|(
name|HDRLOC
argument_list|)
argument_list|,
name|ioflid
argument_list|(
name|loc
operator|.
name|fcb
argument_list|)
argument_list|,
name|loc
operator|.
name|ename
argument_list|,
name|loc
operator|.
name|rcnt
argument_list|,
name|loc
operator|.
name|ccnt
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|middle
condition|)
name|xfprintf
argument_list|(
name|efp
argument_list|,
name|getheader
argument_list|(
name|HDRELOC
argument_list|)
argument_list|,
name|loc
operator|.
name|ename
argument_list|,
name|loc
operator|.
name|rcnt
operator|+
literal|1
argument_list|,
name|loc
operator|.
name|ccnt
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|++
name|level
operator|!=
name|filelevel
condition|)
do|;
if|if
condition|(
name|middle
condition|)
block|{
name|fputs
argument_list|(
literal|":\n"
argument_list|,
name|efp
argument_list|)
expr_stmt|;
name|spaces
argument_list|(
name|efp
argument_list|,
name|indent
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* We use strings for the type and severity, 	so that the format can use %.0s to ignore them. */
name|type
index|[
literal|0
index|]
operator|=
name|messages
index|[
name|e
operator|->
name|errnum
index|]
operator|.
name|type
expr_stmt|;
name|type
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|severity
index|[
literal|0
index|]
operator|=
name|messages
index|[
name|e
operator|->
name|errnum
index|]
operator|.
name|severity
expr_stmt|;
name|severity
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|countit
operator|=
operator|(
name|severity
index|[
literal|0
index|]
operator|!=
literal|'I'
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|countit
condition|)
name|hdrcode
operator|=
name|HDRWARN
expr_stmt|;
elseif|else
if|if
condition|(
name|type
index|[
literal|0
index|]
operator|==
literal|'R'
condition|)
name|hdrcode
operator|=
name|HDRSYS
expr_stmt|;
elseif|else
if|if
condition|(
name|type
index|[
literal|0
index|]
operator|==
literal|'U'
condition|)
name|hdrcode
operator|=
name|HDRUNSUP
expr_stmt|;
else|else
name|hdrcode
operator|=
name|HDRALL
expr_stmt|;
name|xfprintf
argument_list|(
name|efp
argument_list|,
name|getheader
argument_list|(
name|hdrcode
argument_list|)
argument_list|,
name|type
argument_list|,
name|severity
argument_list|,
name|e
operator|->
name|errnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|filelevel
operator|>=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|getlocation
argument_list|(
name|filelevel
argument_list|,
operator|&
name|loc
argument_list|)
expr_stmt|;
name|xfprintf
argument_list|(
name|efp
argument_list|,
name|getheader
argument_list|(
name|HDRLOC
argument_list|)
argument_list|,
name|ioflid
argument_list|(
name|loc
operator|.
name|fcb
argument_list|)
argument_list|,
name|loc
operator|.
name|ename
argument_list|,
name|loc
operator|.
name|rcnt
argument_list|,
name|loc
operator|.
name|ccnt
argument_list|)
expr_stmt|;
while|while
condition|(
name|filelevel
operator|<
name|toplevel
condition|)
block|{
operator|++
name|filelevel
expr_stmt|;
if|if
condition|(
name|swenttr
condition|)
block|{
operator|(
name|void
operator|)
name|getlocation
argument_list|(
name|filelevel
argument_list|,
operator|&
name|loc
argument_list|)
expr_stmt|;
name|xfprintf
argument_list|(
name|efp
argument_list|,
name|getheader
argument_list|(
name|HDRELOC
argument_list|)
argument_list|,
name|loc
operator|.
name|ename
argument_list|,
name|loc
operator|.
name|rcnt
operator|+
literal|1
argument_list|,
name|loc
operator|.
name|ccnt
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* It is necessary to copy the result of getparm() because 	the specification of catgets() says in can return a  	pointer to a static buffer which may get overwritten 	by the next call to catgets(). */
switch|switch
condition|(
name|e
operator|->
name|errtype
condition|)
block|{
case|case
name|MDERR
case|:
name|strncpy
argument_list|(
name|parmbuf
argument_list|,
name|getparm
argument_list|(
name|e
operator|->
name|errsp
argument_list|)
argument_list|,
name|PARMBUFSIZ
operator|*
literal|2
operator|-
literal|1
argument_list|)
expr_stmt|;
name|xfprintf
argument_list|(
name|efp
argument_list|,
name|getheader
argument_list|(
name|HDRMD
argument_list|)
argument_list|,
name|parmbuf
argument_list|,
operator|(
name|e
operator|->
name|subdcl
condition|?
name|e
operator|->
name|subdcl
else|:
operator|(
name|UNCH
operator|*
operator|)
literal|""
operator|)
argument_list|,
name|e
operator|->
name|parmno
argument_list|)
expr_stmt|;
break|break;
case|case
name|MDERR2
case|:
comment|/* no subdcl parameter */
name|strncpy
argument_list|(
name|parmbuf
argument_list|,
name|getparm
argument_list|(
name|e
operator|->
name|errsp
argument_list|)
argument_list|,
name|PARMBUFSIZ
operator|*
literal|2
operator|-
literal|1
argument_list|)
expr_stmt|;
name|xfprintf
argument_list|(
name|efp
argument_list|,
name|getheader
argument_list|(
name|HDRMD2
argument_list|)
argument_list|,
name|parmbuf
argument_list|,
name|e
operator|->
name|parmno
argument_list|)
expr_stmt|;
break|break;
case|case
name|DOCERR
case|:
case|case
name|EXITERR
case|:
if|if
condition|(
name|toplevel
operator|<
literal|0
condition|)
break|break;
name|strncpy
argument_list|(
name|parmbuf
argument_list|,
name|getparm
argument_list|(
name|e
operator|->
name|errsp
argument_list|)
argument_list|,
name|PARMBUFSIZ
operator|*
literal|2
operator|-
literal|1
argument_list|)
expr_stmt|;
name|xfprintf
argument_list|(
name|efp
argument_list|,
name|getheader
argument_list|(
name|HDRMODE
argument_list|)
argument_list|,
name|parmbuf
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|loc
operator|.
name|curchar
condition|)
block|{
case|case
name|EOFCHAR
case|:
name|xfprintf
argument_list|(
name|efp
argument_list|,
name|getheader
argument_list|(
name|HDREOF
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RSCHAR
case|:
name|xfprintf
argument_list|(
name|efp
argument_list|,
name|getheader
argument_list|(
name|HDRRS
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RECHAR
case|:
name|xfprintf
argument_list|(
name|efp
argument_list|,
name|getheader
argument_list|(
name|HDRRE
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DELNONCH
case|:
name|xfprintf
argument_list|(
name|efp
argument_list|,
name|getheader
argument_list|(
name|HDRCTL
argument_list|)
argument_list|,
name|UNSHIFTNON
argument_list|(
name|loc
operator|.
name|nextchar
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOS
case|:
name|xfprintf
argument_list|(
name|efp
argument_list|,
name|getheader
argument_list|(
name|HDREE
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOBCHAR
case|:
break|break;
default|default:
if|if
condition|(
name|ISASCII
argument_list|(
name|loc
operator|.
name|curchar
argument_list|)
operator|&&
name|isprint
argument_list|(
name|loc
operator|.
name|curchar
argument_list|)
condition|)
name|xfprintf
argument_list|(
name|efp
argument_list|,
name|getheader
argument_list|(
name|HDRPRT
argument_list|)
argument_list|,
name|loc
operator|.
name|curchar
argument_list|)
expr_stmt|;
else|else
name|xfprintf
argument_list|(
name|efp
argument_list|,
name|getheader
argument_list|(
name|HDRCTL
argument_list|)
argument_list|,
name|loc
operator|.
name|curchar
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FILERR
case|:
if|if
condition|(
name|getlocation
argument_list|(
name|toplevel
operator|+
literal|1
argument_list|,
operator|&
name|loc
argument_list|)
condition|)
name|xfprintf
argument_list|(
name|efp
argument_list|,
name|getheader
argument_list|(
name|HDRFIL
argument_list|)
argument_list|,
name|ioflid
argument_list|(
name|loc
operator|.
name|fcb
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|fputs
argument_list|(
literal|":\n"
argument_list|,
name|efp
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|errtype
operator|==
name|FILERR
operator|&&
name|e
operator|->
name|sverrno
operator|!=
literal|0
condition|)
block|{
name|char
modifier|*
name|errstr
init|=
name|strerror
argument_list|(
name|e
operator|->
name|sverrno
argument_list|)
decl_stmt|;
name|UNS
name|len
init|=
name|strlen
argument_list|(
name|errstr
argument_list|)
decl_stmt|;
comment|/* Strip a trailing newline if there is one. */
if|if
condition|(
name|len
operator|>
literal|0
operator|&&
name|errstr
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|len
operator|--
expr_stmt|;
name|spaces
argument_list|(
name|efp
argument_list|,
name|indent
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|len
operator|>
literal|0
condition|;
name|len
operator|--
operator|,
name|errstr
operator|++
control|)
name|putc
argument_list|(
operator|*
name|errstr
argument_list|,
name|efp
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|":\n"
argument_list|,
name|efp
argument_list|)
expr_stmt|;
block|}
name|spaces
argument_list|(
name|efp
argument_list|,
name|indent
argument_list|)
expr_stmt|;
name|xfprintf
argument_list|(
name|efp
argument_list|,
name|gettext
argument_list|(
name|e
operator|->
name|errnum
argument_list|)
argument_list|,
name|transparm
argument_list|(
operator|(
name|UNCH
operator|*
operator|)
name|e
operator|->
name|eparm
index|[
literal|0
index|]
argument_list|,
name|parmbuf1
argument_list|)
argument_list|,
name|transparm
argument_list|(
operator|(
name|UNCH
operator|*
operator|)
name|e
operator|->
name|eparm
index|[
literal|1
index|]
argument_list|,
name|parmbuf2
argument_list|)
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|efp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sweltr
condition|)
name|elttrace
argument_list|(
name|efp
argument_list|,
name|indent
argument_list|)
expr_stmt|;
return|return
name|countit
return|;
block|}
end_function

begin_comment
comment|/* Print an element trace. */
end_comment

begin_function
specifier|static
name|VOID
name|elttrace
parameter_list|(
name|efp
parameter_list|,
name|indent
parameter_list|)
name|FILE
modifier|*
name|efp
decl_stmt|;
name|int
name|indent
decl_stmt|;
block|{
name|int
name|i
init|=
literal|1
decl_stmt|;
name|UNCH
modifier|*
name|gi
decl_stmt|;
name|gi
operator|=
name|getgi
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|gi
condition|)
return|return;
name|spaces
argument_list|(
name|efp
argument_list|,
name|indent
argument_list|)
expr_stmt|;
name|xfprintf
argument_list|(
name|efp
argument_list|,
name|getheader
argument_list|(
name|HDRELT
argument_list|)
argument_list|)
expr_stmt|;
do|do
block|{
name|fprintf
argument_list|(
name|efp
argument_list|,
literal|" %s"
argument_list|,
name|gi
argument_list|)
expr_stmt|;
name|gi
operator|=
name|getgi
argument_list|(
operator|++
name|i
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|gi
condition|)
do|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|efp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|VOID
name|spaces
parameter_list|(
name|efp
parameter_list|,
name|indent
parameter_list|)
name|FILE
modifier|*
name|efp
decl_stmt|;
name|int
name|indent
decl_stmt|;
block|{
while|while
condition|(
operator|--
name|indent
operator|>=
literal|0
condition|)
name|putc
argument_list|(
literal|' '
argument_list|,
name|efp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|VOID
name|msginit
parameter_list|(
name|swp
parameter_list|)
name|struct
name|switches
modifier|*
name|swp
decl_stmt|;
block|{
name|catd
operator|=
name|swp
operator|->
name|catd
expr_stmt|;
name|prog
operator|=
name|swp
operator|->
name|prog
expr_stmt|;
name|sweltr
operator|=
name|swp
operator|->
name|sweltr
expr_stmt|;
name|swenttr
operator|=
name|swp
operator|->
name|swenttr
expr_stmt|;
name|die
operator|=
name|swp
operator|->
name|die
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the error count. */
end_comment

begin_function
name|int
name|msgcnterr
parameter_list|()
block|{
return|return
name|cnterr
return|;
block|}
end_function

begin_comment
comment|/* Transform a parameter into a form suitable for printing. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|transparm
parameter_list|(
name|s
parameter_list|,
name|buf
parameter_list|)
name|UNCH
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
block|{
name|char
modifier|*
name|ptr
decl_stmt|;
name|int
name|cnt
decl_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
return|return
literal|0
return|;
name|ptr
operator|=
name|buf
expr_stmt|;
name|cnt
operator|=
name|PARMBUFSIZ
operator|-
literal|4
expr_stmt|;
comment|/* space for `...\0'  */
while|while
condition|(
operator|*
name|s
condition|)
block|{
name|UNCH
name|ch
init|=
operator|*
name|s
operator|++
decl_stmt|;
if|if
condition|(
name|ch
operator|==
name|DELNONCH
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'\0'
condition|)
break|break;
name|ch
operator|=
name|UNSHIFTNON
argument_list|(
operator|*
name|s
argument_list|)
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|ch
operator|==
name|DELCDATA
operator|||
name|ch
operator|==
name|DELSDATA
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'\\'
condition|)
block|{
if|if
condition|(
name|cnt
operator|<
literal|2
condition|)
break|break;
operator|*
name|ptr
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
literal|'\\'
expr_stmt|;
name|cnt
operator|-=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ISASCII
argument_list|(
name|ch
argument_list|)
operator|&&
name|isprint
argument_list|(
name|ch
argument_list|)
condition|)
block|{
if|if
condition|(
name|cnt
operator|<
literal|1
condition|)
break|break;
operator|*
name|ptr
operator|++
operator|=
name|ch
expr_stmt|;
name|cnt
operator|--
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|cnt
operator|<
literal|4
condition|)
break|break;
name|sprintf
argument_list|(
name|ptr
argument_list|,
literal|"\\%03o"
argument_list|,
name|ch
argument_list|)
expr_stmt|;
name|ptr
operator|+=
literal|4
expr_stmt|;
name|cnt
operator|-=
literal|4
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
operator|*
name|s
condition|)
operator|*
name|ptr
operator|=
literal|'\0'
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|"..."
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_comment
comment|/* The message and set numbers in the catgets function must be> 0. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|gettext
parameter_list|(
name|n
parameter_list|)
name|int
name|n
decl_stmt|;
block|{
name|assert
argument_list|(
name|n
operator|>
literal|0
operator|&&
name|n
operator|<
name|SIZEOF
argument_list|(
name|messages
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|messages
index|[
name|n
index|]
operator|.
name|text
operator|!=
literal|0
argument_list|)
expr_stmt|;
return|return
name|catgets
argument_list|(
name|catd
argument_list|,
name|TEXT_SET
argument_list|,
name|n
argument_list|,
name|messages
index|[
name|n
index|]
operator|.
name|text
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|getheader
parameter_list|(
name|n
parameter_list|)
name|int
name|n
decl_stmt|;
block|{
name|assert
argument_list|(
name|n
operator|>=
literal|0
operator|&&
name|n
operator|<
name|SIZEOF
argument_list|(
name|headers
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|catgets
argument_list|(
name|catd
argument_list|,
name|HEADER_SET
argument_list|,
name|n
operator|+
literal|1
argument_list|,
name|headers
index|[
name|n
index|]
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|getparm
parameter_list|(
name|n
parameter_list|)
name|int
name|n
decl_stmt|;
block|{
name|assert
argument_list|(
name|n
operator|>=
literal|0
operator|&&
name|n
operator|<
name|SIZEOF
argument_list|(
name|parms
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|catgets
argument_list|(
name|catd
argument_list|,
name|PARM_SET
argument_list|,
name|n
operator|+
literal|1
argument_list|,
name|parms
index|[
name|n
index|]
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Local Variables: c-indent-level: 5 c-continued-statement-offset: 5 c-brace-offset: -5 c-argdecl-indent: 0 c-label-offset: -5 End: */
end_comment

end_unit

