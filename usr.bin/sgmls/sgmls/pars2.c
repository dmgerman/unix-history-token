begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"sgmlincl.h"
end_include

begin_comment
comment|/* #INCLUDE statements for SGML parser. */
end_comment

begin_comment
comment|/* PARSE: Parse a source input stream with specified lexical and state tables.           Return to caller with action code. */
end_comment

begin_function
name|int
name|parse
parameter_list|(
name|pcb
parameter_list|)
name|struct
name|parse
modifier|*
name|pcb
decl_stmt|;
comment|/* Current parse control block. */
block|{
name|int
name|rc
decl_stmt|;
comment|/* Return code from ENTREF. */
while|while
condition|(
literal|1
condition|)
block|{
name|NEWCC
expr_stmt|;
name|pcb
operator|->
name|input
operator|=
name|pcb
operator|->
name|plex
index|[
operator|*
name|FPOS
index|]
expr_stmt|;
name|pcb
operator|->
name|state
operator|=
name|pcb
operator|->
name|newstate
expr_stmt|;
name|pcb
operator|->
name|newstate
operator|=
operator|(
operator|*
operator|(
name|pcb
operator|->
name|ptab
operator|+
name|pcb
operator|->
name|state
operator|)
operator|)
index|[
name|pcb
operator|->
name|input
index|]
expr_stmt|;
name|pcb
operator|->
name|action
operator|=
operator|(
operator|*
operator|(
name|pcb
operator|->
name|ptab
operator|+
name|pcb
operator|->
name|state
operator|+
literal|1
operator|)
operator|)
index|[
name|pcb
operator|->
name|input
index|]
expr_stmt|;
name|TRACEPCB
argument_list|(
name|pcb
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pcb
operator|->
name|action
condition|)
block|{
case|case
name|RC2_
case|:
comment|/* Back up two characters. */
name|REPEATCC
expr_stmt|;
case|case
name|RCC_
case|:
comment|/* Repeat current character. */
name|REPEATCC
expr_stmt|;
case|case
name|NOP_
case|:
comment|/* No action necessary.*/
continue|continue;
case|case
name|RS_
case|:
comment|/* Record start: ccnt=0; ++rcnt.*/
operator|++
name|RCNT
expr_stmt|;
name|CTRSET
argument_list|(
name|RSCC
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|GET_
case|:
comment|/* EOB or dull EOS or EE found: keep going.*/
if|if
condition|(
name|entget
argument_list|()
operator|==
operator|-
literal|1
condition|)
block|{
name|pcb
operator|->
name|action
operator|=
name|EOD_
expr_stmt|;
break|break;
block|}
comment|/* Signal if EOD.*/
continue|continue;
case|case
name|EOF_
case|:
comment|/* Illegal entity end; return EE_. */
name|synerr
argument_list|(
name|E_EOF
argument_list|,
name|pcb
argument_list|)
expr_stmt|;
name|pcb
operator|->
name|action
operator|=
name|EE_
expr_stmt|;
case|case
name|EE_
case|:
comment|/* Important EOS or EE found: return to caller.*/
if|if
condition|(
name|entget
argument_list|()
operator|==
operator|-
literal|1
condition|)
name|pcb
operator|->
name|action
operator|=
name|EOD_
expr_stmt|;
comment|/* Signal if EOD. */
break|break;
case|case
name|PER_
case|:
comment|/* Parameter entity reference. */
name|REPEATCC
expr_stmt|;
comment|/* Use PERO as 1st char of entity name. */
name|parsenm
argument_list|(
name|entbuf
argument_list|,
name|ENTCASE
argument_list|)
expr_stmt|;
name|parse
argument_list|(
operator|&
name|pcbref
argument_list|)
expr_stmt|;
comment|/* Handle REFC or other terminator. */
name|rc
operator|=
name|entref
argument_list|(
name|entbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
name|ENTPI
condition|)
block|{
name|pcb
operator|->
name|action
operator|=
name|PIE_
expr_stmt|;
break|break;
block|}
continue|continue;
case|case
name|ER_
case|:
comment|/* General entity reference; continue. */
name|parsenm
argument_list|(
name|entbuf
argument_list|,
name|ENTCASE
argument_list|)
expr_stmt|;
name|parse
argument_list|(
operator|&
name|pcbref
argument_list|)
expr_stmt|;
comment|/* Handle REFC or other terminator. */
name|rc
operator|=
name|entref
argument_list|(
name|entbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
name|ENTDATA
condition|)
block|{
name|pcb
operator|->
name|action
operator|=
name|DEF_
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|rc
operator|==
name|ENTPI
condition|)
block|{
name|pcb
operator|->
name|action
operator|=
name|PIE_
expr_stmt|;
break|break;
block|}
continue|continue;
case|case
name|PEX_
case|:
comment|/* Parameter entity reference; return. */
name|REPEATCC
expr_stmt|;
comment|/* Use PERO as 1st char of entity name. */
case|case
name|ERX_
case|:
comment|/* General entity reference; return. */
name|parsenm
argument_list|(
name|entbuf
argument_list|,
name|ENTCASE
argument_list|)
expr_stmt|;
name|parse
argument_list|(
operator|&
name|pcbref
argument_list|)
expr_stmt|;
comment|/* Handle REFC or other terminator. */
name|rc
operator|=
name|entref
argument_list|(
name|entbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
name|ENTDATA
condition|)
block|{
comment|/* Reference to external data/subdoc entity in replaceable 		       character data. */
if|if
condition|(
name|BITON
argument_list|(
name|entdatsw
argument_list|,
name|NDECONT
argument_list|)
condition|)
block|{
switch|switch
condition|(
operator|(
operator|(
name|PNE
operator|)
name|data
operator|)
operator|->
name|nextype
condition|)
block|{
case|case
name|ESNCDATA
case|:
case|case
name|ESNSDATA
case|:
comment|/* The standard says `non-SGML data entity' 				 but the amendment should have changed it 				 to `external data entity'. */
name|synerr
argument_list|(
literal|145
argument_list|,
name|pcb
argument_list|)
expr_stmt|;
break|break;
case|case
name|ESNNDATA
case|:
case|case
name|ESNSUB
case|:
comment|/* This is definitely illegal. */
name|synerr
argument_list|(
literal|141
argument_list|,
name|pcb
argument_list|)
expr_stmt|;
break|break;
block|}
name|entdatsw
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
name|pcb
operator|->
name|action
operator|=
name|DEF_
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rc
operator|==
name|ENTPI
condition|)
block|{
comment|/* Reference to PI entity not allowed in replaceable 		       character data. */
name|synerr
argument_list|(
literal|59
argument_list|,
name|pcb
argument_list|)
expr_stmt|;
name|entpisw
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|rc
condition|)
name|pcb
operator|->
name|action
operator|=
name|EE_
expr_stmt|;
break|break;
case|case
name|CRN_
case|:
comment|/* Character reference: numeric. */
name|parsetkn
argument_list|(
name|entbuf
argument_list|,
name|NU
argument_list|,
name|NAMELEN
argument_list|)
expr_stmt|;
name|parse
argument_list|(
operator|&
name|pcbref
argument_list|)
expr_stmt|;
comment|/* Handle reference terminator. */
name|pcb
operator|->
name|action
operator|=
name|charrefn
argument_list|(
name|entbuf
argument_list|,
name|pcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcb
operator|->
name|action
operator|==
name|CRN_
condition|)
continue|continue;
comment|/* Invalid reference */
break|break;
case|case
name|CRA_
case|:
comment|/* Character reference: alphabetic. */
name|parsenm
argument_list|(
name|entbuf
argument_list|,
name|NAMECASE
argument_list|)
expr_stmt|;
name|parse
argument_list|(
operator|&
name|pcbref
argument_list|)
expr_stmt|;
comment|/* Handle reference terminator. */
name|charrefa
argument_list|(
name|entbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|docelsw
condition|)
name|synerr
argument_list|(
literal|232
argument_list|,
name|pcb
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|SYS_
case|:
comment|/* Invalid NONCHAR: send msg and ignore. */
name|synerr
argument_list|(
name|E_SYS
argument_list|,
name|pcb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|FPOS
operator|==
name|DELNONCH
condition|)
name|NEWCC
expr_stmt|;
continue|continue;
case|case
name|NON_
case|:
comment|/* Valid NONCHAR: prefix and shift encoding. */
name|synerr
argument_list|(
literal|60
argument_list|,
name|pcb
argument_list|)
expr_stmt|;
name|pcb
operator|->
name|action
operator|=
name|datachar
argument_list|(
operator|*
name|FPOS
argument_list|,
name|pcb
argument_list|)
expr_stmt|;
break|break;
case|case
name|NSC_
case|:
name|synerr
argument_list|(
literal|60
argument_list|,
name|pcb
argument_list|)
expr_stmt|;
name|NEWCC
expr_stmt|;
name|nonchbuf
index|[
literal|1
index|]
operator|=
operator|*
name|FPOS
expr_stmt|;
name|pcb
operator|->
name|action
operator|=
name|NON_
expr_stmt|;
break|break;
case|case
name|PCI_
case|:
comment|/* Previous character was invalid (INV_). */
name|REPEATCC
expr_stmt|;
case|case
name|INV_
case|:
comment|/* Markup ended by invalid char; repeat char. */
name|synerr
argument_list|(
literal|9
argument_list|,
name|pcb
argument_list|)
expr_stmt|;
name|REPEATCC
expr_stmt|;
break|break;
case|case
name|LNR_
case|:
comment|/* Previous char exceeded len; back up to it. */
name|REPEATCC
expr_stmt|;
case|case
name|LEN_
case|:
comment|/* Token too long; ignore excess character. */
name|synerr
argument_list|(
literal|3
argument_list|,
name|pcb
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|RCR_
case|:
comment|/* Repeat current char and return to caller. */
name|REPEATCC
expr_stmt|;
default|default:
comment|/* Actions for specific parse. */
break|break;
block|}
return|return
operator|(
name|int
operator|)
name|pcb
operator|->
name|action
return|;
block|}
block|}
end_function

begin_comment
comment|/* CHARREFA: Resolve an alphabetical reference to a function character              and put the character in the read buffer.              If reference is bad, issue an error message. */
end_comment

begin_function
name|VOID
name|charrefa
parameter_list|(
name|r
parameter_list|)
name|UNCH
modifier|*
name|r
decl_stmt|;
comment|/* Undelimited char ref (with length and EOS). */
block|{
name|UNCH
name|thechar
decl_stmt|;
name|thechar
operator|=
name|mapsrch
argument_list|(
name|funtab
argument_list|,
name|r
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|thechar
operator|==
literal|0
condition|)
name|synerr
argument_list|(
literal|62
argument_list|,
operator|&
name|pcbref
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* This isn't ideal, because the character position will still 	     be wrong for one line. */
if|if
condition|(
name|thechar
operator|==
name|RSCHAR
condition|)
name|RCNT
operator|--
expr_stmt|;
name|setcurchar
argument_list|(
name|thechar
argument_list|)
expr_stmt|;
name|REPEATCC
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Make the current character ch. */
end_comment

begin_function
name|VOID
name|setcurchar
parameter_list|(
name|ch
parameter_list|)
name|int
name|ch
decl_stmt|;
block|{
comment|/* If we're reading directly from an internal entity, we can't 	change the entity, since the entity might be referenced again. 	So in this case we copy the entity.  This is inefficient, but 	it will only happen in a case like this:<!entity % amp "&"><!entity e "x%amp;#SPACE;"> 	 	Usually character references will have been processed while the 	entity was being defined.  */
if|if
condition|(
operator|*
name|FPOS
operator|!=
name|ch
condition|)
block|{
if|if
condition|(
operator|!
name|FILESW
operator|&&
operator|!
name|COPIEDSW
condition|)
block|{
name|UNCH
modifier|*
name|s
init|=
name|savestr
argument_list|(
name|FBUF
operator|+
literal|1
argument_list|)
decl_stmt|;
name|FPOS
operator|=
name|s
operator|+
operator|(
name|FPOS
operator|-
name|FBUF
operator|-
literal|1
operator|)
expr_stmt|;
name|FBUF
operator|=
name|s
operator|-
literal|1
expr_stmt|;
name|COPIEDSW
operator|=
literal|1
expr_stmt|;
block|}
operator|*
name|FPOS
operator|=
name|ch
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* CHARREFN: Resolve a numeric character reference.              If reference is bad, issue an error message. */
end_comment

begin_function
name|int
name|charrefn
parameter_list|(
name|r
parameter_list|,
name|pcb
parameter_list|)
name|UNCH
modifier|*
name|r
decl_stmt|;
comment|/* Undelimited character reference. */
name|struct
name|parse
modifier|*
name|pcb
decl_stmt|;
comment|/* Current parse control block. */
block|{
name|int
name|thechar
decl_stmt|;
name|thechar
operator|=
name|atoi
argument_list|(
operator|(
name|char
operator|*
operator|)
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|thechar
operator|<
literal|0
operator|||
name|thechar
operator|>
literal|255
condition|)
block|{
name|synerr
argument_list|(
literal|61
argument_list|,
operator|&
name|pcbref
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|int
operator|)
name|pcb
operator|->
name|action
operator|)
return|;
block|}
return|return
name|datachar
argument_list|(
name|thechar
argument_list|,
name|pcb
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return ch as a datachar.  If this a non-SGML character which might confuse the parser, shift it to a code that won't and place it in a special buffer which has DELNONCH in the preceding byte.  Otherwise put it the read buffer. */
end_comment

begin_function
name|int
name|datachar
parameter_list|(
name|ch
parameter_list|,
name|pcb
parameter_list|)
name|int
name|ch
decl_stmt|;
name|struct
name|parse
modifier|*
name|pcb
decl_stmt|;
block|{
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
name|EOS
case|:
case|case
name|EOFCHAR
case|:
case|case
name|EOBCHAR
case|:
case|case
name|GENRECHAR
case|:
case|case
name|DELCDATA
case|:
case|case
name|DELSDATA
case|:
case|case
name|DELNONCH
case|:
comment|/* A potentially confusing character which must be prefixed 	     with DELNONCH. */
name|nonchbuf
index|[
literal|1
index|]
operator|=
name|SHIFTNON
argument_list|(
operator|(
name|UNCH
operator|)
name|ch
argument_list|)
expr_stmt|;
return|return
name|NON_
return|;
block|}
name|setcurchar
argument_list|(
name|ch
argument_list|)
expr_stmt|;
comment|/* If in content, return DCE_ for element content, DAF_ for mixed.  */
comment|/* If not content, it must be a literal parse, so return MLA_. */
if|if
condition|(
name|pcb
operator|==
name|conpcb
condition|)
block|{
if|if
condition|(
name|pcb
operator|==
operator|&
name|pcbcone
condition|)
return|return
name|DCE_
return|;
else|else
block|{
name|data
operator|=
name|FPOS
expr_stmt|;
comment|/* Action for DAF_ will do REPEATCC. */
name|NEWCC
expr_stmt|;
return|return
name|DAF_
return|;
block|}
block|}
else|else
return|return
name|MLA_
return|;
block|}
end_function

begin_comment
comment|/* INITATT: Initialize al with adl. */
end_comment

begin_function
name|VOID
name|initatt
parameter_list|(
name|adl
parameter_list|)
name|struct
name|ad
modifier|*
name|adl
decl_stmt|;
block|{
name|notadn
operator|=
literal|0
expr_stmt|;
comment|/* No NOTATION attribute yet. */
name|conrefsw
operator|=
literal|0
expr_stmt|;
comment|/* Assume no content reference att. */
comment|/* Copy attribute definition list as a template. */
name|memcpy
argument_list|(
operator|(
name|UNIV
operator|)
name|al
argument_list|,
operator|(
name|UNIV
operator|)
name|adl
argument_list|,
operator|(
literal|1
operator|+
name|ADN
argument_list|(
name|adl
argument_list|)
operator|)
operator|*
name|ADSZ
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* PARSEATT: Parse attribute specification list.              Make a current copy of the attribute definition list              and update it with the user's specifications.              Indicate each attribute that was specified in the              list (as opposed to defaulted) by setting the ASPEC flag.              If no attributes were specified, return NULL.  Otherwise,              if in the prolog, make a permanent copy of the list and              return its pointer.  If not in the prolog, return al. */
end_comment

begin_function
name|struct
name|ad
modifier|*
name|parseatt
parameter_list|(
name|adl
parameter_list|,
name|pt
parameter_list|)
name|struct
name|ad
modifier|*
name|adl
decl_stmt|;
comment|/* Attribute definition list. */
name|UNCH
modifier|*
name|pt
decl_stmt|;
comment|/* Tokenization area: tbuf[TAGLEN+ATTSPLEN]. */
block|{
name|UNCH
modifier|*
name|antvptr
decl_stmt|;
name|UNCH
modifier|*
name|nm
init|=
literal|0
decl_stmt|;
comment|/* Pointer to saved name in tbuf (with length). */
name|int
name|adn
init|=
operator|-
literal|1
decl_stmt|;
comment|/* Position of attribute in list (-1=empty). */
name|UNCH
modifier|*
name|tbuflim
init|=
name|pt
operator|+
name|ATTSPLEN
decl_stmt|;
name|mdessv
operator|=
name|es
expr_stmt|;
comment|/* Save es for checking entity nesting. */
name|initatt
argument_list|(
name|adl
argument_list|)
expr_stmt|;
while|while
condition|(
name|pt
operator|<=
name|tbuflim
condition|)
block|{
name|parse
argument_list|(
operator|&
name|pcbstag
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pcbstag
operator|.
name|action
condition|)
block|{
case|case
name|NVS
case|:
comment|/* Att name or value token found. */
name|parsenm
argument_list|(
name|pt
argument_list|,
name|NAMECASE
argument_list|)
expr_stmt|;
comment|/* Case translation wanted on name. */
name|pt
operator|+=
operator|*
operator|(
name|nm
operator|=
name|pt
operator|)
expr_stmt|;
comment|/* Save name while pointing past it. */
continue|continue;
case|case
name|AVD
case|:
comment|/* Delimited value found. */
case|case
name|AVDA
case|:
comment|/* Delimited value found (alternate delimiter). */
comment|/* Find position (adn) of saved attribute name in list. */
name|adn
operator|=
name|anmget
argument_list|(
operator|(
name|int
operator|)
name|ADN
argument_list|(
name|al
argument_list|)
argument_list|,
name|nm
argument_list|)
expr_stmt|;
name|parselit
argument_list|(
name|pt
argument_list|,
operator|(
name|adn
operator|==
literal|0
operator|||
name|ADTYPE
argument_list|(
name|al
argument_list|,
name|adn
argument_list|)
operator|==
name|ACHARS
operator|)
condition|?
operator|&
name|pcblitr
else|:
operator|&
name|pcblitt
argument_list|,
name|LITLEN
argument_list|,
operator|(
name|pcbstag
operator|.
name|action
operator|==
name|AVD
operator|)
condition|?
name|lex
operator|.
name|d
operator|.
name|lit
else|:
name|lex
operator|.
name|d
operator|.
name|lita
argument_list|)
expr_stmt|;
if|if
condition|(
name|adn
operator|==
literal|0
condition|)
block|{
comment|/* Error: unrecognized attribute name. */
name|sgmlerr
argument_list|(
literal|13
argument_list|,
operator|&
name|pcbstag
argument_list|,
name|nm
operator|+
literal|1
argument_list|,
name|pt
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Tokenize and validate value; let it default if an error. */
comment|/* Put value in list and bump ptr by the normalized length                   (which is always>= the actual length). */
if|if
condition|(
operator|!
name|attval
argument_list|(
literal|1
argument_list|,
name|pt
argument_list|,
name|adn
argument_list|,
name|adl
argument_list|)
condition|)
name|pt
operator|+=
name|ADLEN
argument_list|(
name|al
argument_list|,
name|adn
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|AVU
case|:
comment|/* Attribute value found: undelimited. */
if|if
condition|(
operator|!
name|sd
operator|.
name|shorttag
condition|)
name|sgmlerr
argument_list|(
literal|196
argument_list|,
operator|&
name|pcbstag
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|parsetkn
argument_list|(
name|pt
argument_list|,
name|NMC
argument_list|,
name|LITLEN
argument_list|)
expr_stmt|;
comment|/* Find position (adn) of saved attribute name in list. */
if|if
condition|(
operator|(
name|adn
operator|=
name|anmget
argument_list|(
operator|(
name|int
operator|)
name|ADN
argument_list|(
name|al
argument_list|)
argument_list|,
name|nm
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Error: unrecognized attribute name. */
name|sgmlerr
argument_list|(
literal|13
argument_list|,
operator|&
name|pcbstag
argument_list|,
name|nm
operator|+
literal|1
argument_list|,
name|pt
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Tokenize and validate value; let it default if an error. */
comment|/* Put value in list and bump ptr by the normalized length                   (which is always>= the actual length). */
if|if
condition|(
operator|!
name|attval
argument_list|(
literal|1
argument_list|,
name|pt
argument_list|,
name|adn
argument_list|,
name|adl
argument_list|)
condition|)
name|pt
operator|+=
name|ADLEN
argument_list|(
name|al
argument_list|,
name|adn
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|NASV
case|:
comment|/* Saved NVS was really an NTV. */
name|REPEATCC
expr_stmt|;
comment|/* Put back next token starter. */
name|pt
operator|=
name|nm
expr_stmt|;
comment|/* Back up to NVS. */
case|case
name|NTV
case|:
comment|/* Name token value found. */
if|if
condition|(
operator|!
name|sd
operator|.
name|shorttag
condition|)
name|sgmlerr
argument_list|(
literal|195
argument_list|,
operator|&
name|pcbstag
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcbstag
operator|.
name|action
operator|==
name|NTV
condition|)
name|parsenm
argument_list|(
name|pt
argument_list|,
name|NAMECASE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|adn
operator|=
name|antvget
argument_list|(
operator|(
name|int
operator|)
name|ADN
argument_list|(
name|al
argument_list|)
argument_list|,
name|pt
argument_list|,
operator|&
name|antvptr
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Error: unrecognized name token value. */
name|sgmlerr
argument_list|(
literal|74
argument_list|,
operator|&
name|pcbstag
argument_list|,
name|pt
operator|+
literal|1
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Validate value; let it default if an error. */
comment|/* Put value in list and bump ptr by the normalized length                   (which is always>= the actual length). */
if|if
condition|(
operator|!
name|attval
argument_list|(
literal|0
argument_list|,
name|antvptr
operator|+
literal|1
argument_list|,
name|adn
argument_list|,
name|adl
argument_list|)
condition|)
name|pt
operator|+=
name|ADLEN
argument_list|(
name|al
argument_list|,
name|adn
argument_list|)
expr_stmt|;
continue|continue;
default|default:
comment|/* All attributes have been parsed. */
name|REPEATCC
expr_stmt|;
comment|/* Put next char back for tag close parse. */
break|break;
block|}
break|break;
block|}
if|if
condition|(
name|pt
operator|>
name|tbuflim
condition|)
name|synerr
argument_list|(
literal|75
argument_list|,
operator|&
name|pcbstag
argument_list|)
expr_stmt|;
if|if
condition|(
name|es
operator|!=
name|mdessv
condition|)
name|synerr
argument_list|(
literal|37
argument_list|,
operator|&
name|pcbstag
argument_list|)
expr_stmt|;
if|if
condition|(
name|adn
operator|<
literal|0
condition|)
return|return
operator|(
operator|(
expr|struct
name|ad
operator|*
operator|)
literal|0
operator|)
return|;
comment|/* List was empty. */
name|TRACEADL
argument_list|(
name|al
argument_list|)
expr_stmt|;
return|return
name|al
return|;
block|}
end_function

begin_comment
comment|/* ATTVAL: Validate a specified attribute value.  Issue a message if it is            the wrong type (or otherwise is not up to spec), and use the default.            Call PARSEVAL to tokenize the value, unless it is a CDATA string.            If the attribute is a group, the value is a string.            For other types, the token count is set by PARSEVAL if the value            is syntactically correct.  If incorrect (or if CDATA) the token            count is zero (i.e., the value is a string).            The length of a token does not include the length byte, and            there is no EOS.  A string length (as always) includes both            the length byte and the EOS.            If it is a CONREF attribute, set a switch for STAG().            If it is a CURRENT attribute, store the value as the new default. */
end_comment

begin_define
define|#
directive|define
name|DEFVAL
value|adl[adn].addef
end_define

begin_comment
comment|/* Default value of current attribute. */
end_comment

begin_define
define|#
directive|define
name|DEFNUM
value|adl[adn].adnum
end_define

begin_comment
comment|/* Default group size of current attribute. */
end_comment

begin_define
define|#
directive|define
name|DEFLEN
value|adl[adn].adlen
end_define

begin_comment
comment|/* Length of default value of current attribute.*/
end_comment

begin_function
name|int
name|attval
parameter_list|(
name|mtvsw
parameter_list|,
name|adval
parameter_list|,
name|adn
parameter_list|,
name|adl
parameter_list|)
name|int
name|mtvsw
decl_stmt|;
comment|/* Must tokenize value: 1=yes; 0=no. */
name|UNCH
modifier|*
name|adval
decl_stmt|;
comment|/* Untokenized attribute value. */
name|int
name|adn
decl_stmt|;
comment|/* Attribute's position in list. */
name|struct
name|ad
modifier|*
name|adl
decl_stmt|;
comment|/* Element's master att def list. */
block|{
name|int
name|errcode
decl_stmt|;
comment|/* Value/declaration conflict error code. */
if|if
condition|(
name|GET
argument_list|(
name|ADFLAGS
argument_list|(
name|al
argument_list|,
name|adn
argument_list|)
argument_list|,
name|ASPEC
argument_list|)
condition|)
comment|/* Can't respecify same attribute. */
block|{
name|sgmlerr
argument_list|(
literal|73
argument_list|,
operator|&
name|pcbstag
argument_list|,
name|ADNAME
argument_list|(
name|al
argument_list|,
name|adn
argument_list|)
argument_list|,
name|adval
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|SET
argument_list|(
name|ADFLAGS
argument_list|(
name|al
argument_list|,
name|adn
argument_list|)
argument_list|,
name|ASPEC
argument_list|)
expr_stmt|;
comment|/* Indicate att was specified. */
if|if
condition|(
name|GET
argument_list|(
name|ADFLAGS
argument_list|(
name|al
argument_list|,
name|adn
argument_list|)
argument_list|,
name|ACONREF
argument_list|)
condition|)
comment|/* If attribute is content reference: */
name|conrefsw
operator|=
name|TAGREF
expr_stmt|;
comment|/* Set switch for STAG(). */
if|if
condition|(
name|mtvsw
operator|&&
name|ADTYPE
argument_list|(
name|al
argument_list|,
name|adn
argument_list|)
operator|!=
name|ACHARS
condition|)
block|{
comment|/* If no syntax errors, check for proper group membership. */
if|if
condition|(
operator|(
operator|(
name|errcode
operator|=
name|parseval
argument_list|(
name|adval
argument_list|,
name|ADTYPE
argument_list|(
name|al
argument_list|,
name|adn
argument_list|)
argument_list|,
name|lbuf
argument_list|)
operator|)
operator|==
literal|0
operator|)
operator|&&
name|GET
argument_list|(
name|ADFLAGS
argument_list|(
name|al
argument_list|,
name|adn
argument_list|)
argument_list|,
name|AGROUP
argument_list|)
operator|&&
operator|!
name|amemget
argument_list|(
operator|&
name|al
index|[
name|adn
index|]
argument_list|,
name|ADNUM
argument_list|(
name|al
argument_list|,
name|adn
argument_list|)
argument_list|,
name|lbuf
argument_list|)
condition|)
name|errcode
operator|=
literal|18
expr_stmt|;
comment|/* If syntax or group membership error, send message and exit. */
if|if
condition|(
name|errcode
condition|)
block|{
name|sgmlerr
argument_list|(
name|errcode
argument_list|,
operator|&
name|pcbstag
argument_list|,
name|ADNAME
argument_list|(
name|al
argument_list|,
name|adn
argument_list|)
argument_list|,
name|adval
argument_list|)
expr_stmt|;
name|SET
argument_list|(
name|ADFLAGS
argument_list|(
name|al
argument_list|,
name|adn
argument_list|)
argument_list|,
name|AERROR
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* Replace specified value in adval with tokenized in lbuf. */
name|ustrcpy
argument_list|(
name|adval
argument_list|,
name|lbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|BITOFF
argument_list|(
name|ADFLAGS
argument_list|(
name|al
argument_list|,
name|adn
argument_list|)
argument_list|,
name|AGROUP
argument_list|)
condition|)
name|ADNUM
argument_list|(
name|al
argument_list|,
name|adn
argument_list|)
operator|=
operator|(
name|UNCH
operator|)
name|tokencnt
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|mtvsw
condition|)
name|adval
operator|--
expr_stmt|;
comment|/* If attribute is FIXED, specified value must equal default. */
if|if
condition|(
name|BITON
argument_list|(
name|ADFLAGS
argument_list|(
name|al
argument_list|,
name|adn
argument_list|)
argument_list|,
name|AFIXED
argument_list|)
operator|&&
name|ustrcmp
argument_list|(
name|adval
argument_list|,
name|DEFVAL
argument_list|)
condition|)
block|{
comment|/* Since the value has been tokenized, don't use it in the 	     error message. */
name|sgmlerr
argument_list|(
literal|67
argument_list|,
operator|&
name|pcbstag
argument_list|,
name|ADNAME
argument_list|(
name|al
argument_list|,
name|adn
argument_list|)
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|SET
argument_list|(
name|ADFLAGS
argument_list|(
name|al
argument_list|,
name|adn
argument_list|)
argument_list|,
name|AERROR
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|ADLEN
argument_list|(
name|al
argument_list|,
name|adn
argument_list|)
operator|=
name|vallen
argument_list|(
name|ADTYPE
argument_list|(
name|al
argument_list|,
name|adn
argument_list|)
argument_list|,
name|ADNUM
argument_list|(
name|al
argument_list|,
name|adn
argument_list|)
argument_list|,
name|adval
argument_list|)
expr_stmt|;
if|if
condition|(
name|ADLEN
argument_list|(
name|al
argument_list|,
name|adn
argument_list|)
operator|>
name|LITLEN
condition|)
block|{
name|sgmlerr
argument_list|(
literal|224
argument_list|,
operator|&
name|pcbstag
argument_list|,
name|ADNAME
argument_list|(
name|al
argument_list|,
name|adn
argument_list|)
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|SET
argument_list|(
name|ADFLAGS
argument_list|(
name|al
argument_list|,
name|adn
argument_list|)
argument_list|,
name|AERROR
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|ADVAL
argument_list|(
name|al
argument_list|,
name|adn
argument_list|)
operator|=
name|adval
expr_stmt|;
comment|/* If attribute is CURRENT, value is new default.*/
if|if
condition|(
name|GET
argument_list|(
name|ADFLAGS
argument_list|(
name|al
argument_list|,
name|adn
argument_list|)
argument_list|,
name|ACURRENT
argument_list|)
condition|)
block|{
if|if
condition|(
name|ADLEN
argument_list|(
name|al
argument_list|,
name|adn
argument_list|)
operator|>
name|DEFLEN
condition|)
block|{
name|ds
operator|.
name|attdef
operator|+=
operator|(
name|ADLEN
argument_list|(
name|al
argument_list|,
name|adn
argument_list|)
operator|-
name|DEFLEN
operator|)
expr_stmt|;
name|DEFLEN
operator|=
name|ADLEN
argument_list|(
name|al
argument_list|,
name|adn
argument_list|)
expr_stmt|;
block|}
name|DEFVAL
operator|=
name|replace
argument_list|(
name|DEFVAL
argument_list|,
name|ADVAL
argument_list|(
name|al
argument_list|,
name|adn
argument_list|)
argument_list|)
expr_stmt|;
name|DEFNUM
operator|=
name|ADNUM
argument_list|(
name|al
argument_list|,
name|adn
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Indicate value was valid. */
block|}
end_function

begin_comment
comment|/* ADLVAL: Validate the completed attribute definition list (defaults plus            specified values).  Issue a message if an            attribute is required or current and its value is NULL. */
end_comment

begin_function
name|VOID
name|adlval
parameter_list|(
name|adsz
parameter_list|,
name|newetd
parameter_list|)
name|int
name|adsz
decl_stmt|;
comment|/* Size of list. */
name|struct
name|etd
modifier|*
name|newetd
decl_stmt|;
comment|/* Element type definition for this element. */
block|{
name|int
name|adn
init|=
literal|1
decl_stmt|;
comment|/* Position in list. */
name|UNCH
modifier|*
name|npt
decl_stmt|,
modifier|*
name|pt
decl_stmt|;
comment|/* Ptr save areas. */
name|UNCH
name|nptsv
decl_stmt|;
comment|/* Save area for ptr value (length?). */
name|struct
name|dcncb
modifier|*
name|dpt
decl_stmt|;
comment|/* Save area for dcncb ptr. */
name|aentctr
operator|=
literal|0
expr_stmt|;
comment|/* Number of AENTITY tokens in this att list. */
name|idrctr
operator|=
literal|0
expr_stmt|;
comment|/* Number of IDREF tokens in this att list. */
do|do
block|{
if|if
condition|(
name|ADVAL
argument_list|(
name|al
argument_list|,
name|adn
argument_list|)
operator|==
name|NULL
condition|)
block|{
comment|/* NULL value */
if|if
condition|(
name|GET
argument_list|(
name|ADFLAGS
argument_list|(
name|al
argument_list|,
name|adn
argument_list|)
argument_list|,
name|AREQ
operator|+
name|ACURRENT
argument_list|)
condition|)
block|{
comment|/*Error if REQ, CURRENT*/
name|sgmlerr
argument_list|(
literal|19
argument_list|,
operator|&
name|pcbstag
argument_list|,
name|ADNAME
argument_list|(
name|al
argument_list|,
name|adn
argument_list|)
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|SET
argument_list|(
name|ADFLAGS
argument_list|(
name|al
argument_list|,
name|adn
argument_list|)
argument_list|,
name|AINVALID
argument_list|)
expr_stmt|;
block|}
block|}
else|else
switch|switch
condition|(
name|ADTYPE
argument_list|(
name|al
argument_list|,
name|adn
argument_list|)
condition|)
block|{
case|case
name|AENTITY
case|:
comment|/* Return data ecb pointer if valid entity. */
name|aenttst
argument_list|(
name|adn
argument_list|,
name|ADVAL
argument_list|(
name|al
argument_list|,
name|adn
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|AENTITYS
case|:
comment|/* Return data ecb pointers if valid entities. */
name|pt
operator|=
name|ADVAL
argument_list|(
name|al
argument_list|,
name|adn
argument_list|)
expr_stmt|;
name|tokencnt
operator|=
operator|(
name|int
operator|)
name|ADNUM
argument_list|(
name|al
argument_list|,
name|adn
argument_list|)
expr_stmt|;
while|while
condition|(
name|tokencnt
operator|--
condition|)
block|{
name|nptsv
operator|=
operator|*
operator|(
name|npt
operator|=
name|pt
operator|+
operator|*
name|pt
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
name|pt
operator|+=
literal|2
expr_stmt|;
operator|*
name|npt
operator|=
name|EOS
expr_stmt|;
name|aenttst
argument_list|(
name|adn
argument_list|,
name|pt
argument_list|)
expr_stmt|;
operator|*
name|pt
operator|-=
literal|2
expr_stmt|;
operator|*
operator|(
name|pt
operator|=
name|npt
operator|)
operator|=
name|nptsv
expr_stmt|;
block|}
break|break;
case|case
name|AID
case|:
comment|/* Define ID; msg if it already exists. */
if|if
condition|(
name|iddef
argument_list|(
name|ADVAL
argument_list|(
name|al
argument_list|,
name|adn
argument_list|)
argument_list|)
condition|)
block|{
name|sgmlerr
argument_list|(
literal|71
argument_list|,
operator|&
name|pcbstag
argument_list|,
name|ADNAME
argument_list|(
name|al
argument_list|,
name|adn
argument_list|)
argument_list|,
name|ADVAL
argument_list|(
name|al
argument_list|,
name|adn
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|SET
argument_list|(
name|ADFLAGS
argument_list|(
name|al
argument_list|,
name|adn
argument_list|)
argument_list|,
name|AINVALID
argument_list|)
expr_stmt|;
continue|continue;
block|}
operator|++
name|ds
operator|.
name|idcnt
expr_stmt|;
break|break;
case|case
name|AIDREF
case|:
name|idreftst
argument_list|(
name|adn
argument_list|,
name|ADVAL
argument_list|(
name|al
argument_list|,
name|adn
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|AIDREFS
case|:
name|pt
operator|=
name|ADVAL
argument_list|(
name|al
argument_list|,
name|adn
argument_list|)
expr_stmt|;
name|tokencnt
operator|=
operator|(
name|int
operator|)
name|ADNUM
argument_list|(
name|al
argument_list|,
name|adn
argument_list|)
expr_stmt|;
while|while
condition|(
name|tokencnt
operator|--
condition|)
block|{
name|nptsv
operator|=
operator|*
operator|(
name|npt
operator|=
name|pt
operator|+
operator|*
name|pt
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
name|pt
operator|+=
literal|2
expr_stmt|;
operator|*
name|npt
operator|=
name|EOS
expr_stmt|;
name|idreftst
argument_list|(
name|adn
argument_list|,
name|pt
argument_list|)
expr_stmt|;
operator|*
name|pt
operator|-=
literal|2
expr_stmt|;
operator|*
operator|(
name|pt
operator|=
name|npt
operator|)
operator|=
name|nptsv
expr_stmt|;
block|}
break|break;
case|case
name|ANOTEGRP
case|:
comment|/* Return notation identifier. */
if|if
condition|(
name|GET
argument_list|(
name|ADFLAGS
argument_list|(
name|al
argument_list|,
name|adn
argument_list|)
argument_list|,
name|ASPEC
argument_list|)
condition|)
name|notadn
operator|=
name|adn
expr_stmt|;
comment|/*NOTATION specified*/
if|if
condition|(
operator|(
name|dpt
operator|=
name|dcnfind
argument_list|(
name|ADVAL
argument_list|(
name|al
argument_list|,
name|adn
argument_list|)
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|sgmlerr
argument_list|(
literal|77
argument_list|,
operator|&
name|pcbstag
argument_list|,
name|ADNAME
argument_list|(
name|al
argument_list|,
name|adn
argument_list|)
argument_list|,
name|ADVAL
argument_list|(
name|al
argument_list|,
name|adn
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|SET
argument_list|(
name|ADFLAGS
argument_list|(
name|al
argument_list|,
name|adn
argument_list|)
argument_list|,
name|AINVALID
argument_list|)
expr_stmt|;
block|}
else|else
name|ADDATA
argument_list|(
name|al
argument_list|,
name|adn
argument_list|)
operator|.
name|x
operator|=
name|dpt
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|sd
operator|.
name|shorttag
operator|&&
operator|!
name|sd
operator|.
name|omittag
operator|&&
name|ADVAL
argument_list|(
name|al
argument_list|,
name|adn
argument_list|)
operator|!=
name|NULL
operator|&&
operator|!
name|GET
argument_list|(
name|ADFLAGS
argument_list|(
name|al
argument_list|,
name|adn
argument_list|)
argument_list|,
name|ASPEC
operator|+
name|AINVALID
argument_list|)
condition|)
name|sgmlerr
argument_list|(
literal|197
argument_list|,
operator|&
name|pcbstag
argument_list|,
name|ADNAME
argument_list|(
name|al
argument_list|,
name|adn
argument_list|)
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|adn
operator|+=
name|BITON
argument_list|(
name|ADFLAGS
argument_list|(
name|al
argument_list|,
name|adn
argument_list|)
argument_list|,
name|AGROUP
argument_list|)
condition|?
operator|(
name|int
operator|)
name|ADNUM
argument_list|(
name|al
argument_list|,
name|adn
argument_list|)
operator|+
literal|1
else|:
literal|1
operator|)
operator|<=
name|adsz
condition|)
do|;
comment|/* Error if NOTATION specified with CONREF attribute or EMPTY element. */
if|if
condition|(
name|notadn
operator|&&
operator|(
name|conrefsw
operator|||
operator|(
name|newetd
operator|&&
name|GET
argument_list|(
name|newetd
operator|->
name|etdmod
operator|->
name|ttype
argument_list|,
name|MNONE
argument_list|)
operator|)
operator|)
condition|)
block|{
name|sgmlerr
argument_list|(
call|(
name|UNS
call|)
argument_list|(
name|conrefsw
condition|?
literal|84
else|:
literal|76
argument_list|)
argument_list|,
operator|&
name|pcbstag
argument_list|,
name|ADNAME
argument_list|(
name|al
argument_list|,
name|notadn
argument_list|)
argument_list|,
name|ADVAL
argument_list|(
name|al
argument_list|,
name|notadn
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|SET
argument_list|(
name|ADFLAGS
argument_list|(
name|al
argument_list|,
name|notadn
argument_list|)
argument_list|,
name|AINVALID
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* AENTTST: Validate an individual ENTITY token in AENTITY or AENTITYS value. */
end_comment

begin_function
name|VOID
name|aenttst
parameter_list|(
name|adn
parameter_list|,
name|pt
parameter_list|)
name|int
name|adn
decl_stmt|;
comment|/* Position in list. */
name|UNCH
modifier|*
name|pt
decl_stmt|;
comment|/* Ptr to current ENTITY token in value. */
block|{
name|struct
name|entity
modifier|*
name|ept
decl_stmt|;
comment|/* Save area for ecb ptr. */
if|if
condition|(
operator|++
name|aentctr
operator|>
name|GRPCNT
condition|)
block|{
name|sgmlerr
argument_list|(
literal|136
argument_list|,
operator|&
name|pcbstag
argument_list|,
name|ADNAME
argument_list|(
name|al
argument_list|,
name|adn
argument_list|)
argument_list|,
name|pt
operator|+
literal|1
argument_list|)
expr_stmt|;
name|SET
argument_list|(
name|ADFLAGS
argument_list|(
name|al
argument_list|,
name|adn
argument_list|)
argument_list|,
name|AINVALID
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|ept
operator|=
name|entfind
argument_list|(
name|pt
argument_list|)
operator|)
operator|==
literal|0
operator|&&
operator|(
name|ecbdeflt
operator|==
literal|0
operator|||
operator|(
name|ept
operator|=
name|usedef
argument_list|(
name|pt
argument_list|)
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|sgmlerr
argument_list|(
name|ecbdeflt
condition|?
literal|151
else|:
literal|72
argument_list|,
operator|&
name|pcbstag
argument_list|,
name|ADNAME
argument_list|(
name|al
argument_list|,
name|adn
argument_list|)
argument_list|,
name|pt
operator|+
literal|1
argument_list|)
expr_stmt|;
name|SET
argument_list|(
name|ADFLAGS
argument_list|(
name|al
argument_list|,
name|adn
argument_list|)
argument_list|,
name|AINVALID
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ept
operator|->
name|estore
operator|==
name|ESX
operator|||
name|ept
operator|->
name|estore
operator|==
name|ESC
operator|||
name|ept
operator|->
name|estore
operator|==
name|ESN
condition|)
block|{
comment|/* Error if DCN has no notation identifier. */
if|if
condition|(
name|ept
operator|->
name|estore
operator|==
name|ESN
operator|&&
name|NEXTYPE
argument_list|(
name|ept
operator|->
name|etx
operator|.
name|n
argument_list|)
operator|!=
name|ESNSUB
operator|&&
operator|!
name|NEDCNDEFINED
argument_list|(
name|ept
operator|->
name|etx
operator|.
name|n
argument_list|)
condition|)
block|{
name|sgmlerr
argument_list|(
literal|78
argument_list|,
operator|&
name|pcbstag
argument_list|,
name|NEDCN
argument_list|(
name|ept
operator|->
name|etx
operator|.
name|n
argument_list|)
operator|+
literal|1
argument_list|,
name|pt
operator|+
literal|1
argument_list|)
expr_stmt|;
name|SET
argument_list|(
name|ADFLAGS
argument_list|(
name|al
argument_list|,
name|adn
argument_list|)
argument_list|,
name|AINVALID
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|sgmlerr
argument_list|(
literal|86
argument_list|,
operator|&
name|pcbstag
argument_list|,
name|ADNAME
argument_list|(
name|al
argument_list|,
name|adn
argument_list|)
argument_list|,
name|pt
operator|+
literal|1
argument_list|)
expr_stmt|;
name|SET
argument_list|(
name|ADFLAGS
argument_list|(
name|al
argument_list|,
name|adn
argument_list|)
argument_list|,
name|AINVALID
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* IDREFTST: Validate an individual IDREF token in an IDREF or IDREFS value. */
end_comment

begin_function
name|VOID
name|idreftst
parameter_list|(
name|adn
parameter_list|,
name|pt
parameter_list|)
name|int
name|adn
decl_stmt|;
comment|/* Position in list. */
name|UNCH
modifier|*
name|pt
decl_stmt|;
comment|/* Ptr to current IDREF token in value. */
block|{
name|struct
name|fwdref
modifier|*
name|rp
decl_stmt|;
if|if
condition|(
operator|++
name|idrctr
operator|>
name|GRPCNT
condition|)
block|{
name|sgmlerr
argument_list|(
literal|70
argument_list|,
operator|&
name|pcbstag
argument_list|,
name|ADNAME
argument_list|(
name|al
argument_list|,
name|adn
argument_list|)
argument_list|,
name|pt
operator|+
literal|1
argument_list|)
expr_stmt|;
name|SET
argument_list|(
name|ADFLAGS
argument_list|(
name|al
argument_list|,
name|adn
argument_list|)
argument_list|,
name|AINVALID
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Note IDREF; indicate if ID exists. */
if|if
condition|(
operator|(
name|rp
operator|=
name|idref
argument_list|(
name|pt
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|rp
operator|->
name|msg
operator|=
name|saverr
argument_list|(
literal|69
argument_list|,
operator|&
name|pcbstag
argument_list|,
name|ADNAME
argument_list|(
name|al
argument_list|,
name|adn
argument_list|)
argument_list|,
name|pt
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|++
name|ds
operator|.
name|idrcnt
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ANMGET: Locate an attribute name in an attribute definition list. */
end_comment

begin_function
name|int
name|anmget
parameter_list|(
name|adsz
parameter_list|,
name|nm
parameter_list|)
name|int
name|adsz
decl_stmt|;
comment|/* Size of list. */
name|UNCH
modifier|*
name|nm
decl_stmt|;
comment|/* Value to be found (with length byte). */
block|{
name|int
name|adn
init|=
literal|0
decl_stmt|;
comment|/* Position in list. */
while|while
condition|(
operator|++
name|adn
operator|<=
name|adsz
operator|&&
name|ustrcmp
argument_list|(
name|nm
operator|+
literal|1
argument_list|,
name|ADNAME
argument_list|(
name|al
argument_list|,
name|adn
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|BITON
argument_list|(
name|ADFLAGS
argument_list|(
name|al
argument_list|,
name|adn
argument_list|)
argument_list|,
name|AGROUP
argument_list|)
condition|)
name|adn
operator|+=
operator|(
name|int
operator|)
name|ADNUM
argument_list|(
name|al
argument_list|,
name|adn
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|adn
operator|>
name|adsz
operator|)
condition|?
literal|0
else|:
name|adn
return|;
block|}
end_function

begin_comment
comment|/* ANTVGET: Find the position of a name token value in an attribute list.             Return the position of the attribute definition, or zero             if none was found.  Set pp to the value, if non-NULL. */
end_comment

begin_function
name|int
name|antvget
parameter_list|(
name|adsz
parameter_list|,
name|nm
parameter_list|,
name|pp
parameter_list|)
name|int
name|adsz
decl_stmt|;
comment|/* Size of list. */
name|UNCH
modifier|*
name|nm
decl_stmt|;
comment|/* Value to be found (with length byte). */
name|UNCH
modifier|*
modifier|*
name|pp
decl_stmt|;
comment|/* Store value here */
block|{
name|int
name|adn
init|=
literal|0
decl_stmt|;
comment|/* Position in list. */
while|while
condition|(
operator|++
name|adn
operator|<=
name|adsz
condition|)
block|{
comment|/* Test only name group members. */
if|if
condition|(
name|BITON
argument_list|(
name|ADFLAGS
argument_list|(
name|al
argument_list|,
name|adn
argument_list|)
argument_list|,
name|AGROUP
argument_list|)
condition|)
block|{
name|int
name|advn
decl_stmt|;
comment|/* Position of value in sub-list. */
if|if
condition|(
operator|(
name|advn
operator|=
name|amemget
argument_list|(
operator|&
name|al
index|[
name|adn
index|]
argument_list|,
operator|(
name|int
operator|)
name|ADNUM
argument_list|(
name|al
argument_list|,
name|adn
argument_list|)
argument_list|,
name|nm
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|pp
condition|)
operator|*
name|pp
operator|=
name|al
index|[
name|adn
operator|+
name|advn
index|]
operator|.
name|adname
expr_stmt|;
return|return
name|adn
return|;
block|}
name|adn
operator|+=
operator|(
name|int
operator|)
name|ADNUM
argument_list|(
name|al
argument_list|,
name|adn
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* AMEMGET: Get the position of a member in an attribute name token group.             Returns the position, or zero if not found.             The length byte is ignored in the comparison so that final             form tokens from ATTVAL can be compared to group members. */
end_comment

begin_function
name|int
name|amemget
parameter_list|(
name|anmtgrp
parameter_list|,
name|adsz
parameter_list|,
name|nm
parameter_list|)
name|struct
name|ad
name|anmtgrp
index|[]
decl_stmt|;
comment|/* Name token group. */
name|int
name|adsz
decl_stmt|;
comment|/* Size of group. */
name|UNCH
modifier|*
name|nm
decl_stmt|;
comment|/* Name to be found (with length byte). */
block|{
name|int
name|adn
init|=
literal|0
decl_stmt|;
comment|/* Position in group. */
while|while
condition|(
operator|++
name|adn
operator|<=
name|adsz
operator|&&
name|ustrncmp
argument_list|(
name|nm
operator|+
literal|1
argument_list|,
name|anmtgrp
index|[
name|adn
index|]
operator|.
name|adname
operator|+
literal|1
argument_list|,
operator|(
name|UNS
operator|)
operator|*
name|nm
operator|-
literal|1
argument_list|)
condition|)
empty_stmt|;
return|return
operator|(
name|adn
operator|>
name|adsz
operator|)
condition|?
literal|0
else|:
name|adn
return|;
block|}
end_function

begin_comment
comment|/* VALLEN: Returns the length of an attribute value for capacity            calculations.  Normally, the length is NORMSEP plus the number            of characters.  For tokenized lists, it is NORMSEP,            plus the number of characters in the tokens, plus            NORMSEP for each token. 	   ACHARS and tokenized lists don't have a length byte.  */
end_comment

begin_function
name|UNS
name|vallen
parameter_list|(
name|type
parameter_list|,
name|num
parameter_list|,
name|def
parameter_list|)
name|int
name|type
decl_stmt|;
comment|/* ADTYPE(al,adn) */
name|int
name|num
decl_stmt|;
comment|/* ADNUM(al,adn) */
name|UNCH
modifier|*
name|def
decl_stmt|;
comment|/* ADVAL(al,adn) */
block|{
if|if
condition|(
name|type
operator|==
name|ACHARS
condition|)
return|return
name|ustrlen
argument_list|(
name|def
argument_list|)
operator|+
name|NORMSEP
return|;
if|if
condition|(
name|type
operator|<
name|ATKNLIST
condition|)
return|return
operator|*
name|def
operator|-
literal|2
operator|+
name|NORMSEP
return|;
return|return
name|ustrlen
argument_list|(
name|def
argument_list|)
operator|+
name|num
operator|*
operator|(
name|NORMSEP
operator|-
literal|1
operator|)
operator|+
name|NORMSEP
return|;
block|}
end_function

begin_comment
comment|/* PARSEGRP: Parse GI names, get their etds, and form an array of pointers              to them.  The array is terminated by a NULL pointer.              The number of pointers (including the NULL) is returned.              The grp buffer must have room for GRPCNT+1 etds. */
end_comment

begin_function
name|UNS
name|parsegrp
parameter_list|(
name|grp
parameter_list|,
name|pcb
parameter_list|,
name|tbuf
parameter_list|)
name|struct
name|etd
modifier|*
name|grp
index|[]
decl_stmt|;
comment|/* Buffer for building the group. */
name|struct
name|parse
modifier|*
name|pcb
decl_stmt|;
comment|/* Current parse control block. */
name|UNCH
modifier|*
name|tbuf
decl_stmt|;
block|{
name|int
name|grpcnt
init|=
literal|0
decl_stmt|;
comment|/* Number of etds in the group. */
name|int
name|i
decl_stmt|;
name|int
name|essv
init|=
name|es
decl_stmt|;
comment|/* Entity stack level when grp started. */
while|while
condition|(
name|parse
argument_list|(
name|pcb
argument_list|)
operator|!=
name|GRPE
operator|&&
name|grpcnt
operator|<
name|GRPCNT
condition|)
block|{
switch|switch
condition|(
name|pcb
operator|->
name|action
condition|)
block|{
case|case
name|NAS_
case|:
comment|/* GI name: get its etd for the group. */
name|grp
index|[
name|grpcnt
index|]
operator|=
name|etddef
argument_list|(
name|parsenm
argument_list|(
name|tbuf
argument_list|,
name|NAMECASE
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|grpcnt
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|grp
index|[
name|i
index|]
operator|==
name|grp
index|[
name|grpcnt
index|]
condition|)
block|{
name|mderr
argument_list|(
literal|98
argument_list|,
name|ntoa
argument_list|(
name|grpcnt
operator|+
literal|1
argument_list|)
argument_list|,
name|grp
index|[
name|grpcnt
index|]
operator|->
name|etdgi
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|grpcnt
condition|)
name|grpcnt
operator|++
expr_stmt|;
continue|continue;
case|case
name|EE_
case|:
comment|/* Entity ended (correctly or incorrectly). */
if|if
condition|(
name|es
operator|<
name|essv
condition|)
block|{
name|synerr
argument_list|(
literal|37
argument_list|,
name|pcb
argument_list|)
expr_stmt|;
name|essv
operator|=
name|es
expr_stmt|;
block|}
continue|continue;
case|case
name|PIE_
case|:
comment|/* PI entity reference (invalid). */
name|entpisw
operator|=
literal|0
expr_stmt|;
comment|/* Reset PI entity indicator. */
name|synerr
argument_list|(
literal|59
argument_list|,
name|pcb
argument_list|)
expr_stmt|;
continue|continue;
default|default:
break|break;
block|}
break|break;
block|}
name|grp
index|[
name|grpcnt
operator|++
index|]
operator|=
literal|0
expr_stmt|;
comment|/* NULL pointer indicates end of group. */
if|if
condition|(
name|es
operator|!=
name|essv
condition|)
name|synerr
argument_list|(
literal|37
argument_list|,
name|pcb
argument_list|)
expr_stmt|;
return|return
name|grpcnt
return|;
comment|/* Return number of ptrs in group. */
block|}
end_function

begin_comment
comment|/* PARSNGRP: Parse notation names, get their dcncbs, and form an array of              pointers to them.  The array is terminated by a NULL pointer.              The number of pointers (including the NULL) is returned.              The grp buffer must have room for GRPCNT+1 members. */
end_comment

begin_function
name|UNS
name|parsngrp
parameter_list|(
name|grp
parameter_list|,
name|pcb
parameter_list|,
name|tbuf
parameter_list|)
name|struct
name|dcncb
modifier|*
name|grp
index|[]
decl_stmt|;
comment|/* Buffer for building the group. */
name|struct
name|parse
modifier|*
name|pcb
decl_stmt|;
comment|/* Current parse control block. */
name|UNCH
modifier|*
name|tbuf
decl_stmt|;
block|{
name|int
name|grpcnt
init|=
literal|0
decl_stmt|;
comment|/* Number of members in the group. */
name|int
name|i
decl_stmt|;
name|int
name|essv
init|=
name|es
decl_stmt|;
comment|/* Entity stack level when grp started. */
while|while
condition|(
name|parse
argument_list|(
name|pcb
argument_list|)
operator|!=
name|GRPE
operator|&&
name|grpcnt
operator|<
name|GRPCNT
condition|)
block|{
switch|switch
condition|(
name|pcb
operator|->
name|action
condition|)
block|{
case|case
name|NAS_
case|:
comment|/* Member name: get its control block. */
name|grp
index|[
name|grpcnt
index|]
operator|=
name|dcndef
argument_list|(
name|parsenm
argument_list|(
name|tbuf
argument_list|,
name|NAMECASE
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|grpcnt
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|grp
index|[
name|i
index|]
operator|==
name|grp
index|[
name|grpcnt
index|]
condition|)
block|{
name|mderr
argument_list|(
literal|98
argument_list|,
name|ntoa
argument_list|(
name|grpcnt
operator|+
literal|1
argument_list|)
argument_list|,
name|grp
index|[
name|grpcnt
index|]
operator|->
name|ename
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|grpcnt
condition|)
name|grpcnt
operator|++
expr_stmt|;
continue|continue;
case|case
name|EE_
case|:
comment|/* Entity ended (correctly or incorrectly). */
if|if
condition|(
name|es
operator|<
name|essv
condition|)
block|{
name|synerr
argument_list|(
literal|37
argument_list|,
name|pcb
argument_list|)
expr_stmt|;
name|essv
operator|=
name|es
expr_stmt|;
block|}
continue|continue;
case|case
name|PIE_
case|:
comment|/* PI entity reference (invalid). */
name|entpisw
operator|=
literal|0
expr_stmt|;
comment|/* Reset PI entity indicator. */
name|synerr
argument_list|(
literal|59
argument_list|,
name|pcb
argument_list|)
expr_stmt|;
continue|continue;
default|default:
break|break;
block|}
break|break;
block|}
name|grp
index|[
name|grpcnt
operator|++
index|]
operator|=
literal|0
expr_stmt|;
comment|/* NULL pointer indicates end of group. */
if|if
condition|(
name|es
operator|!=
name|essv
condition|)
name|synerr
argument_list|(
literal|37
argument_list|,
name|pcb
argument_list|)
expr_stmt|;
return|return
name|grpcnt
return|;
comment|/* Return number of ptrs in group. */
block|}
end_function

begin_comment
comment|/* COPYGRP: Allocate storage for a group and copy the group into it. */
end_comment

begin_function
name|PETD
modifier|*
name|copygrp
parameter_list|(
name|pg
parameter_list|,
name|grpsz
parameter_list|)
name|PETD
name|pg
index|[]
decl_stmt|;
comment|/* Pointer to a group (array of etd ptrs). */
name|UNS
name|grpsz
decl_stmt|;
comment|/* Number of ptrs in grp, including final NULL. */
block|{
name|UNS
name|glen
decl_stmt|;
comment|/* Group length in characters. */
name|PETD
modifier|*
name|gnm
decl_stmt|;
comment|/* Ptr to permanent name group. */
if|if
condition|(
name|pg
operator|==
literal|0
condition|)
return|return
operator|(
name|PETD
operator|*
operator|)
literal|0
return|;
name|glen
operator|=
name|grpsz
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|etd
operator|*
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
call|(
name|UNIV
call|)
argument_list|(
name|gnm
operator|=
operator|(
expr|struct
name|etd
operator|*
operator|*
operator|)
name|rmalloc
argument_list|(
name|glen
argument_list|)
argument_list|)
argument_list|,
operator|(
name|UNIV
operator|)
name|pg
argument_list|,
name|glen
argument_list|)
expr_stmt|;
return|return
name|gnm
return|;
block|}
end_function

begin_comment
comment|/* INGRP: Locate an etd in a name group and return its index+1 (or zero           if not found). */
end_comment

begin_function
name|int
name|ingrp
parameter_list|(
name|pg
parameter_list|,
name|ketd
parameter_list|)
name|PETD
name|pg
index|[]
decl_stmt|;
comment|/* Array of pointers to etds. */
name|PETD
name|ketd
decl_stmt|;
comment|/* Pointer to etd to be found in group. */
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
comment|/* Array index. */
while|while
condition|(
name|pg
index|[
name|i
index|]
condition|)
if|if
condition|(
name|pg
index|[
name|i
operator|++
index|]
operator|==
name|ketd
condition|)
return|return
name|i
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* PARSELIT: Parse a delimited string and collect it into a token.              Caller supplies buffer, which must be 1 longer than              maximum string allowed.              Caller also supplies character that delimits the string.              TODO: Return 1 if CDATA, SDATA or NONSGML occurred. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USE_PROTOTYPES
end_ifdef

begin_function
name|VOID
name|parselit
parameter_list|(
name|UNCH
modifier|*
name|tbuf
parameter_list|,
name|struct
name|parse
modifier|*
name|pcb
parameter_list|,
name|UNS
name|maxlen
parameter_list|,
name|UNCH
name|del
parameter_list|)
else|#
directive|else
function|VOID parselit
parameter_list|(
name|tbuf
parameter_list|,
name|pcb
parameter_list|,
name|maxlen
parameter_list|,
name|del
parameter_list|)
name|UNCH
modifier|*
name|tbuf
decl_stmt|;
comment|/* Work area for tokenization (parmlen+1). */
name|struct
name|parse
modifier|*
name|pcb
decl_stmt|;
comment|/* Current parse control block. */
name|UNS
name|maxlen
decl_stmt|;
comment|/* Maximum length of token. */
name|UNCH
name|del
decl_stmt|;
comment|/* Literal delimiter: LIT LITA PIC EOS */
endif|#
directive|endif
block|{
name|UNCH
modifier|*
name|pt
init|=
name|tbuf
decl_stmt|;
comment|/* Current pointer into tbuf. */
name|UNCH
name|lexsv
init|=
name|pcb
operator|->
name|plex
index|[
name|del
index|]
decl_stmt|;
comment|/* Saved value of delimiter in lexical table. */
name|int
name|essv
init|=
name|es
decl_stmt|;
comment|/* Entity stack level when literal started. */
name|UNCH
name|datadel
decl_stmt|;
comment|/* Delimiter for CDATA/SDATA entity. */
name|int
name|parmlen
init|=
operator|(
name|int
operator|)
name|maxlen
operator|+
literal|1
decl_stmt|;
comment|/* Working limit (to be decremented). */
name|int
name|overflow
init|=
literal|0
decl_stmt|;
comment|/* Did the buffer overflow? */
name|pcb
operator|->
name|plex
index|[
name|del
index|]
operator|=
name|pcb
operator|->
name|plex
operator|==
name|lexlms
condition|?
name|lex
operator|.
name|l
operator|.
name|litc
else|:
name|lex
operator|.
name|l
operator|.
name|minlitc
expr_stmt|;
comment|/* The RPR_ action may cause the length of the literal to decrease by 	1 (this discards a final space in a minimum literal); so while 	building the literal, the length must be allowed to grow to 	maxlen + 1. */
do|do
block|{
switch|switch
condition|(
name|parse
argument_list|(
name|pcb
argument_list|)
condition|)
block|{
case|case
name|LP2_
case|:
comment|/* Move 2nd char back to buffer; redo prev.*/
name|REPEATCC
expr_stmt|;
case|case
name|LPR_
case|:
comment|/* Move previous char to buffer; REPEATCC; */
name|REPEATCC
expr_stmt|;
case|case
name|MLA_
case|:
comment|/* Move character to buffer. */
if|if
condition|(
name|parmlen
operator|<=
literal|0
condition|)
block|{
name|overflow
operator|=
literal|1
expr_stmt|;
break|break;
block|}
operator|*
name|pt
operator|++
operator|=
operator|*
name|FPOS
expr_stmt|;
operator|--
name|parmlen
expr_stmt|;
continue|continue;
case|case
name|FUN_
case|:
comment|/* Function char found; replace with space.*/
if|if
condition|(
name|parmlen
operator|<=
literal|0
condition|)
block|{
name|overflow
operator|=
literal|1
expr_stmt|;
break|break;
block|}
operator|*
name|pt
operator|++
operator|=
literal|' '
expr_stmt|;
operator|--
name|parmlen
expr_stmt|;
continue|continue;
case|case
name|RSM_
case|:
comment|/* Record start: ccnt=0; ++rcnt.*/
operator|++
name|RCNT
expr_stmt|;
name|CTRSET
argument_list|(
name|RSCC
argument_list|)
expr_stmt|;
if|if
condition|(
name|parmlen
operator|<=
literal|0
condition|)
block|{
name|overflow
operator|=
literal|1
expr_stmt|;
break|break;
block|}
operator|*
name|pt
operator|++
operator|=
operator|*
name|FPOS
expr_stmt|;
operator|--
name|parmlen
expr_stmt|;
continue|continue;
case|case
name|ERX_
case|:
comment|/* Entity reference: cancel LITC delim. */
case|case
name|PEX_
case|:
comment|/* Parameter entity ref: cancel LITC delim.*/
name|lexlms
index|[
name|del
index|]
operator|=
name|lexsv
expr_stmt|;
continue|continue;
case|case
name|EE_
case|:
if|if
condition|(
name|es
operator|<
name|essv
condition|)
block|{
name|synerr
argument_list|(
literal|37
argument_list|,
name|pcb
argument_list|)
expr_stmt|;
name|essv
operator|=
name|es
expr_stmt|;
block|}
comment|/* If back at top level, re-enable the LITC delimiter. */
if|if
condition|(
name|es
operator|==
name|essv
condition|)
name|lexlms
index|[
name|del
index|]
operator|=
name|lex
operator|.
name|l
operator|.
name|litc
expr_stmt|;
continue|continue;
case|case
name|MLE_
case|:
comment|/* Char not allowed in minimum literal. */
name|synerr
argument_list|(
literal|63
argument_list|,
name|pcb
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|DEF_
case|:
comment|/* Data entity: add it to buffer. */
if|if
condition|(
name|pcb
operator|==
operator|&
name|pcblitt
condition|)
block|{
name|int
name|parmlensv
init|=
name|parmlen
decl_stmt|;
name|entdatsw
operator|=
literal|0
expr_stmt|;
name|parmlen
operator|=
name|tokdata
argument_list|(
name|pt
argument_list|,
name|parmlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|parmlen
operator|<
literal|0
condition|)
break|break;
name|pt
operator|+=
name|parmlensv
operator|-
name|parmlen
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|parmlen
operator|<
name|datalen
operator|+
literal|2
condition|)
block|{
name|entdatsw
operator|=
literal|0
expr_stmt|;
name|overflow
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|parmlen
operator|-=
name|datalen
operator|+
literal|2
expr_stmt|;
operator|*
name|pt
operator|++
operator|=
name|datadel
operator|=
name|BITON
argument_list|(
name|entdatsw
argument_list|,
name|CDECONT
argument_list|)
condition|?
name|DELCDATA
else|:
name|DELSDATA
expr_stmt|;
name|entdatsw
operator|=
literal|0
expr_stmt|;
name|memcpy
argument_list|(
name|pt
argument_list|,
name|data
argument_list|,
name|datalen
argument_list|)
expr_stmt|;
name|pt
operator|+=
name|datalen
expr_stmt|;
operator|*
name|pt
operator|++
operator|=
name|datadel
expr_stmt|;
continue|continue;
case|case
name|NON_
case|:
comment|/* Non-SGML char (delimited and shifted). */
if|if
condition|(
name|parmlen
operator|<
literal|2
condition|)
block|{
name|overflow
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|parmlen
operator|-=
literal|2
expr_stmt|;
name|memcpy
argument_list|(
name|pt
argument_list|,
name|nonchbuf
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|pt
operator|+=
literal|2
expr_stmt|;
continue|continue;
case|case
name|RPR_
case|:
comment|/* Remove character from buffer. */
operator|--
name|pt
expr_stmt|;
operator|++
name|parmlen
expr_stmt|;
break|break;
case|case
name|EOD_
case|:
name|exiterr
argument_list|(
literal|92
argument_list|,
name|pcb
argument_list|)
expr_stmt|;
default|default:
break|break;
block|}
break|break;
block|}
do|while
condition|(
operator|!
name|overflow
operator|&&
name|pcb
operator|->
name|action
operator|!=
name|TER_
condition|)
do|;
if|if
condition|(
name|parmlen
operator|<=
literal|0
condition|)
block|{
operator|--
name|pt
expr_stmt|;
name|overflow
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|overflow
condition|)
name|sgmlerr
argument_list|(
literal|134
argument_list|,
name|pcb
argument_list|,
name|ntoa
argument_list|(
operator|(
name|int
operator|)
name|maxlen
argument_list|)
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|datalen
operator|=
call|(
name|UNS
call|)
argument_list|(
name|pt
operator|-
name|tbuf
argument_list|)
expr_stmt|;
comment|/* To return PI string to text processor. */
operator|*
name|pt
operator|++
operator|=
name|EOS
expr_stmt|;
name|pcb
operator|->
name|plex
index|[
name|del
index|]
operator|=
name|lexsv
expr_stmt|;
comment|/* Restore normal delimiter handling. */
if|if
condition|(
name|es
operator|!=
name|essv
condition|)
name|synerr
argument_list|(
literal|37
argument_list|,
name|pcb
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle a data entity in a tokenized attribute value literal. Parmlen is amount of space left.  Return new parmlen. If there's not enough space return -1, and copy up to parmlen + 1 characters.  Only tokenization should be done, not attribute value interpretation. */
end_comment

begin_function
name|int
name|tokdata
parameter_list|(
name|pt
parameter_list|,
name|parmlen
parameter_list|)
name|UNCH
modifier|*
name|pt
decl_stmt|;
name|int
name|parmlen
decl_stmt|;
block|{
name|int
name|skip
init|=
operator|(
name|pcblitt
operator|.
name|newstate
operator|==
literal|0
operator|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|parmlen
operator|>=
literal|0
operator|&&
name|i
operator|<
name|datalen
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|data
index|[
name|i
index|]
condition|)
block|{
case|case
name|SPCCHAR
case|:
if|if
condition|(
operator|!
name|skip
condition|)
block|{
operator|*
name|pt
operator|++
operator|=
name|data
index|[
name|i
index|]
expr_stmt|;
name|parmlen
operator|--
expr_stmt|;
name|skip
operator|=
literal|1
expr_stmt|;
block|}
break|break;
default|default:
if|if
condition|(
name|data
index|[
name|i
index|]
operator|==
name|DELNONCH
condition|)
block|{
name|assert
argument_list|(
name|i
operator|+
literal|1
operator|<
name|datalen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|parmlen
operator|-=
literal|2
operator|)
operator|<
literal|0
condition|)
break|break;
operator|*
name|pt
operator|++
operator|=
name|DELNONCH
expr_stmt|;
operator|*
name|pt
operator|++
operator|=
name|data
index|[
operator|++
name|i
index|]
expr_stmt|;
name|skip
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
operator|*
name|pt
operator|++
operator|=
name|data
index|[
name|i
index|]
expr_stmt|;
name|parmlen
operator|--
expr_stmt|;
name|skip
operator|=
literal|0
expr_stmt|;
block|}
break|break;
block|}
block|}
name|pcblitt
operator|.
name|newstate
operator|=
name|skip
condition|?
literal|0
else|:
name|pcblittda
expr_stmt|;
return|return
name|parmlen
return|;
block|}
end_function

begin_comment
comment|/* PARSEMD: Parser for markup declarations.             It returns a token each time it is called.  */
end_comment

begin_function
name|int
name|parsemd
parameter_list|(
name|pt
parameter_list|,
name|namecase
parameter_list|,
name|lpcb
parameter_list|,
name|tokenlen
parameter_list|)
name|UNCH
modifier|*
name|pt
decl_stmt|;
comment|/* Token buffer:>=tokenlen+2. */
name|int
name|namecase
decl_stmt|;
comment|/* Case translation: ENTCASE NAMECASE AVALCASE. */
name|struct
name|parse
modifier|*
name|lpcb
decl_stmt|;
comment|/* Parse control block for literal parse. */
name|UNS
name|tokenlen
decl_stmt|;
comment|/* Max length of expected token: NAMELEN LITLEN */
block|{
name|struct
name|parse
modifier|*
name|pcb
decl_stmt|;
comment|/* Current parse control block. */
name|pcb
operator|=
operator|(
name|lpcb
operator|)
condition|?
operator|&
name|pcbmd
else|:
operator|&
name|pcbmdc
expr_stmt|;
comment|/* If no literal pcb, dcl is comment. */
name|doparse
label|:
while|while
condition|(
name|parse
argument_list|(
name|pcb
argument_list|)
operator|==
name|EE_
condition|)
if|if
condition|(
name|es
operator|<
name|mdessv
condition|)
block|{
name|synerr
argument_list|(
literal|37
argument_list|,
name|pcb
argument_list|)
expr_stmt|;
name|mdessv
operator|=
name|es
expr_stmt|;
block|}
if|if
condition|(
name|pcb
operator|->
name|action
operator|==
name|PIE_
condition|)
block|{
comment|/* PI entity reference not allowed. */
name|entpisw
operator|=
literal|0
expr_stmt|;
comment|/* Reset PI entity indicator. */
name|synerr
argument_list|(
literal|59
argument_list|,
name|pcb
argument_list|)
expr_stmt|;
goto|goto
name|doparse
goto|;
block|}
operator|++
name|parmno
expr_stmt|;
comment|/* Increment parameter counter. */
switch|switch
condition|(
name|pcb
operator|->
name|action
condition|)
block|{
case|case
name|CDR
case|:
comment|/* COM[1] (MINUS) occurred previously. */
name|REPEATCC
expr_stmt|;
return|return
operator|(
name|int
operator|)
name|pcb
operator|->
name|action
return|;
case|case
name|LIT
case|:
comment|/* Literal: CDATA with LIT delimiter. */
name|parselit
argument_list|(
name|pt
argument_list|,
name|lpcb
argument_list|,
name|tokenlen
argument_list|,
name|lex
operator|.
name|d
operator|.
name|lit
argument_list|)
expr_stmt|;
return|return
operator|(
name|int
operator|)
name|pcb
operator|->
name|action
return|;
case|case
name|LITE
case|:
comment|/* Literal: CDATA with LITA delimiter. */
name|parselit
argument_list|(
name|pt
argument_list|,
name|lpcb
argument_list|,
name|tokenlen
argument_list|,
name|lex
operator|.
name|d
operator|.
name|lita
argument_list|)
expr_stmt|;
return|return
operator|(
call|(
name|int
call|)
argument_list|(
name|pcb
operator|->
name|action
operator|=
name|LIT
argument_list|)
operator|)
return|;
case|case
name|RNS
case|:
comment|/* Reserved name started (after RNI). */
name|parsenm
argument_list|(
name|pt
argument_list|,
name|NAMECASE
argument_list|)
expr_stmt|;
return|return
operator|(
name|int
operator|)
name|pcb
operator|->
name|action
return|;
case|case
name|NAS
case|:
comment|/* Name started. */
if|if
condition|(
name|namecase
operator|!=
name|AVALCASE
condition|)
block|{
name|parsenm
argument_list|(
name|pt
argument_list|,
name|namecase
argument_list|)
expr_stmt|;
return|return
operator|(
name|int
operator|)
name|pcb
operator|->
name|action
return|;
block|}
comment|/* Treat attribute value as name character string. */
case|case
name|NMT
case|:
comment|/* Name token string. */
name|parsetkn
argument_list|(
name|pt
argument_list|,
name|NMC
argument_list|,
operator|(
name|int
operator|)
name|tokenlen
argument_list|)
expr_stmt|;
comment|/* Get undelimited value. */
return|return
operator|(
name|int
operator|)
name|pcb
operator|->
name|action
return|;
case|case
name|NUM
case|:
comment|/* Number or number token string. */
name|parsetkn
argument_list|(
name|pt
argument_list|,
call|(
name|UNCH
call|)
argument_list|(
operator|(
name|int
operator|)
name|tokenlen
operator|<=
name|NAMELEN
condition|?
name|NU
else|:
name|NMC
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|tokenlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|tokenlen
operator|>
name|NAMELEN
condition|)
name|pcb
operator|->
name|newstate
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|int
operator|)
name|pcb
operator|->
name|action
return|;
case|case
name|PENR
case|:
name|REPEATCC
expr_stmt|;
return|return
operator|(
name|pcb
operator|->
name|action
operator|=
name|PEN
operator|)
return|;
case|case
name|EOD_
case|:
name|exiterr
argument_list|(
literal|133
argument_list|,
name|pcb
argument_list|)
expr_stmt|;
comment|/* EXIT */
default|default:
comment|/* End of declaration. */
return|return
operator|(
name|int
operator|)
name|pcb
operator|->
name|action
return|;
comment|/* EMD GRPS MGRP PEN PGRP */
block|}
block|}
end_function

begin_comment
comment|/* PARSEMOD: If the declared content was a keyword, the token count is zero              and it is only necessary to save the type.  Otherwise,              collect the outermost token count and model type bytes for a model.              The count includes tokens found in nested groups also.              After building the model, parse for its occurrence indicator. */
end_comment

begin_function
name|struct
name|thdr
modifier|*
name|parsemod
parameter_list|(
name|dctype
parameter_list|)
name|int
name|dctype
decl_stmt|;
comment|/* Content type (0=model). */
block|{
name|gbuf
index|[
literal|0
index|]
operator|.
name|ttype
operator|=
operator|(
name|UNCH
operator|)
name|dctype
expr_stmt|;
comment|/* Initialize content flags byte. */
if|if
condition|(
name|dctype
condition|)
block|{
name|gbuf
index|[
literal|0
index|]
operator|.
name|tu
operator|.
name|tnum
operator|=
literal|0
expr_stmt|;
return|return
name|gbuf
return|;
block|}
comment|/* Return if not model. */
name|gbuf
index|[
literal|0
index|]
operator|.
name|tu
operator|.
name|tnum
operator|=
literal|0
expr_stmt|;
comment|/* Don't count 1st group or model header. */
name|gbuf
index|[
literal|1
index|]
operator|.
name|ttype
operator|=
literal|0
expr_stmt|;
comment|/* Initialize 1st group type ... */
name|gbuf
index|[
literal|1
index|]
operator|.
name|tu
operator|.
name|tnum
operator|=
literal|0
expr_stmt|;
comment|/* and count. */
name|grplvl
operator|=
literal|1
expr_stmt|;
comment|/* Content model is 1st level group. */
name|pcbgrcm
operator|.
name|newstate
operator|=
literal|0
expr_stmt|;
comment|/* Go parse the model group. */
comment|/* Empty group is trapped during syntax parse; other errors return NULL. */
if|if
condition|(
operator|!
name|parsegcm
argument_list|(
operator|&
name|pcbgrcm
argument_list|,
operator|&
name|gbuf
index|[
literal|1
index|]
argument_list|,
operator|&
name|gbuf
index|[
literal|0
index|]
argument_list|)
condition|)
return|return
operator|(
expr|struct
name|thdr
operator|*
operator|)
literal|0
return|;
name|parse
argument_list|(
operator|&
name|pcbgrcs
argument_list|)
expr_stmt|;
comment|/* Get the model suffix, if there is one. */
switch|switch
condition|(
name|pcbgrcs
operator|.
name|action
condition|)
block|{
case|case
name|OPT
case|:
comment|/* OPT occurrence indicator for model. */
name|SET
argument_list|(
name|gbuf
index|[
literal|1
index|]
operator|.
name|ttype
argument_list|,
name|TOPT
operator||
name|TXOPT
argument_list|)
expr_stmt|;
break|break;
case|case
name|REP
case|:
comment|/* REP occurrence indicator for model. */
name|SET
argument_list|(
name|gbuf
index|[
literal|1
index|]
operator|.
name|ttype
argument_list|,
name|TREP
operator||
name|TXREP
argument_list|)
expr_stmt|;
break|break;
case|case
name|OREP
case|:
comment|/* OREP occurrence indicator for model. */
name|SET
argument_list|(
name|gbuf
index|[
literal|1
index|]
operator|.
name|ttype
argument_list|,
name|TOREP
operator||
name|TXOREP
argument_list|)
expr_stmt|;
break|break;
case|case
name|EE_
case|:
if|if
condition|(
name|es
operator|<
name|mdessv
condition|)
block|{
name|synerr
argument_list|(
literal|37
argument_list|,
operator|&
name|pcbmd
argument_list|)
expr_stmt|;
name|mdessv
operator|=
name|es
expr_stmt|;
block|}
default|default:
comment|/* RCR_: Repeat char and return. */
break|break;
block|}
if|if
condition|(
name|sw
operator|.
name|swambig
condition|)
name|ambig
argument_list|()
expr_stmt|;
comment|/* Check content model for ambiguity. */
return|return
name|gbuf
return|;
block|}
end_function

begin_comment
comment|/* PARSEGCM: Collect token headers (struct thdr) into a group (array).              An etd is defined for each GI (if none exists) and its pointer is              stored in the header.  The function is called recursively. */
end_comment

begin_function
name|struct
name|thdr
modifier|*
name|parsegcm
parameter_list|(
name|pcb
parameter_list|,
name|pgh
parameter_list|,
name|gbuf
parameter_list|)
name|struct
name|parse
modifier|*
name|pcb
decl_stmt|;
comment|/* Current parse control block. */
name|struct
name|thdr
modifier|*
name|pgh
decl_stmt|;
comment|/* Current group header in group buffer. */
name|struct
name|thdr
modifier|*
name|gbuf
decl_stmt|;
comment|/* Header for outermost group (model). */
block|{
define|#
directive|define
name|MCON
value|gbuf->ttype
comment|/* Model type (content attributes). */
name|struct
name|thdr
modifier|*
name|pg
init|=
name|pgh
decl_stmt|;
comment|/* Current group token. */
name|struct
name|thdr
modifier|*
name|pgsv
init|=
name|pgh
decl_stmt|;
comment|/* Saved current token for occ indicator. */
name|int
name|optcnt
init|=
literal|0
decl_stmt|;
comment|/* Count of optional tokens in group. */
name|int
name|essv
init|=
name|es
decl_stmt|;
comment|/* Entity stack level when grp started. */
while|while
condition|(
name|gbuf
operator|->
name|tu
operator|.
name|tnum
operator|<=
name|GRPGTCNT
operator|&&
name|pgh
operator|->
name|tu
operator|.
name|tnum
operator|<=
name|GRPCNT
operator|&&
name|parse
argument_list|(
name|pcb
argument_list|)
operator|!=
name|GRPE
condition|)
switch|switch
condition|(
name|pcb
operator|->
name|action
condition|)
block|{
case|case
name|NAS_
case|:
comment|/* GI name: get its etd and store it. */
operator|++
name|gbuf
operator|->
name|tu
operator|.
name|tnum
expr_stmt|;
operator|++
name|pgh
operator|->
name|tu
operator|.
name|tnum
expr_stmt|;
operator|(
name|pgsv
operator|=
operator|++
name|pg
operator|)
operator|->
name|ttype
operator|=
name|TTETD
expr_stmt|;
name|pg
operator|->
name|tu
operator|.
name|thetd
operator|=
name|etddef
argument_list|(
name|parsenm
argument_list|(
name|tbuf
argument_list|,
name|NAMECASE
argument_list|)
argument_list|)
expr_stmt|;
name|SET
argument_list|(
name|MCON
argument_list|,
name|MGI
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|RNS_
case|:
comment|/* Reserved name started (#PCDATA). */
name|parsenm
argument_list|(
name|tbuf
argument_list|,
name|NAMECASE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ustrcmp
argument_list|(
name|tbuf
operator|+
literal|1
argument_list|,
name|key
index|[
name|KPCDATA
index|]
argument_list|)
condition|)
block|{
name|mderr
argument_list|(
literal|116
argument_list|,
name|ntoa
argument_list|(
name|gbuf
operator|->
name|tu
operator|.
name|tnum
argument_list|)
argument_list|,
name|tbuf
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
expr|struct
name|thdr
operator|*
operator|)
literal|0
return|;
block|}
comment|/* If #PCDATA is the first non-group token, model is a phrase. */
if|if
condition|(
operator|!
name|MCON
condition|)
name|SET
argument_list|(
name|MCON
argument_list|,
name|MPHRASE
argument_list|)
expr_stmt|;
case|case
name|DTAG
case|:
comment|/* Data tag template ignored; treat as #PCDATA. */
if|if
condition|(
name|pcb
operator|->
name|action
operator|==
name|DTAG
condition|)
name|SET
argument_list|(
name|pgh
operator|->
name|ttype
argument_list|,
name|TTSEQ
argument_list|)
expr_stmt|;
comment|/* DTAG is SEQ grp. */
operator|++
name|gbuf
operator|->
name|tu
operator|.
name|tnum
expr_stmt|;
operator|++
name|pgh
operator|->
name|tu
operator|.
name|tnum
expr_stmt|;
operator|(
operator|++
name|pg
operator|)
operator|->
name|ttype
operator|=
name|TTCHARS
operator|+
name|TOREP
expr_stmt|;
comment|/* #PCDATA is OPT and REP. */
name|pg
operator|->
name|tu
operator|.
name|thetd
operator|=
name|ETDCDATA
expr_stmt|;
operator|++
name|optcnt
expr_stmt|;
comment|/* Ct opt tokens to see if grp is opt.*/
name|SET
argument_list|(
name|MCON
argument_list|,
name|MCHARS
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|GRP_
case|:
comment|/* Group started. */
operator|++
name|gbuf
operator|->
name|tu
operator|.
name|tnum
expr_stmt|;
operator|++
name|pgh
operator|->
name|tu
operator|.
name|tnum
expr_stmt|;
operator|(
name|pgsv
operator|=
operator|++
name|pg
operator|)
operator|->
name|ttype
operator|=
literal|0
expr_stmt|;
comment|/* Type will be set by connector. */
name|pg
operator|->
name|tu
operator|.
name|tnum
operator|=
literal|0
expr_stmt|;
comment|/* Group has number instead of etd. */
if|if
condition|(
operator|++
name|grplvl
operator|>
name|GRPLVL
condition|)
block|{
name|mderr
argument_list|(
literal|115
argument_list|,
name|ntoa
argument_list|(
name|gbuf
operator|->
name|tu
operator|.
name|tnum
argument_list|)
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
expr|struct
name|thdr
operator|*
operator|)
literal|0
return|;
block|}
name|pg
operator|=
name|parsegcm
argument_list|(
name|pcb
argument_list|,
name|pg
argument_list|,
name|gbuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pg
condition|)
return|return
operator|(
expr|struct
name|thdr
operator|*
operator|)
literal|0
return|;
if|if
condition|(
name|GET
argument_list|(
name|pgsv
operator|->
name|ttype
argument_list|,
name|TOPT
argument_list|)
condition|)
operator|++
name|optcnt
expr_stmt|;
comment|/* Indicate nested opt grp. */
operator|--
name|grplvl
expr_stmt|;
continue|continue;
case|case
name|OREP
case|:
comment|/* OREP occurrence indicator for current token.*/
name|SET
argument_list|(
name|pgsv
operator|->
name|ttype
argument_list|,
name|TREP
operator||
name|TXREP
argument_list|)
expr_stmt|;
comment|/* Now treat like OPT. */
case|case
name|OPT
case|:
comment|/* OPT occurrence indicator for current token. */
name|SET
argument_list|(
name|pgsv
operator|->
name|ttype
argument_list|,
name|TXOPT
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET
argument_list|(
name|pgsv
operator|->
name|ttype
argument_list|,
name|TOPT
argument_list|)
condition|)
continue|continue;
comment|/* Exit if nested opt grp. */
name|SET
argument_list|(
name|pgsv
operator|->
name|ttype
argument_list|,
name|TOPT
argument_list|)
expr_stmt|;
operator|++
name|optcnt
expr_stmt|;
comment|/* Count opt tokens to see if grp is optional. */
continue|continue;
case|case
name|REP
case|:
comment|/* REP occurrence indicator for current token. */
name|SET
argument_list|(
name|pgsv
operator|->
name|ttype
argument_list|,
name|TREP
operator||
name|TXREP
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|OR
case|:
comment|/* OR connector found. */
if|if BITOFF
condition|(
name|pgh
operator|->
name|ttype
operator|,
name|TTAND
condition|)
name|SET
argument_list|(
name|pgh
operator|->
name|ttype
argument_list|,
name|TTOR
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET
argument_list|(
name|pgh
operator|->
name|ttype
argument_list|,
name|TTAND
argument_list|)
operator|!=
name|TTOR
condition|)
name|mderr
argument_list|(
literal|55
argument_list|,
name|ntoa
argument_list|(
name|gbuf
operator|->
name|tu
operator|.
name|tnum
argument_list|)
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|AND
case|:
comment|/* AND connector found. */
if|if BITOFF
condition|(
name|pgh
operator|->
name|ttype
operator|,
name|TTAND
condition|)
name|SET
argument_list|(
name|pgh
operator|->
name|ttype
argument_list|,
name|TTAND
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET
argument_list|(
name|pgh
operator|->
name|ttype
argument_list|,
name|TTAND
argument_list|)
operator|!=
name|TTAND
condition|)
name|mderr
argument_list|(
literal|55
argument_list|,
name|ntoa
argument_list|(
name|gbuf
operator|->
name|tu
operator|.
name|tnum
argument_list|)
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|SEQ
case|:
comment|/* SEQ connector found. */
if|if BITOFF
condition|(
name|pgh
operator|->
name|ttype
operator|,
name|TTAND
condition|)
name|SET
argument_list|(
name|pgh
operator|->
name|ttype
argument_list|,
name|TTSEQ
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET
argument_list|(
name|pgh
operator|->
name|ttype
argument_list|,
name|TTAND
argument_list|)
operator|!=
name|TTSEQ
condition|)
name|mderr
argument_list|(
literal|55
argument_list|,
name|ntoa
argument_list|(
name|gbuf
operator|->
name|tu
operator|.
name|tnum
argument_list|)
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|EE_
case|:
comment|/* Entity ended (correctly or incorrectly). */
if|if
condition|(
name|es
operator|<
name|essv
condition|)
block|{
name|synerr
argument_list|(
literal|37
argument_list|,
name|pcb
argument_list|)
expr_stmt|;
name|essv
operator|=
name|es
expr_stmt|;
block|}
continue|continue;
case|case
name|PIE_
case|:
comment|/* PI entity reference (not permitted). */
name|entpisw
operator|=
literal|0
expr_stmt|;
comment|/* Reset PI entity indicator. */
name|synerr
argument_list|(
literal|59
argument_list|,
name|pcb
argument_list|)
expr_stmt|;
continue|continue;
default|default:
comment|/* Syntax errors return in disgrace. */
name|synerr
argument_list|(
literal|37
argument_list|,
name|pcb
argument_list|)
expr_stmt|;
return|return
operator|(
expr|struct
name|thdr
operator|*
operator|)
literal|0
return|;
block|}
if|if
condition|(
name|pgh
operator|->
name|tu
operator|.
name|tnum
operator|>
name|GRPCNT
condition|)
block|{
name|mderr
argument_list|(
literal|113
argument_list|,
name|ntoa
argument_list|(
name|gbuf
operator|->
name|tu
operator|.
name|tnum
argument_list|)
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
expr|struct
name|thdr
operator|*
operator|)
literal|0
return|;
block|}
if|if
condition|(
name|gbuf
operator|->
name|tu
operator|.
name|tnum
operator|>
name|GRPGTCNT
condition|)
block|{
name|mderr
argument_list|(
literal|114
argument_list|,
name|ntoa
argument_list|(
name|gbuf
operator|->
name|tu
operator|.
name|tnum
argument_list|)
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
expr|struct
name|thdr
operator|*
operator|)
literal|0
return|;
block|}
if|if
condition|(
name|pgh
operator|->
name|tu
operator|.
name|tnum
operator|==
literal|1
condition|)
name|SET
argument_list|(
name|pgh
operator|->
name|ttype
argument_list|,
name|TTSEQ
argument_list|)
expr_stmt|;
comment|/* Unit grp is SEQ. */
comment|/* An optional token in an OR group makes the group optional. */
if|if
condition|(
name|GET
argument_list|(
name|pgh
operator|->
name|ttype
argument_list|,
name|TTMASK
argument_list|)
operator|==
name|TTOR
operator|&&
name|optcnt
condition|)
name|SET
argument_list|(
name|pgh
operator|->
name|ttype
argument_list|,
name|TOPT
argument_list|)
expr_stmt|;
comment|/* If all tokens in any group are optional, so is the group. */
if|if
condition|(
name|pgh
operator|->
name|tu
operator|.
name|tnum
operator|<=
name|optcnt
condition|)
name|SET
argument_list|(
name|pgh
operator|->
name|ttype
argument_list|,
name|TOPT
argument_list|)
expr_stmt|;
if|if
condition|(
name|es
operator|!=
name|essv
condition|)
name|synerr
argument_list|(
literal|37
argument_list|,
name|pcb
argument_list|)
expr_stmt|;
return|return
name|pg
return|;
comment|/* Return pointer to GRPS token. */
block|}
end_function

begin_comment
comment|/* PARSENM: Parser for SGML names, which can be translated with LEXTRAN.             The input is read from the entity stack.  CC is 1st char of name.             Returns a pointer to the parsed name. */
end_comment

begin_function
name|UNCH
modifier|*
name|parsenm
parameter_list|(
name|tbuf
parameter_list|,
name|nc
parameter_list|)
name|UNCH
modifier|*
name|tbuf
decl_stmt|;
comment|/* Buffer for name:>=NAMELEN+2. */
name|int
name|nc
decl_stmt|;
comment|/* Namecase translation: 1=yes; 0=no. */
block|{
name|UNCH
name|len
decl_stmt|;
comment|/* Length of name (incl EOS& length byte). */
operator|*
operator|(
name|tbuf
operator|+
operator|(
name|len
operator|=
literal|1
operator|)
operator|)
operator|=
name|nc
condition|?
name|lextran
index|[
operator|*
name|FPOS
index|]
else|:
operator|*
name|FPOS
expr_stmt|;
while|while
condition|(
operator|(
name|NEWCC
operator|,
operator|(
name|int
operator|)
name|lextoke
index|[
operator|*
name|FPOS
index|]
operator|>=
name|NMC
operator|)
operator|&&
operator|(
name|len
operator|<
name|NAMELEN
operator|)
condition|)
block|{
name|TRACETKN
argument_list|(
name|NMC
argument_list|,
name|lextoke
argument_list|)
expr_stmt|;
if|if
condition|(
name|lextoke
index|[
operator|*
operator|(
name|tbuf
operator|+
operator|++
name|len
operator|)
operator|=
operator|(
name|nc
condition|?
name|lextran
index|[
operator|*
name|FPOS
index|]
else|:
operator|*
name|FPOS
operator|)
index|]
operator|==
name|EOB
condition|)
block|{
operator|--
name|len
expr_stmt|;
name|entget
argument_list|()
expr_stmt|;
block|}
block|}
name|REPEATCC
expr_stmt|;
comment|/* Put back the non-token character. */
operator|*
operator|(
name|tbuf
operator|+
operator|++
name|len
operator|)
operator|=
name|EOS
expr_stmt|;
comment|/* Terminate name with standard EOS. */
operator|*
name|tbuf
operator|=
operator|++
name|len
expr_stmt|;
comment|/* Store length ahead of name. */
return|return
name|tbuf
return|;
block|}
end_function

begin_comment
comment|/* PARSETKN: Parser for start-tag attribute value tokens.              First character of token is already in *FPOS.              Returns a pointer to the parsed token. 	     Parsed token has EOS but no length byte. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USE_PROTOTYPES
end_ifdef

begin_function
name|UNCH
modifier|*
name|parsetkn
parameter_list|(
name|UNCH
modifier|*
name|tbuf
parameter_list|,
name|UNCH
name|scope
parameter_list|,
name|int
name|maxlen
parameter_list|)
else|#
directive|else
function|UNCH *parsetkn
parameter_list|(
name|tbuf
parameter_list|,
name|scope
parameter_list|,
name|maxlen
parameter_list|)
name|UNCH
modifier|*
name|tbuf
decl_stmt|;
comment|/* Buffer for token:>=maxlen+1. */
name|UNCH
name|scope
decl_stmt|;
comment|/* Minimum lexical class allowed. */
name|int
name|maxlen
decl_stmt|;
comment|/* Maximum length of a token. */
endif|#
directive|endif
block|{
name|int
name|i
init|=
literal|1
decl_stmt|;
name|tbuf
index|[
literal|0
index|]
operator|=
operator|*
name|FPOS
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|maxlen
condition|)
block|{
name|NEWCC
expr_stmt|;
if|if
condition|(
name|lextoke
index|[
operator|*
name|FPOS
index|]
operator|<
name|scope
condition|)
block|{
name|REPEATCC
expr_stmt|;
break|break;
block|}
name|TRACETKN
argument_list|(
name|scope
argument_list|,
name|lextoke
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|FPOS
operator|==
name|EOBCHAR
condition|)
name|entget
argument_list|()
expr_stmt|;
else|else
name|tbuf
index|[
name|i
operator|++
index|]
operator|=
operator|*
name|FPOS
expr_stmt|;
block|}
name|tbuf
index|[
name|i
index|]
operator|=
name|EOS
expr_stmt|;
return|return
name|tbuf
return|;
block|}
end_function

begin_comment
comment|/* PARSESEQ: Parser for blank sequences (i.e., space and TAB characters ).              First character of sequence is already in *FPOS. */
end_comment

begin_function
name|VOID
name|parseseq
parameter_list|(
name|tbuf
parameter_list|,
name|maxlen
parameter_list|)
name|UNCH
modifier|*
name|tbuf
decl_stmt|;
comment|/* Buffer for storing found sequence. */
name|int
name|maxlen
decl_stmt|;
comment|/* Maximum length of a blank sequence. */
block|{
name|tbuf
index|[
literal|0
index|]
operator|=
operator|*
name|FPOS
expr_stmt|;
name|datalen
operator|=
literal|1
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|NEWCC
expr_stmt|;
if|if
condition|(
operator|*
name|FPOS
operator|==
name|EOBCHAR
condition|)
block|{
name|entget
argument_list|()
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|lextoke
index|[
operator|*
name|FPOS
index|]
operator|!=
name|SEP
operator|&&
operator|*
name|FPOS
operator|!=
name|SPCCHAR
operator|)
operator|||
name|datalen
operator|>=
name|maxlen
condition|)
break|break;
name|tbuf
index|[
name|datalen
operator|++
index|]
operator|=
operator|*
name|FPOS
expr_stmt|;
name|TRACETKN
argument_list|(
name|SEP
argument_list|,
name|lextoke
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* S2VALNM: Parser for attribute values that are tokenized like names.             The input is read from a string (hence S ("string") 2 ("to") VALNM).             It stops at the first bad character.             Returns a pointer to the created name. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USE_PROTOTYPES
end_ifdef

begin_function
name|UNCH
modifier|*
name|s2valnm
parameter_list|(
name|UNCH
modifier|*
name|nm
parameter_list|,
name|UNCH
modifier|*
name|s
parameter_list|,
name|UNCH
name|scope
parameter_list|,
name|int
name|translate
parameter_list|)
else|#
directive|else
function|UNCH *s2valnm
parameter_list|(
name|nm
parameter_list|,
name|s
parameter_list|,
name|scope
parameter_list|,
name|translate
parameter_list|)
name|UNCH
modifier|*
name|nm
decl_stmt|;
comment|/* Name to be created. */
name|UNCH
modifier|*
name|s
decl_stmt|;
comment|/* Source string to be parsed as name. */
name|UNCH
name|scope
decl_stmt|;
comment|/* Minimum lexical class allowed. */
name|int
name|translate
decl_stmt|;
comment|/* Namecase translation: 1=yes; 0=no. */
endif|#
directive|endif
block|{
name|UNCH
name|len
init|=
literal|0
decl_stmt|;
comment|/* Length of name (incl EOS and length). */
for|for
control|(
init|;
operator|(
name|int
operator|)
name|lextoke
index|[
operator|*
name|s
index|]
operator|>=
name|scope
operator|&&
name|len
operator|<
name|NAMELEN
condition|;
name|s
operator|++
control|)
name|nm
index|[
operator|++
name|len
index|]
operator|=
name|translate
condition|?
name|lextran
index|[
operator|*
name|s
index|]
else|:
operator|*
name|s
expr_stmt|;
name|nm
index|[
operator|++
name|len
index|]
operator|=
name|EOS
expr_stmt|;
comment|/* Terminate name with standard EOS. */
operator|*
name|nm
operator|=
operator|++
name|len
expr_stmt|;
comment|/* Store length ahead of name. */
return|return
name|nm
return|;
block|}
end_function

begin_comment
comment|/* PARSEVAL: Parser for attribute values.              The input is read from a string and tokenized in a buffer.              The input is terminated by EOS.              Each token is preceded by its actual length; there is no EOS.              If an error occurs while parsing, or              if a token doesn't conform, set the token count to 0 to show that              value was not tokenized and return the error code.              After successful parse, return buffer length and 0 error code.              The number of tokens found is set in external variable tokencnt. */
end_comment

begin_function
name|int
name|parseval
parameter_list|(
name|s
parameter_list|,
name|atype
parameter_list|,
name|tbuf
parameter_list|)
name|UNCH
modifier|*
name|s
decl_stmt|;
comment|/* Source string to be parsed as token list. */
name|UNS
name|atype
decl_stmt|;
comment|/* Type of token list expected. */
name|UNCH
modifier|*
name|tbuf
decl_stmt|;
comment|/* Work area for tokenization. */
block|{
name|int
name|t
decl_stmt|;
name|UNCH
modifier|*
name|pt
init|=
name|tbuf
decl_stmt|;
name|pcbval
operator|.
name|newstate
operator|=
literal|0
expr_stmt|;
name|tokencnt
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|pcbval
operator|.
name|input
operator|=
name|lextoke
index|[
operator|*
name|s
index|]
expr_stmt|;
name|pcbval
operator|.
name|state
operator|=
name|pcbval
operator|.
name|newstate
expr_stmt|;
name|pcbval
operator|.
name|newstate
operator|=
operator|(
operator|*
operator|(
name|pcbval
operator|.
name|ptab
operator|+
name|pcbval
operator|.
name|state
operator|)
operator|)
index|[
name|pcbval
operator|.
name|input
index|]
expr_stmt|;
name|pcbval
operator|.
name|action
operator|=
operator|(
operator|*
operator|(
name|pcbval
operator|.
name|ptab
operator|+
name|pcbval
operator|.
name|state
operator|+
literal|1
operator|)
operator|)
index|[
name|pcbval
operator|.
name|input
index|]
expr_stmt|;
name|TRACEVAL
argument_list|(
operator|&
name|pcbval
argument_list|,
name|atype
argument_list|,
name|s
argument_list|,
name|tokencnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcbval
operator|.
name|action
operator|!=
name|NOPA
condition|)
break|break;
name|s
operator|++
expr_stmt|;
block|}
switch|switch
condition|(
name|pcbval
operator|.
name|action
condition|)
block|{
case|case
name|INVA
case|:
comment|/* Invalid character; terminate parse. */
if|if
condition|(
operator|*
name|s
operator|==
literal|'\0'
condition|)
goto|goto
name|alldone
goto|;
comment|/* Normal termination. */
name|tokencnt
operator|=
literal|0
expr_stmt|;
comment|/* Value was not tokenized. */
return|return
operator|(
literal|14
operator|)
return|;
case|case
name|LENA
case|:
comment|/* Length limit of token exceeded; end parse. */
name|tokencnt
operator|=
literal|0
expr_stmt|;
comment|/* Value was not tokenized. */
return|return
operator|(
literal|15
operator|)
return|;
default|default:
comment|/* Token begun: NUMA, NASA, or NMTA. */
break|break;
block|}
operator|++
name|tokencnt
expr_stmt|;
comment|/* One token per iteration. */
switch|switch
condition|(
name|atype
condition|)
block|{
case|case
name|AENTITY
case|:
if|if
condition|(
name|tokencnt
operator|>
literal|1
condition|)
block|{
name|tokencnt
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|16
operator|)
return|;
block|}
case|case
name|AENTITYS
case|:
if|if
condition|(
name|pcbval
operator|.
name|action
operator|!=
name|NASA
condition|)
block|{
name|tokencnt
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|17
operator|)
return|;
block|}
name|s2valnm
argument_list|(
name|pt
argument_list|,
name|s
argument_list|,
name|NMC
argument_list|,
name|ENTCASE
argument_list|)
expr_stmt|;
break|break;
case|case
name|AID
case|:
case|case
name|AIDREF
case|:
case|case
name|ANAME
case|:
case|case
name|ANOTEGRP
case|:
if|if
condition|(
name|tokencnt
operator|>
literal|1
condition|)
block|{
name|tokencnt
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|16
operator|)
return|;
block|}
case|case
name|AIDREFS
case|:
case|case
name|ANAMES
case|:
if|if
condition|(
name|pcbval
operator|.
name|action
operator|!=
name|NASA
condition|)
block|{
name|tokencnt
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|17
operator|)
return|;
block|}
name|s2valnm
argument_list|(
name|pt
argument_list|,
name|s
argument_list|,
name|NMC
argument_list|,
name|NAMECASE
argument_list|)
expr_stmt|;
break|break;
case|case
name|ANMTGRP
case|:
case|case
name|ANMTOKE
case|:
if|if
condition|(
name|tokencnt
operator|>
literal|1
condition|)
block|{
name|tokencnt
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|16
operator|)
return|;
block|}
case|case
name|ANMTOKES
case|:
comment|/* No test needed because NMTA, NUMA and NASA are all valid. */
name|s2valnm
argument_list|(
name|pt
argument_list|,
name|s
argument_list|,
name|NMC
argument_list|,
name|NAMECASE
argument_list|)
expr_stmt|;
break|break;
case|case
name|ANUMBER
case|:
if|if
condition|(
name|tokencnt
operator|>
literal|1
condition|)
block|{
name|tokencnt
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|16
operator|)
return|;
block|}
case|case
name|ANUMBERS
case|:
if|if
condition|(
name|pcbval
operator|.
name|action
operator|!=
name|NUMA
condition|)
block|{
name|tokencnt
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|17
operator|)
return|;
block|}
name|s2valnm
argument_list|(
name|pt
argument_list|,
name|s
argument_list|,
name|NU
argument_list|,
name|NAMECASE
argument_list|)
expr_stmt|;
name|t
operator|=
name|lextoke
index|[
name|s
index|[
operator|*
name|pt
operator|-
literal|2
index|]
index|]
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|NMS
operator|||
name|t
operator|==
name|NMC
condition|)
block|{
name|tokencnt
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|17
operator|)
return|;
block|}
break|break;
case|case
name|ANUTOKE
case|:
if|if
condition|(
name|tokencnt
operator|>
literal|1
condition|)
block|{
name|tokencnt
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|16
operator|)
return|;
block|}
case|case
name|ANUTOKES
case|:
if|if
condition|(
name|pcbval
operator|.
name|action
operator|!=
name|NUMA
condition|)
block|{
name|tokencnt
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|17
operator|)
return|;
block|}
name|s2valnm
argument_list|(
name|pt
argument_list|,
name|s
argument_list|,
name|NMC
argument_list|,
name|NAMECASE
argument_list|)
expr_stmt|;
break|break;
block|}
operator|*
name|pt
operator|-=
literal|2
expr_stmt|;
name|s
operator|+=
operator|*
name|pt
expr_stmt|;
name|pt
operator|+=
operator|*
name|pt
operator|+
literal|1
expr_stmt|;
block|}
name|alldone
label|:
operator|*
name|pt
operator|++
operator|=
name|EOS
expr_stmt|;
if|if
condition|(
operator|*
name|tbuf
operator|==
literal|'\0'
condition|)
return|return
literal|25
return|;
if|if
condition|(
name|atype
operator|<
name|ATKNLIST
condition|)
operator|*
name|tbuf
operator|+=
literal|2
expr_stmt|;
comment|/* include length and EOS */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Local Variables: c-indent-level: 5 c-continued-statement-offset: 5 c-brace-offset: -5 c-argdecl-indent: 0 c-label-offset: -5 comment-column: 30 End: */
end_comment

end_unit

