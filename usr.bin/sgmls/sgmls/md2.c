begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"sgmlincl.h"
end_include

begin_comment
comment|/* #INCLUDE statements for SGML parser. */
end_comment

begin_comment
comment|/* MDENTITY: Process ENTITY declaration. */
end_comment

begin_function
name|VOID
name|mdentity
parameter_list|(
name|tbuf
parameter_list|)
name|UNCH
modifier|*
name|tbuf
decl_stmt|;
comment|/* Work area for tokenization[LITLEN+2]. */
block|{
name|struct
name|fpi
name|fpicb
decl_stmt|;
comment|/* Formal public identifier structure. */
name|struct
name|fpi
modifier|*
name|fpis
init|=
operator|&
name|fpicb
decl_stmt|;
comment|/* Ptr to current or #DEFAULT fpi. */
name|union
name|etext
name|etx
decl_stmt|;
comment|/* Ptr to entity text. */
name|UNCH
name|estore
init|=
name|ESM
decl_stmt|;
comment|/* Entity storage class. */
name|struct
name|entity
modifier|*
name|ecb
decl_stmt|;
comment|/* Ptr to entity control block. */
name|int
name|parmsw
init|=
literal|0
decl_stmt|;
comment|/* 1=parameter entity declaration; 0 = not. */
name|int
name|defltsw
init|=
literal|0
decl_stmt|;
comment|/* 1=#DEFAULT declaration; 0=not. */
name|PNE
name|pne
init|=
literal|0
decl_stmt|;
comment|/* Ptr to N/C/SDATA entity control block. */
name|mdname
operator|=
name|key
index|[
name|KENTITY
index|]
expr_stmt|;
comment|/* Declaration name for messages. */
name|subdcl
operator|=
name|NULL
expr_stmt|;
comment|/* No subject as yet. */
name|parmno
operator|=
literal|0
expr_stmt|;
comment|/* No parameters as yet. */
name|mdessv
operator|=
name|es
expr_stmt|;
comment|/* Save es for checking entity nesting. */
comment|/* PARAMETER 1: Entity name.      */
name|pcbmd
operator|.
name|newstate
operator|=
literal|0
expr_stmt|;
name|parsemd
argument_list|(
name|nmbuf
argument_list|,
name|ENTCASE
argument_list|,
operator|&
name|pcblitp
argument_list|,
name|NAMELEN
argument_list|)
expr_stmt|;
name|TRACEMD
argument_list|(
literal|"1: entity nm"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pcbmd
operator|.
name|action
condition|)
block|{
case|case
name|PEN
case|:
name|parsemd
argument_list|(
name|nmbuf
operator|+
literal|1
argument_list|,
name|ENTCASE
argument_list|,
operator|&
name|pcblitp
argument_list|,
name|NAMELEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcbmd
operator|.
name|action
operator|!=
name|NAS
condition|)
block|{
name|mderr
argument_list|(
literal|120
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|nmbuf
index|[
literal|1
index|]
operator|==
name|NAMELEN
operator|+
literal|2
condition|)
block|{
comment|/* It was too long. */
name|nmbuf
index|[
literal|0
index|]
operator|=
name|NAMELEN
operator|+
literal|2
expr_stmt|;
name|nmbuf
index|[
name|NAMELEN
operator|+
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|mderr
argument_list|(
literal|65
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|nmbuf
index|[
literal|0
index|]
operator|=
name|nmbuf
index|[
literal|1
index|]
operator|+
literal|1
expr_stmt|;
comment|/* Increment length for PERO. */
name|nmbuf
index|[
literal|1
index|]
operator|=
name|lex
operator|.
name|d
operator|.
name|pero
expr_stmt|;
comment|/* Prefix PERO to name. */
name|parmsw
operator|=
literal|1
expr_stmt|;
comment|/* Indicate parameter entity. */
case|case
name|NAS
case|:
break|break;
case|case
name|RNS
case|:
comment|/* Reserved name started. */
if|if
condition|(
name|ustrcmp
argument_list|(
name|nmbuf
operator|+
literal|1
argument_list|,
name|key
index|[
name|KDEFAULT
index|]
argument_list|)
condition|)
block|{
name|mderr
argument_list|(
literal|118
argument_list|,
name|nmbuf
operator|+
literal|1
argument_list|,
name|key
index|[
name|KDEFAULT
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
name|memcpy
argument_list|(
name|nmbuf
argument_list|,
name|indefent
argument_list|,
operator|*
name|indefent
argument_list|)
expr_stmt|;
comment|/* Copy #DEFAULT to name buffer. */
name|fpis
operator|=
operator|&
name|fpidf
expr_stmt|;
comment|/* Use #DEFAULT fpi if external. */
name|defltsw
operator|=
literal|1
expr_stmt|;
comment|/* Indicate #DEFAULT is being defined.*/
break|break;
default|default:
name|mderr
argument_list|(
literal|122
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|subdcl
operator|=
name|nmbuf
operator|+
literal|1
expr_stmt|;
comment|/* Subject name for error messages. */
comment|/* PARAMETER 2: Entity text keyword (optional).      */
name|parsemd
argument_list|(
name|tbuf
argument_list|,
name|NAMECASE
argument_list|,
operator|&
name|pcblitp
argument_list|,
name|LITLEN
argument_list|)
expr_stmt|;
name|TRACEMD
argument_list|(
literal|"2: keyword"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pcbmd
operator|.
name|action
condition|)
block|{
case|case
name|NAS
case|:
if|if
condition|(
operator|(
name|estore
operator|=
operator|(
name|UNCH
operator|)
name|mapsrch
argument_list|(
name|enttab
argument_list|,
name|tbuf
operator|+
literal|1
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|estore
operator|=
name|parmsw
condition|?
name|ESP
else|:
name|ESF
expr_stmt|;
name|pne
operator|=
operator|(
name|PNE
operator|)
name|rmalloc
argument_list|(
name|NESZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|mdextid
argument_list|(
name|tbuf
argument_list|,
name|fpis
argument_list|,
name|nmbuf
operator|+
literal|1
operator|+
name|parmsw
argument_list|,
operator|&
name|estore
argument_list|,
name|pne
argument_list|)
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|defltsw
condition|)
name|etx
operator|.
name|x
operator|=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|etx
operator|.
name|x
operator|=
name|entgen
argument_list|(
operator|&
name|fpicb
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|parmsw
condition|)
name|mderr
argument_list|(
literal|148
argument_list|,
name|nmbuf
operator|+
literal|2
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
else|else
name|mderr
argument_list|(
literal|147
argument_list|,
name|nmbuf
operator|+
literal|1
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
goto|goto
name|parm4
goto|;
block|}
if|if
condition|(
name|parmsw
operator|&&
operator|(
name|estore
operator|==
name|ESX
operator|||
name|estore
operator|==
name|ESC
operator|)
condition|)
block|{
name|mderr
argument_list|(
literal|38
argument_list|,
name|tbuf
operator|+
literal|1
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|estore
operator|=
name|ESM
expr_stmt|;
block|}
name|parsemd
argument_list|(
name|tbuf
argument_list|,
name|NAMECASE
argument_list|,
operator|&
name|pcblitp
argument_list|,
name|LITLEN
argument_list|)
expr_stmt|;
break|break;
default|default:
name|estore
operator|=
name|ESM
expr_stmt|;
break|break;
block|}
comment|/* PARAMETER 3: Parameter literal.      */
name|TRACEMD
argument_list|(
literal|"3: literal"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pcbmd
operator|.
name|action
condition|)
block|{
case|case
name|LITE
case|:
case|case
name|LIT
case|:
switch|switch
condition|(
name|estore
condition|)
block|{
case|case
name|ESM
case|:
comment|/* LITERAL: parameter literal required. */
case|case
name|ESC
case|:
comment|/* CDATA: parameter literal required. */
case|case
name|ESX
case|:
comment|/* SDATA: parameter literal required. */
case|case
name|ESI
case|:
comment|/* PI: parameter literal required. */
name|etx
operator|.
name|c
operator|=
name|savestr
argument_list|(
name|tbuf
argument_list|)
expr_stmt|;
break|break;
case|case
name|ESMD
case|:
comment|/* MD: parameter literal required. */
name|etx
operator|.
name|c
operator|=
name|sandwich
argument_list|(
name|tbuf
argument_list|,
name|lex
operator|.
name|m
operator|.
name|mdo
argument_list|,
name|lex
operator|.
name|m
operator|.
name|mdc
argument_list|)
expr_stmt|;
goto|goto
name|bcheck
goto|;
case|case
name|ESMS
case|:
comment|/* MS: parameter literal required. */
name|etx
operator|.
name|c
operator|=
name|sandwich
argument_list|(
name|tbuf
argument_list|,
name|lex
operator|.
name|m
operator|.
name|mss
argument_list|,
name|lex
operator|.
name|m
operator|.
name|mse
argument_list|)
expr_stmt|;
goto|goto
name|bcheck
goto|;
case|case
name|ESS
case|:
comment|/* STARTTAG: parameter literal required. */
name|etx
operator|.
name|c
operator|=
name|sandwich
argument_list|(
name|tbuf
argument_list|,
name|lex
operator|.
name|m
operator|.
name|stag
argument_list|,
name|lex
operator|.
name|m
operator|.
name|tagc
argument_list|)
expr_stmt|;
goto|goto
name|bcheck
goto|;
case|case
name|ESE
case|:
comment|/* ENDTAG: parameter literal required. */
name|etx
operator|.
name|c
operator|=
name|sandwich
argument_list|(
name|tbuf
argument_list|,
name|lex
operator|.
name|m
operator|.
name|etag
argument_list|,
name|lex
operator|.
name|m
operator|.
name|tagc
argument_list|)
expr_stmt|;
name|bcheck
label|:
if|if
condition|(
name|etx
operator|.
name|c
operator|==
literal|0
condition|)
block|{
name|mderr
argument_list|(
literal|225
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
block|}
break|break;
default|default:
name|mderr
argument_list|(
literal|123
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* PARAMETER 4: End of declaration.      */
name|parsemd
argument_list|(
name|tbuf
argument_list|,
name|NAMECASE
argument_list|,
operator|&
name|pcblitp
argument_list|,
name|LITLEN
argument_list|)
expr_stmt|;
name|parm4
label|:
name|TRACEMD
argument_list|(
name|emd
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcbmd
operator|.
name|action
operator|!=
name|EMD
condition|)
name|mderr
argument_list|(
literal|126
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|es
operator|!=
name|mdessv
condition|)
name|synerr
argument_list|(
literal|37
argument_list|,
operator|&
name|pcbmd
argument_list|)
expr_stmt|;
comment|/* EXECUTE: If the entity already exists, ignore the new definition.                  If it is a new entity, store the definition.      */
if|if
condition|(
operator|(
name|ecb
operator|=
name|entfind
argument_list|(
name|nmbuf
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|ecb
operator|->
name|estore
condition|)
block|{
if|if
condition|(
name|ecb
operator|->
name|dflt
condition|)
block|{
name|mderr
argument_list|(
literal|228
argument_list|,
name|nmbuf
operator|+
literal|1
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|hout
argument_list|(
operator|(
name|THASH
operator|)
name|etab
argument_list|,
name|nmbuf
argument_list|,
name|hash
argument_list|(
name|nmbuf
argument_list|,
name|ENTHASH
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ecb
operator|->
name|estore
operator|==
name|ESN
condition|)
block|{
name|frem
argument_list|(
operator|(
name|UNIV
operator|)
name|NEID
argument_list|(
name|ecb
operator|->
name|etx
operator|.
name|n
argument_list|)
argument_list|)
expr_stmt|;
name|frem
argument_list|(
operator|(
name|UNIV
operator|)
name|ecb
operator|->
name|etx
operator|.
name|n
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ecb
operator|->
name|estore
operator|>=
name|ESFM
condition|)
name|frem
argument_list|(
operator|(
name|UNIV
operator|)
name|ecb
operator|->
name|etx
operator|.
name|x
argument_list|)
expr_stmt|;
name|frem
argument_list|(
operator|(
name|UNIV
operator|)
name|ecb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Duplicate definition: not an error. */
if|if
condition|(
name|sw
operator|.
name|swdupent
condition|)
name|mderr
argument_list|(
literal|68
argument_list|,
name|nmbuf
operator|+
literal|1
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|estore
operator|<
name|ESFM
condition|)
name|frem
argument_list|(
operator|(
name|UNIV
operator|)
name|etx
operator|.
name|c
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
operator|++
name|ds
operator|.
name|ecbcnt
expr_stmt|;
comment|/* Do capacity before NOTATION. */
name|ds
operator|.
name|ecbtext
operator|+=
name|estore
operator|<
name|ESFM
condition|?
name|ustrlen
argument_list|(
name|etx
operator|.
name|c
argument_list|)
else|:
name|entlen
expr_stmt|;
name|ecb
operator|=
name|entdef
argument_list|(
name|nmbuf
argument_list|,
name|estore
argument_list|,
operator|&
name|etx
argument_list|)
expr_stmt|;
comment|/* Define the entity. */
if|if
condition|(
name|estore
operator|==
name|ESN
condition|)
block|{
comment|/* If entity is external: */
name|NEENAME
argument_list|(
name|pne
argument_list|)
operator|=
name|ecb
operator|->
name|ename
expr_stmt|;
comment|/* Store entity name in ne. */
name|NEID
argument_list|(
name|pne
argument_list|)
operator|=
name|etx
operator|.
name|x
expr_stmt|;
comment|/* Store system fileid in ne. */
name|NESYSID
argument_list|(
name|pne
argument_list|)
operator|=
name|fpis
operator|->
name|fpisysis
condition|?
name|savestr
argument_list|(
name|fpis
operator|->
name|fpisysis
argument_list|)
else|:
literal|0
expr_stmt|;
name|NEPUBID
argument_list|(
name|pne
argument_list|)
operator|=
name|fpis
operator|->
name|fpipubis
condition|?
name|savestr
argument_list|(
name|fpis
operator|->
name|fpipubis
argument_list|)
else|:
literal|0
expr_stmt|;
name|ecb
operator|->
name|etx
operator|.
name|n
operator|=
name|pne
expr_stmt|;
comment|/* Store ne control block in etx. */
name|TRACEESN
argument_list|(
name|pne
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pne
condition|)
name|frem
argument_list|(
operator|(
name|UNIV
operator|)
name|pne
argument_list|)
expr_stmt|;
if|if
condition|(
name|defltsw
condition|)
block|{
name|ecbdeflt
operator|=
name|ecb
expr_stmt|;
comment|/* If #DEFAULT save ecb. */
if|if
condition|(
name|fpidf
operator|.
name|fpipubis
condition|)
name|fpidf
operator|.
name|fpipubis
operator|=
name|savestr
argument_list|(
name|fpidf
operator|.
name|fpipubis
argument_list|)
expr_stmt|;
if|if
condition|(
name|fpidf
operator|.
name|fpisysis
condition|)
name|fpidf
operator|.
name|fpisysis
operator|=
name|savestr
argument_list|(
name|fpidf
operator|.
name|fpisysis
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* SANDWICH: Catenate a prefix and suffix to a string.    The result has an EOS but no length.    Return 0 if the result if longer than LITLEN. */
end_comment

begin_function
name|UNCH
modifier|*
name|sandwich
parameter_list|(
name|s
parameter_list|,
name|pref
parameter_list|,
name|suff
parameter_list|)
name|UNCH
modifier|*
name|s
decl_stmt|;
comment|/* String, with EOS. */
name|UNCH
modifier|*
name|pref
decl_stmt|;
comment|/* Prefix, with length and EOS. */
name|UNCH
modifier|*
name|suff
decl_stmt|;
comment|/* Suffix, with length and EOS. */
block|{
name|UNCH
modifier|*
name|pt
decl_stmt|;
name|UNS
name|slen
decl_stmt|,
name|tlen
decl_stmt|;
name|slen
operator|=
name|ustrlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|tlen
operator|=
name|slen
operator|+
operator|(
operator|*
name|pref
operator|-
literal|2
operator|)
operator|+
operator|(
operator|*
name|suff
operator|-
literal|2
operator|)
expr_stmt|;
if|if
condition|(
name|tlen
operator|>
name|LITLEN
condition|)
return|return
literal|0
return|;
name|pt
operator|=
operator|(
name|UNCH
operator|*
operator|)
name|rmalloc
argument_list|(
name|tlen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|pt
argument_list|,
name|pref
operator|+
literal|1
argument_list|,
operator|*
name|pref
operator|-
literal|2
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|pt
operator|+
operator|(
operator|*
name|pref
operator|-
literal|2
operator|)
argument_list|,
name|s
argument_list|,
name|slen
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|pt
operator|+
operator|(
operator|*
name|pref
operator|-
literal|2
operator|)
operator|+
name|slen
argument_list|,
name|suff
operator|+
literal|1
argument_list|,
operator|*
name|suff
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|pt
return|;
block|}
end_function

begin_comment
comment|/* MDEXTID: Process external identifier parameter of a markup declaration.             On entry, tbuf contains SYSTEM or PUBLIC if all is well.             NULL is returned if an error, otherwise fpis.  If it is a             valid external data entity, the caller's estore is set to ESN             and its nxetype is set to the code for the external entity type.             The event that terminated the parse is preserved in pcb.action,             so the caller should process it before further parsing. */
end_comment

begin_function
name|struct
name|fpi
modifier|*
name|mdextid
parameter_list|(
name|tbuf
parameter_list|,
name|fpis
parameter_list|,
name|ename
parameter_list|,
name|estore
parameter_list|,
name|pne
parameter_list|)
name|UNCH
modifier|*
name|tbuf
decl_stmt|;
comment|/* Work area for tokenization[2*(LITLEN+2)]. */
name|struct
name|fpi
modifier|*
name|fpis
decl_stmt|;
comment|/* FPI structure. */
name|UNCH
modifier|*
name|ename
decl_stmt|;
comment|/* Entity or notation name, with EOS, no length.*/
comment|/* NOTE: No PERO on parameter entity name. */
name|UNCH
modifier|*
name|estore
decl_stmt|;
comment|/* DTD, general or parameter entity, DCN. */
name|PNE
name|pne
decl_stmt|;
comment|/* Caller's external entity ptr. */
block|{
name|PDCB
name|dcb
decl_stmt|;
comment|/* Ptr to DCN control block. */
name|int
name|exidtype
decl_stmt|;
comment|/* External ID type: 0=none 1=system 2=public. */
name|int
name|exetype
decl_stmt|;
comment|/* External entity type. */
name|MEMZERO
argument_list|(
operator|(
name|UNIV
operator|)
name|fpis
argument_list|,
operator|(
name|UNS
operator|)
name|FPISZ
argument_list|)
expr_stmt|;
comment|/* Initialize fpi structure. */
comment|/* Move entity name into fpi (any PERO was stripped by caller). */
name|fpis
operator|->
name|fpinm
operator|=
name|ename
expr_stmt|;
name|entlen
operator|=
literal|0
expr_stmt|;
comment|/* Initialize external ID length. */
comment|/* PARAMETER 1: External identifier keyword or error.      */
name|TRACEMD
argument_list|(
literal|"1: extid keyword"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|exidtype
operator|=
name|mapsrch
argument_list|(
name|exttab
argument_list|,
name|tbuf
operator|+
literal|1
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|mderr
argument_list|(
literal|29
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
expr|struct
name|fpi
operator|*
operator|)
literal|0
return|;
block|}
if|if
condition|(
name|exidtype
operator|==
name|EDSYSTEM
condition|)
goto|goto
name|parm3
goto|;
comment|/* PARAMETER 2: Public ID literal.      */
comment|/* The length of a minimum literal cannot exceed the value of LITLEN 	in the reference quantity set. */
name|parsemd
argument_list|(
name|pubibuf
argument_list|,
name|NAMECASE
argument_list|,
operator|&
name|pcblitv
argument_list|,
name|REFLITLEN
argument_list|)
expr_stmt|;
name|TRACEMD
argument_list|(
literal|"2: pub ID literal"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pcbmd
operator|.
name|action
condition|)
block|{
case|case
name|LITE
case|:
comment|/* Use alternative literal delimiter. */
case|case
name|LIT
case|:
comment|/* Save literal as public ID string. */
name|entlen
operator|=
name|ustrlen
argument_list|(
name|pubibuf
argument_list|)
expr_stmt|;
name|fpis
operator|->
name|fpipubis
operator|=
name|pubibuf
expr_stmt|;
break|break;
default|default:
name|mderr
argument_list|(
literal|117
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
expr|struct
name|fpi
operator|*
operator|)
literal|0
return|;
comment|/* Signal error to caller. */
block|}
comment|/* PARAMETER 3: System ID literal.      */
name|parm3
label|:
name|parsemd
argument_list|(
name|sysibuf
argument_list|,
name|NAMECASE
argument_list|,
operator|&
name|pcblitc
argument_list|,
name|LITLEN
argument_list|)
expr_stmt|;
name|TRACEMD
argument_list|(
literal|"3: sys ID literal"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcbmd
operator|.
name|action
operator|==
name|LIT
operator|||
name|pcbmd
operator|.
name|action
operator|==
name|LITE
condition|)
block|{
name|entlen
operator|+=
name|ustrlen
argument_list|(
name|sysibuf
argument_list|)
expr_stmt|;
name|fpis
operator|->
name|fpisysis
operator|=
name|sysibuf
expr_stmt|;
name|parsemd
argument_list|(
name|tbuf
argument_list|,
name|NAMECASE
argument_list|,
operator|&
name|pcblitp
argument_list|,
name|LITLEN
argument_list|)
expr_stmt|;
block|}
else|else
name|memcpy
argument_list|(
name|tbuf
argument_list|,
name|sysibuf
argument_list|,
operator|*
name|sysibuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|estore
operator|!=
name|ESF
operator|||
name|pcbmd
operator|.
name|action
operator|!=
name|NAS
condition|)
goto|goto
name|genfpi
goto|;
comment|/* PARAMETER 4: Entity type keyword.      */
name|TRACEMD
argument_list|(
literal|"4: Entity type"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|exetype
operator|=
name|mapsrch
argument_list|(
name|extettab
argument_list|,
name|tbuf
operator|+
literal|1
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|mderr
argument_list|(
literal|24
argument_list|,
name|tbuf
operator|+
literal|1
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
expr|struct
name|fpi
operator|*
operator|)
literal|0
return|;
block|}
if|if
condition|(
name|exetype
operator|==
name|ESNSUB
operator|&&
name|SUBDOC
operator|==
name|NO
condition|)
block|{
name|mderr
argument_list|(
literal|90
argument_list|,
name|tbuf
operator|+
literal|1
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
expr|struct
name|fpi
operator|*
operator|)
literal|0
return|;
block|}
name|NEXTYPE
argument_list|(
name|pne
argument_list|)
operator|=
operator|(
name|UNCH
operator|)
name|exetype
expr_stmt|;
comment|/* Save entity type in caller's ne. */
operator|*
name|estore
operator|=
name|ESN
expr_stmt|;
comment|/* Signal that entity is a data entity. */
if|if
condition|(
name|exetype
operator|==
name|ESNSUB
condition|)
block|{
name|pne
operator|->
name|nedcn
operator|=
literal|0
expr_stmt|;
name|parsemd
argument_list|(
name|tbuf
argument_list|,
name|NAMECASE
argument_list|,
operator|&
name|pcblitp
argument_list|,
name|LITLEN
argument_list|)
expr_stmt|;
goto|goto
name|genfpi
goto|;
block|}
comment|/* PARAMETER 5: Notation name.      */
name|parsemd
argument_list|(
name|lbuf
argument_list|,
name|NAMECASE
argument_list|,
operator|&
name|pcblitp
argument_list|,
name|NAMELEN
argument_list|)
expr_stmt|;
name|TRACEMD
argument_list|(
literal|"5: notation"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcbmd
operator|.
name|action
operator|!=
name|NAS
condition|)
block|{
name|mderr
argument_list|(
literal|119
argument_list|,
name|tbuf
operator|+
literal|1
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
expr|struct
name|fpi
operator|*
operator|)
literal|0
return|;
block|}
comment|/* Locate the data content notation. */
name|pne
operator|->
name|nedcn
operator|=
name|dcb
operator|=
name|dcndef
argument_list|(
name|lbuf
argument_list|)
expr_stmt|;
comment|/* Note that we have defined an entity with this notation. 	If attributes are later defined for this notation, we'll 	have to fix up this entity. */
name|dcb
operator|->
name|entsw
operator|=
literal|1
expr_stmt|;
comment|/* PARAMETER 6: Data attribute specification.      */
name|parsemd
argument_list|(
name|lbuf
argument_list|,
name|NAMECASE
argument_list|,
operator|&
name|pcblitp
argument_list|,
name|NAMELEN
argument_list|)
expr_stmt|;
name|TRACEMD
argument_list|(
literal|"6: [att list]"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcbmd
operator|.
name|action
operator|!=
name|MDS
condition|)
block|{
comment|/* No attributes specified. */
if|if
condition|(
name|dcb
operator|->
name|adl
operator|==
literal|0
condition|)
name|NEAL
argument_list|(
name|pne
argument_list|)
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|initatt
argument_list|(
name|dcb
operator|->
name|adl
argument_list|)
expr_stmt|;
name|adlval
argument_list|(
operator|(
name|int
operator|)
name|ADN
argument_list|(
name|al
argument_list|)
argument_list|,
operator|(
expr|struct
name|etd
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|storedatt
argument_list|(
name|pne
argument_list|)
expr_stmt|;
block|}
goto|goto
name|genfpi
goto|;
block|}
if|if
condition|(
name|dcb
operator|->
name|adl
operator|==
literal|0
condition|)
block|{
comment|/* Atts specified, but none defined. */
name|mderr
argument_list|(
literal|22
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
expr|struct
name|fpi
operator|*
operator|)
literal|0
return|;
block|}
name|pcbstag
operator|.
name|newstate
operator|=
name|pcbstan
expr_stmt|;
comment|/* First separator is optional. */
if|if
condition|(
operator|(
name|parseatt
argument_list|(
name|dcb
operator|->
name|adl
argument_list|,
name|tbuf
argument_list|)
operator|)
operator|==
literal|0
condition|)
comment|/* Empty list. */
name|mderr
argument_list|(
literal|91
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|adlval
argument_list|(
operator|(
name|int
operator|)
name|ADN
argument_list|(
name|al
argument_list|)
argument_list|,
operator|(
expr|struct
name|etd
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|storedatt
argument_list|(
name|pne
argument_list|)
expr_stmt|;
block|}
name|parse
argument_list|(
operator|&
name|pcbeal
argument_list|)
expr_stmt|;
comment|/* Parse the list ending. */
name|parsemd
argument_list|(
name|tbuf
argument_list|,
name|NAMECASE
argument_list|,
operator|&
name|pcblitp
argument_list|,
name|LITLEN
argument_list|)
expr_stmt|;
comment|/* GENFPI: Builds a formal public identifier structure, including the                 entity name, offsets of the components of the public ID, and                 other data a system might use to identify the actual file.      */
name|genfpi
label|:
name|TRACEMD
argument_list|(
literal|"7: generate fpi"
argument_list|)
expr_stmt|;
name|fpis
operator|->
name|fpistore
operator|=
operator|*
name|estore
operator|-
name|ESFM
operator|+
literal|1
expr_stmt|;
comment|/* External entity type: 1-6. */
if|if
condition|(
operator|*
name|estore
operator|==
name|ESN
condition|)
block|{
if|if
condition|(
name|NEXTYPE
argument_list|(
name|pne
argument_list|)
operator|==
name|ESNSUB
condition|)
name|fpis
operator|->
name|fpinedcn
operator|=
literal|0
expr_stmt|;
else|else
name|fpis
operator|->
name|fpinedcn
operator|=
name|NEDCN
argument_list|(
name|pne
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
comment|/* Analyze public ID and make structure entries. */
if|if
condition|(
name|exidtype
operator|==
name|EDPUBLIC
condition|)
block|{
if|if
condition|(
name|parsefpi
argument_list|(
name|fpis
argument_list|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|FORMAL
operator|==
name|YES
condition|)
name|mderr
argument_list|(
literal|88
argument_list|,
name|fpis
operator|->
name|fpipubis
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|fpis
operator|->
name|fpiversw
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Signal bad formal public ID. */
block|}
block|}
return|return
name|fpis
return|;
block|}
end_function

begin_comment
comment|/* Store a data attribute. */
end_comment

begin_function
name|VOID
name|storedatt
parameter_list|(
name|pne
parameter_list|)
name|PNE
name|pne
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|NEAL
argument_list|(
name|pne
argument_list|)
operator|=
operator|(
expr|struct
name|ad
operator|*
operator|)
name|rmalloc
argument_list|(
operator|(
literal|1
operator|+
name|ADN
argument_list|(
name|al
argument_list|)
operator|)
operator|*
name|ADSZ
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|UNIV
operator|)
name|NEAL
argument_list|(
name|pne
argument_list|)
argument_list|,
operator|(
name|UNIV
operator|)
name|al
argument_list|,
operator|(
literal|1
operator|+
name|ADN
argument_list|(
name|al
argument_list|)
operator|)
operator|*
name|ADSZ
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
operator|(
name|int
operator|)
name|ADN
argument_list|(
name|al
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|GET
argument_list|(
name|ADFLAGS
argument_list|(
name|al
argument_list|,
name|i
argument_list|)
argument_list|,
name|ASPEC
argument_list|)
condition|)
name|ds
operator|.
name|attdef
operator|+=
name|ADLEN
argument_list|(
name|al
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|NEAL
argument_list|(
name|pne
argument_list|)
index|[
name|i
index|]
operator|.
name|addef
operator|!=
literal|0
condition|)
name|NEAL
argument_list|(
name|pne
argument_list|)
index|[
name|i
index|]
operator|.
name|addef
operator|=
name|savestr
argument_list|(
name|NEAL
argument_list|(
name|pne
argument_list|)
index|[
name|i
index|]
operator|.
name|addef
argument_list|)
expr_stmt|;
block|}
name|ds
operator|.
name|attcnt
operator|+=
name|AN
argument_list|(
name|al
argument_list|)
expr_stmt|;
comment|/* Number of attributes defined. */
if|#
directive|if
literal|0
comment|/* I can't see any reason to increase AVGRPCNT here. */
block|ds.attgcnt += ADN(al) - AN(al);
comment|/* Number of att grp members. */
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* PARSEFPI: Parses a formal public identifier and builds a control block.              PARSEFPI returns a positive error code (1-10), or 0 if no errors.              It set fpiversw if no version was specified in the ID and the              public text is in a class that permits display versions.              Note: An empty version ("//") can be specified (usually it is              the non-device-specific form, such as a definitional entity set). */
end_comment

begin_function
name|int
name|parsefpi
parameter_list|(
name|f
parameter_list|)
name|PFPI
name|f
decl_stmt|;
comment|/* Ptr to formal public identifier structure. */
block|{
name|UNCH
modifier|*
name|l
decl_stmt|;
comment|/* Pointer to EOS of public identifier. */
name|UNCH
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
comment|/* Ptrs to current field in public identifier. */
name|UNS
name|len
decl_stmt|;
comment|/* Field length */
name|p
operator|=
name|f
operator|->
name|fpipubis
expr_stmt|;
comment|/* Point to start of identifier. */
name|l
operator|=
name|p
operator|+
name|ustrlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* Point to EOS of identifier. */
if|if
condition|(
operator|(
operator|*
name|p
operator|==
literal|'+'
operator|||
operator|*
name|p
operator|==
literal|'-'
operator|)
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'/'
operator|&&
name|p
index|[
literal|2
index|]
operator|==
literal|'/'
condition|)
block|{
comment|/* If owner registered, 					     unregistered. */
name|f
operator|->
name|fpiot
operator|=
operator|*
name|p
expr_stmt|;
comment|/* Save owner type. */
name|p
operator|+=
literal|3
expr_stmt|;
block|}
else|else
name|f
operator|->
name|fpiot
operator|=
literal|'!'
expr_stmt|;
comment|/* Indicate ISO owner identifier. */
if|if
condition|(
operator|(
name|q
operator|=
name|pubfield
argument_list|(
name|p
argument_list|,
name|l
argument_list|,
literal|'/'
argument_list|,
operator|&
name|len
argument_list|)
operator|)
operator|==
literal|0
condition|)
comment|/* Find end of owner ID field. */
return|return
literal|2
return|;
name|f
operator|->
name|fpiol
operator|=
name|len
expr_stmt|;
comment|/* Save owner ID length. */
name|f
operator|->
name|fpio
operator|=
name|p
operator|-
name|f
operator|->
name|fpipubis
expr_stmt|;
comment|/* Save offset in pubis to owner ID. */
if|if
condition|(
operator|(
name|p
operator|=
name|pubfield
argument_list|(
name|q
argument_list|,
name|l
argument_list|,
literal|' '
argument_list|,
operator|&
name|len
argument_list|)
operator|)
operator|==
literal|0
condition|)
comment|/* Find end of text class field. */
return|return
literal|3
return|;
operator|*
operator|(
operator|--
name|p
operator|)
operator|=
name|EOS
expr_stmt|;
comment|/* Temporarily make class a string. */
name|f
operator|->
name|fpic
operator|=
name|mapsrch
argument_list|(
name|pubcltab
argument_list|,
name|q
argument_list|)
expr_stmt|;
comment|/* Check for valid uc class name.*/
operator|*
name|p
operator|++
operator|=
literal|' '
expr_stmt|;
comment|/* Restore the SPACE delimiter. */
if|if
condition|(
name|f
operator|->
name|fpic
operator|==
literal|0
condition|)
return|return
literal|4
return|;
comment|/* Error if not valid uc class name.*/
comment|/* The public text class in a notation identifier must be NOTATION. */
if|if
condition|(
name|f
operator|->
name|fpistore
operator|==
name|ESK
operator|-
name|ESFM
operator|+
literal|1
operator|&&
name|f
operator|->
name|fpic
operator|!=
name|FPINOT
condition|)
return|return
literal|10
return|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'-'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'/'
operator|&&
name|p
index|[
literal|2
index|]
operator|==
literal|'/'
condition|)
block|{
comment|/* If text is unavailable 						     public text.*/
name|f
operator|->
name|fpitt
operator|=
operator|*
name|p
expr_stmt|;
comment|/* Save text type. */
name|p
operator|+=
literal|3
expr_stmt|;
block|}
else|else
name|f
operator|->
name|fpitt
operator|=
literal|'+'
expr_stmt|;
comment|/* Indicate available public text. */
if|if
condition|(
operator|(
name|q
operator|=
name|pubfield
argument_list|(
name|p
argument_list|,
name|l
argument_list|,
literal|'/'
argument_list|,
operator|&
name|len
argument_list|)
operator|)
operator|==
literal|0
condition|)
comment|/* Find end of text description. */
return|return
literal|6
return|;
name|f
operator|->
name|fpitl
operator|=
name|len
expr_stmt|;
comment|/* Save text description length. */
name|f
operator|->
name|fpit
operator|=
name|p
operator|-
name|f
operator|->
name|fpipubis
expr_stmt|;
comment|/* Save ptr to description.*/
name|p
operator|=
name|pubfield
argument_list|(
name|q
argument_list|,
name|l
argument_list|,
literal|'/'
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
comment|/* Bound language field. */
if|if
condition|(
name|f
operator|->
name|fpic
operator|!=
name|FPICHARS
condition|)
block|{
name|int
name|i
decl_stmt|;
comment|/* Language must be all upper-case letters. */
comment|/* The standard only says that it *should* be two letters, so 	     don't enforce that. */
comment|/* Language must be a name, which means it can't be empty. */
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return
literal|7
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
comment|/* Don't assume ASCII. */
if|if
condition|(
operator|!
name|strchr
argument_list|(
literal|"ABCDEFGHIJKLMNOPQRSTUVWXYZ"
argument_list|,
name|q
index|[
name|i
index|]
argument_list|)
condition|)
return|return
literal|7
return|;
block|}
block|}
name|f
operator|->
name|fpill
operator|=
name|len
expr_stmt|;
name|f
operator|->
name|fpil
operator|=
name|q
operator|-
name|f
operator|->
name|fpipubis
expr_stmt|;
if|if
condition|(
name|p
operator|!=
literal|0
condition|)
block|{
comment|/* If there is a version field: */
if|if
condition|(
name|f
operator|->
name|fpic
operator|<
name|FPICMINV
condition|)
comment|/* Error if class prohibits versions. */
return|return
literal|8
return|;
if|if
condition|(
operator|(
name|pubfield
argument_list|(
name|p
argument_list|,
name|l
argument_list|,
literal|'/'
argument_list|,
operator|&
name|len
argument_list|)
operator|)
operator|!=
literal|0
condition|)
comment|/* Bound version field. */
return|return
literal|9
return|;
comment|/* Error if yet another field. */
name|f
operator|->
name|fpivl
operator|=
name|len
expr_stmt|;
comment|/* Save version length. */
name|f
operator|->
name|fpiv
operator|=
name|p
operator|-
name|f
operator|->
name|fpipubis
expr_stmt|;
comment|/* Save ptr (in pubis) to version. */
block|}
elseif|else
if|if
condition|(
name|f
operator|->
name|fpic
operator|>=
name|FPICMINV
condition|)
name|f
operator|->
name|fpiversw
operator|=
literal|1
expr_stmt|;
comment|/* No version: get the best. */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* PUBFIELD: Returns ptr to next field, or NULL if ID has ended. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USE_PROTOTYPES
end_ifdef

begin_function
name|UNCH
modifier|*
name|pubfield
parameter_list|(
name|UNCH
modifier|*
name|p
parameter_list|,
name|UNCH
modifier|*
name|l
parameter_list|,
name|UNCH
name|d
parameter_list|,
name|UNS
modifier|*
name|lenp
parameter_list|)
else|#
directive|else
function|UNCH *pubfield
parameter_list|(
name|p
parameter_list|,
name|l
parameter_list|,
name|d
parameter_list|,
name|lenp
parameter_list|)
name|UNCH
modifier|*
name|p
decl_stmt|;
comment|/* Public identifier field (no length or EOS). */
name|UNCH
modifier|*
name|l
decl_stmt|;
comment|/* Pointer to EOS of public identifier. */
name|UNCH
name|d
decl_stmt|;
comment|/* Field delimiter: ' ' or '/'. */
name|UNS
modifier|*
name|lenp
decl_stmt|;
comment|/* Gets field length */
endif|#
directive|endif
block|{
name|UNCH
modifier|*
name|psv
init|=
name|p
operator|+
literal|1
decl_stmt|;
comment|/* Save starting value of p. */
while|while
condition|(
name|p
operator|<
name|l
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|++
operator|==
name|d
condition|)
block|{
comment|/* Test for delimiter character. */
operator|*
name|lenp
operator|=
name|p
operator|-
name|psv
expr_stmt|;
comment|/* Save field length (no len or EOS). */
if|if
condition|(
name|d
operator|==
literal|'/'
operator|&&
operator|*
name|p
operator|++
operator|!=
name|d
condition|)
comment|/* Solidus requires a second one. */
continue|continue;
return|return
operator|(
name|p
operator|)
return|;
comment|/* Return ptr to next field. */
block|}
block|}
operator|*
name|lenp
operator|=
name|p
operator|-
operator|--
name|psv
expr_stmt|;
comment|/* Save field length (no len or EOS). */
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* MDMS: Process marked section start.          If already in special parse, bump the level counters and return          without parsing the declaration. */
end_comment

begin_function
name|struct
name|parse
modifier|*
name|mdms
parameter_list|(
name|tbuf
parameter_list|,
name|pcb
parameter_list|)
name|UNCH
modifier|*
name|tbuf
decl_stmt|;
comment|/* Work area for tokenization [NAMELEN+2]. */
name|struct
name|parse
modifier|*
name|pcb
decl_stmt|;
comment|/* Parse control block for this parse. */
block|{
name|int
name|key
decl_stmt|;
comment|/* Index of keyword in mslist. */
name|int
name|ptype
decl_stmt|;
comment|/* Parameter token type. */
name|int
name|pcbcode
init|=
literal|0
decl_stmt|;
comment|/* Parse code: 0=same; 2-4 per defines. */
if|if
condition|(
operator|++
name|mslevel
operator|>
name|TAGLVL
condition|)
block|{
operator|--
name|mslevel
expr_stmt|;
name|sgmlerr
argument_list|(
literal|27
argument_list|,
operator|(
expr|struct
name|parse
operator|*
operator|)
literal|0
argument_list|,
name|ntoa
argument_list|(
name|TAGLVL
argument_list|)
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* If already in IGNORE mode, return without parsing parameters. */
if|if
condition|(
name|msplevel
condition|)
block|{
operator|++
name|msplevel
expr_stmt|;
return|return
operator|(
name|pcb
operator|)
return|;
block|}
name|parmno
operator|=
literal|0
expr_stmt|;
comment|/* No parameters as yet. */
name|mdessv
operator|=
name|es
expr_stmt|;
comment|/* Save es for checking entity nesting. */
name|pcbmd
operator|.
name|newstate
operator|=
name|pcbmdtk
expr_stmt|;
comment|/* First separator is optional. */
comment|/* PARAMETERS: TEMP, RCDATA, CDATA, IGNORE, INCLUDE, or MDS. */
while|while
condition|(
operator|(
name|ptype
operator|=
name|parsemd
argument_list|(
name|tbuf
argument_list|,
name|NAMECASE
argument_list|,
operator|&
name|pcblitp
argument_list|,
name|NAMELEN
argument_list|)
operator|)
operator|==
name|NAS
condition|)
block|{
if|if
condition|(
operator|(
name|key
operator|=
name|mapsrch
argument_list|(
name|mstab
argument_list|,
name|tbuf
operator|+
literal|1
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|sgmlerr
argument_list|(
literal|64
argument_list|,
operator|(
expr|struct
name|parse
operator|*
operator|)
literal|0
argument_list|,
name|ntoa
argument_list|(
name|parmno
argument_list|)
argument_list|,
name|tbuf
operator|+
literal|1
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|key
operator|==
name|MSTEMP
condition|)
continue|continue;
comment|/* TEMP: for documentation. */
name|msplevel
operator|=
literal|1
expr_stmt|;
comment|/* Special parse required. */
if|if
condition|(
name|key
operator|>
name|pcbcode
condition|)
name|pcbcode
operator|=
name|key
expr_stmt|;
comment|/* Update if higher priority. */
block|}
if|if
condition|(
name|ptype
operator|!=
name|MDS
condition|)
block|{
name|NEWCC
expr_stmt|;
comment|/* Syntax error did REPEATCC. */
name|sgmlerr
argument_list|(
literal|97
argument_list|,
operator|(
expr|struct
name|parse
operator|*
operator|)
literal|0
argument_list|,
name|lex
operator|.
name|m
operator|.
name|dso
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|REPEATCC
expr_stmt|;
comment|/* 1st char of marked section. */
block|}
if|if
condition|(
name|es
operator|!=
name|mdessv
condition|)
name|synerr
argument_list|(
literal|37
argument_list|,
name|pcb
argument_list|)
expr_stmt|;
name|TRACEMS
argument_list|(
literal|1
argument_list|,
name|pcbcode
argument_list|,
name|mslevel
argument_list|,
name|msplevel
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcbcode
operator|==
name|MSIGNORE
condition|)
name|pcb
operator|=
operator|&
name|pcbmsi
expr_stmt|;
elseif|else
if|if
condition|(
name|pcbcode
condition|)
block|{
name|pcb
operator|=
name|pcbcode
operator|==
name|MSCDATA
condition|?
operator|&
name|pcbmsc
else|:
operator|(
name|rcessv
operator|=
name|es
operator|,
operator|&
name|pcbmsrc
operator|)
expr_stmt|;
block|}
return|return
operator|(
name|pcb
operator|)
return|;
comment|/* Tell caller whether to change the parse. */
block|}
end_function

begin_comment
comment|/* MDMSE: Process marked section end.           Issue an error if no marked section had started. */
end_comment

begin_function
name|int
name|mdmse
parameter_list|()
block|{
name|int
name|retcode
init|=
literal|0
decl_stmt|;
comment|/* Return code: 0=same parse; 1=cancel special. */
if|if
condition|(
name|mslevel
condition|)
operator|--
name|mslevel
expr_stmt|;
else|else
name|sgmlerr
argument_list|(
literal|26
argument_list|,
operator|(
expr|struct
name|parse
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|msplevel
condition|)
if|if
condition|(
operator|--
name|msplevel
operator|==
literal|0
condition|)
name|retcode
operator|=
literal|1
expr_stmt|;
name|TRACEMS
argument_list|(
literal|0
argument_list|,
name|retcode
argument_list|,
name|mslevel
argument_list|,
name|msplevel
argument_list|)
expr_stmt|;
return|return
name|retcode
return|;
block|}
end_function

begin_comment
comment|/* MDNOT: Process NOTATION declaration. */
end_comment

begin_function
name|VOID
name|mdnot
parameter_list|(
name|tbuf
parameter_list|)
name|UNCH
modifier|*
name|tbuf
decl_stmt|;
comment|/* Work area for tokenization[LITLEN+2]. */
block|{
name|struct
name|fpi
name|fpicb
decl_stmt|;
comment|/* Formal public identifier structure. */
name|PDCB
name|dcb
decl_stmt|;
comment|/* Ptr to notation entity in dcntab. */
name|UNCH
name|estore
init|=
name|ESK
decl_stmt|;
comment|/* Entity storage class. */
name|mdname
operator|=
name|key
index|[
name|KNOTATION
index|]
expr_stmt|;
comment|/* Identify declaration for messages. */
name|subdcl
operator|=
name|NULL
expr_stmt|;
comment|/* No subject as yet. */
name|parmno
operator|=
literal|0
expr_stmt|;
comment|/* No parameters as yet. */
name|mdessv
operator|=
name|es
expr_stmt|;
comment|/* Save es for checking entity nesting. */
comment|/* PARAMETER 1: Notation name.      */
name|pcbmd
operator|.
name|newstate
operator|=
literal|0
expr_stmt|;
name|parsemd
argument_list|(
name|lbuf
argument_list|,
name|NAMECASE
argument_list|,
operator|&
name|pcblitp
argument_list|,
name|NAMELEN
argument_list|)
expr_stmt|;
name|TRACEMD
argument_list|(
literal|"1: name"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcbmd
operator|.
name|action
operator|!=
name|NAS
condition|)
block|{
name|mderr
argument_list|(
literal|120
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|subdcl
operator|=
name|lbuf
operator|+
literal|1
expr_stmt|;
comment|/* Save notation name for error msgs. */
comment|/* PARAMETER 2: External identifier keyword.      */
name|parsemd
argument_list|(
name|tbuf
argument_list|,
name|NAMECASE
argument_list|,
operator|&
name|pcblitp
argument_list|,
name|NAMELEN
argument_list|)
expr_stmt|;
name|TRACEMD
argument_list|(
literal|"2: extid"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcbmd
operator|.
name|action
operator|!=
name|NAS
condition|)
block|{
name|mderr
argument_list|(
literal|29
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|mdextid
argument_list|(
name|tbuf
argument_list|,
operator|&
name|fpicb
argument_list|,
name|lbuf
operator|+
literal|1
argument_list|,
operator|&
name|estore
argument_list|,
operator|(
name|PNE
operator|)
literal|0
argument_list|)
operator|==
literal|0
condition|)
return|return;
comment|/* PARAMETER 3: End of declaration.                      Token was parsed by MDEXTID.      */
name|TRACEMD
argument_list|(
name|emd
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcbmd
operator|.
name|action
operator|!=
name|EMD
condition|)
name|mderr
argument_list|(
literal|126
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|es
operator|!=
name|mdessv
condition|)
name|synerr
argument_list|(
literal|37
argument_list|,
operator|&
name|pcbmd
argument_list|)
expr_stmt|;
comment|/* EXECUTE: Store notation name.      */
if|if
condition|(
operator|(
name|dcb
operator|=
name|dcnfind
argument_list|(
name|lbuf
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|dcb
operator|->
name|defined
condition|)
block|{
name|mderr
argument_list|(
literal|56
argument_list|,
name|lbuf
operator|+
literal|1
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* else */
name|dcb
operator|=
name|dcndef
argument_list|(
name|lbuf
argument_list|)
expr_stmt|;
name|dcb
operator|->
name|defined
operator|=
literal|1
expr_stmt|;
name|dcb
operator|->
name|sysid
operator|=
name|fpicb
operator|.
name|fpisysis
condition|?
name|savestr
argument_list|(
name|fpicb
operator|.
name|fpisysis
argument_list|)
else|:
literal|0
expr_stmt|;
name|dcb
operator|->
name|pubid
operator|=
name|fpicb
operator|.
name|fpipubis
condition|?
name|savestr
argument_list|(
name|fpicb
operator|.
name|fpipubis
argument_list|)
else|:
literal|0
expr_stmt|;
operator|++
name|ds
operator|.
name|dcncnt
expr_stmt|;
name|ds
operator|.
name|dcntext
operator|+=
name|entlen
expr_stmt|;
name|TRACEDCN
argument_list|(
name|dcb
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* DCNDEF: Define a notation and return its DCNCB.            If caller does not care if it already exists,            he should specify NULL for the notation text            so we don't clobber the existing text (if any). */
end_comment

begin_function
name|struct
name|dcncb
modifier|*
name|dcndef
parameter_list|(
name|nname
parameter_list|)
name|UNCH
modifier|*
name|nname
decl_stmt|;
comment|/* Notation name (with length and EOS). */
block|{
return|return
operator|(
operator|(
name|PDCB
operator|)
name|hin
argument_list|(
operator|(
name|THASH
operator|)
name|dcntab
argument_list|,
name|nname
argument_list|,
literal|0
argument_list|,
name|DCBSZ
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* DCNFIND: If a notation was declared, return its DCNCB.             Return NULL if it is not defined. */
end_comment

begin_function
name|struct
name|dcncb
modifier|*
name|dcnfind
parameter_list|(
name|nname
parameter_list|)
name|UNCH
modifier|*
name|nname
decl_stmt|;
comment|/* Notation name (with length and EOS). */
block|{
return|return
operator|(
operator|(
name|PDCB
operator|)
name|hfind
argument_list|(
operator|(
name|THASH
operator|)
name|dcntab
argument_list|,
name|nname
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|SRM
parameter_list|(
name|i
parameter_list|)
value|(srhptr->srhsrm[i])
end_define

begin_comment
comment|/* Current entry in SHORTREF map. */
end_comment

begin_comment
comment|/* MDSRMDEF: Process short reference mapping declaration. */
end_comment

begin_function
name|VOID
name|mdsrmdef
parameter_list|(
name|tbuf
parameter_list|)
name|UNCH
modifier|*
name|tbuf
decl_stmt|;
comment|/* Work area for tokenization[LITLEN+2]. */
block|{
name|struct
name|entity
modifier|*
name|entcb
decl_stmt|;
comment|/* Ptr to defined entity. */
name|PSRH
name|srhptr
decl_stmt|;
comment|/* Ptr to short reference map hdr (in srhtab).*/
name|int
name|srn
decl_stmt|;
comment|/* Short reference delimiter number in srdeltab.*/
name|int
name|mapused
init|=
literal|0
decl_stmt|;
comment|/* Has map already been used? */
name|mdname
operator|=
name|key
index|[
name|KSHORTREF
index|]
expr_stmt|;
comment|/* Identify declaration for messages. */
name|subdcl
operator|=
name|NULL
expr_stmt|;
comment|/* No subject as yet. */
name|parmno
operator|=
literal|0
expr_stmt|;
comment|/* No parameters as yet. */
if|if
condition|(
operator|!
name|sd
operator|.
name|shortref
condition|)
block|{
name|mderr
argument_list|(
literal|198
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|mdessv
operator|=
name|es
expr_stmt|;
comment|/* Save es for checking entity nesting. */
comment|/* PARAMETER 1: SHORTREF map name.      */
name|pcbmd
operator|.
name|newstate
operator|=
literal|0
expr_stmt|;
name|parsemd
argument_list|(
name|tbuf
argument_list|,
name|NAMECASE
argument_list|,
operator|&
name|pcblitp
argument_list|,
name|NAMELEN
argument_list|)
expr_stmt|;
name|TRACEMD
argument_list|(
literal|"1: map nm"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcbmd
operator|.
name|action
operator|!=
name|NAS
condition|)
block|{
name|mderr
argument_list|(
literal|120
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|srhptr
operator|=
name|srhfind
argument_list|(
name|tbuf
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|mapused
operator|=
literal|1
expr_stmt|;
comment|/* Error if map was declared (not just used). */
if|if
condition|(
name|SRM
argument_list|(
literal|0
argument_list|)
condition|)
block|{
name|mderr
argument_list|(
literal|56
argument_list|,
name|tbuf
operator|+
literal|1
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
name|srhptr
operator|=
name|srhdef
argument_list|(
name|tbuf
argument_list|)
expr_stmt|;
comment|/* Create map with SRs mapped to NULL.*/
name|SRM
argument_list|(
literal|0
argument_list|)
operator|=
operator|(
name|PECB
operator|)
name|srhptr
expr_stmt|;
comment|/* Indicate map was actually declared.*/
name|subdcl
operator|=
name|srhptr
operator|->
name|ename
operator|+
literal|1
expr_stmt|;
comment|/* Save map name for error msgs. */
while|while
condition|(
name|parsemd
argument_list|(
name|tbuf
argument_list|,
name|NAMECASE
argument_list|,
operator|&
name|pcblitp
argument_list|,
name|SRMAXLEN
argument_list|)
operator|==
name|LIT
operator|||
name|pcbmd
operator|.
name|action
operator|==
name|LITE
condition|)
block|{
comment|/* PARAMETER 2: Delimiter string.           */
name|TRACEMD
argument_list|(
literal|"2: SR string"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|srn
operator|=
name|mapsrch
argument_list|(
name|lex
operator|.
name|s
operator|.
name|dtb
argument_list|,
name|tbuf
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|mderr
argument_list|(
literal|124
argument_list|,
name|tbuf
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
comment|/* PARAMETER 3: Entity name.           */
name|parsemd
argument_list|(
name|tbuf
argument_list|,
name|ENTCASE
argument_list|,
operator|&
name|pcblitp
argument_list|,
name|NAMELEN
argument_list|)
expr_stmt|;
name|TRACEMD
argument_list|(
literal|"3: entity"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcbmd
operator|.
name|action
operator|!=
name|NAS
condition|)
block|{
name|mderr
argument_list|(
literal|120
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
if|if
condition|(
operator|(
name|entcb
operator|=
name|entfind
argument_list|(
name|tbuf
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|union
name|etext
name|etx
decl_stmt|;
name|etx
operator|.
name|x
operator|=
literal|0
expr_stmt|;
name|entcb
operator|=
name|entdef
argument_list|(
name|tbuf
argument_list|,
literal|'\0'
argument_list|,
operator|&
name|etx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SRM
argument_list|(
name|srn
argument_list|)
condition|)
block|{
name|mderr
argument_list|(
literal|56
argument_list|,
operator|(
name|srn
operator|<
name|lex
operator|.
name|s
operator|.
name|prtmin
condition|?
operator|(
name|UNCH
operator|*
operator|)
name|lex
operator|.
name|s
operator|.
name|pdtb
index|[
name|srn
index|]
else|:
name|lex
operator|.
name|s
operator|.
name|dtb
index|[
name|srn
index|]
operator|.
name|mapnm
operator|)
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|SRM
argument_list|(
name|srn
argument_list|)
operator|=
name|entcb
expr_stmt|;
if|if
condition|(
name|srn
operator|>=
name|lex
operator|.
name|s
operator|.
name|fce
operator|&&
name|srn
operator|!=
name|lex
operator|.
name|s
operator|.
name|hyp
operator|&&
name|srn
operator|!=
name|lex
operator|.
name|s
operator|.
name|hyp2
operator|&&
name|srn
operator|!=
name|lex
operator|.
name|s
operator|.
name|lbr
operator|&&
name|srn
operator|!=
name|lex
operator|.
name|s
operator|.
name|rbr
condition|)
name|lexcnm
index|[
operator|*
name|lex
operator|.
name|s
operator|.
name|dtb
index|[
name|srn
index|]
operator|.
name|mapnm
index|]
operator|=
name|lex
operator|.
name|l
operator|.
name|fce
expr_stmt|;
elseif|else
if|if
condition|(
name|srn
operator|==
name|lex
operator|.
name|s
operator|.
name|spc
condition|)
name|lexcnm
index|[
literal|' '
index|]
operator|=
name|lex
operator|.
name|l
operator|.
name|spcr
expr_stmt|;
block|}
comment|/* PARAMETER 4: End of declaration.      */
name|TRACEMD
argument_list|(
name|emd
argument_list|)
expr_stmt|;
if|if
condition|(
name|parmno
operator|==
literal|2
condition|)
block|{
name|mderr
argument_list|(
call|(
name|UNS
call|)
argument_list|(
name|pcbmd
operator|.
name|action
operator|==
name|EMD
condition|?
literal|28
else|:
literal|123
argument_list|)
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
if|if
condition|(
name|pcbmd
operator|.
name|action
operator|!=
name|EMD
condition|)
name|mderr
argument_list|(
literal|126
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|es
operator|!=
name|mdessv
condition|)
name|synerr
argument_list|(
literal|37
argument_list|,
operator|&
name|pcbmd
argument_list|)
expr_stmt|;
operator|++
name|ds
operator|.
name|srcnt
expr_stmt|;
name|TRACESRM
argument_list|(
literal|"SHORTREF"
argument_list|,
name|srhptr
operator|->
name|srhsrm
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return;
name|cleanup
label|:
comment|/* Don't free the map if the map was in use (because of a USEMAP 	declaration) before this declaration. */
if|if
condition|(
name|mapused
condition|)
name|MEMZERO
argument_list|(
operator|(
name|UNIV
operator|)
name|srhptr
operator|->
name|srhsrm
argument_list|,
sizeof|sizeof
argument_list|(
name|PECB
argument_list|)
operator|*
operator|(
name|lex
operator|.
name|s
operator|.
name|dtb
index|[
literal|0
index|]
operator|.
name|mapdata
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
else|else
block|{
name|frem
argument_list|(
operator|(
name|UNIV
operator|)
name|srhptr
operator|->
name|srhsrm
argument_list|)
expr_stmt|;
name|hout
argument_list|(
operator|(
name|THASH
operator|)
name|srhtab
argument_list|,
name|srhptr
operator|->
name|ename
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|frem
argument_list|(
operator|(
name|UNIV
operator|)
name|srhptr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* MDSRMUSE: Activate a short reference map. */
end_comment

begin_function
name|VOID
name|mdsrmuse
parameter_list|(
name|tbuf
parameter_list|)
name|UNCH
modifier|*
name|tbuf
decl_stmt|;
comment|/* Work area for tokenization[LITLEN+2]. */
block|{
name|PSRH
name|srhptr
decl_stmt|;
comment|/* Ptr to short reference map hdr (in srhtab).*/
name|TECB
name|srmptr
decl_stmt|;
comment|/* Ptr to short reference map (in header). */
name|int
name|i
decl_stmt|;
comment|/* Loop counter; temporary variable. */
name|mdname
operator|=
name|key
index|[
name|KUSEMAP
index|]
expr_stmt|;
comment|/* Identify declaration for messages. */
name|subdcl
operator|=
name|NULL
expr_stmt|;
comment|/* No subject as yet. */
name|parmno
operator|=
literal|0
expr_stmt|;
comment|/* No parameters as yet. */
name|mdessv
operator|=
name|es
expr_stmt|;
comment|/* Save es for checking entity nesting. */
comment|/* PARAMETER 1: SHORTREF map name or "#EMPTY".      */
name|pcbmd
operator|.
name|newstate
operator|=
literal|0
expr_stmt|;
name|parsemd
argument_list|(
name|lbuf
argument_list|,
name|NAMECASE
argument_list|,
operator|&
name|pcblitp
argument_list|,
name|NAMELEN
argument_list|)
expr_stmt|;
name|TRACEMD
argument_list|(
literal|"1: map nm"
argument_list|)
expr_stmt|;
name|subdcl
operator|=
name|lbuf
operator|+
literal|1
expr_stmt|;
comment|/* Subject name for error messages. */
switch|switch
condition|(
name|pcbmd
operator|.
name|action
condition|)
block|{
case|case
name|RNS
case|:
comment|/* Empty SHORTREF map requested. */
if|if
condition|(
name|ustrcmp
argument_list|(
name|lbuf
operator|+
literal|1
argument_list|,
name|key
index|[
name|KEMPTY
index|]
argument_list|)
condition|)
block|{
name|mderr
argument_list|(
literal|118
argument_list|,
name|lbuf
operator|+
literal|1
argument_list|,
name|key
index|[
name|KEMPTY
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
name|srmptr
operator|=
name|SRMNULL
expr_stmt|;
break|break;
case|case
name|NAS
case|:
comment|/* Map name specified; save if undefined. */
if|if
condition|(
operator|(
name|srhptr
operator|=
name|srhfind
argument_list|(
name|lbuf
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|indtdsw
condition|)
block|{
name|mderr
argument_list|(
literal|125
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|srmptr
operator|=
name|NULL
expr_stmt|;
block|}
else|else
name|srmptr
operator|=
name|srhptr
operator|->
name|srhsrm
expr_stmt|;
break|break;
default|default:
name|mderr
argument_list|(
literal|120
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* PARAMETER 2: Element name or a group of them. (In DTD only.)      */
name|parsemd
argument_list|(
name|tbuf
argument_list|,
name|NAMECASE
argument_list|,
operator|&
name|pcblitp
argument_list|,
name|NAMELEN
argument_list|)
expr_stmt|;
name|TRACEMD
argument_list|(
literal|"2: GI or grp"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pcbmd
operator|.
name|action
condition|)
block|{
case|case
name|NAS
case|:
if|if
condition|(
operator|!
name|indtdsw
condition|)
block|{
name|mderr
argument_list|(
literal|142
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|nmgrp
index|[
literal|0
index|]
operator|=
name|etddef
argument_list|(
name|tbuf
argument_list|)
expr_stmt|;
name|nmgrp
index|[
literal|1
index|]
operator|=
operator|(
name|PETD
operator|)
name|NULL
expr_stmt|;
break|break;
case|case
name|GRPS
case|:
if|if
condition|(
operator|!
name|indtdsw
condition|)
block|{
name|mderr
argument_list|(
literal|142
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|parsegrp
argument_list|(
name|nmgrp
argument_list|,
operator|&
name|pcbgrnm
argument_list|,
name|tbuf
argument_list|)
expr_stmt|;
break|break;
case|case
name|EMD
case|:
if|if
condition|(
name|indtdsw
condition|)
block|{
name|mderr
argument_list|(
literal|28
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|docelsw
condition|)
block|{
name|mderr
argument_list|(
literal|233
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|tags
index|[
name|ts
index|]
operator|.
name|tsrm
operator|=
name|srmptr
expr_stmt|;
name|TRACESRM
argument_list|(
literal|"USEMAP"
argument_list|,
name|tags
index|[
name|ts
index|]
operator|.
name|tsrm
argument_list|,
name|tags
index|[
name|ts
index|]
operator|.
name|tetd
operator|->
name|etdgi
operator|+
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|realemd
goto|;
default|default:
name|mderr
argument_list|(
name|indtdsw
condition|?
literal|121
else|:
literal|126
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* PARAMETER 3: End of declaration.      */
name|parsemd
argument_list|(
name|tbuf
argument_list|,
name|NAMECASE
argument_list|,
operator|&
name|pcblitp
argument_list|,
name|NAMELEN
argument_list|)
expr_stmt|;
name|TRACEMD
argument_list|(
name|emd
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcbmd
operator|.
name|action
operator|!=
name|EMD
condition|)
name|mderr
argument_list|(
literal|126
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* If map has not yet been defined, do it and get map pointer. */
if|if
condition|(
operator|!
name|srmptr
condition|)
name|srmptr
operator|=
operator|(
name|srhdef
argument_list|(
name|lbuf
argument_list|)
operator|)
operator|->
name|srhsrm
expr_stmt|;
comment|/* Store the map pointer for each element name specified.      */
name|TRACEGRP
argument_list|(
name|nmgrp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
operator|-
literal|1
init|;
name|nmgrp
index|[
operator|++
name|i
index|]
condition|;
control|)
block|{
if|if
condition|(
operator|!
name|nmgrp
index|[
name|i
index|]
operator|->
name|etdsrm
condition|)
name|nmgrp
index|[
name|i
index|]
operator|->
name|etdsrm
operator|=
name|srmptr
expr_stmt|;
elseif|else
if|if
condition|(
name|sw
operator|.
name|swdupent
condition|)
name|mderr
argument_list|(
literal|68
argument_list|,
name|nmgrp
index|[
name|i
index|]
operator|->
name|etdgi
operator|+
literal|1
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
name|realemd
label|:
if|if
condition|(
name|es
operator|!=
name|mdessv
condition|)
name|synerr
argument_list|(
literal|37
argument_list|,
operator|&
name|pcbmd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* SRHDEF: Define a SHORTREF map and return ptr to its header.            All entries in map are mapped to NULL.            Caller must determine whether it already exists. */
end_comment

begin_function
name|PSRH
name|srhdef
parameter_list|(
name|sname
parameter_list|)
name|UNCH
modifier|*
name|sname
decl_stmt|;
comment|/* SHORTREF map name (with length and EOS). */
block|{
name|PSRH
name|srh
decl_stmt|;
comment|/* Ptr to SHORTREF map hdr in srhtab. */
operator|(
name|srh
operator|=
operator|(
name|PSRH
operator|)
name|hin
argument_list|(
operator|(
name|THASH
operator|)
name|srhtab
argument_list|,
name|sname
argument_list|,
literal|0
argument_list|,
name|SRHSZ
argument_list|)
operator|)
operator|->
name|srhsrm
operator|=
operator|(
name|TECB
operator|)
name|rmalloc
argument_list|(
call|(
name|UNS
call|)
argument_list|(
name|lex
operator|.
name|s
operator|.
name|dtb
index|[
literal|0
index|]
operator|.
name|mapdata
operator|+
literal|1
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|PECB
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|srh
operator|)
return|;
block|}
end_function

begin_comment
comment|/* SRHFIND: If a SHORTREF map was declared, return the ptr to its header.             Return NULL if it is not defined. */
end_comment

begin_function
name|PSRH
name|srhfind
parameter_list|(
name|sname
parameter_list|)
name|UNCH
modifier|*
name|sname
decl_stmt|;
comment|/* SHORTREF map name (with length and EOS). */
block|{
return|return
operator|(
operator|(
name|PSRH
operator|)
name|hfind
argument_list|(
operator|(
name|THASH
operator|)
name|srhtab
argument_list|,
name|sname
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|SRM
end_undef

begin_comment
comment|/* Local Variables: c-indent-level: 5 c-continued-statement-offset: 5 c-brace-offset: -5 c-argdecl-indent: 0 c-label-offset: -5 comment-column: 30 End: */
end_comment

end_unit

