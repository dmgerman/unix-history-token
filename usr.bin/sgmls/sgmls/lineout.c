begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* lineout.c -    Implements line-oriented output format.       Written by James Clark (jjc@jclark.com). */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"std.h"
end_include

begin_include
include|#
directive|include
file|"entity.h"
end_include

begin_comment
comment|/* Templates for entity control blocks. */
end_comment

begin_include
include|#
directive|include
file|"adl.h"
end_include

begin_comment
comment|/* Definitions for attribute list processing. */
end_comment

begin_include
include|#
directive|include
file|"sgmlmain.h"
end_include

begin_comment
comment|/* Main interface to SGML services. */
end_comment

begin_include
include|#
directive|include
file|"lineout.h"
end_include

begin_include
include|#
directive|include
file|"appl.h"
end_include

begin_decl_stmt
specifier|static
name|VOID
name|flush_data
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|VOID
name|define_external_entity
name|P
argument_list|(
operator|(
name|PNE
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|VOID
name|define_entity
name|P
argument_list|(
operator|(
name|UNCH
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|VOID
name|handle_attributes
name|P
argument_list|(
operator|(
name|UNCH
operator|*
operator|,
expr|struct
name|ad
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|VOID
name|handle_token_list
name|P
argument_list|(
operator|(
name|UNCH
operator|*
operator|,
expr|struct
name|ad
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|VOID
name|handle_single_token
name|P
argument_list|(
operator|(
name|UNCH
operator|*
operator|,
expr|struct
name|ad
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|VOID
name|output_notation
name|P
argument_list|(
operator|(
name|UNCH
operator|*
operator|,
name|UNCH
operator|*
operator|,
name|UNCH
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|VOID
name|output_internal_entity
name|P
argument_list|(
operator|(
name|UNCH
operator|*
operator|,
name|int
operator|,
name|UNCH
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|VOID
name|output_external_entity
name|P
argument_list|(
operator|(
name|UNCH
operator|*
operator|,
name|int
operator|,
name|UNIV
operator|,
name|UNCH
operator|*
operator|,
name|UNCH
operator|*
operator|,
name|UNCH
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|VOID
name|output_subdoc
name|P
argument_list|(
operator|(
name|UNCH
operator|*
operator|,
name|UNIV
operator|,
name|UNCH
operator|*
operator|,
name|UNCH
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|SUPPORT_SUBDOC
end_ifdef

begin_decl_stmt
specifier|static
name|VOID
name|process_subdoc
name|P
argument_list|(
operator|(
name|UNCH
operator|*
operator|,
name|UNIV
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SUPPORT_SUBDOC */
end_comment

begin_decl_stmt
specifier|static
name|VOID
name|output_record_end
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|VOID
name|output_pcdata
name|P
argument_list|(
operator|(
name|UNS
operator|,
name|UNCH
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|VOID
name|output_cdata
name|P
argument_list|(
operator|(
name|UNS
operator|,
name|UNCH
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|VOID
name|output_sdata
name|P
argument_list|(
operator|(
name|UNS
operator|,
name|UNCH
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|VOID
name|output_entity_reference
name|P
argument_list|(
operator|(
name|UNCH
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|VOID
name|output_start_tag
name|P
argument_list|(
operator|(
name|UNCH
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|VOID
name|output_end_tag
name|P
argument_list|(
operator|(
name|UNCH
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|VOID
name|output_processing_instruction
name|P
argument_list|(
operator|(
name|UNS
operator|,
name|UNCH
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|VOID
name|output_implied_attribute
name|P
argument_list|(
operator|(
name|UNCH
operator|*
operator|,
name|UNCH
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|attribute_type_string
name|P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|VOID
name|output_begin_attribute
name|P
argument_list|(
operator|(
name|UNCH
operator|*
operator|,
name|UNCH
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|VOID
name|output_attribute_token
name|P
argument_list|(
operator|(
name|UNS
operator|,
name|UNCH
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|VOID
name|output_end_attribute
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|VOID
name|print_data
name|P
argument_list|(
operator|(
name|UNS
operator|,
name|UNCH
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|VOID
name|print_string
name|P
argument_list|(
operator|(
name|UNS
operator|,
name|UNCH
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|VOID
name|print_id
name|P
argument_list|(
operator|(
name|UNIV
operator|,
name|UNCH
operator|*
operator|,
name|UNCH
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|VOID
name|print_filename
name|P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|VOID
name|output_location
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|VOID
name|output_appinfo
name|P
argument_list|(
operator|(
name|UNS
operator|,
name|UNCH
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|have_data
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|current_filename
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|current_lineno
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|VOID
name|process_document
parameter_list|(
name|subdocsw
parameter_list|)
name|int
name|subdocsw
decl_stmt|;
block|{
name|enum
name|sgmlevent
name|rc
decl_stmt|;
name|struct
name|rcbtag
name|rcbtag
decl_stmt|;
name|struct
name|rcbdata
name|rcbdaf
decl_stmt|;
while|while
condition|(
operator|(
name|rc
operator|=
name|sgmlnext
argument_list|(
operator|&
name|rcbdaf
argument_list|,
operator|&
name|rcbtag
argument_list|)
operator|)
operator|!=
name|SGMLEOD
condition|)
block|{
ifdef|#
directive|ifdef
name|SUPPORT_SUBDOC
if|if
condition|(
name|rc
operator|==
name|SGMLDAF
operator|&&
operator|!
name|CONTERSW
argument_list|(
name|rcbdaf
argument_list|)
operator|&&
name|NDESW
argument_list|(
name|rcbdaf
argument_list|)
operator|&&
name|NEXTYPE
argument_list|(
name|NEPTR
argument_list|(
name|rcbdaf
argument_list|)
argument_list|)
operator|==
name|ESNSUB
condition|)
block|{
if|if
condition|(
operator|!
name|suppsw
operator|&&
operator|!
name|sgmlment
argument_list|(
name|NEENAME
argument_list|(
name|NEPTR
argument_list|(
name|rcbdaf
argument_list|)
argument_list|)
argument_list|)
condition|)
name|define_external_entity
argument_list|(
name|NEPTR
argument_list|(
name|rcbdaf
argument_list|)
argument_list|)
expr_stmt|;
name|process_subdoc
argument_list|(
name|NEENAME
argument_list|(
name|NEPTR
argument_list|(
name|rcbdaf
argument_list|)
argument_list|)
operator|+
literal|1
argument_list|,
name|NEID
argument_list|(
name|NEPTR
argument_list|(
name|rcbdaf
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
comment|/* SUPPORT_SUBDOC */
if|if
condition|(
operator|!
name|suppsw
condition|)
switch|switch
condition|(
name|rc
condition|)
block|{
case|case
name|SGMLDAF
case|:
if|if
condition|(
name|CONTERSW
argument_list|(
name|rcbdaf
argument_list|)
condition|)
break|break;
if|if
condition|(
name|CDESW
argument_list|(
name|rcbdaf
argument_list|)
condition|)
name|output_cdata
argument_list|(
name|CDATALEN
argument_list|(
name|rcbdaf
argument_list|)
argument_list|,
name|CDATA
argument_list|(
name|rcbdaf
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|SDESW
argument_list|(
name|rcbdaf
argument_list|)
condition|)
name|output_sdata
argument_list|(
name|CDATALEN
argument_list|(
name|rcbdaf
argument_list|)
argument_list|,
name|CDATA
argument_list|(
name|rcbdaf
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|NDESW
argument_list|(
name|rcbdaf
argument_list|)
condition|)
block|{
name|assert
argument_list|(
name|NEXTYPE
argument_list|(
name|NEPTR
argument_list|(
name|rcbdaf
argument_list|)
argument_list|)
operator|!=
name|ESNSUB
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sgmlment
argument_list|(
name|NEENAME
argument_list|(
name|NEPTR
argument_list|(
name|rcbdaf
argument_list|)
argument_list|)
argument_list|)
condition|)
name|define_external_entity
argument_list|(
name|NEPTR
argument_list|(
name|rcbdaf
argument_list|)
argument_list|)
expr_stmt|;
name|output_entity_reference
argument_list|(
name|NEENAME
argument_list|(
name|NEPTR
argument_list|(
name|rcbdaf
argument_list|)
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|output_pcdata
argument_list|(
name|CDATALEN
argument_list|(
name|rcbdaf
argument_list|)
argument_list|,
name|CDATA
argument_list|(
name|rcbdaf
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SGMLSTG
case|:
if|if
condition|(
name|CONTERSW
argument_list|(
name|rcbtag
argument_list|)
condition|)
break|break;
if|if
condition|(
name|ALPTR
argument_list|(
name|rcbtag
argument_list|)
condition|)
name|handle_attributes
argument_list|(
operator|(
name|UNCH
operator|*
operator|)
name|NULL
argument_list|,
name|ALPTR
argument_list|(
name|rcbtag
argument_list|)
argument_list|)
expr_stmt|;
name|output_start_tag
argument_list|(
name|CURGI
argument_list|(
name|rcbtag
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SGMLETG
case|:
if|if
condition|(
name|CONTERSW
argument_list|(
name|rcbtag
argument_list|)
condition|)
break|break;
name|output_end_tag
argument_list|(
name|CURGI
argument_list|(
name|rcbtag
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SGMLPIS
case|:
if|if
condition|(
name|CONTERSW
argument_list|(
name|rcbdaf
argument_list|)
condition|)
break|break;
name|output_processing_instruction
argument_list|(
name|PDATALEN
argument_list|(
name|rcbdaf
argument_list|)
argument_list|,
name|PDATA
argument_list|(
name|rcbdaf
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SGMLREF
case|:
if|if
condition|(
name|CONTERSW
argument_list|(
name|rcbdaf
argument_list|)
condition|)
break|break;
name|output_record_end
argument_list|()
expr_stmt|;
break|break;
case|case
name|SGMLAPP
case|:
if|if
condition|(
name|CONTERSW
argument_list|(
name|rcbdaf
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|!
name|subdocsw
condition|)
name|output_appinfo
argument_list|(
name|ADATALEN
argument_list|(
name|rcbdaf
argument_list|)
argument_list|,
name|ADATA
argument_list|(
name|rcbdaf
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Output an indication that the document was conforming. */
end_comment

begin_function
name|VOID
name|output_conforming
parameter_list|()
block|{
if|if
condition|(
operator|!
name|suppsw
condition|)
name|printf
argument_list|(
literal|"%c\n"
argument_list|,
name|CONFORMING_CODE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|VOID
name|define_external_entity
parameter_list|(
name|p
parameter_list|)
name|PNE
name|p
decl_stmt|;
block|{
if|if
condition|(
name|NEXTYPE
argument_list|(
name|p
argument_list|)
operator|==
name|ESNSUB
condition|)
name|output_subdoc
argument_list|(
name|NEENAME
argument_list|(
name|p
argument_list|)
operator|+
literal|1
argument_list|,
name|NEID
argument_list|(
name|p
argument_list|)
argument_list|,
name|NEPUBID
argument_list|(
name|p
argument_list|)
argument_list|,
name|NESYSID
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|NEDCNMARK
argument_list|(
name|p
argument_list|)
condition|)
name|output_notation
argument_list|(
name|NEDCN
argument_list|(
name|p
argument_list|)
operator|+
literal|1
argument_list|,
name|NEDCNPUBID
argument_list|(
name|p
argument_list|)
argument_list|,
name|NEDCNSYSID
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|output_external_entity
argument_list|(
name|NEENAME
argument_list|(
name|p
argument_list|)
operator|+
literal|1
argument_list|,
name|NEXTYPE
argument_list|(
name|p
argument_list|)
argument_list|,
name|NEID
argument_list|(
name|p
argument_list|)
argument_list|,
name|NEPUBID
argument_list|(
name|p
argument_list|)
argument_list|,
name|NESYSID
argument_list|(
name|p
argument_list|)
argument_list|,
name|NEDCN
argument_list|(
name|p
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|NEAL
argument_list|(
name|p
argument_list|)
condition|)
name|handle_attributes
argument_list|(
name|NEENAME
argument_list|(
name|p
argument_list|)
operator|+
literal|1
argument_list|,
name|NEAL
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|VOID
name|define_entity
parameter_list|(
name|ename
parameter_list|)
name|UNCH
modifier|*
name|ename
decl_stmt|;
block|{
name|int
name|rc
decl_stmt|;
name|PNE
name|np
decl_stmt|;
name|UNCH
modifier|*
name|tp
decl_stmt|;
if|if
condition|(
name|sgmlment
argument_list|(
name|ename
argument_list|)
condition|)
comment|/* already defined it */
return|return;
name|rc
operator|=
name|sgmlgent
argument_list|(
name|ename
argument_list|,
operator|&
name|np
argument_list|,
operator|&
name|tp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|rc
condition|)
block|{
case|case
literal|1
case|:
name|define_external_entity
argument_list|(
name|np
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
case|case
literal|3
case|:
name|output_internal_entity
argument_list|(
name|ename
operator|+
literal|1
argument_list|,
name|rc
operator|==
literal|3
argument_list|,
name|tp
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* ENT is the name of the entity with which these attributes are associated; if it's NULL, they're associated with the next start tag. */
end_comment

begin_function
specifier|static
name|VOID
name|handle_attributes
parameter_list|(
name|ent
parameter_list|,
name|al
parameter_list|)
name|UNCH
modifier|*
name|ent
decl_stmt|;
name|struct
name|ad
modifier|*
name|al
decl_stmt|;
block|{
name|int
name|aln
decl_stmt|;
for|for
control|(
name|aln
operator|=
literal|1
init|;
name|aln
operator|<=
name|ADN
argument_list|(
name|al
argument_list|)
condition|;
name|aln
operator|++
control|)
block|{
if|if
condition|(
name|GET
argument_list|(
name|ADFLAGS
argument_list|(
name|al
argument_list|,
name|aln
argument_list|)
argument_list|,
name|AERROR
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|GET
argument_list|(
name|ADFLAGS
argument_list|(
name|al
argument_list|,
name|aln
argument_list|)
argument_list|,
name|AINVALID
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|ADVAL
argument_list|(
name|al
argument_list|,
name|aln
argument_list|)
operator|==
name|NULL
condition|)
name|output_implied_attribute
argument_list|(
name|ent
argument_list|,
name|ADNAME
argument_list|(
name|al
argument_list|,
name|aln
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ADTYPE
argument_list|(
name|al
argument_list|,
name|aln
argument_list|)
operator|>=
name|ATKNLIST
condition|)
name|handle_token_list
argument_list|(
name|ent
argument_list|,
name|al
argument_list|,
name|aln
argument_list|)
expr_stmt|;
else|else
name|handle_single_token
argument_list|(
name|ent
argument_list|,
name|al
argument_list|,
name|aln
argument_list|)
expr_stmt|;
if|if
condition|(
name|BITON
argument_list|(
name|ADFLAGS
argument_list|(
name|al
argument_list|,
name|aln
argument_list|)
argument_list|,
name|AGROUP
argument_list|)
condition|)
name|aln
operator|+=
name|ADNUM
argument_list|(
name|al
argument_list|,
name|aln
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|VOID
name|handle_token_list
parameter_list|(
name|ent
parameter_list|,
name|al
parameter_list|,
name|aln
parameter_list|)
name|UNCH
modifier|*
name|ent
decl_stmt|;
name|struct
name|ad
modifier|*
name|al
decl_stmt|;
name|int
name|aln
decl_stmt|;
block|{
name|UNCH
modifier|*
name|ptr
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|ADTYPE
argument_list|(
name|al
argument_list|,
name|aln
argument_list|)
operator|==
name|AENTITYS
condition|)
block|{
name|ptr
operator|=
name|ADVAL
argument_list|(
name|al
argument_list|,
name|aln
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ADNUM
argument_list|(
name|al
argument_list|,
name|aln
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
comment|/* Temporarily make token look like normal 		  name with length and EOS. */
name|UNCH
name|c
init|=
name|ptr
index|[
operator|*
name|ptr
operator|+
literal|1
index|]
decl_stmt|;
name|ptr
index|[
operator|*
name|ptr
operator|+
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|ptr
operator|+=
literal|2
expr_stmt|;
name|define_entity
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
operator|*
name|ptr
operator|-=
literal|2
expr_stmt|;
name|ptr
operator|+=
operator|*
name|ptr
operator|+
literal|1
expr_stmt|;
operator|*
name|ptr
operator|=
name|c
expr_stmt|;
block|}
block|}
name|output_begin_attribute
argument_list|(
name|ent
argument_list|,
name|ADNAME
argument_list|(
name|al
argument_list|,
name|aln
argument_list|)
argument_list|,
name|ADTYPE
argument_list|(
name|al
argument_list|,
name|aln
argument_list|)
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|ADVAL
argument_list|(
name|al
argument_list|,
name|aln
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ADNUM
argument_list|(
name|al
argument_list|,
name|aln
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
comment|/* The first byte is a length NOT including the length 	     byte; the tokens are not EOS terminated. */
name|output_attribute_token
argument_list|(
operator|*
name|ptr
argument_list|,
name|ptr
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ptr
operator|+=
operator|*
name|ptr
operator|+
literal|1
expr_stmt|;
block|}
name|output_end_attribute
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|VOID
name|handle_single_token
parameter_list|(
name|ent
parameter_list|,
name|al
parameter_list|,
name|aln
parameter_list|)
name|UNCH
modifier|*
name|ent
decl_stmt|;
name|struct
name|ad
modifier|*
name|al
decl_stmt|;
name|int
name|aln
decl_stmt|;
block|{
if|if
condition|(
name|ADTYPE
argument_list|(
name|al
argument_list|,
name|aln
argument_list|)
operator|==
name|ANOTEGRP
operator|&&
operator|!
name|DCNMARK
argument_list|(
name|ADDATA
argument_list|(
name|al
argument_list|,
name|aln
argument_list|)
operator|.
name|x
argument_list|)
condition|)
name|output_notation
argument_list|(
name|ADVAL
argument_list|(
name|al
argument_list|,
name|aln
argument_list|)
operator|+
literal|1
argument_list|,
name|ADDATA
argument_list|(
name|al
argument_list|,
name|aln
argument_list|)
operator|.
name|x
operator|->
name|pubid
argument_list|,
name|ADDATA
argument_list|(
name|al
argument_list|,
name|aln
argument_list|)
operator|.
name|x
operator|->
name|sysid
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ADTYPE
argument_list|(
name|al
argument_list|,
name|aln
argument_list|)
operator|==
name|AENTITY
condition|)
name|define_entity
argument_list|(
name|ADVAL
argument_list|(
name|al
argument_list|,
name|aln
argument_list|)
argument_list|)
expr_stmt|;
name|output_begin_attribute
argument_list|(
name|ent
argument_list|,
name|ADNAME
argument_list|(
name|al
argument_list|,
name|aln
argument_list|)
argument_list|,
name|ADTYPE
argument_list|(
name|al
argument_list|,
name|aln
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ADTYPE
argument_list|(
name|al
argument_list|,
name|aln
argument_list|)
operator|==
name|ACHARS
condition|)
name|output_attribute_token
argument_list|(
name|ustrlen
argument_list|(
name|ADVAL
argument_list|(
name|al
argument_list|,
name|aln
argument_list|)
argument_list|)
argument_list|,
name|ADVAL
argument_list|(
name|al
argument_list|,
name|aln
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|output_attribute_token
argument_list|(
operator|*
name|ADVAL
argument_list|(
name|al
argument_list|,
name|aln
argument_list|)
operator|-
literal|2
argument_list|,
name|ADVAL
argument_list|(
name|al
argument_list|,
name|aln
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|output_end_attribute
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|VOID
name|output_notation
parameter_list|(
name|name
parameter_list|,
name|pubid
parameter_list|,
name|sysid
parameter_list|)
name|UNCH
modifier|*
name|name
decl_stmt|;
name|UNCH
modifier|*
name|pubid
decl_stmt|,
decl|*
name|sysid
decl_stmt|;
end_function

begin_block
block|{
name|flush_data
argument_list|()
expr_stmt|;
name|print_id
argument_list|(
operator|(
name|UNIV
operator|)
literal|0
argument_list|,
name|pubid
argument_list|,
name|sysid
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%c%s\n"
argument_list|,
name|DEFINE_NOTATION_CODE
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
specifier|static
name|VOID
name|output_internal_entity
parameter_list|(
name|ename
parameter_list|,
name|is_sdata
parameter_list|,
name|text
parameter_list|)
name|UNCH
modifier|*
name|ename
decl_stmt|;
name|int
name|is_sdata
decl_stmt|;
name|UNCH
modifier|*
name|text
decl_stmt|;
block|{
name|flush_data
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"%c%s %s "
argument_list|,
name|DEFINE_INTERNAL_ENTITY_CODE
argument_list|,
name|ename
argument_list|,
name|is_sdata
condition|?
literal|"SDATA"
else|:
literal|"CDATA"
argument_list|)
expr_stmt|;
name|print_string
argument_list|(
name|text
condition|?
name|ustrlen
argument_list|(
name|text
argument_list|)
else|:
literal|0
argument_list|,
name|text
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|VOID
name|output_subdoc
parameter_list|(
name|nm
parameter_list|,
name|id
parameter_list|,
name|pubid
parameter_list|,
name|sysid
parameter_list|)
name|UNCH
modifier|*
name|nm
decl_stmt|;
name|UNIV
name|id
decl_stmt|;
name|UNCH
modifier|*
name|pubid
decl_stmt|,
decl|*
name|sysid
decl_stmt|;
end_function

begin_block
block|{
name|flush_data
argument_list|()
expr_stmt|;
name|print_id
argument_list|(
name|id
argument_list|,
name|pubid
argument_list|,
name|sysid
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%c%s\n"
argument_list|,
name|DEFINE_SUBDOC_ENTITY_CODE
argument_list|,
name|nm
argument_list|)
expr_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|SUPPORT_SUBDOC
end_ifdef

begin_function
specifier|static
name|VOID
name|process_subdoc
parameter_list|(
name|nm
parameter_list|,
name|id
parameter_list|)
name|UNCH
modifier|*
name|nm
decl_stmt|;
name|UNIV
name|id
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|suppsw
condition|)
block|{
name|flush_data
argument_list|()
expr_stmt|;
name|output_location
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"%c%s\n"
argument_list|,
name|START_SUBDOC_CODE
argument_list|,
name|nm
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
condition|)
block|{
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|argv
operator|=
name|make_argv
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|ret
operator|=
name|run_process
argument_list|(
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
name|suberr
operator|++
expr_stmt|;
name|current_filename
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
name|get_subcaps
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|suberr
operator|++
expr_stmt|;
name|appl_error
argument_list|(
name|E_SUBDOC
argument_list|,
name|nm
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|suppsw
condition|)
name|printf
argument_list|(
literal|"%c%s\n"
argument_list|,
name|END_SUBDOC_CODE
argument_list|,
name|nm
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SUPPORT_SUBDOC */
end_comment

begin_function
specifier|static
name|VOID
name|output_external_entity
parameter_list|(
name|nm
parameter_list|,
name|xtype
parameter_list|,
name|id
parameter_list|,
name|pubid
parameter_list|,
name|sysid
parameter_list|,
name|dcn
parameter_list|)
name|UNCH
modifier|*
name|nm
decl_stmt|,
decl|*
name|dcn
decl_stmt|;
end_function

begin_decl_stmt
name|UNIV
name|id
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|UNCH
modifier|*
name|pubid
decl_stmt|,
modifier|*
name|sysid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|xtype
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|type
decl_stmt|;
name|flush_data
argument_list|()
expr_stmt|;
name|print_id
argument_list|(
name|id
argument_list|,
name|pubid
argument_list|,
name|sysid
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|xtype
condition|)
block|{
case|case
name|ESNCDATA
case|:
name|type
operator|=
literal|"CDATA"
expr_stmt|;
break|break;
case|case
name|ESNNDATA
case|:
name|type
operator|=
literal|"NDATA"
expr_stmt|;
break|break;
case|case
name|ESNSDATA
case|:
name|type
operator|=
literal|"SDATA"
expr_stmt|;
break|break;
default|default:
return|return;
block|}
name|printf
argument_list|(
literal|"%c%s %s %s\n"
argument_list|,
name|DEFINE_EXTERNAL_ENTITY_CODE
argument_list|,
name|nm
argument_list|,
name|type
argument_list|,
name|dcn
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
specifier|static
name|VOID
name|output_record_end
parameter_list|()
block|{
specifier|static
name|UNCH
name|re
init|=
name|RECHAR
decl_stmt|;
name|print_data
argument_list|(
literal|1
argument_list|,
operator|&
name|re
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|VOID
name|output_pcdata
parameter_list|(
name|n
parameter_list|,
name|s
parameter_list|)
name|UNS
name|n
decl_stmt|;
name|UNCH
modifier|*
name|s
decl_stmt|;
block|{
name|print_data
argument_list|(
name|n
argument_list|,
name|s
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|VOID
name|output_cdata
parameter_list|(
name|n
parameter_list|,
name|s
parameter_list|)
name|UNS
name|n
decl_stmt|;
name|UNCH
modifier|*
name|s
decl_stmt|;
block|{
name|print_data
argument_list|(
name|n
argument_list|,
name|s
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|VOID
name|output_sdata
parameter_list|(
name|n
parameter_list|,
name|s
parameter_list|)
name|UNS
name|n
decl_stmt|;
name|UNCH
modifier|*
name|s
decl_stmt|;
block|{
name|print_data
argument_list|(
name|n
argument_list|,
name|s
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|VOID
name|output_entity_reference
parameter_list|(
name|s
parameter_list|)
name|UNCH
modifier|*
name|s
decl_stmt|;
block|{
name|flush_data
argument_list|()
expr_stmt|;
name|output_location
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"%c%s\n"
argument_list|,
name|REFERENCE_ENTITY_CODE
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|VOID
name|output_start_tag
parameter_list|(
name|s
parameter_list|)
name|UNCH
modifier|*
name|s
decl_stmt|;
block|{
name|flush_data
argument_list|()
expr_stmt|;
name|output_location
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"%c%s\n"
argument_list|,
name|START_CODE
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|VOID
name|output_end_tag
parameter_list|(
name|s
parameter_list|)
name|UNCH
modifier|*
name|s
decl_stmt|;
block|{
name|flush_data
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"%c%s\n"
argument_list|,
name|END_CODE
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|VOID
name|output_processing_instruction
parameter_list|(
name|n
parameter_list|,
name|s
parameter_list|)
name|UNS
name|n
decl_stmt|;
name|UNCH
modifier|*
name|s
decl_stmt|;
block|{
name|flush_data
argument_list|()
expr_stmt|;
name|output_location
argument_list|()
expr_stmt|;
name|putchar
argument_list|(
name|PI_CODE
argument_list|)
expr_stmt|;
name|print_string
argument_list|(
name|n
argument_list|,
name|s
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|VOID
name|output_appinfo
parameter_list|(
name|n
parameter_list|,
name|s
parameter_list|)
name|UNS
name|n
decl_stmt|;
name|UNCH
modifier|*
name|s
decl_stmt|;
block|{
name|flush_data
argument_list|()
expr_stmt|;
name|output_location
argument_list|()
expr_stmt|;
name|putchar
argument_list|(
name|APPINFO_CODE
argument_list|)
expr_stmt|;
name|print_string
argument_list|(
name|n
argument_list|,
name|s
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|VOID
name|output_implied_attribute
parameter_list|(
name|ent
parameter_list|,
name|aname
parameter_list|)
name|UNCH
modifier|*
name|ent
decl_stmt|,
decl|*
name|aname
decl_stmt|;
end_function

begin_block
block|{
name|flush_data
argument_list|()
expr_stmt|;
if|if
condition|(
name|ent
condition|)
name|printf
argument_list|(
literal|"%c%s %s IMPLIED\n"
argument_list|,
name|DATA_ATTRIBUTE_CODE
argument_list|,
name|ent
argument_list|,
name|aname
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%c%s IMPLIED\n"
argument_list|,
name|ATTRIBUTE_CODE
argument_list|,
name|aname
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
specifier|static
name|char
modifier|*
name|attribute_type_string
parameter_list|(
name|type
parameter_list|)
name|int
name|type
decl_stmt|;
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|ANMTGRP
case|:
case|case
name|ANAME
case|:
case|case
name|ANMTOKE
case|:
case|case
name|ANUTOKE
case|:
case|case
name|ANUMBER
case|:
case|case
name|ANAMES
case|:
case|case
name|ANMTOKES
case|:
case|case
name|ANUTOKES
case|:
case|case
name|ANUMBERS
case|:
case|case
name|AID
case|:
case|case
name|AIDREF
case|:
case|case
name|AIDREFS
case|:
return|return
literal|"TOKEN"
return|;
case|case
name|ANOTEGRP
case|:
return|return
literal|"NOTATION"
return|;
case|case
name|ACHARS
case|:
return|return
literal|"CDATA"
return|;
case|case
name|AENTITY
case|:
case|case
name|AENTITYS
case|:
return|return
literal|"ENTITY"
return|;
block|}
if|#
directive|if
literal|0
block|fatal("invalid attribute type %d", type);
endif|#
directive|endif
return|return
literal|"INVALID"
return|;
block|}
end_function

begin_function
specifier|static
name|VOID
name|output_begin_attribute
parameter_list|(
name|ent
parameter_list|,
name|aname
parameter_list|,
name|type
parameter_list|)
name|UNCH
modifier|*
name|ent
decl_stmt|,
decl|*
name|aname
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|type
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|flush_data
argument_list|()
expr_stmt|;
if|if
condition|(
name|ent
condition|)
name|printf
argument_list|(
literal|"%c%s %s %s"
argument_list|,
name|DATA_ATTRIBUTE_CODE
argument_list|,
name|ent
argument_list|,
name|aname
argument_list|,
name|attribute_type_string
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%c%s %s"
argument_list|,
name|ATTRIBUTE_CODE
argument_list|,
name|aname
argument_list|,
name|attribute_type_string
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
specifier|static
name|VOID
name|output_attribute_token
parameter_list|(
name|vallen
parameter_list|,
name|val
parameter_list|)
name|UNS
name|vallen
decl_stmt|;
name|UNCH
modifier|*
name|val
decl_stmt|;
block|{
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|print_string
argument_list|(
name|vallen
argument_list|,
name|val
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|VOID
name|output_end_attribute
parameter_list|()
block|{
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|VOID
name|print_data
parameter_list|(
name|n
parameter_list|,
name|s
parameter_list|,
name|is_sdata
parameter_list|)
name|UNS
name|n
decl_stmt|;
name|UNCH
modifier|*
name|s
decl_stmt|;
name|int
name|is_sdata
decl_stmt|;
block|{
if|if
condition|(
name|n
operator|>
literal|0
operator|||
name|is_sdata
condition|)
block|{
if|if
condition|(
name|n
operator|==
literal|1
operator|&&
operator|*
name|s
operator|==
name|RECHAR
condition|)
name|current_lineno
operator|++
expr_stmt|;
else|else
name|output_location
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|have_data
condition|)
name|putchar
argument_list|(
name|DATA_CODE
argument_list|)
expr_stmt|;
name|print_string
argument_list|(
name|n
argument_list|,
name|s
argument_list|,
name|is_sdata
argument_list|)
expr_stmt|;
name|have_data
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|VOID
name|flush_data
parameter_list|()
block|{
if|if
condition|(
name|have_data
condition|)
block|{
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|have_data
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|VOID
name|output_location
parameter_list|()
block|{
name|char
modifier|*
name|filename
decl_stmt|;
name|unsigned
name|long
name|lineno
decl_stmt|;
name|int
name|filename_changed
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|locsw
condition|)
return|return;
if|if
condition|(
operator|!
name|sgmlloc
argument_list|(
operator|&
name|lineno
argument_list|,
operator|&
name|filename
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|current_filename
operator|||
name|strcmp
argument_list|(
name|filename
argument_list|,
name|current_filename
argument_list|)
operator|!=
literal|0
condition|)
name|filename_changed
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|lineno
operator|==
name|current_lineno
condition|)
return|return;
name|flush_data
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"%c%lu"
argument_list|,
name|LOCATION_CODE
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|current_lineno
operator|=
name|lineno
expr_stmt|;
if|if
condition|(
name|filename_changed
condition|)
block|{
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|print_filename
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|current_filename
operator|=
name|filename
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|VOID
name|print_string
parameter_list|(
name|slen
parameter_list|,
name|s
parameter_list|,
name|is_sdata
parameter_list|)
name|UNS
name|slen
decl_stmt|;
name|UNCH
modifier|*
name|s
decl_stmt|;
name|int
name|is_sdata
decl_stmt|;
block|{
if|if
condition|(
name|is_sdata
condition|)
name|fputs
argument_list|(
literal|"\\|"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
while|while
condition|(
name|slen
operator|>
literal|0
condition|)
block|{
name|UNCH
name|ch
init|=
operator|*
name|s
operator|++
decl_stmt|;
name|slen
operator|--
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|DELSDATA
condition|)
block|{
if|if
condition|(
name|is_sdata
condition|)
empty_stmt|;
comment|/* I don't think this should happen */
else|else
name|fputs
argument_list|(
literal|"\\|"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
empty_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
name|DELCDATA
condition|)
empty_stmt|;
else|else
block|{
if|if
condition|(
name|ch
operator|==
name|DELNONCH
condition|)
block|{
if|if
condition|(
operator|!
name|slen
condition|)
break|break;
name|ch
operator|=
name|UNSHIFTNON
argument_list|(
operator|*
name|s
argument_list|)
expr_stmt|;
name|s
operator|++
expr_stmt|;
name|slen
operator|--
expr_stmt|;
block|}
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
name|RECHAR
case|:
name|fputs
argument_list|(
literal|"\\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
name|fputs
argument_list|(
literal|"\\\\"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|ISASCII
argument_list|(
name|ch
argument_list|)
operator|&&
name|isprint
argument_list|(
name|ch
argument_list|)
condition|)
name|putchar
argument_list|(
name|ch
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"\\%03o"
argument_list|,
name|ch
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|is_sdata
condition|)
name|fputs
argument_list|(
literal|"\\|"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|VOID
name|print_id
parameter_list|(
name|id
parameter_list|,
name|pubid
parameter_list|,
name|sysid
parameter_list|)
name|UNIV
name|id
decl_stmt|;
name|UNCH
modifier|*
name|pubid
decl_stmt|;
name|UNCH
modifier|*
name|sysid
decl_stmt|;
block|{
if|if
condition|(
name|pubid
condition|)
block|{
name|putchar
argument_list|(
name|PUBID_CODE
argument_list|)
expr_stmt|;
name|print_string
argument_list|(
name|ustrlen
argument_list|(
name|pubid
argument_list|)
argument_list|,
name|pubid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sysid
condition|)
block|{
name|putchar
argument_list|(
name|SYSID_CODE
argument_list|)
expr_stmt|;
name|print_string
argument_list|(
name|ustrlen
argument_list|(
name|sysid
argument_list|)
argument_list|,
name|sysid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|id
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|id
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
block|{
name|putchar
argument_list|(
name|FILE_CODE
argument_list|)
expr_stmt|;
do|do
block|{
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|'\\'
case|:
name|fputs
argument_list|(
literal|"\\\\"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
name|fputs
argument_list|(
literal|"\\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|ISASCII
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|isprint
argument_list|(
operator|(
name|UNCH
operator|)
operator|*
name|p
argument_list|)
condition|)
name|putchar
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"\\%03o"
argument_list|,
operator|(
name|UNCH
operator|)
operator|*
name|p
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
operator|*
operator|++
name|p
condition|)
do|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|VOID
name|print_filename
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
for|for
control|(
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|'\\'
case|:
name|fputs
argument_list|(
literal|"\\\\"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
name|fputs
argument_list|(
literal|"\\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|ISASCII
argument_list|(
operator|*
name|s
argument_list|)
operator|&&
name|isprint
argument_list|(
operator|(
name|UNCH
operator|)
operator|*
name|s
argument_list|)
condition|)
name|putchar
argument_list|(
operator|*
name|s
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"\\%03o"
argument_list|,
operator|(
name|UNCH
operator|)
operator|*
name|s
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Local Variables: c-indent-level: 5 c-continued-statement-offset: 5 c-brace-offset: -5 c-argdecl-indent: 0 c-label-offset: -5 End: */
end_comment

end_unit

