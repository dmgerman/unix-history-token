begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"sgmlincl.h"
end_include

begin_comment
comment|/* #INCLUDE statements for SGML parser. */
end_comment

begin_define
define|#
directive|define
name|GI
value|(tags[ts].tetd->etdgi+1)
end_define

begin_comment
comment|/* GI of current element. */
end_comment

begin_define
define|#
directive|define
name|NEWGI
value|(newetd->etdgi+1)
end_define

begin_comment
comment|/* GI of new tag. */
end_comment

begin_decl_stmt
specifier|static
name|VOID
name|doincludes
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pentname
name|P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mpos
modifier|*
name|newmpos
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|VOID
name|commbufs
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|VOID
name|checkdtd
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* PARSECON: Parse content of an element. */
end_comment

begin_function
name|int
name|parsecon
parameter_list|(
name|tbuf
parameter_list|,
name|pcb
parameter_list|)
name|UNCH
modifier|*
name|tbuf
decl_stmt|;
comment|/* Work area for tokenization. */
name|struct
name|parse
modifier|*
name|pcb
decl_stmt|;
comment|/* Parse control block for this parse. */
block|{
name|int
name|srn
decl_stmt|;
comment|/* SHORTREF delimiter number (1-32). */
name|int
name|refrc
decl_stmt|;
comment|/* Return code from sentref, stagetd, etc. */
name|TRACECON
argument_list|(
name|etagimct
argument_list|,
name|dostag
argument_list|,
name|datarc
argument_list|,
name|pcb
argument_list|,
name|conrefsw
argument_list|,
name|didreq
argument_list|)
expr_stmt|;
if|if
condition|(
name|eodsw
condition|)
return|return
operator|(
name|EOD_
operator|)
return|;
if|if
condition|(
name|didreq
operator|&&
operator|(
name|conrefsw
operator|&
name|TAGREF
operator|)
condition|)
block|{
name|didreq
operator|=
literal|0
expr_stmt|;
goto|goto
name|conr
goto|;
block|}
if|if
condition|(
name|etagimct
operator|>
literal|0
condition|)
block|{
name|etagimsw
operator|=
operator|--
name|etagimct
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|destack
argument_list|()
expr_stmt|;
return|return
operator|(
name|ETG_
operator|)
return|;
block|}
if|if
condition|(
name|dostag
condition|)
block|{
name|conrefsw
operator|=
name|conrefsv
expr_stmt|;
name|etisw
operator|=
name|etiswsv
expr_stmt|;
if|if
condition|(
name|charmode
condition|)
block|{
name|dostag
operator|=
literal|0
expr_stmt|;
return|return
name|datarc
return|;
block|}
return|return
name|stag
argument_list|(
name|datarc
argument_list|)
return|;
block|}
if|if
condition|(
name|conrefsw
condition|)
block|{
name|conr
label|:
name|destack
argument_list|()
expr_stmt|;
name|conrefsw
operator|=
literal|0
expr_stmt|;
return|return
name|ETG_
return|;
block|}
elseif|else
if|if
condition|(
name|eofsw
condition|)
return|return
operator|(
name|EOD_
operator|)
return|;
name|datarc
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|parse
argument_list|(
name|pcb
argument_list|)
expr_stmt|;
name|srn
operator|=
operator|(
name|int
operator|)
name|pcb
operator|->
name|action
operator|-
name|SRMIN
expr_stmt|;
comment|/* Just in case it's a SHORTREF. */
switch|switch
condition|(
name|pcb
operator|->
name|action
condition|)
block|{
case|case
name|DCE_
case|:
comment|/* Data character in element content. */
comment|/* The data character might be a non-SGML character so                   reprocess it using pcbconm. */
name|REPEATCC
expr_stmt|;
name|pcb
operator|=
name|conpcb
operator|=
operator|&
name|pcbconm
expr_stmt|;
name|pcb
operator|->
name|newstate
operator|=
name|pcbcnet
expr_stmt|;
continue|continue;
case|case
name|DAS_
case|:
comment|/* Current character begins data. */
name|data
operator|=
name|FPOS
expr_stmt|;
continue|continue;
case|case
name|NLF_
case|:
comment|/* NET or SR returns data in lookahead buffer. */
name|datalen
operator|=
call|(
name|UNS
call|)
argument_list|(
name|ptcon
operator|-
name|data
argument_list|)
expr_stmt|;
name|REPEATCC
expr_stmt|;
goto|goto
name|rcc
goto|;
case|case
name|LAF_
case|:
comment|/* Return data in lookahead buffer: mixed. */
name|datalen
operator|=
call|(
name|UNS
call|)
argument_list|(
name|ptcon
operator|+
literal|1
operator|-
name|data
argument_list|)
expr_stmt|;
goto|goto
name|rcc
goto|;
case|case
name|NON_
case|:
comment|/* Single nonchar in nonchbuf. */
name|datalen
operator|=
literal|2
expr_stmt|;
name|data
operator|=
name|nonchbuf
expr_stmt|;
goto|goto
name|nrcc
goto|;
case|case
name|DAR_
case|:
comment|/* Return data except for last char. */
name|REPEATCC
expr_stmt|;
case|case
name|DAF_
case|:
comment|/* Return data in source entity buffer. */
name|datalen
operator|=
call|(
name|UNS
call|)
argument_list|(
name|FPOS
operator|-
name|data
argument_list|)
expr_stmt|;
name|rcc
label|:
name|REPEATCC
expr_stmt|;
case|case
name|DEF_
case|:
comment|/* Return data in data entity. */
name|nrcc
label|:
name|datarc
operator|=
name|DAF_
expr_stmt|;
if|if
condition|(
name|pcb
operator|==
operator|&
name|pcbcone
condition|)
block|{
name|pcbconm
operator|.
name|newstate
operator|=
name|pcbcnet
expr_stmt|;
name|conpcb
operator|=
operator|&
name|pcbconm
expr_stmt|;
block|}
if|if
condition|(
name|charmode
condition|)
return|return
operator|(
name|datarc
operator|)
return|;
name|stagmin
operator|=
name|MINNONE
expr_stmt|;
name|stagreal
operator|=
name|newetd
operator|=
name|ETDCDATA
expr_stmt|;
return|return
operator|(
name|stag
argument_list|(
name|datarc
argument_list|)
operator|)
return|;
case|case
name|LAS_
case|:
comment|/* Start lookahead buffer with current char. */
operator|*
operator|(
name|ptcon
operator|=
name|data
operator|=
name|tbuf
operator|+
literal|1
operator|)
operator|=
operator|*
name|FPOS
expr_stmt|;
continue|continue;
case|case
name|LAM_
case|:
comment|/* Move character to lookahead buffer. */
operator|*
operator|++
name|ptcon
operator|=
operator|*
name|FPOS
expr_stmt|;
continue|continue;
case|case
name|STG_
case|:
comment|/* Process non-null start-tag. */
name|CTRSET
argument_list|(
name|tagctr
argument_list|)
expr_stmt|;
comment|/* Start counting tag length. */
name|tages
operator|=
name|es
expr_stmt|;
name|parsenm
argument_list|(
name|tbuf
argument_list|,
name|NAMECASE
argument_list|)
expr_stmt|;
comment|/* Get the GI. */
name|newetd
operator|=
name|etdref
argument_list|(
name|tbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|newetd
operator|&&
name|newetd
operator|->
name|adl
condition|)
block|{
name|parseatt
argument_list|(
name|newetd
operator|->
name|adl
argument_list|,
name|tbuf
argument_list|)
expr_stmt|;
name|adlval
argument_list|(
operator|(
name|int
operator|)
name|ADN
argument_list|(
name|al
argument_list|)
argument_list|,
name|newetd
argument_list|)
expr_stmt|;
block|}
name|parsetag
argument_list|(
operator|&
name|pcbstag
argument_list|)
expr_stmt|;
comment|/* Parse the tag ending. */
if|if
condition|(
operator|(
name|CTRGET
argument_list|(
name|tagctr
argument_list|)
operator|-
name|tagdelsw
operator|)
operator|>=
name|TAGLEN
condition|)
name|sgmlerr
argument_list|(
literal|66
argument_list|,
operator|&
name|pcbstag
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|newetd
condition|)
block|{
name|sgmlerr
argument_list|(
literal|132
argument_list|,
name|pcb
argument_list|,
name|tbuf
operator|+
literal|1
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
return|return
operator|(
name|stagetd
argument_list|(
operator|&
name|pcbstag
argument_list|)
operator|)
return|;
case|case
name|NST_
case|:
comment|/* Process null start-tag. */
return|return
name|nstetd
argument_list|()
return|;
case|case
name|ETC_
case|:
comment|/* End-tag in CDATA or RCDATA. */
case|case
name|ETG_
case|:
comment|/* Process non-null end-tag. */
name|newetd
operator|=
name|etdref
argument_list|(
name|parsenm
argument_list|(
name|tbuf
argument_list|,
name|NAMECASE
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Get the GI. */
name|parsetag
argument_list|(
operator|&
name|pcbetag
argument_list|)
expr_stmt|;
comment|/* Parse tag end. */
if|if
condition|(
operator|!
name|newetd
condition|)
comment|/* Error: undefined.*/
name|sgmlerr
argument_list|(
literal|11
argument_list|,
operator|&
name|pcbetag
argument_list|,
name|tbuf
operator|+
literal|1
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|etagetd
argument_list|(
operator|&
name|pcbetag
argument_list|)
operator|>=
literal|0
condition|)
return|return
name|ETG_
return|;
comment|/* Open element. */
if|if
condition|(
name|pcb
operator|->
name|action
operator|!=
name|ETC_
condition|)
continue|continue;
comment|/* Tag is undefined or not for an open element and we are in                   a CDATA or RCDATA element; issue message and treat as                   null end-tag (</>).                */
name|sgmlerr
argument_list|(
literal|57
argument_list|,
operator|&
name|pcbetag
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
case|case
name|NET_
case|:
comment|/* Process null end-tag. */
if|if
condition|(
operator|(
name|refrc
operator|=
name|netetd
argument_list|(
name|conpcb
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|ETG_
return|;
continue|continue;
case|case
name|NED_
case|:
comment|/* Process null end-tag delimiter. */
name|etagmin
operator|=
name|MINNET
expr_stmt|;
name|newetd
operator|=
name|etagreal
operator|=
name|ETDNET
expr_stmt|;
name|etagimct
operator|=
name|etag
argument_list|()
expr_stmt|;
name|etagimsw
operator|=
name|etagimct
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|destack
argument_list|()
expr_stmt|;
return|return
name|ETG_
return|;
case|case
name|GTR_
case|:
if|if
condition|(
name|entget
argument_list|()
operator|!=
operator|-
literal|1
condition|)
block|{
name|data
operator|=
name|FPOS
expr_stmt|;
continue|continue;
block|}
comment|/* fall through */
case|case
name|EOD_
case|:
comment|/* End of primary file. */
if|if
condition|(
name|ts
operator|<
literal|1
condition|)
return|return
operator|(
name|EOD_
operator|)
return|;
comment|/* Normal end: stack is empty. */
name|etagimct
operator|=
name|ts
operator|-
literal|1
expr_stmt|;
comment|/* Treat as end-tag for top tag on stack. */
name|etagmin
operator|=
name|MINETAG
expr_stmt|;
name|etagreal
operator|=
name|tags
index|[
literal|0
index|]
operator|.
name|tetd
expr_stmt|;
name|destack
argument_list|()
expr_stmt|;
name|eofsw
operator|=
literal|1
expr_stmt|;
comment|/* Return EOD_ after destacking all. */
return|return
name|ETG_
return|;
comment|/* Short references ending with blanks:                If the blank sequence is followed by RE, go do SR7 or SR6.                If the entity is undefined and we are in mixed content,                the blanks must be returned as data.  If not, they                can be ignored.           */
case|case
name|SR9_
case|:
comment|/* Process SR9 (two or more blanks). */
name|REPEATCC
expr_stmt|;
comment|/* Make first blank the CC. */
case|case
name|SR4_
case|:
comment|/* Process SR4 (RS, blanks). */
name|parseseq
argument_list|(
name|tbuf
argument_list|,
name|BSEQLEN
argument_list|)
expr_stmt|;
comment|/* Squeeze out all blanks. */
if|if
condition|(
operator|*
name|FPOS
operator|==
literal|'\r'
condition|)
block|{
name|srn
operator|=
operator|(
name|srn
operator|==
literal|9
operator|)
condition|?
literal|7
else|:
literal|6
expr_stmt|;
name|data
operator|=
name|tbuf
expr_stmt|;
goto|goto
name|sr6
goto|;
block|}
else|else
name|REPEATCC
expr_stmt|;
if|if
condition|(
operator|(
name|refrc
operator|=
name|shortref
argument_list|(
name|srn
argument_list|,
name|pcb
argument_list|)
operator|)
operator|==
name|DEF_
condition|)
goto|goto
name|nrcc
goto|;
if|if
condition|(
name|refrc
operator|>
literal|0
condition|)
return|return
name|refrc
return|;
if|if
condition|(
name|refrc
operator|==
name|ENTUNDEF
operator|&&
name|pcb
operator|==
operator|&
name|pcbconm
condition|)
block|{
name|data
operator|=
name|tbuf
expr_stmt|;
goto|goto
name|nrcc
goto|;
block|}
continue|continue;
comment|/* Short references ending with RE:                If the reference is defined, the RE is ignored.                For RE and RS RE,                no special action is needed if the reference is undefined,                as the RE will be processed immediately as the current character.                For B RE and RS B RE,                the input is primed with a special character that will                be treated as an RE that cannot be a short reference.           */
case|case
name|SR7_
case|:
comment|/* Process SR7 (blanks, RE). */
name|datalen
operator|=
call|(
name|UNS
call|)
argument_list|(
name|FPOS
operator|-
name|data
argument_list|)
expr_stmt|;
case|case
name|SR2_
case|:
comment|/* Process SR2 (RE). */
case|case
name|SR5_
case|:
comment|/* Process SR5 (RS, RE). */
name|sr6
label|:
comment|/* Process SR6 (RS, blanks, RE). */
if|if
condition|(
operator|(
name|refrc
operator|=
name|shortref
argument_list|(
name|srn
argument_list|,
name|pcb
argument_list|)
operator|)
operator|!=
name|ENTUNDEF
condition|)
block|{
if|if
condition|(
name|refrc
operator|==
name|DEF_
condition|)
goto|goto
name|nrcc
goto|;
comment|/* Defined: data entity. */
if|if
condition|(
name|refrc
operator|>
literal|0
condition|)
return|return
name|refrc
return|;
comment|/* Defined: tag entity. */
continue|continue;
comment|/* Defined: not tag. */
block|}
if|if
condition|(
name|pcb
operator|!=
operator|&
name|pcbconm
condition|)
continue|continue;
comment|/* Not mixed; ignore chars. */
if|if
condition|(
name|srn
operator|>=
literal|6
condition|)
comment|/* Return blanks as data. */
block|{
operator|*
name|FPOS
operator|=
name|lex
operator|.
name|d
operator|.
name|genre
expr_stmt|;
name|REPEATCC
expr_stmt|;
goto|goto
name|nrcc
goto|;
block|}
case|case
name|REF_
case|:
comment|/* Undefined SR with RE; return record end. */
name|datarc
operator|=
name|REF_
expr_stmt|;
if|if
condition|(
name|charmode
condition|)
return|return
operator|(
name|datarc
operator|)
return|;
if|#
directive|if
literal|0
comment|/* The standard says this situation can force a tag. 		  See 323:3-6, 412:1-7. */
comment|/* If RE would be ignored, don't treat it as start-tag                   because it could force a required tag; but do change                   state to show that an RE was ignored.                */
block|if (scbsgml[pss].snext==scbsgmst) {                     scbsgml[pss].snext = scbsgmnr; 		    TRACEGML(scbsgml, pss, conactsw, conact);                     continue;                }
endif|#
directive|endif
name|stagmin
operator|=
name|MINNONE
expr_stmt|;
name|stagreal
operator|=
name|newetd
operator|=
name|ETDCDATA
expr_stmt|;
return|return
operator|(
name|stag
argument_list|(
name|datarc
argument_list|)
operator|)
return|;
case|case
name|SR3_
case|:
comment|/* Process SR3 (RS). */
name|REPEATCC
expr_stmt|;
if|if
condition|(
operator|(
name|refrc
operator|=
name|shortref
argument_list|(
name|srn
argument_list|,
name|pcb
argument_list|)
operator|)
operator|==
name|DEF_
condition|)
goto|goto
name|nrcc
goto|;
if|if
condition|(
name|refrc
operator|>
literal|0
condition|)
return|return
name|refrc
return|;
continue|continue;
case|case
name|RBR_
case|:
comment|/* Two right brackets  */
name|srn
operator|=
literal|26
expr_stmt|;
name|REPEATCC
expr_stmt|;
comment|/* fall through */
case|case
name|SR1_
case|:
comment|/* Process SR1 (TAB). */
case|case
name|SR8_
case|:
comment|/* Process SR8 (space). */
case|case
name|SR19
case|:
comment|/* Process SR19 (-). */
case|case
name|SR26
case|:
comment|/* Process SR26 (]). */
name|REPEATCC
expr_stmt|;
goto|goto
name|srproc
goto|;
case|case
name|FCE_
case|:
comment|/* Process free character (SR11-18, SR21-32). */
name|fce
index|[
literal|0
index|]
operator|=
operator|*
name|FPOS
expr_stmt|;
name|srn
operator|=
name|mapsrch
argument_list|(
operator|&
name|lex
operator|.
name|s
operator|.
name|dtb
index|[
name|lex
operator|.
name|s
operator|.
name|fce
index|]
argument_list|,
name|fce
argument_list|)
expr_stmt|;
case|case
name|SR10
case|:
comment|/* Process SR10 ("). */
case|case
name|SR11
case|:
comment|/* Process SR11 (#). */
case|case
name|SR20
case|:
comment|/* Process SR20 (-). */
case|case
name|SR25
case|:
comment|/* Process SR25 ([). */
name|srproc
label|:
if|if
condition|(
operator|(
name|refrc
operator|=
name|shortref
argument_list|(
name|srn
argument_list|,
name|pcb
argument_list|)
operator|)
operator|==
name|DEF_
condition|)
goto|goto
name|nrcc
goto|;
if|if
condition|(
name|refrc
operator|>
literal|0
condition|)
return|return
name|refrc
return|;
if|if
condition|(
name|refrc
operator|==
name|ENTUNDEF
condition|)
block|{
comment|/* Treat the SR as data. */
name|data
operator|=
name|FPOS
operator|-
operator|(
name|srn
operator|==
name|lex
operator|.
name|s
operator|.
name|hyp2
operator|)
expr_stmt|;
comment|/* Two data chars if SR20.*/
if|if
condition|(
name|pcb
operator|!=
operator|&
name|pcbconm
condition|)
block|{
comment|/* If not in mixed content: */
if|if
condition|(
name|srn
operator|>=
name|lex
operator|.
name|s
operator|.
name|data
condition|)
block|{
comment|/* Change PCB. */
name|pcb
operator|=
name|conpcb
operator|=
operator|&
name|pcbconm
expr_stmt|;
name|pcb
operator|->
name|newstate
operator|=
name|pcbcnda
expr_stmt|;
block|}
block|}
else|else
name|pcb
operator|->
name|newstate
operator|=
name|pcbcnda
expr_stmt|;
comment|/* Now in data found state. */
block|}
continue|continue;
case|case
name|ERX_
case|:
comment|/* Entity ref in RCDATA: cancel ending delims.*/
name|lexcon
index|[
name|lex
operator|.
name|d
operator|.
name|tago
index|]
operator|=
name|lex
operator|.
name|l
operator|.
name|fre
expr_stmt|;
name|lexcon
index|[
name|lex
operator|.
name|d
operator|.
name|net
index|]
operator|=
name|lex
operator|.
name|l
operator|.
name|nonet
expr_stmt|;
name|lexlms
index|[
name|lex
operator|.
name|d
operator|.
name|msc
index|]
operator|=
name|lex
operator|.
name|l
operator|.
name|fre
expr_stmt|;
continue|continue;
case|case
name|EE_
case|:
comment|/* Entity end in RCDATA: check nesting. */
if|if
condition|(
name|es
operator|<
name|rcessv
condition|)
block|{
name|synerr
argument_list|(
literal|37
argument_list|,
name|pcb
argument_list|)
expr_stmt|;
name|rcessv
operator|=
name|es
expr_stmt|;
block|}
comment|/* If back at top level, re-enable the ending delimiters. */
if|if
condition|(
name|es
operator|==
name|rcessv
condition|)
block|{
name|lexcon
index|[
name|lex
operator|.
name|d
operator|.
name|tago
index|]
operator|=
name|lex
operator|.
name|l
operator|.
name|tago
expr_stmt|;
name|lexcon
index|[
name|lex
operator|.
name|d
operator|.
name|net
index|]
operator|=
name|etictr
condition|?
name|lex
operator|.
name|l
operator|.
name|net
else|:
name|lex
operator|.
name|l
operator|.
name|nonet
expr_stmt|;
name|lexlms
index|[
name|lex
operator|.
name|d
operator|.
name|msc
index|]
operator|=
name|lex
operator|.
name|l
operator|.
name|msc
expr_stmt|;
block|}
continue|continue;
case|case
name|PIE_
case|:
comment|/* PI entity: same as PIS_. */
return|return
name|PIS_
return|;
case|case
name|RSR_
case|:
comment|/* Record start: ccnt=0; ++rcnt.*/
operator|++
name|RCNT
expr_stmt|;
name|CTRSET
argument_list|(
name|RSCC
argument_list|)
expr_stmt|;
return|return
name|RSR_
return|;
case|case
name|MSS_
case|:
if|if
condition|(
name|ts
operator|==
literal|0
condition|)
name|synerr
argument_list|(
literal|217
argument_list|,
name|pcb
argument_list|)
expr_stmt|;
return|return
name|MSS_
return|;
default|default:
return|return
operator|(
name|int
operator|)
name|pcb
operator|->
name|action
return|;
comment|/* Default (MD_ MDC_ MSS_ MSE_ PIS_). */
block|}
block|}
block|}
end_function

begin_comment
comment|/* STAGETD: Process start-tag etd. */
end_comment

begin_function
name|int
name|stagetd
parameter_list|(
name|pcb
parameter_list|)
name|struct
name|parse
modifier|*
name|pcb
decl_stmt|;
comment|/* Parse control block for this parse. */
block|{
if|if
condition|(
operator|!
name|newetd
operator|->
name|etdmod
condition|)
block|{
name|sgmlerr
argument_list|(
literal|43
argument_list|,
name|pcb
argument_list|,
name|newetd
operator|->
name|etdgi
operator|+
literal|1
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
operator|++
name|ds
operator|.
name|etdercnt
expr_stmt|;
name|etdset
argument_list|(
name|newetd
argument_list|,
operator|(
name|UNCH
operator|)
name|SMO
operator|+
name|EMO
operator|+
name|ETDOCC
argument_list|,
operator|&
name|undechdr
argument_list|,
operator|(
name|PETD
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|PETD
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|PECB
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|TRACEETD
argument_list|(
name|newetd
argument_list|)
expr_stmt|;
block|}
name|stagmin
operator|=
name|MINNONE
expr_stmt|;
name|stagreal
operator|=
name|newetd
expr_stmt|;
return|return
name|stag
argument_list|(
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* NSTETD: Process null start-tag etd. */
end_comment

begin_function
name|int
name|nstetd
parameter_list|()
block|{
if|if
condition|(
name|sd
operator|.
name|omittag
operator|&&
name|ts
operator|>
literal|0
condition|)
name|newetd
operator|=
name|tags
index|[
name|ts
index|]
operator|.
name|tetd
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|sd
operator|.
name|omittag
operator|&&
name|lastetd
operator|!=
literal|0
condition|)
name|newetd
operator|=
name|lastetd
expr_stmt|;
else|else
name|newetd
operator|=
name|tags
index|[
literal|0
index|]
operator|.
name|tetd
operator|->
name|etdmod
index|[
literal|2
index|]
operator|.
name|tu
operator|.
name|thetd
expr_stmt|;
name|stagmin
operator|=
name|MINNULL
expr_stmt|;
name|stagreal
operator|=
name|ETDNULL
expr_stmt|;
name|etisw
operator|=
literal|0
expr_stmt|;
return|return
name|stag
argument_list|(
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ETAGETD: Process end-tag etd. */
end_comment

begin_function
name|int
name|etagetd
parameter_list|(
name|pcb
parameter_list|)
name|struct
name|parse
modifier|*
name|pcb
decl_stmt|;
comment|/* Parse control block for this parse. */
block|{
name|etagmin
operator|=
name|MINNONE
expr_stmt|;
name|etagreal
operator|=
name|newetd
expr_stmt|;
if|if
condition|(
operator|(
name|etagimct
operator|=
name|etag
argument_list|()
operator|)
operator|<
literal|0
condition|)
block|{
name|sgmlerr
argument_list|(
name|E_ETAG
argument_list|,
name|pcb
argument_list|,
name|NEWGI
argument_list|,
name|tags
index|[
name|ts
index|]
operator|.
name|tetd
operator|->
name|etdgi
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|etagimct
return|;
block|}
name|etagimsw
operator|=
name|etagimct
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|destack
argument_list|()
expr_stmt|;
return|return
name|ETG_
return|;
block|}
end_function

begin_comment
comment|/* NETETD: Process null end-tag etd. */
end_comment

begin_function
name|int
name|netetd
parameter_list|(
name|pcb
parameter_list|)
name|struct
name|parse
modifier|*
name|pcb
decl_stmt|;
comment|/* Parse control block for this parse. */
block|{
if|if
condition|(
name|ts
operator|<
literal|1
condition|)
block|{
name|sgmlerr
argument_list|(
literal|51
argument_list|,
name|pcb
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|etagmin
operator|=
name|MINNULL
expr_stmt|;
name|etagreal
operator|=
name|ETDNULL
expr_stmt|;
name|etagimsw
operator|=
literal|0
expr_stmt|;
name|destack
argument_list|()
expr_stmt|;
return|return
name|ETG_
return|;
block|}
end_function

begin_comment
comment|/* SHORTREF: Process a short (alternative) reference to an entity.              Returns ENTUNDEF if entity is not defined, otherwise returns              the return code from stagetd or etagetd if the entity was              a tag, or zero if an error occurred somewhere. */
end_comment

begin_function
name|int
name|shortref
parameter_list|(
name|srn
parameter_list|,
name|pcb
parameter_list|)
name|int
name|srn
decl_stmt|;
comment|/* Short reference number. */
name|struct
name|parse
modifier|*
name|pcb
decl_stmt|;
comment|/* Parse control block for this parse. */
block|{
name|int
name|rc
decl_stmt|;
comment|/* Return code from entopen. */
if|if
condition|(
name|tags
index|[
name|ts
index|]
operator|.
name|tsrm
operator|==
name|SRMNULL
operator|||
operator|!
name|tags
index|[
name|ts
index|]
operator|.
name|tsrm
index|[
name|srn
index|]
condition|)
return|return
name|ENTUNDEF
return|;
name|rc
operator|=
name|entopen
argument_list|(
name|tags
index|[
name|ts
index|]
operator|.
name|tsrm
index|[
name|srn
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
name|ENTDATA
condition|)
return|return
name|DEF_
return|;
if|if
condition|(
name|rc
operator|==
name|ENTPI
condition|)
return|return
name|PIS_
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* PARSEPRO: Parse prolog.              Note: ptpro cannot overrun tbuf (and therefore needn't be              tested), as long as the buffer exceeds the longest              lookahead sequence in the content parse tables. */
end_comment

begin_function
name|int
name|parsepro
parameter_list|()
block|{
name|struct
name|parse
modifier|*
name|oldpcb
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|rc
decl_stmt|;
comment|/* Return code: DAF MSS DCE */
switch|switch
condition|(
name|parse
argument_list|(
name|propcb
argument_list|)
condition|)
block|{
case|case
name|LAS_
case|:
comment|/* Start lookahead buffer with current char. */
operator|*
operator|(
name|ptpro
operator|=
name|data
operator|=
name|tbuf
operator|+
literal|1
operator|)
operator|=
operator|*
name|FPOS
expr_stmt|;
continue|continue;
case|case
name|LAM_
case|:
comment|/* Move character to lookahead buffer. */
operator|*
operator|++
name|ptpro
operator|=
operator|*
name|FPOS
expr_stmt|;
continue|continue;
case|case
name|LAF_
case|:
comment|/* Return data in lookahead buffer. */
name|datalen
operator|=
call|(
name|UNS
call|)
argument_list|(
name|ptpro
operator|+
literal|1
operator|-
name|data
argument_list|)
expr_stmt|;
name|REPEATCC
expr_stmt|;
name|rc
operator|=
name|DAF_
expr_stmt|;
break|break;
comment|/* Prolog ended; data pending. */
case|case
name|DTD_
case|:
comment|/* Process document type declaration. */
name|parsenm
argument_list|(
name|tbuf
argument_list|,
name|NAMECASE
argument_list|)
expr_stmt|;
comment|/* Get declaration name. */
if|if
condition|(
operator|!
name|ustrcmp
argument_list|(
name|tbuf
operator|+
literal|1
argument_list|,
name|sgmlkey
argument_list|)
operator|&&
operator|!
name|dtdsw
operator|&&
operator|!
name|sgmlsw
operator|++
condition|)
block|{
if|#
directive|if
literal|0
block|parse(&pcbmdi);
endif|#
directive|endif
comment|/* If we got some appinfo, return. */
if|if
condition|(
name|sgmldecl
argument_list|()
condition|)
return|return
name|APP_
return|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|ustrcmp
argument_list|(
name|tbuf
operator|+
literal|1
argument_list|,
name|key
index|[
name|KDOCTYPE
index|]
argument_list|)
operator|&&
operator|!
name|dtdsw
operator|++
condition|)
block|{
name|startdtd
argument_list|()
expr_stmt|;
name|mddtds
argument_list|(
name|tbuf
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|sgmlerr
argument_list|(
name|E_MDNAME
argument_list|,
name|propcb
argument_list|,
name|tbuf
operator|+
literal|1
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|DTE_
case|:
comment|/* DOCTYPE declaration (and prolog) ended. */
name|REPEATCC
expr_stmt|;
comment|/* Put back char that followed MSC. */
if|if
condition|(
name|es
operator|!=
literal|0
condition|)
name|sgmlerr
argument_list|(
literal|143
argument_list|,
name|propcb
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|dtdrefsw
condition|)
block|{
comment|/* Process referenced DTD before real DTE. */
name|dtdrefsw
operator|=
literal|0
expr_stmt|;
comment|/* Keep us from coming through here again. */
name|REPEATCC
expr_stmt|;
comment|/* Put back MSC so it follows referenced DTD. */
name|entref
argument_list|(
name|indtdent
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|mslevel
operator|>
literal|0
condition|)
block|{
name|sgmlerr
argument_list|(
literal|230
argument_list|,
name|propcb
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|mslevel
operator|=
literal|0
expr_stmt|;
name|msplevel
operator|=
literal|0
expr_stmt|;
block|}
name|mddtde
argument_list|(
name|tbuf
argument_list|)
expr_stmt|;
block|}
continue|continue;
case|case
name|MD_
case|:
comment|/* Process markup declaration within DTD or LPD. */
name|parsenm
argument_list|(
name|tbuf
argument_list|,
name|NAMECASE
argument_list|)
expr_stmt|;
comment|/* Get declaration name. */
if|if
condition|(
operator|!
name|ustrcmp
argument_list|(
name|tbuf
operator|+
literal|1
argument_list|,
name|key
index|[
name|KENTITY
index|]
argument_list|)
condition|)
name|mdentity
argument_list|(
name|tbuf
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|ustrcmp
argument_list|(
name|tbuf
operator|+
literal|1
argument_list|,
name|key
index|[
name|KUSEMAP
index|]
argument_list|)
condition|)
name|mdsrmuse
argument_list|(
name|tbuf
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|ustrcmp
argument_list|(
name|tbuf
operator|+
literal|1
argument_list|,
name|key
index|[
name|KATTLIST
index|]
argument_list|)
condition|)
name|mdadl
argument_list|(
name|tbuf
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|ustrcmp
argument_list|(
name|tbuf
operator|+
literal|1
argument_list|,
name|key
index|[
name|KSHORTREF
index|]
argument_list|)
condition|)
name|mdsrmdef
argument_list|(
name|tbuf
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|ustrcmp
argument_list|(
name|tbuf
operator|+
literal|1
argument_list|,
name|key
index|[
name|KELEMENT
index|]
argument_list|)
condition|)
name|mdelem
argument_list|(
name|tbuf
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|ustrcmp
argument_list|(
name|tbuf
operator|+
literal|1
argument_list|,
name|key
index|[
name|KNOTATION
index|]
argument_list|)
condition|)
name|mdnot
argument_list|(
name|tbuf
argument_list|)
expr_stmt|;
else|else
name|sgmlerr
argument_list|(
name|E_MDNAME
argument_list|,
name|propcb
argument_list|,
name|tbuf
operator|+
literal|1
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|MDC_
case|:
comment|/* Process markup declaration comment. */
name|sgmlsw
operator|++
expr_stmt|;
comment|/* SGML declaration not allowed after comment */
name|parsemd
argument_list|(
name|tbuf
argument_list|,
name|NAMECASE
argument_list|,
operator|(
expr|struct
name|parse
operator|*
operator|)
literal|0
argument_list|,
name|NAMELEN
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|MSS_
case|:
comment|/* Process marked section start. */
name|oldpcb
operator|=
name|propcb
expr_stmt|;
name|propcb
operator|=
name|mdms
argument_list|(
name|tbuf
argument_list|,
name|propcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|propcb
operator|==
operator|&
name|pcbmsc
operator|||
name|propcb
operator|==
operator|&
name|pcbmsrc
condition|)
block|{
if|if
condition|(
name|oldpcb
operator|==
operator|&
name|pcbmds
condition|)
name|sgmlerr
argument_list|(
literal|135
argument_list|,
name|oldpcb
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|conpcb
operator|=
name|propcb
expr_stmt|;
name|rc
operator|=
name|DCE_
expr_stmt|;
break|break;
block|}
continue|continue;
case|case
name|MSE_
case|:
comment|/* Process marked section end. */
if|if
condition|(
name|mdmse
argument_list|()
condition|)
name|propcb
operator|=
operator|&
name|pcbmds
expr_stmt|;
continue|continue;
case|case
name|MSP_
case|:
comment|/* Marked section start in prolog outside DTD */
name|rc
operator|=
name|MSS_
expr_stmt|;
break|break;
case|case
name|PIE_
case|:
comment|/* PI entity: same as PIS_. */
return|return
operator|(
name|PIS_
operator|)
return|;
case|case
name|EOD_
case|:
comment|/* Return end of primary entity. */
if|if
condition|(
name|dtdsw
operator|&&
name|propcb
operator|==
operator|&
name|pcbpro
condition|)
block|{
comment|/* We've had a DTD, so check it. */
name|setdtype
argument_list|()
expr_stmt|;
name|checkdtd
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|sw
operator|.
name|onlypro
operator|||
name|propcb
operator|!=
operator|&
name|pcbpro
operator|||
operator|!
name|dtdsw
condition|)
name|sgmlerr
argument_list|(
literal|127
argument_list|,
name|propcb
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
name|propcb
operator|->
name|action
return|;
case|case
name|PIS_
case|:
comment|/* Return processing instruction (string). */
name|sgmlsw
operator|++
expr_stmt|;
comment|/* SGML declaration not allowed after PI */
return|return
operator|(
operator|(
name|int
operator|)
name|propcb
operator|->
name|action
operator|)
return|;
comment|/* Prolog will continue later. */
case|case
name|CIR_
case|:
comment|/* Chars ignored; trying to resume parse. */
name|synerr
argument_list|(
name|E_RESTART
argument_list|,
name|propcb
argument_list|)
expr_stmt|;
name|REPEATCC
expr_stmt|;
continue|continue;
case|case
name|ETE_
case|:
comment|/* End tag ended prolog */
name|REPEATCC
expr_stmt|;
comment|/* fall through */
case|case
name|STE_
case|:
comment|/* Start tag ended prolog */
name|REPEATCC
expr_stmt|;
name|REPEATCC
expr_stmt|;
name|rc
operator|=
name|STE_
expr_stmt|;
break|break;
case|case
name|PEP_
case|:
comment|/* Previous character ended prolog. */
name|REPEATCC
expr_stmt|;
case|case
name|DCE_
case|:
comment|/* Data character ended prolog. */
name|REPEATCC
expr_stmt|;
name|rc
operator|=
name|DCE_
expr_stmt|;
break|break;
case|case
name|EE_
case|:
comment|/* Illegal entity end in ignored marked section. */
comment|/* An error message has already been given. */
continue|continue;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* switch */
name|setdtype
argument_list|()
expr_stmt|;
comment|/* First pass only: set document type. */
name|checkdtd
argument_list|()
expr_stmt|;
if|if
condition|(
name|sw
operator|.
name|onlypro
condition|)
return|return
name|EOD_
return|;
name|TRACESET
argument_list|()
expr_stmt|;
comment|/* Set trace switches. */
name|endprolog
argument_list|()
expr_stmt|;
comment|/* *DOC is first element; stack it at level 0. */
name|stack
argument_list|(
name|newetd
operator|=
name|nextetd
operator|=
name|stagreal
operator|=
name|etagreal
operator|=
name|docetd
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
comment|/* while */
block|}
end_function

begin_comment
comment|/* Allocate buffers that are used in the DTD. */
end_comment

begin_function
name|VOID
name|startdtd
parameter_list|()
block|{
name|nmgrp
operator|=
operator|(
expr|struct
name|etd
operator|*
operator|*
operator|)
name|rmalloc
argument_list|(
operator|(
name|GRPCNT
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|etd
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|nnmgrp
operator|=
operator|(
name|PDCB
operator|*
operator|)
name|rmalloc
argument_list|(
operator|(
name|GRPCNT
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|PDCB
argument_list|)
argument_list|)
expr_stmt|;
name|gbuf
operator|=
operator|(
expr|struct
name|thdr
operator|*
operator|)
name|rmalloc
argument_list|(
operator|(
name|GRPGTCNT
operator|+
literal|3
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|thdr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The extra 1 is for parsing the name of a parameter entity in 	mdentity(). */
name|nmbuf
operator|=
operator|(
name|UNCH
operator|*
operator|)
name|rmalloc
argument_list|(
name|NAMELEN
operator|+
literal|3
argument_list|)
expr_stmt|;
name|pubibuf
operator|=
operator|(
name|UNCH
operator|*
operator|)
name|rmalloc
argument_list|(
name|LITLEN
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sysibuf
operator|=
operator|(
name|UNCH
operator|*
operator|)
name|rmalloc
argument_list|(
name|LITLEN
operator|+
literal|1
argument_list|)
expr_stmt|;
name|commbufs
argument_list|()
expr_stmt|;
name|doincludes
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|VOID
name|checkdtd
parameter_list|()
block|{
name|struct
name|dcncb
modifier|*
name|np
decl_stmt|;
name|struct
name|srh
modifier|*
name|sp
decl_stmt|;
if|if
condition|(
name|sw
operator|.
name|swundef
condition|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|etd
modifier|*
name|ep
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ETDHASH
condition|;
name|i
operator|++
control|)
for|for
control|(
name|ep
operator|=
name|etdtab
index|[
name|i
index|]
init|;
name|ep
condition|;
name|ep
operator|=
name|ep
operator|->
name|etdnext
control|)
if|if
condition|(
operator|!
name|ep
operator|->
name|etdmod
condition|)
name|sgmlerr
argument_list|(
literal|140
argument_list|,
operator|(
expr|struct
name|parse
operator|*
operator|)
literal|0
argument_list|,
name|ep
operator|->
name|etdgi
operator|+
literal|1
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|sp
operator|=
name|srhtab
index|[
literal|0
index|]
init|;
name|sp
condition|;
name|sp
operator|=
name|sp
operator|->
name|enext
control|)
if|if
condition|(
name|sp
operator|->
name|srhsrm
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|sgmlerr
argument_list|(
literal|152
argument_list|,
operator|(
expr|struct
name|parse
operator|*
operator|)
literal|0
argument_list|,
name|sp
operator|->
name|ename
operator|+
literal|1
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|lex
operator|.
name|s
operator|.
name|dtb
index|[
literal|0
index|]
operator|.
name|mapdata
operator|+
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|entity
modifier|*
name|ecb
init|=
name|sp
operator|->
name|srhsrm
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|ecb
operator|&&
operator|!
name|ecb
operator|->
name|estore
condition|)
block|{
name|sgmlerr
argument_list|(
literal|93
argument_list|,
operator|(
expr|struct
name|parse
operator|*
operator|)
literal|0
argument_list|,
name|ecb
operator|->
name|ename
operator|+
literal|1
argument_list|,
name|sp
operator|->
name|srhsrm
index|[
literal|0
index|]
operator|->
name|ename
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sp
operator|->
name|srhsrm
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|np
operator|=
name|dcntab
index|[
literal|0
index|]
init|;
name|np
condition|;
name|np
operator|=
name|np
operator|->
name|enext
control|)
if|if
condition|(
operator|!
name|np
operator|->
name|defined
condition|)
name|sgmlerr
argument_list|(
literal|192
argument_list|,
operator|(
expr|struct
name|parse
operator|*
operator|)
literal|0
argument_list|,
name|np
operator|->
name|ename
operator|+
literal|1
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return non-zero if s is a valid parameter entity name. If so put a transformed name in entbuf. */
end_comment

begin_function
specifier|static
name|int
name|pentname
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|lextoke
index|[
operator|(
name|UNCH
operator|)
operator|*
name|s
index|]
operator|!=
name|NMS
condition|)
return|return
literal|0
return|;
name|entbuf
index|[
literal|2
index|]
operator|=
name|ENTCASE
condition|?
name|lextran
index|[
operator|(
name|UNCH
operator|)
operator|*
name|s
index|]
else|:
operator|(
name|UNCH
operator|)
operator|*
name|s
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|s
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>
name|NAMELEN
operator|-
literal|1
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|lextoke
index|[
operator|(
name|UNCH
operator|)
name|s
index|[
name|i
index|]
index|]
operator|<
name|NMC
operator|||
name|s
index|[
name|i
index|]
operator|==
name|EOBCHAR
condition|)
return|return
literal|0
return|;
name|entbuf
index|[
name|i
operator|+
literal|2
index|]
operator|=
name|ENTCASE
condition|?
name|lextran
index|[
operator|(
name|UNCH
operator|)
name|s
index|[
name|i
index|]
index|]
else|:
operator|(
name|UNCH
operator|)
name|s
index|[
name|i
index|]
expr_stmt|;
block|}
name|entbuf
index|[
literal|1
index|]
operator|=
name|lex
operator|.
name|d
operator|.
name|pero
expr_stmt|;
name|entbuf
index|[
name|i
operator|+
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
name|entbuf
index|[
literal|0
index|]
operator|=
call|(
name|UNCH
call|)
argument_list|(
name|i
operator|+
literal|3
argument_list|)
expr_stmt|;
comment|/* length byte, PERO and '\0' */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Handle sw.includes. */
end_comment

begin_function
specifier|static
name|VOID
name|doincludes
parameter_list|()
block|{
name|char
modifier|*
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|!
name|sw
operator|.
name|includes
condition|)
return|return;
for|for
control|(
name|p
operator|=
name|sw
operator|.
name|includes
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|pentname
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|entfind
argument_list|(
name|entbuf
argument_list|)
condition|)
block|{
name|union
name|etext
name|etx
decl_stmt|;
name|etx
operator|.
name|c
operator|=
name|savestr
argument_list|(
name|key
index|[
name|KINCLUDE
index|]
argument_list|)
expr_stmt|;
name|entdef
argument_list|(
name|entbuf
argument_list|,
name|ESM
argument_list|,
operator|&
name|etx
argument_list|)
expr_stmt|;
operator|++
name|ds
operator|.
name|ecbcnt
expr_stmt|;
name|ds
operator|.
name|ecbtext
operator|+=
name|ustrlen
argument_list|(
name|key
index|[
name|KINCLUDE
index|]
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|sgmlerr
argument_list|(
literal|138
argument_list|,
operator|(
expr|struct
name|parse
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
operator|*
name|p
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Allocate buffers that are use both in the DTD and the instance. */
end_comment

begin_function
specifier|static
name|VOID
name|commbufs
parameter_list|()
block|{
name|al
operator|=
operator|(
expr|struct
name|ad
operator|*
operator|)
name|rmalloc
argument_list|(
operator|(
name|ATTCNT
operator|+
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ad
argument_list|)
argument_list|)
expr_stmt|;
name|lbuf
operator|=
operator|(
name|UNCH
operator|*
operator|)
name|rmalloc
argument_list|(
name|LITLEN
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|mpos
modifier|*
name|newmpos
parameter_list|()
block|{
name|int
name|j
decl_stmt|;
name|unsigned
name|long
modifier|*
name|h
decl_stmt|;
name|struct
name|mpos
modifier|*
name|p
init|=
operator|(
expr|struct
name|mpos
operator|*
operator|)
name|rmalloc
argument_list|(
operator|(
name|GRPLVL
operator|+
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|mpos
argument_list|)
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|grplongs
operator|>
literal|0
argument_list|)
expr_stmt|;
name|h
operator|=
operator|(
name|unsigned
name|long
operator|*
operator|)
name|rmalloc
argument_list|(
operator|(
name|GRPLVL
operator|+
literal|2
operator|)
operator|*
name|grplongs
operator|*
expr|sizeof
operator|(
name|unsigned
name|long
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|GRPLVL
operator|+
literal|2
condition|;
name|j
operator|++
control|)
block|{
name|p
index|[
name|j
index|]
operator|.
name|h
operator|=
name|h
expr_stmt|;
name|h
operator|+=
name|grplongs
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* Perform end of prolog buffer allocation. */
end_comment

begin_function
name|VOID
name|endprolog
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|ambigfree
argument_list|()
expr_stmt|;
if|if
condition|(
name|dtdsw
condition|)
block|{
name|frem
argument_list|(
operator|(
name|UNIV
operator|)
name|nmgrp
argument_list|)
expr_stmt|;
name|frem
argument_list|(
operator|(
name|UNIV
operator|)
name|nnmgrp
argument_list|)
expr_stmt|;
name|frem
argument_list|(
operator|(
name|UNIV
operator|)
name|gbuf
argument_list|)
expr_stmt|;
name|frem
argument_list|(
operator|(
name|UNIV
operator|)
name|nmbuf
argument_list|)
expr_stmt|;
name|frem
argument_list|(
operator|(
name|UNIV
operator|)
name|sysibuf
argument_list|)
expr_stmt|;
name|frem
argument_list|(
operator|(
name|UNIV
operator|)
name|pubibuf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|commbufs
argument_list|()
expr_stmt|;
name|doincludes
argument_list|()
expr_stmt|;
block|}
name|scbsgml
operator|=
operator|(
expr|struct
name|restate
operator|*
operator|)
name|rmalloc
argument_list|(
operator|(
name|TAGLVL
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|restate
argument_list|)
argument_list|)
expr_stmt|;
name|tags
operator|=
operator|(
expr|struct
name|tag
operator|*
operator|)
name|rmalloc
argument_list|(
operator|(
name|TAGLVL
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|tag
argument_list|)
argument_list|)
expr_stmt|;
name|grplongs
operator|=
operator|(
name|GRPCNT
operator|+
name|LONGBITS
operator|-
literal|1
operator|)
operator|/
name|LONGBITS
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TAGLVL
operator|+
literal|1
condition|;
name|i
operator|++
control|)
name|tags
index|[
name|i
index|]
operator|.
name|tpos
operator|=
name|newmpos
argument_list|()
expr_stmt|;
name|savedpos
operator|=
name|newmpos
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* SETDTYPE: Establish specified or default document type. */
end_comment

begin_function
name|VOID
name|setdtype
parameter_list|()
block|{
comment|/* Initialize default model hdr for declared content. */
name|undechdr
operator|.
name|ttype
operator|=
name|MANY
operator|+
name|MCHARS
operator|+
name|MGI
expr_stmt|;
comment|/* Declared content is ANY. */
name|undechdr
operator|.
name|tu
operator|.
name|tnum
operator|=
literal|0
expr_stmt|;
comment|/* No content model. */
comment|/* Initialize content model and etd for *DOC. */
name|prcon
index|[
literal|0
index|]
operator|.
name|ttype
operator|=
name|MGI
expr_stmt|;
comment|/* Model is an element model. */
name|prcon
index|[
literal|0
index|]
operator|.
name|tu
operator|.
name|tnum
operator|=
literal|2
expr_stmt|;
comment|/* A single group with a single GI in it. */
name|prcon
index|[
literal|1
index|]
operator|.
name|ttype
operator|=
name|TTSEQ
expr_stmt|;
comment|/* Non-repeatable SEQ group. */
name|prcon
index|[
literal|1
index|]
operator|.
name|tu
operator|.
name|tnum
operator|=
literal|1
expr_stmt|;
comment|/* Only one token in group. */
name|prcon
index|[
literal|2
index|]
operator|.
name|ttype
operator|=
name|TTETD
expr_stmt|;
comment|/* Token is an etd. */
name|docetd
operator|=
name|etddef
argument_list|(
name|indocetd
argument_list|)
expr_stmt|;
comment|/* etd for document as a whole. */
name|etdset
argument_list|(
name|docetd
argument_list|,
name|ETDOCC
argument_list|,
name|prcon
argument_list|,
operator|(
name|PETD
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|PETD
operator|*
operator|)
literal|0
argument_list|,
name|SRMNULL
argument_list|)
expr_stmt|;
comment|/* Put specified or default document type etd in *DOC model. */
if|if
condition|(
operator|!
name|dtype
condition|)
block|{
name|sgmlerr
argument_list|(
name|E_DOCTYPE
argument_list|,
name|propcb
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|dtype
operator|=
name|indefetd
expr_stmt|;
block|}
name|prcon
index|[
literal|2
index|]
operator|.
name|tu
operator|.
name|thetd
operator|=
name|etddef
argument_list|(
name|dtype
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|prcon
index|[
literal|2
index|]
operator|.
name|tu
operator|.
name|thetd
operator|->
name|etdmod
condition|)
block|{
if|if
condition|(
name|dtype
operator|!=
name|indefetd
condition|)
name|sgmlerr
argument_list|(
literal|52
argument_list|,
name|propcb
argument_list|,
name|dtype
operator|+
literal|1
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
operator|++
name|ds
operator|.
name|etdercnt
expr_stmt|;
name|etdset
argument_list|(
name|prcon
index|[
literal|2
index|]
operator|.
name|tu
operator|.
name|thetd
argument_list|,
operator|(
name|UNCH
operator|)
name|SMO
operator|+
name|EMO
operator|+
name|ETDUSED
operator|+
name|ETDOCC
argument_list|,
operator|&
name|undechdr
argument_list|,
operator|(
name|PETD
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|PETD
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|PECB
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
name|TRACEETD
argument_list|(
name|docetd
argument_list|)
expr_stmt|;
name|TRACEMOD
argument_list|(
name|prcon
argument_list|)
expr_stmt|;
name|TRACEETD
argument_list|(
name|prcon
index|[
literal|2
index|]
operator|.
name|tu
operator|.
name|thetd
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* PARSETAG: Tag end parser for SGML documents.              For start-tags, it              sets etisw to TAGNET if tag ended with ETI; otherwise to 0. */
end_comment

begin_function
name|VOID
name|parsetag
parameter_list|(
name|pcb
parameter_list|)
name|struct
name|parse
modifier|*
name|pcb
decl_stmt|;
comment|/* Parse control block: pcbstag or pcbetag. */
block|{
name|tagdelsw
operator|=
literal|1
expr_stmt|;
comment|/* Assume tag had an ETI or TAGC. */
switch|switch
condition|(
name|parse
argument_list|(
name|pcb
argument_list|)
condition|)
block|{
case|case
name|ETIC
case|:
comment|/* Tag closed with ETI. */
if|if
condition|(
operator|!
name|sd
operator|.
name|shorttag
condition|)
name|synerr
argument_list|(
literal|194
argument_list|,
name|pcb
argument_list|)
expr_stmt|;
name|etisw
operator|=
name|TAGNET
expr_stmt|;
comment|/* Set switch for stack entry flag. */
return|return;
case|case
name|DSC
case|:
name|synerr
argument_list|(
literal|9
argument_list|,
name|pcb
argument_list|)
expr_stmt|;
name|REPEATCC
expr_stmt|;
name|etisw
operator|=
literal|0
expr_stmt|;
return|return;
case|case
name|NVS
case|:
comment|/* Att name or value token found. */
case|case
name|NTV
case|:
comment|/* Name token value found. */
name|synerr
argument_list|(
name|E_POSSATT
argument_list|,
name|pcb
argument_list|)
expr_stmt|;
name|pcb
operator|->
name|newstate
operator|=
literal|0
expr_stmt|;
comment|/* Reset parse state. */
name|REPEATCC
expr_stmt|;
comment|/* Put it back for next read. */
name|tagdelsw
operator|=
literal|0
expr_stmt|;
comment|/* Tag had no closing delimiter. */
name|etisw
operator|=
literal|0
expr_stmt|;
comment|/* Don't flag stack entry. */
return|return;
case|case
name|TAGO
case|:
comment|/* Tag closing implied by TAGO. */
if|if
condition|(
operator|!
name|sd
operator|.
name|shorttag
condition|)
name|synerr
argument_list|(
literal|193
argument_list|,
name|pcb
argument_list|)
expr_stmt|;
name|REPEATCC
expr_stmt|;
comment|/* Put it back for next read. */
name|tagdelsw
operator|=
literal|0
expr_stmt|;
comment|/* Tag had no closing delimiter. */
case|case
name|TAGC
case|:
comment|/* Normal close. */
default|default:
comment|/* Invalid character (msg was sent). */
name|etisw
operator|=
literal|0
expr_stmt|;
comment|/* Don't flag stack entry. */
return|return;
block|}
block|}
end_function

begin_comment
comment|/* STAG: Check whether a start-tag is valid at this point in the document          structure, or whether other tags must precede it.          Special case processing is done for the fake tag, #CDATA, as          it is never stacked. */
end_comment

begin_function
name|int
name|stag
parameter_list|(
name|dataret
parameter_list|)
name|int
name|dataret
decl_stmt|;
comment|/* Data pending: DAF_ REF_ 0=not #PCDATA. */
block|{
name|int
name|rc
decl_stmt|,
name|realrc
decl_stmt|;
comment|/* Return code from context or other test. */
name|int
name|mexts
init|=
literal|0
decl_stmt|;
comment|/*>0=stack level of minus grp; -1=plus; 0=none.*/
name|badresw
operator|=
name|pexsw
operator|=
literal|0
expr_stmt|;
comment|/* If real element (i.e., not #PCDATA) set mexts and test if empty. */
if|if
condition|(
name|dataret
operator|==
literal|0
condition|)
block|{
name|mexts
operator|=
name|pexmex
argument_list|(
name|newetd
argument_list|)
expr_stmt|;
comment|/* If element is declared empty, it is same as a conref. */
if|if
condition|(
name|GET
argument_list|(
name|newetd
operator|->
name|etdmod
operator|->
name|ttype
argument_list|,
name|MNONE
argument_list|)
condition|)
name|conrefsw
operator|=
name|TAGREF
expr_stmt|;
block|}
if|if
condition|(
name|GET
argument_list|(
name|tags
index|[
name|ts
index|]
operator|.
name|tetd
operator|->
name|etdmod
operator|->
name|ttype
argument_list|,
name|MANY
argument_list|)
condition|)
name|rc
operator|=
name|mexts
operator|>
literal|0
condition|?
name|RCMEX
else|:
name|RCHIT
expr_stmt|;
else|else
name|rc
operator|=
name|context
argument_list|(
name|newetd
argument_list|,
name|tags
index|[
name|ts
index|]
operator|.
name|tetd
operator|->
name|etdmod
argument_list|,
name|tags
index|[
name|ts
index|]
operator|.
name|tpos
argument_list|,
operator|&
name|tags
index|[
name|ts
index|]
operator|.
name|status
argument_list|,
name|mexts
argument_list|)
expr_stmt|;
name|TRACESTG
argument_list|(
name|newetd
argument_list|,
name|dataret
argument_list|,
name|rc
argument_list|,
name|nextetd
argument_list|,
name|mexts
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|rc
condition|)
block|{
case|case
name|RCEND
case|:
comment|/* End current element, then retry start-tag. */
if|if
condition|(
name|ts
operator|<
literal|1
condition|)
name|realrc
operator|=
name|RCMISS
expr_stmt|;
else|else
name|realrc
operator|=
name|RCEND
expr_stmt|;
break|break;
case|case
name|RCREQ
case|:
comment|/* Stack compulsory GI, then retry start-tag. */
name|realrc
operator|=
name|RCREQ
expr_stmt|;
break|break;
case|case
name|RCMISS
case|:
comment|/* Start-tag invalid (#PCDATA or real). */
if|if
condition|(
name|ts
operator|>
literal|0
operator|&&
name|GET
argument_list|(
name|tags
index|[
name|ts
index|]
operator|.
name|tetd
operator|->
name|etdmod
operator|->
name|ttype
argument_list|,
name|MANY
argument_list|)
condition|)
name|realrc
operator|=
name|RCEND
expr_stmt|;
else|else
name|realrc
operator|=
name|RCMISS
expr_stmt|;
break|break;
case|case
name|RCMEX
case|:
comment|/* Start-tag invalid (minus exception). */
name|etagimct
operator|=
name|ts
operator|-
name|mexts
expr_stmt|;
name|realrc
operator|=
name|RCEND
expr_stmt|;
break|break;
case|case
name|RCHITMEX
case|:
comment|/* Invalid minus exclusion for required element. */
name|sgmlerr
argument_list|(
literal|216
argument_list|,
operator|&
name|pcbstag
argument_list|,
name|NEWGI
argument_list|,
name|tags
index|[
name|mexts
index|]
operator|.
name|tetd
operator|->
name|etdgi
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* fall through */
case|case
name|RCHIT
case|:
comment|/* Start-tag was valid. */
name|realrc
operator|=
name|RCHIT
expr_stmt|;
break|break;
case|case
name|RCPEX
case|:
comment|/* Start-tag valid only because of plus exception. */
name|pexsw
operator|=
name|TAGPEX
expr_stmt|;
name|realrc
operator|=
name|RCHIT
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
switch|switch
condition|(
name|realrc
condition|)
block|{
case|case
name|RCEND
case|:
comment|/* End current element, then retry start-tag. */
if|if
condition|(
name|didreq
condition|)
name|sgmlerr
argument_list|(
literal|07
argument_list|,
operator|&
name|pcbstag
argument_list|,
name|nextetd
operator|->
name|etdgi
operator|+
literal|1
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|didreq
operator|=
literal|0
expr_stmt|;
comment|/* No required start-tag done. */
name|dostag
operator|=
literal|1
expr_stmt|;
name|etiswsv
operator|=
name|etisw
expr_stmt|;
comment|/* Save real start-tag status. */
name|conrefsv
operator|=
name|conrefsw
expr_stmt|;
comment|/* Save real start-tag conref. */
name|conrefsw
operator|=
literal|0
expr_stmt|;
comment|/* Current element is not empty. */
name|etagmin
operator|=
name|MINSTAG
expr_stmt|;
name|destack
argument_list|()
expr_stmt|;
comment|/* Process omitted end-tag. */
return|return
name|ETG_
return|;
case|case
name|RCREQ
case|:
comment|/* Stack compulsory GI, then retry start-tag. */
if|if
condition|(
operator|!
name|BADPTR
argument_list|(
name|nextetd
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|mexts
operator|=
name|pexmex
argument_list|(
name|nextetd
argument_list|)
operator|)
operator|>
literal|0
condition|)
name|sgmlerr
argument_list|(
name|E_MEXERR
argument_list|,
operator|&
name|pcbstag
argument_list|,
name|nextetd
operator|->
name|etdgi
operator|+
literal|1
argument_list|,
name|tags
index|[
name|mexts
index|]
operator|.
name|tetd
operator|->
name|etdgi
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nextetd
operator|->
name|etdmod
condition|)
block|{
name|sgmlerr
argument_list|(
literal|53
argument_list|,
operator|&
name|pcbstag
argument_list|,
name|nextetd
operator|->
name|etdgi
operator|+
literal|1
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|etdset
argument_list|(
name|nextetd
argument_list|,
operator|(
name|UNCH
operator|)
name|SMO
operator|+
name|EMO
operator|+
name|ETDOCC
argument_list|,
operator|&
name|undechdr
argument_list|,
operator|(
name|PETD
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|PETD
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|PECB
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
operator|++
name|ds
operator|.
name|etdercnt
expr_stmt|;
name|TRACEETD
argument_list|(
name|nextetd
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|BITOFF
argument_list|(
name|nextetd
operator|->
name|etdmin
argument_list|,
name|SMO
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|BADPTR
argument_list|(
name|stagreal
argument_list|)
condition|)
name|sgmlerr
argument_list|(
literal|21
argument_list|,
operator|&
name|pcbstag
argument_list|,
name|nextetd
operator|->
name|etdgi
operator|+
literal|1
argument_list|,
name|stagreal
operator|->
name|etdgi
operator|+
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|stagreal
operator|==
name|ETDCDATA
condition|)
name|sgmlerr
argument_list|(
literal|49
argument_list|,
operator|&
name|pcbstag
argument_list|,
name|nextetd
operator|->
name|etdgi
operator|+
literal|1
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
else|else
name|sgmlerr
argument_list|(
literal|50
argument_list|,
operator|&
name|pcbstag
argument_list|,
name|nextetd
operator|->
name|etdgi
operator|+
literal|1
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
name|didreq
operator|=
literal|1
expr_stmt|;
comment|/* Required start-tag done. */
name|dostag
operator|=
literal|1
expr_stmt|;
name|etiswsv
operator|=
name|etisw
expr_stmt|;
comment|/* Save real start-tag status. */
name|etisw
operator|=
literal|0
expr_stmt|;
name|conrefsv
operator|=
name|conrefsw
expr_stmt|;
comment|/* Save real start-tag conref. */
comment|/* If element is declared empty, it is same as a conref. */
name|conrefsw
operator|=
operator|(
name|GET
argument_list|(
name|nextetd
operator|->
name|etdmod
operator|->
name|ttype
argument_list|,
name|MNONE
argument_list|)
operator|)
condition|?
name|TAGREF
else|:
literal|0
expr_stmt|;
name|stack
argument_list|(
name|nextetd
argument_list|)
expr_stmt|;
comment|/* Process omitted start-tag. */
return|return
name|STG_
return|;
case|case
name|RCMISS
case|:
comment|/* Start-tag invalid (#PCDATA or actual). */
name|dostag
operator|=
literal|0
expr_stmt|;
name|contersw
operator||=
literal|1
expr_stmt|;
name|didreq
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dataret
condition|)
block|{
if|if
condition|(
name|dataret
operator|==
name|REF_
condition|)
name|badresw
operator|=
literal|1
expr_stmt|;
else|else
name|sgmlerr
argument_list|(
name|E_CHARS
argument_list|,
name|conpcb
argument_list|,
name|tags
index|[
name|ts
index|]
operator|.
name|tetd
operator|->
name|etdgi
operator|+
literal|1
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
name|dataret
return|;
block|}
name|sgmlerr
argument_list|(
name|E_CONTEXT
argument_list|,
operator|&
name|pcbstag
argument_list|,
name|NEWGI
argument_list|,
name|tags
index|[
name|ts
index|]
operator|.
name|tetd
operator|->
name|etdgi
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|stagmin
operator|!=
name|MINNULL
condition|)
name|stagmin
operator|=
name|MINNONE
expr_stmt|;
name|stack
argument_list|(
name|newetd
argument_list|)
expr_stmt|;
return|return
name|STG_
return|;
case|case
name|RCHIT
case|:
comment|/* Start-tag was valid. */
name|dostag
operator|=
literal|0
expr_stmt|;
name|didreq
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dataret
condition|)
return|return
name|dataret
return|;
name|stack
argument_list|(
name|newetd
argument_list|)
expr_stmt|;
return|return
name|STG_
return|;
block|}
return|return
name|NOP_
return|;
comment|/* To avoid Borland C++ warning */
block|}
end_function

begin_comment
comment|/* PEXMEX: See if a GI is in a plus or minus exception group on the stack.            If in a minus, returns stack level of minus group; otherwise,            returns -1 if in a plus and not a minus, and zero if in neither. */
end_comment

begin_function
name|int
name|pexmex
parameter_list|(
name|curetd
parameter_list|)
name|struct
name|etd
modifier|*
name|curetd
decl_stmt|;
comment|/* The etd for this GI. */
block|{
name|int
name|tsl
decl_stmt|;
comment|/* Temporary stack level for looping. */
name|int
name|pex
init|=
literal|0
decl_stmt|;
comment|/* 1=found in plus grp; 0=not. */
for|for
control|(
name|tsl
operator|=
name|ts
init|;
name|tsl
operator|>
literal|0
condition|;
operator|--
name|tsl
control|)
block|{
if|if
condition|(
name|tags
index|[
name|tsl
index|]
operator|.
name|tetd
operator|->
name|etdmex
operator|&&
name|ingrp
argument_list|(
name|tags
index|[
name|tsl
index|]
operator|.
name|tetd
operator|->
name|etdmex
argument_list|,
name|curetd
argument_list|)
condition|)
return|return
operator|(
name|tsl
operator|)
return|;
if|if
condition|(
name|tags
index|[
name|tsl
index|]
operator|.
name|tetd
operator|->
name|etdpex
operator|&&
name|ingrp
argument_list|(
name|tags
index|[
name|tsl
index|]
operator|.
name|tetd
operator|->
name|etdpex
argument_list|,
name|curetd
argument_list|)
condition|)
name|pex
operator|=
operator|-
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|pex
operator|)
return|;
block|}
end_function

begin_comment
comment|/* STACK: Add a new entry to the tag stack.           If there is no room, issue a message and reuse last position. */
end_comment

begin_function
name|VOID
name|stack
parameter_list|(
name|curetd
parameter_list|)
name|struct
name|etd
modifier|*
name|curetd
decl_stmt|;
comment|/* The etd for this entry. */
block|{
comment|/* Stack the new element type definition (error if no room). */
if|if
condition|(
operator|++
name|ts
operator|>
name|TAGLVL
condition|)
name|sgmlerr
argument_list|(
name|E_STAGMAX
argument_list|,
name|conpcb
argument_list|,
name|curetd
operator|->
name|etdgi
operator|+
literal|1
argument_list|,
name|tags
index|[
operator|--
name|ts
index|]
operator|.
name|tetd
operator|->
name|etdgi
operator|+
literal|1
argument_list|)
expr_stmt|;
name|tags
index|[
name|ts
index|]
operator|.
name|tetd
operator|=
name|curetd
expr_stmt|;
comment|/* Set flags: plus exception + tag had ETI + context error + empty. */
name|tags
index|[
name|ts
index|]
operator|.
name|tflags
operator|=
operator|(
name|UNCH
operator|)
name|pexsw
operator|+
name|etisw
operator|+
name|contersw
operator|+
name|conrefsw
expr_stmt|;
name|contersw
operator|=
literal|0
expr_stmt|;
comment|/* If tag had ETI, update ETI counter and enable NET if first ETI. */
if|if
condition|(
name|etisw
operator|&&
operator|++
name|etictr
operator|==
literal|1
condition|)
name|lexcon
index|[
name|lex
operator|.
name|d
operator|.
name|net
index|]
operator|=
name|lexcnm
index|[
name|lex
operator|.
name|d
operator|.
name|net
index|]
operator|=
name|lex
operator|.
name|l
operator|.
name|net
expr_stmt|;
comment|/* If etd has ALT table, use it; otherwise, use last element's ALT. */
if|if
condition|(
name|curetd
operator|->
name|etdsrm
condition|)
block|{
if|if
condition|(
name|curetd
operator|->
name|etdsrm
operator|!=
name|SRMNULL
operator|&&
name|curetd
operator|->
name|etdsrm
index|[
literal|0
index|]
operator|==
name|NULL
condition|)
block|{
comment|/* Map hasn't been defined.  Ignore it. 		  We already gave an error. */
name|curetd
operator|->
name|etdsrm
operator|=
literal|0
expr_stmt|;
name|tags
index|[
name|ts
index|]
operator|.
name|tsrm
operator|=
name|tags
index|[
name|ts
operator|-
literal|1
index|]
operator|.
name|tsrm
expr_stmt|;
block|}
else|else
name|tags
index|[
name|ts
index|]
operator|.
name|tsrm
operator|=
name|curetd
operator|->
name|etdsrm
expr_stmt|;
block|}
else|else
name|tags
index|[
name|ts
index|]
operator|.
name|tsrm
operator|=
name|tags
index|[
name|ts
operator|-
literal|1
index|]
operator|.
name|tsrm
expr_stmt|;
comment|/* Initialize rest of stack entry. */
name|tags
index|[
name|ts
index|]
operator|.
name|status
operator|=
literal|0
expr_stmt|;
name|tags
index|[
name|ts
index|]
operator|.
name|tpos
index|[
literal|0
index|]
operator|.
name|g
operator|=
literal|1
expr_stmt|;
comment|/* M: Index in model of next token to test.*/
name|tags
index|[
name|ts
index|]
operator|.
name|tpos
index|[
literal|0
index|]
operator|.
name|t
operator|=
literal|1
expr_stmt|;
comment|/* P: Index in tpos of current group. */
name|HITCLEAR
argument_list|(
name|tags
index|[
name|ts
index|]
operator|.
name|tpos
index|[
literal|0
index|]
operator|.
name|h
argument_list|)
expr_stmt|;
name|tags
index|[
name|ts
index|]
operator|.
name|tpos
index|[
literal|1
index|]
operator|.
name|g
operator|=
literal|1
expr_stmt|;
comment|/* Index of group in model (dummy grp). */
name|tags
index|[
name|ts
index|]
operator|.
name|tpos
index|[
literal|1
index|]
operator|.
name|t
operator|=
literal|1
expr_stmt|;
comment|/* 1st token is next in grp to be tested. */
name|HITCLEAR
argument_list|(
name|tags
index|[
name|ts
index|]
operator|.
name|tpos
index|[
literal|1
index|]
operator|.
name|h
argument_list|)
expr_stmt|;
comment|/* No hits yet as yet. */
name|TRACESTK
argument_list|(
operator|&
name|tags
index|[
name|ts
index|]
argument_list|,
name|ts
argument_list|,
name|etictr
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ETAG: Check validity of an end-tag by seeing if it matches any tag          on the stack.  If so, return the offset of the match from the          current entry (0=current).  If there is no match, issue a message          and return an error code (-1).          If the newetd is ETDNET, a NET delimiter was found, so check for          a tag that ended with ETI instead of a matching GI. */
end_comment

begin_function
name|int
name|etag
parameter_list|()
block|{
name|int
name|tsl
init|=
name|ts
operator|+
literal|1
decl_stmt|;
comment|/* Temporary stack level for looping. */
comment|/* See if end-tag is anywhere on stack, starting at current entry. */
while|while
condition|(
operator|--
name|tsl
condition|)
block|{
if|if
condition|(
name|newetd
operator|!=
name|ETDNET
condition|?
name|newetd
operator|==
name|tags
index|[
name|tsl
index|]
operator|.
name|tetd
else|:
name|tags
index|[
name|tsl
index|]
operator|.
name|tflags
condition|)
block|{
name|TRACEETG
argument_list|(
operator|&
name|tags
index|[
name|ts
index|]
argument_list|,
name|newetd
argument_list|,
name|tsl
argument_list|,
name|ts
operator|-
name|tsl
argument_list|)
expr_stmt|;
return|return
operator|(
name|ts
operator|-
name|tsl
operator|)
return|;
block|}
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* End-tag didn't match any start-tag. */
block|}
end_function

begin_comment
comment|/* DESTACK:             Call ECONTEXT to see if element can be ended at this point.             and issue message if there are required tags left.             Remove the current entry from the tag stack.             Issue an error if the destacked element was not minimizable             and its end-tag was omitted. */
end_comment

begin_function
name|VOID
name|destack
parameter_list|()
block|{
specifier|register
name|int
name|ecode
init|=
literal|0
decl_stmt|;
comment|/* Error code (0=o.k.). */
name|UNCH
modifier|*
name|eparm2
init|=
name|NULL
decl_stmt|;
comment|/* Second parameter of error message. */
specifier|register
name|int
name|minmsgsw
decl_stmt|;
comment|/* 1=message if tag omitted; 0=no message. */
comment|/* If element has a content model (i.e., not a keyword) and there         are required tags left, and no CONREF attribute was specified,         issue an error message.      */
name|lastetd
operator|=
name|tags
index|[
name|ts
index|]
operator|.
name|tetd
expr_stmt|;
if|if
condition|(
operator|!
name|GET
argument_list|(
name|tags
index|[
name|ts
index|]
operator|.
name|tetd
operator|->
name|etdmod
operator|->
name|ttype
argument_list|,
name|MKEYWORD
argument_list|)
operator|&&
operator|!
name|conrefsw
operator|&&
operator|!
name|econtext
argument_list|(
name|tags
index|[
name|ts
index|]
operator|.
name|tetd
operator|->
name|etdmod
argument_list|,
name|tags
index|[
name|ts
index|]
operator|.
name|tpos
argument_list|,
operator|&
name|tags
index|[
name|ts
index|]
operator|.
name|status
argument_list|)
condition|)
block|{
if|if
condition|(
name|BADPTR
argument_list|(
name|nextetd
argument_list|)
condition|)
name|sgmlerr
argument_list|(
literal|54
argument_list|,
name|conpcb
argument_list|,
name|tags
index|[
name|ts
index|]
operator|.
name|tetd
operator|->
name|etdgi
operator|+
literal|1
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
else|else
name|sgmlerr
argument_list|(
literal|30
argument_list|,
name|conpcb
argument_list|,
name|tags
index|[
name|ts
index|]
operator|.
name|tetd
operator|->
name|etdgi
operator|+
literal|1
argument_list|,
name|nextetd
operator|->
name|etdgi
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* If the current tag ended with ETI, decrement the etictr.         If etictr is now zero, disable the NET delimiter.      */
if|if
condition|(
name|GET
argument_list|(
name|tags
index|[
name|ts
operator|--
index|]
operator|.
name|tflags
argument_list|,
name|TAGNET
argument_list|)
operator|&&
operator|--
name|etictr
operator|==
literal|0
condition|)
name|lexcon
index|[
name|lex
operator|.
name|d
operator|.
name|net
index|]
operator|=
name|lexcnm
index|[
name|lex
operator|.
name|d
operator|.
name|net
index|]
operator|=
name|lex
operator|.
name|l
operator|.
name|nonet
expr_stmt|;
name|minmsgsw
operator|=
name|BITOFF
argument_list|(
name|tags
index|[
name|ts
operator|+
literal|1
index|]
operator|.
name|tetd
operator|->
name|etdmin
argument_list|,
name|EMO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|conrefsw
operator|&&
name|minmsgsw
operator|&&
operator|(
name|etagimsw
operator|||
name|etagmin
operator|==
name|MINETAG
operator|)
condition|)
block|{
comment|/* Minimization caused by NET delimiter. */
if|if
condition|(
name|BADPTR
argument_list|(
name|etagreal
argument_list|)
condition|)
name|ecode
operator|=
literal|46
expr_stmt|;
comment|/* Minimization caused by a containing end-tag. */
else|else
block|{
name|ecode
operator|=
literal|20
expr_stmt|;
name|eparm2
operator|=
name|etagreal
operator|->
name|etdgi
operator|+
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|conrefsw
operator|&&
name|etagmin
operator|==
name|MINSTAG
operator|&&
operator|(
name|minmsgsw
operator|||
name|ts
operator|<=
literal|0
operator|)
condition|)
block|{
comment|/* Minimization caused by out-of-context start-tag. */
if|if
condition|(
operator|!
name|BADPTR
argument_list|(
name|stagreal
argument_list|)
condition|)
block|{
name|ecode
operator|=
name|ts
operator|>
literal|0
condition|?
literal|39
else|:
literal|89
expr_stmt|;
name|eparm2
operator|=
name|stagreal
operator|->
name|etdgi
operator|+
literal|1
expr_stmt|;
block|}
comment|/* Minimization caused by out-of-context data. */
elseif|else
if|if
condition|(
name|stagreal
operator|==
name|ETDCDATA
condition|)
name|ecode
operator|=
name|ts
operator|>
literal|0
condition|?
literal|47
else|:
literal|95
expr_stmt|;
comment|/* Minimization caused by out-of-context short start-tag. */
else|else
name|ecode
operator|=
name|ts
operator|>
literal|0
condition|?
literal|48
else|:
literal|96
expr_stmt|;
if|if
condition|(
name|ts
operator|<=
literal|0
operator|&&
name|ecode
condition|)
name|eodsw
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|ecode
condition|)
name|sgmlerr
argument_list|(
operator|(
name|UNS
operator|)
name|ecode
argument_list|,
name|conpcb
argument_list|,
name|tags
index|[
name|ts
operator|+
literal|1
index|]
operator|.
name|tetd
operator|->
name|etdgi
operator|+
literal|1
argument_list|,
name|eparm2
argument_list|)
expr_stmt|;
comment|/* TEMP: See if parser bug caused stack to go below zero. */
elseif|else
if|if
condition|(
name|ts
operator|<
literal|0
condition|)
block|{
name|sgmlerr
argument_list|(
literal|64
argument_list|,
name|conpcb
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|ts
operator|=
literal|0
expr_stmt|;
block|}
name|TRACEDSK
argument_list|(
operator|&
name|tags
index|[
name|ts
index|]
argument_list|,
operator|&
name|tags
index|[
name|ts
operator|+
literal|1
index|]
argument_list|,
name|ts
argument_list|,
name|etictr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ts
operator|==
literal|0
condition|)
block|{
name|docelsw
operator|=
literal|1
expr_stmt|;
comment|/* Finished document element. */
if|if
condition|(
name|es
operator|>
literal|0
condition|)
name|sgmlerr
argument_list|(
literal|231
argument_list|,
name|conpcb
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|UNCH
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Local Variables: c-indent-level: 5 c-continued-statement-offset: 5 c-brace-offset: -5 c-argdecl-indent: 0 c-label-offset: -5 comment-column: 30 End: */
end_comment

end_unit

