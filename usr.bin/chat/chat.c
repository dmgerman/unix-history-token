begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *	Chat -- a program for automatic session establishment (i.e. dial  *		the phone and log in).  *  * Standard termination codes:  *  0 - successful completion of the script  *  1 - invalid argument, expect string too large, etc.  *  2 - error on an I/O operation or fatal error condition.  *  3 - timeout waiting for a simple string.  *  4 - the first string declared as "ABORT"  *  5 - the second string declared as "ABORT"  *  6 - ... and so on for successive ABORT strings.  *  *	This software is in the public domain.  *  * -----------------  *	added -T and -U option and \T and \U substitution to pass a phone  *	number into chat script. Two are needed for some ISDN TA applications.  *	Keith Dart<kdart@cisco.com>  *	  *  *	Added SAY keyword to send output to stderr.  *      This allows to turn ECHO OFF and to output specific, user selected,  *      text to give progress messages. This best works when stderr  *      exists (i.e.: pppd in nodetach mode).  *  * 	Added HANGUP directives to allow for us to be called  *      back. When HANGUP is set to NO, chat will not hangup at HUP signal.  *      We rely on timeouts in that case.  *  *      Added CLR_ABORT to clear previously set ABORT string. This has been  *      dictated by the HANGUP above as "NO CARRIER" (for example) must be  *      an ABORT condition until we know the other host is going to close  *      the connection for call back. As soon as we have completed the  *      first stage of the call back sequence, "NO CARRIER" is a valid, non  *      fatal string. As soon as we got called back (probably get "CONNECT"),  *      we should re-arm the ABORT "NO CARRIER". Hence the CLR_ABORT command.  *      Note that CLR_ABORT packs the abort_strings[] array so that we do not  *      have unused entries not being reclaimed.  *  *      In the same vein as above, added CLR_REPORT keyword.  *  *      Allow for comments. Line starting with '#' are comments and are  *      ignored. If a '#' is to be expected as the first character, the   *      expect string must be quoted.  *  *  *		Francis Demierre<Francis@SwissMail.Com>  * 		Thu May 15 17:15:40 MET DST 1997  *  *  *      Added -r "report file" switch& REPORT keyword.  *              Robert Geer<bgeer@xmission.com>  *  *      Added -s "use stderr" and -S "don't use syslog" switches.  *              June 18, 1997  *              Karl O. Pinc<kop@meme.com>  *  *  *	Added -e "echo" switch& ECHO keyword  *		Dick Streefland<dicks@tasking.nl>  *  *  *	Considerable updates and modifications by  *		Al Longyear<longyear@pobox.com>  *		Paul Mackerras<paulus@cs.anu.edu.au>  *  *  *	The original author is:  *  *		Karl Fox<karl@MorningStar.Com>  *		Morning Star Technologies, Inc.  *		1760 Zollinger Road  *		Columbus, OH  43221  *		(614)451-1883  *  *  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|TERMIO
end_ifndef

begin_undef
undef|#
directive|undef
name|TERMIOS
end_undef

begin_define
define|#
directive|define
name|TERMIOS
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|TERMIO
end_ifdef

begin_include
include|#
directive|include
file|<termio.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|TERMIOS
end_ifdef

begin_include
include|#
directive|include
file|<termios.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|STR_LEN
value|1024
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|SIGTYPE
end_ifndef

begin_define
define|#
directive|define
name|SIGTYPE
value|void
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|O_NONBLOCK
end_ifndef

begin_define
define|#
directive|define
name|O_NONBLOCK
value|O_NDELAY
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SUNOS
end_ifdef

begin_decl_stmt
specifier|extern
name|int
name|sys_nerr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|sys_errlist
index|[]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|memmove
parameter_list|(
name|to
parameter_list|,
name|from
parameter_list|,
name|n
parameter_list|)
value|bcopy(from, to, n)
end_define

begin_define
define|#
directive|define
name|strerror
parameter_list|(
name|n
parameter_list|)
value|((unsigned)(n)< sys_nerr? sys_errlist[(n)] :\ 				 "unknown error")
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*************** Micro getopt() *********************************************/
end_comment

begin_define
define|#
directive|define
name|OPTION
parameter_list|(
name|c
parameter_list|,
name|v
parameter_list|)
value|(_O&2&&**v?*(*v)++:!c||_O&4?0:(!(_O&1)&& \ 				(--c,++v),_O=4,c&&**v=='-'&&v[0][1]?*++*v=='-'\&&!v[0][1]?(--c,++v,0):(_O=2,*(*v)++):0))
end_define

begin_define
define|#
directive|define
name|OPTARG
parameter_list|(
name|c
parameter_list|,
name|v
parameter_list|)
value|(_O&2?**v||(++v,--c)?(_O=1,--c,*v++): \ 				(_O=4,(char*)0):(char*)0)
end_define

begin_define
define|#
directive|define
name|OPTONLYARG
parameter_list|(
name|c
parameter_list|,
name|v
parameter_list|)
value|(_O&2&&**v?(_O=1,--c,*v++):(char*)0)
end_define

begin_define
define|#
directive|define
name|ARG
parameter_list|(
name|c
parameter_list|,
name|v
parameter_list|)
value|(c?(--c,*v++):(char*)0)
end_define

begin_decl_stmt
specifier|static
name|int
name|_O
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Internal state */
end_comment

begin_comment
comment|/*************** Micro getopt() *********************************************/
end_comment

begin_define
define|#
directive|define
name|MAX_ABORTS
value|50
end_define

begin_define
define|#
directive|define
name|MAX_REPORTS
value|50
end_define

begin_define
define|#
directive|define
name|DEFAULT_CHAT_TIMEOUT
value|45
end_define

begin_decl_stmt
name|int
name|echo
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|verbose
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|to_log
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|to_stderr
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Verbose
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|quiet
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|report
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|exit_code
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|report_fp
init|=
operator|(
name|FILE
operator|*
operator|)
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|report_file
init|=
operator|(
name|char
operator|*
operator|)
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|chat_file
init|=
operator|(
name|char
operator|*
operator|)
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|phone_num
init|=
operator|(
name|char
operator|*
operator|)
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|phone_num2
init|=
operator|(
name|char
operator|*
operator|)
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|timeout
init|=
name|DEFAULT_CHAT_TIMEOUT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|have_tty_parameters
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|TERMIO
end_ifdef

begin_define
define|#
directive|define
name|term_parms
value|struct termio
end_define

begin_define
define|#
directive|define
name|get_term_param
parameter_list|(
name|param
parameter_list|)
value|ioctl(0, TCGETA, param)
end_define

begin_define
define|#
directive|define
name|set_term_param
parameter_list|(
name|param
parameter_list|)
value|ioctl(0, TCSETA, param)
end_define

begin_decl_stmt
name|struct
name|termio
name|saved_tty_parameters
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|TERMIOS
end_ifdef

begin_define
define|#
directive|define
name|term_parms
value|struct termios
end_define

begin_define
define|#
directive|define
name|get_term_param
parameter_list|(
name|param
parameter_list|)
value|tcgetattr(0, param)
end_define

begin_define
define|#
directive|define
name|set_term_param
parameter_list|(
name|param
parameter_list|)
value|tcsetattr(0, TCSANOW, param)
end_define

begin_decl_stmt
name|struct
name|termios
name|saved_tty_parameters
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|char
modifier|*
name|abort_string
index|[
name|MAX_ABORTS
index|]
decl_stmt|,
modifier|*
name|fail_reason
init|=
operator|(
name|char
operator|*
operator|)
literal|0
decl_stmt|,
name|fail_buffer
index|[
literal|50
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|n_aborts
init|=
literal|0
decl_stmt|,
name|abort_next
init|=
literal|0
decl_stmt|,
name|timeout_next
init|=
literal|0
decl_stmt|,
name|echo_next
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|clear_abort_next
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|report_string
index|[
name|MAX_REPORTS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|report_buffer
index|[
literal|50
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|n_reports
init|=
literal|0
decl_stmt|,
name|report_next
init|=
literal|0
decl_stmt|,
name|report_gathering
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|clear_report_next
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|say_next
init|=
literal|0
decl_stmt|,
name|hup_next
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
modifier|*
name|dup_mem
parameter_list|(
name|void
modifier|*
name|b
parameter_list|,
name|size_t
name|c
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
modifier|*
name|copy_of
parameter_list|(
name|char
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|logf
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|fatal
parameter_list|(
name|int
name|code
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|SIGTYPE
name|sigalrm
parameter_list|(
name|int
name|signo
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|SIGTYPE
name|sigint
parameter_list|(
name|int
name|signo
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|SIGTYPE
name|sigterm
parameter_list|(
name|int
name|signo
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|SIGTYPE
name|sighup
parameter_list|(
name|int
name|signo
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|unalarm
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|init
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|set_tty_parameters
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|echo_stderr
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|break_sequence
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|terminate
parameter_list|(
name|int
name|status
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|do_file
parameter_list|(
name|char
modifier|*
name|chat_file
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|get_string
parameter_list|(
specifier|register
name|char
modifier|*
name|string
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|put_string
parameter_list|(
specifier|register
name|char
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|write_char
parameter_list|(
name|int
name|c
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|put_char
parameter_list|(
name|int
name|c
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|get_char
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|chat_send
parameter_list|(
specifier|register
name|char
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|character
parameter_list|(
name|int
name|c
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|chat_expect
parameter_list|(
specifier|register
name|char
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|clean
parameter_list|(
specifier|register
name|char
modifier|*
name|s
parameter_list|,
name|int
name|sending
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|break_sequence
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|terminate
parameter_list|(
name|int
name|status
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|pack_array
parameter_list|(
name|char
modifier|*
modifier|*
name|array
parameter_list|,
name|int
name|end
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|expect_strtok
parameter_list|(
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|vfmtmsg
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|va_list
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* vsprintf++ */
end_comment

begin_function_decl
name|int
name|main
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
index|[]
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
modifier|*
name|dup_mem
parameter_list|(
name|b
parameter_list|,
name|c
parameter_list|)
name|void
modifier|*
name|b
decl_stmt|;
name|size_t
name|c
decl_stmt|;
block|{
name|void
modifier|*
name|ans
init|=
name|malloc
argument_list|(
name|c
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ans
condition|)
name|fatal
argument_list|(
literal|2
argument_list|,
literal|"memory error!"
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ans
argument_list|,
name|b
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return
name|ans
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|copy_of
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
return|return
name|dup_mem
argument_list|(
name|s
argument_list|,
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * chat [ -v ] [-T number] [-U number] [ -t timeout ] [ -f chat-file ] \  * [ -r report-file ] \  *		[...[[expect[-say[-expect...]] say expect[-say[-expect]] ...]]]  *  *	Perform a UUCP-dialer-like chat script on stdin and stdout.  */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|option
decl_stmt|;
name|char
modifier|*
name|arg
decl_stmt|;
name|tzset
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|option
operator|=
name|OPTION
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
switch|switch
condition|(
name|option
condition|)
block|{
case|case
literal|'e'
case|:
operator|++
name|echo
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
operator|++
name|verbose
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
operator|++
name|Verbose
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
operator|++
name|to_stderr
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|to_log
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
if|if
condition|(
operator|(
name|arg
operator|=
name|OPTARG
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|chat_file
operator|=
name|copy_of
argument_list|(
name|arg
argument_list|)
expr_stmt|;
else|else
name|usage
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
if|if
condition|(
operator|(
name|arg
operator|=
name|OPTARG
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|timeout
operator|=
name|atoi
argument_list|(
name|arg
argument_list|)
expr_stmt|;
else|else
name|usage
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|arg
operator|=
name|OPTARG
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
condition|)
block|{
if|if
condition|(
name|report_fp
operator|!=
name|NULL
condition|)
name|fclose
argument_list|(
name|report_fp
argument_list|)
expr_stmt|;
name|report_file
operator|=
name|copy_of
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|report_fp
operator|=
name|fopen
argument_list|(
name|report_file
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
if|if
condition|(
name|report_fp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
name|fprintf
argument_list|(
name|report_fp
argument_list|,
literal|"Opening \"%s\"...\n"
argument_list|,
name|report_file
argument_list|)
expr_stmt|;
name|report
operator|=
literal|1
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'T'
case|:
if|if
condition|(
operator|(
name|arg
operator|=
name|OPTARG
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|phone_num
operator|=
name|copy_of
argument_list|(
name|arg
argument_list|)
expr_stmt|;
else|else
name|usage
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'U'
case|:
if|if
condition|(
operator|(
name|arg
operator|=
name|OPTARG
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|phone_num2
operator|=
name|copy_of
argument_list|(
name|arg
argument_list|)
expr_stmt|;
else|else
name|usage
argument_list|()
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
comment|/*  * Default the report file to the stderr location  */
if|if
condition|(
name|report_fp
operator|==
name|NULL
condition|)
name|report_fp
operator|=
name|stderr
expr_stmt|;
if|if
condition|(
name|to_log
condition|)
block|{
ifdef|#
directive|ifdef
name|ultrix
name|openlog
argument_list|(
literal|"chat"
argument_list|,
name|LOG_PID
argument_list|)
expr_stmt|;
else|#
directive|else
name|openlog
argument_list|(
literal|"chat"
argument_list|,
name|LOG_PID
operator||
name|LOG_NDELAY
argument_list|,
name|LOG_LOCAL2
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|setlogmask
argument_list|(
name|LOG_UPTO
argument_list|(
name|LOG_INFO
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|setlogmask
argument_list|(
name|LOG_UPTO
argument_list|(
name|LOG_WARNING
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|init
argument_list|()
expr_stmt|;
if|if
condition|(
name|chat_file
operator|!=
name|NULL
condition|)
block|{
name|arg
operator|=
name|ARG
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|!=
name|NULL
condition|)
name|usage
argument_list|()
expr_stmt|;
else|else
name|do_file
argument_list|(
name|chat_file
argument_list|)
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
operator|(
name|arg
operator|=
name|ARG
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|chat_expect
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|arg
operator|=
name|ARG
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|chat_send
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
block|}
name|terminate
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  *  Process a chat script when read from a file.  */
end_comment

begin_function
name|void
name|do_file
parameter_list|(
name|chat_file
parameter_list|)
name|char
modifier|*
name|chat_file
decl_stmt|;
block|{
name|int
name|linect
decl_stmt|,
name|sendflg
decl_stmt|;
name|char
modifier|*
name|sp
decl_stmt|,
modifier|*
name|arg
decl_stmt|,
name|quote
decl_stmt|;
name|char
name|buf
index|[
name|STR_LEN
index|]
decl_stmt|;
name|FILE
modifier|*
name|cfp
decl_stmt|;
name|cfp
operator|=
name|fopen
argument_list|(
name|chat_file
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfp
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|1
argument_list|,
literal|"%s -- open failed: %m"
argument_list|,
name|chat_file
argument_list|)
expr_stmt|;
name|linect
operator|=
literal|0
expr_stmt|;
name|sendflg
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
name|STR_LEN
argument_list|,
name|cfp
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|sp
operator|=
name|strchr
argument_list|(
name|buf
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
condition|)
operator|*
name|sp
operator|=
literal|'\0'
expr_stmt|;
name|linect
operator|++
expr_stmt|;
name|sp
operator|=
name|buf
expr_stmt|;
comment|/* lines starting with '#' are comments. If a real '#'            is to be expected, it should be quoted .... */
if|if
condition|(
operator|*
name|sp
operator|==
literal|'#'
condition|)
continue|continue;
while|while
condition|(
operator|*
name|sp
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|*
name|sp
operator|==
literal|' '
operator|||
operator|*
name|sp
operator|==
literal|'\t'
condition|)
block|{
operator|++
name|sp
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|*
name|sp
operator|==
literal|'"'
operator|||
operator|*
name|sp
operator|==
literal|'\''
condition|)
block|{
name|quote
operator|=
operator|*
name|sp
operator|++
expr_stmt|;
name|arg
operator|=
name|sp
expr_stmt|;
while|while
condition|(
operator|*
name|sp
operator|!=
name|quote
condition|)
block|{
if|if
condition|(
operator|*
name|sp
operator|==
literal|'\0'
condition|)
name|fatal
argument_list|(
literal|1
argument_list|,
literal|"unterminated quote (line %d)"
argument_list|,
name|linect
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|sp
operator|++
operator|==
literal|'\\'
condition|)
block|{
if|if
condition|(
operator|*
name|sp
operator|!=
literal|'\0'
condition|)
operator|++
name|sp
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|arg
operator|=
name|sp
expr_stmt|;
while|while
condition|(
operator|*
name|sp
operator|!=
literal|'\0'
operator|&&
operator|*
name|sp
operator|!=
literal|' '
operator|&&
operator|*
name|sp
operator|!=
literal|'\t'
condition|)
operator|++
name|sp
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|sp
operator|!=
literal|'\0'
condition|)
operator|*
name|sp
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|sendflg
condition|)
name|chat_send
argument_list|(
name|arg
argument_list|)
expr_stmt|;
else|else
name|chat_expect
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|sendflg
operator|=
operator|!
name|sendflg
expr_stmt|;
block|}
block|}
name|fclose
argument_list|(
name|cfp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	We got an error parsing the command line.  */
end_comment

begin_function
specifier|static
name|void
name|usage
parameter_list|()
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ Usage: chat [-e] [-v] [-V] [-t timeout] [-r report-file] [-T phone-number]\n\      [-U phone-number2] {-f chat-file | chat-script}\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|char
name|line
index|[
literal|1024
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Send a message to syslog and/or stderr.  */
end_comment

begin_function
name|void
name|logf
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vfmtmsg
argument_list|(
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|,
name|fmt
argument_list|,
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|to_log
condition|)
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"%s"
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|to_stderr
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	Print an error message and terminate.  */
end_comment

begin_function
name|void
name|fatal
parameter_list|(
name|int
name|code
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vfmtmsg
argument_list|(
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|,
name|fmt
argument_list|,
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|to_log
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s"
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|to_stderr
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|terminate
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|int
name|alarmed
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|SIGTYPE
name|sigalrm
parameter_list|(
name|signo
parameter_list|)
name|int
name|signo
decl_stmt|;
block|{
name|int
name|flags
decl_stmt|;
name|alarm
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|alarmed
operator|=
literal|1
expr_stmt|;
comment|/* Reset alarm to avoid race window */
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|sigalrm
argument_list|)
expr_stmt|;
comment|/* that can cause hanging in read() */
if|if
condition|(
operator|(
name|flags
operator|=
name|fcntl
argument_list|(
literal|0
argument_list|,
name|F_GETFL
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|fatal
argument_list|(
literal|2
argument_list|,
literal|"Can't get file mode flags on stdin: %m"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fcntl
argument_list|(
literal|0
argument_list|,
name|F_SETFL
argument_list|,
name|flags
operator||
name|O_NONBLOCK
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|fatal
argument_list|(
literal|2
argument_list|,
literal|"Can't set file mode flags on stdin: %m"
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|logf
argument_list|(
literal|"alarm"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|unalarm
parameter_list|()
block|{
name|int
name|flags
decl_stmt|;
if|if
condition|(
operator|(
name|flags
operator|=
name|fcntl
argument_list|(
literal|0
argument_list|,
name|F_GETFL
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|fatal
argument_list|(
literal|2
argument_list|,
literal|"Can't get file mode flags on stdin: %m"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fcntl
argument_list|(
literal|0
argument_list|,
name|F_SETFL
argument_list|,
name|flags
operator|&
operator|~
name|O_NONBLOCK
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|fatal
argument_list|(
literal|2
argument_list|,
literal|"Can't set file mode flags on stdin: %m"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|SIGTYPE
name|sigint
parameter_list|(
name|signo
parameter_list|)
name|int
name|signo
decl_stmt|;
block|{
name|fatal
argument_list|(
literal|2
argument_list|,
literal|"SIGINT"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|SIGTYPE
name|sigterm
parameter_list|(
name|signo
parameter_list|)
name|int
name|signo
decl_stmt|;
block|{
name|fatal
argument_list|(
literal|2
argument_list|,
literal|"SIGTERM"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|SIGTYPE
name|sighup
parameter_list|(
name|signo
parameter_list|)
name|int
name|signo
decl_stmt|;
block|{
name|fatal
argument_list|(
literal|2
argument_list|,
literal|"SIGHUP"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|init
parameter_list|()
block|{
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|sigint
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|sigterm
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|sighup
argument_list|)
expr_stmt|;
name|set_tty_parameters
argument_list|()
expr_stmt|;
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|sigalrm
argument_list|)
expr_stmt|;
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|alarmed
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|set_tty_parameters
parameter_list|()
block|{
if|#
directive|if
name|defined
argument_list|(
name|get_term_param
argument_list|)
name|term_parms
name|t
decl_stmt|;
if|if
condition|(
name|get_term_param
argument_list|(
operator|&
name|t
argument_list|)
operator|<
literal|0
condition|)
name|fatal
argument_list|(
literal|2
argument_list|,
literal|"Can't get terminal parameters: %m"
argument_list|)
expr_stmt|;
name|saved_tty_parameters
operator|=
name|t
expr_stmt|;
name|have_tty_parameters
operator|=
literal|1
expr_stmt|;
name|t
operator|.
name|c_iflag
operator||=
name|IGNBRK
operator||
name|ISTRIP
operator||
name|IGNPAR
expr_stmt|;
name|t
operator|.
name|c_oflag
operator|=
literal|0
expr_stmt|;
name|t
operator|.
name|c_lflag
operator|=
literal|0
expr_stmt|;
name|t
operator|.
name|c_cc
index|[
name|VERASE
index|]
operator|=
name|t
operator|.
name|c_cc
index|[
name|VKILL
index|]
operator|=
literal|0
expr_stmt|;
name|t
operator|.
name|c_cc
index|[
name|VMIN
index|]
operator|=
literal|1
expr_stmt|;
name|t
operator|.
name|c_cc
index|[
name|VTIME
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|set_term_param
argument_list|(
operator|&
name|t
argument_list|)
operator|<
literal|0
condition|)
name|fatal
argument_list|(
literal|2
argument_list|,
literal|"Can't set terminal parameters: %m"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|break_sequence
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|TERMIOS
name|tcsendbreak
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|terminate
parameter_list|(
name|status
parameter_list|)
name|int
name|status
decl_stmt|;
block|{
name|echo_stderr
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|report_file
operator|!=
operator|(
name|char
operator|*
operator|)
literal|0
operator|&&
name|report_fp
operator|!=
operator|(
name|FILE
operator|*
operator|)
name|NULL
condition|)
block|{
comment|/*  * Allow the last of the report string to be gathered before we terminate.  */
if|if
condition|(
name|report_gathering
condition|)
block|{
name|int
name|c
decl_stmt|,
name|rep_len
decl_stmt|;
name|rep_len
operator|=
name|strlen
argument_list|(
name|report_buffer
argument_list|)
expr_stmt|;
while|while
condition|(
name|rep_len
operator|+
literal|1
operator|<=
sizeof|sizeof
argument_list|(
name|report_buffer
argument_list|)
condition|)
block|{
name|alarm
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|c
operator|=
name|get_char
argument_list|()
expr_stmt|;
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|0
operator|||
name|iscntrl
argument_list|(
name|c
argument_list|)
condition|)
break|break;
name|report_buffer
index|[
name|rep_len
index|]
operator|=
name|c
expr_stmt|;
operator|++
name|rep_len
expr_stmt|;
block|}
name|report_buffer
index|[
name|rep_len
index|]
operator|=
literal|0
expr_stmt|;
name|fprintf
argument_list|(
name|report_fp
argument_list|,
literal|"chat:  %s\n"
argument_list|,
name|report_buffer
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|verbose
condition|)
name|fprintf
argument_list|(
name|report_fp
argument_list|,
literal|"Closing \"%s\".\n"
argument_list|,
name|report_file
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|report_fp
argument_list|)
expr_stmt|;
name|report_fp
operator|=
operator|(
name|FILE
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|get_term_param
argument_list|)
if|if
condition|(
name|have_tty_parameters
condition|)
block|{
if|if
condition|(
name|set_term_param
argument_list|(
operator|&
name|saved_tty_parameters
argument_list|)
operator|<
literal|0
condition|)
name|fatal
argument_list|(
literal|2
argument_list|,
literal|"Can't restore terminal parameters: %m"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|exit
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	'Clean up' this string.  */
end_comment

begin_function
name|char
modifier|*
name|clean
parameter_list|(
name|s
parameter_list|,
name|sending
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|sending
decl_stmt|;
comment|/* set to 1 when sending (putting) this string. */
block|{
name|char
name|temp
index|[
name|STR_LEN
index|]
decl_stmt|,
name|cur_chr
decl_stmt|;
specifier|register
name|char
modifier|*
name|s1
decl_stmt|,
modifier|*
name|phchar
decl_stmt|;
name|int
name|add_return
init|=
name|sending
decl_stmt|;
define|#
directive|define
name|isoctal
parameter_list|(
name|chr
parameter_list|)
value|(((chr)>= '0')&& ((chr)<= '7'))
name|s1
operator|=
name|temp
expr_stmt|;
comment|/* Don't overflow buffer, leave room for chars we append later */
while|while
condition|(
operator|*
name|s
operator|&&
name|s1
operator|-
name|temp
operator|<
sizeof|sizeof
argument_list|(
name|temp
argument_list|)
operator|-
literal|2
operator|-
name|add_return
condition|)
block|{
name|cur_chr
operator|=
operator|*
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|cur_chr
operator|==
literal|'^'
condition|)
block|{
name|cur_chr
operator|=
operator|*
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|cur_chr
operator|==
literal|'\0'
condition|)
block|{
operator|*
name|s1
operator|++
operator|=
literal|'^'
expr_stmt|;
break|break;
block|}
name|cur_chr
operator|&=
literal|0x1F
expr_stmt|;
if|if
condition|(
name|cur_chr
operator|!=
literal|0
condition|)
block|{
operator|*
name|s1
operator|++
operator|=
name|cur_chr
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
name|cur_chr
operator|!=
literal|'\\'
condition|)
block|{
operator|*
name|s1
operator|++
operator|=
name|cur_chr
expr_stmt|;
continue|continue;
block|}
name|cur_chr
operator|=
operator|*
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|cur_chr
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|sending
condition|)
block|{
operator|*
name|s1
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|s1
operator|++
operator|=
literal|'\\'
expr_stmt|;
block|}
break|break;
block|}
switch|switch
condition|(
name|cur_chr
condition|)
block|{
case|case
literal|'b'
case|:
operator|*
name|s1
operator|++
operator|=
literal|'\b'
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
if|if
condition|(
name|sending
operator|&&
operator|*
name|s
operator|==
literal|'\0'
condition|)
name|add_return
operator|=
literal|0
expr_stmt|;
else|else
operator|*
name|s1
operator|++
operator|=
name|cur_chr
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
case|case
literal|'K'
case|:
case|case
literal|'p'
case|:
case|case
literal|'d'
case|:
if|if
condition|(
name|sending
condition|)
operator|*
name|s1
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|s1
operator|++
operator|=
name|cur_chr
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
if|if
condition|(
name|sending
operator|&&
name|phone_num
condition|)
block|{
for|for
control|(
name|phchar
operator|=
name|phone_num
init|;
operator|*
name|phchar
operator|!=
literal|'\0'
condition|;
name|phchar
operator|++
control|)
operator|*
name|s1
operator|++
operator|=
operator|*
name|phchar
expr_stmt|;
block|}
else|else
block|{
operator|*
name|s1
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|s1
operator|++
operator|=
literal|'T'
expr_stmt|;
block|}
break|break;
case|case
literal|'U'
case|:
if|if
condition|(
name|sending
operator|&&
name|phone_num2
condition|)
block|{
for|for
control|(
name|phchar
operator|=
name|phone_num2
init|;
operator|*
name|phchar
operator|!=
literal|'\0'
condition|;
name|phchar
operator|++
control|)
operator|*
name|s1
operator|++
operator|=
operator|*
name|phchar
expr_stmt|;
block|}
else|else
block|{
operator|*
name|s1
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|s1
operator|++
operator|=
literal|'U'
expr_stmt|;
block|}
break|break;
case|case
literal|'q'
case|:
name|quiet
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
operator|*
name|s1
operator|++
operator|=
literal|'\r'
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
operator|*
name|s1
operator|++
operator|=
literal|'\n'
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
operator|*
name|s1
operator|++
operator|=
literal|' '
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
operator|*
name|s1
operator|++
operator|=
literal|'\t'
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
if|if
condition|(
name|sending
condition|)
block|{
operator|*
name|s1
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|s1
operator|++
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
operator|*
name|s1
operator|++
operator|=
literal|'N'
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|isoctal
argument_list|(
name|cur_chr
argument_list|)
condition|)
block|{
name|cur_chr
operator|&=
literal|0x07
expr_stmt|;
if|if
condition|(
name|isoctal
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
name|cur_chr
operator|<<=
literal|3
expr_stmt|;
name|cur_chr
operator||=
operator|*
name|s
operator|++
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|isoctal
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
name|cur_chr
operator|<<=
literal|3
expr_stmt|;
name|cur_chr
operator||=
operator|*
name|s
operator|++
operator|-
literal|'0'
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cur_chr
operator|!=
literal|0
operator|||
name|sending
condition|)
block|{
if|if
condition|(
name|sending
operator|&&
operator|(
name|cur_chr
operator|==
literal|'\\'
operator|||
name|cur_chr
operator|==
literal|0
operator|)
condition|)
operator|*
name|s1
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|s1
operator|++
operator|=
name|cur_chr
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|sending
condition|)
operator|*
name|s1
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|s1
operator|++
operator|=
name|cur_chr
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|add_return
condition|)
operator|*
name|s1
operator|++
operator|=
literal|'\r'
expr_stmt|;
operator|*
name|s1
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* guarantee closure */
operator|*
name|s1
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* terminate the string */
return|return
name|dup_mem
argument_list|(
name|temp
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|s1
operator|-
name|temp
argument_list|)
argument_list|)
return|;
comment|/* may have embedded nuls */
block|}
end_function

begin_comment
comment|/*  * A modified version of 'strtok'. This version skips \ sequences.  */
end_comment

begin_function
name|char
modifier|*
name|expect_strtok
parameter_list|(
name|s
parameter_list|,
name|term
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|,
decl|*
name|term
decl_stmt|;
end_function

begin_block
block|{
specifier|static
name|char
modifier|*
name|str
init|=
literal|""
decl_stmt|;
name|int
name|escape_flag
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|result
decl_stmt|;
comment|/*  * If a string was specified then do initial processing.  */
if|if
condition|(
name|s
condition|)
name|str
operator|=
name|s
expr_stmt|;
comment|/*  * If this is the escape flag then reset it and ignore the character.  */
if|if
condition|(
operator|*
name|str
condition|)
name|result
operator|=
name|str
expr_stmt|;
else|else
name|result
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|str
condition|)
block|{
if|if
condition|(
name|escape_flag
condition|)
block|{
name|escape_flag
operator|=
literal|0
expr_stmt|;
operator|++
name|str
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|*
name|str
operator|==
literal|'\\'
condition|)
block|{
operator|++
name|str
expr_stmt|;
name|escape_flag
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
comment|/*  * If this is not in the termination string, continue.  */
if|if
condition|(
name|strchr
argument_list|(
name|term
argument_list|,
operator|*
name|str
argument_list|)
operator|==
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
block|{
operator|++
name|str
expr_stmt|;
continue|continue;
block|}
comment|/*  * This is the terminator. Mark the end of the string and stop.  */
operator|*
name|str
operator|++
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Process the expect string  */
end_comment

begin_function
name|void
name|chat_expect
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|char
modifier|*
name|expect
decl_stmt|;
name|char
modifier|*
name|reply
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"HANGUP"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|++
name|hup_next
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"ABORT"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|++
name|abort_next
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"CLR_ABORT"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|++
name|clear_abort_next
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"REPORT"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|++
name|report_next
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"CLR_REPORT"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|++
name|clear_report_next
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"TIMEOUT"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|++
name|timeout_next
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"ECHO"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|++
name|echo_next
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"SAY"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|++
name|say_next
expr_stmt|;
return|return;
block|}
comment|/*  * Fetch the expect and reply string.  */
for|for
control|(
init|;
condition|;
control|)
block|{
name|expect
operator|=
name|expect_strtok
argument_list|(
name|s
argument_list|,
literal|"-"
argument_list|)
expr_stmt|;
name|s
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
if|if
condition|(
name|expect
operator|==
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
return|return;
name|reply
operator|=
name|expect_strtok
argument_list|(
name|s
argument_list|,
literal|"-"
argument_list|)
expr_stmt|;
comment|/*  * Handle the expect string. If successful then exit.  */
if|if
condition|(
name|get_string
argument_list|(
name|expect
argument_list|)
condition|)
return|return;
comment|/*  * If there is a sub-reply string then send it. Otherwise any condition  * is terminal.  */
if|if
condition|(
name|reply
operator|==
operator|(
name|char
operator|*
operator|)
literal|0
operator|||
name|exit_code
operator|!=
literal|3
condition|)
break|break;
name|chat_send
argument_list|(
name|reply
argument_list|)
expr_stmt|;
block|}
comment|/*  * The expectation did not occur. This is terminal.  */
if|if
condition|(
name|fail_reason
condition|)
name|logf
argument_list|(
literal|"Failed (%s)"
argument_list|,
name|fail_reason
argument_list|)
expr_stmt|;
else|else
name|logf
argument_list|(
literal|"Failed"
argument_list|)
expr_stmt|;
name|terminate
argument_list|(
name|exit_code
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Translate the input character to the appropriate string for printing  * the data.  */
end_comment

begin_function
name|char
modifier|*
name|character
parameter_list|(
name|c
parameter_list|)
name|int
name|c
decl_stmt|;
block|{
specifier|static
name|char
name|string
index|[
literal|10
index|]
decl_stmt|;
name|char
modifier|*
name|meta
decl_stmt|;
name|meta
operator|=
operator|(
name|c
operator|&
literal|0x80
operator|)
condition|?
literal|"M-"
else|:
literal|""
expr_stmt|;
name|c
operator|&=
literal|0x7F
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|32
condition|)
name|sprintf
argument_list|(
name|string
argument_list|,
literal|"%s^%c"
argument_list|,
name|meta
argument_list|,
operator|(
name|int
operator|)
name|c
operator|+
literal|'@'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|127
condition|)
name|sprintf
argument_list|(
name|string
argument_list|,
literal|"%s^?"
argument_list|,
name|meta
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|string
argument_list|,
literal|"%s%c"
argument_list|,
name|meta
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return
operator|(
name|string
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  process the reply string  */
end_comment

begin_function
name|void
name|chat_send
parameter_list|(
name|s
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
block|{
if|if
condition|(
name|say_next
condition|)
block|{
name|say_next
operator|=
literal|0
expr_stmt|;
name|s
operator|=
name|clean
argument_list|(
name|s
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|STDERR_FILENO
argument_list|,
name|s
argument_list|,
name|strlen
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|hup_next
condition|)
block|{
name|hup_next
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"OFF"
argument_list|)
operator|==
literal|0
condition|)
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
else|else
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|sighup
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|echo_next
condition|)
block|{
name|echo_next
operator|=
literal|0
expr_stmt|;
name|echo
operator|=
operator|(
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"ON"
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|abort_next
condition|)
block|{
name|char
modifier|*
name|s1
decl_stmt|;
name|abort_next
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|n_aborts
operator|>=
name|MAX_ABORTS
condition|)
name|fatal
argument_list|(
literal|2
argument_list|,
literal|"Too many ABORT strings"
argument_list|)
expr_stmt|;
name|s1
operator|=
name|clean
argument_list|(
name|s
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|s1
argument_list|)
operator|>
name|strlen
argument_list|(
name|s
argument_list|)
operator|||
name|strlen
argument_list|(
name|s1
argument_list|)
operator|+
literal|1
operator|>
sizeof|sizeof
argument_list|(
name|fail_buffer
argument_list|)
condition|)
name|fatal
argument_list|(
literal|1
argument_list|,
literal|"Illegal or too-long ABORT string ('%v')"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|abort_string
index|[
name|n_aborts
operator|++
index|]
operator|=
name|s1
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|logf
argument_list|(
literal|"abort on (%v)"
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|clear_abort_next
condition|)
block|{
name|char
modifier|*
name|s1
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|old_max
decl_stmt|;
name|int
name|pack
init|=
literal|0
decl_stmt|;
name|clear_abort_next
operator|=
literal|0
expr_stmt|;
name|s1
operator|=
name|clean
argument_list|(
name|s
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|s1
argument_list|)
operator|>
name|strlen
argument_list|(
name|s
argument_list|)
operator|||
name|strlen
argument_list|(
name|s1
argument_list|)
operator|+
literal|1
operator|>
sizeof|sizeof
argument_list|(
name|fail_buffer
argument_list|)
condition|)
name|fatal
argument_list|(
literal|1
argument_list|,
literal|"Illegal or too-long CLR_ABORT string ('%v')"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|old_max
operator|=
name|n_aborts
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_aborts
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|s1
argument_list|,
name|abort_string
index|[
name|i
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|abort_string
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|abort_string
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|pack
operator|++
expr_stmt|;
name|n_aborts
operator|--
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|logf
argument_list|(
literal|"clear abort on (%v)"
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|s1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pack
condition|)
name|pack_array
argument_list|(
name|abort_string
argument_list|,
name|old_max
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|report_next
condition|)
block|{
name|char
modifier|*
name|s1
decl_stmt|;
name|report_next
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|n_reports
operator|>=
name|MAX_REPORTS
condition|)
name|fatal
argument_list|(
literal|2
argument_list|,
literal|"Too many REPORT strings"
argument_list|)
expr_stmt|;
name|s1
operator|=
name|clean
argument_list|(
name|s
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|s1
argument_list|)
operator|>
name|strlen
argument_list|(
name|s
argument_list|)
operator|||
name|strlen
argument_list|(
name|s1
argument_list|)
operator|>
sizeof|sizeof
name|fail_buffer
operator|-
literal|1
condition|)
name|fatal
argument_list|(
literal|1
argument_list|,
literal|"Illegal or too-long REPORT string ('%v')"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|report_string
index|[
name|n_reports
operator|++
index|]
operator|=
name|s1
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|logf
argument_list|(
literal|"report (%v)"
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|clear_report_next
condition|)
block|{
name|char
modifier|*
name|s1
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|old_max
decl_stmt|;
name|int
name|pack
init|=
literal|0
decl_stmt|;
name|clear_report_next
operator|=
literal|0
expr_stmt|;
name|s1
operator|=
name|clean
argument_list|(
name|s
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|s1
argument_list|)
operator|>
name|strlen
argument_list|(
name|s
argument_list|)
operator|||
name|strlen
argument_list|(
name|s1
argument_list|)
operator|>
sizeof|sizeof
name|fail_buffer
operator|-
literal|1
condition|)
name|fatal
argument_list|(
literal|1
argument_list|,
literal|"Illegal or too-long REPORT string ('%v')"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|old_max
operator|=
name|n_reports
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_reports
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|s1
argument_list|,
name|report_string
index|[
name|i
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|report_string
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|report_string
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|pack
operator|++
expr_stmt|;
name|n_reports
operator|--
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|logf
argument_list|(
literal|"clear report (%v)"
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|s1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pack
condition|)
name|pack_array
argument_list|(
name|report_string
argument_list|,
name|old_max
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|timeout_next
condition|)
block|{
name|timeout_next
operator|=
literal|0
expr_stmt|;
name|timeout
operator|=
name|atoi
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|timeout
operator|<=
literal|0
condition|)
name|timeout
operator|=
name|DEFAULT_CHAT_TIMEOUT
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|logf
argument_list|(
literal|"timeout set to %d seconds"
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"EOT"
argument_list|)
operator|==
literal|0
condition|)
name|s
operator|=
literal|"^D\\c"
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"BREAK"
argument_list|)
operator|==
literal|0
condition|)
name|s
operator|=
literal|"\\K\\c"
expr_stmt|;
if|if
condition|(
operator|!
name|put_string
argument_list|(
name|s
argument_list|)
condition|)
name|fatal
argument_list|(
literal|1
argument_list|,
literal|"Failed"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|get_char
parameter_list|()
block|{
name|int
name|status
decl_stmt|;
name|char
name|c
decl_stmt|;
name|status
operator|=
name|read
argument_list|(
name|STDIN_FILENO
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|status
condition|)
block|{
case|case
literal|1
case|:
return|return
operator|(
operator|(
name|int
operator|)
name|c
operator|&
literal|0x7F
operator|)
return|;
default|default:
name|logf
argument_list|(
literal|"warning: read() on stdin returned %d"
argument_list|,
name|status
argument_list|)
expr_stmt|;
case|case
operator|-
literal|1
case|:
if|if
condition|(
operator|(
name|status
operator|=
name|fcntl
argument_list|(
literal|0
argument_list|,
name|F_GETFL
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|fatal
argument_list|(
literal|2
argument_list|,
literal|"Can't get file mode flags on stdin: %m"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fcntl
argument_list|(
literal|0
argument_list|,
name|F_SETFL
argument_list|,
name|status
operator|&
operator|~
name|O_NONBLOCK
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|fatal
argument_list|(
literal|2
argument_list|,
literal|"Can't set file mode flags on stdin: %m"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
end_function

begin_function
name|int
name|put_char
parameter_list|(
name|c
parameter_list|)
name|int
name|c
decl_stmt|;
block|{
name|int
name|status
decl_stmt|;
name|char
name|ch
init|=
name|c
decl_stmt|;
name|usleep
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
comment|/* inter-character typing delay (?) */
name|status
operator|=
name|write
argument_list|(
name|STDOUT_FILENO
argument_list|,
operator|&
name|ch
argument_list|,
literal|1
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|status
condition|)
block|{
case|case
literal|1
case|:
return|return
operator|(
literal|0
operator|)
return|;
default|default:
name|logf
argument_list|(
literal|"warning: write() on stdout returned %d"
argument_list|,
name|status
argument_list|)
expr_stmt|;
case|case
operator|-
literal|1
case|:
if|if
condition|(
operator|(
name|status
operator|=
name|fcntl
argument_list|(
literal|0
argument_list|,
name|F_GETFL
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|fatal
argument_list|(
literal|2
argument_list|,
literal|"Can't get file mode flags on stdin, %m"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fcntl
argument_list|(
literal|0
argument_list|,
name|F_SETFL
argument_list|,
name|status
operator|&
operator|~
name|O_NONBLOCK
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|fatal
argument_list|(
literal|2
argument_list|,
literal|"Can't set file mode flags on stdin: %m"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
end_function

begin_function
name|int
name|write_char
parameter_list|(
name|c
parameter_list|)
name|int
name|c
decl_stmt|;
block|{
if|if
condition|(
name|alarmed
operator|||
name|put_char
argument_list|(
name|c
argument_list|)
operator|<
literal|0
condition|)
block|{
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|alarmed
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EINTR
operator|||
name|errno
operator|==
name|EWOULDBLOCK
condition|)
name|logf
argument_list|(
literal|" -- write timed out"
argument_list|)
expr_stmt|;
else|else
name|logf
argument_list|(
literal|" -- write failed: %m"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|put_string
parameter_list|(
name|s
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|quiet
operator|=
literal|0
expr_stmt|;
name|s
operator|=
name|clean
argument_list|(
name|s
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
block|{
if|if
condition|(
name|quiet
condition|)
name|logf
argument_list|(
literal|"send (??????)"
argument_list|)
expr_stmt|;
else|else
name|logf
argument_list|(
literal|"send (%v)"
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
name|alarm
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
name|alarmed
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
block|{
specifier|register
name|char
name|c
init|=
operator|*
name|s
operator|++
decl_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'\\'
condition|)
block|{
if|if
condition|(
operator|!
name|write_char
argument_list|(
name|c
argument_list|)
condition|)
return|return
literal|0
return|;
continue|continue;
block|}
name|c
operator|=
operator|*
name|s
operator|++
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'d'
case|:
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'K'
case|:
name|break_sequence
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|usleep
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
comment|/* 1/100th of a second (arg is microseconds) */
break|break;
default|default:
if|if
condition|(
operator|!
name|write_char
argument_list|(
name|c
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
block|}
block|}
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|alarmed
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	Echo a character to stderr.  *	When called with -1, a '\n' character is generated when  *	the cursor is not at the beginning of a line.  */
end_comment

begin_function
name|void
name|echo_stderr
parameter_list|(
name|n
parameter_list|)
name|int
name|n
decl_stmt|;
block|{
specifier|static
name|int
name|need_lf
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
switch|switch
condition|(
name|n
condition|)
block|{
case|case
literal|'\r'
case|:
comment|/* ignore '\r' */
break|break;
case|case
operator|-
literal|1
case|:
if|if
condition|(
name|need_lf
operator|==
literal|0
condition|)
break|break;
comment|/* fall through */
case|case
literal|'\n'
case|:
name|write
argument_list|(
name|STDERR_FILENO
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|need_lf
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|s
operator|=
name|character
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|STDERR_FILENO
argument_list|,
name|s
argument_list|,
name|strlen
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|need_lf
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  *	'Wait for' this string to appear on this file descriptor.  */
end_comment

begin_function
name|int
name|get_string
parameter_list|(
name|string
parameter_list|)
specifier|register
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|char
name|temp
index|[
name|STR_LEN
index|]
decl_stmt|;
name|int
name|c
decl_stmt|,
name|printed
init|=
literal|0
decl_stmt|,
name|len
decl_stmt|,
name|minlen
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
init|=
name|temp
decl_stmt|,
modifier|*
name|end
init|=
name|s
operator|+
name|STR_LEN
decl_stmt|;
name|char
modifier|*
name|logged
init|=
name|temp
decl_stmt|;
name|fail_reason
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|string
argument_list|)
operator|>
name|STR_LEN
condition|)
block|{
name|logf
argument_list|(
literal|"expect string is too long"
argument_list|)
expr_stmt|;
name|exit_code
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
name|string
operator|=
name|clean
argument_list|(
name|string
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|string
argument_list|)
expr_stmt|;
name|minlen
operator|=
operator|(
name|len
operator|>
sizeof|sizeof
argument_list|(
name|fail_buffer
argument_list|)
condition|?
name|len
else|:
sizeof|sizeof
argument_list|(
name|fail_buffer
argument_list|)
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|logf
argument_list|(
literal|"expect (%v)"
argument_list|,
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
name|logf
argument_list|(
literal|"got it"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|alarm
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
name|alarmed
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|alarmed
operator|&&
operator|(
name|c
operator|=
name|get_char
argument_list|()
operator|)
operator|>=
literal|0
condition|)
block|{
name|int
name|n
decl_stmt|,
name|abort_len
decl_stmt|,
name|report_len
decl_stmt|;
if|if
condition|(
name|echo
condition|)
name|echo_stderr
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
operator|&&
name|c
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|s
operator|==
name|logged
condition|)
name|logf
argument_list|(
literal|""
argument_list|)
expr_stmt|;
comment|/* blank line */
else|else
name|logf
argument_list|(
literal|"%0.*v"
argument_list|,
name|s
operator|-
name|logged
argument_list|,
name|logged
argument_list|)
expr_stmt|;
name|logged
operator|=
name|s
operator|+
literal|1
expr_stmt|;
block|}
operator|*
name|s
operator|++
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|verbose
operator|&&
name|s
operator|>=
name|logged
operator|+
literal|80
condition|)
block|{
name|logf
argument_list|(
literal|"%0.*v"
argument_list|,
name|s
operator|-
name|logged
argument_list|,
name|logged
argument_list|)
expr_stmt|;
name|logged
operator|=
name|s
expr_stmt|;
block|}
if|if
condition|(
name|Verbose
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|!=
literal|'\r'
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s"
argument_list|,
name|character
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|report_gathering
condition|)
block|{
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|n_reports
condition|;
operator|++
name|n
control|)
block|{
if|if
condition|(
operator|(
name|report_string
index|[
name|n
index|]
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
operator|&&
name|s
operator|-
name|temp
operator|>=
operator|(
name|report_len
operator|=
name|strlen
argument_list|(
name|report_string
index|[
name|n
index|]
argument_list|)
operator|)
operator|&&
name|strncmp
argument_list|(
name|s
operator|-
name|report_len
argument_list|,
name|report_string
index|[
name|n
index|]
argument_list|,
name|report_len
argument_list|)
operator|==
literal|0
condition|)
block|{
name|time_t
name|time_now
init|=
name|time
argument_list|(
operator|(
name|time_t
operator|*
operator|)
name|NULL
argument_list|)
decl_stmt|;
name|struct
name|tm
modifier|*
name|tm_now
init|=
name|localtime
argument_list|(
operator|&
name|time_now
argument_list|)
decl_stmt|;
name|strftime
argument_list|(
name|report_buffer
argument_list|,
literal|20
argument_list|,
literal|"%b %d %H:%M:%S "
argument_list|,
name|tm_now
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|report_buffer
argument_list|,
name|report_string
index|[
name|n
index|]
argument_list|)
expr_stmt|;
name|report_string
index|[
name|n
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|report_gathering
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|iscntrl
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|int
name|rep_len
init|=
name|strlen
argument_list|(
name|report_buffer
argument_list|)
decl_stmt|;
name|report_buffer
index|[
name|rep_len
index|]
operator|=
name|c
expr_stmt|;
name|report_buffer
index|[
name|rep_len
operator|+
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
name|report_gathering
operator|=
literal|0
expr_stmt|;
name|fprintf
argument_list|(
name|report_fp
argument_list|,
literal|"chat:  %s\n"
argument_list|,
name|report_buffer
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|s
operator|-
name|temp
operator|>=
name|len
operator|&&
name|c
operator|==
name|string
index|[
name|len
operator|-
literal|1
index|]
operator|&&
name|strncmp
argument_list|(
name|s
operator|-
name|len
argument_list|,
name|string
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
block|{
if|if
condition|(
name|s
operator|>
name|logged
condition|)
name|logf
argument_list|(
literal|"%0.*v"
argument_list|,
name|s
operator|-
name|logged
argument_list|,
name|logged
argument_list|)
expr_stmt|;
name|logf
argument_list|(
literal|" -- got it\n"
argument_list|)
expr_stmt|;
block|}
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|alarmed
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|n_aborts
condition|;
operator|++
name|n
control|)
block|{
if|if
condition|(
name|s
operator|-
name|temp
operator|>=
operator|(
name|abort_len
operator|=
name|strlen
argument_list|(
name|abort_string
index|[
name|n
index|]
argument_list|)
operator|)
operator|&&
name|strncmp
argument_list|(
name|s
operator|-
name|abort_len
argument_list|,
name|abort_string
index|[
name|n
index|]
argument_list|,
name|abort_len
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
block|{
if|if
condition|(
name|s
operator|>
name|logged
condition|)
name|logf
argument_list|(
literal|"%0.*v"
argument_list|,
name|s
operator|-
name|logged
argument_list|,
name|logged
argument_list|)
expr_stmt|;
name|logf
argument_list|(
literal|" -- failed"
argument_list|)
expr_stmt|;
block|}
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|alarmed
operator|=
literal|0
expr_stmt|;
name|exit_code
operator|=
name|n
operator|+
literal|4
expr_stmt|;
name|strcpy
argument_list|(
name|fail_reason
operator|=
name|fail_buffer
argument_list|,
name|abort_string
index|[
name|n
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
if|if
condition|(
name|s
operator|>=
name|end
condition|)
block|{
if|if
condition|(
name|logged
operator|<
name|s
operator|-
name|minlen
condition|)
block|{
name|logf
argument_list|(
literal|"%0.*v"
argument_list|,
name|s
operator|-
name|logged
argument_list|,
name|logged
argument_list|)
expr_stmt|;
name|logged
operator|=
name|s
expr_stmt|;
block|}
name|s
operator|-=
name|minlen
expr_stmt|;
name|memmove
argument_list|(
name|temp
argument_list|,
name|s
argument_list|,
name|minlen
argument_list|)
expr_stmt|;
name|logged
operator|=
name|temp
operator|+
operator|(
name|logged
operator|-
name|s
operator|)
expr_stmt|;
name|s
operator|=
name|temp
operator|+
name|minlen
expr_stmt|;
block|}
if|if
condition|(
name|alarmed
operator|&&
name|verbose
condition|)
name|logf
argument_list|(
literal|"warning: alarm synchronization problem"
argument_list|)
expr_stmt|;
block|}
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
operator|&&
name|printed
condition|)
block|{
if|if
condition|(
name|alarmed
condition|)
name|logf
argument_list|(
literal|" -- read timed out"
argument_list|)
expr_stmt|;
else|else
name|logf
argument_list|(
literal|" -- read failed: %m"
argument_list|)
expr_stmt|;
block|}
name|exit_code
operator|=
literal|3
expr_stmt|;
name|alarmed
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Gross kludge to handle Solaris versions>= 2.6 having usleep.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SOL2
end_ifdef

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_if
if|#
directive|if
name|MAXUID
operator|>
literal|65536
end_if

begin_comment
comment|/* then this is Solaris 2.6 or later */
end_comment

begin_undef
undef|#
directive|undef
name|NO_USLEEP
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SOL2 */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|NO_USLEEP
end_ifdef

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_comment
comment|/*   usleep -- support routine for 4.2BSD system call emulations   last edit:  29-Oct-1984     D A Gwyn   */
end_comment

begin_function_decl
specifier|extern
name|int
name|select
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|int
name|usleep
parameter_list|(
name|usec
parameter_list|)
comment|/* returns 0 if ok, else -1 */
name|long
name|usec
decl_stmt|;
comment|/* delay in microseconds */
block|{
specifier|static
struct|struct
block|{
comment|/* `timeval' */
name|long
name|tv_sec
decl_stmt|;
comment|/* seconds */
name|long
name|tv_usec
decl_stmt|;
comment|/* microsecs */
block|}
name|delay
struct|;
comment|/* _select() timeout */
name|delay
operator|.
name|tv_sec
operator|=
name|usec
operator|/
literal|1000000L
expr_stmt|;
name|delay
operator|.
name|tv_usec
operator|=
name|usec
operator|%
literal|1000000L
expr_stmt|;
return|return
name|select
argument_list|(
literal|0
argument_list|,
operator|(
name|long
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|long
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|long
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|delay
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|pack_array
parameter_list|(
name|array
parameter_list|,
name|end
parameter_list|)
name|char
modifier|*
modifier|*
name|array
decl_stmt|;
comment|/* The address of the array of string pointers */
name|int
name|end
decl_stmt|;
comment|/* The index of the next free entry before CLR_ */
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|end
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|array
index|[
name|i
index|]
operator|==
name|NULL
condition|)
block|{
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|end
condition|;
operator|++
name|j
control|)
if|if
condition|(
name|array
index|[
name|j
index|]
operator|!=
name|NULL
condition|)
name|array
index|[
name|i
operator|++
index|]
operator|=
name|array
index|[
name|j
index|]
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|end
condition|;
operator|++
name|i
control|)
name|array
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * vfmtmsg - format a message into a buffer.  Like vsprintf except we  * also specify the length of the output buffer, and we handle the  * %m (error message) format.  * Doesn't do floating-point formats.  * Returns the number of chars put into buf.  */
end_comment

begin_define
define|#
directive|define
name|OUTCHAR
parameter_list|(
name|c
parameter_list|)
value|(buflen> 0? (--buflen, *buf++ = (c)): 0)
end_define

begin_function
name|int
name|vfmtmsg
parameter_list|(
name|buf
parameter_list|,
name|buflen
parameter_list|,
name|fmt
parameter_list|,
name|args
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|buflen
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|va_list
name|args
decl_stmt|;
block|{
name|int
name|c
decl_stmt|,
name|i
decl_stmt|,
name|n
decl_stmt|;
name|int
name|width
decl_stmt|,
name|prec
decl_stmt|,
name|fillch
decl_stmt|;
name|int
name|base
decl_stmt|,
name|len
decl_stmt|,
name|neg
decl_stmt|,
name|quoted
decl_stmt|;
name|unsigned
name|long
name|val
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|,
modifier|*
name|buf0
decl_stmt|;
specifier|const
name|char
modifier|*
name|f
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|num
index|[
literal|32
index|]
decl_stmt|;
specifier|static
name|char
name|hexchars
index|[]
init|=
literal|"0123456789abcdef"
decl_stmt|;
name|buf0
operator|=
name|buf
expr_stmt|;
operator|--
name|buflen
expr_stmt|;
while|while
condition|(
name|buflen
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|f
operator|=
name|fmt
init|;
operator|*
name|f
operator|!=
literal|'%'
operator|&&
operator|*
name|f
operator|!=
literal|0
condition|;
operator|++
name|f
control|)
empty_stmt|;
if|if
condition|(
name|f
operator|>
name|fmt
condition|)
block|{
name|len
operator|=
name|f
operator|-
name|fmt
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|buflen
condition|)
name|len
operator|=
name|buflen
expr_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
name|fmt
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|buf
operator|+=
name|len
expr_stmt|;
name|buflen
operator|-=
name|len
expr_stmt|;
name|fmt
operator|=
name|f
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|fmt
operator|==
literal|0
condition|)
break|break;
name|c
operator|=
operator|*
operator|++
name|fmt
expr_stmt|;
name|width
operator|=
name|prec
operator|=
literal|0
expr_stmt|;
name|fillch
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'0'
condition|)
block|{
name|fillch
operator|=
literal|'0'
expr_stmt|;
name|c
operator|=
operator|*
operator|++
name|fmt
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|'*'
condition|)
block|{
name|width
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|c
operator|=
operator|*
operator|++
name|fmt
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|width
operator|=
name|width
operator|*
literal|10
operator|+
name|c
operator|-
literal|'0'
expr_stmt|;
name|c
operator|=
operator|*
operator|++
name|fmt
expr_stmt|;
block|}
block|}
if|if
condition|(
name|c
operator|==
literal|'.'
condition|)
block|{
name|c
operator|=
operator|*
operator|++
name|fmt
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'*'
condition|)
block|{
name|prec
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|c
operator|=
operator|*
operator|++
name|fmt
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|prec
operator|=
name|prec
operator|*
literal|10
operator|+
name|c
operator|-
literal|'0'
expr_stmt|;
name|c
operator|=
operator|*
operator|++
name|fmt
expr_stmt|;
block|}
block|}
block|}
name|str
operator|=
literal|0
expr_stmt|;
name|base
operator|=
literal|0
expr_stmt|;
name|neg
operator|=
literal|0
expr_stmt|;
operator|++
name|fmt
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'d'
case|:
name|i
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|int
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|neg
operator|=
literal|1
expr_stmt|;
name|val
operator|=
operator|-
name|i
expr_stmt|;
block|}
else|else
name|val
operator|=
name|i
expr_stmt|;
name|base
operator|=
literal|10
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|val
operator|=
name|va_arg
argument_list|(
argument|args
argument_list|,
argument|unsigned int
argument_list|)
expr_stmt|;
name|base
operator|=
literal|8
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|val
operator|=
name|va_arg
argument_list|(
argument|args
argument_list|,
argument|unsigned int
argument_list|)
expr_stmt|;
name|base
operator|=
literal|16
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|val
operator|=
operator|(
name|unsigned
name|long
operator|)
name|va_arg
argument_list|(
name|args
argument_list|,
name|void
operator|*
argument_list|)
expr_stmt|;
name|base
operator|=
literal|16
expr_stmt|;
name|neg
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|str
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|num
index|[
literal|0
index|]
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|num
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|str
operator|=
name|num
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|str
operator|=
name|strerror
argument_list|(
name|errno
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
comment|/* "visible" string */
case|case
literal|'q'
case|:
comment|/* quoted string */
name|quoted
operator|=
name|c
operator|==
literal|'q'
expr_stmt|;
name|p
operator|=
name|va_arg
argument_list|(
argument|args
argument_list|,
argument|unsigned char *
argument_list|)
expr_stmt|;
if|if
condition|(
name|fillch
operator|==
literal|'0'
operator|&&
name|prec
operator|>
literal|0
condition|)
block|{
name|n
operator|=
name|prec
expr_stmt|;
block|}
else|else
block|{
name|n
operator|=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|prec
operator|>
literal|0
operator|&&
name|prec
operator|<
name|n
condition|)
name|n
operator|=
name|prec
expr_stmt|;
block|}
while|while
condition|(
name|n
operator|>
literal|0
operator|&&
name|buflen
operator|>
literal|0
condition|)
block|{
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|--
name|n
expr_stmt|;
if|if
condition|(
operator|!
name|quoted
operator|&&
name|c
operator|>=
literal|0x80
condition|)
block|{
name|OUTCHAR
argument_list|(
literal|'M'
argument_list|)
expr_stmt|;
name|OUTCHAR
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
name|c
operator|-=
literal|0x80
expr_stmt|;
block|}
if|if
condition|(
name|quoted
operator|&&
operator|(
name|c
operator|==
literal|'"'
operator|||
name|c
operator|==
literal|'\\'
operator|)
condition|)
name|OUTCHAR
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|0x20
operator|||
operator|(
literal|0x7f
operator|<=
name|c
operator|&&
name|c
operator|<
literal|0xa0
operator|)
condition|)
block|{
if|if
condition|(
name|quoted
condition|)
block|{
name|OUTCHAR
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\t'
case|:
name|OUTCHAR
argument_list|(
literal|'t'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
name|OUTCHAR
argument_list|(
literal|'n'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\b'
case|:
name|OUTCHAR
argument_list|(
literal|'b'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\f'
case|:
name|OUTCHAR
argument_list|(
literal|'f'
argument_list|)
expr_stmt|;
break|break;
default|default:
name|OUTCHAR
argument_list|(
literal|'x'
argument_list|)
expr_stmt|;
name|OUTCHAR
argument_list|(
name|hexchars
index|[
name|c
operator|>>
literal|4
index|]
argument_list|)
expr_stmt|;
name|OUTCHAR
argument_list|(
name|hexchars
index|[
name|c
operator|&
literal|0xf
index|]
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|c
operator|==
literal|'\t'
condition|)
name|OUTCHAR
argument_list|(
name|c
argument_list|)
expr_stmt|;
else|else
block|{
name|OUTCHAR
argument_list|(
literal|'^'
argument_list|)
expr_stmt|;
name|OUTCHAR
argument_list|(
name|c
operator|^
literal|0x40
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
name|OUTCHAR
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
continue|continue;
default|default:
operator|*
name|buf
operator|++
operator|=
literal|'%'
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'%'
condition|)
operator|--
name|fmt
expr_stmt|;
comment|/* so %z outputs %z etc. */
operator|--
name|buflen
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|base
operator|!=
literal|0
condition|)
block|{
name|str
operator|=
name|num
operator|+
sizeof|sizeof
argument_list|(
name|num
argument_list|)
expr_stmt|;
operator|*
operator|--
name|str
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|str
operator|>
name|num
operator|+
name|neg
condition|)
block|{
operator|*
operator|--
name|str
operator|=
name|hexchars
index|[
name|val
operator|%
name|base
index|]
expr_stmt|;
name|val
operator|=
name|val
operator|/
name|base
expr_stmt|;
if|if
condition|(
operator|--
name|prec
operator|<=
literal|0
operator|&&
name|val
operator|==
literal|0
condition|)
break|break;
block|}
switch|switch
condition|(
name|neg
condition|)
block|{
case|case
literal|1
case|:
operator|*
operator|--
name|str
operator|=
literal|'-'
expr_stmt|;
break|break;
case|case
literal|2
case|:
operator|*
operator|--
name|str
operator|=
literal|'x'
expr_stmt|;
operator|*
operator|--
name|str
operator|=
literal|'0'
expr_stmt|;
break|break;
block|}
name|len
operator|=
name|num
operator|+
sizeof|sizeof
argument_list|(
name|num
argument_list|)
operator|-
literal|1
operator|-
name|str
expr_stmt|;
block|}
else|else
block|{
name|len
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|prec
operator|>
literal|0
operator|&&
name|len
operator|>
name|prec
condition|)
name|len
operator|=
name|prec
expr_stmt|;
block|}
if|if
condition|(
name|width
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|width
operator|>
name|buflen
condition|)
name|width
operator|=
name|buflen
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|width
operator|-
name|len
operator|)
operator|>
literal|0
condition|)
block|{
name|buflen
operator|-=
name|n
expr_stmt|;
for|for
control|(
init|;
name|n
operator|>
literal|0
condition|;
operator|--
name|n
control|)
operator|*
name|buf
operator|++
operator|=
name|fillch
expr_stmt|;
block|}
block|}
if|if
condition|(
name|len
operator|>
name|buflen
condition|)
name|len
operator|=
name|buflen
expr_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
name|str
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|buf
operator|+=
name|len
expr_stmt|;
name|buflen
operator|-=
name|len
expr_stmt|;
block|}
operator|*
name|buf
operator|=
literal|0
expr_stmt|;
return|return
name|buf
operator|-
name|buf0
return|;
block|}
end_function

end_unit

