begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *	Chat -- a program for automatic session establishment (i.e. dial  *		the phone and log in).  *  * Standard termination codes:  *  0 - successful completion of the script  *  1 - invalid argument, expect string too large, etc.  *  2 - error on an I/O operation or fatal error condtion.  *  3 - timeout waiting for a simple string.  *  4 - the first string declared as "ABORT"  *  5 - the second string declared as "ABORT"  *  6 - ... and so on for successive ABORT strings.  *  *	This software is in the public domain.  *  * -----------------  *  *	Added SAY keyword to send output to stderr.  *      This allows to turn ECHO OFF and to output specific, user selected,  *      text to give progress messages. This best works when stderr  *      exists (i.e.: pppd in nodetach mode).  *  * 	Added HANGUP directives to allow for us to be called  *      back. When HANGUP is set to NO, chat will not hangup at HUP signal.  *      We rely on timeouts in that case.  *  *      Added CLR_ABORT to clear previously set ABORT string. This has been  *      dictated by the HANGUP above as "NO CARRIER" (for example) must be  *      an ABORT condition until we know the other host is going to close  *      the connection for call back. As soon as we have completed the  *      first stage of the call back sequence, "NO CARRIER" is a valid, non  *      fatal string. As soon as we got called back (probably get "CONNECT"),  *      we should re-arm the ABORT "NO CARRIER". Hence the CLR_ABORT command.  *      Note that CLR_ABORT packs the abort_strings[] array so that we do not  *      have unused entries not being reclaimed.  *  *      In the same vein as above, added CLR_REPORT keyword.  *  *      Allow for comments. Line starting with '#' are comments and are  *      ignored. If a '#' is to be expected as the first character, the   *      expect string must be quoted.  *  *  *		Francis Demierre<Francis@SwissMail.Com>  * 		Thu May 15 17:15:40 MET DST 1997  *  *  *      Added -r "report file" switch& REPORT keyword.  *              Robert Geer<bgeer@xmission.com>  *  *  *	Added -e "echo" switch& ECHO keyword  *		Dick Streefland<dicks@tasking.nl>  *  *  *	Considerable updates and modifications by  *		Al Longyear<longyear@pobox.com>  *		Paul Mackerras<paulus@cs.anu.edu.au>  *  *  *	The original author is:  *  *		Karl Fox<karl@MorningStar.Com>  *		Morning Star Technologies, Inc.  *		1760 Zollinger Road  *		Columbus, OH  43221  *		(614)451-1883  *  *  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$Id: chat.c,v 1.9 1997/08/22 15:24:36 peter Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|TERMIO
end_ifndef

begin_undef
undef|#
directive|undef
name|TERMIOS
end_undef

begin_define
define|#
directive|define
name|TERMIOS
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|TERMIO
end_ifdef

begin_include
include|#
directive|include
file|<termio.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|TERMIOS
end_ifdef

begin_include
include|#
directive|include
file|<termios.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|STR_LEN
value|1024
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|SIGTYPE
end_ifndef

begin_define
define|#
directive|define
name|SIGTYPE
value|void
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_undef
undef|#
directive|undef
name|__P
end_undef

begin_define
define|#
directive|define
name|__P
parameter_list|(
name|x
parameter_list|)
value|x
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|__P
parameter_list|(
name|x
parameter_list|)
value|()
end_define

begin_define
define|#
directive|define
name|const
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|O_NONBLOCK
end_ifndef

begin_define
define|#
directive|define
name|O_NONBLOCK
value|O_NDELAY
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*************** Micro getopt() *********************************************/
end_comment

begin_define
define|#
directive|define
name|OPTION
parameter_list|(
name|c
parameter_list|,
name|v
parameter_list|)
value|(_O&2&&**v?*(*v)++:!c||_O&4?0:(!(_O&1)&& \ 				(--c,++v),_O=4,c&&**v=='-'&&v[0][1]?*++*v=='-'\&&!v[0][1]?(--c,++v,0):(_O=2,*(*v)++):0))
end_define

begin_define
define|#
directive|define
name|OPTARG
parameter_list|(
name|c
parameter_list|,
name|v
parameter_list|)
value|(_O&2?**v||(++v,--c)?(_O=1,--c,*v++): \ 				(_O=4,(char*)0):(char*)0)
end_define

begin_define
define|#
directive|define
name|OPTONLYARG
parameter_list|(
name|c
parameter_list|,
name|v
parameter_list|)
value|(_O&2&&**v?(_O=1,--c,*v++):(char*)0)
end_define

begin_define
define|#
directive|define
name|ARG
parameter_list|(
name|c
parameter_list|,
name|v
parameter_list|)
value|(c?(--c,*v++):(char*)0)
end_define

begin_decl_stmt
specifier|static
name|int
name|_O
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Internal state */
end_comment

begin_comment
comment|/*************** Micro getopt() *********************************************/
end_comment

begin_define
define|#
directive|define
name|MAX_ABORTS
value|50
end_define

begin_define
define|#
directive|define
name|MAX_REPORTS
value|50
end_define

begin_define
define|#
directive|define
name|DEFAULT_CHAT_TIMEOUT
value|45
end_define

begin_decl_stmt
name|int
name|echo
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|verbose
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Verbose
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|quiet
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|report
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|exit_code
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|report_fp
init|=
operator|(
name|FILE
operator|*
operator|)
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|report_file
init|=
operator|(
name|char
operator|*
operator|)
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|chat_file
init|=
operator|(
name|char
operator|*
operator|)
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|timeout
init|=
name|DEFAULT_CHAT_TIMEOUT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|have_tty_parameters
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|TERMIO
end_ifdef

begin_define
define|#
directive|define
name|term_parms
value|struct termio
end_define

begin_define
define|#
directive|define
name|get_term_param
parameter_list|(
name|param
parameter_list|)
value|ioctl(0, TCGETA, param)
end_define

begin_define
define|#
directive|define
name|set_term_param
parameter_list|(
name|param
parameter_list|)
value|ioctl(0, TCSETA, param)
end_define

begin_decl_stmt
name|struct
name|termio
name|saved_tty_parameters
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|TERMIOS
end_ifdef

begin_define
define|#
directive|define
name|term_parms
value|struct termios
end_define

begin_define
define|#
directive|define
name|get_term_param
parameter_list|(
name|param
parameter_list|)
value|tcgetattr(0, param)
end_define

begin_define
define|#
directive|define
name|set_term_param
parameter_list|(
name|param
parameter_list|)
value|tcsetattr(0, TCSANOW, param)
end_define

begin_decl_stmt
name|struct
name|termios
name|saved_tty_parameters
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|char
modifier|*
name|abort_string
index|[
name|MAX_ABORTS
index|]
decl_stmt|,
modifier|*
name|fail_reason
init|=
operator|(
name|char
operator|*
operator|)
literal|0
decl_stmt|,
name|fail_buffer
index|[
literal|50
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|n_aborts
init|=
literal|0
decl_stmt|,
name|abort_next
init|=
literal|0
decl_stmt|,
name|timeout_next
init|=
literal|0
decl_stmt|,
name|echo_next
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|clear_abort_next
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|report_string
index|[
name|MAX_REPORTS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|report_buffer
index|[
literal|50
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|n_reports
init|=
literal|0
decl_stmt|,
name|report_next
init|=
literal|0
decl_stmt|,
name|report_gathering
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|clear_report_next
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|say_next
init|=
literal|0
decl_stmt|,
name|hup_next
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
modifier|*
name|dup_mem
name|__P
argument_list|(
operator|(
name|void
operator|*
name|b
operator|,
name|size_t
name|c
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
modifier|*
name|copy_of
name|__P
argument_list|(
operator|(
name|char
operator|*
name|s
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|usage
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|logf
name|__P
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|str
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|logflush
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|fatal
name|__P
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|msg
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|sysfatal
name|__P
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|msg
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|SIGTYPE
name|sigalrm
name|__P
argument_list|(
operator|(
name|int
name|signo
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|SIGTYPE
name|sigint
name|__P
argument_list|(
operator|(
name|int
name|signo
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|SIGTYPE
name|sigterm
name|__P
argument_list|(
operator|(
name|int
name|signo
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|SIGTYPE
name|sighup
name|__P
argument_list|(
operator|(
name|int
name|signo
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|unalarm
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|init
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|set_tty_parameters
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|echo_stderr
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|break_sequence
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|terminate
name|__P
argument_list|(
operator|(
name|int
name|status
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|do_file
name|__P
argument_list|(
operator|(
name|char
operator|*
name|chat_file
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|get_string
name|__P
argument_list|(
operator|(
specifier|register
name|char
operator|*
name|string
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|put_string
name|__P
argument_list|(
operator|(
specifier|register
name|char
operator|*
name|s
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|write_char
name|__P
argument_list|(
operator|(
name|int
name|c
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|put_char
name|__P
argument_list|(
operator|(
name|int
name|c
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|get_char
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|chat_send
name|__P
argument_list|(
operator|(
specifier|register
name|char
operator|*
name|s
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|character
name|__P
argument_list|(
operator|(
name|int
name|c
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|chat_expect
name|__P
argument_list|(
operator|(
specifier|register
name|char
operator|*
name|s
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|clean
name|__P
argument_list|(
operator|(
specifier|register
name|char
operator|*
name|s
operator|,
name|int
name|sending
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|break_sequence
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|terminate
name|__P
argument_list|(
operator|(
name|int
name|status
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|die
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|pack_array
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|*
name|array
operator|,
name|int
name|end
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|expect_strtok
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
decl|main
name|__P
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|void
modifier|*
name|dup_mem
parameter_list|(
name|b
parameter_list|,
name|c
parameter_list|)
name|void
modifier|*
name|b
decl_stmt|;
name|size_t
name|c
decl_stmt|;
block|{
name|void
modifier|*
name|ans
init|=
name|malloc
argument_list|(
name|c
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ans
condition|)
block|{
name|fatal
argument_list|(
literal|"memory error!\n"
argument_list|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|ans
argument_list|,
name|b
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return
name|ans
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|copy_of
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
return|return
name|dup_mem
argument_list|(
name|s
argument_list|,
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  *	chat [ -v ] [ -t timeout ] [ -f chat-file ] [ -r report-file ] \  *		[...[[expect[-say[-expect...]] say expect[-say[-expect]] ...]]]  *  *	Perform a UUCP-dialer-like chat script on stdin and stdout.  */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|option
decl_stmt|;
name|char
modifier|*
name|arg
decl_stmt|;
name|tzset
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|option
operator|=
name|OPTION
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
switch|switch
condition|(
name|option
condition|)
block|{
case|case
literal|'e'
case|:
operator|++
name|echo
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
operator|++
name|verbose
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
operator|++
name|Verbose
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
if|if
condition|(
operator|(
name|arg
operator|=
name|OPTARG
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|chat_file
operator|=
name|copy_of
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|usage
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
literal|'t'
case|:
if|if
condition|(
operator|(
name|arg
operator|=
name|OPTARG
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|timeout
operator|=
name|atoi
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|usage
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
literal|'r'
case|:
name|arg
operator|=
name|OPTARG
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
condition|)
block|{
if|if
condition|(
name|report_fp
operator|!=
name|NULL
condition|)
block|{
name|fclose
argument_list|(
name|report_fp
argument_list|)
expr_stmt|;
block|}
name|report_file
operator|=
name|copy_of
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|report_fp
operator|=
name|fopen
argument_list|(
name|report_file
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
if|if
condition|(
name|report_fp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
block|{
name|fprintf
argument_list|(
name|report_fp
argument_list|,
literal|"Opening \"%s\"...\n"
argument_list|,
name|report_file
argument_list|)
expr_stmt|;
block|}
name|report
operator|=
literal|1
expr_stmt|;
block|}
block|}
break|break;
default|default:
name|usage
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
comment|/*  * Default the report file to the stderr location  */
if|if
condition|(
name|report_fp
operator|==
name|NULL
condition|)
block|{
name|report_fp
operator|=
name|stderr
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ultrix
name|openlog
argument_list|(
literal|"chat"
argument_list|,
name|LOG_PID
argument_list|)
expr_stmt|;
else|#
directive|else
name|openlog
argument_list|(
literal|"chat"
argument_list|,
name|LOG_PID
operator||
name|LOG_NDELAY
argument_list|,
name|LOG_LOCAL2
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
block|{
name|setlogmask
argument_list|(
name|LOG_UPTO
argument_list|(
name|LOG_INFO
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|setlogmask
argument_list|(
name|LOG_UPTO
argument_list|(
name|LOG_WARNING
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|init
argument_list|()
expr_stmt|;
if|if
condition|(
name|chat_file
operator|!=
name|NULL
condition|)
block|{
name|arg
operator|=
name|ARG
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|!=
name|NULL
condition|)
block|{
name|usage
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|do_file
argument_list|(
name|chat_file
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
while|while
condition|(
operator|(
name|arg
operator|=
name|ARG
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|chat_expect
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|arg
operator|=
name|ARG
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|chat_send
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|terminate
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  *  Process a chat script when read from a file.  */
end_comment

begin_function
name|void
name|do_file
parameter_list|(
name|chat_file
parameter_list|)
name|char
modifier|*
name|chat_file
decl_stmt|;
block|{
name|int
name|linect
decl_stmt|,
name|sendflg
decl_stmt|;
name|char
modifier|*
name|sp
decl_stmt|,
modifier|*
name|arg
decl_stmt|,
name|quote
decl_stmt|;
name|char
name|buf
index|[
name|STR_LEN
index|]
decl_stmt|;
name|FILE
modifier|*
name|cfp
decl_stmt|;
name|cfp
operator|=
name|fopen
argument_list|(
name|chat_file
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfp
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s -- open failed: %m"
argument_list|,
name|chat_file
argument_list|)
expr_stmt|;
name|terminate
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|linect
operator|=
literal|0
expr_stmt|;
name|sendflg
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
name|STR_LEN
argument_list|,
name|cfp
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|sp
operator|=
name|strchr
argument_list|(
name|buf
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
condition|)
block|{
operator|*
name|sp
operator|=
literal|'\0'
expr_stmt|;
block|}
name|linect
operator|++
expr_stmt|;
name|sp
operator|=
name|buf
expr_stmt|;
comment|/* lines starting with '#' are comments. If a real '#'            is to be expected, it should be quoted .... */
if|if
condition|(
operator|*
name|sp
operator|==
literal|'#'
condition|)
continue|continue;
while|while
condition|(
operator|*
name|sp
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|*
name|sp
operator|==
literal|' '
operator|||
operator|*
name|sp
operator|==
literal|'\t'
condition|)
block|{
operator|++
name|sp
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|*
name|sp
operator|==
literal|'"'
operator|||
operator|*
name|sp
operator|==
literal|'\''
condition|)
block|{
name|quote
operator|=
operator|*
name|sp
operator|++
expr_stmt|;
name|arg
operator|=
name|sp
expr_stmt|;
while|while
condition|(
operator|*
name|sp
operator|!=
name|quote
condition|)
block|{
if|if
condition|(
operator|*
name|sp
operator|==
literal|'\0'
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"unterminated quote (line %d)"
argument_list|,
name|linect
argument_list|)
expr_stmt|;
name|terminate
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|sp
operator|++
operator|==
literal|'\\'
condition|)
block|{
if|if
condition|(
operator|*
name|sp
operator|!=
literal|'\0'
condition|)
block|{
operator|++
name|sp
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
name|arg
operator|=
name|sp
expr_stmt|;
while|while
condition|(
operator|*
name|sp
operator|!=
literal|'\0'
operator|&&
operator|*
name|sp
operator|!=
literal|' '
operator|&&
operator|*
name|sp
operator|!=
literal|'\t'
condition|)
block|{
operator|++
name|sp
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|*
name|sp
operator|!=
literal|'\0'
condition|)
block|{
operator|*
name|sp
operator|++
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|sendflg
condition|)
block|{
name|chat_send
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|chat_expect
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
name|sendflg
operator|=
operator|!
name|sendflg
expr_stmt|;
block|}
block|}
name|fclose
argument_list|(
name|cfp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	We got an error parsing the command line.  */
end_comment

begin_function
specifier|static
name|void
name|usage
parameter_list|()
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s %s\n"
argument_list|,
literal|"usage: chat [-e] [-v] [-V] [-t timeout] [-r report-file]"
argument_list|,
literal|"{-f chat-file | chat-script}"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|char
name|line
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|logf
parameter_list|(
name|str
parameter_list|)
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|int
name|l
init|=
name|strlen
argument_list|(
name|line
argument_list|)
decl_stmt|;
if|if
condition|(
name|l
operator|+
name|strlen
argument_list|(
name|str
argument_list|)
operator|>=
sizeof|sizeof
argument_list|(
name|line
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"%s"
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|l
operator|=
literal|0
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|line
operator|+
name|l
argument_list|,
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
index|[
name|strlen
argument_list|(
name|str
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"%s"
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|line
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|logflush
parameter_list|()
block|{
if|if
condition|(
name|line
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"%s"
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|line
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  *	Terminate with an error.  */
end_comment

begin_function
name|void
name|die
parameter_list|()
block|{
name|terminate
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	Print an error message and terminate.  */
end_comment

begin_function
name|void
name|fatal
parameter_list|(
name|msg
parameter_list|)
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|terminate
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	Print an error message along with the system error message and  *	terminate.  */
end_comment

begin_function
name|void
name|sysfatal
parameter_list|(
name|msg
parameter_list|)
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: %m"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|terminate
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|int
name|alarmed
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|SIGTYPE
name|sigalrm
parameter_list|(
name|signo
parameter_list|)
name|int
name|signo
decl_stmt|;
block|{
name|int
name|flags
decl_stmt|;
name|alarm
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|alarmed
operator|=
literal|1
expr_stmt|;
comment|/* Reset alarm to avoid race window */
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|sigalrm
argument_list|)
expr_stmt|;
comment|/* that can cause hanging in read() */
name|logflush
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|=
name|fcntl
argument_list|(
literal|0
argument_list|,
name|F_GETFL
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|sysfatal
argument_list|(
literal|"Can't get file mode flags on stdin"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|fcntl
argument_list|(
literal|0
argument_list|,
name|F_SETFL
argument_list|,
name|flags
operator||
name|O_NONBLOCK
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|sysfatal
argument_list|(
literal|"Can't set file mode flags on stdin"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|verbose
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"alarm"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|unalarm
parameter_list|()
block|{
name|int
name|flags
decl_stmt|;
if|if
condition|(
operator|(
name|flags
operator|=
name|fcntl
argument_list|(
literal|0
argument_list|,
name|F_GETFL
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|sysfatal
argument_list|(
literal|"Can't get file mode flags on stdin"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|fcntl
argument_list|(
literal|0
argument_list|,
name|F_SETFL
argument_list|,
name|flags
operator|&
operator|~
name|O_NONBLOCK
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|sysfatal
argument_list|(
literal|"Can't set file mode flags on stdin"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|SIGTYPE
name|sigint
parameter_list|(
name|signo
parameter_list|)
name|int
name|signo
decl_stmt|;
block|{
name|fatal
argument_list|(
literal|"SIGINT"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|SIGTYPE
name|sigterm
parameter_list|(
name|signo
parameter_list|)
name|int
name|signo
decl_stmt|;
block|{
name|fatal
argument_list|(
literal|"SIGTERM"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|SIGTYPE
name|sighup
parameter_list|(
name|signo
parameter_list|)
name|int
name|signo
decl_stmt|;
block|{
name|fatal
argument_list|(
literal|"SIGHUP"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|init
parameter_list|()
block|{
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|sigint
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|sigterm
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|sighup
argument_list|)
expr_stmt|;
name|set_tty_parameters
argument_list|()
expr_stmt|;
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|sigalrm
argument_list|)
expr_stmt|;
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|alarmed
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|set_tty_parameters
parameter_list|()
block|{
if|#
directive|if
name|defined
argument_list|(
name|get_term_param
argument_list|)
name|term_parms
name|t
decl_stmt|;
if|if
condition|(
name|get_term_param
argument_list|(
operator|&
name|t
argument_list|)
operator|<
literal|0
condition|)
block|{
name|have_tty_parameters
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|saved_tty_parameters
operator|=
name|t
expr_stmt|;
name|have_tty_parameters
operator|=
literal|1
expr_stmt|;
name|t
operator|.
name|c_iflag
operator||=
name|IGNBRK
operator||
name|ISTRIP
operator||
name|IGNPAR
expr_stmt|;
name|t
operator|.
name|c_oflag
operator|=
literal|0
expr_stmt|;
name|t
operator|.
name|c_lflag
operator|=
literal|0
expr_stmt|;
name|t
operator|.
name|c_cc
index|[
name|VERASE
index|]
operator|=
name|t
operator|.
name|c_cc
index|[
name|VKILL
index|]
operator|=
literal|0
expr_stmt|;
name|t
operator|.
name|c_cc
index|[
name|VMIN
index|]
operator|=
literal|1
expr_stmt|;
name|t
operator|.
name|c_cc
index|[
name|VTIME
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|set_term_param
argument_list|(
operator|&
name|t
argument_list|)
operator|<
literal|0
condition|)
block|{
name|sysfatal
argument_list|(
literal|"Can't set terminal parameters"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|break_sequence
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|TERMIOS
name|tcsendbreak
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|terminate
parameter_list|(
name|status
parameter_list|)
name|int
name|status
decl_stmt|;
block|{
name|echo_stderr
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|report_file
operator|!=
operator|(
name|char
operator|*
operator|)
literal|0
operator|&&
name|report_fp
operator|!=
operator|(
name|FILE
operator|*
operator|)
name|NULL
condition|)
block|{
comment|/*  * Allow the last of the report string to be gathered before we terminate.  */
if|if
condition|(
name|report_gathering
condition|)
block|{
name|int
name|c
decl_stmt|,
name|rep_len
decl_stmt|;
name|rep_len
operator|=
name|strlen
argument_list|(
name|report_buffer
argument_list|)
expr_stmt|;
while|while
condition|(
name|rep_len
operator|+
literal|1
operator|<=
sizeof|sizeof
argument_list|(
name|report_buffer
argument_list|)
condition|)
block|{
name|alarm
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|c
operator|=
name|get_char
argument_list|()
expr_stmt|;
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|0
operator|||
name|iscntrl
argument_list|(
name|c
argument_list|)
condition|)
break|break;
name|report_buffer
index|[
name|rep_len
index|]
operator|=
name|c
expr_stmt|;
operator|++
name|rep_len
expr_stmt|;
block|}
name|report_buffer
index|[
name|rep_len
index|]
operator|=
literal|0
expr_stmt|;
name|fprintf
argument_list|(
name|report_fp
argument_list|,
literal|"chat:  %s\n"
argument_list|,
name|report_buffer
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|verbose
condition|)
block|{
name|fprintf
argument_list|(
name|report_fp
argument_list|,
literal|"Closing \"%s\".\n"
argument_list|,
name|report_file
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|report_fp
argument_list|)
expr_stmt|;
name|report_fp
operator|=
operator|(
name|FILE
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|get_term_param
argument_list|)
if|if
condition|(
name|have_tty_parameters
condition|)
block|{
if|if
condition|(
name|set_term_param
argument_list|(
operator|&
name|saved_tty_parameters
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Can't restore terminal parameters: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|exit
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	'Clean up' this string.  */
end_comment

begin_function
name|char
modifier|*
name|clean
parameter_list|(
name|s
parameter_list|,
name|sending
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|sending
decl_stmt|;
block|{
name|char
name|temp
index|[
name|STR_LEN
index|]
decl_stmt|,
name|cur_chr
decl_stmt|;
specifier|register
name|char
modifier|*
name|s1
decl_stmt|;
name|int
name|add_return
init|=
name|sending
decl_stmt|;
define|#
directive|define
name|isoctal
parameter_list|(
name|chr
parameter_list|)
value|(((chr)>= '0')&& ((chr)<= '7'))
name|s1
operator|=
name|temp
expr_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
block|{
name|cur_chr
operator|=
operator|*
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|cur_chr
operator|==
literal|'^'
condition|)
block|{
name|cur_chr
operator|=
operator|*
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|cur_chr
operator|==
literal|'\0'
condition|)
block|{
operator|*
name|s1
operator|++
operator|=
literal|'^'
expr_stmt|;
break|break;
block|}
name|cur_chr
operator|&=
literal|0x1F
expr_stmt|;
if|if
condition|(
name|cur_chr
operator|!=
literal|0
condition|)
block|{
operator|*
name|s1
operator|++
operator|=
name|cur_chr
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
name|cur_chr
operator|!=
literal|'\\'
condition|)
block|{
operator|*
name|s1
operator|++
operator|=
name|cur_chr
expr_stmt|;
continue|continue;
block|}
name|cur_chr
operator|=
operator|*
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|cur_chr
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|sending
condition|)
block|{
operator|*
name|s1
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|s1
operator|++
operator|=
literal|'\\'
expr_stmt|;
block|}
break|break;
block|}
switch|switch
condition|(
name|cur_chr
condition|)
block|{
case|case
literal|'b'
case|:
operator|*
name|s1
operator|++
operator|=
literal|'\b'
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
if|if
condition|(
name|sending
operator|&&
operator|*
name|s
operator|==
literal|'\0'
condition|)
block|{
name|add_return
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
operator|*
name|s1
operator|++
operator|=
name|cur_chr
expr_stmt|;
block|}
break|break;
case|case
literal|'\\'
case|:
case|case
literal|'K'
case|:
case|case
literal|'p'
case|:
case|case
literal|'d'
case|:
if|if
condition|(
name|sending
condition|)
block|{
operator|*
name|s1
operator|++
operator|=
literal|'\\'
expr_stmt|;
block|}
operator|*
name|s1
operator|++
operator|=
name|cur_chr
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|quiet
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
operator|*
name|s1
operator|++
operator|=
literal|'\r'
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
operator|*
name|s1
operator|++
operator|=
literal|'\n'
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
operator|*
name|s1
operator|++
operator|=
literal|' '
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
operator|*
name|s1
operator|++
operator|=
literal|'\t'
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
if|if
condition|(
name|sending
condition|)
block|{
operator|*
name|s1
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|s1
operator|++
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
operator|*
name|s1
operator|++
operator|=
literal|'N'
expr_stmt|;
block|}
break|break;
default|default:
if|if
condition|(
name|isoctal
argument_list|(
name|cur_chr
argument_list|)
condition|)
block|{
name|cur_chr
operator|&=
literal|0x07
expr_stmt|;
if|if
condition|(
name|isoctal
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
name|cur_chr
operator|<<=
literal|3
expr_stmt|;
name|cur_chr
operator||=
operator|*
name|s
operator|++
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|isoctal
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
name|cur_chr
operator|<<=
literal|3
expr_stmt|;
name|cur_chr
operator||=
operator|*
name|s
operator|++
operator|-
literal|'0'
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cur_chr
operator|!=
literal|0
operator|||
name|sending
condition|)
block|{
if|if
condition|(
name|sending
operator|&&
operator|(
name|cur_chr
operator|==
literal|'\\'
operator|||
name|cur_chr
operator|==
literal|0
operator|)
condition|)
block|{
operator|*
name|s1
operator|++
operator|=
literal|'\\'
expr_stmt|;
block|}
operator|*
name|s1
operator|++
operator|=
name|cur_chr
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|sending
condition|)
block|{
operator|*
name|s1
operator|++
operator|=
literal|'\\'
expr_stmt|;
block|}
operator|*
name|s1
operator|++
operator|=
name|cur_chr
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|add_return
condition|)
block|{
operator|*
name|s1
operator|++
operator|=
literal|'\r'
expr_stmt|;
block|}
operator|*
name|s1
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* guarantee closure */
operator|*
name|s1
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* terminate the string */
return|return
name|dup_mem
argument_list|(
name|temp
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|s1
operator|-
name|temp
argument_list|)
argument_list|)
return|;
comment|/* may have embedded nuls */
block|}
end_function

begin_comment
comment|/*  * A modified version of 'strtok'. This version skips \ sequences.  */
end_comment

begin_function
name|char
modifier|*
name|expect_strtok
parameter_list|(
name|s
parameter_list|,
name|term
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|,
decl|*
name|term
decl_stmt|;
end_function

begin_block
block|{
specifier|static
name|char
modifier|*
name|str
init|=
literal|""
decl_stmt|;
name|int
name|escape_flag
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|result
decl_stmt|;
comment|/*  * If a string was specified then do initial processing.  */
if|if
condition|(
name|s
condition|)
block|{
name|str
operator|=
name|s
expr_stmt|;
block|}
comment|/*  * If this is the escape flag then reset it and ignore the character.  */
if|if
condition|(
operator|*
name|str
condition|)
block|{
name|result
operator|=
name|str
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
block|}
while|while
condition|(
operator|*
name|str
condition|)
block|{
if|if
condition|(
name|escape_flag
condition|)
block|{
name|escape_flag
operator|=
literal|0
expr_stmt|;
operator|++
name|str
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|*
name|str
operator|==
literal|'\\'
condition|)
block|{
operator|++
name|str
expr_stmt|;
name|escape_flag
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
comment|/*  * If this is not in the termination string, continue.  */
if|if
condition|(
name|strchr
argument_list|(
name|term
argument_list|,
operator|*
name|str
argument_list|)
operator|==
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
block|{
operator|++
name|str
expr_stmt|;
continue|continue;
block|}
comment|/*  * This is the terminator. Mark the end of the string and stop.  */
operator|*
name|str
operator|++
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Process the expect string  */
end_comment

begin_function
name|void
name|chat_expect
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|char
modifier|*
name|expect
decl_stmt|;
name|char
modifier|*
name|reply
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"HANGUP"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|++
name|hup_next
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"ABORT"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|++
name|abort_next
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"CLR_ABORT"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|++
name|clear_abort_next
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"REPORT"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|++
name|report_next
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"CLR_REPORT"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|++
name|clear_report_next
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"TIMEOUT"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|++
name|timeout_next
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"ECHO"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|++
name|echo_next
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"SAY"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|++
name|say_next
expr_stmt|;
return|return;
block|}
comment|/*  * Fetch the expect and reply string.  */
for|for
control|(
init|;
condition|;
control|)
block|{
name|expect
operator|=
name|expect_strtok
argument_list|(
name|s
argument_list|,
literal|"-"
argument_list|)
expr_stmt|;
name|s
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
if|if
condition|(
name|expect
operator|==
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
block|{
return|return;
block|}
name|reply
operator|=
name|expect_strtok
argument_list|(
name|s
argument_list|,
literal|"-"
argument_list|)
expr_stmt|;
comment|/*  * Handle the expect string. If successful then exit.  */
if|if
condition|(
name|get_string
argument_list|(
name|expect
argument_list|)
condition|)
block|{
return|return;
block|}
comment|/*  * If there is a sub-reply string then send it. Otherwise any condition  * is terminal.  */
if|if
condition|(
name|reply
operator|==
operator|(
name|char
operator|*
operator|)
literal|0
operator|||
name|exit_code
operator|!=
literal|3
condition|)
block|{
break|break;
block|}
name|chat_send
argument_list|(
name|reply
argument_list|)
expr_stmt|;
block|}
comment|/*  * The expectation did not occur. This is terminal.  */
if|if
condition|(
name|fail_reason
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"Failed (%s)"
argument_list|,
name|fail_reason
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"Failed"
argument_list|)
expr_stmt|;
block|}
name|terminate
argument_list|(
name|exit_code
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Translate the input character to the appropriate string for printing  * the data.  */
end_comment

begin_function
name|char
modifier|*
name|character
parameter_list|(
name|c
parameter_list|)
name|int
name|c
decl_stmt|;
block|{
specifier|static
name|char
name|string
index|[
literal|10
index|]
decl_stmt|;
name|char
modifier|*
name|meta
decl_stmt|;
name|meta
operator|=
operator|(
name|c
operator|&
literal|0x80
operator|)
condition|?
literal|"M-"
else|:
literal|""
expr_stmt|;
name|c
operator|&=
literal|0x7F
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|32
condition|)
block|{
name|sprintf
argument_list|(
name|string
argument_list|,
literal|"%s^%c"
argument_list|,
name|meta
argument_list|,
operator|(
name|int
operator|)
name|c
operator|+
literal|'@'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|c
operator|==
literal|127
condition|)
block|{
name|sprintf
argument_list|(
name|string
argument_list|,
literal|"%s^?"
argument_list|,
name|meta
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|string
argument_list|,
literal|"%s%c"
argument_list|,
name|meta
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|string
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  process the reply string  */
end_comment

begin_function
name|void
name|chat_send
parameter_list|(
name|s
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
block|{
if|if
condition|(
name|say_next
condition|)
block|{
name|say_next
operator|=
literal|0
expr_stmt|;
name|s
operator|=
name|clean
argument_list|(
name|s
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|write
argument_list|(
literal|2
argument_list|,
name|s
argument_list|,
name|strlen
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|hup_next
condition|)
block|{
name|hup_next
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"OFF"
argument_list|)
operator|==
literal|0
condition|)
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
else|else
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|sighup
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|echo_next
condition|)
block|{
name|echo_next
operator|=
literal|0
expr_stmt|;
name|echo
operator|=
operator|(
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"ON"
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|abort_next
condition|)
block|{
name|char
modifier|*
name|s1
decl_stmt|;
name|abort_next
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|n_aborts
operator|>=
name|MAX_ABORTS
condition|)
block|{
name|fatal
argument_list|(
literal|"Too many ABORT strings"
argument_list|)
expr_stmt|;
block|}
name|s1
operator|=
name|clean
argument_list|(
name|s
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|s1
argument_list|)
operator|>
name|strlen
argument_list|(
name|s
argument_list|)
operator|||
name|strlen
argument_list|(
name|s1
argument_list|)
operator|+
literal|1
operator|>
sizeof|sizeof
argument_list|(
name|fail_buffer
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"Illegal or too-long ABORT string ('%s')"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|die
argument_list|()
expr_stmt|;
block|}
name|abort_string
index|[
name|n_aborts
operator|++
index|]
operator|=
name|s1
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
block|{
name|logf
argument_list|(
literal|"abort on ("
argument_list|)
expr_stmt|;
for|for
control|(
name|s1
operator|=
name|s
init|;
operator|*
name|s1
condition|;
operator|++
name|s1
control|)
block|{
name|logf
argument_list|(
name|character
argument_list|(
operator|*
name|s1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|logf
argument_list|(
literal|")\n"
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|clear_abort_next
condition|)
block|{
name|char
modifier|*
name|s1
decl_stmt|;
name|char
modifier|*
name|s2
init|=
name|s
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|old_max
decl_stmt|;
name|int
name|pack
init|=
literal|0
decl_stmt|;
name|clear_abort_next
operator|=
literal|0
expr_stmt|;
name|s1
operator|=
name|clean
argument_list|(
name|s
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|s1
argument_list|)
operator|>
name|strlen
argument_list|(
name|s
argument_list|)
operator|||
name|strlen
argument_list|(
name|s1
argument_list|)
operator|+
literal|1
operator|>
sizeof|sizeof
argument_list|(
name|fail_buffer
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"Illegal or too-long CLR_ABORT string ('%s')"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|die
argument_list|()
expr_stmt|;
block|}
name|old_max
operator|=
name|n_aborts
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_aborts
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|s1
argument_list|,
name|abort_string
index|[
name|i
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|abort_string
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|abort_string
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|pack
operator|++
expr_stmt|;
name|n_aborts
operator|--
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
block|{
name|logf
argument_list|(
literal|"clear abort on ("
argument_list|)
expr_stmt|;
for|for
control|(
name|s2
operator|=
name|s
init|;
operator|*
name|s2
condition|;
operator|++
name|s2
control|)
block|{
name|logf
argument_list|(
name|character
argument_list|(
operator|*
name|s2
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|logf
argument_list|(
literal|")\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|free
argument_list|(
name|s1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pack
condition|)
name|pack_array
argument_list|(
name|abort_string
argument_list|,
name|old_max
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|report_next
condition|)
block|{
name|char
modifier|*
name|s1
decl_stmt|;
name|report_next
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|n_reports
operator|>=
name|MAX_REPORTS
condition|)
block|{
name|fatal
argument_list|(
literal|"Too many REPORT strings"
argument_list|)
expr_stmt|;
block|}
name|s1
operator|=
name|clean
argument_list|(
name|s
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|s1
argument_list|)
operator|>
name|strlen
argument_list|(
name|s
argument_list|)
operator|||
name|strlen
argument_list|(
name|s1
argument_list|)
operator|>
sizeof|sizeof
name|fail_buffer
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"Illegal or too-long REPORT string ('%s')"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|die
argument_list|()
expr_stmt|;
block|}
name|report_string
index|[
name|n_reports
operator|++
index|]
operator|=
name|s1
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
block|{
name|logf
argument_list|(
literal|"report ("
argument_list|)
expr_stmt|;
name|s1
operator|=
name|s
expr_stmt|;
while|while
condition|(
operator|*
name|s1
condition|)
block|{
name|logf
argument_list|(
name|character
argument_list|(
operator|*
name|s1
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|s1
expr_stmt|;
block|}
name|logf
argument_list|(
literal|")\n"
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|clear_report_next
condition|)
block|{
name|char
modifier|*
name|s1
decl_stmt|;
name|char
modifier|*
name|s2
init|=
name|s
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|old_max
decl_stmt|;
name|int
name|pack
init|=
literal|0
decl_stmt|;
name|clear_report_next
operator|=
literal|0
expr_stmt|;
name|s1
operator|=
name|clean
argument_list|(
name|s
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|s1
argument_list|)
operator|>
name|strlen
argument_list|(
name|s
argument_list|)
operator|||
name|strlen
argument_list|(
name|s1
argument_list|)
operator|>
sizeof|sizeof
name|fail_buffer
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"Illegal or too-long REPORT string ('%s')"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|die
argument_list|()
expr_stmt|;
block|}
name|old_max
operator|=
name|n_reports
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_reports
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|s1
argument_list|,
name|report_string
index|[
name|i
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|report_string
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|report_string
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|pack
operator|++
expr_stmt|;
name|n_reports
operator|--
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
block|{
name|logf
argument_list|(
literal|"clear report ("
argument_list|)
expr_stmt|;
for|for
control|(
name|s2
operator|=
name|s
init|;
operator|*
name|s2
condition|;
operator|++
name|s2
control|)
block|{
name|logf
argument_list|(
name|character
argument_list|(
operator|*
name|s2
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|logf
argument_list|(
literal|")\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|free
argument_list|(
name|s1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pack
condition|)
name|pack_array
argument_list|(
name|report_string
argument_list|,
name|old_max
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|timeout_next
condition|)
block|{
name|timeout_next
operator|=
literal|0
expr_stmt|;
name|timeout
operator|=
name|atoi
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|timeout
operator|<=
literal|0
condition|)
block|{
name|timeout
operator|=
name|DEFAULT_CHAT_TIMEOUT
expr_stmt|;
block|}
if|if
condition|(
name|verbose
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"timeout set to %d seconds"
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"EOT"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|s
operator|=
literal|"^D\\c"
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"BREAK"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|s
operator|=
literal|"\\K\\c"
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|put_string
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"Failed"
argument_list|)
expr_stmt|;
name|terminate
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|get_char
parameter_list|()
block|{
name|int
name|status
decl_stmt|;
name|char
name|c
decl_stmt|;
name|status
operator|=
name|read
argument_list|(
literal|0
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|status
condition|)
block|{
case|case
literal|1
case|:
return|return
operator|(
operator|(
name|int
operator|)
name|c
operator|&
literal|0x7F
operator|)
return|;
default|default:
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"warning: read() on stdin returned %d"
argument_list|,
name|status
argument_list|)
expr_stmt|;
case|case
operator|-
literal|1
case|:
if|if
condition|(
operator|(
name|status
operator|=
name|fcntl
argument_list|(
literal|0
argument_list|,
name|F_GETFL
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|sysfatal
argument_list|(
literal|"Can't get file mode flags on stdin"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|fcntl
argument_list|(
literal|0
argument_list|,
name|F_SETFL
argument_list|,
name|status
operator|&
operator|~
name|O_NONBLOCK
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|sysfatal
argument_list|(
literal|"Can't set file mode flags on stdin"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
end_function

begin_function
name|int
name|put_char
parameter_list|(
name|c
parameter_list|)
name|int
name|c
decl_stmt|;
block|{
name|int
name|status
decl_stmt|;
name|char
name|ch
init|=
name|c
decl_stmt|;
name|usleep
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
comment|/* inter-character typing delay (?) */
name|status
operator|=
name|write
argument_list|(
literal|1
argument_list|,
operator|&
name|ch
argument_list|,
literal|1
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|status
condition|)
block|{
case|case
literal|1
case|:
return|return
operator|(
literal|0
operator|)
return|;
default|default:
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"warning: write() on stdout returned %d"
argument_list|,
name|status
argument_list|)
expr_stmt|;
case|case
operator|-
literal|1
case|:
if|if
condition|(
operator|(
name|status
operator|=
name|fcntl
argument_list|(
literal|0
argument_list|,
name|F_GETFL
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|sysfatal
argument_list|(
literal|"Can't get file mode flags on stdin"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|fcntl
argument_list|(
literal|0
argument_list|,
name|F_SETFL
argument_list|,
name|status
operator|&
operator|~
name|O_NONBLOCK
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|sysfatal
argument_list|(
literal|"Can't set file mode flags on stdin"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
end_function

begin_function
name|int
name|write_char
parameter_list|(
name|c
parameter_list|)
name|int
name|c
decl_stmt|;
block|{
if|if
condition|(
name|alarmed
operator|||
name|put_char
argument_list|(
name|c
argument_list|)
operator|<
literal|0
condition|)
block|{
specifier|extern
name|int
name|errno
decl_stmt|;
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|alarmed
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EINTR
operator|||
name|errno
operator|==
name|EWOULDBLOCK
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|" -- write timed out"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|" -- write failed: %m"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|put_string
parameter_list|(
name|s
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|quiet
operator|=
literal|0
expr_stmt|;
name|s
operator|=
name|clean
argument_list|(
name|s
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
block|{
name|logf
argument_list|(
literal|"send ("
argument_list|)
expr_stmt|;
if|if
condition|(
name|quiet
condition|)
block|{
name|logf
argument_list|(
literal|"??????"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|register
name|char
modifier|*
name|s1
init|=
name|s
decl_stmt|;
for|for
control|(
name|s1
operator|=
name|s
init|;
operator|*
name|s1
condition|;
operator|++
name|s1
control|)
block|{
name|logf
argument_list|(
name|character
argument_list|(
operator|*
name|s1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|logf
argument_list|(
literal|")\n"
argument_list|)
expr_stmt|;
block|}
name|alarm
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
name|alarmed
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
block|{
specifier|register
name|char
name|c
init|=
operator|*
name|s
operator|++
decl_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'\\'
condition|)
block|{
if|if
condition|(
operator|!
name|write_char
argument_list|(
name|c
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
continue|continue;
block|}
name|c
operator|=
operator|*
name|s
operator|++
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'d'
case|:
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'K'
case|:
name|break_sequence
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|usleep
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
comment|/* 1/100th of a second (arg is microseconds) */
break|break;
default|default:
if|if
condition|(
operator|!
name|write_char
argument_list|(
name|c
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
block|}
block|}
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|alarmed
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	Echo a character to stderr.  *	When called with -1, a '\n' character is generated when  *	the cursor is not at the beginning of a line.  */
end_comment

begin_function
name|void
name|echo_stderr
parameter_list|(
name|n
parameter_list|)
name|int
name|n
decl_stmt|;
block|{
specifier|static
name|int
name|need_lf
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
switch|switch
condition|(
name|n
condition|)
block|{
case|case
literal|'\r'
case|:
comment|/* ignore '\r' */
break|break;
case|case
operator|-
literal|1
case|:
if|if
condition|(
name|need_lf
operator|==
literal|0
condition|)
break|break;
comment|/* fall through */
case|case
literal|'\n'
case|:
name|write
argument_list|(
literal|2
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|need_lf
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|s
operator|=
name|character
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|write
argument_list|(
literal|2
argument_list|,
name|s
argument_list|,
name|strlen
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|need_lf
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  *	'Wait for' this string to appear on this file descriptor.  */
end_comment

begin_function
name|int
name|get_string
parameter_list|(
name|string
parameter_list|)
specifier|register
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|char
name|temp
index|[
name|STR_LEN
index|]
decl_stmt|;
name|int
name|c
decl_stmt|,
name|printed
init|=
literal|0
decl_stmt|,
name|len
decl_stmt|,
name|minlen
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
init|=
name|temp
decl_stmt|,
modifier|*
name|end
init|=
name|s
operator|+
name|STR_LEN
decl_stmt|;
name|fail_reason
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
name|string
operator|=
name|clean
argument_list|(
name|string
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|string
argument_list|)
expr_stmt|;
name|minlen
operator|=
operator|(
name|len
operator|>
sizeof|sizeof
argument_list|(
name|fail_buffer
argument_list|)
condition|?
name|len
else|:
sizeof|sizeof
argument_list|(
name|fail_buffer
argument_list|)
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
block|{
specifier|register
name|char
modifier|*
name|s1
decl_stmt|;
name|logf
argument_list|(
literal|"expect ("
argument_list|)
expr_stmt|;
for|for
control|(
name|s1
operator|=
name|string
init|;
operator|*
name|s1
condition|;
operator|++
name|s1
control|)
block|{
name|logf
argument_list|(
name|character
argument_list|(
operator|*
name|s1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|logf
argument_list|(
literal|")\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|>
name|STR_LEN
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"expect string is too long"
argument_list|)
expr_stmt|;
name|exit_code
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"got it"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|alarm
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
name|alarmed
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|alarmed
operator|&&
operator|(
name|c
operator|=
name|get_char
argument_list|()
operator|)
operator|>=
literal|0
condition|)
block|{
name|int
name|n
decl_stmt|,
name|abort_len
decl_stmt|,
name|report_len
decl_stmt|;
if|if
condition|(
name|echo
condition|)
block|{
name|echo_stderr
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|verbose
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
name|logf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|logf
argument_list|(
name|character
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|Verbose
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|!=
literal|'\r'
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s"
argument_list|,
name|character
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|*
name|s
operator|++
operator|=
name|c
expr_stmt|;
if|if
condition|(
operator|!
name|report_gathering
condition|)
block|{
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|n_reports
condition|;
operator|++
name|n
control|)
block|{
if|if
condition|(
operator|(
name|report_string
index|[
name|n
index|]
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
operator|&&
name|s
operator|-
name|temp
operator|>=
operator|(
name|report_len
operator|=
name|strlen
argument_list|(
name|report_string
index|[
name|n
index|]
argument_list|)
operator|)
operator|&&
name|strncmp
argument_list|(
name|s
operator|-
name|report_len
argument_list|,
name|report_string
index|[
name|n
index|]
argument_list|,
name|report_len
argument_list|)
operator|==
literal|0
condition|)
block|{
name|time_t
name|time_now
init|=
name|time
argument_list|(
operator|(
name|time_t
operator|*
operator|)
name|NULL
argument_list|)
decl_stmt|;
name|struct
name|tm
modifier|*
name|tm_now
init|=
name|localtime
argument_list|(
operator|&
name|time_now
argument_list|)
decl_stmt|;
name|strftime
argument_list|(
name|report_buffer
argument_list|,
literal|20
argument_list|,
literal|"%b %d %H:%M:%S "
argument_list|,
name|tm_now
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|report_buffer
argument_list|,
name|report_string
index|[
name|n
index|]
argument_list|)
expr_stmt|;
name|report_string
index|[
name|n
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|report_gathering
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|iscntrl
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|int
name|rep_len
init|=
name|strlen
argument_list|(
name|report_buffer
argument_list|)
decl_stmt|;
name|report_buffer
index|[
name|rep_len
index|]
operator|=
name|c
expr_stmt|;
name|report_buffer
index|[
name|rep_len
operator|+
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
name|report_gathering
operator|=
literal|0
expr_stmt|;
name|fprintf
argument_list|(
name|report_fp
argument_list|,
literal|"chat:  %s\n"
argument_list|,
name|report_buffer
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|s
operator|-
name|temp
operator|>=
name|len
operator|&&
name|c
operator|==
name|string
index|[
name|len
operator|-
literal|1
index|]
operator|&&
name|strncmp
argument_list|(
name|s
operator|-
name|len
argument_list|,
name|string
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
block|{
name|logf
argument_list|(
literal|" -- got it\n"
argument_list|)
expr_stmt|;
block|}
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|alarmed
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|n_aborts
condition|;
operator|++
name|n
control|)
block|{
if|if
condition|(
name|s
operator|-
name|temp
operator|>=
operator|(
name|abort_len
operator|=
name|strlen
argument_list|(
name|abort_string
index|[
name|n
index|]
argument_list|)
operator|)
operator|&&
name|strncmp
argument_list|(
name|s
operator|-
name|abort_len
argument_list|,
name|abort_string
index|[
name|n
index|]
argument_list|,
name|abort_len
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
block|{
name|logf
argument_list|(
literal|" -- failed\n"
argument_list|)
expr_stmt|;
block|}
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|alarmed
operator|=
literal|0
expr_stmt|;
name|exit_code
operator|=
name|n
operator|+
literal|4
expr_stmt|;
name|strcpy
argument_list|(
name|fail_reason
operator|=
name|fail_buffer
argument_list|,
name|abort_string
index|[
name|n
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
if|if
condition|(
name|s
operator|>=
name|end
condition|)
block|{
name|strncpy
argument_list|(
name|temp
argument_list|,
name|s
operator|-
name|minlen
argument_list|,
name|minlen
argument_list|)
expr_stmt|;
name|s
operator|=
name|temp
operator|+
name|minlen
expr_stmt|;
block|}
if|if
condition|(
name|alarmed
operator|&&
name|verbose
condition|)
block|{
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"warning: alarm synchronization problem"
argument_list|)
expr_stmt|;
block|}
block|}
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
operator|&&
name|printed
condition|)
block|{
if|if
condition|(
name|alarmed
condition|)
block|{
name|logf
argument_list|(
literal|" -- read timed out\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|logflush
argument_list|()
expr_stmt|;
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|" -- read failed: %m"
argument_list|)
expr_stmt|;
block|}
block|}
name|exit_code
operator|=
literal|3
expr_stmt|;
name|alarmed
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|NO_USLEEP
end_ifdef

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_comment
comment|/*   usleep -- support routine for 4.2BSD system call emulations   last edit:  29-Oct-1984     D A Gwyn   */
end_comment

begin_function_decl
specifier|extern
name|int
name|select
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|int
name|usleep
parameter_list|(
name|usec
parameter_list|)
comment|/* returns 0 if ok, else -1 */
name|long
name|usec
decl_stmt|;
comment|/* delay in microseconds */
block|{
specifier|static
struct|struct
comment|/* `timeval' */
block|{
name|long
name|tv_sec
decl_stmt|;
comment|/* seconds */
name|long
name|tv_usec
decl_stmt|;
comment|/* microsecs */
block|}
name|delay
struct|;
comment|/* _select() timeout */
name|delay
operator|.
name|tv_sec
operator|=
name|usec
operator|/
literal|1000000L
expr_stmt|;
name|delay
operator|.
name|tv_usec
operator|=
name|usec
operator|%
literal|1000000L
expr_stmt|;
return|return
name|select
argument_list|(
literal|0
argument_list|,
operator|(
name|long
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|long
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|long
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|delay
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|pack_array
parameter_list|(
name|array
parameter_list|,
name|end
parameter_list|)
name|char
modifier|*
modifier|*
name|array
decl_stmt|;
comment|/* The address of the array of string pointers */
name|int
name|end
decl_stmt|;
comment|/* The index of the next free entry before CLR_ */
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|end
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|array
index|[
name|i
index|]
operator|==
name|NULL
condition|)
block|{
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|end
condition|;
operator|++
name|j
control|)
if|if
condition|(
name|array
index|[
name|j
index|]
operator|!=
name|NULL
condition|)
name|array
index|[
name|i
operator|++
index|]
operator|=
name|array
index|[
name|j
index|]
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|end
condition|;
operator|++
name|i
control|)
name|array
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

end_unit

