begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   *  parsetime.c - parse time for at(1)  *  Copyright (C) 1993, 1994  Thomas Koenig  *  *  modifications for English-language times  *  Copyright (C) 1993  David Parsons  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. The name of the author(s) may not be used to endorse or promote  *    products derived from this software without specific prior written  *    permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  *  at [NOW] PLUS NUMBER MINUTES|HOURS|DAYS|WEEKS  *     /NUMBER [DOT NUMBER] [AM|PM]\ /[MONTH NUMBER [NUMBER]]             \  *     |NOON                       | |[TOMORROW]                          |  *     |MIDNIGHT                   | |[DAY OF WEEK]                       |  *     \TEATIME                    / |NUMBER [SLASH NUMBER [SLASH NUMBER]]|  *                                   \PLUS NUMBER MINUTES|HOURS|DAYS|WEEKS/  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/* System Headers */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|__FreeBSD__
end_ifndef

begin_include
include|#
directive|include
file|<getopt.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Local headers */
end_comment

begin_include
include|#
directive|include
file|"at.h"
end_include

begin_include
include|#
directive|include
file|"panic.h"
end_include

begin_comment
comment|/* Structures and unions */
end_comment

begin_enum
enum|enum
block|{
comment|/* symbols */
name|MIDNIGHT
block|,
name|NOON
block|,
name|TEATIME
block|,
name|PM
block|,
name|AM
block|,
name|TOMORROW
block|,
name|TODAY
block|,
name|NOW
block|,
name|MINUTES
block|,
name|HOURS
block|,
name|DAYS
block|,
name|WEEKS
block|,
name|MONTHS
block|,
name|YEARS
block|,
name|NUMBER
block|,
name|PLUS
block|,
name|DOT
block|,
name|SLASH
block|,
name|ID
block|,
name|JUNK
block|,
name|JAN
block|,
name|FEB
block|,
name|MAR
block|,
name|APR
block|,
name|MAY
block|,
name|JUN
block|,
name|JUL
block|,
name|AUG
block|,
name|SEP
block|,
name|OCT
block|,
name|NOV
block|,
name|DEC
block|,
name|SUN
block|,
name|MON
block|,
name|TUE
block|,
name|WED
block|,
name|THU
block|,
name|FRI
block|,
name|SAT
block|}
enum|;
end_enum

begin_comment
comment|/* parse translation table - table driven parsers can be your FRIEND!  */
end_comment

begin_struct
struct|struct
block|{
name|char
modifier|*
name|name
decl_stmt|;
comment|/* token name */
name|int
name|value
decl_stmt|;
comment|/* token id */
name|int
name|plural
decl_stmt|;
comment|/* is this plural? */
block|}
name|Specials
index|[]
init|=
block|{
block|{
literal|"midnight"
block|,
name|MIDNIGHT
block|,
literal|0
block|}
block|,
comment|/* 00:00:00 of today or tomorrow */
block|{
literal|"noon"
block|,
name|NOON
block|,
literal|0
block|}
block|,
comment|/* 12:00:00 of today or tomorrow */
block|{
literal|"teatime"
block|,
name|TEATIME
block|,
literal|0
block|}
block|,
comment|/* 16:00:00 of today or tomorrow */
block|{
literal|"am"
block|,
name|AM
block|,
literal|0
block|}
block|,
comment|/* morning times for 0-12 clock */
block|{
literal|"pm"
block|,
name|PM
block|,
literal|0
block|}
block|,
comment|/* evening times for 0-12 clock */
block|{
literal|"tomorrow"
block|,
name|TOMORROW
block|,
literal|0
block|}
block|,
comment|/* execute 24 hours from time */
block|{
literal|"today"
block|,
name|TODAY
block|,
literal|0
block|}
block|,
comment|/* execute today - don't advance time */
block|{
literal|"now"
block|,
name|NOW
block|,
literal|0
block|}
block|,
comment|/* opt prefix for PLUS */
block|{
literal|"minute"
block|,
name|MINUTES
block|,
literal|0
block|}
block|,
comment|/* minutes multiplier */
block|{
literal|"minutes"
block|,
name|MINUTES
block|,
literal|1
block|}
block|,
comment|/* (pluralized) */
block|{
literal|"hour"
block|,
name|HOURS
block|,
literal|0
block|}
block|,
comment|/* hours ... */
block|{
literal|"hours"
block|,
name|HOURS
block|,
literal|1
block|}
block|,
comment|/* (pluralized) */
block|{
literal|"day"
block|,
name|DAYS
block|,
literal|0
block|}
block|,
comment|/* days ... */
block|{
literal|"days"
block|,
name|DAYS
block|,
literal|1
block|}
block|,
comment|/* (pluralized) */
block|{
literal|"week"
block|,
name|WEEKS
block|,
literal|0
block|}
block|,
comment|/* week ... */
block|{
literal|"weeks"
block|,
name|WEEKS
block|,
literal|1
block|}
block|,
comment|/* (pluralized) */
block|{
literal|"month"
block|,
name|MONTHS
block|,
literal|0
block|}
block|,
comment|/* month ... */
block|{
literal|"months"
block|,
name|MONTHS
block|,
literal|1
block|}
block|,
comment|/* (pluralized) */
block|{
literal|"year"
block|,
name|YEARS
block|,
literal|0
block|}
block|,
comment|/* year ... */
block|{
literal|"years"
block|,
name|YEARS
block|,
literal|1
block|}
block|,
comment|/* (pluralized) */
block|{
literal|"jan"
block|,
name|JAN
block|,
literal|0
block|}
block|,
block|{
literal|"feb"
block|,
name|FEB
block|,
literal|0
block|}
block|,
block|{
literal|"mar"
block|,
name|MAR
block|,
literal|0
block|}
block|,
block|{
literal|"apr"
block|,
name|APR
block|,
literal|0
block|}
block|,
block|{
literal|"may"
block|,
name|MAY
block|,
literal|0
block|}
block|,
block|{
literal|"jun"
block|,
name|JUN
block|,
literal|0
block|}
block|,
block|{
literal|"jul"
block|,
name|JUL
block|,
literal|0
block|}
block|,
block|{
literal|"aug"
block|,
name|AUG
block|,
literal|0
block|}
block|,
block|{
literal|"sep"
block|,
name|SEP
block|,
literal|0
block|}
block|,
block|{
literal|"oct"
block|,
name|OCT
block|,
literal|0
block|}
block|,
block|{
literal|"nov"
block|,
name|NOV
block|,
literal|0
block|}
block|,
block|{
literal|"dec"
block|,
name|DEC
block|,
literal|0
block|}
block|,
block|{
literal|"january"
block|,
name|JAN
block|,
literal|0
block|}
block|,
block|{
literal|"february"
block|,
name|FEB
block|,
literal|0
block|}
block|,
block|{
literal|"march"
block|,
name|MAR
block|,
literal|0
block|}
block|,
block|{
literal|"april"
block|,
name|APR
block|,
literal|0
block|}
block|,
block|{
literal|"may"
block|,
name|MAY
block|,
literal|0
block|}
block|,
block|{
literal|"june"
block|,
name|JUN
block|,
literal|0
block|}
block|,
block|{
literal|"july"
block|,
name|JUL
block|,
literal|0
block|}
block|,
block|{
literal|"august"
block|,
name|AUG
block|,
literal|0
block|}
block|,
block|{
literal|"september"
block|,
name|SEP
block|,
literal|0
block|}
block|,
block|{
literal|"october"
block|,
name|OCT
block|,
literal|0
block|}
block|,
block|{
literal|"november"
block|,
name|NOV
block|,
literal|0
block|}
block|,
block|{
literal|"december"
block|,
name|DEC
block|,
literal|0
block|}
block|,
block|{
literal|"sunday"
block|,
name|SUN
block|,
literal|0
block|}
block|,
block|{
literal|"sun"
block|,
name|SUN
block|,
literal|0
block|}
block|,
block|{
literal|"monday"
block|,
name|MON
block|,
literal|0
block|}
block|,
block|{
literal|"mon"
block|,
name|MON
block|,
literal|0
block|}
block|,
block|{
literal|"tuesday"
block|,
name|TUE
block|,
literal|0
block|}
block|,
block|{
literal|"tue"
block|,
name|TUE
block|,
literal|0
block|}
block|,
block|{
literal|"wednesday"
block|,
name|WED
block|,
literal|0
block|}
block|,
block|{
literal|"wed"
block|,
name|WED
block|,
literal|0
block|}
block|,
block|{
literal|"thursday"
block|,
name|THU
block|,
literal|0
block|}
block|,
block|{
literal|"thu"
block|,
name|THU
block|,
literal|0
block|}
block|,
block|{
literal|"friday"
block|,
name|FRI
block|,
literal|0
block|}
block|,
block|{
literal|"fri"
block|,
name|FRI
block|,
literal|0
block|}
block|,
block|{
literal|"saturday"
block|,
name|SAT
block|,
literal|0
block|}
block|,
block|{
literal|"sat"
block|,
name|SAT
block|,
literal|0
block|}
block|, }
struct|;
end_struct

begin_comment
comment|/* File scope variables */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|scp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* scanner - pointer at arglist */
end_comment

begin_decl_stmt
specifier|static
name|char
name|scc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* scanner - count of remaining arguments */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|sct
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* scanner - next char pointer in current argument */
end_comment

begin_decl_stmt
specifier|static
name|int
name|need
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* scanner - need to advance to next argument */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|sc_token
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* scanner - token buffer */
end_comment

begin_decl_stmt
specifier|static
name|size_t
name|sc_len
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* scanner - length of token buffer */
end_comment

begin_decl_stmt
specifier|static
name|int
name|sc_tokid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* scanner - token id */
end_comment

begin_decl_stmt
specifier|static
name|int
name|sc_tokplur
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* scanner - is token plural? */
end_comment

begin_comment
comment|/* Local functions */
end_comment

begin_comment
comment|/*  * parse a token, checking if it's something special to us  */
end_comment

begin_function
specifier|static
name|int
name|parse_token
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
sizeof|sizeof
name|Specials
operator|/
sizeof|sizeof
name|Specials
index|[
literal|0
index|]
operator|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcasecmp
argument_list|(
name|Specials
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|arg
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sc_tokplur
operator|=
name|Specials
index|[
name|i
index|]
operator|.
name|plural
expr_stmt|;
return|return
name|sc_tokid
operator|=
name|Specials
index|[
name|i
index|]
operator|.
name|value
return|;
block|}
comment|/* not special - must be some random id */
return|return
name|ID
return|;
block|}
end_function

begin_comment
comment|/* parse_token */
end_comment

begin_comment
comment|/*  * init_scanner() sets up the scanner to eat arguments  */
end_comment

begin_function
specifier|static
name|void
name|init_scanner
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|scp
operator|=
name|argv
expr_stmt|;
name|scc
operator|=
name|argc
expr_stmt|;
name|need
operator|=
literal|1
expr_stmt|;
name|sc_len
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|argc
operator|--
operator|>
literal|0
condition|)
name|sc_len
operator|+=
name|strlen
argument_list|(
operator|*
name|argv
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc_token
operator|=
name|malloc
argument_list|(
name|sc_len
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"virtual memory exhausted"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* init_scanner */
end_comment

begin_comment
comment|/*  * token() fetches a token from the input stream  */
end_comment

begin_function
specifier|static
name|int
name|token
parameter_list|()
block|{
name|int
name|idx
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|memset
argument_list|(
name|sc_token
argument_list|,
literal|0
argument_list|,
name|sc_len
argument_list|)
expr_stmt|;
name|sc_tokid
operator|=
name|EOF
expr_stmt|;
name|sc_tokplur
operator|=
literal|0
expr_stmt|;
name|idx
operator|=
literal|0
expr_stmt|;
comment|/* if we need to read another argument, walk along the argument list; 	 * when we fall off the arglist, we'll just return EOF forever 	 */
if|if
condition|(
name|need
condition|)
block|{
if|if
condition|(
name|scc
operator|<
literal|1
condition|)
return|return
name|sc_tokid
return|;
name|sct
operator|=
operator|*
name|scp
expr_stmt|;
name|scp
operator|++
expr_stmt|;
name|scc
operator|--
expr_stmt|;
name|need
operator|=
literal|0
expr_stmt|;
block|}
comment|/* eat whitespace now - if we walk off the end of the argument, 	 * we'll continue, which puts us up at the top of the while loop 	 * to fetch the next argument in 	 */
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|sct
argument_list|)
condition|)
operator|++
name|sct
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|sct
condition|)
block|{
name|need
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
comment|/* preserve the first character of the new token 	 */
name|sc_token
index|[
literal|0
index|]
operator|=
operator|*
name|sct
operator|++
expr_stmt|;
comment|/* then see what it is 	 */
if|if
condition|(
name|isdigit
argument_list|(
name|sc_token
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|sct
argument_list|)
condition|)
name|sc_token
index|[
operator|++
name|idx
index|]
operator|=
operator|*
name|sct
operator|++
expr_stmt|;
name|sc_token
index|[
operator|++
name|idx
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|sc_tokid
operator|=
name|NUMBER
return|;
block|}
elseif|else
if|if
condition|(
name|isalpha
argument_list|(
name|sc_token
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
while|while
condition|(
name|isalpha
argument_list|(
operator|*
name|sct
argument_list|)
condition|)
name|sc_token
index|[
operator|++
name|idx
index|]
operator|=
operator|*
name|sct
operator|++
expr_stmt|;
name|sc_token
index|[
operator|++
name|idx
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|parse_token
argument_list|(
name|sc_token
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|sc_token
index|[
literal|0
index|]
operator|==
literal|':'
operator|||
name|sc_token
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
return|return
name|sc_tokid
operator|=
name|DOT
return|;
elseif|else
if|if
condition|(
name|sc_token
index|[
literal|0
index|]
operator|==
literal|'+'
condition|)
return|return
name|sc_tokid
operator|=
name|PLUS
return|;
elseif|else
if|if
condition|(
name|sc_token
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
return|return
name|sc_tokid
operator|=
name|SLASH
return|;
else|else
return|return
name|sc_tokid
operator|=
name|JUNK
return|;
block|}
comment|/* while (1) */
block|}
end_function

begin_comment
comment|/* token */
end_comment

begin_comment
comment|/*  * plonk() gives an appropriate error message if a token is incorrect  */
end_comment

begin_function
specifier|static
name|void
name|plonk
parameter_list|(
name|int
name|tok
parameter_list|)
block|{
name|panic
argument_list|(
operator|(
name|tok
operator|==
name|EOF
operator|)
condition|?
literal|"incomplete time"
else|:
literal|"garbled time"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* plonk */
end_comment

begin_comment
comment|/*   * expect() gets a token and dies most horribly if it's not the token we want  */
end_comment

begin_function
specifier|static
name|void
name|expect
parameter_list|(
name|int
name|desired
parameter_list|)
block|{
if|if
condition|(
name|token
argument_list|()
operator|!=
name|desired
condition|)
name|plonk
argument_list|(
name|sc_tokid
argument_list|)
expr_stmt|;
comment|/* and we die here... */
block|}
end_function

begin_comment
comment|/* expect */
end_comment

begin_comment
comment|/*  * plus() parses a now + time  *  *  at [NOW] PLUS NUMBER [MINUTES|HOURS|DAYS|WEEKS|MONTHS|YEARS]  *  */
end_comment

begin_function
specifier|static
name|void
name|plus
parameter_list|(
name|struct
name|tm
modifier|*
name|tm
parameter_list|)
block|{
name|int
name|delay
decl_stmt|;
name|int
name|expectplur
decl_stmt|;
name|expect
argument_list|(
name|NUMBER
argument_list|)
expr_stmt|;
name|delay
operator|=
name|atoi
argument_list|(
name|sc_token
argument_list|)
expr_stmt|;
name|expectplur
operator|=
operator|(
name|delay
operator|!=
literal|1
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
switch|switch
condition|(
name|token
argument_list|()
condition|)
block|{
case|case
name|YEARS
case|:
name|tm
operator|->
name|tm_year
operator|+=
name|delay
expr_stmt|;
break|break;
case|case
name|MONTHS
case|:
name|tm
operator|->
name|tm_mon
operator|+=
name|delay
expr_stmt|;
break|break;
case|case
name|WEEKS
case|:
name|delay
operator|*=
literal|7
expr_stmt|;
case|case
name|DAYS
case|:
name|tm
operator|->
name|tm_mday
operator|+=
name|delay
expr_stmt|;
break|break;
case|case
name|HOURS
case|:
name|tm
operator|->
name|tm_hour
operator|+=
name|delay
expr_stmt|;
break|break;
case|case
name|MINUTES
case|:
name|tm
operator|->
name|tm_min
operator|+=
name|delay
expr_stmt|;
break|break;
default|default:
name|plonk
argument_list|(
name|sc_tokid
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|expectplur
operator|!=
name|sc_tokplur
condition|)
name|warnx
argument_list|(
literal|"pluralization is wrong"
argument_list|)
expr_stmt|;
name|tm
operator|->
name|tm_isdst
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|mktime
argument_list|(
name|tm
argument_list|)
operator|<
literal|0
condition|)
name|plonk
argument_list|(
name|sc_tokid
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* plus */
end_comment

begin_comment
comment|/*  * tod() computes the time of day  *     [NUMBER [DOT NUMBER] [AM|PM]]  */
end_comment

begin_function
specifier|static
name|void
name|tod
parameter_list|(
name|struct
name|tm
modifier|*
name|tm
parameter_list|)
block|{
name|int
name|hour
decl_stmt|,
name|minute
init|=
literal|0
decl_stmt|;
name|int
name|tlen
decl_stmt|;
name|hour
operator|=
name|atoi
argument_list|(
name|sc_token
argument_list|)
expr_stmt|;
name|tlen
operator|=
name|strlen
argument_list|(
name|sc_token
argument_list|)
expr_stmt|;
comment|/* first pick out the time of day - if it's 4 digits, we assume      * a HHMM time, otherwise it's HH DOT MM time      */
if|if
condition|(
name|token
argument_list|()
operator|==
name|DOT
condition|)
block|{
name|expect
argument_list|(
name|NUMBER
argument_list|)
expr_stmt|;
name|minute
operator|=
name|atoi
argument_list|(
name|sc_token
argument_list|)
expr_stmt|;
if|if
condition|(
name|minute
operator|>
literal|59
condition|)
name|panic
argument_list|(
literal|"garbled time"
argument_list|)
expr_stmt|;
name|token
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tlen
operator|==
literal|4
condition|)
block|{
name|minute
operator|=
name|hour
operator|%
literal|100
expr_stmt|;
if|if
condition|(
name|minute
operator|>
literal|59
condition|)
name|panic
argument_list|(
literal|"garbled time"
argument_list|)
expr_stmt|;
name|hour
operator|=
name|hour
operator|/
literal|100
expr_stmt|;
block|}
comment|/* check if an AM or PM specifier was given      */
if|if
condition|(
name|sc_tokid
operator|==
name|AM
operator|||
name|sc_tokid
operator|==
name|PM
condition|)
block|{
if|if
condition|(
name|hour
operator|>
literal|12
condition|)
name|panic
argument_list|(
literal|"garbled time"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc_tokid
operator|==
name|PM
condition|)
block|{
if|if
condition|(
name|hour
operator|!=
literal|12
condition|)
comment|/* 12:xx PM is 12:xx, not 24:xx */
name|hour
operator|+=
literal|12
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|hour
operator|==
literal|12
condition|)
comment|/* 12:xx AM is 00:xx, not 12:xx */
name|hour
operator|=
literal|0
expr_stmt|;
block|}
name|token
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hour
operator|>
literal|23
condition|)
name|panic
argument_list|(
literal|"garbled time"
argument_list|)
expr_stmt|;
comment|/* if we specify an absolute time, we don't want to bump the day even      * if we've gone past that time - but if we're specifying a time plus      * a relative offset, it's okay to bump things      */
if|if
condition|(
operator|(
name|sc_tokid
operator|==
name|EOF
operator|||
name|sc_tokid
operator|==
name|PLUS
operator|)
operator|&&
name|tm
operator|->
name|tm_hour
operator|>
name|hour
condition|)
block|{
name|tm
operator|->
name|tm_mday
operator|++
expr_stmt|;
name|tm
operator|->
name|tm_wday
operator|++
expr_stmt|;
block|}
name|tm
operator|->
name|tm_hour
operator|=
name|hour
expr_stmt|;
name|tm
operator|->
name|tm_min
operator|=
name|minute
expr_stmt|;
if|if
condition|(
name|tm
operator|->
name|tm_hour
operator|==
literal|24
condition|)
block|{
name|tm
operator|->
name|tm_hour
operator|=
literal|0
expr_stmt|;
name|tm
operator|->
name|tm_mday
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* tod */
end_comment

begin_comment
comment|/*  * assign_date() assigns a date, wrapping to next year if needed  */
end_comment

begin_function
specifier|static
name|void
name|assign_date
parameter_list|(
name|struct
name|tm
modifier|*
name|tm
parameter_list|,
name|long
name|mday
parameter_list|,
name|long
name|mon
parameter_list|,
name|long
name|year
parameter_list|)
block|{
comment|/*     * Convert year into tm_year format (year - 1900).     * We may be given the year in 2 digit, 4 digit, or tm_year format.     */
if|if
condition|(
name|year
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|year
operator|>=
literal|1900
condition|)
name|year
operator|-=
literal|1900
expr_stmt|;
comment|/* convert from 4 digit year */
elseif|else
if|if
condition|(
name|year
operator|<
literal|100
condition|)
block|{
comment|/* convert from 2 digit year */
name|struct
name|tm
modifier|*
name|lt
decl_stmt|;
name|time_t
name|now
decl_stmt|;
name|time
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|lt
operator|=
name|localtime
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
comment|/* Convert to tm_year assuming current century */
name|year
operator|+=
operator|(
name|lt
operator|->
name|tm_year
operator|/
literal|100
operator|)
operator|*
literal|100
expr_stmt|;
if|if
condition|(
name|year
operator|==
name|lt
operator|->
name|tm_year
operator|-
literal|1
condition|)
name|year
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|year
operator|<
name|lt
operator|->
name|tm_year
condition|)
name|year
operator|+=
literal|100
expr_stmt|;
comment|/* must be in next century */
block|}
block|}
if|if
condition|(
name|year
operator|<
literal|0
operator|&&
operator|(
name|tm
operator|->
name|tm_mon
operator|>
name|mon
operator|||
operator|(
name|tm
operator|->
name|tm_mon
operator|==
name|mon
operator|&&
name|tm
operator|->
name|tm_mday
operator|>
name|mday
operator|)
operator|)
condition|)
name|year
operator|=
name|tm
operator|->
name|tm_year
operator|+
literal|1
expr_stmt|;
name|tm
operator|->
name|tm_mday
operator|=
name|mday
expr_stmt|;
name|tm
operator|->
name|tm_mon
operator|=
name|mon
expr_stmt|;
if|if
condition|(
name|year
operator|>=
literal|0
condition|)
name|tm
operator|->
name|tm_year
operator|=
name|year
expr_stmt|;
block|}
end_function

begin_comment
comment|/* assign_date */
end_comment

begin_comment
comment|/*   * month() picks apart a month specification  *  *  /[<month> NUMBER [NUMBER]]           \  *  |[TOMORROW]                          |  *  |[DAY OF WEEK]                       |  *  |NUMBER [SLASH NUMBER [SLASH NUMBER]]|  *  \PLUS NUMBER MINUTES|HOURS|DAYS|WEEKS/  */
end_comment

begin_function
specifier|static
name|void
name|month
parameter_list|(
name|struct
name|tm
modifier|*
name|tm
parameter_list|)
block|{
name|long
name|year
init|=
operator|(
operator|-
literal|1
operator|)
decl_stmt|;
name|long
name|mday
init|=
literal|0
decl_stmt|,
name|wday
decl_stmt|,
name|mon
decl_stmt|;
name|int
name|tlen
decl_stmt|;
switch|switch
condition|(
name|sc_tokid
condition|)
block|{
case|case
name|PLUS
case|:
name|plus
argument_list|(
name|tm
argument_list|)
expr_stmt|;
break|break;
case|case
name|TOMORROW
case|:
comment|/* do something tomorrow */
name|tm
operator|->
name|tm_mday
operator|++
expr_stmt|;
name|tm
operator|->
name|tm_wday
operator|++
expr_stmt|;
case|case
name|TODAY
case|:
comment|/* force ourselves to stay in today - no further processing */
name|token
argument_list|()
expr_stmt|;
break|break;
case|case
name|JAN
case|:
case|case
name|FEB
case|:
case|case
name|MAR
case|:
case|case
name|APR
case|:
case|case
name|MAY
case|:
case|case
name|JUN
case|:
case|case
name|JUL
case|:
case|case
name|AUG
case|:
case|case
name|SEP
case|:
case|case
name|OCT
case|:
case|case
name|NOV
case|:
case|case
name|DEC
case|:
comment|/* do month mday [year] 	     */
name|mon
operator|=
operator|(
name|sc_tokid
operator|-
name|JAN
operator|)
expr_stmt|;
name|expect
argument_list|(
name|NUMBER
argument_list|)
expr_stmt|;
name|mday
operator|=
name|atol
argument_list|(
name|sc_token
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
argument_list|()
operator|==
name|NUMBER
condition|)
block|{
name|year
operator|=
name|atol
argument_list|(
name|sc_token
argument_list|)
expr_stmt|;
name|token
argument_list|()
expr_stmt|;
block|}
name|assign_date
argument_list|(
name|tm
argument_list|,
name|mday
argument_list|,
name|mon
argument_list|,
name|year
argument_list|)
expr_stmt|;
break|break;
case|case
name|SUN
case|:
case|case
name|MON
case|:
case|case
name|TUE
case|:
case|case
name|WED
case|:
case|case
name|THU
case|:
case|case
name|FRI
case|:
case|case
name|SAT
case|:
comment|/* do a particular day of the week 	     */
name|wday
operator|=
operator|(
name|sc_tokid
operator|-
name|SUN
operator|)
expr_stmt|;
name|mday
operator|=
name|tm
operator|->
name|tm_mday
expr_stmt|;
comment|/* if this day is< today, then roll to next week 	     */
if|if
condition|(
name|wday
operator|<
name|tm
operator|->
name|tm_wday
condition|)
name|mday
operator|+=
literal|7
operator|-
operator|(
name|tm
operator|->
name|tm_wday
operator|-
name|wday
operator|)
expr_stmt|;
else|else
name|mday
operator|+=
operator|(
name|wday
operator|-
name|tm
operator|->
name|tm_wday
operator|)
expr_stmt|;
name|tm
operator|->
name|tm_wday
operator|=
name|wday
expr_stmt|;
name|assign_date
argument_list|(
name|tm
argument_list|,
name|mday
argument_list|,
name|tm
operator|->
name|tm_mon
argument_list|,
name|tm
operator|->
name|tm_year
argument_list|)
expr_stmt|;
break|break;
case|case
name|NUMBER
case|:
comment|/* get numeric MMDDYY, mm/dd/yy, or dd.mm.yy 	     */
name|tlen
operator|=
name|strlen
argument_list|(
name|sc_token
argument_list|)
expr_stmt|;
name|mon
operator|=
name|atol
argument_list|(
name|sc_token
argument_list|)
expr_stmt|;
name|token
argument_list|()
expr_stmt|;
if|if
condition|(
name|sc_tokid
operator|==
name|SLASH
operator|||
name|sc_tokid
operator|==
name|DOT
condition|)
block|{
name|int
name|sep
decl_stmt|;
name|sep
operator|=
name|sc_tokid
expr_stmt|;
name|expect
argument_list|(
name|NUMBER
argument_list|)
expr_stmt|;
name|mday
operator|=
name|atol
argument_list|(
name|sc_token
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
argument_list|()
operator|==
name|sep
condition|)
block|{
name|expect
argument_list|(
name|NUMBER
argument_list|)
expr_stmt|;
name|year
operator|=
name|atol
argument_list|(
name|sc_token
argument_list|)
expr_stmt|;
name|token
argument_list|()
expr_stmt|;
block|}
comment|/* flip months and days for European timing 		 */
if|if
condition|(
name|sep
operator|==
name|DOT
condition|)
block|{
name|int
name|x
init|=
name|mday
decl_stmt|;
name|mday
operator|=
name|mon
expr_stmt|;
name|mon
operator|=
name|x
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|tlen
operator|==
literal|6
operator|||
name|tlen
operator|==
literal|8
condition|)
block|{
if|if
condition|(
name|tlen
operator|==
literal|8
condition|)
block|{
name|year
operator|=
operator|(
name|mon
operator|%
literal|10000
operator|)
operator|-
literal|1900
expr_stmt|;
name|mon
operator|/=
literal|10000
expr_stmt|;
block|}
else|else
block|{
name|year
operator|=
name|mon
operator|%
literal|100
expr_stmt|;
name|mon
operator|/=
literal|100
expr_stmt|;
block|}
name|mday
operator|=
name|mon
operator|%
literal|100
expr_stmt|;
name|mon
operator|/=
literal|100
expr_stmt|;
block|}
else|else
name|panic
argument_list|(
literal|"garbled time"
argument_list|)
expr_stmt|;
name|mon
operator|--
expr_stmt|;
if|if
condition|(
name|mon
operator|<
literal|0
operator|||
name|mon
operator|>
literal|11
operator|||
name|mday
operator|<
literal|1
operator|||
name|mday
operator|>
literal|31
condition|)
name|panic
argument_list|(
literal|"garbled time"
argument_list|)
expr_stmt|;
name|assign_date
argument_list|(
name|tm
argument_list|,
name|mday
argument_list|,
name|mon
argument_list|,
name|year
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* case */
block|}
end_function

begin_comment
comment|/* month */
end_comment

begin_comment
comment|/* Global functions */
end_comment

begin_function
name|time_t
name|parsetime
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
comment|/* Do the argument parsing, die if necessary, and return the time the job  * should be run.  */
name|time_t
name|nowtimer
decl_stmt|,
name|runtimer
decl_stmt|;
name|struct
name|tm
name|nowtime
decl_stmt|,
name|runtime
decl_stmt|;
name|int
name|hr
init|=
literal|0
decl_stmt|;
comment|/* this MUST be initialized to zero for midnight/noon/teatime */
name|nowtimer
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|nowtime
operator|=
operator|*
name|localtime
argument_list|(
operator|&
name|nowtimer
argument_list|)
expr_stmt|;
name|runtime
operator|=
name|nowtime
expr_stmt|;
name|runtime
operator|.
name|tm_sec
operator|=
literal|0
expr_stmt|;
name|runtime
operator|.
name|tm_isdst
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|argc
operator|<=
name|optind
condition|)
name|usage
argument_list|()
expr_stmt|;
name|init_scanner
argument_list|(
name|argc
operator|-
name|optind
argument_list|,
name|argv
operator|+
name|optind
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|token
argument_list|()
condition|)
block|{
case|case
name|NOW
case|:
if|if
condition|(
name|scc
operator|<
literal|1
condition|)
block|{
return|return
name|nowtimer
return|;
block|}
comment|/* now is optional prefix for PLUS tree */
name|expect
argument_list|(
name|PLUS
argument_list|)
expr_stmt|;
case|case
name|PLUS
case|:
name|plus
argument_list|(
operator|&
name|runtime
argument_list|)
expr_stmt|;
break|break;
case|case
name|NUMBER
case|:
name|tod
argument_list|(
operator|&
name|runtime
argument_list|)
expr_stmt|;
name|month
argument_list|(
operator|&
name|runtime
argument_list|)
expr_stmt|;
break|break;
comment|/* evil coding for TEATIME|NOON|MIDNIGHT - we've initialised 	     * hr to zero up above, then fall into this case in such a 	     * way so we add +12 +4 hours to it for teatime, +12 hours 	     * to it for noon, and nothing at all for midnight, then 	     * set our runtime to that hour before leaping into the 	     * month scanner 	     */
case|case
name|TEATIME
case|:
name|hr
operator|+=
literal|4
expr_stmt|;
case|case
name|NOON
case|:
name|hr
operator|+=
literal|12
expr_stmt|;
case|case
name|MIDNIGHT
case|:
if|if
condition|(
name|runtime
operator|.
name|tm_hour
operator|>=
name|hr
condition|)
block|{
name|runtime
operator|.
name|tm_mday
operator|++
expr_stmt|;
name|runtime
operator|.
name|tm_wday
operator|++
expr_stmt|;
block|}
name|runtime
operator|.
name|tm_hour
operator|=
name|hr
expr_stmt|;
name|runtime
operator|.
name|tm_min
operator|=
literal|0
expr_stmt|;
name|token
argument_list|()
expr_stmt|;
comment|/* FALLTHROUGH to month setting */
default|default:
name|month
argument_list|(
operator|&
name|runtime
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* ugly case statement */
name|expect
argument_list|(
name|EOF
argument_list|)
expr_stmt|;
comment|/* adjust for daylight savings time      */
name|runtime
operator|.
name|tm_isdst
operator|=
operator|-
literal|1
expr_stmt|;
name|runtimer
operator|=
name|mktime
argument_list|(
operator|&
name|runtime
argument_list|)
expr_stmt|;
if|if
condition|(
name|runtime
operator|.
name|tm_isdst
operator|>
literal|0
condition|)
block|{
name|runtimer
operator|-=
literal|3600
expr_stmt|;
name|runtimer
operator|=
name|mktime
argument_list|(
operator|&
name|runtime
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|runtimer
operator|<
literal|0
condition|)
name|panic
argument_list|(
literal|"garbled time"
argument_list|)
expr_stmt|;
if|if
condition|(
name|nowtimer
operator|>
name|runtimer
condition|)
name|panic
argument_list|(
literal|"trying to travel back in time"
argument_list|)
expr_stmt|;
return|return
name|runtimer
return|;
block|}
end_function

begin_comment
comment|/* parsetime */
end_comment

end_unit

