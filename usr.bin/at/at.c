begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   *  at.c : Put file into atrun queue  *  Copyright (C) 1993, 1994 Thomas Koenig  *  *  Atrun& Atq modifications  *  Copyright (C) 1993  David Parsons  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. The name of the author(s) may not be used to endorse or promote  *    products derived from this software without specific prior written  *    permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_define
define|#
directive|define
name|_USE_BSD
value|1
end_define

begin_comment
comment|/* System Headers */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<dirent.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|__FreeBSD__
end_ifndef

begin_include
include|#
directive|include
file|<getopt.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<locale.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Local headers */
end_comment

begin_include
include|#
directive|include
file|"at.h"
end_include

begin_include
include|#
directive|include
file|"panic.h"
end_include

begin_include
include|#
directive|include
file|"parsetime.h"
end_include

begin_include
include|#
directive|include
file|"perm.h"
end_include

begin_define
define|#
directive|define
name|MAIN
end_define

begin_include
include|#
directive|include
file|"privs.h"
end_include

begin_comment
comment|/* Macros */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ATJOB_DIR
end_ifndef

begin_define
define|#
directive|define
name|ATJOB_DIR
value|"/usr/spool/atjobs/"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LFILE
end_ifndef

begin_define
define|#
directive|define
name|LFILE
value|ATJOB_DIR ".lockfile"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ATJOB_MX
end_ifndef

begin_define
define|#
directive|define
name|ATJOB_MX
value|255
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|ALARMC
value|10
end_define

begin_comment
comment|/* Number of seconds to wait for timeout */
end_comment

begin_define
define|#
directive|define
name|SIZE
value|255
end_define

begin_define
define|#
directive|define
name|TIMESIZE
value|50
end_define

begin_enum
enum|enum
block|{
name|ATQ
block|,
name|ATRM
block|,
name|AT
block|,
name|BATCH
block|,
name|CAT
block|}
enum|;
end_enum

begin_comment
comment|/* what program we want to run */
end_comment

begin_comment
comment|/* File scope variables */
end_comment

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$Id: at.c,v 1.7 1995/10/24 05:09:54 ache Exp $"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|no_export
index|[]
init|=
block|{
literal|"TERM"
block|,
literal|"TERMCAP"
block|,
literal|"DISPLAY"
block|,
literal|"_"
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|send_mail
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* External variables */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
modifier|*
name|environ
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|fcreated
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|namep
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|atfile
index|[]
init|=
name|ATJOB_DIR
literal|"12345678901234"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|atinput
init|=
operator|(
name|char
operator|*
operator|)
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* where to get input from */
end_comment

begin_decl_stmt
name|char
name|atqueue
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* which queue to examine for jobs (atq) */
end_comment

begin_decl_stmt
name|char
name|atverify
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* verify time instead of queuing job */
end_comment

begin_comment
comment|/* Function declarations */
end_comment

begin_function_decl
specifier|static
name|void
name|sigc
parameter_list|(
name|int
name|signo
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|alarmc
parameter_list|(
name|int
name|signo
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|cwdname
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|writefile
parameter_list|(
name|time_t
name|runtimer
parameter_list|,
name|char
name|queue
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|list_jobs
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Signal catching functions */
end_comment

begin_function
specifier|static
name|void
name|sigc
parameter_list|(
name|int
name|signo
parameter_list|)
block|{
comment|/* If the user presses ^C, remove the spool file and exit   */
if|if
condition|(
name|fcreated
condition|)
block|{
name|PRIV_START
name|unlink
argument_list|(
name|atfile
argument_list|)
decl_stmt|;
name|PRIV_END
block|}
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|alarmc
parameter_list|(
name|int
name|signo
parameter_list|)
block|{
comment|/* Time out after some seconds  */
name|panic
argument_list|(
literal|"File locking timed out"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Local functions */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|cwdname
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Read in the current directory; the name will be overwritten on  * subsequent calls.  */
specifier|static
name|char
modifier|*
name|ptr
init|=
name|NULL
decl_stmt|;
specifier|static
name|size_t
name|size
init|=
name|SIZE
decl_stmt|;
if|if
condition|(
name|ptr
operator|==
name|NULL
condition|)
name|ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|mymalloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|ptr
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"Out of memory"
argument_list|)
expr_stmt|;
if|if
condition|(
name|getcwd
argument_list|(
name|ptr
argument_list|,
name|size
operator|-
literal|1
argument_list|)
operator|!=
name|NULL
condition|)
return|return
name|ptr
return|;
if|if
condition|(
name|errno
operator|!=
name|ERANGE
condition|)
name|perr
argument_list|(
literal|"Cannot get directory"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|size
operator|+=
name|SIZE
expr_stmt|;
name|ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|mymalloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|long
name|nextjob
parameter_list|()
block|{
name|long
name|jobno
decl_stmt|;
name|FILE
modifier|*
name|fid
decl_stmt|;
if|if
condition|(
operator|(
name|fid
operator|=
name|fopen
argument_list|(
name|ATJOB_DIR
literal|".SEQ"
argument_list|,
literal|"r+"
argument_list|)
operator|)
operator|!=
operator|(
name|FILE
operator|*
operator|)
literal|0
condition|)
block|{
if|if
condition|(
name|fscanf
argument_list|(
name|fid
argument_list|,
literal|"%5lx"
argument_list|,
operator|&
name|jobno
argument_list|)
operator|==
literal|1
condition|)
block|{
name|rewind
argument_list|(
name|fid
argument_list|)
expr_stmt|;
name|jobno
operator|=
operator|(
literal|1
operator|+
name|jobno
operator|)
operator|%
literal|0xfffff
expr_stmt|;
comment|/* 2^20 jobs enough? */
name|fprintf
argument_list|(
name|fid
argument_list|,
literal|"%05lx\n"
argument_list|,
name|jobno
argument_list|)
expr_stmt|;
block|}
else|else
name|jobno
operator|=
name|EOF
expr_stmt|;
name|fclose
argument_list|(
name|fid
argument_list|)
expr_stmt|;
return|return
name|jobno
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|fid
operator|=
name|fopen
argument_list|(
name|ATJOB_DIR
literal|".SEQ"
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|!=
operator|(
name|FILE
operator|*
operator|)
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|fid
argument_list|,
literal|"%05lx\n"
argument_list|,
name|jobno
operator|=
literal|1
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fid
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
name|EOF
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|writefile
parameter_list|(
name|time_t
name|runtimer
parameter_list|,
name|char
name|queue
parameter_list|)
block|{
comment|/* This does most of the work if at or batch are invoked for writing a job.  */
name|long
name|jobno
decl_stmt|;
name|char
modifier|*
name|ap
decl_stmt|,
modifier|*
name|ppos
decl_stmt|,
modifier|*
name|mailname
decl_stmt|;
name|struct
name|passwd
modifier|*
name|pass_entry
decl_stmt|;
name|struct
name|stat
name|statbuf
decl_stmt|;
name|int
name|fdes
decl_stmt|,
name|lockdes
decl_stmt|,
name|fd2
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|,
modifier|*
name|fpin
decl_stmt|;
name|struct
name|sigaction
name|act
decl_stmt|;
name|char
modifier|*
modifier|*
name|atenv
decl_stmt|;
name|int
name|ch
decl_stmt|;
name|mode_t
name|cmask
decl_stmt|;
name|struct
name|flock
name|lock
decl_stmt|;
ifdef|#
directive|ifdef
name|__FreeBSD__
operator|(
name|void
operator|)
name|setlocale
argument_list|(
name|LC_TIME
argument_list|,
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Install the signal handler for SIGINT; terminate after removing the  * spool file if necessary  */
name|act
operator|.
name|sa_handler
operator|=
name|sigc
expr_stmt|;
name|sigemptyset
argument_list|(
operator|&
operator|(
name|act
operator|.
name|sa_mask
operator|)
argument_list|)
expr_stmt|;
name|act
operator|.
name|sa_flags
operator|=
literal|0
expr_stmt|;
name|sigaction
argument_list|(
name|SIGINT
argument_list|,
operator|&
name|act
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ppos
operator|=
name|atfile
operator|+
name|strlen
argument_list|(
name|ATJOB_DIR
argument_list|)
expr_stmt|;
comment|/* Loop over all possible file names for running something at this      * particular time, see if a file is there; the first empty slot at any      * particular time is used.  Lock the file LFILE first to make sure      * we're alone when doing this.      */
name|PRIV_START
if|if
condition|(
operator|(
name|lockdes
operator|=
name|open
argument_list|(
name|LFILE
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
argument_list|,
name|S_IWUSR
operator||
name|S_IRUSR
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|perr
argument_list|(
literal|"Cannot open lockfile "
name|LFILE
argument_list|)
expr_stmt|;
name|lock
operator|.
name|l_type
operator|=
name|F_WRLCK
expr_stmt|;
name|lock
operator|.
name|l_whence
operator|=
name|SEEK_SET
expr_stmt|;
name|lock
operator|.
name|l_start
operator|=
literal|0
expr_stmt|;
name|lock
operator|.
name|l_len
operator|=
literal|0
expr_stmt|;
name|act
operator|.
name|sa_handler
operator|=
name|alarmc
expr_stmt|;
name|sigemptyset
argument_list|(
operator|&
operator|(
name|act
operator|.
name|sa_mask
operator|)
argument_list|)
expr_stmt|;
name|act
operator|.
name|sa_flags
operator|=
literal|0
expr_stmt|;
comment|/* Set an alarm so a timeout occurs after ALARMC seconds, in case      * something is seriously broken.      */
name|sigaction
argument_list|(
name|SIGALRM
argument_list|,
operator|&
name|act
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|alarm
argument_list|(
name|ALARMC
argument_list|)
expr_stmt|;
name|fcntl
argument_list|(
name|lockdes
argument_list|,
name|F_SETLKW
argument_list|,
operator|&
name|lock
argument_list|)
expr_stmt|;
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|jobno
operator|=
name|nextjob
argument_list|()
operator|)
operator|==
name|EOF
condition|)
name|perr
argument_list|(
literal|"Cannot generate job number"
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|ppos
argument_list|,
literal|"%c%5lx%8lx"
argument_list|,
name|queue
argument_list|,
name|jobno
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|runtimer
operator|/
literal|60
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|ap
operator|=
name|ppos
init|;
operator|*
name|ap
operator|!=
literal|'\0'
condition|;
name|ap
operator|++
control|)
if|if
condition|(
operator|*
name|ap
operator|==
literal|' '
condition|)
operator|*
name|ap
operator|=
literal|'0'
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|atfile
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|!=
literal|0
condition|)
if|if
condition|(
name|errno
operator|!=
name|ENOENT
condition|)
name|perr
argument_list|(
literal|"Cannot access "
name|ATJOB_DIR
argument_list|)
expr_stmt|;
comment|/* Create the file. The x bit is only going to be set after it has      * been completely written out, to make sure it is not executed in the      * meantime.  To make sure they do not get deleted, turn off their r      * bit.  Yes, this is a kluge.      */
name|cmask
operator|=
name|umask
argument_list|(
name|S_IRUSR
operator||
name|S_IWUSR
operator||
name|S_IXUSR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fdes
operator|=
name|creat
argument_list|(
name|atfile
argument_list|,
name|O_WRONLY
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|perr
argument_list|(
literal|"Cannot create atjob file"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd2
operator|=
name|dup
argument_list|(
name|fdes
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|perr
argument_list|(
literal|"Error in dup() of job file"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fchown
argument_list|(
name|fd2
argument_list|,
name|real_uid
argument_list|,
name|real_gid
argument_list|)
operator|!=
literal|0
condition|)
name|perr
argument_list|(
literal|"Cannot give away file"
argument_list|)
expr_stmt|;
name|PRIV_END
comment|/* We no longer need suid root; now we just need to be able to write      * to the directory, if necessary.      */
name|REDUCE_PRIV
argument_list|(
name|DAEMON_UID
argument_list|,
name|DAEMON_GID
argument_list|)
comment|/* We've successfully created the file; let's set the flag so it       * gets removed in case of an interrupt or error.      */
name|fcreated
init|=
literal|1
decl_stmt|;
comment|/* Now we can release the lock, so other people can access it      */
name|lock
operator|.
name|l_type
operator|=
name|F_UNLCK
expr_stmt|;
name|lock
operator|.
name|l_whence
operator|=
name|SEEK_SET
expr_stmt|;
name|lock
operator|.
name|l_start
operator|=
literal|0
expr_stmt|;
name|lock
operator|.
name|l_len
operator|=
literal|0
expr_stmt|;
name|fcntl
argument_list|(
name|lockdes
argument_list|,
name|F_SETLKW
argument_list|,
operator|&
name|lock
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|lockdes
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fdopen
argument_list|(
name|fdes
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"Cannot reopen atjob file"
argument_list|)
expr_stmt|;
comment|/* Get the userid to mail to, first by trying getlogin(), which reads      * /etc/utmp, then from LOGNAME, finally from getpwuid().      */
name|mailname
operator|=
name|getlogin
argument_list|()
expr_stmt|;
if|if
condition|(
name|mailname
operator|==
name|NULL
condition|)
name|mailname
operator|=
name|getenv
argument_list|(
literal|"LOGNAME"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mailname
operator|==
name|NULL
operator|)
operator|||
operator|(
name|mailname
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|)
operator|||
operator|(
name|strlen
argument_list|(
name|mailname
argument_list|)
operator|>
literal|8
operator|)
operator|||
operator|(
name|getpwnam
argument_list|(
name|mailname
argument_list|)
operator|==
name|NULL
operator|)
condition|)
block|{
name|pass_entry
operator|=
name|getpwuid
argument_list|(
name|real_uid
argument_list|)
expr_stmt|;
if|if
condition|(
name|pass_entry
operator|!=
name|NULL
condition|)
name|mailname
operator|=
name|pass_entry
operator|->
name|pw_name
expr_stmt|;
block|}
if|if
condition|(
name|atinput
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
name|fpin
operator|=
name|freopen
argument_list|(
name|atinput
argument_list|,
literal|"r"
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
if|if
condition|(
name|fpin
operator|==
name|NULL
condition|)
name|perr
argument_list|(
literal|"Cannot open input file"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"#!/bin/sh\n# atrun uid=%ld gid=%ld\n# mail %8s %d\n"
argument_list|,
operator|(
name|long
operator|)
name|real_uid
argument_list|,
operator|(
name|long
operator|)
name|real_gid
argument_list|,
name|mailname
argument_list|,
name|send_mail
argument_list|)
expr_stmt|;
comment|/* Write out the umask at the time of invocation      */
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"umask %lo\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|cmask
argument_list|)
expr_stmt|;
comment|/* Write out the environment. Anything that may look like a      * special character to the shell is quoted, except for \n, which is      * done with a pair of "'s.  Dont't export the no_export list (such      * as TERM or DISPLAY) because we don't want these.      */
for|for
control|(
name|atenv
operator|=
name|environ
init|;
operator|*
name|atenv
operator|!=
name|NULL
condition|;
name|atenv
operator|++
control|)
block|{
name|int
name|export
init|=
literal|1
decl_stmt|;
name|char
modifier|*
name|eqp
decl_stmt|;
name|eqp
operator|=
name|strchr
argument_list|(
operator|*
name|atenv
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
if|if
condition|(
name|ap
operator|==
name|NULL
condition|)
name|eqp
operator|=
operator|*
name|atenv
expr_stmt|;
else|else
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|no_export
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|no_export
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|export
operator|=
name|export
operator|&&
operator|(
name|strncmp
argument_list|(
operator|*
name|atenv
argument_list|,
name|no_export
index|[
name|i
index|]
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|eqp
operator|-
operator|*
name|atenv
argument_list|)
argument_list|)
operator|!=
literal|0
operator|)
expr_stmt|;
block|}
name|eqp
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|export
condition|)
block|{
name|fwrite
argument_list|(
operator|*
name|atenv
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
name|eqp
operator|-
operator|*
name|atenv
argument_list|,
name|fp
argument_list|)
expr_stmt|;
for|for
control|(
name|ap
operator|=
name|eqp
init|;
operator|*
name|ap
operator|!=
literal|'\0'
condition|;
name|ap
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|ap
operator|==
literal|'\n'
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\"\n\""
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|isalnum
argument_list|(
operator|*
name|ap
argument_list|)
condition|)
block|{
switch|switch
condition|(
operator|*
name|ap
condition|)
block|{
case|case
literal|'%'
case|:
case|case
literal|'/'
case|:
case|case
literal|'{'
case|:
case|case
literal|'['
case|:
case|case
literal|']'
case|:
case|case
literal|'='
case|:
case|case
literal|'}'
case|:
case|case
literal|'@'
case|:
case|case
literal|'+'
case|:
case|case
literal|'#'
case|:
case|case
literal|','
case|:
case|case
literal|'.'
case|:
case|case
literal|':'
case|:
case|case
literal|'-'
case|:
case|case
literal|'_'
case|:
break|break;
default|default:
name|fputc
argument_list|(
literal|'\\'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|fputc
argument_list|(
operator|*
name|ap
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
name|fputs
argument_list|(
literal|"; export "
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
operator|*
name|atenv
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
name|eqp
operator|-
operator|*
name|atenv
operator|-
literal|1
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Cd to the directory at the time and write out all the      * commands the user supplies from stdin.      */
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"cd "
argument_list|)
expr_stmt|;
for|for
control|(
name|ap
operator|=
name|cwdname
argument_list|()
init|;
operator|*
name|ap
operator|!=
literal|'\0'
condition|;
name|ap
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|ap
operator|==
literal|'\n'
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\"\n\""
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|*
name|ap
operator|!=
literal|'/'
operator|&&
operator|!
name|isalnum
argument_list|(
operator|*
name|ap
argument_list|)
condition|)
name|fputc
argument_list|(
literal|'\\'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
operator|*
name|ap
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Test cd's exit status: die if the original directory has been      * removed, become unreadable or whatever      */
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" || {\n\t echo 'Execution directory "
literal|"inaccessible'>&2\n\t exit 1\n}\n"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|getchar
argument_list|()
operator|)
operator|!=
name|EOF
condition|)
name|fputc
argument_list|(
name|ch
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
name|panic
argument_list|(
literal|"Output error"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|stdin
argument_list|)
condition|)
name|panic
argument_list|(
literal|"Input error"
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
comment|/* Set the x bit so that we're ready to start executing      */
if|if
condition|(
name|fchmod
argument_list|(
name|fd2
argument_list|,
name|S_IRUSR
operator||
name|S_IWUSR
operator||
name|S_IXUSR
argument_list|)
operator|<
literal|0
condition|)
name|perr
argument_list|(
literal|"Cannot give away file"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd2
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Job %ld will be executed using /bin/sh\n"
argument_list|,
name|jobno
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|list_jobs
parameter_list|()
block|{
comment|/* List all a user's jobs in the queue, by looping through ATJOB_DIR,       * or everybody's if we are root      */
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
name|DIR
modifier|*
name|spool
decl_stmt|;
name|struct
name|dirent
modifier|*
name|dirent
decl_stmt|;
name|struct
name|stat
name|buf
decl_stmt|;
name|struct
name|tm
name|runtime
decl_stmt|;
name|unsigned
name|long
name|ctm
decl_stmt|;
name|char
name|queue
decl_stmt|;
name|long
name|jobno
decl_stmt|;
name|time_t
name|runtimer
decl_stmt|;
name|char
name|timestr
index|[
name|TIMESIZE
index|]
decl_stmt|;
name|int
name|first
init|=
literal|1
decl_stmt|;
name|PRIV_START
if|if
condition|(
name|chdir
argument_list|(
name|ATJOB_DIR
argument_list|)
operator|!=
literal|0
condition|)
name|perr
argument_list|(
literal|"Cannot change to "
name|ATJOB_DIR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|spool
operator|=
name|opendir
argument_list|(
literal|"."
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|perr
argument_list|(
literal|"Cannot open "
name|ATJOB_DIR
argument_list|)
expr_stmt|;
comment|/*	Loop over every file in the directory       */
while|while
condition|(
operator|(
name|dirent
operator|=
name|readdir
argument_list|(
name|spool
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|stat
argument_list|(
name|dirent
operator|->
name|d_name
argument_list|,
operator|&
name|buf
argument_list|)
operator|!=
literal|0
condition|)
name|perr
argument_list|(
literal|"Cannot stat in "
name|ATJOB_DIR
argument_list|)
expr_stmt|;
comment|/* See it's a regular file and has its x bit turned on and          * is the user's          */
if|if
condition|(
operator|!
name|S_ISREG
argument_list|(
name|buf
operator|.
name|st_mode
argument_list|)
operator|||
operator|(
operator|(
name|buf
operator|.
name|st_uid
operator|!=
name|real_uid
operator|)
operator|&&
operator|!
operator|(
name|real_uid
operator|==
literal|0
operator|)
operator|)
operator|||
operator|!
operator|(
name|S_IXUSR
operator|&
name|buf
operator|.
name|st_mode
operator|||
name|atverify
operator|)
condition|)
continue|continue;
if|if
condition|(
name|sscanf
argument_list|(
name|dirent
operator|->
name|d_name
argument_list|,
literal|"%c%5lx%8lx"
argument_list|,
operator|&
name|queue
argument_list|,
operator|&
name|jobno
argument_list|,
operator|&
name|ctm
argument_list|)
operator|!=
literal|3
condition|)
continue|continue;
if|if
condition|(
name|atqueue
operator|&&
operator|(
name|queue
operator|!=
name|atqueue
operator|)
condition|)
continue|continue;
name|runtimer
operator|=
literal|60
operator|*
operator|(
name|time_t
operator|)
name|ctm
expr_stmt|;
name|runtime
operator|=
operator|*
name|localtime
argument_list|(
operator|&
name|runtimer
argument_list|)
expr_stmt|;
name|strftime
argument_list|(
name|timestr
argument_list|,
name|TIMESIZE
argument_list|,
literal|"%X %x"
argument_list|,
operator|&
name|runtime
argument_list|)
expr_stmt|;
if|if
condition|(
name|first
condition|)
block|{
name|printf
argument_list|(
literal|"Date\t\t\tOwner\tQueue\tJob#\n"
argument_list|)
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
block|}
name|pw
operator|=
name|getpwuid
argument_list|(
name|buf
operator|.
name|st_uid
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s\t%s\t%c%s\t%ld\n"
argument_list|,
name|timestr
argument_list|,
name|pw
condition|?
name|pw
operator|->
name|pw_name
else|:
literal|"???"
argument_list|,
name|queue
argument_list|,
operator|(
name|S_IXUSR
operator|&
name|buf
operator|.
name|st_mode
operator|)
condition|?
literal|""
else|:
literal|"(done)"
argument_list|,
name|jobno
argument_list|)
expr_stmt|;
block|}
name|PRIV_END
block|}
end_function

begin_function
specifier|static
name|void
name|process_jobs
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|int
name|what
parameter_list|)
block|{
comment|/* Delete every argument (job - ID) given      */
name|int
name|i
decl_stmt|;
name|struct
name|stat
name|buf
decl_stmt|;
name|DIR
modifier|*
name|spool
decl_stmt|;
name|struct
name|dirent
modifier|*
name|dirent
decl_stmt|;
name|unsigned
name|long
name|ctm
decl_stmt|;
name|char
name|queue
decl_stmt|;
name|long
name|jobno
decl_stmt|;
name|PRIV_START
if|if
condition|(
name|chdir
argument_list|(
name|ATJOB_DIR
argument_list|)
operator|!=
literal|0
condition|)
name|perr
argument_list|(
literal|"Cannot change to "
name|ATJOB_DIR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|spool
operator|=
name|opendir
argument_list|(
literal|"."
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|perr
argument_list|(
literal|"Cannot open "
name|ATJOB_DIR
argument_list|)
expr_stmt|;
name|PRIV_END
comment|/*	Loop over every file in the directory       */
while|while
condition|(
operator|(
name|dirent
operator|=
name|readdir
argument_list|(
name|spool
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|PRIV_START
if|if
condition|(
name|stat
argument_list|(
name|dirent
operator|->
name|d_name
argument_list|,
operator|&
name|buf
argument_list|)
operator|!=
literal|0
condition|)
name|perr
argument_list|(
literal|"Cannot stat in "
name|ATJOB_DIR
argument_list|)
expr_stmt|;
name|PRIV_END
if|if
condition|(
name|sscanf
argument_list|(
name|dirent
operator|->
name|d_name
argument_list|,
literal|"%c%5lx%8lx"
argument_list|,
operator|&
name|queue
argument_list|,
operator|&
name|jobno
argument_list|,
operator|&
name|ctm
argument_list|)
operator|!=
literal|3
condition|)
continue|continue;
for|for
control|(
name|i
operator|=
name|optind
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|atoi
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
operator|==
name|jobno
condition|)
block|{
if|if
condition|(
operator|(
name|buf
operator|.
name|st_uid
operator|!=
name|real_uid
operator|)
operator|&&
operator|!
operator|(
name|real_uid
operator|==
literal|0
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Not owner\n"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|what
condition|)
block|{
case|case
name|ATRM
case|:
name|PRIV_START
if|if
condition|(
name|unlink
argument_list|(
name|dirent
operator|->
name|d_name
argument_list|)
operator|!=
literal|0
condition|)
name|perr
argument_list|(
name|dirent
operator|->
name|d_name
argument_list|)
expr_stmt|;
name|PRIV_END
break|break;
case|case
name|CAT
case|:
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|int
name|ch
decl_stmt|;
name|PRIV_START
name|fp
init|=
name|fopen
argument_list|(
name|dirent
operator|->
name|d_name
argument_list|,
literal|"r"
argument_list|)
decl_stmt|;
name|PRIV_END
if|if
condition|(
operator|!
name|fp
condition|)
block|{
name|perr
argument_list|(
literal|"Cannot open file"
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|ch
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
name|putchar
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Internal error, process_jobs = %d\n"
argument_list|,
name|what
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* delete_jobs */
end_comment

begin_comment
comment|/* Global functions */
end_comment

begin_function
name|void
modifier|*
name|mymalloc
parameter_list|(
name|size_t
name|n
parameter_list|)
block|{
name|void
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|malloc
argument_list|(
name|n
argument_list|)
operator|)
operator|==
operator|(
name|void
operator|*
operator|)
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Virtual memory exhausted\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|char
name|queue
init|=
name|DEFAULT_AT_QUEUE
decl_stmt|;
name|char
name|queue_set
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|pgm
decl_stmt|;
enum|enum
block|{
name|ATQ
block|,
name|ATRM
block|,
name|AT
block|,
name|BATCH
block|,
name|CAT
block|}
enum|;
comment|/* what program we want to run */
name|int
name|program
init|=
name|AT
decl_stmt|;
comment|/* our default program */
name|char
modifier|*
name|options
init|=
literal|"q:f:mvldbVc"
decl_stmt|;
comment|/* default options for at */
name|int
name|disp_version
init|=
literal|0
decl_stmt|;
name|time_t
name|timer
decl_stmt|;
name|RELINQUISH_PRIVS
comment|/* Eat any leading paths      */
if|if
condition|(
operator|(
name|pgm
operator|=
name|strrchr
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|pgm
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
else|else
name|pgm
operator|++
expr_stmt|;
name|namep
operator|=
name|pgm
expr_stmt|;
comment|/* find out what this program is supposed to do      */
if|if
condition|(
name|strcmp
argument_list|(
name|pgm
argument_list|,
literal|"atq"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|program
operator|=
name|ATQ
expr_stmt|;
name|options
operator|=
literal|"q:vV"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|pgm
argument_list|,
literal|"atrm"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|program
operator|=
name|ATRM
expr_stmt|;
name|options
operator|=
literal|"V"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|pgm
argument_list|,
literal|"batch"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|program
operator|=
name|BATCH
expr_stmt|;
name|options
operator|=
literal|"f:q:mvV"
expr_stmt|;
block|}
comment|/* process whatever options we can process      */
name|opterr
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|options
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'v'
case|:
comment|/* verify time settings */
name|atverify
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
comment|/* send mail when job is complete */
name|send_mail
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|atinput
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
comment|/* specify queue */
if|if
condition|(
name|strlen
argument_list|(
name|optarg
argument_list|)
operator|>
literal|1
condition|)
name|usage
argument_list|()
expr_stmt|;
name|atqueue
operator|=
name|queue
operator|=
operator|*
name|optarg
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|islower
argument_list|(
name|queue
argument_list|)
operator|||
name|isupper
argument_list|(
name|queue
argument_list|)
operator|)
condition|)
name|usage
argument_list|()
expr_stmt|;
name|queue_set
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
if|if
condition|(
name|program
operator|!=
name|AT
condition|)
name|usage
argument_list|()
expr_stmt|;
name|program
operator|=
name|ATRM
expr_stmt|;
name|options
operator|=
literal|"V"
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
if|if
condition|(
name|program
operator|!=
name|AT
condition|)
name|usage
argument_list|()
expr_stmt|;
name|program
operator|=
name|ATQ
expr_stmt|;
name|options
operator|=
literal|"q:vV"
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
if|if
condition|(
name|program
operator|!=
name|AT
condition|)
name|usage
argument_list|()
expr_stmt|;
name|program
operator|=
name|BATCH
expr_stmt|;
name|options
operator|=
literal|"f:q:mvV"
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
name|disp_version
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|program
operator|=
name|CAT
expr_stmt|;
name|options
operator|=
literal|""
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|()
expr_stmt|;
break|break;
block|}
comment|/* end of options eating      */
if|if
condition|(
name|disp_version
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"at version "
name|VERSION
literal|"\n"
literal|"Bug reports to: ig25@rz.uni-karlsruhe.de (Thomas Koenig)\n"
argument_list|)
expr_stmt|;
comment|/* select our program      */
if|if
condition|(
operator|!
name|check_permission
argument_list|()
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"You do not have permission to use %s.\n"
argument_list|,
name|namep
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|program
condition|)
block|{
case|case
name|ATQ
case|:
name|REDUCE_PRIV
argument_list|(
argument|DAEMON_UID
argument_list|,
argument|DAEMON_GID
argument_list|)
name|list_jobs
argument_list|()
expr_stmt|;
break|break;
case|case
name|ATRM
case|:
name|REDUCE_PRIV
argument_list|(
argument|DAEMON_UID
argument_list|,
argument|DAEMON_GID
argument_list|)
name|process_jobs
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|ATRM
argument_list|)
expr_stmt|;
break|break;
case|case
name|CAT
case|:
name|process_jobs
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|CAT
argument_list|)
expr_stmt|;
break|break;
case|case
name|AT
case|:
name|timer
operator|=
name|parsetime
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|atverify
condition|)
block|{
name|struct
name|tm
modifier|*
name|tm
init|=
name|localtime
argument_list|(
operator|&
name|timer
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|asctime
argument_list|(
name|tm
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|writefile
argument_list|(
name|timer
argument_list|,
name|queue
argument_list|)
expr_stmt|;
break|break;
case|case
name|BATCH
case|:
if|if
condition|(
name|queue_set
condition|)
name|queue
operator|=
name|toupper
argument_list|(
name|queue
argument_list|)
expr_stmt|;
else|else
name|queue
operator|=
name|DEFAULT_BATCH_QUEUE
expr_stmt|;
if|if
condition|(
name|argc
operator|>
name|optind
condition|)
name|timer
operator|=
name|parsetime
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
else|else
name|timer
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|atverify
condition|)
block|{
name|struct
name|tm
modifier|*
name|tm
init|=
name|localtime
argument_list|(
operator|&
name|timer
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|asctime
argument_list|(
name|tm
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|writefile
argument_list|(
name|timer
argument_list|,
name|queue
argument_list|)
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"Internal error"
argument_list|)
expr_stmt|;
break|break;
block|}
name|exit
argument_list|(
name|EXIT_SUCCESS
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

