begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**************************************************************** Copyright 1990 - 1996 by AT&T, Lucent Technologies and Bellcore.  Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that the copyright notice and this permission notice and warranty disclaimer appear in supporting documentation, and that the names of AT&T, Bell Laboratories, Lucent or Bellcore or any of their entities not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  AT&T, Lucent and Bellcore disclaim all warranties with regard to this software, including all implied warranties of merchantability and fitness.  In no event shall AT&T, Lucent or Bellcore be liable for any special, indirect or consequential damages or any damages whatsoever resulting from loss of use, data or profits, whether in an action of contract, negligence or other tortious action, arising out of or in connection with the use or performance of this software. ****************************************************************/
end_comment

begin_decl_stmt
specifier|extern
name|char
name|F2C_version
index|[]
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"parse.h"
end_include

begin_decl_stmt
name|int
name|complex_seen
decl_stmt|,
name|dcomplex_seen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LOCAL
name|int
name|Max_ftn_files
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|badargs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|ftn_files
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|current_ftn_file
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|flag
name|ftn66flag
init|=
name|NO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|flag
name|nowarnflag
init|=
name|NO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|flag
name|noextflag
init|=
name|NO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|flag
name|no66flag
init|=
name|NO
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Must also set noextflag to this 					   same value */
end_comment

begin_decl_stmt
name|flag
name|zflag
init|=
name|YES
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* recognize double complex intrinsics */
end_comment

begin_decl_stmt
name|flag
name|debugflag
init|=
name|NO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|flag
name|onetripflag
init|=
name|NO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|flag
name|shiftcase
init|=
name|YES
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|flag
name|undeftype
init|=
name|NO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|flag
name|checksubs
init|=
name|NO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|flag
name|r8flag
init|=
name|NO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|flag
name|use_bs
init|=
name|YES
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|flag
name|keepsubs
init|=
name|NO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|flag
name|byterev
init|=
name|NO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|intr_omit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|no_cd
decl_stmt|,
name|no_i90
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|TYQUAD
end_ifdef

begin_decl_stmt
name|flag
name|use_tyquad
init|=
name|YES
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|tyreal
init|=
name|TYREAL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|tycomplex
init|=
name|TYCOMPLEX
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|maxregvar
init|=
name|MAXREGVAR
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* if maxregvar> MAXREGVAR, error */
end_comment

begin_decl_stmt
name|int
name|maxequiv
init|=
name|MAXEQUIV
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|maxext
init|=
name|MAXEXT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|maxstno
init|=
name|MAXSTNO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|maxctl
init|=
name|MAXCTL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|maxhash
init|=
name|MAXHASH
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|maxliterals
init|=
name|MAXLITERALS
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|maxcontin
init|=
name|MAXCONTIN
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|maxlablist
init|=
name|MAXLABLIST
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|extcomm
decl_stmt|,
name|ext1comm
decl_stmt|,
name|useauto
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|can_include
init|=
name|YES
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* so we can disable includes for netlib */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|def_i2
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|useshortints
init|=
name|NO
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* YES => tyint = TYSHORT */
end_comment

begin_decl_stmt
specifier|static
name|int
name|uselongints
init|=
name|NO
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* YES => tyint = TYLONG */
end_comment

begin_decl_stmt
name|int
name|addftnsrc
init|=
name|NO
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Include ftn source in output */
end_comment

begin_decl_stmt
name|int
name|usedefsforcommon
init|=
name|NO
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Use #defines for common reference */
end_comment

begin_decl_stmt
name|int
name|forcedouble
init|=
name|YES
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* force real functions to double */
end_comment

begin_decl_stmt
name|int
name|dneg
init|=
name|NO
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* f77 treatment of unary minus */
end_comment

begin_decl_stmt
name|int
name|Ansi
init|=
name|NO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|def_equivs
init|=
name|YES
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|tyioint
init|=
name|TYLONG
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|szleng
init|=
name|SZLENG
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|inqmask
init|=
name|M
argument_list|(
name|TYLONG
argument_list|)
operator||
name|M
argument_list|(
name|TYLOGICAL
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|wordalign
init|=
name|NO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|forcereal
init|=
name|NO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|warn72
init|=
name|NO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|skipC
decl_stmt|,
name|skipversion
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|file_name
decl_stmt|,
modifier|*
name|filename0
decl_stmt|,
modifier|*
name|parens
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Castargs
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|Castargs1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|typedefs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|chars_per_wd
decl_stmt|,
name|gflag
decl_stmt|,
name|protostatus
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|infertypes
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|used_rets
index|[
name|TYSUBR
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|tmpdir
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|h0align
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|halign
decl_stmt|,
modifier|*
name|ohalign
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|krparens
init|=
name|NO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|hsize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for padding under -h */
end_comment

begin_decl_stmt
name|int
name|htype
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for wr_equiv_init under -h */
end_comment

begin_decl_stmt
name|chainp
name|Iargs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|o_coutput
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|f2c_entry
parameter_list|(
name|swit
parameter_list|,
name|count
parameter_list|,
name|type
parameter_list|,
name|store
parameter_list|,
name|size
parameter_list|)
define|\
value|p_entry ("-", swit, 0, count, type, store, size)
end_define

begin_decl_stmt
specifier|static
name|arg_info
name|table
index|[]
init|=
block|{
name|f2c_entry
argument_list|(
literal|"o"
argument_list|,
name|P_ONE_ARG
argument_list|,
name|P_STRING
argument_list|,
operator|&
name|o_coutput
argument_list|,
name|YES
argument_list|)
block|,
name|f2c_entry
argument_list|(
literal|"w66"
argument_list|,
name|P_NO_ARGS
argument_list|,
name|P_INT
argument_list|,
operator|&
name|ftn66flag
argument_list|,
name|YES
argument_list|)
block|,
name|f2c_entry
argument_list|(
literal|"w"
argument_list|,
name|P_NO_ARGS
argument_list|,
name|P_INT
argument_list|,
operator|&
name|nowarnflag
argument_list|,
name|YES
argument_list|)
block|,
name|f2c_entry
argument_list|(
literal|"66"
argument_list|,
name|P_NO_ARGS
argument_list|,
name|P_INT
argument_list|,
operator|&
name|no66flag
argument_list|,
name|YES
argument_list|)
block|,
name|f2c_entry
argument_list|(
literal|"1"
argument_list|,
name|P_NO_ARGS
argument_list|,
name|P_INT
argument_list|,
operator|&
name|onetripflag
argument_list|,
name|YES
argument_list|)
block|,
name|f2c_entry
argument_list|(
literal|"onetrip"
argument_list|,
name|P_NO_ARGS
argument_list|,
name|P_INT
argument_list|,
operator|&
name|onetripflag
argument_list|,
name|YES
argument_list|)
block|,
name|f2c_entry
argument_list|(
literal|"I2"
argument_list|,
name|P_NO_ARGS
argument_list|,
name|P_INT
argument_list|,
operator|&
name|useshortints
argument_list|,
name|YES
argument_list|)
block|,
name|f2c_entry
argument_list|(
literal|"I4"
argument_list|,
name|P_NO_ARGS
argument_list|,
name|P_INT
argument_list|,
operator|&
name|uselongints
argument_list|,
name|YES
argument_list|)
block|,
name|f2c_entry
argument_list|(
literal|"U"
argument_list|,
name|P_NO_ARGS
argument_list|,
name|P_INT
argument_list|,
operator|&
name|shiftcase
argument_list|,
name|NO
argument_list|)
block|,
name|f2c_entry
argument_list|(
literal|"u"
argument_list|,
name|P_NO_ARGS
argument_list|,
name|P_INT
argument_list|,
operator|&
name|undeftype
argument_list|,
name|YES
argument_list|)
block|,
name|f2c_entry
argument_list|(
literal|"O"
argument_list|,
name|P_ONE_ARG
argument_list|,
name|P_INT
argument_list|,
operator|&
name|maxregvar
argument_list|,
literal|0
argument_list|)
block|,
name|f2c_entry
argument_list|(
literal|"C"
argument_list|,
name|P_NO_ARGS
argument_list|,
name|P_INT
argument_list|,
operator|&
name|checksubs
argument_list|,
name|YES
argument_list|)
block|,
name|f2c_entry
argument_list|(
literal|"Nq"
argument_list|,
name|P_ONE_ARG
argument_list|,
name|P_INT
argument_list|,
operator|&
name|maxequiv
argument_list|,
literal|0
argument_list|)
block|,
name|f2c_entry
argument_list|(
literal|"Nx"
argument_list|,
name|P_ONE_ARG
argument_list|,
name|P_INT
argument_list|,
operator|&
name|maxext
argument_list|,
literal|0
argument_list|)
block|,
name|f2c_entry
argument_list|(
literal|"Ns"
argument_list|,
name|P_ONE_ARG
argument_list|,
name|P_INT
argument_list|,
operator|&
name|maxstno
argument_list|,
literal|0
argument_list|)
block|,
name|f2c_entry
argument_list|(
literal|"Nc"
argument_list|,
name|P_ONE_ARG
argument_list|,
name|P_INT
argument_list|,
operator|&
name|maxctl
argument_list|,
literal|0
argument_list|)
block|,
name|f2c_entry
argument_list|(
literal|"Nn"
argument_list|,
name|P_ONE_ARG
argument_list|,
name|P_INT
argument_list|,
operator|&
name|maxhash
argument_list|,
literal|0
argument_list|)
block|,
name|f2c_entry
argument_list|(
literal|"NL"
argument_list|,
name|P_ONE_ARG
argument_list|,
name|P_INT
argument_list|,
operator|&
name|maxliterals
argument_list|,
literal|0
argument_list|)
block|,
name|f2c_entry
argument_list|(
literal|"NC"
argument_list|,
name|P_ONE_ARG
argument_list|,
name|P_INT
argument_list|,
operator|&
name|maxcontin
argument_list|,
literal|0
argument_list|)
block|,
name|f2c_entry
argument_list|(
literal|"Nl"
argument_list|,
name|P_ONE_ARG
argument_list|,
name|P_INT
argument_list|,
operator|&
name|maxlablist
argument_list|,
literal|0
argument_list|)
block|,
name|f2c_entry
argument_list|(
literal|"c"
argument_list|,
name|P_NO_ARGS
argument_list|,
name|P_INT
argument_list|,
operator|&
name|addftnsrc
argument_list|,
name|YES
argument_list|)
block|,
name|f2c_entry
argument_list|(
literal|"p"
argument_list|,
name|P_NO_ARGS
argument_list|,
name|P_INT
argument_list|,
operator|&
name|usedefsforcommon
argument_list|,
name|YES
argument_list|)
block|,
name|f2c_entry
argument_list|(
literal|"R"
argument_list|,
name|P_NO_ARGS
argument_list|,
name|P_INT
argument_list|,
operator|&
name|forcedouble
argument_list|,
name|NO
argument_list|)
block|,
name|f2c_entry
argument_list|(
literal|"!R"
argument_list|,
name|P_NO_ARGS
argument_list|,
name|P_INT
argument_list|,
operator|&
name|forcedouble
argument_list|,
name|YES
argument_list|)
block|,
name|f2c_entry
argument_list|(
literal|"A"
argument_list|,
name|P_NO_ARGS
argument_list|,
name|P_INT
argument_list|,
operator|&
name|Ansi
argument_list|,
name|YES
argument_list|)
block|,
name|f2c_entry
argument_list|(
literal|"ext"
argument_list|,
name|P_NO_ARGS
argument_list|,
name|P_INT
argument_list|,
operator|&
name|noextflag
argument_list|,
name|YES
argument_list|)
block|,
name|f2c_entry
argument_list|(
literal|"z"
argument_list|,
name|P_NO_ARGS
argument_list|,
name|P_INT
argument_list|,
operator|&
name|zflag
argument_list|,
name|NO
argument_list|)
block|,
name|f2c_entry
argument_list|(
literal|"a"
argument_list|,
name|P_NO_ARGS
argument_list|,
name|P_INT
argument_list|,
operator|&
name|useauto
argument_list|,
name|YES
argument_list|)
block|,
name|f2c_entry
argument_list|(
literal|"r8"
argument_list|,
name|P_NO_ARGS
argument_list|,
name|P_INT
argument_list|,
operator|&
name|r8flag
argument_list|,
name|YES
argument_list|)
block|,
name|f2c_entry
argument_list|(
literal|"i2"
argument_list|,
name|P_NO_ARGS
argument_list|,
name|P_INT
argument_list|,
operator|&
name|tyioint
argument_list|,
name|NO
argument_list|)
block|,
name|f2c_entry
argument_list|(
literal|"w8"
argument_list|,
name|P_NO_ARGS
argument_list|,
name|P_INT
argument_list|,
operator|&
name|wordalign
argument_list|,
name|YES
argument_list|)
block|,
name|f2c_entry
argument_list|(
literal|"!I"
argument_list|,
name|P_NO_ARGS
argument_list|,
name|P_INT
argument_list|,
operator|&
name|can_include
argument_list|,
name|NO
argument_list|)
block|,
name|f2c_entry
argument_list|(
literal|"W"
argument_list|,
name|P_ONE_ARG
argument_list|,
name|P_INT
argument_list|,
operator|&
name|chars_per_wd
argument_list|,
literal|0
argument_list|)
block|,
name|f2c_entry
argument_list|(
literal|"g"
argument_list|,
name|P_NO_ARGS
argument_list|,
name|P_INT
argument_list|,
operator|&
name|gflag
argument_list|,
name|YES
argument_list|)
block|,
name|f2c_entry
argument_list|(
literal|"T"
argument_list|,
name|P_ONE_ARG
argument_list|,
name|P_STRING
argument_list|,
operator|&
name|tmpdir
argument_list|,
literal|0
argument_list|)
block|,
name|f2c_entry
argument_list|(
literal|"E"
argument_list|,
name|P_NO_ARGS
argument_list|,
name|P_INT
argument_list|,
operator|&
name|extcomm
argument_list|,
literal|1
argument_list|)
block|,
name|f2c_entry
argument_list|(
literal|"e1c"
argument_list|,
name|P_NO_ARGS
argument_list|,
name|P_INT
argument_list|,
operator|&
name|ext1comm
argument_list|,
literal|1
argument_list|)
block|,
name|f2c_entry
argument_list|(
literal|"ec"
argument_list|,
name|P_NO_ARGS
argument_list|,
name|P_INT
argument_list|,
operator|&
name|ext1comm
argument_list|,
literal|2
argument_list|)
block|,
name|f2c_entry
argument_list|(
literal|"C++"
argument_list|,
name|P_NO_ARGS
argument_list|,
name|P_INT
argument_list|,
operator|&
name|Ansi
argument_list|,
literal|2
argument_list|)
block|,
name|f2c_entry
argument_list|(
literal|"P"
argument_list|,
name|P_NO_ARGS
argument_list|,
name|P_INT
argument_list|,
operator|&
name|Castargs
argument_list|,
literal|3
argument_list|)
block|,
name|f2c_entry
argument_list|(
literal|"Ps"
argument_list|,
name|P_NO_ARGS
argument_list|,
name|P_INT
argument_list|,
operator|&
name|protostatus
argument_list|,
literal|1
argument_list|)
block|,
name|f2c_entry
argument_list|(
literal|"!P"
argument_list|,
name|P_NO_ARGS
argument_list|,
name|P_INT
argument_list|,
operator|&
name|Castargs
argument_list|,
literal|0
argument_list|)
block|,
name|f2c_entry
argument_list|(
literal|"!c"
argument_list|,
name|P_NO_ARGS
argument_list|,
name|P_INT
argument_list|,
operator|&
name|skipC
argument_list|,
literal|1
argument_list|)
block|,
name|f2c_entry
argument_list|(
literal|"!it"
argument_list|,
name|P_NO_ARGS
argument_list|,
name|P_INT
argument_list|,
operator|&
name|infertypes
argument_list|,
literal|0
argument_list|)
block|,
name|f2c_entry
argument_list|(
literal|"h"
argument_list|,
name|P_NO_ARGS
argument_list|,
name|P_INT
argument_list|,
operator|&
name|h0align
argument_list|,
literal|1
argument_list|)
block|,
name|f2c_entry
argument_list|(
literal|"hd"
argument_list|,
name|P_NO_ARGS
argument_list|,
name|P_INT
argument_list|,
operator|&
name|h0align
argument_list|,
literal|2
argument_list|)
block|,
name|f2c_entry
argument_list|(
literal|"kr"
argument_list|,
name|P_NO_ARGS
argument_list|,
name|P_INT
argument_list|,
operator|&
name|krparens
argument_list|,
literal|1
argument_list|)
block|,
name|f2c_entry
argument_list|(
literal|"krd"
argument_list|,
name|P_NO_ARGS
argument_list|,
name|P_INT
argument_list|,
operator|&
name|krparens
argument_list|,
literal|2
argument_list|)
block|,
name|f2c_entry
argument_list|(
literal|"!bs"
argument_list|,
name|P_NO_ARGS
argument_list|,
name|P_INT
argument_list|,
operator|&
name|use_bs
argument_list|,
name|NO
argument_list|)
block|,
name|f2c_entry
argument_list|(
literal|"r"
argument_list|,
name|P_NO_ARGS
argument_list|,
name|P_INT
argument_list|,
operator|&
name|forcereal
argument_list|,
name|YES
argument_list|)
block|,
name|f2c_entry
argument_list|(
literal|"72"
argument_list|,
name|P_NO_ARGS
argument_list|,
name|P_INT
argument_list|,
operator|&
name|warn72
argument_list|,
literal|1
argument_list|)
block|,
name|f2c_entry
argument_list|(
literal|"f"
argument_list|,
name|P_NO_ARGS
argument_list|,
name|P_INT
argument_list|,
operator|&
name|warn72
argument_list|,
literal|2
argument_list|)
block|,
name|f2c_entry
argument_list|(
literal|"s"
argument_list|,
name|P_NO_ARGS
argument_list|,
name|P_INT
argument_list|,
operator|&
name|keepsubs
argument_list|,
literal|1
argument_list|)
block|,
name|f2c_entry
argument_list|(
literal|"d"
argument_list|,
name|P_ONE_ARG
argument_list|,
name|P_STRING
argument_list|,
operator|&
name|outbuf
argument_list|,
literal|0
argument_list|)
block|,
name|f2c_entry
argument_list|(
literal|"cd"
argument_list|,
name|P_NO_ARGS
argument_list|,
name|P_INT
argument_list|,
operator|&
name|no_cd
argument_list|,
literal|1
argument_list|)
block|,
name|f2c_entry
argument_list|(
literal|"i90"
argument_list|,
name|P_NO_ARGS
argument_list|,
name|P_INT
argument_list|,
operator|&
name|no_i90
argument_list|,
literal|2
argument_list|)
block|,
ifdef|#
directive|ifdef
name|TYQUAD
name|f2c_entry
argument_list|(
literal|"!i8"
argument_list|,
name|P_NO_ARGS
argument_list|,
name|P_INT
argument_list|,
operator|&
name|use_tyquad
argument_list|,
name|NO
argument_list|)
block|,
endif|#
directive|endif
comment|/* options omitted from man pages */
comment|/* -b ==> for unformatted I/O, call do_unio (for noncharacter  */
comment|/* data of length> 1 byte) and do_ucio (for the rest) rather  */
comment|/* than do_uio.  This permits modifying libI77 to byte-reverse */
comment|/* numeric data. */
name|f2c_entry
argument_list|(
literal|"b"
argument_list|,
name|P_NO_ARGS
argument_list|,
name|P_INT
argument_list|,
operator|&
name|byterev
argument_list|,
name|YES
argument_list|)
block|,
comment|/* -ev ==> implement equivalence with initialized pointers */
name|f2c_entry
argument_list|(
literal|"ev"
argument_list|,
name|P_NO_ARGS
argument_list|,
name|P_INT
argument_list|,
operator|&
name|def_equivs
argument_list|,
name|NO
argument_list|)
block|,
comment|/* -!it used to be the default when -it was more agressive */
name|f2c_entry
argument_list|(
literal|"it"
argument_list|,
name|P_NO_ARGS
argument_list|,
name|P_INT
argument_list|,
operator|&
name|infertypes
argument_list|,
literal|1
argument_list|)
block|,
comment|/* -Pd is similar to -P, but omits :ref: lines */
name|f2c_entry
argument_list|(
literal|"Pd"
argument_list|,
name|P_NO_ARGS
argument_list|,
name|P_INT
argument_list|,
operator|&
name|Castargs
argument_list|,
literal|2
argument_list|)
block|,
comment|/* -t ==> emit typedefs (under -A or -C++) for procedure 		argument types used.  This is meant for netlib's 		f2c service, so -A and -C++ will work with older 		versions of f2c.h 		*/
name|f2c_entry
argument_list|(
literal|"t"
argument_list|,
name|P_NO_ARGS
argument_list|,
name|P_INT
argument_list|,
operator|&
name|typedefs
argument_list|,
literal|1
argument_list|)
block|,
comment|/* -!V ==> omit version msg (to facilitate using diff in 		regression testing) 		*/
name|f2c_entry
argument_list|(
literal|"!V"
argument_list|,
name|P_NO_ARGS
argument_list|,
name|P_INT
argument_list|,
operator|&
name|skipversion
argument_list|,
literal|1
argument_list|)
block|,
comment|/* -Dnnn = debug level nnn */
name|f2c_entry
argument_list|(
literal|"D"
argument_list|,
name|P_ONE_ARG
argument_list|,
name|P_INT
argument_list|,
operator|&
name|debugflag
argument_list|,
name|YES
argument_list|)
block|,
comment|/* -dneg ==> under (default) -!R, imitate f77's bizarre	*/
comment|/* treatment of unary minus of REAL expressions by	*/
comment|/* promoting them to DOUBLE PRECISION . */
name|f2c_entry
argument_list|(
literal|"dneg"
argument_list|,
argument|P_NO_ARGS
argument_list|,
argument|P_INT
argument_list|,
argument|&dneg
argument_list|,
argument|YES
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* table */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|c_functions
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* "c_functions"	*/
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|coutput
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* "c_output"		*/
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|initfname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* "raw_data"		*/
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|blkdfname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* "block_data"		*/
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|p1_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* "p1_file"		*/
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|p1_bakfile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* "p1_file.BAK"	*/
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|sortfname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* "init_file"		*/
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|proto_fname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* "proto_file"		*/
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|protofile
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|set_externs
parameter_list|(
name|Void
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|hset
index|[
literal|3
index|]
init|=
block|{
literal|0
block|,
literal|"integer"
block|,
literal|"doublereal"
block|}
decl_stmt|;
comment|/* Adjust the global flags according to the command line parameters */
if|if
condition|(
name|chars_per_wd
operator|>
literal|0
condition|)
block|{
name|typesize
index|[
name|TYADDR
index|]
operator|=
name|typesize
index|[
name|TYLONG
index|]
operator|=
name|typesize
index|[
name|TYREAL
index|]
operator|=
name|typesize
index|[
name|TYLOGICAL
index|]
operator|=
name|chars_per_wd
expr_stmt|;
name|typesize
index|[
name|TYINT1
index|]
operator|=
name|typesize
index|[
name|TYLOGICAL1
index|]
operator|=
literal|1
expr_stmt|;
name|typesize
index|[
name|TYDREAL
index|]
operator|=
name|typesize
index|[
name|TYCOMPLEX
index|]
operator|=
name|chars_per_wd
operator|<<
literal|1
expr_stmt|;
name|typesize
index|[
name|TYDCOMPLEX
index|]
operator|=
name|chars_per_wd
operator|<<
literal|2
expr_stmt|;
name|typesize
index|[
name|TYSHORT
index|]
operator|=
name|typesize
index|[
name|TYLOGICAL2
index|]
operator|=
name|chars_per_wd
operator|>>
literal|1
expr_stmt|;
name|typesize
index|[
name|TYCILIST
index|]
operator|=
literal|5
operator|*
name|chars_per_wd
expr_stmt|;
name|typesize
index|[
name|TYICILIST
index|]
operator|=
literal|6
operator|*
name|chars_per_wd
expr_stmt|;
name|typesize
index|[
name|TYOLIST
index|]
operator|=
literal|9
operator|*
name|chars_per_wd
expr_stmt|;
name|typesize
index|[
name|TYCLLIST
index|]
operator|=
literal|3
operator|*
name|chars_per_wd
expr_stmt|;
name|typesize
index|[
name|TYALIST
index|]
operator|=
literal|2
operator|*
name|chars_per_wd
expr_stmt|;
name|typesize
index|[
name|TYINLIST
index|]
operator|=
literal|26
operator|*
name|chars_per_wd
expr_stmt|;
block|}
if|if
condition|(
name|wordalign
condition|)
name|typealign
index|[
name|TYDREAL
index|]
operator|=
name|typealign
index|[
name|TYDCOMPLEX
index|]
operator|=
name|typealign
index|[
name|TYREAL
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|tyioint
condition|)
block|{
name|tyioint
operator|=
name|TYSHORT
expr_stmt|;
name|szleng
operator|=
name|typesize
index|[
name|TYSHORT
index|]
expr_stmt|;
name|def_i2
operator|=
literal|"#define f2c_i2 1\n"
expr_stmt|;
name|inqmask
operator|=
name|M
argument_list|(
name|TYSHORT
argument_list|)
operator||
name|M
argument_list|(
name|TYLOGICAL2
argument_list|)
expr_stmt|;
goto|goto
name|checklong
goto|;
block|}
else|else
name|szleng
operator|=
name|typesize
index|[
name|TYLONG
index|]
expr_stmt|;
if|if
condition|(
name|useshortints
condition|)
block|{
comment|/* inqmask = M(TYLONG); */
comment|/* used to disallow LOGICAL in INQUIRE under -I2 */
name|checklong
label|:
name|protorettypes
index|[
name|TYLOGICAL
index|]
operator|=
literal|"shortlogical"
expr_stmt|;
name|casttypes
index|[
name|TYLOGICAL
index|]
operator|=
literal|"K_fp"
expr_stmt|;
if|if
condition|(
name|uselongints
condition|)
name|err
argument_list|(
literal|"Can't use both long and short ints"
argument_list|)
expr_stmt|;
else|else
block|{
name|tyint
operator|=
name|tylogical
operator|=
name|TYSHORT
expr_stmt|;
name|tylog
operator|=
name|TYLOGICAL2
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|uselongints
condition|)
name|tyint
operator|=
name|TYLONG
expr_stmt|;
if|if
condition|(
name|h0align
condition|)
block|{
if|if
condition|(
name|tyint
operator|==
name|TYLONG
operator|&&
name|wordalign
condition|)
name|h0align
operator|=
literal|1
expr_stmt|;
name|ohalign
operator|=
name|halign
operator|=
name|hset
index|[
name|h0align
index|]
expr_stmt|;
name|htype
operator|=
name|h0align
operator|==
literal|1
condition|?
name|tyint
else|:
name|TYDREAL
expr_stmt|;
name|hsize
operator|=
name|typesize
index|[
name|htype
index|]
expr_stmt|;
block|}
if|if
condition|(
name|no66flag
condition|)
name|noextflag
operator|=
name|no66flag
expr_stmt|;
if|if
condition|(
name|noextflag
condition|)
name|zflag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|r8flag
condition|)
block|{
name|tyreal
operator|=
name|TYDREAL
expr_stmt|;
name|tycomplex
operator|=
name|TYDCOMPLEX
expr_stmt|;
name|r8fix
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|forcedouble
condition|)
block|{
name|protorettypes
index|[
name|TYREAL
index|]
operator|=
literal|"E_f"
expr_stmt|;
name|casttypes
index|[
name|TYREAL
index|]
operator|=
literal|"E_fp"
expr_stmt|;
block|}
else|else
name|dneg
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|maxregvar
operator|>
name|MAXREGVAR
condition|)
block|{
name|warni
argument_list|(
literal|"-O%d: too many register variables"
argument_list|,
name|maxregvar
argument_list|)
expr_stmt|;
name|maxregvar
operator|=
name|MAXREGVAR
expr_stmt|;
block|}
comment|/* if maxregvar> MAXREGVAR */
comment|/* Check the list of input files */
block|{
name|int
name|bad
decl_stmt|,
name|i
decl_stmt|,
name|cur_max
init|=
name|Max_ftn_files
decl_stmt|;
for|for
control|(
name|i
operator|=
name|bad
operator|=
literal|0
init|;
name|i
operator|<
name|cur_max
operator|&&
name|ftn_files
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|ftn_files
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
name|errstr
argument_list|(
literal|"Invalid flag '%s'"
argument_list|,
name|ftn_files
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|bad
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|bad
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* block */
block|}
end_function

begin_comment
comment|/* set_externs */
end_comment

begin_function
specifier|static
name|int
name|comm2dcl
parameter_list|(
name|Void
parameter_list|)
block|{
name|Extsym
modifier|*
name|ext
decl_stmt|;
if|if
condition|(
name|ext1comm
condition|)
for|for
control|(
name|ext
operator|=
name|extsymtab
init|;
name|ext
operator|<
name|nextext
condition|;
name|ext
operator|++
control|)
if|if
condition|(
name|ext
operator|->
name|extstg
operator|==
name|STGCOMMON
operator|&&
operator|!
name|ext
operator|->
name|extinit
condition|)
return|return
name|ext1comm
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|write_typedefs
parameter_list|(
name|outfile
parameter_list|)
name|FILE
modifier|*
name|outfile
decl_stmt|;
else|#
directive|else
function|write_typedefs
parameter_list|(
name|FILE
modifier|*
name|outfile
parameter_list|)
endif|#
directive|endif
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|p
init|=
literal|0
decl_stmt|;
specifier|static
name|char
name|st
index|[
literal|4
index|]
init|=
block|{
name|TYREAL
block|,
name|TYCOMPLEX
block|,
name|TYDCOMPLEX
block|,
name|TYCHAR
block|}
decl_stmt|;
specifier|static
name|char
name|stl
index|[
literal|4
index|]
init|=
block|{
literal|'E'
block|,
literal|'C'
block|,
literal|'Z'
block|,
literal|'H'
block|}
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|TYSUBR
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|s
operator|=
name|usedcasts
index|[
name|i
index|]
condition|)
block|{
if|if
condition|(
operator|!
name|p
condition|)
block|{
name|p
operator|=
name|Ansi
operator|==
literal|1
condition|?
literal|"()"
else|:
literal|"(...)"
expr_stmt|;
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"/* Types for casting procedure arguments: */\ \n\n#ifndef F2C_proc_par_types\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"typedef int /* Unknown procedure type */ (*%s)%s;\n"
argument_list|,
name|s
argument_list|,
name|p
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"typedef %s (*%s)%s;\n"
argument_list|,
name|c_type_decl
argument_list|(
name|i
argument_list|,
literal|1
argument_list|)
argument_list|,
name|s
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
operator|!
name|forcedouble
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|used_rets
index|[
name|st
index|[
name|i
index|]
index|]
condition|)
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"typedef %s %c_f; /* %s function */\n"
argument_list|,
name|p
operator|=
name|i
condition|?
literal|"VOID"
else|:
literal|"doublereal"
argument_list|,
name|stl
index|[
name|i
index|]
argument_list|,
name|ftn_types
index|[
name|st
index|[
name|i
index|]
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"#endif\n\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|commonprotos
parameter_list|(
name|outfile
parameter_list|)
specifier|register
name|FILE
modifier|*
name|outfile
decl_stmt|;
else|#
directive|else
function|commonprotos
parameter_list|(
specifier|register
name|FILE
modifier|*
name|outfile
parameter_list|)
endif|#
directive|endif
block|{
specifier|register
name|Extsym
modifier|*
name|e
decl_stmt|,
modifier|*
name|ee
decl_stmt|;
specifier|register
name|Argtypes
modifier|*
name|at
decl_stmt|;
name|Atype
modifier|*
name|a
decl_stmt|,
modifier|*
name|ae
decl_stmt|;
name|int
name|k
decl_stmt|;
specifier|extern
name|int
name|proc_protochanges
decl_stmt|;
if|if
condition|(
operator|!
name|outfile
condition|)
return|return;
for|for
control|(
name|e
operator|=
name|extsymtab
operator|,
name|ee
operator|=
name|nextext
init|;
name|e
operator|<
name|ee
condition|;
name|e
operator|++
control|)
if|if
condition|(
name|e
operator|->
name|extstg
operator|==
name|STGCOMMON
operator|&&
name|e
operator|->
name|allextp
condition|)
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"/* comlen %s %ld */\n"
argument_list|,
name|e
operator|->
name|cextname
argument_list|,
name|e
operator|->
name|maxleng
argument_list|)
expr_stmt|;
if|if
condition|(
name|Castargs1
operator|<
literal|3
condition|)
return|return;
comment|/* -Pr: special comments conveying current knowledge 	    of external references */
name|k
operator|=
name|proc_protochanges
expr_stmt|;
for|for
control|(
name|e
operator|=
name|extsymtab
operator|,
name|ee
operator|=
name|nextext
init|;
name|e
operator|<
name|ee
condition|;
name|e
operator|++
control|)
if|if
condition|(
name|e
operator|->
name|extstg
operator|==
name|STGEXT
operator|&&
name|e
operator|->
name|cextname
operator|!=
name|e
operator|->
name|fextname
condition|)
comment|/* not a library function */
if|if
condition|(
name|at
operator|=
name|e
operator|->
name|arginfo
condition|)
block|{
if|if
condition|(
operator|(
operator|!
name|e
operator|->
name|extinit
operator|||
name|at
operator|->
name|changes
operator|&
literal|1
operator|)
comment|/* not defined here or 					changed since definition */
operator|&&
name|at
operator|->
name|nargs
operator|>=
literal|0
condition|)
block|{
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"/*:ref: %s %d %d"
argument_list|,
name|e
operator|->
name|cextname
argument_list|,
name|e
operator|->
name|extype
argument_list|,
name|at
operator|->
name|nargs
argument_list|)
expr_stmt|;
name|a
operator|=
name|at
operator|->
name|atypes
expr_stmt|;
for|for
control|(
name|ae
operator|=
name|a
operator|+
name|at
operator|->
name|nargs
init|;
name|a
operator|<
name|ae
condition|;
name|a
operator|++
control|)
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|" %d"
argument_list|,
name|a
operator|->
name|type
argument_list|)
expr_stmt|;
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|" */\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|at
operator|->
name|changes
operator|&
literal|1
condition|)
name|k
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|e
operator|->
name|extype
condition|)
comment|/* typed external, never invoked */
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"/*:ref: %s %d :*/\n"
argument_list|,
name|e
operator|->
name|cextname
argument_list|,
name|e
operator|->
name|extype
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
condition|)
block|{
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"/* Rerunning f2c -P may change prototypes or declarations. */\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|nerr
condition|)
return|return;
if|if
condition|(
name|protostatus
condition|)
name|done
argument_list|(
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|protofile
operator|!=
name|stdout
condition|)
block|{
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"Rerunning \"f2c -P ... %s %s\" may change prototypes or declarations.\n"
argument_list|,
name|filename0
argument_list|,
name|proto_fname
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|diagfile
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
ifdef|#
directive|ifdef
name|KR_headers
name|I_args
parameter_list|(
name|argc
parameter_list|,
name|a
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|a
decl_stmt|;
else|#
directive|else
function|I_args
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|a
parameter_list|)
endif|#
directive|endif
block|{
name|char
modifier|*
modifier|*
name|a0
decl_stmt|,
modifier|*
modifier|*
name|a1
decl_stmt|,
modifier|*
modifier|*
name|ae
decl_stmt|,
modifier|*
name|s
decl_stmt|;
name|ae
operator|=
name|a
operator|+
name|argc
expr_stmt|;
name|a0
operator|=
name|a
expr_stmt|;
for|for
control|(
name|a1
operator|=
operator|++
name|a
init|;
name|a
operator|<
name|ae
condition|;
name|a
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|s
operator|=
operator|*
name|a
operator|)
condition|)
break|break;
if|if
condition|(
operator|*
name|s
operator|==
literal|'-'
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|'I'
operator|&&
name|s
index|[
literal|2
index|]
operator|&&
operator|(
name|s
index|[
literal|3
index|]
operator|||
name|s
index|[
literal|2
index|]
operator|!=
literal|'2'
operator|&&
name|s
index|[
literal|2
index|]
operator|!=
literal|'4'
operator|)
condition|)
name|Iargs
operator|=
name|mkchain
argument_list|(
name|s
operator|+
literal|2
argument_list|,
name|Iargs
argument_list|)
expr_stmt|;
else|else
operator|*
name|a1
operator|++
operator|=
name|s
expr_stmt|;
block|}
name|Iargs
operator|=
name|revchain
argument_list|(
name|Iargs
argument_list|)
expr_stmt|;
operator|*
name|a1
operator|=
literal|0
expr_stmt|;
return|return
name|a1
operator|-
name|a0
return|;
block|}
end_function

begin_decl_stmt
name|int
name|retcode
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
ifdef|#
directive|ifdef
name|KR_headers
decl|main
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
name|int
name|argc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_function
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
endif|#
directive|endif
block|{
name|int
name|c2d
decl_stmt|,
name|k
decl_stmt|;
name|FILE
modifier|*
name|c_output
decl_stmt|;
name|char
modifier|*
name|cdfilename
decl_stmt|;
specifier|static
name|char
name|stderrbuf
index|[
name|BUFSIZ
index|]
decl_stmt|;
specifier|extern
name|char
modifier|*
modifier|*
name|dfltproc
decl_stmt|,
modifier|*
name|dflt1proc
index|[]
decl_stmt|;
specifier|extern
name|char
name|link_msg
index|[]
decl_stmt|;
name|diagfile
operator|=
name|stderr
expr_stmt|;
name|setbuf
argument_list|(
name|stderr
argument_list|,
name|stderrbuf
argument_list|)
expr_stmt|;
comment|/* arrange for fast error msgs */
name|argc
operator|=
name|I_args
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
comment|/* extract -I args */
name|Max_ftn_files
operator|=
name|argc
operator|-
literal|1
expr_stmt|;
name|ftn_files
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|ckalloc
argument_list|(
operator|(
name|argc
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|parse_args
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|table
argument_list|,
sizeof|sizeof
argument_list|(
name|table
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|arg_info
argument_list|)
argument_list|,
name|ftn_files
argument_list|,
name|Max_ftn_files
argument_list|)
expr_stmt|;
if|if
condition|(
name|badargs
condition|)
return|return
literal|1
return|;
name|intr_omit
operator|=
name|no_cd
operator||
name|no_i90
expr_stmt|;
if|if
condition|(
name|keepsubs
operator|&&
name|checksubs
condition|)
block|{
name|warn
argument_list|(
literal|"-C suppresses -s\n"
argument_list|)
expr_stmt|;
name|keepsubs
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|can_include
operator|&&
name|ext1comm
operator|==
literal|2
condition|)
name|ext1comm
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ext1comm
operator|&&
operator|!
name|extcomm
condition|)
name|extcomm
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|protostatus
condition|)
name|Castargs
operator|=
literal|3
expr_stmt|;
name|Castargs1
operator|=
name|Castargs
expr_stmt|;
if|if
condition|(
operator|!
name|Ansi
condition|)
block|{
name|Castargs
operator|=
literal|0
expr_stmt|;
name|parens
operator|=
literal|"()"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|Castargs
condition|)
name|parens
operator|=
name|Ansi
operator|==
literal|1
condition|?
literal|"()"
else|:
literal|"(...)"
expr_stmt|;
else|else
name|dfltproc
operator|=
name|dflt1proc
expr_stmt|;
name|outbuf_adjust
argument_list|()
expr_stmt|;
name|set_externs
argument_list|()
expr_stmt|;
name|fileinit
argument_list|()
expr_stmt|;
name|read_Pfiles
argument_list|(
name|ftn_files
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|1
init|;
name|ftn_files
index|[
name|k
index|]
condition|;
name|k
operator|++
control|)
if|if
condition|(
name|dofork
argument_list|()
condition|)
break|break;
name|filename0
operator|=
name|file_name
operator|=
name|ftn_files
index|[
name|current_ftn_file
operator|=
name|k
operator|-
literal|1
index|]
expr_stmt|;
name|set_tmp_names
argument_list|()
expr_stmt|;
name|sigcatch
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|c_file
operator|=
name|opf
argument_list|(
name|c_functions
argument_list|,
name|textwrite
argument_list|)
expr_stmt|;
name|pass1_file
operator|=
name|opf
argument_list|(
name|p1_file
argument_list|,
name|binwrite
argument_list|)
expr_stmt|;
name|initkey
argument_list|()
expr_stmt|;
if|if
condition|(
name|file_name
operator|&&
operator|*
name|file_name
condition|)
block|{
if|if
condition|(
name|debugflag
operator|!=
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|o_coutput
condition|)
name|coutput
operator|=
name|c_name
argument_list|(
name|file_name
argument_list|,
literal|'c'
argument_list|)
expr_stmt|;
else|else
name|coutput
operator|=
name|o_coutput
expr_stmt|;
if|if
condition|(
name|Castargs1
operator|>=
literal|2
condition|)
name|proto_fname
operator|=
name|c_name
argument_list|(
name|file_name
argument_list|,
literal|'P'
argument_list|)
expr_stmt|;
block|}
name|cdfilename
operator|=
name|coutput
expr_stmt|;
if|if
condition|(
name|skipC
condition|)
name|coutput
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|coutput
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
name|c_output
operator|=
name|stdout
expr_stmt|;
name|coutput
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|c_output
operator|=
name|fopen
argument_list|(
name|coutput
argument_list|,
name|textwrite
argument_list|)
operator|)
condition|)
block|{
name|file_name
operator|=
name|coutput
expr_stmt|;
name|coutput
operator|=
literal|0
expr_stmt|;
comment|/* don't delete read-only .c file */
name|fatalstr
argument_list|(
literal|"can't open %.86s"
argument_list|,
name|file_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Castargs1
operator|>=
literal|2
operator|&&
operator|!
operator|(
name|protofile
operator|=
name|fopen
argument_list|(
name|proto_fname
argument_list|,
name|textwrite
argument_list|)
operator|)
condition|)
name|fatalstr
argument_list|(
literal|"Can't open %.84s\n"
argument_list|,
name|proto_fname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|file_name
operator|=
literal|""
expr_stmt|;
name|cdfilename
operator|=
literal|"f2c_out.c"
expr_stmt|;
name|c_output
operator|=
name|stdout
expr_stmt|;
name|coutput
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|Castargs1
operator|>=
literal|2
condition|)
block|{
name|protofile
operator|=
name|stdout
expr_stmt|;
if|if
condition|(
operator|!
name|skipC
condition|)
name|printf
argument_list|(
literal|"#ifdef P_R_O_T_O_T_Y_P_E_S\n"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|inilex
argument_list|(
name|copys
argument_list|(
name|file_name
argument_list|)
argument_list|)
condition|)
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|filename0
condition|)
block|{
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"%s:\n"
argument_list|,
name|file_name
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|diagfile
argument_list|)
expr_stmt|;
block|}
name|procinit
argument_list|()
expr_stmt|;
if|if
condition|(
name|k
operator|=
name|yyparse
argument_list|()
condition|)
block|{
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"Bad parse, return code %d\n"
argument_list|,
name|k
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|commonprotos
argument_list|(
name|protofile
argument_list|)
expr_stmt|;
if|if
condition|(
name|protofile
operator|==
name|stdout
operator|&&
operator|!
name|skipC
condition|)
name|printf
argument_list|(
literal|"#endif\n\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|nerr
operator|||
name|skipC
condition|)
goto|goto
name|C_skipped
goto|;
comment|/* Write out the declarations which are global to this file */
if|if
condition|(
operator|(
name|c2d
operator|=
name|comm2dcl
argument_list|()
operator|)
operator|==
literal|1
condition|)
name|nice_printf
argument_list|(
name|c_output
argument_list|,
literal|"/*>>>'/dev/null'<<<*/\n\n\ /* Split this into several files by piping it through\n\n\ sed \"s/^\\/\\*>>>'\\(.*\\)'<<<\\*\\/\\$/cat>'\\1'<<'\\/*<<<\\1>>>*\\/'/\" | /bin/sh\n\  */\n\ /*<<</dev/null>>>*/\n\ /*>>>'%s'<<<*/\n"
argument_list|,
name|cdfilename
argument_list|)
expr_stmt|;
if|if
condition|(
name|gflag
condition|)
name|nice_printf
argument_list|(
name|c_output
argument_list|,
literal|"#line 1 \"%s\"\n"
argument_list|,
name|file_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|skipversion
condition|)
block|{
name|nice_printf
argument_list|(
name|c_output
argument_list|,
literal|"/* %s -- translated by f2c "
argument_list|,
name|file_name
argument_list|)
expr_stmt|;
name|nice_printf
argument_list|(
name|c_output
argument_list|,
literal|"(version %s).\n"
argument_list|,
name|F2C_version
argument_list|)
expr_stmt|;
name|nice_printf
argument_list|(
name|c_output
argument_list|,
literal|"   You must link the resulting object file with the libraries:\n\ 	%s   (in that order)\n*/\n\n"
argument_list|,
name|link_msg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Ansi
operator|==
literal|2
condition|)
name|nice_printf
argument_list|(
name|c_output
argument_list|,
literal|"#ifdef __cplusplus\nextern \"C\" {\n#endif\n"
argument_list|)
expr_stmt|;
name|nice_printf
argument_list|(
name|c_output
argument_list|,
literal|"%s#include \"f2c.h\"\n\n"
argument_list|,
name|def_i2
argument_list|)
expr_stmt|;
if|if
condition|(
name|gflag
condition|)
name|nice_printf
argument_list|(
name|c_output
argument_list|,
literal|"#line 1 \"%s\"\n"
argument_list|,
name|file_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|Castargs
operator|&&
name|typedefs
condition|)
name|write_typedefs
argument_list|(
name|c_output
argument_list|)
expr_stmt|;
name|nice_printf
argument_list|(
name|c_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|c_file
argument_list|)
expr_stmt|;
name|c_file
operator|=
name|c_output
expr_stmt|;
comment|/* HACK to get the next indenting 					   to work */
name|wr_common_decls
argument_list|(
name|c_output
argument_list|)
expr_stmt|;
if|if
condition|(
name|blkdfile
condition|)
name|list_init_data
argument_list|(
operator|&
name|blkdfile
argument_list|,
name|blkdfname
argument_list|,
name|c_output
argument_list|)
expr_stmt|;
name|wr_globals
argument_list|(
name|c_output
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c_file
operator|=
name|fopen
argument_list|(
name|c_functions
argument_list|,
name|textread
argument_list|)
operator|)
operator|==
operator|(
name|FILE
operator|*
operator|)
name|NULL
condition|)
name|Fatal
argument_list|(
literal|"main - couldn't reopen c_functions"
argument_list|)
expr_stmt|;
name|ffilecopy
argument_list|(
name|c_file
argument_list|,
name|c_output
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|main_alias
condition|)
block|{
name|nice_printf
argument_list|(
name|c_output
argument_list|,
literal|"/* Main program alias */ "
argument_list|)
expr_stmt|;
name|nice_printf
argument_list|(
name|c_output
argument_list|,
literal|"int %s () { MAIN__ ();%s }\n"
argument_list|,
name|main_alias
argument_list|,
name|Ansi
condition|?
literal|" return 0;"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Ansi
operator|==
literal|2
condition|)
name|nice_printf
argument_list|(
name|c_output
argument_list|,
literal|"#ifdef __cplusplus\n\t}\n#endif\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|c2d
condition|)
block|{
if|if
condition|(
name|c2d
operator|==
literal|1
condition|)
name|fprintf
argument_list|(
name|c_output
argument_list|,
literal|"/*<<<%s>>>*/\n"
argument_list|,
name|cdfilename
argument_list|)
expr_stmt|;
else|else
name|fclose
argument_list|(
name|c_output
argument_list|)
expr_stmt|;
name|def_commons
argument_list|(
name|c_output
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c2d
operator|!=
literal|2
condition|)
name|fclose
argument_list|(
name|c_output
argument_list|)
expr_stmt|;
name|C_skipped
label|:
if|if
condition|(
name|parstate
operator|!=
name|OUTSIDE
condition|)
block|{
name|warn
argument_list|(
literal|"missing final end statement"
argument_list|)
expr_stmt|;
name|endproc
argument_list|()
expr_stmt|;
name|nerr
operator|=
literal|1
expr_stmt|;
block|}
name|done
argument_list|(
name|nerr
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
comment|/* NOT REACHED */
return|return
literal|0
return|;
block|}
end_function

begin_function
name|FILEP
ifdef|#
directive|ifdef
name|KR_headers
name|opf
parameter_list|(
name|fn
parameter_list|,
name|mode
parameter_list|)
name|char
modifier|*
name|fn
decl_stmt|;
name|char
modifier|*
name|mode
decl_stmt|;
else|#
directive|else
function|opf
parameter_list|(
name|char
modifier|*
name|fn
parameter_list|,
name|char
modifier|*
name|mode
parameter_list|)
endif|#
directive|endif
block|{
name|FILEP
name|fp
decl_stmt|;
if|if
condition|(
name|fp
operator|=
name|fopen
argument_list|(
name|fn
argument_list|,
name|mode
argument_list|)
condition|)
return|return
operator|(
name|fp
operator|)
return|;
name|fatalstr
argument_list|(
literal|"cannot open intermediate file %s"
argument_list|,
name|fn
argument_list|)
expr_stmt|;
comment|/* NOT REACHED */
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|clf
parameter_list|(
name|p
parameter_list|,
name|what
parameter_list|,
name|quit
parameter_list|)
name|FILEP
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|what
decl_stmt|;
name|int
name|quit
decl_stmt|;
else|#
directive|else
function|clf
parameter_list|(
name|FILEP
modifier|*
name|p
parameter_list|,
name|char
modifier|*
name|what
parameter_list|,
name|int
name|quit
parameter_list|)
endif|#
directive|endif
block|{
if|if
condition|(
name|p
operator|!=
name|NULL
operator|&&
operator|*
name|p
operator|!=
name|NULL
operator|&&
operator|*
name|p
operator|!=
name|stdout
condition|)
block|{
if|if
condition|(
name|ferror
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"I/O error on %s\n"
argument_list|,
name|what
argument_list|)
expr_stmt|;
if|if
condition|(
name|quit
condition|)
name|done
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|retcode
operator|=
literal|3
expr_stmt|;
block|}
name|fclose
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
block|}
operator|*
name|p
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|done
parameter_list|(
name|k
parameter_list|)
name|int
name|k
decl_stmt|;
else|#
directive|else
function|done
parameter_list|(
name|int
name|k
parameter_list|)
endif|#
directive|endif
block|{
name|clf
argument_list|(
operator|&
name|initfile
argument_list|,
literal|"initfile"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|clf
argument_list|(
operator|&
name|c_file
argument_list|,
literal|"c_file"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|clf
argument_list|(
operator|&
name|pass1_file
argument_list|,
literal|"pass1_file"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|Un_link_all
argument_list|(
name|k
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|k
operator||
name|retcode
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

