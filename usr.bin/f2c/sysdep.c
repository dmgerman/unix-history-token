begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**************************************************************** Copyright 1990 - 1994 by AT&T Bell Laboratories and Bellcore.  Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that the copyright notice and this permission notice and warranty disclaimer appear in supporting documentation, and that the names of AT&T Bell Laboratories or Bellcore or any of their entities not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  AT&T and Bellcore disclaim all warranties with regard to this software, including all implied warranties of merchantability and fitness.  In no event shall AT&T or Bellcore be liable for any special, indirect or consequential damages or any damages whatsoever resulting from loss of use, data or profits, whether in an action of contract, negligence or other tortious action, arising out of or in connection with the use or performance of this software. ****************************************************************/
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"usignal.h"
end_include

begin_decl_stmt
name|char
name|binread
index|[]
init|=
literal|"rb"
decl_stmt|,
name|textread
index|[]
init|=
literal|"r"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|binwrite
index|[]
init|=
literal|"wb"
decl_stmt|,
name|textwrite
index|[]
init|=
literal|"w"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|c_functions
init|=
literal|"c_functions"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|coutput
init|=
literal|"c_output"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|initfname
init|=
literal|"raw_data"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|initbname
init|=
literal|"raw_data.b"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|blkdfname
init|=
literal|"block_data"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|p1_file
init|=
literal|"p1_file"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|p1_bakfile
init|=
literal|"p1_file.BAK"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|sortfname
init|=
literal|"init_file"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|proto_fname
init|=
literal|"proto_file"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|link_msg
index|[]
init|=
literal|"-lf2c -lm"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* was "-lF77 -lI77 -lm -lc"; */
end_comment

begin_decl_stmt
name|char
modifier|*
name|outbuf
init|=
literal|""
decl_stmt|,
modifier|*
name|outbtail
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|TMPDIR
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|MSDOS
end_ifdef

begin_define
define|#
directive|define
name|TMPDIR
value|""
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|TMPDIR
value|"/tmp"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|char
modifier|*
name|tmpdir
init|=
name|TMPDIR
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|MSDOS
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|KR_headers
end_ifndef

begin_function_decl
specifier|extern
name|int
name|getpid
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|Un_link_all
parameter_list|(
name|cdelete
parameter_list|)
name|int
name|cdelete
decl_stmt|;
else|#
directive|else
function|Un_link_all
parameter_list|(
name|int
name|cdelete
parameter_list|)
endif|#
directive|endif
block|{
ifndef|#
directive|ifndef
name|KR_headers
specifier|extern
name|int
name|unlink
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|debugflag
condition|)
block|{
name|unlink
argument_list|(
name|c_functions
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|initfname
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|p1_file
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|sortfname
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|blkdfname
argument_list|)
expr_stmt|;
if|if
condition|(
name|cdelete
operator|&&
name|coutput
condition|)
name|unlink
argument_list|(
name|coutput
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|set_tmp_names
parameter_list|(
name|Void
parameter_list|)
block|{
name|int
name|k
decl_stmt|;
if|if
condition|(
name|debugflag
operator|==
literal|1
condition|)
return|return;
name|k
operator|=
name|strlen
argument_list|(
name|tmpdir
argument_list|)
operator|+
literal|16
expr_stmt|;
name|c_functions
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
literal|7
operator|*
name|k
argument_list|)
expr_stmt|;
name|initfname
operator|=
name|c_functions
operator|+
name|k
expr_stmt|;
name|initbname
operator|=
name|initfname
operator|+
name|k
expr_stmt|;
name|blkdfname
operator|=
name|initbname
operator|+
name|k
expr_stmt|;
name|p1_file
operator|=
name|blkdfname
operator|+
name|k
expr_stmt|;
name|p1_bakfile
operator|=
name|p1_file
operator|+
name|k
expr_stmt|;
name|sortfname
operator|=
name|p1_bakfile
operator|+
name|k
expr_stmt|;
block|{
ifdef|#
directive|ifdef
name|MSDOS
name|char
name|buf
index|[
literal|64
index|]
decl_stmt|,
modifier|*
name|s
decl_stmt|,
modifier|*
name|t
decl_stmt|;
if|if
condition|(
operator|!
operator|*
name|tmpdir
operator|||
operator|*
name|tmpdir
operator|==
literal|'.'
operator|&&
operator|!
name|tmpdir
index|[
literal|1
index|]
condition|)
name|t
operator|=
literal|""
expr_stmt|;
else|else
block|{
comment|/* substitute \ for / to avoid confusion with a 		 * switch indicator in the system("sort ...") 		 * call in formatdata.c 		 */
for|for
control|(
name|s
operator|=
name|tmpdir
operator|,
name|t
operator|=
name|buf
init|;
operator|*
name|s
condition|;
name|s
operator|++
operator|,
name|t
operator|++
control|)
if|if
condition|(
operator|(
operator|*
name|t
operator|=
operator|*
name|s
operator|)
operator|==
literal|'/'
condition|)
operator|*
name|t
operator|=
literal|'\\'
expr_stmt|;
if|if
condition|(
name|t
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\\'
condition|)
operator|*
name|t
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|t
operator|=
literal|0
expr_stmt|;
name|t
operator|=
name|buf
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|c_functions
argument_list|,
literal|"%sf2c_func"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|initfname
argument_list|,
literal|"%sf2c_rd"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|blkdfname
argument_list|,
literal|"%sf2c_blkd"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|p1_file
argument_list|,
literal|"%sf2c_p1f"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|p1_bakfile
argument_list|,
literal|"%sf2c_p1fb"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|sortfname
argument_list|,
literal|"%sf2c_sort"
argument_list|,
name|t
argument_list|)
expr_stmt|;
else|#
directive|else
name|int
name|pid
init|=
name|getpid
argument_list|()
decl_stmt|;
name|sprintf
argument_list|(
name|c_functions
argument_list|,
literal|"%s/f2c%d_func"
argument_list|,
name|tmpdir
argument_list|,
name|pid
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|initfname
argument_list|,
literal|"%s/f2c%d_rd"
argument_list|,
name|tmpdir
argument_list|,
name|pid
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|blkdfname
argument_list|,
literal|"%s/f2c%d_blkd"
argument_list|,
name|tmpdir
argument_list|,
name|pid
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|p1_file
argument_list|,
literal|"%s/f2c%d_p1f"
argument_list|,
name|tmpdir
argument_list|,
name|pid
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|p1_bakfile
argument_list|,
literal|"%s/f2c%d_p1fb"
argument_list|,
name|tmpdir
argument_list|,
name|pid
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|sortfname
argument_list|,
literal|"%s/f2c%d_sort"
argument_list|,
name|tmpdir
argument_list|,
name|pid
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sprintf
argument_list|(
name|initbname
argument_list|,
literal|"%s.b"
argument_list|,
name|initfname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|debugflag
condition|)
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"%s %s %s %s %s %s\n"
argument_list|,
name|c_functions
argument_list|,
name|initfname
argument_list|,
name|blkdfname
argument_list|,
name|p1_file
argument_list|,
name|p1_bakfile
argument_list|,
name|sortfname
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|char
modifier|*
ifdef|#
directive|ifdef
name|KR_headers
name|c_name
parameter_list|(
name|s
parameter_list|,
name|ft
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|ft
decl_stmt|;
else|#
directive|else
function|c_name
parameter_list|(
name|char
modifier|*
name|s
parameter_list|,
name|int
name|ft
parameter_list|)
endif|#
directive|endif
block|{
name|char
modifier|*
name|b
decl_stmt|,
modifier|*
name|s0
decl_stmt|;
name|int
name|c
decl_stmt|;
name|b
operator|=
name|s0
operator|=
name|s
expr_stmt|;
while|while
condition|(
name|c
operator|=
operator|*
name|s
operator|++
condition|)
if|if
condition|(
name|c
operator|==
literal|'/'
condition|)
name|b
operator|=
name|s
expr_stmt|;
if|if
condition|(
operator|--
name|s
operator|<
name|s0
operator|+
literal|3
operator|||
name|s
index|[
operator|-
literal|2
index|]
operator|!=
literal|'.'
operator|||
operator|(
operator|(
name|c
operator|=
operator|*
operator|--
name|s
operator|)
operator|!=
literal|'f'
operator|&&
name|c
operator|!=
literal|'F'
operator|)
condition|)
block|{
name|infname
operator|=
name|s0
expr_stmt|;
name|Fatal
argument_list|(
literal|"file name must end in .f or .F"
argument_list|)
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|outbtail
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|outbtail
index|[
name|s
operator|-
name|b
index|]
operator|=
name|ft
expr_stmt|;
name|b
operator|=
name|copys
argument_list|(
name|outbuf
argument_list|)
expr_stmt|;
return|return
name|b
return|;
block|}
end_function

begin_function
specifier|static
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|killed
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
else|#
directive|else
function|killed
parameter_list|(
name|int
name|sig
parameter_list|)
endif|#
directive|endif
block|{
name|sig
operator|=
name|sig
expr_stmt|;
comment|/* shut up warning */
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGQUIT
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGHUP
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|Un_link_all
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|126
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|sig1catch
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
else|#
directive|else
function|sig1catch
parameter_list|(
name|int
name|sig
parameter_list|)
endif|#
directive|endif
block|{
name|sig
operator|=
name|sig
expr_stmt|;
comment|/* shut up warning */
if|if
condition|(
name|signal
argument_list|(
name|sig
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|sig
argument_list|,
name|killed
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|flovflo
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
else|#
directive|else
function|flovflo
parameter_list|(
name|int
name|sig
parameter_list|)
endif|#
directive|endif
block|{
name|sig
operator|=
name|sig
expr_stmt|;
comment|/* shut up warning */
name|Fatal
argument_list|(
literal|"floating exception during constant evaluation; cannot recover"
argument_list|)
expr_stmt|;
comment|/* vax returns a reserved operand that generates 	   an illegal operand fault on next instruction, 	   which if ignored causes an infinite loop. 	*/
name|signal
argument_list|(
name|SIGFPE
argument_list|,
name|flovflo
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|sigcatch
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
else|#
directive|else
function|sigcatch
parameter_list|(
name|int
name|sig
parameter_list|)
endif|#
directive|endif
block|{
name|sig
operator|=
name|sig
expr_stmt|;
comment|/* shut up warning */
name|sig1catch
argument_list|(
name|SIGINT
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGQUIT
name|sig1catch
argument_list|(
name|SIGQUIT
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGHUP
name|sig1catch
argument_list|(
name|SIGHUP
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sig1catch
argument_list|(
name|SIGTERM
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGFPE
argument_list|,
name|flovflo
argument_list|)
expr_stmt|;
comment|/* catch overflows */
block|}
end_function

begin_macro
name|dofork
argument_list|(
argument|Void
argument_list|)
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|MSDOS
name|Fatal
argument_list|(
literal|"Only one Fortran input file allowed under MS-DOS"
argument_list|)
expr_stmt|;
else|#
directive|else
ifndef|#
directive|ifndef
name|KR_headers
specifier|extern
name|int
name|fork
argument_list|(
name|void
argument_list|)
decl_stmt|,
name|wait
argument_list|(
name|int
operator|*
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|int
name|pid
decl_stmt|,
name|status
decl_stmt|,
name|w
decl_stmt|;
specifier|extern
name|int
name|retcode
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|pid
operator|=
name|fork
argument_list|()
operator|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|pid
operator|==
operator|-
literal|1
condition|)
name|Fatal
argument_list|(
literal|"bad fork"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|w
operator|=
name|wait
argument_list|(
operator|&
name|status
argument_list|)
operator|)
operator|!=
name|pid
condition|)
if|if
condition|(
name|w
operator|==
operator|-
literal|1
condition|)
name|Fatal
argument_list|(
literal|"bad wait code"
argument_list|)
expr_stmt|;
name|retcode
operator||=
name|status
operator|>>
literal|8
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Initialization of tables that change with the character set... */
end_comment

begin_decl_stmt
name|char
name|escapes
index|[
name|Table_size
index|]
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|non_ASCII
end_ifdef

begin_decl_stmt
name|char
modifier|*
name|str_fmt
index|[
name|Table_size
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|str0fmt
index|[
literal|127
index|]
init|=
block|{
comment|/*}*/
else|#
directive|else
name|char
operator|*
name|str_fmt
index|[
name|Table_size
index|]
operator|=
block|{
endif|#
directive|endif
literal|"\\000"
block|,
literal|"\\001"
block|,
literal|"\\002"
block|,
literal|"\\003"
block|,
literal|"\\004"
block|,
literal|"\\005"
block|,
literal|"\\006"
block|,
literal|"\\007"
block|,
literal|"\\b"
block|,
literal|"\\t"
block|,
literal|"\\n"
block|,
literal|"\\013"
block|,
literal|"\\f"
block|,
literal|"\\r"
block|,
literal|"\\016"
block|,
literal|"\\017"
block|,
literal|"\\020"
block|,
literal|"\\021"
block|,
literal|"\\022"
block|,
literal|"\\023"
block|,
literal|"\\024"
block|,
literal|"\\025"
block|,
literal|"\\026"
block|,
literal|"\\027"
block|,
literal|"\\030"
block|,
literal|"\\031"
block|,
literal|"\\032"
block|,
literal|"\\033"
block|,
literal|"\\034"
block|,
literal|"\\035"
block|,
literal|"\\036"
block|,
literal|"\\037"
block|,
literal|" "
block|,
literal|"!"
block|,
literal|"\\\""
block|,
literal|"#"
block|,
literal|"$"
block|,
literal|"%%"
block|,
literal|"&"
block|,
literal|"'"
block|,
literal|"("
block|,
literal|")"
block|,
literal|"*"
block|,
literal|"+"
block|,
literal|","
block|,
literal|"-"
block|,
literal|"."
block|,
literal|"/"
block|,
literal|"0"
block|,
literal|"1"
block|,
literal|"2"
block|,
literal|"3"
block|,
literal|"4"
block|,
literal|"5"
block|,
literal|"6"
block|,
literal|"7"
block|,
literal|"8"
block|,
literal|"9"
block|,
literal|":"
block|,
literal|";"
block|,
literal|"<"
block|,
literal|"="
block|,
literal|">"
block|,
literal|"?"
block|,
literal|"@"
block|,
literal|"A"
block|,
literal|"B"
block|,
literal|"C"
block|,
literal|"D"
block|,
literal|"E"
block|,
literal|"F"
block|,
literal|"G"
block|,
literal|"H"
block|,
literal|"I"
block|,
literal|"J"
block|,
literal|"K"
block|,
literal|"L"
block|,
literal|"M"
block|,
literal|"N"
block|,
literal|"O"
block|,
literal|"P"
block|,
literal|"Q"
block|,
literal|"R"
block|,
literal|"S"
block|,
literal|"T"
block|,
literal|"U"
block|,
literal|"V"
block|,
literal|"W"
block|,
literal|"X"
block|,
literal|"Y"
block|,
literal|"Z"
block|,
literal|"["
block|,
literal|"\\\\"
block|,
literal|"]"
block|,
literal|"^"
block|,
literal|"_"
block|,
literal|"`"
block|,
literal|"a"
block|,
literal|"b"
block|,
literal|"c"
block|,
literal|"d"
block|,
literal|"e"
block|,
literal|"f"
block|,
literal|"g"
block|,
literal|"h"
block|,
literal|"i"
block|,
literal|"j"
block|,
literal|"k"
block|,
literal|"l"
block|,
literal|"m"
block|,
literal|"n"
block|,
literal|"o"
block|,
literal|"p"
block|,
literal|"q"
block|,
literal|"r"
block|,
literal|"s"
block|,
literal|"t"
block|,
literal|"u"
block|,
literal|"v"
block|,
literal|"w"
block|,
literal|"x"
block|,
literal|"y"
block|,
literal|"z"
block|,
literal|"{"
block|,
literal|"|"
block|,
literal|"}"
block|,
literal|"~"
block|}
block|;
ifdef|#
directive|ifdef
name|non_ASCII
name|char
operator|*
name|chr_fmt
index|[
name|Table_size
index|]
block|;
specifier|static
name|char
operator|*
name|chr0fmt
index|[
literal|127
index|]
operator|=
block|{
comment|/*}*/
else|#
directive|else
name|char
operator|*
name|chr_fmt
index|[
name|Table_size
index|]
operator|=
block|{
endif|#
directive|endif
literal|"\\0"
block|,
literal|"\\1"
block|,
literal|"\\2"
block|,
literal|"\\3"
block|,
literal|"\\4"
block|,
literal|"\\5"
block|,
literal|"\\6"
block|,
literal|"\\7"
block|,
literal|"\\b"
block|,
literal|"\\t"
block|,
literal|"\\n"
block|,
literal|"\\13"
block|,
literal|"\\f"
block|,
literal|"\\r"
block|,
literal|"\\16"
block|,
literal|"\\17"
block|,
literal|"\\20"
block|,
literal|"\\21"
block|,
literal|"\\22"
block|,
literal|"\\23"
block|,
literal|"\\24"
block|,
literal|"\\25"
block|,
literal|"\\26"
block|,
literal|"\\27"
block|,
literal|"\\30"
block|,
literal|"\\31"
block|,
literal|"\\32"
block|,
literal|"\\33"
block|,
literal|"\\34"
block|,
literal|"\\35"
block|,
literal|"\\36"
block|,
literal|"\\37"
block|,
literal|" "
block|,
literal|"!"
block|,
literal|"\""
block|,
literal|"#"
block|,
literal|"$"
block|,
literal|"%%"
block|,
literal|"&"
block|,
literal|"\\'"
block|,
literal|"("
block|,
literal|")"
block|,
literal|"*"
block|,
literal|"+"
block|,
literal|","
block|,
literal|"-"
block|,
literal|"."
block|,
literal|"/"
block|,
literal|"0"
block|,
literal|"1"
block|,
literal|"2"
block|,
literal|"3"
block|,
literal|"4"
block|,
literal|"5"
block|,
literal|"6"
block|,
literal|"7"
block|,
literal|"8"
block|,
literal|"9"
block|,
literal|":"
block|,
literal|";"
block|,
literal|"<"
block|,
literal|"="
block|,
literal|">"
block|,
literal|"?"
block|,
literal|"@"
block|,
literal|"A"
block|,
literal|"B"
block|,
literal|"C"
block|,
literal|"D"
block|,
literal|"E"
block|,
literal|"F"
block|,
literal|"G"
block|,
literal|"H"
block|,
literal|"I"
block|,
literal|"J"
block|,
literal|"K"
block|,
literal|"L"
block|,
literal|"M"
block|,
literal|"N"
block|,
literal|"O"
block|,
literal|"P"
block|,
literal|"Q"
block|,
literal|"R"
block|,
literal|"S"
block|,
literal|"T"
block|,
literal|"U"
block|,
literal|"V"
block|,
literal|"W"
block|,
literal|"X"
block|,
literal|"Y"
block|,
literal|"Z"
block|,
literal|"["
block|,
literal|"\\\\"
block|,
literal|"]"
block|,
literal|"^"
block|,
literal|"_"
block|,
literal|"`"
block|,
literal|"a"
block|,
literal|"b"
block|,
literal|"c"
block|,
literal|"d"
block|,
literal|"e"
block|,
literal|"f"
block|,
literal|"g"
block|,
literal|"h"
block|,
literal|"i"
block|,
literal|"j"
block|,
literal|"k"
block|,
literal|"l"
block|,
literal|"m"
block|,
literal|"n"
block|,
literal|"o"
block|,
literal|"p"
block|,
literal|"q"
block|,
literal|"r"
block|,
literal|"s"
block|,
literal|"t"
block|,
literal|"u"
block|,
literal|"v"
block|,
literal|"w"
block|,
literal|"x"
block|,
literal|"y"
block|,
literal|"z"
block|,
literal|"{"
block|,
literal|"|"
block|,
literal|"}"
block|,
literal|"~"
block|}
block|;
name|void
name|fmt_init
argument_list|(
argument|Void
argument_list|)
block|{
specifier|static
name|char
operator|*
name|str1fmt
index|[
literal|6
index|]
operator|=
block|{
literal|"\\b"
block|,
literal|"\\t"
block|,
literal|"\\n"
block|,
literal|"\\f"
block|,
literal|"\\r"
block|,
literal|"\\%03o"
block|}
block|;
specifier|register
name|int
name|i
block|,
name|j
block|;
specifier|register
name|char
operator|*
name|s
block|;
comment|/* str_fmt */
ifdef|#
directive|ifdef
name|non_ASCII
name|i
operator|=
literal|0
block|;
else|#
directive|else
name|i
operator|=
literal|127
block|;
endif|#
directive|endif
for|for
control|(
init|;
name|i
operator|<
name|Table_size
condition|;
name|i
operator|++
control|)
name|str_fmt
index|[
name|i
index|]
operator|=
literal|"\\%03o"
expr_stmt|;
ifdef|#
directive|ifdef
name|non_ASCII
for|for
control|(
name|i
operator|=
literal|32
init|;
name|i
operator|<
literal|127
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|=
name|str0fmt
index|[
name|i
index|]
expr_stmt|;
name|str_fmt
index|[
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s
index|]
operator|=
name|s
expr_stmt|;
block|}
name|str_fmt
index|[
literal|'"'
index|]
operator|=
literal|"\\\""
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|Ansi
operator|==
literal|1
condition|)
name|str_fmt
index|[
literal|7
index|]
operator|=
name|chr_fmt
index|[
literal|7
index|]
operator|=
literal|"\\a"
expr_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* chr_fmt */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|non_ASCII
end_ifdef

begin_for
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
name|chr_fmt
index|[
name|i
index|]
operator|=
name|chr0fmt
index|[
name|i
index|]
expr_stmt|;
end_for

begin_else
else|#
directive|else
end_else

begin_expr_stmt
name|i
operator|=
literal|127
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_for
for|for
control|(
init|;
name|i
operator|<
name|Table_size
condition|;
name|i
operator|++
control|)
name|chr_fmt
index|[
name|i
index|]
operator|=
literal|"\\%o"
expr_stmt|;
end_for

begin_ifdef
ifdef|#
directive|ifdef
name|non_ASCII
end_ifdef

begin_for
for|for
control|(
name|i
operator|=
literal|32
init|;
name|i
operator|<
literal|127
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|=
name|chr0fmt
index|[
name|i
index|]
expr_stmt|;
name|j
operator|=
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s
expr_stmt|;
if|if
condition|(
name|j
operator|==
literal|'\\'
condition|)
name|j
operator|=
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
name|s
operator|+
literal|1
operator|)
expr_stmt|;
name|chr_fmt
index|[
name|j
index|]
operator|=
name|s
expr_stmt|;
block|}
end_for

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* escapes (used in lex.c) */
end_comment

begin_for
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|Table_size
condition|;
name|i
operator|++
control|)
name|escapes
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
end_for

begin_for
for|for
control|(
name|s
operator|=
literal|"btnfr0"
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
name|escapes
index|[
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s
operator|++
index|]
operator|=
literal|"\b\t\n\f\r"
index|[
name|i
index|]
expr_stmt|;
end_for

begin_comment
comment|/* finish str_fmt and chr_fmt */
end_comment

begin_if
if|if
condition|(
name|Ansi
condition|)
name|str1fmt
index|[
literal|5
index|]
operator|=
literal|"\\v"
expr_stmt|;
end_if

begin_if
if|if
condition|(
literal|'\v'
operator|==
literal|'v'
condition|)
block|{
comment|/* ancient C compiler */
name|str1fmt
index|[
literal|5
index|]
operator|=
literal|"v"
expr_stmt|;
ifndef|#
directive|ifndef
name|non_ASCII
name|escapes
index|[
literal|'v'
index|]
operator|=
literal|11
expr_stmt|;
endif|#
directive|endif
block|}
else|else
name|escapes
index|[
literal|'v'
index|]
operator|=
literal|'\v'
expr_stmt|;
end_if

begin_for
for|for
control|(
name|s
operator|=
literal|"\b\t\n\f\r\v"
operator|,
name|i
operator|=
literal|0
init|;
name|j
operator|=
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s
operator|++
condition|;
control|)
name|str_fmt
index|[
name|j
index|]
operator|=
name|chr_fmt
index|[
name|j
index|]
operator|=
name|str1fmt
index|[
name|i
operator|++
index|]
expr_stmt|;
end_for

begin_comment
comment|/* '\v' = 11 for both EBCDIC and ASCII... */
end_comment

begin_expr_stmt
name|chr_fmt
index|[
literal|11
index|]
operator|=
name|Ansi
condition|?
literal|"\\v"
else|:
literal|"\\13"
expr_stmt|;
end_expr_stmt

begin_macro
unit|}   void
name|outbuf_adjust
argument_list|(
argument|Void
argument_list|)
end_macro

begin_block
block|{
name|int
name|n
decl_stmt|,
name|n1
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|n
operator|=
name|n1
operator|=
name|strlen
argument_list|(
name|outbuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|outbuf
operator|&&
name|outbuf
index|[
name|n
operator|-
literal|1
index|]
operator|!=
literal|'/'
condition|)
name|n1
operator|++
expr_stmt|;
name|s
operator|=
name|Alloc
argument_list|(
name|n
operator|+
literal|64
argument_list|)
expr_stmt|;
name|outbtail
operator|=
name|s
operator|+
name|n1
expr_stmt|;
name|strcpy
argument_list|(
name|s
argument_list|,
name|outbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
name|n1
condition|)
name|strcpy
argument_list|(
name|s
operator|+
name|n
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|outbuf
operator|=
name|s
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Unless SYSTEM_SORT is defined, the following gives a simple  * in-core version of dsort().  On Fortran source with huge DATA  * statements, the in-core version may exhaust the available memory,  * in which case you might either recompile this source file with  * SYSTEM_SORT defined (if that's reasonable on your system), or  * replace the dsort below with a more elaborate version that  * does a merging sort with the help of auxiliary files.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SYSTEM_SORT
end_ifdef

begin_function
name|int
ifdef|#
directive|ifdef
name|KR_headers
name|dsort
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|)
name|char
modifier|*
name|from
decl_stmt|;
name|char
modifier|*
name|to
decl_stmt|;
else|#
directive|else
function|dsort
parameter_list|(
name|char
modifier|*
name|from
parameter_list|,
name|char
modifier|*
name|to
parameter_list|)
endif|#
directive|endif
block|{
name|char
name|buf
index|[
literal|200
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"sort<%s>%s"
argument_list|,
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
return|return
name|system
argument_list|(
name|buf
argument_list|)
operator|>>
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
specifier|static
name|int
ifdef|#
directive|ifdef
name|KR_headers
name|compare
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
name|char
modifier|*
name|a
decl_stmt|,
decl|*
name|b
decl_stmt|;
end_function

begin_else
else|#
directive|else
end_else

begin_macro
name|compare
argument_list|(
argument|const void *a
argument_list|,
argument|const void *b
argument_list|)
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
return|return
name|strcmp
argument_list|(
operator|*
operator|(
name|char
operator|*
operator|*
operator|)
name|a
argument_list|,
operator|*
operator|(
name|char
operator|*
operator|*
operator|)
name|b
argument_list|)
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|KR_headers
end_ifdef

begin_macro
name|dsort
argument_list|(
argument|from
argument_list|,
argument|to
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|from
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|to
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_macro
name|dsort
argument_list|(
argument|char *from
argument_list|,
argument|char *to
argument_list|)
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
struct|struct
name|Memb
block|{
name|struct
name|Memb
modifier|*
name|next
decl_stmt|;
name|int
name|n
decl_stmt|;
name|char
name|buf
index|[
literal|32000
index|]
decl_stmt|;
block|}
struct|;
typedef|typedef
name|struct
name|Memb
name|memb
typedef|;
name|memb
modifier|*
name|mb
decl_stmt|,
modifier|*
name|mb1
decl_stmt|;
specifier|register
name|char
modifier|*
name|x
decl_stmt|,
modifier|*
name|x0
decl_stmt|,
modifier|*
name|xe
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|,
name|n
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
name|char
modifier|*
modifier|*
name|z
decl_stmt|,
modifier|*
modifier|*
name|z0
decl_stmt|;
name|int
name|nn
init|=
literal|0
decl_stmt|;
name|f
operator|=
name|opf
argument_list|(
name|from
argument_list|,
name|textread
argument_list|)
expr_stmt|;
name|mb
operator|=
operator|(
name|memb
operator|*
operator|)
name|Alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|memb
argument_list|)
argument_list|)
expr_stmt|;
name|mb
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|x0
operator|=
name|x
operator|=
name|mb
operator|->
name|buf
expr_stmt|;
name|xe
operator|=
name|x
operator|+
sizeof|sizeof
argument_list|(
name|mb
operator|->
name|buf
argument_list|)
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
name|getc
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|>=
name|xe
operator|&&
operator|(
name|c
operator|!=
name|EOF
operator|||
name|x
operator|!=
name|x0
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|n
condition|)
return|return
literal|126
return|;
name|nn
operator|+=
name|n
expr_stmt|;
name|mb
operator|->
name|n
operator|=
name|n
expr_stmt|;
name|mb1
operator|=
operator|(
name|memb
operator|*
operator|)
name|Alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|memb
argument_list|)
argument_list|)
expr_stmt|;
name|mb1
operator|->
name|next
operator|=
name|mb
expr_stmt|;
name|mb
operator|=
name|mb1
expr_stmt|;
name|memcpy
argument_list|(
name|mb
operator|->
name|buf
argument_list|,
name|x0
argument_list|,
name|n
operator|=
name|x
operator|-
name|x0
argument_list|)
expr_stmt|;
name|x0
operator|=
name|mb
operator|->
name|buf
expr_stmt|;
name|x
operator|=
name|x0
operator|+
name|n
expr_stmt|;
name|xe
operator|=
name|x0
operator|+
sizeof|sizeof
argument_list|(
name|mb
operator|->
name|buf
argument_list|)
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
break|break;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
operator|++
name|n
expr_stmt|;
operator|*
name|x
operator|++
operator|=
literal|0
expr_stmt|;
name|x0
operator|=
name|x
expr_stmt|;
block|}
else|else
operator|*
name|x
operator|++
operator|=
name|c
expr_stmt|;
block|}
name|clf
argument_list|(
operator|&
name|f
argument_list|,
name|from
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|f
operator|=
name|opf
argument_list|(
name|to
argument_list|,
name|textwrite
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|>
name|x0
condition|)
block|{
comment|/* shouldn't happen */
operator|*
name|x
operator|=
literal|0
expr_stmt|;
operator|++
name|n
expr_stmt|;
block|}
name|mb
operator|->
name|n
operator|=
name|n
expr_stmt|;
name|nn
operator|+=
name|n
expr_stmt|;
if|if
condition|(
operator|!
name|nn
condition|)
comment|/* shouldn't happen */
goto|goto
name|done
goto|;
name|z
operator|=
name|z0
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|Alloc
argument_list|(
name|nn
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|mb1
operator|=
name|mb
init|;
name|mb1
condition|;
name|mb1
operator|=
name|mb1
operator|->
name|next
control|)
block|{
name|x
operator|=
name|mb1
operator|->
name|buf
expr_stmt|;
name|n
operator|=
name|mb1
operator|->
name|n
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
operator|*
name|z
operator|++
operator|=
name|x
expr_stmt|;
if|if
condition|(
operator|--
name|n
operator|<=
literal|0
condition|)
break|break;
while|while
condition|(
operator|*
name|x
operator|++
condition|)
empty_stmt|;
block|}
block|}
name|qsort
argument_list|(
operator|(
name|char
operator|*
operator|)
name|z0
argument_list|,
name|nn
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|,
name|compare
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
name|nn
operator|,
name|z
operator|=
name|z0
init|;
name|n
operator|>
literal|0
condition|;
name|n
operator|--
control|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s\n"
argument_list|,
operator|*
name|z
operator|++
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|z0
argument_list|)
expr_stmt|;
name|done
label|:
name|clf
argument_list|(
operator|&
name|f
argument_list|,
name|to
argument_list|,
literal|1
argument_list|)
expr_stmt|;
do|do
block|{
name|mb1
operator|=
name|mb
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|mb
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|mb
operator|=
name|mb1
condition|)
do|;
return|return
literal|0
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

