begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**************************************************************** Copyright 1990, 1991, 1993, 1994, 1996 by AT&T, Lucent Technologies and Bellcore.  Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that the copyright notice and this permission notice and warranty disclaimer appear in supporting documentation, and that the names of AT&T, Bell Laboratories, Lucent or Bellcore or any of their entities not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  AT&T, Lucent and Bellcore disclaim all warranties with regard to this software, including all implied warranties of merchantability and fitness.  In no event shall AT&T, Lucent or Bellcore be liable for any special, indirect or consequential damages or any damages whatsoever resulting from loss of use, data or profits, whether in an action of contract, negligence or other tortious action, arising out of or in connection with the use or performance of this software. ****************************************************************/
end_comment

begin_comment
comment|/* Routines to generate code for I/O statements.    Some corrections and improvements due to David Wasley, U. C. Berkeley */
end_comment

begin_comment
comment|/* TEMPORARY */
end_comment

begin_define
define|#
directive|define
name|TYIOINT
value|TYLONG
end_define

begin_define
define|#
directive|define
name|SZIOINT
value|SZLONG
end_define

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"names.h"
end_include

begin_include
include|#
directive|include
file|"iob.h"
end_include

begin_decl_stmt
specifier|extern
name|int
name|byterev
decl_stmt|,
name|inqmask
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dofclose
name|Argdcl
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dofinquire
name|Argdcl
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dofmove
name|Argdcl
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dofopen
name|Argdcl
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|doiolist
name|Argdcl
argument_list|(
operator|(
name|chainp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ioset
name|Argdcl
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
name|expptr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ioseta
name|Argdcl
argument_list|(
operator|(
name|int
operator|,
name|Addrp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|iosetc
name|Argdcl
argument_list|(
operator|(
name|int
operator|,
name|expptr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|iosetip
name|Argdcl
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|iosetlc
name|Argdcl
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|putio
name|Argdcl
argument_list|(
operator|(
name|expptr
operator|,
name|expptr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|putiocall
name|Argdcl
argument_list|(
operator|(
name|expptr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|iob_data
modifier|*
name|iob_list
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Addrp
name|io_structs
index|[
literal|9
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LOCAL
name|char
name|ioroutine
index|[
literal|12
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LOCAL
name|long
name|ioendlab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LOCAL
name|long
name|ioerrlab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LOCAL
name|int
name|endbit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LOCAL
name|int
name|errbit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LOCAL
name|long
name|jumplab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LOCAL
name|long
name|skiplab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LOCAL
name|int
name|ioformatted
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LOCAL
name|int
name|statstruct
init|=
name|NO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LOCAL
name|struct
name|Labelblock
modifier|*
name|skiplabel
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Addrp
name|ioblkp
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|UNFORMATTED
value|0
end_define

begin_define
define|#
directive|define
name|FORMATTED
value|1
end_define

begin_define
define|#
directive|define
name|LISTDIRECTED
value|2
end_define

begin_define
define|#
directive|define
name|NAMEDIRECTED
value|3
end_define

begin_define
define|#
directive|define
name|V
parameter_list|(
name|z
parameter_list|)
value|ioc[z].iocval
end_define

begin_define
define|#
directive|define
name|IOALL
value|07777
end_define

begin_macro
name|LOCAL
end_macro

begin_struct
struct|struct
name|Ioclist
block|{
name|char
modifier|*
name|iocname
decl_stmt|;
name|int
name|iotype
decl_stmt|;
name|expptr
name|iocval
decl_stmt|;
block|}
name|ioc
index|[ ]
init|=
block|{
block|{
literal|""
block|,
literal|0
block|}
block|,
block|{
literal|"unit"
block|,
name|IOALL
block|}
block|,
block|{
literal|"fmt"
block|,
name|M
argument_list|(
name|IOREAD
argument_list|)
operator||
name|M
argument_list|(
argument|IOWRITE
argument_list|)
block|}
block|,
block|{
literal|"err"
block|,
name|IOALL
block|}
block|,
block|{
literal|"end"
block|,
name|M
argument_list|(
argument|IOREAD
argument_list|)
block|}
block|,
block|{
literal|"iostat"
block|,
name|IOALL
block|}
block|,
block|{
literal|"rec"
block|,
name|M
argument_list|(
name|IOREAD
argument_list|)
operator||
name|M
argument_list|(
argument|IOWRITE
argument_list|)
block|}
block|,
block|{
literal|"recl"
block|,
name|M
argument_list|(
name|IOOPEN
argument_list|)
operator||
name|M
argument_list|(
argument|IOINQUIRE
argument_list|)
block|}
block|,
block|{
literal|"file"
block|,
name|M
argument_list|(
name|IOOPEN
argument_list|)
operator||
name|M
argument_list|(
argument|IOINQUIRE
argument_list|)
block|}
block|,
block|{
literal|"status"
block|,
name|M
argument_list|(
name|IOOPEN
argument_list|)
operator||
name|M
argument_list|(
argument|IOCLOSE
argument_list|)
block|}
block|,
block|{
literal|"access"
block|,
name|M
argument_list|(
name|IOOPEN
argument_list|)
operator||
name|M
argument_list|(
argument|IOINQUIRE
argument_list|)
block|}
block|,
block|{
literal|"form"
block|,
name|M
argument_list|(
name|IOOPEN
argument_list|)
operator||
name|M
argument_list|(
argument|IOINQUIRE
argument_list|)
block|}
block|,
block|{
literal|"blank"
block|,
name|M
argument_list|(
name|IOOPEN
argument_list|)
operator||
name|M
argument_list|(
argument|IOINQUIRE
argument_list|)
block|}
block|,
block|{
literal|"exist"
block|,
name|M
argument_list|(
argument|IOINQUIRE
argument_list|)
block|}
block|,
block|{
literal|"opened"
block|,
name|M
argument_list|(
argument|IOINQUIRE
argument_list|)
block|}
block|,
block|{
literal|"number"
block|,
name|M
argument_list|(
argument|IOINQUIRE
argument_list|)
block|}
block|,
block|{
literal|"named"
block|,
name|M
argument_list|(
argument|IOINQUIRE
argument_list|)
block|}
block|,
block|{
literal|"name"
block|,
name|M
argument_list|(
argument|IOINQUIRE
argument_list|)
block|}
block|,
block|{
literal|"sequential"
block|,
name|M
argument_list|(
argument|IOINQUIRE
argument_list|)
block|}
block|,
block|{
literal|"direct"
block|,
name|M
argument_list|(
argument|IOINQUIRE
argument_list|)
block|}
block|,
block|{
literal|"formatted"
block|,
name|M
argument_list|(
argument|IOINQUIRE
argument_list|)
block|}
block|,
block|{
literal|"unformatted"
block|,
name|M
argument_list|(
argument|IOINQUIRE
argument_list|)
block|}
block|,
block|{
literal|"nextrec"
block|,
name|M
argument_list|(
argument|IOINQUIRE
argument_list|)
block|}
block|,
block|{
literal|"nml"
block|,
name|M
argument_list|(
name|IOREAD
argument_list|)
operator||
name|M
argument_list|(
argument|IOWRITE
argument_list|)
block|}
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|NIOS
value|(sizeof(ioc)/sizeof(struct Ioclist) - 1)
end_define

begin_comment
comment|/* #define IOSUNIT 1 */
end_comment

begin_comment
comment|/* #define IOSFMT 2 */
end_comment

begin_define
define|#
directive|define
name|IOSERR
value|3
end_define

begin_define
define|#
directive|define
name|IOSEND
value|4
end_define

begin_define
define|#
directive|define
name|IOSIOSTAT
value|5
end_define

begin_define
define|#
directive|define
name|IOSREC
value|6
end_define

begin_define
define|#
directive|define
name|IOSRECL
value|7
end_define

begin_define
define|#
directive|define
name|IOSFILE
value|8
end_define

begin_define
define|#
directive|define
name|IOSSTATUS
value|9
end_define

begin_define
define|#
directive|define
name|IOSACCESS
value|10
end_define

begin_define
define|#
directive|define
name|IOSFORM
value|11
end_define

begin_define
define|#
directive|define
name|IOSBLANK
value|12
end_define

begin_define
define|#
directive|define
name|IOSEXISTS
value|13
end_define

begin_define
define|#
directive|define
name|IOSOPENED
value|14
end_define

begin_define
define|#
directive|define
name|IOSNUMBER
value|15
end_define

begin_define
define|#
directive|define
name|IOSNAMED
value|16
end_define

begin_define
define|#
directive|define
name|IOSNAME
value|17
end_define

begin_define
define|#
directive|define
name|IOSSEQUENTIAL
value|18
end_define

begin_define
define|#
directive|define
name|IOSDIRECT
value|19
end_define

begin_define
define|#
directive|define
name|IOSFORMATTED
value|20
end_define

begin_define
define|#
directive|define
name|IOSUNFORMATTED
value|21
end_define

begin_define
define|#
directive|define
name|IOSNEXTREC
value|22
end_define

begin_define
define|#
directive|define
name|IOSNML
value|23
end_define

begin_define
define|#
directive|define
name|IOSTP
value|V(IOSIOSTAT)
end_define

begin_comment
comment|/* offsets in generated structures */
end_comment

begin_define
define|#
directive|define
name|SZFLAG
value|SZIOINT
end_define

begin_comment
comment|/* offsets for external READ and WRITE statements */
end_comment

begin_define
define|#
directive|define
name|XERR
value|0
end_define

begin_define
define|#
directive|define
name|XUNIT
value|SZFLAG
end_define

begin_define
define|#
directive|define
name|XEND
value|SZFLAG + SZIOINT
end_define

begin_define
define|#
directive|define
name|XFMT
value|2*SZFLAG + SZIOINT
end_define

begin_define
define|#
directive|define
name|XREC
value|2*SZFLAG + SZIOINT + SZADDR
end_define

begin_comment
comment|/* offsets for internal READ and WRITE statements */
end_comment

begin_define
define|#
directive|define
name|XIUNIT
value|SZFLAG
end_define

begin_define
define|#
directive|define
name|XIEND
value|SZFLAG + SZADDR
end_define

begin_define
define|#
directive|define
name|XIFMT
value|2*SZFLAG + SZADDR
end_define

begin_define
define|#
directive|define
name|XIRLEN
value|2*SZFLAG + 2*SZADDR
end_define

begin_define
define|#
directive|define
name|XIRNUM
value|2*SZFLAG + 2*SZADDR + SZIOINT
end_define

begin_define
define|#
directive|define
name|XIREC
value|2*SZFLAG + 2*SZADDR + 2*SZIOINT
end_define

begin_comment
comment|/* offsets for OPEN statements */
end_comment

begin_define
define|#
directive|define
name|XFNAME
value|SZFLAG + SZIOINT
end_define

begin_define
define|#
directive|define
name|XFNAMELEN
value|SZFLAG + SZIOINT + SZADDR
end_define

begin_define
define|#
directive|define
name|XSTATUS
value|SZFLAG + 2*SZIOINT + SZADDR
end_define

begin_define
define|#
directive|define
name|XACCESS
value|SZFLAG + 2*SZIOINT + 2*SZADDR
end_define

begin_define
define|#
directive|define
name|XFORMATTED
value|SZFLAG + 2*SZIOINT + 3*SZADDR
end_define

begin_define
define|#
directive|define
name|XRECLEN
value|SZFLAG + 2*SZIOINT + 4*SZADDR
end_define

begin_define
define|#
directive|define
name|XBLANK
value|SZFLAG + 3*SZIOINT + 4*SZADDR
end_define

begin_comment
comment|/* offset for CLOSE statement */
end_comment

begin_define
define|#
directive|define
name|XCLSTATUS
value|SZFLAG + SZIOINT
end_define

begin_comment
comment|/* offsets for INQUIRE statement */
end_comment

begin_define
define|#
directive|define
name|XFILE
value|SZFLAG + SZIOINT
end_define

begin_define
define|#
directive|define
name|XFILELEN
value|SZFLAG + SZIOINT + SZADDR
end_define

begin_define
define|#
directive|define
name|XEXISTS
value|SZFLAG + 2*SZIOINT + SZADDR
end_define

begin_define
define|#
directive|define
name|XOPEN
value|SZFLAG + 2*SZIOINT + 2*SZADDR
end_define

begin_define
define|#
directive|define
name|XNUMBER
value|SZFLAG + 2*SZIOINT + 3*SZADDR
end_define

begin_define
define|#
directive|define
name|XNAMED
value|SZFLAG + 2*SZIOINT + 4*SZADDR
end_define

begin_define
define|#
directive|define
name|XNAME
value|SZFLAG + 2*SZIOINT + 5*SZADDR
end_define

begin_define
define|#
directive|define
name|XNAMELEN
value|SZFLAG + 2*SZIOINT + 6*SZADDR
end_define

begin_define
define|#
directive|define
name|XQACCESS
value|SZFLAG + 3*SZIOINT + 6*SZADDR
end_define

begin_define
define|#
directive|define
name|XQACCLEN
value|SZFLAG + 3*SZIOINT + 7*SZADDR
end_define

begin_define
define|#
directive|define
name|XSEQ
value|SZFLAG + 4*SZIOINT + 7*SZADDR
end_define

begin_define
define|#
directive|define
name|XSEQLEN
value|SZFLAG + 4*SZIOINT + 8*SZADDR
end_define

begin_define
define|#
directive|define
name|XDIRECT
value|SZFLAG + 5*SZIOINT + 8*SZADDR
end_define

begin_define
define|#
directive|define
name|XDIRLEN
value|SZFLAG + 5*SZIOINT + 9*SZADDR
end_define

begin_define
define|#
directive|define
name|XFORM
value|SZFLAG + 6*SZIOINT + 9*SZADDR
end_define

begin_define
define|#
directive|define
name|XFORMLEN
value|SZFLAG + 6*SZIOINT + 10*SZADDR
end_define

begin_define
define|#
directive|define
name|XFMTED
value|SZFLAG + 7*SZIOINT + 10*SZADDR
end_define

begin_define
define|#
directive|define
name|XFMTEDLEN
value|SZFLAG + 7*SZIOINT + 11*SZADDR
end_define

begin_define
define|#
directive|define
name|XUNFMT
value|SZFLAG + 8*SZIOINT + 11*SZADDR
end_define

begin_define
define|#
directive|define
name|XUNFMTLEN
value|SZFLAG + 8*SZIOINT + 12*SZADDR
end_define

begin_define
define|#
directive|define
name|XQRECL
value|SZFLAG + 9*SZIOINT + 12*SZADDR
end_define

begin_define
define|#
directive|define
name|XNEXTREC
value|SZFLAG + 9*SZIOINT + 13*SZADDR
end_define

begin_define
define|#
directive|define
name|XQBLANK
value|SZFLAG + 9*SZIOINT + 14*SZADDR
end_define

begin_define
define|#
directive|define
name|XQBLANKLEN
value|SZFLAG + 9*SZIOINT + 15*SZADDR
end_define

begin_decl_stmt
name|LOCAL
name|char
modifier|*
name|cilist_names
index|[]
init|=
block|{
literal|"cilist"
block|,
literal|"cierr"
block|,
literal|"ciunit"
block|,
literal|"ciend"
block|,
literal|"cifmt"
block|,
literal|"cirec"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LOCAL
name|char
modifier|*
name|icilist_names
index|[]
init|=
block|{
literal|"icilist"
block|,
literal|"icierr"
block|,
literal|"iciunit"
block|,
literal|"iciend"
block|,
literal|"icifmt"
block|,
literal|"icirlen"
block|,
literal|"icirnum"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LOCAL
name|char
modifier|*
name|olist_names
index|[]
init|=
block|{
literal|"olist"
block|,
literal|"oerr"
block|,
literal|"ounit"
block|,
literal|"ofnm"
block|,
literal|"ofnmlen"
block|,
literal|"osta"
block|,
literal|"oacc"
block|,
literal|"ofm"
block|,
literal|"orl"
block|,
literal|"oblnk"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LOCAL
name|char
modifier|*
name|cllist_names
index|[]
init|=
block|{
literal|"cllist"
block|,
literal|"cerr"
block|,
literal|"cunit"
block|,
literal|"csta"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LOCAL
name|char
modifier|*
name|alist_names
index|[]
init|=
block|{
literal|"alist"
block|,
literal|"aerr"
block|,
literal|"aunit"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LOCAL
name|char
modifier|*
name|inlist_names
index|[]
init|=
block|{
literal|"inlist"
block|,
literal|"inerr"
block|,
literal|"inunit"
block|,
literal|"infile"
block|,
literal|"infilen"
block|,
literal|"inex"
block|,
literal|"inopen"
block|,
literal|"innum"
block|,
literal|"innamed"
block|,
literal|"inname"
block|,
literal|"innamlen"
block|,
literal|"inacc"
block|,
literal|"inacclen"
block|,
literal|"inseq"
block|,
literal|"inseqlen"
block|,
literal|"indir"
block|,
literal|"indirlen"
block|,
literal|"infmt"
block|,
literal|"infmtlen"
block|,
literal|"inform"
block|,
literal|"informlen"
block|,
literal|"inunf"
block|,
literal|"inunflen"
block|,
literal|"inrecl"
block|,
literal|"innrec"
block|,
literal|"inblank"
block|,
literal|"inblanklen"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LOCAL
name|char
modifier|*
modifier|*
name|io_fields
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|zork
parameter_list|(
name|n
parameter_list|,
name|t
parameter_list|)
value|n, sizeof(n)/sizeof(char *) - 1, t
end_define

begin_decl_stmt
name|LOCAL
name|io_setup
name|io_stuff
index|[]
init|=
block|{
name|zork
argument_list|(
name|cilist_names
argument_list|,
name|TYCILIST
argument_list|)
block|,
comment|/* external read/write */
name|zork
argument_list|(
name|inlist_names
argument_list|,
name|TYINLIST
argument_list|)
block|,
comment|/* inquire */
name|zork
argument_list|(
name|olist_names
argument_list|,
name|TYOLIST
argument_list|)
block|,
comment|/* open */
name|zork
argument_list|(
name|cllist_names
argument_list|,
name|TYCLLIST
argument_list|)
block|,
comment|/* close */
name|zork
argument_list|(
name|alist_names
argument_list|,
name|TYALIST
argument_list|)
block|,
comment|/* rewind */
name|zork
argument_list|(
name|alist_names
argument_list|,
name|TYALIST
argument_list|)
block|,
comment|/* backspace */
name|zork
argument_list|(
name|alist_names
argument_list|,
name|TYALIST
argument_list|)
block|,
comment|/* endfile */
name|zork
argument_list|(
name|icilist_names
argument_list|,
name|TYICILIST
argument_list|)
block|,
comment|/* internal read */
name|zork
argument_list|(
argument|icilist_names
argument_list|,
argument|TYICILIST
argument_list|)
comment|/* internal write */
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|zork
end_undef

begin_function
name|int
ifdef|#
directive|ifdef
name|KR_headers
name|fmtstmt
parameter_list|(
name|lp
parameter_list|)
specifier|register
name|struct
name|Labelblock
modifier|*
name|lp
decl_stmt|;
else|#
directive|else
function|fmtstmt
parameter_list|(
specifier|register
name|struct
name|Labelblock
modifier|*
name|lp
parameter_list|)
endif|#
directive|endif
block|{
if|if
condition|(
name|lp
operator|==
name|NULL
condition|)
block|{
name|execerr
argument_list|(
literal|"unlabeled format statement"
argument_list|,
name|CNULL
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|lp
operator|->
name|labtype
operator|==
name|LABUNKNOWN
condition|)
block|{
name|lp
operator|->
name|labtype
operator|=
name|LABFORMAT
expr_stmt|;
name|lp
operator|->
name|labelno
operator|=
operator|(
name|int
operator|)
name|newlabel
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lp
operator|->
name|labtype
operator|!=
name|LABFORMAT
condition|)
block|{
name|execerr
argument_list|(
literal|"bad format number"
argument_list|,
name|CNULL
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
name|lp
operator|->
name|labelno
operator|)
return|;
block|}
end_function

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|setfmt
parameter_list|(
name|lp
parameter_list|)
name|struct
name|Labelblock
modifier|*
name|lp
decl_stmt|;
else|#
directive|else
function|setfmt
parameter_list|(
name|struct
name|Labelblock
modifier|*
name|lp
parameter_list|)
endif|#
directive|endif
block|{
name|int
name|n
decl_stmt|,
name|parity
decl_stmt|;
name|char
modifier|*
name|s0
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|se
decl_stmt|,
modifier|*
name|t
decl_stmt|;
specifier|register
name|k
expr_stmt|;
name|s0
operator|=
name|s
operator|=
name|lexline
argument_list|(
operator|&
name|n
argument_list|)
expr_stmt|;
name|se
operator|=
name|t
operator|=
name|s
operator|+
name|n
expr_stmt|;
comment|/* warn of trivial errors, e.g. "  11 CONTINUE" (one too few spaces) */
comment|/* following FORMAT... */
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
name|warn
argument_list|(
literal|"No (...) after FORMAT"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|s
operator|!=
literal|'('
condition|)
name|warni
argument_list|(
literal|"%c rather than ( after FORMAT"
argument_list|,
operator|*
name|s
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|se
index|[
operator|-
literal|1
index|]
operator|!=
literal|')'
condition|)
block|{
operator|*
name|se
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|--
name|t
operator|>
name|s
operator|&&
operator|*
name|t
operator|!=
literal|')'
condition|)
empty_stmt|;
if|if
condition|(
name|t
operator|<=
name|s
condition|)
name|warn
argument_list|(
literal|"No ) at end of FORMAT statement"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|se
operator|-
name|t
operator|>
literal|30
condition|)
name|warn1
argument_list|(
literal|"Extraneous text at end of FORMAT: ...%s"
argument_list|,
name|se
operator|-
literal|12
argument_list|)
expr_stmt|;
else|else
name|warn1
argument_list|(
literal|"Extraneous text at end of FORMAT: %s"
argument_list|,
name|t
operator|+
literal|1
argument_list|)
expr_stmt|;
name|t
operator|=
name|se
expr_stmt|;
block|}
comment|/* fix MYQUOTES (\002's) and \\'s */
name|parity
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|se
condition|)
switch|switch
condition|(
operator|*
name|s
operator|++
condition|)
block|{
case|case
literal|2
case|:
if|if
condition|(
operator|(
name|parity
operator|^=
literal|1
operator|)
operator|&&
operator|*
name|s
operator|==
literal|2
condition|)
block|{
name|t
operator|-=
literal|2
expr_stmt|;
operator|++
name|s
expr_stmt|;
block|}
else|else
name|t
operator|+=
literal|3
expr_stmt|;
break|break;
case|case
literal|'"'
case|:
case|case
literal|'\\'
case|:
name|t
operator|++
expr_stmt|;
break|break;
block|}
name|s
operator|=
name|s0
expr_stmt|;
name|parity
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|lp
condition|)
block|{
name|lp
operator|->
name|fmtstring
operator|=
name|t
operator|=
name|mem
argument_list|(
call|(
name|int
call|)
argument_list|(
name|t
operator|-
name|s
operator|+
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|se
condition|)
switch|switch
condition|(
name|k
operator|=
operator|*
name|s
operator|++
condition|)
block|{
case|case
literal|2
case|:
if|if
condition|(
operator|(
name|parity
operator|^=
literal|1
operator|)
operator|&&
operator|*
name|s
operator|==
literal|2
condition|)
name|s
operator|++
expr_stmt|;
else|else
block|{
name|t
index|[
literal|0
index|]
operator|=
literal|'\\'
expr_stmt|;
name|t
index|[
literal|1
index|]
operator|=
literal|'0'
expr_stmt|;
name|t
index|[
literal|2
index|]
operator|=
literal|'0'
expr_stmt|;
name|t
index|[
literal|3
index|]
operator|=
literal|'2'
expr_stmt|;
name|t
operator|+=
literal|4
expr_stmt|;
block|}
break|break;
case|case
literal|'"'
case|:
case|case
literal|'\\'
case|:
operator|*
name|t
operator|++
operator|=
literal|'\\'
expr_stmt|;
comment|/* no break */
default|default:
operator|*
name|t
operator|++
operator|=
name|k
expr_stmt|;
block|}
operator|*
name|t
operator|=
literal|0
expr_stmt|;
block|}
name|flline
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|startioctl
parameter_list|()
else|#
directive|else
function|startioctl
parameter_list|()
endif|#
directive|endif
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|inioctl
operator|=
name|YES
expr_stmt|;
name|nioctl
operator|=
literal|0
expr_stmt|;
name|ioformatted
operator|=
name|UNFORMATTED
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|NIOS
condition|;
operator|++
name|i
control|)
name|V
argument_list|(
name|i
argument_list|)
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|long
name|newiolabel
parameter_list|(
name|Void
parameter_list|)
block|{
name|long
name|rv
decl_stmt|;
name|rv
operator|=
operator|++
name|lastiolabno
expr_stmt|;
name|skiplabel
operator|=
name|mklabel
argument_list|(
name|rv
argument_list|)
expr_stmt|;
name|skiplabel
operator|->
name|labdefined
operator|=
literal|1
expr_stmt|;
return|return
name|rv
return|;
block|}
end_function

begin_function
name|void
name|endioctl
parameter_list|(
name|Void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|expptr
name|p
decl_stmt|;
name|struct
name|io_setup
modifier|*
name|ios
decl_stmt|;
name|inioctl
operator|=
name|NO
expr_stmt|;
comment|/* set up for error recovery */
name|ioerrlab
operator|=
name|ioendlab
operator|=
name|skiplab
operator|=
name|jumplab
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p
operator|=
name|V
argument_list|(
name|IOSEND
argument_list|)
condition|)
if|if
condition|(
name|ISICON
argument_list|(
name|p
argument_list|)
condition|)
name|execlab
argument_list|(
name|ioendlab
operator|=
name|p
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
argument_list|)
expr_stmt|;
else|else
name|err
argument_list|(
literal|"bad end= clause"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|=
name|V
argument_list|(
name|IOSERR
argument_list|)
condition|)
if|if
condition|(
name|ISICON
argument_list|(
name|p
argument_list|)
condition|)
name|execlab
argument_list|(
name|ioerrlab
operator|=
name|p
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
argument_list|)
expr_stmt|;
else|else
name|err
argument_list|(
literal|"bad err= clause"
argument_list|)
expr_stmt|;
if|if
condition|(
name|IOSTP
condition|)
if|if
condition|(
name|IOSTP
operator|->
name|tag
operator|!=
name|TADDR
operator|||
operator|!
name|ISINT
argument_list|(
name|IOSTP
operator|->
name|addrblock
operator|.
name|vtype
argument_list|)
condition|)
block|{
name|err
argument_list|(
literal|"iostat must be an integer variable"
argument_list|)
expr_stmt|;
name|frexpr
argument_list|(
name|IOSTP
argument_list|)
expr_stmt|;
name|IOSTP
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|iostmt
operator|==
name|IOREAD
condition|)
block|{
if|if
condition|(
name|IOSTP
condition|)
block|{
if|if
condition|(
name|ioerrlab
operator|&&
name|ioendlab
operator|&&
name|ioerrlab
operator|==
name|ioendlab
condition|)
name|jumplab
operator|=
name|ioerrlab
expr_stmt|;
else|else
name|skiplab
operator|=
name|jumplab
operator|=
name|newiolabel
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ioerrlab
operator|&&
name|ioendlab
operator|&&
name|ioerrlab
operator|!=
name|ioendlab
condition|)
block|{
name|IOSTP
operator|=
operator|(
name|expptr
operator|)
name|mktmp
argument_list|(
name|TYINT
argument_list|,
name|ENULL
argument_list|)
expr_stmt|;
name|skiplab
operator|=
name|jumplab
operator|=
name|newiolabel
argument_list|()
expr_stmt|;
block|}
else|else
name|jumplab
operator|=
operator|(
name|ioerrlab
condition|?
name|ioerrlab
else|:
name|ioendlab
operator|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|iostmt
operator|==
name|IOWRITE
condition|)
block|{
if|if
condition|(
name|IOSTP
operator|&&
operator|!
name|ioerrlab
condition|)
name|skiplab
operator|=
name|jumplab
operator|=
name|newiolabel
argument_list|()
expr_stmt|;
else|else
name|jumplab
operator|=
name|ioerrlab
expr_stmt|;
block|}
else|else
name|jumplab
operator|=
name|ioerrlab
expr_stmt|;
name|endbit
operator|=
name|IOSTP
operator|!=
name|NULL
operator|||
name|ioendlab
operator|!=
literal|0
expr_stmt|;
comment|/* for use in startrw() */
name|errbit
operator|=
name|IOSTP
operator|!=
name|NULL
operator|||
name|ioerrlab
operator|!=
literal|0
expr_stmt|;
if|if
condition|(
name|jumplab
operator|&&
operator|!
name|IOSTP
condition|)
name|IOSTP
operator|=
operator|(
name|expptr
operator|)
name|mktmp
argument_list|(
name|TYINT
argument_list|,
name|ENULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|iostmt
operator|!=
name|IOREAD
operator|&&
name|iostmt
operator|!=
name|IOWRITE
condition|)
block|{
name|ios
operator|=
name|io_stuff
operator|+
name|iostmt
expr_stmt|;
name|io_fields
operator|=
name|ios
operator|->
name|fields
expr_stmt|;
name|ioblkp
operator|=
name|io_structs
index|[
name|iostmt
index|]
expr_stmt|;
if|if
condition|(
name|ioblkp
operator|==
name|NULL
condition|)
name|io_structs
index|[
name|iostmt
index|]
operator|=
name|ioblkp
operator|=
name|autovar
argument_list|(
literal|1
argument_list|,
name|ios
operator|->
name|type
argument_list|,
name|ENULL
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|ioset
argument_list|(
name|TYIOINT
argument_list|,
name|XERR
argument_list|,
name|ICON
argument_list|(
name|errbit
argument_list|)
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|iostmt
condition|)
block|{
case|case
name|IOOPEN
case|:
name|dofopen
argument_list|()
expr_stmt|;
break|break;
case|case
name|IOCLOSE
case|:
name|dofclose
argument_list|()
expr_stmt|;
break|break;
case|case
name|IOINQUIRE
case|:
name|dofinquire
argument_list|()
expr_stmt|;
break|break;
case|case
name|IOBACKSPACE
case|:
name|dofmove
argument_list|(
literal|"f_back"
argument_list|)
expr_stmt|;
break|break;
case|case
name|IOREWIND
case|:
name|dofmove
argument_list|(
literal|"f_rew"
argument_list|)
expr_stmt|;
break|break;
case|case
name|IOENDFILE
case|:
name|dofmove
argument_list|(
literal|"f_end"
argument_list|)
expr_stmt|;
break|break;
case|case
name|IOREAD
case|:
case|case
name|IOWRITE
case|:
name|startrw
argument_list|()
expr_stmt|;
break|break;
default|default:
name|fatali
argument_list|(
literal|"impossible iostmt %d"
argument_list|,
name|iostmt
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|NIOS
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|i
operator|!=
name|IOSIOSTAT
operator|&&
name|V
argument_list|(
name|i
argument_list|)
operator|!=
name|NULL
condition|)
name|frexpr
argument_list|(
name|V
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|iocname
parameter_list|(
name|Void
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|found
decl_stmt|,
name|mask
decl_stmt|;
name|found
operator|=
literal|0
expr_stmt|;
name|mask
operator|=
name|M
argument_list|(
name|iostmt
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|NIOS
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ioc
index|[
name|i
index|]
operator|.
name|iocname
argument_list|,
name|token
argument_list|)
condition|)
if|if
condition|(
name|ioc
index|[
name|i
index|]
operator|.
name|iotype
operator|&
name|mask
condition|)
return|return
operator|(
name|i
operator|)
return|;
else|else
block|{
name|found
operator|=
name|i
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|found
condition|)
block|{
if|if
condition|(
name|iostmt
operator|==
name|IOOPEN
operator|&&
operator|!
name|strcmp
argument_list|(
name|ioc
index|[
name|i
index|]
operator|.
name|iocname
argument_list|,
literal|"name"
argument_list|)
condition|)
block|{
name|NOEXT
argument_list|(
literal|"open with \"name=\" treated as \"file=\""
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|strcmp
argument_list|(
name|ioc
index|[
name|i
index|]
operator|.
name|iocname
argument_list|,
literal|"file"
argument_list|)
condition|;
name|i
operator|++
control|)
empty_stmt|;
return|return
name|i
return|;
block|}
name|errstr
argument_list|(
literal|"invalid control %s for statement"
argument_list|,
name|ioc
index|[
name|found
index|]
operator|.
name|iocname
argument_list|)
expr_stmt|;
block|}
else|else
name|errstr
argument_list|(
literal|"unknown iocontrol %s"
argument_list|,
name|token
argument_list|)
expr_stmt|;
return|return
operator|(
name|IOSBAD
operator|)
return|;
block|}
end_function

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|ioclause
parameter_list|(
name|n
parameter_list|,
name|p
parameter_list|)
specifier|register
name|int
name|n
decl_stmt|;
specifier|register
name|expptr
name|p
decl_stmt|;
else|#
directive|else
function|ioclause
parameter_list|(
specifier|register
name|int
name|n
parameter_list|,
specifier|register
name|expptr
name|p
parameter_list|)
endif|#
directive|endif
block|{
name|struct
name|Ioclist
modifier|*
name|iocp
decl_stmt|;
operator|++
name|nioctl
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|IOSBAD
condition|)
return|return;
if|if
condition|(
name|n
operator|==
name|IOSPOSITIONAL
condition|)
block|{
name|n
operator|=
name|nioctl
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|IOSFMT
condition|)
block|{
if|if
condition|(
name|iostmt
operator|==
name|IOOPEN
condition|)
block|{
name|n
operator|=
name|IOSFILE
expr_stmt|;
name|NOEXT
argument_list|(
literal|"file= specifier omitted from open"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|iostmt
operator|<
name|IOREAD
condition|)
goto|goto
name|illegal
goto|;
block|}
elseif|else
if|if
condition|(
name|n
operator|>
name|IOSFMT
condition|)
block|{
name|illegal
label|:
name|err
argument_list|(
literal|"illegal positional iocontrol"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|n
operator|==
name|IOSNML
condition|)
name|n
operator|=
name|IOSFMT
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|n
operator|==
name|IOSUNIT
condition|)
name|p
operator|=
call|(
name|expptr
call|)
argument_list|(
name|iostmt
operator|==
name|IOREAD
condition|?
name|IOSTDIN
else|:
name|IOSTDOUT
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|n
operator|!=
name|IOSFMT
condition|)
block|{
name|err
argument_list|(
literal|"illegal * iocontrol"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|n
operator|==
name|IOSFMT
condition|)
name|ioformatted
operator|=
operator|(
name|p
operator|==
name|NULL
condition|?
name|LISTDIRECTED
else|:
name|FORMATTED
operator|)
expr_stmt|;
name|iocp
operator|=
operator|&
name|ioc
index|[
name|n
index|]
expr_stmt|;
if|if
condition|(
name|iocp
operator|->
name|iocval
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|n
operator|!=
name|IOSFMT
operator|&&
operator|(
name|n
operator|!=
name|IOSUNIT
operator|||
operator|(
name|p
operator|&&
name|p
operator|->
name|headblock
operator|.
name|vtype
operator|!=
name|TYCHAR
operator|)
operator|)
condition|)
name|p
operator|=
name|fixtype
argument_list|(
name|p
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|&&
name|p
operator|->
name|tag
operator|==
name|TPRIM
operator|&&
name|p
operator|->
name|primblock
operator|.
name|namep
operator|->
name|vclass
operator|==
name|CLUNKNOWN
condition|)
block|{
comment|/* kludge made necessary by attempt to infer types 			 * for untyped external parameters: given an error 			 * in calling sequences, an integer argument might 			 * tentatively be assumed TYCHAR; this would otherwise 			 * be corrected too late in startrw after startrw 			 * had decided this to be an internal file. 			 */
name|vardcl
argument_list|(
name|p
operator|->
name|primblock
operator|.
name|namep
argument_list|)
expr_stmt|;
name|p
operator|->
name|primblock
operator|.
name|vtype
operator|=
name|p
operator|->
name|primblock
operator|.
name|namep
operator|->
name|vtype
expr_stmt|;
block|}
name|iocp
operator|->
name|iocval
operator|=
name|p
expr_stmt|;
block|}
else|else
name|errstr
argument_list|(
literal|"iocontrol %s repeated"
argument_list|,
name|iocp
operator|->
name|iocname
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* io list item */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|doio
parameter_list|(
name|list
parameter_list|)
name|chainp
name|list
decl_stmt|;
else|#
directive|else
function|doio
parameter_list|(
name|chainp
name|list
parameter_list|)
endif|#
directive|endif
block|{
if|if
condition|(
name|ioformatted
operator|==
name|NAMEDIRECTED
condition|)
block|{
if|if
condition|(
name|list
condition|)
name|err
argument_list|(
literal|"no I/O list allowed in NAMELIST read/write"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|doiolist
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|ioroutine
index|[
literal|0
index|]
operator|=
literal|'e'
expr_stmt|;
if|if
condition|(
name|skiplab
condition|)
name|jumplab
operator|=
literal|0
expr_stmt|;
name|putiocall
argument_list|(
name|call0
argument_list|(
name|TYINT
argument_list|,
name|ioroutine
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|LOCAL
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|doiolist
parameter_list|(
name|p0
parameter_list|)
name|chainp
name|p0
decl_stmt|;
else|#
directive|else
function|doiolist
parameter_list|(
name|chainp
name|p0
parameter_list|)
endif|#
directive|endif
block|{
name|chainp
name|p
decl_stmt|;
specifier|register
name|tagptr
name|q
decl_stmt|;
specifier|register
name|expptr
name|qe
decl_stmt|;
specifier|register
name|Namep
name|qn
decl_stmt|;
name|Addrp
name|tp
decl_stmt|;
name|int
name|range
decl_stmt|;
specifier|extern
name|char
modifier|*
name|ohalign
decl_stmt|;
for|for
control|(
name|p
operator|=
name|p0
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|nextp
control|)
block|{
name|q
operator|=
operator|(
name|tagptr
operator|)
name|p
operator|->
name|datap
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|tag
operator|==
name|TIMPLDO
condition|)
block|{
name|exdo
argument_list|(
name|range
operator|=
operator|(
name|int
operator|)
name|newlabel
argument_list|()
argument_list|,
operator|(
name|Namep
operator|)
literal|0
argument_list|,
name|q
operator|->
name|impldoblock
operator|.
name|impdospec
argument_list|)
expr_stmt|;
name|doiolist
argument_list|(
name|q
operator|->
name|impldoblock
operator|.
name|datalist
argument_list|)
expr_stmt|;
name|enddo
argument_list|(
name|range
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|charptr
operator|)
name|q
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|q
operator|->
name|tag
operator|==
name|TPRIM
operator|&&
name|q
operator|->
name|primblock
operator|.
name|argsp
operator|==
name|NULL
operator|&&
name|q
operator|->
name|primblock
operator|.
name|namep
operator|->
name|vdim
operator|!=
name|NULL
condition|)
block|{
name|vardcl
argument_list|(
name|qn
operator|=
name|q
operator|->
name|primblock
operator|.
name|namep
argument_list|)
expr_stmt|;
if|if
condition|(
name|qn
operator|->
name|vdim
operator|->
name|nelt
condition|)
block|{
name|putio
argument_list|(
name|fixtype
argument_list|(
name|cpexpr
argument_list|(
name|qn
operator|->
name|vdim
operator|->
name|nelt
argument_list|)
argument_list|)
argument_list|,
operator|(
name|expptr
operator|)
name|mkscalar
argument_list|(
name|qn
argument_list|)
argument_list|)
expr_stmt|;
name|qn
operator|->
name|vlastdim
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|err
argument_list|(
literal|"attempt to i/o array of unknown size"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|q
operator|->
name|tag
operator|==
name|TPRIM
operator|&&
name|q
operator|->
name|primblock
operator|.
name|argsp
operator|==
name|NULL
operator|&&
operator|(
name|qe
operator|=
operator|(
name|expptr
operator|)
name|memversion
argument_list|(
name|q
operator|->
name|primblock
operator|.
name|namep
argument_list|)
operator|)
condition|)
name|putio
argument_list|(
name|ICON
argument_list|(
literal|1
argument_list|)
argument_list|,
name|qe
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ISCONST
argument_list|(
name|q
argument_list|)
operator|&&
name|q
operator|->
name|constblock
operator|.
name|vtype
operator|==
name|TYCHAR
condition|)
block|{
name|halign
operator|=
literal|0
expr_stmt|;
name|putio
argument_list|(
name|ICON
argument_list|(
literal|1
argument_list|)
argument_list|,
name|qe
operator|=
name|fixtype
argument_list|(
name|cpexpr
argument_list|(
name|q
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|halign
operator|=
name|ohalign
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
name|qe
operator|=
name|fixtype
argument_list|(
name|cpexpr
argument_list|(
name|q
argument_list|)
argument_list|)
operator|)
operator|->
name|tag
operator|==
name|TADDR
operator|&&
operator|(
name|qe
operator|->
name|addrblock
operator|.
name|uname_tag
operator|!=
name|UNAM_CONST
operator|||
operator|!
name|ISCOMPLEX
argument_list|(
name|qe
operator|->
name|addrblock
operator|.
name|vtype
argument_list|)
operator|)
operator|)
operator|||
operator|(
name|qe
operator|->
name|tag
operator|==
name|TCONST
operator|&&
operator|!
name|ISCOMPLEX
argument_list|(
name|qe
operator|->
name|headblock
operator|.
name|vtype
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|qe
operator|->
name|tag
operator|==
name|TCONST
condition|)
name|qe
operator|=
operator|(
name|expptr
operator|)
name|putconst
argument_list|(
operator|(
name|Constp
operator|)
name|qe
argument_list|)
expr_stmt|;
name|putio
argument_list|(
name|ICON
argument_list|(
literal|1
argument_list|)
argument_list|,
name|qe
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|qe
operator|->
name|headblock
operator|.
name|vtype
operator|!=
name|TYERROR
condition|)
block|{
if|if
condition|(
name|iostmt
operator|==
name|IOWRITE
condition|)
block|{
name|expptr
name|qvl
decl_stmt|;
name|qvl
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ISCHAR
argument_list|(
name|qe
argument_list|)
condition|)
block|{
name|qvl
operator|=
operator|(
name|expptr
operator|)
name|cpexpr
argument_list|(
name|qe
operator|->
name|headblock
operator|.
name|vleng
argument_list|)
expr_stmt|;
name|tp
operator|=
name|mktmp
argument_list|(
name|qe
operator|->
name|headblock
operator|.
name|vtype
argument_list|,
name|ICON
argument_list|(
name|lencat
argument_list|(
name|qe
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|tp
operator|=
name|mktmp
argument_list|(
name|qe
operator|->
name|headblock
operator|.
name|vtype
argument_list|,
name|qe
operator|->
name|headblock
operator|.
name|vleng
argument_list|)
expr_stmt|;
name|puteq
argument_list|(
name|cpexpr
argument_list|(
operator|(
name|expptr
operator|)
name|tp
argument_list|)
argument_list|,
name|qe
argument_list|)
expr_stmt|;
if|if
condition|(
name|qvl
condition|)
comment|/* put right length on block */
block|{
name|frexpr
argument_list|(
name|tp
operator|->
name|vleng
argument_list|)
expr_stmt|;
name|tp
operator|->
name|vleng
operator|=
name|qvl
expr_stmt|;
block|}
name|putio
argument_list|(
name|ICON
argument_list|(
literal|1
argument_list|)
argument_list|,
operator|(
name|expptr
operator|)
name|tp
argument_list|)
expr_stmt|;
block|}
else|else
name|err
argument_list|(
literal|"non-left side in READ list"
argument_list|)
expr_stmt|;
block|}
name|frexpr
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
block|}
name|frchain
argument_list|(
operator|&
name|p0
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|int
name|iocalladdr
init|=
name|TYADDR
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for fixing TYADDR in saveargtypes */
end_comment

begin_decl_stmt
name|int
name|typeconv
index|[
name|TYERROR
operator|+
literal|1
index|]
init|=
block|{
ifdef|#
directive|ifdef
name|TYQUAD
literal|0
block|,
literal|1
block|,
literal|11
block|,
literal|2
block|,
literal|3
block|,
literal|14
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|12
block|,
literal|13
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|15
else|#
directive|else
literal|0
block|,
literal|1
block|,
literal|11
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|12
block|,
literal|13
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|14
endif|#
directive|endif
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|LOCAL
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|putio
parameter_list|(
name|nelt
parameter_list|,
name|addr
parameter_list|)
name|expptr
name|nelt
decl_stmt|;
specifier|register
name|expptr
name|addr
decl_stmt|;
else|#
directive|else
function|putio
parameter_list|(
name|expptr
name|nelt
parameter_list|,
specifier|register
name|expptr
name|addr
parameter_list|)
endif|#
directive|endif
block|{
name|int
name|type
decl_stmt|;
specifier|register
name|expptr
name|q
decl_stmt|;
specifier|register
name|Addrp
name|c
init|=
literal|0
decl_stmt|;
name|type
operator|=
name|addr
operator|->
name|headblock
operator|.
name|vtype
expr_stmt|;
if|if
condition|(
name|ioformatted
operator|!=
name|LISTDIRECTED
operator|&&
name|ISCOMPLEX
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|nelt
operator|=
name|mkexpr
argument_list|(
name|OPSTAR
argument_list|,
name|ICON
argument_list|(
literal|2
argument_list|)
argument_list|,
name|nelt
argument_list|)
expr_stmt|;
name|type
operator|-=
operator|(
name|TYCOMPLEX
operator|-
name|TYREAL
operator|)
expr_stmt|;
block|}
comment|/* pass a length with every item.  for noncharacter data, fake one */
if|if
condition|(
name|type
operator|!=
name|TYCHAR
condition|)
block|{
if|if
condition|(
name|ISCONST
argument_list|(
name|addr
argument_list|)
condition|)
name|addr
operator|=
operator|(
name|expptr
operator|)
name|putconst
argument_list|(
operator|(
name|Constp
operator|)
name|addr
argument_list|)
expr_stmt|;
name|c
operator|=
name|ALLOC
argument_list|(
name|Addrblock
argument_list|)
expr_stmt|;
name|c
operator|->
name|tag
operator|=
name|TADDR
expr_stmt|;
name|c
operator|->
name|vtype
operator|=
name|TYLENG
expr_stmt|;
name|c
operator|->
name|vstg
operator|=
name|STGAUTO
expr_stmt|;
name|c
operator|->
name|ntempelt
operator|=
literal|1
expr_stmt|;
name|c
operator|->
name|isarray
operator|=
literal|1
expr_stmt|;
name|c
operator|->
name|memoffset
operator|=
name|ICON
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|c
operator|->
name|uname_tag
operator|=
name|UNAM_IDENT
expr_stmt|;
name|c
operator|->
name|charleng
operator|=
literal|1
expr_stmt|;
name|sprintf
argument_list|(
name|c
operator|->
name|user
operator|.
name|ident
argument_list|,
literal|"(ftnlen)sizeof(%s)"
argument_list|,
name|typename
index|[
name|type
index|]
argument_list|)
expr_stmt|;
name|addr
operator|=
name|mkexpr
argument_list|(
name|OPCHARCAST
argument_list|,
name|addr
argument_list|,
name|ENULL
argument_list|)
expr_stmt|;
block|}
name|nelt
operator|=
name|fixtype
argument_list|(
name|mkconv
argument_list|(
name|tyioint
argument_list|,
name|nelt
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioformatted
operator|==
name|LISTDIRECTED
condition|)
block|{
name|expptr
name|mc
init|=
name|mkconv
argument_list|(
name|tyioint
argument_list|,
name|ICON
argument_list|(
name|typeconv
index|[
name|type
index|]
argument_list|)
argument_list|)
decl_stmt|;
name|q
operator|=
name|c
condition|?
name|call4
argument_list|(
name|TYINT
argument_list|,
literal|"do_lio"
argument_list|,
name|mc
argument_list|,
name|nelt
argument_list|,
name|addr
argument_list|,
operator|(
name|expptr
operator|)
name|c
argument_list|)
else|:
name|call3
argument_list|(
name|TYINT
argument_list|,
literal|"do_lio"
argument_list|,
name|mc
argument_list|,
name|nelt
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|s
init|=
name|ioformatted
operator|==
name|FORMATTED
condition|?
literal|"do_fio"
else|:
operator|!
name|byterev
condition|?
literal|"do_uio"
else|:
name|ONEOF
argument_list|(
name|type
argument_list|,
name|M
argument_list|(
name|TYCHAR
argument_list|)
operator||
name|M
argument_list|(
name|TYINT1
argument_list|)
operator||
name|M
argument_list|(
name|TYLOGICAL1
argument_list|)
argument_list|)
condition|?
literal|"do_ucio"
else|:
literal|"do_unio"
decl_stmt|;
name|q
operator|=
name|c
condition|?
name|call3
argument_list|(
name|TYINT
argument_list|,
name|s
argument_list|,
name|nelt
argument_list|,
name|addr
argument_list|,
operator|(
name|expptr
operator|)
name|c
argument_list|)
else|:
name|call2
argument_list|(
name|TYINT
argument_list|,
name|s
argument_list|,
name|nelt
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
name|iocalladdr
operator|=
name|TYCHAR
expr_stmt|;
name|putiocall
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|iocalladdr
operator|=
name|TYADDR
expr_stmt|;
block|}
end_function

begin_function
name|void
name|endio
parameter_list|(
name|Void
parameter_list|)
block|{
if|if
condition|(
name|skiplab
condition|)
block|{
if|if
condition|(
name|ioformatted
operator|!=
name|NAMEDIRECTED
condition|)
name|p1_label
argument_list|(
call|(
name|long
call|)
argument_list|(
name|skiplabel
operator|-
name|labeltab
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioendlab
condition|)
block|{
name|exif
argument_list|(
name|mkexpr
argument_list|(
name|OPLT
argument_list|,
name|cpexpr
argument_list|(
name|IOSTP
argument_list|)
argument_list|,
name|ICON
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|exgoto
argument_list|(
name|execlab
argument_list|(
name|ioendlab
argument_list|)
argument_list|)
expr_stmt|;
name|exendif
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|ioerrlab
condition|)
block|{
name|exif
argument_list|(
name|mkexpr
argument_list|(
name|iostmt
operator|==
name|IOREAD
operator|||
name|iostmt
operator|==
name|IOWRITE
condition|?
name|OPGT
else|:
name|OPNE
argument_list|,
name|cpexpr
argument_list|(
name|IOSTP
argument_list|)
argument_list|,
name|ICON
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|exgoto
argument_list|(
name|execlab
argument_list|(
name|ioerrlab
argument_list|)
argument_list|)
expr_stmt|;
name|exendif
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|IOSTP
condition|)
name|frexpr
argument_list|(
name|IOSTP
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|LOCAL
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|putiocall
parameter_list|(
name|q
parameter_list|)
specifier|register
name|expptr
name|q
decl_stmt|;
else|#
directive|else
function|putiocall
parameter_list|(
specifier|register
name|expptr
name|q
parameter_list|)
endif|#
directive|endif
block|{
name|int
name|tyintsave
decl_stmt|;
name|tyintsave
operator|=
name|tyint
expr_stmt|;
name|tyint
operator|=
name|tyioint
expr_stmt|;
comment|/* for -I2 and -i2 */
if|if
condition|(
name|IOSTP
condition|)
block|{
name|q
operator|->
name|headblock
operator|.
name|vtype
operator|=
name|TYINT
expr_stmt|;
name|q
operator|=
name|fixexpr
argument_list|(
operator|(
name|Exprp
operator|)
name|mkexpr
argument_list|(
name|OPASSIGN
argument_list|,
name|cpexpr
argument_list|(
name|IOSTP
argument_list|)
argument_list|,
name|q
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|putexpr
argument_list|(
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|jumplab
condition|)
block|{
name|exif
argument_list|(
name|mkexpr
argument_list|(
name|OPNE
argument_list|,
name|cpexpr
argument_list|(
name|IOSTP
argument_list|)
argument_list|,
name|ICON
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|exgoto
argument_list|(
name|execlab
argument_list|(
name|jumplab
argument_list|)
argument_list|)
expr_stmt|;
name|exendif
argument_list|()
expr_stmt|;
block|}
name|tyint
operator|=
name|tyintsave
expr_stmt|;
block|}
end_function

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|fmtname
parameter_list|(
name|np
parameter_list|,
name|q
parameter_list|)
name|Namep
name|np
decl_stmt|;
specifier|register
name|Addrp
name|q
decl_stmt|;
else|#
directive|else
function|fmtname
parameter_list|(
name|Namep
name|np
parameter_list|,
specifier|register
name|Addrp
name|q
parameter_list|)
endif|#
directive|endif
block|{
specifier|register
name|int
name|k
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|t
decl_stmt|;
specifier|extern
name|chainp
name|assigned_fmts
decl_stmt|;
if|if
condition|(
operator|!
name|np
operator|->
name|vfmt_asg
condition|)
block|{
name|np
operator|->
name|vfmt_asg
operator|=
literal|1
expr_stmt|;
name|assigned_fmts
operator|=
name|mkchain
argument_list|(
operator|(
name|char
operator|*
operator|)
name|np
argument_list|,
name|assigned_fmts
argument_list|)
expr_stmt|;
block|}
name|k
operator|=
name|strlen
argument_list|(
name|s
operator|=
name|np
operator|->
name|fvarname
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|<
name|IDENT_LEN
operator|-
literal|4
condition|)
block|{
name|q
operator|->
name|uname_tag
operator|=
name|UNAM_IDENT
expr_stmt|;
name|t
operator|=
name|q
operator|->
name|user
operator|.
name|ident
expr_stmt|;
block|}
else|else
block|{
name|q
operator|->
name|uname_tag
operator|=
name|UNAM_CHARP
expr_stmt|;
name|q
operator|->
name|user
operator|.
name|Charp
operator|=
name|t
operator|=
name|mem
argument_list|(
name|k
operator|+
literal|5
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|t
argument_list|,
literal|"%s_fmt"
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|LOCAL
name|Addrp
ifdef|#
directive|ifdef
name|KR_headers
name|asg_addr
parameter_list|(
name|p
parameter_list|)
name|union
name|Expression
modifier|*
name|p
decl_stmt|;
else|#
directive|else
function|asg_addr
parameter_list|(
name|union
name|Expression
modifier|*
name|p
parameter_list|)
endif|#
directive|endif
block|{
specifier|register
name|Addrp
name|q
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|tag
operator|!=
name|TPRIM
condition|)
name|badtag
argument_list|(
literal|"asg_addr"
argument_list|,
name|p
operator|->
name|tag
argument_list|)
expr_stmt|;
name|q
operator|=
name|ALLOC
argument_list|(
name|Addrblock
argument_list|)
expr_stmt|;
name|q
operator|->
name|tag
operator|=
name|TADDR
expr_stmt|;
name|q
operator|->
name|vtype
operator|=
name|TYCHAR
expr_stmt|;
name|q
operator|->
name|vstg
operator|=
name|STGAUTO
expr_stmt|;
name|q
operator|->
name|ntempelt
operator|=
literal|1
expr_stmt|;
name|q
operator|->
name|isarray
operator|=
literal|0
expr_stmt|;
name|q
operator|->
name|memoffset
operator|=
name|ICON
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|fmtname
argument_list|(
name|p
operator|->
name|primblock
operator|.
name|namep
argument_list|,
name|q
argument_list|)
expr_stmt|;
return|return
name|q
return|;
block|}
end_function

begin_function
name|void
name|startrw
parameter_list|(
name|Void
parameter_list|)
block|{
specifier|register
name|expptr
name|p
decl_stmt|;
specifier|register
name|Namep
name|np
decl_stmt|;
specifier|register
name|Addrp
name|unitp
decl_stmt|,
name|fmtp
decl_stmt|,
name|recp
decl_stmt|;
specifier|register
name|expptr
name|nump
decl_stmt|;
name|int
name|iostmt1
decl_stmt|;
name|flag
name|intfile
decl_stmt|,
name|sequential
decl_stmt|,
name|ok
decl_stmt|,
name|varfmt
decl_stmt|;
name|struct
name|io_setup
modifier|*
name|ios
decl_stmt|;
comment|/* First look at all the parameters and determine what is to be done */
name|ok
operator|=
name|YES
expr_stmt|;
name|statstruct
operator|=
name|YES
expr_stmt|;
name|intfile
operator|=
name|NO
expr_stmt|;
if|if
condition|(
name|p
operator|=
name|V
argument_list|(
name|IOSUNIT
argument_list|)
condition|)
block|{
if|if
condition|(
name|ISINT
argument_list|(
name|p
operator|->
name|headblock
operator|.
name|vtype
argument_list|)
condition|)
block|{
name|int_unit
label|:
name|unitp
operator|=
operator|(
name|Addrp
operator|)
name|cpexpr
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|headblock
operator|.
name|vtype
operator|==
name|TYCHAR
condition|)
block|{
if|if
condition|(
name|nioctl
operator|==
literal|1
operator|&&
name|iostmt
operator|==
name|IOREAD
condition|)
block|{
comment|/* kludge to recognize READ(format expr) */
name|V
argument_list|(
name|IOSFMT
argument_list|)
operator|=
name|p
expr_stmt|;
name|V
argument_list|(
name|IOSUNIT
argument_list|)
operator|=
name|p
operator|=
operator|(
name|expptr
operator|)
name|IOSTDIN
expr_stmt|;
name|ioformatted
operator|=
name|FORMATTED
expr_stmt|;
goto|goto
name|int_unit
goto|;
block|}
name|intfile
operator|=
name|YES
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|tag
operator|==
name|TPRIM
operator|&&
name|p
operator|->
name|primblock
operator|.
name|argsp
operator|==
name|NULL
operator|&&
operator|(
name|np
operator|=
name|p
operator|->
name|primblock
operator|.
name|namep
operator|)
operator|->
name|vdim
operator|!=
name|NULL
condition|)
block|{
name|vardcl
argument_list|(
name|np
argument_list|)
expr_stmt|;
if|if
condition|(
name|nump
operator|=
name|np
operator|->
name|vdim
operator|->
name|nelt
condition|)
block|{
name|nump
operator|=
name|fixtype
argument_list|(
name|cpexpr
argument_list|(
name|nump
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ISCONST
argument_list|(
name|nump
argument_list|)
condition|)
block|{
name|statstruct
operator|=
name|NO
expr_stmt|;
name|np
operator|->
name|vlastdim
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|err
argument_list|(
literal|"attempt to use internal unit array of unknown size"
argument_list|)
expr_stmt|;
name|ok
operator|=
name|NO
expr_stmt|;
name|nump
operator|=
name|ICON
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|unitp
operator|=
name|mkscalar
argument_list|(
name|np
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nump
operator|=
name|ICON
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|unitp
operator|=
operator|(
name|Addrp
comment|/*pjw */
operator|)
name|fixtype
argument_list|(
name|cpexpr
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|isstatic
argument_list|(
operator|(
name|expptr
operator|)
name|unitp
argument_list|)
condition|)
name|statstruct
operator|=
name|NO
expr_stmt|;
block|}
else|else
block|{
name|err
argument_list|(
literal|"unit specifier not of type integer or character"
argument_list|)
expr_stmt|;
name|ok
operator|=
name|NO
expr_stmt|;
block|}
block|}
else|else
block|{
name|err
argument_list|(
literal|"bad unit specifier"
argument_list|)
expr_stmt|;
name|ok
operator|=
name|NO
expr_stmt|;
block|}
name|sequential
operator|=
name|YES
expr_stmt|;
if|if
condition|(
name|p
operator|=
name|V
argument_list|(
name|IOSREC
argument_list|)
condition|)
if|if
condition|(
name|ISINT
argument_list|(
name|p
operator|->
name|headblock
operator|.
name|vtype
argument_list|)
condition|)
block|{
name|recp
operator|=
operator|(
name|Addrp
operator|)
name|cpexpr
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|sequential
operator|=
name|NO
expr_stmt|;
block|}
else|else
block|{
name|err
argument_list|(
literal|"bad REC= clause"
argument_list|)
expr_stmt|;
name|ok
operator|=
name|NO
expr_stmt|;
block|}
else|else
name|recp
operator|=
name|NULL
expr_stmt|;
name|varfmt
operator|=
name|YES
expr_stmt|;
name|fmtp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|p
operator|=
name|V
argument_list|(
name|IOSFMT
argument_list|)
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|tag
operator|==
name|TPRIM
operator|&&
name|p
operator|->
name|primblock
operator|.
name|argsp
operator|==
name|NULL
condition|)
block|{
name|np
operator|=
name|p
operator|->
name|primblock
operator|.
name|namep
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|vclass
operator|==
name|CLNAMELIST
condition|)
block|{
name|ioformatted
operator|=
name|NAMEDIRECTED
expr_stmt|;
name|fmtp
operator|=
operator|(
name|Addrp
operator|)
name|fixtype
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|V
argument_list|(
name|IOSFMT
argument_list|)
operator|=
operator|(
name|expptr
operator|)
name|fmtp
expr_stmt|;
if|if
condition|(
name|skiplab
condition|)
name|jumplab
operator|=
literal|0
expr_stmt|;
goto|goto
name|endfmt
goto|;
block|}
name|vardcl
argument_list|(
name|np
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|vdim
condition|)
block|{
if|if
condition|(
operator|!
name|ONEOF
argument_list|(
name|np
operator|->
name|vstg
argument_list|,
name|MSKSTATIC
argument_list|)
condition|)
name|statstruct
operator|=
name|NO
expr_stmt|;
name|fmtp
operator|=
name|mkscalar
argument_list|(
name|np
argument_list|)
expr_stmt|;
goto|goto
name|endfmt
goto|;
block|}
if|if
condition|(
name|ISINT
argument_list|(
name|np
operator|->
name|vtype
argument_list|)
condition|)
comment|/* ASSIGNed label */
block|{
name|statstruct
operator|=
name|NO
expr_stmt|;
name|varfmt
operator|=
name|YES
expr_stmt|;
name|fmtp
operator|=
name|asg_addr
argument_list|(
name|p
argument_list|)
expr_stmt|;
goto|goto
name|endfmt
goto|;
block|}
block|}
name|p
operator|=
name|V
argument_list|(
name|IOSFMT
argument_list|)
operator|=
name|fixtype
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|headblock
operator|.
name|vtype
operator|==
name|TYCHAR
comment|/* Since we allow write(6,n)		*/
comment|/* we may as well allow write(6,n(2))	*/
operator|||
name|p
operator|->
name|tag
operator|==
name|TADDR
operator|&&
name|ISINT
argument_list|(
name|p
operator|->
name|addrblock
operator|.
name|vtype
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|isstatic
argument_list|(
name|p
argument_list|)
condition|)
name|statstruct
operator|=
name|NO
expr_stmt|;
name|fmtp
operator|=
operator|(
name|Addrp
operator|)
name|cpexpr
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ISICON
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|struct
name|Labelblock
modifier|*
name|lp
decl_stmt|;
name|lp
operator|=
name|mklabel
argument_list|(
name|p
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmtstmt
argument_list|(
name|lp
argument_list|)
operator|>
literal|0
condition|)
block|{
name|fmtp
operator|=
operator|(
name|Addrp
operator|)
name|mkaddcon
argument_list|(
name|lp
operator|->
name|stateno
argument_list|)
expr_stmt|;
comment|/* lp->stateno for names fmt_nnn */
name|lp
operator|->
name|fmtlabused
operator|=
literal|1
expr_stmt|;
name|varfmt
operator|=
name|NO
expr_stmt|;
block|}
else|else
name|ioformatted
operator|=
name|UNFORMATTED
expr_stmt|;
block|}
else|else
block|{
name|err
argument_list|(
literal|"bad format descriptor"
argument_list|)
expr_stmt|;
name|ioformatted
operator|=
name|UNFORMATTED
expr_stmt|;
name|ok
operator|=
name|NO
expr_stmt|;
block|}
block|}
else|else
name|fmtp
operator|=
name|NULL
expr_stmt|;
name|endfmt
label|:
if|if
condition|(
name|intfile
condition|)
block|{
if|if
condition|(
name|ioformatted
operator|==
name|UNFORMATTED
condition|)
block|{
name|err
argument_list|(
literal|"unformatted internal I/O not allowed"
argument_list|)
expr_stmt|;
name|ok
operator|=
name|NO
expr_stmt|;
block|}
if|if
condition|(
name|recp
condition|)
block|{
name|err
argument_list|(
literal|"direct internal I/O not allowed"
argument_list|)
expr_stmt|;
name|ok
operator|=
name|NO
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|sequential
operator|&&
name|ioformatted
operator|==
name|LISTDIRECTED
condition|)
block|{
name|err
argument_list|(
literal|"direct list-directed I/O not allowed"
argument_list|)
expr_stmt|;
name|ok
operator|=
name|NO
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|sequential
operator|&&
name|ioformatted
operator|==
name|NAMEDIRECTED
condition|)
block|{
name|err
argument_list|(
literal|"direct namelist I/O not allowed"
argument_list|)
expr_stmt|;
name|ok
operator|=
name|NO
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ok
condition|)
block|{
name|statstruct
operator|=
name|NO
expr_stmt|;
return|return;
block|}
comment|/*    Now put out the I/O structure, statically if all the clauses    are constants, dynamically otherwise */
if|if
condition|(
name|intfile
condition|)
block|{
name|ios
operator|=
name|io_stuff
operator|+
name|iostmt
expr_stmt|;
name|iostmt1
operator|=
name|IOREAD
expr_stmt|;
block|}
else|else
block|{
name|ios
operator|=
name|io_stuff
expr_stmt|;
name|iostmt1
operator|=
literal|0
expr_stmt|;
block|}
name|io_fields
operator|=
name|ios
operator|->
name|fields
expr_stmt|;
if|if
condition|(
name|statstruct
condition|)
block|{
name|ioblkp
operator|=
name|ALLOC
argument_list|(
name|Addrblock
argument_list|)
expr_stmt|;
name|ioblkp
operator|->
name|tag
operator|=
name|TADDR
expr_stmt|;
name|ioblkp
operator|->
name|vtype
operator|=
name|ios
operator|->
name|type
expr_stmt|;
name|ioblkp
operator|->
name|vclass
operator|=
name|CLVAR
expr_stmt|;
name|ioblkp
operator|->
name|vstg
operator|=
name|STGINIT
expr_stmt|;
name|ioblkp
operator|->
name|memno
operator|=
operator|++
name|lastvarno
expr_stmt|;
name|ioblkp
operator|->
name|memoffset
operator|=
name|ICON
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|ioblkp
operator|->
name|uname_tag
operator|=
name|UNAM_IDENT
expr_stmt|;
name|new_iob_data
argument_list|(
name|ios
argument_list|,
name|temp_name
argument_list|(
literal|"io_"
argument_list|,
name|lastvarno
argument_list|,
name|ioblkp
operator|->
name|user
operator|.
name|ident
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|ioblkp
operator|=
name|io_structs
index|[
name|iostmt1
index|]
operator|)
condition|)
name|io_structs
index|[
name|iostmt1
index|]
operator|=
name|ioblkp
operator|=
name|autovar
argument_list|(
literal|1
argument_list|,
name|ios
operator|->
name|type
argument_list|,
name|ENULL
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|ioset
argument_list|(
name|TYIOINT
argument_list|,
name|XERR
argument_list|,
name|ICON
argument_list|(
name|errbit
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|iostmt
operator|==
name|IOREAD
condition|)
name|ioset
argument_list|(
name|TYIOINT
argument_list|,
operator|(
name|intfile
condition|?
name|XIEND
else|:
name|XEND
operator|)
argument_list|,
name|ICON
argument_list|(
name|endbit
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|intfile
condition|)
block|{
name|ioset
argument_list|(
name|TYIOINT
argument_list|,
name|XIRNUM
argument_list|,
name|nump
argument_list|)
expr_stmt|;
name|ioset
argument_list|(
name|TYIOINT
argument_list|,
name|XIRLEN
argument_list|,
name|cpexpr
argument_list|(
name|unitp
operator|->
name|vleng
argument_list|)
argument_list|)
expr_stmt|;
name|ioseta
argument_list|(
name|XIUNIT
argument_list|,
name|unitp
argument_list|)
expr_stmt|;
block|}
else|else
name|ioset
argument_list|(
name|TYIOINT
argument_list|,
name|XUNIT
argument_list|,
operator|(
name|expptr
operator|)
name|unitp
argument_list|)
expr_stmt|;
if|if
condition|(
name|recp
condition|)
name|ioset
argument_list|(
name|TYIOINT
argument_list|,
comment|/* intfile ? XIREC : */
name|XREC
argument_list|,
operator|(
name|expptr
operator|)
name|recp
argument_list|)
expr_stmt|;
if|if
condition|(
name|varfmt
condition|)
name|ioseta
argument_list|(
name|intfile
condition|?
name|XIFMT
else|:
name|XFMT
argument_list|,
name|fmtp
argument_list|)
expr_stmt|;
else|else
name|ioset
argument_list|(
name|TYADDR
argument_list|,
name|intfile
condition|?
name|XIFMT
else|:
name|XFMT
argument_list|,
operator|(
name|expptr
operator|)
name|fmtp
argument_list|)
expr_stmt|;
name|ioroutine
index|[
literal|0
index|]
operator|=
literal|'s'
expr_stmt|;
name|ioroutine
index|[
literal|1
index|]
operator|=
literal|'_'
expr_stmt|;
name|ioroutine
index|[
literal|2
index|]
operator|=
name|iostmt
operator|==
name|IOREAD
condition|?
literal|'r'
else|:
literal|'w'
expr_stmt|;
name|ioroutine
index|[
literal|3
index|]
operator|=
literal|"ds"
index|[
name|sequential
index|]
expr_stmt|;
name|ioroutine
index|[
literal|4
index|]
operator|=
literal|"ufln"
index|[
name|ioformatted
index|]
expr_stmt|;
name|ioroutine
index|[
literal|5
index|]
operator|=
literal|"ei"
index|[
name|intfile
index|]
expr_stmt|;
name|ioroutine
index|[
literal|6
index|]
operator|=
literal|'\0'
expr_stmt|;
name|putiocall
argument_list|(
name|call1
argument_list|(
name|TYINT
argument_list|,
name|ioroutine
argument_list|,
name|cpexpr
argument_list|(
operator|(
name|expptr
operator|)
name|ioblkp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|statstruct
condition|)
block|{
name|frexpr
argument_list|(
operator|(
name|expptr
operator|)
name|ioblkp
argument_list|)
expr_stmt|;
name|statstruct
operator|=
name|NO
expr_stmt|;
name|ioblkp
operator|=
literal|0
expr_stmt|;
comment|/* unnecessary */
block|}
block|}
end_function

begin_function
name|LOCAL
name|void
name|dofopen
parameter_list|(
name|Void
parameter_list|)
block|{
specifier|register
name|expptr
name|p
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|V
argument_list|(
name|IOSUNIT
argument_list|)
operator|)
operator|&&
name|ISINT
argument_list|(
name|p
operator|->
name|headblock
operator|.
name|vtype
argument_list|)
condition|)
name|ioset
argument_list|(
name|TYIOINT
argument_list|,
name|XUNIT
argument_list|,
name|cpexpr
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|err
argument_list|(
literal|"bad unit in open"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|V
argument_list|(
name|IOSFILE
argument_list|)
operator|)
condition|)
if|if
condition|(
name|p
operator|->
name|headblock
operator|.
name|vtype
operator|==
name|TYCHAR
condition|)
name|ioset
argument_list|(
name|TYIOINT
argument_list|,
name|XFNAMELEN
argument_list|,
name|cpexpr
argument_list|(
name|p
operator|->
name|headblock
operator|.
name|vleng
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|err
argument_list|(
literal|"bad file in open"
argument_list|)
expr_stmt|;
name|iosetc
argument_list|(
name|XFNAME
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|=
name|V
argument_list|(
name|IOSRECL
argument_list|)
condition|)
if|if
condition|(
name|ISINT
argument_list|(
name|p
operator|->
name|headblock
operator|.
name|vtype
argument_list|)
condition|)
name|ioset
argument_list|(
name|TYIOINT
argument_list|,
name|XRECLEN
argument_list|,
name|cpexpr
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|err
argument_list|(
literal|"bad recl"
argument_list|)
expr_stmt|;
else|else
name|ioset
argument_list|(
name|TYIOINT
argument_list|,
name|XRECLEN
argument_list|,
name|ICON
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|iosetc
argument_list|(
name|XSTATUS
argument_list|,
name|V
argument_list|(
name|IOSSTATUS
argument_list|)
argument_list|)
expr_stmt|;
name|iosetc
argument_list|(
name|XACCESS
argument_list|,
name|V
argument_list|(
name|IOSACCESS
argument_list|)
argument_list|)
expr_stmt|;
name|iosetc
argument_list|(
name|XFORMATTED
argument_list|,
name|V
argument_list|(
name|IOSFORM
argument_list|)
argument_list|)
expr_stmt|;
name|iosetc
argument_list|(
name|XBLANK
argument_list|,
name|V
argument_list|(
name|IOSBLANK
argument_list|)
argument_list|)
expr_stmt|;
name|putiocall
argument_list|(
name|call1
argument_list|(
name|TYINT
argument_list|,
literal|"f_open"
argument_list|,
name|cpexpr
argument_list|(
operator|(
name|expptr
operator|)
name|ioblkp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|LOCAL
name|void
name|dofclose
parameter_list|(
name|Void
parameter_list|)
block|{
specifier|register
name|expptr
name|p
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|V
argument_list|(
name|IOSUNIT
argument_list|)
operator|)
operator|&&
name|ISINT
argument_list|(
name|p
operator|->
name|headblock
operator|.
name|vtype
argument_list|)
condition|)
block|{
name|ioset
argument_list|(
name|TYIOINT
argument_list|,
name|XUNIT
argument_list|,
name|cpexpr
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|iosetc
argument_list|(
name|XCLSTATUS
argument_list|,
name|V
argument_list|(
name|IOSSTATUS
argument_list|)
argument_list|)
expr_stmt|;
name|putiocall
argument_list|(
name|call1
argument_list|(
name|TYINT
argument_list|,
literal|"f_clos"
argument_list|,
name|cpexpr
argument_list|(
operator|(
name|expptr
operator|)
name|ioblkp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|err
argument_list|(
literal|"bad unit in close statement"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|LOCAL
name|void
name|dofinquire
parameter_list|(
name|Void
parameter_list|)
block|{
specifier|register
name|expptr
name|p
decl_stmt|;
if|if
condition|(
name|p
operator|=
name|V
argument_list|(
name|IOSUNIT
argument_list|)
condition|)
block|{
if|if
condition|(
name|V
argument_list|(
name|IOSFILE
argument_list|)
condition|)
name|err
argument_list|(
literal|"inquire by unit or by file, not both"
argument_list|)
expr_stmt|;
name|ioset
argument_list|(
name|TYIOINT
argument_list|,
name|XUNIT
argument_list|,
name|cpexpr
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|V
argument_list|(
name|IOSFILE
argument_list|)
condition|)
name|err
argument_list|(
literal|"must inquire by unit or by file"
argument_list|)
expr_stmt|;
name|iosetlc
argument_list|(
name|IOSFILE
argument_list|,
name|XFILE
argument_list|,
name|XFILELEN
argument_list|)
expr_stmt|;
name|iosetip
argument_list|(
name|IOSEXISTS
argument_list|,
name|XEXISTS
argument_list|)
expr_stmt|;
name|iosetip
argument_list|(
name|IOSOPENED
argument_list|,
name|XOPEN
argument_list|)
expr_stmt|;
name|iosetip
argument_list|(
name|IOSNUMBER
argument_list|,
name|XNUMBER
argument_list|)
expr_stmt|;
name|iosetip
argument_list|(
name|IOSNAMED
argument_list|,
name|XNAMED
argument_list|)
expr_stmt|;
name|iosetlc
argument_list|(
name|IOSNAME
argument_list|,
name|XNAME
argument_list|,
name|XNAMELEN
argument_list|)
expr_stmt|;
name|iosetlc
argument_list|(
name|IOSACCESS
argument_list|,
name|XQACCESS
argument_list|,
name|XQACCLEN
argument_list|)
expr_stmt|;
name|iosetlc
argument_list|(
name|IOSSEQUENTIAL
argument_list|,
name|XSEQ
argument_list|,
name|XSEQLEN
argument_list|)
expr_stmt|;
name|iosetlc
argument_list|(
name|IOSDIRECT
argument_list|,
name|XDIRECT
argument_list|,
name|XDIRLEN
argument_list|)
expr_stmt|;
name|iosetlc
argument_list|(
name|IOSFORM
argument_list|,
name|XFORM
argument_list|,
name|XFORMLEN
argument_list|)
expr_stmt|;
name|iosetlc
argument_list|(
name|IOSFORMATTED
argument_list|,
name|XFMTED
argument_list|,
name|XFMTEDLEN
argument_list|)
expr_stmt|;
name|iosetlc
argument_list|(
name|IOSUNFORMATTED
argument_list|,
name|XUNFMT
argument_list|,
name|XUNFMTLEN
argument_list|)
expr_stmt|;
name|iosetip
argument_list|(
name|IOSRECL
argument_list|,
name|XQRECL
argument_list|)
expr_stmt|;
name|iosetip
argument_list|(
name|IOSNEXTREC
argument_list|,
name|XNEXTREC
argument_list|)
expr_stmt|;
name|iosetlc
argument_list|(
name|IOSBLANK
argument_list|,
name|XQBLANK
argument_list|,
name|XQBLANKLEN
argument_list|)
expr_stmt|;
name|putiocall
argument_list|(
name|call1
argument_list|(
name|TYINT
argument_list|,
literal|"f_inqu"
argument_list|,
name|cpexpr
argument_list|(
operator|(
name|expptr
operator|)
name|ioblkp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|LOCAL
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|dofmove
parameter_list|(
name|subname
parameter_list|)
name|char
modifier|*
name|subname
decl_stmt|;
else|#
directive|else
function|dofmove
parameter_list|(
name|char
modifier|*
name|subname
parameter_list|)
endif|#
directive|endif
block|{
specifier|register
name|expptr
name|p
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|V
argument_list|(
name|IOSUNIT
argument_list|)
operator|)
operator|&&
name|ISINT
argument_list|(
name|p
operator|->
name|headblock
operator|.
name|vtype
argument_list|)
condition|)
block|{
name|ioset
argument_list|(
name|TYIOINT
argument_list|,
name|XUNIT
argument_list|,
name|cpexpr
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|putiocall
argument_list|(
name|call1
argument_list|(
name|TYINT
argument_list|,
name|subname
argument_list|,
name|cpexpr
argument_list|(
operator|(
name|expptr
operator|)
name|ioblkp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|err
argument_list|(
literal|"bad unit in I/O motion statement"
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|ioset_assign
init|=
name|OPASSIGN
decl_stmt|;
end_decl_stmt

begin_function
name|LOCAL
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|ioset
parameter_list|(
name|type
parameter_list|,
name|offset
parameter_list|,
name|p
parameter_list|)
name|int
name|type
decl_stmt|;
name|int
name|offset
decl_stmt|;
specifier|register
name|expptr
name|p
decl_stmt|;
else|#
directive|else
function|ioset
parameter_list|(
name|int
name|type
parameter_list|,
name|int
name|offset
parameter_list|,
specifier|register
name|expptr
name|p
parameter_list|)
endif|#
directive|endif
block|{
name|offset
operator|/=
name|SZLONG
expr_stmt|;
if|if
condition|(
name|statstruct
operator|&&
name|ISCONST
argument_list|(
name|p
argument_list|)
condition|)
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|TYADDR
case|:
comment|/* stmt label */
name|s
operator|=
literal|"fmt_"
expr_stmt|;
break|break;
case|case
name|TYIOINT
case|:
name|s
operator|=
literal|""
expr_stmt|;
break|break;
default|default:
name|badtype
argument_list|(
literal|"ioset"
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
name|iob_list
operator|->
name|fields
index|[
name|offset
index|]
operator|=
name|string_num
argument_list|(
name|s
argument_list|,
name|p
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
argument_list|)
expr_stmt|;
name|frexpr
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|register
name|Addrp
name|q
decl_stmt|;
name|q
operator|=
name|ALLOC
argument_list|(
name|Addrblock
argument_list|)
expr_stmt|;
name|q
operator|->
name|tag
operator|=
name|TADDR
expr_stmt|;
name|q
operator|->
name|vtype
operator|=
name|type
expr_stmt|;
name|q
operator|->
name|vstg
operator|=
name|STGAUTO
expr_stmt|;
name|q
operator|->
name|ntempelt
operator|=
literal|1
expr_stmt|;
name|q
operator|->
name|isarray
operator|=
literal|0
expr_stmt|;
name|q
operator|->
name|memoffset
operator|=
name|ICON
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|q
operator|->
name|uname_tag
operator|=
name|UNAM_IDENT
expr_stmt|;
name|sprintf
argument_list|(
name|q
operator|->
name|user
operator|.
name|ident
argument_list|,
literal|"%s.%s"
argument_list|,
name|statstruct
condition|?
name|iob_list
operator|->
name|name
else|:
name|ioblkp
operator|->
name|user
operator|.
name|ident
argument_list|,
name|io_fields
index|[
name|offset
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|TYADDR
operator|&&
name|p
operator|->
name|tag
operator|==
name|TCONST
operator|&&
name|p
operator|->
name|constblock
operator|.
name|vtype
operator|==
name|TYADDR
condition|)
block|{
comment|/* kludge */
specifier|register
name|Addrp
name|p1
decl_stmt|;
name|p1
operator|=
name|ALLOC
argument_list|(
name|Addrblock
argument_list|)
expr_stmt|;
name|p1
operator|->
name|tag
operator|=
name|TADDR
expr_stmt|;
name|p1
operator|->
name|vtype
operator|=
name|type
expr_stmt|;
name|p1
operator|->
name|vstg
operator|=
name|STGAUTO
expr_stmt|;
comment|/* wrong, but who cares? */
name|p1
operator|->
name|ntempelt
operator|=
literal|1
expr_stmt|;
name|p1
operator|->
name|isarray
operator|=
literal|0
expr_stmt|;
name|p1
operator|->
name|memoffset
operator|=
name|ICON
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|p1
operator|->
name|uname_tag
operator|=
name|UNAM_IDENT
expr_stmt|;
name|sprintf
argument_list|(
name|p1
operator|->
name|user
operator|.
name|ident
argument_list|,
literal|"fmt_%ld"
argument_list|,
name|p
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
argument_list|)
expr_stmt|;
name|frexpr
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
name|expptr
operator|)
name|p1
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|==
name|TYADDR
operator|&&
name|p
operator|->
name|headblock
operator|.
name|vtype
operator|==
name|TYCHAR
condition|)
name|q
operator|->
name|vtype
operator|=
name|TYCHAR
expr_stmt|;
name|putexpr
argument_list|(
name|mkexpr
argument_list|(
name|ioset_assign
argument_list|,
operator|(
name|expptr
operator|)
name|q
argument_list|,
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|LOCAL
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|iosetc
parameter_list|(
name|offset
parameter_list|,
name|p
parameter_list|)
name|int
name|offset
decl_stmt|;
specifier|register
name|expptr
name|p
decl_stmt|;
else|#
directive|else
function|iosetc
parameter_list|(
name|int
name|offset
parameter_list|,
specifier|register
name|expptr
name|p
parameter_list|)
endif|#
directive|endif
block|{
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|ioset
argument_list|(
name|TYADDR
argument_list|,
name|offset
argument_list|,
name|ICON
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|->
name|headblock
operator|.
name|vtype
operator|==
name|TYCHAR
condition|)
block|{
name|p
operator|=
name|putx
argument_list|(
name|fixtype
argument_list|(
operator|(
name|expptr
operator|)
name|putchop
argument_list|(
name|cpexpr
argument_list|(
name|p
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ioset
argument_list|(
name|TYADDR
argument_list|,
name|offset
argument_list|,
name|addrof
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|err
argument_list|(
literal|"non-character control clause"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|LOCAL
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|ioseta
parameter_list|(
name|offset
parameter_list|,
name|p
parameter_list|)
name|int
name|offset
decl_stmt|;
specifier|register
name|Addrp
name|p
decl_stmt|;
else|#
directive|else
function|ioseta
parameter_list|(
name|int
name|offset
parameter_list|,
specifier|register
name|Addrp
name|p
parameter_list|)
endif|#
directive|endif
block|{
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|s1
decl_stmt|;
specifier|static
name|char
name|who
index|[]
init|=
literal|"ioseta"
decl_stmt|;
name|expptr
name|e
decl_stmt|,
name|mo
decl_stmt|;
name|Namep
name|np
decl_stmt|;
name|ftnint
name|ci
decl_stmt|;
name|int
name|k
decl_stmt|;
name|char
name|buf
index|[
literal|24
index|]
decl_stmt|,
name|buf1
index|[
literal|24
index|]
decl_stmt|;
name|Extsym
modifier|*
name|comm
decl_stmt|;
specifier|extern
name|int
name|usedefsforcommon
decl_stmt|;
if|if
condition|(
name|statstruct
condition|)
block|{
if|if
condition|(
operator|!
name|p
condition|)
return|return;
if|if
condition|(
name|p
operator|->
name|tag
operator|!=
name|TADDR
condition|)
name|badtag
argument_list|(
name|who
argument_list|,
name|p
operator|->
name|tag
argument_list|)
expr_stmt|;
name|offset
operator|/=
name|SZLONG
expr_stmt|;
switch|switch
condition|(
name|p
operator|->
name|uname_tag
condition|)
block|{
case|case
name|UNAM_NAME
case|:
name|mo
operator|=
name|p
operator|->
name|memoffset
expr_stmt|;
if|if
condition|(
name|mo
operator|->
name|tag
operator|!=
name|TCONST
condition|)
name|badtag
argument_list|(
literal|"ioseta/memoffset"
argument_list|,
name|mo
operator|->
name|tag
argument_list|)
expr_stmt|;
name|np
operator|=
name|p
operator|->
name|user
operator|.
name|name
expr_stmt|;
name|np
operator|->
name|visused
operator|=
literal|1
expr_stmt|;
name|ci
operator|=
name|mo
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
operator|-
name|np
operator|->
name|voffset
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|vstg
operator|==
name|STGCOMMON
operator|&&
operator|!
name|np
operator|->
name|vcommequiv
operator|&&
operator|!
name|usedefsforcommon
condition|)
block|{
name|comm
operator|=
operator|&
name|extsymtab
index|[
name|np
operator|->
name|vardesc
operator|.
name|varno
index|]
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d."
argument_list|,
name|comm
operator|->
name|curno
argument_list|)
expr_stmt|;
name|k
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
operator|+
name|strlen
argument_list|(
name|comm
operator|->
name|cextname
argument_list|)
operator|+
name|strlen
argument_list|(
name|np
operator|->
name|cvarname
argument_list|)
expr_stmt|;
if|if
condition|(
name|ci
condition|)
block|{
name|sprintf
argument_list|(
name|buf1
argument_list|,
literal|"+%ld"
argument_list|,
name|ci
argument_list|)
expr_stmt|;
name|k
operator|+=
name|strlen
argument_list|(
name|buf1
argument_list|)
expr_stmt|;
block|}
else|else
name|buf1
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|s
operator|=
name|mem
argument_list|(
name|k
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|s
argument_list|,
literal|"%s%s%s%s"
argument_list|,
name|comm
operator|->
name|cextname
argument_list|,
name|buf
argument_list|,
name|np
operator|->
name|cvarname
argument_list|,
name|buf1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ci
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%ld"
argument_list|,
name|ci
argument_list|)
expr_stmt|;
name|s1
operator|=
name|p
operator|->
name|user
operator|.
name|name
operator|->
name|cvarname
expr_stmt|;
name|k
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
operator|+
name|strlen
argument_list|(
name|s1
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|s
operator|=
name|mem
argument_list|(
name|k
operator|+
literal|2
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|"%s+%s"
argument_list|,
name|s1
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
else|else
name|s
operator|=
name|cpstring
argument_list|(
name|np
operator|->
name|cvarname
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNAM_CONST
case|:
name|s
operator|=
name|tostring
argument_list|(
name|p
operator|->
name|user
operator|.
name|Const
operator|.
name|ccp1
operator|.
name|ccp0
argument_list|,
operator|(
name|int
operator|)
name|p
operator|->
name|vleng
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
argument_list|)
expr_stmt|;
break|break;
default|default:
name|badthing
argument_list|(
literal|"uname_tag"
argument_list|,
name|who
argument_list|,
name|p
operator|->
name|uname_tag
argument_list|)
expr_stmt|;
block|}
comment|/* kludge for Hollerith */
if|if
condition|(
name|p
operator|->
name|vtype
operator|!=
name|TYCHAR
condition|)
block|{
name|s1
operator|=
name|mem
argument_list|(
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|10
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|s1
argument_list|,
literal|"(char *)%s%s"
argument_list|,
name|p
operator|->
name|isarray
condition|?
literal|""
else|:
literal|"&"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
name|s1
expr_stmt|;
block|}
name|iob_list
operator|->
name|fields
index|[
name|offset
index|]
operator|=
name|s
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|p
condition|)
name|e
operator|=
name|ICON
argument_list|(
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|->
name|vtype
operator|!=
name|TYCHAR
condition|)
block|{
name|NOEXT
argument_list|(
literal|"non-character variable as format or internal unit"
argument_list|)
expr_stmt|;
name|e
operator|=
name|mkexpr
argument_list|(
name|OPCHARCAST
argument_list|,
operator|(
name|expptr
operator|)
name|p
argument_list|,
name|ENULL
argument_list|)
expr_stmt|;
block|}
else|else
name|e
operator|=
name|addrof
argument_list|(
operator|(
name|expptr
operator|)
name|p
argument_list|)
expr_stmt|;
name|ioset
argument_list|(
name|TYADDR
argument_list|,
name|offset
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|LOCAL
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|iosetip
parameter_list|(
name|i
parameter_list|,
name|offset
parameter_list|)
name|int
name|i
decl_stmt|;
name|int
name|offset
decl_stmt|;
else|#
directive|else
function|iosetip
parameter_list|(
name|int
name|i
parameter_list|,
name|int
name|offset
parameter_list|)
endif|#
directive|endif
block|{
specifier|register
name|expptr
name|p
decl_stmt|;
if|if
condition|(
name|p
operator|=
name|V
argument_list|(
name|i
argument_list|)
condition|)
if|if
condition|(
name|p
operator|->
name|tag
operator|==
name|TADDR
operator|&&
name|ONEOF
argument_list|(
name|p
operator|->
name|addrblock
operator|.
name|vtype
argument_list|,
name|inqmask
argument_list|)
condition|)
block|{
name|ioset_assign
operator|=
name|OPASSIGNI
expr_stmt|;
name|ioset
argument_list|(
name|TYADDR
argument_list|,
name|offset
argument_list|,
name|addrof
argument_list|(
name|cpexpr
argument_list|(
name|p
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ioset_assign
operator|=
name|OPASSIGN
expr_stmt|;
block|}
else|else
name|errstr
argument_list|(
literal|"impossible inquire parameter %s"
argument_list|,
name|ioc
index|[
name|i
index|]
operator|.
name|iocname
argument_list|)
expr_stmt|;
else|else
name|ioset
argument_list|(
name|TYADDR
argument_list|,
name|offset
argument_list|,
name|ICON
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|LOCAL
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|iosetlc
parameter_list|(
name|i
parameter_list|,
name|offp
parameter_list|,
name|offl
parameter_list|)
name|int
name|i
decl_stmt|;
name|int
name|offp
decl_stmt|;
name|int
name|offl
decl_stmt|;
else|#
directive|else
function|iosetlc
parameter_list|(
name|int
name|i
parameter_list|,
name|int
name|offp
parameter_list|,
name|int
name|offl
parameter_list|)
endif|#
directive|endif
block|{
specifier|register
name|expptr
name|p
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|V
argument_list|(
name|i
argument_list|)
operator|)
operator|&&
name|p
operator|->
name|headblock
operator|.
name|vtype
operator|==
name|TYCHAR
condition|)
name|ioset
argument_list|(
name|TYIOINT
argument_list|,
name|offl
argument_list|,
name|cpexpr
argument_list|(
name|p
operator|->
name|headblock
operator|.
name|vleng
argument_list|)
argument_list|)
expr_stmt|;
name|iosetc
argument_list|(
name|offp
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

