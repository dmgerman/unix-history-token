begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**************************************************************** Copyright 1990, 1992 - 1995 by AT&T Bell Laboratories and Bellcore.  Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that the copyright notice and this permission notice and warranty disclaimer appear in supporting documentation, and that the names of AT&T Bell Laboratories or Bellcore or any of their entities not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  AT&T and Bellcore disclaim all warranties with regard to this software, including all implied warranties of merchantability and fitness.  In no event shall AT&T or Bellcore be liable for any special, indirect or consequential damages or any damages whatsoever resulting from loss of use, data or profits, whether in an action of contract, negligence or other tortious action, arising out of or in connection with the use or performance of this software. ****************************************************************/
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"tokdefs.h"
end_include

begin_include
include|#
directive|include
file|"p1defs.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|NO_EOF_CHAR_CHECK
end_ifdef

begin_undef
undef|#
directive|undef
name|EOF_CHAR
end_undef

begin_else
else|#
directive|else
end_else

begin_ifndef
ifndef|#
directive|ifndef
name|EOF_CHAR
end_ifndef

begin_define
define|#
directive|define
name|EOF_CHAR
value|26
end_define

begin_comment
comment|/* ASCII control-Z */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|BLANK
value|' '
end_define

begin_define
define|#
directive|define
name|MYQUOTE
value|(2)
end_define

begin_define
define|#
directive|define
name|SEOF
value|0
end_define

begin_comment
comment|/* card types */
end_comment

begin_define
define|#
directive|define
name|STEOF
value|1
end_define

begin_define
define|#
directive|define
name|STINITIAL
value|2
end_define

begin_define
define|#
directive|define
name|STCONTINUE
value|3
end_define

begin_comment
comment|/* lex states */
end_comment

begin_define
define|#
directive|define
name|NEWSTMT
value|1
end_define

begin_define
define|#
directive|define
name|FIRSTTOKEN
value|2
end_define

begin_define
define|#
directive|define
name|OTHERTOKEN
value|3
end_define

begin_define
define|#
directive|define
name|RETEOS
value|4
end_define

begin_decl_stmt
name|LOCAL
name|int
name|stkey
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Type of the current statement (DO, END, IF, etc) */
end_comment

begin_decl_stmt
specifier|static
name|int
name|needwkey
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ftnint
name|yystno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|flag
name|intonly
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|new_dcl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LOCAL
name|long
name|int
name|stno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LOCAL
name|long
name|int
name|nxtstno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Statement label */
end_comment

begin_decl_stmt
name|LOCAL
name|int
name|parlev
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Parentheses level */
end_comment

begin_decl_stmt
name|LOCAL
name|int
name|parseen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LOCAL
name|int
name|expcom
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LOCAL
name|int
name|expeql
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LOCAL
name|char
modifier|*
name|nextch
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LOCAL
name|char
modifier|*
name|lastch
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LOCAL
name|char
modifier|*
name|nextcd
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LOCAL
name|char
modifier|*
name|endcd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LOCAL
name|long
name|prevlin
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LOCAL
name|long
name|thislin
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LOCAL
name|int
name|code
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Card type; INITIAL, CONTINUE or EOF */
end_comment

begin_decl_stmt
name|LOCAL
name|int
name|lexstate
init|=
name|NEWSTMT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LOCAL
name|char
modifier|*
name|sbuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Main buffer for Fortran source input. */
end_comment

begin_decl_stmt
name|LOCAL
name|char
modifier|*
name|send
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Was = sbuf+20*66 with sbuf[1390]. */
end_comment

begin_decl_stmt
name|LOCAL
name|int
name|maxcont
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LOCAL
name|int
name|nincl
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current number of include files */
end_comment

begin_decl_stmt
name|LOCAL
name|long
name|firstline
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LOCAL
name|char
modifier|*
name|laststb
decl_stmt|,
modifier|*
name|stb0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|addftnsrc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|linestart
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LOCAL
name|int
name|ncont
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LOCAL
name|char
name|comstart
index|[
name|Table_size
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|USC
value|(unsigned char *)
end_define

begin_decl_stmt
specifier|static
name|char
name|anum_buf
index|[
name|Table_size
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|isalnum_
parameter_list|(
name|x
parameter_list|)
value|anum_buf[x]
end_define

begin_define
define|#
directive|define
name|isalpha_
parameter_list|(
name|x
parameter_list|)
value|(anum_buf[x] == 1)
end_define

begin_define
define|#
directive|define
name|COMMENT_BUF_STORE
value|4088
end_define

begin_typedef
typedef|typedef
struct|struct
name|comment_buf
block|{
name|struct
name|comment_buf
modifier|*
name|next
decl_stmt|;
name|char
modifier|*
name|last
decl_stmt|;
name|char
name|buf
index|[
name|COMMENT_BUF_STORE
index|]
decl_stmt|;
block|}
name|comment_buf
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|comment_buf
modifier|*
name|cbfirst
decl_stmt|,
modifier|*
name|cbcur
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|cbinit
decl_stmt|,
modifier|*
name|cbnext
decl_stmt|,
modifier|*
name|cblast
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|flush_comments
name|Argdcl
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|flag
name|use_bs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|lastfile
init|=
literal|"??"
decl_stmt|,
modifier|*
name|lastfile0
init|=
literal|"?"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|fbuf
index|[
name|P1_FILENAME_MAX
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|lastline
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|putlineno
parameter_list|(
name|Void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Comment buffering data  	Comments are kept in a list until the statement before them has    been parsed.  This list is implemented with the above comment_buf    structure and the pointers cbnext and cblast.  	The comments are stored with terminating NULL, and no other    intervening space.  The last few bytes of each block are likely to    remain unused. */
end_comment

begin_comment
comment|/* struct Inclfile   holds the state information for each include file */
end_comment

begin_struct
struct|struct
name|Inclfile
block|{
name|struct
name|Inclfile
modifier|*
name|inclnext
decl_stmt|;
name|FILEP
name|inclfp
decl_stmt|;
name|char
modifier|*
name|inclname
decl_stmt|;
name|int
name|incllno
decl_stmt|;
name|char
modifier|*
name|incllinp
decl_stmt|;
name|int
name|incllen
decl_stmt|;
name|int
name|inclcode
decl_stmt|;
name|ftnint
name|inclstno
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|LOCAL
name|struct
name|Inclfile
modifier|*
name|inclp
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|Keylist
block|{
name|char
modifier|*
name|keyname
decl_stmt|;
name|int
name|keyval
decl_stmt|;
name|char
name|notinf66
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|Punctlist
block|{
name|char
name|punchar
decl_stmt|;
name|int
name|punval
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|Fmtlist
block|{
name|char
name|fmtchar
decl_stmt|;
name|int
name|fmtval
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|Dotlist
block|{
name|char
modifier|*
name|dotname
decl_stmt|;
name|int
name|dotval
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|LOCAL
name|struct
name|Keylist
modifier|*
name|keystart
index|[
literal|26
index|]
decl_stmt|,
modifier|*
name|keyend
index|[
literal|26
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* KEYWORD AND SPECIAL CHARACTER TABLES */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|Punctlist
name|puncts
index|[ ]
init|=
block|{
literal|'('
block|,
name|SLPAR
block|,
literal|')'
block|,
name|SRPAR
block|,
literal|'='
block|,
name|SEQUALS
block|,
literal|','
block|,
name|SCOMMA
block|,
literal|'+'
block|,
name|SPLUS
block|,
literal|'-'
block|,
name|SMINUS
block|,
literal|'*'
block|,
name|SSTAR
block|,
literal|'/'
block|,
name|SSLASH
block|,
literal|'$'
block|,
name|SCURRENCY
block|,
literal|':'
block|,
name|SCOLON
block|,
literal|'<'
block|,
name|SLT
block|,
literal|'>'
block|,
name|SGT
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LOCAL
name|struct
name|Dotlist
name|dots
index|[ ]
init|=
block|{
literal|"and."
block|,
name|SAND
block|,
literal|"or."
block|,
name|SOR
block|,
literal|"not."
block|,
name|SNOT
block|,
literal|"true."
block|,
name|STRUE
block|,
literal|"false."
block|,
name|SFALSE
block|,
literal|"eq."
block|,
name|SEQ
block|,
literal|"ne."
block|,
name|SNE
block|,
literal|"lt."
block|,
name|SLT
block|,
literal|"le."
block|,
name|SLE
block|,
literal|"gt."
block|,
name|SGT
block|,
literal|"ge."
block|,
name|SGE
block|,
literal|"neqv."
block|,
name|SNEQV
block|,
literal|"eqv."
block|,
name|SEQV
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LOCAL
name|struct
name|Keylist
name|keys
index|[ ]
init|=
block|{
block|{
literal|"assign"
block|,
name|SASSIGN
block|}
block|,
block|{
literal|"automatic"
block|,
name|SAUTOMATIC
block|,
name|YES
block|}
block|,
block|{
literal|"backspace"
block|,
name|SBACKSPACE
block|}
block|,
block|{
literal|"blockdata"
block|,
name|SBLOCK
block|}
block|,
block|{
literal|"byte"
block|,
name|SBYTE
block|}
block|,
block|{
literal|"call"
block|,
name|SCALL
block|}
block|,
block|{
literal|"character"
block|,
name|SCHARACTER
block|,
name|YES
block|}
block|,
block|{
literal|"close"
block|,
name|SCLOSE
block|,
name|YES
block|}
block|,
block|{
literal|"common"
block|,
name|SCOMMON
block|}
block|,
block|{
literal|"complex"
block|,
name|SCOMPLEX
block|}
block|,
block|{
literal|"continue"
block|,
name|SCONTINUE
block|}
block|,
block|{
literal|"data"
block|,
name|SDATA
block|}
block|,
block|{
literal|"dimension"
block|,
name|SDIMENSION
block|}
block|,
block|{
literal|"doubleprecision"
block|,
name|SDOUBLE
block|}
block|,
block|{
literal|"doublecomplex"
block|,
name|SDCOMPLEX
block|,
name|YES
block|}
block|,
block|{
literal|"elseif"
block|,
name|SELSEIF
block|,
name|YES
block|}
block|,
block|{
literal|"else"
block|,
name|SELSE
block|,
name|YES
block|}
block|,
block|{
literal|"endfile"
block|,
name|SENDFILE
block|}
block|,
block|{
literal|"endif"
block|,
name|SENDIF
block|,
name|YES
block|}
block|,
block|{
literal|"enddo"
block|,
name|SENDDO
block|,
name|YES
block|}
block|,
block|{
literal|"end"
block|,
name|SEND
block|}
block|,
block|{
literal|"entry"
block|,
name|SENTRY
block|,
name|YES
block|}
block|,
block|{
literal|"equivalence"
block|,
name|SEQUIV
block|}
block|,
block|{
literal|"external"
block|,
name|SEXTERNAL
block|}
block|,
block|{
literal|"format"
block|,
name|SFORMAT
block|}
block|,
block|{
literal|"function"
block|,
name|SFUNCTION
block|}
block|,
block|{
literal|"goto"
block|,
name|SGOTO
block|}
block|,
block|{
literal|"implicit"
block|,
name|SIMPLICIT
block|,
name|YES
block|}
block|,
block|{
literal|"include"
block|,
name|SINCLUDE
block|,
name|YES
block|}
block|,
block|{
literal|"inquire"
block|,
name|SINQUIRE
block|,
name|YES
block|}
block|,
block|{
literal|"intrinsic"
block|,
name|SINTRINSIC
block|,
name|YES
block|}
block|,
block|{
literal|"integer"
block|,
name|SINTEGER
block|}
block|,
block|{
literal|"logical"
block|,
name|SLOGICAL
block|}
block|,
block|{
literal|"namelist"
block|,
name|SNAMELIST
block|,
name|YES
block|}
block|,
block|{
literal|"none"
block|,
name|SUNDEFINED
block|,
name|YES
block|}
block|,
block|{
literal|"open"
block|,
name|SOPEN
block|,
name|YES
block|}
block|,
block|{
literal|"parameter"
block|,
name|SPARAM
block|,
name|YES
block|}
block|,
block|{
literal|"pause"
block|,
name|SPAUSE
block|}
block|,
block|{
literal|"print"
block|,
name|SPRINT
block|}
block|,
block|{
literal|"program"
block|,
name|SPROGRAM
block|,
name|YES
block|}
block|,
block|{
literal|"punch"
block|,
name|SPUNCH
block|,
name|YES
block|}
block|,
block|{
literal|"read"
block|,
name|SREAD
block|}
block|,
block|{
literal|"real"
block|,
name|SREAL
block|}
block|,
block|{
literal|"return"
block|,
name|SRETURN
block|}
block|,
block|{
literal|"rewind"
block|,
name|SREWIND
block|}
block|,
block|{
literal|"save"
block|,
name|SSAVE
block|,
name|YES
block|}
block|,
block|{
literal|"static"
block|,
name|SSTATIC
block|,
name|YES
block|}
block|,
block|{
literal|"stop"
block|,
name|SSTOP
block|}
block|,
block|{
literal|"subroutine"
block|,
name|SSUBROUTINE
block|}
block|,
block|{
literal|"then"
block|,
name|STHEN
block|,
name|YES
block|}
block|,
block|{
literal|"undefined"
block|,
name|SUNDEFINED
block|,
name|YES
block|}
block|,
block|{
literal|"while"
block|,
name|SWHILE
block|,
name|YES
block|}
block|,
block|{
literal|"write"
block|,
name|SWRITE
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|analyz
name|Argdcl
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|crunch
name|Argdcl
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|getcd
name|Argdcl
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|getcds
name|Argdcl
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|getkwd
name|Argdcl
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|gettok
name|Argdcl
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|store_comment
name|Argdcl
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LOCAL
name|char
modifier|*
name|stbuf
index|[
literal|3
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|int
ifdef|#
directive|ifdef
name|KR_headers
name|inilex
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
else|#
directive|else
function|inilex
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
endif|#
directive|endif
block|{
name|stbuf
index|[
literal|0
index|]
operator|=
name|Alloc
argument_list|(
literal|3
operator|*
name|P1_STMTBUFSIZE
argument_list|)
expr_stmt|;
name|stbuf
index|[
literal|1
index|]
operator|=
name|stbuf
index|[
literal|0
index|]
operator|+
name|P1_STMTBUFSIZE
expr_stmt|;
name|stbuf
index|[
literal|2
index|]
operator|=
name|stbuf
index|[
literal|1
index|]
operator|+
name|P1_STMTBUFSIZE
expr_stmt|;
name|nincl
operator|=
literal|0
expr_stmt|;
name|inclp
operator|=
name|NULL
expr_stmt|;
name|doinclude
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|lexstate
operator|=
name|NEWSTMT
expr_stmt|;
return|return
operator|(
name|NO
operator|)
return|;
block|}
end_function

begin_comment
comment|/* throw away the rest of the current line */
end_comment

begin_function
name|void
name|flline
parameter_list|(
name|Void
parameter_list|)
block|{
name|lexstate
operator|=
name|RETEOS
expr_stmt|;
block|}
end_function

begin_function
name|char
modifier|*
ifdef|#
directive|ifdef
name|KR_headers
name|lexline
parameter_list|(
name|n
parameter_list|)
name|int
modifier|*
name|n
decl_stmt|;
else|#
directive|else
function|lexline
parameter_list|(
name|int
modifier|*
name|n
parameter_list|)
endif|#
directive|endif
block|{
operator|*
name|n
operator|=
operator|(
name|lastch
operator|-
name|nextch
operator|)
operator|+
literal|1
expr_stmt|;
return|return
operator|(
name|nextch
operator|)
return|;
block|}
end_function

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|doinclude
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
else|#
directive|else
function|doinclude
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
endif|#
directive|endif
block|{
name|FILEP
name|fp
decl_stmt|;
name|struct
name|Inclfile
modifier|*
name|t
decl_stmt|;
name|char
modifier|*
name|name0
decl_stmt|,
modifier|*
name|lastslash
decl_stmt|,
modifier|*
name|s
decl_stmt|,
modifier|*
name|s0
decl_stmt|,
modifier|*
name|temp
decl_stmt|;
name|int
name|j
decl_stmt|,
name|k
decl_stmt|;
name|chainp
name|I
decl_stmt|;
specifier|extern
name|chainp
name|Iargs
decl_stmt|;
if|if
condition|(
name|inclp
condition|)
block|{
name|inclp
operator|->
name|incllno
operator|=
name|thislin
expr_stmt|;
name|inclp
operator|->
name|inclcode
operator|=
name|code
expr_stmt|;
name|inclp
operator|->
name|inclstno
operator|=
name|nxtstno
expr_stmt|;
if|if
condition|(
name|nextcd
condition|)
name|inclp
operator|->
name|incllinp
operator|=
name|copyn
argument_list|(
name|inclp
operator|->
name|incllen
operator|=
name|endcd
operator|-
name|nextcd
argument_list|,
name|nextcd
argument_list|)
expr_stmt|;
else|else
name|inclp
operator|->
name|incllinp
operator|=
literal|0
expr_stmt|;
block|}
name|nextcd
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|++
name|nincl
operator|>=
name|MAXINCLUDES
condition|)
name|Fatal
argument_list|(
literal|"includes nested too deep"
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|fp
operator|=
name|stdin
expr_stmt|;
elseif|else
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'/'
operator|||
name|inclp
operator|==
name|NULL
ifdef|#
directive|ifdef
name|MSDOS
operator|||
name|name
index|[
literal|0
index|]
operator|==
literal|'\\'
operator|||
name|name
index|[
literal|1
index|]
operator|==
literal|':'
endif|#
directive|endif
condition|)
name|fp
operator|=
name|fopen
argument_list|(
name|name
argument_list|,
name|textread
argument_list|)
expr_stmt|;
else|else
block|{
name|lastslash
operator|=
name|NULL
expr_stmt|;
name|s
operator|=
name|s0
operator|=
name|inclp
operator|->
name|inclname
expr_stmt|;
ifdef|#
directive|ifdef
name|MSDOS
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|':'
condition|)
name|lastslash
operator|=
name|s
operator|+
literal|1
expr_stmt|;
endif|#
directive|endif
for|for
control|(
init|;
operator|*
name|s
condition|;
operator|++
name|s
control|)
if|if
condition|(
operator|*
name|s
operator|==
literal|'/'
ifdef|#
directive|ifdef
name|MSDOS
operator|||
operator|*
name|s
operator|==
literal|'\\'
endif|#
directive|endif
condition|)
name|lastslash
operator|=
name|s
expr_stmt|;
name|name0
operator|=
name|name
expr_stmt|;
if|if
condition|(
name|lastslash
condition|)
block|{
name|k
operator|=
name|lastslash
operator|-
name|s0
operator|+
literal|1
expr_stmt|;
name|temp
operator|=
name|Alloc
argument_list|(
name|k
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|temp
argument_list|,
name|s0
argument_list|,
name|k
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|temp
operator|+
name|k
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|name
operator|=
name|temp
expr_stmt|;
block|}
name|fp
operator|=
name|fopen
argument_list|(
name|name
argument_list|,
name|textread
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fp
operator|&&
operator|(
name|I
operator|=
name|Iargs
operator|)
condition|)
block|{
name|k
operator|=
name|strlen
argument_list|(
name|name0
argument_list|)
operator|+
literal|2
expr_stmt|;
for|for
control|(
init|;
name|I
condition|;
name|I
operator|=
name|I
operator|->
name|nextp
control|)
block|{
name|j
operator|=
name|strlen
argument_list|(
name|s
operator|=
name|I
operator|->
name|datap
argument_list|)
expr_stmt|;
name|name
operator|=
name|Alloc
argument_list|(
name|j
operator|+
name|k
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|name
argument_list|,
name|s
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|s
index|[
name|j
operator|-
literal|1
index|]
condition|)
block|{
case|case
literal|'/'
case|:
ifdef|#
directive|ifdef
name|MSDOS
case|case
literal|':'
case|:
case|case
literal|'\\'
case|:
endif|#
directive|endif
break|break;
default|default:
name|name
index|[
name|j
operator|++
index|]
operator|=
literal|'/'
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|name
operator|+
name|j
argument_list|,
name|name0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|=
name|fopen
argument_list|(
name|name
argument_list|,
name|textread
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|name0
argument_list|)
expr_stmt|;
goto|goto
name|havefp
goto|;
block|}
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|name
operator|=
name|name0
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|fp
condition|)
block|{
name|havefp
label|:
name|t
operator|=
name|inclp
expr_stmt|;
name|inclp
operator|=
name|ALLOC
argument_list|(
name|Inclfile
argument_list|)
expr_stmt|;
name|inclp
operator|->
name|inclnext
operator|=
name|t
expr_stmt|;
name|prevlin
operator|=
name|thislin
operator|=
literal|0
expr_stmt|;
name|infname
operator|=
name|inclp
operator|->
name|inclname
operator|=
name|name
expr_stmt|;
name|infile
operator|=
name|inclp
operator|->
name|inclfp
operator|=
name|fp
expr_stmt|;
name|lastline
operator|=
literal|0
expr_stmt|;
name|putlineno
argument_list|()
expr_stmt|;
name|lastline
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"Cannot open file %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|LOCAL
name|int
name|popinclude
parameter_list|(
name|Void
parameter_list|)
block|{
name|struct
name|Inclfile
modifier|*
name|t
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|k
decl_stmt|;
if|if
condition|(
name|infile
operator|!=
name|stdin
condition|)
name|clf
argument_list|(
operator|&
name|infile
argument_list|,
name|infname
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Close the input file */
name|free
argument_list|(
name|infname
argument_list|)
expr_stmt|;
operator|--
name|nincl
expr_stmt|;
name|t
operator|=
name|inclp
operator|->
name|inclnext
expr_stmt|;
name|free
argument_list|(
operator|(
name|charptr
operator|)
name|inclp
argument_list|)
expr_stmt|;
name|inclp
operator|=
name|t
expr_stmt|;
if|if
condition|(
name|inclp
operator|==
name|NULL
condition|)
block|{
name|infname
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|NO
operator|)
return|;
block|}
name|infile
operator|=
name|inclp
operator|->
name|inclfp
expr_stmt|;
name|infname
operator|=
name|inclp
operator|->
name|inclname
expr_stmt|;
name|lineno
operator|=
name|prevlin
operator|=
name|thislin
operator|=
name|inclp
operator|->
name|incllno
expr_stmt|;
name|code
operator|=
name|inclp
operator|->
name|inclcode
expr_stmt|;
name|stno
operator|=
name|nxtstno
operator|=
name|inclp
operator|->
name|inclstno
expr_stmt|;
if|if
condition|(
name|inclp
operator|->
name|incllinp
condition|)
block|{
name|lastline
operator|=
literal|0
expr_stmt|;
name|putlineno
argument_list|()
expr_stmt|;
name|lastline
operator|=
name|lineno
expr_stmt|;
name|endcd
operator|=
name|nextcd
operator|=
name|sbuf
expr_stmt|;
name|k
operator|=
name|inclp
operator|->
name|incllen
expr_stmt|;
name|p
operator|=
name|inclp
operator|->
name|incllinp
expr_stmt|;
while|while
condition|(
operator|--
name|k
operator|>=
literal|0
condition|)
operator|*
name|endcd
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|free
argument_list|(
call|(
name|charptr
call|)
argument_list|(
name|inclp
operator|->
name|incllinp
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|nextcd
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|YES
operator|)
return|;
block|}
end_function

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|p1_line_number
parameter_list|(
name|line_number
parameter_list|)
name|long
name|line_number
decl_stmt|;
else|#
directive|else
function|p1_line_number
parameter_list|(
name|long
name|line_number
parameter_list|)
endif|#
directive|endif
block|{
if|if
condition|(
name|lastfile
operator|!=
name|lastfile0
condition|)
block|{
name|p1puts
argument_list|(
name|P1_FILENAME
argument_list|,
name|fbuf
argument_list|)
expr_stmt|;
name|lastfile0
operator|=
name|lastfile
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|pass1_file
argument_list|,
literal|"%d: %ld\n"
argument_list|,
name|P1_SET_LINE
argument_list|,
name|line_number
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|putlineno
parameter_list|(
name|Void
parameter_list|)
block|{
specifier|extern
name|int
name|gflag
decl_stmt|;
specifier|register
name|char
modifier|*
name|s0
decl_stmt|,
modifier|*
name|s1
decl_stmt|;
if|if
condition|(
name|gflag
condition|)
block|{
if|if
condition|(
name|lastline
condition|)
name|p1_line_number
argument_list|(
name|lastline
argument_list|)
expr_stmt|;
name|lastline
operator|=
name|firstline
expr_stmt|;
if|if
condition|(
name|lastfile
operator|!=
name|infname
condition|)
if|if
condition|(
name|lastfile
operator|=
name|infname
condition|)
block|{
name|strncpy
argument_list|(
name|fbuf
argument_list|,
name|lastfile
argument_list|,
sizeof|sizeof
argument_list|(
name|fbuf
argument_list|)
argument_list|)
expr_stmt|;
name|fbuf
index|[
sizeof|sizeof
argument_list|(
name|fbuf
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|fbuf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|addftnsrc
condition|)
block|{
if|if
condition|(
name|laststb
operator|&&
operator|*
name|laststb
condition|)
block|{
for|for
control|(
name|s1
operator|=
name|laststb
init|;
operator|*
name|s1
condition|;
name|s1
operator|++
control|)
block|{
for|for
control|(
name|s0
operator|=
name|s1
init|;
operator|*
name|s1
operator|!=
literal|'\n'
condition|;
name|s1
operator|++
control|)
if|if
condition|(
operator|*
name|s1
operator|==
literal|'*'
operator|&&
name|s1
index|[
literal|1
index|]
operator|==
literal|'/'
condition|)
operator|*
name|s1
operator|=
literal|'+'
expr_stmt|;
operator|*
name|s1
operator|=
literal|0
expr_stmt|;
name|p1puts
argument_list|(
name|P1_FORTRAN
argument_list|,
name|s0
argument_list|)
expr_stmt|;
block|}
operator|*
name|laststb
operator|=
literal|0
expr_stmt|;
comment|/* prevent trouble after EOF */
block|}
name|laststb
operator|=
name|stb0
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|yylex
parameter_list|(
name|Void
parameter_list|)
block|{
specifier|static
name|int
name|tokno
decl_stmt|;
name|int
name|retval
decl_stmt|;
switch|switch
condition|(
name|lexstate
condition|)
block|{
case|case
name|NEWSTMT
case|:
comment|/* need a new statement */
name|retval
operator|=
name|getcds
argument_list|()
expr_stmt|;
name|putlineno
argument_list|()
expr_stmt|;
if|if
condition|(
name|retval
operator|==
name|STEOF
condition|)
block|{
name|retval
operator|=
name|SEOF
expr_stmt|;
break|break;
block|}
comment|/* if getcds() == STEOF */
name|crunch
argument_list|()
expr_stmt|;
name|tokno
operator|=
literal|0
expr_stmt|;
name|lexstate
operator|=
name|FIRSTTOKEN
expr_stmt|;
name|yystno
operator|=
name|stno
expr_stmt|;
name|stno
operator|=
name|nxtstno
expr_stmt|;
name|toklen
operator|=
literal|0
expr_stmt|;
name|retval
operator|=
name|SLABEL
expr_stmt|;
break|break;
name|first
label|:
case|case
name|FIRSTTOKEN
case|:
comment|/* first step on a statement */
name|analyz
argument_list|()
expr_stmt|;
name|lexstate
operator|=
name|OTHERTOKEN
expr_stmt|;
name|tokno
operator|=
literal|1
expr_stmt|;
name|retval
operator|=
name|stkey
expr_stmt|;
break|break;
case|case
name|OTHERTOKEN
case|:
comment|/* return next token */
if|if
condition|(
name|nextch
operator|>
name|lastch
condition|)
goto|goto
name|reteos
goto|;
operator|++
name|tokno
expr_stmt|;
if|if
condition|(
operator|(
name|stkey
operator|==
name|SLOGIF
operator|||
name|stkey
operator|==
name|SELSEIF
operator|)
operator|&&
name|parlev
operator|==
literal|0
operator|&&
name|tokno
operator|>
literal|3
condition|)
goto|goto
name|first
goto|;
if|if
condition|(
name|stkey
operator|==
name|SASSIGN
operator|&&
name|tokno
operator|==
literal|3
operator|&&
name|nextch
operator|<
name|lastch
operator|&&
name|nextch
index|[
literal|0
index|]
operator|==
literal|'t'
operator|&&
name|nextch
index|[
literal|1
index|]
operator|==
literal|'o'
condition|)
block|{
name|nextch
operator|+=
literal|2
expr_stmt|;
name|retval
operator|=
name|STO
expr_stmt|;
break|break;
block|}
name|retval
operator|=
name|gettok
argument_list|()
expr_stmt|;
break|break;
name|reteos
label|:
case|case
name|RETEOS
case|:
name|lexstate
operator|=
name|NEWSTMT
expr_stmt|;
name|retval
operator|=
name|SEOS
expr_stmt|;
break|break;
default|default:
name|fatali
argument_list|(
literal|"impossible lexstate %d"
argument_list|,
name|lexstate
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|retval
operator|==
name|SEOF
condition|)
name|flush_comments
argument_list|()
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
name|LOCAL
name|void
name|contmax
parameter_list|(
name|Void
parameter_list|)
block|{
name|lineno
operator|=
name|thislin
expr_stmt|;
name|many
argument_list|(
literal|"continuation lines"
argument_list|,
literal|'C'
argument_list|,
name|maxcontin
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get Cards.     Returns STEOF or STINITIAL, never STCONTINUE.  Any continuation cards get merged into one long card (hence the size of the buffer named   sbuf)   */
end_comment

begin_function
name|LOCAL
name|int
name|getcds
parameter_list|(
name|Void
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|flush_comments
argument_list|()
expr_stmt|;
name|top
label|:
if|if
condition|(
name|nextcd
operator|==
name|NULL
condition|)
block|{
name|code
operator|=
name|getcd
argument_list|(
name|nextcd
operator|=
name|sbuf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|stno
operator|=
name|nxtstno
expr_stmt|;
name|prevlin
operator|=
name|thislin
expr_stmt|;
block|}
if|if
condition|(
name|code
operator|==
name|STEOF
condition|)
if|if
condition|(
name|popinclude
argument_list|()
condition|)
goto|goto
name|top
goto|;
else|else
return|return
operator|(
name|STEOF
operator|)
return|;
if|if
condition|(
name|code
operator|==
name|STCONTINUE
condition|)
block|{
name|lineno
operator|=
name|thislin
expr_stmt|;
name|nextcd
operator|=
name|NULL
expr_stmt|;
goto|goto
name|top
goto|;
block|}
comment|/* Get rid of unused space at the head of the buffer */
if|if
condition|(
name|nextcd
operator|>
name|sbuf
condition|)
block|{
name|q
operator|=
name|nextcd
expr_stmt|;
name|p
operator|=
name|sbuf
expr_stmt|;
while|while
condition|(
name|q
operator|<
name|endcd
condition|)
operator|*
name|p
operator|++
operator|=
operator|*
name|q
operator|++
expr_stmt|;
name|endcd
operator|=
name|p
expr_stmt|;
block|}
comment|/* Be aware that the input (i.e. the string at the address   nextcd)   is NOT    NULL-terminated */
comment|/* This loop merges all continuations into one long statement, AND puts the next    card to be read at the end of the buffer (i.e. it stores the look-ahead card    when there's room) */
name|ncont
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|nextcd
operator|=
name|endcd
expr_stmt|;
if|if
condition|(
name|ncont
operator|>=
name|maxcont
operator|||
name|nextcd
operator|+
literal|66
operator|>
name|send
condition|)
name|contmax
argument_list|()
expr_stmt|;
name|linestart
index|[
name|ncont
operator|++
index|]
operator|=
name|nextcd
expr_stmt|;
if|if
condition|(
operator|(
name|code
operator|=
name|getcd
argument_list|(
name|nextcd
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
name|STCONTINUE
condition|)
break|break;
if|if
condition|(
name|ncont
operator|==
literal|20
operator|&&
name|noextflag
condition|)
block|{
name|lineno
operator|=
name|thislin
expr_stmt|;
name|errext
argument_list|(
literal|"more than 19 continuation lines"
argument_list|)
expr_stmt|;
block|}
block|}
name|nextch
operator|=
name|sbuf
expr_stmt|;
name|lastch
operator|=
name|nextcd
operator|-
literal|1
expr_stmt|;
name|lineno
operator|=
name|prevlin
expr_stmt|;
name|prevlin
operator|=
name|thislin
expr_stmt|;
return|return
operator|(
name|STINITIAL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|bang
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|,
name|e
parameter_list|)
name|char
modifier|*
name|a
decl_stmt|;
name|char
modifier|*
name|b
decl_stmt|;
name|char
modifier|*
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|d
decl_stmt|;
specifier|register
name|char
modifier|*
name|e
decl_stmt|;
else|#
directive|else
function|bang
parameter_list|(
name|char
modifier|*
name|a
parameter_list|,
name|char
modifier|*
name|b
parameter_list|,
name|char
modifier|*
name|c
parameter_list|,
specifier|register
name|char
modifier|*
name|d
parameter_list|,
specifier|register
name|char
modifier|*
name|e
parameter_list|)
endif|#
directive|endif
comment|/* save ! comments */
block|{
name|char
name|buf
index|[
name|COMMENT_BUFFER_SIZE
operator|+
literal|1
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|pe
decl_stmt|;
name|p
operator|=
name|buf
expr_stmt|;
name|pe
operator|=
name|buf
operator|+
name|COMMENT_BUFFER_SIZE
expr_stmt|;
operator|*
name|pe
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|a
operator|<
name|b
condition|)
if|if
condition|(
operator|!
operator|(
operator|*
name|p
operator|++
operator|=
operator|*
name|a
operator|++
operator|)
condition|)
name|p
index|[
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|b
operator|<
name|c
condition|)
operator|*
name|p
operator|++
operator|=
literal|'\t'
expr_stmt|;
while|while
condition|(
name|d
operator|<
name|e
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|*
name|p
operator|++
operator|=
operator|*
name|d
operator|++
operator|)
condition|)
name|p
index|[
operator|-
literal|1
index|]
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|pe
condition|)
block|{
name|store_comment
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|p
operator|=
name|buf
expr_stmt|;
block|}
block|}
if|if
condition|(
name|p
operator|>
name|buf
condition|)
block|{
while|while
condition|(
operator|--
name|p
operator|>=
name|buf
operator|&&
operator|*
name|p
operator|==
literal|' '
condition|)
empty_stmt|;
name|p
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|store_comment
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* getcd - Get next input card  	This function reads the next input card from global file pointer   infile. It assumes that   b   points to currently empty storage somewhere in  sbuf  */
end_comment

begin_function
name|LOCAL
name|int
ifdef|#
directive|ifdef
name|KR_headers
name|getcd
parameter_list|(
name|b
parameter_list|,
name|nocont
parameter_list|)
specifier|register
name|char
modifier|*
name|b
decl_stmt|;
name|int
name|nocont
decl_stmt|;
else|#
directive|else
function|getcd
parameter_list|(
specifier|register
name|char
modifier|*
name|b
parameter_list|,
name|int
name|nocont
parameter_list|)
endif|#
directive|endif
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|bend
decl_stmt|;
name|int
name|speclin
decl_stmt|;
comment|/* Special line - true when the line is allowed 				   to have more than 66 characters (e.g. the 				   "&" shorthand for continuation, use of a "\t" 				   to skip part of the label columns) */
specifier|static
name|char
name|a
index|[
literal|6
index|]
decl_stmt|;
comment|/* Statement label buffer */
specifier|static
name|char
modifier|*
name|aend
init|=
name|a
operator|+
literal|6
decl_stmt|;
specifier|static
name|char
modifier|*
name|stb
decl_stmt|,
modifier|*
name|stbend
decl_stmt|;
specifier|static
name|int
name|nst
decl_stmt|;
name|char
modifier|*
name|atend
decl_stmt|,
modifier|*
name|endcd0
decl_stmt|;
specifier|extern
name|int
name|warn72
decl_stmt|;
name|char
name|buf72
index|[
literal|24
index|]
decl_stmt|;
name|int
name|amp
decl_stmt|,
name|i
decl_stmt|;
name|char
name|storage
index|[
name|COMMENT_BUFFER_SIZE
operator|+
literal|1
index|]
decl_stmt|;
name|char
modifier|*
name|pointer
decl_stmt|;
name|long
name|L
decl_stmt|;
name|top
label|:
name|endcd
operator|=
name|b
expr_stmt|;
name|bend
operator|=
name|b
operator|+
literal|66
expr_stmt|;
name|amp
operator|=
name|speclin
operator|=
name|NO
expr_stmt|;
name|atend
operator|=
name|aend
expr_stmt|;
comment|/* Handle the continuation shorthand of "&" in the first column, which stands    for "     x" */
if|if
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
operator|)
operator|==
literal|'&'
condition|)
block|{
name|a
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
name|a
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|a
index|[
literal|5
index|]
operator|=
literal|'x'
expr_stmt|;
name|amp
operator|=
name|speclin
operator|=
name|YES
expr_stmt|;
name|bend
operator|=
name|send
expr_stmt|;
name|p
operator|=
name|aend
expr_stmt|;
block|}
comment|/* Handle the Comment cards (a 'C', 'c', '*', or '!' in the first column). */
elseif|else
if|if
condition|(
name|comstart
index|[
name|c
operator|&
literal|0xfff
index|]
condition|)
block|{
if|if
condition|(
name|feof
argument_list|(
name|infile
argument_list|)
ifdef|#
directive|ifdef
name|EOF_CHAR
operator|||
name|c
operator|==
name|EOF_CHAR
endif|#
directive|endif
condition|)
return|return
name|STEOF
return|;
if|if
condition|(
name|c
operator|==
literal|'#'
condition|)
block|{
operator|*
name|endcd
operator|++
operator|=
name|c
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
operator|)
operator|!=
literal|'\n'
condition|)
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
return|return
name|STEOF
return|;
elseif|else
if|if
condition|(
name|endcd
operator|<
name|bend
condition|)
operator|*
name|endcd
operator|++
operator|=
name|c
expr_stmt|;
operator|++
name|thislin
expr_stmt|;
operator|*
name|endcd
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|b
index|[
literal|1
index|]
operator|==
literal|' '
condition|)
name|p
operator|=
name|b
operator|+
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|b
argument_list|,
literal|"#line "
argument_list|,
literal|6
argument_list|)
condition|)
name|p
operator|=
name|b
operator|+
literal|6
expr_stmt|;
else|else
block|{
name|bad_cpp
label|:
name|errstr
argument_list|(
literal|"Bad # line: \"%s\""
argument_list|,
name|b
argument_list|)
expr_stmt|;
goto|goto
name|top
goto|;
block|}
if|if
condition|(
operator|*
name|p
operator|<
literal|'1'
operator|||
operator|*
name|p
operator|>
literal|'9'
condition|)
goto|goto
name|bad_cpp
goto|;
name|L
operator|=
operator|*
name|p
operator|-
literal|'0'
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
operator|++
name|p
operator|)
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
name|L
operator|=
literal|10
operator|*
name|L
operator|+
name|c
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|' '
operator|||
operator|*
operator|++
name|p
operator|!=
literal|'"'
condition|)
goto|goto
name|bad_cpp
goto|;
name|bend
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|*
operator|++
name|p
operator|!=
literal|'"'
condition|)
if|if
condition|(
operator|!
operator|*
name|p
condition|)
goto|goto
name|bad_cpp
goto|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|i
operator|=
name|p
operator|-
name|bend
operator|++
expr_stmt|;
name|thislin
operator|=
name|L
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|infname
operator|||
name|strcmp
argument_list|(
name|infname
argument_list|,
name|bend
argument_list|)
condition|)
block|{
if|if
condition|(
name|infname
condition|)
name|free
argument_list|(
name|infname
argument_list|)
expr_stmt|;
name|lastfile
operator|=
literal|0
expr_stmt|;
name|infname
operator|=
name|Alloc
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|infname
argument_list|,
name|bend
argument_list|)
expr_stmt|;
if|if
condition|(
name|inclp
condition|)
name|inclp
operator|->
name|inclname
operator|=
name|infname
expr_stmt|;
block|}
goto|goto
name|top
goto|;
block|}
name|storage
index|[
name|COMMENT_BUFFER_SIZE
index|]
operator|=
name|c
operator|=
literal|'\0'
expr_stmt|;
name|pointer
operator|=
name|storage
expr_stmt|;
while|while
condition|(
operator|!
name|feof
argument_list|(
name|infile
argument_list|)
operator|&&
operator|(
operator|*
name|pointer
operator|++
operator|=
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
operator|)
operator|!=
literal|'\n'
condition|)
block|{
comment|/* Handle obscure end of file conditions on many machines */
if|if
condition|(
name|feof
argument_list|(
name|infile
argument_list|)
operator|&&
operator|(
name|c
operator|==
literal|'\377'
operator|||
name|c
operator|==
name|EOF
operator|)
condition|)
block|{
name|pointer
operator|--
expr_stmt|;
break|break;
block|}
comment|/* if (feof (infile)) */
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
operator|*
operator|(
name|pointer
operator|-
literal|1
operator|)
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
name|pointer
operator|==
operator|&
name|storage
index|[
name|COMMENT_BUFFER_SIZE
index|]
condition|)
block|{
name|store_comment
argument_list|(
name|storage
argument_list|)
expr_stmt|;
name|pointer
operator|=
name|storage
expr_stmt|;
block|}
comment|/* if (pointer == BUFFER_SIZE) */
block|}
comment|/* while */
if|if
condition|(
name|pointer
operator|>
name|storage
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
comment|/* Get rid of the newline */
name|pointer
index|[
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
else|else
operator|*
name|pointer
operator|=
literal|0
expr_stmt|;
name|store_comment
argument_list|(
name|storage
argument_list|)
expr_stmt|;
block|}
comment|/* if */
if|if
condition|(
name|feof
argument_list|(
name|infile
argument_list|)
condition|)
if|if
condition|(
name|c
operator|!=
literal|'\n'
condition|)
comment|/* To allow the line index to 					   increment correctly */
return|return
name|STEOF
return|;
operator|++
name|thislin
expr_stmt|;
goto|goto
name|top
goto|;
block|}
elseif|else
if|if
condition|(
name|c
operator|!=
name|EOF
condition|)
block|{
comment|/* Load buffer   a   with the statement label */
comment|/* a tab in columns 1-6 skips to column 7 */
name|ungetc
argument_list|(
name|c
argument_list|,
name|infile
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|a
init|;
name|p
operator|<
name|aend
operator|&&
operator|(
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
operator|)
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
name|EOF
condition|;
control|)
if|if
condition|(
name|c
operator|==
literal|'\t'
condition|)
comment|/* The tab character translates into blank characters in the statement label */
block|{
name|atend
operator|=
name|p
expr_stmt|;
while|while
condition|(
name|p
operator|<
name|aend
condition|)
operator|*
name|p
operator|++
operator|=
name|BLANK
expr_stmt|;
name|speclin
operator|=
name|YES
expr_stmt|;
name|bend
operator|=
name|send
expr_stmt|;
block|}
else|else
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
block|}
comment|/* By now we've read either a continuation character or the statement label    field */
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
return|return
operator|(
name|STEOF
operator|)
return|;
comment|/* The next 'if' block handles lines that have fewer than 7 characters */
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
while|while
condition|(
name|p
operator|<
name|aend
condition|)
operator|*
name|p
operator|++
operator|=
name|BLANK
expr_stmt|;
comment|/* Blank out the buffer on lines which are not longer than 66 characters */
name|endcd0
operator|=
name|endcd
expr_stmt|;
if|if
condition|(
operator|!
name|speclin
condition|)
while|while
condition|(
name|endcd
operator|<
name|bend
condition|)
operator|*
name|endcd
operator|++
operator|=
name|BLANK
expr_stmt|;
block|}
else|else
block|{
comment|/* read body of line */
if|if
condition|(
name|warn72
operator|&
literal|2
condition|)
block|{
name|speclin
operator|=
name|YES
expr_stmt|;
name|bend
operator|=
name|send
expr_stmt|;
block|}
while|while
condition|(
name|endcd
operator|<
name|bend
operator|&&
operator|(
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
operator|)
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
name|EOF
condition|)
operator|*
name|endcd
operator|++
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
return|return
operator|(
name|STEOF
operator|)
return|;
comment|/* Drop any extra characters on the input card; this usually means those after    column 72 */
if|if
condition|(
name|c
operator|!=
literal|'\n'
condition|)
block|{
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
operator|)
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
name|EOF
condition|)
if|if
condition|(
name|i
operator|<
literal|23
condition|)
name|buf72
index|[
name|i
operator|++
index|]
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|warn72
operator|&&
name|i
operator|&&
operator|!
name|speclin
condition|)
block|{
name|buf72
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|23
condition|)
name|strcpy
argument_list|(
name|buf72
operator|+
literal|20
argument_list|,
literal|"..."
argument_list|)
expr_stmt|;
name|lineno
operator|=
name|thislin
operator|+
literal|1
expr_stmt|;
name|errstr
argument_list|(
literal|"text after column 72: %s"
argument_list|,
name|buf72
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
return|return
operator|(
name|STEOF
operator|)
return|;
block|}
name|endcd0
operator|=
name|endcd
expr_stmt|;
if|if
condition|(
operator|!
name|speclin
condition|)
while|while
condition|(
name|endcd
operator|<
name|bend
condition|)
operator|*
name|endcd
operator|++
operator|=
name|BLANK
expr_stmt|;
block|}
comment|/* The flow of control usually gets to this line (unless an earlier RETURN has    been taken) */
operator|++
name|thislin
expr_stmt|;
comment|/* Fortran 77 specifies that a 0 in column 6 */
comment|/* does not signify continuation */
if|if
condition|(
operator|!
name|isspace
argument_list|(
name|a
index|[
literal|5
index|]
argument_list|)
operator|&&
name|a
index|[
literal|5
index|]
operator|!=
literal|'0'
condition|)
block|{
if|if
condition|(
operator|!
name|amp
condition|)
for|for
control|(
name|p
operator|=
name|a
init|;
name|p
operator|<
name|aend
condition|;
control|)
if|if
condition|(
operator|*
name|p
operator|++
operator|==
literal|'!'
operator|&&
name|p
operator|!=
name|aend
condition|)
goto|goto
name|initcheck
goto|;
if|if
condition|(
name|addftnsrc
operator|&&
name|stb
condition|)
block|{
if|if
condition|(
name|stbend
operator|>
name|stb
operator|+
literal|7
condition|)
block|{
comment|/* otherwise forget col 1-6 */
comment|/* kludge around funny p1gets behavior */
operator|*
name|stb
operator|++
operator|=
literal|'$'
expr_stmt|;
if|if
condition|(
name|amp
condition|)
operator|*
name|stb
operator|++
operator|=
literal|'&'
expr_stmt|;
else|else
for|for
control|(
name|p
operator|=
name|a
init|;
name|p
operator|<
name|atend
condition|;
control|)
operator|*
name|stb
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|endcd0
operator|-
name|b
operator|>
name|stbend
operator|-
name|stb
condition|)
block|{
if|if
condition|(
name|stb
operator|>
name|stbend
condition|)
name|stb
operator|=
name|stbend
expr_stmt|;
name|endcd0
operator|=
name|b
operator|+
operator|(
name|stbend
operator|-
name|stb
operator|)
expr_stmt|;
block|}
for|for
control|(
name|p
operator|=
name|b
init|;
name|p
operator|<
name|endcd0
condition|;
control|)
operator|*
name|stb
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|stb
operator|++
operator|=
literal|'\n'
expr_stmt|;
operator|*
name|stb
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|nocont
condition|)
block|{
name|lineno
operator|=
name|thislin
expr_stmt|;
name|errstr
argument_list|(
literal|"illegal continuation card (starts \"%.6s\")"
argument_list|,
name|a
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|amp
operator|&&
name|strncmp
argument_list|(
name|a
argument_list|,
literal|"     "
argument_list|,
literal|5
argument_list|)
condition|)
block|{
name|lineno
operator|=
name|thislin
expr_stmt|;
name|errstr
argument_list|(
literal|"labeled continuation line (starts \"%.6s\")"
argument_list|,
name|a
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|STCONTINUE
operator|)
return|;
block|}
name|initcheck
label|:
for|for
control|(
name|p
operator|=
name|a
init|;
name|p
operator|<
name|atend
condition|;
operator|++
name|p
control|)
if|if
condition|(
operator|!
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
literal|'!'
condition|)
goto|goto
name|initline
goto|;
name|bang
argument_list|(
name|p
argument_list|,
name|atend
argument_list|,
name|aend
argument_list|,
name|b
argument_list|,
name|endcd
argument_list|)
expr_stmt|;
goto|goto
name|top
goto|;
block|}
for|for
control|(
name|p
operator|=
name|b
init|;
name|p
operator|<
name|endcd
condition|;
operator|++
name|p
control|)
if|if
condition|(
operator|!
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
literal|'!'
condition|)
goto|goto
name|initline
goto|;
name|bang
argument_list|(
name|a
argument_list|,
name|a
argument_list|,
name|a
argument_list|,
name|p
argument_list|,
name|endcd
argument_list|)
expr_stmt|;
goto|goto
name|top
goto|;
block|}
comment|/* Skip over blank cards by reading the next one right away */
goto|goto
name|top
goto|;
name|initline
label|:
if|if
condition|(
operator|!
name|lastline
condition|)
name|lastline
operator|=
name|thislin
expr_stmt|;
if|if
condition|(
name|addftnsrc
condition|)
block|{
name|nst
operator|=
operator|(
name|nst
operator|+
literal|1
operator|)
operator|%
literal|3
expr_stmt|;
if|if
condition|(
operator|!
name|laststb
operator|&&
name|stb0
condition|)
name|laststb
operator|=
name|stb0
expr_stmt|;
name|stb0
operator|=
name|stb
operator|=
name|stbuf
index|[
name|nst
index|]
expr_stmt|;
operator|*
name|stb
operator|++
operator|=
literal|'$'
expr_stmt|;
comment|/* kludge around funny p1gets behavior */
name|stbend
operator|=
name|stb
operator|+
sizeof|sizeof
argument_list|(
name|stbuf
index|[
literal|0
index|]
argument_list|)
operator|-
literal|2
expr_stmt|;
for|for
control|(
name|p
operator|=
name|a
init|;
name|p
operator|<
name|atend
condition|;
control|)
operator|*
name|stb
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|atend
operator|<
name|aend
condition|)
operator|*
name|stb
operator|++
operator|=
literal|'\t'
expr_stmt|;
for|for
control|(
name|p
operator|=
name|b
init|;
name|p
operator|<
name|endcd0
condition|;
control|)
operator|*
name|stb
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|stb
operator|++
operator|=
literal|'\n'
expr_stmt|;
operator|*
name|stb
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Set   nxtstno   equal to the integer value of the statement label */
name|nxtstno
operator|=
literal|0
expr_stmt|;
name|bend
operator|=
name|a
operator|+
literal|5
expr_stmt|;
for|for
control|(
name|p
operator|=
name|a
init|;
name|p
operator|<
name|bend
condition|;
operator|++
name|p
control|)
if|if
condition|(
operator|!
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|nxtstno
operator|=
literal|10
operator|*
name|nxtstno
operator|+
operator|(
operator|*
name|p
operator|-
literal|'0'
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'!'
condition|)
block|{
if|if
condition|(
operator|!
name|addftnsrc
condition|)
name|bang
argument_list|(
name|p
operator|+
literal|1
argument_list|,
name|atend
argument_list|,
name|aend
argument_list|,
name|b
argument_list|,
name|endcd
argument_list|)
expr_stmt|;
name|endcd
operator|=
name|b
expr_stmt|;
break|break;
block|}
else|else
block|{
name|lineno
operator|=
name|thislin
expr_stmt|;
name|errstr
argument_list|(
literal|"nondigit in statement label field \"%.5s\""
argument_list|,
name|a
argument_list|)
expr_stmt|;
name|nxtstno
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|firstline
operator|=
name|thislin
expr_stmt|;
return|return
operator|(
name|STINITIAL
operator|)
return|;
block|}
end_function

begin_function
name|LOCAL
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|adjtoklen
parameter_list|(
name|newlen
parameter_list|)
name|int
name|newlen
decl_stmt|;
else|#
directive|else
function|adjtoklen
parameter_list|(
name|int
name|newlen
parameter_list|)
endif|#
directive|endif
block|{
while|while
condition|(
name|maxtoklen
operator|<
name|newlen
condition|)
name|maxtoklen
operator|=
literal|2
operator|*
name|maxtoklen
operator|+
literal|2
expr_stmt|;
if|if
condition|(
name|token
operator|=
operator|(
name|char
operator|*
operator|)
name|realloc
argument_list|(
name|token
argument_list|,
name|maxtoklen
argument_list|)
condition|)
return|return;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"adjtoklen: realloc(%d) failure!\n"
argument_list|,
name|maxtoklen
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* crunch -- deletes all space characters, folds the backslash chars and    Hollerith strings, quotes the Fortran strings */
end_comment

begin_function
name|LOCAL
name|void
name|crunch
parameter_list|(
name|Void
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|i
decl_stmt|,
modifier|*
name|j
decl_stmt|,
modifier|*
name|j0
decl_stmt|,
modifier|*
name|j1
decl_stmt|,
modifier|*
name|prvstr
decl_stmt|;
name|int
name|k
decl_stmt|,
name|ten
decl_stmt|,
name|nh
decl_stmt|,
name|nh0
decl_stmt|,
name|quote
decl_stmt|;
comment|/* i is the next input character to be looked at 	   j is the next output character */
name|new_dcl
operator|=
name|needwkey
operator|=
name|parlev
operator|=
name|parseen
operator|=
literal|0
expr_stmt|;
name|expcom
operator|=
literal|0
expr_stmt|;
comment|/* exposed ','s */
name|expeql
operator|=
literal|0
expr_stmt|;
comment|/* exposed equal signs */
name|j
operator|=
name|sbuf
expr_stmt|;
name|prvstr
operator|=
name|sbuf
expr_stmt|;
name|k
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|sbuf
init|;
name|i
operator|<=
name|lastch
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|isspace
argument_list|(
operator|*
name|i
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|*
name|i
operator|==
literal|'!'
condition|)
block|{
while|while
condition|(
name|i
operator|>=
name|linestart
index|[
name|k
index|]
condition|)
if|if
condition|(
operator|++
name|k
operator|>=
name|maxcont
condition|)
name|contmax
argument_list|()
expr_stmt|;
name|j0
operator|=
name|linestart
index|[
name|k
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|addftnsrc
condition|)
name|bang
argument_list|(
name|sbuf
argument_list|,
name|sbuf
argument_list|,
name|sbuf
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|j0
argument_list|)
expr_stmt|;
name|i
operator|=
name|j0
operator|-
literal|1
expr_stmt|;
continue|continue;
block|}
comment|/* Keep everything in a quoted string */
if|if
condition|(
operator|*
name|i
operator|==
literal|'\''
operator|||
operator|*
name|i
operator|==
literal|'"'
condition|)
block|{
name|int
name|len
init|=
literal|0
decl_stmt|;
name|quote
operator|=
operator|*
name|i
expr_stmt|;
operator|*
name|j
operator|=
name|MYQUOTE
expr_stmt|;
comment|/* special marker */
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|++
name|i
operator|>
name|lastch
condition|)
block|{
name|err
argument_list|(
literal|"unbalanced quotes; closing quote supplied"
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|>=
name|lastch
condition|)
name|j
operator|=
name|lastch
operator|-
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|*
name|i
operator|==
name|quote
condition|)
if|if
condition|(
name|i
operator|<
name|lastch
operator|&&
name|i
index|[
literal|1
index|]
operator|==
name|quote
condition|)
operator|++
name|i
expr_stmt|;
else|else
break|break;
elseif|else
if|if
condition|(
operator|*
name|i
operator|==
literal|'\\'
operator|&&
name|i
operator|<
name|lastch
operator|&&
name|use_bs
condition|)
block|{
operator|++
name|i
expr_stmt|;
operator|*
name|i
operator|=
name|escapes
index|[
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|)
name|i
index|]
expr_stmt|;
block|}
operator|*
operator|++
name|j
operator|=
operator|*
name|i
expr_stmt|;
name|len
operator|++
expr_stmt|;
block|}
comment|/* for (;;) */
if|if
condition|(
operator|(
name|len
operator|=
name|j
operator|-
name|sbuf
operator|)
operator|>
name|maxtoklen
condition|)
name|adjtoklen
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|j
index|[
literal|1
index|]
operator|=
name|MYQUOTE
expr_stmt|;
name|j
operator|+=
literal|2
expr_stmt|;
name|prvstr
operator|=
name|j
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|i
operator|==
literal|'h'
operator|||
operator|*
name|i
operator|==
literal|'H'
operator|)
operator|&&
name|j
operator|>
name|prvstr
condition|)
comment|/* test for Hollerith strings */
block|{
name|j0
operator|=
name|j
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
name|j0
argument_list|)
condition|)
goto|goto
name|copychar
goto|;
name|nh
operator|=
operator|*
name|j0
operator|-
literal|'0'
expr_stmt|;
name|ten
operator|=
literal|10
expr_stmt|;
name|j1
operator|=
name|prvstr
expr_stmt|;
if|if
condition|(
name|j1
operator|+
literal|4
operator|<
name|j
condition|)
name|j1
operator|=
name|j
operator|-
literal|4
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|j0
operator|--
operator|<=
name|j1
condition|)
goto|goto
name|copychar
goto|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
name|j0
argument_list|)
condition|)
break|break;
name|nh
operator|+=
name|ten
operator|*
operator|(
operator|*
name|j0
operator|-
literal|'0'
operator|)
expr_stmt|;
name|ten
operator|*=
literal|10
expr_stmt|;
block|}
comment|/* a hollerith must be preceded by a punctuation mark.    '*' is possible only as repetition factor in a data statement    not, in particular, in character*2h */
if|if
condition|(
operator|!
operator|(
operator|*
name|j0
operator|==
literal|'*'
operator|&&
name|sbuf
index|[
literal|0
index|]
operator|==
literal|'d'
operator|)
operator|&&
operator|*
name|j0
operator|!=
literal|'/'
operator|&&
operator|*
name|j0
operator|!=
literal|'('
operator|&&
operator|*
name|j0
operator|!=
literal|','
operator|&&
operator|*
name|j0
operator|!=
literal|'='
operator|&&
operator|*
name|j0
operator|!=
literal|'.'
condition|)
goto|goto
name|copychar
goto|;
name|nh0
operator|=
name|nh
expr_stmt|;
if|if
condition|(
name|i
operator|+
name|nh
operator|>
name|lastch
condition|)
block|{
name|erri
argument_list|(
literal|"%dH too big"
argument_list|,
name|nh
argument_list|)
expr_stmt|;
name|nh
operator|=
name|lastch
operator|-
name|i
expr_stmt|;
name|nh0
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|nh
operator|>
name|maxtoklen
condition|)
name|adjtoklen
argument_list|(
name|nh
argument_list|)
expr_stmt|;
name|j0
index|[
literal|1
index|]
operator|=
name|MYQUOTE
expr_stmt|;
comment|/* special marker */
name|j
operator|=
name|j0
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|nh
operator|--
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|++
name|i
operator|>
name|lastch
condition|)
block|{
name|hol_overflow
label|:
if|if
condition|(
name|nh0
operator|>=
literal|0
condition|)
name|erri
argument_list|(
literal|"escapes make %dH too big"
argument_list|,
name|nh0
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|*
name|i
operator|==
literal|'\\'
operator|&&
name|use_bs
condition|)
block|{
if|if
condition|(
operator|++
name|i
operator|>
name|lastch
condition|)
goto|goto
name|hol_overflow
goto|;
operator|*
name|i
operator|=
name|escapes
index|[
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|)
name|i
index|]
expr_stmt|;
block|}
operator|*
operator|++
name|j
operator|=
operator|*
name|i
expr_stmt|;
block|}
name|j
index|[
literal|1
index|]
operator|=
name|MYQUOTE
expr_stmt|;
name|j
operator|+=
literal|2
expr_stmt|;
name|prvstr
operator|=
name|j
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|i
operator|==
literal|'('
condition|)
name|parseen
operator|=
operator|++
name|parlev
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|i
operator|==
literal|')'
condition|)
operator|--
name|parlev
expr_stmt|;
elseif|else
if|if
condition|(
name|parlev
operator|==
literal|0
condition|)
if|if
condition|(
operator|*
name|i
operator|==
literal|'='
condition|)
name|expeql
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|i
operator|==
literal|','
condition|)
name|expcom
operator|=
literal|1
expr_stmt|;
name|copychar
label|:
comment|/*not a string or space -- copy, shifting case if necessary */
if|if
condition|(
name|shiftcase
operator|&&
name|isupper
argument_list|(
operator|*
name|i
argument_list|)
condition|)
operator|*
name|j
operator|++
operator|=
name|tolower
argument_list|(
operator|*
name|i
argument_list|)
expr_stmt|;
else|else
operator|*
name|j
operator|++
operator|=
operator|*
name|i
expr_stmt|;
block|}
block|}
name|lastch
operator|=
name|j
operator|-
literal|1
expr_stmt|;
name|nextch
operator|=
name|sbuf
expr_stmt|;
block|}
end_function

begin_function
name|LOCAL
name|void
name|analyz
parameter_list|(
name|Void
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|i
decl_stmt|;
if|if
condition|(
name|parlev
operator|!=
literal|0
condition|)
block|{
name|err
argument_list|(
literal|"unbalanced parentheses, statement skipped"
argument_list|)
expr_stmt|;
name|stkey
operator|=
name|SUNKNOWN
expr_stmt|;
name|lastch
operator|=
name|sbuf
operator|-
literal|1
expr_stmt|;
comment|/* prevent double error msg */
return|return;
block|}
if|if
condition|(
name|nextch
operator|+
literal|2
operator|<=
name|lastch
operator|&&
name|nextch
index|[
literal|0
index|]
operator|==
literal|'i'
operator|&&
name|nextch
index|[
literal|1
index|]
operator|==
literal|'f'
operator|&&
name|nextch
index|[
literal|2
index|]
operator|==
literal|'('
condition|)
block|{
comment|/* assignment or if statement -- look at character after balancing paren */
name|parlev
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
name|nextch
operator|+
literal|3
init|;
name|i
operator|<=
name|lastch
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|*
name|i
operator|==
operator|(
name|MYQUOTE
operator|)
condition|)
block|{
while|while
condition|(
operator|*
operator|++
name|i
operator|!=
name|MYQUOTE
condition|)
empty_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|i
operator|==
literal|'('
condition|)
operator|++
name|parlev
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|i
operator|==
literal|')'
condition|)
block|{
if|if
condition|(
operator|--
name|parlev
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|>=
name|lastch
condition|)
name|stkey
operator|=
name|SLOGIF
expr_stmt|;
elseif|else
if|if
condition|(
name|i
index|[
literal|1
index|]
operator|==
literal|'='
condition|)
name|stkey
operator|=
name|SLET
expr_stmt|;
elseif|else
if|if
condition|(
name|isdigit
argument_list|(
name|i
index|[
literal|1
index|]
argument_list|)
condition|)
name|stkey
operator|=
name|SARITHIF
expr_stmt|;
else|else
name|stkey
operator|=
name|SLOGIF
expr_stmt|;
if|if
condition|(
name|stkey
operator|!=
name|SLET
condition|)
name|nextch
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|expeql
condition|)
comment|/* may be an assignment */
block|{
if|if
condition|(
name|expcom
operator|&&
name|nextch
operator|<
name|lastch
operator|&&
name|nextch
index|[
literal|0
index|]
operator|==
literal|'d'
operator|&&
name|nextch
index|[
literal|1
index|]
operator|==
literal|'o'
condition|)
block|{
name|stkey
operator|=
name|SDO
expr_stmt|;
name|nextch
operator|+=
literal|2
expr_stmt|;
block|}
else|else
name|stkey
operator|=
name|SLET
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|parseen
operator|&&
name|nextch
operator|+
literal|7
operator|<
name|lastch
operator|&&
name|nextch
index|[
literal|2
index|]
operator|!=
literal|'u'
comment|/* screen out "double..." early */
operator|&&
name|nextch
index|[
literal|0
index|]
operator|==
literal|'d'
operator|&&
name|nextch
index|[
literal|1
index|]
operator|==
literal|'o'
operator|&&
operator|(
operator|(
name|nextch
index|[
literal|2
index|]
operator|>=
literal|'0'
operator|&&
name|nextch
index|[
literal|2
index|]
operator|<=
literal|'9'
operator|)
operator|||
name|nextch
index|[
literal|2
index|]
operator|==
literal|','
operator|||
name|nextch
index|[
literal|2
index|]
operator|==
literal|'w'
operator|)
condition|)
block|{
name|stkey
operator|=
name|SDO
expr_stmt|;
name|nextch
operator|+=
literal|2
expr_stmt|;
name|needwkey
operator|=
literal|1
expr_stmt|;
block|}
comment|/* otherwise search for keyword */
else|else
block|{
name|stkey
operator|=
name|getkwd
argument_list|()
expr_stmt|;
if|if
condition|(
name|stkey
operator|==
name|SGOTO
operator|&&
name|lastch
operator|>=
name|nextch
condition|)
if|if
condition|(
name|nextch
index|[
literal|0
index|]
operator|==
literal|'('
condition|)
name|stkey
operator|=
name|SCOMPGOTO
expr_stmt|;
elseif|else
if|if
condition|(
name|isalpha_
argument_list|(
argument|* USC nextch
argument_list|)
condition|)
name|stkey
operator|=
name|SASGOTO
expr_stmt|;
block|}
name|parlev
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|LOCAL
name|int
name|getkwd
parameter_list|(
name|Void
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|i
decl_stmt|,
modifier|*
name|j
decl_stmt|;
specifier|register
name|struct
name|Keylist
modifier|*
name|pk
decl_stmt|,
modifier|*
name|pend
decl_stmt|;
name|int
name|k
decl_stmt|;
if|if
condition|(
operator|!
name|isalpha_
argument_list|(
argument|* USC nextch
argument_list|)
condition|)
return|return
operator|(
name|SUNKNOWN
operator|)
return|;
name|k
operator|=
name|letter
argument_list|(
name|nextch
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|pk
operator|=
name|keystart
index|[
name|k
index|]
condition|)
for|for
control|(
name|pend
operator|=
name|keyend
index|[
name|k
index|]
init|;
name|pk
operator|<=
name|pend
condition|;
operator|++
name|pk
control|)
block|{
name|i
operator|=
name|pk
operator|->
name|keyname
expr_stmt|;
name|j
operator|=
name|nextch
expr_stmt|;
while|while
condition|(
operator|*
operator|++
name|i
operator|==
operator|*
operator|++
name|j
operator|&&
operator|*
name|i
operator|!=
literal|'\0'
condition|)
empty_stmt|;
if|if
condition|(
operator|*
name|i
operator|==
literal|'\0'
operator|&&
name|j
operator|<=
name|lastch
operator|+
literal|1
condition|)
block|{
name|nextch
operator|=
name|j
expr_stmt|;
if|if
condition|(
name|no66flag
operator|&&
name|pk
operator|->
name|notinf66
condition|)
name|errstr
argument_list|(
literal|"Not a Fortran 66 keyword: %s"
argument_list|,
name|pk
operator|->
name|keyname
argument_list|)
expr_stmt|;
return|return
operator|(
name|pk
operator|->
name|keyval
operator|)
return|;
block|}
block|}
return|return
operator|(
name|SUNKNOWN
operator|)
return|;
block|}
end_function

begin_function
name|void
name|initkey
parameter_list|(
name|Void
parameter_list|)
block|{
specifier|register
name|struct
name|Keylist
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|26
condition|;
operator|++
name|i
control|)
name|keystart
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|p
operator|=
name|keys
init|;
name|p
operator|->
name|keyname
condition|;
operator|++
name|p
control|)
block|{
name|j
operator|=
name|letter
argument_list|(
name|p
operator|->
name|keyname
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|keystart
index|[
name|j
index|]
operator|==
name|NULL
condition|)
name|keystart
index|[
name|j
index|]
operator|=
name|p
expr_stmt|;
name|keyend
index|[
name|j
index|]
operator|=
name|p
expr_stmt|;
block|}
name|i
operator|=
operator|(
name|maxcontin
operator|+
literal|2
operator|)
operator|*
literal|66
expr_stmt|;
name|sbuf
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
name|i
operator|+
literal|70
argument_list|)
expr_stmt|;
name|send
operator|=
name|sbuf
operator|+
name|i
expr_stmt|;
name|maxcont
operator|=
name|maxcontin
operator|+
literal|1
expr_stmt|;
name|linestart
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|ckalloc
argument_list|(
name|maxcont
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|comstart
index|[
literal|'c'
index|]
operator|=
name|comstart
index|[
literal|'C'
index|]
operator|=
name|comstart
index|[
literal|'*'
index|]
operator|=
name|comstart
index|[
literal|'!'
index|]
operator|=
name|comstart
index|[
literal|'#'
index|]
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|EOF_CHAR
name|comstart
index|[
name|EOF_CHAR
index|]
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|s
operator|=
literal|"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_"
expr_stmt|;
while|while
condition|(
name|i
operator|=
operator|*
name|s
operator|++
condition|)
name|anum_buf
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|s
operator|=
literal|"0123456789"
expr_stmt|;
while|while
condition|(
name|i
operator|=
operator|*
name|s
operator|++
condition|)
name|anum_buf
index|[
name|i
index|]
operator|=
literal|2
expr_stmt|;
block|}
end_function

begin_function
name|LOCAL
name|int
ifdef|#
directive|ifdef
name|KR_headers
name|hexcheck
parameter_list|(
name|key
parameter_list|)
name|int
name|key
decl_stmt|;
else|#
directive|else
function|hexcheck
parameter_list|(
name|int
name|key
parameter_list|)
endif|#
directive|endif
block|{
specifier|register
name|int
name|radix
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|kind
decl_stmt|;
switch|switch
condition|(
name|key
condition|)
block|{
case|case
literal|'z'
case|:
case|case
literal|'Z'
case|:
case|case
literal|'x'
case|:
case|case
literal|'X'
case|:
name|radix
operator|=
literal|16
expr_stmt|;
name|key
operator|=
name|SHEXCON
expr_stmt|;
name|kind
operator|=
literal|"hexadecimal"
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
case|case
literal|'O'
case|:
name|radix
operator|=
literal|8
expr_stmt|;
name|key
operator|=
name|SOCTCON
expr_stmt|;
name|kind
operator|=
literal|"octal"
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
case|case
literal|'B'
case|:
name|radix
operator|=
literal|2
expr_stmt|;
name|key
operator|=
name|SBITCON
expr_stmt|;
name|kind
operator|=
literal|"binary"
expr_stmt|;
break|break;
default|default:
name|err
argument_list|(
literal|"bad bit identifier"
argument_list|)
expr_stmt|;
return|return
operator|(
name|SNAME
operator|)
return|;
block|}
for|for
control|(
name|p
operator|=
name|token
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
name|hextoi
argument_list|(
operator|*
name|p
argument_list|)
operator|>=
name|radix
condition|)
block|{
name|errstr
argument_list|(
literal|"invalid %s character"
argument_list|,
name|kind
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|key
return|;
block|}
end_function

begin_comment
comment|/* gettok -- moves the right amount of text from   nextch   into the   token    buffer.   token   initially contains garbage (leftovers from the prev token) */
end_comment

begin_function
name|LOCAL
name|int
name|gettok
parameter_list|(
name|Void
parameter_list|)
block|{
name|int
name|havdot
decl_stmt|,
name|havexp
decl_stmt|,
name|havdbl
decl_stmt|;
name|int
name|radix
decl_stmt|,
name|val
decl_stmt|;
name|struct
name|Punctlist
modifier|*
name|pp
decl_stmt|;
name|struct
name|Dotlist
modifier|*
name|pd
decl_stmt|;
specifier|register
name|int
name|ch
decl_stmt|;
name|char
modifier|*
name|i
decl_stmt|,
modifier|*
name|j
decl_stmt|,
modifier|*
name|n1
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|ch
operator|=
operator|*
name|USC
name|nextch
expr_stmt|;
if|if
condition|(
name|ch
operator|==
operator|(
name|MYQUOTE
operator|)
condition|)
block|{
operator|++
name|nextch
expr_stmt|;
name|p
operator|=
name|token
expr_stmt|;
while|while
condition|(
operator|*
name|nextch
operator|!=
name|MYQUOTE
condition|)
operator|*
name|p
operator|++
operator|=
operator|*
name|nextch
operator|++
expr_stmt|;
name|toklen
operator|=
name|p
operator|-
name|token
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
comment|/* allow octal, binary, hex constants of the form 'abc'x (etc.) */
if|if
condition|(
operator|++
name|nextch
operator|<=
name|lastch
operator|&&
name|isalpha_
argument_list|(
argument|val = * USC nextch
argument_list|)
condition|)
block|{
operator|++
name|nextch
expr_stmt|;
return|return
name|hexcheck
argument_list|(
name|val
argument_list|)
return|;
block|}
return|return
operator|(
name|SHOLLERITH
operator|)
return|;
block|}
if|if
condition|(
name|needkwd
condition|)
block|{
name|needkwd
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|getkwd
argument_list|()
operator|)
return|;
block|}
for|for
control|(
name|pp
operator|=
name|puncts
init|;
name|pp
operator|->
name|punchar
condition|;
operator|++
name|pp
control|)
if|if
condition|(
name|ch
operator|==
name|pp
operator|->
name|punchar
condition|)
block|{
name|val
operator|=
name|pp
operator|->
name|punval
expr_stmt|;
if|if
condition|(
operator|++
name|nextch
operator|<=
name|lastch
condition|)
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'/'
case|:
if|if
condition|(
operator|*
name|nextch
operator|==
literal|'/'
condition|)
block|{
name|nextch
operator|++
expr_stmt|;
name|val
operator|=
name|SCONCAT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|new_dcl
operator|&&
name|parlev
operator|==
literal|0
condition|)
name|val
operator|=
name|SSLASHD
expr_stmt|;
return|return
name|val
return|;
case|case
literal|'*'
case|:
if|if
condition|(
operator|*
name|nextch
operator|==
literal|'*'
condition|)
block|{
name|nextch
operator|++
expr_stmt|;
return|return
name|SPOWER
return|;
block|}
break|break;
case|case
literal|'<'
case|:
if|if
condition|(
operator|*
name|nextch
operator|==
literal|'='
condition|)
block|{
name|nextch
operator|++
expr_stmt|;
name|val
operator|=
name|SLE
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|nextch
operator|==
literal|'>'
condition|)
block|{
name|nextch
operator|++
expr_stmt|;
name|val
operator|=
name|SNE
expr_stmt|;
block|}
goto|goto
name|extchk
goto|;
case|case
literal|'='
case|:
if|if
condition|(
operator|*
name|nextch
operator|==
literal|'='
condition|)
block|{
name|nextch
operator|++
expr_stmt|;
name|val
operator|=
name|SEQ
expr_stmt|;
goto|goto
name|extchk
goto|;
block|}
break|break;
case|case
literal|'>'
case|:
if|if
condition|(
operator|*
name|nextch
operator|==
literal|'='
condition|)
block|{
name|nextch
operator|++
expr_stmt|;
name|val
operator|=
name|SGE
expr_stmt|;
block|}
name|extchk
label|:
name|NOEXT
argument_list|(
literal|"Fortran 8x comparison operator"
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'/'
operator|&&
name|new_dcl
operator|&&
name|parlev
operator|==
literal|0
condition|)
return|return
name|SSLASHD
return|;
switch|switch
condition|(
name|val
condition|)
block|{
case|case
name|SLPAR
case|:
operator|++
name|parlev
expr_stmt|;
break|break;
case|case
name|SRPAR
case|:
operator|--
name|parlev
expr_stmt|;
block|}
return|return
operator|(
name|val
operator|)
return|;
block|}
if|if
condition|(
name|ch
operator|==
literal|'.'
condition|)
if|if
condition|(
name|nextch
operator|>=
name|lastch
condition|)
goto|goto
name|badchar
goto|;
elseif|else
if|if
condition|(
name|isdigit
argument_list|(
name|nextch
index|[
literal|1
index|]
argument_list|)
condition|)
goto|goto
name|numconst
goto|;
else|else
block|{
for|for
control|(
name|pd
operator|=
name|dots
init|;
operator|(
name|j
operator|=
name|pd
operator|->
name|dotname
operator|)
condition|;
operator|++
name|pd
control|)
block|{
for|for
control|(
name|i
operator|=
name|nextch
operator|+
literal|1
init|;
name|i
operator|<=
name|lastch
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|*
name|i
operator|!=
operator|*
name|j
condition|)
break|break;
elseif|else
if|if
condition|(
operator|*
name|i
operator|!=
literal|'.'
condition|)
operator|++
name|j
expr_stmt|;
else|else
block|{
name|nextch
operator|=
name|i
operator|+
literal|1
expr_stmt|;
return|return
operator|(
name|pd
operator|->
name|dotval
operator|)
return|;
block|}
block|}
goto|goto
name|badchar
goto|;
block|}
if|if
condition|(
name|isalpha_
argument_list|(
name|ch
argument_list|)
condition|)
block|{
name|p
operator|=
name|token
expr_stmt|;
operator|*
name|p
operator|++
operator|=
operator|*
name|nextch
operator|++
expr_stmt|;
while|while
condition|(
name|nextch
operator|<=
name|lastch
condition|)
if|if
condition|(
name|isalnum_
argument_list|(
argument|* USC nextch
argument_list|)
condition|)
operator|*
name|p
operator|++
operator|=
operator|*
name|nextch
operator|++
expr_stmt|;
else|else
break|break;
name|toklen
operator|=
name|p
operator|-
name|token
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|needwkey
condition|)
block|{
name|needwkey
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|toklen
operator|==
literal|5
operator|&&
name|nextch
operator|<=
name|lastch
operator|&&
operator|*
name|nextch
operator|==
literal|'('
comment|/*)*/
operator|&&
operator|!
name|strcmp
argument_list|(
name|token
argument_list|,
literal|"while"
argument_list|)
condition|)
return|return
operator|(
name|SWHILE
operator|)
return|;
block|}
if|if
condition|(
name|inioctl
operator|&&
name|nextch
operator|<=
name|lastch
operator|&&
operator|*
name|nextch
operator|==
literal|'='
condition|)
block|{
operator|++
name|nextch
expr_stmt|;
return|return
operator|(
name|SNAMEEQ
operator|)
return|;
block|}
if|if
condition|(
name|toklen
operator|>
literal|8
operator|&&
name|eqn
argument_list|(
literal|8
argument_list|,
name|token
argument_list|,
literal|"function"
argument_list|)
operator|&&
name|isalpha_
argument_list|(
operator|*
name|USC
argument_list|(
name|token
operator|+
literal|8
argument_list|)
argument_list|)
operator|&&
name|nextch
operator|<
name|lastch
operator|&&
name|nextch
index|[
literal|0
index|]
operator|==
literal|'('
operator|&&
operator|(
name|nextch
index|[
literal|1
index|]
operator|==
literal|')'
operator|||
name|isalpha_
argument_list|(
operator|*
name|USC
argument_list|(
name|nextch
operator|+
literal|1
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|nextch
operator|-=
operator|(
name|toklen
operator|-
literal|8
operator|)
expr_stmt|;
return|return
operator|(
name|SFUNCTION
operator|)
return|;
block|}
if|if
condition|(
name|toklen
operator|>
literal|50
condition|)
block|{
name|char
name|buff
index|[
literal|100
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buff
argument_list|,
name|toklen
operator|>=
literal|60
condition|?
literal|"name %.56s... too long, truncated to %.*s"
else|:
literal|"name %s too long, truncated to %.*s"
argument_list|,
name|token
argument_list|,
literal|50
argument_list|,
name|token
argument_list|)
expr_stmt|;
name|err
argument_list|(
name|buff
argument_list|)
expr_stmt|;
name|toklen
operator|=
literal|50
expr_stmt|;
name|token
index|[
literal|50
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|toklen
operator|==
literal|1
operator|&&
operator|*
name|nextch
operator|==
name|MYQUOTE
condition|)
block|{
name|val
operator|=
name|token
index|[
literal|0
index|]
expr_stmt|;
operator|++
name|nextch
expr_stmt|;
for|for
control|(
name|p
operator|=
name|token
init|;
operator|*
name|nextch
operator|!=
name|MYQUOTE
condition|;
control|)
operator|*
name|p
operator|++
operator|=
operator|*
name|nextch
operator|++
expr_stmt|;
operator|++
name|nextch
expr_stmt|;
name|toklen
operator|=
name|p
operator|-
name|token
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
return|return
name|hexcheck
argument_list|(
name|val
argument_list|)
return|;
block|}
return|return
operator|(
name|SNAME
operator|)
return|;
block|}
if|if
condition|(
name|isdigit
argument_list|(
name|ch
argument_list|)
condition|)
block|{
comment|/* Check for NAG's special hex constant */
if|if
condition|(
name|nextch
index|[
literal|1
index|]
operator|==
literal|'#'
operator|&&
name|nextch
operator|<
name|lastch
operator|||
name|nextch
index|[
literal|2
index|]
operator|==
literal|'#'
operator|&&
name|isdigit
argument_list|(
name|nextch
index|[
literal|1
index|]
operator|&&
name|lastch
operator|-
name|nextch
operator|>=
literal|2
argument_list|)
condition|)
block|{
name|radix
operator|=
name|atoi
argument_list|(
name|nextch
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|++
name|nextch
operator|!=
literal|'#'
condition|)
name|nextch
operator|++
expr_stmt|;
if|if
condition|(
name|radix
operator|!=
literal|2
operator|&&
name|radix
operator|!=
literal|8
operator|&&
name|radix
operator|!=
literal|16
condition|)
block|{
name|erri
argument_list|(
literal|"invalid base %d for constant, defaulting to hex"
argument_list|,
name|radix
argument_list|)
expr_stmt|;
name|radix
operator|=
literal|16
expr_stmt|;
block|}
comment|/* if */
if|if
condition|(
operator|++
name|nextch
operator|>
name|lastch
condition|)
goto|goto
name|badchar
goto|;
for|for
control|(
name|p
operator|=
name|token
init|;
name|hextoi
argument_list|(
operator|*
name|nextch
argument_list|)
operator|<
name|radix
condition|;
control|)
block|{
operator|*
name|p
operator|++
operator|=
operator|*
name|nextch
operator|++
expr_stmt|;
if|if
condition|(
name|nextch
operator|>
name|lastch
condition|)
break|break;
block|}
name|toklen
operator|=
name|p
operator|-
name|token
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|radix
operator|==
literal|16
operator|)
condition|?
name|SHEXCON
else|:
operator|(
operator|(
name|radix
operator|==
literal|8
operator|)
condition|?
name|SOCTCON
else|:
name|SBITCON
operator|)
return|;
block|}
block|}
else|else
goto|goto
name|badchar
goto|;
name|numconst
label|:
name|havdot
operator|=
name|NO
expr_stmt|;
name|havexp
operator|=
name|NO
expr_stmt|;
name|havdbl
operator|=
name|NO
expr_stmt|;
for|for
control|(
name|n1
operator|=
name|nextch
init|;
name|nextch
operator|<=
name|lastch
condition|;
operator|++
name|nextch
control|)
block|{
if|if
condition|(
operator|*
name|nextch
operator|==
literal|'.'
condition|)
if|if
condition|(
name|havdot
condition|)
break|break;
elseif|else
if|if
condition|(
name|nextch
operator|+
literal|2
operator|<=
name|lastch
operator|&&
name|isalpha_
argument_list|(
operator|*
name|USC
argument_list|(
name|nextch
operator|+
literal|1
argument_list|)
argument_list|)
operator|&&
name|isalpha_
argument_list|(
operator|*
name|USC
argument_list|(
name|nextch
operator|+
literal|2
argument_list|)
argument_list|)
condition|)
break|break;
else|else
name|havdot
operator|=
name|YES
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|intonly
operator|&&
operator|(
operator|*
name|nextch
operator|==
literal|'d'
operator|||
operator|*
name|nextch
operator|==
literal|'e'
operator|)
condition|)
block|{
name|p
operator|=
name|nextch
expr_stmt|;
name|havexp
operator|=
name|YES
expr_stmt|;
if|if
condition|(
operator|*
name|nextch
operator|==
literal|'d'
condition|)
name|havdbl
operator|=
name|YES
expr_stmt|;
if|if
condition|(
name|nextch
operator|<
name|lastch
condition|)
if|if
condition|(
name|nextch
index|[
literal|1
index|]
operator|==
literal|'+'
operator|||
name|nextch
index|[
literal|1
index|]
operator|==
literal|'-'
condition|)
operator|++
name|nextch
expr_stmt|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
operator|++
name|nextch
argument_list|)
condition|)
block|{
name|nextch
operator|=
name|p
expr_stmt|;
name|havdbl
operator|=
name|havexp
operator|=
name|NO
expr_stmt|;
break|break;
block|}
for|for
control|(
operator|++
name|nextch
init|;
name|nextch
operator|<=
name|lastch
operator|&&
name|isdigit
argument_list|(
argument|* USC nextch
argument_list|)
condition|;
operator|++
name|nextch
control|)
empty_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
operator|!
name|isdigit
argument_list|(
argument|* USC nextch
argument_list|)
condition|)
break|break;
block|}
name|p
operator|=
name|token
expr_stmt|;
name|i
operator|=
name|n1
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|nextch
condition|)
operator|*
name|p
operator|++
operator|=
operator|*
name|i
operator|++
expr_stmt|;
name|toklen
operator|=
name|p
operator|-
name|token
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|havdbl
condition|)
return|return
operator|(
name|SDCON
operator|)
return|;
if|if
condition|(
name|havdot
operator|||
name|havexp
condition|)
return|return
operator|(
name|SRCON
operator|)
return|;
return|return
operator|(
name|SICON
operator|)
return|;
name|badchar
label|:
name|sbuf
index|[
literal|0
index|]
operator|=
operator|*
name|nextch
operator|++
expr_stmt|;
return|return
operator|(
name|SUNKNOWN
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Comment buffering code */
end_comment

begin_function
specifier|static
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|store_comment
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
else|#
directive|else
function|store_comment
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
endif|#
directive|endif
block|{
name|int
name|len
decl_stmt|;
name|comment_buf
modifier|*
name|ncb
decl_stmt|;
if|if
condition|(
name|nextcd
operator|==
name|sbuf
condition|)
block|{
name|flush_comments
argument_list|()
expr_stmt|;
name|p1_comment
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
name|len
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|cbnext
operator|+
name|len
operator|>
name|cblast
condition|)
block|{
if|if
condition|(
operator|!
name|cbcur
operator|||
operator|!
operator|(
name|ncb
operator|=
name|cbcur
operator|->
name|next
operator|)
condition|)
block|{
name|ncb
operator|=
operator|(
name|comment_buf
operator|*
operator|)
name|Alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|comment_buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cbcur
condition|)
block|{
name|cbcur
operator|->
name|last
operator|=
name|cbnext
expr_stmt|;
name|cbcur
operator|->
name|next
operator|=
name|ncb
expr_stmt|;
block|}
else|else
block|{
name|cbfirst
operator|=
name|ncb
expr_stmt|;
name|cbinit
operator|=
name|ncb
operator|->
name|buf
expr_stmt|;
block|}
name|ncb
operator|->
name|next
operator|=
literal|0
expr_stmt|;
block|}
name|cbcur
operator|=
name|ncb
expr_stmt|;
name|cbnext
operator|=
name|ncb
operator|->
name|buf
expr_stmt|;
name|cblast
operator|=
name|cbnext
operator|+
name|COMMENT_BUF_STORE
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|cbnext
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|cbnext
operator|+=
name|len
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|flush_comments
parameter_list|(
name|Void
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|s1
decl_stmt|;
specifier|register
name|comment_buf
modifier|*
name|cb
decl_stmt|;
if|if
condition|(
name|cbnext
operator|==
name|cbinit
condition|)
return|return;
name|cbcur
operator|->
name|last
operator|=
name|cbnext
expr_stmt|;
for|for
control|(
name|cb
operator|=
name|cbfirst
init|;
condition|;
name|cb
operator|=
name|cb
operator|->
name|next
control|)
block|{
for|for
control|(
name|s
operator|=
name|cb
operator|->
name|buf
init|;
name|s
operator|<
name|cb
operator|->
name|last
condition|;
name|s
operator|=
name|s1
control|)
block|{
comment|/* compute s1 = new s value first, since */
comment|/* p1_comment may insert nulls into s */
name|s1
operator|=
name|s
operator|+
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
expr_stmt|;
name|p1_comment
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cb
operator|==
name|cbcur
condition|)
break|break;
block|}
name|cbcur
operator|=
name|cbfirst
expr_stmt|;
name|cbnext
operator|=
name|cbinit
expr_stmt|;
name|cblast
operator|=
name|cbnext
operator|+
name|COMMENT_BUF_STORE
expr_stmt|;
block|}
end_function

begin_function
name|void
name|unclassifiable
parameter_list|(
name|Void
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|se
decl_stmt|;
name|s
operator|=
name|sbuf
expr_stmt|;
name|se
operator|=
name|lastch
expr_stmt|;
if|if
condition|(
name|se
operator|<
name|sbuf
condition|)
return|return;
name|lastch
operator|=
name|s
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|se
operator|-
name|s
operator|>
literal|10
condition|)
name|se
operator|=
name|s
operator|+
literal|10
expr_stmt|;
for|for
control|(
init|;
name|s
operator|<
name|se
condition|;
name|s
operator|++
control|)
if|if
condition|(
operator|*
name|s
operator|==
name|MYQUOTE
condition|)
block|{
name|se
operator|=
name|s
expr_stmt|;
break|break;
block|}
operator|*
name|se
operator|=
literal|0
expr_stmt|;
name|errstr
argument_list|(
literal|"unclassifiable statement (starts \"%s\")"
argument_list|,
name|sbuf
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

