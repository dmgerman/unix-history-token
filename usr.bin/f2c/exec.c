begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**************************************************************** Copyright 1990, 1993 - 1996 by AT&T, Lucent Technologies and Bellcore.  Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that the copyright notice and this permission notice and warranty disclaimer appear in supporting documentation, and that the names of AT&T, Bell Laboratories, Lucent or Bellcore or any of their entities not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  AT&T, Lucent and Bellcore disclaim all warranties with regard to this software, including all implied warranties of merchantability and fitness.  In no event shall AT&T, Lucent or Bellcore be liable for any special, indirect or consequential damages or any damages whatsoever resulting from loss of use, data or profits, whether in an action of contract, negligence or other tortious action, arising out of or in connection with the use or performance of this software. ****************************************************************/
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"p1defs.h"
end_include

begin_include
include|#
directive|include
file|"names.h"
end_include

begin_decl_stmt
specifier|static
name|void
name|exar2
name|Argdcl
argument_list|(
operator|(
name|int
operator|,
name|tagptr
operator|,
expr|struct
name|Labelblock
operator|*
operator|,
expr|struct
name|Labelblock
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|popctl
name|Argdcl
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pushctl
name|Argdcl
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*   Logical IF codes */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|exif
parameter_list|(
name|p
parameter_list|)
name|expptr
name|p
decl_stmt|;
else|#
directive|else
function|exif
parameter_list|(
name|expptr
name|p
parameter_list|)
endif|#
directive|endif
block|{
name|pushctl
argument_list|(
name|CTLIF
argument_list|)
expr_stmt|;
name|putif
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 0 => if, not elseif */
block|}
end_function

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|exelif
parameter_list|(
name|p
parameter_list|)
name|expptr
name|p
decl_stmt|;
else|#
directive|else
function|exelif
parameter_list|(
name|expptr
name|p
parameter_list|)
endif|#
directive|endif
block|{
if|if
condition|(
name|ctlstack
operator|->
name|ctltype
operator|==
name|CTLIF
operator|||
name|ctlstack
operator|->
name|ctltype
operator|==
name|CTLIFX
condition|)
name|putif
argument_list|(
name|p
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 1 ==> elseif */
else|else
name|execerr
argument_list|(
literal|"elseif out of place"
argument_list|,
name|CNULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|exelse
parameter_list|(
name|Void
parameter_list|)
block|{
specifier|register
name|struct
name|Ctlframe
modifier|*
name|c
decl_stmt|;
for|for
control|(
name|c
operator|=
name|ctlstack
init|;
name|c
operator|->
name|ctltype
operator|==
name|CTLIFX
condition|;
operator|--
name|c
control|)
empty_stmt|;
if|if
condition|(
name|c
operator|->
name|ctltype
operator|==
name|CTLIF
condition|)
block|{
name|p1_else
argument_list|()
expr_stmt|;
name|c
operator|->
name|ctltype
operator|=
name|CTLELSE
expr_stmt|;
block|}
else|else
name|execerr
argument_list|(
literal|"else out of place"
argument_list|,
name|CNULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|exendif
parameter_list|()
else|#
directive|else
function|exendif
parameter_list|()
endif|#
directive|endif
block|{
while|while
condition|(
name|ctlstack
operator|->
name|ctltype
operator|==
name|CTLIFX
condition|)
block|{
name|popctl
argument_list|()
expr_stmt|;
name|p1else_end
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|ctlstack
operator|->
name|ctltype
operator|==
name|CTLIF
condition|)
block|{
name|popctl
argument_list|()
expr_stmt|;
name|p1_endif
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctlstack
operator|->
name|ctltype
operator|==
name|CTLELSE
condition|)
block|{
name|popctl
argument_list|()
expr_stmt|;
name|p1else_end
argument_list|()
expr_stmt|;
block|}
else|else
name|execerr
argument_list|(
literal|"endif out of place"
argument_list|,
name|CNULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|new_endif
parameter_list|()
else|#
directive|else
function|new_endif
parameter_list|()
endif|#
directive|endif
block|{
if|if
condition|(
name|ctlstack
operator|->
name|ctltype
operator|==
name|CTLIF
operator|||
name|ctlstack
operator|->
name|ctltype
operator|==
name|CTLIFX
condition|)
name|pushctl
argument_list|(
name|CTLIFX
argument_list|)
expr_stmt|;
else|else
name|err
argument_list|(
literal|"new_endif bug"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* pushctl -- Start a new control construct, initialize the labels (to    zero) */
end_comment

begin_function
name|LOCAL
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|pushctl
parameter_list|(
name|code
parameter_list|)
name|int
name|code
decl_stmt|;
else|#
directive|else
function|pushctl
parameter_list|(
name|int
name|code
parameter_list|)
endif|#
directive|endif
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|++
name|ctlstack
operator|>=
name|lastctl
condition|)
name|many
argument_list|(
literal|"loops or if-then-elses"
argument_list|,
literal|'c'
argument_list|,
name|maxctl
argument_list|)
expr_stmt|;
name|ctlstack
operator|->
name|ctltype
operator|=
name|code
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
operator|++
name|i
control|)
name|ctlstack
operator|->
name|ctlabels
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|ctlstack
operator|->
name|dowhile
operator|=
literal|0
expr_stmt|;
name|ctlstack
operator|->
name|domax
operator|=
name|ctlstack
operator|->
name|dostep
operator|=
literal|0
expr_stmt|;
comment|/* in case of errors */
operator|++
name|blklevel
expr_stmt|;
block|}
end_function

begin_function
name|LOCAL
name|void
name|popctl
parameter_list|(
name|Void
parameter_list|)
block|{
if|if
condition|(
name|ctlstack
operator|--
operator|<
name|ctls
condition|)
name|Fatal
argument_list|(
literal|"control stack empty"
argument_list|)
expr_stmt|;
operator|--
name|blklevel
expr_stmt|;
block|}
end_function

begin_comment
comment|/* poplab -- update the flags in   labeltab   */
end_comment

begin_function
name|LOCAL
name|void
name|poplab
parameter_list|(
name|Void
parameter_list|)
block|{
specifier|register
name|struct
name|Labelblock
modifier|*
name|lp
decl_stmt|;
for|for
control|(
name|lp
operator|=
name|labeltab
init|;
name|lp
operator|<
name|highlabtab
condition|;
operator|++
name|lp
control|)
if|if
condition|(
name|lp
operator|->
name|labdefined
condition|)
block|{
comment|/* mark all labels in inner blocks unreachable */
if|if
condition|(
name|lp
operator|->
name|blklevel
operator|>
name|blklevel
condition|)
name|lp
operator|->
name|labinacc
operator|=
name|YES
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lp
operator|->
name|blklevel
operator|>
name|blklevel
condition|)
block|{
comment|/* move all labels referred to in inner blocks out a level */
name|lp
operator|->
name|blklevel
operator|=
name|blklevel
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  BRANCHING CODE */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|exgoto
parameter_list|(
name|lab
parameter_list|)
name|struct
name|Labelblock
modifier|*
name|lab
decl_stmt|;
else|#
directive|else
function|exgoto
parameter_list|(
name|struct
name|Labelblock
modifier|*
name|lab
parameter_list|)
endif|#
directive|endif
block|{
name|lab
operator|->
name|labused
operator|=
literal|1
expr_stmt|;
name|p1_goto
argument_list|(
name|lab
operator|->
name|stateno
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|exequals
parameter_list|(
name|lp
parameter_list|,
name|rp
parameter_list|)
specifier|register
name|struct
name|Primblock
modifier|*
name|lp
decl_stmt|;
specifier|register
name|expptr
name|rp
decl_stmt|;
else|#
directive|else
function|exequals
parameter_list|(
specifier|register
name|struct
name|Primblock
modifier|*
name|lp
parameter_list|,
specifier|register
name|expptr
name|rp
parameter_list|)
endif|#
directive|endif
block|{
if|if
condition|(
name|lp
operator|->
name|tag
operator|!=
name|TPRIM
condition|)
block|{
name|err
argument_list|(
literal|"assignment to a non-variable"
argument_list|)
expr_stmt|;
name|frexpr
argument_list|(
operator|(
name|expptr
operator|)
name|lp
argument_list|)
expr_stmt|;
name|frexpr
argument_list|(
name|rp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lp
operator|->
name|namep
operator|->
name|vclass
operator|!=
name|CLVAR
operator|&&
name|lp
operator|->
name|argsp
condition|)
block|{
if|if
condition|(
name|parstate
operator|>=
name|INEXEC
condition|)
name|errstr
argument_list|(
literal|"statement function %.62s amid executables."
argument_list|,
name|lp
operator|->
name|namep
operator|->
name|fvarname
argument_list|)
expr_stmt|;
name|mkstfunct
argument_list|(
name|lp
argument_list|,
name|rp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lp
operator|->
name|vtype
operator|==
name|TYSUBR
condition|)
name|err
argument_list|(
literal|"illegal use of subroutine name"
argument_list|)
expr_stmt|;
else|else
block|{
name|expptr
name|new_lp
decl_stmt|,
name|new_rp
decl_stmt|;
if|if
condition|(
name|parstate
operator|<
name|INDATA
condition|)
name|enddcl
argument_list|()
expr_stmt|;
name|new_lp
operator|=
name|mklhs
argument_list|(
name|lp
argument_list|,
name|keepsubs
argument_list|)
expr_stmt|;
name|new_rp
operator|=
name|fixtype
argument_list|(
name|rp
argument_list|)
expr_stmt|;
name|puteq
argument_list|(
name|new_lp
argument_list|,
name|new_rp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Make Statement Function */
end_comment

begin_decl_stmt
name|long
name|laststfcn
init|=
operator|-
literal|1
decl_stmt|,
name|thisstno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|doing_stmtfcn
decl_stmt|;
end_decl_stmt

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|mkstfunct
parameter_list|(
name|lp
parameter_list|,
name|rp
parameter_list|)
name|struct
name|Primblock
modifier|*
name|lp
decl_stmt|;
name|expptr
name|rp
decl_stmt|;
else|#
directive|else
function|mkstfunct
parameter_list|(
name|struct
name|Primblock
modifier|*
name|lp
parameter_list|,
name|expptr
name|rp
parameter_list|)
endif|#
directive|endif
block|{
specifier|register
name|struct
name|Primblock
modifier|*
name|p
decl_stmt|;
specifier|register
name|Namep
name|np
decl_stmt|;
name|chainp
name|args
decl_stmt|;
name|laststfcn
operator|=
name|thisstno
expr_stmt|;
name|np
operator|=
name|lp
operator|->
name|namep
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|vclass
operator|==
name|CLUNKNOWN
condition|)
name|np
operator|->
name|vclass
operator|=
name|CLPROC
expr_stmt|;
else|else
block|{
name|dclerr
argument_list|(
literal|"redeclaration of statement function"
argument_list|,
name|np
argument_list|)
expr_stmt|;
return|return;
block|}
name|np
operator|->
name|vprocclass
operator|=
name|PSTFUNCT
expr_stmt|;
name|np
operator|->
name|vstg
operator|=
name|STGSTFUNCT
expr_stmt|;
comment|/* Set the type of the function */
name|impldcl
argument_list|(
name|np
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|vtype
operator|==
name|TYCHAR
operator|&&
operator|!
name|np
operator|->
name|vleng
condition|)
name|err
argument_list|(
literal|"character statement function with length (*)"
argument_list|)
expr_stmt|;
name|args
operator|=
operator|(
name|lp
operator|->
name|argsp
condition|?
name|lp
operator|->
name|argsp
operator|->
name|listp
else|:
name|CHNULL
operator|)
expr_stmt|;
name|np
operator|->
name|varxptr
operator|.
name|vstfdesc
operator|=
name|mkchain
argument_list|(
operator|(
name|char
operator|*
operator|)
name|args
argument_list|,
operator|(
name|chainp
operator|)
name|rp
argument_list|)
expr_stmt|;
for|for
control|(
name|doing_stmtfcn
operator|=
literal|1
init|;
name|args
condition|;
name|args
operator|=
name|args
operator|->
name|nextp
control|)
comment|/* It is an error for the formal parameters to have arguments or    subscripts */
if|if
condition|(
operator|(
call|(
name|tagptr
call|)
argument_list|(
name|args
operator|->
name|datap
argument_list|)
operator|)
operator|->
name|tag
operator|!=
name|TPRIM
operator|||
operator|(
name|p
operator|=
operator|(
expr|struct
name|Primblock
operator|*
operator|)
operator|(
name|args
operator|->
name|datap
operator|)
operator|)
operator|->
name|argsp
operator|||
name|p
operator|->
name|fcharp
operator|||
name|p
operator|->
name|lcharp
condition|)
block|{
name|err
argument_list|(
literal|"non-variable argument in statement function definition"
argument_list|)
expr_stmt|;
name|args
operator|->
name|datap
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* Replace the name on the left-hand side */
name|args
operator|->
name|datap
operator|=
operator|(
name|char
operator|*
operator|)
name|p
operator|->
name|namep
expr_stmt|;
name|vardcl
argument_list|(
name|p
operator|->
name|namep
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
argument_list|)
expr_stmt|;
block|}
name|doing_stmtfcn
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|mixed_type
parameter_list|(
name|np
parameter_list|)
name|Namep
name|np
decl_stmt|;
else|#
directive|else
function|mixed_type
parameter_list|(
name|Namep
name|np
parameter_list|)
endif|#
directive|endif
block|{
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s function %.90s invoked as subroutine"
argument_list|,
name|ftn_types
index|[
name|np
operator|->
name|vtype
index|]
argument_list|,
name|np
operator|->
name|fvarname
argument_list|)
expr_stmt|;
name|warn
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|excall
parameter_list|(
name|name
parameter_list|,
name|args
parameter_list|,
name|nstars
parameter_list|,
name|labels
parameter_list|)
name|Namep
name|name
decl_stmt|;
name|struct
name|Listblock
modifier|*
name|args
decl_stmt|;
name|int
name|nstars
decl_stmt|;
name|struct
name|Labelblock
modifier|*
modifier|*
name|labels
decl_stmt|;
else|#
directive|else
function|excall
parameter_list|(
name|Namep
name|name
parameter_list|,
name|struct
name|Listblock
modifier|*
name|args
parameter_list|,
name|int
name|nstars
parameter_list|,
name|struct
name|Labelblock
modifier|*
modifier|*
name|labels
parameter_list|)
endif|#
directive|endif
block|{
specifier|register
name|expptr
name|p
decl_stmt|;
if|if
condition|(
name|name
operator|->
name|vtype
operator|!=
name|TYSUBR
condition|)
block|{
if|if
condition|(
name|name
operator|->
name|vinfproc
operator|&&
operator|!
name|name
operator|->
name|vcalled
condition|)
block|{
name|name
operator|->
name|vtype
operator|=
name|TYSUBR
expr_stmt|;
name|frexpr
argument_list|(
name|name
operator|->
name|vleng
argument_list|)
expr_stmt|;
name|name
operator|->
name|vleng
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|name
operator|->
name|vimpltype
operator|&&
name|name
operator|->
name|vtype
operator|!=
name|TYUNKNOWN
condition|)
name|mixed_type
argument_list|(
name|name
argument_list|)
expr_stmt|;
else|else
name|settype
argument_list|(
name|name
argument_list|,
name|TYSUBR
argument_list|,
operator|(
name|ftnint
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|mkfunct
argument_list|(
name|mkprim
argument_list|(
name|name
argument_list|,
name|args
argument_list|,
name|CHNULL
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|tag
operator|==
name|TERROR
condition|)
return|return;
comment|/* Subroutines and their identifiers acquire the type INT */
name|p
operator|->
name|exprblock
operator|.
name|vtype
operator|=
name|p
operator|->
name|exprblock
operator|.
name|leftp
operator|->
name|headblock
operator|.
name|vtype
operator|=
name|TYINT
expr_stmt|;
comment|/* Handle the alternate return mechanism */
if|if
condition|(
name|nstars
operator|>
literal|0
condition|)
name|putcmgo
argument_list|(
name|putx
argument_list|(
name|fixtype
argument_list|(
name|p
argument_list|)
argument_list|)
argument_list|,
name|nstars
argument_list|,
name|labels
argument_list|)
expr_stmt|;
else|else
name|putexpr
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|exstop
parameter_list|(
name|stop
parameter_list|,
name|p
parameter_list|)
name|int
name|stop
decl_stmt|;
specifier|register
name|expptr
name|p
decl_stmt|;
else|#
directive|else
function|exstop
parameter_list|(
name|int
name|stop
parameter_list|,
specifier|register
name|expptr
name|p
parameter_list|)
endif|#
directive|endif
block|{
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|n
decl_stmt|;
if|if
condition|(
name|p
condition|)
block|{
if|if
condition|(
operator|!
name|ISCONST
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|execerr
argument_list|(
literal|"pause/stop argument must be constant"
argument_list|,
name|CNULL
argument_list|)
expr_stmt|;
name|frexpr
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|mkstrcon
argument_list|(
literal|0
argument_list|,
name|CNULL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ISINT
argument_list|(
name|p
operator|->
name|constblock
operator|.
name|vtype
argument_list|)
condition|)
block|{
name|str
operator|=
name|convic
argument_list|(
name|p
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
argument_list|)
expr_stmt|;
name|n
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|p
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ccp
operator|=
name|copyn
argument_list|(
name|n
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|p
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ccp1
operator|.
name|blanks
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|constblock
operator|.
name|vtype
operator|=
name|TYCHAR
expr_stmt|;
name|p
operator|->
name|constblock
operator|.
name|vleng
operator|=
operator|(
name|expptr
operator|)
name|ICON
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
else|else
name|p
operator|=
operator|(
name|expptr
operator|)
name|mkstrcon
argument_list|(
literal|0
argument_list|,
name|CNULL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|constblock
operator|.
name|vtype
operator|!=
name|TYCHAR
condition|)
block|{
name|execerr
argument_list|(
literal|"pause/stop argument must be integer or string"
argument_list|,
name|CNULL
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
name|expptr
operator|)
name|mkstrcon
argument_list|(
literal|0
argument_list|,
name|CNULL
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|p
operator|=
operator|(
name|expptr
operator|)
name|mkstrcon
argument_list|(
literal|0
argument_list|,
name|CNULL
argument_list|)
expr_stmt|;
block|{
name|expptr
name|subr_call
decl_stmt|;
name|subr_call
operator|=
name|call1
argument_list|(
name|TYSUBR
argument_list|,
operator|(
name|stop
condition|?
literal|"s_stop"
else|:
literal|"s_paus"
operator|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|putexpr
argument_list|(
name|subr_call
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* DO LOOP CODE */
end_comment

begin_define
define|#
directive|define
name|DOINIT
value|par[0]
end_define

begin_define
define|#
directive|define
name|DOLIMIT
value|par[1]
end_define

begin_define
define|#
directive|define
name|DOINCR
value|par[2]
end_define

begin_comment
comment|/* Macros for   ctlstack -> dostepsign   */
end_comment

begin_define
define|#
directive|define
name|VARSTEP
value|0
end_define

begin_define
define|#
directive|define
name|POSSTEP
value|1
end_define

begin_define
define|#
directive|define
name|NEGSTEP
value|2
end_define

begin_comment
comment|/* exdo -- generate DO loop code.  In the case of a variable increment,    positive increment tests are placed above the body, negative increment    tests are placed below (see   enddo()   ) */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|exdo
parameter_list|(
name|range
parameter_list|,
name|loopname
parameter_list|,
name|spec
parameter_list|)
name|int
name|range
decl_stmt|;
name|Namep
name|loopname
decl_stmt|;
name|chainp
name|spec
decl_stmt|;
else|#
directive|else
function|exdo
parameter_list|(
name|int
name|range
parameter_list|,
name|Namep
name|loopname
parameter_list|,
name|chainp
name|spec
parameter_list|)
endif|#
directive|endif
comment|/* range = end label */
comment|/* input spec must have at least 2 exprs */
block|{
specifier|register
name|expptr
name|p
decl_stmt|;
specifier|register
name|Namep
name|np
decl_stmt|;
name|chainp
name|cp
decl_stmt|;
comment|/* loops over the fields in   spec */
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|dotype
decl_stmt|;
comment|/* type of the index variable */
name|int
name|incsign
decl_stmt|;
comment|/* sign of the increment, if it's constant 				   */
name|Addrp
name|dovarp
decl_stmt|;
comment|/* loop index variable */
name|expptr
name|doinit
decl_stmt|;
comment|/* constant or register for init param */
name|expptr
name|par
index|[
literal|3
index|]
decl_stmt|;
comment|/* local specification parameters */
name|expptr
name|init
decl_stmt|,
name|test
decl_stmt|,
name|inc
decl_stmt|;
comment|/* Expressions in the resulting FOR loop */
name|test
operator|=
name|ENULL
expr_stmt|;
name|pushctl
argument_list|(
name|CTLDO
argument_list|)
expr_stmt|;
name|dorange
operator|=
name|ctlstack
operator|->
name|dolabel
operator|=
name|range
expr_stmt|;
name|ctlstack
operator|->
name|loopname
operator|=
name|loopname
expr_stmt|;
comment|/* Declare the loop index */
name|np
operator|=
operator|(
name|Namep
operator|)
name|spec
operator|->
name|datap
expr_stmt|;
name|ctlstack
operator|->
name|donamep
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|np
condition|)
block|{
comment|/* do while */
name|ctlstack
operator|->
name|dowhile
operator|=
literal|1
expr_stmt|;
if|#
directive|if
literal|0
block|if (loopname) { 			if (loopname->vtype == TYUNKNOWN) { 				loopname->vdcldone = 1; 				loopname->vclass = CLLABEL; 				loopname->vprocclass = PLABEL; 				loopname->vtype = TYLABEL; 				} 			if (loopname->vtype == TYLABEL) 				if (loopname->vdovar) 					dclerr("already in use as a loop name", 						loopname); 				else 					loopname->vdovar = 1; 			else 				dclerr("already declared; cannot be a loop name", 					loopname); 			}
endif|#
directive|endif
name|putwhile
argument_list|(
operator|(
name|expptr
operator|)
name|spec
operator|->
name|nextp
argument_list|)
expr_stmt|;
name|NOEXT
argument_list|(
literal|"do while"
argument_list|)
expr_stmt|;
name|spec
operator|->
name|nextp
operator|=
literal|0
expr_stmt|;
name|frchain
argument_list|(
operator|&
name|spec
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|np
operator|->
name|vdovar
condition|)
block|{
name|errstr
argument_list|(
literal|"nested loops with variable %s"
argument_list|,
name|np
operator|->
name|fvarname
argument_list|)
expr_stmt|;
name|ctlstack
operator|->
name|donamep
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
comment|/* Create a memory-resident version of the index variable */
name|dovarp
operator|=
name|mkplace
argument_list|(
name|np
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ONEOF
argument_list|(
name|dovarp
operator|->
name|vtype
argument_list|,
name|MSKINT
operator||
name|MSKREAL
argument_list|)
condition|)
block|{
name|err
argument_list|(
literal|"bad type on do variable"
argument_list|)
expr_stmt|;
return|return;
block|}
name|ctlstack
operator|->
name|donamep
operator|=
name|np
expr_stmt|;
name|np
operator|->
name|vdovar
operator|=
name|YES
expr_stmt|;
comment|/* Now   dovarp   points to the index to be used within the loop,   dostgp    points to the one which may need to be stored */
name|dotype
operator|=
name|dovarp
operator|->
name|vtype
expr_stmt|;
comment|/* Count the input specifications and type-check each one independently;    this just eliminates non-numeric values from the specification */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|cp
operator|=
name|spec
operator|->
name|nextp
init|;
name|cp
operator|!=
name|NULL
operator|&&
name|i
operator|<
literal|3
condition|;
name|cp
operator|=
name|cp
operator|->
name|nextp
control|)
block|{
name|p
operator|=
name|par
index|[
name|i
operator|++
index|]
operator|=
name|fixtype
argument_list|(
operator|(
name|tagptr
operator|)
name|cp
operator|->
name|datap
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ONEOF
argument_list|(
name|p
operator|->
name|headblock
operator|.
name|vtype
argument_list|,
name|MSKINT
operator||
name|MSKREAL
argument_list|)
condition|)
block|{
name|err
argument_list|(
literal|"bad type on DO parameter"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|frchain
argument_list|(
operator|&
name|spec
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|i
condition|)
block|{
case|case
literal|0
case|:
case|case
literal|1
case|:
name|err
argument_list|(
literal|"too few DO parameters"
argument_list|)
expr_stmt|;
return|return;
default|default:
name|err
argument_list|(
literal|"too many DO parameters"
argument_list|)
expr_stmt|;
return|return;
case|case
literal|2
case|:
name|DOINCR
operator|=
operator|(
name|expptr
operator|)
name|ICON
argument_list|(
literal|1
argument_list|)
expr_stmt|;
case|case
literal|3
case|:
break|break;
block|}
comment|/* Now all of the local specification fields are set, but their types are    not yet consistent */
comment|/* Declare the loop initialization value, casting it properly and declaring a    register if need be */
name|ctlstack
operator|->
name|doinit
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ISCONST
argument_list|(
name|DOINIT
argument_list|)
operator|||
operator|!
name|onetripflag
condition|)
comment|/* putx added 6-29-89 (mwm), not sure if fixtype is required, but I doubt it    since mkconv is called just before */
name|doinit
operator|=
name|putx
argument_list|(
name|mkconv
argument_list|(
name|dotype
argument_list|,
name|DOINIT
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|onetripflag
condition|)
name|ctlstack
operator|->
name|doinit
operator|=
name|doinit
operator|=
operator|(
name|expptr
operator|)
name|mktmp0
argument_list|(
name|dotype
argument_list|,
name|ENULL
argument_list|)
expr_stmt|;
else|else
name|doinit
operator|=
operator|(
name|expptr
operator|)
name|mktmp
argument_list|(
name|dotype
argument_list|,
name|ENULL
argument_list|)
expr_stmt|;
name|puteq
argument_list|(
name|cpexpr
argument_list|(
name|doinit
argument_list|)
argument_list|,
name|DOINIT
argument_list|)
expr_stmt|;
block|}
comment|/* else */
comment|/* Declare the loop ending value, casting it to the type of the index    variable */
if|if
condition|(
name|ISCONST
argument_list|(
name|DOLIMIT
argument_list|)
condition|)
name|ctlstack
operator|->
name|domax
operator|=
name|mkconv
argument_list|(
name|dotype
argument_list|,
name|DOLIMIT
argument_list|)
expr_stmt|;
else|else
block|{
name|ctlstack
operator|->
name|domax
operator|=
operator|(
name|expptr
operator|)
name|mktmp0
argument_list|(
name|dotype
argument_list|,
name|ENULL
argument_list|)
expr_stmt|;
name|puteq
argument_list|(
name|cpexpr
argument_list|(
name|ctlstack
operator|->
name|domax
argument_list|)
argument_list|,
name|DOLIMIT
argument_list|)
expr_stmt|;
block|}
comment|/* else */
comment|/* Declare the loop increment value, casting it to the type of the index    variable */
if|if
condition|(
name|ISCONST
argument_list|(
name|DOINCR
argument_list|)
condition|)
block|{
name|ctlstack
operator|->
name|dostep
operator|=
name|mkconv
argument_list|(
name|dotype
argument_list|,
name|DOINCR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|incsign
operator|=
name|conssgn
argument_list|(
name|ctlstack
operator|->
name|dostep
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|err
argument_list|(
literal|"zero DO increment"
argument_list|)
expr_stmt|;
name|ctlstack
operator|->
name|dostepsign
operator|=
operator|(
name|incsign
operator|>
literal|0
condition|?
name|POSSTEP
else|:
name|NEGSTEP
operator|)
expr_stmt|;
block|}
else|else
block|{
name|ctlstack
operator|->
name|dostep
operator|=
operator|(
name|expptr
operator|)
name|mktmp0
argument_list|(
name|dotype
argument_list|,
name|ENULL
argument_list|)
expr_stmt|;
name|ctlstack
operator|->
name|dostepsign
operator|=
name|VARSTEP
expr_stmt|;
name|puteq
argument_list|(
name|cpexpr
argument_list|(
name|ctlstack
operator|->
name|dostep
argument_list|)
argument_list|,
name|DOINCR
argument_list|)
expr_stmt|;
block|}
comment|/* All data is now properly typed and in the   ctlstack,   except for the    initial value.  Assignments of temps have been generated already */
switch|switch
condition|(
name|ctlstack
operator|->
name|dostepsign
condition|)
block|{
case|case
name|VARSTEP
case|:
name|test
operator|=
name|mkexpr
argument_list|(
name|OPQUEST
argument_list|,
name|mkexpr
argument_list|(
name|OPLT
argument_list|,
name|cpexpr
argument_list|(
name|ctlstack
operator|->
name|dostep
argument_list|)
argument_list|,
name|ICON
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|,
name|mkexpr
argument_list|(
name|OPCOLON
argument_list|,
name|mkexpr
argument_list|(
name|OPGE
argument_list|,
name|cpexpr
argument_list|(
operator|(
name|expptr
operator|)
name|dovarp
argument_list|)
argument_list|,
name|cpexpr
argument_list|(
name|ctlstack
operator|->
name|domax
argument_list|)
argument_list|)
argument_list|,
name|mkexpr
argument_list|(
name|OPLE
argument_list|,
name|cpexpr
argument_list|(
operator|(
name|expptr
operator|)
name|dovarp
argument_list|)
argument_list|,
name|cpexpr
argument_list|(
name|ctlstack
operator|->
name|domax
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|POSSTEP
case|:
name|test
operator|=
name|mkexpr
argument_list|(
name|OPLE
argument_list|,
name|cpexpr
argument_list|(
operator|(
name|expptr
operator|)
name|dovarp
argument_list|)
argument_list|,
name|cpexpr
argument_list|(
name|ctlstack
operator|->
name|domax
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|NEGSTEP
case|:
name|test
operator|=
name|mkexpr
argument_list|(
name|OPGE
argument_list|,
name|cpexpr
argument_list|(
operator|(
name|expptr
operator|)
name|dovarp
argument_list|)
argument_list|,
name|cpexpr
argument_list|(
name|ctlstack
operator|->
name|domax
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|erri
argument_list|(
literal|"exdo:  bad dostepsign '%d'"
argument_list|,
name|ctlstack
operator|->
name|dostepsign
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* switch (ctlstack -> dostepsign) */
if|if
condition|(
name|onetripflag
condition|)
name|test
operator|=
name|mkexpr
argument_list|(
name|OPOR
argument_list|,
name|test
argument_list|,
name|mkexpr
argument_list|(
name|OPEQ
argument_list|,
name|cpexpr
argument_list|(
operator|(
name|expptr
operator|)
name|dovarp
argument_list|)
argument_list|,
name|cpexpr
argument_list|(
name|doinit
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|init
operator|=
name|mkexpr
argument_list|(
name|OPASSIGN
argument_list|,
name|cpexpr
argument_list|(
operator|(
name|expptr
operator|)
name|dovarp
argument_list|)
argument_list|,
name|ctlstack
operator|->
name|doinit
condition|?
name|cpexpr
argument_list|(
name|doinit
argument_list|)
else|:
name|doinit
argument_list|)
expr_stmt|;
name|inc
operator|=
name|mkexpr
argument_list|(
name|OPPLUSEQ
argument_list|,
operator|(
name|expptr
operator|)
name|dovarp
argument_list|,
name|cpexpr
argument_list|(
name|ctlstack
operator|->
name|dostep
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|onetripflag
operator|&&
name|ISCONST
argument_list|(
name|ctlstack
operator|->
name|domax
argument_list|)
operator|&&
name|ISCONST
argument_list|(
name|doinit
argument_list|)
operator|&&
name|ctlstack
operator|->
name|dostepsign
operator|!=
name|VARSTEP
condition|)
block|{
name|expptr
name|tester
decl_stmt|;
name|tester
operator|=
name|mkexpr
argument_list|(
name|OPMINUS
argument_list|,
name|cpexpr
argument_list|(
name|doinit
argument_list|)
argument_list|,
name|cpexpr
argument_list|(
name|ctlstack
operator|->
name|domax
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|incsign
operator|==
name|conssgn
argument_list|(
name|tester
argument_list|)
condition|)
name|warn
argument_list|(
literal|"DO range never executed"
argument_list|)
expr_stmt|;
name|frexpr
argument_list|(
name|tester
argument_list|)
expr_stmt|;
block|}
comment|/* if !onetripflag&& */
name|p1_for
argument_list|(
name|init
argument_list|,
name|test
argument_list|,
name|inc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|exenddo
parameter_list|(
name|np
parameter_list|)
name|Namep
name|np
decl_stmt|;
else|#
directive|else
function|exenddo
parameter_list|(
name|Namep
name|np
parameter_list|)
endif|#
directive|endif
block|{
name|Namep
name|np1
decl_stmt|;
name|int
name|here
decl_stmt|;
name|struct
name|Ctlframe
modifier|*
name|cf
decl_stmt|;
if|if
condition|(
name|ctlstack
operator|<
name|ctls
condition|)
goto|goto
name|misplaced
goto|;
name|here
operator|=
name|ctlstack
operator|->
name|dolabel
expr_stmt|;
if|if
condition|(
name|ctlstack
operator|->
name|ctltype
operator|!=
name|CTLDO
operator|||
name|here
operator|>=
literal|0
operator|&&
operator|(
operator|!
name|thislabel
operator|||
name|thislabel
operator|->
name|labelno
operator|!=
name|here
operator|)
condition|)
block|{
name|misplaced
label|:
name|err
argument_list|(
literal|"misplaced ENDDO"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|np
operator|!=
name|ctlstack
operator|->
name|loopname
condition|)
block|{
if|if
condition|(
name|np1
operator|=
name|ctlstack
operator|->
name|loopname
condition|)
name|errstr
argument_list|(
literal|"expected \"enddo %s\""
argument_list|,
name|np1
operator|->
name|fvarname
argument_list|)
expr_stmt|;
else|else
name|err
argument_list|(
literal|"expected unnamed ENDDO"
argument_list|)
expr_stmt|;
for|for
control|(
name|cf
operator|=
name|ctls
init|;
name|cf
operator|<
name|ctlstack
condition|;
name|cf
operator|++
control|)
if|if
condition|(
name|cf
operator|->
name|ctltype
operator|==
name|CTLDO
operator|&&
name|cf
operator|->
name|loopname
operator|==
name|np
condition|)
block|{
name|here
operator|=
name|cf
operator|->
name|dolabel
expr_stmt|;
break|break;
block|}
block|}
name|enddo
argument_list|(
name|here
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|enddo
parameter_list|(
name|here
parameter_list|)
name|int
name|here
decl_stmt|;
else|#
directive|else
function|enddo
parameter_list|(
name|int
name|here
parameter_list|)
endif|#
directive|endif
block|{
specifier|register
name|struct
name|Ctlframe
modifier|*
name|q
decl_stmt|;
name|Namep
name|np
decl_stmt|;
comment|/* name of the current DO index */
name|Addrp
name|ap
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|expptr
name|e
decl_stmt|;
comment|/* Many DO's can end at the same statement, so keep looping over all    nested indicies */
while|while
condition|(
name|here
operator|==
name|dorange
condition|)
block|{
if|if
condition|(
name|np
operator|=
name|ctlstack
operator|->
name|donamep
condition|)
block|{
name|p1for_end
argument_list|()
expr_stmt|;
comment|/* Now we're done with all of the tests, and the loop has terminated.    Store the index value back in long-term memory */
if|if
condition|(
name|ap
operator|=
name|memversion
argument_list|(
name|np
argument_list|)
condition|)
name|puteq
argument_list|(
operator|(
name|expptr
operator|)
name|ap
argument_list|,
operator|(
name|expptr
operator|)
name|mkplace
argument_list|(
name|np
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
operator|++
name|i
control|)
name|ctlstack
operator|->
name|ctlabels
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|deregister
argument_list|(
name|ctlstack
operator|->
name|donamep
argument_list|)
expr_stmt|;
name|ctlstack
operator|->
name|donamep
operator|->
name|vdovar
operator|=
name|NO
expr_stmt|;
comment|/* ctlstack->dostep and ctlstack->domax can be zero */
comment|/* with sufficiently bizarre (erroneous) syntax */
if|if
condition|(
name|e
operator|=
name|ctlstack
operator|->
name|dostep
condition|)
if|if
condition|(
name|e
operator|->
name|tag
operator|==
name|TADDR
operator|&&
name|e
operator|->
name|addrblock
operator|.
name|istemp
condition|)
name|frtemp
argument_list|(
operator|(
name|Addrp
operator|)
name|e
argument_list|)
expr_stmt|;
else|else
name|frexpr
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|=
name|ctlstack
operator|->
name|domax
condition|)
if|if
condition|(
name|e
operator|->
name|tag
operator|==
name|TADDR
operator|&&
name|e
operator|->
name|addrblock
operator|.
name|istemp
condition|)
name|frtemp
argument_list|(
operator|(
name|Addrp
operator|)
name|e
argument_list|)
expr_stmt|;
else|else
name|frexpr
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|=
name|ctlstack
operator|->
name|doinit
condition|)
name|frtemp
argument_list|(
operator|(
name|Addrp
operator|)
name|e
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctlstack
operator|->
name|dowhile
condition|)
name|p1for_end
argument_list|()
expr_stmt|;
comment|/* Set   dorange   to the closing label of the next most enclosing DO loop    */
name|popctl
argument_list|()
expr_stmt|;
name|poplab
argument_list|()
expr_stmt|;
name|dorange
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|q
operator|=
name|ctlstack
init|;
name|q
operator|>=
name|ctls
condition|;
operator|--
name|q
control|)
if|if
condition|(
name|q
operator|->
name|ctltype
operator|==
name|CTLDO
condition|)
block|{
name|dorange
operator|=
name|q
operator|->
name|dolabel
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|exassign
parameter_list|(
name|vname
parameter_list|,
name|labelval
parameter_list|)
specifier|register
name|Namep
name|vname
decl_stmt|;
name|struct
name|Labelblock
modifier|*
name|labelval
decl_stmt|;
else|#
directive|else
function|exassign
parameter_list|(
specifier|register
name|Namep
name|vname
parameter_list|,
name|struct
name|Labelblock
modifier|*
name|labelval
parameter_list|)
endif|#
directive|endif
block|{
name|Addrp
name|p
decl_stmt|;
specifier|register
name|Addrp
name|q
decl_stmt|;
name|char
modifier|*
name|fs
decl_stmt|;
specifier|register
name|chainp
name|cp
decl_stmt|,
name|cpprev
decl_stmt|;
specifier|register
name|ftnint
name|k
decl_stmt|,
name|stno
decl_stmt|;
name|p
operator|=
name|mkplace
argument_list|(
name|vname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ONEOF
argument_list|(
name|p
operator|->
name|vtype
argument_list|,
name|MSKINT
operator||
name|MSKADDR
argument_list|)
condition|)
block|{
name|err
argument_list|(
literal|"noninteger assign variable"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If the label hasn't been defined, then we do things twice: 	 * once for an executable stmt label, once for a format 	 */
comment|/* code for executable label... */
comment|/* Now store the assigned value in a list associated with this variable.    This will be used later to generate a switch() statement in the C output */
name|fs
operator|=
name|labelval
operator|->
name|fmtstring
expr_stmt|;
if|if
condition|(
operator|!
name|labelval
operator|->
name|labdefined
operator|||
operator|!
name|fs
condition|)
block|{
if|if
condition|(
name|vname
operator|->
name|vis_assigned
operator|==
literal|0
condition|)
block|{
name|vname
operator|->
name|varxptr
operator|.
name|assigned_values
operator|=
name|CHNULL
expr_stmt|;
name|vname
operator|->
name|vis_assigned
operator|=
literal|1
expr_stmt|;
block|}
comment|/* don't duplicate labels... */
name|stno
operator|=
name|labelval
operator|->
name|stateno
expr_stmt|;
name|cpprev
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
operator|,
name|cp
operator|=
name|vname
operator|->
name|varxptr
operator|.
name|assigned_values
init|;
name|cp
condition|;
name|cpprev
operator|=
name|cp
operator|,
name|cp
operator|=
name|cp
operator|->
name|nextp
operator|,
name|k
operator|++
control|)
if|if
condition|(
operator|(
name|ftnint
operator|)
name|cp
operator|->
name|datap
operator|==
name|stno
condition|)
break|break;
if|if
condition|(
operator|!
name|cp
condition|)
block|{
name|cp
operator|=
name|mkchain
argument_list|(
operator|(
name|char
operator|*
operator|)
name|stno
argument_list|,
name|CHNULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpprev
condition|)
name|cpprev
operator|->
name|nextp
operator|=
name|cp
expr_stmt|;
else|else
name|vname
operator|->
name|varxptr
operator|.
name|assigned_values
operator|=
name|cp
expr_stmt|;
name|labelval
operator|->
name|labused
operator|=
literal|1
expr_stmt|;
block|}
name|putout
argument_list|(
name|mkexpr
argument_list|(
name|OPASSIGN
argument_list|,
operator|(
name|expptr
operator|)
name|p
argument_list|,
name|mkintcon
argument_list|(
name|k
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Code for FORMAT label... */
if|if
condition|(
operator|!
name|labelval
operator|->
name|labdefined
operator|||
name|fs
condition|)
block|{
name|labelval
operator|->
name|fmtlabused
operator|=
literal|1
expr_stmt|;
name|p
operator|=
name|ALLOC
argument_list|(
name|Addrblock
argument_list|)
expr_stmt|;
name|p
operator|->
name|tag
operator|=
name|TADDR
expr_stmt|;
name|p
operator|->
name|vtype
operator|=
name|TYCHAR
expr_stmt|;
name|p
operator|->
name|vstg
operator|=
name|STGAUTO
expr_stmt|;
name|p
operator|->
name|memoffset
operator|=
name|ICON
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|fmtname
argument_list|(
name|vname
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|q
operator|=
name|ALLOC
argument_list|(
name|Addrblock
argument_list|)
expr_stmt|;
name|q
operator|->
name|tag
operator|=
name|TADDR
expr_stmt|;
name|q
operator|->
name|vtype
operator|=
name|TYCHAR
expr_stmt|;
name|q
operator|->
name|vstg
operator|=
name|STGAUTO
expr_stmt|;
name|q
operator|->
name|ntempelt
operator|=
literal|1
expr_stmt|;
name|q
operator|->
name|memoffset
operator|=
name|ICON
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|q
operator|->
name|uname_tag
operator|=
name|UNAM_IDENT
expr_stmt|;
name|sprintf
argument_list|(
name|q
operator|->
name|user
operator|.
name|ident
argument_list|,
literal|"fmt_%ld"
argument_list|,
name|labelval
operator|->
name|stateno
argument_list|)
expr_stmt|;
name|putout
argument_list|(
name|mkexpr
argument_list|(
name|OPASSIGN
argument_list|,
operator|(
name|expptr
operator|)
name|p
argument_list|,
operator|(
name|expptr
operator|)
name|q
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* exassign */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|exarif
parameter_list|(
name|expr
parameter_list|,
name|neglab
parameter_list|,
name|zerlab
parameter_list|,
name|poslab
parameter_list|)
name|expptr
name|expr
decl_stmt|;
name|struct
name|Labelblock
modifier|*
name|neglab
decl_stmt|;
name|struct
name|Labelblock
modifier|*
name|zerlab
decl_stmt|;
name|struct
name|Labelblock
modifier|*
name|poslab
decl_stmt|;
else|#
directive|else
function|exarif
parameter_list|(
name|expptr
name|expr
parameter_list|,
name|struct
name|Labelblock
modifier|*
name|neglab
parameter_list|,
name|struct
name|Labelblock
modifier|*
name|zerlab
parameter_list|,
name|struct
name|Labelblock
modifier|*
name|poslab
parameter_list|)
endif|#
directive|endif
block|{
specifier|register
name|int
name|lm
decl_stmt|,
name|lz
decl_stmt|,
name|lp
decl_stmt|;
name|lm
operator|=
name|neglab
operator|->
name|stateno
expr_stmt|;
name|lz
operator|=
name|zerlab
operator|->
name|stateno
expr_stmt|;
name|lp
operator|=
name|poslab
operator|->
name|stateno
expr_stmt|;
name|expr
operator|=
name|fixtype
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ONEOF
argument_list|(
name|expr
operator|->
name|headblock
operator|.
name|vtype
argument_list|,
name|MSKINT
operator||
name|MSKREAL
argument_list|)
condition|)
block|{
name|err
argument_list|(
literal|"invalid type of arithmetic if expression"
argument_list|)
expr_stmt|;
name|frexpr
argument_list|(
name|expr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|lm
operator|==
name|lz
operator|&&
name|lz
operator|==
name|lp
condition|)
name|exgoto
argument_list|(
name|neglab
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|lm
operator|==
name|lz
condition|)
name|exar2
argument_list|(
name|OPLE
argument_list|,
name|expr
argument_list|,
name|neglab
argument_list|,
name|poslab
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|lm
operator|==
name|lp
condition|)
name|exar2
argument_list|(
name|OPNE
argument_list|,
name|expr
argument_list|,
name|neglab
argument_list|,
name|zerlab
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|lz
operator|==
name|lp
condition|)
name|exar2
argument_list|(
name|OPGE
argument_list|,
name|expr
argument_list|,
name|zerlab
argument_list|,
name|neglab
argument_list|)
expr_stmt|;
else|else
block|{
name|expptr
name|t
decl_stmt|;
if|if
condition|(
operator|!
name|addressable
argument_list|(
name|expr
argument_list|)
condition|)
block|{
name|t
operator|=
operator|(
name|expptr
operator|)
name|mktmp
argument_list|(
name|expr
operator|->
name|headblock
operator|.
name|vtype
argument_list|,
name|ENULL
argument_list|)
expr_stmt|;
name|expr
operator|=
name|mkexpr
argument_list|(
name|OPASSIGN
argument_list|,
name|cpexpr
argument_list|(
name|t
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
block|}
else|else
name|t
operator|=
operator|(
name|expptr
operator|)
name|cpexpr
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|p1_if
argument_list|(
name|putx
argument_list|(
name|fixtype
argument_list|(
name|mkexpr
argument_list|(
name|OPLT
argument_list|,
name|expr
argument_list|,
name|ICON
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|exgoto
argument_list|(
name|neglab
argument_list|)
expr_stmt|;
name|p1_elif
argument_list|(
name|mkexpr
argument_list|(
name|OPEQ
argument_list|,
name|t
argument_list|,
name|ICON
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|exgoto
argument_list|(
name|zerlab
argument_list|)
expr_stmt|;
name|p1_else
argument_list|()
expr_stmt|;
name|exgoto
argument_list|(
name|poslab
argument_list|)
expr_stmt|;
name|p1else_end
argument_list|()
expr_stmt|;
block|}
comment|/* else */
block|}
block|}
end_function

begin_comment
comment|/* exar2 -- Do arithmetic IF for only 2 distinct labels;   if !(e.op.0)    goto l2 else goto l1.  If this seems backwards, that's because it is,    in order to make the 1 pass algorithm work. */
end_comment

begin_function
name|LOCAL
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|exar2
parameter_list|(
name|op
parameter_list|,
name|e
parameter_list|,
name|l1
parameter_list|,
name|l2
parameter_list|)
name|int
name|op
decl_stmt|;
name|expptr
name|e
decl_stmt|;
name|struct
name|Labelblock
modifier|*
name|l1
decl_stmt|;
name|struct
name|Labelblock
modifier|*
name|l2
decl_stmt|;
else|#
directive|else
function|exar2
parameter_list|(
name|int
name|op
parameter_list|,
name|expptr
name|e
parameter_list|,
name|struct
name|Labelblock
modifier|*
name|l1
parameter_list|,
name|struct
name|Labelblock
modifier|*
name|l2
parameter_list|)
endif|#
directive|endif
block|{
name|expptr
name|comp
decl_stmt|;
name|comp
operator|=
name|mkexpr
argument_list|(
name|op
argument_list|,
name|e
argument_list|,
name|ICON
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|p1_if
argument_list|(
name|putx
argument_list|(
name|fixtype
argument_list|(
name|comp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|exgoto
argument_list|(
name|l1
argument_list|)
expr_stmt|;
name|p1_else
argument_list|()
expr_stmt|;
name|exgoto
argument_list|(
name|l2
argument_list|)
expr_stmt|;
name|p1else_end
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* exreturn -- return the value in   p  from a SUBROUTINE call -- used to    implement the alternate return mechanism */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|exreturn
parameter_list|(
name|p
parameter_list|)
specifier|register
name|expptr
name|p
decl_stmt|;
else|#
directive|else
function|exreturn
parameter_list|(
specifier|register
name|expptr
name|p
parameter_list|)
endif|#
directive|endif
block|{
if|if
condition|(
name|procclass
operator|!=
name|CLPROC
condition|)
name|warn
argument_list|(
literal|"RETURN statement in main or block data"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|&&
operator|(
name|proctype
operator|!=
name|TYSUBR
operator|||
name|procclass
operator|!=
name|CLPROC
operator|)
condition|)
block|{
name|err
argument_list|(
literal|"alternate return in nonsubroutine"
argument_list|)
expr_stmt|;
name|p
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|||
name|proctype
operator|==
name|TYSUBR
condition|)
block|{
if|if
condition|(
name|p
operator|==
name|ENULL
condition|)
name|p
operator|=
name|ICON
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|p
operator|=
name|mkconv
argument_list|(
name|TYLONG
argument_list|,
name|fixtype
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|p1_subr_ret
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
comment|/* if p || proctype == TYSUBR */
else|else
name|p1_subr_ret
argument_list|(
operator|(
name|expptr
operator|)
name|retslot
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|exasgoto
parameter_list|(
name|labvar
parameter_list|)
name|Namep
name|labvar
decl_stmt|;
else|#
directive|else
function|exasgoto
parameter_list|(
name|Namep
name|labvar
parameter_list|)
endif|#
directive|endif
block|{
specifier|register
name|Addrp
name|p
decl_stmt|;
name|p
operator|=
name|mkplace
argument_list|(
name|labvar
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ISINT
argument_list|(
name|p
operator|->
name|vtype
argument_list|)
condition|)
name|err
argument_list|(
literal|"assigned goto variable must be integer"
argument_list|)
expr_stmt|;
else|else
block|{
name|p1_asgoto
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
comment|/* else */
block|}
end_function

end_unit

