begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**************************************************************** Copyright 1990, 1991, 1993, 1994 by AT&T Bell Laboratories and Bellcore.  Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that the copyright notice and this permission notice and warranty disclaimer appear in supporting documentation, and that the names of AT&T Bell Laboratories or Bellcore or any of their entities not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  AT&T and Bellcore disclaim all warranties with regard to this software, including all implied warranties of merchantability and fitness.  In no event shall AT&T or Bellcore be liable for any special, indirect or consequential damages or any damages whatsoever resulting from loss of use, data or profits, whether in an action of contract, negligence or other tortious action, arising out of or in connection with the use or performance of this software. ****************************************************************/
end_comment

begin_comment
comment|/*  * INTERMEDIATE CODE GENERATION PROCEDURES COMMON TO BOTH  * JOHNSON (PORTABLE) AND RITCHIE FAMILIES OF SECOND PASSES */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"names.h"
end_include

begin_comment
comment|/* For LOCAL_CONST_NAME */
end_comment

begin_include
include|#
directive|include
file|"pccdefs.h"
end_include

begin_include
include|#
directive|include
file|"p1defs.h"
end_include

begin_comment
comment|/* Definitions for   putconst()   */
end_comment

begin_define
define|#
directive|define
name|LIT_CHAR
value|1
end_define

begin_define
define|#
directive|define
name|LIT_FLOAT
value|2
end_define

begin_define
define|#
directive|define
name|LIT_INT
value|3
end_define

begin_comment
comment|/* char *ops [ ] = 	{ 	"??", "+", "-", "*", "/", "**", "-", 	"OR", "AND", "EQV", "NEQV", "NOT", 	"CONCAT", 	"<", "==", ">", "<=", "!=", ">=", 	" of ", " ofC ", " = ", " += ", " *= ", " CONV ", "<< ", " % ", 	" , ", " ? ", " : " 	" abs ", " min ", " max ", " addr ", " indirect ", 	" bitor ", " bitand ", " bitxor ", " bitnot ", ">> ", 	}; */
end_comment

begin_comment
comment|/* Each of these values is defined in   pccdefs   */
end_comment

begin_decl_stmt
name|int
name|ops2
index|[ ]
init|=
block|{
name|P2BAD
block|,
name|P2PLUS
block|,
name|P2MINUS
block|,
name|P2STAR
block|,
name|P2SLASH
block|,
name|P2BAD
block|,
name|P2NEG
block|,
name|P2OROR
block|,
name|P2ANDAND
block|,
name|P2EQ
block|,
name|P2NE
block|,
name|P2NOT
block|,
name|P2BAD
block|,
name|P2LT
block|,
name|P2EQ
block|,
name|P2GT
block|,
name|P2LE
block|,
name|P2NE
block|,
name|P2GE
block|,
name|P2CALL
block|,
name|P2CALL
block|,
name|P2ASSIGN
block|,
name|P2PLUSEQ
block|,
name|P2STAREQ
block|,
name|P2CONV
block|,
name|P2LSHIFT
block|,
name|P2MOD
block|,
name|P2COMOP
block|,
name|P2QUEST
block|,
name|P2COLON
block|,
literal|1
block|,
name|P2BAD
block|,
name|P2BAD
block|,
name|P2BAD
block|,
name|P2BAD
block|,
name|P2BITOR
block|,
name|P2BITAND
block|,
name|P2BITXOR
block|,
name|P2BITNOT
block|,
name|P2RSHIFT
block|,
name|P2BAD
block|,
name|P2BAD
block|,
name|P2BAD
block|,
name|P2BAD
block|,
name|P2BAD
block|,
name|P2BAD
block|,
name|P2BAD
block|,
name|P2BAD
block|,
name|P2BAD
block|,
name|P2BAD
block|,
name|P2BAD
block|,
name|P2BAD
block|,
name|P2BAD
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
comment|/* OPNEG1, OPDMIN, OPDMAX, OPASSIGNI, OPIDENTITY */
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
comment|/* OPCHARCAST, OPDABS, OPMIN2, OPMAX2 */
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|putexpr
parameter_list|(
name|p
parameter_list|)
name|expptr
name|p
decl_stmt|;
else|#
directive|else
function|putexpr
parameter_list|(
name|expptr
name|p
parameter_list|)
endif|#
directive|endif
block|{
comment|/* Write the expression to the p1 file */
name|p
operator|=
operator|(
name|expptr
operator|)
name|putx
argument_list|(
name|fixtype
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|p1_expr
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|expptr
ifdef|#
directive|ifdef
name|KR_headers
name|putassign
parameter_list|(
name|lp
parameter_list|,
name|rp
parameter_list|)
name|expptr
name|lp
decl_stmt|;
name|expptr
name|rp
decl_stmt|;
else|#
directive|else
function|putassign
parameter_list|(
name|expptr
name|lp
parameter_list|,
name|expptr
name|rp
parameter_list|)
endif|#
directive|endif
block|{
return|return
name|putx
argument_list|(
name|fixexpr
argument_list|(
operator|(
name|Exprp
operator|)
name|mkexpr
argument_list|(
name|OPASSIGN
argument_list|,
name|lp
argument_list|,
name|rp
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|puteq
parameter_list|(
name|lp
parameter_list|,
name|rp
parameter_list|)
name|expptr
name|lp
decl_stmt|;
name|expptr
name|rp
decl_stmt|;
else|#
directive|else
function|puteq
parameter_list|(
name|expptr
name|lp
parameter_list|,
name|expptr
name|rp
parameter_list|)
endif|#
directive|endif
block|{
name|putexpr
argument_list|(
name|mkexpr
argument_list|(
name|OPASSIGN
argument_list|,
name|lp
argument_list|,
name|rp
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* put code for  a *= b */
end_comment

begin_function
name|expptr
ifdef|#
directive|ifdef
name|KR_headers
name|putsteq
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
name|Addrp
name|a
decl_stmt|;
name|Addrp
name|b
decl_stmt|;
else|#
directive|else
function|putsteq
parameter_list|(
name|Addrp
name|a
parameter_list|,
name|Addrp
name|b
parameter_list|)
endif|#
directive|endif
block|{
return|return
name|putx
argument_list|(
name|fixexpr
argument_list|(
operator|(
name|Exprp
operator|)
name|mkexpr
argument_list|(
name|OPSTAREQ
argument_list|,
name|cpexpr
argument_list|(
operator|(
name|expptr
operator|)
name|a
argument_list|)
argument_list|,
name|cpexpr
argument_list|(
operator|(
name|expptr
operator|)
name|b
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|Addrp
ifdef|#
directive|ifdef
name|KR_headers
name|mkfield
parameter_list|(
name|res
parameter_list|,
name|f
parameter_list|,
name|ty
parameter_list|)
specifier|register
name|Addrp
name|res
decl_stmt|;
name|char
modifier|*
name|f
decl_stmt|;
name|int
name|ty
decl_stmt|;
else|#
directive|else
function|mkfield
parameter_list|(
specifier|register
name|Addrp
name|res
parameter_list|,
name|char
modifier|*
name|f
parameter_list|,
name|int
name|ty
parameter_list|)
endif|#
directive|endif
block|{
name|res
operator|->
name|vtype
operator|=
name|ty
expr_stmt|;
name|res
operator|->
name|Field
operator|=
name|f
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/* mkfield */
end_comment

begin_function
name|Addrp
ifdef|#
directive|ifdef
name|KR_headers
name|realpart
parameter_list|(
name|p
parameter_list|)
specifier|register
name|Addrp
name|p
decl_stmt|;
else|#
directive|else
function|realpart
parameter_list|(
specifier|register
name|Addrp
name|p
parameter_list|)
endif|#
directive|endif
block|{
specifier|register
name|Addrp
name|q
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|tag
operator|==
name|TADDR
operator|&&
name|p
operator|->
name|uname_tag
operator|==
name|UNAM_CONST
operator|&&
name|ISCOMPLEX
argument_list|(
name|p
operator|->
name|vtype
argument_list|)
condition|)
return|return
operator|(
name|Addrp
operator|)
name|mkrealcon
argument_list|(
name|p
operator|->
name|vtype
operator|+
name|TYREAL
operator|-
name|TYCOMPLEX
argument_list|,
name|p
operator|->
name|user
operator|.
name|kludge
operator|.
name|vstg1
condition|?
name|p
operator|->
name|user
operator|.
name|Const
operator|.
name|cds
index|[
literal|0
index|]
else|:
name|cds
argument_list|(
name|dtos
argument_list|(
name|p
operator|->
name|user
operator|.
name|Const
operator|.
name|cd
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|CNULL
argument_list|)
argument_list|)
return|;
name|q
operator|=
operator|(
name|Addrp
operator|)
name|cpexpr
argument_list|(
operator|(
name|expptr
operator|)
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISCOMPLEX
argument_list|(
name|p
operator|->
name|vtype
argument_list|)
condition|)
name|q
operator|=
name|mkfield
argument_list|(
name|q
argument_list|,
literal|"r"
argument_list|,
name|p
operator|->
name|vtype
operator|+
name|TYREAL
operator|-
name|TYCOMPLEX
argument_list|)
expr_stmt|;
return|return
operator|(
name|q
operator|)
return|;
block|}
end_function

begin_function
name|expptr
ifdef|#
directive|ifdef
name|KR_headers
name|imagpart
parameter_list|(
name|p
parameter_list|)
specifier|register
name|Addrp
name|p
decl_stmt|;
else|#
directive|else
function|imagpart
parameter_list|(
specifier|register
name|Addrp
name|p
parameter_list|)
endif|#
directive|endif
block|{
specifier|register
name|Addrp
name|q
decl_stmt|;
if|if
condition|(
name|ISCOMPLEX
argument_list|(
name|p
operator|->
name|vtype
argument_list|)
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|tag
operator|==
name|TADDR
operator|&&
name|p
operator|->
name|uname_tag
operator|==
name|UNAM_CONST
condition|)
return|return
name|mkrealcon
argument_list|(
name|p
operator|->
name|vtype
operator|+
name|TYREAL
operator|-
name|TYCOMPLEX
argument_list|,
name|p
operator|->
name|user
operator|.
name|kludge
operator|.
name|vstg1
condition|?
name|p
operator|->
name|user
operator|.
name|Const
operator|.
name|cds
index|[
literal|1
index|]
else|:
name|cds
argument_list|(
name|dtos
argument_list|(
name|p
operator|->
name|user
operator|.
name|Const
operator|.
name|cd
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|CNULL
argument_list|)
argument_list|)
return|;
name|q
operator|=
operator|(
name|Addrp
operator|)
name|cpexpr
argument_list|(
operator|(
name|expptr
operator|)
name|p
argument_list|)
expr_stmt|;
name|q
operator|=
name|mkfield
argument_list|(
name|q
argument_list|,
literal|"i"
argument_list|,
name|p
operator|->
name|vtype
operator|+
name|TYREAL
operator|-
name|TYCOMPLEX
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|expptr
operator|)
name|q
operator|)
return|;
block|}
else|else
comment|/* Cast an integer type onto a Double Real type */
return|return
operator|(
name|mkrealcon
argument_list|(
name|ISINT
argument_list|(
name|p
operator|->
name|vtype
argument_list|)
condition|?
name|TYDREAL
else|:
name|p
operator|->
name|vtype
argument_list|,
literal|"0"
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ncat -- computes the number of adjacent concatenation operations */
end_comment

begin_function
name|int
ifdef|#
directive|ifdef
name|KR_headers
name|ncat
parameter_list|(
name|p
parameter_list|)
specifier|register
name|expptr
name|p
decl_stmt|;
else|#
directive|else
function|ncat
parameter_list|(
specifier|register
name|expptr
name|p
parameter_list|)
endif|#
directive|endif
block|{
if|if
condition|(
name|p
operator|->
name|tag
operator|==
name|TEXPR
operator|&&
name|p
operator|->
name|exprblock
operator|.
name|opcode
operator|==
name|OPCONCAT
condition|)
return|return
operator|(
name|ncat
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|leftp
argument_list|)
operator|+
name|ncat
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|rightp
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* lencat -- returns the length of the concatenated string.  Each    substring must have a static (i.e. compile-time) fixed length */
end_comment

begin_function
name|ftnint
ifdef|#
directive|ifdef
name|KR_headers
name|lencat
parameter_list|(
name|p
parameter_list|)
specifier|register
name|expptr
name|p
decl_stmt|;
else|#
directive|else
function|lencat
parameter_list|(
specifier|register
name|expptr
name|p
parameter_list|)
endif|#
directive|endif
block|{
if|if
condition|(
name|p
operator|->
name|tag
operator|==
name|TEXPR
operator|&&
name|p
operator|->
name|exprblock
operator|.
name|opcode
operator|==
name|OPCONCAT
condition|)
return|return
operator|(
name|lencat
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|leftp
argument_list|)
operator|+
name|lencat
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|rightp
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
name|p
operator|->
name|headblock
operator|.
name|vleng
operator|!=
name|NULL
operator|&&
name|ISICON
argument_list|(
name|p
operator|->
name|headblock
operator|.
name|vleng
argument_list|)
condition|)
return|return
operator|(
name|p
operator|->
name|headblock
operator|.
name|vleng
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
operator|)
return|;
elseif|else
if|if
condition|(
name|p
operator|->
name|tag
operator|==
name|TADDR
operator|&&
name|p
operator|->
name|addrblock
operator|.
name|varleng
operator|!=
literal|0
condition|)
return|return
operator|(
name|p
operator|->
name|addrblock
operator|.
name|varleng
operator|)
return|;
else|else
block|{
name|err
argument_list|(
literal|"impossible element in concatenation"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* putconst -- Creates a new Addrp value which maps onto the input    constant value.  The Addrp doesn't retain the value of the constant,    instead that value is copied into a table of constants (called    litpool,   for pool of literal values).  The only way to retrieve the    actual value of the constant is to look at the   memno   field of the    Addrp result.  You know that the associated literal is the one referred    to by   q   when   (q -> memno == litp -> litnum). */
end_comment

begin_function
name|Addrp
ifdef|#
directive|ifdef
name|KR_headers
name|putconst
parameter_list|(
name|p
parameter_list|)
specifier|register
name|Constp
name|p
decl_stmt|;
else|#
directive|else
function|putconst
parameter_list|(
specifier|register
name|Constp
name|p
parameter_list|)
endif|#
directive|endif
block|{
specifier|register
name|Addrp
name|q
decl_stmt|;
name|struct
name|Literal
modifier|*
name|litp
decl_stmt|,
modifier|*
name|lastlit
decl_stmt|;
name|int
name|k
decl_stmt|,
name|len
decl_stmt|,
name|type
decl_stmt|;
name|int
name|litflavor
decl_stmt|;
name|double
name|cd
index|[
literal|2
index|]
decl_stmt|;
name|ftnint
name|nblanks
decl_stmt|;
name|char
modifier|*
name|strp
decl_stmt|;
name|char
name|cdsbuf0
index|[
literal|64
index|]
decl_stmt|,
name|cdsbuf1
index|[
literal|64
index|]
decl_stmt|,
modifier|*
name|ds
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|tag
operator|!=
name|TCONST
condition|)
name|badtag
argument_list|(
literal|"putconst"
argument_list|,
name|p
operator|->
name|tag
argument_list|)
expr_stmt|;
name|q
operator|=
name|ALLOC
argument_list|(
name|Addrblock
argument_list|)
expr_stmt|;
name|q
operator|->
name|tag
operator|=
name|TADDR
expr_stmt|;
name|type
operator|=
name|p
operator|->
name|vtype
expr_stmt|;
name|q
operator|->
name|vtype
operator|=
operator|(
name|type
operator|==
name|TYADDR
condition|?
name|tyint
else|:
name|type
operator|)
expr_stmt|;
name|q
operator|->
name|vleng
operator|=
operator|(
name|expptr
operator|)
name|cpexpr
argument_list|(
name|p
operator|->
name|vleng
argument_list|)
expr_stmt|;
name|q
operator|->
name|vstg
operator|=
name|STGCONST
expr_stmt|;
comment|/* Create the new label for the constant.  This is wasteful of labels    because when the constant value already exists in the literal pool,    this label gets thrown away and is never reclaimed.  It might be    cleaner to move this down past the first   switch()   statement below */
name|q
operator|->
name|memno
operator|=
name|newlabel
argument_list|()
expr_stmt|;
name|q
operator|->
name|memoffset
operator|=
name|ICON
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|q
operator|->
name|uname_tag
operator|=
name|UNAM_CONST
expr_stmt|;
comment|/* Copy the constant info into the Addrblock; do this by copying the    largest storage elts */
name|q
operator|->
name|user
operator|.
name|Const
operator|=
name|p
operator|->
name|Const
expr_stmt|;
name|q
operator|->
name|user
operator|.
name|kludge
operator|.
name|vstg1
operator|=
name|p
operator|->
name|vstg
expr_stmt|;
comment|/* distinguish string from binary fp */
comment|/* check for value in literal pool, and update pool if necessary */
name|k
operator|=
literal|1
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|TYCHAR
case|:
if|if
condition|(
name|halign
condition|)
block|{
name|strp
operator|=
name|p
operator|->
name|Const
operator|.
name|ccp
expr_stmt|;
name|nblanks
operator|=
name|p
operator|->
name|Const
operator|.
name|ccp1
operator|.
name|blanks
expr_stmt|;
name|len
operator|=
name|p
operator|->
name|vleng
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
expr_stmt|;
name|litflavor
operator|=
name|LIT_CHAR
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
else|else
name|q
operator|->
name|memno
operator|=
name|BAD_MEMNO
expr_stmt|;
break|break;
case|case
name|TYCOMPLEX
case|:
case|case
name|TYDCOMPLEX
case|:
name|k
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|vstg
condition|)
name|cd
index|[
literal|1
index|]
operator|=
name|atof
argument_list|(
name|ds
index|[
literal|1
index|]
operator|=
name|p
operator|->
name|Const
operator|.
name|cds
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
name|ds
index|[
literal|1
index|]
operator|=
name|cds
argument_list|(
name|dtos
argument_list|(
name|cd
index|[
literal|1
index|]
operator|=
name|p
operator|->
name|Const
operator|.
name|cd
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|cdsbuf1
argument_list|)
expr_stmt|;
case|case
name|TYREAL
case|:
case|case
name|TYDREAL
case|:
name|litflavor
operator|=
name|LIT_FLOAT
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|vstg
condition|)
name|cd
index|[
literal|0
index|]
operator|=
name|atof
argument_list|(
name|ds
index|[
literal|0
index|]
operator|=
name|p
operator|->
name|Const
operator|.
name|cds
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
else|else
name|ds
index|[
literal|0
index|]
operator|=
name|cds
argument_list|(
name|dtos
argument_list|(
name|cd
index|[
literal|0
index|]
operator|=
name|p
operator|->
name|Const
operator|.
name|cd
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|cdsbuf0
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
case|case
name|TYLOGICAL1
case|:
case|case
name|TYLOGICAL2
case|:
case|case
name|TYLOGICAL
case|:
case|case
name|TYLONG
case|:
case|case
name|TYSHORT
case|:
case|case
name|TYINT1
case|:
ifdef|#
directive|ifdef
name|TYQUAD
case|case
name|TYQUAD
case|:
endif|#
directive|endif
name|lit_int_flavor
label|:
name|litflavor
operator|=
name|LIT_INT
expr_stmt|;
comment|/* Scan the literal pool for this constant value.  If this same constant    has been assigned before, use the same label.  Note that this routine    does NOT consider two differently-typed constants with the same bit    pattern to be the same constant */
name|loop
label|:
name|lastlit
operator|=
name|litpool
operator|+
name|nliterals
expr_stmt|;
for|for
control|(
name|litp
operator|=
name|litpool
init|;
name|litp
operator|<
name|lastlit
condition|;
operator|++
name|litp
control|)
comment|/* Remove this type checking to ensure that all bit patterns are reused */
if|if
condition|(
name|type
operator|==
name|litp
operator|->
name|littype
condition|)
switch|switch
condition|(
name|litflavor
condition|)
block|{
case|case
name|LIT_CHAR
case|:
if|if
condition|(
name|len
operator|==
operator|(
name|int
operator|)
name|litp
operator|->
name|litval
operator|.
name|litival2
index|[
literal|0
index|]
operator|&&
name|nblanks
operator|==
name|litp
operator|->
name|litval
operator|.
name|litival2
index|[
literal|1
index|]
operator|&&
operator|!
name|memcmp
argument_list|(
name|strp
argument_list|,
name|litp
operator|->
name|cds
index|[
literal|0
index|]
argument_list|,
name|len
argument_list|)
condition|)
block|{
name|q
operator|->
name|memno
operator|=
name|litp
operator|->
name|litnum
expr_stmt|;
name|frexpr
argument_list|(
operator|(
name|expptr
operator|)
name|p
argument_list|)
expr_stmt|;
name|q
operator|->
name|user
operator|.
name|Const
operator|.
name|ccp1
operator|.
name|ccp0
operator|=
name|litp
operator|->
name|cds
index|[
literal|0
index|]
expr_stmt|;
return|return
operator|(
name|q
operator|)
return|;
block|}
break|break;
case|case
name|LIT_FLOAT
case|:
if|if
condition|(
name|cd
index|[
literal|0
index|]
operator|==
name|litp
operator|->
name|litval
operator|.
name|litdval
index|[
literal|0
index|]
operator|&&
operator|!
name|strcmp
argument_list|(
name|ds
index|[
literal|0
index|]
argument_list|,
name|litp
operator|->
name|cds
index|[
literal|0
index|]
argument_list|)
operator|&&
operator|(
name|k
operator|==
literal|1
operator|||
name|cd
index|[
literal|1
index|]
operator|==
name|litp
operator|->
name|litval
operator|.
name|litdval
index|[
literal|1
index|]
operator|&&
operator|!
name|strcmp
argument_list|(
name|ds
index|[
literal|1
index|]
argument_list|,
name|litp
operator|->
name|cds
index|[
literal|1
index|]
argument_list|)
operator|)
condition|)
block|{
name|ret
label|:
name|q
operator|->
name|memno
operator|=
name|litp
operator|->
name|litnum
expr_stmt|;
name|frexpr
argument_list|(
operator|(
name|expptr
operator|)
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|q
operator|)
return|;
block|}
break|break;
case|case
name|LIT_INT
case|:
if|if
condition|(
name|p
operator|->
name|Const
operator|.
name|ci
operator|==
name|litp
operator|->
name|litval
operator|.
name|litival
condition|)
goto|goto
name|ret
goto|;
break|break;
block|}
comment|/* If there's room in the literal pool, add this new value to the pool */
if|if
condition|(
name|nliterals
operator|<
name|maxliterals
condition|)
block|{
operator|++
name|nliterals
expr_stmt|;
comment|/* litp   now points to the next free elt */
name|litp
operator|->
name|littype
operator|=
name|type
expr_stmt|;
name|litp
operator|->
name|litnum
operator|=
name|q
operator|->
name|memno
expr_stmt|;
switch|switch
condition|(
name|litflavor
condition|)
block|{
case|case
name|LIT_CHAR
case|:
name|litp
operator|->
name|litval
operator|.
name|litival2
index|[
literal|0
index|]
operator|=
name|len
expr_stmt|;
name|litp
operator|->
name|litval
operator|.
name|litival2
index|[
literal|1
index|]
operator|=
name|nblanks
expr_stmt|;
name|q
operator|->
name|user
operator|.
name|Const
operator|.
name|ccp
operator|=
name|litp
operator|->
name|cds
index|[
literal|0
index|]
operator|=
name|memcpy
argument_list|(
name|gmem
argument_list|(
name|len
argument_list|,
literal|0
argument_list|)
argument_list|,
name|strp
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|LIT_FLOAT
case|:
name|litp
operator|->
name|litval
operator|.
name|litdval
index|[
literal|0
index|]
operator|=
name|cd
index|[
literal|0
index|]
expr_stmt|;
name|litp
operator|->
name|cds
index|[
literal|0
index|]
operator|=
name|copys
argument_list|(
name|ds
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|==
literal|2
condition|)
block|{
name|litp
operator|->
name|litval
operator|.
name|litdval
index|[
literal|1
index|]
operator|=
name|cd
index|[
literal|1
index|]
expr_stmt|;
name|litp
operator|->
name|cds
index|[
literal|1
index|]
operator|=
name|copys
argument_list|(
name|ds
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|LIT_INT
case|:
name|litp
operator|->
name|litval
operator|.
name|litival
operator|=
name|p
operator|->
name|Const
operator|.
name|ci
expr_stmt|;
break|break;
block|}
comment|/* switch (litflavor) */
block|}
else|else
name|many
argument_list|(
literal|"literal constants"
argument_list|,
literal|'L'
argument_list|,
name|maxliterals
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYADDR
case|:
break|break;
default|default:
name|badtype
argument_list|(
literal|"putconst"
argument_list|,
name|p
operator|->
name|vtype
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* switch */
if|if
condition|(
name|type
operator|!=
name|TYCHAR
operator|||
name|halign
condition|)
name|frexpr
argument_list|(
operator|(
name|expptr
operator|)
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|q
operator|)
return|;
block|}
end_function

end_unit

