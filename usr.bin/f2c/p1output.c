begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**************************************************************** Copyright 1990, 1991, 1993, 1994 by AT&T, Lucent Technologies and Bellcore.  Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that the copyright notice and this permission notice and warranty disclaimer appear in supporting documentation, and that the names of AT&T, Bell Laboratories, Lucent or Bellcore or any of their entities not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  AT&T, Lucent and Bellcore disclaim all warranties with regard to this software, including all implied warranties of merchantability and fitness.  In no event shall AT&T, Lucent or Bellcore be liable for any special, indirect or consequential damages or any damages whatsoever resulting from loss of use, data or profits, whether in an action of contract, negligence or other tortious action, arising out of or in connection with the use or performance of this software. ****************************************************************/
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"p1defs.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"names.h"
end_include

begin_decl_stmt
specifier|static
name|void
name|p1_addr
name|Argdcl
argument_list|(
operator|(
name|Addrp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|p1_big_addr
name|Argdcl
argument_list|(
operator|(
name|Addrp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|p1_binary
name|Argdcl
argument_list|(
operator|(
name|Exprp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|p1_const
name|Argdcl
argument_list|(
operator|(
name|Constp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|p1_list
name|Argdcl
argument_list|(
operator|(
expr|struct
name|Listblock
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|p1_literal
name|Argdcl
argument_list|(
operator|(
name|long
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|p1_name
name|Argdcl
argument_list|(
operator|(
name|Namep
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|p1_unary
name|Argdcl
argument_list|(
operator|(
name|Exprp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|p1putd
name|Argdcl
argument_list|(
operator|(
name|int
operator|,
name|long
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|p1putdd
name|Argdcl
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|p1putddd
name|Argdcl
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|p1putdds
name|Argdcl
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|p1putds
name|Argdcl
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|p1putn
name|Argdcl
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* p1_comment -- save the text of a Fortran comment in the intermediate    file.  Make sure that there are no spurious "/ *" or "* /" characters by    mapping them onto "/+" and "+/".   str   is assumed to hold no newlines and be    null terminated; it may be modified by this function. */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|p1_comment
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
else|#
directive|else
function|p1_comment
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
endif|#
directive|endif
block|{
specifier|register
name|unsigned
name|char
modifier|*
name|pointer
decl_stmt|,
modifier|*
name|ustr
decl_stmt|;
if|if
condition|(
operator|!
name|str
condition|)
return|return;
comment|/* Get rid of any open or close comment combinations that may be in the    Fortran input */
name|ustr
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|str
expr_stmt|;
for|for
control|(
name|pointer
operator|=
name|ustr
init|;
operator|*
name|pointer
condition|;
name|pointer
operator|++
control|)
if|if
condition|(
operator|*
name|pointer
operator|==
literal|'*'
operator|&&
operator|(
name|pointer
index|[
literal|1
index|]
operator|==
literal|'/'
operator|||
name|pointer
operator|>
name|ustr
operator|&&
name|pointer
index|[
operator|-
literal|1
index|]
operator|==
literal|'/'
operator|)
condition|)
operator|*
name|pointer
operator|=
literal|'+'
expr_stmt|;
comment|/* trim trailing white space */
ifdef|#
directive|ifdef
name|isascii
while|while
condition|(
operator|--
name|pointer
operator|>=
name|ustr
operator|&&
operator|(
operator|!
name|isascii
argument_list|(
operator|*
name|pointer
argument_list|)
operator|||
name|isspace
argument_list|(
operator|*
name|pointer
argument_list|)
operator|)
condition|)
empty_stmt|;
else|#
directive|else
while|while
condition|(
operator|--
name|pointer
operator|>=
name|ustr
operator|&&
name|isspace
argument_list|(
operator|*
name|pointer
argument_list|)
condition|)
empty_stmt|;
endif|#
directive|endif
name|pointer
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|p1puts
argument_list|(
name|P1_COMMENT
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* p1_comment */
end_comment

begin_comment
comment|/* p1_name -- Writes the address of a hash table entry into the    intermediate file */
end_comment

begin_function
specifier|static
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|p1_name
parameter_list|(
name|namep
parameter_list|)
name|Namep
name|namep
decl_stmt|;
else|#
directive|else
function|p1_name
parameter_list|(
name|Namep
name|namep
parameter_list|)
endif|#
directive|endif
block|{
name|p1putd
argument_list|(
name|P1_NAME_POINTER
argument_list|,
operator|(
name|long
operator|)
name|namep
argument_list|)
expr_stmt|;
name|namep
operator|->
name|visused
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* p1_name */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|p1_expr
parameter_list|(
name|expr
parameter_list|)
name|expptr
name|expr
decl_stmt|;
else|#
directive|else
function|p1_expr
parameter_list|(
name|expptr
name|expr
parameter_list|)
endif|#
directive|endif
block|{
comment|/* An opcode of 0 means a null entry */
if|if
condition|(
name|expr
operator|==
name|ENULL
condition|)
block|{
name|p1putdd
argument_list|(
name|P1_EXPR
argument_list|,
literal|0
argument_list|,
name|TYUNKNOWN
argument_list|)
expr_stmt|;
comment|/* Should this be TYERROR? */
return|return;
block|}
comment|/* if (expr == ENULL) */
switch|switch
condition|(
name|expr
operator|->
name|tag
condition|)
block|{
case|case
name|TNAME
case|:
name|p1_name
argument_list|(
operator|(
name|Namep
operator|)
name|expr
argument_list|)
expr_stmt|;
return|return;
case|case
name|TCONST
case|:
name|p1_const
argument_list|(
operator|&
name|expr
operator|->
name|constblock
argument_list|)
expr_stmt|;
return|return;
case|case
name|TEXPR
case|:
comment|/* Fall through the switch */
break|break;
case|case
name|TADDR
case|:
name|p1_addr
argument_list|(
operator|&
operator|(
name|expr
operator|->
name|addrblock
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|freeup
goto|;
case|case
name|TPRIM
case|:
name|warn
argument_list|(
literal|"p1_expr:  got TPRIM"
argument_list|)
expr_stmt|;
return|return;
case|case
name|TLIST
case|:
name|p1_list
argument_list|(
operator|&
operator|(
name|expr
operator|->
name|listblock
operator|)
argument_list|)
expr_stmt|;
name|frchain
argument_list|(
operator|&
operator|(
name|expr
operator|->
name|listblock
operator|.
name|listp
operator|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|TERROR
case|:
return|return;
default|default:
name|erri
argument_list|(
literal|"p1_expr: bad tag '%d'"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|expr
operator|->
name|tag
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Now we know that the tag is TEXPR */
if|if
condition|(
name|is_unary_op
argument_list|(
name|expr
operator|->
name|exprblock
operator|.
name|opcode
argument_list|)
condition|)
name|p1_unary
argument_list|(
operator|&
operator|(
name|expr
operator|->
name|exprblock
operator|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|is_binary_op
argument_list|(
name|expr
operator|->
name|exprblock
operator|.
name|opcode
argument_list|)
condition|)
name|p1_binary
argument_list|(
operator|&
operator|(
name|expr
operator|->
name|exprblock
operator|)
argument_list|)
expr_stmt|;
else|else
name|erri
argument_list|(
literal|"p1_expr:  bad opcode '%d'"
argument_list|,
operator|(
name|int
operator|)
name|expr
operator|->
name|exprblock
operator|.
name|opcode
argument_list|)
expr_stmt|;
name|freeup
label|:
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|expr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* p1_expr */
end_comment

begin_function
specifier|static
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|p1_const
parameter_list|(
name|cp
parameter_list|)
specifier|register
name|Constp
name|cp
decl_stmt|;
else|#
directive|else
function|p1_const
parameter_list|(
specifier|register
name|Constp
name|cp
parameter_list|)
endif|#
directive|endif
block|{
name|int
name|type
init|=
name|cp
operator|->
name|vtype
decl_stmt|;
name|expptr
name|vleng
init|=
name|cp
operator|->
name|vleng
decl_stmt|;
name|union
name|Constant
modifier|*
name|c
init|=
operator|&
name|cp
operator|->
name|Const
decl_stmt|;
name|char
name|cdsbuf0
index|[
literal|64
index|]
decl_stmt|,
name|cdsbuf1
index|[
literal|64
index|]
decl_stmt|;
name|char
modifier|*
name|cds0
decl_stmt|,
modifier|*
name|cds1
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|TYINT1
case|:
case|case
name|TYSHORT
case|:
case|case
name|TYLONG
case|:
ifdef|#
directive|ifdef
name|TYQUAD
case|case
name|TYQUAD
case|:
endif|#
directive|endif
case|case
name|TYLOGICAL
case|:
case|case
name|TYLOGICAL1
case|:
case|case
name|TYLOGICAL2
case|:
name|fprintf
argument_list|(
name|pass1_file
argument_list|,
literal|"%d: %d %ld\n"
argument_list|,
name|P1_CONST
argument_list|,
name|type
argument_list|,
name|c
operator|->
name|ci
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYREAL
case|:
case|case
name|TYDREAL
case|:
name|fprintf
argument_list|(
name|pass1_file
argument_list|,
literal|"%d: %d %s\n"
argument_list|,
name|P1_CONST
argument_list|,
name|type
argument_list|,
name|cp
operator|->
name|vstg
condition|?
name|c
operator|->
name|cds
index|[
literal|0
index|]
else|:
name|cds
argument_list|(
name|dtos
argument_list|(
name|c
operator|->
name|cd
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|cdsbuf0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYCOMPLEX
case|:
case|case
name|TYDCOMPLEX
case|:
if|if
condition|(
name|cp
operator|->
name|vstg
condition|)
block|{
name|cds0
operator|=
name|c
operator|->
name|cds
index|[
literal|0
index|]
expr_stmt|;
name|cds1
operator|=
name|c
operator|->
name|cds
index|[
literal|1
index|]
expr_stmt|;
block|}
else|else
block|{
name|cds0
operator|=
name|cds
argument_list|(
name|dtos
argument_list|(
name|c
operator|->
name|cd
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|cdsbuf0
argument_list|)
expr_stmt|;
name|cds1
operator|=
name|cds
argument_list|(
name|dtos
argument_list|(
name|c
operator|->
name|cd
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|cdsbuf1
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|pass1_file
argument_list|,
literal|"%d: %d %s %s\n"
argument_list|,
name|P1_CONST
argument_list|,
name|type
argument_list|,
name|cds0
argument_list|,
name|cds1
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYCHAR
case|:
if|if
condition|(
name|vleng
operator|&&
operator|!
name|ISICON
argument_list|(
name|vleng
argument_list|)
condition|)
name|erri
argument_list|(
literal|"p1_const:  bad vleng '%d'\n"
argument_list|,
operator|(
name|int
operator|)
name|vleng
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|pass1_file
argument_list|,
literal|"%d: %d %lx\n"
argument_list|,
name|P1_CONST
argument_list|,
name|type
argument_list|,
name|cpexpr
argument_list|(
operator|(
name|expptr
operator|)
name|cp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|erri
argument_list|(
literal|"p1_const:  bad constant type '%d'"
argument_list|,
name|type
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* switch */
block|}
end_function

begin_comment
comment|/* p1_const */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|p1_asgoto
parameter_list|(
name|addrp
parameter_list|)
name|Addrp
name|addrp
decl_stmt|;
else|#
directive|else
function|p1_asgoto
parameter_list|(
name|Addrp
name|addrp
parameter_list|)
endif|#
directive|endif
block|{
name|p1put
argument_list|(
name|P1_ASGOTO
argument_list|)
expr_stmt|;
name|p1_addr
argument_list|(
name|addrp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* p1_asgoto */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|p1_goto
parameter_list|(
name|stateno
parameter_list|)
name|ftnint
name|stateno
decl_stmt|;
else|#
directive|else
function|p1_goto
parameter_list|(
name|ftnint
name|stateno
parameter_list|)
endif|#
directive|endif
block|{
name|p1putd
argument_list|(
name|P1_GOTO
argument_list|,
name|stateno
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* p1_goto */
end_comment

begin_function
specifier|static
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|p1_addr
parameter_list|(
name|addrp
parameter_list|)
specifier|register
name|struct
name|Addrblock
modifier|*
name|addrp
decl_stmt|;
else|#
directive|else
function|p1_addr
parameter_list|(
specifier|register
name|struct
name|Addrblock
modifier|*
name|addrp
parameter_list|)
endif|#
directive|endif
block|{
name|int
name|stg
decl_stmt|;
if|if
condition|(
name|addrp
operator|==
operator|(
expr|struct
name|Addrblock
operator|*
operator|)
name|NULL
condition|)
return|return;
name|stg
operator|=
name|addrp
operator|->
name|vstg
expr_stmt|;
if|if
condition|(
name|ONEOF
argument_list|(
name|stg
argument_list|,
name|M
argument_list|(
name|STGINIT
argument_list|)
operator||
name|M
argument_list|(
name|STGREG
argument_list|)
argument_list|)
operator|||
name|ONEOF
argument_list|(
name|stg
argument_list|,
name|M
argument_list|(
name|STGCOMMON
argument_list|)
operator||
name|M
argument_list|(
name|STGEQUIV
argument_list|)
argument_list|)
operator|&&
operator|(
operator|!
name|ISICON
argument_list|(
name|addrp
operator|->
name|memoffset
argument_list|)
operator|||
operator|(
name|addrp
operator|->
name|uname_tag
operator|==
name|UNAM_NAME
condition|?
name|addrp
operator|->
name|memoffset
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
operator|!=
name|addrp
operator|->
name|user
operator|.
name|name
operator|->
name|voffset
else|:
name|addrp
operator|->
name|memoffset
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
operator|)
operator|)
operator|||
name|ONEOF
argument_list|(
name|stg
argument_list|,
name|M
argument_list|(
name|STGBSS
argument_list|)
operator||
name|M
argument_list|(
name|STGINIT
argument_list|)
operator||
name|M
argument_list|(
name|STGAUTO
argument_list|)
operator||
name|M
argument_list|(
name|STGARG
argument_list|)
argument_list|)
operator|&&
operator|(
operator|!
name|ISICON
argument_list|(
name|addrp
operator|->
name|memoffset
argument_list|)
operator|||
name|addrp
operator|->
name|memoffset
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
operator|)
operator|||
name|addrp
operator|->
name|Field
operator|||
name|addrp
operator|->
name|isarray
operator|||
name|addrp
operator|->
name|vstg
operator|==
name|STGLENG
condition|)
block|{
name|p1_big_addr
argument_list|(
name|addrp
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Write out a level of indirection for non-array arguments, which have    addrp -> memoffset   set and are handled by   p1_big_addr().    Lengths are passed by value, so don't check STGLENG    28-Jun-89 (dmg)  Added the check for != TYCHAR  */
if|if
condition|(
name|oneof_stg
argument_list|(
name|addrp
operator|->
name|uname_tag
operator|==
name|UNAM_NAME
condition|?
name|addrp
operator|->
name|user
operator|.
name|name
else|:
name|NULL
argument_list|,
name|stg
argument_list|,
name|M
argument_list|(
name|STGARG
argument_list|)
operator||
name|M
argument_list|(
name|STGEQUIV
argument_list|)
argument_list|)
operator|&&
name|addrp
operator|->
name|vtype
operator|!=
name|TYCHAR
condition|)
block|{
name|p1putdd
argument_list|(
name|P1_EXPR
argument_list|,
name|OPWHATSIN
argument_list|,
name|addrp
operator|->
name|vtype
argument_list|)
expr_stmt|;
name|p1_expr
argument_list|(
name|ENULL
argument_list|)
expr_stmt|;
comment|/* Put dummy   vleng   */
block|}
comment|/* if stg == STGARG */
switch|switch
condition|(
name|addrp
operator|->
name|uname_tag
condition|)
block|{
case|case
name|UNAM_NAME
case|:
name|p1_name
argument_list|(
name|addrp
operator|->
name|user
operator|.
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNAM_IDENT
case|:
name|p1putdds
argument_list|(
name|P1_IDENT
argument_list|,
name|addrp
operator|->
name|vtype
argument_list|,
name|addrp
operator|->
name|vstg
argument_list|,
name|addrp
operator|->
name|user
operator|.
name|ident
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNAM_CHARP
case|:
name|p1putdds
argument_list|(
name|P1_CHARP
argument_list|,
name|addrp
operator|->
name|vtype
argument_list|,
name|addrp
operator|->
name|vstg
argument_list|,
name|addrp
operator|->
name|user
operator|.
name|Charp
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNAM_EXTERN
case|:
name|p1putd
argument_list|(
name|P1_EXTERN
argument_list|,
operator|(
name|long
operator|)
name|addrp
operator|->
name|memno
argument_list|)
expr_stmt|;
if|if
condition|(
name|addrp
operator|->
name|vclass
operator|==
name|CLPROC
condition|)
name|extsymtab
index|[
name|addrp
operator|->
name|memno
index|]
operator|.
name|extype
operator|=
name|addrp
operator|->
name|vtype
expr_stmt|;
break|break;
case|case
name|UNAM_CONST
case|:
if|if
condition|(
name|addrp
operator|->
name|memno
operator|!=
name|BAD_MEMNO
condition|)
name|p1_literal
argument_list|(
name|addrp
operator|->
name|memno
argument_list|)
expr_stmt|;
else|else
name|p1_const
argument_list|(
operator|(
expr|struct
name|Constblock
operator|*
operator|)
name|addrp
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNAM_UNKNOWN
case|:
default|default:
name|erri
argument_list|(
literal|"p1_addr:  unknown uname_tag '%d'"
argument_list|,
name|addrp
operator|->
name|uname_tag
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* switch */
block|}
end_function

begin_comment
comment|/* p1_addr */
end_comment

begin_function
specifier|static
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|p1_list
parameter_list|(
name|listp
parameter_list|)
name|struct
name|Listblock
modifier|*
name|listp
decl_stmt|;
else|#
directive|else
function|p1_list
parameter_list|(
name|struct
name|Listblock
modifier|*
name|listp
parameter_list|)
endif|#
directive|endif
block|{
name|chainp
name|lis
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|listp
operator|==
operator|(
expr|struct
name|Listblock
operator|*
operator|)
name|NULL
condition|)
return|return;
comment|/* Count the number of parameters in the list */
for|for
control|(
name|lis
operator|=
name|listp
operator|->
name|listp
init|;
name|lis
condition|;
name|lis
operator|=
name|lis
operator|->
name|nextp
control|)
name|count
operator|++
expr_stmt|;
name|p1putddd
argument_list|(
name|P1_LIST
argument_list|,
name|listp
operator|->
name|tag
argument_list|,
name|listp
operator|->
name|vtype
argument_list|,
name|count
argument_list|)
expr_stmt|;
for|for
control|(
name|lis
operator|=
name|listp
operator|->
name|listp
init|;
name|lis
condition|;
name|lis
operator|=
name|lis
operator|->
name|nextp
control|)
name|p1_expr
argument_list|(
operator|(
name|expptr
operator|)
name|lis
operator|->
name|datap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* p1_list */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|p1_label
parameter_list|(
name|lab
parameter_list|)
name|long
name|lab
decl_stmt|;
else|#
directive|else
function|p1_label
parameter_list|(
name|long
name|lab
parameter_list|)
endif|#
directive|endif
block|{
if|if
condition|(
name|parstate
operator|<
name|INDATA
condition|)
name|earlylabs
operator|=
name|mkchain
argument_list|(
operator|(
name|char
operator|*
operator|)
name|lab
argument_list|,
name|earlylabs
argument_list|)
expr_stmt|;
else|else
name|p1putd
argument_list|(
name|P1_LABEL
argument_list|,
name|lab
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|p1_literal
parameter_list|(
name|memno
parameter_list|)
name|long
name|memno
decl_stmt|;
else|#
directive|else
function|p1_literal
parameter_list|(
name|long
name|memno
parameter_list|)
endif|#
directive|endif
block|{
name|p1putd
argument_list|(
name|P1_LITERAL
argument_list|,
name|memno
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* p1_literal */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|p1_if
parameter_list|(
name|expr
parameter_list|)
name|expptr
name|expr
decl_stmt|;
else|#
directive|else
function|p1_if
parameter_list|(
name|expptr
name|expr
parameter_list|)
endif|#
directive|endif
block|{
name|p1put
argument_list|(
name|P1_IF
argument_list|)
expr_stmt|;
name|p1_expr
argument_list|(
name|expr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* p1_if */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|p1_elif
parameter_list|(
name|expr
parameter_list|)
name|expptr
name|expr
decl_stmt|;
else|#
directive|else
function|p1_elif
parameter_list|(
name|expptr
name|expr
parameter_list|)
endif|#
directive|endif
block|{
name|p1put
argument_list|(
name|P1_ELIF
argument_list|)
expr_stmt|;
name|p1_expr
argument_list|(
name|expr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* p1_elif */
end_comment

begin_function
name|void
name|p1_else
parameter_list|(
name|Void
parameter_list|)
block|{
name|p1put
argument_list|(
name|P1_ELSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* p1_else */
end_comment

begin_function
name|void
name|p1_endif
parameter_list|(
name|Void
parameter_list|)
block|{
name|p1put
argument_list|(
name|P1_ENDIF
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* p1_endif */
end_comment

begin_function
name|void
name|p1else_end
parameter_list|(
name|Void
parameter_list|)
block|{
name|p1put
argument_list|(
name|P1_ENDELSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* p1else_end */
end_comment

begin_function
specifier|static
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|p1_big_addr
parameter_list|(
name|addrp
parameter_list|)
name|Addrp
name|addrp
decl_stmt|;
else|#
directive|else
function|p1_big_addr
parameter_list|(
name|Addrp
name|addrp
parameter_list|)
endif|#
directive|endif
block|{
if|if
condition|(
name|addrp
operator|==
operator|(
name|Addrp
operator|)
name|NULL
condition|)
return|return;
name|p1putn
argument_list|(
name|P1_ADDR
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|Addrblock
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|addrp
argument_list|)
expr_stmt|;
name|p1_expr
argument_list|(
name|addrp
operator|->
name|vleng
argument_list|)
expr_stmt|;
name|p1_expr
argument_list|(
name|addrp
operator|->
name|memoffset
argument_list|)
expr_stmt|;
if|if
condition|(
name|addrp
operator|->
name|uname_tag
operator|==
name|UNAM_NAME
condition|)
name|addrp
operator|->
name|user
operator|.
name|name
operator|->
name|visused
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* p1_big_addr */
end_comment

begin_function
specifier|static
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|p1_unary
parameter_list|(
name|e
parameter_list|)
name|struct
name|Exprblock
modifier|*
name|e
decl_stmt|;
else|#
directive|else
function|p1_unary
parameter_list|(
name|struct
name|Exprblock
modifier|*
name|e
parameter_list|)
endif|#
directive|endif
block|{
if|if
condition|(
name|e
operator|==
operator|(
expr|struct
name|Exprblock
operator|*
operator|)
name|NULL
condition|)
return|return;
name|p1putdd
argument_list|(
name|P1_EXPR
argument_list|,
operator|(
name|int
operator|)
name|e
operator|->
name|opcode
argument_list|,
name|e
operator|->
name|vtype
argument_list|)
expr_stmt|;
name|p1_expr
argument_list|(
name|e
operator|->
name|vleng
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|e
operator|->
name|opcode
condition|)
block|{
case|case
name|OPNEG
case|:
case|case
name|OPNEG1
case|:
case|case
name|OPNOT
case|:
case|case
name|OPABS
case|:
case|case
name|OPBITNOT
case|:
case|case
name|OPPREINC
case|:
case|case
name|OPPREDEC
case|:
case|case
name|OPADDR
case|:
case|case
name|OPIDENTITY
case|:
case|case
name|OPCHARCAST
case|:
case|case
name|OPDABS
case|:
name|p1_expr
argument_list|(
name|e
operator|->
name|leftp
argument_list|)
expr_stmt|;
break|break;
default|default:
name|erri
argument_list|(
literal|"p1_unary: bad opcode '%d'"
argument_list|,
operator|(
name|int
operator|)
name|e
operator|->
name|opcode
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* switch */
block|}
end_function

begin_comment
comment|/* p1_unary */
end_comment

begin_function
specifier|static
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|p1_binary
parameter_list|(
name|e
parameter_list|)
name|struct
name|Exprblock
modifier|*
name|e
decl_stmt|;
else|#
directive|else
function|p1_binary
parameter_list|(
name|struct
name|Exprblock
modifier|*
name|e
parameter_list|)
endif|#
directive|endif
block|{
if|if
condition|(
name|e
operator|==
operator|(
expr|struct
name|Exprblock
operator|*
operator|)
name|NULL
condition|)
return|return;
name|p1putdd
argument_list|(
name|P1_EXPR
argument_list|,
name|e
operator|->
name|opcode
argument_list|,
name|e
operator|->
name|vtype
argument_list|)
expr_stmt|;
name|p1_expr
argument_list|(
name|e
operator|->
name|vleng
argument_list|)
expr_stmt|;
name|p1_expr
argument_list|(
name|e
operator|->
name|leftp
argument_list|)
expr_stmt|;
name|p1_expr
argument_list|(
name|e
operator|->
name|rightp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* p1_binary */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|p1_head
parameter_list|(
name|class
parameter_list|,
name|name
parameter_list|)
name|int
name|class
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
else|#
directive|else
function|p1_head
parameter_list|(
name|int
name|class
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
endif|#
directive|endif
block|{
name|p1putds
argument_list|(
name|P1_HEAD
argument_list|,
name|class
argument_list|,
name|name
condition|?
name|name
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* p1_head */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|p1_subr_ret
parameter_list|(
name|retexp
parameter_list|)
name|expptr
name|retexp
decl_stmt|;
else|#
directive|else
function|p1_subr_ret
parameter_list|(
name|expptr
name|retexp
parameter_list|)
endif|#
directive|endif
block|{
name|p1put
argument_list|(
name|P1_SUBR_RET
argument_list|)
expr_stmt|;
name|p1_expr
argument_list|(
name|cpexpr
argument_list|(
name|retexp
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* p1_subr_ret */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|p1comp_goto
parameter_list|(
name|index
parameter_list|,
name|count
parameter_list|,
name|labels
parameter_list|)
name|expptr
name|index
decl_stmt|;
name|int
name|count
decl_stmt|;
name|struct
name|Labelblock
modifier|*
modifier|*
name|labels
decl_stmt|;
else|#
directive|else
function|p1comp_goto
parameter_list|(
name|expptr
name|index
parameter_list|,
name|int
name|count
parameter_list|,
name|struct
name|Labelblock
modifier|*
modifier|*
name|labels
parameter_list|)
endif|#
directive|endif
block|{
name|struct
name|Constblock
name|c
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|Labelblock
modifier|*
name|L
decl_stmt|;
name|p1put
argument_list|(
name|P1_COMP_GOTO
argument_list|)
expr_stmt|;
name|p1_expr
argument_list|(
name|index
argument_list|)
expr_stmt|;
comment|/* Write out a P1_LIST directly, to avoid the overhead of allocating a    list before it's needed HACK HACK HACK */
name|p1putddd
argument_list|(
name|P1_LIST
argument_list|,
name|TLIST
argument_list|,
name|TYUNKNOWN
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|c
operator|.
name|vtype
operator|=
name|TYLONG
expr_stmt|;
name|c
operator|.
name|vleng
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|L
operator|=
name|labels
index|[
name|i
index|]
expr_stmt|;
name|L
operator|->
name|labused
operator|=
literal|1
expr_stmt|;
name|c
operator|.
name|Const
operator|.
name|ci
operator|=
name|L
operator|->
name|stateno
expr_stmt|;
name|p1_const
argument_list|(
operator|&
name|c
argument_list|)
expr_stmt|;
block|}
comment|/* for i = 0 */
block|}
end_function

begin_comment
comment|/* p1comp_goto */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|p1_for
parameter_list|(
name|init
parameter_list|,
name|test
parameter_list|,
name|inc
parameter_list|)
name|expptr
name|init
decl_stmt|;
name|expptr
name|test
decl_stmt|;
name|expptr
name|inc
decl_stmt|;
else|#
directive|else
function|p1_for
parameter_list|(
name|expptr
name|init
parameter_list|,
name|expptr
name|test
parameter_list|,
name|expptr
name|inc
parameter_list|)
endif|#
directive|endif
block|{
name|p1put
argument_list|(
name|P1_FOR
argument_list|)
expr_stmt|;
name|p1_expr
argument_list|(
name|init
argument_list|)
expr_stmt|;
name|p1_expr
argument_list|(
name|test
argument_list|)
expr_stmt|;
name|p1_expr
argument_list|(
name|inc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* p1_for */
end_comment

begin_function
name|void
name|p1for_end
parameter_list|(
name|Void
parameter_list|)
block|{
name|p1put
argument_list|(
name|P1_ENDFOR
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* p1for_end */
end_comment

begin_comment
comment|/* ----------------------------------------------------------------------    The intermediate file actually gets written ONLY by the routines below.    To change the format of the file, you need only change these routines.    ---------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* p1puts -- Put a typed string into the Pass 1 intermediate file.  Assumes that    str   contains no newlines and is null-terminated. */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|p1puts
parameter_list|(
name|type
parameter_list|,
name|str
parameter_list|)
name|int
name|type
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
else|#
directive|else
function|p1puts
parameter_list|(
name|int
name|type
parameter_list|,
name|char
modifier|*
name|str
parameter_list|)
endif|#
directive|endif
block|{
name|fprintf
argument_list|(
name|pass1_file
argument_list|,
literal|"%d: %s\n"
argument_list|,
name|type
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* p1puts */
end_comment

begin_comment
comment|/* p1putd -- Put a typed integer into the Pass 1 intermediate file. */
end_comment

begin_function
specifier|static
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|p1putd
parameter_list|(
name|type
parameter_list|,
name|value
parameter_list|)
name|int
name|type
decl_stmt|;
name|long
name|value
decl_stmt|;
else|#
directive|else
function|p1putd
parameter_list|(
name|int
name|type
parameter_list|,
name|long
name|value
parameter_list|)
endif|#
directive|endif
block|{
name|fprintf
argument_list|(
name|pass1_file
argument_list|,
literal|"%d: %ld\n"
argument_list|,
name|type
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* p1_putd */
end_comment

begin_comment
comment|/* p1putdd -- Put a typed pair of integers into the intermediate file. */
end_comment

begin_function
specifier|static
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|p1putdd
parameter_list|(
name|type
parameter_list|,
name|v1
parameter_list|,
name|v2
parameter_list|)
name|int
name|type
decl_stmt|;
name|int
name|v1
decl_stmt|;
name|int
name|v2
decl_stmt|;
else|#
directive|else
function|p1putdd
parameter_list|(
name|int
name|type
parameter_list|,
name|int
name|v1
parameter_list|,
name|int
name|v2
parameter_list|)
endif|#
directive|endif
block|{
name|fprintf
argument_list|(
name|pass1_file
argument_list|,
literal|"%d: %d %d\n"
argument_list|,
name|type
argument_list|,
name|v1
argument_list|,
name|v2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* p1putdd */
end_comment

begin_comment
comment|/* p1putddd -- Put a typed triple of integers into the intermediate file. */
end_comment

begin_function
specifier|static
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|p1putddd
parameter_list|(
name|type
parameter_list|,
name|v1
parameter_list|,
name|v2
parameter_list|,
name|v3
parameter_list|)
name|int
name|type
decl_stmt|;
name|int
name|v1
decl_stmt|;
name|int
name|v2
decl_stmt|;
name|int
name|v3
decl_stmt|;
else|#
directive|else
function|p1putddd
parameter_list|(
name|int
name|type
parameter_list|,
name|int
name|v1
parameter_list|,
name|int
name|v2
parameter_list|,
name|int
name|v3
parameter_list|)
endif|#
directive|endif
block|{
name|fprintf
argument_list|(
name|pass1_file
argument_list|,
literal|"%d: %d %d %d\n"
argument_list|,
name|type
argument_list|,
name|v1
argument_list|,
name|v2
argument_list|,
name|v3
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* p1putddd */
end_comment

begin_union
union|union
name|dL
block|{
name|double
name|d
decl_stmt|;
name|long
name|L
index|[
literal|2
index|]
decl_stmt|;
block|}
union|;
end_union

begin_function
specifier|static
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|p1putn
parameter_list|(
name|type
parameter_list|,
name|count
parameter_list|,
name|str
parameter_list|)
name|int
name|type
decl_stmt|;
name|int
name|count
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
else|#
directive|else
function|p1putn
parameter_list|(
name|int
name|type
parameter_list|,
name|int
name|count
parameter_list|,
name|char
modifier|*
name|str
parameter_list|)
endif|#
directive|endif
block|{
name|int
name|i
decl_stmt|;
name|fprintf
argument_list|(
name|pass1_file
argument_list|,
literal|"%d: "
argument_list|,
name|type
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
name|putc
argument_list|(
name|str
index|[
name|i
index|]
argument_list|,
name|pass1_file
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|pass1_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* p1putn */
end_comment

begin_comment
comment|/* p1put -- Put a type marker into the intermediate file. */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|p1put
parameter_list|(
name|type
parameter_list|)
name|int
name|type
decl_stmt|;
else|#
directive|else
function|p1put
parameter_list|(
name|int
name|type
parameter_list|)
endif|#
directive|endif
block|{
name|fprintf
argument_list|(
name|pass1_file
argument_list|,
literal|"%d:\n"
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* p1put */
end_comment

begin_function
specifier|static
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|p1putds
parameter_list|(
name|type
parameter_list|,
name|i
parameter_list|,
name|str
parameter_list|)
name|int
name|type
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
else|#
directive|else
function|p1putds
parameter_list|(
name|int
name|type
parameter_list|,
name|int
name|i
parameter_list|,
name|char
modifier|*
name|str
parameter_list|)
endif|#
directive|endif
block|{
name|fprintf
argument_list|(
name|pass1_file
argument_list|,
literal|"%d: %d %s\n"
argument_list|,
name|type
argument_list|,
name|i
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* p1putds */
end_comment

begin_function
specifier|static
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|p1putdds
parameter_list|(
name|token
parameter_list|,
name|type
parameter_list|,
name|stg
parameter_list|,
name|str
parameter_list|)
name|int
name|token
decl_stmt|;
name|int
name|type
decl_stmt|;
name|int
name|stg
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
else|#
directive|else
function|p1putdds
parameter_list|(
name|int
name|token
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|stg
parameter_list|,
name|char
modifier|*
name|str
parameter_list|)
endif|#
directive|endif
block|{
name|fprintf
argument_list|(
name|pass1_file
argument_list|,
literal|"%d: %d %d %s\n"
argument_list|,
name|token
argument_list|,
name|type
argument_list|,
name|stg
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* p1putdds */
end_comment

end_unit

