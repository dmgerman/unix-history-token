begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**************************************************************** Copyright 1990, 1992 - 1996 by AT&T, Lucent Technologies and Bellcore.  Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that the copyright notice and this permission notice and warranty disclaimer appear in supporting documentation, and that the names of AT&T, Bell Laboratories, Lucent or Bellcore or any of their entities not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  AT&T, Lucent and Bellcore disclaim all warranties with regard to this software, including all implied warranties of merchantability and fitness.  In no event shall AT&T, Lucent or Bellcore be liable for any special, indirect or consequential damages or any damages whatsoever resulting from loss of use, data or profits, whether in an action of contract, negligence or other tortious action, arising out of or in connection with the use or performance of this software. ****************************************************************/
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"iob.h"
end_include

begin_comment
comment|/* State required for the C output */
end_comment

begin_decl_stmt
name|char
modifier|*
name|fl_fmt_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Float format string */
end_comment

begin_decl_stmt
name|char
modifier|*
name|db_fmt_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Double format string */
end_comment

begin_decl_stmt
name|char
modifier|*
name|cm_fmt_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Complex format string */
end_comment

begin_decl_stmt
name|char
modifier|*
name|dcm_fmt_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Double complex format string */
end_comment

begin_decl_stmt
name|chainp
name|new_vars
init|=
name|CHNULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List of newly created locals in this 				   function.  These may have identifiers 				   which have underscores and more than VL 				   characters */
end_comment

begin_decl_stmt
name|chainp
name|used_builtins
init|=
name|CHNULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List of builtins used by this function. 				   These are all Addrps with UNAM_EXTERN 				   */
end_comment

begin_decl_stmt
name|chainp
name|assigned_fmts
init|=
name|CHNULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* assigned formats */
end_comment

begin_decl_stmt
name|chainp
name|allargs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* union of args in all entry points */
end_comment

begin_decl_stmt
name|chainp
name|earlylabs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* labels seen before enddcl() */
end_comment

begin_decl_stmt
name|char
name|main_alias
index|[
literal|52
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* PROGRAM name, if any is given */
end_comment

begin_decl_stmt
name|int
name|tab_size
init|=
literal|4
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILEP
name|infile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILEP
name|diagfile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILEP
name|c_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILEP
name|pass1_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILEP
name|initfile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILEP
name|blkdfile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|token
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|maxtoklen
decl_stmt|,
name|toklen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|err_lineno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|lineno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current line in the input file, NOT the 				   Fortran statement label number */
end_comment

begin_decl_stmt
name|char
modifier|*
name|infname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|needkwd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|Labelblock
modifier|*
name|thislabel
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nerr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nwarn
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|flag
name|saveall
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|flag
name|substars
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|parstate
init|=
name|OUTSIDE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|flag
name|headerdone
init|=
name|NO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|blklevel
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|doin_setbound
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|impltype
index|[
literal|26
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ftnint
name|implleng
index|[
literal|26
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|implstg
index|[
literal|26
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|tyint
init|=
name|TYLONG
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|tylogical
init|=
name|TYLONG
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|tylog
init|=
name|TYLOGICAL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|typesize
index|[
name|NTYPES
index|]
init|=
block|{
literal|1
block|,
name|SZADDR
block|,
literal|1
block|,
name|SZSHORT
block|,
name|SZLONG
block|,
ifdef|#
directive|ifdef
name|TYQUAD
literal|2
operator|*
name|SZLONG
block|,
endif|#
directive|endif
name|SZLONG
block|,
literal|2
operator|*
name|SZLONG
block|,
literal|2
operator|*
name|SZLONG
block|,
literal|4
operator|*
name|SZLONG
block|,
literal|1
block|,
name|SZSHORT
block|,
name|SZLONG
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|4
operator|*
name|SZLONG
operator|+
name|SZADDR
block|,
comment|/* sizeof(cilist) */
literal|4
operator|*
name|SZLONG
operator|+
literal|2
operator|*
name|SZADDR
block|,
comment|/* sizeof(icilist) */
literal|4
operator|*
name|SZLONG
operator|+
literal|5
operator|*
name|SZADDR
block|,
comment|/* sizeof(olist) */
literal|2
operator|*
name|SZLONG
operator|+
name|SZADDR
block|,
comment|/* sizeof(cllist) */
literal|2
operator|*
name|SZLONG
block|,
comment|/* sizeof(alist) */
literal|11
operator|*
name|SZLONG
operator|+
literal|15
operator|*
name|SZADDR
comment|/* sizeof(inlist) */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|typealign
index|[
name|NTYPES
index|]
init|=
block|{
literal|1
block|,
name|ALIADDR
block|,
literal|1
block|,
name|ALISHORT
block|,
name|ALILONG
block|,
ifdef|#
directive|ifdef
name|TYQUAD
name|ALIDOUBLE
block|,
endif|#
directive|endif
name|ALILONG
block|,
name|ALIDOUBLE
block|,
name|ALILONG
block|,
name|ALIDOUBLE
block|,
literal|1
block|,
name|ALISHORT
block|,
name|ALILONG
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
name|ALILONG
block|,
name|ALILONG
block|,
name|ALILONG
block|,
name|ALILONG
block|,
name|ALILONG
block|,
name|ALILONG
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|type_choice
index|[
literal|4
index|]
init|=
block|{
name|TYDREAL
block|,
name|TYSHORT
block|,
name|TYLONG
block|,
name|TYSHORT
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|typename
index|[]
init|=
block|{
literal|"<<unknown>>"
block|,
literal|"address"
block|,
literal|"integer1"
block|,
literal|"shortint"
block|,
literal|"integer"
block|,
ifdef|#
directive|ifdef
name|TYQUAD
literal|"longint"
block|,
endif|#
directive|endif
literal|"real"
block|,
literal|"doublereal"
block|,
literal|"complex"
block|,
literal|"doublecomplex"
block|,
literal|"logical1"
block|,
literal|"shortlogical"
block|,
literal|"logical"
block|,
literal|"char"
comment|/* character */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|type_pref
index|[
name|NTYPES
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|3
block|,
literal|5
block|,
literal|7
block|,
ifdef|#
directive|ifdef
name|TYQUAD
literal|10
block|,
endif|#
directive|endif
literal|8
block|,
literal|11
block|,
literal|9
block|,
literal|12
block|,
literal|1
block|,
literal|4
block|,
literal|6
block|,
literal|2
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|protorettypes
index|[]
init|=
block|{
literal|"?"
block|,
literal|"??"
block|,
literal|"integer1"
block|,
literal|"shortint"
block|,
literal|"integer"
block|,
ifdef|#
directive|ifdef
name|TYQUAD
literal|"longint"
block|,
endif|#
directive|endif
literal|"real"
block|,
literal|"doublereal"
block|,
literal|"C_f"
block|,
literal|"Z_f"
block|,
literal|"logical1"
block|,
literal|"shortlogical"
block|,
literal|"logical"
block|,
literal|"H_f"
block|,
literal|"int"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|casttypes
index|[
name|TYSUBR
operator|+
literal|1
index|]
init|=
block|{
literal|"U_fp"
block|,
literal|"??bug??"
block|,
literal|"I1_fp"
block|,
literal|"J_fp"
block|,
literal|"I_fp"
block|,
ifdef|#
directive|ifdef
name|TYQUAD
literal|"Q_fp"
block|,
endif|#
directive|endif
literal|"R_fp"
block|,
literal|"D_fp"
block|,
literal|"C_fp"
block|,
literal|"Z_fp"
block|,
literal|"L1_fp"
block|,
literal|"L2_fp"
block|,
literal|"L_fp"
block|,
literal|"H_fp"
block|,
literal|"S_fp"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|usedcasts
index|[
name|TYSUBR
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|dfltarg
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|"(integer1 *)0"
block|,
literal|"(shortint *)0"
block|,
literal|"(integer *)0"
block|,
ifdef|#
directive|ifdef
name|TYQUAD
literal|"(longint *)0"
block|,
endif|#
directive|endif
literal|"(real *)0"
block|,
literal|"(doublereal *)0"
block|,
literal|"(complex *)0"
block|,
literal|"(doublecomplex *)0"
block|,
literal|"(logical1 *)0"
block|,
literal|"(shortlogical *)0"
block|,
literal|"(logical *)0"
block|,
literal|"(char *)0"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|dflt0proc
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|"(integer1 (*)())0"
block|,
literal|"(shortint (*)())0"
block|,
literal|"(integer (*)())0"
block|,
ifdef|#
directive|ifdef
name|TYQUAD
literal|"(longint (*)())0"
block|,
endif|#
directive|endif
literal|"(real (*)())0"
block|,
literal|"(doublereal (*)())0"
block|,
literal|"(complex (*)())0"
block|,
literal|"(doublecomplex (*)())0"
block|,
literal|"(logical1 (*)())0"
block|,
literal|"(shortlogical (*)())0"
block|,
literal|"(logical (*)())0"
block|,
literal|"(char (*)())0"
block|,
literal|"(int (*)())0"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|dflt1proc
index|[]
init|=
block|{
literal|"(U_fp)0"
block|,
literal|"(??bug??)0"
block|,
literal|"(I1_fp)0"
block|,
literal|"(J_fp)0"
block|,
literal|"(I_fp)0"
block|,
ifdef|#
directive|ifdef
name|TYQUAD
literal|"(Q_fp)0"
block|,
endif|#
directive|endif
literal|"(R_fp)0"
block|,
literal|"(D_fp)0"
block|,
literal|"(C_fp)0"
block|,
literal|"(Z_fp)0"
block|,
literal|"(L1_fp)0"
block|,
literal|"(L2_fp)0"
block|,
literal|"(L_fp)0"
block|,
literal|"(H_fp)0"
block|,
literal|"(S_fp)0"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|dfltproc
init|=
name|dflt0proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|Bug
index|[]
init|=
literal|"bug"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|ftn_types
index|[]
init|=
block|{
literal|"external"
block|,
literal|"??"
block|,
literal|"integer*1"
block|,
literal|"integer*2"
block|,
literal|"integer"
block|,
ifdef|#
directive|ifdef
name|TYQUAD
literal|"integer*8"
block|,
endif|#
directive|endif
literal|"real"
block|,
literal|"double precision"
block|,
literal|"complex"
block|,
literal|"double complex"
block|,
literal|"logical*1"
block|,
literal|"logical*2"
block|,
literal|"logical"
block|,
literal|"character"
block|,
literal|"subroutine"
block|,
name|Bug
block|,
name|Bug
block|,
name|Bug
block|,
name|Bug
block|,
name|Bug
block|,
name|Bug
block|,
name|Bug
block|,
name|Bug
block|,
name|Bug
block|,
literal|"ftnlen"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|init_ac
index|[
name|TYSUBR
operator|+
literal|1
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
ifdef|#
directive|ifdef
name|TYQUAD
literal|0
block|,
endif|#
directive|endif
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|2
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|proctype
init|=
name|TYUNKNOWN
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|procname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rtvlabel
index|[
name|NTYPES0
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Addrp
name|retslot
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Holds automatic variable which was 				   allocated the function return value 				   */
end_comment

begin_decl_stmt
name|Addrp
name|xretslot
index|[
name|NTYPES0
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for multiple entry points */
end_comment

begin_decl_stmt
name|int
name|cxslot
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|chslot
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|chlgslot
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|procclass
init|=
name|CLUNKNOWN
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nentry
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nallargs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nallchargs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|flag
name|multitype
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ftnint
name|procleng
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|lastiolabno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|lastlabno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|lastvarno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|lastargslot
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|autonum
index|[
name|TYVOID
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|av_pfix
index|[
name|TYVOID
index|]
init|=
block|{
literal|"??TYUNKNOWN??"
block|,
literal|"a"
block|,
literal|"i1"
block|,
literal|"s"
block|,
literal|"i"
block|,
ifdef|#
directive|ifdef
name|TYQUAD
literal|"i8"
block|,
endif|#
directive|endif
literal|"r"
block|,
literal|"d"
block|,
literal|"q"
block|,
literal|"z"
block|,
literal|"L1"
block|,
literal|"L2"
block|,
literal|"L"
block|,
literal|"ch"
block|,
literal|"??TYSUBR??"
block|,
literal|"??TYERROR??"
block|,
literal|"ci"
block|,
literal|"ici"
block|,
literal|"o"
block|,
literal|"cl"
block|,
literal|"al"
block|,
literal|"ioin"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|maxctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|Ctlframe
modifier|*
name|ctls
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|Ctlframe
modifier|*
name|ctlstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|Ctlframe
modifier|*
name|lastctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Namep
name|regnamep
index|[
name|MAXREGVAR
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|highregvar
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nregvar
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|maxext
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Extsym
modifier|*
name|extsymtab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Extsym
modifier|*
name|nextext
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Extsym
modifier|*
name|lastext
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|maxequiv
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|Equivblock
modifier|*
name|eqvclass
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|maxhash
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|Hashentry
modifier|*
name|hashtab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|Hashentry
modifier|*
name|lasthash
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|maxstno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Maximum number of statement labels */
end_comment

begin_decl_stmt
name|struct
name|Labelblock
modifier|*
name|labeltab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|Labelblock
modifier|*
name|labtabend
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|Labelblock
modifier|*
name|highlabtab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|maxdim
init|=
name|MAXDIM
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|Rplblock
modifier|*
name|rpllist
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|Chain
modifier|*
name|curdtp
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|flag
name|toomanyinit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ftnint
name|curdtelt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|chainp
name|templist
index|[
name|TYVOID
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|chainp
name|holdtemps
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dorange
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|Entrypoint
modifier|*
name|entries
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|chainp
name|chains
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|flag
name|inioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|iostmt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nequiv
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|eqvstart
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nintnames
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|maxlablist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|Labelblock
modifier|*
modifier|*
name|labarray
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|Literal
modifier|*
name|litpool
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nliterals
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|dflttype
index|[
literal|26
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|hextoi_tab
index|[
name|Table_size
index|]
decl_stmt|,
name|Letters
index|[
name|Table_size
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|ei_first
decl_stmt|,
modifier|*
name|ei_next
decl_stmt|,
modifier|*
name|ei_last
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|wh_first
decl_stmt|,
modifier|*
name|wh_next
decl_stmt|,
modifier|*
name|wh_last
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ALLOCN
parameter_list|(
name|n
parameter_list|,
name|x
parameter_list|)
value|(struct x *) ckalloc((n)*sizeof(struct x))
end_define

begin_function
name|void
name|fileinit
parameter_list|(
name|Void
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|lastiolabno
operator|=
literal|100000
expr_stmt|;
name|lastlabno
operator|=
literal|0
expr_stmt|;
name|lastvarno
operator|=
literal|0
expr_stmt|;
name|nliterals
operator|=
literal|0
expr_stmt|;
name|nerr
operator|=
literal|0
expr_stmt|;
name|infile
operator|=
name|stdin
expr_stmt|;
name|maxtoklen
operator|=
literal|502
expr_stmt|;
name|token
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
name|maxtoklen
operator|+
literal|2
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|dflttype
argument_list|,
name|tyreal
argument_list|,
literal|26
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|dflttype
operator|+
literal|'i'
operator|-
literal|'a'
argument_list|,
name|tyint
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|hextoi_tab
argument_list|,
literal|16
argument_list|,
sizeof|sizeof
argument_list|(
name|hextoi_tab
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|s
operator|=
literal|"0123456789abcdef"
init|;
operator|*
name|s
condition|;
name|i
operator|++
operator|,
name|s
operator|++
control|)
name|hextoi
argument_list|(
operator|*
name|s
argument_list|)
operator|=
name|i
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|10
operator|,
name|s
operator|=
literal|"ABCDEF"
init|;
operator|*
name|s
condition|;
name|i
operator|++
operator|,
name|s
operator|++
control|)
name|hextoi
argument_list|(
operator|*
name|s
argument_list|)
operator|=
name|i
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|s
operator|=
literal|"abcdefghijklmnopqrstuvwxyz"
init|;
name|i
operator|=
operator|*
name|s
operator|++
condition|;
name|j
operator|++
control|)
name|Letters
index|[
name|i
index|]
operator|=
name|Letters
index|[
name|i
operator|+
literal|'A'
operator|-
literal|'a'
index|]
operator|=
name|j
expr_stmt|;
name|ctls
operator|=
name|ALLOCN
argument_list|(
name|maxctl
operator|+
literal|1
argument_list|,
name|Ctlframe
argument_list|)
expr_stmt|;
name|extsymtab
operator|=
name|ALLOCN
argument_list|(
name|maxext
argument_list|,
name|Extsym
argument_list|)
expr_stmt|;
name|eqvclass
operator|=
name|ALLOCN
argument_list|(
name|maxequiv
argument_list|,
name|Equivblock
argument_list|)
expr_stmt|;
name|hashtab
operator|=
name|ALLOCN
argument_list|(
name|maxhash
argument_list|,
name|Hashentry
argument_list|)
expr_stmt|;
name|labeltab
operator|=
name|ALLOCN
argument_list|(
name|maxstno
argument_list|,
name|Labelblock
argument_list|)
expr_stmt|;
name|litpool
operator|=
name|ALLOCN
argument_list|(
name|maxliterals
argument_list|,
name|Literal
argument_list|)
expr_stmt|;
name|labarray
operator|=
operator|(
expr|struct
name|Labelblock
operator|*
operator|*
operator|)
name|ckalloc
argument_list|(
name|maxlablist
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|Labelblock
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|fmt_init
argument_list|()
expr_stmt|;
name|mem_init
argument_list|()
expr_stmt|;
name|np_init
argument_list|()
expr_stmt|;
name|ctlstack
operator|=
name|ctls
operator|++
expr_stmt|;
name|lastctl
operator|=
name|ctls
operator|+
name|maxctl
expr_stmt|;
name|nextext
operator|=
name|extsymtab
expr_stmt|;
name|lastext
operator|=
name|extsymtab
operator|+
name|maxext
expr_stmt|;
name|lasthash
operator|=
name|hashtab
operator|+
name|maxhash
expr_stmt|;
name|labtabend
operator|=
name|labeltab
operator|+
name|maxstno
expr_stmt|;
name|highlabtab
operator|=
name|labeltab
expr_stmt|;
name|main_alias
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|forcedouble
condition|)
name|dfltproc
index|[
name|TYREAL
index|]
operator|=
name|dfltproc
index|[
name|TYDREAL
index|]
expr_stmt|;
comment|/* Initialize the routines for providing C output */
name|out_init
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|hashclear
parameter_list|(
name|Void
parameter_list|)
comment|/* clear hash table */
block|{
specifier|register
name|struct
name|Hashentry
modifier|*
name|hp
decl_stmt|;
specifier|register
name|Namep
name|p
decl_stmt|;
specifier|register
name|struct
name|Dimblock
modifier|*
name|q
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|hp
operator|=
name|hashtab
init|;
name|hp
operator|<
name|lasthash
condition|;
operator|++
name|hp
control|)
if|if
condition|(
name|p
operator|=
name|hp
operator|->
name|varp
condition|)
block|{
name|frexpr
argument_list|(
name|p
operator|->
name|vleng
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|=
name|p
operator|->
name|vdim
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|q
operator|->
name|ndim
condition|;
operator|++
name|i
control|)
block|{
name|frexpr
argument_list|(
name|q
operator|->
name|dims
index|[
name|i
index|]
operator|.
name|dimsize
argument_list|)
expr_stmt|;
name|frexpr
argument_list|(
name|q
operator|->
name|dims
index|[
name|i
index|]
operator|.
name|dimexpr
argument_list|)
expr_stmt|;
block|}
name|frexpr
argument_list|(
name|q
operator|->
name|nelt
argument_list|)
expr_stmt|;
name|frexpr
argument_list|(
name|q
operator|->
name|baseoffset
argument_list|)
expr_stmt|;
name|frexpr
argument_list|(
name|q
operator|->
name|basexpr
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|charptr
operator|)
name|q
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|vclass
operator|==
name|CLNAMELIST
condition|)
name|frchain
argument_list|(
operator|&
operator|(
name|p
operator|->
name|varxptr
operator|.
name|namelist
operator|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|charptr
operator|)
name|p
argument_list|)
expr_stmt|;
name|hp
operator|->
name|varp
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|procinit
parameter_list|(
name|Void
parameter_list|)
block|{
specifier|register
name|struct
name|Labelblock
modifier|*
name|lp
decl_stmt|;
name|struct
name|Chain
modifier|*
name|cp
decl_stmt|;
name|int
name|i
decl_stmt|;
struct_decl|struct
name|memblock
struct_decl|;
specifier|extern
name|struct
name|memblock
modifier|*
name|curmemblock
decl_stmt|,
modifier|*
name|firstmemblock
decl_stmt|;
specifier|extern
name|char
modifier|*
name|mem_first
decl_stmt|,
modifier|*
name|mem_next
decl_stmt|,
modifier|*
name|mem_last
decl_stmt|,
modifier|*
name|mem0_last
decl_stmt|;
name|curmemblock
operator|=
name|firstmemblock
expr_stmt|;
name|mem_next
operator|=
name|mem_first
expr_stmt|;
name|mem_last
operator|=
name|mem0_last
expr_stmt|;
name|ei_next
operator|=
name|ei_first
operator|=
name|ei_last
operator|=
literal|0
expr_stmt|;
name|wh_next
operator|=
name|wh_first
operator|=
name|wh_last
operator|=
literal|0
expr_stmt|;
name|iob_list
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|9
condition|;
name|i
operator|++
control|)
name|io_structs
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|parstate
operator|=
name|OUTSIDE
expr_stmt|;
name|headerdone
operator|=
name|NO
expr_stmt|;
name|blklevel
operator|=
literal|1
expr_stmt|;
name|saveall
operator|=
name|NO
expr_stmt|;
name|substars
operator|=
name|NO
expr_stmt|;
name|nwarn
operator|=
literal|0
expr_stmt|;
name|thislabel
operator|=
name|NULL
expr_stmt|;
name|needkwd
operator|=
literal|0
expr_stmt|;
name|proctype
operator|=
name|TYUNKNOWN
expr_stmt|;
name|procname
operator|=
literal|"MAIN_"
expr_stmt|;
name|procclass
operator|=
name|CLUNKNOWN
expr_stmt|;
name|nentry
operator|=
literal|0
expr_stmt|;
name|nallargs
operator|=
name|nallchargs
operator|=
literal|0
expr_stmt|;
name|multitype
operator|=
name|NO
expr_stmt|;
name|retslot
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NTYPES0
condition|;
name|i
operator|++
control|)
block|{
name|frexpr
argument_list|(
operator|(
name|expptr
operator|)
name|xretslot
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|xretslot
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|cxslot
operator|=
operator|-
literal|1
expr_stmt|;
name|chslot
operator|=
operator|-
literal|1
expr_stmt|;
name|chlgslot
operator|=
operator|-
literal|1
expr_stmt|;
name|procleng
operator|=
literal|0
expr_stmt|;
name|blklevel
operator|=
literal|1
expr_stmt|;
name|lastargslot
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|lp
operator|=
name|labeltab
init|;
name|lp
operator|<
name|labtabend
condition|;
operator|++
name|lp
control|)
name|lp
operator|->
name|stateno
operator|=
literal|0
expr_stmt|;
name|hashclear
argument_list|()
expr_stmt|;
comment|/* Clear the list of newly generated identifiers from the previous    function */
name|frexchain
argument_list|(
operator|&
name|new_vars
argument_list|)
expr_stmt|;
name|frexchain
argument_list|(
operator|&
name|used_builtins
argument_list|)
expr_stmt|;
name|frchain
argument_list|(
operator|&
name|assigned_fmts
argument_list|)
expr_stmt|;
name|frchain
argument_list|(
operator|&
name|allargs
argument_list|)
expr_stmt|;
name|frchain
argument_list|(
operator|&
name|earlylabs
argument_list|)
expr_stmt|;
name|nintnames
operator|=
literal|0
expr_stmt|;
name|highlabtab
operator|=
name|labeltab
expr_stmt|;
name|ctlstack
operator|=
name|ctls
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
name|TYADDR
init|;
name|i
operator|<
name|TYVOID
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|cp
operator|=
name|templist
index|[
name|i
index|]
init|;
name|cp
condition|;
name|cp
operator|=
name|cp
operator|->
name|nextp
control|)
name|free
argument_list|(
call|(
name|charptr
call|)
argument_list|(
name|cp
operator|->
name|datap
argument_list|)
argument_list|)
expr_stmt|;
name|frchain
argument_list|(
name|templist
operator|+
name|i
argument_list|)
expr_stmt|;
name|autonum
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|holdtemps
operator|=
name|NULL
expr_stmt|;
name|dorange
operator|=
literal|0
expr_stmt|;
name|nregvar
operator|=
literal|0
expr_stmt|;
name|highregvar
operator|=
literal|0
expr_stmt|;
name|entries
operator|=
name|NULL
expr_stmt|;
name|rpllist
operator|=
name|NULL
expr_stmt|;
name|inioctl
operator|=
name|NO
expr_stmt|;
name|eqvstart
operator|+=
name|nequiv
expr_stmt|;
name|nequiv
operator|=
literal|0
expr_stmt|;
name|dcomplex_seen
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NTYPES0
condition|;
operator|++
name|i
control|)
name|rtvlabel
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|undeftype
condition|)
name|setimpl
argument_list|(
name|TYUNKNOWN
argument_list|,
operator|(
name|ftnint
operator|)
literal|0
argument_list|,
literal|'a'
argument_list|,
literal|'z'
argument_list|)
expr_stmt|;
else|else
block|{
name|setimpl
argument_list|(
name|tyreal
argument_list|,
operator|(
name|ftnint
operator|)
literal|0
argument_list|,
literal|'a'
argument_list|,
literal|'z'
argument_list|)
expr_stmt|;
name|setimpl
argument_list|(
name|tyint
argument_list|,
operator|(
name|ftnint
operator|)
literal|0
argument_list|,
literal|'i'
argument_list|,
literal|'n'
argument_list|)
expr_stmt|;
block|}
name|setimpl
argument_list|(
operator|-
name|STGBSS
argument_list|,
operator|(
name|ftnint
operator|)
literal|0
argument_list|,
literal|'a'
argument_list|,
literal|'z'
argument_list|)
expr_stmt|;
comment|/* set class */
block|}
end_function

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|setimpl
parameter_list|(
name|type
parameter_list|,
name|length
parameter_list|,
name|c1
parameter_list|,
name|c2
parameter_list|)
name|int
name|type
decl_stmt|;
name|ftnint
name|length
decl_stmt|;
name|int
name|c1
decl_stmt|;
name|int
name|c2
decl_stmt|;
else|#
directive|else
function|setimpl
parameter_list|(
name|int
name|type
parameter_list|,
name|ftnint
name|length
parameter_list|,
name|int
name|c1
parameter_list|,
name|int
name|c2
parameter_list|)
endif|#
directive|endif
block|{
name|int
name|i
decl_stmt|;
name|char
name|buff
index|[
literal|100
index|]
decl_stmt|;
if|if
condition|(
name|c1
operator|==
literal|0
operator|||
name|c2
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|c1
operator|>
name|c2
condition|)
block|{
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"characters out of order in implicit:%c-%c"
argument_list|,
name|c1
argument_list|,
name|c2
argument_list|)
expr_stmt|;
name|err
argument_list|(
name|buff
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|c1
operator|=
name|letter
argument_list|(
name|c1
argument_list|)
expr_stmt|;
name|c2
operator|=
name|letter
argument_list|(
name|c2
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|<
literal|0
condition|)
for|for
control|(
name|i
operator|=
name|c1
init|;
name|i
operator|<=
name|c2
condition|;
operator|++
name|i
control|)
name|implstg
index|[
name|i
index|]
operator|=
operator|-
name|type
expr_stmt|;
else|else
block|{
name|type
operator|=
name|lengtype
argument_list|(
name|type
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|TYCHAR
condition|)
block|{
if|if
condition|(
name|length
operator|<
literal|0
condition|)
block|{
name|err
argument_list|(
literal|"length (*) in implicit"
argument_list|)
expr_stmt|;
name|length
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|type
operator|!=
name|TYLONG
condition|)
name|length
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|c1
init|;
name|i
operator|<=
name|c2
condition|;
operator|++
name|i
control|)
block|{
name|impltype
index|[
name|i
index|]
operator|=
name|type
expr_stmt|;
name|implleng
index|[
name|i
index|]
operator|=
name|length
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

end_unit

