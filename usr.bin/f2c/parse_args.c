begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**************************************************************** Copyright 1990, 1994 by AT&T Bell Laboratories and Bellcore.  Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that the copyright notice and this permission notice and warranty disclaimer appear in supporting documentation, and that the names of AT&T Bell Laboratories or Bellcore or any of their entities not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  AT&T and Bellcore disclaim all warranties with regard to this software, including all implied warranties of merchantability and fitness.  In no event shall AT&T or Bellcore be liable for any special, indirect or consequential damages or any damages whatsoever resulting from loss of use, data or profits, whether in an action of contract, negligence or other tortious action, arising out of or in connection with the use or performance of this software. ****************************************************************/
end_comment

begin_comment
comment|/* parse_args  	This function will parse command line input into appropriate data    structures, output error messages when appropriate and provide some    minimal type conversion.  	Input to the function consists of the standard   argc,argv    values, and a table which directs the parser.  Each table entry has the    following components:  	prefix -- the (optional) switch character string, e.g. "-" "/" "=" 	switch -- the command string, e.g. "o" "data" "file" "F" 	flags -- control flags, e.g.   CASE_INSENSITIVE, REQUIRED_PREFIX 	arg_count -- number of arguments this command requires, e.g. 0 for 		     booleans, 1 for filenames, INFINITY for input files 	result_type -- how to interpret the switch arguments, e.g. STRING, 		       CHAR, FILE, OLD_FILE, NEW_FILE 	result_ptr -- pointer to storage for the result, be it a table or 		      a string or whatever 	table_size -- if the arguments fill a table, the maximum number of 		      entries; if there are no arguments, the value to 		      load into the result storage  	Although the table can be used to hold a list of filenames, only    scalar values (e.g. pointers) can be stored in the table.  No vector    processing will be done, only pointers to string storage will be moved.  	An example entry, which could be used to parse input filenames, is:  	"-", "o", 0, oo, OLD_FILE, infilenames, INFILE_TABLE_SIZE  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|NULL
end_ifndef

begin_comment
comment|/* ANSI C */
end_comment

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|KR_headers
end_ifdef

begin_function_decl
specifier|extern
name|double
name|atof
parameter_list|()
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"stdlib.h"
end_include

begin_include
include|#
directive|include
file|"string.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"parse.h"
end_include

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_comment
comment|/* For atof */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_define
define|#
directive|define
name|MAX_INPUT_SIZE
value|1000
end_define

begin_define
define|#
directive|define
name|arg_prefix
parameter_list|(
name|x
parameter_list|)
value|((x).prefix)
end_define

begin_define
define|#
directive|define
name|arg_string
parameter_list|(
name|x
parameter_list|)
value|((x).string)
end_define

begin_define
define|#
directive|define
name|arg_flags
parameter_list|(
name|x
parameter_list|)
value|((x).flags)
end_define

begin_define
define|#
directive|define
name|arg_count
parameter_list|(
name|x
parameter_list|)
value|((x).count)
end_define

begin_define
define|#
directive|define
name|arg_result_type
parameter_list|(
name|x
parameter_list|)
value|((x).result_type)
end_define

begin_define
define|#
directive|define
name|arg_result_ptr
parameter_list|(
name|x
parameter_list|)
value|((x).result_ptr)
end_define

begin_define
define|#
directive|define
name|arg_table_size
parameter_list|(
name|x
parameter_list|)
value|((x).table_size)
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|TRUE
end_ifndef

begin_define
define|#
directive|define
name|TRUE
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|FALSE
end_ifndef

begin_define
define|#
directive|define
name|FALSE
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_typedef
typedef|typedef
name|int
name|boolean
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|this_program
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|arg_parse
name|Argdcl
argument_list|(
operator|(
name|char
operator|*
operator|,
name|arg_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|lower_string
name|Argdcl
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|match
name|Argdcl
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|arg_info
operator|*
operator|,
name|boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|put_one_arg
name|Argdcl
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|*
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|boolean
ifdef|#
directive|ifdef
name|KR_headers
name|parse_args
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|table
parameter_list|,
name|entries
parameter_list|,
name|others
parameter_list|,
name|other_count
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|arg_info
modifier|*
name|table
decl_stmt|;
name|int
name|entries
decl_stmt|;
name|char
modifier|*
modifier|*
name|others
decl_stmt|;
name|int
name|other_count
decl_stmt|;
else|#
directive|else
function|parse_args
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|arg_info
modifier|*
name|table
parameter_list|,
name|int
name|entries
parameter_list|,
name|char
modifier|*
modifier|*
name|others
parameter_list|,
name|int
name|other_count
parameter_list|)
endif|#
directive|endif
block|{
name|boolean
name|result
decl_stmt|;
if|if
condition|(
name|argv
condition|)
name|this_program
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
comment|/* Check the validity of the table and its parameters */
name|result
operator|=
name|arg_verify
argument_list|(
name|argv
argument_list|,
name|table
argument_list|,
name|entries
argument_list|)
expr_stmt|;
comment|/* Initialize the storage values */
name|init_store
argument_list|(
name|table
argument_list|,
name|entries
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
block|{
name|boolean
name|use_prefix
init|=
name|TRUE
decl_stmt|;
name|char
modifier|*
name|argv0
decl_stmt|;
name|argc
operator|--
expr_stmt|;
name|argv0
operator|=
operator|*
operator|++
name|argv
expr_stmt|;
while|while
condition|(
name|argc
condition|)
block|{
name|int
name|index
decl_stmt|,
name|length
decl_stmt|;
name|index
operator|=
name|match_table
argument_list|(
operator|*
name|argv
argument_list|,
name|table
argument_list|,
name|entries
argument_list|,
name|use_prefix
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|<
literal|0
condition|)
block|{
comment|/* The argument doesn't match anything in the table */
if|if
condition|(
name|others
condition|)
block|{
if|if
condition|(
operator|*
name|argv
operator|>
name|argv0
condition|)
operator|*
operator|--
operator|*
name|argv
operator|=
literal|'-'
expr_stmt|;
comment|/* complain at invalid flag */
if|if
condition|(
name|other_count
operator|>
literal|0
condition|)
block|{
operator|*
name|others
operator|++
operator|=
operator|*
name|argv
expr_stmt|;
name|other_count
operator|--
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:  too many parameters: "
argument_list|,
name|this_program
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"'%s' ignored\n"
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
block|}
comment|/* else */
block|}
comment|/* if (others) */
name|argv0
operator|=
operator|*
operator|++
name|argv
expr_stmt|;
name|argc
operator|--
expr_stmt|;
block|}
else|else
block|{
comment|/* A match was found */
if|if
condition|(
name|length
operator|>=
name|strlen
argument_list|(
operator|*
name|argv
argument_list|)
condition|)
block|{
name|argc
operator|--
expr_stmt|;
name|argv0
operator|=
operator|*
operator|++
name|argv
expr_stmt|;
name|use_prefix
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
operator|(
operator|*
name|argv
operator|)
operator|+=
name|length
expr_stmt|;
name|use_prefix
operator|=
name|FALSE
expr_stmt|;
block|}
comment|/* else */
comment|/* Parse any necessary arguments */
if|if
condition|(
name|arg_count
argument_list|(
name|table
index|[
name|index
index|]
argument_list|)
operator|!=
name|P_NO_ARGS
condition|)
block|{
comment|/* Now   length   will be used to store the number of parsed characters */
name|length
operator|=
name|arg_parse
argument_list|(
operator|*
name|argv
argument_list|,
operator|&
name|table
index|[
name|index
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|argv
operator|==
name|NULL
condition|)
name|argc
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|length
operator|>=
name|strlen
argument_list|(
operator|*
name|argv
argument_list|)
condition|)
block|{
name|argc
operator|--
expr_stmt|;
name|argv0
operator|=
operator|*
operator|++
name|argv
expr_stmt|;
name|use_prefix
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
operator|(
operator|*
name|argv
operator|)
operator|+=
name|length
expr_stmt|;
name|use_prefix
operator|=
name|FALSE
expr_stmt|;
block|}
comment|/* else */
block|}
comment|/* if (argv_count != P_NO_ARGS) */
else|else
operator|*
name|arg_result_ptr
argument_list|(
name|table
index|[
name|index
index|]
argument_list|)
operator|=
name|arg_table_size
argument_list|(
name|table
index|[
name|index
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* else */
block|}
comment|/* while (argc) */
block|}
comment|/* if (result) */
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* parse_args */
end_comment

begin_function
name|boolean
ifdef|#
directive|ifdef
name|KR_headers
name|arg_verify
parameter_list|(
name|argv
parameter_list|,
name|table
parameter_list|,
name|entries
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|arg_info
modifier|*
name|table
decl_stmt|;
name|int
name|entries
decl_stmt|;
else|#
directive|else
function|arg_verify
parameter_list|(
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|arg_info
modifier|*
name|table
parameter_list|,
name|int
name|entries
parameter_list|)
endif|#
directive|endif
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|this_program
init|=
literal|""
decl_stmt|;
if|if
condition|(
name|argv
condition|)
name|this_program
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|entries
condition|;
name|i
operator|++
control|)
block|{
name|arg_info
modifier|*
name|arg
init|=
operator|&
name|table
index|[
name|i
index|]
decl_stmt|;
comment|/* Check the argument flags */
if|if
condition|(
name|arg_flags
argument_list|(
operator|*
name|arg
argument_list|)
operator|&
operator|~
operator|(
name|P_CASE_INSENSITIVE
operator||
name|P_REQUIRED_PREFIX
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s [arg_verify]:  too many "
argument_list|,
name|this_program
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"flags in entry %d:  '%x' (hex)\n"
argument_list|,
name|i
argument_list|,
name|arg_flags
argument_list|(
operator|*
name|arg
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* if */
comment|/* Check the argument count */
block|{
name|int
name|count
init|=
name|arg_count
argument_list|(
operator|*
name|arg
argument_list|)
decl_stmt|;
if|if
condition|(
name|count
operator|!=
name|P_NO_ARGS
operator|&&
name|count
operator|!=
name|P_ONE_ARG
operator|&&
name|count
operator|!=
name|P_INFINITE_ARGS
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s [arg_verify]:  invalid "
argument_list|,
name|this_program
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"argument count in entry %d:  '%d'\n"
argument_list|,
name|i
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
comment|/* if count != P_NO_ARGS ... */
comment|/* Check the result field; want to be able to store results */
elseif|else
if|if
condition|(
name|arg_result_ptr
argument_list|(
operator|*
name|arg
argument_list|)
operator|==
operator|(
name|int
operator|*
operator|)
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s [arg_verify]:  "
argument_list|,
name|this_program
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"no argument storage given for "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"entry %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* if arg_result_ptr */
block|}
comment|/* Check the argument type */
block|{
name|int
name|type
init|=
name|arg_result_type
argument_list|(
operator|*
name|arg
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|<
name|P_STRING
operator|||
name|type
operator|>
name|P_DOUBLE
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s [arg_verify]:  bad arg type in entry %d:  '%d'\n"
argument_list|,
name|this_program
argument_list|,
name|i
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
comment|/* Check table size */
block|{
name|int
name|size
init|=
name|arg_table_size
argument_list|(
operator|*
name|arg
argument_list|)
decl_stmt|;
if|if
condition|(
name|arg_count
argument_list|(
operator|*
name|arg
argument_list|)
operator|==
name|P_INFINITE_ARGS
operator|&&
name|size
operator|<
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s [arg_verify]:  bad "
argument_list|,
name|this_program
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"table size in entry %d:  '%d'\n"
argument_list|,
name|i
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
comment|/* if (arg_count == P_INFINITE_ARGS&& size< 1) */
block|}
block|}
comment|/* for i = 0 */
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* arg_verify */
end_comment

begin_comment
comment|/* match_table -- returns the index of the best entry matching the input,    -1 if no match.  The best match is the one of longest length which    appears lowest in the table.  The length of the match will be returned    in   length   ONLY IF a match was found.   */
end_comment

begin_function
name|int
ifdef|#
directive|ifdef
name|KR_headers
name|match_table
parameter_list|(
name|norm_input
parameter_list|,
name|table
parameter_list|,
name|entries
parameter_list|,
name|use_prefix
parameter_list|,
name|length
parameter_list|)
specifier|register
name|char
modifier|*
name|norm_input
decl_stmt|;
name|arg_info
modifier|*
name|table
decl_stmt|;
name|int
name|entries
decl_stmt|;
name|boolean
name|use_prefix
decl_stmt|;
name|int
modifier|*
name|length
decl_stmt|;
else|#
directive|else
function|match_table
parameter_list|(
specifier|register
name|char
modifier|*
name|norm_input
parameter_list|,
name|arg_info
modifier|*
name|table
parameter_list|,
name|int
name|entries
parameter_list|,
name|boolean
name|use_prefix
parameter_list|,
name|int
modifier|*
name|length
parameter_list|)
endif|#
directive|endif
block|{
name|char
name|low_input
index|[
name|MAX_INPUT_SIZE
index|]
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|best_index
init|=
operator|-
literal|1
decl_stmt|,
name|best_length
init|=
literal|0
decl_stmt|;
comment|/* FUNCTION BODY */
operator|(
name|void
operator|)
name|lower_string
argument_list|(
name|low_input
argument_list|,
name|norm_input
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|entries
condition|;
name|i
operator|++
control|)
block|{
name|int
name|this_length
init|=
name|match
argument_list|(
name|norm_input
argument_list|,
name|low_input
argument_list|,
operator|&
name|table
index|[
name|i
index|]
argument_list|,
name|use_prefix
argument_list|)
decl_stmt|;
if|if
condition|(
name|this_length
operator|>
name|best_length
condition|)
block|{
name|best_index
operator|=
name|i
expr_stmt|;
name|best_length
operator|=
name|this_length
expr_stmt|;
block|}
comment|/* if (this_length> best_length) */
block|}
comment|/* for (i = 0) */
if|if
condition|(
name|best_index
operator|>
operator|-
literal|1
operator|&&
name|length
operator|!=
operator|(
name|int
operator|*
operator|)
name|NULL
condition|)
operator|*
name|length
operator|=
name|best_length
expr_stmt|;
return|return
name|best_index
return|;
block|}
end_function

begin_comment
comment|/* match_table */
end_comment

begin_comment
comment|/* match -- takes an input string and table entry, and returns the length    of the longer match.  	0 ==> input doesn't match     For example:  	INPUT	PREFIX	STRING	RESULT ---------------------------------------------------------------------- 	"abcd"	"-"	"d"	0 	"-d"	"-"	"d"	2    (i.e. "-d") 	"dout"	"-"	"d"	1    (i.e. "d") 	"-d"	""	"-d"	2    (i.e. "-d") 	"dd"	"d"	"d"	2<= here's the weird one */
end_comment

begin_function
specifier|static
name|int
ifdef|#
directive|ifdef
name|KR_headers
name|match
parameter_list|(
name|norm_input
parameter_list|,
name|low_input
parameter_list|,
name|entry
parameter_list|,
name|use_prefix
parameter_list|)
name|char
modifier|*
name|norm_input
decl_stmt|;
name|char
modifier|*
name|low_input
decl_stmt|;
name|arg_info
modifier|*
name|entry
decl_stmt|;
name|boolean
name|use_prefix
decl_stmt|;
else|#
directive|else
function|match
parameter_list|(
name|char
modifier|*
name|norm_input
parameter_list|,
name|char
modifier|*
name|low_input
parameter_list|,
name|arg_info
modifier|*
name|entry
parameter_list|,
name|boolean
name|use_prefix
parameter_list|)
endif|#
directive|endif
block|{
name|char
modifier|*
name|norm_prefix
init|=
name|arg_prefix
argument_list|(
operator|*
name|entry
argument_list|)
decl_stmt|;
name|char
modifier|*
name|norm_string
init|=
name|arg_string
argument_list|(
operator|*
name|entry
argument_list|)
decl_stmt|;
name|boolean
name|prefix_match
init|=
name|FALSE
decl_stmt|,
name|string_match
init|=
name|FALSE
decl_stmt|;
name|int
name|result
init|=
literal|0
decl_stmt|;
comment|/* Buffers for the lowercased versions of the strings being compared.    These are used when the switch is to be case insensitive */
specifier|static
name|char
name|low_prefix
index|[
name|MAX_INPUT_SIZE
index|]
decl_stmt|;
specifier|static
name|char
name|low_string
index|[
name|MAX_INPUT_SIZE
index|]
decl_stmt|;
name|int
name|prefix_length
init|=
name|strlen
argument_list|(
name|norm_prefix
argument_list|)
decl_stmt|;
name|int
name|string_length
init|=
name|strlen
argument_list|(
name|norm_string
argument_list|)
decl_stmt|;
comment|/* Pointers for the required strings (lowered or nonlowered) */
specifier|register
name|char
modifier|*
name|input
decl_stmt|,
modifier|*
name|prefix
decl_stmt|,
modifier|*
name|string
decl_stmt|;
comment|/* FUNCTION BODY */
comment|/* Use the appropriate strings to handle case sensitivity */
if|if
condition|(
name|arg_flags
argument_list|(
operator|*
name|entry
argument_list|)
operator|&
name|P_CASE_INSENSITIVE
condition|)
block|{
name|input
operator|=
name|low_input
expr_stmt|;
name|prefix
operator|=
name|lower_string
argument_list|(
name|low_prefix
argument_list|,
name|norm_prefix
argument_list|)
expr_stmt|;
name|string
operator|=
name|lower_string
argument_list|(
name|low_string
argument_list|,
name|norm_string
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|input
operator|=
name|norm_input
expr_stmt|;
name|prefix
operator|=
name|norm_prefix
expr_stmt|;
name|string
operator|=
name|norm_string
expr_stmt|;
block|}
comment|/* else */
comment|/* First, check the string formed by concatenating the prefix onto the    switch string, but only when the prefix is not being ignored */
if|if
condition|(
name|use_prefix
operator|&&
name|prefix
operator|!=
name|NULL
operator|&&
operator|*
name|prefix
operator|!=
literal|'\0'
condition|)
name|prefix_match
operator|=
operator|(
name|strncmp
argument_list|(
name|input
argument_list|,
name|prefix
argument_list|,
name|prefix_length
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|input
operator|+
name|prefix_length
argument_list|,
name|string
argument_list|,
name|string_length
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
comment|/* Next, check just the switch string, if that's allowed */
if|if
condition|(
operator|!
name|use_prefix
operator|&&
operator|(
name|arg_flags
argument_list|(
operator|*
name|entry
argument_list|)
operator|&
name|P_REQUIRED_PREFIX
operator|)
operator|==
literal|0
condition|)
name|string_match
operator|=
name|strncmp
argument_list|(
name|input
argument_list|,
name|string
argument_list|,
name|string_length
argument_list|)
operator|==
literal|0
expr_stmt|;
if|if
condition|(
name|prefix_match
condition|)
name|result
operator|=
name|prefix_length
operator|+
name|string_length
expr_stmt|;
elseif|else
if|if
condition|(
name|string_match
condition|)
name|result
operator|=
name|string_length
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* match */
end_comment

begin_function
specifier|static
name|char
modifier|*
ifdef|#
directive|ifdef
name|KR_headers
name|lower_string
parameter_list|(
name|dest
parameter_list|,
name|src
parameter_list|)
name|char
modifier|*
name|dest
decl_stmt|;
name|char
modifier|*
name|src
decl_stmt|;
else|#
directive|else
function|lower_string
parameter_list|(
name|char
modifier|*
name|dest
parameter_list|,
name|char
modifier|*
name|src
parameter_list|)
endif|#
directive|endif
block|{
name|char
modifier|*
name|result
init|=
name|dest
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
if|if
condition|(
name|dest
operator|==
name|NULL
operator|||
name|src
operator|==
name|NULL
condition|)
name|result
operator|=
name|NULL
expr_stmt|;
else|else
while|while
condition|(
operator|*
name|dest
operator|++
operator|=
operator|(
name|c
operator|=
operator|*
name|src
operator|++
operator|)
operator|>=
literal|'A'
operator|&&
name|c
operator|<=
literal|'Z'
condition|?
name|tolower
argument_list|(
name|c
argument_list|)
else|:
name|c
condition|)
empty_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* lower_string */
end_comment

begin_comment
comment|/* arg_parse -- returns the number of characters parsed for this entry */
end_comment

begin_function
specifier|static
name|int
ifdef|#
directive|ifdef
name|KR_headers
name|arg_parse
parameter_list|(
name|str
parameter_list|,
name|entry
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|arg_info
modifier|*
name|entry
decl_stmt|;
else|#
directive|else
function|arg_parse
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|arg_info
modifier|*
name|entry
parameter_list|)
endif|#
directive|endif
block|{
name|int
name|length
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|arg_count
argument_list|(
operator|*
name|entry
argument_list|)
operator|==
name|P_ONE_ARG
condition|)
block|{
name|char
modifier|*
modifier|*
name|store
init|=
operator|(
name|char
operator|*
operator|*
operator|)
name|arg_result_ptr
argument_list|(
operator|*
name|entry
argument_list|)
decl_stmt|;
name|length
operator|=
name|put_one_arg
argument_list|(
name|arg_result_type
argument_list|(
operator|*
name|entry
argument_list|)
argument_list|,
name|str
argument_list|,
name|store
argument_list|,
name|arg_prefix
argument_list|(
operator|*
name|entry
argument_list|)
argument_list|,
name|arg_string
argument_list|(
operator|*
name|entry
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* if (arg_count == P_ONE_ARG) */
else|else
block|{
comment|/* Must be a table of arguments */
name|char
modifier|*
modifier|*
name|store
init|=
operator|(
name|char
operator|*
operator|*
operator|)
name|arg_result_ptr
argument_list|(
operator|*
name|entry
argument_list|)
decl_stmt|;
if|if
condition|(
name|store
condition|)
block|{
while|while
condition|(
operator|*
name|store
condition|)
name|store
operator|++
expr_stmt|;
name|length
operator|=
name|put_one_arg
argument_list|(
name|arg_result_type
argument_list|(
operator|*
name|entry
argument_list|)
argument_list|,
name|str
argument_list|,
name|store
operator|++
argument_list|,
name|arg_prefix
argument_list|(
operator|*
name|entry
argument_list|)
argument_list|,
name|arg_string
argument_list|(
operator|*
name|entry
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|store
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
comment|/* if (store) */
block|}
comment|/* else */
return|return
name|length
return|;
block|}
end_function

begin_comment
comment|/* arg_parse */
end_comment

begin_function
specifier|static
name|int
ifdef|#
directive|ifdef
name|KR_headers
name|put_one_arg
parameter_list|(
name|type
parameter_list|,
name|str
parameter_list|,
name|store
parameter_list|,
name|prefix
parameter_list|,
name|string
parameter_list|)
name|int
name|type
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|char
modifier|*
modifier|*
name|store
decl_stmt|;
name|char
modifier|*
name|prefix
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
else|#
directive|else
function|put_one_arg
parameter_list|(
name|int
name|type
parameter_list|,
name|char
modifier|*
name|str
parameter_list|,
name|char
modifier|*
modifier|*
name|store
parameter_list|,
name|char
modifier|*
name|prefix
parameter_list|,
name|char
modifier|*
name|string
parameter_list|)
endif|#
directive|endif
block|{
name|int
name|length
init|=
literal|0
decl_stmt|;
name|long
name|L
decl_stmt|;
if|if
condition|(
name|store
condition|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|P_STRING
case|:
case|case
name|P_FILE
case|:
case|case
name|P_OLD_FILE
case|:
case|case
name|P_NEW_FILE
case|:
operator|*
name|store
operator|=
name|str
expr_stmt|;
if|if
condition|(
name|str
operator|==
name|NULL
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Missing argument after '%s%s'\n"
argument_list|,
name|this_program
argument_list|,
name|prefix
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|length
operator|=
name|str
condition|?
name|strlen
argument_list|(
name|str
argument_list|)
else|:
literal|0
expr_stmt|;
break|break;
case|case
name|P_CHAR
case|:
operator|*
operator|(
operator|(
name|char
operator|*
operator|)
name|store
operator|)
operator|=
operator|*
name|str
expr_stmt|;
name|length
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|P_SHORT
case|:
name|L
operator|=
name|atol
argument_list|(
name|str
argument_list|)
expr_stmt|;
operator|*
operator|(
name|short
operator|*
operator|)
name|store
operator|=
operator|(
name|short
operator|)
name|L
expr_stmt|;
if|if
condition|(
name|L
operator|!=
operator|*
operator|(
name|short
operator|*
operator|)
name|store
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s%s parameter '%ld' is not a SHORT INT (truncating to %d)\n"
argument_list|,
name|prefix
argument_list|,
name|string
argument_list|,
name|L
argument_list|,
operator|*
operator|(
name|short
operator|*
operator|)
name|store
argument_list|)
expr_stmt|;
name|length
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
break|break;
case|case
name|P_INT
case|:
name|L
operator|=
name|atol
argument_list|(
name|str
argument_list|)
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|store
operator|=
operator|(
name|int
operator|)
name|L
expr_stmt|;
if|if
condition|(
name|L
operator|!=
operator|*
operator|(
name|int
operator|*
operator|)
name|store
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s%s parameter '%ld' is not an INT (truncating to %d)\n"
argument_list|,
name|prefix
argument_list|,
name|string
argument_list|,
name|L
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|store
argument_list|)
expr_stmt|;
name|length
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
break|break;
case|case
name|P_LONG
case|:
operator|*
operator|(
name|long
operator|*
operator|)
name|store
operator|=
name|atol
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|length
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
break|break;
case|case
name|P_FLOAT
case|:
operator|*
operator|(
operator|(
name|float
operator|*
operator|)
name|store
operator|)
operator|=
operator|(
name|float
operator|)
name|atof
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|length
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
break|break;
case|case
name|P_DOUBLE
case|:
operator|*
operator|(
operator|(
name|double
operator|*
operator|)
name|store
operator|)
operator|=
operator|(
name|double
operator|)
name|atof
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|length
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"put_one_arg:  bad type '%d'\n"
argument_list|,
name|type
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* switch */
block|}
comment|/* if (store) */
return|return
name|length
return|;
block|}
end_function

begin_comment
comment|/* put_one_arg */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|init_store
parameter_list|(
name|table
parameter_list|,
name|entries
parameter_list|)
name|arg_info
modifier|*
name|table
decl_stmt|;
name|int
name|entries
decl_stmt|;
else|#
directive|else
function|init_store
parameter_list|(
name|arg_info
modifier|*
name|table
parameter_list|,
name|int
name|entries
parameter_list|)
endif|#
directive|endif
block|{
name|int
name|index
decl_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|entries
condition|;
name|index
operator|++
control|)
if|if
condition|(
name|arg_count
argument_list|(
name|table
index|[
name|index
index|]
argument_list|)
operator|==
name|P_INFINITE_ARGS
condition|)
block|{
name|char
modifier|*
modifier|*
name|place
init|=
operator|(
name|char
operator|*
operator|*
operator|)
name|arg_result_ptr
argument_list|(
name|table
index|[
name|index
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|place
condition|)
operator|*
name|place
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
comment|/* if arg_count == P_INFINITE_ARGS */
block|}
end_function

begin_comment
comment|/* init_store */
end_comment

end_unit

