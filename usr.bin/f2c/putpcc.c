begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**************************************************************** Copyright 1990 - 1996 by AT&T, Lucent Technologies and Bellcore.  Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that the copyright notice and this permission notice and warranty disclaimer appear in supporting documentation, and that the names of AT&T, Bell Laboratories, Lucent or Bellcore or any of their entities not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  AT&T, Lucent and Bellcore disclaim all warranties with regard to this software, including all implied warranties of merchantability and fitness.  In no event shall AT&T, Lucent or Bellcore be liable for any special, indirect or consequential damages or any damages whatsoever resulting from loss of use, data or profits, whether in an action of contract, negligence or other tortious action, arising out of or in connection with the use or performance of this software. ****************************************************************/
end_comment

begin_comment
comment|/* INTERMEDIATE CODE GENERATION FOR S. C. JOHNSON C COMPILERS */
end_comment

begin_comment
comment|/* NEW VERSION USING BINARY POLISH POSTFIX INTERMEDIATE */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"pccdefs.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_comment
comment|/* for nice_printf */
end_comment

begin_include
include|#
directive|include
file|"names.h"
end_include

begin_include
include|#
directive|include
file|"p1defs.h"
end_include

begin_decl_stmt
specifier|static
name|Addrp
name|intdouble
name|Argdcl
argument_list|(
operator|(
name|Addrp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Addrp
name|putcx1
name|Argdcl
argument_list|(
operator|(
name|tagptr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tagptr
name|putaddr
name|Argdcl
argument_list|(
operator|(
name|tagptr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tagptr
name|putcall
name|Argdcl
argument_list|(
operator|(
name|tagptr
operator|,
name|Addrp
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tagptr
name|putcat
name|Argdcl
argument_list|(
operator|(
name|tagptr
operator|,
name|tagptr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Addrp
name|putch1
name|Argdcl
argument_list|(
operator|(
name|tagptr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tagptr
name|putchcmp
name|Argdcl
argument_list|(
operator|(
name|tagptr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tagptr
name|putcheq
name|Argdcl
argument_list|(
operator|(
name|tagptr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|putct1
name|Argdcl
argument_list|(
operator|(
name|tagptr
operator|,
name|Addrp
operator|,
name|Addrp
operator|,
name|ptr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tagptr
name|putcxcmp
name|Argdcl
argument_list|(
operator|(
name|tagptr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Addrp
name|putcxeq
name|Argdcl
argument_list|(
operator|(
name|tagptr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tagptr
name|putmnmx
name|Argdcl
argument_list|(
operator|(
name|tagptr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tagptr
name|putop
name|Argdcl
argument_list|(
operator|(
name|tagptr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tagptr
name|putpower
name|Argdcl
argument_list|(
operator|(
name|tagptr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|init_ac
index|[
name|TYSUBR
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|ops2
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|proc_argchanges
decl_stmt|,
name|proc_protochanges
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|krparens
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|P2BUFFMAX
value|128
end_define

begin_comment
comment|/* Puthead -- output the header information about subroutines, functions    and entry points */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|puthead
parameter_list|(
name|s
parameter_list|,
name|class
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|class
decl_stmt|;
else|#
directive|else
function|puthead
parameter_list|(
name|char
modifier|*
name|s
parameter_list|,
name|int
name|class
parameter_list|)
endif|#
directive|endif
block|{
if|if
condition|(
name|headerdone
operator|==
name|NO
condition|)
block|{
if|if
condition|(
name|class
operator|==
name|CLMAIN
condition|)
name|s
operator|=
literal|"MAIN__"
expr_stmt|;
name|p1_head
argument_list|(
name|class
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|headerdone
operator|=
name|YES
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|putif
parameter_list|(
name|p
parameter_list|,
name|else_if_p
parameter_list|)
specifier|register
name|expptr
name|p
decl_stmt|;
name|int
name|else_if_p
decl_stmt|;
else|#
directive|else
function|putif
parameter_list|(
specifier|register
name|expptr
name|p
parameter_list|,
name|int
name|else_if_p
parameter_list|)
endif|#
directive|endif
block|{
specifier|register
name|int
name|k
decl_stmt|;
name|int
name|n
decl_stmt|;
name|long
name|where
decl_stmt|;
if|if
condition|(
name|else_if_p
condition|)
block|{
name|p1put
argument_list|(
name|P1_ELSEIFSTART
argument_list|)
expr_stmt|;
name|where
operator|=
name|ftell
argument_list|(
name|pass1_file
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ISLOGICAL
argument_list|(
operator|(
name|k
operator|=
operator|(
name|p
operator|=
name|fixtype
argument_list|(
name|p
argument_list|)
operator|)
operator|->
name|headblock
operator|.
name|vtype
operator|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|k
operator|!=
name|TYERROR
condition|)
name|err
argument_list|(
literal|"non-logical expression in IF statement"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|else_if_p
condition|)
block|{
if|if
condition|(
name|ei_next
operator|>=
name|ei_last
condition|)
block|{
name|k
operator|=
name|ei_last
operator|-
name|ei_first
expr_stmt|;
name|n
operator|=
name|k
operator|+
literal|100
expr_stmt|;
name|ei_next
operator|=
name|mem
argument_list|(
name|n
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ei_last
operator|=
name|ei_first
operator|+
name|n
expr_stmt|;
if|if
condition|(
name|k
condition|)
name|memcpy
argument_list|(
name|ei_next
argument_list|,
name|ei_first
argument_list|,
name|k
argument_list|)
expr_stmt|;
name|ei_first
operator|=
name|ei_next
expr_stmt|;
name|ei_next
operator|+=
name|k
expr_stmt|;
name|ei_last
operator|=
name|ei_first
operator|+
name|n
expr_stmt|;
block|}
name|p
operator|=
name|putx
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ei_next
operator|++
operator|=
name|ftell
argument_list|(
name|pass1_file
argument_list|)
operator|>
name|where
condition|)
block|{
name|p1_if
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|new_endif
argument_list|()
expr_stmt|;
block|}
else|else
name|p1_elif
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p
operator|=
name|putx
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p1_if
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|putout
parameter_list|(
name|p
parameter_list|)
name|expptr
name|p
decl_stmt|;
else|#
directive|else
function|putout
parameter_list|(
name|expptr
name|p
parameter_list|)
endif|#
directive|endif
block|{
name|p1_expr
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* Used to make temporaries in holdtemps available here, but they */
comment|/* may be reused too soon (e.g. when multiple **'s are involved). */
block|}
end_function

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|putcmgo
parameter_list|(
name|index
parameter_list|,
name|nlab
parameter_list|,
name|labs
parameter_list|)
name|expptr
name|index
decl_stmt|;
name|int
name|nlab
decl_stmt|;
name|struct
name|Labelblock
modifier|*
modifier|*
name|labs
decl_stmt|;
else|#
directive|else
function|putcmgo
parameter_list|(
name|expptr
name|index
parameter_list|,
name|int
name|nlab
parameter_list|,
name|struct
name|Labelblock
modifier|*
modifier|*
name|labs
parameter_list|)
endif|#
directive|endif
block|{
if|if
condition|(
operator|!
name|ISINT
argument_list|(
name|index
operator|->
name|headblock
operator|.
name|vtype
argument_list|)
condition|)
block|{
name|execerr
argument_list|(
literal|"computed goto index must be integer"
argument_list|,
name|CNULL
argument_list|)
expr_stmt|;
return|return;
block|}
name|p1comp_goto
argument_list|(
name|index
argument_list|,
name|nlab
argument_list|,
name|labs
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|expptr
ifdef|#
directive|ifdef
name|KR_headers
name|krput
parameter_list|(
name|p
parameter_list|)
specifier|register
name|expptr
name|p
decl_stmt|;
else|#
directive|else
function|krput
parameter_list|(
specifier|register
name|expptr
name|p
parameter_list|)
endif|#
directive|endif
block|{
specifier|register
name|expptr
name|e
decl_stmt|,
name|e1
decl_stmt|;
specifier|register
name|unsigned
name|op
decl_stmt|;
name|int
name|t
init|=
name|krparens
operator|==
literal|2
condition|?
name|TYDREAL
else|:
name|p
operator|->
name|exprblock
operator|.
name|vtype
decl_stmt|;
name|op
operator|=
name|p
operator|->
name|exprblock
operator|.
name|opcode
expr_stmt|;
name|e
operator|=
name|p
operator|->
name|exprblock
operator|.
name|leftp
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|tag
operator|==
name|TEXPR
operator|&&
name|e
operator|->
name|exprblock
operator|.
name|opcode
operator|==
name|op
condition|)
block|{
name|e1
operator|=
operator|(
name|expptr
operator|)
name|mktmp
argument_list|(
name|t
argument_list|,
name|ENULL
argument_list|)
expr_stmt|;
name|putout
argument_list|(
name|putassign
argument_list|(
name|cpexpr
argument_list|(
name|e1
argument_list|)
argument_list|,
name|e
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|exprblock
operator|.
name|leftp
operator|=
name|e1
expr_stmt|;
block|}
else|else
name|p
operator|->
name|exprblock
operator|.
name|leftp
operator|=
name|putx
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|e
operator|=
name|p
operator|->
name|exprblock
operator|.
name|rightp
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|tag
operator|==
name|TEXPR
operator|&&
name|e
operator|->
name|exprblock
operator|.
name|opcode
operator|==
name|op
condition|)
block|{
name|e1
operator|=
operator|(
name|expptr
operator|)
name|mktmp
argument_list|(
name|t
argument_list|,
name|ENULL
argument_list|)
expr_stmt|;
name|putout
argument_list|(
name|putassign
argument_list|(
name|cpexpr
argument_list|(
name|e1
argument_list|)
argument_list|,
name|e
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|exprblock
operator|.
name|rightp
operator|=
name|e1
expr_stmt|;
block|}
else|else
name|p
operator|->
name|exprblock
operator|.
name|rightp
operator|=
name|putx
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_function
name|expptr
ifdef|#
directive|ifdef
name|KR_headers
name|putx
parameter_list|(
name|p
parameter_list|)
specifier|register
name|expptr
name|p
decl_stmt|;
else|#
directive|else
function|putx
parameter_list|(
specifier|register
name|expptr
name|p
parameter_list|)
endif|#
directive|endif
block|{
name|int
name|opc
decl_stmt|;
name|int
name|k
decl_stmt|;
if|if
condition|(
name|p
condition|)
switch|switch
condition|(
name|p
operator|->
name|tag
condition|)
block|{
case|case
name|TERROR
case|:
break|break;
case|case
name|TCONST
case|:
switch|switch
condition|(
name|p
operator|->
name|constblock
operator|.
name|vtype
condition|)
block|{
case|case
name|TYLOGICAL1
case|:
case|case
name|TYLOGICAL2
case|:
case|case
name|TYLOGICAL
case|:
ifdef|#
directive|ifdef
name|TYQUAD
case|case
name|TYQUAD
case|:
endif|#
directive|endif
case|case
name|TYLONG
case|:
case|case
name|TYSHORT
case|:
case|case
name|TYINT1
case|:
break|break;
case|case
name|TYADDR
case|:
break|break;
case|case
name|TYREAL
case|:
case|case
name|TYDREAL
case|:
comment|/* Don't write it out to the p2 file, since you'd need to call putconst,    which is just what we need to avoid in the translator */
break|break;
default|default:
name|p
operator|=
name|putx
argument_list|(
operator|(
name|expptr
operator|)
name|putconst
argument_list|(
operator|(
name|Constp
operator|)
name|p
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|TEXPR
case|:
switch|switch
condition|(
name|opc
operator|=
name|p
operator|->
name|exprblock
operator|.
name|opcode
condition|)
block|{
case|case
name|OPCALL
case|:
case|case
name|OPCCALL
case|:
if|if
condition|(
name|ISCOMPLEX
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|vtype
argument_list|)
condition|)
name|p
operator|=
name|putcxop
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|else
name|p
operator|=
name|putcall
argument_list|(
name|p
argument_list|,
operator|(
name|Addrp
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPMIN
case|:
case|case
name|OPMAX
case|:
name|p
operator|=
name|putmnmx
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPASSIGN
case|:
if|if
condition|(
name|ISCOMPLEX
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|leftp
operator|->
name|headblock
operator|.
name|vtype
argument_list|)
operator|||
name|ISCOMPLEX
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|rightp
operator|->
name|headblock
operator|.
name|vtype
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|putcxeq
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|ENULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ISCHAR
argument_list|(
name|p
argument_list|)
condition|)
name|p
operator|=
name|putcheq
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|else
goto|goto
name|putopp
goto|;
break|break;
case|case
name|OPEQ
case|:
case|case
name|OPNE
case|:
if|if
condition|(
name|ISCOMPLEX
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|leftp
operator|->
name|headblock
operator|.
name|vtype
argument_list|)
operator|||
name|ISCOMPLEX
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|rightp
operator|->
name|headblock
operator|.
name|vtype
argument_list|)
condition|)
block|{
name|p
operator|=
name|putcxcmp
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|OPLT
case|:
case|case
name|OPLE
case|:
case|case
name|OPGT
case|:
case|case
name|OPGE
case|:
if|if
condition|(
name|ISCHAR
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|leftp
argument_list|)
condition|)
block|{
name|p
operator|=
name|putchcmp
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
block|}
goto|goto
name|putopp
goto|;
case|case
name|OPPOWER
case|:
name|p
operator|=
name|putpower
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPSTAR
case|:
comment|/*   m * (2**k) -> m<<k   */
if|if
condition|(
name|INT
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|leftp
operator|->
name|headblock
operator|.
name|vtype
argument_list|)
operator|&&
name|ISICON
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|rightp
argument_list|)
operator|&&
operator|(
operator|(
name|k
operator|=
name|log_2
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|rightp
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
argument_list|)
operator|)
operator|>
literal|0
operator|)
condition|)
block|{
name|p
operator|->
name|exprblock
operator|.
name|opcode
operator|=
name|OPLSHIFT
expr_stmt|;
name|frexpr
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|rightp
argument_list|)
expr_stmt|;
name|p
operator|->
name|exprblock
operator|.
name|rightp
operator|=
name|ICON
argument_list|(
name|k
argument_list|)
expr_stmt|;
goto|goto
name|putopp
goto|;
block|}
if|if
condition|(
name|krparens
operator|&&
name|ISREAL
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|vtype
argument_list|)
condition|)
return|return
name|krput
argument_list|(
name|p
argument_list|)
return|;
case|case
name|OPMOD
case|:
goto|goto
name|putopp
goto|;
case|case
name|OPPLUS
case|:
if|if
condition|(
name|krparens
operator|&&
name|ISREAL
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|vtype
argument_list|)
condition|)
return|return
name|krput
argument_list|(
name|p
argument_list|)
return|;
case|case
name|OPMINUS
case|:
case|case
name|OPSLASH
case|:
case|case
name|OPNEG
case|:
case|case
name|OPNEG1
case|:
case|case
name|OPABS
case|:
case|case
name|OPDABS
case|:
if|if
condition|(
name|ISCOMPLEX
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|vtype
argument_list|)
condition|)
name|p
operator|=
name|putcxop
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|else
goto|goto
name|putopp
goto|;
break|break;
case|case
name|OPCONV
case|:
if|if
condition|(
name|ISCOMPLEX
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|vtype
argument_list|)
condition|)
name|p
operator|=
name|putcxop
argument_list|(
name|p
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ISCOMPLEX
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|leftp
operator|->
name|headblock
operator|.
name|vtype
argument_list|)
condition|)
block|{
name|p
operator|=
name|putx
argument_list|(
name|mkconv
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|vtype
argument_list|,
operator|(
name|expptr
operator|)
name|realpart
argument_list|(
name|putcx1
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|leftp
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
goto|goto
name|putopp
goto|;
break|break;
case|case
name|OPNOT
case|:
case|case
name|OPOR
case|:
case|case
name|OPAND
case|:
case|case
name|OPEQV
case|:
case|case
name|OPNEQV
case|:
case|case
name|OPADDR
case|:
case|case
name|OPPLUSEQ
case|:
case|case
name|OPSTAREQ
case|:
case|case
name|OPCOMMA
case|:
case|case
name|OPQUEST
case|:
case|case
name|OPCOLON
case|:
case|case
name|OPBITOR
case|:
case|case
name|OPBITAND
case|:
case|case
name|OPBITXOR
case|:
case|case
name|OPBITNOT
case|:
case|case
name|OPLSHIFT
case|:
case|case
name|OPRSHIFT
case|:
case|case
name|OPASSIGNI
case|:
case|case
name|OPIDENTITY
case|:
case|case
name|OPCHARCAST
case|:
case|case
name|OPMIN2
case|:
case|case
name|OPMAX2
case|:
case|case
name|OPDMIN
case|:
case|case
name|OPDMAX
case|:
case|case
name|OPBITTEST
case|:
case|case
name|OPBITCLR
case|:
case|case
name|OPBITSET
case|:
ifdef|#
directive|ifdef
name|TYQUAD
case|case
name|OPQBITSET
case|:
case|case
name|OPQBITCLR
case|:
endif|#
directive|endif
name|putopp
label|:
name|p
operator|=
name|putop
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPCONCAT
case|:
comment|/* weird things like ichar(a//a) */
name|p
operator|=
operator|(
name|expptr
operator|)
name|putch1
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
default|default:
name|badop
argument_list|(
literal|"putx"
argument_list|,
name|opc
argument_list|)
expr_stmt|;
name|p
operator|=
name|errnode
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|TADDR
case|:
name|p
operator|=
name|putaddr
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
default|default:
name|badtag
argument_list|(
literal|"putx"
argument_list|,
name|p
operator|->
name|tag
argument_list|)
expr_stmt|;
name|p
operator|=
name|errnode
argument_list|()
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
end_function

begin_function
name|LOCAL
name|expptr
ifdef|#
directive|ifdef
name|KR_headers
name|putop
parameter_list|(
name|p
parameter_list|)
name|expptr
name|p
decl_stmt|;
else|#
directive|else
function|putop
parameter_list|(
name|expptr
name|p
parameter_list|)
endif|#
directive|endif
block|{
name|expptr
name|lp
decl_stmt|,
name|tp
decl_stmt|;
name|int
name|pt
decl_stmt|,
name|lt
decl_stmt|,
name|lt1
decl_stmt|;
name|int
name|comma
decl_stmt|;
name|char
modifier|*
name|hsave
decl_stmt|;
switch|switch
condition|(
name|p
operator|->
name|exprblock
operator|.
name|opcode
condition|)
comment|/* check for special cases and rewrite */
block|{
case|case
name|OPCONV
case|:
name|pt
operator|=
name|p
operator|->
name|exprblock
operator|.
name|vtype
expr_stmt|;
name|lp
operator|=
name|p
operator|->
name|exprblock
operator|.
name|leftp
expr_stmt|;
name|lt
operator|=
name|lp
operator|->
name|headblock
operator|.
name|vtype
expr_stmt|;
comment|/* Simplify nested type casts */
while|while
condition|(
name|p
operator|->
name|tag
operator|==
name|TEXPR
operator|&&
name|p
operator|->
name|exprblock
operator|.
name|opcode
operator|==
name|OPCONV
operator|&&
operator|(
operator|(
name|ISREAL
argument_list|(
name|pt
argument_list|)
operator|&&
name|ONEOF
argument_list|(
name|lt
argument_list|,
name|MSKREAL
operator||
name|MSKCOMPLEX
argument_list|)
operator|)
operator|||
operator|(
name|INT
argument_list|(
name|pt
argument_list|)
operator|&&
operator|(
name|ONEOF
argument_list|(
name|lt
argument_list|,
name|MSKINT
operator||
name|MSKADDR
operator||
name|MSKCHAR
operator||
name|M
argument_list|(
name|TYSUBR
argument_list|)
argument_list|)
operator|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|pt
operator|==
name|TYDREAL
operator|&&
name|lt
operator|==
name|TYREAL
condition|)
block|{
if|if
condition|(
name|lp
operator|->
name|tag
operator|==
name|TEXPR
operator|&&
name|lp
operator|->
name|exprblock
operator|.
name|opcode
operator|==
name|OPCONV
condition|)
block|{
name|lt1
operator|=
name|lp
operator|->
name|exprblock
operator|.
name|leftp
operator|->
name|headblock
operator|.
name|vtype
expr_stmt|;
if|if
condition|(
name|lt1
operator|==
name|TYDREAL
condition|)
block|{
name|lp
operator|->
name|exprblock
operator|.
name|leftp
operator|=
name|putx
argument_list|(
name|lp
operator|->
name|exprblock
operator|.
name|leftp
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
if|if
condition|(
name|lt1
operator|==
name|TYDCOMPLEX
condition|)
block|{
name|lp
operator|->
name|exprblock
operator|.
name|leftp
operator|=
name|putx
argument_list|(
operator|(
name|expptr
operator|)
name|realpart
argument_list|(
name|putcx1
argument_list|(
name|lp
operator|->
name|exprblock
operator|.
name|leftp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
block|}
break|break;
block|}
elseif|else
if|if
condition|(
name|ISREAL
argument_list|(
name|pt
argument_list|)
operator|&&
name|ISCOMPLEX
argument_list|(
name|lt
argument_list|)
condition|)
block|{
name|p
operator|->
name|exprblock
operator|.
name|leftp
operator|=
name|putx
argument_list|(
name|mkconv
argument_list|(
name|pt
argument_list|,
operator|(
name|expptr
operator|)
name|realpart
argument_list|(
name|putcx1
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|leftp
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|lt
operator|==
name|TYCHAR
operator|&&
name|lp
operator|->
name|tag
operator|==
name|TEXPR
operator|&&
name|lp
operator|->
name|exprblock
operator|.
name|opcode
operator|==
name|OPCALL
condition|)
block|{
comment|/* May want to make a comma expression here instead.  I had one, but took    it out for my convenience, not for the convenience of the end user */
name|putout
argument_list|(
name|putcall
argument_list|(
name|lp
argument_list|,
operator|(
name|Addrp
operator|*
operator|)
operator|&
operator|(
name|p
operator|->
name|exprblock
operator|.
name|leftp
operator|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|putop
argument_list|(
name|p
argument_list|)
return|;
block|}
if|if
condition|(
name|lt
operator|==
name|TYCHAR
condition|)
block|{
if|if
condition|(
name|ISCONST
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|leftp
argument_list|)
operator|&&
name|ISNUMERIC
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|vtype
argument_list|)
condition|)
block|{
name|hsave
operator|=
name|halign
expr_stmt|;
name|halign
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|exprblock
operator|.
name|leftp
operator|=
name|putx
argument_list|(
operator|(
name|expptr
operator|)
name|putconst
argument_list|(
operator|(
name|Constp
operator|)
name|p
operator|->
name|exprblock
operator|.
name|leftp
argument_list|)
argument_list|)
expr_stmt|;
name|halign
operator|=
name|hsave
expr_stmt|;
block|}
else|else
name|p
operator|->
name|exprblock
operator|.
name|leftp
operator|=
name|putx
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|leftp
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
if|if
condition|(
name|pt
operator|<
name|lt
operator|&&
name|ONEOF
argument_list|(
name|lt
argument_list|,
name|MSKINT
operator||
name|MSKREAL
argument_list|)
condition|)
break|break;
name|frexpr
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|vleng
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|charptr
operator|)
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|lp
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|tag
operator|!=
name|TEXPR
condition|)
goto|goto
name|retputx
goto|;
name|pt
operator|=
name|lt
expr_stmt|;
name|lp
operator|=
name|p
operator|->
name|exprblock
operator|.
name|leftp
expr_stmt|;
name|lt
operator|=
name|lp
operator|->
name|headblock
operator|.
name|vtype
expr_stmt|;
block|}
comment|/* while */
if|if
condition|(
name|p
operator|->
name|tag
operator|==
name|TEXPR
operator|&&
name|p
operator|->
name|exprblock
operator|.
name|opcode
operator|==
name|OPCONV
condition|)
break|break;
name|retputx
label|:
return|return
name|putx
argument_list|(
name|p
argument_list|)
return|;
case|case
name|OPADDR
case|:
name|comma
operator|=
name|NO
expr_stmt|;
name|lp
operator|=
name|p
operator|->
name|exprblock
operator|.
name|leftp
expr_stmt|;
name|free
argument_list|(
operator|(
name|charptr
operator|)
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|lp
operator|->
name|tag
operator|!=
name|TADDR
condition|)
block|{
name|tp
operator|=
operator|(
name|expptr
operator|)
name|mktmp
argument_list|(
name|lp
operator|->
name|headblock
operator|.
name|vtype
argument_list|,
name|lp
operator|->
name|headblock
operator|.
name|vleng
argument_list|)
expr_stmt|;
name|p
operator|=
name|putx
argument_list|(
name|mkexpr
argument_list|(
name|OPASSIGN
argument_list|,
name|cpexpr
argument_list|(
name|tp
argument_list|)
argument_list|,
name|lp
argument_list|)
argument_list|)
expr_stmt|;
name|lp
operator|=
name|tp
expr_stmt|;
name|comma
operator|=
name|YES
expr_stmt|;
block|}
if|if
condition|(
name|comma
condition|)
name|p
operator|=
name|mkexpr
argument_list|(
name|OPCOMMA
argument_list|,
name|p
argument_list|,
name|putaddr
argument_list|(
name|lp
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|p
operator|=
operator|(
name|expptr
operator|)
name|putaddr
argument_list|(
name|lp
argument_list|)
expr_stmt|;
return|return
name|p
return|;
case|case
name|OPASSIGN
case|:
case|case
name|OPASSIGNI
case|:
case|case
name|OPLT
case|:
case|case
name|OPLE
case|:
case|case
name|OPGT
case|:
case|case
name|OPGE
case|:
case|case
name|OPEQ
case|:
case|case
name|OPNE
case|:
empty_stmt|;
block|}
if|if
condition|(
name|ops2
index|[
name|p
operator|->
name|exprblock
operator|.
name|opcode
index|]
operator|<=
literal|0
condition|)
name|badop
argument_list|(
literal|"putop"
argument_list|,
name|p
operator|->
name|exprblock
operator|.
name|opcode
argument_list|)
expr_stmt|;
name|lp
operator|=
name|p
operator|->
name|exprblock
operator|.
name|leftp
operator|=
name|putx
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|leftp
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|exprblock
operator|.
name|rightp
condition|)
block|{
name|tp
operator|=
name|p
operator|->
name|exprblock
operator|.
name|rightp
operator|=
name|putx
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|rightp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISCONST
argument_list|(
name|tp
argument_list|)
operator|&&
name|ISCONST
argument_list|(
name|lp
argument_list|)
condition|)
name|p
operator|=
name|fold
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
end_function

begin_function
name|LOCAL
name|expptr
ifdef|#
directive|ifdef
name|KR_headers
name|putpower
parameter_list|(
name|p
parameter_list|)
name|expptr
name|p
decl_stmt|;
else|#
directive|else
function|putpower
parameter_list|(
name|expptr
name|p
parameter_list|)
endif|#
directive|endif
block|{
name|expptr
name|base
decl_stmt|;
name|Addrp
name|t1
decl_stmt|,
name|t2
decl_stmt|;
name|ftnint
name|k
decl_stmt|;
name|int
name|type
decl_stmt|;
name|char
name|buf
index|[
literal|80
index|]
decl_stmt|;
comment|/* buffer for text of comment */
if|if
condition|(
operator|!
name|ISICON
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|rightp
argument_list|)
operator|||
operator|(
name|k
operator|=
name|p
operator|->
name|exprblock
operator|.
name|rightp
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
operator|)
operator|<
literal|2
condition|)
name|Fatal
argument_list|(
literal|"putpower: bad call"
argument_list|)
expr_stmt|;
name|base
operator|=
name|p
operator|->
name|exprblock
operator|.
name|leftp
expr_stmt|;
name|type
operator|=
name|base
operator|->
name|headblock
operator|.
name|vtype
expr_stmt|;
name|t1
operator|=
name|mktmp
argument_list|(
name|type
argument_list|,
name|ENULL
argument_list|)
expr_stmt|;
name|t2
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
operator|(
name|charptr
operator|)
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|putassign
argument_list|(
name|cpexpr
argument_list|(
operator|(
name|expptr
operator|)
name|t1
argument_list|)
argument_list|,
name|base
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"Computing %ld%s power"
argument_list|,
name|k
argument_list|,
name|k
operator|==
literal|2
condition|?
literal|"nd"
else|:
name|k
operator|==
literal|3
condition|?
literal|"rd"
else|:
literal|"th"
argument_list|)
expr_stmt|;
name|p1_comment
argument_list|(
name|buf
argument_list|)
expr_stmt|;
for|for
control|(
init|;
operator|(
name|k
operator|&
literal|1
operator|)
operator|==
literal|0
operator|&&
name|k
operator|>
literal|2
condition|;
name|k
operator|>>=
literal|1
control|)
block|{
name|p
operator|=
name|mkexpr
argument_list|(
name|OPCOMMA
argument_list|,
name|p
argument_list|,
name|putsteq
argument_list|(
name|t1
argument_list|,
name|t1
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|k
operator|==
literal|2
condition|)
block|{
comment|/* Write the power computation out immediately */
name|putout
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|putx
argument_list|(
name|mkexpr
argument_list|(
name|OPSTAR
argument_list|,
name|cpexpr
argument_list|(
operator|(
name|expptr
operator|)
name|t1
argument_list|)
argument_list|,
name|cpexpr
argument_list|(
operator|(
name|expptr
operator|)
name|t1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|t2
operator|=
name|mktmp
argument_list|(
name|type
argument_list|,
name|ENULL
argument_list|)
expr_stmt|;
name|p
operator|=
name|mkexpr
argument_list|(
name|OPCOMMA
argument_list|,
name|p
argument_list|,
name|putassign
argument_list|(
name|cpexpr
argument_list|(
operator|(
name|expptr
operator|)
name|t2
argument_list|)
argument_list|,
name|cpexpr
argument_list|(
operator|(
name|expptr
operator|)
name|t1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|>>=
literal|1
init|;
name|k
operator|>
literal|1
condition|;
name|k
operator|>>=
literal|1
control|)
block|{
name|p
operator|=
name|mkexpr
argument_list|(
name|OPCOMMA
argument_list|,
name|p
argument_list|,
name|putsteq
argument_list|(
name|t1
argument_list|,
name|t1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|&
literal|1
condition|)
block|{
name|p
operator|=
name|mkexpr
argument_list|(
name|OPCOMMA
argument_list|,
name|p
argument_list|,
name|putsteq
argument_list|(
name|t2
argument_list|,
name|t1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Write the power computation out immediately */
name|putout
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|putx
argument_list|(
name|mkexpr
argument_list|(
name|OPSTAR
argument_list|,
name|cpexpr
argument_list|(
operator|(
name|expptr
operator|)
name|t2
argument_list|)
argument_list|,
name|mkexpr
argument_list|(
name|OPSTAR
argument_list|,
name|cpexpr
argument_list|(
operator|(
name|expptr
operator|)
name|t1
argument_list|)
argument_list|,
name|cpexpr
argument_list|(
operator|(
name|expptr
operator|)
name|t1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|frexpr
argument_list|(
operator|(
name|expptr
operator|)
name|t1
argument_list|)
expr_stmt|;
if|if
condition|(
name|t2
condition|)
name|frexpr
argument_list|(
operator|(
name|expptr
operator|)
name|t2
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_function
name|LOCAL
name|Addrp
ifdef|#
directive|ifdef
name|KR_headers
name|intdouble
parameter_list|(
name|p
parameter_list|)
name|Addrp
name|p
decl_stmt|;
else|#
directive|else
function|intdouble
parameter_list|(
name|Addrp
name|p
parameter_list|)
endif|#
directive|endif
block|{
specifier|register
name|Addrp
name|t
decl_stmt|;
name|t
operator|=
name|mktmp
argument_list|(
name|TYDREAL
argument_list|,
name|ENULL
argument_list|)
expr_stmt|;
name|putout
argument_list|(
name|putassign
argument_list|(
name|cpexpr
argument_list|(
operator|(
name|expptr
operator|)
name|t
argument_list|)
argument_list|,
operator|(
name|expptr
operator|)
name|p
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|t
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Complex-type variable assignment */
end_comment

begin_function
name|LOCAL
name|Addrp
ifdef|#
directive|ifdef
name|KR_headers
name|putcxeq
parameter_list|(
name|p
parameter_list|)
specifier|register
name|expptr
name|p
decl_stmt|;
else|#
directive|else
function|putcxeq
parameter_list|(
specifier|register
name|expptr
name|p
parameter_list|)
endif|#
directive|endif
block|{
specifier|register
name|Addrp
name|lp
decl_stmt|,
name|rp
decl_stmt|;
name|expptr
name|code
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|tag
operator|!=
name|TEXPR
condition|)
name|badtag
argument_list|(
literal|"putcxeq"
argument_list|,
name|p
operator|->
name|tag
argument_list|)
expr_stmt|;
name|lp
operator|=
name|putcx1
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|leftp
argument_list|)
expr_stmt|;
name|rp
operator|=
name|putcx1
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|rightp
argument_list|)
expr_stmt|;
name|code
operator|=
name|putassign
argument_list|(
operator|(
name|expptr
operator|)
name|realpart
argument_list|(
name|lp
argument_list|)
argument_list|,
operator|(
name|expptr
operator|)
name|realpart
argument_list|(
name|rp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISCOMPLEX
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|vtype
argument_list|)
condition|)
block|{
name|code
operator|=
name|mkexpr
argument_list|(
name|OPCOMMA
argument_list|,
name|code
argument_list|,
name|putassign
argument_list|(
name|imagpart
argument_list|(
name|lp
argument_list|)
argument_list|,
name|imagpart
argument_list|(
name|rp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|putout
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|frexpr
argument_list|(
operator|(
name|expptr
operator|)
name|rp
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|charptr
operator|)
name|p
argument_list|)
expr_stmt|;
return|return
name|lp
return|;
block|}
end_function

begin_comment
comment|/* putcxop -- used to write out embedded calls to complex functions, and    complex arguments to procedures */
end_comment

begin_function
name|expptr
ifdef|#
directive|ifdef
name|KR_headers
name|putcxop
parameter_list|(
name|p
parameter_list|)
name|expptr
name|p
decl_stmt|;
else|#
directive|else
function|putcxop
parameter_list|(
name|expptr
name|p
parameter_list|)
endif|#
directive|endif
block|{
return|return
operator|(
name|expptr
operator|)
name|putaddr
argument_list|(
operator|(
name|expptr
operator|)
name|putcx1
argument_list|(
name|p
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|PAIR
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|mkexpr (OPCOMMA, (x), (y))
end_define

begin_function
name|LOCAL
name|Addrp
ifdef|#
directive|ifdef
name|KR_headers
name|putcx1
parameter_list|(
name|p
parameter_list|)
specifier|register
name|expptr
name|p
decl_stmt|;
else|#
directive|else
function|putcx1
parameter_list|(
specifier|register
name|expptr
name|p
parameter_list|)
endif|#
directive|endif
block|{
name|expptr
name|q
decl_stmt|;
name|Addrp
name|lp
decl_stmt|,
name|rp
decl_stmt|;
specifier|register
name|Addrp
name|resp
decl_stmt|;
name|int
name|opcode
decl_stmt|;
name|int
name|ltype
decl_stmt|,
name|rtype
decl_stmt|;
name|long
name|ts
decl_stmt|,
name|tskludge
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
switch|switch
condition|(
name|p
operator|->
name|tag
condition|)
block|{
case|case
name|TCONST
case|:
if|if
condition|(
name|ISCOMPLEX
argument_list|(
name|p
operator|->
name|constblock
operator|.
name|vtype
argument_list|)
condition|)
name|p
operator|=
operator|(
name|expptr
operator|)
name|putconst
argument_list|(
operator|(
name|Constp
operator|)
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|Addrp
operator|)
name|p
operator|)
return|;
case|case
name|TADDR
case|:
name|resp
operator|=
operator|&
name|p
operator|->
name|addrblock
expr_stmt|;
if|if
condition|(
name|addressable
argument_list|(
name|p
argument_list|)
condition|)
return|return
operator|(
name|Addrp
operator|)
name|p
return|;
name|ts
operator|=
name|tskludge
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|q
operator|=
name|resp
operator|->
name|memoffset
condition|)
block|{
if|if
condition|(
name|resp
operator|->
name|uname_tag
operator|==
name|UNAM_REF
condition|)
block|{
name|q
operator|=
name|cpexpr
argument_list|(
operator|(
name|tagptr
operator|)
name|resp
argument_list|)
expr_stmt|;
name|q
operator|->
name|addrblock
operator|.
name|vtype
operator|=
name|tyint
expr_stmt|;
name|q
operator|->
name|addrblock
operator|.
name|cmplx_sub
operator|=
literal|1
expr_stmt|;
name|p
operator|->
name|addrblock
operator|.
name|skip_offset
operator|=
literal|1
expr_stmt|;
name|resp
operator|->
name|user
operator|.
name|name
operator|->
name|vsubscrused
operator|=
literal|1
expr_stmt|;
name|resp
operator|->
name|uname_tag
operator|=
name|UNAM_NAME
expr_stmt|;
name|tskludge
operator|=
name|typesize
index|[
name|resp
operator|->
name|vtype
index|]
operator|*
operator|(
name|resp
operator|->
name|Field
condition|?
literal|2
else|:
literal|1
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|resp
operator|->
name|isarray
operator|&&
name|resp
operator|->
name|vtype
operator|!=
name|TYCHAR
condition|)
block|{
if|if
condition|(
name|ONEOF
argument_list|(
name|resp
operator|->
name|vstg
argument_list|,
name|M
argument_list|(
name|STGCOMMON
argument_list|)
operator||
name|M
argument_list|(
name|STGEQUIV
argument_list|)
argument_list|)
operator|&&
name|resp
operator|->
name|uname_tag
operator|==
name|UNAM_NAME
condition|)
name|q
operator|=
name|mkexpr
argument_list|(
name|OPMINUS
argument_list|,
name|q
argument_list|,
name|mkintcon
argument_list|(
name|resp
operator|->
name|user
operator|.
name|name
operator|->
name|voffset
argument_list|)
argument_list|)
expr_stmt|;
name|ts
operator|=
name|typesize
index|[
name|resp
operator|->
name|vtype
index|]
operator|*
operator|(
name|resp
operator|->
name|Field
condition|?
literal|2
else|:
literal|1
operator|)
expr_stmt|;
name|q
operator|=
name|resp
operator|->
name|memoffset
operator|=
name|mkexpr
argument_list|(
name|OPSLASH
argument_list|,
name|q
argument_list|,
name|ICON
argument_list|(
name|ts
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|resp
operator|=
name|mktmp
argument_list|(
name|tyint
argument_list|,
name|ENULL
argument_list|)
expr_stmt|;
name|putout
argument_list|(
name|putassign
argument_list|(
name|cpexpr
argument_list|(
operator|(
name|expptr
operator|)
name|resp
argument_list|)
argument_list|,
name|q
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|addrblock
operator|.
name|memoffset
operator|=
name|tskludge
condition|?
name|mkexpr
argument_list|(
name|OPSTAR
argument_list|,
operator|(
name|expptr
operator|)
name|resp
argument_list|,
name|ICON
argument_list|(
name|tskludge
argument_list|)
argument_list|)
else|:
operator|(
name|expptr
operator|)
name|resp
expr_stmt|;
if|if
condition|(
name|ts
condition|)
block|{
name|resp
operator|=
operator|&
name|p
operator|->
name|addrblock
expr_stmt|;
name|q
operator|=
name|mkexpr
argument_list|(
name|OPSTAR
argument_list|,
name|resp
operator|->
name|memoffset
argument_list|,
name|ICON
argument_list|(
name|ts
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ONEOF
argument_list|(
name|resp
operator|->
name|vstg
argument_list|,
name|M
argument_list|(
name|STGCOMMON
argument_list|)
operator||
name|M
argument_list|(
name|STGEQUIV
argument_list|)
argument_list|)
operator|&&
name|resp
operator|->
name|uname_tag
operator|==
name|UNAM_NAME
condition|)
name|q
operator|=
name|mkexpr
argument_list|(
name|OPPLUS
argument_list|,
name|q
argument_list|,
name|mkintcon
argument_list|(
name|resp
operator|->
name|user
operator|.
name|name
operator|->
name|voffset
argument_list|)
argument_list|)
expr_stmt|;
name|resp
operator|->
name|memoffset
operator|=
name|q
expr_stmt|;
block|}
return|return
operator|(
name|Addrp
operator|)
name|p
return|;
case|case
name|TEXPR
case|:
if|if
condition|(
name|ISCOMPLEX
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|vtype
argument_list|)
condition|)
break|break;
name|resp
operator|=
name|mktmp
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|vtype
argument_list|,
name|ENULL
argument_list|)
expr_stmt|;
comment|/*first arg of above mktmp call was TYDREAL before 19950102 */
name|putout
argument_list|(
name|putassign
argument_list|(
name|cpexpr
argument_list|(
operator|(
name|expptr
operator|)
name|resp
argument_list|)
argument_list|,
name|p
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|resp
operator|)
return|;
case|case
name|TERROR
case|:
return|return
name|NULL
return|;
default|default:
name|badtag
argument_list|(
literal|"putcx1"
argument_list|,
name|p
operator|->
name|tag
argument_list|)
expr_stmt|;
block|}
name|opcode
operator|=
name|p
operator|->
name|exprblock
operator|.
name|opcode
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
name|OPCALL
operator|||
name|opcode
operator|==
name|OPCCALL
condition|)
block|{
name|Addrp
name|t
decl_stmt|;
name|p
operator|=
name|putcall
argument_list|(
name|p
argument_list|,
operator|&
name|t
argument_list|)
expr_stmt|;
name|putout
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
elseif|else
if|if
condition|(
name|opcode
operator|==
name|OPASSIGN
condition|)
block|{
return|return
name|putcxeq
argument_list|(
name|p
argument_list|)
return|;
block|}
comment|/* BUG  (inefficient)  Generates too many temporary variables */
name|resp
operator|=
name|mktmp
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|vtype
argument_list|,
name|ENULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|lp
operator|=
name|putcx1
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|leftp
argument_list|)
condition|)
name|ltype
operator|=
name|lp
operator|->
name|vtype
expr_stmt|;
if|if
condition|(
name|rp
operator|=
name|putcx1
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|rightp
argument_list|)
condition|)
name|rtype
operator|=
name|rp
operator|->
name|vtype
expr_stmt|;
switch|switch
condition|(
name|opcode
condition|)
block|{
case|case
name|OPCOMMA
case|:
name|frexpr
argument_list|(
operator|(
name|expptr
operator|)
name|resp
argument_list|)
expr_stmt|;
name|resp
operator|=
name|rp
expr_stmt|;
name|rp
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|OPNEG
case|:
case|case
name|OPNEG1
case|:
name|putout
argument_list|(
name|PAIR
argument_list|(
name|putassign
argument_list|(
operator|(
name|expptr
operator|)
name|realpart
argument_list|(
name|resp
argument_list|)
argument_list|,
name|mkexpr
argument_list|(
name|OPNEG
argument_list|,
operator|(
name|expptr
operator|)
name|realpart
argument_list|(
name|lp
argument_list|)
argument_list|,
name|ENULL
argument_list|)
argument_list|)
argument_list|,
name|putassign
argument_list|(
name|imagpart
argument_list|(
name|resp
argument_list|)
argument_list|,
name|mkexpr
argument_list|(
name|OPNEG
argument_list|,
name|imagpart
argument_list|(
name|lp
argument_list|)
argument_list|,
name|ENULL
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPPLUS
case|:
case|case
name|OPMINUS
case|:
block|{
name|expptr
name|r
decl_stmt|;
name|r
operator|=
name|putassign
argument_list|(
operator|(
name|expptr
operator|)
name|realpart
argument_list|(
name|resp
argument_list|)
argument_list|,
name|mkexpr
argument_list|(
name|opcode
argument_list|,
operator|(
name|expptr
operator|)
name|realpart
argument_list|(
name|lp
argument_list|)
argument_list|,
operator|(
name|expptr
operator|)
name|realpart
argument_list|(
name|rp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtype
operator|<
name|TYCOMPLEX
condition|)
name|q
operator|=
name|putassign
argument_list|(
name|imagpart
argument_list|(
name|resp
argument_list|)
argument_list|,
name|imagpart
argument_list|(
name|lp
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ltype
operator|<
name|TYCOMPLEX
condition|)
block|{
if|if
condition|(
name|opcode
operator|==
name|OPPLUS
condition|)
name|q
operator|=
name|putassign
argument_list|(
name|imagpart
argument_list|(
name|resp
argument_list|)
argument_list|,
name|imagpart
argument_list|(
name|rp
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|q
operator|=
name|putassign
argument_list|(
name|imagpart
argument_list|(
name|resp
argument_list|)
argument_list|,
name|mkexpr
argument_list|(
name|OPNEG
argument_list|,
name|imagpart
argument_list|(
name|rp
argument_list|)
argument_list|,
name|ENULL
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|q
operator|=
name|putassign
argument_list|(
name|imagpart
argument_list|(
name|resp
argument_list|)
argument_list|,
name|mkexpr
argument_list|(
name|opcode
argument_list|,
name|imagpart
argument_list|(
name|lp
argument_list|)
argument_list|,
name|imagpart
argument_list|(
name|rp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|r
operator|=
name|PAIR
argument_list|(
name|r
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|putout
argument_list|(
name|r
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* case OPPLUS, OPMINUS: */
case|case
name|OPSTAR
case|:
if|if
condition|(
name|ltype
operator|<
name|TYCOMPLEX
condition|)
block|{
if|if
condition|(
name|ISINT
argument_list|(
name|ltype
argument_list|)
condition|)
name|lp
operator|=
name|intdouble
argument_list|(
name|lp
argument_list|)
expr_stmt|;
name|putout
argument_list|(
name|PAIR
argument_list|(
name|putassign
argument_list|(
operator|(
name|expptr
operator|)
name|realpart
argument_list|(
name|resp
argument_list|)
argument_list|,
name|mkexpr
argument_list|(
name|OPSTAR
argument_list|,
name|cpexpr
argument_list|(
operator|(
name|expptr
operator|)
name|lp
argument_list|)
argument_list|,
operator|(
name|expptr
operator|)
name|realpart
argument_list|(
name|rp
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|putassign
argument_list|(
name|imagpart
argument_list|(
name|resp
argument_list|)
argument_list|,
name|mkexpr
argument_list|(
name|OPSTAR
argument_list|,
name|cpexpr
argument_list|(
operator|(
name|expptr
operator|)
name|lp
argument_list|)
argument_list|,
name|imagpart
argument_list|(
name|rp
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rtype
operator|<
name|TYCOMPLEX
condition|)
block|{
if|if
condition|(
name|ISINT
argument_list|(
name|rtype
argument_list|)
condition|)
name|rp
operator|=
name|intdouble
argument_list|(
name|rp
argument_list|)
expr_stmt|;
name|putout
argument_list|(
name|PAIR
argument_list|(
name|putassign
argument_list|(
operator|(
name|expptr
operator|)
name|realpart
argument_list|(
name|resp
argument_list|)
argument_list|,
name|mkexpr
argument_list|(
name|OPSTAR
argument_list|,
name|cpexpr
argument_list|(
operator|(
name|expptr
operator|)
name|rp
argument_list|)
argument_list|,
operator|(
name|expptr
operator|)
name|realpart
argument_list|(
name|lp
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|putassign
argument_list|(
name|imagpart
argument_list|(
name|resp
argument_list|)
argument_list|,
name|mkexpr
argument_list|(
name|OPSTAR
argument_list|,
name|cpexpr
argument_list|(
operator|(
name|expptr
operator|)
name|rp
argument_list|)
argument_list|,
name|imagpart
argument_list|(
name|lp
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|putout
argument_list|(
name|PAIR
argument_list|(
name|putassign
argument_list|(
operator|(
name|expptr
operator|)
name|realpart
argument_list|(
name|resp
argument_list|)
argument_list|,
name|mkexpr
argument_list|(
name|OPMINUS
argument_list|,
name|mkexpr
argument_list|(
name|OPSTAR
argument_list|,
operator|(
name|expptr
operator|)
name|realpart
argument_list|(
name|lp
argument_list|)
argument_list|,
operator|(
name|expptr
operator|)
name|realpart
argument_list|(
name|rp
argument_list|)
argument_list|)
argument_list|,
name|mkexpr
argument_list|(
name|OPSTAR
argument_list|,
name|imagpart
argument_list|(
name|lp
argument_list|)
argument_list|,
name|imagpart
argument_list|(
name|rp
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|putassign
argument_list|(
name|imagpart
argument_list|(
name|resp
argument_list|)
argument_list|,
name|mkexpr
argument_list|(
name|OPPLUS
argument_list|,
name|mkexpr
argument_list|(
name|OPSTAR
argument_list|,
operator|(
name|expptr
operator|)
name|realpart
argument_list|(
name|lp
argument_list|)
argument_list|,
name|imagpart
argument_list|(
name|rp
argument_list|)
argument_list|)
argument_list|,
name|mkexpr
argument_list|(
name|OPSTAR
argument_list|,
name|imagpart
argument_list|(
name|lp
argument_list|)
argument_list|,
operator|(
name|expptr
operator|)
name|realpart
argument_list|(
name|rp
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|OPSLASH
case|:
comment|/* fixexpr has already replaced all divisions 		 * by a complex by a function call 		 */
if|if
condition|(
name|ISINT
argument_list|(
name|rtype
argument_list|)
condition|)
name|rp
operator|=
name|intdouble
argument_list|(
name|rp
argument_list|)
expr_stmt|;
name|putout
argument_list|(
name|PAIR
argument_list|(
name|putassign
argument_list|(
operator|(
name|expptr
operator|)
name|realpart
argument_list|(
name|resp
argument_list|)
argument_list|,
name|mkexpr
argument_list|(
name|OPSLASH
argument_list|,
operator|(
name|expptr
operator|)
name|realpart
argument_list|(
name|lp
argument_list|)
argument_list|,
name|cpexpr
argument_list|(
operator|(
name|expptr
operator|)
name|rp
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|putassign
argument_list|(
name|imagpart
argument_list|(
name|resp
argument_list|)
argument_list|,
name|mkexpr
argument_list|(
name|OPSLASH
argument_list|,
name|imagpart
argument_list|(
name|lp
argument_list|)
argument_list|,
name|cpexpr
argument_list|(
operator|(
name|expptr
operator|)
name|rp
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPCONV
case|:
if|if
condition|(
operator|!
name|lp
condition|)
break|break;
if|if
condition|(
name|ISCOMPLEX
argument_list|(
name|lp
operator|->
name|vtype
argument_list|)
condition|)
name|q
operator|=
name|imagpart
argument_list|(
name|lp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rp
operator|!=
name|NULL
condition|)
name|q
operator|=
operator|(
name|expptr
operator|)
name|realpart
argument_list|(
name|rp
argument_list|)
expr_stmt|;
else|else
name|q
operator|=
name|mkrealcon
argument_list|(
name|TYDREAL
argument_list|,
literal|"0"
argument_list|)
expr_stmt|;
name|putout
argument_list|(
name|PAIR
argument_list|(
name|putassign
argument_list|(
operator|(
name|expptr
operator|)
name|realpart
argument_list|(
name|resp
argument_list|)
argument_list|,
operator|(
name|expptr
operator|)
name|realpart
argument_list|(
name|lp
argument_list|)
argument_list|)
argument_list|,
name|putassign
argument_list|(
name|imagpart
argument_list|(
name|resp
argument_list|)
argument_list|,
name|q
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|badop
argument_list|(
literal|"putcx1"
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
block|}
name|frexpr
argument_list|(
operator|(
name|expptr
operator|)
name|lp
argument_list|)
expr_stmt|;
name|frexpr
argument_list|(
operator|(
name|expptr
operator|)
name|rp
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|charptr
operator|)
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|resp
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Only .EQ. and .NE. may be performed on COMPLEX data, other relations    are not defined */
end_comment

begin_function
name|LOCAL
name|expptr
ifdef|#
directive|ifdef
name|KR_headers
name|putcxcmp
parameter_list|(
name|p
parameter_list|)
specifier|register
name|expptr
name|p
decl_stmt|;
else|#
directive|else
function|putcxcmp
parameter_list|(
specifier|register
name|expptr
name|p
parameter_list|)
endif|#
directive|endif
block|{
name|int
name|opcode
decl_stmt|;
specifier|register
name|Addrp
name|lp
decl_stmt|,
name|rp
decl_stmt|;
name|expptr
name|q
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|tag
operator|!=
name|TEXPR
condition|)
name|badtag
argument_list|(
literal|"putcxcmp"
argument_list|,
name|p
operator|->
name|tag
argument_list|)
expr_stmt|;
name|opcode
operator|=
name|p
operator|->
name|exprblock
operator|.
name|opcode
expr_stmt|;
name|lp
operator|=
name|putcx1
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|leftp
argument_list|)
expr_stmt|;
name|rp
operator|=
name|putcx1
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|rightp
argument_list|)
expr_stmt|;
name|q
operator|=
name|mkexpr
argument_list|(
name|opcode
operator|==
name|OPEQ
condition|?
name|OPAND
else|:
name|OPOR
argument_list|,
name|mkexpr
argument_list|(
name|opcode
argument_list|,
operator|(
name|expptr
operator|)
name|realpart
argument_list|(
name|lp
argument_list|)
argument_list|,
operator|(
name|expptr
operator|)
name|realpart
argument_list|(
name|rp
argument_list|)
argument_list|)
argument_list|,
name|mkexpr
argument_list|(
name|opcode
argument_list|,
name|imagpart
argument_list|(
name|lp
argument_list|)
argument_list|,
name|imagpart
argument_list|(
name|rp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|charptr
operator|)
name|lp
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|charptr
operator|)
name|rp
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|charptr
operator|)
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISCONST
argument_list|(
name|q
argument_list|)
condition|)
return|return
name|q
return|;
return|return
name|putx
argument_list|(
name|fixexpr
argument_list|(
operator|(
name|Exprp
operator|)
name|q
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* putch1 -- Forces constants into the literal pool, among other things */
end_comment

begin_function
name|LOCAL
name|Addrp
ifdef|#
directive|ifdef
name|KR_headers
name|putch1
parameter_list|(
name|p
parameter_list|)
specifier|register
name|expptr
name|p
decl_stmt|;
else|#
directive|else
function|putch1
parameter_list|(
specifier|register
name|expptr
name|p
parameter_list|)
endif|#
directive|endif
block|{
name|Addrp
name|t
decl_stmt|;
name|expptr
name|e
decl_stmt|;
switch|switch
condition|(
name|p
operator|->
name|tag
condition|)
block|{
case|case
name|TCONST
case|:
return|return
operator|(
name|putconst
argument_list|(
operator|(
name|Constp
operator|)
name|p
argument_list|)
operator|)
return|;
case|case
name|TADDR
case|:
return|return
operator|(
operator|(
name|Addrp
operator|)
name|p
operator|)
return|;
case|case
name|TEXPR
case|:
switch|switch
condition|(
name|p
operator|->
name|exprblock
operator|.
name|opcode
condition|)
block|{
name|expptr
name|q
decl_stmt|;
case|case
name|OPCALL
case|:
case|case
name|OPCCALL
case|:
name|p
operator|=
name|putcall
argument_list|(
name|p
argument_list|,
operator|&
name|t
argument_list|)
expr_stmt|;
name|putout
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPCONCAT
case|:
name|t
operator|=
name|mktmp
argument_list|(
name|TYCHAR
argument_list|,
name|ICON
argument_list|(
name|lencat
argument_list|(
name|p
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|q
operator|=
operator|(
name|expptr
operator|)
name|cpexpr
argument_list|(
name|p
operator|->
name|headblock
operator|.
name|vleng
argument_list|)
expr_stmt|;
name|p
operator|=
name|putcat
argument_list|(
name|cpexpr
argument_list|(
operator|(
name|expptr
operator|)
name|t
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* put the correct length on the block */
name|frexpr
argument_list|(
name|t
operator|->
name|vleng
argument_list|)
expr_stmt|;
name|t
operator|->
name|vleng
operator|=
name|q
expr_stmt|;
name|putout
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPCONV
case|:
if|if
condition|(
operator|!
name|ISICON
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|vleng
argument_list|)
operator|||
name|p
operator|->
name|exprblock
operator|.
name|vleng
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
operator|!=
literal|1
operator|||
operator|!
name|INT
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|leftp
operator|->
name|headblock
operator|.
name|vtype
argument_list|)
condition|)
name|Fatal
argument_list|(
literal|"putch1: bad character conversion"
argument_list|)
expr_stmt|;
name|t
operator|=
name|mktmp
argument_list|(
name|TYCHAR
argument_list|,
name|ICON
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|e
operator|=
name|mkexpr
argument_list|(
name|OPCONV
argument_list|,
operator|(
name|expptr
operator|)
name|t
argument_list|,
name|ENULL
argument_list|)
expr_stmt|;
name|e
operator|->
name|headblock
operator|.
name|vtype
operator|=
name|TYCHAR
expr_stmt|;
name|p
operator|=
name|putop
argument_list|(
name|mkexpr
argument_list|(
name|OPASSIGN
argument_list|,
name|cpexpr
argument_list|(
name|e
argument_list|)
argument_list|,
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|putout
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
default|default:
name|badop
argument_list|(
literal|"putch1"
argument_list|,
name|p
operator|->
name|exprblock
operator|.
name|opcode
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|t
operator|)
return|;
default|default:
name|badtag
argument_list|(
literal|"putch1"
argument_list|,
name|p
operator|->
name|tag
argument_list|)
expr_stmt|;
block|}
comment|/* NOT REACHED */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* putchop -- Write out a character actual parameter; that is, this is    part of a procedure invocation */
end_comment

begin_function
name|Addrp
ifdef|#
directive|ifdef
name|KR_headers
name|putchop
parameter_list|(
name|p
parameter_list|)
name|expptr
name|p
decl_stmt|;
else|#
directive|else
function|putchop
parameter_list|(
name|expptr
name|p
parameter_list|)
endif|#
directive|endif
block|{
name|p
operator|=
name|putaddr
argument_list|(
operator|(
name|expptr
operator|)
name|putch1
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|Addrp
operator|)
name|p
return|;
block|}
end_function

begin_function
name|LOCAL
name|expptr
ifdef|#
directive|ifdef
name|KR_headers
name|putcheq
parameter_list|(
name|p
parameter_list|)
specifier|register
name|expptr
name|p
decl_stmt|;
else|#
directive|else
function|putcheq
parameter_list|(
specifier|register
name|expptr
name|p
parameter_list|)
endif|#
directive|endif
block|{
name|expptr
name|lp
decl_stmt|,
name|rp
decl_stmt|;
name|int
name|nbad
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|tag
operator|!=
name|TEXPR
condition|)
name|badtag
argument_list|(
literal|"putcheq"
argument_list|,
name|p
operator|->
name|tag
argument_list|)
expr_stmt|;
name|lp
operator|=
name|p
operator|->
name|exprblock
operator|.
name|leftp
expr_stmt|;
name|rp
operator|=
name|p
operator|->
name|exprblock
operator|.
name|rightp
expr_stmt|;
name|frexpr
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|vleng
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|charptr
operator|)
name|p
argument_list|)
expr_stmt|;
comment|/* If s = t // u, don't bother copying the result, write it directly into    this buffer */
name|nbad
operator|=
name|badchleng
argument_list|(
name|lp
argument_list|)
operator|+
name|badchleng
argument_list|(
name|rp
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp
operator|->
name|tag
operator|==
name|TEXPR
operator|&&
name|rp
operator|->
name|exprblock
operator|.
name|opcode
operator|==
name|OPCONCAT
condition|)
name|p
operator|=
name|putcat
argument_list|(
name|lp
argument_list|,
name|rp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|nbad
operator|&&
name|ISONE
argument_list|(
name|lp
operator|->
name|headblock
operator|.
name|vleng
argument_list|)
operator|&&
name|ISONE
argument_list|(
name|rp
operator|->
name|headblock
operator|.
name|vleng
argument_list|)
condition|)
block|{
name|lp
operator|=
name|mkexpr
argument_list|(
name|OPCONV
argument_list|,
name|lp
argument_list|,
name|ENULL
argument_list|)
expr_stmt|;
name|rp
operator|=
name|mkexpr
argument_list|(
name|OPCONV
argument_list|,
name|rp
argument_list|,
name|ENULL
argument_list|)
expr_stmt|;
name|lp
operator|->
name|headblock
operator|.
name|vtype
operator|=
name|rp
operator|->
name|headblock
operator|.
name|vtype
operator|=
name|TYCHAR
expr_stmt|;
name|p
operator|=
name|putop
argument_list|(
name|mkexpr
argument_list|(
name|OPASSIGN
argument_list|,
name|lp
argument_list|,
name|rp
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|p
operator|=
name|putx
argument_list|(
name|call2
argument_list|(
name|TYSUBR
argument_list|,
literal|"s_copy"
argument_list|,
name|lp
argument_list|,
name|rp
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_function
name|LOCAL
name|expptr
ifdef|#
directive|ifdef
name|KR_headers
name|putchcmp
parameter_list|(
name|p
parameter_list|)
specifier|register
name|expptr
name|p
decl_stmt|;
else|#
directive|else
function|putchcmp
parameter_list|(
specifier|register
name|expptr
name|p
parameter_list|)
endif|#
directive|endif
block|{
name|expptr
name|lp
decl_stmt|,
name|rp
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|tag
operator|!=
name|TEXPR
condition|)
name|badtag
argument_list|(
literal|"putchcmp"
argument_list|,
name|p
operator|->
name|tag
argument_list|)
expr_stmt|;
name|lp
operator|=
name|p
operator|->
name|exprblock
operator|.
name|leftp
expr_stmt|;
name|rp
operator|=
name|p
operator|->
name|exprblock
operator|.
name|rightp
expr_stmt|;
if|if
condition|(
name|ISONE
argument_list|(
name|lp
operator|->
name|headblock
operator|.
name|vleng
argument_list|)
operator|&&
name|ISONE
argument_list|(
name|rp
operator|->
name|headblock
operator|.
name|vleng
argument_list|)
condition|)
block|{
name|lp
operator|=
name|mkexpr
argument_list|(
name|OPCONV
argument_list|,
name|lp
argument_list|,
name|ENULL
argument_list|)
expr_stmt|;
name|rp
operator|=
name|mkexpr
argument_list|(
name|OPCONV
argument_list|,
name|rp
argument_list|,
name|ENULL
argument_list|)
expr_stmt|;
name|lp
operator|->
name|headblock
operator|.
name|vtype
operator|=
name|rp
operator|->
name|headblock
operator|.
name|vtype
operator|=
name|TYCHAR
expr_stmt|;
block|}
else|else
block|{
name|lp
operator|=
name|call2
argument_list|(
name|TYINT
argument_list|,
literal|"s_cmp"
argument_list|,
name|lp
argument_list|,
name|rp
argument_list|)
expr_stmt|;
name|rp
operator|=
name|ICON
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|p
operator|->
name|exprblock
operator|.
name|leftp
operator|=
name|lp
expr_stmt|;
name|p
operator|->
name|exprblock
operator|.
name|rightp
operator|=
name|rp
expr_stmt|;
name|p
operator|=
name|putop
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* putcat -- Writes out a concatenation operation.  Two temporary arrays    are allocated,   putct1()   is called to initialize them, and then a    call to runtime library routine   s_cat()   is inserted.  	This routine generates code which will perform an  (nconc lhs rhs)    at runtime.  The runtime funciton does not return a value, the routine    that calls this   putcat   must remember the name of   lhs. */
end_comment

begin_function
name|LOCAL
name|expptr
ifdef|#
directive|ifdef
name|KR_headers
name|putcat
parameter_list|(
name|lhs0
parameter_list|,
name|rhs
parameter_list|)
name|expptr
name|lhs0
decl_stmt|;
specifier|register
name|expptr
name|rhs
decl_stmt|;
else|#
directive|else
function|putcat
parameter_list|(
name|expptr
name|lhs0
parameter_list|,
specifier|register
name|expptr
name|rhs
parameter_list|)
endif|#
directive|endif
block|{
specifier|register
name|Addrp
name|lhs
init|=
operator|(
name|Addrp
operator|)
name|lhs0
decl_stmt|;
name|int
name|n
decl_stmt|,
name|tyi
decl_stmt|;
name|Addrp
name|length_var
decl_stmt|,
name|string_var
decl_stmt|;
name|expptr
name|p
decl_stmt|;
specifier|static
name|char
name|Writing_concatenation
index|[]
init|=
literal|"Writing concatenation"
decl_stmt|;
comment|/* Create the temporary arrays */
name|n
operator|=
name|ncat
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
name|length_var
operator|=
name|mktmpn
argument_list|(
name|n
argument_list|,
name|tyioint
argument_list|,
name|ENULL
argument_list|)
expr_stmt|;
name|string_var
operator|=
name|mktmpn
argument_list|(
name|n
argument_list|,
name|TYADDR
argument_list|,
name|ENULL
argument_list|)
expr_stmt|;
name|frtemp
argument_list|(
operator|(
name|Addrp
operator|)
name|cpexpr
argument_list|(
operator|(
name|expptr
operator|)
name|length_var
argument_list|)
argument_list|)
expr_stmt|;
name|frtemp
argument_list|(
operator|(
name|Addrp
operator|)
name|cpexpr
argument_list|(
operator|(
name|expptr
operator|)
name|string_var
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Initialize the arrays */
name|n
operator|=
literal|0
expr_stmt|;
comment|/* p1_comment scribbles on its argument, so we 	 * cannot safely pass a string literal here. */
name|p1_comment
argument_list|(
name|Writing_concatenation
argument_list|)
expr_stmt|;
name|putct1
argument_list|(
name|rhs
argument_list|,
name|length_var
argument_list|,
name|string_var
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
comment|/* Create the invocation */
name|tyi
operator|=
name|tyint
expr_stmt|;
name|tyint
operator|=
name|tyioint
expr_stmt|;
comment|/* for -I2 */
name|p
operator|=
name|putx
argument_list|(
name|call4
argument_list|(
name|TYSUBR
argument_list|,
literal|"s_cat"
argument_list|,
operator|(
name|expptr
operator|)
name|lhs
argument_list|,
operator|(
name|expptr
operator|)
name|string_var
argument_list|,
operator|(
name|expptr
operator|)
name|length_var
argument_list|,
operator|(
name|expptr
operator|)
name|putconst
argument_list|(
operator|(
name|Constp
operator|)
name|ICON
argument_list|(
name|n
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|tyint
operator|=
name|tyi
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_function
name|LOCAL
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|putct1
parameter_list|(
name|q
parameter_list|,
name|length_var
parameter_list|,
name|string_var
parameter_list|,
name|ip
parameter_list|)
specifier|register
name|expptr
name|q
decl_stmt|;
specifier|register
name|Addrp
name|length_var
decl_stmt|;
specifier|register
name|Addrp
name|string_var
decl_stmt|;
name|int
modifier|*
name|ip
decl_stmt|;
else|#
directive|else
function|putct1
parameter_list|(
specifier|register
name|expptr
name|q
parameter_list|,
specifier|register
name|Addrp
name|length_var
parameter_list|,
specifier|register
name|Addrp
name|string_var
parameter_list|,
name|int
modifier|*
name|ip
parameter_list|)
endif|#
directive|endif
block|{
name|int
name|i
decl_stmt|;
name|Addrp
name|length_copy
decl_stmt|,
name|string_copy
decl_stmt|;
name|expptr
name|e
decl_stmt|;
specifier|extern
name|int
name|szleng
decl_stmt|;
if|if
condition|(
name|q
operator|->
name|tag
operator|==
name|TEXPR
operator|&&
name|q
operator|->
name|exprblock
operator|.
name|opcode
operator|==
name|OPCONCAT
condition|)
block|{
name|putct1
argument_list|(
name|q
operator|->
name|exprblock
operator|.
name|leftp
argument_list|,
name|length_var
argument_list|,
name|string_var
argument_list|,
name|ip
argument_list|)
expr_stmt|;
name|putct1
argument_list|(
name|q
operator|->
name|exprblock
operator|.
name|rightp
argument_list|,
name|length_var
argument_list|,
name|string_var
argument_list|,
name|ip
argument_list|)
expr_stmt|;
name|frexpr
argument_list|(
name|q
operator|->
name|exprblock
operator|.
name|vleng
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|charptr
operator|)
name|q
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|i
operator|=
operator|(
operator|*
name|ip
operator|)
operator|++
expr_stmt|;
name|e
operator|=
name|cpexpr
argument_list|(
name|q
operator|->
name|headblock
operator|.
name|vleng
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|e
condition|)
return|return;
comment|/* error -- character*(*) */
name|length_copy
operator|=
operator|(
name|Addrp
operator|)
name|cpexpr
argument_list|(
operator|(
name|expptr
operator|)
name|length_var
argument_list|)
expr_stmt|;
name|length_copy
operator|->
name|memoffset
operator|=
name|mkexpr
argument_list|(
name|OPPLUS
argument_list|,
name|length_copy
operator|->
name|memoffset
argument_list|,
name|ICON
argument_list|(
name|i
operator|*
name|szleng
argument_list|)
argument_list|)
expr_stmt|;
name|string_copy
operator|=
operator|(
name|Addrp
operator|)
name|cpexpr
argument_list|(
operator|(
name|expptr
operator|)
name|string_var
argument_list|)
expr_stmt|;
name|string_copy
operator|->
name|memoffset
operator|=
name|mkexpr
argument_list|(
name|OPPLUS
argument_list|,
name|string_copy
operator|->
name|memoffset
argument_list|,
name|ICON
argument_list|(
name|i
operator|*
name|typesize
index|[
name|TYADDR
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|putout
argument_list|(
name|PAIR
argument_list|(
name|putassign
argument_list|(
operator|(
name|expptr
operator|)
name|length_copy
argument_list|,
name|e
argument_list|)
argument_list|,
name|putassign
argument_list|(
operator|(
name|expptr
operator|)
name|string_copy
argument_list|,
name|addrof
argument_list|(
operator|(
name|expptr
operator|)
name|putch1
argument_list|(
name|q
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* putaddr -- seems to write out function invocation actual parameters */
end_comment

begin_function
name|LOCAL
name|expptr
ifdef|#
directive|ifdef
name|KR_headers
name|putaddr
parameter_list|(
name|p0
parameter_list|)
name|expptr
name|p0
decl_stmt|;
else|#
directive|else
function|putaddr
parameter_list|(
name|expptr
name|p0
parameter_list|)
endif|#
directive|endif
block|{
specifier|register
name|Addrp
name|p
decl_stmt|;
name|chainp
name|cp
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|p
operator|=
operator|(
name|Addrp
operator|)
name|p0
operator|)
condition|)
return|return
name|ENULL
return|;
if|if
condition|(
name|p
operator|->
name|tag
operator|==
name|TERROR
operator|||
operator|(
name|p
operator|->
name|memoffset
operator|!=
name|NULL
operator|&&
name|ISERROR
argument_list|(
name|p
operator|->
name|memoffset
argument_list|)
operator|)
condition|)
block|{
name|frexpr
argument_list|(
operator|(
name|expptr
operator|)
name|p
argument_list|)
expr_stmt|;
return|return
name|ENULL
return|;
block|}
if|if
condition|(
name|p
operator|->
name|isarray
operator|&&
name|p
operator|->
name|memoffset
condition|)
if|if
condition|(
name|p
operator|->
name|uname_tag
operator|==
name|UNAM_REF
condition|)
block|{
name|cp
operator|=
name|p
operator|->
name|memoffset
operator|->
name|listblock
operator|.
name|listp
expr_stmt|;
for|for
control|(
init|;
name|cp
condition|;
name|cp
operator|=
name|cp
operator|->
name|nextp
control|)
name|cp
operator|->
name|datap
operator|=
operator|(
name|char
operator|*
operator|)
name|fixtype
argument_list|(
operator|(
name|tagptr
operator|)
name|cp
operator|->
name|datap
argument_list|)
expr_stmt|;
block|}
else|else
name|p
operator|->
name|memoffset
operator|=
name|putx
argument_list|(
name|p
operator|->
name|memoffset
argument_list|)
expr_stmt|;
return|return
operator|(
name|expptr
operator|)
name|p
return|;
block|}
end_function

begin_function
name|LOCAL
name|expptr
ifdef|#
directive|ifdef
name|KR_headers
name|addrfix
parameter_list|(
name|e
parameter_list|)
name|expptr
name|e
decl_stmt|;
else|#
directive|else
function|addrfix
parameter_list|(
name|expptr
name|e
parameter_list|)
endif|#
directive|endif
comment|/* fudge character string length if it's a TADDR */
block|{
return|return
name|e
operator|->
name|tag
operator|==
name|TADDR
condition|?
name|mkexpr
argument_list|(
name|OPIDENTITY
argument_list|,
name|e
argument_list|,
name|ENULL
argument_list|)
else|:
name|e
return|;
block|}
end_function

begin_function
name|LOCAL
name|int
ifdef|#
directive|ifdef
name|KR_headers
name|typekludge
parameter_list|(
name|ccall
parameter_list|,
name|q
parameter_list|,
name|at
parameter_list|,
name|j
parameter_list|)
name|int
name|ccall
decl_stmt|;
specifier|register
name|expptr
name|q
decl_stmt|;
name|Atype
modifier|*
name|at
decl_stmt|;
name|int
name|j
decl_stmt|;
else|#
directive|else
function|typekludge
parameter_list|(
name|int
name|ccall
parameter_list|,
specifier|register
name|expptr
name|q
parameter_list|,
name|Atype
modifier|*
name|at
parameter_list|,
name|int
name|j
parameter_list|)
endif|#
directive|endif
comment|/* j = alternate type */
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|k
decl_stmt|;
specifier|extern
name|int
name|iocalladdr
decl_stmt|;
specifier|register
name|Namep
name|np
decl_stmt|;
comment|/* Return value classes: 	 *< 100 ==> Fortran arg (pointer to type) 	 *< 200 ==> C arg 	 *< 300 ==> procedure arg 	 *< 400 ==> external, no explicit type 	 *< 500 ==> arg that may turn out to be 	 *		  either a variable or a procedure 	 */
name|k
operator|=
name|q
operator|->
name|headblock
operator|.
name|vtype
expr_stmt|;
if|if
condition|(
name|ccall
condition|)
block|{
if|if
condition|(
name|k
operator|==
name|TYREAL
condition|)
name|k
operator|=
name|TYDREAL
expr_stmt|;
comment|/* force double for library routines */
return|return
name|k
operator|+
literal|100
return|;
block|}
if|if
condition|(
name|k
operator|==
name|TYADDR
condition|)
return|return
name|iocalladdr
return|;
name|i
operator|=
name|q
operator|->
name|tag
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|==
name|TEXPR
operator|&&
name|q
operator|->
name|exprblock
operator|.
name|opcode
operator|!=
name|OPCOMMA_ARG
operator|)
operator|||
operator|(
name|i
operator|==
name|TADDR
operator|&&
name|q
operator|->
name|addrblock
operator|.
name|charleng
operator|)
operator|||
name|i
operator|==
name|TCONST
condition|)
name|k
operator|=
name|TYFTNLEN
operator|+
literal|100
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
name|TADDR
condition|)
switch|switch
condition|(
name|q
operator|->
name|addrblock
operator|.
name|vclass
condition|)
block|{
case|case
name|CLPROC
case|:
if|if
condition|(
name|q
operator|->
name|addrblock
operator|.
name|uname_tag
operator|!=
name|UNAM_NAME
condition|)
name|k
operator|+=
literal|200
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|np
operator|=
name|q
operator|->
name|addrblock
operator|.
name|user
operator|.
name|name
operator|)
operator|->
name|vprocclass
operator|!=
name|PTHISPROC
condition|)
block|{
if|if
condition|(
name|k
operator|&&
operator|!
name|np
operator|->
name|vimpltype
condition|)
name|k
operator|+=
literal|200
expr_stmt|;
else|else
block|{
if|if
condition|(
name|j
operator|>
literal|200
operator|&&
name|infertypes
operator|&&
name|j
operator|<
literal|300
condition|)
block|{
name|k
operator|=
name|j
expr_stmt|;
name|inferdcl
argument_list|(
name|np
argument_list|,
name|j
operator|-
literal|200
argument_list|)
expr_stmt|;
block|}
else|else
name|k
operator|=
operator|(
name|np
operator|->
name|vstg
operator|==
name|STGEXT
condition|?
name|extsymtab
index|[
name|np
operator|->
name|vardesc
operator|.
name|varno
index|]
operator|.
name|extype
else|:
literal|0
operator|)
operator|+
literal|200
expr_stmt|;
name|at
operator|->
name|cp
operator|=
name|mkchain
argument_list|(
operator|(
name|char
operator|*
operator|)
name|np
argument_list|,
name|at
operator|->
name|cp
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|k
operator|==
name|TYSUBR
condition|)
name|k
operator|+=
literal|200
expr_stmt|;
break|break;
case|case
name|CLUNKNOWN
case|:
if|if
condition|(
name|q
operator|->
name|addrblock
operator|.
name|vstg
operator|==
name|STGARG
operator|&&
name|q
operator|->
name|addrblock
operator|.
name|uname_tag
operator|==
name|UNAM_NAME
condition|)
block|{
name|k
operator|+=
literal|400
expr_stmt|;
name|at
operator|->
name|cp
operator|=
name|mkchain
argument_list|(
operator|(
name|char
operator|*
operator|)
name|q
operator|->
name|addrblock
operator|.
name|user
operator|.
name|name
argument_list|,
name|at
operator|->
name|cp
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|i
operator|==
name|TNAME
operator|&&
name|q
operator|->
name|nameblock
operator|.
name|vstg
operator|==
name|STGARG
condition|)
block|{
name|np
operator|=
operator|&
name|q
operator|->
name|nameblock
expr_stmt|;
switch|switch
condition|(
name|np
operator|->
name|vclass
condition|)
block|{
case|case
name|CLPROC
case|:
if|if
condition|(
operator|!
name|np
operator|->
name|vimpltype
condition|)
name|k
operator|+=
literal|200
expr_stmt|;
elseif|else
if|if
condition|(
name|j
operator|<=
literal|200
operator|||
operator|!
name|infertypes
operator|||
name|j
operator|>=
literal|300
condition|)
name|k
operator|+=
literal|300
expr_stmt|;
else|else
block|{
name|k
operator|=
name|j
expr_stmt|;
name|inferdcl
argument_list|(
name|np
argument_list|,
name|j
operator|-
literal|200
argument_list|)
expr_stmt|;
block|}
goto|goto
name|add2chain
goto|;
case|case
name|CLUNKNOWN
case|:
comment|/* argument may be a scalar variable or a function */
if|if
condition|(
name|np
operator|->
name|vimpltype
operator|&&
name|j
operator|&&
name|infertypes
operator|&&
name|j
operator|<
literal|300
condition|)
block|{
name|inferdcl
argument_list|(
name|np
argument_list|,
name|j
operator|%
literal|100
argument_list|)
expr_stmt|;
name|k
operator|=
name|j
expr_stmt|;
block|}
else|else
name|k
operator|+=
literal|400
expr_stmt|;
comment|/* to handle procedure args only so far known to be 			 * external, save a pointer to the symbol table entry... 		 	 */
name|add2chain
label|:
name|at
operator|->
name|cp
operator|=
name|mkchain
argument_list|(
operator|(
name|char
operator|*
operator|)
name|np
argument_list|,
name|at
operator|->
name|cp
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|k
return|;
block|}
end_function

begin_function
name|char
modifier|*
ifdef|#
directive|ifdef
name|KR_headers
name|Argtype
parameter_list|(
name|k
parameter_list|,
name|buf
parameter_list|)
name|int
name|k
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
else|#
directive|else
function|Argtype
parameter_list|(
name|int
name|k
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|)
endif|#
directive|endif
block|{
if|if
condition|(
name|k
operator|<
literal|100
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s variable"
argument_list|,
name|ftn_types
index|[
name|k
index|]
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
if|if
condition|(
name|k
operator|<
literal|200
condition|)
block|{
name|k
operator|-=
literal|100
expr_stmt|;
return|return
name|ftn_types
index|[
name|k
index|]
return|;
block|}
if|if
condition|(
name|k
operator|<
literal|300
condition|)
block|{
name|k
operator|-=
literal|200
expr_stmt|;
if|if
condition|(
name|k
operator|==
name|TYSUBR
condition|)
return|return
name|ftn_types
index|[
name|TYSUBR
index|]
return|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s function"
argument_list|,
name|ftn_types
index|[
name|k
index|]
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
if|if
condition|(
name|k
operator|<
literal|400
condition|)
return|return
literal|"external argument"
return|;
name|k
operator|-=
literal|400
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s argument"
argument_list|,
name|ftn_types
index|[
name|k
index|]
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_function
specifier|static
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|atype_squawk
parameter_list|(
name|at
parameter_list|,
name|msg
parameter_list|)
name|Argtypes
modifier|*
name|at
decl_stmt|;
name|char
modifier|*
name|msg
decl_stmt|;
else|#
directive|else
function|atype_squawk
parameter_list|(
name|Argtypes
modifier|*
name|at
parameter_list|,
name|char
modifier|*
name|msg
parameter_list|)
endif|#
directive|endif
block|{
specifier|register
name|Atype
modifier|*
name|a
decl_stmt|,
modifier|*
name|ae
decl_stmt|;
name|warn
argument_list|(
name|msg
argument_list|)
expr_stmt|;
for|for
control|(
name|a
operator|=
name|at
operator|->
name|atypes
operator|,
name|ae
operator|=
name|a
operator|+
name|at
operator|->
name|nargs
init|;
name|a
operator|<
name|ae
condition|;
name|a
operator|++
control|)
name|frchain
argument_list|(
operator|&
name|a
operator|->
name|cp
argument_list|)
expr_stmt|;
name|at
operator|->
name|nargs
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|at
operator|->
name|changes
operator|&
literal|2
operator|&&
operator|!
name|at
operator|->
name|defined
condition|)
name|proc_protochanges
operator|++
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
name|inconsist
index|[]
init|=
literal|"inconsistent calling sequences for "
decl_stmt|;
end_decl_stmt

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|bad_atypes
parameter_list|(
name|at
parameter_list|,
name|fname
parameter_list|,
name|i
parameter_list|,
name|j
parameter_list|,
name|k
parameter_list|,
name|here
parameter_list|,
name|prev
parameter_list|)
name|Argtypes
modifier|*
name|at
decl_stmt|;
name|char
modifier|*
name|fname
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|j
decl_stmt|;
name|int
name|k
decl_stmt|;
name|char
modifier|*
name|here
decl_stmt|;
name|char
modifier|*
name|prev
decl_stmt|;
else|#
directive|else
function|bad_atypes
parameter_list|(
name|Argtypes
modifier|*
name|at
parameter_list|,
name|char
modifier|*
name|fname
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|,
name|char
modifier|*
name|here
parameter_list|,
name|char
modifier|*
name|prev
parameter_list|)
endif|#
directive|endif
block|{
name|char
name|buf
index|[
literal|208
index|]
decl_stmt|,
name|buf1
index|[
literal|32
index|]
decl_stmt|,
name|buf2
index|[
literal|32
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s%.90s,\n\targ %d: %s%s%s %s."
argument_list|,
name|inconsist
argument_list|,
name|fname
argument_list|,
name|i
argument_list|,
name|here
argument_list|,
name|Argtype
argument_list|(
name|k
argument_list|,
name|buf1
argument_list|)
argument_list|,
name|prev
argument_list|,
name|Argtype
argument_list|(
name|j
argument_list|,
name|buf2
argument_list|)
argument_list|)
expr_stmt|;
name|atype_squawk
argument_list|(
name|at
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
ifdef|#
directive|ifdef
name|KR_headers
name|type_fixup
parameter_list|(
name|at
parameter_list|,
name|a
parameter_list|,
name|k
parameter_list|)
name|Argtypes
modifier|*
name|at
decl_stmt|;
name|Atype
modifier|*
name|a
decl_stmt|;
name|int
name|k
decl_stmt|;
else|#
directive|else
function|type_fixup
parameter_list|(
name|Argtypes
modifier|*
name|at
parameter_list|,
name|Atype
modifier|*
name|a
parameter_list|,
name|int
name|k
parameter_list|)
endif|#
directive|endif
block|{
specifier|register
name|struct
name|Entrypoint
modifier|*
name|ep
decl_stmt|;
if|if
condition|(
operator|!
name|infertypes
condition|)
return|return
literal|0
return|;
for|for
control|(
name|ep
operator|=
name|entries
init|;
name|ep
condition|;
name|ep
operator|=
name|ep
operator|->
name|entnextp
control|)
if|if
condition|(
name|ep
operator|->
name|entryname
operator|&&
name|at
operator|==
name|ep
operator|->
name|entryname
operator|->
name|arginfo
condition|)
block|{
name|a
operator|->
name|type
operator|=
name|k
operator|%
literal|100
expr_stmt|;
return|return
name|proc_argchanges
operator|=
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|save_argtypes
parameter_list|(
name|arglist
parameter_list|,
name|at0
parameter_list|,
name|at1
parameter_list|,
name|ccall
parameter_list|,
name|fname
parameter_list|,
name|stg
parameter_list|,
name|nchargs
parameter_list|,
name|type
parameter_list|,
name|zap
parameter_list|)
name|chainp
name|arglist
decl_stmt|;
name|Argtypes
modifier|*
modifier|*
name|at0
decl_stmt|;
name|Argtypes
modifier|*
modifier|*
name|at1
decl_stmt|;
name|int
name|ccall
decl_stmt|;
name|char
modifier|*
name|fname
decl_stmt|;
name|int
name|stg
decl_stmt|;
name|int
name|nchargs
decl_stmt|;
name|int
name|type
decl_stmt|;
name|int
name|zap
decl_stmt|;
else|#
directive|else
function|save_argtypes
parameter_list|(
name|chainp
name|arglist
parameter_list|,
name|Argtypes
modifier|*
modifier|*
name|at0
parameter_list|,
name|Argtypes
modifier|*
modifier|*
name|at1
parameter_list|,
name|int
name|ccall
parameter_list|,
name|char
modifier|*
name|fname
parameter_list|,
name|int
name|stg
parameter_list|,
name|int
name|nchargs
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|zap
parameter_list|)
endif|#
directive|endif
block|{
name|Argtypes
modifier|*
name|at
decl_stmt|;
name|chainp
name|cp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|i0
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|nargs
decl_stmt|,
name|nbad
decl_stmt|,
modifier|*
name|t
decl_stmt|,
modifier|*
name|te
decl_stmt|;
name|Atype
modifier|*
name|atypes
decl_stmt|;
name|expptr
name|q
decl_stmt|;
name|char
name|buf
index|[
literal|208
index|]
decl_stmt|,
name|buf1
index|[
literal|32
index|]
decl_stmt|,
name|buf2
index|[
literal|32
index|]
decl_stmt|;
specifier|static
name|int
name|initargs
index|[
literal|4
index|]
init|=
block|{
name|TYCOMPLEX
block|,
name|TYDCOMPLEX
block|,
name|TYCHAR
block|,
name|TYFTNLEN
operator|+
literal|100
block|}
decl_stmt|;
specifier|static
name|int
modifier|*
name|init_ap
index|[
name|TYSUBR
operator|+
literal|1
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
ifdef|#
directive|ifdef
name|TYQUAD
literal|0
block|,
endif|#
directive|endif
name|initargs
block|,
name|initargs
operator|+
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|initargs
operator|+
literal|2
block|}
decl_stmt|;
name|i0
operator|=
name|init_ac
index|[
name|type
index|]
expr_stmt|;
name|t
operator|=
name|init_ap
index|[
name|type
index|]
expr_stmt|;
name|te
operator|=
name|t
operator|+
name|i0
expr_stmt|;
if|if
condition|(
name|at
operator|=
operator|*
name|at0
condition|)
block|{
operator|*
name|at1
operator|=
name|at
expr_stmt|;
name|nargs
operator|=
name|at
operator|->
name|nargs
expr_stmt|;
if|if
condition|(
name|nargs
operator|<
literal|0
operator|&&
name|type
operator|&&
name|at
operator|->
name|changes
operator|&
literal|2
operator|&&
operator|!
name|at
operator|->
name|defined
condition|)
operator|--
name|proc_protochanges
expr_stmt|;
if|if
condition|(
name|at
operator|->
name|dnargs
operator|>=
literal|0
operator|&&
name|zap
operator|!=
literal|2
condition|)
name|type
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nargs
operator|<
literal|0
condition|)
block|{
comment|/* inconsistent usage seen */
if|if
condition|(
name|type
condition|)
goto|goto
name|newlist
goto|;
return|return;
block|}
name|atypes
operator|=
name|at
operator|->
name|atypes
expr_stmt|;
name|i
operator|=
name|nchargs
expr_stmt|;
for|for
control|(
name|nbad
operator|=
literal|0
init|;
name|t
operator|<
name|te
condition|;
name|atypes
operator|++
control|)
block|{
if|if
condition|(
operator|++
name|i
operator|>
name|nargs
condition|)
block|{
name|toomany
label|:
name|i
operator|=
name|nchargs
operator|+
name|i0
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|arglist
init|;
name|cp
condition|;
name|cp
operator|=
name|cp
operator|->
name|nextp
control|)
name|i
operator|++
expr_stmt|;
name|toofew
label|:
switch|switch
condition|(
name|zap
condition|)
block|{
case|case
literal|2
case|:
name|zap
operator|=
literal|6
expr_stmt|;
break|break;
case|case
literal|1
case|:
if|if
condition|(
name|at
operator|->
name|defined
operator|&
literal|4
condition|)
return|return;
block|}
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s%.90s:\n\there %d, previously %d args and string lengths."
argument_list|,
name|inconsist
argument_list|,
name|fname
argument_list|,
name|i
argument_list|,
name|nargs
argument_list|)
expr_stmt|;
name|atype_squawk
argument_list|(
name|at
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
condition|)
block|{
name|t
operator|=
name|init_ap
index|[
name|type
index|]
expr_stmt|;
goto|goto
name|newlist
goto|;
block|}
return|return;
block|}
name|j
operator|=
name|atypes
operator|->
name|type
expr_stmt|;
name|k
operator|=
operator|*
name|t
operator|++
expr_stmt|;
if|if
condition|(
name|j
operator|!=
name|k
operator|&&
name|j
operator|-
literal|400
operator|!=
name|k
condition|)
block|{
name|cp
operator|=
literal|0
expr_stmt|;
goto|goto
name|badtypes
goto|;
block|}
block|}
for|for
control|(
name|cp
operator|=
name|arglist
init|;
name|cp
condition|;
name|atypes
operator|++
operator|,
name|cp
operator|=
name|cp
operator|->
name|nextp
control|)
block|{
if|if
condition|(
operator|++
name|i
operator|>
name|nargs
condition|)
goto|goto
name|toomany
goto|;
name|j
operator|=
name|atypes
operator|->
name|type
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|q
operator|=
operator|(
name|expptr
operator|)
name|cp
operator|->
name|datap
operator|)
condition|)
continue|continue;
name|k
operator|=
name|typekludge
argument_list|(
name|ccall
argument_list|,
name|q
argument_list|,
name|atypes
argument_list|,
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|>=
literal|300
operator|||
name|k
operator|==
name|j
condition|)
continue|continue;
if|if
condition|(
name|j
operator|>=
literal|300
condition|)
block|{
if|if
condition|(
name|k
operator|>=
literal|200
condition|)
block|{
if|if
condition|(
name|k
operator|==
name|TYUNKNOWN
operator|+
literal|200
condition|)
continue|continue;
if|if
condition|(
name|j
operator|%
literal|100
operator|!=
name|k
operator|-
literal|200
operator|&&
name|k
operator|!=
name|TYSUBR
operator|+
literal|200
operator|&&
name|j
operator|!=
name|TYUNKNOWN
operator|+
literal|300
operator|&&
operator|!
name|type_fixup
argument_list|(
name|at
argument_list|,
name|atypes
argument_list|,
name|k
argument_list|)
condition|)
goto|goto
name|badtypes
goto|;
block|}
elseif|else
if|if
condition|(
name|j
operator|%
literal|100
operator|%
name|TYSUBR
operator|!=
name|k
operator|%
name|TYSUBR
operator|&&
operator|!
name|type_fixup
argument_list|(
name|at
argument_list|,
name|atypes
argument_list|,
name|k
argument_list|)
condition|)
goto|goto
name|badtypes
goto|;
block|}
elseif|else
if|if
condition|(
name|k
operator|<
literal|200
operator|||
name|j
operator|<
literal|200
condition|)
if|if
condition|(
name|j
condition|)
block|{
if|if
condition|(
name|k
operator|==
name|TYUNKNOWN
operator|&&
name|q
operator|->
name|tag
operator|==
name|TNAME
operator|&&
name|q
operator|->
name|nameblock
operator|.
name|vinfproc
condition|)
block|{
name|q
operator|->
name|nameblock
operator|.
name|vdcldone
operator|=
literal|0
expr_stmt|;
name|impldcl
argument_list|(
operator|(
name|Namep
operator|)
name|q
argument_list|)
expr_stmt|;
block|}
goto|goto
name|badtypes
goto|;
block|}
else|else
empty_stmt|;
comment|/* fall through to update */
elseif|else
if|if
condition|(
name|k
operator|==
name|TYUNKNOWN
operator|+
literal|200
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|j
operator|!=
name|TYUNKNOWN
operator|+
literal|200
condition|)
block|{
name|badtypes
label|:
if|if
condition|(
operator|++
name|nbad
operator|==
literal|1
condition|)
name|bad_atypes
argument_list|(
name|at
argument_list|,
name|fname
argument_list|,
name|i
operator|-
name|nchargs
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
literal|"here "
argument_list|,
literal|", previously"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\targ %d: here %s, previously %s.\n"
argument_list|,
name|i
operator|-
name|nchargs
argument_list|,
name|Argtype
argument_list|(
name|k
argument_list|,
name|buf1
argument_list|)
argument_list|,
name|Argtype
argument_list|(
name|j
argument_list|,
name|buf2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cp
condition|)
break|break;
continue|continue;
block|}
comment|/* We've subsequently learned the right type, 			   as in the call on zoo below...  				subroutine foo(x, zap) 				external zap 				call goo(zap) 				x = zap(3) 				call zoo(zap) 				end 			 */
if|if
condition|(
operator|!
name|nbad
condition|)
block|{
name|atypes
operator|->
name|type
operator|=
name|k
expr_stmt|;
name|at
operator|->
name|changes
operator||=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|i
operator|<
name|nargs
condition|)
goto|goto
name|toofew
goto|;
if|if
condition|(
name|nbad
condition|)
block|{
if|if
condition|(
name|type
condition|)
block|{
comment|/* we're defining the procedure */
name|t
operator|=
name|init_ap
index|[
name|type
index|]
expr_stmt|;
name|te
operator|=
name|t
operator|+
name|i0
expr_stmt|;
name|proc_argchanges
operator|=
literal|1
expr_stmt|;
goto|goto
name|newlist
goto|;
block|}
return|return;
block|}
if|if
condition|(
name|zap
operator|==
literal|1
operator|&&
operator|(
name|at
operator|->
name|changes
operator|&
literal|5
operator|)
operator|!=
literal|5
condition|)
name|at
operator|->
name|changes
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|newlist
label|:
name|i
operator|=
name|i0
operator|+
name|nchargs
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|arglist
init|;
name|cp
condition|;
name|cp
operator|=
name|cp
operator|->
name|nextp
control|)
name|i
operator|++
expr_stmt|;
name|k
operator|=
sizeof|sizeof
argument_list|(
name|Argtypes
argument_list|)
operator|+
operator|(
name|i
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|Atype
argument_list|)
expr_stmt|;
operator|*
name|at0
operator|=
operator|*
name|at1
operator|=
name|at
operator|=
name|stg
operator|==
name|STGEXT
condition|?
operator|(
name|Argtypes
operator|*
operator|)
name|gmem
argument_list|(
name|k
argument_list|,
literal|1
argument_list|)
else|:
operator|(
name|Argtypes
operator|*
operator|)
name|mem
argument_list|(
name|k
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|at
operator|->
name|dnargs
operator|=
name|at
operator|->
name|nargs
operator|=
name|i
expr_stmt|;
name|at
operator|->
name|defined
operator|=
name|zap
operator|&
literal|6
expr_stmt|;
name|at
operator|->
name|changes
operator|=
name|type
condition|?
literal|0
else|:
literal|4
expr_stmt|;
name|atypes
operator|=
name|at
operator|->
name|atypes
expr_stmt|;
for|for
control|(
init|;
name|t
operator|<
name|te
condition|;
name|atypes
operator|++
control|)
block|{
name|atypes
operator|->
name|type
operator|=
operator|*
name|t
operator|++
expr_stmt|;
name|atypes
operator|->
name|cp
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|cp
operator|=
name|arglist
init|;
name|cp
condition|;
name|atypes
operator|++
operator|,
name|cp
operator|=
name|cp
operator|->
name|nextp
control|)
block|{
name|atypes
operator|->
name|cp
operator|=
literal|0
expr_stmt|;
name|atypes
operator|->
name|type
operator|=
operator|(
name|q
operator|=
operator|(
name|expptr
operator|)
name|cp
operator|->
name|datap
operator|)
condition|?
name|typekludge
argument_list|(
name|ccall
argument_list|,
name|q
argument_list|,
name|atypes
argument_list|,
literal|0
argument_list|)
else|:
literal|0
expr_stmt|;
block|}
for|for
control|(
init|;
operator|--
name|nchargs
operator|>=
literal|0
condition|;
name|atypes
operator|++
control|)
block|{
name|atypes
operator|->
name|type
operator|=
name|TYFTNLEN
operator|+
literal|100
expr_stmt|;
name|atypes
operator|->
name|cp
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
ifdef|#
directive|ifdef
name|KR_headers
name|get_argtypes
parameter_list|(
name|p
parameter_list|,
name|pat0
parameter_list|,
name|pat1
parameter_list|)
name|Exprp
name|p
decl_stmt|;
name|Argtypes
modifier|*
modifier|*
modifier|*
name|pat0
decl_stmt|,
decl|*
modifier|*
modifier|*
name|pat1
decl_stmt|;
end_function

begin_else
else|#
directive|else
end_else

begin_macro
name|get_argtypes
argument_list|(
argument|Exprp p
argument_list|,
argument|Argtypes ***pat0
argument_list|,
argument|Argtypes ***pat1
argument_list|)
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|Addrp
name|a
decl_stmt|;
name|Argtypes
modifier|*
modifier|*
name|at0
decl_stmt|,
modifier|*
modifier|*
name|at1
decl_stmt|;
name|Namep
name|np
decl_stmt|;
name|expptr
name|rp
decl_stmt|;
name|Extsym
modifier|*
name|e
decl_stmt|;
name|char
modifier|*
name|fname
decl_stmt|;
name|a
operator|=
operator|(
name|Addrp
operator|)
name|p
operator|->
name|leftp
expr_stmt|;
switch|switch
condition|(
name|a
operator|->
name|vstg
condition|)
block|{
case|case
name|STGEXT
case|:
switch|switch
condition|(
name|a
operator|->
name|uname_tag
condition|)
block|{
case|case
name|UNAM_EXTERN
case|:
comment|/* e.g., sqrt() */
name|e
operator|=
name|extsymtab
operator|+
name|a
operator|->
name|memno
expr_stmt|;
name|at0
operator|=
name|at1
operator|=
operator|&
name|e
operator|->
name|arginfo
expr_stmt|;
name|fname
operator|=
name|e
operator|->
name|fextname
expr_stmt|;
break|break;
case|case
name|UNAM_NAME
case|:
name|np
operator|=
name|a
operator|->
name|user
operator|.
name|name
expr_stmt|;
name|at0
operator|=
operator|&
name|extsymtab
index|[
name|np
operator|->
name|vardesc
operator|.
name|varno
index|]
operator|.
name|arginfo
expr_stmt|;
name|at1
operator|=
operator|&
name|np
operator|->
name|arginfo
expr_stmt|;
name|fname
operator|=
name|np
operator|->
name|fvarname
expr_stmt|;
break|break;
default|default:
goto|goto
name|bug
goto|;
block|}
break|break;
case|case
name|STGARG
case|:
if|if
condition|(
name|a
operator|->
name|uname_tag
operator|!=
name|UNAM_NAME
condition|)
goto|goto
name|bug
goto|;
name|np
operator|=
name|a
operator|->
name|user
operator|.
name|name
expr_stmt|;
name|at0
operator|=
name|at1
operator|=
operator|&
name|np
operator|->
name|arginfo
expr_stmt|;
name|fname
operator|=
name|np
operator|->
name|fvarname
expr_stmt|;
break|break;
default|default:
name|bug
label|:
name|Fatal
argument_list|(
literal|"Confusion in saveargtypes"
argument_list|)
expr_stmt|;
block|}
operator|*
name|pat0
operator|=
name|at0
expr_stmt|;
operator|*
name|pat1
operator|=
name|at1
expr_stmt|;
return|return
name|fname
return|;
block|}
end_block

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|saveargtypes
parameter_list|(
name|p
parameter_list|)
specifier|register
name|Exprp
name|p
decl_stmt|;
else|#
directive|else
function|saveargtypes
parameter_list|(
specifier|register
name|Exprp
name|p
parameter_list|)
endif|#
directive|endif
comment|/* for writing prototypes */
block|{
name|Argtypes
modifier|*
modifier|*
name|at0
decl_stmt|,
modifier|*
modifier|*
name|at1
decl_stmt|;
name|chainp
name|arglist
decl_stmt|;
name|expptr
name|rp
decl_stmt|;
name|char
modifier|*
name|fname
decl_stmt|;
name|fname
operator|=
name|get_argtypes
argument_list|(
name|p
argument_list|,
operator|&
name|at0
argument_list|,
operator|&
name|at1
argument_list|)
expr_stmt|;
name|rp
operator|=
name|p
operator|->
name|rightp
expr_stmt|;
name|arglist
operator|=
name|rp
operator|&&
name|rp
operator|->
name|tag
operator|==
name|TLIST
condition|?
name|rp
operator|->
name|listblock
operator|.
name|listp
else|:
literal|0
expr_stmt|;
name|save_argtypes
argument_list|(
name|arglist
argument_list|,
name|at0
argument_list|,
name|at1
argument_list|,
name|p
operator|->
name|opcode
operator|==
name|OPCCALL
argument_list|,
name|fname
argument_list|,
name|p
operator|->
name|leftp
operator|->
name|addrblock
operator|.
name|vstg
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* putcall - fix up the argument list, and write out the invocation.   p    is expected to be initialized and point to an OPCALL or OPCCALL    expression.  The return value is a pointer to a temporary holding the    result of a COMPLEX or CHARACTER operation, or NULL. */
end_comment

begin_function
name|LOCAL
name|expptr
ifdef|#
directive|ifdef
name|KR_headers
name|putcall
parameter_list|(
name|p0
parameter_list|,
name|temp
parameter_list|)
name|expptr
name|p0
decl_stmt|;
name|Addrp
modifier|*
name|temp
decl_stmt|;
else|#
directive|else
function|putcall
parameter_list|(
name|expptr
name|p0
parameter_list|,
name|Addrp
modifier|*
name|temp
parameter_list|)
endif|#
directive|endif
block|{
specifier|register
name|Exprp
name|p
init|=
operator|(
name|Exprp
operator|)
name|p0
decl_stmt|;
name|chainp
name|arglist
decl_stmt|;
comment|/* Pointer to actual arguments, if any */
name|chainp
name|charsp
decl_stmt|;
comment|/* List of copies of the variables which 				   hold the lengths of character 				   parameters (other than procedure 				   parameters) */
name|chainp
name|cp
decl_stmt|;
comment|/* Iterator over argument lists */
specifier|register
name|expptr
name|q
decl_stmt|;
comment|/* Pointer to the current argument */
name|Addrp
name|fval
decl_stmt|;
comment|/* Function return value */
name|int
name|type
decl_stmt|;
comment|/* type of the call - presumably this was 				   set elsewhere */
name|int
name|byvalue
decl_stmt|;
comment|/* True iff we don't want to massage the 				   parameter list, since we're calling a C 				   library routine */
name|char
modifier|*
name|s
decl_stmt|;
name|Argtypes
modifier|*
name|at
decl_stmt|,
modifier|*
modifier|*
name|at0
decl_stmt|,
modifier|*
modifier|*
name|at1
decl_stmt|;
name|Atype
modifier|*
name|At
decl_stmt|,
modifier|*
name|Ate
decl_stmt|;
name|type
operator|=
name|p
operator|->
name|vtype
expr_stmt|;
name|charsp
operator|=
name|NULL
expr_stmt|;
name|byvalue
operator|=
operator|(
name|p
operator|->
name|opcode
operator|==
name|OPCCALL
operator|)
expr_stmt|;
comment|/* Verify the actual parameters */
if|if
condition|(
name|p
operator|==
operator|(
name|Exprp
operator|)
name|NULL
condition|)
name|err
argument_list|(
literal|"putcall:  NULL call expression"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|->
name|tag
operator|!=
name|TEXPR
condition|)
name|erri
argument_list|(
literal|"putcall:  expected TEXPR, got '%d'"
argument_list|,
name|p
operator|->
name|tag
argument_list|)
expr_stmt|;
comment|/* Find the argument list */
if|if
condition|(
name|p
operator|->
name|rightp
operator|&&
name|p
operator|->
name|rightp
operator|->
name|tag
operator|==
name|TLIST
condition|)
name|arglist
operator|=
name|p
operator|->
name|rightp
operator|->
name|listblock
operator|.
name|listp
expr_stmt|;
else|else
name|arglist
operator|=
name|NULL
expr_stmt|;
comment|/* Count the number of explicit arguments, including lengths of character    variables */
if|if
condition|(
operator|!
name|byvalue
condition|)
block|{
name|get_argtypes
argument_list|(
name|p
argument_list|,
operator|&
name|at0
argument_list|,
operator|&
name|at1
argument_list|)
expr_stmt|;
name|At
operator|=
name|Ate
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|at
operator|=
operator|*
name|at0
operator|)
operator|&&
name|at
operator|->
name|nargs
operator|>=
literal|0
condition|)
block|{
name|At
operator|=
name|at
operator|->
name|atypes
expr_stmt|;
name|Ate
operator|=
name|At
operator|+
name|at
operator|->
name|nargs
expr_stmt|;
name|At
operator|+=
name|init_ac
index|[
name|type
index|]
expr_stmt|;
block|}
for|for
control|(
name|cp
operator|=
name|arglist
init|;
name|cp
condition|;
name|cp
operator|=
name|cp
operator|->
name|nextp
control|)
block|{
name|q
operator|=
operator|(
name|expptr
operator|)
name|cp
operator|->
name|datap
expr_stmt|;
if|if
condition|(
name|ISCONST
argument_list|(
name|q
argument_list|)
condition|)
block|{
comment|/* Even constants are passed by reference, so we need to put them in the    literal table */
name|q
operator|=
operator|(
name|expptr
operator|)
name|putconst
argument_list|(
operator|(
name|Constp
operator|)
name|q
argument_list|)
expr_stmt|;
name|cp
operator|->
name|datap
operator|=
operator|(
name|char
operator|*
operator|)
name|q
expr_stmt|;
block|}
comment|/* Save the length expression of character variables (NOT character    procedures) for the end of the argument list */
if|if
condition|(
name|ISCHAR
argument_list|(
name|q
argument_list|)
operator|&&
operator|(
name|q
operator|->
name|headblock
operator|.
name|vclass
operator|!=
name|CLPROC
operator|||
name|q
operator|->
name|headblock
operator|.
name|vstg
operator|==
name|STGARG
operator|&&
name|q
operator|->
name|tag
operator|==
name|TADDR
operator|&&
name|q
operator|->
name|addrblock
operator|.
name|uname_tag
operator|==
name|UNAM_NAME
operator|&&
name|q
operator|->
name|addrblock
operator|.
name|user
operator|.
name|name
operator|->
name|vprocclass
operator|==
name|PTHISPROC
operator|)
operator|&&
operator|(
operator|!
name|At
operator|||
name|At
operator|->
name|type
operator|%
literal|100
operator|%
name|TYSUBR
operator|==
name|TYCHAR
operator|)
condition|)
block|{
name|p0
operator|=
name|cpexpr
argument_list|(
name|q
operator|->
name|headblock
operator|.
name|vleng
argument_list|)
expr_stmt|;
name|charsp
operator|=
name|mkchain
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p0
argument_list|,
name|charsp
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|headblock
operator|.
name|vclass
operator|==
name|CLUNKNOWN
operator|&&
name|q
operator|->
name|headblock
operator|.
name|vstg
operator|==
name|STGARG
condition|)
name|q
operator|->
name|addrblock
operator|.
name|user
operator|.
name|name
operator|->
name|vpassed
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|q
operator|->
name|tag
operator|==
name|TADDR
operator|&&
name|q
operator|->
name|addrblock
operator|.
name|uname_tag
operator|==
name|UNAM_CONST
condition|)
name|p0
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
operator|+=
name|q
operator|->
name|addrblock
operator|.
name|user
operator|.
name|Const
operator|.
name|ccp1
operator|.
name|blanks
expr_stmt|;
block|}
if|if
condition|(
name|At
operator|&&
operator|++
name|At
operator|==
name|Ate
condition|)
name|At
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|charsp
operator|=
name|revchain
argument_list|(
name|charsp
argument_list|)
expr_stmt|;
comment|/* If the routine is a CHARACTER function ... */
if|if
condition|(
name|type
operator|==
name|TYCHAR
condition|)
block|{
if|if
condition|(
name|ISICON
argument_list|(
name|p
operator|->
name|vleng
argument_list|)
condition|)
block|{
comment|/* Allocate a temporary to hold the return value of the function */
name|fval
operator|=
name|mktmp
argument_list|(
name|TYCHAR
argument_list|,
name|p
operator|->
name|vleng
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|err
argument_list|(
literal|"adjustable character function"
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
condition|)
operator|*
name|temp
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
comment|/* If the routine is a COMPLEX function ... */
elseif|else
if|if
condition|(
name|ISCOMPLEX
argument_list|(
name|type
argument_list|)
condition|)
name|fval
operator|=
name|mktmp
argument_list|(
name|type
argument_list|,
name|ENULL
argument_list|)
expr_stmt|;
else|else
name|fval
operator|=
name|NULL
expr_stmt|;
comment|/* Write the function name, without taking its address */
name|p
operator|->
name|leftp
operator|=
name|putx
argument_list|(
name|fixtype
argument_list|(
name|putaddr
argument_list|(
name|p
operator|->
name|leftp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fval
condition|)
block|{
name|chainp
name|prepend
decl_stmt|;
comment|/* Prepend a copy of the function return value buffer out as the first    argument. */
name|prepend
operator|=
name|mkchain
argument_list|(
operator|(
name|char
operator|*
operator|)
name|putx
argument_list|(
name|putaddr
argument_list|(
name|cpexpr
argument_list|(
operator|(
name|expptr
operator|)
name|fval
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
comment|/* If it's a character function, also prepend the length of the result */
if|if
condition|(
name|type
operator|==
name|TYCHAR
condition|)
block|{
name|prepend
operator|->
name|nextp
operator|=
name|mkchain
argument_list|(
operator|(
name|char
operator|*
operator|)
name|putx
argument_list|(
name|mkconv
argument_list|(
name|TYLENG
argument_list|,
name|p
operator|->
name|vleng
argument_list|)
argument_list|)
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|q
operator|=
name|p
operator|->
name|rightp
operator|)
condition|)
name|p
operator|->
name|rightp
operator|=
name|q
operator|=
operator|(
name|expptr
operator|)
name|mklist
argument_list|(
name|CHNULL
argument_list|)
expr_stmt|;
name|q
operator|->
name|listblock
operator|.
name|listp
operator|=
name|prepend
expr_stmt|;
block|}
comment|/* Scan through the fortran argument list */
for|for
control|(
name|cp
operator|=
name|arglist
init|;
name|cp
condition|;
name|cp
operator|=
name|cp
operator|->
name|nextp
control|)
block|{
name|q
operator|=
call|(
name|expptr
call|)
argument_list|(
name|cp
operator|->
name|datap
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|==
name|ENULL
condition|)
name|err
argument_list|(
literal|"putcall:  NULL argument"
argument_list|)
expr_stmt|;
comment|/* call putaddr only when we've got a parameter for a C routine or a    memory resident parameter */
if|if
condition|(
name|q
operator|->
name|tag
operator|==
name|TCONST
operator|&&
operator|!
name|byvalue
condition|)
name|q
operator|=
operator|(
name|expptr
operator|)
name|putconst
argument_list|(
operator|(
name|Constp
operator|)
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|tag
operator|==
name|TADDR
operator|&&
operator|(
name|byvalue
operator|||
name|q
operator|->
name|addrblock
operator|.
name|vstg
operator|!=
name|STGREG
operator|)
condition|)
block|{
if|if
condition|(
name|q
operator|->
name|addrblock
operator|.
name|parenused
operator|&&
operator|!
name|byvalue
operator|&&
name|q
operator|->
name|headblock
operator|.
name|vtype
operator|!=
name|TYCHAR
condition|)
goto|goto
name|make_copy
goto|;
name|cp
operator|->
name|datap
operator|=
operator|(
name|char
operator|*
operator|)
name|putaddr
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ISCOMPLEX
argument_list|(
name|q
operator|->
name|headblock
operator|.
name|vtype
argument_list|)
condition|)
name|cp
operator|->
name|datap
operator|=
operator|(
name|char
operator|*
operator|)
name|putx
argument_list|(
name|fixtype
argument_list|(
name|putcxop
argument_list|(
name|q
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ISCHAR
argument_list|(
name|q
argument_list|)
condition|)
name|cp
operator|->
name|datap
operator|=
operator|(
name|char
operator|*
operator|)
name|putx
argument_list|(
name|fixtype
argument_list|(
operator|(
name|expptr
operator|)
name|putchop
argument_list|(
name|q
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|ISERROR
argument_list|(
name|q
argument_list|)
condition|)
block|{
if|if
condition|(
name|byvalue
condition|)
block|{
if|if
condition|(
name|q
operator|->
name|tag
operator|==
name|TEXPR
operator|&&
name|q
operator|->
name|exprblock
operator|.
name|opcode
operator|==
name|OPCONV
condition|)
block|{
if|if
condition|(
name|ISCOMPLEX
argument_list|(
name|q
operator|->
name|exprblock
operator|.
name|leftp
operator|->
name|headblock
operator|.
name|vtype
argument_list|)
operator|&&
name|q
operator|->
name|exprblock
operator|.
name|leftp
operator|->
name|tag
operator|==
name|TEXPR
condition|)
name|q
operator|->
name|exprblock
operator|.
name|leftp
operator|=
name|putcxop
argument_list|(
name|q
operator|->
name|exprblock
operator|.
name|leftp
argument_list|)
expr_stmt|;
else|else
name|q
operator|->
name|exprblock
operator|.
name|leftp
operator|=
name|putx
argument_list|(
name|q
operator|->
name|exprblock
operator|.
name|leftp
argument_list|)
expr_stmt|;
block|}
else|else
name|cp
operator|->
name|datap
operator|=
operator|(
name|char
operator|*
operator|)
name|putx
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|q
operator|->
name|tag
operator|==
name|TEXPR
operator|&&
name|q
operator|->
name|exprblock
operator|.
name|opcode
operator|==
name|OPCHARCAST
condition|)
name|cp
operator|->
name|datap
operator|=
operator|(
name|char
operator|*
operator|)
name|putx
argument_list|(
name|q
argument_list|)
expr_stmt|;
else|else
block|{
name|expptr
name|t
decl_stmt|,
name|t1
decl_stmt|;
comment|/* If we've got a register parameter, or (maybe?) a constant, save it in a    temporary first */
name|make_copy
label|:
name|t
operator|=
operator|(
name|expptr
operator|)
name|mktmp
argument_list|(
name|q
operator|->
name|headblock
operator|.
name|vtype
argument_list|,
name|q
operator|->
name|headblock
operator|.
name|vleng
argument_list|)
expr_stmt|;
comment|/* Assign to temporary variables before invoking the subroutine or    function */
name|t1
operator|=
name|putassign
argument_list|(
name|cpexpr
argument_list|(
name|t
argument_list|)
argument_list|,
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|doin_setbound
condition|)
name|t
operator|=
name|mkexpr
argument_list|(
name|OPCOMMA_ARG
argument_list|,
name|t1
argument_list|,
name|t
argument_list|)
expr_stmt|;
else|else
name|putout
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|cp
operator|->
name|datap
operator|=
operator|(
name|char
operator|*
operator|)
name|t
expr_stmt|;
block|}
comment|/* else */
block|}
comment|/* if !ISERROR(q) */
block|}
comment|/* Now adjust the lengths of the CHARACTER parameters */
for|for
control|(
name|cp
operator|=
name|charsp
init|;
name|cp
condition|;
name|cp
operator|=
name|cp
operator|->
name|nextp
control|)
name|cp
operator|->
name|datap
operator|=
operator|(
name|char
operator|*
operator|)
name|addrfix
argument_list|(
name|putx
argument_list|(
comment|/* in case MAIN has a character*(*)... */
operator|(
name|s
operator|=
name|cp
operator|->
name|datap
operator|)
condition|?
name|mkconv
argument_list|(
name|TYLENG
argument_list|,
operator|(
name|expptr
operator|)
name|s
argument_list|)
else|:
name|ICON
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ... and add them to the end of the argument list */
name|hookup
argument_list|(
name|arglist
argument_list|,
name|charsp
argument_list|)
expr_stmt|;
comment|/* Return the name of the temporary used to hold the results, if any was    necessary. */
if|if
condition|(
name|temp
condition|)
operator|*
name|temp
operator|=
name|fval
expr_stmt|;
else|else
name|frexpr
argument_list|(
operator|(
name|expptr
operator|)
name|fval
argument_list|)
expr_stmt|;
name|saveargtypes
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|expptr
operator|)
name|p
return|;
block|}
end_function

begin_comment
comment|/* putmnmx -- Put min or max.   p   must point to an EXPR, not just a    CONST */
end_comment

begin_function
name|LOCAL
name|expptr
ifdef|#
directive|ifdef
name|KR_headers
name|putmnmx
parameter_list|(
name|p
parameter_list|)
specifier|register
name|expptr
name|p
decl_stmt|;
else|#
directive|else
function|putmnmx
parameter_list|(
specifier|register
name|expptr
name|p
parameter_list|)
endif|#
directive|endif
block|{
name|int
name|op
decl_stmt|,
name|op2
decl_stmt|,
name|type
decl_stmt|;
name|expptr
name|arg
decl_stmt|,
name|qp
decl_stmt|,
name|temp
decl_stmt|;
name|chainp
name|p0
decl_stmt|,
name|p1
decl_stmt|;
name|Addrp
name|sp
decl_stmt|,
name|tp
decl_stmt|;
name|char
name|comment_buf
index|[
literal|80
index|]
decl_stmt|;
name|char
modifier|*
name|what
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|tag
operator|!=
name|TEXPR
condition|)
name|badtag
argument_list|(
literal|"putmnmx"
argument_list|,
name|p
operator|->
name|tag
argument_list|)
expr_stmt|;
name|type
operator|=
name|p
operator|->
name|exprblock
operator|.
name|vtype
expr_stmt|;
name|op
operator|=
name|p
operator|->
name|exprblock
operator|.
name|opcode
expr_stmt|;
name|op2
operator|=
name|op
operator|==
name|OPMIN
condition|?
name|OPMIN2
else|:
name|OPMAX2
expr_stmt|;
name|p0
operator|=
name|p
operator|->
name|exprblock
operator|.
name|leftp
operator|->
name|listblock
operator|.
name|listp
expr_stmt|;
name|free
argument_list|(
call|(
name|charptr
call|)
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|leftp
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|charptr
operator|)
name|p
argument_list|)
expr_stmt|;
comment|/* special case for two addressable operands */
if|if
condition|(
name|addressable
argument_list|(
operator|(
name|expptr
operator|)
name|p0
operator|->
name|datap
argument_list|)
operator|&&
operator|(
name|p1
operator|=
name|p0
operator|->
name|nextp
operator|)
operator|&&
name|addressable
argument_list|(
operator|(
name|expptr
operator|)
name|p1
operator|->
name|datap
argument_list|)
operator|&&
operator|!
name|p1
operator|->
name|nextp
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|TYREAL
operator|&&
name|forcedouble
condition|)
name|op2
operator|=
name|op
operator|==
name|OPMIN
condition|?
name|OPDMIN
else|:
name|OPDMAX
expr_stmt|;
name|p
operator|=
name|mkexpr
argument_list|(
name|op2
argument_list|,
name|mkconv
argument_list|(
name|type
argument_list|,
name|cpexpr
argument_list|(
operator|(
name|expptr
operator|)
name|p0
operator|->
name|datap
argument_list|)
argument_list|)
argument_list|,
name|mkconv
argument_list|(
name|type
argument_list|,
name|cpexpr
argument_list|(
operator|(
name|expptr
operator|)
name|p1
operator|->
name|datap
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|frchain
argument_list|(
operator|&
name|p0
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
comment|/* general case */
name|sp
operator|=
name|mktmp
argument_list|(
name|type
argument_list|,
name|ENULL
argument_list|)
expr_stmt|;
comment|/* We only need a second temporary if the arg list has an unaddressable    value */
name|tp
operator|=
operator|(
name|Addrp
operator|)
name|NULL
expr_stmt|;
name|qp
operator|=
name|ENULL
expr_stmt|;
for|for
control|(
name|p1
operator|=
name|p0
operator|->
name|nextp
init|;
name|p1
condition|;
name|p1
operator|=
name|p1
operator|->
name|nextp
control|)
if|if
condition|(
operator|!
name|addressable
argument_list|(
operator|(
name|expptr
operator|)
name|p1
operator|->
name|datap
argument_list|)
condition|)
block|{
name|tp
operator|=
name|mktmp
argument_list|(
name|type
argument_list|,
name|ENULL
argument_list|)
expr_stmt|;
name|qp
operator|=
name|mkexpr
argument_list|(
name|op2
argument_list|,
name|cpexpr
argument_list|(
operator|(
name|expptr
operator|)
name|sp
argument_list|)
argument_list|,
name|cpexpr
argument_list|(
operator|(
name|expptr
operator|)
name|tp
argument_list|)
argument_list|)
expr_stmt|;
name|qp
operator|=
name|fixexpr
argument_list|(
operator|(
name|Exprp
operator|)
name|qp
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* if */
comment|/* Now output the appropriate number of assignments and comparisons.  Min    and max are implemented by the simple O(n) algorithm:  	min (a, b, c, d) ==> 	{<type> t1, t2;  	    t1 = a; 	    t2 = b; t1 = (t1< t2) ? t1 : t2; 	    t2 = c; t1 = (t1< t2) ? t1 : t2; 	    t2 = d; t1 = (t1< t2) ? t1 : t2; 	} */
if|if
condition|(
operator|!
name|doin_setbound
condition|)
block|{
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|OPLT
case|:
case|case
name|OPMIN
case|:
case|case
name|OPDMIN
case|:
case|case
name|OPMIN2
case|:
name|what
operator|=
literal|"IN"
expr_stmt|;
break|break;
default|default:
name|what
operator|=
literal|"AX"
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|comment_buf
argument_list|,
literal|"Computing M%s"
argument_list|,
name|what
argument_list|)
expr_stmt|;
name|p1_comment
argument_list|(
name|comment_buf
argument_list|)
expr_stmt|;
block|}
name|p1
operator|=
name|p0
operator|->
name|nextp
expr_stmt|;
name|temp
operator|=
operator|(
name|expptr
operator|)
name|p0
operator|->
name|datap
expr_stmt|;
if|if
condition|(
name|addressable
argument_list|(
name|temp
argument_list|)
operator|&&
name|addressable
argument_list|(
operator|(
name|expptr
operator|)
name|p1
operator|->
name|datap
argument_list|)
condition|)
block|{
name|p
operator|=
name|mkconv
argument_list|(
name|type
argument_list|,
name|cpexpr
argument_list|(
name|temp
argument_list|)
argument_list|)
expr_stmt|;
name|arg
operator|=
name|mkconv
argument_list|(
name|type
argument_list|,
name|cpexpr
argument_list|(
operator|(
name|expptr
operator|)
name|p1
operator|->
name|datap
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|=
name|mkexpr
argument_list|(
name|op2
argument_list|,
name|p
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ISCONST
argument_list|(
name|temp
argument_list|)
condition|)
name|temp
operator|=
name|fixexpr
argument_list|(
operator|(
name|Exprp
operator|)
name|temp
argument_list|)
expr_stmt|;
name|p1
operator|=
name|p1
operator|->
name|nextp
expr_stmt|;
block|}
name|p
operator|=
name|putassign
argument_list|(
name|cpexpr
argument_list|(
operator|(
name|expptr
operator|)
name|sp
argument_list|)
argument_list|,
name|temp
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|p1
condition|;
name|p1
operator|=
name|p1
operator|->
name|nextp
control|)
block|{
if|if
condition|(
name|addressable
argument_list|(
operator|(
name|expptr
operator|)
name|p1
operator|->
name|datap
argument_list|)
condition|)
block|{
name|arg
operator|=
name|mkconv
argument_list|(
name|type
argument_list|,
name|cpexpr
argument_list|(
operator|(
name|expptr
operator|)
name|p1
operator|->
name|datap
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|=
name|mkexpr
argument_list|(
name|op2
argument_list|,
name|cpexpr
argument_list|(
operator|(
name|expptr
operator|)
name|sp
argument_list|)
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|temp
operator|=
name|fixexpr
argument_list|(
operator|(
name|Exprp
operator|)
name|temp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|temp
operator|=
operator|(
name|expptr
operator|)
name|cpexpr
argument_list|(
name|qp
argument_list|)
expr_stmt|;
name|p
operator|=
name|mkexpr
argument_list|(
name|OPCOMMA
argument_list|,
name|p
argument_list|,
name|putassign
argument_list|(
name|cpexpr
argument_list|(
operator|(
name|expptr
operator|)
name|tp
argument_list|)
argument_list|,
operator|(
name|expptr
operator|)
name|p1
operator|->
name|datap
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* else */
if|if
condition|(
name|p1
operator|->
name|nextp
condition|)
name|p
operator|=
name|mkexpr
argument_list|(
name|OPCOMMA
argument_list|,
name|p
argument_list|,
name|putassign
argument_list|(
name|cpexpr
argument_list|(
operator|(
name|expptr
operator|)
name|sp
argument_list|)
argument_list|,
name|temp
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|type
operator|==
name|TYREAL
operator|&&
name|forcedouble
condition|)
name|temp
operator|->
name|exprblock
operator|.
name|opcode
operator|=
name|op
operator|==
name|OPMIN
condition|?
name|OPDMIN
else|:
name|OPDMAX
expr_stmt|;
if|if
condition|(
name|doin_setbound
condition|)
name|p
operator|=
name|mkexpr
argument_list|(
name|OPCOMMA
argument_list|,
name|p
argument_list|,
name|temp
argument_list|)
expr_stmt|;
else|else
block|{
name|putout
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|putx
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|qp
condition|)
name|frexpr
argument_list|(
name|qp
argument_list|)
expr_stmt|;
block|}
comment|/* else */
block|}
comment|/* for */
name|frchain
argument_list|(
operator|&
name|p0
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|putwhile
parameter_list|(
name|p
parameter_list|)
name|expptr
name|p
decl_stmt|;
else|#
directive|else
function|putwhile
parameter_list|(
name|expptr
name|p
parameter_list|)
endif|#
directive|endif
block|{
name|long
name|where
decl_stmt|;
name|int
name|k
decl_stmt|,
name|n
decl_stmt|;
if|if
condition|(
name|wh_next
operator|>=
name|wh_last
condition|)
block|{
name|k
operator|=
name|wh_last
operator|-
name|wh_first
expr_stmt|;
name|n
operator|=
name|k
operator|+
literal|100
expr_stmt|;
name|wh_next
operator|=
name|mem
argument_list|(
name|n
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wh_last
operator|=
name|wh_first
operator|+
name|n
expr_stmt|;
if|if
condition|(
name|k
condition|)
name|memcpy
argument_list|(
name|wh_next
argument_list|,
name|wh_first
argument_list|,
name|k
argument_list|)
expr_stmt|;
name|wh_first
operator|=
name|wh_next
expr_stmt|;
name|wh_next
operator|+=
name|k
expr_stmt|;
name|wh_last
operator|=
name|wh_first
operator|+
name|n
expr_stmt|;
block|}
name|p1put
argument_list|(
name|P1_WHILE1START
argument_list|)
expr_stmt|;
name|where
operator|=
name|ftell
argument_list|(
name|pass1_file
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ISLOGICAL
argument_list|(
operator|(
name|k
operator|=
operator|(
name|p
operator|=
name|fixtype
argument_list|(
name|p
argument_list|)
operator|)
operator|->
name|headblock
operator|.
name|vtype
operator|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|k
operator|!=
name|TYERROR
condition|)
name|err
argument_list|(
literal|"non-logical expression in DO WHILE statement"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p
operator|=
name|putx
argument_list|(
name|p
argument_list|)
expr_stmt|;
operator|*
name|wh_next
operator|++
operator|=
name|ftell
argument_list|(
name|pass1_file
argument_list|)
operator|>
name|where
expr_stmt|;
name|p1put
argument_list|(
name|P1_WHILE2START
argument_list|)
expr_stmt|;
name|p1_expr
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

