begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**************************************************************** Copyright 1990, 1991, 1993, 1994 by AT&T, Lucent Technologies and Bellcore.  Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that the copyright notice and this permission notice and warranty disclaimer appear in supporting documentation, and that the names of AT&T, Bell Laboratories, Lucent or Bellcore or any of their entities not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  AT&T, Lucent and Bellcore disclaim all warranties with regard to this software, including all implied warranties of merchantability and fitness.  In no event shall AT&T, Lucent or Bellcore be liable for any special, indirect or consequential damages or any damages whatsoever resulting from loss of use, data or profits, whether in an action of contract, negligence or other tortious action, arising out of or in connection with the use or performance of this software. ****************************************************************/
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"names.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|KR_headers
end_ifndef

begin_include
include|#
directive|include
file|"stdarg.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|TOO_LONG_INDENT
value|(2 * tab_size)
end_define

begin_define
define|#
directive|define
name|MAX_INDENT
value|44
end_define

begin_define
define|#
directive|define
name|MIN_INDENT
value|22
end_define

begin_decl_stmt
specifier|static
name|int
name|last_was_newline
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|sharp_line
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|indent
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|in_comment
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|in_define
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|gflag1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|filename
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ind_printf
name|Argdcl
argument_list|(
operator|(
name|int
operator|,
name|FILE
operator|*
operator|,
name|char
operator|*
operator|,
name|va_list
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|write_indent
parameter_list|(
name|fp
parameter_list|,
name|use_indent
parameter_list|,
name|extra_indent
parameter_list|,
name|start
parameter_list|,
name|end
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
name|int
name|use_indent
decl_stmt|;
name|int
name|extra_indent
decl_stmt|;
name|char
modifier|*
name|start
decl_stmt|;
name|char
modifier|*
name|end
decl_stmt|;
else|#
directive|else
function|write_indent
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|int
name|use_indent
parameter_list|,
name|int
name|extra_indent
parameter_list|,
name|char
modifier|*
name|start
parameter_list|,
name|char
modifier|*
name|end
parameter_list|)
endif|#
directive|endif
block|{
name|int
name|ind
decl_stmt|,
name|tab
decl_stmt|;
if|if
condition|(
name|sharp_line
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"#line %ld \"%s\"\n"
argument_list|,
name|lineno
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|sharp_line
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|in_define
operator|==
literal|1
condition|)
block|{
name|in_define
operator|=
literal|2
expr_stmt|;
name|use_indent
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|last_was_newline
operator|&&
name|use_indent
condition|)
block|{
if|if
condition|(
operator|*
name|start
operator|==
literal|'\n'
condition|)
do|do
block|{
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|start
operator|>
name|end
condition|)
return|return;
block|}
do|while
condition|(
operator|*
name|start
operator|==
literal|'\n'
condition|)
do|;
name|ind
operator|=
name|indent
operator|<=
name|MAX_INDENT
condition|?
name|indent
else|:
name|MIN_INDENT
operator|+
name|indent
operator|%
operator|(
name|MAX_INDENT
operator|-
name|MIN_INDENT
operator|)
expr_stmt|;
name|tab
operator|=
name|ind
operator|+
name|extra_indent
expr_stmt|;
while|while
condition|(
name|tab
operator|>
literal|7
condition|)
block|{
name|putc
argument_list|(
literal|'\t'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|tab
operator|-=
literal|8
expr_stmt|;
block|}
comment|/* while */
while|while
condition|(
name|tab
operator|--
operator|>
literal|0
condition|)
name|putc
argument_list|(
literal|' '
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
comment|/* if last_was_newline */
while|while
condition|(
name|start
operator|<=
name|end
condition|)
name|putc
argument_list|(
operator|*
name|start
operator|++
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* write_indent */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|KR_headers
end_ifdef

begin_comment
comment|/*VARARGS2*/
end_comment

begin_function
name|void
name|margin_printf
parameter_list|(
name|fp
parameter_list|,
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|,
name|e
parameter_list|,
name|f
parameter_list|,
name|g
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
modifier|*
name|a
decl_stmt|;
name|long
name|b
decl_stmt|,
name|c
decl_stmt|,
name|d
decl_stmt|,
name|e
decl_stmt|,
name|f
decl_stmt|,
name|g
decl_stmt|;
block|{
name|ind_printf
argument_list|(
literal|0
argument_list|,
name|fp
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|e
argument_list|,
name|f
argument_list|,
name|g
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* margin_printf */
end_comment

begin_comment
comment|/*VARARGS2*/
end_comment

begin_function
name|void
name|nice_printf
parameter_list|(
name|fp
parameter_list|,
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|,
name|e
parameter_list|,
name|f
parameter_list|,
name|g
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
modifier|*
name|a
decl_stmt|;
name|long
name|b
decl_stmt|,
name|c
decl_stmt|,
name|d
decl_stmt|,
name|e
decl_stmt|,
name|f
decl_stmt|,
name|g
decl_stmt|;
block|{
name|ind_printf
argument_list|(
literal|1
argument_list|,
name|fp
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|e
argument_list|,
name|f
argument_list|,
name|g
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* nice_printf */
end_comment

begin_define
define|#
directive|define
name|SPRINTF
parameter_list|(
name|x
parameter_list|,
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|,
name|e
parameter_list|,
name|f
parameter_list|,
name|g
parameter_list|)
value|sprintf(x,a,b,c,d,e,f,g)
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* if (!defined(KR_HEADERS)) */
end_comment

begin_define
define|#
directive|define
name|SPRINTF
parameter_list|(
name|x
parameter_list|,
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|,
name|e
parameter_list|,
name|f
parameter_list|,
name|g
parameter_list|)
value|vsprintf(x,a,ap)
end_define

begin_function
name|void
name|margin_printf
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|ind_printf
argument_list|(
literal|0
argument_list|,
name|fp
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|nice_printf
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|ind_printf
argument_list|(
literal|1
argument_list|,
name|fp
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|max_line_len
value|c_output_line_length
end_define

begin_comment
comment|/* 74Number of characters allowed on an output 			           line.  This assumes newlines are handled 			           nicely, i.e. a newline after a full text 			           line on a terminal is ignored */
end_comment

begin_comment
comment|/* output_buf   holds the text of the next line to be printed.  It gets    flushed when a newline is printed.   next_slot   points to the next    available location in the output buffer, i.e. where the next call to    nice_printf will have its output stored */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|output_buf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|next_slot
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|string_start
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|word_start
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cursor_pos
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|In_string
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|np_init
parameter_list|(
name|Void
parameter_list|)
block|{
name|next_slot
operator|=
name|output_buf
operator|=
name|Alloc
argument_list|(
name|MAX_OUTPUT_SIZE
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|output_buf
argument_list|,
literal|0
argument_list|,
name|MAX_OUTPUT_SIZE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
ifdef|#
directive|ifdef
name|KR_headers
name|adjust_pointer_in_string
parameter_list|(
name|pointer
parameter_list|)
specifier|register
name|char
modifier|*
name|pointer
decl_stmt|;
else|#
directive|else
function|adjust_pointer_in_string
parameter_list|(
specifier|register
name|char
modifier|*
name|pointer
parameter_list|)
endif|#
directive|endif
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|s1
decl_stmt|,
modifier|*
name|se
decl_stmt|,
modifier|*
name|s0
decl_stmt|;
comment|/* arrange not to break \002 */
name|s1
operator|=
name|string_start
condition|?
name|string_start
else|:
name|output_buf
expr_stmt|;
for|for
control|(
name|s
operator|=
name|s1
init|;
name|s
operator|<
name|pointer
condition|;
name|s
operator|++
control|)
block|{
name|s0
operator|=
name|s1
expr_stmt|;
name|s1
operator|=
name|s
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'\\'
condition|)
block|{
name|se
operator|=
name|s
operator|++
operator|+
literal|4
expr_stmt|;
if|if
condition|(
name|se
operator|>
name|pointer
condition|)
break|break;
if|if
condition|(
operator|*
name|s
operator|<
literal|'0'
operator|||
operator|*
name|s
operator|>
literal|'7'
condition|)
continue|continue;
while|while
condition|(
operator|++
name|s
operator|<
name|se
condition|)
if|if
condition|(
operator|*
name|s
operator|<
literal|'0'
operator|||
operator|*
name|s
operator|>
literal|'7'
condition|)
break|break;
operator|--
name|s
expr_stmt|;
block|}
block|}
return|return
name|s0
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* ANSI says strcpy's behavior is undefined for overlapping args,  * so we roll our own fwd_strcpy: */
end_comment

begin_function
specifier|static
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|fwd_strcpy
parameter_list|(
name|t
parameter_list|,
name|s
parameter_list|)
specifier|register
name|char
modifier|*
name|t
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
else|#
directive|else
function|fwd_strcpy
parameter_list|(
specifier|register
name|char
modifier|*
name|t
parameter_list|,
specifier|register
name|char
modifier|*
name|s
parameter_list|)
endif|#
directive|endif
block|{
while|while
condition|(
operator|*
name|t
operator|++
operator|=
operator|*
name|s
operator|++
condition|)
empty_stmt|;
block|}
end_function

begin_comment
comment|/* isident -- true iff character could belong to a unit.  C allows    letters, numbers and underscores in identifiers.  This also doubles as    a check for numeric constants, since we include the decimal point and    minus sign.  The minus has to be here, since the constant "10e-2"    cannot be broken up.  The '.' also prevents structure references from    being broken, which is a quite acceptable side effect */
end_comment

begin_define
define|#
directive|define
name|isident
parameter_list|(
name|x
parameter_list|)
value|(Tr[x]& 1)
end_define

begin_define
define|#
directive|define
name|isntident
parameter_list|(
name|x
parameter_list|)
value|(!Tr[x])
end_define

begin_function
specifier|static
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|ind_printf
parameter_list|(
name|use_indent
parameter_list|,
name|fp
parameter_list|,
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|,
name|e
parameter_list|,
name|f
parameter_list|,
name|g
parameter_list|)
name|int
name|use_indent
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
modifier|*
name|a
decl_stmt|;
name|long
name|b
decl_stmt|,
name|c
decl_stmt|,
name|d
decl_stmt|,
name|e
decl_stmt|,
name|f
decl_stmt|,
name|g
decl_stmt|;
else|#
directive|else
function|ind_printf
parameter_list|(
name|int
name|use_indent
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
name|char
modifier|*
name|a
parameter_list|,
name|va_list
name|ap
parameter_list|)
endif|#
directive|endif
block|{
specifier|extern
name|int
name|max_line_len
decl_stmt|;
specifier|extern
name|FILEP
name|c_file
decl_stmt|;
specifier|extern
name|char
name|tr_tab
index|[]
decl_stmt|;
comment|/* in output.c */
specifier|register
name|char
modifier|*
name|Tr
init|=
name|tr_tab
decl_stmt|;
name|int
name|ch
decl_stmt|,
name|inc
decl_stmt|,
name|ind
decl_stmt|;
specifier|static
name|int
name|extra_indent
decl_stmt|,
name|last_indent
decl_stmt|,
name|set_cursor
init|=
literal|1
decl_stmt|;
name|cursor_pos
operator|+=
name|indent
operator|-
name|last_indent
expr_stmt|;
name|last_indent
operator|=
name|indent
expr_stmt|;
name|SPRINTF
argument_list|(
name|next_slot
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|e
argument_list|,
name|f
argument_list|,
name|g
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|!=
name|c_file
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s"
argument_list|,
name|next_slot
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* if fp != c_file */
do|do
block|{
name|char
modifier|*
name|pointer
decl_stmt|;
comment|/* The   for   loop will parse one output line */
if|if
condition|(
name|set_cursor
condition|)
block|{
name|ind
operator|=
name|indent
operator|<=
name|MAX_INDENT
condition|?
name|indent
else|:
name|MIN_INDENT
operator|+
name|indent
operator|%
operator|(
name|MAX_INDENT
operator|-
name|MIN_INDENT
operator|)
expr_stmt|;
name|cursor_pos
operator|=
name|ind
operator|+
name|extra_indent
expr_stmt|;
name|set_cursor
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|in_comment
condition|)
for|for
control|(
name|pointer
operator|=
name|next_slot
init|;
operator|*
name|pointer
operator|&&
operator|*
name|pointer
operator|!=
literal|'\n'
operator|&&
name|cursor_pos
operator|<=
name|max_line_len
condition|;
name|pointer
operator|++
control|)
name|cursor_pos
operator|++
expr_stmt|;
else|else
for|for
control|(
name|pointer
operator|=
name|next_slot
init|;
operator|*
name|pointer
operator|&&
operator|*
name|pointer
operator|!=
literal|'\n'
operator|&&
name|cursor_pos
operator|<=
name|max_line_len
condition|;
name|pointer
operator|++
control|)
block|{
comment|/* Update state variables here */
if|if
condition|(
name|In_string
condition|)
block|{
switch|switch
condition|(
operator|*
name|pointer
condition|)
block|{
case|case
literal|'\\'
case|:
if|if
condition|(
operator|++
name|cursor_pos
operator|>
name|max_line_len
condition|)
block|{
name|cursor_pos
operator|-=
literal|2
expr_stmt|;
operator|--
name|pointer
expr_stmt|;
goto|goto
name|overflow
goto|;
block|}
operator|++
name|pointer
expr_stmt|;
break|break;
case|case
literal|'"'
case|:
name|In_string
operator|=
literal|0
expr_stmt|;
name|word_start
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
switch|switch
condition|(
operator|*
name|pointer
condition|)
block|{
case|case
literal|'"'
case|:
if|if
condition|(
name|cursor_pos
operator|+
literal|5
operator|>
name|max_line_len
condition|)
block|{
name|word_start
operator|=
literal|0
expr_stmt|;
operator|--
name|pointer
expr_stmt|;
goto|goto
name|overflow
goto|;
block|}
name|In_string
operator|=
literal|1
expr_stmt|;
name|string_start
operator|=
name|word_start
operator|=
name|pointer
expr_stmt|;
break|break;
case|case
literal|'\''
case|:
if|if
condition|(
name|pointer
index|[
literal|1
index|]
operator|==
literal|'\\'
condition|)
if|if
condition|(
operator|(
name|ch
operator|=
name|pointer
index|[
literal|2
index|]
operator|)
operator|>=
literal|'0'
operator|&&
name|ch
operator|<=
literal|'7'
condition|)
for|for
control|(
name|inc
operator|=
literal|3
init|;
name|pointer
index|[
name|inc
index|]
operator|!=
literal|'\''
operator|&&
operator|++
name|inc
operator|<
literal|5
condition|;
control|)
empty_stmt|;
else|else
name|inc
operator|=
literal|3
expr_stmt|;
else|else
name|inc
operator|=
literal|2
expr_stmt|;
comment|/*debug*/
if|if
condition|(
name|pointer
index|[
name|inc
index|]
operator|!=
literal|'\''
condition|)
comment|/*debug*/
name|fatalstr
argument_list|(
literal|"Bad character constant %.10s"
argument_list|,
name|pointer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cursor_pos
operator|+=
name|inc
operator|)
operator|>
name|max_line_len
condition|)
block|{
name|cursor_pos
operator|-=
name|inc
expr_stmt|;
name|word_start
operator|=
literal|0
expr_stmt|;
operator|--
name|pointer
expr_stmt|;
goto|goto
name|overflow
goto|;
block|}
name|word_start
operator|=
name|pointer
expr_stmt|;
name|pointer
operator|+=
name|inc
expr_stmt|;
break|break;
case|case
literal|'\t'
case|:
name|cursor_pos
operator|=
literal|8
operator|*
operator|(
operator|(
name|cursor_pos
operator|+
literal|8
operator|)
operator|/
literal|8
operator|)
operator|-
literal|1
expr_stmt|;
break|break;
default|default:
block|{
comment|/* HACK  Assumes that all characters in an atomic C token will be written    at the same time.  Must check for tokens first, since '-' is considered    part of an identifier; checking isident first would mean breaking up "->" */
if|if
condition|(
name|word_start
condition|)
block|{
if|if
condition|(
name|isntident
argument_list|(
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|)
name|pointer
argument_list|)
condition|)
name|word_start
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isident
argument_list|(
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|)
name|pointer
argument_list|)
condition|)
name|word_start
operator|=
name|pointer
expr_stmt|;
break|break;
block|}
comment|/* default */
block|}
comment|/* switch */
name|cursor_pos
operator|++
expr_stmt|;
block|}
comment|/* for pointer = next_slot */
name|overflow
label|:
if|if
condition|(
operator|*
name|pointer
operator|==
literal|'\0'
condition|)
block|{
comment|/* The output line is not complete, so break out and don't output    anything.  The current line fragment will be stored in the buffer */
name|next_slot
operator|=
name|pointer
expr_stmt|;
break|break;
block|}
else|else
block|{
name|char
name|last_char
decl_stmt|;
name|int
name|in_string0
init|=
name|In_string
decl_stmt|;
comment|/* If the line was too long, move   pointer   back to the character before    the current word.  This allows line breaking on word boundaries.  Make    sure that 80 character comment lines get broken up somehow.  We assume    that any non-string 80 character identifier must be in a comment. */
if|if
condition|(
operator|*
name|pointer
operator|==
literal|'\n'
condition|)
name|in_define
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|word_start
operator|&&
name|word_start
operator|>
name|output_buf
condition|)
if|if
condition|(
name|In_string
condition|)
if|if
condition|(
name|string_start
operator|&&
name|pointer
operator|-
name|string_start
operator|<
literal|5
condition|)
name|pointer
operator|=
name|string_start
operator|-
literal|1
expr_stmt|;
else|else
block|{
name|pointer
operator|=
name|adjust_pointer_in_string
argument_list|(
name|pointer
argument_list|)
expr_stmt|;
name|string_start
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|word_start
operator|==
name|string_start
operator|&&
name|pointer
operator|-
name|string_start
operator|>=
literal|5
condition|)
block|{
name|pointer
operator|=
name|adjust_pointer_in_string
argument_list|(
name|next_slot
argument_list|)
expr_stmt|;
name|In_string
operator|=
literal|1
expr_stmt|;
name|string_start
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|pointer
operator|=
name|word_start
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|cursor_pos
operator|>
name|max_line_len
condition|)
block|{
ifndef|#
directive|ifndef
name|ANSI_Libraries
specifier|extern
name|char
modifier|*
name|strchr
parameter_list|()
function_decl|;
endif|#
directive|endif
if|if
condition|(
name|In_string
condition|)
block|{
name|pointer
operator|=
name|adjust_pointer_in_string
argument_list|(
name|pointer
argument_list|)
expr_stmt|;
if|if
condition|(
name|string_start
operator|&&
name|pointer
operator|>
name|string_start
condition|)
name|string_start
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strchr
argument_list|(
literal|"&*+-/<=>|"
argument_list|,
operator|*
name|pointer
argument_list|)
operator|&&
name|strchr
argument_list|(
literal|"!%&*+-/<=>^|"
argument_list|,
name|pointer
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
block|{
name|pointer
operator|-=
literal|2
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
literal|"<>"
argument_list|,
operator|*
name|pointer
argument_list|)
condition|)
comment|/*<<=,>>= */
name|pointer
operator|--
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|word_start
condition|)
while|while
condition|(
name|isident
argument_list|(
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|)
name|pointer
argument_list|)
condition|)
name|pointer
operator|++
expr_stmt|;
name|pointer
operator|--
expr_stmt|;
block|}
block|}
name|last_char
operator|=
operator|*
name|pointer
expr_stmt|;
name|write_indent
argument_list|(
name|fp
argument_list|,
name|use_indent
argument_list|,
name|extra_indent
argument_list|,
name|output_buf
argument_list|,
name|pointer
argument_list|)
expr_stmt|;
name|next_slot
operator|=
name|output_buf
expr_stmt|;
if|if
condition|(
name|In_string
operator|&&
operator|!
name|string_start
operator|&&
name|Ansi
operator|==
literal|1
operator|&&
name|last_char
operator|!=
literal|'\n'
condition|)
operator|*
name|next_slot
operator|++
operator|=
literal|'"'
expr_stmt|;
name|fwd_strcpy
argument_list|(
name|next_slot
argument_list|,
name|pointer
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* insert a line break */
if|if
condition|(
name|last_char
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|In_string
condition|)
name|last_was_newline
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|last_was_newline
operator|=
literal|1
expr_stmt|;
name|extra_indent
operator|=
literal|0
expr_stmt|;
name|sharp_line
operator|=
name|gflag1
expr_stmt|;
block|}
block|}
else|else
block|{
name|extra_indent
operator|=
name|TOO_LONG_INDENT
expr_stmt|;
if|if
condition|(
name|In_string
operator|&&
operator|!
name|string_start
condition|)
block|{
if|if
condition|(
name|Ansi
operator|==
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
name|gflag1
condition|?
literal|"\"\\\n"
else|:
literal|"\"\n"
argument_list|)
expr_stmt|;
name|use_indent
operator|=
literal|1
expr_stmt|;
name|last_was_newline
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\\\n"
argument_list|)
expr_stmt|;
name|last_was_newline
operator|=
literal|0
expr_stmt|;
block|}
name|In_string
operator|=
name|in_string0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|in_define
comment|/* | gflag1*/
condition|)
name|putc
argument_list|(
literal|'\\'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|last_was_newline
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* if *pointer != '\n' */
if|if
condition|(
name|In_string
operator|&&
name|Ansi
operator|!=
literal|1
operator|&&
operator|!
name|string_start
condition|)
name|cursor_pos
operator|=
literal|0
expr_stmt|;
else|else
name|set_cursor
operator|=
literal|1
expr_stmt|;
name|string_start
operator|=
name|word_start
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* else */
block|}
do|while
condition|(
operator|*
name|next_slot
condition|)
do|;
block|}
end_function

begin_comment
comment|/* ind_printf */
end_comment

end_unit

