begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**************************************************************** Copyright 1990, 1993 - 1995 by AT&T Bell Laboratories and Bellcore.  Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that the copyright notice and this permission notice and warranty disclaimer appear in supporting documentation, and that the names of AT&T Bell Laboratories or Bellcore or any of their entities not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  AT&T and Bellcore disclaim all warranties with regard to this software, including all implied warranties of merchantability and fitness.  In no event shall AT&T or Bellcore be liable for any special, indirect or consequential damages or any damages whatsoever resulting from loss of use, data or profits, whether in an action of contract, negligence or other tortious action, arising out of or in connection with the use or performance of this software. ****************************************************************/
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_comment
comment|/* ROUTINES CALLED DURING DATA AND PARAMETER STATEMENT PROCESSING */
end_comment

begin_decl_stmt
specifier|static
name|char
name|datafmt
index|[]
init|=
literal|"%s\t%09ld\t%d"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|cur_varname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* another initializer, called from parser */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|dataval
parameter_list|(
name|repp
parameter_list|,
name|valp
parameter_list|)
specifier|register
name|expptr
name|repp
decl_stmt|;
specifier|register
name|expptr
name|valp
decl_stmt|;
else|#
directive|else
function|dataval
parameter_list|(
specifier|register
name|expptr
name|repp
parameter_list|,
specifier|register
name|expptr
name|valp
parameter_list|)
endif|#
directive|endif
block|{
name|int
name|i
decl_stmt|,
name|nrep
decl_stmt|;
name|ftnint
name|elen
decl_stmt|;
specifier|register
name|Addrp
name|p
decl_stmt|;
if|if
condition|(
name|parstate
operator|<
name|INDATA
condition|)
block|{
name|frexpr
argument_list|(
name|repp
argument_list|)
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
if|if
condition|(
name|repp
operator|==
name|NULL
condition|)
name|nrep
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|ISICON
argument_list|(
name|repp
argument_list|)
operator|&&
name|repp
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
operator|>=
literal|0
condition|)
name|nrep
operator|=
name|repp
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
expr_stmt|;
else|else
block|{
name|err
argument_list|(
literal|"invalid repetition count in DATA statement"
argument_list|)
expr_stmt|;
name|frexpr
argument_list|(
name|repp
argument_list|)
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
name|frexpr
argument_list|(
name|repp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ISCONST
argument_list|(
name|valp
argument_list|)
condition|)
block|{
if|if
condition|(
name|valp
operator|->
name|tag
operator|==
name|TADDR
operator|&&
name|valp
operator|->
name|addrblock
operator|.
name|uname_tag
operator|==
name|UNAM_CONST
condition|)
block|{
comment|/* kludge */
name|frexpr
argument_list|(
name|valp
operator|->
name|addrblock
operator|.
name|memoffset
argument_list|)
expr_stmt|;
name|valp
operator|->
name|tag
operator|=
name|TCONST
expr_stmt|;
block|}
else|else
block|{
name|err
argument_list|(
literal|"non-constant initializer"
argument_list|)
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
block|}
if|if
condition|(
name|toomanyinit
condition|)
goto|goto
name|ret
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nrep
condition|;
operator|++
name|i
control|)
block|{
name|p
operator|=
name|nextdata
argument_list|(
operator|&
name|elen
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|err
argument_list|(
literal|"too many initializers"
argument_list|)
expr_stmt|;
name|toomanyinit
operator|=
name|YES
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
name|setdata
argument_list|(
operator|(
name|Addrp
operator|)
name|p
argument_list|,
operator|(
name|Constp
operator|)
name|valp
argument_list|,
name|elen
argument_list|)
expr_stmt|;
name|frexpr
argument_list|(
operator|(
name|expptr
operator|)
name|p
argument_list|)
expr_stmt|;
block|}
name|ret
label|:
name|frexpr
argument_list|(
name|valp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Addrp
ifdef|#
directive|ifdef
name|KR_headers
name|nextdata
parameter_list|(
name|elenp
parameter_list|)
name|ftnint
modifier|*
name|elenp
decl_stmt|;
else|#
directive|else
function|nextdata
parameter_list|(
name|ftnint
modifier|*
name|elenp
parameter_list|)
endif|#
directive|endif
block|{
specifier|register
name|struct
name|Impldoblock
modifier|*
name|ip
decl_stmt|;
name|struct
name|Primblock
modifier|*
name|pp
decl_stmt|;
specifier|register
name|Namep
name|np
decl_stmt|;
specifier|register
name|struct
name|Rplblock
modifier|*
name|rp
decl_stmt|;
name|tagptr
name|p
decl_stmt|;
name|expptr
name|neltp
decl_stmt|;
specifier|register
name|expptr
name|q
decl_stmt|;
name|int
name|skip
decl_stmt|;
name|ftnint
name|off
decl_stmt|,
name|vlen
decl_stmt|;
while|while
condition|(
name|curdtp
condition|)
block|{
name|p
operator|=
operator|(
name|tagptr
operator|)
name|curdtp
operator|->
name|datap
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|tag
operator|==
name|TIMPLDO
condition|)
block|{
name|ip
operator|=
operator|&
operator|(
name|p
operator|->
name|impldoblock
operator|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|implb
operator|==
name|NULL
operator|||
name|ip
operator|->
name|impub
operator|==
name|NULL
operator|||
name|ip
operator|->
name|varnp
operator|==
name|NULL
condition|)
name|fatali
argument_list|(
literal|"bad impldoblock 0%o"
argument_list|,
operator|(
name|int
operator|)
name|ip
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|isactive
condition|)
name|ip
operator|->
name|varvp
operator|->
name|Const
operator|.
name|ci
operator|+=
name|ip
operator|->
name|impdiff
expr_stmt|;
else|else
block|{
name|q
operator|=
name|fixtype
argument_list|(
name|cpexpr
argument_list|(
name|ip
operator|->
name|implb
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ISICON
argument_list|(
name|q
argument_list|)
condition|)
goto|goto
name|doerr
goto|;
name|ip
operator|->
name|varvp
operator|=
operator|(
name|Constp
operator|)
name|q
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|impstep
condition|)
block|{
name|q
operator|=
name|fixtype
argument_list|(
name|cpexpr
argument_list|(
name|ip
operator|->
name|impstep
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ISICON
argument_list|(
name|q
argument_list|)
condition|)
goto|goto
name|doerr
goto|;
name|ip
operator|->
name|impdiff
operator|=
name|q
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
expr_stmt|;
name|frexpr
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
else|else
name|ip
operator|->
name|impdiff
operator|=
literal|1
expr_stmt|;
name|q
operator|=
name|fixtype
argument_list|(
name|cpexpr
argument_list|(
name|ip
operator|->
name|impub
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ISICON
argument_list|(
name|q
argument_list|)
condition|)
goto|goto
name|doerr
goto|;
name|ip
operator|->
name|implim
operator|=
name|q
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
expr_stmt|;
name|frexpr
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|ip
operator|->
name|isactive
operator|=
name|YES
expr_stmt|;
name|rp
operator|=
name|ALLOC
argument_list|(
name|Rplblock
argument_list|)
expr_stmt|;
name|rp
operator|->
name|rplnextp
operator|=
name|rpllist
expr_stmt|;
name|rpllist
operator|=
name|rp
expr_stmt|;
name|rp
operator|->
name|rplnp
operator|=
name|ip
operator|->
name|varnp
expr_stmt|;
name|rp
operator|->
name|rplvp
operator|=
call|(
name|expptr
call|)
argument_list|(
name|ip
operator|->
name|varvp
argument_list|)
expr_stmt|;
name|rp
operator|->
name|rpltag
operator|=
name|TCONST
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ip
operator|->
name|impdiff
operator|>
literal|0
operator|&&
operator|(
name|ip
operator|->
name|varvp
operator|->
name|Const
operator|.
name|ci
operator|<=
name|ip
operator|->
name|implim
operator|)
operator|)
operator|||
operator|(
name|ip
operator|->
name|impdiff
operator|<
literal|0
operator|&&
operator|(
name|ip
operator|->
name|varvp
operator|->
name|Const
operator|.
name|ci
operator|>=
name|ip
operator|->
name|implim
operator|)
operator|)
condition|)
block|{
comment|/* start new loop */
name|curdtp
operator|=
name|ip
operator|->
name|datalist
expr_stmt|;
goto|goto
name|next
goto|;
block|}
comment|/* clean up loop */
if|if
condition|(
name|rpllist
condition|)
block|{
name|rp
operator|=
name|rpllist
expr_stmt|;
name|rpllist
operator|=
name|rpllist
operator|->
name|rplnextp
expr_stmt|;
name|free
argument_list|(
operator|(
name|charptr
operator|)
name|rp
argument_list|)
expr_stmt|;
block|}
else|else
name|Fatal
argument_list|(
literal|"rpllist empty"
argument_list|)
expr_stmt|;
name|frexpr
argument_list|(
operator|(
name|expptr
operator|)
name|ip
operator|->
name|varvp
argument_list|)
expr_stmt|;
name|ip
operator|->
name|isactive
operator|=
name|NO
expr_stmt|;
name|curdtp
operator|=
name|curdtp
operator|->
name|nextp
expr_stmt|;
goto|goto
name|next
goto|;
block|}
name|pp
operator|=
operator|(
expr|struct
name|Primblock
operator|*
operator|)
name|p
expr_stmt|;
name|np
operator|=
name|pp
operator|->
name|namep
expr_stmt|;
name|cur_varname
operator|=
name|np
operator|->
name|fvarname
expr_stmt|;
name|skip
operator|=
name|YES
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|primblock
operator|.
name|argsp
operator|==
name|NULL
operator|&&
name|np
operator|->
name|vdim
operator|!=
name|NULL
condition|)
block|{
comment|/* array initialization */
name|q
operator|=
operator|(
name|expptr
operator|)
name|mkaddr
argument_list|(
name|np
argument_list|)
expr_stmt|;
name|off
operator|=
name|typesize
index|[
name|np
operator|->
name|vtype
index|]
operator|*
name|curdtelt
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|vtype
operator|==
name|TYCHAR
condition|)
name|off
operator|*=
name|np
operator|->
name|vleng
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
expr_stmt|;
name|q
operator|->
name|addrblock
operator|.
name|memoffset
operator|=
name|mkexpr
argument_list|(
name|OPPLUS
argument_list|,
name|q
operator|->
name|addrblock
operator|.
name|memoffset
argument_list|,
name|mkintcon
argument_list|(
name|off
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|neltp
operator|=
name|np
operator|->
name|vdim
operator|->
name|nelt
operator|)
operator|&&
name|ISCONST
argument_list|(
name|neltp
argument_list|)
condition|)
block|{
if|if
condition|(
operator|++
name|curdtelt
operator|<
name|neltp
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
condition|)
name|skip
operator|=
name|NO
expr_stmt|;
block|}
else|else
name|err
argument_list|(
literal|"attempt to initialize adjustable array"
argument_list|)
expr_stmt|;
block|}
else|else
name|q
operator|=
name|mklhs
argument_list|(
operator|(
expr|struct
name|Primblock
operator|*
operator|)
name|cpexpr
argument_list|(
operator|(
name|expptr
operator|)
name|pp
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|skip
condition|)
block|{
name|curdtp
operator|=
name|curdtp
operator|->
name|nextp
expr_stmt|;
name|curdtelt
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|q
operator|->
name|headblock
operator|.
name|vtype
operator|==
name|TYCHAR
condition|)
if|if
condition|(
name|ISICON
argument_list|(
name|q
operator|->
name|headblock
operator|.
name|vleng
argument_list|)
condition|)
operator|*
name|elenp
operator|=
name|q
operator|->
name|headblock
operator|.
name|vleng
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
expr_stmt|;
else|else
block|{
name|err
argument_list|(
literal|"initialization of string of nonconstant length"
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
operator|*
name|elenp
operator|=
name|typesize
index|[
name|q
operator|->
name|headblock
operator|.
name|vtype
index|]
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|vstg
operator|==
name|STGBSS
condition|)
block|{
name|vlen
operator|=
name|np
operator|->
name|vtype
operator|==
name|TYCHAR
condition|?
name|np
operator|->
name|vleng
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
else|:
name|typesize
index|[
name|np
operator|->
name|vtype
index|]
expr_stmt|;
if|if
condition|(
name|vlen
operator|>
literal|0
condition|)
name|np
operator|->
name|vstg
operator|=
name|STGINIT
expr_stmt|;
block|}
return|return
operator|(
operator|(
name|Addrp
operator|)
name|q
operator|)
return|;
name|doerr
label|:
name|err
argument_list|(
literal|"nonconstant implied DO parameter"
argument_list|)
expr_stmt|;
name|frexpr
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|curdtp
operator|=
name|curdtp
operator|->
name|nextp
expr_stmt|;
name|next
label|:
name|curdtelt
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|LOCAL
name|FILEP
name|dfile
decl_stmt|;
end_decl_stmt

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|setdata
parameter_list|(
name|varp
parameter_list|,
name|valp
parameter_list|,
name|elen
parameter_list|)
specifier|register
name|Addrp
name|varp
decl_stmt|;
specifier|register
name|Constp
name|valp
decl_stmt|;
name|ftnint
name|elen
decl_stmt|;
else|#
directive|else
function|setdata
parameter_list|(
specifier|register
name|Addrp
name|varp
parameter_list|,
specifier|register
name|Constp
name|valp
parameter_list|,
name|ftnint
name|elen
parameter_list|)
endif|#
directive|endif
block|{
name|struct
name|Constblock
name|con
decl_stmt|;
specifier|register
name|int
name|type
decl_stmt|;
name|int
name|i
decl_stmt|,
name|k
decl_stmt|,
name|valtype
decl_stmt|;
name|ftnint
name|offset
decl_stmt|;
name|char
modifier|*
name|varname
decl_stmt|;
specifier|static
name|Addrp
name|badvar
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|s
decl_stmt|;
specifier|static
name|int
name|last_lineno
decl_stmt|;
specifier|static
name|char
modifier|*
name|last_varname
decl_stmt|;
if|if
condition|(
name|varp
operator|->
name|vstg
operator|==
name|STGCOMMON
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|dfile
operator|=
name|blkdfile
operator|)
condition|)
name|dfile
operator|=
name|blkdfile
operator|=
name|opf
argument_list|(
name|blkdfname
argument_list|,
name|textwrite
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|procclass
operator|==
name|CLBLOCK
condition|)
block|{
if|if
condition|(
name|varp
operator|!=
name|badvar
condition|)
block|{
name|badvar
operator|=
name|varp
expr_stmt|;
name|warn1
argument_list|(
literal|"%s is not in a COMMON block"
argument_list|,
name|varp
operator|->
name|uname_tag
operator|==
name|UNAM_NAME
condition|?
name|varp
operator|->
name|user
operator|.
name|name
operator|->
name|fvarname
else|:
literal|"???"
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
operator|!
operator|(
name|dfile
operator|=
name|initfile
operator|)
condition|)
name|dfile
operator|=
name|initfile
operator|=
name|opf
argument_list|(
name|initfname
argument_list|,
name|textwrite
argument_list|)
expr_stmt|;
block|}
name|varname
operator|=
name|dataname
argument_list|(
name|varp
operator|->
name|vstg
argument_list|,
name|varp
operator|->
name|memno
argument_list|)
expr_stmt|;
name|offset
operator|=
name|varp
operator|->
name|memoffset
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
expr_stmt|;
name|type
operator|=
name|varp
operator|->
name|vtype
expr_stmt|;
name|valtype
operator|=
name|valp
operator|->
name|vtype
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|TYCHAR
operator|&&
name|valtype
operator|==
name|TYCHAR
condition|)
block|{
if|if
condition|(
operator|!
name|ftn66flag
operator|&&
operator|(
name|last_varname
operator|!=
name|cur_varname
operator|||
name|last_lineno
operator|!=
name|lineno
operator|)
condition|)
block|{
comment|/* prevent multiple warnings */
name|last_lineno
operator|=
name|lineno
expr_stmt|;
name|warn1
argument_list|(
literal|"non-character datum %.42s initialized with character string"
argument_list|,
name|last_varname
operator|=
name|cur_varname
argument_list|)
expr_stmt|;
block|}
name|varp
operator|->
name|vleng
operator|=
name|ICON
argument_list|(
name|typesize
index|[
name|type
index|]
argument_list|)
expr_stmt|;
name|varp
operator|->
name|vtype
operator|=
name|type
operator|=
name|TYCHAR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|type
operator|==
name|TYCHAR
operator|&&
name|valtype
operator|!=
name|TYCHAR
operator|)
operator|||
operator|(
name|cktype
argument_list|(
name|OPASSIGN
argument_list|,
name|type
argument_list|,
name|valtype
argument_list|)
operator|==
name|TYERROR
operator|)
condition|)
block|{
name|err
argument_list|(
literal|"incompatible types in initialization"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|type
operator|==
name|TYADDR
condition|)
name|con
operator|.
name|Const
operator|.
name|ci
operator|=
name|valp
operator|->
name|Const
operator|.
name|ci
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|!=
name|TYCHAR
condition|)
block|{
if|if
condition|(
name|valtype
operator|==
name|TYUNKNOWN
condition|)
name|con
operator|.
name|Const
operator|.
name|ci
operator|=
name|valp
operator|->
name|Const
operator|.
name|ci
expr_stmt|;
else|else
name|consconv
argument_list|(
name|type
argument_list|,
operator|&
name|con
argument_list|,
name|valp
argument_list|)
expr_stmt|;
block|}
name|k
operator|=
literal|1
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|TYLOGICAL
case|:
case|case
name|TYINT1
case|:
case|case
name|TYLOGICAL1
case|:
case|case
name|TYLOGICAL2
case|:
case|case
name|TYSHORT
case|:
case|case
name|TYLONG
case|:
ifdef|#
directive|ifdef
name|TYQUAD
case|case
name|TYQUAD
case|:
endif|#
directive|endif
name|dataline
argument_list|(
name|varname
argument_list|,
name|offset
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|prconi
argument_list|(
name|dfile
argument_list|,
name|con
operator|.
name|Const
operator|.
name|ci
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYADDR
case|:
name|dataline
argument_list|(
name|varname
argument_list|,
name|offset
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|prcona
argument_list|(
name|dfile
argument_list|,
name|con
operator|.
name|Const
operator|.
name|ci
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYCOMPLEX
case|:
case|case
name|TYDCOMPLEX
case|:
name|k
operator|=
literal|2
expr_stmt|;
case|case
name|TYREAL
case|:
case|case
name|TYDREAL
case|:
name|dataline
argument_list|(
name|varname
argument_list|,
name|offset
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|prconr
argument_list|(
name|dfile
argument_list|,
operator|&
name|con
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYCHAR
case|:
name|k
operator|=
name|valp
operator|->
name|vleng
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
expr_stmt|;
if|if
condition|(
name|elen
operator|<
name|k
condition|)
name|k
operator|=
name|elen
expr_stmt|;
name|s
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|valp
operator|->
name|Const
operator|.
name|ccp
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|k
condition|;
operator|++
name|i
control|)
block|{
name|dataline
argument_list|(
name|varname
argument_list|,
name|offset
operator|++
argument_list|,
name|TYCHAR
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dfile
argument_list|,
literal|"\t%d\n"
argument_list|,
operator|*
name|s
operator|++
argument_list|)
expr_stmt|;
block|}
name|k
operator|=
name|elen
operator|-
name|valp
operator|->
name|vleng
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
expr_stmt|;
if|if
condition|(
name|k
operator|>
literal|0
condition|)
block|{
name|dataline
argument_list|(
name|varname
argument_list|,
name|offset
argument_list|,
name|TYBLANK
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dfile
argument_list|,
literal|"\t%d\n"
argument_list|,
name|k
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|badtype
argument_list|(
literal|"setdata"
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*    output form of name is padded with blanks and preceded    with a storage class digit */
end_comment

begin_function
name|char
modifier|*
ifdef|#
directive|ifdef
name|KR_headers
name|dataname
parameter_list|(
name|stg
parameter_list|,
name|memno
parameter_list|)
name|int
name|stg
decl_stmt|;
name|long
name|memno
decl_stmt|;
else|#
directive|else
function|dataname
parameter_list|(
name|int
name|stg
parameter_list|,
name|long
name|memno
parameter_list|)
endif|#
directive|endif
block|{
specifier|static
name|char
name|varname
index|[
literal|64
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|t
decl_stmt|;
name|char
name|buf
index|[
literal|16
index|]
decl_stmt|;
if|if
condition|(
name|stg
operator|==
name|STGCOMMON
condition|)
block|{
name|varname
index|[
literal|0
index|]
operator|=
literal|'2'
expr_stmt|;
name|sprintf
argument_list|(
name|s
operator|=
name|buf
argument_list|,
literal|"Q.%ld"
argument_list|,
name|memno
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|varname
index|[
literal|0
index|]
operator|=
name|stg
operator|==
name|STGEQUIV
condition|?
literal|'1'
else|:
literal|'0'
expr_stmt|;
name|s
operator|=
name|memname
argument_list|(
name|stg
argument_list|,
name|memno
argument_list|)
expr_stmt|;
block|}
name|t
operator|=
name|varname
operator|+
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|t
operator|++
operator|=
operator|*
name|s
operator|++
condition|)
empty_stmt|;
operator|*
name|t
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|varname
operator|)
return|;
block|}
end_function

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|frdata
parameter_list|(
name|p0
parameter_list|)
name|chainp
name|p0
decl_stmt|;
else|#
directive|else
function|frdata
parameter_list|(
name|chainp
name|p0
parameter_list|)
endif|#
directive|endif
block|{
specifier|register
name|struct
name|Chain
modifier|*
name|p
decl_stmt|;
specifier|register
name|tagptr
name|q
decl_stmt|;
for|for
control|(
name|p
operator|=
name|p0
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|nextp
control|)
block|{
name|q
operator|=
operator|(
name|tagptr
operator|)
name|p
operator|->
name|datap
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|tag
operator|==
name|TIMPLDO
condition|)
block|{
if|if
condition|(
name|q
operator|->
name|impldoblock
operator|.
name|isbusy
condition|)
return|return;
comment|/* circular chain completed */
name|q
operator|->
name|impldoblock
operator|.
name|isbusy
operator|=
name|YES
expr_stmt|;
name|frdata
argument_list|(
name|q
operator|->
name|impldoblock
operator|.
name|datalist
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|charptr
operator|)
name|q
argument_list|)
expr_stmt|;
block|}
else|else
name|frexpr
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
name|frchain
argument_list|(
operator|&
name|p0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|dataline
parameter_list|(
name|varname
parameter_list|,
name|offset
parameter_list|,
name|type
parameter_list|)
name|char
modifier|*
name|varname
decl_stmt|;
name|ftnint
name|offset
decl_stmt|;
name|int
name|type
decl_stmt|;
else|#
directive|else
function|dataline
parameter_list|(
name|char
modifier|*
name|varname
parameter_list|,
name|ftnint
name|offset
parameter_list|,
name|int
name|type
parameter_list|)
endif|#
directive|endif
block|{
name|fprintf
argument_list|(
name|dfile
argument_list|,
name|datafmt
argument_list|,
name|varname
argument_list|,
name|offset
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|make_param
parameter_list|(
name|p
parameter_list|,
name|e
parameter_list|)
specifier|register
name|struct
name|Paramblock
modifier|*
name|p
decl_stmt|;
name|expptr
name|e
decl_stmt|;
else|#
directive|else
function|make_param
parameter_list|(
specifier|register
name|struct
name|Paramblock
modifier|*
name|p
parameter_list|,
name|expptr
name|e
parameter_list|)
endif|#
directive|endif
block|{
specifier|register
name|expptr
name|q
decl_stmt|;
name|struct
name|Constblock
name|qc
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|vstg
operator|==
name|STGARG
condition|)
name|errstr
argument_list|(
literal|"Dummy argument %.50s appears in a parameter statement."
argument_list|,
name|p
operator|->
name|fvarname
argument_list|)
expr_stmt|;
name|p
operator|->
name|vclass
operator|=
name|CLPARAM
expr_stmt|;
name|impldcl
argument_list|(
operator|(
name|Namep
operator|)
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|headblock
operator|.
name|vtype
operator|!=
name|TYCHAR
condition|)
name|e
operator|=
name|putx
argument_list|(
name|fixtype
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|paramval
operator|=
name|q
operator|=
name|mkconv
argument_list|(
name|p
operator|->
name|vtype
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|vtype
operator|==
name|TYCHAR
condition|)
block|{
if|if
condition|(
name|q
operator|->
name|tag
operator|==
name|TEXPR
condition|)
name|p
operator|->
name|paramval
operator|=
name|q
operator|=
name|fixexpr
argument_list|(
operator|(
name|Exprp
operator|)
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|tag
operator|==
name|TADDR
operator|&&
name|q
operator|->
name|addrblock
operator|.
name|uname_tag
operator|==
name|UNAM_CONST
condition|)
block|{
name|qc
operator|.
name|Const
operator|=
name|q
operator|->
name|addrblock
operator|.
name|user
operator|.
name|Const
expr_stmt|;
name|qc
operator|.
name|tag
operator|=
name|TCONST
expr_stmt|;
name|qc
operator|.
name|vtype
operator|=
name|q
operator|->
name|addrblock
operator|.
name|vtype
expr_stmt|;
name|qc
operator|.
name|vleng
operator|=
name|q
operator|->
name|addrblock
operator|.
name|vleng
expr_stmt|;
name|q
operator|=
operator|(
name|expptr
operator|)
operator|&
name|qc
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ISCONST
argument_list|(
name|q
argument_list|)
operator|||
name|q
operator|->
name|constblock
operator|.
name|vtype
operator|!=
name|TYCHAR
condition|)
block|{
name|errstr
argument_list|(
literal|"invalid value for character parameter %s"
argument_list|,
name|p
operator|->
name|fvarname
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
operator|(
name|e
operator|=
name|p
operator|->
name|vleng
operator|)
condition|)
name|p
operator|->
name|vleng
operator|=
name|ICON
argument_list|(
name|q
operator|->
name|constblock
operator|.
name|vleng
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
operator|+
name|q
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ccp1
operator|.
name|blanks
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|q
operator|->
name|constblock
operator|.
name|vleng
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
operator|>
name|e
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
condition|)
block|{
name|q
operator|->
name|constblock
operator|.
name|vleng
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
operator|=
name|e
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
expr_stmt|;
name|q
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ccp1
operator|.
name|blanks
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|q
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ccp1
operator|.
name|blanks
operator|=
name|e
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
operator|-
name|q
operator|->
name|constblock
operator|.
name|vleng
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
expr_stmt|;
block|}
block|}
end_function

end_unit

