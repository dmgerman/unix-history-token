begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**************************************************************** Copyright 1990, 1994-6 by AT&T, Lucent Technologies and Bellcore.  Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that the copyright notice and this permission notice and warranty disclaimer appear in supporting documentation, and that the names of AT&T, Bell Laboratories, Lucent or Bellcore or any of their entities not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  AT&T, Lucent and Bellcore disclaim all warranties with regard to this software, including all implied warranties of merchantability and fitness.  In no event shall AT&T, Lucent or Bellcore be liable for any special, indirect or consequential damages or any damages whatsoever resulting from loss of use, data or profits, whether in an action of contract, negligence or other tortious action, arising out of or in connection with the use or performance of this software. ****************************************************************/
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"names.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"p1defs.h"
end_include

begin_comment
comment|/* round a up to the nearest multiple of b:     a = b * floor ( (a + (b - 1)) / b )*/
end_comment

begin_undef
undef|#
directive|undef
name|roundup
end_undef

begin_define
define|#
directive|define
name|roundup
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|( b * ( (a+b-1)/b) )
end_define

begin_define
define|#
directive|define
name|EXNULL
value|(union Expression *)0
end_define

begin_decl_stmt
specifier|static
name|void
name|dobss
name|Argdcl
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|docomleng
name|Argdcl
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|docommon
name|Argdcl
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|doentry
name|Argdcl
argument_list|(
operator|(
expr|struct
name|Entrypoint
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|epicode
name|Argdcl
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nextarg
name|Argdcl
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|retval
name|Argdcl
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|Blank
index|[]
init|=
name|BLANKCOMMON
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|postfix
index|[]
init|=
block|{
literal|"g"
block|,
literal|"h"
block|,
literal|"i"
block|,
ifdef|#
directive|ifdef
name|TYQUAD
literal|"j"
block|,
endif|#
directive|endif
literal|"r"
block|,
literal|"d"
block|,
literal|"c"
block|,
literal|"z"
block|,
literal|"g"
block|,
literal|"h"
block|,
literal|"i"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|chainp
name|new_procs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|prev_proc
decl_stmt|,
name|proc_argchanges
decl_stmt|,
name|proc_protochanges
decl_stmt|;
end_decl_stmt

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|changedtype
parameter_list|(
name|q
parameter_list|)
name|Namep
name|q
decl_stmt|;
else|#
directive|else
function|changedtype
parameter_list|(
name|Namep
name|q
parameter_list|)
endif|#
directive|endif
block|{
name|char
name|buf
index|[
literal|200
index|]
decl_stmt|;
name|int
name|qtype
decl_stmt|,
name|type1
decl_stmt|;
specifier|register
name|Extsym
modifier|*
name|e
decl_stmt|;
name|Argtypes
modifier|*
name|at
decl_stmt|;
if|if
condition|(
name|q
operator|->
name|vtypewarned
condition|)
return|return;
name|q
operator|->
name|vtypewarned
operator|=
literal|1
expr_stmt|;
name|qtype
operator|=
name|q
operator|->
name|vtype
expr_stmt|;
name|e
operator|=
operator|&
name|extsymtab
index|[
name|q
operator|->
name|vardesc
operator|.
name|varno
index|]
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|at
operator|=
name|e
operator|->
name|arginfo
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|e
operator|->
name|exused
condition|)
return|return;
block|}
elseif|else
if|if
condition|(
name|at
operator|->
name|changes
operator|&
literal|2
operator|&&
name|qtype
operator|!=
name|TYUNKNOWN
operator|&&
operator|!
name|at
operator|->
name|defined
condition|)
name|proc_protochanges
operator|++
expr_stmt|;
name|type1
operator|=
name|e
operator|->
name|extype
expr_stmt|;
if|if
condition|(
name|type1
operator|==
name|TYUNKNOWN
condition|)
return|return;
if|if
condition|(
name|qtype
operator|==
name|TYUNKNOWN
condition|)
comment|/* e.g., 			subroutine foo 			end 			external foo 			call goo(foo) 			end 		*/
return|return;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%.90s: inconsistent declarations:\n\ 	here %s%s, previously %s%s."
argument_list|,
name|q
operator|->
name|fvarname
argument_list|,
name|ftn_types
index|[
name|qtype
index|]
argument_list|,
name|qtype
operator|==
name|TYSUBR
condition|?
literal|""
else|:
literal|" function"
argument_list|,
name|ftn_types
index|[
name|type1
index|]
argument_list|,
name|type1
operator|==
name|TYSUBR
condition|?
literal|""
else|:
literal|" function"
argument_list|)
expr_stmt|;
name|warn
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|unamstring
parameter_list|(
name|q
parameter_list|,
name|s
parameter_list|)
specifier|register
name|Addrp
name|q
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
else|#
directive|else
function|unamstring
parameter_list|(
specifier|register
name|Addrp
name|q
parameter_list|,
specifier|register
name|char
modifier|*
name|s
parameter_list|)
endif|#
directive|endif
block|{
specifier|register
name|int
name|k
decl_stmt|;
specifier|register
name|char
modifier|*
name|t
decl_stmt|;
name|k
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|<
name|IDENT_LEN
condition|)
block|{
name|q
operator|->
name|uname_tag
operator|=
name|UNAM_IDENT
expr_stmt|;
name|t
operator|=
name|q
operator|->
name|user
operator|.
name|ident
expr_stmt|;
block|}
else|else
block|{
name|q
operator|->
name|uname_tag
operator|=
name|UNAM_CHARP
expr_stmt|;
name|q
operator|->
name|user
operator|.
name|Charp
operator|=
name|t
operator|=
name|mem
argument_list|(
name|k
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|t
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fix_entry_returns
parameter_list|(
name|Void
parameter_list|)
comment|/* for multiple entry points */
block|{
name|Addrp
name|a
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|Entrypoint
modifier|*
name|e
decl_stmt|;
name|Namep
name|np
decl_stmt|;
name|e
operator|=
name|entries
operator|=
operator|(
expr|struct
name|Entrypoint
operator|*
operator|)
name|revchain
argument_list|(
operator|(
name|chainp
operator|)
name|entries
argument_list|)
expr_stmt|;
name|allargs
operator|=
name|revchain
argument_list|(
name|allargs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|multitype
condition|)
return|return;
comment|/* TYLOGICAL should have been turned into TYLONG or TYSHORT by now */
for|for
control|(
name|i
operator|=
name|TYINT1
init|;
name|i
operator|<=
name|TYLOGICAL
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|a
operator|=
name|xretslot
index|[
name|i
index|]
condition|)
name|sprintf
argument_list|(
name|a
operator|->
name|user
operator|.
name|ident
argument_list|,
literal|"(*ret_val).%s"
argument_list|,
name|postfix
index|[
name|i
operator|-
name|TYINT1
index|]
argument_list|)
expr_stmt|;
do|do
block|{
name|np
operator|=
name|e
operator|->
name|enamep
expr_stmt|;
switch|switch
condition|(
name|np
operator|->
name|vtype
condition|)
block|{
case|case
name|TYINT1
case|:
case|case
name|TYSHORT
case|:
case|case
name|TYLONG
case|:
ifdef|#
directive|ifdef
name|TYQUAD
case|case
name|TYQUAD
case|:
endif|#
directive|endif
case|case
name|TYREAL
case|:
case|case
name|TYDREAL
case|:
case|case
name|TYCOMPLEX
case|:
case|case
name|TYDCOMPLEX
case|:
case|case
name|TYLOGICAL1
case|:
case|case
name|TYLOGICAL2
case|:
case|case
name|TYLOGICAL
case|:
name|np
operator|->
name|vstg
operator|=
name|STGARG
expr_stmt|;
block|}
block|}
do|while
condition|(
name|e
operator|=
name|e
operator|->
name|entnextp
condition|)
do|;
block|}
end_function

begin_function
specifier|static
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|putentries
parameter_list|(
name|outfile
parameter_list|)
name|FILE
modifier|*
name|outfile
decl_stmt|;
else|#
directive|else
function|putentries
parameter_list|(
name|FILE
modifier|*
name|outfile
parameter_list|)
endif|#
directive|endif
comment|/* put out wrappers for multiple entries */
block|{
name|char
name|base
index|[
name|MAXNAMELEN
operator|+
literal|4
index|]
decl_stmt|;
name|struct
name|Entrypoint
modifier|*
name|e
decl_stmt|;
name|Namep
modifier|*
name|A
decl_stmt|,
modifier|*
name|Ae
decl_stmt|,
modifier|*
name|Ae1
decl_stmt|,
modifier|*
modifier|*
name|Alp
decl_stmt|,
modifier|*
name|a
decl_stmt|,
modifier|*
modifier|*
name|a1
decl_stmt|,
name|np
decl_stmt|;
name|chainp
name|args
decl_stmt|,
name|lengths
decl_stmt|;
name|int
name|i
decl_stmt|,
name|k
decl_stmt|,
name|mt
decl_stmt|,
name|nL
decl_stmt|,
name|t
decl_stmt|,
name|type
decl_stmt|;
specifier|extern
name|char
modifier|*
name|dfltarg
index|[]
decl_stmt|,
modifier|*
modifier|*
name|dfltproc
decl_stmt|;
name|e
operator|=
name|entries
expr_stmt|;
if|if
condition|(
operator|!
name|e
operator|->
name|enamep
condition|)
comment|/* only possible with erroneous input */
return|return;
name|nL
operator|=
operator|(
name|nallargs
operator|+
name|nallchargs
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|Namep
operator|*
argument_list|)
expr_stmt|;
name|A
operator|=
operator|(
name|Namep
operator|*
operator|)
name|ckalloc
argument_list|(
name|nL
operator|+
name|nallargs
operator|*
sizeof|sizeof
argument_list|(
name|Namep
operator|*
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|Ae
operator|=
name|A
operator|+
name|nallargs
expr_stmt|;
name|Alp
operator|=
operator|(
name|Namep
operator|*
operator|*
operator|)
operator|(
name|Ae1
operator|=
name|Ae
operator|+
name|nallchargs
operator|)
expr_stmt|;
name|i
operator|=
name|k
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|a1
operator|=
name|Alp
operator|,
name|args
operator|=
name|allargs
init|;
name|args
condition|;
name|a1
operator|++
operator|,
name|args
operator|=
name|args
operator|->
name|nextp
control|)
block|{
name|np
operator|=
operator|(
name|Namep
operator|)
name|args
operator|->
name|datap
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|vtype
operator|==
name|TYCHAR
operator|&&
name|np
operator|->
name|vclass
operator|!=
name|CLPROC
condition|)
operator|*
name|a1
operator|=
operator|&
name|Ae
index|[
name|i
operator|++
index|]
expr_stmt|;
block|}
name|mt
operator|=
name|multitype
expr_stmt|;
name|multitype
operator|=
literal|0
expr_stmt|;
name|sprintf
argument_list|(
name|base
argument_list|,
literal|"%s0_"
argument_list|,
name|e
operator|->
name|enamep
operator|->
name|cvarname
argument_list|)
expr_stmt|;
do|do
block|{
name|np
operator|=
name|e
operator|->
name|enamep
expr_stmt|;
name|lengths
operator|=
name|length_comp
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|proctype
operator|=
name|type
operator|=
name|np
operator|->
name|vtype
expr_stmt|;
if|if
condition|(
name|protofile
condition|)
name|protowrite
argument_list|(
name|protofile
argument_list|,
name|type
argument_list|,
name|np
operator|->
name|cvarname
argument_list|,
name|e
argument_list|,
name|lengths
argument_list|)
expr_stmt|;
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"\n%s "
argument_list|,
name|c_type_decl
argument_list|(
name|type
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"%s"
argument_list|,
name|np
operator|->
name|cvarname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Ansi
condition|)
block|{
name|listargs
argument_list|(
name|outfile
argument_list|,
name|e
argument_list|,
literal|0
argument_list|,
name|lengths
argument_list|)
expr_stmt|;
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|list_arg_types
argument_list|(
name|outfile
argument_list|,
name|e
argument_list|,
name|lengths
argument_list|,
literal|0
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"{\n"
argument_list|)
expr_stmt|;
name|frchain
argument_list|(
operator|&
name|lengths
argument_list|)
expr_stmt|;
name|next_tab
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|mt
condition|)
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"Multitype ret_val;\n%s(%d,&ret_val"
argument_list|,
name|base
argument_list|,
name|k
argument_list|)
expr_stmt|;
comment|/*)*/
elseif|else
if|if
condition|(
name|ISCOMPLEX
argument_list|(
name|type
argument_list|)
condition|)
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"%s(%d,%s"
argument_list|,
name|base
argument_list|,
name|k
argument_list|,
name|xretslot
index|[
name|type
index|]
operator|->
name|user
operator|.
name|ident
argument_list|)
expr_stmt|;
comment|/*)*/
elseif|else
if|if
condition|(
name|type
operator|==
name|TYCHAR
condition|)
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"%s(%d, ret_val, ret_val_len"
argument_list|,
name|base
argument_list|,
name|k
argument_list|)
expr_stmt|;
comment|/*)*/
else|else
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"return %s(%d"
argument_list|,
name|base
argument_list|,
name|k
argument_list|)
expr_stmt|;
comment|/*)*/
name|k
operator|++
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|A
argument_list|,
literal|0
argument_list|,
name|nL
argument_list|)
expr_stmt|;
for|for
control|(
name|args
operator|=
name|e
operator|->
name|arglist
init|;
name|args
condition|;
name|args
operator|=
name|args
operator|->
name|nextp
control|)
block|{
name|np
operator|=
operator|(
name|Namep
operator|)
name|args
operator|->
name|datap
expr_stmt|;
name|A
index|[
name|np
operator|->
name|argno
index|]
operator|=
name|np
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|vtype
operator|==
name|TYCHAR
operator|&&
name|np
operator|->
name|vclass
operator|!=
name|CLPROC
condition|)
operator|*
name|Alp
index|[
name|np
operator|->
name|argno
index|]
operator|=
name|np
expr_stmt|;
block|}
name|args
operator|=
name|allargs
expr_stmt|;
for|for
control|(
name|a
operator|=
name|A
init|;
name|a
operator|<
name|Ae
condition|;
name|a
operator|++
operator|,
name|args
operator|=
name|args
operator|->
name|nextp
control|)
block|{
name|t
operator|=
operator|(
operator|(
name|Namep
operator|)
name|args
operator|->
name|datap
operator|)
operator|->
name|vtype
expr_stmt|;
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|", %s"
argument_list|,
operator|(
name|np
operator|=
operator|*
name|a
operator|)
condition|?
name|np
operator|->
name|cvarname
else|:
operator|(
operator|(
name|Namep
operator|)
name|args
operator|->
name|datap
operator|)
operator|->
name|vclass
operator|==
name|CLPROC
condition|?
name|dfltproc
index|[
operator|(
operator|(
name|Namep
operator|)
name|args
operator|->
name|datap
operator|)
operator|->
name|vimpltype
condition|?
operator|(
name|Castargs
condition|?
name|TYUNKNOWN
else|:
name|TYSUBR
operator|)
else|:
name|t
operator|==
name|TYREAL
operator|&&
name|forcedouble
operator|&&
operator|!
name|Castargs
condition|?
name|TYDREAL
else|:
name|t
index|]
else|:
name|dfltarg
index|[
operator|(
operator|(
name|Namep
operator|)
name|args
operator|->
name|datap
operator|)
operator|->
name|vtype
index|]
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
name|a
operator|<
name|Ae1
condition|;
name|a
operator|++
control|)
if|if
condition|(
name|np
operator|=
operator|*
name|a
condition|)
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|", %s"
argument_list|,
name|new_arg_length
argument_list|(
name|np
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|", (ftnint)0"
argument_list|)
expr_stmt|;
name|nice_printf
argument_list|(
name|outfile
argument_list|,
comment|/*(*/
literal|");\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|mt
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|TYCOMPLEX
condition|)
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"r_v->r = ret_val.c.r; r_v->i = ret_val.c.i;\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|TYDCOMPLEX
condition|)
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"r_v->r = ret_val.z.r; r_v->i = ret_val.z.i;\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|<=
name|TYLOGICAL
condition|)
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"return ret_val.%s;\n"
argument_list|,
name|postfix
index|[
name|type
operator|-
name|TYINT1
index|]
argument_list|)
expr_stmt|;
block|}
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"}\n"
argument_list|)
expr_stmt|;
name|prev_tab
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|e
operator|=
name|e
operator|->
name|entnextp
condition|)
do|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|A
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|entry_goto
parameter_list|(
name|outfile
parameter_list|)
name|FILE
modifier|*
name|outfile
decl_stmt|;
else|#
directive|else
function|entry_goto
parameter_list|(
name|FILE
modifier|*
name|outfile
parameter_list|)
endif|#
directive|endif
block|{
name|struct
name|Entrypoint
modifier|*
name|e
init|=
name|entries
decl_stmt|;
name|int
name|k
init|=
literal|0
decl_stmt|;
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"switch(n__) {\n"
argument_list|)
expr_stmt|;
name|next_tab
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
while|while
condition|(
name|e
operator|=
name|e
operator|->
name|entnextp
condition|)
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"case %d: goto %s;\n"
argument_list|,
operator|++
name|k
argument_list|,
name|user_label
argument_list|(
call|(
name|long
call|)
argument_list|(
name|extsymtab
operator|-
name|e
operator|->
name|entryname
operator|-
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"}\n\n"
argument_list|)
expr_stmt|;
name|prev_tab
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* start a new procedure */
end_comment

begin_function
name|void
name|newproc
parameter_list|(
name|Void
parameter_list|)
block|{
if|if
condition|(
name|parstate
operator|!=
name|OUTSIDE
condition|)
block|{
name|execerr
argument_list|(
literal|"missing end statement"
argument_list|,
name|CNULL
argument_list|)
expr_stmt|;
name|endproc
argument_list|()
expr_stmt|;
block|}
name|parstate
operator|=
name|INSIDE
expr_stmt|;
name|procclass
operator|=
name|CLMAIN
expr_stmt|;
comment|/* default */
block|}
end_function

begin_function
specifier|static
name|void
name|zap_changes
parameter_list|(
name|Void
parameter_list|)
block|{
specifier|register
name|chainp
name|cp
decl_stmt|;
specifier|register
name|Argtypes
modifier|*
name|at
decl_stmt|;
comment|/* arrange to get correct count of prototypes that would 	   change by running f2c again */
if|if
condition|(
name|prev_proc
operator|&&
name|proc_argchanges
condition|)
name|proc_protochanges
operator|++
expr_stmt|;
name|prev_proc
operator|=
name|proc_argchanges
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|new_procs
init|;
name|cp
condition|;
name|cp
operator|=
name|cp
operator|->
name|nextp
control|)
if|if
condition|(
name|at
operator|=
operator|(
operator|(
name|Namep
operator|)
name|cp
operator|->
name|datap
operator|)
operator|->
name|arginfo
condition|)
name|at
operator|->
name|changes
operator|&=
operator|~
literal|1
expr_stmt|;
name|frchain
argument_list|(
operator|&
name|new_procs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* end of procedure. generate variables, epilogs, and prologs */
end_comment

begin_function
name|void
name|endproc
parameter_list|(
name|Void
parameter_list|)
block|{
name|struct
name|Labelblock
modifier|*
name|lp
decl_stmt|;
name|Extsym
modifier|*
name|ext
decl_stmt|;
if|if
condition|(
name|parstate
operator|<
name|INDATA
condition|)
name|enddcl
argument_list|()
expr_stmt|;
if|if
condition|(
name|ctlstack
operator|>=
name|ctls
condition|)
name|err
argument_list|(
literal|"DO loop or BLOCK IF not closed"
argument_list|)
expr_stmt|;
for|for
control|(
name|lp
operator|=
name|labeltab
init|;
name|lp
operator|<
name|labtabend
condition|;
operator|++
name|lp
control|)
if|if
condition|(
name|lp
operator|->
name|stateno
operator|!=
literal|0
operator|&&
name|lp
operator|->
name|labdefined
operator|==
name|NO
condition|)
name|errstr
argument_list|(
literal|"missing statement label %s"
argument_list|,
name|convic
argument_list|(
name|lp
operator|->
name|stateno
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Save copies of the common variables in extptr -> allextp */
for|for
control|(
name|ext
operator|=
name|extsymtab
init|;
name|ext
operator|<
name|nextext
condition|;
name|ext
operator|++
control|)
if|if
condition|(
name|ext
operator|->
name|extstg
operator|==
name|STGCOMMON
operator|&&
name|ext
operator|->
name|extp
condition|)
block|{
specifier|extern
name|int
name|usedefsforcommon
decl_stmt|;
comment|/* Write out the abbreviations for common block reference */
name|copy_data
argument_list|(
name|ext
operator|->
name|extp
argument_list|)
expr_stmt|;
if|if
condition|(
name|usedefsforcommon
condition|)
block|{
name|wr_abbrevs
argument_list|(
name|c_file
argument_list|,
literal|1
argument_list|,
name|ext
operator|->
name|extp
argument_list|)
expr_stmt|;
name|ext
operator|->
name|used_here
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|ext
operator|->
name|extp
operator|=
name|CHNULL
expr_stmt|;
block|}
if|if
condition|(
name|nentry
operator|>
literal|1
condition|)
name|fix_entry_returns
argument_list|()
expr_stmt|;
name|epicode
argument_list|()
expr_stmt|;
name|donmlist
argument_list|()
expr_stmt|;
name|dobss
argument_list|()
expr_stmt|;
name|start_formatting
argument_list|()
expr_stmt|;
if|if
condition|(
name|nentry
operator|>
literal|1
condition|)
name|putentries
argument_list|(
name|c_file
argument_list|)
expr_stmt|;
name|zap_changes
argument_list|()
expr_stmt|;
name|procinit
argument_list|()
expr_stmt|;
comment|/* clean up for next procedure */
block|}
end_function

begin_comment
comment|/* End of declaration section of procedure.  Allocate storage. */
end_comment

begin_function
name|void
name|enddcl
parameter_list|(
name|Void
parameter_list|)
block|{
specifier|register
name|struct
name|Entrypoint
modifier|*
name|ep
decl_stmt|;
name|struct
name|Entrypoint
modifier|*
name|ep0
decl_stmt|;
name|chainp
name|cp
decl_stmt|;
specifier|extern
name|char
modifier|*
name|err_proc
decl_stmt|;
specifier|static
name|char
name|comblks
index|[]
init|=
literal|"common blocks"
decl_stmt|;
name|err_proc
operator|=
name|comblks
expr_stmt|;
name|docommon
argument_list|()
expr_stmt|;
comment|/* Now the hash table entries for fields of common blocks have STGCOMMON,    vdcldone, voffset, and varno.  And the common blocks themselves have    their full sizes in extleng. */
name|err_proc
operator|=
literal|"equivalences"
expr_stmt|;
name|doequiv
argument_list|()
expr_stmt|;
name|err_proc
operator|=
name|comblks
expr_stmt|;
name|docomleng
argument_list|()
expr_stmt|;
comment|/* This implies that entry points in the declarations are buffered in    entries   but not written out */
name|err_proc
operator|=
literal|"entries"
expr_stmt|;
if|if
condition|(
name|ep
operator|=
name|ep0
operator|=
operator|(
expr|struct
name|Entrypoint
operator|*
operator|)
name|revchain
argument_list|(
operator|(
name|chainp
operator|)
name|entries
argument_list|)
condition|)
block|{
comment|/* entries could be 0 in case of an error */
do|do
name|doentry
argument_list|(
name|ep
argument_list|)
expr_stmt|;
do|while
condition|(
name|ep
operator|=
name|ep
operator|->
name|entnextp
condition|)
do|;
name|entries
operator|=
operator|(
expr|struct
name|Entrypoint
operator|*
operator|)
name|revchain
argument_list|(
operator|(
name|chainp
operator|)
name|ep0
argument_list|)
expr_stmt|;
block|}
name|err_proc
operator|=
literal|0
expr_stmt|;
name|parstate
operator|=
name|INEXEC
expr_stmt|;
name|p1put
argument_list|(
name|P1_PROCODE
argument_list|)
expr_stmt|;
name|freetemps
argument_list|()
expr_stmt|;
if|if
condition|(
name|earlylabs
condition|)
block|{
for|for
control|(
name|cp
operator|=
name|earlylabs
operator|=
name|revchain
argument_list|(
name|earlylabs
argument_list|)
init|;
name|cp
condition|;
name|cp
operator|=
name|cp
operator|->
name|nextp
control|)
name|p1_label
argument_list|(
operator|(
name|long
operator|)
name|cp
operator|->
name|datap
argument_list|)
expr_stmt|;
name|frchain
argument_list|(
operator|&
name|earlylabs
argument_list|)
expr_stmt|;
block|}
name|p1_line_number
argument_list|(
name|lineno
argument_list|)
expr_stmt|;
comment|/* for files that start with a MAIN program */
comment|/* that starts with an executable statement */
block|}
end_function

begin_comment
comment|/* ROUTINES CALLED WHEN ENCOUNTERING ENTRY POINTS */
end_comment

begin_comment
comment|/* Main program or Block data */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|startproc
parameter_list|(
name|progname
parameter_list|,
name|class
parameter_list|)
name|Extsym
modifier|*
name|progname
decl_stmt|;
name|int
name|class
decl_stmt|;
else|#
directive|else
function|startproc
parameter_list|(
name|Extsym
modifier|*
name|progname
parameter_list|,
name|int
name|class
parameter_list|)
endif|#
directive|endif
block|{
specifier|register
name|struct
name|Entrypoint
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|ALLOC
argument_list|(
name|Entrypoint
argument_list|)
expr_stmt|;
if|if
condition|(
name|class
operator|==
name|CLMAIN
condition|)
block|{
name|puthead
argument_list|(
name|CNULL
argument_list|,
name|CLMAIN
argument_list|)
expr_stmt|;
if|if
condition|(
name|progname
condition|)
name|strcpy
argument_list|(
name|main_alias
argument_list|,
name|progname
operator|->
name|cextname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|progname
condition|)
block|{
comment|/* Construct an empty subroutine with this name */
comment|/* in case the name is needed to force loading */
comment|/* of this block-data subprogram: the name can */
comment|/* appear elsewhere in an external statement. */
name|entrypt
argument_list|(
name|CLPROC
argument_list|,
name|TYSUBR
argument_list|,
operator|(
name|ftnint
operator|)
literal|0
argument_list|,
name|progname
argument_list|,
operator|(
name|chainp
operator|)
literal|0
argument_list|)
expr_stmt|;
name|endproc
argument_list|()
expr_stmt|;
name|newproc
argument_list|()
expr_stmt|;
block|}
name|puthead
argument_list|(
name|CNULL
argument_list|,
name|CLBLOCK
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|class
operator|==
name|CLMAIN
condition|)
name|newentry
argument_list|(
name|mkname
argument_list|(
literal|" MAIN"
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|->
name|extinit
operator|=
literal|1
expr_stmt|;
name|p
operator|->
name|entryname
operator|=
name|progname
expr_stmt|;
name|entries
operator|=
name|p
expr_stmt|;
name|procclass
operator|=
name|class
expr_stmt|;
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"   %s"
argument_list|,
operator|(
name|class
operator|==
name|CLMAIN
condition|?
literal|"MAIN"
else|:
literal|"BLOCK DATA"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|progname
condition|)
block|{
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|" %s"
argument_list|,
name|progname
operator|->
name|fextname
argument_list|)
expr_stmt|;
name|procname
operator|=
name|progname
operator|->
name|cextname
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|":\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|diagfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* subroutine or function statement */
end_comment

begin_function
name|Extsym
modifier|*
ifdef|#
directive|ifdef
name|KR_headers
name|newentry
parameter_list|(
name|v
parameter_list|,
name|substmsg
parameter_list|)
specifier|register
name|Namep
name|v
decl_stmt|;
name|int
name|substmsg
decl_stmt|;
else|#
directive|else
function|newentry
parameter_list|(
specifier|register
name|Namep
name|v
parameter_list|,
name|int
name|substmsg
parameter_list|)
endif|#
directive|endif
block|{
specifier|register
name|Extsym
modifier|*
name|p
decl_stmt|;
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|,
name|badname
index|[
literal|64
index|]
decl_stmt|;
specifier|static
name|int
name|nbad
init|=
literal|0
decl_stmt|;
specifier|static
name|char
name|already
index|[]
init|=
literal|"external name already used"
decl_stmt|;
name|p
operator|=
name|mkext
argument_list|(
name|v
operator|->
name|fvarname
argument_list|,
name|addunder
argument_list|(
name|v
operator|->
name|cvarname
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|extinit
operator|||
operator|!
name|ONEOF
argument_list|(
name|p
operator|->
name|extstg
argument_list|,
name|M
argument_list|(
name|STGUNKNOWN
argument_list|)
operator||
name|M
argument_list|(
name|STGEXT
argument_list|)
argument_list|)
condition|)
block|{
name|sprintf
argument_list|(
name|badname
argument_list|,
literal|"%s_bad%d"
argument_list|,
name|v
operator|->
name|fvarname
argument_list|,
operator|++
name|nbad
argument_list|)
expr_stmt|;
if|if
condition|(
name|substmsg
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s\n\tsubstituting \"%s\""
argument_list|,
name|already
argument_list|,
name|badname
argument_list|)
expr_stmt|;
name|dclerr
argument_list|(
name|buf
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
else|else
name|dclerr
argument_list|(
name|already
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|p
operator|=
name|mkext
argument_list|(
name|v
operator|->
name|fvarname
argument_list|,
name|badname
argument_list|)
expr_stmt|;
block|}
name|v
operator|->
name|vstg
operator|=
name|STGAUTO
expr_stmt|;
name|v
operator|->
name|vprocclass
operator|=
name|PTHISPROC
expr_stmt|;
name|v
operator|->
name|vclass
operator|=
name|CLPROC
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|extstg
operator|==
name|STGEXT
condition|)
name|prev_proc
operator|=
literal|1
expr_stmt|;
else|else
name|p
operator|->
name|extstg
operator|=
name|STGEXT
expr_stmt|;
name|p
operator|->
name|extinit
operator|=
name|YES
expr_stmt|;
name|v
operator|->
name|vardesc
operator|.
name|varno
operator|=
name|p
operator|-
name|extsymtab
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|entrypt
parameter_list|(
name|class
parameter_list|,
name|type
parameter_list|,
name|length
parameter_list|,
name|entry
parameter_list|,
name|args
parameter_list|)
name|int
name|class
decl_stmt|;
name|int
name|type
decl_stmt|;
name|ftnint
name|length
decl_stmt|;
name|Extsym
modifier|*
name|entry
decl_stmt|;
name|chainp
name|args
decl_stmt|;
else|#
directive|else
function|entrypt
parameter_list|(
name|int
name|class
parameter_list|,
name|int
name|type
parameter_list|,
name|ftnint
name|length
parameter_list|,
name|Extsym
modifier|*
name|entry
parameter_list|,
name|chainp
name|args
parameter_list|)
endif|#
directive|endif
block|{
specifier|register
name|Namep
name|q
decl_stmt|;
specifier|register
name|struct
name|Entrypoint
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|class
operator|!=
name|CLENTRY
condition|)
name|puthead
argument_list|(
name|procname
operator|=
name|entry
operator|->
name|cextname
argument_list|,
name|class
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"       entry "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"   %s:\n"
argument_list|,
name|entry
operator|->
name|fextname
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|diagfile
argument_list|)
expr_stmt|;
name|q
operator|=
name|mkname
argument_list|(
name|entry
operator|->
name|fextname
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|TYSUBR
condition|)
name|q
operator|->
name|vstg
operator|=
name|STGEXT
expr_stmt|;
name|type
operator|=
name|lengtype
argument_list|(
name|type
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|class
operator|==
name|CLPROC
condition|)
block|{
name|procclass
operator|=
name|CLPROC
expr_stmt|;
name|proctype
operator|=
name|type
expr_stmt|;
name|procleng
operator|=
name|type
operator|==
name|TYCHAR
condition|?
name|length
else|:
literal|0
expr_stmt|;
block|}
name|p
operator|=
name|ALLOC
argument_list|(
name|Entrypoint
argument_list|)
expr_stmt|;
name|p
operator|->
name|entnextp
operator|=
name|entries
expr_stmt|;
name|entries
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|entryname
operator|=
name|entry
expr_stmt|;
name|p
operator|->
name|arglist
operator|=
name|revchain
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|p
operator|->
name|enamep
operator|=
name|q
expr_stmt|;
if|if
condition|(
name|class
operator|==
name|CLENTRY
condition|)
block|{
name|class
operator|=
name|CLPROC
expr_stmt|;
if|if
condition|(
name|proctype
operator|==
name|TYSUBR
condition|)
name|type
operator|=
name|TYSUBR
expr_stmt|;
block|}
name|q
operator|->
name|vclass
operator|=
name|class
expr_stmt|;
name|q
operator|->
name|vprocclass
operator|=
literal|0
expr_stmt|;
name|settype
argument_list|(
name|q
argument_list|,
name|type
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|q
operator|->
name|vprocclass
operator|=
name|PTHISPROC
expr_stmt|;
comment|/* hold all initial entry points till end of declarations */
if|if
condition|(
name|parstate
operator|>=
name|INDATA
condition|)
name|doentry
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* generate epilogs */
end_comment

begin_comment
comment|/* epicode -- write out the proper function return mechanism at the end of    the procedure declaration.  Handles multiple return value types, as    well as cooercion into the proper value */
end_comment

begin_function
name|LOCAL
name|void
name|epicode
parameter_list|(
name|Void
parameter_list|)
block|{
specifier|extern
name|int
name|lastwasbranch
decl_stmt|;
if|if
condition|(
name|procclass
operator|==
name|CLPROC
condition|)
block|{
if|if
condition|(
name|proctype
operator|==
name|TYSUBR
condition|)
block|{
comment|/* Return a zero only when the alternate return mechanism has been    specified in the function header */
if|if
condition|(
operator|(
name|substars
operator|||
name|Ansi
operator|)
operator|&&
name|lastwasbranch
operator|!=
name|YES
condition|)
name|p1_subr_ret
argument_list|(
name|ICON
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|multitype
operator|&&
name|lastwasbranch
operator|!=
name|YES
condition|)
name|retval
argument_list|(
name|proctype
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|procclass
operator|==
name|CLMAIN
operator|&&
name|Ansi
operator|&&
name|lastwasbranch
operator|!=
name|YES
condition|)
name|p1_subr_ret
argument_list|(
name|ICON
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|lastwasbranch
operator|=
name|NO
expr_stmt|;
block|}
end_function

begin_comment
comment|/* generate code to return value of type  t */
end_comment

begin_function
name|LOCAL
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|retval
parameter_list|(
name|t
parameter_list|)
specifier|register
name|int
name|t
decl_stmt|;
else|#
directive|else
function|retval
parameter_list|(
specifier|register
name|int
name|t
parameter_list|)
endif|#
directive|endif
block|{
specifier|register
name|Addrp
name|p
decl_stmt|;
switch|switch
condition|(
name|t
condition|)
block|{
case|case
name|TYCHAR
case|:
case|case
name|TYCOMPLEX
case|:
case|case
name|TYDCOMPLEX
case|:
break|break;
case|case
name|TYLOGICAL
case|:
name|t
operator|=
name|tylogical
expr_stmt|;
case|case
name|TYINT1
case|:
case|case
name|TYADDR
case|:
case|case
name|TYSHORT
case|:
case|case
name|TYLONG
case|:
ifdef|#
directive|ifdef
name|TYQUAD
case|case
name|TYQUAD
case|:
endif|#
directive|endif
case|case
name|TYREAL
case|:
case|case
name|TYDREAL
case|:
case|case
name|TYLOGICAL1
case|:
case|case
name|TYLOGICAL2
case|:
name|p
operator|=
operator|(
name|Addrp
operator|)
name|cpexpr
argument_list|(
operator|(
name|expptr
operator|)
name|retslot
argument_list|)
expr_stmt|;
name|p
operator|->
name|vtype
operator|=
name|t
expr_stmt|;
name|p1_subr_ret
argument_list|(
name|mkconv
argument_list|(
name|t
argument_list|,
name|fixtype
argument_list|(
operator|(
name|expptr
operator|)
name|p
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|badtype
argument_list|(
literal|"retval"
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Do parameter adjustments */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|procode
parameter_list|(
name|outfile
parameter_list|)
name|FILE
modifier|*
name|outfile
decl_stmt|;
else|#
directive|else
function|procode
parameter_list|(
name|FILE
modifier|*
name|outfile
parameter_list|)
endif|#
directive|endif
block|{
name|prolog
argument_list|(
name|outfile
argument_list|,
name|allargs
argument_list|)
expr_stmt|;
if|if
condition|(
name|nentry
operator|>
literal|1
condition|)
name|entry_goto
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|bad_dimtype
parameter_list|(
name|q
parameter_list|)
name|Namep
name|q
decl_stmt|;
else|#
directive|else
function|bad_dimtype
parameter_list|(
name|Namep
name|q
parameter_list|)
endif|#
directive|endif
block|{
name|errstr
argument_list|(
literal|"bad dimension type for %.70s"
argument_list|,
name|q
operator|->
name|fvarname
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish bound computations now that all variables are declared.  * This used to be in setbound(), but under -u the following incurred  * an erroneous error message:  *	subroutine foo(x,n)  *	real x(n)  *	integer n  */
end_comment

begin_function
specifier|static
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|dim_finish
parameter_list|(
name|v
parameter_list|)
name|Namep
name|v
decl_stmt|;
else|#
directive|else
function|dim_finish
parameter_list|(
name|Namep
name|v
parameter_list|)
endif|#
directive|endif
block|{
specifier|register
name|struct
name|Dimblock
modifier|*
name|p
decl_stmt|;
specifier|register
name|expptr
name|q
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|nd
decl_stmt|;
name|p
operator|=
name|v
operator|->
name|vdim
expr_stmt|;
name|v
operator|->
name|vdimfinish
operator|=
literal|0
expr_stmt|;
name|nd
operator|=
name|p
operator|->
name|ndim
expr_stmt|;
name|doin_setbound
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nd
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|q
operator|=
name|p
operator|->
name|dims
index|[
name|i
index|]
operator|.
name|dimexpr
condition|)
block|{
name|q
operator|=
name|p
operator|->
name|dims
index|[
name|i
index|]
operator|.
name|dimexpr
operator|=
name|make_int_expr
argument_list|(
name|putx
argument_list|(
name|fixtype
argument_list|(
name|q
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ONEOF
argument_list|(
name|q
operator|->
name|headblock
operator|.
name|vtype
argument_list|,
name|MSKINT
operator||
name|MSKREAL
argument_list|)
condition|)
name|bad_dimtype
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|q
operator|=
name|p
operator|->
name|basexpr
condition|)
name|p
operator|->
name|basexpr
operator|=
name|make_int_expr
argument_list|(
name|putx
argument_list|(
name|fixtype
argument_list|(
name|q
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|doin_setbound
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|duparg
parameter_list|(
name|q
parameter_list|)
name|Namep
name|q
decl_stmt|;
else|#
directive|else
function|duparg
parameter_list|(
name|Namep
name|q
parameter_list|)
endif|#
directive|endif
block|{
name|errstr
argument_list|(
literal|"duplicate argument %.80s"
argument_list|,
name|q
operator|->
name|fvarname
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*    manipulate argument lists (allocate argument slot positions)  * keep track of return types and labels  */
end_comment

begin_function
name|LOCAL
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|doentry
parameter_list|(
name|ep
parameter_list|)
name|struct
name|Entrypoint
modifier|*
name|ep
decl_stmt|;
else|#
directive|else
function|doentry
parameter_list|(
name|struct
name|Entrypoint
modifier|*
name|ep
parameter_list|)
endif|#
directive|endif
block|{
specifier|register
name|int
name|type
decl_stmt|;
specifier|register
name|Namep
name|np
decl_stmt|;
name|chainp
name|p
decl_stmt|,
name|p1
decl_stmt|;
specifier|register
name|Namep
name|q
decl_stmt|;
name|Addrp
name|rs
decl_stmt|;
name|int
name|it
decl_stmt|,
name|k
decl_stmt|;
specifier|extern
name|char
name|dflttype
index|[
literal|26
index|]
decl_stmt|;
name|Extsym
modifier|*
name|entryname
init|=
name|ep
operator|->
name|entryname
decl_stmt|;
if|if
condition|(
operator|++
name|nentry
operator|>
literal|1
condition|)
name|p1_label
argument_list|(
call|(
name|long
call|)
argument_list|(
name|extsymtab
operator|-
name|entryname
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The main program isn't allowed to have parameters, so any given    parameters are ignored */
if|if
condition|(
name|procclass
operator|==
name|CLMAIN
operator|||
name|procclass
operator|==
name|CLBLOCK
condition|)
return|return;
comment|/* So now we're working with something other than CLMAIN or CLBLOCK.    Determine the type of its return value. */
name|impldcl
argument_list|(
name|np
operator|=
name|mkname
argument_list|(
name|entryname
operator|->
name|fextname
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|np
operator|->
name|vtype
expr_stmt|;
name|proc_argchanges
operator|=
name|prev_proc
operator|&&
name|type
operator|!=
name|entryname
operator|->
name|extype
expr_stmt|;
name|entryname
operator|->
name|extseen
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|proctype
operator|==
name|TYUNKNOWN
condition|)
if|if
condition|(
operator|(
name|proctype
operator|=
name|type
operator|)
operator|==
name|TYCHAR
condition|)
name|procleng
operator|=
name|np
operator|->
name|vleng
condition|?
name|np
operator|->
name|vleng
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
else|:
call|(
name|ftnint
call|)
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|proctype
operator|==
name|TYCHAR
condition|)
block|{
if|if
condition|(
name|type
operator|!=
name|TYCHAR
condition|)
name|err
argument_list|(
literal|"noncharacter entry of character function"
argument_list|)
expr_stmt|;
comment|/* Functions returning type   char   can only have multiple entries if all    entries return the same length */
elseif|else
if|if
condition|(
operator|(
name|np
operator|->
name|vleng
condition|?
name|np
operator|->
name|vleng
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
else|:
call|(
name|ftnint
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|)
operator|!=
name|procleng
condition|)
name|err
argument_list|(
literal|"mismatched character entry lengths"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|TYCHAR
condition|)
name|err
argument_list|(
literal|"character entry of noncharacter function"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|!=
name|proctype
condition|)
name|multitype
operator|=
name|YES
expr_stmt|;
if|if
condition|(
name|rtvlabel
index|[
name|type
index|]
operator|==
literal|0
condition|)
name|rtvlabel
index|[
name|type
index|]
operator|=
operator|(
name|int
operator|)
name|newlabel
argument_list|()
expr_stmt|;
name|ep
operator|->
name|typelabel
operator|=
name|rtvlabel
index|[
name|type
index|]
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|TYCHAR
condition|)
block|{
if|if
condition|(
name|chslot
operator|<
literal|0
condition|)
block|{
name|chslot
operator|=
name|nextarg
argument_list|(
name|TYADDR
argument_list|)
expr_stmt|;
name|chlgslot
operator|=
name|nextarg
argument_list|(
name|TYLENG
argument_list|)
expr_stmt|;
block|}
name|np
operator|->
name|vstg
operator|=
name|STGARG
expr_stmt|;
comment|/* Put a new argument in the function, one which will hold the result of    a character function.  This will have to be named sometime, probably in    mkarg(). */
if|if
condition|(
name|procleng
operator|<
literal|0
condition|)
block|{
name|np
operator|->
name|vleng
operator|=
operator|(
name|expptr
operator|)
name|mkarg
argument_list|(
name|TYLENG
argument_list|,
name|chlgslot
argument_list|)
expr_stmt|;
name|np
operator|->
name|vleng
operator|->
name|addrblock
operator|.
name|uname_tag
operator|=
name|UNAM_IDENT
expr_stmt|;
name|strcpy
argument_list|(
name|np
operator|->
name|vleng
operator|->
name|addrblock
operator|.
name|user
operator|.
name|ident
argument_list|,
name|new_func_length
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|xretslot
index|[
name|TYCHAR
index|]
condition|)
block|{
name|xretslot
index|[
name|TYCHAR
index|]
operator|=
name|rs
operator|=
name|autovar
argument_list|(
literal|0
argument_list|,
name|type
argument_list|,
name|ISCONST
argument_list|(
name|np
operator|->
name|vleng
argument_list|)
condition|?
name|np
operator|->
name|vleng
else|:
name|ICON
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|rs
operator|->
name|user
operator|.
name|ident
argument_list|,
literal|"ret_val"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Handle a   complex   return type -- declare a new parameter (pointer to    a complex value) */
elseif|else
if|if
condition|(
name|ISCOMPLEX
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|xretslot
index|[
name|type
index|]
condition|)
name|xretslot
index|[
name|type
index|]
operator|=
name|autovar
argument_list|(
literal|0
argument_list|,
name|type
argument_list|,
name|EXNULL
argument_list|,
literal|" ret_val"
argument_list|)
expr_stmt|;
comment|/* the blank is for use in out_addr */
name|np
operator|->
name|vstg
operator|=
name|STGARG
expr_stmt|;
if|if
condition|(
name|cxslot
operator|<
literal|0
condition|)
name|cxslot
operator|=
name|nextarg
argument_list|(
name|TYADDR
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|!=
name|TYSUBR
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|TYUNKNOWN
condition|)
block|{
name|dclerr
argument_list|(
literal|"untyped function"
argument_list|,
name|np
argument_list|)
expr_stmt|;
name|proctype
operator|=
name|type
operator|=
name|np
operator|->
name|vtype
operator|=
name|dflttype
index|[
name|letter
argument_list|(
name|np
operator|->
name|fvarname
index|[
literal|0
index|]
argument_list|)
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|xretslot
index|[
name|type
index|]
condition|)
name|xretslot
index|[
name|type
index|]
operator|=
name|retslot
operator|=
name|autovar
argument_list|(
literal|1
argument_list|,
name|type
argument_list|,
name|EXNULL
argument_list|,
literal|" ret_val"
argument_list|)
expr_stmt|;
comment|/* the blank is for use in out_addr */
name|np
operator|->
name|vstg
operator|=
name|STGAUTO
expr_stmt|;
block|}
for|for
control|(
name|p
operator|=
name|ep
operator|->
name|arglist
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|nextp
control|)
if|if
condition|(
operator|!
operator|(
operator|(
name|q
operator|=
call|(
name|Namep
call|)
argument_list|(
name|p
operator|->
name|datap
argument_list|)
operator|)
operator|->
name|vknownarg
operator|)
condition|)
block|{
name|q
operator|->
name|vknownarg
operator|=
literal|1
expr_stmt|;
name|q
operator|->
name|vardesc
operator|.
name|varno
operator|=
name|nextarg
argument_list|(
name|TYADDR
argument_list|)
expr_stmt|;
name|allargs
operator|=
name|mkchain
argument_list|(
operator|(
name|char
operator|*
operator|)
name|q
argument_list|,
name|allargs
argument_list|)
expr_stmt|;
name|q
operator|->
name|argno
operator|=
name|nallargs
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nentry
operator|==
literal|1
condition|)
name|duparg
argument_list|(
name|q
argument_list|)
expr_stmt|;
else|else
for|for
control|(
name|p1
operator|=
name|ep
operator|->
name|arglist
init|;
name|p1
operator|!=
name|p
condition|;
name|p1
operator|=
name|p1
operator|->
name|nextp
control|)
if|if
condition|(
operator|(
name|Namep
operator|)
name|p1
operator|->
name|datap
operator|==
name|q
condition|)
name|duparg
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|k
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|ep
operator|->
name|arglist
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|nextp
control|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|q
operator|=
call|(
name|Namep
call|)
argument_list|(
name|p
operator|->
name|datap
argument_list|)
operator|)
operator|->
name|vdcldone
operator|)
condition|)
block|{
name|impldcl
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|q
operator|->
name|vdcldone
operator|=
name|YES
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|vtype
operator|==
name|TYCHAR
condition|)
block|{
comment|/* If we don't know the length of a char*(*) (i.e. a string), we must add    in this additional length argument. */
operator|++
name|nallchargs
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|vclass
operator|==
name|CLPROC
condition|)
name|nallchargs
operator|--
expr_stmt|;
elseif|else
if|if
condition|(
name|q
operator|->
name|vleng
operator|==
name|NULL
condition|)
block|{
comment|/* character*(*) */
name|q
operator|->
name|vleng
operator|=
operator|(
name|expptr
operator|)
name|mkarg
argument_list|(
name|TYLENG
argument_list|,
name|nextarg
argument_list|(
name|TYLENG
argument_list|)
argument_list|)
expr_stmt|;
name|unamstring
argument_list|(
operator|(
name|Addrp
operator|)
name|q
operator|->
name|vleng
argument_list|,
name|new_arg_length
argument_list|(
name|q
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|q
operator|->
name|vdimfinish
condition|)
name|dim_finish
argument_list|(
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|vtype
operator|==
name|TYCHAR
operator|&&
name|q
operator|->
name|vclass
operator|!=
name|CLPROC
condition|)
name|k
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|entryname
operator|->
name|extype
operator|!=
name|type
condition|)
name|changedtype
argument_list|(
name|np
argument_list|)
expr_stmt|;
comment|/* save information for checking consistency of arg lists */
name|it
operator|=
name|infertypes
expr_stmt|;
if|if
condition|(
name|entryname
operator|->
name|exproto
condition|)
name|infertypes
operator|=
literal|1
expr_stmt|;
name|save_argtypes
argument_list|(
name|ep
operator|->
name|arglist
argument_list|,
operator|&
name|entryname
operator|->
name|arginfo
argument_list|,
operator|&
name|np
operator|->
name|arginfo
argument_list|,
literal|0
argument_list|,
name|np
operator|->
name|fvarname
argument_list|,
name|STGEXT
argument_list|,
name|k
argument_list|,
name|np
operator|->
name|vtype
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|infertypes
operator|=
name|it
expr_stmt|;
block|}
end_function

begin_function
name|LOCAL
name|int
ifdef|#
directive|ifdef
name|KR_headers
name|nextarg
parameter_list|(
name|type
parameter_list|)
name|int
name|type
decl_stmt|;
else|#
directive|else
function|nextarg
parameter_list|(
name|int
name|type
parameter_list|)
endif|#
directive|endif
block|{
name|type
operator|=
name|type
expr_stmt|;
comment|/* shut up warning */
return|return
operator|(
name|lastargslot
operator|++
operator|)
return|;
block|}
end_function

begin_function
name|LOCAL
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|dim_check
parameter_list|(
name|q
parameter_list|)
name|Namep
name|q
decl_stmt|;
else|#
directive|else
function|dim_check
parameter_list|(
name|Namep
name|q
parameter_list|)
endif|#
directive|endif
block|{
specifier|register
name|struct
name|Dimblock
modifier|*
name|vdim
init|=
name|q
operator|->
name|vdim
decl_stmt|;
specifier|register
name|expptr
name|nelt
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|nelt
operator|=
name|vdim
operator|->
name|nelt
operator|)
operator|||
operator|!
name|ISCONST
argument_list|(
name|nelt
argument_list|)
condition|)
name|dclerr
argument_list|(
literal|"adjustable dimension on non-argument"
argument_list|,
name|q
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|ONEOF
argument_list|(
name|nelt
operator|->
name|headblock
operator|.
name|vtype
argument_list|,
name|MSKINT
operator||
name|MSKREAL
argument_list|)
condition|)
name|bad_dimtype
argument_list|(
name|q
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ISINT
argument_list|(
name|nelt
operator|->
name|headblock
operator|.
name|vtype
argument_list|)
operator|&&
name|nelt
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
operator|<=
literal|0
operator|||
name|nelt
operator|->
name|constblock
operator|.
name|Const
operator|.
name|cd
index|[
literal|0
index|]
operator|<=
literal|0
condition|)
name|dclerr
argument_list|(
literal|"nonpositive dimension"
argument_list|,
name|q
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|LOCAL
name|void
name|dobss
parameter_list|(
name|Void
parameter_list|)
block|{
specifier|register
name|struct
name|Hashentry
modifier|*
name|p
decl_stmt|;
specifier|register
name|Namep
name|q
decl_stmt|;
name|int
name|qstg
decl_stmt|,
name|qclass
decl_stmt|,
name|qtype
decl_stmt|;
name|Extsym
modifier|*
name|e
decl_stmt|;
for|for
control|(
name|p
operator|=
name|hashtab
init|;
name|p
operator|<
name|lasthash
condition|;
operator|++
name|p
control|)
if|if
condition|(
name|q
operator|=
name|p
operator|->
name|varp
condition|)
block|{
name|qstg
operator|=
name|q
operator|->
name|vstg
expr_stmt|;
name|qtype
operator|=
name|q
operator|->
name|vtype
expr_stmt|;
name|qclass
operator|=
name|q
operator|->
name|vclass
expr_stmt|;
if|if
condition|(
operator|(
name|qclass
operator|==
name|CLUNKNOWN
operator|&&
name|qstg
operator|!=
name|STGARG
operator|)
operator|||
operator|(
name|qclass
operator|==
name|CLVAR
operator|&&
name|qstg
operator|==
name|STGUNKNOWN
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|q
operator|->
name|vis_assigned
operator||
name|q
operator|->
name|vimpldovar
operator|)
condition|)
name|warn1
argument_list|(
literal|"local variable %s never used"
argument_list|,
name|q
operator|->
name|fvarname
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|qclass
operator|==
name|CLVAR
operator|&&
name|qstg
operator|==
name|STGBSS
condition|)
block|{
empty_stmt|;
block|}
comment|/* Give external procedures the proper storage class */
elseif|else
if|if
condition|(
name|qclass
operator|==
name|CLPROC
operator|&&
name|q
operator|->
name|vprocclass
operator|==
name|PEXTERNAL
operator|&&
name|qstg
operator|!=
name|STGARG
condition|)
block|{
name|e
operator|=
name|mkext
argument_list|(
name|q
operator|->
name|fvarname
argument_list|,
name|addunder
argument_list|(
name|q
operator|->
name|cvarname
argument_list|)
argument_list|)
expr_stmt|;
name|e
operator|->
name|extstg
operator|=
name|STGEXT
expr_stmt|;
name|q
operator|->
name|vardesc
operator|.
name|varno
operator|=
name|e
operator|-
name|extsymtab
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|extype
operator|!=
name|qtype
condition|)
name|changedtype
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|qclass
operator|==
name|CLVAR
condition|)
block|{
if|if
condition|(
name|qstg
operator|!=
name|STGARG
operator|&&
name|q
operator|->
name|vdim
condition|)
name|dim_check
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
comment|/* if qclass == CLVAR */
block|}
block|}
end_function

begin_function
name|void
name|donmlist
parameter_list|(
name|Void
parameter_list|)
block|{
specifier|register
name|struct
name|Hashentry
modifier|*
name|p
decl_stmt|;
specifier|register
name|Namep
name|q
decl_stmt|;
for|for
control|(
name|p
operator|=
name|hashtab
init|;
name|p
operator|<
name|lasthash
condition|;
operator|++
name|p
control|)
if|if
condition|(
operator|(
name|q
operator|=
name|p
operator|->
name|varp
operator|)
operator|&&
name|q
operator|->
name|vclass
operator|==
name|CLNAMELIST
condition|)
name|namelist
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* iarrlen -- Returns the size of the array in bytes, or -1 */
end_comment

begin_function
name|ftnint
ifdef|#
directive|ifdef
name|KR_headers
name|iarrlen
parameter_list|(
name|q
parameter_list|)
specifier|register
name|Namep
name|q
decl_stmt|;
else|#
directive|else
function|iarrlen
parameter_list|(
specifier|register
name|Namep
name|q
parameter_list|)
endif|#
directive|endif
block|{
name|ftnint
name|leng
decl_stmt|;
name|leng
operator|=
name|typesize
index|[
name|q
operator|->
name|vtype
index|]
expr_stmt|;
if|if
condition|(
name|leng
operator|<=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|q
operator|->
name|vdim
condition|)
if|if
condition|(
name|ISICON
argument_list|(
name|q
operator|->
name|vdim
operator|->
name|nelt
argument_list|)
condition|)
name|leng
operator|*=
name|q
operator|->
name|vdim
operator|->
name|nelt
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
expr_stmt|;
else|else
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|q
operator|->
name|vleng
condition|)
if|if
condition|(
name|ISICON
argument_list|(
name|q
operator|->
name|vleng
argument_list|)
condition|)
name|leng
operator|*=
name|q
operator|->
name|vleng
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
expr_stmt|;
else|else
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
name|leng
operator|)
return|;
block|}
end_function

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|namelist
parameter_list|(
name|np
parameter_list|)
name|Namep
name|np
decl_stmt|;
else|#
directive|else
function|namelist
parameter_list|(
name|Namep
name|np
parameter_list|)
endif|#
directive|endif
block|{
specifier|register
name|chainp
name|q
decl_stmt|;
specifier|register
name|Namep
name|v
decl_stmt|;
name|int
name|y
decl_stmt|;
if|if
condition|(
operator|!
name|np
operator|->
name|visused
condition|)
return|return;
name|y
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|q
operator|=
name|np
operator|->
name|varxptr
operator|.
name|namelist
init|;
name|q
condition|;
name|q
operator|=
name|q
operator|->
name|nextp
control|)
block|{
name|vardcl
argument_list|(
name|v
operator|=
call|(
name|Namep
call|)
argument_list|(
name|q
operator|->
name|datap
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ONEOF
argument_list|(
name|v
operator|->
name|vstg
argument_list|,
name|MSKSTATIC
argument_list|)
condition|)
name|dclerr
argument_list|(
literal|"may not appear in namelist"
argument_list|,
name|v
argument_list|)
expr_stmt|;
else|else
block|{
name|v
operator|->
name|vnamelist
operator|=
literal|1
expr_stmt|;
name|v
operator|->
name|visused
operator|=
literal|1
expr_stmt|;
name|v
operator|->
name|vsave
operator|=
literal|1
expr_stmt|;
name|y
operator|=
literal|1
expr_stmt|;
block|}
name|np
operator|->
name|visused
operator|=
name|y
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* docommon -- called at the end of procedure declarations, before    equivalences and the procedure body */
end_comment

begin_function
name|LOCAL
name|void
name|docommon
parameter_list|(
name|Void
parameter_list|)
block|{
specifier|register
name|Extsym
modifier|*
name|extptr
decl_stmt|;
specifier|register
name|chainp
name|q
decl_stmt|,
name|q1
decl_stmt|;
name|struct
name|Dimblock
modifier|*
name|t
decl_stmt|;
name|expptr
name|neltp
decl_stmt|;
specifier|register
name|Namep
name|comvar
decl_stmt|;
name|ftnint
name|size
decl_stmt|;
name|int
name|i
decl_stmt|,
name|k
decl_stmt|,
name|pref
decl_stmt|,
name|type
decl_stmt|;
specifier|extern
name|int
name|type_pref
index|[]
decl_stmt|;
for|for
control|(
name|extptr
operator|=
name|extsymtab
init|;
name|extptr
operator|<
name|nextext
condition|;
operator|++
name|extptr
control|)
if|if
condition|(
name|extptr
operator|->
name|extstg
operator|==
name|STGCOMMON
operator|&&
operator|(
name|q
operator|=
name|extptr
operator|->
name|extp
operator|)
condition|)
block|{
comment|/* If a common declaration also had a list of variables ... */
name|q
operator|=
name|extptr
operator|->
name|extp
operator|=
name|revchain
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|pref
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|k
operator|=
name|TYCHAR
init|;
name|q
condition|;
name|q
operator|=
name|q
operator|->
name|nextp
control|)
block|{
name|comvar
operator|=
call|(
name|Namep
call|)
argument_list|(
name|q
operator|->
name|datap
argument_list|)
expr_stmt|;
if|if
condition|(
name|comvar
operator|->
name|vdcldone
operator|==
name|NO
condition|)
name|vardcl
argument_list|(
name|comvar
argument_list|)
expr_stmt|;
name|type
operator|=
name|comvar
operator|->
name|vtype
expr_stmt|;
if|if
condition|(
name|pref
operator|<
name|type_pref
index|[
name|type
index|]
condition|)
name|pref
operator|=
name|type_pref
index|[
name|k
operator|=
name|type
index|]
expr_stmt|;
if|if
condition|(
name|extptr
operator|->
name|extleng
operator|%
name|typealign
index|[
name|type
index|]
operator|!=
literal|0
condition|)
block|{
name|dclerr
argument_list|(
literal|"common alignment"
argument_list|,
name|comvar
argument_list|)
expr_stmt|;
operator|--
name|nerr
expr_stmt|;
comment|/* don't give bad return code for this */
if|#
directive|if
literal|0
block|extptr->extleng = roundup(extptr->extleng, typealign[type]);
endif|#
directive|endif
block|}
comment|/* if extptr -> extleng % */
comment|/* Set the offset into the common block */
name|comvar
operator|->
name|voffset
operator|=
name|extptr
operator|->
name|extleng
expr_stmt|;
name|comvar
operator|->
name|vardesc
operator|.
name|varno
operator|=
name|extptr
operator|-
name|extsymtab
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|TYCHAR
condition|)
if|if
condition|(
name|comvar
operator|->
name|vleng
condition|)
name|size
operator|=
name|comvar
operator|->
name|vleng
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
expr_stmt|;
else|else
block|{
name|dclerr
argument_list|(
literal|"character*(*) in common"
argument_list|,
name|comvar
argument_list|)
expr_stmt|;
name|size
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|size
operator|=
name|typesize
index|[
name|type
index|]
expr_stmt|;
if|if
condition|(
name|t
operator|=
name|comvar
operator|->
name|vdim
condition|)
if|if
condition|(
operator|(
name|neltp
operator|=
name|t
operator|->
name|nelt
operator|)
operator|&&
name|ISCONST
argument_list|(
name|neltp
argument_list|)
condition|)
name|size
operator|*=
name|neltp
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
expr_stmt|;
else|else
name|dclerr
argument_list|(
literal|"adjustable array in common"
argument_list|,
name|comvar
argument_list|)
expr_stmt|;
comment|/* Adjust the length of the common block so far */
name|extptr
operator|->
name|extleng
operator|+=
name|size
expr_stmt|;
block|}
comment|/* for */
name|extptr
operator|->
name|extype
operator|=
name|k
expr_stmt|;
comment|/* Determine curno and, if new, save this identifier chain */
name|q1
operator|=
name|extptr
operator|->
name|extp
expr_stmt|;
for|for
control|(
name|q
operator|=
name|extptr
operator|->
name|allextp
operator|,
name|i
operator|=
literal|0
init|;
name|q
condition|;
name|i
operator|++
operator|,
name|q
operator|=
name|q
operator|->
name|nextp
control|)
if|if
condition|(
name|struct_eq
argument_list|(
operator|(
name|chainp
operator|)
name|q
operator|->
name|datap
argument_list|,
name|q1
argument_list|)
condition|)
break|break;
if|if
condition|(
name|q
condition|)
name|extptr
operator|->
name|curno
operator|=
name|extptr
operator|->
name|maxno
operator|-
name|i
expr_stmt|;
else|else
block|{
name|extptr
operator|->
name|curno
operator|=
operator|++
name|extptr
operator|->
name|maxno
expr_stmt|;
name|extptr
operator|->
name|allextp
operator|=
name|mkchain
argument_list|(
operator|(
name|char
operator|*
operator|)
name|extptr
operator|->
name|extp
argument_list|,
name|extptr
operator|->
name|allextp
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* if extptr -> extstg == STGCOMMON */
comment|/* Now the hash table entries have STGCOMMON, vdcldone, voffset, and    varno.  And the common block itself has its full size in extleng. */
block|}
end_function

begin_comment
comment|/* docommon */
end_comment

begin_comment
comment|/* copy_data -- copy the Namep entries so they are available even after    the hash table is empty */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|copy_data
parameter_list|(
name|list
parameter_list|)
name|chainp
name|list
decl_stmt|;
else|#
directive|else
function|copy_data
parameter_list|(
name|chainp
name|list
parameter_list|)
endif|#
directive|endif
block|{
for|for
control|(
init|;
name|list
condition|;
name|list
operator|=
name|list
operator|->
name|nextp
control|)
block|{
name|Namep
name|namep
init|=
name|ALLOC
argument_list|(
name|Nameblock
argument_list|)
decl_stmt|;
name|int
name|size
decl_stmt|,
name|nd
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|Dimblock
modifier|*
name|dp
decl_stmt|;
name|cpn
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|Nameblock
argument_list|)
argument_list|,
name|list
operator|->
name|datap
argument_list|,
operator|(
name|char
operator|*
operator|)
name|namep
argument_list|)
expr_stmt|;
name|namep
operator|->
name|fvarname
operator|=
name|strcpy
argument_list|(
name|gmem
argument_list|(
name|strlen
argument_list|(
name|namep
operator|->
name|fvarname
argument_list|)
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|namep
operator|->
name|fvarname
argument_list|)
expr_stmt|;
name|namep
operator|->
name|cvarname
operator|=
name|strcmp
argument_list|(
name|namep
operator|->
name|fvarname
argument_list|,
name|namep
operator|->
name|cvarname
argument_list|)
condition|?
name|strcpy
argument_list|(
name|gmem
argument_list|(
name|strlen
argument_list|(
name|namep
operator|->
name|cvarname
argument_list|)
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|namep
operator|->
name|cvarname
argument_list|)
else|:
name|namep
operator|->
name|fvarname
expr_stmt|;
if|if
condition|(
name|namep
operator|->
name|vleng
condition|)
name|namep
operator|->
name|vleng
operator|=
operator|(
name|expptr
operator|)
name|cpexpr
argument_list|(
name|namep
operator|->
name|vleng
argument_list|)
expr_stmt|;
if|if
condition|(
name|namep
operator|->
name|vdim
condition|)
block|{
name|nd
operator|=
name|namep
operator|->
name|vdim
operator|->
name|ndim
expr_stmt|;
name|size
operator|=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|+
operator|(
literal|3
operator|+
literal|2
operator|*
name|nd
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|expptr
argument_list|)
expr_stmt|;
name|dp
operator|=
operator|(
expr|struct
name|Dimblock
operator|*
operator|)
name|ckalloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|cpn
argument_list|(
name|size
argument_list|,
operator|(
name|char
operator|*
operator|)
name|namep
operator|->
name|vdim
argument_list|,
operator|(
name|char
operator|*
operator|)
name|dp
argument_list|)
expr_stmt|;
name|namep
operator|->
name|vdim
operator|=
name|dp
expr_stmt|;
name|dp
operator|->
name|nelt
operator|=
operator|(
name|expptr
operator|)
name|cpexpr
argument_list|(
name|dp
operator|->
name|nelt
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nd
condition|;
name|i
operator|++
control|)
block|{
name|dp
operator|->
name|dims
index|[
name|i
index|]
operator|.
name|dimsize
operator|=
operator|(
name|expptr
operator|)
name|cpexpr
argument_list|(
name|dp
operator|->
name|dims
index|[
name|i
index|]
operator|.
name|dimsize
argument_list|)
expr_stmt|;
block|}
comment|/* for */
block|}
comment|/* if */
name|list
operator|->
name|datap
operator|=
operator|(
name|char
operator|*
operator|)
name|namep
expr_stmt|;
block|}
comment|/* for */
block|}
end_function

begin_comment
comment|/* copy_data */
end_comment

begin_function
name|LOCAL
name|void
name|docomleng
parameter_list|(
name|Void
parameter_list|)
block|{
specifier|register
name|Extsym
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|extsymtab
init|;
name|p
operator|<
name|nextext
condition|;
operator|++
name|p
control|)
if|if
condition|(
name|p
operator|->
name|extstg
operator|==
name|STGCOMMON
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|maxleng
operator|!=
literal|0
operator|&&
name|p
operator|->
name|extleng
operator|!=
literal|0
operator|&&
name|p
operator|->
name|maxleng
operator|!=
name|p
operator|->
name|extleng
operator|&&
name|strcmp
argument_list|(
name|Blank
argument_list|,
name|p
operator|->
name|cextname
argument_list|)
condition|)
name|warn1
argument_list|(
literal|"incompatible lengths for common block %.60s"
argument_list|,
name|p
operator|->
name|fextname
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|maxleng
operator|<
name|p
operator|->
name|extleng
condition|)
name|p
operator|->
name|maxleng
operator|=
name|p
operator|->
name|extleng
expr_stmt|;
name|p
operator|->
name|extleng
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ROUTINES DEALING WITH AUTOMATIC AND TEMPORARY STORAGE */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|frtemp
parameter_list|(
name|p
parameter_list|)
name|Addrp
name|p
decl_stmt|;
else|#
directive|else
function|frtemp
parameter_list|(
name|Addrp
name|p
parameter_list|)
endif|#
directive|endif
block|{
comment|/* put block on chain of temps to be reclaimed */
name|holdtemps
operator|=
name|mkchain
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
argument_list|,
name|holdtemps
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|freetemps
parameter_list|(
name|Void
parameter_list|)
block|{
specifier|register
name|chainp
name|p
decl_stmt|,
name|p1
decl_stmt|;
specifier|register
name|Addrp
name|q
decl_stmt|;
specifier|register
name|int
name|t
decl_stmt|;
name|p1
operator|=
name|holdtemps
expr_stmt|;
while|while
condition|(
name|p
operator|=
name|p1
condition|)
block|{
name|q
operator|=
operator|(
name|Addrp
operator|)
name|p
operator|->
name|datap
expr_stmt|;
name|t
operator|=
name|q
operator|->
name|vtype
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|TYCHAR
operator|&&
name|q
operator|->
name|varleng
operator|!=
literal|0
condition|)
block|{
comment|/* restore clobbered character string lengths */
name|frexpr
argument_list|(
name|q
operator|->
name|vleng
argument_list|)
expr_stmt|;
name|q
operator|->
name|vleng
operator|=
name|ICON
argument_list|(
name|q
operator|->
name|varleng
argument_list|)
expr_stmt|;
block|}
name|p1
operator|=
name|p
operator|->
name|nextp
expr_stmt|;
name|p
operator|->
name|nextp
operator|=
name|templist
index|[
name|t
index|]
expr_stmt|;
name|templist
index|[
name|t
index|]
operator|=
name|p
expr_stmt|;
block|}
name|holdtemps
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* allocate an automatic variable slot for each of   nelt   variables */
end_comment

begin_function
name|Addrp
ifdef|#
directive|ifdef
name|KR_headers
name|autovar
parameter_list|(
name|nelt0
parameter_list|,
name|t
parameter_list|,
name|lengp
parameter_list|,
name|name
parameter_list|)
specifier|register
name|int
name|nelt0
decl_stmt|;
specifier|register
name|int
name|t
decl_stmt|;
name|expptr
name|lengp
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
else|#
directive|else
function|autovar
parameter_list|(
specifier|register
name|int
name|nelt0
parameter_list|,
specifier|register
name|int
name|t
parameter_list|,
name|expptr
name|lengp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
endif|#
directive|endif
block|{
name|ftnint
name|leng
decl_stmt|;
specifier|register
name|Addrp
name|q
decl_stmt|;
specifier|register
name|int
name|nelt
init|=
name|nelt0
operator|>
literal|0
condition|?
name|nelt0
else|:
literal|1
decl_stmt|;
specifier|extern
name|char
modifier|*
name|av_pfix
index|[]
decl_stmt|;
if|if
condition|(
name|t
operator|==
name|TYCHAR
condition|)
if|if
condition|(
name|ISICON
argument_list|(
name|lengp
argument_list|)
condition|)
name|leng
operator|=
name|lengp
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
expr_stmt|;
else|else
block|{
name|Fatal
argument_list|(
literal|"automatic variable of nonconstant length"
argument_list|)
expr_stmt|;
block|}
else|else
name|leng
operator|=
name|typesize
index|[
name|t
index|]
expr_stmt|;
name|q
operator|=
name|ALLOC
argument_list|(
name|Addrblock
argument_list|)
expr_stmt|;
name|q
operator|->
name|tag
operator|=
name|TADDR
expr_stmt|;
name|q
operator|->
name|vtype
operator|=
name|t
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|TYCHAR
condition|)
block|{
name|q
operator|->
name|vleng
operator|=
name|ICON
argument_list|(
name|leng
argument_list|)
expr_stmt|;
name|q
operator|->
name|varleng
operator|=
name|leng
expr_stmt|;
block|}
name|q
operator|->
name|vstg
operator|=
name|STGAUTO
expr_stmt|;
name|q
operator|->
name|ntempelt
operator|=
name|nelt
expr_stmt|;
name|q
operator|->
name|isarray
operator|=
operator|(
name|nelt
operator|>
literal|1
operator|)
expr_stmt|;
name|q
operator|->
name|memoffset
operator|=
name|ICON
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* kludge for nls so we can have ret_val rather than ret_val_4 */
if|if
condition|(
operator|*
name|name
operator|==
literal|' '
condition|)
name|unamstring
argument_list|(
name|q
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
block|{
name|q
operator|->
name|uname_tag
operator|=
name|UNAM_IDENT
expr_stmt|;
name|temp_name
argument_list|(
name|av_pfix
index|[
name|t
index|]
argument_list|,
operator|++
name|autonum
index|[
name|t
index|]
argument_list|,
name|q
operator|->
name|user
operator|.
name|ident
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nelt0
operator|>
literal|0
condition|)
name|declare_new_addr
argument_list|(
name|q
argument_list|)
expr_stmt|;
return|return
operator|(
name|q
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Returns a temporary of the appropriate type.  Will reuse existing    temporaries when possible */
end_comment

begin_function
name|Addrp
ifdef|#
directive|ifdef
name|KR_headers
name|mktmpn
parameter_list|(
name|nelt
parameter_list|,
name|type
parameter_list|,
name|lengp
parameter_list|)
name|int
name|nelt
decl_stmt|;
specifier|register
name|int
name|type
decl_stmt|;
name|expptr
name|lengp
decl_stmt|;
else|#
directive|else
function|mktmpn
parameter_list|(
name|int
name|nelt
parameter_list|,
specifier|register
name|int
name|type
parameter_list|,
name|expptr
name|lengp
parameter_list|)
endif|#
directive|endif
block|{
name|ftnint
name|leng
decl_stmt|;
name|chainp
name|p
decl_stmt|,
name|oldp
decl_stmt|;
specifier|register
name|Addrp
name|q
decl_stmt|;
specifier|extern
name|int
name|krparens
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|TYUNKNOWN
operator|||
name|type
operator|==
name|TYERROR
condition|)
name|badtype
argument_list|(
literal|"mktmpn"
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|TYCHAR
condition|)
if|if
condition|(
name|lengp
operator|&&
name|ISICON
argument_list|(
name|lengp
argument_list|)
condition|)
name|leng
operator|=
name|lengp
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
expr_stmt|;
else|else
block|{
name|err
argument_list|(
literal|"adjustable length"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|Addrp
operator|)
name|errnode
argument_list|()
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|type
operator|>
name|TYCHAR
operator|||
name|type
operator|<
name|TYADDR
condition|)
block|{
name|erri
argument_list|(
literal|"mktmpn: unexpected type %d"
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/*  * if a temporary of appropriate shape is on the templist,  * remove it from the list and return it  */
if|if
condition|(
name|krparens
operator|==
literal|2
operator|&&
name|ONEOF
argument_list|(
name|type
argument_list|,
name|M
argument_list|(
name|TYREAL
argument_list|)
operator||
name|M
argument_list|(
name|TYCOMPLEX
argument_list|)
argument_list|)
condition|)
name|type
operator|++
expr_stmt|;
for|for
control|(
name|oldp
operator|=
name|CHNULL
operator|,
name|p
operator|=
name|templist
index|[
name|type
index|]
init|;
name|p
condition|;
name|oldp
operator|=
name|p
operator|,
name|p
operator|=
name|p
operator|->
name|nextp
control|)
block|{
name|q
operator|=
call|(
name|Addrp
call|)
argument_list|(
name|p
operator|->
name|datap
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|ntempelt
operator|==
name|nelt
operator|&&
operator|(
name|type
operator|!=
name|TYCHAR
operator|||
name|q
operator|->
name|vleng
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
operator|==
name|leng
operator|)
condition|)
block|{
if|if
condition|(
name|oldp
condition|)
name|oldp
operator|->
name|nextp
operator|=
name|p
operator|->
name|nextp
expr_stmt|;
else|else
name|templist
index|[
name|type
index|]
operator|=
name|p
operator|->
name|nextp
expr_stmt|;
name|free
argument_list|(
operator|(
name|charptr
operator|)
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|q
operator|)
return|;
block|}
block|}
name|q
operator|=
name|autovar
argument_list|(
name|nelt
argument_list|,
name|type
argument_list|,
name|lengp
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
operator|(
name|q
operator|)
return|;
block|}
end_function

begin_comment
comment|/* mktmp -- create new local variable; call it something like   name    lengp   is taken directly, not copied */
end_comment

begin_function
name|Addrp
ifdef|#
directive|ifdef
name|KR_headers
name|mktmp
parameter_list|(
name|type
parameter_list|,
name|lengp
parameter_list|)
name|int
name|type
decl_stmt|;
name|expptr
name|lengp
decl_stmt|;
else|#
directive|else
function|mktmp
parameter_list|(
name|int
name|type
parameter_list|,
name|expptr
name|lengp
parameter_list|)
endif|#
directive|endif
block|{
name|Addrp
name|rv
decl_stmt|;
comment|/* arrange for temporaries to be recycled */
comment|/* at the end of this statement... */
name|rv
operator|=
name|mktmpn
argument_list|(
literal|1
argument_list|,
name|type
argument_list|,
name|lengp
argument_list|)
expr_stmt|;
name|frtemp
argument_list|(
operator|(
name|Addrp
operator|)
name|cpexpr
argument_list|(
operator|(
name|expptr
operator|)
name|rv
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|rv
return|;
block|}
end_function

begin_comment
comment|/* mktmp0 omits frtemp() */
end_comment

begin_function
name|Addrp
ifdef|#
directive|ifdef
name|KR_headers
name|mktmp0
parameter_list|(
name|type
parameter_list|,
name|lengp
parameter_list|)
name|int
name|type
decl_stmt|;
name|expptr
name|lengp
decl_stmt|;
else|#
directive|else
function|mktmp0
parameter_list|(
name|int
name|type
parameter_list|,
name|expptr
name|lengp
parameter_list|)
endif|#
directive|endif
block|{
name|Addrp
name|rv
decl_stmt|;
comment|/* arrange for temporaries to be recycled */
comment|/* when this Addrp is freed */
name|rv
operator|=
name|mktmpn
argument_list|(
literal|1
argument_list|,
name|type
argument_list|,
name|lengp
argument_list|)
expr_stmt|;
name|rv
operator|->
name|istemp
operator|=
name|YES
expr_stmt|;
return|return
name|rv
return|;
block|}
end_function

begin_comment
comment|/* VARIOUS ROUTINES FOR PROCESSING DECLARATIONS */
end_comment

begin_comment
comment|/* comblock -- Declare a new common block.  Input parameters name the block;    s   will be NULL if the block is unnamed */
end_comment

begin_function
name|Extsym
modifier|*
ifdef|#
directive|ifdef
name|KR_headers
name|comblock
parameter_list|(
name|s
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
else|#
directive|else
function|comblock
parameter_list|(
specifier|register
name|char
modifier|*
name|s
parameter_list|)
endif|#
directive|endif
block|{
name|Extsym
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|t
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|,
name|i
decl_stmt|;
name|char
name|cbuf
index|[
literal|256
index|]
decl_stmt|,
modifier|*
name|s0
decl_stmt|;
comment|/* Give the unnamed common block a unique name */
if|if
condition|(
operator|*
name|s
operator|==
literal|0
condition|)
name|p
operator|=
name|mkext1
argument_list|(
name|s0
operator|=
name|Blank
argument_list|,
name|Blank
argument_list|)
expr_stmt|;
else|else
block|{
name|s0
operator|=
name|s
expr_stmt|;
name|t
operator|=
name|cbuf
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|c
operator|=
operator|*
name|t
operator|=
operator|*
name|s
operator|++
condition|;
name|t
operator|++
control|)
if|if
condition|(
name|c
operator|==
literal|'_'
condition|)
name|i
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|i
condition|)
operator|*
name|t
operator|++
operator|=
literal|'_'
expr_stmt|;
name|t
index|[
literal|0
index|]
operator|=
literal|'_'
expr_stmt|;
name|t
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|mkext1
argument_list|(
name|s0
argument_list|,
name|cbuf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|extstg
operator|==
name|STGUNKNOWN
condition|)
name|p
operator|->
name|extstg
operator|=
name|STGCOMMON
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|->
name|extstg
operator|!=
name|STGCOMMON
condition|)
block|{
name|errstr
argument_list|(
literal|"%.52s cannot be a common block: it is a subprogram."
argument_list|,
name|s0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/* incomm -- add a new variable to a common declaration */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|incomm
parameter_list|(
name|c
parameter_list|,
name|v
parameter_list|)
name|Extsym
modifier|*
name|c
decl_stmt|;
name|Namep
name|v
decl_stmt|;
else|#
directive|else
function|incomm
parameter_list|(
name|Extsym
modifier|*
name|c
parameter_list|,
name|Namep
name|v
parameter_list|)
endif|#
directive|endif
block|{
if|if
condition|(
operator|!
name|c
condition|)
return|return;
if|if
condition|(
name|v
operator|->
name|vstg
operator|!=
name|STGUNKNOWN
operator|&&
operator|!
name|v
operator|->
name|vimplstg
condition|)
name|dclerr
argument_list|(
name|v
operator|->
name|vstg
operator|==
name|STGARG
condition|?
literal|"dummy arguments cannot be in common"
else|:
literal|"incompatible common declaration"
argument_list|,
name|v
argument_list|)
expr_stmt|;
else|else
block|{
name|v
operator|->
name|vstg
operator|=
name|STGCOMMON
expr_stmt|;
name|c
operator|->
name|extp
operator|=
name|mkchain
argument_list|(
operator|(
name|char
operator|*
operator|)
name|v
argument_list|,
name|c
operator|->
name|extp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* settype -- set the type or storage class of a Namep object.  If    v -> vstg == STGUNKNOWN&& type< 0,   attempt to reset vstg to be    -type.  This function will not change any earlier definitions in   v,    in will only attempt to fill out more information give the other params */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|settype
parameter_list|(
name|v
parameter_list|,
name|type
parameter_list|,
name|length
parameter_list|)
specifier|register
name|Namep
name|v
decl_stmt|;
specifier|register
name|int
name|type
decl_stmt|;
specifier|register
name|ftnint
name|length
decl_stmt|;
else|#
directive|else
function|settype
parameter_list|(
specifier|register
name|Namep
name|v
parameter_list|,
specifier|register
name|int
name|type
parameter_list|,
specifier|register
name|ftnint
name|length
parameter_list|)
endif|#
directive|endif
block|{
name|int
name|type1
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|TYUNKNOWN
condition|)
return|return;
if|if
condition|(
name|type
operator|==
name|TYSUBR
operator|&&
name|v
operator|->
name|vtype
operator|!=
name|TYUNKNOWN
operator|&&
name|v
operator|->
name|vstg
operator|==
name|STGARG
condition|)
block|{
name|v
operator|->
name|vtype
operator|=
name|TYSUBR
expr_stmt|;
name|frexpr
argument_list|(
name|v
operator|->
name|vleng
argument_list|)
expr_stmt|;
name|v
operator|->
name|vleng
operator|=
literal|0
expr_stmt|;
name|v
operator|->
name|vimpltype
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|<
literal|0
condition|)
comment|/* storage class set */
block|{
if|if
condition|(
name|v
operator|->
name|vstg
operator|==
name|STGUNKNOWN
condition|)
name|v
operator|->
name|vstg
operator|=
operator|-
name|type
expr_stmt|;
elseif|else
if|if
condition|(
name|v
operator|->
name|vstg
operator|!=
operator|-
name|type
condition|)
name|dclerr
argument_list|(
literal|"incompatible storage declarations"
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|v
operator|->
name|vtype
operator|==
name|TYUNKNOWN
operator|||
name|v
operator|->
name|vtype
operator|!=
name|type
operator|&&
operator|(
name|v
operator|->
name|vimpltype
operator|||
name|v
operator|->
name|vinftype
operator|||
name|v
operator|->
name|vinfproc
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|v
operator|->
name|vtype
operator|=
name|lengtype
argument_list|(
name|type
argument_list|,
name|length
argument_list|)
operator|)
operator|==
name|TYCHAR
condition|)
if|if
condition|(
name|length
operator|>=
literal|0
condition|)
name|v
operator|->
name|vleng
operator|=
name|ICON
argument_list|(
name|length
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|parstate
operator|>=
name|INDATA
condition|)
name|v
operator|->
name|vleng
operator|=
name|ICON
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* avoid a memory fault */
name|v
operator|->
name|vimpltype
operator|=
literal|0
expr_stmt|;
name|v
operator|->
name|vinftype
operator|=
literal|0
expr_stmt|;
comment|/* 19960709 */
name|v
operator|->
name|vinfproc
operator|=
literal|0
expr_stmt|;
comment|/* 19960709 */
if|if
condition|(
name|v
operator|->
name|vclass
operator|==
name|CLPROC
condition|)
block|{
if|if
condition|(
name|v
operator|->
name|vstg
operator|==
name|STGEXT
operator|&&
operator|(
name|type1
operator|=
name|extsymtab
index|[
name|v
operator|->
name|vardesc
operator|.
name|varno
index|]
operator|.
name|extype
operator|)
operator|&&
name|type1
operator|!=
name|v
operator|->
name|vtype
condition|)
name|changedtype
argument_list|(
name|v
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|v
operator|->
name|vprocclass
operator|==
name|PTHISPROC
operator|&&
operator|(
name|parstate
operator|>=
name|INDATA
operator|||
name|procclass
operator|==
name|CLMAIN
operator|)
operator|&&
operator|!
name|xretslot
index|[
name|type
index|]
condition|)
block|{
name|xretslot
index|[
name|type
index|]
operator|=
name|autovar
argument_list|(
name|ONEOF
argument_list|(
name|type
argument_list|,
name|MSKCOMPLEX
operator||
name|MSKCHAR
argument_list|)
condition|?
literal|0
else|:
literal|1
argument_list|,
name|type
argument_list|,
name|v
operator|->
name|vleng
argument_list|,
literal|" ret_val"
argument_list|)
expr_stmt|;
if|if
condition|(
name|procclass
operator|==
name|CLMAIN
condition|)
name|errstr
argument_list|(
literal|"illegal use of %.60s (main program name)"
argument_list|,
name|v
operator|->
name|fvarname
argument_list|)
expr_stmt|;
comment|/* not completely right, but enough to */
comment|/* avoid memory faults; we won't */
comment|/* emit any C as we have illegal Fortran */
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|v
operator|->
name|vtype
operator|!=
name|type
operator|&&
name|v
operator|->
name|vtype
operator|!=
name|lengtype
argument_list|(
name|type
argument_list|,
name|length
argument_list|)
condition|)
block|{
name|incompat
label|:
name|dclerr
argument_list|(
literal|"incompatible type declarations"
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|TYCHAR
condition|)
if|if
condition|(
name|v
operator|->
name|vleng
operator|&&
name|v
operator|->
name|vleng
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
operator|!=
name|length
condition|)
goto|goto
name|incompat
goto|;
elseif|else
if|if
condition|(
name|parstate
operator|>=
name|INDATA
condition|)
name|v
operator|->
name|vleng
operator|=
name|ICON
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* avoid a memory fault */
block|}
end_function

begin_comment
comment|/* lengtype -- returns the proper compiler type, given input of Fortran    type and length specifier */
end_comment

begin_function
name|int
ifdef|#
directive|ifdef
name|KR_headers
name|lengtype
parameter_list|(
name|type
parameter_list|,
name|len
parameter_list|)
specifier|register
name|int
name|type
decl_stmt|;
name|ftnint
name|len
decl_stmt|;
else|#
directive|else
function|lengtype
parameter_list|(
specifier|register
name|int
name|type
parameter_list|,
name|ftnint
name|len
parameter_list|)
endif|#
directive|endif
block|{
specifier|register
name|int
name|length
init|=
operator|(
name|int
operator|)
name|len
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|TYREAL
case|:
if|if
condition|(
name|length
operator|==
name|typesize
index|[
name|TYDREAL
index|]
condition|)
return|return
operator|(
name|TYDREAL
operator|)
return|;
if|if
condition|(
name|length
operator|==
name|typesize
index|[
name|TYREAL
index|]
condition|)
goto|goto
name|ret
goto|;
break|break;
case|case
name|TYCOMPLEX
case|:
if|if
condition|(
name|length
operator|==
name|typesize
index|[
name|TYDCOMPLEX
index|]
condition|)
return|return
operator|(
name|TYDCOMPLEX
operator|)
return|;
if|if
condition|(
name|length
operator|==
name|typesize
index|[
name|TYCOMPLEX
index|]
condition|)
goto|goto
name|ret
goto|;
break|break;
case|case
name|TYINT1
case|:
case|case
name|TYSHORT
case|:
case|case
name|TYDREAL
case|:
case|case
name|TYDCOMPLEX
case|:
case|case
name|TYCHAR
case|:
case|case
name|TYLOGICAL1
case|:
case|case
name|TYLOGICAL2
case|:
case|case
name|TYUNKNOWN
case|:
case|case
name|TYSUBR
case|:
case|case
name|TYERROR
case|:
ifdef|#
directive|ifdef
name|TYQUAD
case|case
name|TYQUAD
case|:
endif|#
directive|endif
goto|goto
name|ret
goto|;
case|case
name|TYLOGICAL
case|:
switch|switch
condition|(
name|length
condition|)
block|{
case|case
literal|0
case|:
return|return
name|tylog
return|;
case|case
literal|1
case|:
return|return
name|TYLOGICAL1
return|;
case|case
literal|2
case|:
return|return
name|TYLOGICAL2
return|;
case|case
literal|4
case|:
goto|goto
name|ret
goto|;
block|}
break|break;
case|case
name|TYLONG
case|:
if|if
condition|(
name|length
operator|==
literal|0
condition|)
return|return
operator|(
name|tyint
operator|)
return|;
if|if
condition|(
name|length
operator|==
literal|1
condition|)
return|return
name|TYINT1
return|;
if|if
condition|(
name|length
operator|==
name|typesize
index|[
name|TYSHORT
index|]
condition|)
return|return
operator|(
name|TYSHORT
operator|)
return|;
ifdef|#
directive|ifdef
name|TYQUAD
if|if
condition|(
name|length
operator|==
name|typesize
index|[
name|TYQUAD
index|]
operator|&&
name|use_tyquad
condition|)
return|return
operator|(
name|TYQUAD
operator|)
return|;
endif|#
directive|endif
if|if
condition|(
name|length
operator|==
name|typesize
index|[
name|TYLONG
index|]
condition|)
goto|goto
name|ret
goto|;
break|break;
default|default:
name|badtype
argument_list|(
literal|"lengtype"
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|!=
literal|0
condition|)
name|err
argument_list|(
literal|"incompatible type-length combination"
argument_list|)
expr_stmt|;
name|ret
label|:
return|return
operator|(
name|type
operator|)
return|;
block|}
end_function

begin_comment
comment|/* setintr -- Set Intrinsic function */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|setintr
parameter_list|(
name|v
parameter_list|)
specifier|register
name|Namep
name|v
decl_stmt|;
else|#
directive|else
function|setintr
parameter_list|(
specifier|register
name|Namep
name|v
parameter_list|)
endif|#
directive|endif
block|{
name|int
name|k
decl_stmt|;
if|if
condition|(
name|k
operator|=
name|intrfunct
argument_list|(
name|v
operator|->
name|fvarname
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
operator|*
operator|(
expr|struct
name|Intrpacked
operator|*
operator|)
operator|&
name|k
operator|)
operator|.
name|f4
condition|)
if|if
condition|(
name|noextflag
condition|)
goto|goto
name|unknown
goto|;
else|else
name|dcomplex_seen
operator|++
expr_stmt|;
name|v
operator|->
name|vardesc
operator|.
name|varno
operator|=
name|k
expr_stmt|;
block|}
else|else
block|{
name|unknown
label|:
name|dclerr
argument_list|(
literal|"unknown intrinsic function"
argument_list|,
name|v
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|v
operator|->
name|vstg
operator|==
name|STGUNKNOWN
condition|)
name|v
operator|->
name|vstg
operator|=
name|STGINTR
expr_stmt|;
elseif|else
if|if
condition|(
name|v
operator|->
name|vstg
operator|!=
name|STGINTR
condition|)
name|dclerr
argument_list|(
literal|"incompatible use of intrinsic function"
argument_list|,
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|vclass
operator|==
name|CLUNKNOWN
condition|)
name|v
operator|->
name|vclass
operator|=
name|CLPROC
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|vprocclass
operator|==
name|PUNKNOWN
condition|)
name|v
operator|->
name|vprocclass
operator|=
name|PINTRINSIC
expr_stmt|;
elseif|else
if|if
condition|(
name|v
operator|->
name|vprocclass
operator|!=
name|PINTRINSIC
condition|)
name|dclerr
argument_list|(
literal|"invalid intrinsic declaration"
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* setext -- Set External declaration -- assume that unknowns will become    procedures */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|setext
parameter_list|(
name|v
parameter_list|)
specifier|register
name|Namep
name|v
decl_stmt|;
else|#
directive|else
function|setext
parameter_list|(
specifier|register
name|Namep
name|v
parameter_list|)
endif|#
directive|endif
block|{
if|if
condition|(
name|v
operator|->
name|vclass
operator|==
name|CLUNKNOWN
condition|)
name|v
operator|->
name|vclass
operator|=
name|CLPROC
expr_stmt|;
elseif|else
if|if
condition|(
name|v
operator|->
name|vclass
operator|!=
name|CLPROC
condition|)
name|dclerr
argument_list|(
literal|"invalid external declaration"
argument_list|,
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|vprocclass
operator|==
name|PUNKNOWN
condition|)
name|v
operator|->
name|vprocclass
operator|=
name|PEXTERNAL
expr_stmt|;
elseif|else
if|if
condition|(
name|v
operator|->
name|vprocclass
operator|!=
name|PEXTERNAL
condition|)
name|dclerr
argument_list|(
literal|"invalid external declaration"
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* setext */
end_comment

begin_comment
comment|/* create dimensions block for array variable */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|setbound
parameter_list|(
name|v
parameter_list|,
name|nd
parameter_list|,
name|dims
parameter_list|)
specifier|register
name|Namep
name|v
decl_stmt|;
name|int
name|nd
decl_stmt|;
name|struct
name|Dims
modifier|*
name|dims
decl_stmt|;
else|#
directive|else
function|setbound
parameter_list|(
specifier|register
name|Namep
name|v
parameter_list|,
name|int
name|nd
parameter_list|,
name|struct
name|Dims
modifier|*
name|dims
parameter_list|)
endif|#
directive|endif
block|{
specifier|register
name|expptr
name|q
decl_stmt|,
name|t
decl_stmt|;
specifier|register
name|struct
name|Dimblock
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|extern
name|chainp
name|new_vars
decl_stmt|;
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
if|if
condition|(
name|v
operator|->
name|vclass
operator|==
name|CLUNKNOWN
condition|)
name|v
operator|->
name|vclass
operator|=
name|CLVAR
expr_stmt|;
elseif|else
if|if
condition|(
name|v
operator|->
name|vclass
operator|!=
name|CLVAR
condition|)
block|{
name|dclerr
argument_list|(
literal|"only variables may be arrays"
argument_list|,
name|v
argument_list|)
expr_stmt|;
return|return;
block|}
name|v
operator|->
name|vdim
operator|=
name|p
operator|=
operator|(
expr|struct
name|Dimblock
operator|*
operator|)
name|ckalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|+
operator|(
literal|3
operator|+
literal|2
operator|*
name|nd
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|expptr
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|ndim
operator|=
name|nd
operator|--
expr_stmt|;
name|p
operator|->
name|nelt
operator|=
name|ICON
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|doin_setbound
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|noextflag
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|nd
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
operator|(
name|q
operator|=
name|dims
index|[
name|i
index|]
operator|.
name|lb
operator|)
operator|&&
operator|!
name|ISINT
argument_list|(
name|q
operator|->
name|headblock
operator|.
name|vtype
argument_list|)
operator|)
operator|||
operator|(
operator|(
name|q
operator|=
name|dims
index|[
name|i
index|]
operator|.
name|ub
operator|)
operator|&&
operator|!
name|ISINT
argument_list|(
name|q
operator|->
name|headblock
operator|.
name|vtype
argument_list|)
operator|)
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"dimension %d of %s is not an integer."
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|v
operator|->
name|fvarname
argument_list|)
expr_stmt|;
name|errext
argument_list|(
name|buf
argument_list|)
expr_stmt|;
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|nd
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|q
operator|=
name|dims
index|[
name|i
index|]
operator|.
name|lb
operator|)
operator|&&
operator|!
name|ISINT
argument_list|(
name|q
operator|->
name|headblock
operator|.
name|vtype
argument_list|)
operator|)
condition|)
name|dims
index|[
name|i
index|]
operator|.
name|lb
operator|=
name|mkconv
argument_list|(
name|TYINT
argument_list|,
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|q
operator|=
name|dims
index|[
name|i
index|]
operator|.
name|ub
operator|)
operator|&&
operator|!
name|ISINT
argument_list|(
name|q
operator|->
name|headblock
operator|.
name|vtype
argument_list|)
operator|)
condition|)
name|dims
index|[
name|i
index|]
operator|.
name|ub
operator|=
name|mkconv
argument_list|(
name|TYINT
argument_list|,
name|q
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|nd
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|(
name|q
operator|=
name|dims
index|[
name|i
index|]
operator|.
name|ub
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|i
operator|==
name|nd
condition|)
block|{
name|frexpr
argument_list|(
name|p
operator|->
name|nelt
argument_list|)
expr_stmt|;
name|p
operator|->
name|nelt
operator|=
name|NULL
expr_stmt|;
block|}
else|else
name|err
argument_list|(
literal|"only last bound may be asterisk"
argument_list|)
expr_stmt|;
name|p
operator|->
name|dims
index|[
name|i
index|]
operator|.
name|dimsize
operator|=
name|ICON
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|p
operator|->
name|dims
index|[
name|i
index|]
operator|.
name|dimexpr
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|dims
index|[
name|i
index|]
operator|.
name|lb
condition|)
block|{
name|q
operator|=
name|mkexpr
argument_list|(
name|OPMINUS
argument_list|,
name|q
argument_list|,
name|cpexpr
argument_list|(
name|dims
index|[
name|i
index|]
operator|.
name|lb
argument_list|)
argument_list|)
expr_stmt|;
name|q
operator|=
name|mkexpr
argument_list|(
name|OPPLUS
argument_list|,
name|q
argument_list|,
name|ICON
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ISCONST
argument_list|(
name|q
argument_list|)
condition|)
block|{
name|p
operator|->
name|dims
index|[
name|i
index|]
operator|.
name|dimsize
operator|=
name|q
expr_stmt|;
name|p
operator|->
name|dims
index|[
name|i
index|]
operator|.
name|dimexpr
operator|=
operator|(
name|expptr
operator|)
name|PNULL
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|" %s_dim%d"
argument_list|,
name|v
operator|->
name|fvarname
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|p
operator|->
name|dims
index|[
name|i
index|]
operator|.
name|dimsize
operator|=
operator|(
name|expptr
operator|)
name|autovar
argument_list|(
literal|1
argument_list|,
name|tyint
argument_list|,
name|EXNULL
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|p
operator|->
name|dims
index|[
name|i
index|]
operator|.
name|dimexpr
operator|=
name|q
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|nd
condition|)
name|v
operator|->
name|vlastdim
operator|=
name|new_vars
expr_stmt|;
name|v
operator|->
name|vdimfinish
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|nelt
condition|)
name|p
operator|->
name|nelt
operator|=
name|mkexpr
argument_list|(
name|OPSTAR
argument_list|,
name|p
operator|->
name|nelt
argument_list|,
name|cpexpr
argument_list|(
name|p
operator|->
name|dims
index|[
name|i
index|]
operator|.
name|dimsize
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|q
operator|=
name|dims
index|[
name|nd
index|]
operator|.
name|lb
expr_stmt|;
if|if
condition|(
name|q
operator|==
name|NULL
condition|)
name|q
operator|=
name|ICON
argument_list|(
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|nd
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|t
operator|=
name|dims
index|[
name|i
index|]
operator|.
name|lb
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL
condition|)
name|t
operator|=
name|ICON
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|dims
index|[
name|i
index|]
operator|.
name|dimsize
condition|)
name|q
operator|=
name|mkexpr
argument_list|(
name|OPPLUS
argument_list|,
name|t
argument_list|,
name|mkexpr
argument_list|(
name|OPSTAR
argument_list|,
name|cpexpr
argument_list|(
name|p
operator|->
name|dims
index|[
name|i
index|]
operator|.
name|dimsize
argument_list|)
argument_list|,
name|q
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ISCONST
argument_list|(
name|q
argument_list|)
condition|)
block|{
name|p
operator|->
name|baseoffset
operator|=
name|q
expr_stmt|;
name|p
operator|->
name|basexpr
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|" %s_offset"
argument_list|,
name|v
operator|->
name|fvarname
argument_list|)
expr_stmt|;
name|p
operator|->
name|baseoffset
operator|=
operator|(
name|expptr
operator|)
name|autovar
argument_list|(
literal|1
argument_list|,
name|tyint
argument_list|,
name|EXNULL
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|p
operator|->
name|basexpr
operator|=
name|q
expr_stmt|;
name|v
operator|->
name|vdimfinish
operator|=
literal|1
expr_stmt|;
block|}
name|doin_setbound
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|wr_abbrevs
parameter_list|(
name|outfile
parameter_list|,
name|function_head
parameter_list|,
name|vars
parameter_list|)
name|FILE
modifier|*
name|outfile
decl_stmt|;
name|int
name|function_head
decl_stmt|;
name|chainp
name|vars
decl_stmt|;
else|#
directive|else
function|wr_abbrevs
parameter_list|(
name|FILE
modifier|*
name|outfile
parameter_list|,
name|int
name|function_head
parameter_list|,
name|chainp
name|vars
parameter_list|)
endif|#
directive|endif
block|{
for|for
control|(
init|;
name|vars
condition|;
name|vars
operator|=
name|vars
operator|->
name|nextp
control|)
block|{
name|Namep
name|name
init|=
operator|(
name|Namep
operator|)
name|vars
operator|->
name|datap
decl_stmt|;
if|if
condition|(
operator|!
name|name
operator|->
name|visused
condition|)
continue|continue;
if|if
condition|(
name|function_head
condition|)
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"#define "
argument_list|)
expr_stmt|;
else|else
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"#undef "
argument_list|)
expr_stmt|;
name|out_name
argument_list|(
name|outfile
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|function_head
condition|)
block|{
name|Extsym
modifier|*
name|comm
init|=
operator|&
name|extsymtab
index|[
name|name
operator|->
name|vardesc
operator|.
name|varno
index|]
decl_stmt|;
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|" ("
argument_list|)
expr_stmt|;
name|extern_out
argument_list|(
name|outfile
argument_list|,
name|comm
argument_list|)
expr_stmt|;
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"%d."
argument_list|,
name|comm
operator|->
name|curno
argument_list|)
expr_stmt|;
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"%s)"
argument_list|,
name|name
operator|->
name|cvarname
argument_list|)
expr_stmt|;
block|}
comment|/* if function_head */
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/* for */
block|}
end_function

begin_comment
comment|/* wr_abbrevs */
end_comment

end_unit

