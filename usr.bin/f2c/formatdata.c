begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**************************************************************** Copyright 1990, 1991, 1993-6 by AT&T, Lucent Technologies and Bellcore.  Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that the copyright notice and this permission notice and warranty disclaimer appear in supporting documentation, and that the names of AT&T, Bell Laboratories, Lucent or Bellcore or any of their entities not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  AT&T, Lucent and Bellcore disclaim all warranties with regard to this software, including all implied warranties of merchantability and fitness.  In no event shall AT&T, Lucent or Bellcore be liable for any special, indirect or consequential damages or any damages whatsoever resulting from loss of use, data or profits, whether in an action of contract, negligence or other tortious action, arising out of or in connection with the use or performance of this software. ****************************************************************/
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"names.h"
end_include

begin_include
include|#
directive|include
file|"format.h"
end_include

begin_define
define|#
directive|define
name|MAX_INIT_LINE
value|100
end_define

begin_define
define|#
directive|define
name|NAME_MAX
value|64
end_define

begin_decl_stmt
specifier|static
name|int
name|memno2info
name|Argdcl
argument_list|(
operator|(
name|int
operator|,
name|Namep
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|initbname
decl_stmt|;
end_decl_stmt

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|list_init_data
parameter_list|(
name|Infile
parameter_list|,
name|Inname
parameter_list|,
name|outfile
parameter_list|)
name|FILE
modifier|*
modifier|*
name|Infile
decl_stmt|;
name|char
modifier|*
name|Inname
decl_stmt|;
name|FILE
modifier|*
name|outfile
decl_stmt|;
else|#
directive|else
function|list_init_data
parameter_list|(
name|FILE
modifier|*
modifier|*
name|Infile
parameter_list|,
name|char
modifier|*
name|Inname
parameter_list|,
name|FILE
modifier|*
name|outfile
parameter_list|)
endif|#
directive|endif
block|{
name|FILE
modifier|*
name|sortfp
decl_stmt|;
name|int
name|status
decl_stmt|;
name|fclose
argument_list|(
operator|*
name|Infile
argument_list|)
expr_stmt|;
operator|*
name|Infile
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|status
operator|=
name|dsort
argument_list|(
name|Inname
argument_list|,
name|sortfname
argument_list|)
condition|)
name|fatali
argument_list|(
literal|"sort failed, status %d"
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|scrub
argument_list|(
name|Inname
argument_list|)
expr_stmt|;
comment|/* optionally unlink Inname */
if|if
condition|(
operator|(
name|sortfp
operator|=
name|fopen
argument_list|(
name|sortfname
argument_list|,
name|textread
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|Fatal
argument_list|(
literal|"Couldn't open sorted initialization data"
argument_list|)
expr_stmt|;
name|do_init_data
argument_list|(
name|outfile
argument_list|,
name|sortfp
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|sortfp
argument_list|)
expr_stmt|;
name|scrub
argument_list|(
name|sortfname
argument_list|)
expr_stmt|;
comment|/* Insert a blank line after any initialized data */
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|debugflag
operator|&&
name|infname
condition|)
comment|/* don't back block data file up -- it won't be overwritten */
name|backup
argument_list|(
name|initfname
argument_list|,
name|initbname
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* list_init_data */
end_comment

begin_comment
comment|/* do_init_data -- returns YES when at least one declaration has been    written */
end_comment

begin_function
name|int
ifdef|#
directive|ifdef
name|KR_headers
name|do_init_data
parameter_list|(
name|outfile
parameter_list|,
name|infile
parameter_list|)
name|FILE
modifier|*
name|outfile
decl_stmt|;
name|FILE
modifier|*
name|infile
decl_stmt|;
else|#
directive|else
function|do_init_data
parameter_list|(
name|FILE
modifier|*
name|outfile
parameter_list|,
name|FILE
modifier|*
name|infile
parameter_list|)
endif|#
directive|endif
block|{
name|char
name|varname
index|[
name|NAME_MAX
index|]
decl_stmt|,
name|ovarname
index|[
name|NAME_MAX
index|]
decl_stmt|;
name|ftnint
name|offset
decl_stmt|;
name|ftnint
name|type
decl_stmt|;
name|int
name|vargroup
decl_stmt|;
comment|/* 0 --> init, 1 --> equiv, 2 --> common */
name|int
name|did_one
init|=
literal|0
decl_stmt|;
comment|/* True when one has been output */
name|chainp
name|values
init|=
name|CHNULL
decl_stmt|;
comment|/* Actual data values */
name|int
name|keepit
init|=
literal|0
decl_stmt|;
name|Namep
name|np
decl_stmt|;
name|ovarname
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|rdname
argument_list|(
name|infile
argument_list|,
operator|&
name|vargroup
argument_list|,
name|varname
argument_list|)
operator|&&
name|rdlong
argument_list|(
name|infile
argument_list|,
operator|&
name|offset
argument_list|)
operator|&&
name|rdlong
argument_list|(
name|infile
argument_list|,
operator|&
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|varname
argument_list|,
name|ovarname
argument_list|)
condition|)
block|{
comment|/* If this is a new variable name, the old initialization has been 	   completed */
name|wr_one_init
argument_list|(
name|outfile
argument_list|,
name|ovarname
argument_list|,
operator|&
name|values
argument_list|,
name|keepit
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|ovarname
argument_list|,
name|varname
argument_list|)
expr_stmt|;
name|values
operator|=
name|CHNULL
expr_stmt|;
if|if
condition|(
name|vargroup
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|memno2info
argument_list|(
name|atoi
argument_list|(
name|varname
operator|+
literal|2
argument_list|)
argument_list|,
operator|&
name|np
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|Addrp
operator|)
name|np
operator|)
operator|->
name|uname_tag
operator|!=
name|UNAM_NAME
condition|)
block|{
name|err
argument_list|(
literal|"do_init_data: expected NAME"
argument_list|)
expr_stmt|;
goto|goto
name|Keep
goto|;
block|}
name|np
operator|=
operator|(
operator|(
name|Addrp
operator|)
name|np
operator|)
operator|->
name|user
operator|.
name|name
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|keepit
operator|=
name|np
operator|->
name|visused
operator|)
operator|&&
operator|!
name|np
operator|->
name|vimpldovar
condition|)
name|warn1
argument_list|(
literal|"local variable %s never used"
argument_list|,
name|np
operator|->
name|fvarname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Keep
label|:
name|keepit
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|keepit
operator|&&
operator|!
name|did_one
condition|)
block|{
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"/* Initialized data */\n\n"
argument_list|)
expr_stmt|;
name|did_one
operator|=
name|YES
expr_stmt|;
block|}
block|}
comment|/* if strcmp */
name|values
operator|=
name|mkchain
argument_list|(
operator|(
name|char
operator|*
operator|)
name|data_value
argument_list|(
name|infile
argument_list|,
name|offset
argument_list|,
operator|(
name|int
operator|)
name|type
argument_list|)
argument_list|,
name|values
argument_list|)
expr_stmt|;
block|}
comment|/* while */
comment|/* Write out the last declaration */
name|wr_one_init
argument_list|(
name|outfile
argument_list|,
name|ovarname
argument_list|,
operator|&
name|values
argument_list|,
name|keepit
argument_list|)
expr_stmt|;
return|return
name|did_one
return|;
block|}
end_function

begin_comment
comment|/* do_init_data */
end_comment

begin_function
name|ftnint
ifdef|#
directive|ifdef
name|KR_headers
name|wr_char_len
parameter_list|(
name|outfile
parameter_list|,
name|dimp
parameter_list|,
name|n
parameter_list|,
name|extra1
parameter_list|)
name|FILE
modifier|*
name|outfile
decl_stmt|;
name|struct
name|Dimblock
modifier|*
name|dimp
decl_stmt|;
name|int
name|n
decl_stmt|;
name|int
name|extra1
decl_stmt|;
else|#
directive|else
function|wr_char_len
parameter_list|(
name|FILE
modifier|*
name|outfile
parameter_list|,
name|struct
name|Dimblock
modifier|*
name|dimp
parameter_list|,
name|int
name|n
parameter_list|,
name|int
name|extra1
parameter_list|)
endif|#
directive|endif
block|{
name|int
name|i
decl_stmt|,
name|nd
decl_stmt|;
name|expptr
name|e
decl_stmt|;
name|ftnint
name|j
decl_stmt|,
name|rv
decl_stmt|;
if|if
condition|(
operator|!
name|dimp
condition|)
block|{
name|nice_printf
argument_list|(
name|outfile
argument_list|,
name|extra1
condition|?
literal|"[%d+1]"
else|:
literal|"[%d]"
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
name|n
operator|+
name|extra1
return|;
block|}
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"[%d"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|nd
operator|=
name|dimp
operator|->
name|ndim
expr_stmt|;
name|rv
operator|=
name|n
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nd
condition|;
name|i
operator|++
control|)
block|{
name|e
operator|=
name|dimp
operator|->
name|dims
index|[
name|i
index|]
operator|.
name|dimsize
expr_stmt|;
if|if
condition|(
name|ISCONST
argument_list|(
name|e
argument_list|)
condition|)
block|{
if|if
condition|(
name|ISINT
argument_list|(
name|e
operator|->
name|constblock
operator|.
name|vtype
argument_list|)
condition|)
name|j
operator|=
name|e
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
expr_stmt|;
elseif|else
if|if
condition|(
name|ISREAL
argument_list|(
name|e
operator|->
name|constblock
operator|.
name|vtype
argument_list|)
condition|)
name|j
operator|=
operator|(
name|ftnint
operator|)
name|e
operator|->
name|constblock
operator|.
name|Const
operator|.
name|cd
index|[
literal|0
index|]
expr_stmt|;
else|else
goto|goto
name|non_const
goto|;
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"*%ld"
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|rv
operator|*=
name|j
expr_stmt|;
block|}
else|else
block|{
name|non_const
label|:
name|err
argument_list|(
literal|"wr_char_len:  nonconstant array size"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* extra1 allows for stupid C compilers that complain about 	 * too many initializers in 	 *	char x[2] = "ab"; 	 */
name|nice_printf
argument_list|(
name|outfile
argument_list|,
name|extra1
condition|?
literal|"+1]"
else|:
literal|"]"
argument_list|)
expr_stmt|;
return|return
name|extra1
condition|?
name|rv
operator|+
literal|1
else|:
name|rv
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|ch_ar_dim
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* length of each element of char string array */
end_comment

begin_decl_stmt
specifier|static
name|int
name|eqvmemno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* kludge */
end_comment

begin_function
specifier|static
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|write_char_init
parameter_list|(
name|outfile
parameter_list|,
name|Values
parameter_list|,
name|namep
parameter_list|)
name|FILE
modifier|*
name|outfile
decl_stmt|;
name|chainp
modifier|*
name|Values
decl_stmt|;
name|Namep
name|namep
decl_stmt|;
else|#
directive|else
function|write_char_init
parameter_list|(
name|FILE
modifier|*
name|outfile
parameter_list|,
name|chainp
modifier|*
name|Values
parameter_list|,
name|Namep
name|namep
parameter_list|)
endif|#
directive|endif
block|{
name|struct
name|Equivblock
modifier|*
name|eqv
decl_stmt|;
name|long
name|size
decl_stmt|;
name|struct
name|Dimblock
modifier|*
name|dimp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|nd
decl_stmt|,
name|type
decl_stmt|;
name|ftnint
name|j
decl_stmt|;
name|expptr
name|ds
decl_stmt|;
if|if
condition|(
operator|!
name|namep
condition|)
return|return;
if|if
condition|(
name|nequiv
operator|>=
name|maxequiv
condition|)
name|many
argument_list|(
literal|"equivalences"
argument_list|,
literal|'q'
argument_list|,
name|maxequiv
argument_list|)
expr_stmt|;
name|eqv
operator|=
operator|&
name|eqvclass
index|[
name|nequiv
index|]
expr_stmt|;
name|eqv
operator|->
name|eqvbottom
operator|=
literal|0
expr_stmt|;
name|type
operator|=
name|namep
operator|->
name|vtype
expr_stmt|;
name|size
operator|=
name|type
operator|==
name|TYCHAR
condition|?
name|namep
operator|->
name|vleng
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
else|:
name|typesize
index|[
name|type
index|]
expr_stmt|;
if|if
condition|(
name|dimp
operator|=
name|namep
operator|->
name|vdim
condition|)
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|nd
operator|=
name|dimp
operator|->
name|ndim
init|;
name|i
operator|<
name|nd
condition|;
name|i
operator|++
control|)
block|{
name|ds
operator|=
name|dimp
operator|->
name|dims
index|[
name|i
index|]
operator|.
name|dimsize
expr_stmt|;
if|if
condition|(
name|ISCONST
argument_list|(
name|ds
argument_list|)
condition|)
block|{
if|if
condition|(
name|ISINT
argument_list|(
name|ds
operator|->
name|constblock
operator|.
name|vtype
argument_list|)
condition|)
name|j
operator|=
name|ds
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
expr_stmt|;
elseif|else
if|if
condition|(
name|ISREAL
argument_list|(
name|ds
operator|->
name|constblock
operator|.
name|vtype
argument_list|)
condition|)
name|j
operator|=
operator|(
name|ftnint
operator|)
name|ds
operator|->
name|constblock
operator|.
name|Const
operator|.
name|cd
index|[
literal|0
index|]
expr_stmt|;
else|else
goto|goto
name|non_const
goto|;
name|size
operator|*=
name|j
expr_stmt|;
block|}
else|else
block|{
name|non_const
label|:
name|err
argument_list|(
literal|"write_char_values: nonconstant array size"
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|Values
operator|=
name|revchain
argument_list|(
operator|*
name|Values
argument_list|)
expr_stmt|;
name|eqv
operator|->
name|eqvtop
operator|=
name|size
expr_stmt|;
name|eqvmemno
operator|=
operator|++
name|lastvarno
expr_stmt|;
name|eqv
operator|->
name|eqvtype
operator|=
name|type
expr_stmt|;
name|wr_equiv_init
argument_list|(
name|outfile
argument_list|,
name|nequiv
argument_list|,
name|Values
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|def_start
argument_list|(
name|outfile
argument_list|,
name|namep
operator|->
name|cvarname
argument_list|,
name|CNULL
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|TYCHAR
condition|)
name|margin_printf
argument_list|(
name|outfile
argument_list|,
literal|"((char *)&equiv_%d)\n\n"
argument_list|,
name|eqvmemno
argument_list|)
expr_stmt|;
else|else
name|margin_printf
argument_list|(
name|outfile
argument_list|,
name|dimp
condition|?
literal|"((%s *)&equiv_%d)\n\n"
else|:
literal|"(*(%s *)&equiv_%d)\n\n"
argument_list|,
name|c_type_decl
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
argument_list|,
name|eqvmemno
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* wr_one_init -- outputs the initialization of the variable pointed to    by   info.   When   is_addr   is true,   info   is an Addrp; otherwise,    treat it as a Namep */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|wr_one_init
parameter_list|(
name|outfile
parameter_list|,
name|varname
parameter_list|,
name|Values
parameter_list|,
name|keepit
parameter_list|)
name|FILE
modifier|*
name|outfile
decl_stmt|;
name|char
modifier|*
name|varname
decl_stmt|;
name|chainp
modifier|*
name|Values
decl_stmt|;
name|int
name|keepit
decl_stmt|;
else|#
directive|else
function|wr_one_init
parameter_list|(
name|FILE
modifier|*
name|outfile
parameter_list|,
name|char
modifier|*
name|varname
parameter_list|,
name|chainp
modifier|*
name|Values
parameter_list|,
name|int
name|keepit
parameter_list|)
endif|#
directive|endif
block|{
specifier|static
name|int
name|memno
decl_stmt|;
specifier|static
union|union
block|{
name|Namep
name|name
decl_stmt|;
name|Addrp
name|addr
decl_stmt|;
block|}
name|info
union|;
name|Namep
name|namep
decl_stmt|;
name|int
name|is_addr
decl_stmt|,
name|size
decl_stmt|,
name|type
decl_stmt|;
name|ftnint
name|last
decl_stmt|,
name|loc
decl_stmt|;
name|int
name|is_scalar
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|array_comment
init|=
name|NULL
decl_stmt|,
modifier|*
name|name
decl_stmt|;
name|chainp
name|cp
decl_stmt|,
name|values
decl_stmt|;
specifier|extern
name|char
name|datachar
index|[]
decl_stmt|;
specifier|static
name|int
name|e1
index|[
literal|3
index|]
init|=
block|{
literal|1
block|,
literal|0
block|,
literal|1
block|}
decl_stmt|;
name|ftnint
name|x
decl_stmt|;
specifier|extern
name|int
name|hsize
decl_stmt|;
if|if
condition|(
operator|!
name|keepit
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
name|varname
operator|==
name|NULL
operator|||
name|varname
index|[
literal|1
index|]
operator|!=
literal|'.'
condition|)
goto|goto
name|badvar
goto|;
comment|/* Get back to a meaningful representation; find the given   memno in one    of the appropriate tables (user-generated variables in the hash table,    system-generated variables in a separate list */
name|memno
operator|=
name|atoi
argument_list|(
name|varname
operator|+
literal|2
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|varname
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'q'
case|:
comment|/* Must subtract eqvstart when the source file 		 * contains more than one procedure. 		 */
name|wr_equiv_init
argument_list|(
name|outfile
argument_list|,
name|eqvmemno
operator|=
name|memno
operator|-
name|eqvstart
argument_list|,
name|Values
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
case|case
literal|'Q'
case|:
comment|/* COMMON initialization (BLOCK DATA) */
name|wr_equiv_init
argument_list|(
name|outfile
argument_list|,
name|memno
argument_list|,
name|Values
argument_list|,
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
case|case
literal|'v'
case|:
break|break;
default|default:
name|badvar
label|:
name|errstr
argument_list|(
literal|"wr_one_init:  unknown variable name '%s'"
argument_list|,
name|varname
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|is_addr
operator|=
name|memno2info
argument_list|(
name|memno
argument_list|,
operator|&
name|info
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|.
name|name
operator|==
operator|(
name|Namep
operator|)
name|NULL
condition|)
block|{
name|err
argument_list|(
literal|"wr_one_init -- unknown variable"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|is_addr
condition|)
block|{
if|if
condition|(
name|info
operator|.
name|addr
operator|->
name|uname_tag
operator|!=
name|UNAM_NAME
condition|)
block|{
name|erri
argument_list|(
literal|"wr_one_init -- couldn't get name pointer; tag is %d"
argument_list|,
name|info
operator|.
name|addr
operator|->
name|uname_tag
argument_list|)
expr_stmt|;
name|namep
operator|=
operator|(
name|Namep
operator|)
name|NULL
expr_stmt|;
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|" /* bad init data */"
argument_list|)
expr_stmt|;
block|}
else|else
name|namep
operator|=
name|info
operator|.
name|addr
operator|->
name|user
operator|.
name|name
expr_stmt|;
block|}
else|else
name|namep
operator|=
name|info
operator|.
name|name
expr_stmt|;
comment|/* check for character initialization */
operator|*
name|Values
operator|=
name|values
operator|=
name|revchain
argument_list|(
operator|*
name|Values
argument_list|)
expr_stmt|;
name|type
operator|=
name|info
operator|.
name|name
operator|->
name|vtype
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|TYCHAR
condition|)
block|{
for|for
control|(
name|last
operator|=
literal|0
init|;
name|values
condition|;
name|values
operator|=
name|values
operator|->
name|nextp
control|)
block|{
name|cp
operator|=
operator|(
name|chainp
operator|)
name|values
operator|->
name|datap
expr_stmt|;
name|loc
operator|=
operator|(
name|ftnint
operator|)
name|cp
operator|->
name|datap
expr_stmt|;
if|if
condition|(
name|loc
operator|>
name|last
condition|)
block|{
name|write_char_init
argument_list|(
name|outfile
argument_list|,
name|Values
argument_list|,
name|namep
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|last
operator|=
operator|(
name|int
operator|)
name|cp
operator|->
name|nextp
operator|->
name|datap
operator|==
name|TYBLANK
condition|?
name|loc
operator|+
operator|(
name|int
operator|)
name|cp
operator|->
name|nextp
operator|->
name|nextp
operator|->
name|datap
else|:
name|loc
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|halign
operator|&&
name|info
operator|.
name|name
operator|->
name|tag
operator|==
name|TNAME
condition|)
block|{
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"static struct { %s fill; char val"
argument_list|,
name|halign
argument_list|)
expr_stmt|;
name|x
operator|=
name|wr_char_len
argument_list|(
name|outfile
argument_list|,
name|namep
operator|->
name|vdim
argument_list|,
name|ch_ar_dim
operator|=
name|info
operator|.
name|name
operator|->
name|vleng
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|%=
name|hsize
condition|)
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"; char fill2[%ld]"
argument_list|,
name|hsize
operator|-
name|x
argument_list|)
expr_stmt|;
name|name
operator|=
name|info
operator|.
name|name
operator|->
name|cvarname
expr_stmt|;
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"; } %s_st = { 0,"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|wr_output_values
argument_list|(
name|outfile
argument_list|,
name|namep
argument_list|,
operator|*
name|Values
argument_list|)
expr_stmt|;
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|" };\n"
argument_list|)
expr_stmt|;
name|ch_ar_dim
operator|=
operator|-
literal|1
expr_stmt|;
name|def_start
argument_list|(
name|outfile
argument_list|,
name|name
argument_list|,
name|CNULL
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|margin_printf
argument_list|(
name|outfile
argument_list|,
literal|"_st.val\n"
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
else|else
block|{
name|size
operator|=
name|typesize
index|[
name|type
index|]
expr_stmt|;
name|loc
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|values
condition|;
name|values
operator|=
name|values
operator|->
name|nextp
control|)
block|{
if|if
condition|(
call|(
name|int
call|)
argument_list|(
operator|(
name|chainp
operator|)
name|values
operator|->
name|datap
argument_list|)
operator|->
name|nextp
operator|->
name|datap
operator|==
name|TYCHAR
condition|)
block|{
name|write_char_init
argument_list|(
name|outfile
argument_list|,
name|Values
argument_list|,
name|namep
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|last
operator|=
operator|(
call|(
name|long
call|)
argument_list|(
operator|(
name|chainp
operator|)
name|values
operator|->
name|datap
argument_list|)
operator|->
name|datap
operator|)
operator|/
name|size
expr_stmt|;
if|if
condition|(
name|last
operator|-
name|loc
operator|>
literal|4
condition|)
block|{
name|write_char_init
argument_list|(
name|outfile
argument_list|,
name|Values
argument_list|,
name|namep
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|loc
operator|=
name|last
expr_stmt|;
block|}
block|}
name|values
operator|=
operator|*
name|Values
expr_stmt|;
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"static %s "
argument_list|,
name|c_type_decl
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_addr
condition|)
name|write_nv_ident
argument_list|(
name|outfile
argument_list|,
name|info
operator|.
name|addr
argument_list|)
expr_stmt|;
else|else
name|out_name
argument_list|(
name|outfile
argument_list|,
name|info
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|namep
condition|)
name|is_scalar
operator|=
name|namep
operator|->
name|vdim
operator|==
operator|(
expr|struct
name|Dimblock
operator|*
operator|)
name|NULL
expr_stmt|;
if|if
condition|(
name|namep
operator|&&
operator|!
name|is_scalar
condition|)
name|array_comment
operator|=
name|type
operator|==
name|TYCHAR
condition|?
literal|0
else|:
name|wr_ardecls
argument_list|(
name|outfile
argument_list|,
name|namep
operator|->
name|vdim
argument_list|,
literal|1L
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|TYCHAR
condition|)
if|if
condition|(
name|ISICON
argument_list|(
name|info
operator|.
name|name
operator|->
name|vleng
argument_list|)
condition|)
comment|/* We'll make single strings one character longer, so that we can use the    standard C initialization.  All this does is pad an extra zero onto the    end of the string */
name|wr_char_len
argument_list|(
name|outfile
argument_list|,
name|namep
operator|->
name|vdim
argument_list|,
name|ch_ar_dim
operator|=
name|info
operator|.
name|name
operator|->
name|vleng
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
argument_list|,
name|e1
index|[
name|Ansi
index|]
argument_list|)
expr_stmt|;
else|else
name|err
argument_list|(
literal|"variable length character initialization"
argument_list|)
expr_stmt|;
if|if
condition|(
name|array_comment
condition|)
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"%s"
argument_list|,
name|array_comment
argument_list|)
expr_stmt|;
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|" = "
argument_list|)
expr_stmt|;
name|wr_output_values
argument_list|(
name|outfile
argument_list|,
name|namep
argument_list|,
name|values
argument_list|)
expr_stmt|;
name|ch_ar_dim
operator|=
operator|-
literal|1
expr_stmt|;
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|";\n"
argument_list|)
expr_stmt|;
name|done
label|:
name|frchain
argument_list|(
name|Values
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* wr_one_init */
end_comment

begin_function
name|chainp
ifdef|#
directive|ifdef
name|KR_headers
name|data_value
parameter_list|(
name|infile
parameter_list|,
name|offset
parameter_list|,
name|type
parameter_list|)
name|FILE
modifier|*
name|infile
decl_stmt|;
name|ftnint
name|offset
decl_stmt|;
name|int
name|type
decl_stmt|;
else|#
directive|else
function|data_value
parameter_list|(
name|FILE
modifier|*
name|infile
parameter_list|,
name|ftnint
name|offset
parameter_list|,
name|int
name|type
parameter_list|)
endif|#
directive|endif
block|{
name|char
name|line
index|[
name|MAX_INIT_LINE
operator|+
literal|1
index|]
decl_stmt|,
modifier|*
name|pointer
decl_stmt|;
name|chainp
name|vals
decl_stmt|,
name|prev_val
decl_stmt|;
name|char
modifier|*
name|newval
decl_stmt|;
if|if
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
name|MAX_INIT_LINE
argument_list|,
name|infile
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|err
argument_list|(
literal|"data_value:  error reading from intermediate file"
argument_list|)
expr_stmt|;
return|return
name|CHNULL
return|;
block|}
comment|/* if fgets */
comment|/* Get rid of the trailing newline */
if|if
condition|(
name|line
index|[
literal|0
index|]
condition|)
name|line
index|[
name|strlen
argument_list|(
name|line
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
define|#
directive|define
name|iswhite
parameter_list|(
name|x
parameter_list|)
value|(isspace (x) || (x) == ',')
name|pointer
operator|=
name|line
expr_stmt|;
name|prev_val
operator|=
name|vals
operator|=
name|CHNULL
expr_stmt|;
while|while
condition|(
operator|*
name|pointer
condition|)
block|{
specifier|register
name|char
modifier|*
name|end_ptr
decl_stmt|,
name|old_val
decl_stmt|;
comment|/* Move   pointer   to the start of the next word */
while|while
condition|(
operator|*
name|pointer
operator|&&
name|iswhite
argument_list|(
operator|*
name|pointer
argument_list|)
condition|)
name|pointer
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|pointer
operator|==
literal|'\0'
condition|)
break|break;
comment|/* Move   end_ptr   to the end of the current word */
for|for
control|(
name|end_ptr
operator|=
name|pointer
operator|+
literal|1
init|;
operator|*
name|end_ptr
operator|&&
operator|!
name|iswhite
argument_list|(
operator|*
name|end_ptr
argument_list|)
condition|;
name|end_ptr
operator|++
control|)
empty_stmt|;
name|old_val
operator|=
operator|*
name|end_ptr
expr_stmt|;
operator|*
name|end_ptr
operator|=
literal|'\0'
expr_stmt|;
comment|/* Add this value to the end of the list */
if|if
condition|(
name|ONEOF
argument_list|(
name|type
argument_list|,
name|MSKREAL
operator||
name|MSKCOMPLEX
argument_list|)
condition|)
name|newval
operator|=
name|cpstring
argument_list|(
name|pointer
argument_list|)
expr_stmt|;
else|else
name|newval
operator|=
operator|(
name|char
operator|*
operator|)
name|atol
argument_list|(
name|pointer
argument_list|)
expr_stmt|;
if|if
condition|(
name|vals
condition|)
block|{
name|prev_val
operator|->
name|nextp
operator|=
name|mkchain
argument_list|(
name|newval
argument_list|,
name|CHNULL
argument_list|)
expr_stmt|;
name|prev_val
operator|=
name|prev_val
operator|->
name|nextp
expr_stmt|;
block|}
else|else
name|prev_val
operator|=
name|vals
operator|=
name|mkchain
argument_list|(
name|newval
argument_list|,
name|CHNULL
argument_list|)
expr_stmt|;
operator|*
name|end_ptr
operator|=
name|old_val
expr_stmt|;
name|pointer
operator|=
name|end_ptr
expr_stmt|;
block|}
comment|/* while *pointer */
return|return
name|mkchain
argument_list|(
operator|(
name|char
operator|*
operator|)
name|offset
argument_list|,
name|mkchain
argument_list|(
argument|(char *)LONG_CAST type
argument_list|,
argument|vals
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* data_value */
end_comment

begin_function
specifier|static
name|void
name|overlapping
parameter_list|(
name|Void
parameter_list|)
block|{
specifier|extern
name|char
modifier|*
name|filename0
decl_stmt|;
specifier|static
name|int
name|warned
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|warned
condition|)
return|return;
name|warned
operator|=
literal|1
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error"
argument_list|)
expr_stmt|;
if|if
condition|(
name|filename0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" in file %s"
argument_list|,
name|filename0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|": overlapping initializations\n"
argument_list|)
expr_stmt|;
name|nerr
operator|++
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|make_one_const
name|Argdcl
argument_list|(
operator|(
name|int
operator|,
expr|union
name|Constant
operator|*
operator|,
name|chainp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|charlen
decl_stmt|;
end_decl_stmt

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|wr_output_values
parameter_list|(
name|outfile
parameter_list|,
name|namep
parameter_list|,
name|values
parameter_list|)
name|FILE
modifier|*
name|outfile
decl_stmt|;
name|Namep
name|namep
decl_stmt|;
name|chainp
name|values
decl_stmt|;
else|#
directive|else
function|wr_output_values
parameter_list|(
name|FILE
modifier|*
name|outfile
parameter_list|,
name|Namep
name|namep
parameter_list|,
name|chainp
name|values
parameter_list|)
endif|#
directive|endif
block|{
name|int
name|type
init|=
name|TYUNKNOWN
decl_stmt|;
name|struct
name|Constblock
name|Const
decl_stmt|;
specifier|static
name|expptr
name|Vlen
decl_stmt|;
if|if
condition|(
name|namep
condition|)
name|type
operator|=
name|namep
operator|->
name|vtype
expr_stmt|;
comment|/* Handle array initializations away from scalars */
if|if
condition|(
name|namep
operator|&&
name|namep
operator|->
name|vdim
condition|)
name|wr_array_init
argument_list|(
name|outfile
argument_list|,
name|namep
operator|->
name|vtype
argument_list|,
name|values
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|values
operator|->
name|nextp
operator|&&
name|type
operator|!=
name|TYCHAR
condition|)
name|overlapping
argument_list|()
expr_stmt|;
else|else
block|{
name|make_one_const
argument_list|(
name|type
argument_list|,
operator|&
name|Const
operator|.
name|Const
argument_list|,
name|values
argument_list|)
expr_stmt|;
name|Const
operator|.
name|vtype
operator|=
name|type
expr_stmt|;
name|Const
operator|.
name|vstg
operator|=
name|ONEOF
argument_list|(
name|type
argument_list|,
name|MSKREAL
operator||
name|MSKCOMPLEX
argument_list|)
operator|!=
literal|0
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|TYCHAR
condition|)
block|{
if|if
condition|(
operator|!
name|Vlen
condition|)
name|Vlen
operator|=
name|ICON
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|Const
operator|.
name|vleng
operator|=
name|Vlen
expr_stmt|;
name|Vlen
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
operator|=
name|charlen
expr_stmt|;
name|out_const
argument_list|(
name|outfile
argument_list|,
operator|&
name|Const
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|Const
operator|.
name|Const
operator|.
name|ccp
argument_list|)
expr_stmt|;
block|}
else|else
name|out_const
argument_list|(
name|outfile
argument_list|,
operator|&
name|Const
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|wr_array_init
parameter_list|(
name|outfile
parameter_list|,
name|type
parameter_list|,
name|values
parameter_list|)
name|FILE
modifier|*
name|outfile
decl_stmt|;
name|int
name|type
decl_stmt|;
name|chainp
name|values
decl_stmt|;
else|#
directive|else
function|wr_array_init
parameter_list|(
name|FILE
modifier|*
name|outfile
parameter_list|,
name|int
name|type
parameter_list|,
name|chainp
name|values
parameter_list|)
endif|#
directive|endif
block|{
name|int
name|size
init|=
name|typesize
index|[
name|type
index|]
decl_stmt|;
name|long
name|index
decl_stmt|,
name|main_index
init|=
literal|0
decl_stmt|;
name|int
name|k
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|TYCHAR
condition|)
block|{
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"\""
argument_list|)
expr_stmt|;
name|k
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|Ansi
operator|!=
literal|1
condition|)
name|ch_ar_dim
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"{ "
argument_list|)
expr_stmt|;
while|while
condition|(
name|values
condition|)
block|{
name|struct
name|Constblock
name|Const
decl_stmt|;
name|index
operator|=
operator|(
call|(
name|long
call|)
argument_list|(
operator|(
name|chainp
operator|)
name|values
operator|->
name|datap
argument_list|)
operator|->
name|datap
operator|)
operator|/
name|size
expr_stmt|;
while|while
condition|(
name|index
operator|>
name|main_index
condition|)
block|{
comment|/* Fill with zeros.  The structure shorthand works because the compiler    will expand the "0" in braces to fill the size of the entire structure    */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|TYREAL
case|:
case|case
name|TYDREAL
case|:
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"0.0,"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYCOMPLEX
case|:
case|case
name|TYDCOMPLEX
case|:
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"{0},"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYCHAR
case|:
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
break|break;
default|default:
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"0,"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* switch */
name|main_index
operator|++
expr_stmt|;
block|}
comment|/* while index> main_index */
if|if
condition|(
name|index
operator|<
name|main_index
condition|)
name|overlapping
argument_list|()
expr_stmt|;
else|else
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|TYCHAR
case|:
block|{
name|int
name|this_char
decl_stmt|;
if|if
condition|(
name|k
operator|==
name|ch_ar_dim
condition|)
block|{
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"\" \""
argument_list|)
expr_stmt|;
name|k
operator|=
literal|0
expr_stmt|;
block|}
name|this_char
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|chainp
operator|)
name|values
operator|->
name|datap
argument_list|)
operator|->
name|nextp
operator|->
name|nextp
operator|->
name|datap
expr_stmt|;
if|if
condition|(
call|(
name|int
call|)
argument_list|(
operator|(
name|chainp
operator|)
name|values
operator|->
name|datap
argument_list|)
operator|->
name|nextp
operator|->
name|datap
operator|==
name|TYBLANK
condition|)
block|{
name|main_index
operator|+=
name|this_char
expr_stmt|;
name|k
operator|+=
name|this_char
expr_stmt|;
while|while
condition|(
operator|--
name|this_char
operator|>=
literal|0
condition|)
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|values
operator|=
name|values
operator|->
name|nextp
expr_stmt|;
continue|continue;
block|}
name|nice_printf
argument_list|(
name|outfile
argument_list|,
name|str_fmt
index|[
name|this_char
index|]
argument_list|,
name|this_char
argument_list|)
expr_stmt|;
name|k
operator|++
expr_stmt|;
block|}
comment|/* case TYCHAR */
break|break;
case|case
name|TYINT1
case|:
case|case
name|TYSHORT
case|:
case|case
name|TYLONG
case|:
ifdef|#
directive|ifdef
name|TYQUAD
case|case
name|TYQUAD
case|:
endif|#
directive|endif
case|case
name|TYREAL
case|:
case|case
name|TYDREAL
case|:
case|case
name|TYLOGICAL
case|:
case|case
name|TYLOGICAL1
case|:
case|case
name|TYLOGICAL2
case|:
case|case
name|TYCOMPLEX
case|:
case|case
name|TYDCOMPLEX
case|:
name|make_one_const
argument_list|(
name|type
argument_list|,
operator|&
name|Const
operator|.
name|Const
argument_list|,
name|values
argument_list|)
expr_stmt|;
name|Const
operator|.
name|vtype
operator|=
name|type
expr_stmt|;
name|Const
operator|.
name|vstg
operator|=
name|ONEOF
argument_list|(
name|type
argument_list|,
name|MSKREAL
operator||
name|MSKCOMPLEX
argument_list|)
operator|!=
literal|0
expr_stmt|;
name|out_const
argument_list|(
name|outfile
argument_list|,
operator|&
name|Const
argument_list|)
expr_stmt|;
break|break;
default|default:
name|erri
argument_list|(
literal|"wr_array_init: bad type '%d'"
argument_list|,
name|type
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* switch */
name|values
operator|=
name|values
operator|->
name|nextp
expr_stmt|;
name|main_index
operator|++
expr_stmt|;
if|if
condition|(
name|values
operator|&&
name|type
operator|!=
name|TYCHAR
condition|)
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|","
argument_list|)
expr_stmt|;
block|}
comment|/* while values */
if|if
condition|(
name|type
operator|==
name|TYCHAR
condition|)
block|{
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"\""
argument_list|)
expr_stmt|;
block|}
else|else
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|" }"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* wr_array_init */
end_comment

begin_function
specifier|static
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|make_one_const
parameter_list|(
name|type
parameter_list|,
name|storage
parameter_list|,
name|values
parameter_list|)
name|int
name|type
decl_stmt|;
name|union
name|Constant
modifier|*
name|storage
decl_stmt|;
name|chainp
name|values
decl_stmt|;
else|#
directive|else
function|make_one_const
parameter_list|(
name|int
name|type
parameter_list|,
name|union
name|Constant
modifier|*
name|storage
parameter_list|,
name|chainp
name|values
parameter_list|)
endif|#
directive|endif
block|{
name|union
name|Constant
modifier|*
name|Const
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|L
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|TYCHAR
condition|)
block|{
name|char
modifier|*
name|str
decl_stmt|,
modifier|*
name|str_ptr
decl_stmt|;
name|chainp
name|v
decl_stmt|,
name|prev
decl_stmt|;
name|int
name|b
init|=
literal|0
decl_stmt|,
name|k
decl_stmt|,
name|main_index
init|=
literal|0
decl_stmt|;
comment|/* Find the max length of init string, by finding the highest offset    value stored in the list of initial values */
for|for
control|(
name|k
operator|=
literal|1
operator|,
name|prev
operator|=
name|CHNULL
operator|,
name|v
operator|=
name|values
init|;
name|v
condition|;
name|prev
operator|=
name|v
operator|,
name|v
operator|=
name|v
operator|->
name|nextp
control|)
empty_stmt|;
if|if
condition|(
name|prev
operator|!=
name|CHNULL
condition|)
name|k
operator|=
operator|(
call|(
name|int
call|)
argument_list|(
operator|(
operator|(
name|chainp
operator|)
name|prev
operator|->
name|datap
operator|)
operator|->
name|datap
argument_list|)
operator|)
operator|+
literal|2
expr_stmt|;
comment|/* + 2 above for null char at end */
name|str
operator|=
name|Alloc
argument_list|(
name|k
argument_list|)
expr_stmt|;
for|for
control|(
name|str_ptr
operator|=
name|str
init|;
name|values
condition|;
name|str_ptr
operator|++
control|)
block|{
name|int
name|index
init|=
call|(
name|int
call|)
argument_list|(
operator|(
operator|(
name|chainp
operator|)
name|values
operator|->
name|datap
operator|)
operator|->
name|datap
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|<
name|main_index
condition|)
name|overlapping
argument_list|()
expr_stmt|;
while|while
condition|(
name|index
operator|>
name|main_index
operator|++
condition|)
operator|*
name|str_ptr
operator|++
operator|=
literal|' '
expr_stmt|;
name|k
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
operator|(
name|chainp
operator|)
name|values
operator|->
name|datap
operator|)
operator|->
name|nextp
operator|->
name|nextp
operator|->
name|datap
argument_list|)
expr_stmt|;
if|if
condition|(
call|(
name|int
call|)
argument_list|(
operator|(
name|chainp
operator|)
name|values
operator|->
name|datap
argument_list|)
operator|->
name|nextp
operator|->
name|datap
operator|==
name|TYBLANK
condition|)
block|{
name|b
operator|=
name|k
expr_stmt|;
break|break;
block|}
operator|*
name|str_ptr
operator|=
name|k
expr_stmt|;
name|values
operator|=
name|values
operator|->
name|nextp
expr_stmt|;
block|}
comment|/* for str_ptr */
operator|*
name|str_ptr
operator|=
literal|'\0'
expr_stmt|;
name|Const
operator|=
name|storage
expr_stmt|;
name|Const
operator|->
name|ccp
operator|=
name|str
expr_stmt|;
name|Const
operator|->
name|ccp1
operator|.
name|blanks
operator|=
name|b
expr_stmt|;
name|charlen
operator|=
name|str_ptr
operator|-
name|str
expr_stmt|;
block|}
else|else
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|chainp
name|vals
decl_stmt|;
name|vals
operator|=
operator|(
operator|(
name|chainp
operator|)
name|values
operator|->
name|datap
operator|)
operator|->
name|nextp
operator|->
name|nextp
expr_stmt|;
if|if
condition|(
name|vals
condition|)
block|{
name|L
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|storage
expr_stmt|;
do|do
name|L
index|[
name|i
operator|++
index|]
operator|=
name|vals
operator|->
name|datap
expr_stmt|;
do|while
condition|(
name|vals
operator|=
name|vals
operator|->
name|nextp
condition|)
do|;
block|}
block|}
comment|/* else */
block|}
end_function

begin_comment
comment|/* make_one_const */
end_comment

begin_function
name|int
ifdef|#
directive|ifdef
name|KR_headers
name|rdname
parameter_list|(
name|infile
parameter_list|,
name|vargroupp
parameter_list|,
name|name
parameter_list|)
name|FILE
modifier|*
name|infile
decl_stmt|;
name|int
modifier|*
name|vargroupp
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
else|#
directive|else
function|rdname
parameter_list|(
name|FILE
modifier|*
name|infile
parameter_list|,
name|int
modifier|*
name|vargroupp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
endif|#
directive|endif
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|c
decl_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|feof
argument_list|(
name|infile
argument_list|)
condition|)
return|return
name|NO
return|;
operator|*
name|vargroupp
operator|=
name|c
operator|-
literal|'0'
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>=
name|NAME_MAX
condition|)
name|Fatal
argument_list|(
literal|"rdname: oversize name"
argument_list|)
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|feof
argument_list|(
name|infile
argument_list|)
condition|)
return|return
name|NO
return|;
if|if
condition|(
name|c
operator|==
literal|'\t'
condition|)
break|break;
operator|*
name|name
operator|++
operator|=
name|c
expr_stmt|;
block|}
operator|*
name|name
operator|=
literal|0
expr_stmt|;
return|return
name|YES
return|;
block|}
end_function

begin_comment
comment|/* rdname */
end_comment

begin_function
name|int
ifdef|#
directive|ifdef
name|KR_headers
name|rdlong
parameter_list|(
name|infile
parameter_list|,
name|n
parameter_list|)
name|FILE
modifier|*
name|infile
decl_stmt|;
name|ftnint
modifier|*
name|n
decl_stmt|;
else|#
directive|else
function|rdlong
parameter_list|(
name|FILE
modifier|*
name|infile
parameter_list|,
name|ftnint
modifier|*
name|n
parameter_list|)
endif|#
directive|endif
block|{
specifier|register
name|int
name|c
decl_stmt|;
for|for
control|(
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
init|;
operator|!
name|feof
argument_list|(
name|infile
argument_list|)
operator|&&
name|isspace
argument_list|(
name|c
argument_list|)
condition|;
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
control|)
empty_stmt|;
if|if
condition|(
name|feof
argument_list|(
name|infile
argument_list|)
condition|)
return|return
name|NO
return|;
for|for
control|(
operator|*
name|n
operator|=
literal|0
init|;
name|isdigit
argument_list|(
name|c
argument_list|)
condition|;
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
control|)
operator|*
name|n
operator|=
literal|10
operator|*
operator|(
operator|*
name|n
operator|)
operator|+
name|c
operator|-
literal|'0'
expr_stmt|;
return|return
name|YES
return|;
block|}
end_function

begin_comment
comment|/* rdlong */
end_comment

begin_function
specifier|static
name|int
ifdef|#
directive|ifdef
name|KR_headers
name|memno2info
parameter_list|(
name|memno
parameter_list|,
name|info
parameter_list|)
name|int
name|memno
decl_stmt|;
name|Namep
modifier|*
name|info
decl_stmt|;
else|#
directive|else
function|memno2info
parameter_list|(
name|int
name|memno
parameter_list|,
name|Namep
modifier|*
name|info
parameter_list|)
endif|#
directive|endif
block|{
name|chainp
name|this_var
decl_stmt|;
specifier|extern
name|chainp
name|new_vars
decl_stmt|;
specifier|extern
name|struct
name|Hashentry
modifier|*
name|hashtab
decl_stmt|,
modifier|*
name|lasthash
decl_stmt|;
name|struct
name|Hashentry
modifier|*
name|entry
decl_stmt|;
for|for
control|(
name|this_var
operator|=
name|new_vars
init|;
name|this_var
condition|;
name|this_var
operator|=
name|this_var
operator|->
name|nextp
control|)
block|{
name|Addrp
name|var
init|=
operator|(
name|Addrp
operator|)
name|this_var
operator|->
name|datap
decl_stmt|;
if|if
condition|(
name|var
operator|==
operator|(
name|Addrp
operator|)
name|NULL
condition|)
name|Fatal
argument_list|(
literal|"memno2info:  null variable"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|var
operator|->
name|tag
operator|!=
name|TADDR
condition|)
name|Fatal
argument_list|(
literal|"memno2info:  bad tag"
argument_list|)
expr_stmt|;
if|if
condition|(
name|memno
operator|==
name|var
operator|->
name|memno
condition|)
block|{
operator|*
name|info
operator|=
operator|(
name|Namep
operator|)
name|var
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* if memno == var -> memno */
block|}
comment|/* for this_var = new_vars */
for|for
control|(
name|entry
operator|=
name|hashtab
init|;
name|entry
operator|<
name|lasthash
condition|;
operator|++
name|entry
control|)
block|{
name|Namep
name|var
init|=
name|entry
operator|->
name|varp
decl_stmt|;
if|if
condition|(
name|var
operator|&&
name|var
operator|->
name|vardesc
operator|.
name|varno
operator|==
name|memno
operator|&&
name|var
operator|->
name|vstg
operator|==
name|STGINIT
condition|)
block|{
operator|*
name|info
operator|=
operator|(
name|Namep
operator|)
name|var
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* if entry -> vardesc.varno == memno */
block|}
comment|/* for entry = hashtab */
name|Fatal
argument_list|(
literal|"memno2info:  couldn't find memno"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* memno2info */
end_comment

begin_function
specifier|static
name|chainp
ifdef|#
directive|ifdef
name|KR_headers
name|do_string
parameter_list|(
name|outfile
parameter_list|,
name|v
parameter_list|,
name|nloc
parameter_list|)
name|FILE
modifier|*
name|outfile
decl_stmt|;
specifier|register
name|chainp
name|v
decl_stmt|;
name|ftnint
modifier|*
name|nloc
decl_stmt|;
else|#
directive|else
function|do_string
parameter_list|(
name|FILE
modifier|*
name|outfile
parameter_list|,
specifier|register
name|chainp
name|v
parameter_list|,
name|ftnint
modifier|*
name|nloc
parameter_list|)
endif|#
directive|endif
block|{
specifier|register
name|chainp
name|cp
decl_stmt|,
name|v0
decl_stmt|;
name|ftnint
name|dloc
decl_stmt|,
name|k
decl_stmt|,
name|loc
decl_stmt|;
name|unsigned
name|long
name|uk
decl_stmt|;
name|char
name|buf
index|[
literal|8
index|]
decl_stmt|,
modifier|*
name|comma
decl_stmt|;
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"{"
argument_list|)
expr_stmt|;
name|cp
operator|=
operator|(
name|chainp
operator|)
name|v
operator|->
name|datap
expr_stmt|;
name|loc
operator|=
operator|(
name|ftnint
operator|)
name|cp
operator|->
name|datap
expr_stmt|;
name|comma
operator|=
literal|""
expr_stmt|;
for|for
control|(
name|v0
operator|=
name|v
init|;
condition|;
control|)
block|{
switch|switch
condition|(
operator|(
name|int
operator|)
name|cp
operator|->
name|nextp
operator|->
name|datap
condition|)
block|{
case|case
name|TYBLANK
case|:
name|k
operator|=
operator|(
name|ftnint
operator|)
name|cp
operator|->
name|nextp
operator|->
name|nextp
operator|->
name|datap
expr_stmt|;
name|loc
operator|+=
name|k
expr_stmt|;
while|while
condition|(
operator|--
name|k
operator|>=
literal|0
condition|)
block|{
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"%s' '"
argument_list|,
name|comma
argument_list|)
expr_stmt|;
name|comma
operator|=
literal|", "
expr_stmt|;
block|}
break|break;
case|case
name|TYCHAR
case|:
name|uk
operator|=
operator|(
name|ftnint
operator|)
name|cp
operator|->
name|nextp
operator|->
name|nextp
operator|->
name|datap
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
name|chr_fmt
index|[
name|uk
index|]
argument_list|,
name|uk
argument_list|)
expr_stmt|;
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"%s'%s'"
argument_list|,
name|comma
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|comma
operator|=
literal|", "
expr_stmt|;
name|loc
operator|++
expr_stmt|;
break|break;
default|default:
goto|goto
name|done
goto|;
block|}
name|v0
operator|=
name|v
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|v
operator|=
name|v
operator|->
name|nextp
operator|)
operator|||
operator|!
operator|(
name|cp
operator|=
operator|(
name|chainp
operator|)
name|v
operator|->
name|datap
operator|)
condition|)
break|break;
name|dloc
operator|=
operator|(
name|ftnint
operator|)
name|cp
operator|->
name|datap
expr_stmt|;
if|if
condition|(
name|loc
operator|!=
name|dloc
condition|)
break|break;
block|}
name|done
label|:
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"}"
argument_list|)
expr_stmt|;
operator|*
name|nloc
operator|=
name|loc
expr_stmt|;
return|return
name|v0
return|;
block|}
end_function

begin_function
specifier|static
name|chainp
ifdef|#
directive|ifdef
name|KR_headers
name|Ado_string
parameter_list|(
name|outfile
parameter_list|,
name|v
parameter_list|,
name|nloc
parameter_list|)
name|FILE
modifier|*
name|outfile
decl_stmt|;
specifier|register
name|chainp
name|v
decl_stmt|;
name|ftnint
modifier|*
name|nloc
decl_stmt|;
else|#
directive|else
function|Ado_string
parameter_list|(
name|FILE
modifier|*
name|outfile
parameter_list|,
specifier|register
name|chainp
name|v
parameter_list|,
name|ftnint
modifier|*
name|nloc
parameter_list|)
endif|#
directive|endif
block|{
specifier|register
name|chainp
name|cp
decl_stmt|,
name|v0
decl_stmt|;
name|ftnint
name|dloc
decl_stmt|,
name|k
decl_stmt|,
name|loc
decl_stmt|;
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"\""
argument_list|)
expr_stmt|;
name|cp
operator|=
operator|(
name|chainp
operator|)
name|v
operator|->
name|datap
expr_stmt|;
name|loc
operator|=
operator|(
name|ftnint
operator|)
name|cp
operator|->
name|datap
expr_stmt|;
for|for
control|(
name|v0
operator|=
name|v
init|;
condition|;
control|)
block|{
switch|switch
condition|(
operator|(
name|int
operator|)
name|cp
operator|->
name|nextp
operator|->
name|datap
condition|)
block|{
case|case
name|TYBLANK
case|:
name|k
operator|=
operator|(
name|ftnint
operator|)
name|cp
operator|->
name|nextp
operator|->
name|nextp
operator|->
name|datap
expr_stmt|;
name|loc
operator|+=
name|k
expr_stmt|;
while|while
condition|(
operator|--
name|k
operator|>=
literal|0
condition|)
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYCHAR
case|:
name|k
operator|=
operator|(
name|ftnint
operator|)
name|cp
operator|->
name|nextp
operator|->
name|nextp
operator|->
name|datap
expr_stmt|;
name|nice_printf
argument_list|(
name|outfile
argument_list|,
name|str_fmt
index|[
name|k
index|]
argument_list|,
name|k
argument_list|)
expr_stmt|;
name|loc
operator|++
expr_stmt|;
break|break;
default|default:
goto|goto
name|done
goto|;
block|}
name|v0
operator|=
name|v
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|v
operator|=
name|v
operator|->
name|nextp
operator|)
operator|||
operator|!
operator|(
name|cp
operator|=
operator|(
name|chainp
operator|)
name|v
operator|->
name|datap
operator|)
condition|)
break|break;
name|dloc
operator|=
operator|(
name|ftnint
operator|)
name|cp
operator|->
name|datap
expr_stmt|;
if|if
condition|(
name|loc
operator|!=
name|dloc
condition|)
break|break;
block|}
name|done
label|:
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"\""
argument_list|)
expr_stmt|;
operator|*
name|nloc
operator|=
name|loc
expr_stmt|;
return|return
name|v0
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
ifdef|#
directive|ifdef
name|KR_headers
name|Len
parameter_list|(
name|L
parameter_list|,
name|type
parameter_list|)
name|long
name|L
decl_stmt|;
name|int
name|type
decl_stmt|;
else|#
directive|else
function|Len
parameter_list|(
name|long
name|L
parameter_list|,
name|int
name|type
parameter_list|)
endif|#
directive|endif
block|{
specifier|static
name|char
name|buf
index|[
literal|24
index|]
decl_stmt|;
if|if
condition|(
name|L
operator|==
literal|1
operator|&&
name|type
operator|!=
name|TYCHAR
condition|)
return|return
literal|""
return|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"[%ld]"
argument_list|,
name|L
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|wr_equiv_init
parameter_list|(
name|outfile
parameter_list|,
name|memno
parameter_list|,
name|Values
parameter_list|,
name|iscomm
parameter_list|)
name|FILE
modifier|*
name|outfile
decl_stmt|;
name|int
name|memno
decl_stmt|;
name|chainp
modifier|*
name|Values
decl_stmt|;
name|int
name|iscomm
decl_stmt|;
else|#
directive|else
function|wr_equiv_init
parameter_list|(
name|FILE
modifier|*
name|outfile
parameter_list|,
name|int
name|memno
parameter_list|,
name|chainp
modifier|*
name|Values
parameter_list|,
name|int
name|iscomm
parameter_list|)
endif|#
directive|endif
block|{
name|struct
name|Equivblock
modifier|*
name|eqv
decl_stmt|;
name|int
name|btype
decl_stmt|,
name|curtype
decl_stmt|,
name|dtype
decl_stmt|,
name|filltype
decl_stmt|,
name|filltype1
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|wasblank
decl_stmt|,
name|xtype
decl_stmt|;
specifier|static
name|char
name|Blank
index|[]
init|=
literal|""
decl_stmt|;
specifier|register
name|char
modifier|*
name|comma
init|=
name|Blank
decl_stmt|;
specifier|register
name|chainp
name|cp
decl_stmt|,
name|v
decl_stmt|;
name|chainp
name|sentinel
decl_stmt|,
name|values
decl_stmt|,
name|v1
decl_stmt|,
name|vlast
decl_stmt|;
name|ftnint
name|L
decl_stmt|,
name|L1
decl_stmt|,
name|dL
decl_stmt|,
name|dloc
decl_stmt|,
name|loc
decl_stmt|,
name|loc0
decl_stmt|;
name|union
name|Constant
name|Const
decl_stmt|;
name|char
name|imag_buf
index|[
literal|50
index|]
decl_stmt|,
name|real_buf
index|[
literal|50
index|]
decl_stmt|;
name|int
name|szshort
init|=
name|typesize
index|[
name|TYSHORT
index|]
decl_stmt|;
specifier|static
name|char
name|typepref
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
name|TYINT1
block|,
name|TYSHORT
block|,
name|TYLONG
block|,
ifdef|#
directive|ifdef
name|TYQUAD
name|TYQUAD
block|,
endif|#
directive|endif
name|TYREAL
block|,
name|TYDREAL
block|,
name|TYREAL
block|,
name|TYDREAL
block|,
name|TYLOGICAL1
block|,
name|TYLOGICAL2
block|,
name|TYLOGICAL
block|,
name|TYCHAR
block|}
decl_stmt|;
specifier|static
name|char
name|basetype
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
name|TYCHAR
block|,
name|TYSHORT
block|,
name|TYLONG
block|,
ifdef|#
directive|ifdef
name|TYQUAD
name|TYDREAL
block|,
endif|#
directive|endif
name|TYLONG
block|,
name|TYDREAL
block|,
name|TYLONG
block|,
name|TYDREAL
block|,
name|TYCHAR
block|,
name|TYSHORT
block|,
name|TYLONG
block|,
name|TYCHAR
block|,
literal|0
comment|/* for TYBLANK */
block|}
decl_stmt|;
specifier|extern
name|int
name|htype
decl_stmt|;
name|char
modifier|*
name|z
decl_stmt|;
comment|/* add sentinel */
if|if
condition|(
name|iscomm
condition|)
block|{
name|L
operator|=
name|extsymtab
index|[
name|memno
index|]
operator|.
name|maxleng
expr_stmt|;
name|xtype
operator|=
name|extsymtab
index|[
name|memno
index|]
operator|.
name|extype
expr_stmt|;
block|}
else|else
block|{
name|eqv
operator|=
operator|&
name|eqvclass
index|[
name|memno
index|]
expr_stmt|;
name|L
operator|=
name|eqv
operator|->
name|eqvtop
operator|-
name|eqv
operator|->
name|eqvbottom
expr_stmt|;
name|xtype
operator|=
name|eqv
operator|->
name|eqvtype
expr_stmt|;
block|}
if|if
condition|(
name|halign
operator|&&
name|typealign
index|[
name|typepref
index|[
name|xtype
index|]
index|]
operator|<
name|typealign
index|[
name|htype
index|]
condition|)
name|xtype
operator|=
name|htype
expr_stmt|;
operator|*
name|Values
operator|=
name|values
operator|=
name|revchain
argument_list|(
name|vlast
operator|=
operator|*
name|Values
argument_list|)
expr_stmt|;
if|if
condition|(
name|xtype
operator|!=
name|TYCHAR
condition|)
block|{
comment|/* unless the data include a value of the appropriate 		 * type, we add an extra element in an attempt 		 * to force correct alignment */
name|btype
operator|=
name|basetype
index|[
name|xtype
index|]
expr_stmt|;
name|loc
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|v
operator|=
operator|*
name|Values
init|;
condition|;
name|v
operator|=
name|v
operator|->
name|nextp
control|)
block|{
if|if
condition|(
operator|!
name|v
condition|)
block|{
name|dtype
operator|=
name|typepref
index|[
name|xtype
index|]
expr_stmt|;
name|z
operator|=
name|ISREAL
argument_list|(
name|dtype
argument_list|)
condition|?
name|cpstring
argument_list|(
literal|"0."
argument_list|)
else|:
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
name|k
operator|=
name|typesize
index|[
name|dtype
index|]
expr_stmt|;
if|if
condition|(
name|j
operator|=
name|L
operator|%
name|k
condition|)
name|L
operator|+=
name|k
operator|-
name|j
expr_stmt|;
name|v
operator|=
name|mkchain
argument_list|(
operator|(
name|char
operator|*
operator|)
name|L
argument_list|,
name|mkchain
argument_list|(
argument|(char *)LONG_CAST dtype
argument_list|,
argument|mkchain(z, CHNULL)
argument_list|)
argument_list|)
expr_stmt|;
name|vlast
operator|=
name|vlast
operator|->
name|nextp
operator|=
name|mkchain
argument_list|(
operator|(
name|char
operator|*
operator|)
name|v
argument_list|,
name|CHNULL
argument_list|)
expr_stmt|;
name|L
operator|+=
name|k
expr_stmt|;
break|break;
block|}
name|cp
operator|=
operator|(
name|chainp
operator|)
name|v
operator|->
name|datap
expr_stmt|;
if|if
condition|(
name|basetype
index|[
operator|(
name|int
operator|)
name|cp
operator|->
name|nextp
operator|->
name|datap
index|]
operator|==
name|btype
condition|)
break|break;
name|dloc
operator|=
operator|(
name|ftnint
operator|)
name|cp
operator|->
name|datap
expr_stmt|;
name|L1
operator|=
name|dloc
operator|-
name|loc
expr_stmt|;
if|if
condition|(
name|L1
operator|>
literal|0
operator|&&
operator|!
operator|(
name|L1
operator|%
name|szshort
operator|)
operator|&&
operator|!
operator|(
name|loc
operator|%
name|szshort
operator|)
operator|&&
name|btype
operator|<=
name|type_choice
index|[
name|L1
operator|/
name|szshort
operator|%
literal|4
index|]
operator|&&
name|btype
operator|<=
name|type_choice
index|[
name|loc
operator|/
name|szshort
operator|%
literal|4
index|]
condition|)
break|break;
name|dtype
operator|=
operator|(
name|int
operator|)
name|cp
operator|->
name|nextp
operator|->
name|datap
expr_stmt|;
name|loc
operator|=
name|dloc
operator|+
name|dtype
operator|==
name|TYBLANK
condition|?
operator|(
name|ftnint
operator|)
name|cp
operator|->
name|nextp
operator|->
name|nextp
operator|->
name|datap
else|:
name|typesize
index|[
name|dtype
index|]
expr_stmt|;
block|}
block|}
name|sentinel
operator|=
name|mkchain
argument_list|(
operator|(
name|char
operator|*
operator|)
name|L
argument_list|,
name|mkchain
argument_list|(
operator|(
name|char
operator|*
operator|)
name|TYERROR
argument_list|,
name|CHNULL
argument_list|)
argument_list|)
expr_stmt|;
name|vlast
operator|->
name|nextp
operator|=
name|mkchain
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sentinel
argument_list|,
name|CHNULL
argument_list|)
expr_stmt|;
comment|/* use doublereal fillers only if there are doublereal values */
name|k
operator|=
name|TYLONG
expr_stmt|;
for|for
control|(
name|v
operator|=
name|values
init|;
name|v
condition|;
name|v
operator|=
name|v
operator|->
name|nextp
control|)
if|if
condition|(
name|ONEOF
argument_list|(
call|(
name|int
call|)
argument_list|(
operator|(
name|chainp
operator|)
name|v
operator|->
name|datap
argument_list|)
operator|->
name|nextp
operator|->
name|datap
argument_list|,
name|M
argument_list|(
name|TYDREAL
argument_list|)
operator||
name|M
argument_list|(
name|TYDCOMPLEX
argument_list|)
argument_list|)
condition|)
block|{
name|k
operator|=
name|TYDREAL
expr_stmt|;
break|break;
block|}
name|type_choice
index|[
literal|0
index|]
operator|=
name|k
expr_stmt|;
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"%sstruct {\n"
argument_list|,
name|iscomm
condition|?
literal|""
else|:
literal|"static "
argument_list|)
expr_stmt|;
name|next_tab
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
name|loc
operator|=
name|loc0
operator|=
name|k
operator|=
literal|0
expr_stmt|;
name|curtype
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|v
operator|=
name|values
init|;
name|v
condition|;
name|v
operator|=
name|v
operator|->
name|nextp
control|)
block|{
name|cp
operator|=
operator|(
name|chainp
operator|)
name|v
operator|->
name|datap
expr_stmt|;
name|dloc
operator|=
operator|(
name|ftnint
operator|)
name|cp
operator|->
name|datap
expr_stmt|;
name|L
operator|=
name|dloc
operator|-
name|loc
expr_stmt|;
if|if
condition|(
name|L
operator|<
literal|0
condition|)
block|{
name|overlapping
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|cp
operator|->
name|nextp
operator|->
name|datap
operator|!=
name|TYERROR
condition|)
block|{
name|v1
operator|=
name|cp
expr_stmt|;
name|frchain
argument_list|(
operator|&
name|v1
argument_list|)
expr_stmt|;
name|v
operator|->
name|datap
operator|=
literal|0
expr_stmt|;
block|}
continue|continue;
block|}
name|dtype
operator|=
operator|(
name|int
operator|)
name|cp
operator|->
name|nextp
operator|->
name|datap
expr_stmt|;
if|if
condition|(
name|dtype
operator|==
name|TYBLANK
condition|)
block|{
name|dtype
operator|=
name|TYCHAR
expr_stmt|;
name|wasblank
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|wasblank
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|curtype
operator|!=
name|dtype
operator|||
name|L
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|curtype
operator|!=
operator|-
literal|1
condition|)
block|{
name|L1
operator|=
operator|(
name|loc
operator|-
name|loc0
operator|)
operator|/
name|dL
expr_stmt|;
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"%s e_%d%s;\n"
argument_list|,
name|typename
index|[
name|curtype
index|]
argument_list|,
operator|++
name|k
argument_list|,
name|Len
argument_list|(
name|L1
argument_list|,
name|curtype
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|curtype
operator|=
name|dtype
expr_stmt|;
name|loc0
operator|=
name|dloc
expr_stmt|;
block|}
if|if
condition|(
name|L
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|xtype
operator|==
name|TYCHAR
condition|)
name|filltype
operator|=
name|TYCHAR
expr_stmt|;
else|else
block|{
name|filltype
operator|=
name|L
operator|%
name|szshort
condition|?
name|TYCHAR
else|:
name|type_choice
index|[
name|L
operator|/
name|szshort
operator|%
literal|4
index|]
expr_stmt|;
name|filltype1
operator|=
name|loc
operator|%
name|szshort
condition|?
name|TYCHAR
else|:
name|type_choice
index|[
name|loc
operator|/
name|szshort
operator|%
literal|4
index|]
expr_stmt|;
if|if
condition|(
name|typesize
index|[
name|filltype
index|]
operator|>
name|typesize
index|[
name|filltype1
index|]
condition|)
name|filltype
operator|=
name|filltype1
expr_stmt|;
block|}
name|L1
operator|=
name|L
operator|/
name|typesize
index|[
name|filltype
index|]
expr_stmt|;
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"%s fill_%d[%ld];\n"
argument_list|,
name|typename
index|[
name|filltype
index|]
argument_list|,
operator|++
name|k
argument_list|,
name|L1
argument_list|)
expr_stmt|;
name|loc
operator|=
name|dloc
expr_stmt|;
block|}
if|if
condition|(
name|wasblank
condition|)
block|{
name|loc
operator|+=
operator|(
name|ftnint
operator|)
name|cp
operator|->
name|nextp
operator|->
name|nextp
operator|->
name|datap
expr_stmt|;
name|dL
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|dL
operator|=
name|typesize
index|[
name|dtype
index|]
expr_stmt|;
name|loc
operator|+=
name|dL
expr_stmt|;
block|}
block|}
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"} %s = { "
argument_list|,
name|iscomm
condition|?
name|extsymtab
index|[
name|memno
index|]
operator|.
name|cextname
else|:
name|equiv_name
argument_list|(
name|eqvmemno
argument_list|,
name|CNULL
argument_list|)
argument_list|)
expr_stmt|;
name|loc
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|v
operator|=
name|values
init|;
condition|;
name|v
operator|=
name|v
operator|->
name|nextp
control|)
block|{
name|cp
operator|=
operator|(
name|chainp
operator|)
name|v
operator|->
name|datap
expr_stmt|;
if|if
condition|(
operator|!
name|cp
condition|)
continue|continue;
name|dtype
operator|=
operator|(
name|int
operator|)
name|cp
operator|->
name|nextp
operator|->
name|datap
expr_stmt|;
if|if
condition|(
name|dtype
operator|==
name|TYERROR
condition|)
break|break;
name|dloc
operator|=
operator|(
name|ftnint
operator|)
name|cp
operator|->
name|datap
expr_stmt|;
if|if
condition|(
name|dloc
operator|>
name|loc
condition|)
block|{
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"%s{0}"
argument_list|,
name|comma
argument_list|)
expr_stmt|;
name|comma
operator|=
literal|", "
expr_stmt|;
name|loc
operator|=
name|dloc
expr_stmt|;
block|}
if|if
condition|(
name|comma
operator|!=
name|Blank
condition|)
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|comma
operator|=
literal|", "
expr_stmt|;
if|if
condition|(
name|dtype
operator|==
name|TYCHAR
operator|||
name|dtype
operator|==
name|TYBLANK
condition|)
block|{
name|v
operator|=
name|Ansi
operator|==
literal|1
condition|?
name|Ado_string
argument_list|(
name|outfile
argument_list|,
name|v
argument_list|,
operator|&
name|loc
argument_list|)
else|:
name|do_string
argument_list|(
name|outfile
argument_list|,
name|v
argument_list|,
operator|&
name|loc
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|make_one_const
argument_list|(
name|dtype
argument_list|,
operator|&
name|Const
argument_list|,
name|v
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|dtype
condition|)
block|{
case|case
name|TYLOGICAL
case|:
case|case
name|TYLOGICAL2
case|:
case|case
name|TYLOGICAL1
case|:
if|if
condition|(
name|Const
operator|.
name|ci
operator|<
literal|0
operator|||
name|Const
operator|.
name|ci
operator|>
literal|1
condition|)
name|errl
argument_list|(
literal|"wr_equiv_init: unexpected logical value %ld"
argument_list|,
name|Const
operator|.
name|ci
argument_list|)
expr_stmt|;
name|nice_printf
argument_list|(
name|outfile
argument_list|,
name|Const
operator|.
name|ci
condition|?
literal|"TRUE_"
else|:
literal|"FALSE_"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYINT1
case|:
case|case
name|TYSHORT
case|:
case|case
name|TYLONG
case|:
ifdef|#
directive|ifdef
name|TYQUAD
case|case
name|TYQUAD
case|:
endif|#
directive|endif
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"%ld"
argument_list|,
name|Const
operator|.
name|ci
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYREAL
case|:
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"%s"
argument_list|,
name|flconst
argument_list|(
name|real_buf
argument_list|,
name|Const
operator|.
name|cds
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYDREAL
case|:
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"%s"
argument_list|,
name|Const
operator|.
name|cds
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYCOMPLEX
case|:
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"%s, %s"
argument_list|,
name|flconst
argument_list|(
name|real_buf
argument_list|,
name|Const
operator|.
name|cds
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|flconst
argument_list|(
name|imag_buf
argument_list|,
name|Const
operator|.
name|cds
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYDCOMPLEX
case|:
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"%s, %s"
argument_list|,
name|Const
operator|.
name|cds
index|[
literal|0
index|]
argument_list|,
name|Const
operator|.
name|cds
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
default|default:
name|erri
argument_list|(
literal|"unexpected type %d in wr_equiv_init"
argument_list|,
name|dtype
argument_list|)
expr_stmt|;
block|}
name|loc
operator|+=
name|typesize
index|[
name|dtype
index|]
expr_stmt|;
block|}
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|" };\n\n"
argument_list|)
expr_stmt|;
name|prev_tab
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
name|frchain
argument_list|(
operator|&
name|sentinel
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

