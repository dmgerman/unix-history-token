begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**************************************************************** Copyright 1990 - 1996 by AT&T, Lucent Technologies and Bellcore.  Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that the copyright notice and this permission notice and warranty disclaimer appear in supporting documentation, and that the names of AT&T, Bell Laboratories, Lucent or Bellcore or any of their entities not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  AT&T, Lucent and Bellcore disclaim all warranties with regard to this software, including all implied warranties of merchantability and fitness.  In no event shall AT&T, Lucent or Bellcore be liable for any special, indirect or consequential damages or any damages whatsoever resulting from loss of use, data or profits, whether in an action of contract, negligence or other tortious action, arising out of or in connection with the use or performance of this software. ****************************************************************/
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"names.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|TRUE
end_ifndef

begin_define
define|#
directive|define
name|TRUE
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|FALSE
end_ifndef

begin_define
define|#
directive|define
name|FALSE
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|char
name|_assoc_table
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Opcode table -- This array is indexed by the OP_____ macros defined in    defines.h; these macros are expected to be adjacent integers, so that    this table is as small as possible. */
end_comment

begin_decl_stmt
name|table_entry
name|opcode_table
index|[]
init|=
block|{
block|{
literal|0
block|,
literal|0
block|,
name|NULL
block|}
block|,
comment|/* OPPLUS 1 */
block|{
name|BINARY_OP
block|,
literal|12
block|,
literal|"%l + %r"
block|}
block|,
comment|/* OPMINUS 2 */
block|{
name|BINARY_OP
block|,
literal|12
block|,
literal|"%l - %r"
block|}
block|,
comment|/* OPSTAR 3 */
block|{
name|BINARY_OP
block|,
literal|13
block|,
literal|"%l * %r"
block|}
block|,
comment|/* OPSLASH 4 */
block|{
name|BINARY_OP
block|,
literal|13
block|,
literal|"%l / %r"
block|}
block|,
comment|/* OPPOWER 5 */
block|{
name|BINARY_OP
block|,
literal|0
block|,
literal|"power (%l, %r)"
block|}
block|,
comment|/* OPNEG 6 */
block|{
name|UNARY_OP
block|,
literal|14
block|,
literal|"-%l"
block|}
block|,
comment|/* OPOR 7 */
block|{
name|BINARY_OP
block|,
literal|4
block|,
literal|"%l || %r"
block|}
block|,
comment|/* OPAND 8 */
block|{
name|BINARY_OP
block|,
literal|5
block|,
literal|"%l&& %r"
block|}
block|,
comment|/* OPEQV 9 */
block|{
name|BINARY_OP
block|,
literal|9
block|,
literal|"%l == %r"
block|}
block|,
comment|/* OPNEQV 10 */
block|{
name|BINARY_OP
block|,
literal|9
block|,
literal|"%l != %r"
block|}
block|,
comment|/* OPNOT 11 */
block|{
name|UNARY_OP
block|,
literal|14
block|,
literal|"! %l"
block|}
block|,
comment|/* OPCONCAT 12 */
block|{
name|BINARY_OP
block|,
literal|0
block|,
literal|"concat (%l, %r)"
block|}
block|,
comment|/* OPLT 13 */
block|{
name|BINARY_OP
block|,
literal|10
block|,
literal|"%l< %r"
block|}
block|,
comment|/* OPEQ 14 */
block|{
name|BINARY_OP
block|,
literal|9
block|,
literal|"%l == %r"
block|}
block|,
comment|/* OPGT 15 */
block|{
name|BINARY_OP
block|,
literal|10
block|,
literal|"%l> %r"
block|}
block|,
comment|/* OPLE 16 */
block|{
name|BINARY_OP
block|,
literal|10
block|,
literal|"%l<= %r"
block|}
block|,
comment|/* OPNE 17 */
block|{
name|BINARY_OP
block|,
literal|9
block|,
literal|"%l != %r"
block|}
block|,
comment|/* OPGE 18 */
block|{
name|BINARY_OP
block|,
literal|10
block|,
literal|"%l>= %r"
block|}
block|,
comment|/* OPCALL 19 */
block|{
name|BINARY_OP
block|,
literal|15
block|,
name|SPECIAL_FMT
block|}
block|,
comment|/* OPCCALL 20 */
block|{
name|BINARY_OP
block|,
literal|15
block|,
name|SPECIAL_FMT
block|}
block|,
comment|/* Left hand side of an assignment cannot have outermost parens */
comment|/* OPASSIGN 21 */
block|{
name|BINARY_OP
block|,
literal|2
block|,
literal|"%l = %r"
block|}
block|,
comment|/* OPPLUSEQ 22 */
block|{
name|BINARY_OP
block|,
literal|2
block|,
literal|"%l += %r"
block|}
block|,
comment|/* OPSTAREQ 23 */
block|{
name|BINARY_OP
block|,
literal|2
block|,
literal|"%l *= %r"
block|}
block|,
comment|/* OPCONV 24 */
block|{
name|BINARY_OP
block|,
literal|14
block|,
literal|"%l"
block|}
block|,
comment|/* OPLSHIFT 25 */
block|{
name|BINARY_OP
block|,
literal|11
block|,
literal|"%l<< %r"
block|}
block|,
comment|/* OPMOD 26 */
block|{
name|BINARY_OP
block|,
literal|13
block|,
literal|"%l %% %r"
block|}
block|,
comment|/* OPCOMMA 27 */
block|{
name|BINARY_OP
block|,
literal|1
block|,
literal|"%l, %r"
block|}
block|,
comment|/* Don't want to nest the colon operator in parens */
comment|/* OPQUEST 28 */
block|{
name|BINARY_OP
block|,
literal|3
block|,
literal|"%l ? %r"
block|}
block|,
comment|/* OPCOLON 29 */
block|{
name|BINARY_OP
block|,
literal|3
block|,
literal|"%l : %r"
block|}
block|,
comment|/* OPABS 30 */
block|{
name|UNARY_OP
block|,
literal|0
block|,
literal|"abs(%l)"
block|}
block|,
comment|/* OPMIN 31 */
block|{
name|BINARY_OP
block|,
literal|0
block|,
name|SPECIAL_FMT
block|}
block|,
comment|/* OPMAX 32 */
block|{
name|BINARY_OP
block|,
literal|0
block|,
name|SPECIAL_FMT
block|}
block|,
comment|/* OPADDR 33 */
block|{
name|UNARY_OP
block|,
literal|14
block|,
literal|"&%l"
block|}
block|,
comment|/* OPCOMMA_ARG 34 */
block|{
name|BINARY_OP
block|,
literal|15
block|,
name|SPECIAL_FMT
block|}
block|,
comment|/* OPBITOR 35 */
block|{
name|BINARY_OP
block|,
literal|6
block|,
literal|"%l | %r"
block|}
block|,
comment|/* OPBITAND 36 */
block|{
name|BINARY_OP
block|,
literal|8
block|,
literal|"%l& %r"
block|}
block|,
comment|/* OPBITXOR 37 */
block|{
name|BINARY_OP
block|,
literal|7
block|,
literal|"%l ^ %r"
block|}
block|,
comment|/* OPBITNOT 38 */
block|{
name|UNARY_OP
block|,
literal|14
block|,
literal|"~ %l"
block|}
block|,
comment|/* OPRSHIFT 39 */
block|{
name|BINARY_OP
block|,
literal|11
block|,
literal|"%l>> %r"
block|}
block|,
comment|/* This isn't quite right -- it doesn't handle arrays, for instance */
comment|/* OPWHATSIN 40 */
block|{
name|UNARY_OP
block|,
literal|14
block|,
literal|"*%l"
block|}
block|,
comment|/* OPMINUSEQ 41 */
block|{
name|BINARY_OP
block|,
literal|2
block|,
literal|"%l -= %r"
block|}
block|,
comment|/* OPSLASHEQ 42 */
block|{
name|BINARY_OP
block|,
literal|2
block|,
literal|"%l /= %r"
block|}
block|,
comment|/* OPMODEQ 43 */
block|{
name|BINARY_OP
block|,
literal|2
block|,
literal|"%l %%= %r"
block|}
block|,
comment|/* OPLSHIFTEQ 44 */
block|{
name|BINARY_OP
block|,
literal|2
block|,
literal|"%l<<= %r"
block|}
block|,
comment|/* OPRSHIFTEQ 45 */
block|{
name|BINARY_OP
block|,
literal|2
block|,
literal|"%l>>= %r"
block|}
block|,
comment|/* OPBITANDEQ 46 */
block|{
name|BINARY_OP
block|,
literal|2
block|,
literal|"%l&= %r"
block|}
block|,
comment|/* OPBITXOREQ 47 */
block|{
name|BINARY_OP
block|,
literal|2
block|,
literal|"%l ^= %r"
block|}
block|,
comment|/* OPBITOREQ 48 */
block|{
name|BINARY_OP
block|,
literal|2
block|,
literal|"%l |= %r"
block|}
block|,
comment|/* OPPREINC 49 */
block|{
name|UNARY_OP
block|,
literal|14
block|,
literal|"++%l"
block|}
block|,
comment|/* OPPREDEC 50 */
block|{
name|UNARY_OP
block|,
literal|14
block|,
literal|"--%l"
block|}
block|,
comment|/* OPDOT 51 */
block|{
name|BINARY_OP
block|,
literal|15
block|,
literal|"%l.%r"
block|}
block|,
comment|/* OPARROW 52 */
block|{
name|BINARY_OP
block|,
literal|15
block|,
literal|"%l -> %r"
block|}
block|,
comment|/* OPNEG1 53 */
block|{
name|UNARY_OP
block|,
literal|14
block|,
literal|"-%l"
block|}
block|,
comment|/* OPDMIN 54 */
block|{
name|BINARY_OP
block|,
literal|0
block|,
literal|"dmin(%l,%r)"
block|}
block|,
comment|/* OPDMAX 55 */
block|{
name|BINARY_OP
block|,
literal|0
block|,
literal|"dmax(%l,%r)"
block|}
block|,
comment|/* OPASSIGNI 56 */
block|{
name|BINARY_OP
block|,
literal|2
block|,
literal|"%l =&%r"
block|}
block|,
comment|/* OPIDENTITY 57 */
block|{
name|UNARY_OP
block|,
literal|15
block|,
literal|"%l"
block|}
block|,
comment|/* OPCHARCAST 58 */
block|{
name|UNARY_OP
block|,
literal|14
block|,
literal|"(char *)&%l"
block|}
block|,
comment|/* OPDABS 59 */
block|{
name|UNARY_OP
block|,
literal|0
block|,
literal|"dabs(%l)"
block|}
block|,
comment|/* OPMIN2 60 */
block|{
name|BINARY_OP
block|,
literal|0
block|,
literal|"min(%l,%r)"
block|}
block|,
comment|/* OPMAX2 61 */
block|{
name|BINARY_OP
block|,
literal|0
block|,
literal|"max(%l,%r)"
block|}
block|,
comment|/* OPBITTEST 62 */
block|{
name|BINARY_OP
block|,
literal|0
block|,
literal|"bit_test(%l,%r)"
block|}
block|,
comment|/* OPBITCLR 63 */
block|{
name|BINARY_OP
block|,
literal|0
block|,
literal|"bit_clear(%l,%r)"
block|}
block|,
comment|/* OPBITSET 64 */
block|{
name|BINARY_OP
block|,
literal|0
block|,
literal|"bit_set(%l,%r)"
block|}
block|,
ifdef|#
directive|ifdef
name|TYQUAD
comment|/* OPQBITCLR 65 */
block|{
name|BINARY_OP
block|,
literal|0
block|,
literal|"qbit_clear(%l,%r)"
block|}
block|,
comment|/* OPQBITSET 66 */
block|{
name|BINARY_OP
block|,
literal|0
block|,
literal|"qbit_set(%l,%r)"
block|}
block|,
endif|#
directive|endif
comment|/* kludge to imitate (under forcedouble) f77's bizarre treatement of OPNEG... */
comment|/* OPNEG KLUDGE */
block|{
name|UNARY_OP
block|,
literal|14
block|,
literal|"-(doublereal)%l"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* opcode_table */
end_comment

begin_define
define|#
directive|define
name|OPNEG_KLUDGE
value|(sizeof(opcode_table)/sizeof(table_entry) - 1)
end_define

begin_decl_stmt
specifier|extern
name|int
name|dneg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|opeqable
index|[
sizeof|sizeof
argument_list|(
name|opcode_table
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|table_entry
argument_list|)
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_arg_list
name|Argdcl
argument_list|(
operator|(
name|FILEP
operator|,
expr|struct
name|Listblock
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_binary
name|Argdcl
argument_list|(
operator|(
name|FILEP
operator|,
name|Exprp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_list
name|Argdcl
argument_list|(
operator|(
name|FILEP
operator|,
expr|struct
name|Listblock
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_literal
name|Argdcl
argument_list|(
operator|(
name|FILEP
operator|,
name|long
operator|,
name|Constp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_prim
name|Argdcl
argument_list|(
operator|(
name|FILEP
operator|,
expr|struct
name|Primblock
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_unary
name|Argdcl
argument_list|(
operator|(
name|FILEP
operator|,
name|Exprp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|expr_out
parameter_list|(
name|fp
parameter_list|,
name|e
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
name|expptr
name|e
decl_stmt|;
else|#
directive|else
function|expr_out
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|expptr
name|e
parameter_list|)
endif|#
directive|endif
block|{
if|if
condition|(
name|e
operator|==
operator|(
name|expptr
operator|)
name|NULL
condition|)
return|return;
switch|switch
condition|(
name|e
operator|->
name|tag
condition|)
block|{
case|case
name|TNAME
case|:
name|out_name
argument_list|(
name|fp
argument_list|,
operator|(
expr|struct
name|Nameblock
operator|*
operator|)
name|e
argument_list|)
expr_stmt|;
return|return;
case|case
name|TCONST
case|:
name|out_const
argument_list|(
name|fp
argument_list|,
operator|&
name|e
operator|->
name|constblock
argument_list|)
expr_stmt|;
goto|goto
name|end_out
goto|;
case|case
name|TEXPR
case|:
break|break;
case|case
name|TADDR
case|:
name|out_addr
argument_list|(
name|fp
argument_list|,
operator|&
operator|(
name|e
operator|->
name|addrblock
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|end_out
goto|;
case|case
name|TPRIM
case|:
if|if
condition|(
operator|!
name|nerr
condition|)
name|warn
argument_list|(
literal|"expr_out: got TPRIM"
argument_list|)
expr_stmt|;
name|output_prim
argument_list|(
name|fp
argument_list|,
operator|&
operator|(
name|e
operator|->
name|primblock
operator|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|TLIST
case|:
name|output_list
argument_list|(
name|fp
argument_list|,
operator|&
operator|(
name|e
operator|->
name|listblock
operator|)
argument_list|)
expr_stmt|;
name|end_out
label|:
name|frexpr
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return;
case|case
name|TIMPLDO
case|:
name|err
argument_list|(
literal|"expr_out: got TIMPLDO"
argument_list|)
expr_stmt|;
return|return;
case|case
name|TERROR
case|:
default|default:
name|erri
argument_list|(
literal|"expr_out: bad tag '%d'"
argument_list|,
name|e
operator|->
name|tag
argument_list|)
expr_stmt|;
block|}
comment|/* switch */
comment|/* Now we know that the tag is TEXPR */
comment|/* Optimize on simple expressions, such as "a = a + b" ==> "a += b" */
if|if
condition|(
name|e
operator|->
name|exprblock
operator|.
name|opcode
operator|==
name|OPASSIGN
operator|&&
name|e
operator|->
name|exprblock
operator|.
name|rightp
operator|&&
name|e
operator|->
name|exprblock
operator|.
name|rightp
operator|->
name|tag
operator|==
name|TEXPR
condition|)
block|{
name|int
name|opcode
decl_stmt|;
name|opcode
operator|=
name|e
operator|->
name|exprblock
operator|.
name|rightp
operator|->
name|exprblock
operator|.
name|opcode
expr_stmt|;
if|if
condition|(
name|opeqable
index|[
name|opcode
index|]
condition|)
block|{
name|expptr
name|leftp
decl_stmt|,
name|rightp
decl_stmt|;
if|if
condition|(
operator|(
name|leftp
operator|=
name|e
operator|->
name|exprblock
operator|.
name|leftp
operator|)
operator|&&
operator|(
name|rightp
operator|=
name|e
operator|->
name|exprblock
operator|.
name|rightp
operator|->
name|exprblock
operator|.
name|leftp
operator|)
condition|)
block|{
if|if
condition|(
name|same_ident
argument_list|(
name|leftp
argument_list|,
name|rightp
argument_list|)
condition|)
block|{
name|expptr
name|temp
init|=
name|e
operator|->
name|exprblock
operator|.
name|rightp
decl_stmt|;
name|e
operator|->
name|exprblock
operator|.
name|opcode
operator|=
name|op_assign
argument_list|(
name|opcode
argument_list|)
expr_stmt|;
name|e
operator|->
name|exprblock
operator|.
name|rightp
operator|=
name|temp
operator|->
name|exprblock
operator|.
name|rightp
expr_stmt|;
name|temp
operator|->
name|exprblock
operator|.
name|rightp
operator|=
literal|0
expr_stmt|;
name|frexpr
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
comment|/* if same_ident (leftp, rightp) */
block|}
comment|/* if leftp&& rightp */
block|}
comment|/* if opcode == OPPLUS || */
block|}
comment|/* if e -> exprblock.opcode == OPASSIGN */
comment|/* Optimize on increment or decrement by 1 */
block|{
name|int
name|opcode
init|=
name|e
operator|->
name|exprblock
operator|.
name|opcode
decl_stmt|;
name|expptr
name|leftp
init|=
name|e
operator|->
name|exprblock
operator|.
name|leftp
decl_stmt|;
name|expptr
name|rightp
init|=
name|e
operator|->
name|exprblock
operator|.
name|rightp
decl_stmt|;
if|if
condition|(
name|leftp
operator|&&
name|rightp
operator|&&
operator|(
name|leftp
operator|->
name|headblock
operator|.
name|vstg
operator|==
name|STGARG
operator|||
name|ISINT
argument_list|(
name|leftp
operator|->
name|headblock
operator|.
name|vtype
argument_list|)
operator|)
operator|&&
operator|(
name|opcode
operator|==
name|OPPLUSEQ
operator|||
name|opcode
operator|==
name|OPMINUSEQ
operator|)
operator|&&
name|ISINT
argument_list|(
name|rightp
operator|->
name|headblock
operator|.
name|vtype
argument_list|)
operator|&&
name|ISICON
argument_list|(
name|e
operator|->
name|exprblock
operator|.
name|rightp
argument_list|)
operator|&&
operator|(
name|ISONE
argument_list|(
name|e
operator|->
name|exprblock
operator|.
name|rightp
argument_list|)
operator|||
name|e
operator|->
name|exprblock
operator|.
name|rightp
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
operator|==
operator|-
literal|1
operator|)
condition|)
block|{
comment|/* Allow for the '-1' constant value */
if|if
condition|(
operator|!
name|ISONE
argument_list|(
name|e
operator|->
name|exprblock
operator|.
name|rightp
argument_list|)
condition|)
name|opcode
operator|=
operator|(
name|opcode
operator|==
name|OPPLUSEQ
operator|)
condition|?
name|OPMINUSEQ
else|:
name|OPPLUSEQ
expr_stmt|;
comment|/* replace the existing opcode */
if|if
condition|(
name|opcode
operator|==
name|OPPLUSEQ
condition|)
name|e
operator|->
name|exprblock
operator|.
name|opcode
operator|=
name|OPPREINC
expr_stmt|;
else|else
name|e
operator|->
name|exprblock
operator|.
name|opcode
operator|=
name|OPPREDEC
expr_stmt|;
comment|/* Free up storage used by the right hand side */
name|frexpr
argument_list|(
name|e
operator|->
name|exprblock
operator|.
name|rightp
argument_list|)
expr_stmt|;
name|e
operator|->
name|exprblock
operator|.
name|rightp
operator|=
literal|0
expr_stmt|;
block|}
comment|/* if opcode == OPPLUS */
block|}
comment|/* block */
if|if
condition|(
name|is_unary_op
argument_list|(
name|e
operator|->
name|exprblock
operator|.
name|opcode
argument_list|)
condition|)
name|output_unary
argument_list|(
name|fp
argument_list|,
operator|&
operator|(
name|e
operator|->
name|exprblock
operator|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|is_binary_op
argument_list|(
name|e
operator|->
name|exprblock
operator|.
name|opcode
argument_list|)
condition|)
name|output_binary
argument_list|(
name|fp
argument_list|,
operator|&
operator|(
name|e
operator|->
name|exprblock
operator|)
argument_list|)
expr_stmt|;
else|else
name|erri
argument_list|(
literal|"expr_out: bad opcode '%d'"
argument_list|,
operator|(
name|int
operator|)
name|e
operator|->
name|exprblock
operator|.
name|opcode
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|e
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* expr_out */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|out_and_free_statement
parameter_list|(
name|outfile
parameter_list|,
name|expr
parameter_list|)
name|FILE
modifier|*
name|outfile
decl_stmt|;
name|expptr
name|expr
decl_stmt|;
else|#
directive|else
function|out_and_free_statement
parameter_list|(
name|FILE
modifier|*
name|outfile
parameter_list|,
name|expptr
name|expr
parameter_list|)
endif|#
directive|endif
block|{
if|if
condition|(
name|expr
condition|)
name|expr_out
argument_list|(
name|outfile
argument_list|,
name|expr
argument_list|)
expr_stmt|;
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|";\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* out_and_free_statement */
end_comment

begin_function
name|int
ifdef|#
directive|ifdef
name|KR_headers
name|same_ident
parameter_list|(
name|left
parameter_list|,
name|right
parameter_list|)
name|expptr
name|left
decl_stmt|;
name|expptr
name|right
decl_stmt|;
else|#
directive|else
function|same_ident
parameter_list|(
name|expptr
name|left
parameter_list|,
name|expptr
name|right
parameter_list|)
endif|#
directive|endif
block|{
if|if
condition|(
operator|!
name|left
operator|||
operator|!
name|right
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|left
operator|->
name|tag
operator|==
name|TNAME
operator|&&
name|right
operator|->
name|tag
operator|==
name|TNAME
operator|&&
name|left
operator|==
name|right
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|left
operator|->
name|tag
operator|==
name|TADDR
operator|&&
name|right
operator|->
name|tag
operator|==
name|TADDR
operator|&&
name|left
operator|->
name|addrblock
operator|.
name|uname_tag
operator|==
name|right
operator|->
name|addrblock
operator|.
name|uname_tag
condition|)
switch|switch
condition|(
name|left
operator|->
name|addrblock
operator|.
name|uname_tag
condition|)
block|{
case|case
name|UNAM_REF
case|:
case|case
name|UNAM_NAME
case|:
comment|/* Check for array subscripts */
if|if
condition|(
name|left
operator|->
name|addrblock
operator|.
name|user
operator|.
name|name
operator|->
name|vdim
operator|||
name|right
operator|->
name|addrblock
operator|.
name|user
operator|.
name|name
operator|->
name|vdim
condition|)
if|if
condition|(
name|left
operator|->
name|addrblock
operator|.
name|user
operator|.
name|name
operator|!=
name|right
operator|->
name|addrblock
operator|.
name|user
operator|.
name|name
operator|||
operator|!
name|same_expr
argument_list|(
name|left
operator|->
name|addrblock
operator|.
name|memoffset
argument_list|,
name|right
operator|->
name|addrblock
operator|.
name|memoffset
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|same_ident
argument_list|(
call|(
name|expptr
call|)
argument_list|(
name|left
operator|->
name|addrblock
operator|.
name|user
operator|.
name|name
argument_list|)
argument_list|,
operator|(
name|expptr
operator|)
name|right
operator|->
name|addrblock
operator|.
name|user
operator|.
name|name
argument_list|)
return|;
case|case
name|UNAM_IDENT
case|:
return|return
name|strcmp
argument_list|(
name|left
operator|->
name|addrblock
operator|.
name|user
operator|.
name|ident
argument_list|,
name|right
operator|->
name|addrblock
operator|.
name|user
operator|.
name|ident
argument_list|)
operator|==
literal|0
return|;
case|case
name|UNAM_CHARP
case|:
return|return
name|strcmp
argument_list|(
name|left
operator|->
name|addrblock
operator|.
name|user
operator|.
name|Charp
argument_list|,
name|right
operator|->
name|addrblock
operator|.
name|user
operator|.
name|Charp
argument_list|)
operator|==
literal|0
return|;
default|default:
return|return
literal|0
return|;
block|}
comment|/* switch */
if|if
condition|(
name|left
operator|->
name|tag
operator|==
name|TEXPR
operator|&&
name|left
operator|->
name|exprblock
operator|.
name|opcode
operator|==
name|OPWHATSIN
operator|&&
name|right
operator|->
name|tag
operator|==
name|TEXPR
operator|&&
name|right
operator|->
name|exprblock
operator|.
name|opcode
operator|==
name|OPWHATSIN
condition|)
return|return
name|same_ident
argument_list|(
name|left
operator|->
name|exprblock
operator|.
name|leftp
argument_list|,
name|right
operator|->
name|exprblock
operator|.
name|leftp
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* same_ident */
end_comment

begin_function
specifier|static
name|int
ifdef|#
directive|ifdef
name|KR_headers
name|samefpconst
parameter_list|(
name|c1
parameter_list|,
name|c2
parameter_list|,
name|n
parameter_list|)
specifier|register
name|Constp
name|c1
decl_stmt|;
specifier|register
name|Constp
name|c2
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
else|#
directive|else
function|samefpconst
parameter_list|(
specifier|register
name|Constp
name|c1
parameter_list|,
specifier|register
name|Constp
name|c2
parameter_list|,
specifier|register
name|int
name|n
parameter_list|)
endif|#
directive|endif
block|{
name|char
modifier|*
name|s1
decl_stmt|,
modifier|*
name|s2
decl_stmt|;
if|if
condition|(
operator|!
name|c1
operator|->
name|vstg
operator|&&
operator|!
name|c2
operator|->
name|vstg
condition|)
return|return
name|c1
operator|->
name|Const
operator|.
name|cd
index|[
name|n
index|]
operator|==
name|c2
operator|->
name|Const
operator|.
name|cd
index|[
name|n
index|]
return|;
name|s1
operator|=
name|c1
operator|->
name|vstg
condition|?
name|c1
operator|->
name|Const
operator|.
name|cds
index|[
name|n
index|]
else|:
name|dtos
argument_list|(
name|c1
operator|->
name|Const
operator|.
name|cd
index|[
name|n
index|]
argument_list|)
expr_stmt|;
name|s2
operator|=
name|c2
operator|->
name|vstg
condition|?
name|c2
operator|->
name|Const
operator|.
name|cds
index|[
name|n
index|]
else|:
name|dtos
argument_list|(
name|c2
operator|->
name|Const
operator|.
name|cd
index|[
name|n
index|]
argument_list|)
expr_stmt|;
return|return
operator|!
name|strcmp
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
ifdef|#
directive|ifdef
name|KR_headers
name|sameconst
parameter_list|(
name|c1
parameter_list|,
name|c2
parameter_list|)
specifier|register
name|Constp
name|c1
decl_stmt|;
specifier|register
name|Constp
name|c2
decl_stmt|;
else|#
directive|else
function|sameconst
parameter_list|(
specifier|register
name|Constp
name|c1
parameter_list|,
specifier|register
name|Constp
name|c2
parameter_list|)
endif|#
directive|endif
block|{
switch|switch
condition|(
name|c1
operator|->
name|vtype
condition|)
block|{
case|case
name|TYCOMPLEX
case|:
case|case
name|TYDCOMPLEX
case|:
if|if
condition|(
operator|!
name|samefpconst
argument_list|(
name|c1
argument_list|,
name|c2
argument_list|,
literal|1
argument_list|)
condition|)
return|return
literal|0
return|;
case|case
name|TYREAL
case|:
case|case
name|TYDREAL
case|:
return|return
name|samefpconst
argument_list|(
name|c1
argument_list|,
name|c2
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|TYCHAR
case|:
return|return
name|c1
operator|->
name|Const
operator|.
name|ccp1
operator|.
name|blanks
operator|==
name|c2
operator|->
name|Const
operator|.
name|ccp1
operator|.
name|blanks
operator|&&
name|c1
operator|->
name|vleng
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
operator|==
name|c2
operator|->
name|vleng
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
operator|&&
operator|!
name|memcmp
argument_list|(
name|c1
operator|->
name|Const
operator|.
name|ccp
argument_list|,
name|c2
operator|->
name|Const
operator|.
name|ccp
argument_list|,
operator|(
name|int
operator|)
name|c1
operator|->
name|vleng
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
argument_list|)
return|;
case|case
name|TYSHORT
case|:
case|case
name|TYINT
case|:
case|case
name|TYLOGICAL
case|:
return|return
name|c1
operator|->
name|Const
operator|.
name|ci
operator|==
name|c2
operator|->
name|Const
operator|.
name|ci
return|;
block|}
name|err
argument_list|(
literal|"unexpected type in sameconst"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* same_expr -- Returns true only if   e1 and e2   match.  This is    somewhat pessimistic, but can afford to be because it's just used to    optimize on the assignment operators (+=, -=, etc). */
end_comment

begin_function
name|int
ifdef|#
directive|ifdef
name|KR_headers
name|same_expr
parameter_list|(
name|e1
parameter_list|,
name|e2
parameter_list|)
name|expptr
name|e1
decl_stmt|;
name|expptr
name|e2
decl_stmt|;
else|#
directive|else
function|same_expr
parameter_list|(
name|expptr
name|e1
parameter_list|,
name|expptr
name|e2
parameter_list|)
endif|#
directive|endif
block|{
if|if
condition|(
operator|!
name|e1
operator|||
operator|!
name|e2
condition|)
return|return
operator|!
name|e1
operator|&&
operator|!
name|e2
return|;
if|if
condition|(
name|e1
operator|->
name|tag
operator|!=
name|e2
operator|->
name|tag
operator|||
name|e1
operator|->
name|headblock
operator|.
name|vtype
operator|!=
name|e2
operator|->
name|headblock
operator|.
name|vtype
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|e1
operator|->
name|tag
condition|)
block|{
case|case
name|TEXPR
case|:
if|if
condition|(
name|e1
operator|->
name|exprblock
operator|.
name|opcode
operator|!=
name|e2
operator|->
name|exprblock
operator|.
name|opcode
condition|)
return|return
literal|0
return|;
return|return
name|same_expr
argument_list|(
name|e1
operator|->
name|exprblock
operator|.
name|leftp
argument_list|,
name|e2
operator|->
name|exprblock
operator|.
name|leftp
argument_list|)
operator|&&
name|same_expr
argument_list|(
name|e1
operator|->
name|exprblock
operator|.
name|rightp
argument_list|,
name|e2
operator|->
name|exprblock
operator|.
name|rightp
argument_list|)
return|;
case|case
name|TNAME
case|:
case|case
name|TADDR
case|:
return|return
name|same_ident
argument_list|(
name|e1
argument_list|,
name|e2
argument_list|)
return|;
case|case
name|TCONST
case|:
return|return
name|sameconst
argument_list|(
operator|&
name|e1
operator|->
name|constblock
argument_list|,
operator|&
name|e2
operator|->
name|constblock
argument_list|)
return|;
default|default:
return|return
literal|0
return|;
block|}
comment|/* switch */
block|}
end_function

begin_comment
comment|/* same_expr */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|out_name
parameter_list|(
name|fp
parameter_list|,
name|namep
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
name|Namep
name|namep
decl_stmt|;
else|#
directive|else
function|out_name
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|Namep
name|namep
parameter_list|)
endif|#
directive|endif
block|{
specifier|extern
name|int
name|usedefsforcommon
decl_stmt|;
name|Extsym
modifier|*
name|comm
decl_stmt|;
if|if
condition|(
name|namep
operator|==
name|NULL
condition|)
return|return;
comment|/* DON'T want to use oneof_stg() here; need to find the right common name    */
if|if
condition|(
name|namep
operator|->
name|vstg
operator|==
name|STGCOMMON
operator|&&
operator|!
name|namep
operator|->
name|vcommequiv
operator|&&
operator|!
name|usedefsforcommon
condition|)
block|{
name|comm
operator|=
operator|&
name|extsymtab
index|[
name|namep
operator|->
name|vardesc
operator|.
name|varno
index|]
expr_stmt|;
name|extern_out
argument_list|(
name|fp
argument_list|,
name|comm
argument_list|)
expr_stmt|;
name|nice_printf
argument_list|(
name|fp
argument_list|,
literal|"%d."
argument_list|,
name|comm
operator|->
name|curno
argument_list|)
expr_stmt|;
block|}
comment|/* if namep -> vstg == STGCOMMON */
if|if
condition|(
name|namep
operator|->
name|vprocclass
operator|==
name|PTHISPROC
operator|&&
name|namep
operator|->
name|vtype
operator|!=
name|TYSUBR
condition|)
name|nice_printf
argument_list|(
name|fp
argument_list|,
name|xretslot
index|[
name|namep
operator|->
name|vtype
index|]
operator|->
name|user
operator|.
name|ident
argument_list|)
expr_stmt|;
else|else
name|nice_printf
argument_list|(
name|fp
argument_list|,
literal|"%s"
argument_list|,
name|namep
operator|->
name|cvarname
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* out_name */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|Longfmt
init|=
literal|"%ld"
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|cpd
parameter_list|(
name|n
parameter_list|)
value|cp->vstg ? cp->Const.cds[n] : dtos(cp->Const.cd[n])
end_define

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|out_const
parameter_list|(
name|fp
parameter_list|,
name|cp
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
specifier|register
name|Constp
name|cp
decl_stmt|;
else|#
directive|else
function|out_const
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
specifier|register
name|Constp
name|cp
parameter_list|)
endif|#
directive|endif
block|{
specifier|static
name|char
name|real_buf
index|[
literal|50
index|]
decl_stmt|,
name|imag_buf
index|[
literal|50
index|]
decl_stmt|;
name|unsigned
name|int
name|k
decl_stmt|;
name|int
name|type
init|=
name|cp
operator|->
name|vtype
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|TYINT1
case|:
case|case
name|TYSHORT
case|:
name|nice_printf
argument_list|(
name|fp
argument_list|,
literal|"%ld"
argument_list|,
name|cp
operator|->
name|Const
operator|.
name|ci
argument_list|)
expr_stmt|;
comment|/* don't cast ci! */
break|break;
case|case
name|TYLONG
case|:
ifdef|#
directive|ifdef
name|TYQUAD
case|case
name|TYQUAD
case|:
endif|#
directive|endif
name|nice_printf
argument_list|(
name|fp
argument_list|,
name|Longfmt
argument_list|,
name|cp
operator|->
name|Const
operator|.
name|ci
argument_list|)
expr_stmt|;
comment|/* don't cast ci! */
break|break;
case|case
name|TYREAL
case|:
name|nice_printf
argument_list|(
name|fp
argument_list|,
literal|"%s"
argument_list|,
name|flconst
argument_list|(
name|real_buf
argument_list|,
name|cpd
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYDREAL
case|:
name|nice_printf
argument_list|(
name|fp
argument_list|,
literal|"%s"
argument_list|,
name|cpd
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYCOMPLEX
case|:
name|nice_printf
argument_list|(
name|fp
argument_list|,
name|cm_fmt_string
argument_list|,
name|flconst
argument_list|(
name|real_buf
argument_list|,
name|cpd
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|,
name|flconst
argument_list|(
name|imag_buf
argument_list|,
name|cpd
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYDCOMPLEX
case|:
name|nice_printf
argument_list|(
name|fp
argument_list|,
name|dcm_fmt_string
argument_list|,
name|cpd
argument_list|(
literal|0
argument_list|)
argument_list|,
name|cpd
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYLOGICAL1
case|:
case|case
name|TYLOGICAL2
case|:
case|case
name|TYLOGICAL
case|:
name|nice_printf
argument_list|(
name|fp
argument_list|,
literal|"%s"
argument_list|,
name|cp
operator|->
name|Const
operator|.
name|ci
condition|?
literal|"TRUE_"
else|:
literal|"FALSE_"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYCHAR
case|:
block|{
name|char
modifier|*
name|c
init|=
name|cp
operator|->
name|Const
operator|.
name|ccp
decl_stmt|,
modifier|*
name|ce
decl_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
block|{
name|nice_printf
argument_list|(
name|fp
argument_list|,
literal|"\"\""
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* if c == NULL */
name|nice_printf
argument_list|(
name|fp
argument_list|,
literal|"\""
argument_list|)
expr_stmt|;
name|ce
operator|=
name|c
operator|+
name|cp
operator|->
name|vleng
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
expr_stmt|;
while|while
condition|(
name|c
operator|<
name|ce
condition|)
block|{
name|k
operator|=
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|)
name|c
operator|++
expr_stmt|;
name|nice_printf
argument_list|(
name|fp
argument_list|,
name|str_fmt
index|[
name|k
index|]
argument_list|,
name|k
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|k
operator|=
name|cp
operator|->
name|Const
operator|.
name|ccp1
operator|.
name|blanks
init|;
name|k
operator|>
literal|0
condition|;
name|k
operator|--
control|)
name|nice_printf
argument_list|(
name|fp
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|nice_printf
argument_list|(
name|fp
argument_list|,
literal|"\""
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* case TYCHAR */
default|default:
name|erri
argument_list|(
literal|"out_const:  bad type '%d'"
argument_list|,
operator|(
name|int
operator|)
name|type
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* switch */
block|}
end_function

begin_comment
comment|/* out_const */
end_comment

begin_undef
undef|#
directive|undef
name|cpd
end_undef

begin_function
specifier|static
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|out_args
parameter_list|(
name|fp
parameter_list|,
name|ep
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
name|expptr
name|ep
decl_stmt|;
else|#
directive|else
function|out_args
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|expptr
name|ep
parameter_list|)
endif|#
directive|endif
block|{
name|chainp
name|arglist
decl_stmt|;
if|if
condition|(
name|ep
operator|->
name|tag
operator|!=
name|TLIST
condition|)
name|badtag
argument_list|(
literal|"out_args"
argument_list|,
name|ep
operator|->
name|tag
argument_list|)
expr_stmt|;
for|for
control|(
name|arglist
operator|=
name|ep
operator|->
name|listblock
operator|.
name|listp
init|;
condition|;
control|)
block|{
name|expr_out
argument_list|(
name|fp
argument_list|,
operator|(
name|expptr
operator|)
name|arglist
operator|->
name|datap
argument_list|)
expr_stmt|;
name|arglist
operator|->
name|datap
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|arglist
operator|=
name|arglist
operator|->
name|nextp
operator|)
condition|)
break|break;
name|nice_printf
argument_list|(
name|fp
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* out_addr -- this routine isn't local because it is called by the    system-generated identifier printing routines */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|out_addr
parameter_list|(
name|fp
parameter_list|,
name|addrp
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
name|struct
name|Addrblock
modifier|*
name|addrp
decl_stmt|;
else|#
directive|else
function|out_addr
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|struct
name|Addrblock
modifier|*
name|addrp
parameter_list|)
endif|#
directive|endif
block|{
specifier|extern
name|Extsym
modifier|*
name|extsymtab
decl_stmt|;
name|int
name|was_array
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|addrp
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|doin_setbound
operator|&&
name|addrp
operator|->
name|vstg
operator|==
name|STGARG
operator|&&
name|addrp
operator|->
name|vtype
operator|!=
name|TYCHAR
operator|&&
name|ISICON
argument_list|(
name|addrp
operator|->
name|memoffset
argument_list|)
operator|&&
operator|!
name|addrp
operator|->
name|memoffset
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
condition|)
name|nice_printf
argument_list|(
name|fp
argument_list|,
literal|"*"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|addrp
operator|->
name|uname_tag
condition|)
block|{
case|case
name|UNAM_REF
case|:
name|nice_printf
argument_list|(
name|fp
argument_list|,
literal|"%s_%s("
argument_list|,
name|addrp
operator|->
name|user
operator|.
name|name
operator|->
name|cvarname
argument_list|,
name|addrp
operator|->
name|cmplx_sub
condition|?
literal|"subscr"
else|:
literal|"ref"
argument_list|)
expr_stmt|;
name|out_args
argument_list|(
name|fp
argument_list|,
name|addrp
operator|->
name|memoffset
argument_list|)
expr_stmt|;
name|nice_printf
argument_list|(
name|fp
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
return|return;
case|case
name|UNAM_NAME
case|:
name|out_name
argument_list|(
name|fp
argument_list|,
name|addrp
operator|->
name|user
operator|.
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNAM_IDENT
case|:
if|if
condition|(
operator|*
operator|(
name|s
operator|=
name|addrp
operator|->
name|user
operator|.
name|ident
operator|)
operator|==
literal|' '
condition|)
block|{
if|if
condition|(
name|multitype
condition|)
name|nice_printf
argument_list|(
name|fp
argument_list|,
literal|"%s"
argument_list|,
name|xretslot
index|[
name|addrp
operator|->
name|vtype
index|]
operator|->
name|user
operator|.
name|ident
argument_list|)
expr_stmt|;
else|else
name|nice_printf
argument_list|(
name|fp
argument_list|,
literal|"%s"
argument_list|,
name|s
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nice_printf
argument_list|(
name|fp
argument_list|,
literal|"%s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|UNAM_CHARP
case|:
name|nice_printf
argument_list|(
name|fp
argument_list|,
literal|"%s"
argument_list|,
name|addrp
operator|->
name|user
operator|.
name|Charp
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNAM_EXTERN
case|:
name|extern_out
argument_list|(
name|fp
argument_list|,
operator|&
name|extsymtab
index|[
name|addrp
operator|->
name|memno
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNAM_CONST
case|:
switch|switch
condition|(
name|addrp
operator|->
name|vstg
condition|)
block|{
case|case
name|STGCONST
case|:
name|out_const
argument_list|(
name|fp
argument_list|,
operator|(
name|Constp
operator|)
name|addrp
argument_list|)
expr_stmt|;
break|break;
case|case
name|STGMEMNO
case|:
name|output_literal
argument_list|(
name|fp
argument_list|,
name|addrp
operator|->
name|memno
argument_list|,
operator|(
name|Constp
operator|)
name|addrp
argument_list|)
expr_stmt|;
break|break;
default|default:
name|Fatal
argument_list|(
literal|"unexpected vstg in out_addr"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|UNAM_UNKNOWN
case|:
default|default:
name|nice_printf
argument_list|(
name|fp
argument_list|,
literal|"Unknown Addrp"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* switch */
comment|/* It's okay to just throw in the brackets here because they have a    precedence level of 15, the highest value.  */
if|if
condition|(
operator|(
name|addrp
operator|->
name|uname_tag
operator|==
name|UNAM_NAME
operator|&&
name|addrp
operator|->
name|user
operator|.
name|name
operator|->
name|vdim
operator|||
name|addrp
operator|->
name|ntempelt
operator|>
literal|1
operator|||
name|addrp
operator|->
name|isarray
operator|)
operator|&&
name|addrp
operator|->
name|vtype
operator|!=
name|TYCHAR
condition|)
block|{
name|expptr
name|offset
decl_stmt|;
name|was_array
operator|=
literal|1
expr_stmt|;
name|offset
operator|=
name|addrp
operator|->
name|memoffset
expr_stmt|;
name|addrp
operator|->
name|memoffset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ONEOF
argument_list|(
name|addrp
operator|->
name|vstg
argument_list|,
name|M
argument_list|(
name|STGCOMMON
argument_list|)
operator||
name|M
argument_list|(
name|STGEQUIV
argument_list|)
argument_list|)
operator|&&
name|addrp
operator|->
name|uname_tag
operator|==
name|UNAM_NAME
operator|&&
operator|!
name|addrp
operator|->
name|skip_offset
condition|)
name|offset
operator|=
name|mkexpr
argument_list|(
name|OPMINUS
argument_list|,
name|offset
argument_list|,
name|mkintcon
argument_list|(
name|addrp
operator|->
name|user
operator|.
name|name
operator|->
name|voffset
argument_list|)
argument_list|)
expr_stmt|;
name|nice_printf
argument_list|(
name|fp
argument_list|,
literal|"["
argument_list|)
expr_stmt|;
name|offset
operator|=
name|mkexpr
argument_list|(
name|OPSLASH
argument_list|,
name|offset
argument_list|,
name|ICON
argument_list|(
name|typesize
index|[
name|addrp
operator|->
name|vtype
index|]
operator|*
operator|(
name|addrp
operator|->
name|Field
condition|?
literal|2
else|:
literal|1
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr_out
argument_list|(
name|fp
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|nice_printf
argument_list|(
name|fp
argument_list|,
literal|"]"
argument_list|)
expr_stmt|;
block|}
comment|/* Check for structure field reference */
if|if
condition|(
name|addrp
operator|->
name|Field
operator|&&
name|addrp
operator|->
name|uname_tag
operator|!=
name|UNAM_CONST
operator|&&
name|addrp
operator|->
name|uname_tag
operator|!=
name|UNAM_UNKNOWN
condition|)
block|{
if|if
condition|(
name|oneof_stg
argument_list|(
operator|(
name|addrp
operator|->
name|uname_tag
operator|==
name|UNAM_NAME
condition|?
name|addrp
operator|->
name|user
operator|.
name|name
else|:
operator|(
name|Namep
operator|)
name|NULL
operator|)
argument_list|,
name|addrp
operator|->
name|vstg
argument_list|,
name|M
argument_list|(
name|STGARG
argument_list|)
operator||
name|M
argument_list|(
name|STGEQUIV
argument_list|)
argument_list|)
operator|&&
operator|!
name|was_array
operator|&&
operator|(
name|addrp
operator|->
name|vclass
operator|!=
name|CLPROC
operator|||
operator|!
name|multitype
operator|)
condition|)
name|nice_printf
argument_list|(
name|fp
argument_list|,
literal|"->%s"
argument_list|,
name|addrp
operator|->
name|Field
argument_list|)
expr_stmt|;
else|else
name|nice_printf
argument_list|(
name|fp
argument_list|,
literal|".%s"
argument_list|,
name|addrp
operator|->
name|Field
argument_list|)
expr_stmt|;
block|}
comment|/* if */
comment|/* Check for character subscripting */
if|if
condition|(
name|addrp
operator|->
name|vtype
operator|==
name|TYCHAR
operator|&&
operator|(
name|addrp
operator|->
name|vclass
operator|!=
name|CLPROC
operator|||
name|addrp
operator|->
name|uname_tag
operator|==
name|UNAM_NAME
operator|&&
name|addrp
operator|->
name|user
operator|.
name|name
operator|->
name|vprocclass
operator|==
name|PTHISPROC
operator|)
operator|&&
name|addrp
operator|->
name|memoffset
operator|&&
operator|(
name|addrp
operator|->
name|uname_tag
operator|!=
name|UNAM_NAME
operator|||
name|addrp
operator|->
name|user
operator|.
name|name
operator|->
name|vtype
operator|==
name|TYCHAR
operator|)
operator|&&
operator|(
operator|!
name|ISICON
argument_list|(
name|addrp
operator|->
name|memoffset
argument_list|)
operator|||
operator|(
name|addrp
operator|->
name|memoffset
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
operator|)
operator|)
condition|)
block|{
name|int
name|use_paren
init|=
literal|0
decl_stmt|;
name|expptr
name|e
init|=
name|addrp
operator|->
name|memoffset
decl_stmt|;
if|if
condition|(
operator|!
name|e
condition|)
return|return;
name|addrp
operator|->
name|memoffset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ONEOF
argument_list|(
name|addrp
operator|->
name|vstg
argument_list|,
name|M
argument_list|(
name|STGCOMMON
argument_list|)
operator||
name|M
argument_list|(
name|STGEQUIV
argument_list|)
argument_list|)
operator|&&
name|addrp
operator|->
name|uname_tag
operator|==
name|UNAM_NAME
condition|)
block|{
name|e
operator|=
name|mkexpr
argument_list|(
name|OPMINUS
argument_list|,
name|e
argument_list|,
name|mkintcon
argument_list|(
name|addrp
operator|->
name|user
operator|.
name|name
operator|->
name|voffset
argument_list|)
argument_list|)
expr_stmt|;
comment|/* mkexpr will simplify it to zero if possible */
if|if
condition|(
name|e
operator|->
name|tag
operator|==
name|TCONST
operator|&&
name|e
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
operator|==
literal|0
condition|)
return|return;
block|}
comment|/* if addrp -> vstg == STGCOMMON */
comment|/* In the worst case, parentheses might be needed OUTSIDE the expression,    too.  But since I think this subscripting can only appear as a    parameter in a procedure call, I don't think outside parens will ever    be needed.  INSIDE parens are handled below */
name|nice_printf
argument_list|(
name|fp
argument_list|,
literal|" + "
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|tag
operator|==
name|TEXPR
condition|)
block|{
name|int
name|arg_prec
init|=
name|op_precedence
argument_list|(
name|e
operator|->
name|exprblock
operator|.
name|opcode
argument_list|)
decl_stmt|;
name|int
name|prec
init|=
name|op_precedence
argument_list|(
name|OPPLUS
argument_list|)
decl_stmt|;
name|use_paren
operator|=
name|arg_prec
operator|&&
operator|(
name|arg_prec
operator|<
name|prec
operator|||
operator|(
name|arg_prec
operator|==
name|prec
operator|&&
name|is_left_assoc
argument_list|(
name|OPPLUS
argument_list|)
operator|)
operator|)
expr_stmt|;
block|}
comment|/* if e -> tag == TEXPR */
if|if
condition|(
name|use_paren
condition|)
name|nice_printf
argument_list|(
name|fp
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|expr_out
argument_list|(
name|fp
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_paren
condition|)
name|nice_printf
argument_list|(
name|fp
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
comment|/* if */
block|}
end_function

begin_comment
comment|/* out_addr */
end_comment

begin_function
specifier|static
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|output_literal
parameter_list|(
name|fp
parameter_list|,
name|memno
parameter_list|,
name|cp
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
name|long
name|memno
decl_stmt|;
name|Constp
name|cp
decl_stmt|;
else|#
directive|else
function|output_literal
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|long
name|memno
parameter_list|,
name|Constp
name|cp
parameter_list|)
endif|#
directive|endif
block|{
name|struct
name|Literal
modifier|*
name|litp
decl_stmt|,
modifier|*
name|lastlit
decl_stmt|;
name|lastlit
operator|=
name|litpool
operator|+
name|nliterals
expr_stmt|;
for|for
control|(
name|litp
operator|=
name|litpool
init|;
name|litp
operator|<
name|lastlit
condition|;
name|litp
operator|++
control|)
block|{
if|if
condition|(
name|litp
operator|->
name|litnum
operator|==
name|memno
condition|)
break|break;
block|}
comment|/* for litp */
if|if
condition|(
name|litp
operator|>=
name|lastlit
condition|)
name|out_const
argument_list|(
name|fp
argument_list|,
name|cp
argument_list|)
expr_stmt|;
else|else
block|{
name|nice_printf
argument_list|(
name|fp
argument_list|,
literal|"%s"
argument_list|,
name|lit_name
argument_list|(
name|litp
argument_list|)
argument_list|)
expr_stmt|;
name|litp
operator|->
name|lituse
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* output_literal */
end_comment

begin_function
specifier|static
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|output_prim
parameter_list|(
name|fp
parameter_list|,
name|primp
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
name|struct
name|Primblock
modifier|*
name|primp
decl_stmt|;
else|#
directive|else
function|output_prim
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|struct
name|Primblock
modifier|*
name|primp
parameter_list|)
endif|#
directive|endif
block|{
if|if
condition|(
name|primp
operator|==
name|NULL
condition|)
return|return;
name|out_name
argument_list|(
name|fp
argument_list|,
name|primp
operator|->
name|namep
argument_list|)
expr_stmt|;
if|if
condition|(
name|primp
operator|->
name|argsp
condition|)
name|output_arg_list
argument_list|(
name|fp
argument_list|,
name|primp
operator|->
name|argsp
argument_list|)
expr_stmt|;
if|if
condition|(
name|primp
operator|->
name|fcharp
operator|!=
operator|(
name|expptr
operator|)
name|NULL
operator|||
name|primp
operator|->
name|lcharp
operator|!=
operator|(
name|expptr
operator|)
name|NULL
condition|)
name|nice_printf
argument_list|(
name|fp
argument_list|,
literal|"Sorry, no substrings yet"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|output_arg_list
parameter_list|(
name|fp
parameter_list|,
name|listp
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
name|struct
name|Listblock
modifier|*
name|listp
decl_stmt|;
else|#
directive|else
function|output_arg_list
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|struct
name|Listblock
modifier|*
name|listp
parameter_list|)
endif|#
directive|endif
block|{
name|chainp
name|arg_list
decl_stmt|;
if|if
condition|(
name|listp
operator|==
operator|(
expr|struct
name|Listblock
operator|*
operator|)
name|NULL
operator|||
name|listp
operator|->
name|listp
operator|==
operator|(
name|chainp
operator|)
name|NULL
condition|)
return|return;
name|nice_printf
argument_list|(
name|fp
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
for|for
control|(
name|arg_list
operator|=
name|listp
operator|->
name|listp
init|;
name|arg_list
condition|;
name|arg_list
operator|=
name|arg_list
operator|->
name|nextp
control|)
block|{
name|expr_out
argument_list|(
name|fp
argument_list|,
operator|(
name|expptr
operator|)
name|arg_list
operator|->
name|datap
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg_list
operator|->
name|nextp
operator|!=
operator|(
name|chainp
operator|)
name|NULL
condition|)
comment|/* Might want to add a hook in here to accomodate the style setting which    wants spaces after commas */
name|nice_printf
argument_list|(
name|fp
argument_list|,
literal|","
argument_list|)
expr_stmt|;
block|}
comment|/* for arg_list */
name|nice_printf
argument_list|(
name|fp
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* output_arg_list */
end_comment

begin_function
specifier|static
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|output_unary
parameter_list|(
name|fp
parameter_list|,
name|e
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
name|struct
name|Exprblock
modifier|*
name|e
decl_stmt|;
else|#
directive|else
function|output_unary
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|struct
name|Exprblock
modifier|*
name|e
parameter_list|)
endif|#
directive|endif
block|{
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
return|return;
switch|switch
condition|(
name|e
operator|->
name|opcode
condition|)
block|{
case|case
name|OPNEG
case|:
if|if
condition|(
name|e
operator|->
name|vtype
operator|==
name|TYREAL
operator|&&
name|dneg
condition|)
block|{
name|e
operator|->
name|opcode
operator|=
name|OPNEG_KLUDGE
expr_stmt|;
name|output_binary
argument_list|(
name|fp
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|e
operator|->
name|opcode
operator|=
name|OPNEG
expr_stmt|;
break|break;
block|}
case|case
name|OPNEG1
case|:
case|case
name|OPNOT
case|:
case|case
name|OPABS
case|:
case|case
name|OPBITNOT
case|:
case|case
name|OPWHATSIN
case|:
case|case
name|OPPREINC
case|:
case|case
name|OPPREDEC
case|:
case|case
name|OPADDR
case|:
case|case
name|OPIDENTITY
case|:
case|case
name|OPCHARCAST
case|:
case|case
name|OPDABS
case|:
name|output_binary
argument_list|(
name|fp
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPCALL
case|:
case|case
name|OPCCALL
case|:
name|nice_printf
argument_list|(
name|fp
argument_list|,
literal|"Sorry, no OPCALL yet"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|erri
argument_list|(
literal|"output_unary: bad opcode"
argument_list|,
operator|(
name|int
operator|)
name|e
operator|->
name|opcode
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* switch */
block|}
end_function

begin_comment
comment|/* output_unary */
end_comment

begin_function
specifier|static
name|char
modifier|*
ifdef|#
directive|ifdef
name|KR_headers
name|findconst
parameter_list|(
name|m
parameter_list|)
specifier|register
name|long
name|m
decl_stmt|;
else|#
directive|else
function|findconst
parameter_list|(
specifier|register
name|long
name|m
parameter_list|)
endif|#
directive|endif
block|{
specifier|register
name|struct
name|Literal
modifier|*
name|litp
decl_stmt|,
modifier|*
name|litpe
decl_stmt|;
name|litp
operator|=
name|litpool
expr_stmt|;
for|for
control|(
name|litpe
operator|=
name|litp
operator|+
name|nliterals
init|;
name|litp
operator|<
name|litpe
condition|;
name|litp
operator|++
control|)
if|if
condition|(
name|litp
operator|->
name|litnum
operator|==
name|m
condition|)
return|return
name|litp
operator|->
name|cds
index|[
literal|0
index|]
return|;
name|Fatal
argument_list|(
literal|"findconst failure!"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
ifdef|#
directive|ifdef
name|KR_headers
name|opconv_fudge
parameter_list|(
name|fp
parameter_list|,
name|e
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
name|struct
name|Exprblock
modifier|*
name|e
decl_stmt|;
else|#
directive|else
function|opconv_fudge
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|struct
name|Exprblock
modifier|*
name|e
parameter_list|)
endif|#
directive|endif
block|{
comment|/* special handling for conversions, ichar and character*1 */
specifier|register
name|expptr
name|lp
decl_stmt|;
specifier|register
name|union
name|Expression
modifier|*
name|Offset
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|lt
decl_stmt|;
name|char
name|buf
index|[
literal|8
index|]
decl_stmt|,
modifier|*
name|s
decl_stmt|;
name|unsigned
name|int
name|k
decl_stmt|;
name|Namep
name|np
decl_stmt|;
name|Addrp
name|ap
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|lp
operator|=
name|e
operator|->
name|leftp
operator|)
condition|)
comment|/* possible with erroneous Fortran */
return|return
literal|1
return|;
name|lt
operator|=
name|lp
operator|->
name|headblock
operator|.
name|vtype
expr_stmt|;
if|if
condition|(
name|lt
operator|==
name|TYCHAR
condition|)
block|{
switch|switch
condition|(
name|lp
operator|->
name|tag
condition|)
block|{
case|case
name|TNAME
case|:
name|nice_printf
argument_list|(
name|fp
argument_list|,
literal|"*(unsigned char *)"
argument_list|)
expr_stmt|;
name|out_name
argument_list|(
name|fp
argument_list|,
operator|(
name|Namep
operator|)
name|lp
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|TCONST
case|:
name|tconst
label|:
name|cp
operator|=
name|lp
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ccp
expr_stmt|;
name|tconst1
label|:
name|k
operator|=
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|)
name|cp
expr_stmt|;
if|if
condition|(
name|k
operator|<
literal|128
condition|)
block|{
comment|/* ASCII character */
name|sprintf
argument_list|(
name|buf
argument_list|,
name|chr_fmt
index|[
name|k
index|]
argument_list|,
name|k
argument_list|)
expr_stmt|;
name|nice_printf
argument_list|(
name|fp
argument_list|,
literal|"'%s'"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
else|else
name|nice_printf
argument_list|(
name|fp
argument_list|,
literal|"%d"
argument_list|,
name|k
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|TADDR
case|:
switch|switch
condition|(
name|lp
operator|->
name|addrblock
operator|.
name|vstg
condition|)
block|{
case|case
name|STGMEMNO
case|:
if|if
condition|(
name|halign
operator|&&
name|e
operator|->
name|vtype
operator|!=
name|TYCHAR
condition|)
block|{
name|nice_printf
argument_list|(
name|fp
argument_list|,
literal|"*(%s *)"
argument_list|,
name|c_type_decl
argument_list|(
name|e
operator|->
name|vtype
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|expr_out
argument_list|(
name|fp
argument_list|,
name|lp
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|cp
operator|=
name|findconst
argument_list|(
name|lp
operator|->
name|addrblock
operator|.
name|memno
argument_list|)
expr_stmt|;
goto|goto
name|tconst1
goto|;
case|case
name|STGCONST
case|:
goto|goto
name|tconst
goto|;
block|}
name|lp
operator|->
name|addrblock
operator|.
name|vtype
operator|=
name|tyint
expr_stmt|;
name|Offset
operator|=
name|lp
operator|->
name|addrblock
operator|.
name|memoffset
expr_stmt|;
switch|switch
condition|(
name|lp
operator|->
name|addrblock
operator|.
name|uname_tag
condition|)
block|{
case|case
name|UNAM_REF
case|:
name|nice_printf
argument_list|(
name|fp
argument_list|,
literal|"*(unsigned char *)"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|UNAM_NAME
case|:
name|np
operator|=
name|lp
operator|->
name|addrblock
operator|.
name|user
operator|.
name|name
expr_stmt|;
if|if
condition|(
name|ONEOF
argument_list|(
name|np
operator|->
name|vstg
argument_list|,
name|M
argument_list|(
name|STGCOMMON
argument_list|)
operator||
name|M
argument_list|(
name|STGEQUIV
argument_list|)
argument_list|)
condition|)
name|Offset
operator|=
name|mkexpr
argument_list|(
name|OPMINUS
argument_list|,
name|Offset
argument_list|,
name|ICON
argument_list|(
name|np
operator|->
name|voffset
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|lp
operator|->
name|addrblock
operator|.
name|memoffset
operator|=
name|Offset
condition|?
name|mkexpr
argument_list|(
name|OPSTAR
argument_list|,
name|Offset
argument_list|,
name|ICON
argument_list|(
name|typesize
index|[
name|tyint
index|]
argument_list|)
argument_list|)
else|:
name|ICON
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|lp
operator|->
name|addrblock
operator|.
name|isarray
operator|=
literal|1
expr_stmt|;
comment|/* STGCOMMON or STGEQUIV would cause */
comment|/* voffset to be added in a second time */
name|lp
operator|->
name|addrblock
operator|.
name|vstg
operator|=
name|STGUNKNOWN
expr_stmt|;
name|nice_printf
argument_list|(
name|fp
argument_list|,
literal|"*(unsigned char *)&"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
default|default:
name|badtag
argument_list|(
literal|"opconv_fudge"
argument_list|,
name|lp
operator|->
name|tag
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|lt
operator|!=
name|e
operator|->
name|vtype
condition|)
block|{
name|s
operator|=
name|c_type_decl
argument_list|(
name|e
operator|->
name|vtype
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISCOMPLEX
argument_list|(
name|lt
argument_list|)
condition|)
block|{
name|tryagain
label|:
name|np
operator|=
operator|(
name|Namep
operator|)
name|e
operator|->
name|leftp
expr_stmt|;
switch|switch
condition|(
name|np
operator|->
name|tag
condition|)
block|{
case|case
name|TNAME
case|:
name|nice_printf
argument_list|(
name|fp
argument_list|,
literal|"(%s) %s%sr"
argument_list|,
name|s
argument_list|,
name|np
operator|->
name|cvarname
argument_list|,
name|np
operator|->
name|vstg
operator|==
name|STGARG
condition|?
literal|"->"
else|:
literal|"."
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|TADDR
case|:
name|ap
operator|=
operator|(
name|Addrp
operator|)
name|np
expr_stmt|;
switch|switch
condition|(
name|ap
operator|->
name|uname_tag
condition|)
block|{
case|case
name|UNAM_IDENT
case|:
name|nice_printf
argument_list|(
name|fp
argument_list|,
literal|"(%s) %s.r"
argument_list|,
name|s
argument_list|,
name|ap
operator|->
name|user
operator|.
name|ident
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|UNAM_NAME
case|:
name|nice_printf
argument_list|(
name|fp
argument_list|,
literal|"(%s) "
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|out_addr
argument_list|(
name|fp
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|nice_printf
argument_list|(
name|fp
argument_list|,
literal|".r"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
case|case
name|TEXPR
case|:
name|e
operator|=
operator|(
name|Exprp
operator|)
name|np
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|opcode
operator|==
name|OPWHATSIN
condition|)
goto|goto
name|tryagain
goto|;
default|default:
name|fatali
argument_list|(
literal|"Unexpected tag %d in opconv_fudge"
argument_list|,
name|np
operator|->
name|tag
argument_list|)
expr_stmt|;
block|}
block|}
name|nice_printf
argument_list|(
name|fp
argument_list|,
literal|"(%s) "
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|output_binary
parameter_list|(
name|fp
parameter_list|,
name|e
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
name|struct
name|Exprblock
modifier|*
name|e
decl_stmt|;
else|#
directive|else
function|output_binary
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|struct
name|Exprblock
modifier|*
name|e
parameter_list|)
endif|#
directive|endif
block|{
name|char
modifier|*
name|format
decl_stmt|;
specifier|extern
name|table_entry
name|opcode_table
index|[]
decl_stmt|;
name|int
name|prec
decl_stmt|;
if|if
condition|(
name|e
operator|==
name|NULL
operator|||
name|e
operator|->
name|tag
operator|!=
name|TEXPR
condition|)
return|return;
comment|/* Instead of writing a huge switch, I've incorporated the output format    into a table.  Things like "%l" and "%r" stand for the left and    right subexpressions.  This should allow both prefix and infix    functions to be specified (e.g. "(%l * %r", "z_div (%l, %r").  Of    course, I should REALLY think out the ramifications of writing out    straight text, as opposed to some intermediate format, which could    figure out and optimize on the the number of required blanks (we don't    want "x - (-y)" to become "x --y", for example).  Special cases (such as    incomplete implementations) could still be implemented as part of the    switch, they will just have some dummy value instead of the string    pattern.  Another difficulty is the fact that the complex functions    will differ from the integer and real ones */
comment|/* Handle a special case.  We don't want to output "x + - 4", or "y - - 3" */
if|if
condition|(
operator|(
name|e
operator|->
name|opcode
operator|==
name|OPPLUS
operator|||
name|e
operator|->
name|opcode
operator|==
name|OPMINUS
operator|)
operator|&&
name|e
operator|->
name|rightp
operator|&&
name|e
operator|->
name|rightp
operator|->
name|tag
operator|==
name|TCONST
operator|&&
name|isnegative_const
argument_list|(
operator|&
operator|(
name|e
operator|->
name|rightp
operator|->
name|constblock
operator|)
argument_list|)
operator|&&
name|is_negatable
argument_list|(
operator|&
operator|(
name|e
operator|->
name|rightp
operator|->
name|constblock
operator|)
argument_list|)
condition|)
block|{
name|e
operator|->
name|opcode
operator|=
operator|(
name|e
operator|->
name|opcode
operator|==
name|OPPLUS
operator|)
condition|?
name|OPMINUS
else|:
name|OPPLUS
expr_stmt|;
name|negate_const
argument_list|(
operator|&
operator|(
name|e
operator|->
name|rightp
operator|->
name|constblock
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* if e -> opcode == PLUS or MINUS */
name|prec
operator|=
name|op_precedence
argument_list|(
name|e
operator|->
name|opcode
argument_list|)
expr_stmt|;
name|format
operator|=
name|op_format
argument_list|(
name|e
operator|->
name|opcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|format
operator|!=
name|SPECIAL_FMT
condition|)
block|{
while|while
condition|(
operator|*
name|format
condition|)
block|{
if|if
condition|(
operator|*
name|format
operator|==
literal|'%'
condition|)
block|{
name|int
name|arg_prec
decl_stmt|,
name|use_paren
init|=
literal|0
decl_stmt|;
name|expptr
name|lp
decl_stmt|,
name|rp
decl_stmt|;
switch|switch
condition|(
operator|*
operator|(
name|format
operator|+
literal|1
operator|)
condition|)
block|{
case|case
literal|'l'
case|:
name|lp
operator|=
name|e
operator|->
name|leftp
expr_stmt|;
if|if
condition|(
name|lp
operator|&&
name|lp
operator|->
name|tag
operator|==
name|TEXPR
condition|)
block|{
name|arg_prec
operator|=
name|op_precedence
argument_list|(
name|lp
operator|->
name|exprblock
operator|.
name|opcode
argument_list|)
expr_stmt|;
name|use_paren
operator|=
name|arg_prec
operator|&&
operator|(
name|arg_prec
operator|<
name|prec
operator|||
operator|(
name|arg_prec
operator|==
name|prec
operator|&&
name|is_right_assoc
argument_list|(
name|prec
argument_list|)
operator|)
operator|)
expr_stmt|;
block|}
comment|/* if e -> leftp */
if|if
condition|(
name|e
operator|->
name|opcode
operator|==
name|OPCONV
operator|&&
name|opconv_fudge
argument_list|(
name|fp
argument_list|,
name|e
argument_list|)
condition|)
break|break;
if|if
condition|(
name|use_paren
condition|)
name|nice_printf
argument_list|(
name|fp
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|expr_out
argument_list|(
name|fp
argument_list|,
name|lp
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_paren
condition|)
name|nice_printf
argument_list|(
name|fp
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|rp
operator|=
name|e
operator|->
name|rightp
expr_stmt|;
if|if
condition|(
name|rp
operator|&&
name|rp
operator|->
name|tag
operator|==
name|TEXPR
condition|)
block|{
name|arg_prec
operator|=
name|op_precedence
argument_list|(
name|rp
operator|->
name|exprblock
operator|.
name|opcode
argument_list|)
expr_stmt|;
name|use_paren
operator|=
name|arg_prec
operator|&&
operator|(
name|arg_prec
operator|<
name|prec
operator|||
operator|(
name|arg_prec
operator|==
name|prec
operator|&&
name|is_left_assoc
argument_list|(
name|prec
argument_list|)
operator|)
operator|)
expr_stmt|;
name|use_paren
operator|=
name|use_paren
operator|||
operator|(
name|rp
operator|->
name|exprblock
operator|.
name|opcode
operator|==
name|OPNEG
operator|&&
name|prec
operator|>=
name|op_precedence
argument_list|(
name|OPMINUS
argument_list|)
operator|)
expr_stmt|;
block|}
comment|/* if e -> rightp */
if|if
condition|(
name|use_paren
condition|)
name|nice_printf
argument_list|(
name|fp
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|expr_out
argument_list|(
name|fp
argument_list|,
name|rp
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_paren
condition|)
name|nice_printf
argument_list|(
name|fp
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\0'
case|:
case|case
literal|'%'
case|:
name|nice_printf
argument_list|(
name|fp
argument_list|,
literal|"%%"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|erri
argument_list|(
literal|"output_binary: format err: '%%%c' illegal"
argument_list|,
operator|(
name|int
operator|)
operator|*
operator|(
name|format
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* switch */
name|format
operator|+=
literal|2
expr_stmt|;
block|}
else|else
name|nice_printf
argument_list|(
name|fp
argument_list|,
literal|"%c"
argument_list|,
operator|*
name|format
operator|++
argument_list|)
expr_stmt|;
block|}
comment|/* while *format */
block|}
else|else
block|{
comment|/* Handle Special cases of formatting */
switch|switch
condition|(
name|e
operator|->
name|opcode
condition|)
block|{
case|case
name|OPCCALL
case|:
case|case
name|OPCALL
case|:
name|out_call
argument_list|(
name|fp
argument_list|,
operator|(
name|int
operator|)
name|e
operator|->
name|opcode
argument_list|,
name|e
operator|->
name|vtype
argument_list|,
name|e
operator|->
name|vleng
argument_list|,
name|e
operator|->
name|leftp
argument_list|,
name|e
operator|->
name|rightp
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPCOMMA_ARG
case|:
name|doin_setbound
operator|=
literal|1
expr_stmt|;
name|nice_printf
argument_list|(
name|fp
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|expr_out
argument_list|(
name|fp
argument_list|,
name|e
operator|->
name|leftp
argument_list|)
expr_stmt|;
name|nice_printf
argument_list|(
name|fp
argument_list|,
literal|",&"
argument_list|)
expr_stmt|;
name|doin_setbound
operator|=
literal|0
expr_stmt|;
name|expr_out
argument_list|(
name|fp
argument_list|,
name|e
operator|->
name|rightp
argument_list|)
expr_stmt|;
name|nice_printf
argument_list|(
name|fp
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPADDR
case|:
default|default:
name|nice_printf
argument_list|(
name|fp
argument_list|,
literal|"Sorry, can't format OPCODE '%d'"
argument_list|,
name|e
operator|->
name|opcode
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* else */
block|}
end_function

begin_comment
comment|/* output_binary */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|out_call
parameter_list|(
name|outfile
parameter_list|,
name|op
parameter_list|,
name|ftype
parameter_list|,
name|len
parameter_list|,
name|name
parameter_list|,
name|args
parameter_list|)
name|FILE
modifier|*
name|outfile
decl_stmt|;
name|int
name|op
decl_stmt|;
name|int
name|ftype
decl_stmt|;
name|expptr
name|len
decl_stmt|;
name|expptr
name|name
decl_stmt|;
name|expptr
name|args
decl_stmt|;
else|#
directive|else
function|out_call
parameter_list|(
name|FILE
modifier|*
name|outfile
parameter_list|,
name|int
name|op
parameter_list|,
name|int
name|ftype
parameter_list|,
name|expptr
name|len
parameter_list|,
name|expptr
name|name
parameter_list|,
name|expptr
name|args
parameter_list|)
endif|#
directive|endif
block|{
name|chainp
name|arglist
decl_stmt|;
comment|/* Pointer to any actual arguments */
name|chainp
name|cp
decl_stmt|;
comment|/* Iterator over argument lists */
name|Addrp
name|ret_val
init|=
operator|(
name|Addrp
operator|)
name|NULL
decl_stmt|;
comment|/* Function return value buffer, if any is 				   required */
name|int
name|byvalue
decl_stmt|;
comment|/* True iff we're calling a C library 				   routine */
name|int
name|done_once
decl_stmt|;
comment|/* Used for writing commas to   outfile   */
name|int
name|narg
decl_stmt|,
name|t
decl_stmt|;
specifier|register
name|expptr
name|q
decl_stmt|;
name|long
name|L
decl_stmt|;
name|Argtypes
modifier|*
name|at
decl_stmt|;
name|Atype
modifier|*
name|A
decl_stmt|,
modifier|*
name|Ac
decl_stmt|;
name|Namep
name|np
decl_stmt|;
specifier|extern
name|int
name|forcereal
decl_stmt|;
comment|/* Don't use addresses if we're calling a C function */
name|byvalue
operator|=
name|op
operator|==
name|OPCCALL
expr_stmt|;
if|if
condition|(
name|args
condition|)
name|arglist
operator|=
name|args
operator|->
name|listblock
operator|.
name|listp
expr_stmt|;
else|else
name|arglist
operator|=
name|CHNULL
expr_stmt|;
comment|/* If this is a CHARACTER function, the first argument is the result */
if|if
condition|(
name|ftype
operator|==
name|TYCHAR
condition|)
if|if
condition|(
name|ISICON
argument_list|(
name|len
argument_list|)
condition|)
block|{
name|ret_val
operator|=
call|(
name|Addrp
call|)
argument_list|(
name|arglist
operator|->
name|datap
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|arglist
operator|->
name|nextp
expr_stmt|;
block|}
else|else
block|{
name|err
argument_list|(
literal|"adjustable character function"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* else */
comment|/* If this is a COMPLEX function, the first argument is the result */
elseif|else
if|if
condition|(
name|ISCOMPLEX
argument_list|(
name|ftype
argument_list|)
condition|)
block|{
name|ret_val
operator|=
call|(
name|Addrp
call|)
argument_list|(
name|arglist
operator|->
name|datap
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|arglist
operator|->
name|nextp
expr_stmt|;
block|}
comment|/* if ISCOMPLEX */
comment|/* prepare to cast procedure parameters -- set A if we know how */
name|np
operator|=
name|name
operator|->
name|tag
operator|==
name|TEXPR
operator|&&
name|name
operator|->
name|exprblock
operator|.
name|opcode
operator|==
name|OPWHATSIN
condition|?
operator|(
name|Namep
operator|)
name|name
operator|->
name|exprblock
operator|.
name|leftp
else|:
operator|(
name|Namep
operator|)
name|name
expr_stmt|;
name|A
operator|=
name|Ac
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|tag
operator|==
name|TNAME
operator|&&
operator|(
name|at
operator|=
name|np
operator|->
name|arginfo
operator|)
condition|)
block|{
if|if
condition|(
name|at
operator|->
name|nargs
operator|>
literal|0
condition|)
name|A
operator|=
name|at
operator|->
name|atypes
expr_stmt|;
if|if
condition|(
name|Ansi
operator|&&
operator|(
name|at
operator|->
name|defined
operator|||
name|at
operator|->
name|nargs
operator|>
literal|0
operator|)
condition|)
name|Ac
operator|=
name|at
operator|->
name|atypes
expr_stmt|;
block|}
comment|/* Now we can actually start to write out the function invocation */
if|if
condition|(
name|ftype
operator|==
name|TYREAL
operator|&&
name|forcereal
condition|)
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"(real)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|->
name|tag
operator|==
name|TEXPR
operator|&&
name|name
operator|->
name|exprblock
operator|.
name|opcode
operator|==
name|OPWHATSIN
condition|)
block|{
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|expr_out
argument_list|(
name|outfile
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
else|else
name|expr_out
argument_list|(
name|outfile
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
if|if
condition|(
name|ISCOMPLEX
argument_list|(
name|ftype
argument_list|)
condition|)
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"&"
argument_list|)
expr_stmt|;
name|expr_out
argument_list|(
name|outfile
argument_list|,
operator|(
name|expptr
operator|)
name|ret_val
argument_list|)
expr_stmt|;
if|if
condition|(
name|Ac
condition|)
name|Ac
operator|++
expr_stmt|;
comment|/* The length of the result of a character function is the second argument */
comment|/* It should be in place from putcall(), so we won't touch it explicitly */
block|}
comment|/* if ret_val */
name|done_once
operator|=
name|ret_val
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
comment|/* Now run through the named arguments */
name|narg
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|arglist
init|;
name|cp
condition|;
name|cp
operator|=
name|cp
operator|->
name|nextp
operator|,
name|done_once
operator|=
name|TRUE
control|)
block|{
if|if
condition|(
name|done_once
condition|)
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|narg
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|q
operator|=
operator|(
name|expptr
operator|)
name|cp
operator|->
name|datap
operator|)
condition|)
continue|continue;
if|if
condition|(
name|q
operator|->
name|tag
operator|==
name|TADDR
condition|)
block|{
if|if
condition|(
name|q
operator|->
name|addrblock
operator|.
name|vtype
operator|>
name|TYERROR
condition|)
block|{
comment|/* I/O block */
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"&%s"
argument_list|,
name|q
operator|->
name|addrblock
operator|.
name|user
operator|.
name|ident
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|byvalue
operator|&&
name|q
operator|->
name|addrblock
operator|.
name|isarray
operator|&&
name|q
operator|->
name|addrblock
operator|.
name|vtype
operator|!=
name|TYCHAR
operator|&&
name|q
operator|->
name|addrblock
operator|.
name|memoffset
operator|->
name|tag
operator|==
name|TCONST
condition|)
block|{
comment|/* check for 0 offset -- after */
comment|/* correcting for equivalence. */
name|L
operator|=
name|q
operator|->
name|addrblock
operator|.
name|memoffset
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
expr_stmt|;
if|if
condition|(
name|ONEOF
argument_list|(
name|q
operator|->
name|addrblock
operator|.
name|vstg
argument_list|,
name|M
argument_list|(
name|STGCOMMON
argument_list|)
operator||
name|M
argument_list|(
name|STGEQUIV
argument_list|)
argument_list|)
operator|&&
name|q
operator|->
name|addrblock
operator|.
name|uname_tag
operator|==
name|UNAM_NAME
condition|)
name|L
operator|-=
name|q
operator|->
name|addrblock
operator|.
name|user
operator|.
name|name
operator|->
name|voffset
expr_stmt|;
if|if
condition|(
name|L
condition|)
goto|goto
name|skip_deref
goto|;
if|if
condition|(
name|Ac
operator|&&
name|narg
operator|<
name|at
operator|->
name|dnargs
operator|&&
name|q
operator|->
name|headblock
operator|.
name|vtype
operator|!=
operator|(
name|t
operator|=
name|Ac
index|[
name|narg
index|]
operator|.
name|type
operator|)
operator|&&
name|t
operator|>
name|TYADDR
operator|&&
name|t
operator|<
name|TYSUBR
condition|)
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"(%s*)"
argument_list|,
name|typename
index|[
name|t
index|]
argument_list|)
expr_stmt|;
comment|/*&x[0] == x */
comment|/* This also prevents&sizeof(doublereal)[0] */
switch|switch
condition|(
name|q
operator|->
name|addrblock
operator|.
name|uname_tag
condition|)
block|{
case|case
name|UNAM_NAME
case|:
name|out_name
argument_list|(
name|outfile
argument_list|,
name|q
operator|->
name|addrblock
operator|.
name|user
operator|.
name|name
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|UNAM_IDENT
case|:
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"%s"
argument_list|,
name|q
operator|->
name|addrblock
operator|.
name|user
operator|.
name|ident
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|UNAM_CHARP
case|:
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"%s"
argument_list|,
name|q
operator|->
name|addrblock
operator|.
name|user
operator|.
name|Charp
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|UNAM_EXTERN
case|:
name|extern_out
argument_list|(
name|outfile
argument_list|,
operator|&
name|extsymtab
index|[
name|q
operator|->
name|addrblock
operator|.
name|memno
index|]
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
block|}
comment|/* Skip over the dereferencing operator generated only for the    intermediate file */
name|skip_deref
label|:
if|if
condition|(
name|q
operator|->
name|tag
operator|==
name|TEXPR
operator|&&
name|q
operator|->
name|exprblock
operator|.
name|opcode
operator|==
name|OPWHATSIN
condition|)
name|q
operator|=
name|q
operator|->
name|exprblock
operator|.
name|leftp
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|headblock
operator|.
name|vclass
operator|==
name|CLPROC
condition|)
block|{
if|if
condition|(
name|Castargs
operator|&&
operator|(
name|q
operator|->
name|tag
operator|!=
name|TNAME
operator|||
name|q
operator|->
name|nameblock
operator|.
name|vprocclass
operator|!=
name|PTHISPROC
operator|)
operator|&&
operator|(
name|q
operator|->
name|tag
operator|!=
name|TADDR
operator|||
name|q
operator|->
name|addrblock
operator|.
name|uname_tag
operator|!=
name|UNAM_NAME
operator|||
name|q
operator|->
name|addrblock
operator|.
name|user
operator|.
name|name
operator|->
name|vprocclass
operator|!=
name|PTHISPROC
operator|)
condition|)
block|{
if|if
condition|(
name|A
operator|&&
operator|(
name|t
operator|=
name|A
index|[
name|narg
index|]
operator|.
name|type
operator|)
operator|>=
literal|200
condition|)
name|t
operator|%=
literal|100
expr_stmt|;
else|else
block|{
name|t
operator|=
name|q
operator|->
name|headblock
operator|.
name|vtype
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|tag
operator|==
name|TNAME
operator|&&
name|q
operator|->
name|nameblock
operator|.
name|vimpltype
condition|)
name|t
operator|=
name|TYUNKNOWN
expr_stmt|;
block|}
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"(%s)"
argument_list|,
name|usedcasts
index|[
name|t
index|]
operator|=
name|casttypes
index|[
name|t
index|]
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|Ac
operator|&&
name|narg
operator|<
name|at
operator|->
name|dnargs
operator|&&
name|q
operator|->
name|headblock
operator|.
name|vtype
operator|!=
operator|(
name|t
operator|=
name|Ac
index|[
name|narg
index|]
operator|.
name|type
operator|)
operator|&&
name|t
operator|>
name|TYADDR
operator|&&
name|t
operator|<
name|TYSUBR
condition|)
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"(%s*)"
argument_list|,
name|typename
index|[
name|t
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|q
operator|->
name|tag
operator|==
name|TADDR
operator|||
name|q
operator|->
name|tag
operator|==
name|TNAME
operator|)
operator|&&
operator|(
name|byvalue
operator|||
name|q
operator|->
name|headblock
operator|.
name|vstg
operator|!=
name|STGREG
operator|)
condition|)
block|{
if|if
condition|(
name|q
operator|->
name|headblock
operator|.
name|vtype
operator|!=
name|TYCHAR
condition|)
if|if
condition|(
name|byvalue
condition|)
block|{
if|if
condition|(
name|q
operator|->
name|tag
operator|==
name|TADDR
operator|&&
name|q
operator|->
name|addrblock
operator|.
name|uname_tag
operator|==
name|UNAM_NAME
operator|&&
operator|!
name|q
operator|->
name|addrblock
operator|.
name|user
operator|.
name|name
operator|->
name|vdim
operator|&&
name|oneof_stg
argument_list|(
name|q
operator|->
name|addrblock
operator|.
name|user
operator|.
name|name
argument_list|,
name|q
operator|->
name|addrblock
operator|.
name|vstg
argument_list|,
name|M
argument_list|(
name|STGARG
argument_list|)
operator||
name|M
argument_list|(
name|STGEQUIV
argument_list|)
argument_list|)
operator|&&
operator|!
name|ISCOMPLEX
argument_list|(
name|q
operator|->
name|addrblock
operator|.
name|user
operator|.
name|name
operator|->
name|vtype
argument_list|)
condition|)
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"*"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|q
operator|->
name|tag
operator|==
name|TNAME
operator|&&
name|oneof_stg
argument_list|(
operator|&
name|q
operator|->
name|nameblock
argument_list|,
name|q
operator|->
name|nameblock
operator|.
name|vstg
argument_list|,
name|M
argument_list|(
name|STGARG
argument_list|)
operator||
name|M
argument_list|(
name|STGEQUIV
argument_list|)
argument_list|)
operator|&&
operator|!
operator|(
name|q
operator|->
name|nameblock
operator|.
name|vdim
operator|)
condition|)
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"*"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|expptr
name|memoffset
decl_stmt|;
if|if
condition|(
name|q
operator|->
name|tag
operator|==
name|TADDR
operator|&&
operator|(
operator|!
name|ONEOF
argument_list|(
name|q
operator|->
name|addrblock
operator|.
name|vstg
argument_list|,
name|M
argument_list|(
name|STGEXT
argument_list|)
operator||
name|M
argument_list|(
name|STGLENG
argument_list|)
argument_list|)
operator|&&
operator|(
name|ONEOF
argument_list|(
name|q
operator|->
name|addrblock
operator|.
name|vstg
argument_list|,
name|M
argument_list|(
name|STGCOMMON
argument_list|)
operator||
name|M
argument_list|(
name|STGEQUIV
argument_list|)
operator||
name|M
argument_list|(
name|STGMEMNO
argument_list|)
argument_list|)
operator|||
operator|(
operator|(
name|memoffset
operator|=
name|q
operator|->
name|addrblock
operator|.
name|memoffset
operator|)
operator|&&
operator|(
operator|!
name|ISICON
argument_list|(
name|memoffset
argument_list|)
operator|||
name|memoffset
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
operator|)
operator|)
operator|)
operator|||
name|ONEOF
argument_list|(
name|q
operator|->
name|addrblock
operator|.
name|vstg
argument_list|,
name|M
argument_list|(
name|STGINIT
argument_list|)
operator||
name|M
argument_list|(
name|STGAUTO
argument_list|)
operator||
name|M
argument_list|(
name|STGBSS
argument_list|)
argument_list|)
operator|&&
operator|!
name|q
operator|->
name|addrblock
operator|.
name|isarray
operator|)
condition|)
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"&"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|q
operator|->
name|tag
operator|==
name|TNAME
operator|&&
operator|!
name|oneof_stg
argument_list|(
operator|&
name|q
operator|->
name|nameblock
argument_list|,
name|q
operator|->
name|nameblock
operator|.
name|vstg
argument_list|,
name|M
argument_list|(
name|STGARG
argument_list|)
operator||
name|M
argument_list|(
name|STGEXT
argument_list|)
operator||
name|M
argument_list|(
name|STGEQUIV
argument_list|)
argument_list|)
condition|)
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"&"
argument_list|)
expr_stmt|;
block|}
comment|/* else */
name|expr_out
argument_list|(
name|outfile
argument_list|,
name|q
argument_list|)
expr_stmt|;
block|}
comment|/* if q -> tag == TADDR || q -> tag == TNAME */
comment|/* Might be a Constant expression, e.g. string length, character constants */
elseif|else
if|if
condition|(
name|q
operator|->
name|tag
operator|==
name|TCONST
condition|)
block|{
if|if
condition|(
name|tyioint
operator|==
name|TYLONG
condition|)
name|Longfmt
operator|=
literal|"%ldL"
expr_stmt|;
name|out_const
argument_list|(
name|outfile
argument_list|,
operator|&
name|q
operator|->
name|constblock
argument_list|)
expr_stmt|;
name|Longfmt
operator|=
literal|"%ld"
expr_stmt|;
block|}
comment|/* Must be some other kind of expression, or register var, or constant.    In particular, this is likely to be a temporary variable assignment    which was generated in p1put_call */
elseif|else
if|if
condition|(
operator|!
name|ISCOMPLEX
argument_list|(
name|q
operator|->
name|headblock
operator|.
name|vtype
argument_list|)
operator|&&
operator|!
name|ISCHAR
argument_list|(
name|q
argument_list|)
condition|)
block|{
name|int
name|use_paren
init|=
name|q
operator|->
name|tag
operator|==
name|TEXPR
operator|&&
name|op_precedence
argument_list|(
name|q
operator|->
name|exprblock
operator|.
name|opcode
argument_list|)
operator|<=
name|op_precedence
argument_list|(
name|OPCOMMA
argument_list|)
decl_stmt|;
if|if
condition|(
name|use_paren
condition|)
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|expr_out
argument_list|(
name|outfile
argument_list|,
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_paren
condition|)
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
comment|/* if !ISCOMPLEX */
else|else
name|err
argument_list|(
literal|"out_call:  unknown parameter"
argument_list|)
expr_stmt|;
block|}
comment|/* for (cp = arglist */
if|if
condition|(
name|arglist
condition|)
name|frchain
argument_list|(
operator|&
name|arglist
argument_list|)
expr_stmt|;
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* out_call */
end_comment

begin_function
name|char
modifier|*
ifdef|#
directive|ifdef
name|KR_headers
name|flconst
parameter_list|(
name|buf
parameter_list|,
name|x
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
name|char
modifier|*
name|x
decl_stmt|;
else|#
directive|else
function|flconst
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|char
modifier|*
name|x
parameter_list|)
endif|#
directive|endif
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
name|fl_fmt_string
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_function
name|char
modifier|*
ifdef|#
directive|ifdef
name|KR_headers
name|dtos
parameter_list|(
name|x
parameter_list|)
name|double
name|x
decl_stmt|;
else|#
directive|else
function|dtos
parameter_list|(
name|double
name|x
parameter_list|)
endif|#
directive|endif
block|{
specifier|static
name|char
name|buf
index|[
literal|64
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|USE_DTOA
name|g_fmt
argument_list|(
name|buf
argument_list|,
name|x
argument_list|)
expr_stmt|;
else|#
directive|else
name|sprintf
argument_list|(
name|buf
argument_list|,
name|db_fmt_string
argument_list|,
name|x
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|strcpy
argument_list|(
name|mem
argument_list|(
name|strlen
argument_list|(
name|buf
argument_list|)
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|buf
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
name|char
name|tr_tab
index|[
name|Table_size
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* out_init -- Initialize the data structures used by the routines in    output.c.  These structures include the output format to be used for    Float, Double, Complex, and Double Complex constants. */
end_comment

begin_function
name|void
name|out_init
parameter_list|(
name|Void
parameter_list|)
block|{
specifier|extern
name|int
name|tab_size
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
name|s
operator|=
literal|"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_+-."
expr_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
name|tr_tab
index|[
operator|*
name|s
operator|++
index|]
operator|=
literal|3
expr_stmt|;
name|tr_tab
index|[
literal|'>'
index|]
operator|=
literal|1
expr_stmt|;
name|opeqable
index|[
name|OPPLUS
index|]
operator|=
literal|1
expr_stmt|;
name|opeqable
index|[
name|OPMINUS
index|]
operator|=
literal|1
expr_stmt|;
name|opeqable
index|[
name|OPSTAR
index|]
operator|=
literal|1
expr_stmt|;
name|opeqable
index|[
name|OPSLASH
index|]
operator|=
literal|1
expr_stmt|;
name|opeqable
index|[
name|OPMOD
index|]
operator|=
literal|1
expr_stmt|;
name|opeqable
index|[
name|OPLSHIFT
index|]
operator|=
literal|1
expr_stmt|;
name|opeqable
index|[
name|OPBITAND
index|]
operator|=
literal|1
expr_stmt|;
name|opeqable
index|[
name|OPBITXOR
index|]
operator|=
literal|1
expr_stmt|;
name|opeqable
index|[
name|OPBITOR
index|]
operator|=
literal|1
expr_stmt|;
comment|/* Set the output format for both types of floating point constants */
if|if
condition|(
name|fl_fmt_string
operator|==
name|NULL
operator|||
operator|*
name|fl_fmt_string
operator|==
literal|'\0'
condition|)
name|fl_fmt_string
operator|=
name|Ansi
operator|==
literal|1
condition|?
literal|"%sf"
else|:
literal|"(float)%s"
expr_stmt|;
if|if
condition|(
name|db_fmt_string
operator|==
name|NULL
operator|||
operator|*
name|db_fmt_string
operator|==
literal|'\0'
condition|)
name|db_fmt_string
operator|=
literal|"%.17g"
expr_stmt|;
comment|/* Set the output format for both types of complex constants.  They will    have string parameters rather than float or double so that the decimal    point may be added to the strings generated by the {db,fl}_fmt_string    formats above */
if|if
condition|(
name|cm_fmt_string
operator|==
name|NULL
operator|||
operator|*
name|cm_fmt_string
operator|==
literal|'\0'
condition|)
block|{
name|cm_fmt_string
operator|=
literal|"{%s,%s}"
expr_stmt|;
block|}
comment|/* if cm_fmt_string == NULL */
if|if
condition|(
name|dcm_fmt_string
operator|==
name|NULL
operator|||
operator|*
name|dcm_fmt_string
operator|==
literal|'\0'
condition|)
block|{
name|dcm_fmt_string
operator|=
literal|"{%s,%s}"
expr_stmt|;
block|}
comment|/* if dcm_fmt_string == NULL */
name|tab_size
operator|=
literal|4
expr_stmt|;
block|}
end_function

begin_comment
comment|/* out_init */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|extern_out
parameter_list|(
name|fp
parameter_list|,
name|extsym
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
name|Extsym
modifier|*
name|extsym
decl_stmt|;
else|#
directive|else
function|extern_out
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|Extsym
modifier|*
name|extsym
parameter_list|)
endif|#
directive|endif
block|{
if|if
condition|(
name|extsym
operator|==
operator|(
name|Extsym
operator|*
operator|)
name|NULL
condition|)
return|return;
name|nice_printf
argument_list|(
name|fp
argument_list|,
literal|"%s"
argument_list|,
name|extsym
operator|->
name|cextname
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* extern_out */
end_comment

begin_function
specifier|static
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|output_list
parameter_list|(
name|fp
parameter_list|,
name|listp
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
name|struct
name|Listblock
modifier|*
name|listp
decl_stmt|;
else|#
directive|else
function|output_list
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|struct
name|Listblock
modifier|*
name|listp
parameter_list|)
endif|#
directive|endif
block|{
name|int
name|did_one
init|=
literal|0
decl_stmt|;
name|chainp
name|elts
decl_stmt|;
name|nice_printf
argument_list|(
name|fp
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
if|if
condition|(
name|listp
condition|)
for|for
control|(
name|elts
operator|=
name|listp
operator|->
name|listp
init|;
name|elts
condition|;
name|elts
operator|=
name|elts
operator|->
name|nextp
control|)
block|{
if|if
condition|(
name|elts
operator|->
name|datap
condition|)
block|{
if|if
condition|(
name|did_one
condition|)
name|nice_printf
argument_list|(
name|fp
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|expr_out
argument_list|(
name|fp
argument_list|,
operator|(
name|expptr
operator|)
name|elts
operator|->
name|datap
argument_list|)
expr_stmt|;
name|did_one
operator|=
literal|1
expr_stmt|;
block|}
comment|/* if elts -> datap */
block|}
comment|/* for elts */
name|nice_printf
argument_list|(
name|fp
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* output_list */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|out_asgoto
parameter_list|(
name|outfile
parameter_list|,
name|expr
parameter_list|)
name|FILE
modifier|*
name|outfile
decl_stmt|;
name|expptr
name|expr
decl_stmt|;
else|#
directive|else
function|out_asgoto
parameter_list|(
name|FILE
modifier|*
name|outfile
parameter_list|,
name|expptr
name|expr
parameter_list|)
endif|#
directive|endif
block|{
name|chainp
name|value
decl_stmt|;
name|Namep
name|namep
decl_stmt|;
name|int
name|k
decl_stmt|;
if|if
condition|(
name|expr
operator|==
operator|(
name|expptr
operator|)
name|NULL
condition|)
block|{
name|err
argument_list|(
literal|"out_asgoto:  NULL variable expr"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* if expr */
name|nice_printf
argument_list|(
name|outfile
argument_list|,
name|Ansi
condition|?
literal|"switch ("
else|:
literal|"switch ((int)"
argument_list|)
expr_stmt|;
comment|/*)*/
name|expr_out
argument_list|(
name|outfile
argument_list|,
name|expr
argument_list|)
expr_stmt|;
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|") {\n"
argument_list|)
expr_stmt|;
name|next_tab
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
comment|/* The initial addrp value will be stored as a namep pointer */
switch|switch
condition|(
name|expr
operator|->
name|tag
condition|)
block|{
case|case
name|TNAME
case|:
comment|/* local variable */
name|namep
operator|=
operator|&
name|expr
operator|->
name|nameblock
expr_stmt|;
break|break;
case|case
name|TEXPR
case|:
if|if
condition|(
name|expr
operator|->
name|exprblock
operator|.
name|opcode
operator|==
name|OPWHATSIN
operator|&&
name|expr
operator|->
name|exprblock
operator|.
name|leftp
operator|->
name|tag
operator|==
name|TNAME
condition|)
comment|/* argument */
name|namep
operator|=
operator|&
name|expr
operator|->
name|exprblock
operator|.
name|leftp
operator|->
name|nameblock
expr_stmt|;
else|else
goto|goto
name|bad
goto|;
break|break;
case|case
name|TADDR
case|:
if|if
condition|(
name|expr
operator|->
name|addrblock
operator|.
name|uname_tag
operator|==
name|UNAM_NAME
condition|)
block|{
comment|/* initialized local variable */
name|namep
operator|=
name|expr
operator|->
name|addrblock
operator|.
name|user
operator|.
name|name
expr_stmt|;
break|break;
block|}
default|default:
name|bad
label|:
name|err
argument_list|(
literal|"out_asgoto:  bad expr"
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|k
operator|=
literal|0
operator|,
name|value
operator|=
name|namep
operator|->
name|varxptr
operator|.
name|assigned_values
init|;
name|value
condition|;
name|value
operator|=
name|value
operator|->
name|nextp
operator|,
name|k
operator|++
control|)
block|{
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"case %d: goto %s;\n"
argument_list|,
name|k
argument_list|,
name|user_label
argument_list|(
operator|(
name|long
operator|)
name|value
operator|->
name|datap
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* for value */
name|prev_tab
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"}\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* out_asgoto */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|out_if
parameter_list|(
name|outfile
parameter_list|,
name|expr
parameter_list|)
name|FILE
modifier|*
name|outfile
decl_stmt|;
name|expptr
name|expr
decl_stmt|;
else|#
directive|else
function|out_if
parameter_list|(
name|FILE
modifier|*
name|outfile
parameter_list|,
name|expptr
name|expr
parameter_list|)
endif|#
directive|endif
block|{
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"if ("
argument_list|)
expr_stmt|;
name|expr_out
argument_list|(
name|outfile
argument_list|,
name|expr
argument_list|)
expr_stmt|;
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|") {\n"
argument_list|)
expr_stmt|;
name|next_tab
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* out_if */
end_comment

begin_function
specifier|static
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|output_rbrace
parameter_list|(
name|outfile
parameter_list|,
name|s
parameter_list|)
name|FILE
modifier|*
name|outfile
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
else|#
directive|else
function|output_rbrace
parameter_list|(
name|FILE
modifier|*
name|outfile
parameter_list|,
name|char
modifier|*
name|s
parameter_list|)
endif|#
directive|endif
block|{
specifier|extern
name|int
name|last_was_label
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|last_was_label
condition|)
block|{
name|last_was_label
operator|=
literal|0
expr_stmt|;
name|fmt
operator|=
literal|";%s"
expr_stmt|;
block|}
else|else
name|fmt
operator|=
literal|"%s"
expr_stmt|;
name|nice_printf
argument_list|(
name|outfile
argument_list|,
name|fmt
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|out_else
parameter_list|(
name|outfile
parameter_list|)
name|FILE
modifier|*
name|outfile
decl_stmt|;
else|#
directive|else
function|out_else
parameter_list|(
name|FILE
modifier|*
name|outfile
parameter_list|)
endif|#
directive|endif
block|{
name|prev_tab
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
name|output_rbrace
argument_list|(
name|outfile
argument_list|,
literal|"} else {\n"
argument_list|)
expr_stmt|;
name|next_tab
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* out_else */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|elif_out
parameter_list|(
name|outfile
parameter_list|,
name|expr
parameter_list|)
name|FILE
modifier|*
name|outfile
decl_stmt|;
name|expptr
name|expr
decl_stmt|;
else|#
directive|else
function|elif_out
parameter_list|(
name|FILE
modifier|*
name|outfile
parameter_list|,
name|expptr
name|expr
parameter_list|)
endif|#
directive|endif
block|{
name|prev_tab
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
name|output_rbrace
argument_list|(
name|outfile
argument_list|,
literal|"} else "
argument_list|)
expr_stmt|;
name|out_if
argument_list|(
name|outfile
argument_list|,
name|expr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* elif_out */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|endif_out
parameter_list|(
name|outfile
parameter_list|)
name|FILE
modifier|*
name|outfile
decl_stmt|;
else|#
directive|else
function|endif_out
parameter_list|(
name|FILE
modifier|*
name|outfile
parameter_list|)
endif|#
directive|endif
block|{
name|prev_tab
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
name|output_rbrace
argument_list|(
name|outfile
argument_list|,
literal|"}\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* endif_out */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|end_else_out
parameter_list|(
name|outfile
parameter_list|)
name|FILE
modifier|*
name|outfile
decl_stmt|;
else|#
directive|else
function|end_else_out
parameter_list|(
name|FILE
modifier|*
name|outfile
parameter_list|)
endif|#
directive|endif
block|{
name|prev_tab
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
name|output_rbrace
argument_list|(
name|outfile
argument_list|,
literal|"}\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* end_else_out */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|compgoto_out
parameter_list|(
name|outfile
parameter_list|,
name|index
parameter_list|,
name|labels
parameter_list|)
name|FILE
modifier|*
name|outfile
decl_stmt|;
name|expptr
name|index
decl_stmt|;
name|expptr
name|labels
decl_stmt|;
else|#
directive|else
function|compgoto_out
parameter_list|(
name|FILE
modifier|*
name|outfile
parameter_list|,
name|expptr
name|index
parameter_list|,
name|expptr
name|labels
parameter_list|)
endif|#
directive|endif
block|{
name|char
modifier|*
name|s1
decl_stmt|,
modifier|*
name|s2
decl_stmt|;
if|if
condition|(
name|index
operator|==
name|ENULL
condition|)
name|err
argument_list|(
literal|"compgoto_out:  null index for computed goto"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|labels
operator|&&
name|labels
operator|->
name|tag
operator|!=
name|TLIST
condition|)
name|erri
argument_list|(
literal|"compgoto_out:  expected label list, got tag '%d'"
argument_list|,
name|labels
operator|->
name|tag
argument_list|)
expr_stmt|;
else|else
block|{
name|chainp
name|elts
decl_stmt|;
name|int
name|i
init|=
literal|1
decl_stmt|;
name|s2
operator|=
comment|/*(*/
literal|") {\n"
expr_stmt|;
comment|/*}*/
if|if
condition|(
name|Ansi
condition|)
name|s1
operator|=
literal|"switch ("
expr_stmt|;
comment|/*)*/
elseif|else
if|if
condition|(
name|index
operator|->
name|tag
operator|==
name|TNAME
operator|||
name|index
operator|->
name|tag
operator|==
name|TEXPR
operator|&&
name|index
operator|->
name|exprblock
operator|.
name|opcode
operator|==
name|OPWHATSIN
condition|)
name|s1
operator|=
literal|"switch ((int)"
expr_stmt|;
comment|/*)*/
else|else
block|{
name|s1
operator|=
literal|"switch ((int)("
expr_stmt|;
name|s2
operator|=
literal|")) {\n"
expr_stmt|;
comment|/*}*/
block|}
name|nice_printf
argument_list|(
name|outfile
argument_list|,
name|s1
argument_list|)
expr_stmt|;
name|expr_out
argument_list|(
name|outfile
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|nice_printf
argument_list|(
name|outfile
argument_list|,
name|s2
argument_list|)
expr_stmt|;
name|next_tab
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
for|for
control|(
name|elts
operator|=
name|labels
operator|->
name|listblock
operator|.
name|listp
init|;
name|elts
condition|;
name|elts
operator|=
name|elts
operator|->
name|nextp
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
name|elts
operator|->
name|datap
condition|)
block|{
if|if
condition|(
name|ISICON
argument_list|(
operator|(
call|(
name|expptr
call|)
argument_list|(
name|elts
operator|->
name|datap
argument_list|)
operator|)
argument_list|)
condition|)
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"case %d:  goto %s;\n"
argument_list|,
name|i
argument_list|,
name|user_label
argument_list|(
operator|(
call|(
name|expptr
call|)
argument_list|(
name|elts
operator|->
name|datap
argument_list|)
operator|)
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|err
argument_list|(
literal|"compgoto_out:  bad label in label list"
argument_list|)
expr_stmt|;
block|}
comment|/* if (elts -> datap) */
block|}
comment|/* for elts */
name|prev_tab
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
name|nice_printf
argument_list|(
name|outfile
argument_list|,
comment|/*{*/
literal|"}\n"
argument_list|)
expr_stmt|;
block|}
comment|/* else */
block|}
end_function

begin_comment
comment|/* compgoto_out */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|out_for
parameter_list|(
name|outfile
parameter_list|,
name|init
parameter_list|,
name|test
parameter_list|,
name|inc
parameter_list|)
name|FILE
modifier|*
name|outfile
decl_stmt|;
name|expptr
name|init
decl_stmt|;
name|expptr
name|test
decl_stmt|;
name|expptr
name|inc
decl_stmt|;
else|#
directive|else
function|out_for
parameter_list|(
name|FILE
modifier|*
name|outfile
parameter_list|,
name|expptr
name|init
parameter_list|,
name|expptr
name|test
parameter_list|,
name|expptr
name|inc
parameter_list|)
endif|#
directive|endif
block|{
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"for ("
argument_list|)
expr_stmt|;
name|expr_out
argument_list|(
name|outfile
argument_list|,
name|init
argument_list|)
expr_stmt|;
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"; "
argument_list|)
expr_stmt|;
name|expr_out
argument_list|(
name|outfile
argument_list|,
name|test
argument_list|)
expr_stmt|;
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"; "
argument_list|)
expr_stmt|;
name|expr_out
argument_list|(
name|outfile
argument_list|,
name|inc
argument_list|)
expr_stmt|;
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|") {\n"
argument_list|)
expr_stmt|;
name|next_tab
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* out_for */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|out_end_for
parameter_list|(
name|outfile
parameter_list|)
name|FILE
modifier|*
name|outfile
decl_stmt|;
else|#
directive|else
function|out_end_for
parameter_list|(
name|FILE
modifier|*
name|outfile
parameter_list|)
endif|#
directive|endif
block|{
name|prev_tab
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"}\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* out_end_for */
end_comment

end_unit

