begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**************************************************************** Copyright 1990, 1991, 1994 by AT&T, Lucent Technologies and Bellcore.  Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that the copyright notice and this permission notice and warranty disclaimer appear in supporting documentation, and that the names of AT&T, Bell Laboratories, Lucent or Bellcore or any of their entities not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  AT&T, Lucent and Bellcore disclaim all warranties with regard to this software, including all implied warranties of merchantability and fitness.  In no event shall AT&T, Lucent or Bellcore be liable for any special, indirect or consequential damages or any damages whatsoever resulting from loss of use, data or profits, whether in an action of contract, negligence or other tortious action, arising out of or in connection with the use or performance of this software. ****************************************************************/
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"iob.h"
end_include

begin_define
define|#
directive|define
name|MEMBSIZE
value|32000
end_define

begin_define
define|#
directive|define
name|GMEMBSIZE
value|16000
end_define

begin_function
name|char
modifier|*
ifdef|#
directive|ifdef
name|KR_headers
name|gmem
parameter_list|(
name|n
parameter_list|,
name|round
parameter_list|)
name|int
name|n
decl_stmt|;
name|int
name|round
decl_stmt|;
else|#
directive|else
function|gmem
parameter_list|(
name|int
name|n
parameter_list|,
name|int
name|round
parameter_list|)
endif|#
directive|endif
block|{
specifier|static
name|char
modifier|*
name|last
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|char
modifier|*
name|rv
decl_stmt|;
if|if
condition|(
name|round
condition|)
ifdef|#
directive|ifdef
name|CRAY
if|if
condition|(
operator|(
name|long
operator|)
name|next
operator|&
literal|0xe000000000000000
condition|)
name|next
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
operator|(
operator|(
name|long
operator|)
name|next
operator|&
literal|0x1fffffffffffffff
operator|)
operator|+
literal|1
operator|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|MSDOS
if|if
condition|(
operator|(
name|int
operator|)
name|next
operator|&
literal|1
condition|)
name|next
operator|++
expr_stmt|;
else|#
directive|else
name|next
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
operator|(
operator|(
name|long
operator|)
name|next
operator|+
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
operator|(
name|long
operator|)
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|rv
operator|=
name|next
expr_stmt|;
if|if
condition|(
operator|(
name|next
operator|+=
name|n
operator|)
operator|>
name|last
condition|)
block|{
name|rv
operator|=
name|Alloc
argument_list|(
name|n
operator|+
name|GMEMBSIZE
argument_list|)
expr_stmt|;
name|next
operator|=
name|rv
operator|+
name|n
expr_stmt|;
name|last
operator|=
name|next
operator|+
name|GMEMBSIZE
expr_stmt|;
block|}
return|return
name|rv
return|;
block|}
end_function

begin_struct
struct|struct
name|memblock
block|{
name|struct
name|memblock
modifier|*
name|next
decl_stmt|;
name|char
name|buf
index|[
name|MEMBSIZE
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|memblock
name|memblock
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|memblock
modifier|*
name|mem0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|memblock
modifier|*
name|curmemblock
decl_stmt|,
modifier|*
name|firstmemblock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|mem_first
decl_stmt|,
modifier|*
name|mem_next
decl_stmt|,
modifier|*
name|mem_last
decl_stmt|,
modifier|*
name|mem0_last
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|mem_init
parameter_list|(
name|Void
parameter_list|)
block|{
name|curmemblock
operator|=
name|firstmemblock
operator|=
name|mem0
operator|=
operator|(
name|memblock
operator|*
operator|)
name|Alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|memblock
argument_list|)
argument_list|)
expr_stmt|;
name|mem_first
operator|=
name|mem0
operator|->
name|buf
expr_stmt|;
name|mem_next
operator|=
name|mem0
operator|->
name|buf
expr_stmt|;
name|mem_last
operator|=
name|mem0
operator|->
name|buf
operator|+
name|MEMBSIZE
expr_stmt|;
name|mem0_last
operator|=
name|mem0
operator|->
name|buf
operator|+
name|MEMBSIZE
expr_stmt|;
name|mem0
operator|->
name|next
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|char
modifier|*
ifdef|#
directive|ifdef
name|KR_headers
name|mem
parameter_list|(
name|n
parameter_list|,
name|round
parameter_list|)
name|int
name|n
decl_stmt|;
name|int
name|round
decl_stmt|;
else|#
directive|else
function|mem
parameter_list|(
name|int
name|n
parameter_list|,
name|int
name|round
parameter_list|)
endif|#
directive|endif
block|{
name|memblock
modifier|*
name|b
decl_stmt|;
specifier|register
name|char
modifier|*
name|rv
decl_stmt|,
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|round
condition|)
ifdef|#
directive|ifdef
name|CRAY
if|if
condition|(
operator|(
name|long
operator|)
name|mem_next
operator|&
literal|0xe000000000000000
condition|)
name|mem_next
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
operator|(
operator|(
name|long
operator|)
name|mem_next
operator|&
literal|0x1fffffffffffffff
operator|)
operator|+
literal|1
operator|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|MSDOS
if|if
condition|(
operator|(
name|int
operator|)
name|mem_next
operator|&
literal|1
condition|)
name|mem_next
operator|++
expr_stmt|;
else|#
directive|else
name|mem_next
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
operator|(
operator|(
name|long
operator|)
name|mem_next
operator|+
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
operator|(
name|long
operator|)
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|rv
operator|=
name|mem_next
expr_stmt|;
name|s
operator|=
name|rv
operator|+
name|n
expr_stmt|;
if|if
condition|(
name|s
operator|>=
name|mem_last
condition|)
block|{
if|if
condition|(
name|n
operator|>
name|MEMBSIZE
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"mem(%d) failure!\n"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|b
operator|=
name|curmemblock
operator|->
name|next
operator|)
condition|)
block|{
name|b
operator|=
operator|(
name|memblock
operator|*
operator|)
name|Alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|memblock
argument_list|)
argument_list|)
expr_stmt|;
name|curmemblock
operator|->
name|next
operator|=
name|b
expr_stmt|;
name|b
operator|->
name|next
operator|=
literal|0
expr_stmt|;
block|}
name|curmemblock
operator|=
name|b
expr_stmt|;
name|rv
operator|=
name|b
operator|->
name|buf
expr_stmt|;
name|mem_last
operator|=
name|rv
operator|+
sizeof|sizeof
argument_list|(
name|b
operator|->
name|buf
argument_list|)
expr_stmt|;
name|s
operator|=
name|rv
operator|+
name|n
expr_stmt|;
block|}
name|mem_next
operator|=
name|s
expr_stmt|;
return|return
name|rv
return|;
block|}
end_function

begin_function
name|char
modifier|*
ifdef|#
directive|ifdef
name|KR_headers
name|tostring
parameter_list|(
name|s
parameter_list|,
name|n
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|n
decl_stmt|;
else|#
directive|else
function|tostring
parameter_list|(
specifier|register
name|char
modifier|*
name|s
parameter_list|,
name|int
name|n
parameter_list|)
endif|#
directive|endif
block|{
specifier|register
name|char
modifier|*
name|s1
decl_stmt|,
modifier|*
name|se
decl_stmt|,
modifier|*
modifier|*
name|sf
decl_stmt|;
name|char
modifier|*
name|rv
decl_stmt|,
modifier|*
name|s0
decl_stmt|;
specifier|register
name|int
name|k
init|=
name|n
operator|+
literal|2
decl_stmt|,
name|t
decl_stmt|;
name|sf
operator|=
name|str_fmt
expr_stmt|;
name|sf
index|[
literal|'%'
index|]
operator|=
literal|"%"
expr_stmt|;
name|s0
operator|=
name|s
expr_stmt|;
name|se
operator|=
name|s
operator|+
name|n
expr_stmt|;
for|for
control|(
init|;
name|s
operator|<
name|se
condition|;
name|s
operator|++
control|)
block|{
name|t
operator|=
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s
expr_stmt|;
name|s1
operator|=
name|sf
index|[
name|t
index|]
expr_stmt|;
while|while
condition|(
operator|*
operator|++
name|s1
condition|)
name|k
operator|++
expr_stmt|;
block|}
name|sf
index|[
literal|'%'
index|]
operator|=
literal|"%%"
expr_stmt|;
name|rv
operator|=
name|s1
operator|=
name|mem
argument_list|(
name|k
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|s1
operator|++
operator|=
literal|'"'
expr_stmt|;
for|for
control|(
name|s
operator|=
name|s0
init|;
name|s
operator|<
name|se
condition|;
name|s
operator|++
control|)
block|{
name|t
operator|=
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s
expr_stmt|;
name|sprintf
argument_list|(
name|s1
argument_list|,
name|sf
index|[
name|t
index|]
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|s1
operator|+=
name|strlen
argument_list|(
name|s1
argument_list|)
expr_stmt|;
block|}
operator|*
name|s1
operator|=
literal|0
expr_stmt|;
return|return
name|rv
return|;
block|}
end_function

begin_function
name|char
modifier|*
ifdef|#
directive|ifdef
name|KR_headers
name|cpstring
parameter_list|(
name|s
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
else|#
directive|else
function|cpstring
parameter_list|(
specifier|register
name|char
modifier|*
name|s
parameter_list|)
endif|#
directive|endif
block|{
return|return
name|strcpy
argument_list|(
name|mem
argument_list|(
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|s
argument_list|)
return|;
block|}
end_function

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|new_iob_data
parameter_list|(
name|ios
parameter_list|,
name|name
parameter_list|)
specifier|register
name|io_setup
modifier|*
name|ios
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
else|#
directive|else
function|new_iob_data
parameter_list|(
specifier|register
name|io_setup
modifier|*
name|ios
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
endif|#
directive|endif
block|{
specifier|register
name|iob_data
modifier|*
name|iod
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|s
decl_stmt|,
modifier|*
modifier|*
name|se
decl_stmt|;
name|iod
operator|=
operator|(
name|iob_data
operator|*
operator|)
name|mem
argument_list|(
sizeof|sizeof
argument_list|(
name|iob_data
argument_list|)
operator|+
name|ios
operator|->
name|nelt
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|iod
operator|->
name|next
operator|=
name|iob_list
expr_stmt|;
name|iob_list
operator|=
name|iod
expr_stmt|;
name|iod
operator|->
name|type
operator|=
name|ios
operator|->
name|fields
index|[
literal|0
index|]
expr_stmt|;
name|iod
operator|->
name|name
operator|=
name|cpstring
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|s
operator|=
name|iod
operator|->
name|fields
expr_stmt|;
name|se
operator|=
name|s
operator|+
name|ios
operator|->
name|nelt
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|se
condition|)
operator|*
name|s
operator|++
operator|=
literal|"0"
expr_stmt|;
operator|*
name|s
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|char
modifier|*
ifdef|#
directive|ifdef
name|KR_headers
name|string_num
parameter_list|(
name|pfx
parameter_list|,
name|n
parameter_list|)
name|char
modifier|*
name|pfx
decl_stmt|;
name|long
name|n
decl_stmt|;
else|#
directive|else
function|string_num
parameter_list|(
name|char
modifier|*
name|pfx
parameter_list|,
name|long
name|n
parameter_list|)
endif|#
directive|endif
block|{
name|char
name|buf
index|[
literal|32
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s%ld"
argument_list|,
name|pfx
argument_list|,
name|n
argument_list|)
expr_stmt|;
comment|/* can't trust return type of sprintf -- BSD gets it wrong */
return|return
name|strcpy
argument_list|(
name|mem
argument_list|(
name|strlen
argument_list|(
name|buf
argument_list|)
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|buf
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|defines
modifier|*
name|define_list
decl_stmt|;
end_decl_stmt

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|def_start
parameter_list|(
name|outfile
parameter_list|,
name|s1
parameter_list|,
name|s2
parameter_list|,
name|post
parameter_list|)
name|FILE
modifier|*
name|outfile
decl_stmt|;
name|char
modifier|*
name|s1
decl_stmt|;
name|char
modifier|*
name|s2
decl_stmt|;
name|char
modifier|*
name|post
decl_stmt|;
else|#
directive|else
function|def_start
parameter_list|(
name|FILE
modifier|*
name|outfile
parameter_list|,
name|char
modifier|*
name|s1
parameter_list|,
name|char
modifier|*
name|s2
parameter_list|,
name|char
modifier|*
name|post
parameter_list|)
endif|#
directive|endif
block|{
name|defines
modifier|*
name|d
decl_stmt|;
name|int
name|n
decl_stmt|,
name|n1
decl_stmt|;
specifier|extern
name|int
name|in_define
decl_stmt|;
name|n
operator|=
name|n1
operator|=
name|strlen
argument_list|(
name|s1
argument_list|)
expr_stmt|;
if|if
condition|(
name|s2
condition|)
name|n
operator|+=
name|strlen
argument_list|(
name|s2
argument_list|)
expr_stmt|;
name|d
operator|=
operator|(
name|defines
operator|*
operator|)
name|mem
argument_list|(
sizeof|sizeof
argument_list|(
name|defines
argument_list|)
operator|+
name|n
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|d
operator|->
name|next
operator|=
name|define_list
expr_stmt|;
name|define_list
operator|=
name|d
expr_stmt|;
name|strcpy
argument_list|(
name|d
operator|->
name|defname
argument_list|,
name|s1
argument_list|)
expr_stmt|;
if|if
condition|(
name|s2
condition|)
name|strcpy
argument_list|(
name|d
operator|->
name|defname
operator|+
name|n1
argument_list|,
name|s2
argument_list|)
expr_stmt|;
name|in_define
operator|=
literal|1
expr_stmt|;
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"#define %s"
argument_list|,
name|d
operator|->
name|defname
argument_list|)
expr_stmt|;
if|if
condition|(
name|post
condition|)
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|" %s"
argument_list|,
name|post
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|other_undefs
parameter_list|(
name|outfile
parameter_list|)
name|FILE
modifier|*
name|outfile
decl_stmt|;
else|#
directive|else
function|other_undefs
parameter_list|(
name|FILE
modifier|*
name|outfile
parameter_list|)
endif|#
directive|endif
block|{
name|defines
modifier|*
name|d
decl_stmt|;
if|if
condition|(
name|d
operator|=
name|define_list
condition|)
block|{
name|define_list
operator|=
literal|0
expr_stmt|;
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
do|do
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"#undef %s\n"
argument_list|,
name|d
operator|->
name|defname
argument_list|)
expr_stmt|;
do|while
condition|(
name|d
operator|=
name|d
operator|->
name|next
condition|)
do|;
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

