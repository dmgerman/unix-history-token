begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**************************************************************** Copyright 1990 - 1996 by AT&T, Lucent Technologies and Bellcore.  Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that the copyright notice and this permission notice and warranty disclaimer appear in supporting documentation, and that the names of AT&T, Bell Laboratories, Lucent or Bellcore or any of their entities not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  AT&T, Lucent and Bellcore disclaim all warranties with regard to this software, including all implied warranties of merchantability and fitness.  In no event shall AT&T, Lucent or Bellcore be liable for any special, indirect or consequential damages or any damages whatsoever resulting from loss of use, data or profits, whether in an action of contract, negligence or other tortious action, arising out of or in connection with the use or performance of this software. ****************************************************************/
end_comment

begin_comment
comment|/* Format.c -- this file takes an intermediate file (generated by pass 1    of the translator) and some state information about the contents of that    file, and generates C program text. */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"p1defs.h"
end_include

begin_include
include|#
directive|include
file|"format.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"names.h"
end_include

begin_include
include|#
directive|include
file|"iob.h"
end_include

begin_decl_stmt
name|int
name|c_output_line_length
init|=
name|DEF_C_LINE_LENGTH
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|last_was_label
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Boolean used to generate semicolons 				   when a label terminates a block */
end_comment

begin_decl_stmt
specifier|static
name|char
name|this_proc_name
index|[
literal|52
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Name of the current procedure.  This is 				   probably too simplistic to handle 				   multiple entry points */
end_comment

begin_decl_stmt
specifier|static
name|tagptr
name|do_format
name|Argdcl
argument_list|(
operator|(
name|FILEP
operator|,
name|FILEP
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_p1_1while
name|Argdcl
argument_list|(
operator|(
name|FILEP
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_p1_2while
name|Argdcl
argument_list|(
operator|(
name|FILEP
operator|,
name|FILEP
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tagptr
name|do_p1_addr
name|Argdcl
argument_list|(
operator|(
name|FILEP
operator|,
name|FILEP
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_p1_asgoto
name|Argdcl
argument_list|(
operator|(
name|FILEP
operator|,
name|FILEP
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tagptr
name|do_p1_charp
name|Argdcl
argument_list|(
operator|(
name|FILEP
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_p1_comment
name|Argdcl
argument_list|(
operator|(
name|FILEP
operator|,
name|FILEP
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_p1_comp_goto
name|Argdcl
argument_list|(
operator|(
name|FILEP
operator|,
name|FILEP
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tagptr
name|do_p1_const
name|Argdcl
argument_list|(
operator|(
name|FILEP
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_p1_elif
name|Argdcl
argument_list|(
operator|(
name|FILEP
operator|,
name|FILEP
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_p1_else
name|Argdcl
argument_list|(
operator|(
name|FILEP
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_p1_elseifstart
name|Argdcl
argument_list|(
operator|(
name|FILEP
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_p1_end_for
name|Argdcl
argument_list|(
operator|(
name|FILEP
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_p1_endelse
name|Argdcl
argument_list|(
operator|(
name|FILEP
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_p1_endif
name|Argdcl
argument_list|(
operator|(
name|FILEP
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tagptr
name|do_p1_expr
name|Argdcl
argument_list|(
operator|(
name|FILEP
operator|,
name|FILEP
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tagptr
name|do_p1_extern
name|Argdcl
argument_list|(
operator|(
name|FILEP
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_p1_for
name|Argdcl
argument_list|(
operator|(
name|FILEP
operator|,
name|FILEP
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_p1_fortran
name|Argdcl
argument_list|(
operator|(
name|FILEP
operator|,
name|FILEP
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_p1_goto
name|Argdcl
argument_list|(
operator|(
name|FILEP
operator|,
name|FILEP
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tagptr
name|do_p1_head
name|Argdcl
argument_list|(
operator|(
name|FILEP
operator|,
name|FILEP
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tagptr
name|do_p1_ident
name|Argdcl
argument_list|(
operator|(
name|FILEP
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_p1_if
name|Argdcl
argument_list|(
operator|(
name|FILEP
operator|,
name|FILEP
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_p1_label
name|Argdcl
argument_list|(
operator|(
name|FILEP
operator|,
name|FILEP
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tagptr
name|do_p1_list
name|Argdcl
argument_list|(
operator|(
name|FILEP
operator|,
name|FILEP
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tagptr
name|do_p1_literal
name|Argdcl
argument_list|(
operator|(
name|FILEP
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tagptr
name|do_p1_name_pointer
name|Argdcl
argument_list|(
operator|(
name|FILEP
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_p1_set_line
name|Argdcl
argument_list|(
operator|(
name|FILEP
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_p1_subr_ret
name|Argdcl
argument_list|(
operator|(
name|FILEP
operator|,
name|FILEP
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|get_p1_token
name|Argdcl
argument_list|(
operator|(
name|FILEP
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|p1get_const
name|Argdcl
argument_list|(
operator|(
name|FILEP
operator|,
name|int
operator|,
name|Constp
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|p1getd
name|Argdcl
argument_list|(
operator|(
name|FILEP
operator|,
name|long
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|p1getf
name|Argdcl
argument_list|(
operator|(
name|FILEP
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|p1getn
name|Argdcl
argument_list|(
operator|(
name|FILEP
operator|,
name|int
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|p1gets
name|Argdcl
argument_list|(
operator|(
name|FILEP
operator|,
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|proto
name|Argdcl
argument_list|(
operator|(
name|FILEP
operator|,
name|Argtypes
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|chainp
name|assigned_fmts
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|filename
index|[
name|P1_FILENAME_MAX
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|gflag
decl_stmt|,
name|sharp_line
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|gflag1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|parens
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|start_formatting
parameter_list|(
name|Void
parameter_list|)
block|{
name|FILE
modifier|*
name|infile
decl_stmt|;
specifier|static
name|int
name|wrote_one
init|=
literal|0
decl_stmt|;
specifier|extern
name|int
name|usedefsforcommon
decl_stmt|;
specifier|extern
name|char
modifier|*
name|p1_file
decl_stmt|,
modifier|*
name|p1_bakfile
decl_stmt|;
name|this_proc_name
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|last_was_label
operator|=
literal|0
expr_stmt|;
name|ei_next
operator|=
name|ei_first
expr_stmt|;
name|wh_next
operator|=
name|wh_first
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|pass1_file
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|infile
operator|=
name|fopen
argument_list|(
name|p1_file
argument_list|,
name|binread
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|Fatal
argument_list|(
literal|"start_formatting:  couldn't open the intermediate file\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|wrote_one
condition|)
name|nice_printf
argument_list|(
name|c_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|feof
argument_list|(
name|infile
argument_list|)
condition|)
block|{
name|expptr
name|this_expr
decl_stmt|;
name|this_expr
operator|=
name|do_format
argument_list|(
name|infile
argument_list|,
name|c_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_expr
condition|)
block|{
name|out_and_free_statement
argument_list|(
name|c_file
argument_list|,
name|this_expr
argument_list|)
expr_stmt|;
block|}
comment|/* if this_expr */
block|}
comment|/* while !feof infile */
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_was_label
condition|)
name|nice_printf
argument_list|(
name|c_file
argument_list|,
literal|";\n"
argument_list|)
expr_stmt|;
name|prev_tab
argument_list|(
name|c_file
argument_list|)
expr_stmt|;
name|gflag1
operator|=
name|sharp_line
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|this_proc_name
index|[
literal|0
index|]
condition|)
name|nice_printf
argument_list|(
name|c_file
argument_list|,
literal|"} /* %s */\n"
argument_list|,
name|this_proc_name
argument_list|)
expr_stmt|;
comment|/* Write the #undefs for common variable reference */
if|if
condition|(
name|usedefsforcommon
condition|)
block|{
name|Extsym
modifier|*
name|ext
decl_stmt|;
name|int
name|did_one
init|=
literal|0
decl_stmt|;
for|for
control|(
name|ext
operator|=
name|extsymtab
init|;
name|ext
operator|<
name|nextext
condition|;
name|ext
operator|++
control|)
if|if
condition|(
name|ext
operator|->
name|extstg
operator|==
name|STGCOMMON
operator|&&
name|ext
operator|->
name|used_here
condition|)
block|{
name|ext
operator|->
name|used_here
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|did_one
condition|)
name|nice_printf
argument_list|(
name|c_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|wr_abbrevs
argument_list|(
name|c_file
argument_list|,
literal|0
argument_list|,
name|ext
operator|->
name|extp
argument_list|)
expr_stmt|;
name|did_one
operator|=
literal|1
expr_stmt|;
name|ext
operator|->
name|extp
operator|=
name|CHNULL
expr_stmt|;
block|}
comment|/* if */
if|if
condition|(
name|did_one
condition|)
name|nice_printf
argument_list|(
name|c_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/* if usedefsforcommon */
name|other_undefs
argument_list|(
name|c_file
argument_list|)
expr_stmt|;
name|wrote_one
operator|=
literal|1
expr_stmt|;
comment|/* For debugging only */
if|if
condition|(
name|debugflag
operator|&&
operator|(
name|pass1_file
operator|=
name|fopen
argument_list|(
name|p1_bakfile
argument_list|,
name|binwrite
argument_list|)
operator|)
condition|)
if|if
condition|(
name|infile
operator|=
name|fopen
argument_list|(
name|p1_file
argument_list|,
name|binread
argument_list|)
condition|)
block|{
name|ffilecopy
argument_list|(
name|infile
argument_list|,
name|pass1_file
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|infile
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|pass1_file
argument_list|)
expr_stmt|;
block|}
comment|/* if infile */
comment|/* End of "debugging only" */
name|scrub
argument_list|(
name|p1_file
argument_list|)
expr_stmt|;
comment|/* optionally unlink */
if|if
condition|(
operator|(
name|pass1_file
operator|=
name|fopen
argument_list|(
name|p1_file
argument_list|,
name|binwrite
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|"start_formatting:  couldn't reopen the pass1 file"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* start_formatting */
end_comment

begin_function
specifier|static
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|put_semi
parameter_list|(
name|outfile
parameter_list|)
name|FILE
modifier|*
name|outfile
decl_stmt|;
else|#
directive|else
function|put_semi
parameter_list|(
name|FILE
modifier|*
name|outfile
parameter_list|)
endif|#
directive|endif
block|{
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|";\n"
argument_list|)
expr_stmt|;
name|last_was_label
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|SEM_CHECK
parameter_list|(
name|x
parameter_list|)
value|if (last_was_label) put_semi(x)
end_define

begin_comment
comment|/* do_format -- takes an input stream (a file in pass1 format) and writes    the appropriate C code to   outfile   when possible.  When reading an    expression, the expression tree is returned instead. */
end_comment

begin_function
specifier|static
name|expptr
ifdef|#
directive|ifdef
name|KR_headers
name|do_format
parameter_list|(
name|infile
parameter_list|,
name|outfile
parameter_list|)
name|FILE
modifier|*
name|infile
decl_stmt|;
name|FILE
modifier|*
name|outfile
decl_stmt|;
else|#
directive|else
function|do_format
parameter_list|(
name|FILE
modifier|*
name|infile
parameter_list|,
name|FILE
modifier|*
name|outfile
parameter_list|)
endif|#
directive|endif
block|{
name|int
name|token_type
decl_stmt|,
name|was_c_token
decl_stmt|;
name|expptr
name|retval
init|=
name|ENULL
decl_stmt|;
name|token_type
operator|=
name|get_p1_token
argument_list|(
name|infile
argument_list|)
expr_stmt|;
name|was_c_token
operator|=
literal|1
expr_stmt|;
switch|switch
condition|(
name|token_type
condition|)
block|{
case|case
name|P1_COMMENT
case|:
name|do_p1_comment
argument_list|(
name|infile
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|was_c_token
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|P1_SET_LINE
case|:
name|do_p1_set_line
argument_list|(
name|infile
argument_list|)
expr_stmt|;
name|was_c_token
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|P1_FILENAME
case|:
name|p1gets
argument_list|(
name|infile
argument_list|,
name|filename
argument_list|,
name|P1_FILENAME_MAX
argument_list|)
expr_stmt|;
name|was_c_token
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|P1_NAME_POINTER
case|:
name|retval
operator|=
name|do_p1_name_pointer
argument_list|(
name|infile
argument_list|)
expr_stmt|;
break|break;
case|case
name|P1_CONST
case|:
name|retval
operator|=
name|do_p1_const
argument_list|(
name|infile
argument_list|)
expr_stmt|;
break|break;
case|case
name|P1_EXPR
case|:
name|retval
operator|=
name|do_p1_expr
argument_list|(
name|infile
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|P1_IDENT
case|:
name|retval
operator|=
name|do_p1_ident
argument_list|(
name|infile
argument_list|)
expr_stmt|;
break|break;
case|case
name|P1_CHARP
case|:
name|retval
operator|=
name|do_p1_charp
argument_list|(
name|infile
argument_list|)
expr_stmt|;
break|break;
case|case
name|P1_EXTERN
case|:
name|retval
operator|=
name|do_p1_extern
argument_list|(
name|infile
argument_list|)
expr_stmt|;
break|break;
case|case
name|P1_HEAD
case|:
name|gflag1
operator|=
name|sharp_line
operator|=
literal|0
expr_stmt|;
name|retval
operator|=
name|do_p1_head
argument_list|(
name|infile
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|gflag1
operator|=
name|sharp_line
operator|=
name|gflag
expr_stmt|;
break|break;
case|case
name|P1_LIST
case|:
name|retval
operator|=
name|do_p1_list
argument_list|(
name|infile
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|P1_LITERAL
case|:
name|retval
operator|=
name|do_p1_literal
argument_list|(
name|infile
argument_list|)
expr_stmt|;
break|break;
case|case
name|P1_LABEL
case|:
name|do_p1_label
argument_list|(
name|infile
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
comment|/* last_was_label = 1; -- now set in do_p1_label */
name|was_c_token
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|P1_ASGOTO
case|:
name|do_p1_asgoto
argument_list|(
name|infile
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|P1_GOTO
case|:
name|do_p1_goto
argument_list|(
name|infile
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|P1_IF
case|:
name|do_p1_if
argument_list|(
name|infile
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|P1_ELSE
case|:
name|SEM_CHECK
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
name|do_p1_else
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|P1_ELIF
case|:
name|SEM_CHECK
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
name|do_p1_elif
argument_list|(
name|infile
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|P1_ENDIF
case|:
name|SEM_CHECK
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
name|do_p1_endif
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|P1_ENDELSE
case|:
name|SEM_CHECK
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
name|do_p1_endelse
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|P1_ADDR
case|:
name|retval
operator|=
name|do_p1_addr
argument_list|(
name|infile
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|P1_SUBR_RET
case|:
name|do_p1_subr_ret
argument_list|(
name|infile
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|P1_COMP_GOTO
case|:
name|do_p1_comp_goto
argument_list|(
name|infile
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|P1_FOR
case|:
name|do_p1_for
argument_list|(
name|infile
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|P1_ENDFOR
case|:
name|SEM_CHECK
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
name|do_p1_end_for
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|P1_WHILE1START
case|:
name|do_p1_1while
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|P1_WHILE2START
case|:
name|do_p1_2while
argument_list|(
name|infile
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|P1_PROCODE
case|:
name|procode
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|P1_ELSEIFSTART
case|:
name|SEM_CHECK
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
name|do_p1_elseifstart
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|P1_FORTRAN
case|:
name|do_p1_fortran
argument_list|(
name|infile
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
comment|/* no break; */
case|case
name|P1_EOF
case|:
name|was_c_token
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|P1_UNKNOWN
case|:
name|Fatal
argument_list|(
literal|"do_format:  Unknown token type in intermediate file"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|Fatal
argument_list|(
literal|"do_format:  Bad token type in intermediate file"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* switch */
if|if
condition|(
name|was_c_token
condition|)
name|last_was_label
operator|=
literal|0
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* do_format */
end_comment

begin_function
specifier|static
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|do_p1_comment
parameter_list|(
name|infile
parameter_list|,
name|outfile
parameter_list|)
name|FILE
modifier|*
name|infile
decl_stmt|;
name|FILE
modifier|*
name|outfile
decl_stmt|;
else|#
directive|else
function|do_p1_comment
parameter_list|(
name|FILE
modifier|*
name|infile
parameter_list|,
name|FILE
modifier|*
name|outfile
parameter_list|)
endif|#
directive|endif
block|{
specifier|extern
name|int
name|c_output_line_length
decl_stmt|,
name|in_comment
decl_stmt|;
name|char
name|storage
index|[
name|COMMENT_BUFFER_SIZE
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|length
decl_stmt|;
if|if
condition|(
operator|!
name|p1gets
argument_list|(
name|infile
argument_list|,
name|storage
argument_list|,
name|COMMENT_BUFFER_SIZE
operator|+
literal|1
argument_list|)
condition|)
return|return;
name|length
operator|=
name|strlen
argument_list|(
name|storage
argument_list|)
expr_stmt|;
name|gflag1
operator|=
name|sharp_line
operator|=
literal|0
expr_stmt|;
name|in_comment
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|length
operator|>
name|c_output_line_length
operator|-
literal|6
condition|)
name|margin_printf
argument_list|(
name|outfile
argument_list|,
literal|"/*%s*/\n"
argument_list|,
name|storage
argument_list|)
expr_stmt|;
else|else
name|margin_printf
argument_list|(
name|outfile
argument_list|,
name|length
condition|?
literal|"/* %s */\n"
else|:
literal|"\n"
argument_list|,
name|storage
argument_list|)
expr_stmt|;
name|in_comment
operator|=
literal|0
expr_stmt|;
name|gflag1
operator|=
name|sharp_line
operator|=
name|gflag
expr_stmt|;
block|}
end_function

begin_comment
comment|/* do_p1_comment */
end_comment

begin_function
specifier|static
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|do_p1_set_line
parameter_list|(
name|infile
parameter_list|)
name|FILE
modifier|*
name|infile
decl_stmt|;
else|#
directive|else
function|do_p1_set_line
parameter_list|(
name|FILE
modifier|*
name|infile
parameter_list|)
endif|#
directive|endif
block|{
name|int
name|status
decl_stmt|;
name|long
name|new_line_number
init|=
operator|-
literal|1
decl_stmt|;
name|status
operator|=
name|p1getd
argument_list|(
name|infile
argument_list|,
operator|&
name|new_line_number
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|EOF
condition|)
name|err
argument_list|(
literal|"do_p1_set_line:  Missing line number at end of file\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|status
operator|==
literal|0
operator|||
name|new_line_number
operator|==
operator|-
literal|1
condition|)
name|errl
argument_list|(
literal|"do_p1_set_line:  Illegal line number in intermediate file: %ld\n"
argument_list|,
name|new_line_number
argument_list|)
expr_stmt|;
else|else
block|{
name|lineno
operator|=
name|new_line_number
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* do_p1_set_line */
end_comment

begin_function
specifier|static
name|expptr
ifdef|#
directive|ifdef
name|KR_headers
name|do_p1_name_pointer
parameter_list|(
name|infile
parameter_list|)
name|FILE
modifier|*
name|infile
decl_stmt|;
else|#
directive|else
function|do_p1_name_pointer
parameter_list|(
name|FILE
modifier|*
name|infile
parameter_list|)
endif|#
directive|endif
block|{
name|Namep
name|namep
init|=
operator|(
name|Namep
operator|)
name|NULL
decl_stmt|;
name|int
name|status
decl_stmt|;
name|status
operator|=
name|p1getd
argument_list|(
name|infile
argument_list|,
operator|(
name|long
operator|*
operator|)
operator|&
name|namep
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|EOF
condition|)
name|err
argument_list|(
literal|"do_p1_name_pointer:  Missing pointer at end of file\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|status
operator|==
literal|0
operator|||
name|namep
operator|==
operator|(
name|Namep
operator|)
name|NULL
condition|)
name|erri
argument_list|(
literal|"do_p1_name_pointer:  Illegal name pointer in p1 file: '%x'\n"
argument_list|,
operator|(
name|int
operator|)
name|namep
argument_list|)
expr_stmt|;
return|return
operator|(
name|expptr
operator|)
name|namep
return|;
block|}
end_function

begin_comment
comment|/* do_p1_name_pointer */
end_comment

begin_function
specifier|static
name|expptr
ifdef|#
directive|ifdef
name|KR_headers
name|do_p1_const
parameter_list|(
name|infile
parameter_list|)
name|FILE
modifier|*
name|infile
decl_stmt|;
else|#
directive|else
function|do_p1_const
parameter_list|(
name|FILE
modifier|*
name|infile
parameter_list|)
endif|#
directive|endif
block|{
name|struct
name|Constblock
modifier|*
name|c
init|=
operator|(
expr|struct
name|Constblock
operator|*
operator|)
name|NULL
decl_stmt|;
name|long
name|type
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|status
decl_stmt|;
name|status
operator|=
name|p1getd
argument_list|(
name|infile
argument_list|,
operator|&
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|EOF
condition|)
name|err
argument_list|(
literal|"do_p1_const:  Missing constant type at end of file\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|status
operator|==
literal|0
condition|)
name|errl
argument_list|(
literal|"do_p1_const:  Illegal constant type in p1 file: %ld\n"
argument_list|,
name|type
argument_list|)
expr_stmt|;
else|else
block|{
name|status
operator|=
name|p1get_const
argument_list|(
name|infile
argument_list|,
operator|(
name|int
operator|)
name|type
argument_list|,
operator|&
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|EOF
condition|)
block|{
name|err
argument_list|(
literal|"do_p1_const:  Missing constant value at end of file\n"
argument_list|)
expr_stmt|;
name|c
operator|=
operator|(
expr|struct
name|Constblock
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|status
operator|==
literal|0
condition|)
block|{
name|err
argument_list|(
literal|"do_p1_const:  Illegal constant value in p1 file\n"
argument_list|)
expr_stmt|;
name|c
operator|=
operator|(
expr|struct
name|Constblock
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
comment|/* else */
block|}
comment|/* else */
return|return
operator|(
name|expptr
operator|)
name|c
return|;
block|}
end_function

begin_comment
comment|/* do_p1_const */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|addrlit
parameter_list|(
name|addrp
parameter_list|)
name|Addrp
name|addrp
decl_stmt|;
else|#
directive|else
function|addrlit
parameter_list|(
name|Addrp
name|addrp
parameter_list|)
endif|#
directive|endif
block|{
name|long
name|memno
init|=
name|addrp
operator|->
name|memno
decl_stmt|;
name|struct
name|Literal
modifier|*
name|litp
decl_stmt|,
modifier|*
name|lastlit
decl_stmt|;
name|lastlit
operator|=
name|litpool
operator|+
name|nliterals
expr_stmt|;
for|for
control|(
name|litp
operator|=
name|litpool
init|;
name|litp
operator|<
name|lastlit
condition|;
name|litp
operator|++
control|)
if|if
condition|(
name|litp
operator|->
name|litnum
operator|==
name|memno
condition|)
block|{
name|addrp
operator|->
name|vtype
operator|=
name|litp
operator|->
name|littype
expr_stmt|;
operator|*
operator|(
operator|(
expr|union
name|Constant
operator|*
operator|)
operator|&
operator|(
name|addrp
operator|->
name|user
operator|)
operator|)
operator|=
operator|*
operator|(
operator|(
expr|union
name|Constant
operator|*
operator|)
operator|&
operator|(
name|litp
operator|->
name|litval
operator|)
operator|)
expr_stmt|;
name|addrp
operator|->
name|vstg
operator|=
name|STGMEMNO
expr_stmt|;
return|return;
block|}
name|err
argument_list|(
literal|"addrlit failure!"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|expptr
ifdef|#
directive|ifdef
name|KR_headers
name|do_p1_literal
parameter_list|(
name|infile
parameter_list|)
name|FILE
modifier|*
name|infile
decl_stmt|;
else|#
directive|else
function|do_p1_literal
parameter_list|(
name|FILE
modifier|*
name|infile
parameter_list|)
endif|#
directive|endif
block|{
name|int
name|status
decl_stmt|;
name|long
name|memno
decl_stmt|;
name|Addrp
name|addrp
decl_stmt|;
name|status
operator|=
name|p1getd
argument_list|(
name|infile
argument_list|,
operator|&
name|memno
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|EOF
condition|)
name|err
argument_list|(
literal|"do_p1_literal:  Missing memno at end of file"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|status
operator|==
literal|0
condition|)
name|err
argument_list|(
literal|"do_p1_literal:  Missing memno in p1 file"
argument_list|)
expr_stmt|;
else|else
block|{
name|addrp
operator|=
name|ALLOC
argument_list|(
name|Addrblock
argument_list|)
expr_stmt|;
name|addrp
operator|->
name|tag
operator|=
name|TADDR
expr_stmt|;
name|addrp
operator|->
name|vtype
operator|=
name|TYUNKNOWN
expr_stmt|;
name|addrp
operator|->
name|Field
operator|=
name|NULL
expr_stmt|;
name|addrp
operator|->
name|memno
operator|=
name|memno
expr_stmt|;
name|addrlit
argument_list|(
name|addrp
argument_list|)
expr_stmt|;
name|addrp
operator|->
name|uname_tag
operator|=
name|UNAM_CONST
expr_stmt|;
block|}
comment|/* else */
return|return
operator|(
name|expptr
operator|)
name|addrp
return|;
block|}
end_function

begin_comment
comment|/* do_p1_literal */
end_comment

begin_function
specifier|static
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|do_p1_label
parameter_list|(
name|infile
parameter_list|,
name|outfile
parameter_list|)
name|FILE
modifier|*
name|infile
decl_stmt|;
name|FILE
modifier|*
name|outfile
decl_stmt|;
else|#
directive|else
function|do_p1_label
parameter_list|(
name|FILE
modifier|*
name|infile
parameter_list|,
name|FILE
modifier|*
name|outfile
parameter_list|)
endif|#
directive|endif
block|{
name|int
name|status
decl_stmt|;
name|ftnint
name|stateno
decl_stmt|;
name|struct
name|Labelblock
modifier|*
name|L
decl_stmt|;
name|char
modifier|*
name|fmt
decl_stmt|;
name|status
operator|=
name|p1getd
argument_list|(
name|infile
argument_list|,
operator|&
name|stateno
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|EOF
condition|)
name|err
argument_list|(
literal|"do_p1_label:  Missing label at end of file"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|status
operator|==
literal|0
condition|)
name|err
argument_list|(
literal|"do_p1_label:  Missing label in p1 file "
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|stateno
operator|<
literal|0
condition|)
block|{
comment|/* entry */
name|margin_printf
argument_list|(
name|outfile
argument_list|,
literal|"\n%s:\n"
argument_list|,
name|user_label
argument_list|(
name|stateno
argument_list|)
argument_list|)
expr_stmt|;
name|last_was_label
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|L
operator|=
name|labeltab
operator|+
name|stateno
expr_stmt|;
if|if
condition|(
name|L
operator|->
name|labused
condition|)
block|{
name|fmt
operator|=
literal|"%s:\n"
expr_stmt|;
name|last_was_label
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|fmt
operator|=
literal|"/* %s: */\n"
expr_stmt|;
name|margin_printf
argument_list|(
name|outfile
argument_list|,
name|fmt
argument_list|,
name|user_label
argument_list|(
name|L
operator|->
name|stateno
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* else */
block|}
end_function

begin_comment
comment|/* do_p1_label */
end_comment

begin_function
specifier|static
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|do_p1_asgoto
parameter_list|(
name|infile
parameter_list|,
name|outfile
parameter_list|)
name|FILE
modifier|*
name|infile
decl_stmt|;
name|FILE
modifier|*
name|outfile
decl_stmt|;
else|#
directive|else
function|do_p1_asgoto
parameter_list|(
name|FILE
modifier|*
name|infile
parameter_list|,
name|FILE
modifier|*
name|outfile
parameter_list|)
endif|#
directive|endif
block|{
name|expptr
name|expr
decl_stmt|;
name|expr
operator|=
name|do_format
argument_list|(
name|infile
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|out_asgoto
argument_list|(
name|outfile
argument_list|,
name|expr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* do_p1_asgoto */
end_comment

begin_function
specifier|static
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|do_p1_goto
parameter_list|(
name|infile
parameter_list|,
name|outfile
parameter_list|)
name|FILE
modifier|*
name|infile
decl_stmt|;
name|FILE
modifier|*
name|outfile
decl_stmt|;
else|#
directive|else
function|do_p1_goto
parameter_list|(
name|FILE
modifier|*
name|infile
parameter_list|,
name|FILE
modifier|*
name|outfile
parameter_list|)
endif|#
directive|endif
block|{
name|int
name|status
decl_stmt|;
name|long
name|stateno
decl_stmt|;
name|status
operator|=
name|p1getd
argument_list|(
name|infile
argument_list|,
operator|&
name|stateno
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|EOF
condition|)
name|err
argument_list|(
literal|"do_p1_goto:  Missing goto label at end of file"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|status
operator|==
literal|0
condition|)
name|err
argument_list|(
literal|"do_p1_goto:  Missing goto label in p1 file"
argument_list|)
expr_stmt|;
else|else
block|{
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"goto %s;\n"
argument_list|,
name|user_label
argument_list|(
name|stateno
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* else */
block|}
end_function

begin_comment
comment|/* do_p1_goto */
end_comment

begin_function
specifier|static
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|do_p1_if
parameter_list|(
name|infile
parameter_list|,
name|outfile
parameter_list|)
name|FILE
modifier|*
name|infile
decl_stmt|;
name|FILE
modifier|*
name|outfile
decl_stmt|;
else|#
directive|else
function|do_p1_if
parameter_list|(
name|FILE
modifier|*
name|infile
parameter_list|,
name|FILE
modifier|*
name|outfile
parameter_list|)
endif|#
directive|endif
block|{
name|expptr
name|cond
decl_stmt|;
do|do
block|{
name|cond
operator|=
name|do_format
argument_list|(
name|infile
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|cond
operator|==
name|ENULL
condition|)
do|;
name|out_if
argument_list|(
name|outfile
argument_list|,
name|cond
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* do_p1_if */
end_comment

begin_function
specifier|static
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|do_p1_else
parameter_list|(
name|outfile
parameter_list|)
name|FILE
modifier|*
name|outfile
decl_stmt|;
else|#
directive|else
function|do_p1_else
parameter_list|(
name|FILE
modifier|*
name|outfile
parameter_list|)
endif|#
directive|endif
block|{
name|out_else
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* do_p1_else */
end_comment

begin_function
specifier|static
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|do_p1_elif
parameter_list|(
name|infile
parameter_list|,
name|outfile
parameter_list|)
name|FILE
modifier|*
name|infile
decl_stmt|;
name|FILE
modifier|*
name|outfile
decl_stmt|;
else|#
directive|else
function|do_p1_elif
parameter_list|(
name|FILE
modifier|*
name|infile
parameter_list|,
name|FILE
modifier|*
name|outfile
parameter_list|)
endif|#
directive|endif
block|{
name|expptr
name|cond
decl_stmt|;
do|do
block|{
name|cond
operator|=
name|do_format
argument_list|(
name|infile
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|cond
operator|==
name|ENULL
condition|)
do|;
name|elif_out
argument_list|(
name|outfile
argument_list|,
name|cond
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* do_p1_elif */
end_comment

begin_function
specifier|static
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|do_p1_endif
parameter_list|(
name|outfile
parameter_list|)
name|FILE
modifier|*
name|outfile
decl_stmt|;
else|#
directive|else
function|do_p1_endif
parameter_list|(
name|FILE
modifier|*
name|outfile
parameter_list|)
endif|#
directive|endif
block|{
name|endif_out
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* do_p1_endif */
end_comment

begin_function
specifier|static
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|do_p1_endelse
parameter_list|(
name|outfile
parameter_list|)
name|FILE
modifier|*
name|outfile
decl_stmt|;
else|#
directive|else
function|do_p1_endelse
parameter_list|(
name|FILE
modifier|*
name|outfile
parameter_list|)
endif|#
directive|endif
block|{
name|end_else_out
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* do_p1_endelse */
end_comment

begin_function
specifier|static
name|expptr
ifdef|#
directive|ifdef
name|KR_headers
name|do_p1_addr
parameter_list|(
name|infile
parameter_list|,
name|outfile
parameter_list|)
name|FILE
modifier|*
name|infile
decl_stmt|;
name|FILE
modifier|*
name|outfile
decl_stmt|;
else|#
directive|else
function|do_p1_addr
parameter_list|(
name|FILE
modifier|*
name|infile
parameter_list|,
name|FILE
modifier|*
name|outfile
parameter_list|)
endif|#
directive|endif
block|{
name|Addrp
name|addrp
init|=
operator|(
name|Addrp
operator|)
name|NULL
decl_stmt|;
name|int
name|status
decl_stmt|;
name|status
operator|=
name|p1getn
argument_list|(
name|infile
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|Addrblock
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|addrp
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|EOF
condition|)
name|err
argument_list|(
literal|"do_p1_addr:  Missing Addrp at end of file"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|status
operator|==
literal|0
condition|)
name|err
argument_list|(
literal|"do_p1_addr:  Missing Addrp in p1 file"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|addrp
operator|==
operator|(
name|Addrp
operator|)
name|NULL
condition|)
name|err
argument_list|(
literal|"do_p1_addr:  Null addrp in p1 file"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|addrp
operator|->
name|tag
operator|!=
name|TADDR
condition|)
name|erri
argument_list|(
literal|"do_p1_addr: bad tag in p1 file '%d'"
argument_list|,
name|addrp
operator|->
name|tag
argument_list|)
expr_stmt|;
else|else
block|{
name|addrp
operator|->
name|vleng
operator|=
name|do_format
argument_list|(
name|infile
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|addrp
operator|->
name|memoffset
operator|=
name|do_format
argument_list|(
name|infile
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|expptr
operator|)
name|addrp
return|;
block|}
end_function

begin_comment
comment|/* do_p1_addr */
end_comment

begin_function
specifier|static
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|do_p1_subr_ret
parameter_list|(
name|infile
parameter_list|,
name|outfile
parameter_list|)
name|FILE
modifier|*
name|infile
decl_stmt|;
name|FILE
modifier|*
name|outfile
decl_stmt|;
else|#
directive|else
function|do_p1_subr_ret
parameter_list|(
name|FILE
modifier|*
name|infile
parameter_list|,
name|FILE
modifier|*
name|outfile
parameter_list|)
endif|#
directive|endif
block|{
name|expptr
name|retval
decl_stmt|;
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"return "
argument_list|)
expr_stmt|;
name|retval
operator|=
name|do_format
argument_list|(
name|infile
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|multitype
condition|)
if|if
condition|(
name|retval
condition|)
name|expr_out
argument_list|(
name|outfile
argument_list|,
name|retval
argument_list|)
expr_stmt|;
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|";\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* do_p1_subr_ret */
end_comment

begin_function
specifier|static
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|do_p1_comp_goto
parameter_list|(
name|infile
parameter_list|,
name|outfile
parameter_list|)
name|FILE
modifier|*
name|infile
decl_stmt|;
name|FILE
modifier|*
name|outfile
decl_stmt|;
else|#
directive|else
function|do_p1_comp_goto
parameter_list|(
name|FILE
modifier|*
name|infile
parameter_list|,
name|FILE
modifier|*
name|outfile
parameter_list|)
endif|#
directive|endif
block|{
name|expptr
name|index
decl_stmt|;
name|expptr
name|labels
decl_stmt|;
name|index
operator|=
name|do_format
argument_list|(
name|infile
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|==
name|ENULL
condition|)
block|{
name|err
argument_list|(
literal|"do_p1_comp_goto:  no expression for computed goto"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* if index == ENULL */
name|labels
operator|=
name|do_format
argument_list|(
name|infile
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|labels
operator|&&
name|labels
operator|->
name|tag
operator|!=
name|TLIST
condition|)
name|erri
argument_list|(
literal|"do_p1_comp_goto:  expected list, got tag '%d'"
argument_list|,
name|labels
operator|->
name|tag
argument_list|)
expr_stmt|;
else|else
name|compgoto_out
argument_list|(
name|outfile
argument_list|,
name|index
argument_list|,
name|labels
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* do_p1_comp_goto */
end_comment

begin_function
specifier|static
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|do_p1_for
parameter_list|(
name|infile
parameter_list|,
name|outfile
parameter_list|)
name|FILE
modifier|*
name|infile
decl_stmt|;
name|FILE
modifier|*
name|outfile
decl_stmt|;
else|#
directive|else
function|do_p1_for
parameter_list|(
name|FILE
modifier|*
name|infile
parameter_list|,
name|FILE
modifier|*
name|outfile
parameter_list|)
endif|#
directive|endif
block|{
name|expptr
name|init
decl_stmt|,
name|test
decl_stmt|,
name|inc
decl_stmt|;
name|init
operator|=
name|do_format
argument_list|(
name|infile
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|test
operator|=
name|do_format
argument_list|(
name|infile
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|inc
operator|=
name|do_format
argument_list|(
name|infile
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|out_for
argument_list|(
name|outfile
argument_list|,
name|init
argument_list|,
name|test
argument_list|,
name|inc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* do_p1_for */
end_comment

begin_function
specifier|static
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|do_p1_end_for
parameter_list|(
name|outfile
parameter_list|)
name|FILE
modifier|*
name|outfile
decl_stmt|;
else|#
directive|else
function|do_p1_end_for
parameter_list|(
name|FILE
modifier|*
name|outfile
parameter_list|)
endif|#
directive|endif
block|{
name|out_end_for
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* do_p1_end_for */
end_comment

begin_function
specifier|static
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|do_p1_fortran
parameter_list|(
name|infile
parameter_list|,
name|outfile
parameter_list|)
name|FILE
modifier|*
name|infile
decl_stmt|;
name|FILE
modifier|*
name|outfile
decl_stmt|;
else|#
directive|else
function|do_p1_fortran
parameter_list|(
name|FILE
modifier|*
name|infile
parameter_list|,
name|FILE
modifier|*
name|outfile
parameter_list|)
endif|#
directive|endif
block|{
name|char
name|buf
index|[
name|P1_STMTBUFSIZE
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|p1gets
argument_list|(
name|infile
argument_list|,
name|buf
argument_list|,
name|P1_STMTBUFSIZE
argument_list|)
condition|)
return|return;
comment|/* bypass nice_printf nonsense */
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"/*< %s>*/\n"
argument_list|,
name|buf
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* + 1 to skip by '$' */
block|}
end_function

begin_function
specifier|static
name|expptr
ifdef|#
directive|ifdef
name|KR_headers
name|do_p1_expr
parameter_list|(
name|infile
parameter_list|,
name|outfile
parameter_list|)
name|FILE
modifier|*
name|infile
decl_stmt|;
name|FILE
modifier|*
name|outfile
decl_stmt|;
else|#
directive|else
function|do_p1_expr
parameter_list|(
name|FILE
modifier|*
name|infile
parameter_list|,
name|FILE
modifier|*
name|outfile
parameter_list|)
endif|#
directive|endif
block|{
name|int
name|status
decl_stmt|;
name|long
name|opcode
decl_stmt|,
name|type
decl_stmt|;
name|struct
name|Exprblock
modifier|*
name|result
init|=
operator|(
expr|struct
name|Exprblock
operator|*
operator|)
name|NULL
decl_stmt|;
name|status
operator|=
name|p1getd
argument_list|(
name|infile
argument_list|,
operator|&
name|opcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|EOF
condition|)
name|err
argument_list|(
literal|"do_p1_expr:  Missing expr opcode at end of file"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|status
operator|==
literal|0
condition|)
name|err
argument_list|(
literal|"do_p1_expr:  Missing expr opcode in p1 file"
argument_list|)
expr_stmt|;
else|else
block|{
name|status
operator|=
name|p1getd
argument_list|(
name|infile
argument_list|,
operator|&
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|EOF
condition|)
name|err
argument_list|(
literal|"do_p1_expr:  Missing expr type at end of file"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|status
operator|==
literal|0
condition|)
name|err
argument_list|(
literal|"do_p1_expr:  Missing expr type in p1 file"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|opcode
operator|==
literal|0
condition|)
return|return
name|ENULL
return|;
else|else
block|{
name|result
operator|=
name|ALLOC
argument_list|(
name|Exprblock
argument_list|)
expr_stmt|;
name|result
operator|->
name|tag
operator|=
name|TEXPR
expr_stmt|;
name|result
operator|->
name|vtype
operator|=
name|type
expr_stmt|;
name|result
operator|->
name|opcode
operator|=
name|opcode
expr_stmt|;
name|result
operator|->
name|vleng
operator|=
name|do_format
argument_list|(
name|infile
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_unary_op
argument_list|(
name|opcode
argument_list|)
condition|)
name|result
operator|->
name|leftp
operator|=
name|do_format
argument_list|(
name|infile
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|is_binary_op
argument_list|(
name|opcode
argument_list|)
condition|)
block|{
name|result
operator|->
name|leftp
operator|=
name|do_format
argument_list|(
name|infile
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|result
operator|->
name|rightp
operator|=
name|do_format
argument_list|(
name|infile
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
block|}
else|else
name|errl
argument_list|(
literal|"do_p1_expr:  Illegal opcode %ld"
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
block|}
comment|/* else */
block|}
comment|/* else */
return|return
operator|(
name|expptr
operator|)
name|result
return|;
block|}
end_function

begin_comment
comment|/* do_p1_expr */
end_comment

begin_function
specifier|static
name|expptr
ifdef|#
directive|ifdef
name|KR_headers
name|do_p1_ident
parameter_list|(
name|infile
parameter_list|)
name|FILE
modifier|*
name|infile
decl_stmt|;
else|#
directive|else
function|do_p1_ident
parameter_list|(
name|FILE
modifier|*
name|infile
parameter_list|)
endif|#
directive|endif
block|{
name|Addrp
name|addrp
decl_stmt|;
name|int
name|status
decl_stmt|;
name|long
name|vtype
decl_stmt|,
name|vstg
decl_stmt|;
name|addrp
operator|=
name|ALLOC
argument_list|(
name|Addrblock
argument_list|)
expr_stmt|;
name|addrp
operator|->
name|tag
operator|=
name|TADDR
expr_stmt|;
name|status
operator|=
name|p1getd
argument_list|(
name|infile
argument_list|,
operator|&
name|vtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|EOF
condition|)
name|err
argument_list|(
literal|"do_p1_ident:  Missing identifier type at end of file\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|status
operator|==
literal|0
operator|||
name|vtype
operator|<
literal|0
operator|||
name|vtype
operator|>=
name|NTYPES
condition|)
name|errl
argument_list|(
literal|"do_p1_ident:  Bad type in intermediate file: %ld\n"
argument_list|,
name|vtype
argument_list|)
expr_stmt|;
else|else
name|addrp
operator|->
name|vtype
operator|=
name|vtype
expr_stmt|;
name|status
operator|=
name|p1getd
argument_list|(
name|infile
argument_list|,
operator|&
name|vstg
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|EOF
condition|)
name|err
argument_list|(
literal|"do_p1_ident:  Missing identifier storage at end of file\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|status
operator|==
literal|0
operator|||
name|vstg
operator|<
literal|0
operator|||
name|vstg
operator|>
name|STGNULL
condition|)
name|errl
argument_list|(
literal|"do_p1_ident:  Bad storage in intermediate file: %ld\n"
argument_list|,
name|vtype
argument_list|)
expr_stmt|;
else|else
name|addrp
operator|->
name|vstg
operator|=
name|vstg
expr_stmt|;
name|status
operator|=
name|p1gets
argument_list|(
name|infile
argument_list|,
name|addrp
operator|->
name|user
operator|.
name|ident
argument_list|,
name|IDENT_LEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|EOF
condition|)
name|err
argument_list|(
literal|"do_p1_ident:  Missing ident string at end of file"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|status
operator|==
literal|0
condition|)
name|err
argument_list|(
literal|"do_p1_ident:  Missing ident string in intermediate file"
argument_list|)
expr_stmt|;
name|addrp
operator|->
name|uname_tag
operator|=
name|UNAM_IDENT
expr_stmt|;
return|return
operator|(
name|expptr
operator|)
name|addrp
return|;
block|}
end_function

begin_comment
comment|/* do_p1_ident */
end_comment

begin_function
specifier|static
name|expptr
ifdef|#
directive|ifdef
name|KR_headers
name|do_p1_charp
parameter_list|(
name|infile
parameter_list|)
name|FILE
modifier|*
name|infile
decl_stmt|;
else|#
directive|else
function|do_p1_charp
parameter_list|(
name|FILE
modifier|*
name|infile
parameter_list|)
endif|#
directive|endif
block|{
name|Addrp
name|addrp
decl_stmt|;
name|int
name|status
decl_stmt|;
name|long
name|vtype
decl_stmt|,
name|vstg
decl_stmt|;
name|char
name|buf
index|[
literal|64
index|]
decl_stmt|;
name|addrp
operator|=
name|ALLOC
argument_list|(
name|Addrblock
argument_list|)
expr_stmt|;
name|addrp
operator|->
name|tag
operator|=
name|TADDR
expr_stmt|;
name|status
operator|=
name|p1getd
argument_list|(
name|infile
argument_list|,
operator|&
name|vtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|EOF
condition|)
name|err
argument_list|(
literal|"do_p1_ident:  Missing identifier type at end of file\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|status
operator|==
literal|0
operator|||
name|vtype
operator|<
literal|0
operator|||
name|vtype
operator|>=
name|NTYPES
condition|)
name|errl
argument_list|(
literal|"do_p1_ident:  Bad type in intermediate file: %ld\n"
argument_list|,
name|vtype
argument_list|)
expr_stmt|;
else|else
name|addrp
operator|->
name|vtype
operator|=
name|vtype
expr_stmt|;
name|status
operator|=
name|p1getd
argument_list|(
name|infile
argument_list|,
operator|&
name|vstg
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|EOF
condition|)
name|err
argument_list|(
literal|"do_p1_ident:  Missing identifier storage at end of file\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|status
operator|==
literal|0
operator|||
name|vstg
operator|<
literal|0
operator|||
name|vstg
operator|>
name|STGNULL
condition|)
name|errl
argument_list|(
literal|"do_p1_ident:  Bad storage in intermediate file: %ld\n"
argument_list|,
name|vtype
argument_list|)
expr_stmt|;
else|else
name|addrp
operator|->
name|vstg
operator|=
name|vstg
expr_stmt|;
name|status
operator|=
name|p1gets
argument_list|(
name|infile
argument_list|,
name|buf
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|EOF
condition|)
name|err
argument_list|(
literal|"do_p1_ident:  Missing charp ident string at end of file"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|status
operator|==
literal|0
condition|)
name|err
argument_list|(
literal|"do_p1_ident:  Missing charp ident string in intermediate file"
argument_list|)
expr_stmt|;
name|addrp
operator|->
name|uname_tag
operator|=
name|UNAM_CHARP
expr_stmt|;
name|addrp
operator|->
name|user
operator|.
name|Charp
operator|=
name|strcpy
argument_list|(
name|mem
argument_list|(
name|strlen
argument_list|(
name|buf
argument_list|)
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|expptr
operator|)
name|addrp
return|;
block|}
end_function

begin_function
specifier|static
name|expptr
ifdef|#
directive|ifdef
name|KR_headers
name|do_p1_extern
parameter_list|(
name|infile
parameter_list|)
name|FILE
modifier|*
name|infile
decl_stmt|;
else|#
directive|else
function|do_p1_extern
parameter_list|(
name|FILE
modifier|*
name|infile
parameter_list|)
endif|#
directive|endif
block|{
name|Addrp
name|addrp
decl_stmt|;
name|addrp
operator|=
name|ALLOC
argument_list|(
name|Addrblock
argument_list|)
expr_stmt|;
if|if
condition|(
name|addrp
condition|)
block|{
name|int
name|status
decl_stmt|;
name|addrp
operator|->
name|tag
operator|=
name|TADDR
expr_stmt|;
name|addrp
operator|->
name|vstg
operator|=
name|STGEXT
expr_stmt|;
name|addrp
operator|->
name|uname_tag
operator|=
name|UNAM_EXTERN
expr_stmt|;
name|status
operator|=
name|p1getd
argument_list|(
name|infile
argument_list|,
operator|&
operator|(
name|addrp
operator|->
name|memno
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|EOF
condition|)
name|err
argument_list|(
literal|"do_p1_extern:  Missing memno at end of file"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|status
operator|==
literal|0
condition|)
name|err
argument_list|(
literal|"do_p1_extern:  Missing memno in intermediate file"
argument_list|)
expr_stmt|;
if|if
condition|(
name|addrp
operator|->
name|vtype
operator|=
name|extsymtab
index|[
name|addrp
operator|->
name|memno
index|]
operator|.
name|extype
condition|)
name|addrp
operator|->
name|vclass
operator|=
name|CLPROC
expr_stmt|;
block|}
comment|/* if addrp */
return|return
operator|(
name|expptr
operator|)
name|addrp
return|;
block|}
end_function

begin_comment
comment|/* do_p1_extern */
end_comment

begin_function
specifier|static
name|expptr
ifdef|#
directive|ifdef
name|KR_headers
name|do_p1_head
parameter_list|(
name|infile
parameter_list|,
name|outfile
parameter_list|)
name|FILE
modifier|*
name|infile
decl_stmt|;
name|FILE
modifier|*
name|outfile
decl_stmt|;
else|#
directive|else
function|do_p1_head
parameter_list|(
name|FILE
modifier|*
name|infile
parameter_list|,
name|FILE
modifier|*
name|outfile
parameter_list|)
endif|#
directive|endif
block|{
name|int
name|status
decl_stmt|;
name|int
name|add_n_
decl_stmt|;
name|long
name|class
decl_stmt|;
name|char
name|storage
index|[
literal|256
index|]
decl_stmt|;
name|status
operator|=
name|p1getd
argument_list|(
name|infile
argument_list|,
operator|&
name|class
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|EOF
condition|)
name|err
argument_list|(
literal|"do_p1_head:  missing header class at end of file"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|status
operator|==
literal|0
condition|)
name|err
argument_list|(
literal|"do_p1_head:  missing header class in p1 file"
argument_list|)
expr_stmt|;
else|else
block|{
name|status
operator|=
name|p1gets
argument_list|(
name|infile
argument_list|,
name|storage
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|storage
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|EOF
operator|||
name|status
operator|==
literal|0
condition|)
name|storage
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/* else */
if|if
condition|(
name|class
operator|==
name|CLPROC
operator|||
name|class
operator|==
name|CLMAIN
condition|)
block|{
name|chainp
name|lengths
decl_stmt|;
name|add_n_
operator|=
name|nentry
operator|>
literal|1
expr_stmt|;
name|lengths
operator|=
name|length_comp
argument_list|(
name|entries
argument_list|,
name|add_n_
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|add_n_
operator|&&
name|protofile
operator|&&
name|class
operator|!=
name|CLMAIN
condition|)
name|protowrite
argument_list|(
name|protofile
argument_list|,
name|proctype
argument_list|,
name|storage
argument_list|,
name|entries
argument_list|,
name|lengths
argument_list|)
expr_stmt|;
if|if
condition|(
name|class
operator|==
name|CLMAIN
condition|)
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"/* Main program */ "
argument_list|)
expr_stmt|;
else|else
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"%s "
argument_list|,
name|multitype
condition|?
literal|"VOID"
else|:
name|c_type_decl
argument_list|(
name|proctype
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|nice_printf
argument_list|(
name|outfile
argument_list|,
name|add_n_
condition|?
literal|"%s0_"
else|:
literal|"%s"
argument_list|,
name|storage
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Ansi
condition|)
block|{
name|listargs
argument_list|(
name|outfile
argument_list|,
name|entries
argument_list|,
name|add_n_
argument_list|,
name|lengths
argument_list|)
expr_stmt|;
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|list_arg_types
argument_list|(
name|outfile
argument_list|,
name|entries
argument_list|,
name|lengths
argument_list|,
name|add_n_
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"{\n"
argument_list|)
expr_stmt|;
name|frchain
argument_list|(
operator|&
name|lengths
argument_list|)
expr_stmt|;
name|next_tab
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|this_proc_name
argument_list|,
name|storage
argument_list|)
expr_stmt|;
name|list_decls
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|class
operator|==
name|CLBLOCK
condition|)
name|next_tab
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
else|else
name|errl
argument_list|(
literal|"do_p1_head: got class %ld"
argument_list|,
name|class
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* do_p1_head */
end_comment

begin_function
specifier|static
name|expptr
ifdef|#
directive|ifdef
name|KR_headers
name|do_p1_list
parameter_list|(
name|infile
parameter_list|,
name|outfile
parameter_list|)
name|FILE
modifier|*
name|infile
decl_stmt|;
name|FILE
modifier|*
name|outfile
decl_stmt|;
else|#
directive|else
function|do_p1_list
parameter_list|(
name|FILE
modifier|*
name|infile
parameter_list|,
name|FILE
modifier|*
name|outfile
parameter_list|)
endif|#
directive|endif
block|{
name|long
name|tag
decl_stmt|,
name|type
decl_stmt|,
name|count
decl_stmt|;
name|int
name|status
decl_stmt|;
name|expptr
name|result
decl_stmt|;
name|status
operator|=
name|p1getd
argument_list|(
name|infile
argument_list|,
operator|&
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|EOF
condition|)
name|err
argument_list|(
literal|"do_p1_list:  missing list tag at end of file"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|status
operator|==
literal|0
condition|)
name|err
argument_list|(
literal|"do_p1_list:  missing list tag in p1 file"
argument_list|)
expr_stmt|;
else|else
block|{
name|status
operator|=
name|p1getd
argument_list|(
name|infile
argument_list|,
operator|&
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|EOF
condition|)
name|err
argument_list|(
literal|"do_p1_list:  missing list type at end of file"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|status
operator|==
literal|0
condition|)
name|err
argument_list|(
literal|"do_p1_list:  missing list type in p1 file"
argument_list|)
expr_stmt|;
else|else
block|{
name|status
operator|=
name|p1getd
argument_list|(
name|infile
argument_list|,
operator|&
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|EOF
condition|)
name|err
argument_list|(
literal|"do_p1_list:  missing count at end of file"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|status
operator|==
literal|0
condition|)
name|err
argument_list|(
literal|"do_p1_list:  missing count in p1 file"
argument_list|)
expr_stmt|;
block|}
comment|/* else */
block|}
comment|/* else */
name|result
operator|=
operator|(
name|expptr
operator|)
name|ALLOC
argument_list|(
name|Listblock
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
block|{
name|chainp
name|pointer
decl_stmt|;
name|result
operator|->
name|tag
operator|=
name|tag
expr_stmt|;
name|result
operator|->
name|listblock
operator|.
name|vtype
operator|=
name|type
expr_stmt|;
comment|/* Assume there will be enough data */
if|if
condition|(
name|count
operator|--
condition|)
block|{
name|pointer
operator|=
name|result
operator|->
name|listblock
operator|.
name|listp
operator|=
name|mkchain
argument_list|(
operator|(
name|char
operator|*
operator|)
name|do_format
argument_list|(
name|infile
argument_list|,
name|outfile
argument_list|)
argument_list|,
name|CHNULL
argument_list|)
expr_stmt|;
while|while
condition|(
name|count
operator|--
condition|)
block|{
name|pointer
operator|->
name|nextp
operator|=
name|mkchain
argument_list|(
operator|(
name|char
operator|*
operator|)
name|do_format
argument_list|(
name|infile
argument_list|,
name|outfile
argument_list|)
argument_list|,
name|CHNULL
argument_list|)
expr_stmt|;
name|pointer
operator|=
name|pointer
operator|->
name|nextp
expr_stmt|;
block|}
comment|/* while (count--) */
block|}
comment|/* if (count) */
block|}
comment|/* if (result) */
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* do_p1_list */
end_comment

begin_function
name|chainp
ifdef|#
directive|ifdef
name|KR_headers
name|length_comp
parameter_list|(
name|e
parameter_list|,
name|add_n
parameter_list|)
name|struct
name|Entrypoint
modifier|*
name|e
decl_stmt|;
name|int
name|add_n
decl_stmt|;
else|#
directive|else
function|length_comp
parameter_list|(
name|struct
name|Entrypoint
modifier|*
name|e
parameter_list|,
name|int
name|add_n
parameter_list|)
endif|#
directive|endif
comment|/* get lengths of characters args */
block|{
name|chainp
name|lengths
decl_stmt|;
name|chainp
name|args
decl_stmt|,
name|args1
decl_stmt|;
name|Namep
name|arg
decl_stmt|,
name|np
decl_stmt|;
name|int
name|nchargs
decl_stmt|;
name|Argtypes
modifier|*
name|at
decl_stmt|;
name|Atype
modifier|*
name|a
decl_stmt|;
specifier|extern
name|int
name|init_ac
index|[
name|TYSUBR
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|e
condition|)
return|return
literal|0
return|;
comment|/* possible only with errors */
name|args
operator|=
name|args1
operator|=
name|add_n
condition|?
name|allargs
else|:
name|e
operator|->
name|arglist
expr_stmt|;
name|nchargs
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|lengths
operator|=
name|NULL
init|;
name|args
condition|;
name|args
operator|=
name|args
operator|->
name|nextp
control|)
if|if
condition|(
name|arg
operator|=
operator|(
name|Namep
operator|)
name|args
operator|->
name|datap
condition|)
block|{
if|if
condition|(
name|arg
operator|->
name|vclass
operator|==
name|CLUNKNOWN
condition|)
name|arg
operator|->
name|vclass
operator|=
name|CLVAR
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|vtype
operator|==
name|TYCHAR
operator|&&
name|arg
operator|->
name|vclass
operator|!=
name|CLPROC
condition|)
block|{
name|lengths
operator|=
name|mkchain
argument_list|(
operator|(
name|char
operator|*
operator|)
name|arg
argument_list|,
name|lengths
argument_list|)
expr_stmt|;
name|nchargs
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|add_n
operator|&&
operator|(
name|np
operator|=
name|e
operator|->
name|enamep
operator|)
condition|)
block|{
comment|/* one last check -- by now we know all we ever will 		 * about external args... 		 */
name|save_argtypes
argument_list|(
name|e
operator|->
name|arglist
argument_list|,
operator|&
name|e
operator|->
name|entryname
operator|->
name|arginfo
argument_list|,
operator|&
name|np
operator|->
name|arginfo
argument_list|,
literal|0
argument_list|,
name|np
operator|->
name|fvarname
argument_list|,
name|STGEXT
argument_list|,
name|nchargs
argument_list|,
name|np
operator|->
name|vtype
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|at
operator|=
name|e
operator|->
name|entryname
operator|->
name|arginfo
expr_stmt|;
name|a
operator|=
name|at
operator|->
name|atypes
operator|+
name|init_ac
index|[
name|np
operator|->
name|vtype
index|]
expr_stmt|;
for|for
control|(
init|;
name|args1
condition|;
name|a
operator|++
operator|,
name|args1
operator|=
name|args1
operator|->
name|nextp
control|)
block|{
name|frchain
argument_list|(
operator|&
name|a
operator|->
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|=
operator|(
name|Namep
operator|)
name|args1
operator|->
name|datap
condition|)
switch|switch
condition|(
name|arg
operator|->
name|vclass
condition|)
block|{
case|case
name|CLPROC
case|:
if|if
condition|(
name|arg
operator|->
name|vimpltype
operator|&&
name|a
operator|->
name|type
operator|>=
literal|300
condition|)
name|a
operator|->
name|type
operator|=
name|TYUNKNOWN
operator|+
literal|200
expr_stmt|;
break|break;
case|case
name|CLUNKNOWN
case|:
name|a
operator|->
name|type
operator|%=
literal|100
expr_stmt|;
block|}
block|}
block|}
return|return
name|revchain
argument_list|(
name|lengths
argument_list|)
return|;
block|}
end_function

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|listargs
parameter_list|(
name|outfile
parameter_list|,
name|entryp
parameter_list|,
name|add_n_
parameter_list|,
name|lengths
parameter_list|)
name|FILE
modifier|*
name|outfile
decl_stmt|;
name|struct
name|Entrypoint
modifier|*
name|entryp
decl_stmt|;
name|int
name|add_n_
decl_stmt|;
name|chainp
name|lengths
decl_stmt|;
else|#
directive|else
function|listargs
parameter_list|(
name|FILE
modifier|*
name|outfile
parameter_list|,
name|struct
name|Entrypoint
modifier|*
name|entryp
parameter_list|,
name|int
name|add_n_
parameter_list|,
name|chainp
name|lengths
parameter_list|)
endif|#
directive|endif
block|{
name|chainp
name|args
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|Namep
name|arg
decl_stmt|;
name|int
name|did_one
init|=
literal|0
decl_stmt|;
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
if|if
condition|(
name|add_n_
condition|)
block|{
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"n__"
argument_list|)
expr_stmt|;
name|did_one
operator|=
literal|1
expr_stmt|;
name|args
operator|=
name|allargs
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|entryp
condition|)
return|return;
comment|/* possible only with errors */
name|args
operator|=
name|entryp
operator|->
name|arglist
expr_stmt|;
block|}
if|if
condition|(
name|multitype
condition|)
block|{
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|", ret_val"
argument_list|)
expr_stmt|;
name|did_one
operator|=
literal|1
expr_stmt|;
name|args
operator|=
name|allargs
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ONEOF
argument_list|(
name|proctype
argument_list|,
name|MSKCOMPLEX
operator||
name|MSKCHAR
argument_list|)
condition|)
block|{
name|s
operator|=
name|xretslot
index|[
name|proctype
index|]
operator|->
name|user
operator|.
name|ident
expr_stmt|;
name|nice_printf
argument_list|(
name|outfile
argument_list|,
name|did_one
condition|?
literal|", %s"
else|:
literal|"%s"
argument_list|,
operator|*
name|s
operator|==
literal|'('
comment|/*)*/
condition|?
literal|"r_v"
else|:
name|s
argument_list|)
expr_stmt|;
name|did_one
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|proctype
operator|==
name|TYCHAR
condition|)
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|", ret_val_len"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
name|args
condition|;
name|args
operator|=
name|args
operator|->
name|nextp
control|)
if|if
condition|(
name|arg
operator|=
operator|(
name|Namep
operator|)
name|args
operator|->
name|datap
condition|)
block|{
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"%s"
argument_list|,
name|did_one
condition|?
literal|", "
else|:
literal|""
argument_list|)
expr_stmt|;
name|out_name
argument_list|(
name|outfile
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|did_one
operator|=
literal|1
expr_stmt|;
block|}
for|for
control|(
name|args
operator|=
name|lengths
init|;
name|args
condition|;
name|args
operator|=
name|args
operator|->
name|nextp
control|)
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|", %s"
argument_list|,
name|new_arg_length
argument_list|(
operator|(
name|Namep
operator|)
name|args
operator|->
name|datap
argument_list|)
argument_list|)
expr_stmt|;
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* listargs */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|list_arg_types
parameter_list|(
name|outfile
parameter_list|,
name|entryp
parameter_list|,
name|lengths
parameter_list|,
name|add_n_
parameter_list|,
name|finalnl
parameter_list|)
name|FILE
modifier|*
name|outfile
decl_stmt|;
name|struct
name|Entrypoint
modifier|*
name|entryp
decl_stmt|;
name|chainp
name|lengths
decl_stmt|;
name|int
name|add_n_
decl_stmt|;
name|char
modifier|*
name|finalnl
decl_stmt|;
else|#
directive|else
function|list_arg_types
parameter_list|(
name|FILE
modifier|*
name|outfile
parameter_list|,
name|struct
name|Entrypoint
modifier|*
name|entryp
parameter_list|,
name|chainp
name|lengths
parameter_list|,
name|int
name|add_n_
parameter_list|,
name|char
modifier|*
name|finalnl
parameter_list|)
endif|#
directive|endif
block|{
name|chainp
name|args
decl_stmt|;
name|int
name|last_type
init|=
operator|-
literal|1
decl_stmt|,
name|last_class
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|did_one
init|=
literal|0
decl_stmt|,
name|done_one
decl_stmt|,
name|is_ext
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|sep
init|=
literal|""
decl_stmt|,
modifier|*
name|sep1
decl_stmt|;
if|if
condition|(
name|outfile
operator|==
operator|(
name|FILE
operator|*
operator|)
name|NULL
condition|)
block|{
name|err
argument_list|(
literal|"list_arg_types:  null output file"
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|entryp
operator|==
operator|(
expr|struct
name|Entrypoint
operator|*
operator|)
name|NULL
condition|)
block|{
name|err
argument_list|(
literal|"list_arg_types:  null procedure entry pointer"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* else */
if|if
condition|(
name|Ansi
condition|)
block|{
name|done_one
operator|=
literal|0
expr_stmt|;
name|sep1
operator|=
literal|", "
expr_stmt|;
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"("
comment|/*)*/
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|done_one
operator|=
literal|1
expr_stmt|;
name|sep1
operator|=
literal|";\n"
expr_stmt|;
block|}
name|args
operator|=
name|entryp
operator|->
name|arglist
expr_stmt|;
if|if
condition|(
name|add_n_
condition|)
block|{
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"int n__"
argument_list|)
expr_stmt|;
name|did_one
operator|=
name|done_one
expr_stmt|;
name|sep
operator|=
name|sep1
expr_stmt|;
name|args
operator|=
name|allargs
expr_stmt|;
block|}
if|if
condition|(
name|multitype
condition|)
block|{
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"%sMultitype *ret_val"
argument_list|,
name|sep
argument_list|)
expr_stmt|;
name|did_one
operator|=
name|done_one
expr_stmt|;
name|sep
operator|=
name|sep1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ONEOF
argument_list|(
name|proctype
argument_list|,
name|MSKCOMPLEX
operator||
name|MSKCHAR
argument_list|)
condition|)
block|{
name|s
operator|=
name|xretslot
index|[
name|proctype
index|]
operator|->
name|user
operator|.
name|ident
expr_stmt|;
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"%s%s *%s"
argument_list|,
name|sep
argument_list|,
name|c_type_decl
argument_list|(
name|proctype
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|*
name|s
operator|==
literal|'('
comment|/*)*/
condition|?
literal|"r_v"
else|:
name|s
argument_list|)
expr_stmt|;
name|did_one
operator|=
name|done_one
expr_stmt|;
name|sep
operator|=
name|sep1
expr_stmt|;
if|if
condition|(
name|proctype
operator|==
name|TYCHAR
condition|)
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"%sftnlen ret_val_len"
argument_list|,
name|sep
argument_list|)
expr_stmt|;
block|}
comment|/* if ONEOF proctype */
for|for
control|(
init|;
name|args
condition|;
name|args
operator|=
name|args
operator|->
name|nextp
control|)
block|{
name|Namep
name|arg
init|=
operator|(
name|Namep
operator|)
name|args
operator|->
name|datap
decl_stmt|;
comment|/* Scalars are passed by reference, and arrays will have their lower bound    adjusted, so nearly everything is printed with a star in front.  The    exception is character lengths, which are passed by value. */
if|if
condition|(
name|arg
condition|)
block|{
name|int
name|type
init|=
name|arg
operator|->
name|vtype
decl_stmt|,
name|class
init|=
name|arg
operator|->
name|vclass
decl_stmt|;
if|if
condition|(
name|class
operator|==
name|CLPROC
condition|)
if|if
condition|(
name|arg
operator|->
name|vimpltype
condition|)
name|type
operator|=
name|Castargs
condition|?
name|TYUNKNOWN
else|:
name|TYSUBR
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|TYREAL
operator|&&
name|forcedouble
operator|&&
operator|!
name|Castargs
condition|)
name|type
operator|=
name|TYDREAL
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|last_type
operator|&&
name|class
operator|==
name|last_class
operator|&&
name|did_one
condition|)
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|is_ext
operator|=
name|class
operator|==
name|CLPROC
operator|)
operator|&&
name|Castargs
condition|)
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"%s%s "
argument_list|,
name|sep
argument_list|,
name|usedcasts
index|[
name|type
index|]
operator|=
name|casttypes
index|[
name|type
index|]
argument_list|)
expr_stmt|;
else|else
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"%s%s "
argument_list|,
name|sep
argument_list|,
name|c_type_decl
argument_list|(
name|type
argument_list|,
name|is_ext
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|class
operator|==
name|CLPROC
condition|)
if|if
condition|(
name|Castargs
condition|)
name|out_name
argument_list|(
name|outfile
argument_list|,
name|arg
argument_list|)
expr_stmt|;
else|else
block|{
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"(*"
argument_list|)
expr_stmt|;
name|out_name
argument_list|(
name|outfile
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|") %s"
argument_list|,
name|parens
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"*"
argument_list|)
expr_stmt|;
name|out_name
argument_list|(
name|outfile
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
name|last_type
operator|=
name|type
expr_stmt|;
name|last_class
operator|=
name|class
expr_stmt|;
name|did_one
operator|=
name|done_one
expr_stmt|;
name|sep
operator|=
name|sep1
expr_stmt|;
block|}
comment|/* if (arg) */
block|}
comment|/* for args = entryp -> arglist */
for|for
control|(
name|args
operator|=
name|lengths
init|;
name|args
condition|;
name|args
operator|=
name|args
operator|->
name|nextp
control|)
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"%sftnlen %s"
argument_list|,
name|sep
argument_list|,
name|new_arg_length
argument_list|(
operator|(
name|Namep
operator|)
name|args
operator|->
name|datap
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|did_one
condition|)
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|";\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|Ansi
condition|)
name|nice_printf
argument_list|(
name|outfile
argument_list|,
comment|/*((*/
name|sep
operator|!=
name|sep1
operator|&&
name|Ansi
operator|==
literal|1
condition|?
literal|"void)%s"
else|:
literal|")%s"
argument_list|,
name|finalnl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* list_arg_types */
end_comment

begin_function
specifier|static
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|write_formats
parameter_list|(
name|outfile
parameter_list|)
name|FILE
modifier|*
name|outfile
decl_stmt|;
else|#
directive|else
function|write_formats
parameter_list|(
name|FILE
modifier|*
name|outfile
parameter_list|)
endif|#
directive|endif
block|{
specifier|register
name|struct
name|Labelblock
modifier|*
name|lp
decl_stmt|;
name|int
name|first
init|=
literal|1
decl_stmt|;
name|char
modifier|*
name|fs
decl_stmt|;
for|for
control|(
name|lp
operator|=
name|labeltab
init|;
name|lp
operator|<
name|highlabtab
condition|;
operator|++
name|lp
control|)
if|if
condition|(
name|lp
operator|->
name|fmtlabused
condition|)
block|{
if|if
condition|(
name|first
condition|)
block|{
name|first
operator|=
literal|0
expr_stmt|;
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"/* Format strings */\n"
argument_list|)
expr_stmt|;
block|}
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"static char fmt_%ld[] = \""
argument_list|,
name|lp
operator|->
name|stateno
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|fs
operator|=
name|lp
operator|->
name|fmtstring
operator|)
condition|)
name|fs
operator|=
literal|""
expr_stmt|;
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"%s\";\n"
argument_list|,
name|fs
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|first
condition|)
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|write_ioblocks
parameter_list|(
name|outfile
parameter_list|)
name|FILE
modifier|*
name|outfile
decl_stmt|;
else|#
directive|else
function|write_ioblocks
parameter_list|(
name|FILE
modifier|*
name|outfile
parameter_list|)
endif|#
directive|endif
block|{
specifier|register
name|iob_data
modifier|*
name|L
decl_stmt|;
specifier|register
name|char
modifier|*
name|f
decl_stmt|,
modifier|*
modifier|*
name|s
decl_stmt|,
modifier|*
name|sep
decl_stmt|;
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"/* Fortran I/O blocks */\n"
argument_list|)
expr_stmt|;
name|L
operator|=
name|iob_list
operator|=
operator|(
name|iob_data
operator|*
operator|)
name|revchain
argument_list|(
operator|(
name|chainp
operator|)
name|iob_list
argument_list|)
expr_stmt|;
do|do
block|{
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"static %s %s = { "
argument_list|,
name|L
operator|->
name|type
argument_list|,
name|L
operator|->
name|name
argument_list|)
expr_stmt|;
name|sep
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|s
operator|=
name|L
operator|->
name|fields
init|;
name|f
operator|=
operator|*
name|s
condition|;
name|s
operator|++
control|)
block|{
if|if
condition|(
name|sep
condition|)
name|nice_printf
argument_list|(
name|outfile
argument_list|,
name|sep
argument_list|)
expr_stmt|;
name|sep
operator|=
literal|", "
expr_stmt|;
if|if
condition|(
operator|*
name|f
operator|==
literal|'"'
condition|)
block|{
comment|/* kludge */
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"\""
argument_list|)
expr_stmt|;
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"%s\""
argument_list|,
name|f
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"%s"
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|" };\n"
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|L
operator|=
name|L
operator|->
name|next
condition|)
do|;
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"\n\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|write_assigned_fmts
parameter_list|(
name|outfile
parameter_list|)
name|FILE
modifier|*
name|outfile
decl_stmt|;
else|#
directive|else
function|write_assigned_fmts
parameter_list|(
name|FILE
modifier|*
name|outfile
parameter_list|)
endif|#
directive|endif
block|{
specifier|register
name|chainp
name|cp
decl_stmt|;
name|Namep
name|np
decl_stmt|;
name|char
modifier|*
name|comma
decl_stmt|,
modifier|*
name|type
decl_stmt|;
name|int
name|did_one
init|=
literal|0
decl_stmt|;
name|cp
operator|=
name|assigned_fmts
operator|=
name|revchain
argument_list|(
name|assigned_fmts
argument_list|)
expr_stmt|;
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"/* Assigned format variables */\n"
argument_list|)
expr_stmt|;
do|do
block|{
name|np
operator|=
operator|(
name|Namep
operator|)
name|cp
operator|->
name|datap
expr_stmt|;
if|if
condition|(
name|did_one
operator|==
name|np
operator|->
name|vstg
condition|)
block|{
name|comma
operator|=
literal|", "
expr_stmt|;
name|type
operator|=
literal|""
expr_stmt|;
block|}
else|else
block|{
name|comma
operator|=
name|did_one
condition|?
literal|";\n"
else|:
literal|""
expr_stmt|;
name|type
operator|=
name|np
operator|->
name|vstg
operator|==
name|STGAUTO
condition|?
literal|"char "
else|:
literal|"static char "
expr_stmt|;
name|did_one
operator|=
name|np
operator|->
name|vstg
expr_stmt|;
block|}
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"%s%s*%s_fmt"
argument_list|,
name|comma
argument_list|,
name|type
argument_list|,
name|np
operator|->
name|fvarname
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|cp
operator|=
name|cp
operator|->
name|nextp
condition|)
do|;
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|";\n\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
ifdef|#
directive|ifdef
name|KR_headers
name|to_upper
parameter_list|(
name|s
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
else|#
directive|else
function|to_upper
parameter_list|(
specifier|register
name|char
modifier|*
name|s
parameter_list|)
endif|#
directive|endif
block|{
specifier|static
name|char
name|buf
index|[
literal|64
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|t
init|=
name|buf
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
while|while
condition|(
operator|*
name|t
operator|++
operator|=
operator|(
name|c
operator|=
operator|*
name|s
operator|++
operator|)
operator|>=
literal|'a'
operator|&&
name|c
operator|<=
literal|'z'
condition|?
name|c
operator|+
literal|'A'
operator|-
literal|'a'
else|:
name|c
condition|)
empty_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_comment
comment|/* This routine creates static structures representing a namelist.    Declarations of the namelist and related structures are:  	struct Vardesc { 		char *name; 		char *addr; 		ftnlen *dims;	/* laid out as struct dimensions below */
end_comment

begin_comment
comment|/* 		int  type; 		}; 	typedef struct Vardesc Vardesc;  	struct Namelist { 		char *name; 		Vardesc **vars; 		int nvars; 		};  	struct dimensions 		{ 		ftnlen numberofdimensions; 		ftnlen numberofelements 		ftnlen baseoffset; 		ftnlen span[numberofdimensions-1]; 		};     If dims is not null, then the corner element of the array is at    addr.  However,  the element with subscripts (i1,...,in) is at    addr + sizeoftype * (i1+span[0]*(i2+span[1]*...) - dimp->baseoffset) */
end_comment

begin_function
specifier|static
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|write_namelists
parameter_list|(
name|nmch
parameter_list|,
name|outfile
parameter_list|)
name|chainp
name|nmch
decl_stmt|;
name|FILE
modifier|*
name|outfile
decl_stmt|;
else|#
directive|else
function|write_namelists
parameter_list|(
name|chainp
name|nmch
parameter_list|,
name|FILE
modifier|*
name|outfile
parameter_list|)
endif|#
directive|endif
block|{
name|Namep
name|var
decl_stmt|;
name|struct
name|Hashentry
modifier|*
name|entry
decl_stmt|;
name|struct
name|Dimblock
modifier|*
name|dimp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|nd
decl_stmt|,
name|type
decl_stmt|;
name|char
modifier|*
name|comma
decl_stmt|,
modifier|*
name|name
decl_stmt|;
specifier|register
name|chainp
name|q
decl_stmt|;
specifier|register
name|Namep
name|v
decl_stmt|;
specifier|extern
name|int
name|typeconv
index|[]
decl_stmt|;
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"/* Namelist stuff */\n\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|entry
operator|=
name|hashtab
init|;
name|entry
operator|<
name|lasthash
condition|;
operator|++
name|entry
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|v
operator|=
name|entry
operator|->
name|varp
operator|)
operator|||
operator|!
name|v
operator|->
name|vnamelist
condition|)
continue|continue;
name|type
operator|=
name|v
operator|->
name|vtype
expr_stmt|;
name|name
operator|=
name|v
operator|->
name|cvarname
expr_stmt|;
if|if
condition|(
name|dimp
operator|=
name|v
operator|->
name|vdim
condition|)
block|{
name|nd
operator|=
name|dimp
operator|->
name|ndim
expr_stmt|;
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"static ftnlen %s_dims[] = { %d, %ld, %ld"
argument_list|,
name|name
argument_list|,
name|nd
argument_list|,
name|dimp
operator|->
name|nelt
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
argument_list|,
name|dimp
operator|->
name|baseoffset
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
operator|--
name|nd
init|;
name|i
operator|<
name|nd
condition|;
name|i
operator|++
control|)
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|", %ld"
argument_list|,
name|dimp
operator|->
name|dims
index|[
name|i
index|]
operator|.
name|dimsize
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
argument_list|)
expr_stmt|;
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|" };\n"
argument_list|)
expr_stmt|;
block|}
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"static Vardesc %s_dv = { \"%s\", %s"
argument_list|,
name|name
argument_list|,
name|to_upper
argument_list|(
name|v
operator|->
name|fvarname
argument_list|)
argument_list|,
name|type
operator|==
name|TYCHAR
condition|?
literal|""
else|:
operator|(
name|dimp
operator|||
name|oneof_stg
argument_list|(
name|v
argument_list|,
name|v
operator|->
name|vstg
argument_list|,
name|M
argument_list|(
name|STGEQUIV
argument_list|)
operator||
name|M
argument_list|(
name|STGCOMMON
argument_list|)
argument_list|)
operator|)
condition|?
literal|"(char *)"
else|:
literal|"(char *)&"
argument_list|)
expr_stmt|;
name|out_name
argument_list|(
name|outfile
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|nice_printf
argument_list|(
name|outfile
argument_list|,
name|dimp
condition|?
literal|", %s_dims"
else|:
literal|", (ftnlen *)0"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|", %ld };\n"
argument_list|,
name|type
operator|!=
name|TYCHAR
condition|?
operator|(
name|long
operator|)
name|typeconv
index|[
name|type
index|]
else|:
operator|-
name|v
operator|->
name|vleng
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
argument_list|)
expr_stmt|;
block|}
do|do
block|{
name|var
operator|=
operator|(
name|Namep
operator|)
name|nmch
operator|->
name|datap
expr_stmt|;
name|name
operator|=
name|var
operator|->
name|cvarname
expr_stmt|;
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"\nstatic Vardesc *%s_vl[] = "
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|comma
operator|=
literal|"{"
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|q
operator|=
name|var
operator|->
name|varxptr
operator|.
name|namelist
init|;
name|q
condition|;
name|q
operator|=
name|q
operator|->
name|nextp
control|)
block|{
name|v
operator|=
operator|(
name|Namep
operator|)
name|q
operator|->
name|datap
expr_stmt|;
if|if
condition|(
operator|!
name|v
operator|->
name|vnamelist
condition|)
continue|continue;
name|i
operator|++
expr_stmt|;
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"%s&%s_dv"
argument_list|,
name|comma
argument_list|,
name|v
operator|->
name|cvarname
argument_list|)
expr_stmt|;
name|comma
operator|=
literal|","
expr_stmt|;
block|}
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|" };\n"
argument_list|)
expr_stmt|;
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"static Namelist %s = { \"%s\", %s_vl, %d };\n"
argument_list|,
name|name
argument_list|,
name|to_upper
argument_list|(
name|var
operator|->
name|fvarname
argument_list|)
argument_list|,
name|name
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|nmch
operator|=
name|nmch
operator|->
name|nextp
condition|)
do|;
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* fixextype tries to infer from usage in previous procedures    the type of an external procedure declared    external and passed as an argument but never typed or invoked.  */
end_comment

begin_function
specifier|static
name|int
ifdef|#
directive|ifdef
name|KR_headers
name|fixexttype
parameter_list|(
name|var
parameter_list|)
name|Namep
name|var
decl_stmt|;
else|#
directive|else
function|fixexttype
parameter_list|(
name|Namep
name|var
parameter_list|)
endif|#
directive|endif
block|{
name|Extsym
modifier|*
name|e
decl_stmt|;
name|int
name|type
decl_stmt|,
name|type1
decl_stmt|;
name|type
operator|=
name|var
operator|->
name|vtype
expr_stmt|;
name|e
operator|=
operator|&
name|extsymtab
index|[
name|var
operator|->
name|vardesc
operator|.
name|varno
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|type1
operator|=
name|e
operator|->
name|extype
operator|)
operator|&&
name|type
operator|==
name|TYUNKNOWN
condition|)
return|return
name|var
operator|->
name|vtype
operator|=
name|type1
return|;
if|if
condition|(
name|var
operator|->
name|visused
condition|)
block|{
if|if
condition|(
name|e
operator|->
name|exused
operator|&&
name|type
operator|!=
name|type1
condition|)
name|changedtype
argument_list|(
name|var
argument_list|)
expr_stmt|;
name|e
operator|->
name|exused
operator|=
literal|1
expr_stmt|;
name|e
operator|->
name|extype
operator|=
name|type
expr_stmt|;
block|}
return|return
name|type
return|;
block|}
end_function

begin_function
specifier|static
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|ref_defs
parameter_list|(
name|outfile
parameter_list|,
name|refdefs
parameter_list|)
name|FILE
modifier|*
name|outfile
decl_stmt|;
name|chainp
name|refdefs
decl_stmt|;
else|#
directive|else
function|ref_defs
parameter_list|(
name|FILE
modifier|*
name|outfile
parameter_list|,
name|chainp
name|refdefs
parameter_list|)
endif|#
directive|endif
block|{
name|chainp
name|cp
decl_stmt|;
name|int
name|eb
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|,
name|n
decl_stmt|;
name|struct
name|Dimblock
modifier|*
name|dimp
decl_stmt|;
name|expptr
name|b
decl_stmt|,
name|vl
decl_stmt|;
name|Namep
name|var
decl_stmt|;
name|char
modifier|*
name|amp
decl_stmt|,
modifier|*
name|comma
decl_stmt|;
name|margin_printf
argument_list|(
name|outfile
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|refdefs
operator|=
name|revchain
argument_list|(
name|refdefs
argument_list|)
init|;
name|cp
condition|;
name|cp
operator|=
name|cp
operator|->
name|nextp
control|)
block|{
name|var
operator|=
operator|(
name|Namep
operator|)
name|cp
operator|->
name|datap
expr_stmt|;
name|cp
operator|->
name|datap
operator|=
literal|0
expr_stmt|;
name|amp
operator|=
literal|"_subscr"
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|eb
operator|=
name|var
operator|->
name|vsubscrused
operator|)
condition|)
block|{
name|var
operator|->
name|vrefused
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|ISCOMPLEX
argument_list|(
name|var
operator|->
name|vtype
argument_list|)
condition|)
name|amp
operator|=
literal|"_ref"
expr_stmt|;
block|}
name|def_start
argument_list|(
name|outfile
argument_list|,
name|var
operator|->
name|cvarname
argument_list|,
name|amp
argument_list|,
name|CNULL
argument_list|)
expr_stmt|;
name|dimp
operator|=
name|var
operator|->
name|vdim
expr_stmt|;
name|vl
operator|=
literal|0
expr_stmt|;
name|comma
operator|=
literal|"("
expr_stmt|;
name|amp
operator|=
literal|""
expr_stmt|;
if|if
condition|(
name|var
operator|->
name|vtype
operator|==
name|TYCHAR
condition|)
block|{
name|amp
operator|=
literal|"&"
expr_stmt|;
name|vl
operator|=
name|var
operator|->
name|vleng
expr_stmt|;
if|if
condition|(
name|ISCONST
argument_list|(
name|vl
argument_list|)
operator|&&
name|vl
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
operator|==
literal|1
condition|)
name|vl
operator|=
literal|0
expr_stmt|;
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"%sa_0"
argument_list|,
name|comma
argument_list|)
expr_stmt|;
name|comma
operator|=
literal|","
expr_stmt|;
block|}
name|n
operator|=
name|dimp
operator|->
name|ndim
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|n
condition|;
name|i
operator|++
operator|,
name|comma
operator|=
literal|","
control|)
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"%sa_%d"
argument_list|,
name|comma
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|") %s"
argument_list|,
name|amp
argument_list|)
expr_stmt|;
if|if
condition|(
name|var
operator|->
name|vsubscrused
condition|)
name|var
operator|->
name|vsubscrused
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|ISCOMPLEX
argument_list|(
name|var
operator|->
name|vtype
argument_list|)
condition|)
block|{
name|out_name
argument_list|(
name|outfile
argument_list|,
name|var
argument_list|)
expr_stmt|;
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"[%s"
argument_list|,
name|vl
condition|?
literal|"("
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
literal|2
init|;
name|j
operator|<
name|n
condition|;
name|j
operator|++
control|)
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|i
operator|>
literal|1
condition|)
block|{
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"(a_%d)%s*"
argument_list|,
name|i
argument_list|,
name|i
operator|==
name|n
condition|?
literal|""
else|:
literal|")"
argument_list|)
expr_stmt|;
name|expr_out
argument_list|(
name|outfile
argument_list|,
name|cpexpr
argument_list|(
name|dimp
operator|->
name|dims
index|[
name|i
operator|-
literal|2
index|]
operator|.
name|dimsize
argument_list|)
argument_list|)
expr_stmt|;
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|" + "
argument_list|)
expr_stmt|;
block|}
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"a_1"
argument_list|)
expr_stmt|;
if|if
condition|(
name|var
operator|->
name|vtype
operator|==
name|TYCHAR
condition|)
block|{
if|if
condition|(
name|vl
condition|)
block|{
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|")*"
argument_list|)
expr_stmt|;
name|expr_out
argument_list|(
name|outfile
argument_list|,
name|cpexpr
argument_list|(
name|vl
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|" + a_0"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|var
operator|->
name|vstg
operator|!=
name|STGARG
comment|/* || checksubs */
operator|)
operator|&&
operator|(
name|b
operator|=
name|dimp
operator|->
name|baseoffset
operator|)
condition|)
block|{
name|b
operator|=
name|cpexpr
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|var
operator|->
name|vtype
operator|==
name|TYCHAR
condition|)
name|b
operator|=
name|mkexpr
argument_list|(
name|OPSTAR
argument_list|,
name|cpexpr
argument_list|(
name|var
operator|->
name|vleng
argument_list|)
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|" - "
argument_list|)
expr_stmt|;
name|expr_out
argument_list|(
name|outfile
argument_list|,
name|b
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ISCOMPLEX
argument_list|(
name|var
operator|->
name|vtype
argument_list|)
condition|)
block|{
name|margin_printf
argument_list|(
name|outfile
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|def_start
argument_list|(
name|outfile
argument_list|,
name|var
operator|->
name|cvarname
argument_list|,
literal|"_ref"
argument_list|,
name|CNULL
argument_list|)
expr_stmt|;
name|comma
operator|=
literal|"("
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|n
condition|;
name|i
operator|++
operator|,
name|comma
operator|=
literal|","
control|)
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"%sa_%d"
argument_list|,
name|comma
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|") %s[%s_subscr"
argument_list|,
name|var
operator|->
name|cvarname
argument_list|,
name|var
operator|->
name|cvarname
argument_list|)
expr_stmt|;
name|comma
operator|=
literal|"("
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|n
condition|;
name|i
operator|++
operator|,
name|comma
operator|=
literal|","
control|)
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"%sa_%d"
argument_list|,
name|comma
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
name|margin_printf
argument_list|(
name|outfile
argument_list|,
literal|"]\n"
operator|+
name|eb
argument_list|)
expr_stmt|;
block|}
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|frchain
argument_list|(
operator|&
name|refdefs
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|list_decls
parameter_list|(
name|outfile
parameter_list|)
name|FILE
modifier|*
name|outfile
decl_stmt|;
else|#
directive|else
function|list_decls
parameter_list|(
name|FILE
modifier|*
name|outfile
parameter_list|)
endif|#
directive|endif
block|{
specifier|extern
name|chainp
name|used_builtins
decl_stmt|;
specifier|extern
name|struct
name|Hashentry
modifier|*
name|hashtab
decl_stmt|;
name|struct
name|Hashentry
modifier|*
name|entry
decl_stmt|;
name|int
name|write_header
init|=
literal|1
decl_stmt|;
name|int
name|last_class
init|=
operator|-
literal|1
decl_stmt|,
name|last_stg
init|=
operator|-
literal|1
decl_stmt|;
name|Namep
name|var
decl_stmt|;
name|int
name|Alias
decl_stmt|,
name|Define
decl_stmt|,
name|did_one
decl_stmt|,
name|last_type
decl_stmt|,
name|type
decl_stmt|;
specifier|extern
name|int
name|def_equivs
decl_stmt|,
name|useauto
decl_stmt|;
specifier|extern
name|chainp
name|new_vars
decl_stmt|;
comment|/* Compiler-generated locals */
name|chainp
name|namelists
init|=
literal|0
decl_stmt|,
name|refdefs
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|ctype
decl_stmt|;
name|int
name|useauto1
init|=
name|useauto
operator|&&
operator|!
name|saveall
decl_stmt|;
name|long
name|x
decl_stmt|;
specifier|extern
name|int
name|hsize
decl_stmt|;
comment|/* First write out the statically initialized data */
if|if
condition|(
name|initfile
condition|)
name|list_init_data
argument_list|(
operator|&
name|initfile
argument_list|,
name|initfname
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
comment|/* Next come formats */
name|write_formats
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
comment|/* Now write out the system-generated identifiers */
if|if
condition|(
name|new_vars
operator|||
name|nequiv
condition|)
block|{
name|chainp
name|args
decl_stmt|,
name|next_var
decl_stmt|,
name|this_var
decl_stmt|;
name|chainp
name|nv
index|[
name|TYVOID
index|]
decl_stmt|,
name|nv1
index|[
name|TYVOID
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|Addrp
name|Var
decl_stmt|;
name|Namep
name|arg
decl_stmt|;
comment|/* zap unused dimension variables */
for|for
control|(
name|args
operator|=
name|allargs
init|;
name|args
condition|;
name|args
operator|=
name|args
operator|->
name|nextp
control|)
block|{
name|arg
operator|=
operator|(
name|Namep
operator|)
name|args
operator|->
name|datap
expr_stmt|;
if|if
condition|(
name|this_var
operator|=
name|arg
operator|->
name|vlastdim
condition|)
block|{
name|frexpr
argument_list|(
operator|(
name|tagptr
operator|)
name|this_var
operator|->
name|datap
argument_list|)
expr_stmt|;
name|this_var
operator|->
name|datap
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* sort new_vars by type, skipping entries just zapped */
for|for
control|(
name|i
operator|=
name|TYADDR
init|;
name|i
operator|<
name|TYVOID
condition|;
name|i
operator|++
control|)
name|nv
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|this_var
operator|=
name|new_vars
init|;
name|this_var
condition|;
name|this_var
operator|=
name|next_var
control|)
block|{
name|next_var
operator|=
name|this_var
operator|->
name|nextp
expr_stmt|;
if|if
condition|(
name|Var
operator|=
operator|(
name|Addrp
operator|)
name|this_var
operator|->
name|datap
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|this_var
operator|->
name|nextp
operator|=
name|nv
index|[
name|j
operator|=
name|Var
operator|->
name|vtype
index|]
operator|)
condition|)
name|nv1
index|[
name|j
index|]
operator|=
name|this_var
expr_stmt|;
name|nv
index|[
name|j
index|]
operator|=
name|this_var
expr_stmt|;
block|}
else|else
block|{
name|this_var
operator|->
name|nextp
operator|=
literal|0
expr_stmt|;
name|frchain
argument_list|(
operator|&
name|this_var
argument_list|)
expr_stmt|;
block|}
block|}
name|new_vars
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|TYVOID
init|;
operator|--
name|i
operator|>=
name|TYADDR
condition|;
control|)
if|if
condition|(
name|this_var
operator|=
name|nv
index|[
name|i
index|]
condition|)
block|{
name|nv1
index|[
name|i
index|]
operator|->
name|nextp
operator|=
name|new_vars
expr_stmt|;
name|new_vars
operator|=
name|this_var
expr_stmt|;
block|}
comment|/* write the declarations */
name|did_one
operator|=
literal|0
expr_stmt|;
name|last_type
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|this_var
operator|=
name|new_vars
init|;
name|this_var
condition|;
name|this_var
operator|=
name|this_var
operator|->
name|nextp
control|)
block|{
name|Var
operator|=
operator|(
name|Addrp
operator|)
name|this_var
operator|->
name|datap
expr_stmt|;
if|if
condition|(
name|Var
operator|==
operator|(
name|Addrp
operator|)
name|NULL
condition|)
name|err
argument_list|(
literal|"list_decls:  null variable"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|Var
operator|->
name|tag
operator|!=
name|TADDR
condition|)
name|erri
argument_list|(
literal|"list_decls:  bad tag on new variable '%d'"
argument_list|,
name|Var
operator|->
name|tag
argument_list|)
expr_stmt|;
name|type
operator|=
name|nv_type
argument_list|(
name|Var
argument_list|)
expr_stmt|;
if|if
condition|(
name|Var
operator|->
name|vstg
operator|==
name|STGINIT
operator|||
name|Var
operator|->
name|uname_tag
operator|==
name|UNAM_IDENT
operator|&&
operator|*
name|Var
operator|->
name|user
operator|.
name|ident
operator|==
literal|' '
operator|&&
name|multitype
condition|)
continue|continue;
if|if
condition|(
operator|!
name|did_one
condition|)
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"/* System generated locals */\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_type
operator|==
name|type
operator|&&
name|did_one
condition|)
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|did_one
condition|)
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|";\n"
argument_list|)
expr_stmt|;
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"%s "
argument_list|,
name|c_type_decl
argument_list|(
name|type
argument_list|,
name|Var
operator|->
name|vclass
operator|==
name|CLPROC
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* else */
comment|/* Character type is really a string type.  Put out a '*' for parameters    with unknown length and functions returning character */
if|if
condition|(
name|Var
operator|->
name|vtype
operator|==
name|TYCHAR
operator|&&
operator|(
operator|!
name|ISICON
argument_list|(
operator|(
name|Var
operator|->
name|vleng
operator|)
argument_list|)
operator|||
name|Var
operator|->
name|vclass
operator|==
name|CLPROC
operator|)
condition|)
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"*"
argument_list|)
expr_stmt|;
name|write_nv_ident
argument_list|(
name|outfile
argument_list|,
operator|(
name|Addrp
operator|)
name|this_var
operator|->
name|datap
argument_list|)
expr_stmt|;
if|if
condition|(
name|Var
operator|->
name|vtype
operator|==
name|TYCHAR
operator|&&
name|Var
operator|->
name|vclass
operator|!=
name|CLPROC
operator|&&
name|ISICON
argument_list|(
operator|(
name|Var
operator|->
name|vleng
operator|)
argument_list|)
operator|&&
operator|(
name|i
operator|=
name|Var
operator|->
name|vleng
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
operator|)
operator|>
literal|0
condition|)
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"[%d]"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|did_one
operator|=
literal|1
expr_stmt|;
name|last_type
operator|=
name|nv_type
argument_list|(
name|Var
argument_list|)
expr_stmt|;
block|}
comment|/* for this_var */
comment|/* Handle the uninitialized equivalences */
name|do_uninit_equivs
argument_list|(
name|outfile
argument_list|,
operator|&
name|did_one
argument_list|)
expr_stmt|;
if|if
condition|(
name|did_one
condition|)
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|";\n\n"
argument_list|)
expr_stmt|;
block|}
comment|/* if new_vars */
comment|/* Write out builtin declarations */
if|if
condition|(
name|used_builtins
condition|)
block|{
name|chainp
name|cp
decl_stmt|;
name|Extsym
modifier|*
name|es
decl_stmt|;
name|last_type
operator|=
operator|-
literal|1
expr_stmt|;
name|did_one
operator|=
literal|0
expr_stmt|;
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"/* Builtin functions */"
argument_list|)
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|used_builtins
init|;
name|cp
condition|;
name|cp
operator|=
name|cp
operator|->
name|nextp
control|)
block|{
name|Addrp
name|e
init|=
operator|(
name|Addrp
operator|)
name|cp
operator|->
name|datap
decl_stmt|;
switch|switch
condition|(
name|type
operator|=
name|e
operator|->
name|vtype
condition|)
block|{
case|case
name|TYDREAL
case|:
case|case
name|TYREAL
case|:
comment|/* if (forcedouble || e->dbl_builtin) */
comment|/* libF77 currently assumes everything double */
name|type
operator|=
name|TYDREAL
expr_stmt|;
name|ctype
operator|=
literal|"double"
expr_stmt|;
break|break;
case|case
name|TYCOMPLEX
case|:
case|case
name|TYDCOMPLEX
case|:
name|type
operator|=
name|TYVOID
expr_stmt|;
comment|/* no break */
default|default:
name|ctype
operator|=
name|c_type_decl
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|did_one
operator|&&
name|last_type
operator|==
name|type
condition|)
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
else|else
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"%s\n%s "
argument_list|,
name|did_one
condition|?
literal|";"
else|:
literal|""
argument_list|,
name|ctype
argument_list|)
expr_stmt|;
name|extern_out
argument_list|(
name|outfile
argument_list|,
name|es
operator|=
operator|&
name|extsymtab
index|[
name|e
operator|->
name|memno
index|]
argument_list|)
expr_stmt|;
name|proto
argument_list|(
name|outfile
argument_list|,
name|es
operator|->
name|arginfo
argument_list|,
name|es
operator|->
name|fextname
argument_list|)
expr_stmt|;
name|last_type
operator|=
name|type
expr_stmt|;
name|did_one
operator|=
literal|1
expr_stmt|;
block|}
comment|/* for cp = used_builtins */
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|";\n\n"
argument_list|)
expr_stmt|;
block|}
comment|/* if used_builtins */
name|last_type
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|entry
operator|=
name|hashtab
init|;
name|entry
operator|<
name|lasthash
condition|;
operator|++
name|entry
control|)
block|{
name|var
operator|=
name|entry
operator|->
name|varp
expr_stmt|;
if|if
condition|(
name|var
condition|)
block|{
name|int
name|procclass
init|=
name|var
operator|->
name|vprocclass
decl_stmt|;
name|char
modifier|*
name|comment
init|=
name|NULL
decl_stmt|;
name|int
name|stg
init|=
name|var
operator|->
name|vstg
decl_stmt|;
name|int
name|class
init|=
name|var
operator|->
name|vclass
decl_stmt|;
name|type
operator|=
name|var
operator|->
name|vtype
expr_stmt|;
if|if
condition|(
name|var
operator|->
name|vrefused
condition|)
name|refdefs
operator|=
name|mkchain
argument_list|(
operator|(
name|char
operator|*
operator|)
name|var
argument_list|,
name|refdefs
argument_list|)
expr_stmt|;
if|if
condition|(
name|var
operator|->
name|vsubscrused
condition|)
if|if
condition|(
name|ISCOMPLEX
argument_list|(
name|var
operator|->
name|vtype
argument_list|)
condition|)
name|var
operator|->
name|vsubscrused
operator|=
literal|0
expr_stmt|;
else|else
name|refdefs
operator|=
name|mkchain
argument_list|(
operator|(
name|char
operator|*
operator|)
name|var
argument_list|,
name|refdefs
argument_list|)
expr_stmt|;
if|if
condition|(
name|ONEOF
argument_list|(
name|stg
argument_list|,
name|M
argument_list|(
name|STGARG
argument_list|)
operator||
name|M
argument_list|(
name|STGLENG
argument_list|)
operator||
name|M
argument_list|(
name|STGINIT
argument_list|)
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|useauto1
operator|&&
name|stg
operator|==
name|STGBSS
operator|&&
operator|!
name|var
operator|->
name|vsave
condition|)
name|stg
operator|=
name|STGAUTO
expr_stmt|;
switch|switch
condition|(
name|class
condition|)
block|{
case|case
name|CLVAR
case|:
break|break;
case|case
name|CLPROC
case|:
switch|switch
condition|(
name|procclass
condition|)
block|{
case|case
name|PTHISPROC
case|:
name|extsymtab
index|[
name|var
operator|->
name|vardesc
operator|.
name|varno
index|]
operator|.
name|extype
operator|=
name|type
expr_stmt|;
continue|continue;
case|case
name|PSTFUNCT
case|:
case|case
name|PINTRINSIC
case|:
continue|continue;
case|case
name|PUNKNOWN
case|:
name|err
argument_list|(
literal|"list_decls:  unknown procedure class"
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|PEXTERNAL
case|:
if|if
condition|(
name|stg
operator|==
name|STGUNKNOWN
condition|)
block|{
name|warn1
argument_list|(
literal|"%.64s declared EXTERNAL but never used."
argument_list|,
name|var
operator|->
name|fvarname
argument_list|)
expr_stmt|;
comment|/* to retain names declared EXTERNAL */
comment|/* but not referenced, change	*/
comment|/* "continue" to "stg = STGEXT" */
continue|continue;
block|}
else|else
name|type
operator|=
name|fixexttype
argument_list|(
name|var
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CLUNKNOWN
case|:
comment|/* declared but never used */
continue|continue;
case|case
name|CLPARAM
case|:
continue|continue;
case|case
name|CLNAMELIST
case|:
if|if
condition|(
name|var
operator|->
name|visused
condition|)
name|namelists
operator|=
name|mkchain
argument_list|(
operator|(
name|char
operator|*
operator|)
name|var
argument_list|,
name|namelists
argument_list|)
expr_stmt|;
continue|continue;
default|default:
name|erri
argument_list|(
literal|"list_decls:  can't handle class '%d' yet"
argument_list|,
name|class
argument_list|)
expr_stmt|;
name|Fatal
argument_list|(
name|var
operator|->
name|fvarname
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* switch */
comment|/* Might be equivalenced to a common.  If not, don't process */
if|if
condition|(
name|stg
operator|==
name|STGCOMMON
operator|&&
operator|!
name|var
operator|->
name|vcommequiv
condition|)
continue|continue;
comment|/* Only write the header if system-generated locals, builtins, or    uninitialized equivs were already output */
if|if
condition|(
name|write_header
operator|==
literal|1
operator|&&
operator|(
name|new_vars
operator|||
name|nequiv
operator|||
name|used_builtins
operator|)
operator|&&
name|oneof_stg
argument_list|(
name|var
argument_list|,
name|stg
argument_list|,
name|M
argument_list|(
name|STGBSS
argument_list|)
operator||
name|M
argument_list|(
name|STGEXT
argument_list|)
operator||
name|M
argument_list|(
name|STGAUTO
argument_list|)
operator||
name|M
argument_list|(
name|STGCOMMON
argument_list|)
operator||
name|M
argument_list|(
name|STGEQUIV
argument_list|)
argument_list|)
condition|)
block|{
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"/* Local variables */\n"
argument_list|)
expr_stmt|;
name|write_header
operator|=
literal|2
expr_stmt|;
block|}
name|Alias
operator|=
name|oneof_stg
argument_list|(
name|var
argument_list|,
name|stg
argument_list|,
name|M
argument_list|(
name|STGEQUIV
argument_list|)
operator||
name|M
argument_list|(
name|STGCOMMON
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|Define
operator|=
operator|(
name|Alias
operator|&&
name|def_equivs
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|write_header
condition|)
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|";\n"
argument_list|)
expr_stmt|;
name|def_start
argument_list|(
name|outfile
argument_list|,
name|var
operator|->
name|cvarname
argument_list|,
name|CNULL
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
goto|goto
name|Alias1
goto|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|last_type
operator|&&
name|class
operator|==
name|last_class
operator|&&
name|stg
operator|==
name|last_stg
operator|&&
operator|!
name|write_header
condition|)
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|write_header
operator|&&
name|ONEOF
argument_list|(
name|stg
argument_list|,
name|M
argument_list|(
name|STGBSS
argument_list|)
operator||
name|M
argument_list|(
name|STGEXT
argument_list|)
operator||
name|M
argument_list|(
name|STGAUTO
argument_list|)
operator||
name|M
argument_list|(
name|STGEQUIV
argument_list|)
operator||
name|M
argument_list|(
name|STGCOMMON
argument_list|)
argument_list|)
condition|)
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|";\n"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|stg
condition|)
block|{
case|case
name|STGARG
case|:
case|case
name|STGLENG
case|:
comment|/* Part of the argument list, don't write them out 			   again */
continue|continue;
comment|/* Go back to top of the loop */
case|case
name|STGBSS
case|:
case|case
name|STGEQUIV
case|:
case|case
name|STGCOMMON
case|:
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"static "
argument_list|)
expr_stmt|;
break|break;
case|case
name|STGEXT
case|:
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"extern "
argument_list|)
expr_stmt|;
break|break;
case|case
name|STGAUTO
case|:
break|break;
case|case
name|STGINIT
case|:
case|case
name|STGUNKNOWN
case|:
comment|/* Don't want to touch the initialized data, that will 			   be handled elsewhere.  Unknown data have 			   already been complained about, so skip them */
continue|continue;
default|default:
name|erri
argument_list|(
literal|"list_decls:  can't handle storage class %d"
argument_list|,
name|stg
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* switch */
if|if
condition|(
name|type
operator|==
name|TYCHAR
operator|&&
name|halign
operator|&&
name|class
operator|!=
name|CLPROC
operator|&&
name|ISICON
argument_list|(
name|var
operator|->
name|vleng
argument_list|)
condition|)
block|{
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"struct { %s fill; char val"
argument_list|,
name|halign
argument_list|)
expr_stmt|;
name|x
operator|=
name|wr_char_len
argument_list|(
name|outfile
argument_list|,
name|var
operator|->
name|vdim
argument_list|,
name|var
operator|->
name|vleng
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|%=
name|hsize
condition|)
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"; char fill2[%ld]"
argument_list|,
name|hsize
operator|-
name|x
argument_list|)
expr_stmt|;
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"; } %s_st;\n"
argument_list|,
name|var
operator|->
name|cvarname
argument_list|)
expr_stmt|;
name|def_start
argument_list|(
name|outfile
argument_list|,
name|var
operator|->
name|cvarname
argument_list|,
name|CNULL
argument_list|,
name|var
operator|->
name|cvarname
argument_list|)
expr_stmt|;
name|margin_printf
argument_list|(
name|outfile
argument_list|,
literal|"_st.val\n"
argument_list|)
expr_stmt|;
name|last_type
operator|=
operator|-
literal|1
expr_stmt|;
name|write_header
operator|=
literal|2
expr_stmt|;
continue|continue;
block|}
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"%s "
argument_list|,
name|c_type_decl
argument_list|(
name|type
argument_list|,
name|class
operator|==
name|CLPROC
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* else */
comment|/* Character type is really a string type.  Put out a '*' for variable    length strings, and also for equivalences */
if|if
condition|(
name|type
operator|==
name|TYCHAR
operator|&&
name|class
operator|!=
name|CLPROC
operator|&&
operator|(
operator|!
name|var
operator|->
name|vleng
operator|||
operator|!
name|ISICON
argument_list|(
name|var
operator|->
name|vleng
argument_list|)
operator|)
operator|||
name|oneof_stg
argument_list|(
name|var
argument_list|,
name|stg
argument_list|,
name|M
argument_list|(
name|STGEQUIV
argument_list|)
operator||
name|M
argument_list|(
name|STGCOMMON
argument_list|)
argument_list|)
condition|)
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"*%s"
argument_list|,
name|var
operator|->
name|cvarname
argument_list|)
expr_stmt|;
else|else
block|{
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"%s"
argument_list|,
name|var
operator|->
name|cvarname
argument_list|)
expr_stmt|;
if|if
condition|(
name|class
operator|==
name|CLPROC
condition|)
block|{
name|Argtypes
modifier|*
name|at
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|at
operator|=
name|var
operator|->
name|arginfo
operator|)
operator|&&
name|var
operator|->
name|vprocclass
operator|==
name|PEXTERNAL
condition|)
name|at
operator|=
name|extsymtab
index|[
name|var
operator|->
name|vardesc
operator|.
name|varno
index|]
operator|.
name|arginfo
expr_stmt|;
name|proto
argument_list|(
name|outfile
argument_list|,
name|at
argument_list|,
name|var
operator|->
name|fvarname
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|TYCHAR
operator|&&
name|ISICON
argument_list|(
operator|(
name|var
operator|->
name|vleng
operator|)
argument_list|)
condition|)
name|wr_char_len
argument_list|(
name|outfile
argument_list|,
name|var
operator|->
name|vdim
argument_list|,
operator|(
name|int
operator|)
name|var
operator|->
name|vleng
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|var
operator|->
name|vdim
operator|&&
operator|!
name|oneof_stg
argument_list|(
name|var
argument_list|,
name|stg
argument_list|,
name|M
argument_list|(
name|STGEQUIV
argument_list|)
operator||
name|M
argument_list|(
name|STGCOMMON
argument_list|)
argument_list|)
condition|)
name|comment
operator|=
name|wr_ardecls
argument_list|(
name|outfile
argument_list|,
name|var
operator|->
name|vdim
argument_list|,
literal|1L
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|comment
condition|)
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"%s"
argument_list|,
name|comment
argument_list|)
expr_stmt|;
name|Alias1
label|:
if|if
condition|(
name|Alias
condition|)
block|{
name|char
modifier|*
name|amp
decl_stmt|,
modifier|*
name|lp
decl_stmt|,
modifier|*
name|name
decl_stmt|,
modifier|*
name|rp
decl_stmt|;
name|ftnint
name|voff
init|=
name|var
operator|->
name|voffset
decl_stmt|;
name|int
name|et0
decl_stmt|,
name|expr_type
decl_stmt|,
name|k
decl_stmt|;
name|Extsym
modifier|*
name|E
decl_stmt|;
name|struct
name|Equivblock
modifier|*
name|eb
decl_stmt|;
name|char
name|buf
index|[
literal|16
index|]
decl_stmt|;
comment|/* We DON'T want to use oneof_stg here, because we need to distinguish    between them */
if|if
condition|(
name|stg
operator|==
name|STGEQUIV
condition|)
block|{
name|name
operator|=
name|equiv_name
argument_list|(
name|k
operator|=
name|var
operator|->
name|vardesc
operator|.
name|varno
argument_list|,
name|CNULL
argument_list|)
expr_stmt|;
name|eb
operator|=
name|eqvclass
operator|+
name|k
expr_stmt|;
if|if
condition|(
name|eb
operator|->
name|eqvinit
condition|)
block|{
name|amp
operator|=
literal|"&"
expr_stmt|;
name|et0
operator|=
name|TYERROR
expr_stmt|;
block|}
else|else
block|{
name|amp
operator|=
literal|""
expr_stmt|;
name|et0
operator|=
name|eb
operator|->
name|eqvtype
expr_stmt|;
block|}
name|expr_type
operator|=
name|et0
expr_stmt|;
block|}
else|else
block|{
name|E
operator|=
operator|&
name|extsymtab
index|[
name|var
operator|->
name|vardesc
operator|.
name|varno
index|]
expr_stmt|;
name|sprintf
argument_list|(
name|name
operator|=
name|buf
argument_list|,
literal|"%s%d"
argument_list|,
name|E
operator|->
name|cextname
argument_list|,
name|E
operator|->
name|curno
argument_list|)
expr_stmt|;
name|expr_type
operator|=
name|type
expr_stmt|;
name|et0
operator|=
operator|-
literal|1
expr_stmt|;
name|amp
operator|=
literal|"&"
expr_stmt|;
block|}
comment|/* else */
if|if
condition|(
operator|!
name|Define
condition|)
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|" = "
argument_list|)
expr_stmt|;
if|if
condition|(
name|voff
condition|)
block|{
name|k
operator|=
name|typesize
index|[
name|type
index|]
expr_stmt|;
switch|switch
condition|(
call|(
name|int
call|)
argument_list|(
name|voff
operator|%
name|k
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
name|voff
operator|/=
name|k
expr_stmt|;
name|expr_type
operator|=
name|type
expr_stmt|;
break|break;
case|case
name|SZSHORT
case|:
case|case
name|SZSHORT
operator|+
name|SZLONG
case|:
name|expr_type
operator|=
name|TYSHORT
expr_stmt|;
name|voff
operator|/=
name|SZSHORT
expr_stmt|;
break|break;
case|case
name|SZLONG
case|:
name|expr_type
operator|=
name|TYLONG
expr_stmt|;
name|voff
operator|/=
name|SZLONG
expr_stmt|;
break|break;
default|default:
name|expr_type
operator|=
name|TYCHAR
expr_stmt|;
block|}
block|}
if|if
condition|(
name|expr_type
operator|==
name|type
condition|)
block|{
name|lp
operator|=
name|rp
operator|=
literal|""
expr_stmt|;
if|if
condition|(
name|et0
operator|==
operator|-
literal|1
operator|&&
operator|!
name|voff
condition|)
goto|goto
name|cast
goto|;
block|}
else|else
block|{
name|lp
operator|=
literal|"("
expr_stmt|;
name|rp
operator|=
literal|")"
expr_stmt|;
name|cast
label|:
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"(%s *)"
argument_list|,
name|c_type_decl
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Now worry about computing the offset */
if|if
condition|(
name|voff
condition|)
block|{
if|if
condition|(
name|expr_type
operator|==
name|et0
condition|)
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"%s%s + %ld%s"
argument_list|,
name|lp
argument_list|,
name|name
argument_list|,
name|voff
argument_list|,
name|rp
argument_list|)
expr_stmt|;
else|else
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"%s(%s *)%s%s + %ld%s"
argument_list|,
name|lp
argument_list|,
name|c_type_decl
argument_list|(
name|expr_type
argument_list|,
literal|0
argument_list|)
argument_list|,
name|amp
argument_list|,
name|name
argument_list|,
name|voff
argument_list|,
name|rp
argument_list|)
expr_stmt|;
block|}
else|else
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"%s%s"
argument_list|,
name|amp
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* Always put these at the end of the line */
name|last_type
operator|=
name|last_class
operator|=
name|last_stg
operator|=
operator|-
literal|1
expr_stmt|;
name|write_header
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|Define
condition|)
block|{
name|margin_printf
argument_list|(
name|outfile
argument_list|,
literal|")\n"
argument_list|)
expr_stmt|;
name|write_header
operator|=
literal|2
expr_stmt|;
block|}
continue|continue;
block|}
name|write_header
operator|=
literal|0
expr_stmt|;
name|last_type
operator|=
name|type
expr_stmt|;
name|last_class
operator|=
name|class
expr_stmt|;
name|last_stg
operator|=
name|stg
expr_stmt|;
block|}
comment|/* if (var) */
block|}
comment|/* for (entry = hashtab */
if|if
condition|(
operator|!
name|write_header
condition|)
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|";\n\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|write_header
operator|==
literal|2
condition|)
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* Next, namelists, which may reference equivs */
if|if
condition|(
name|namelists
condition|)
block|{
name|write_namelists
argument_list|(
name|namelists
operator|=
name|revchain
argument_list|(
name|namelists
argument_list|)
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|frchain
argument_list|(
operator|&
name|namelists
argument_list|)
expr_stmt|;
block|}
comment|/* Finally, ioblocks (which may reference equivs and namelists) */
if|if
condition|(
name|iob_list
condition|)
name|write_ioblocks
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|assigned_fmts
condition|)
name|write_assigned_fmts
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|refdefs
condition|)
name|ref_defs
argument_list|(
name|outfile
argument_list|,
name|refdefs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* list_decls */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|do_uninit_equivs
parameter_list|(
name|outfile
parameter_list|,
name|did_one
parameter_list|)
name|FILE
modifier|*
name|outfile
decl_stmt|;
name|int
modifier|*
name|did_one
decl_stmt|;
else|#
directive|else
function|do_uninit_equivs
parameter_list|(
name|FILE
modifier|*
name|outfile
parameter_list|,
name|int
modifier|*
name|did_one
parameter_list|)
endif|#
directive|endif
block|{
specifier|extern
name|int
name|nequiv
decl_stmt|;
name|struct
name|Equivblock
modifier|*
name|eqv
decl_stmt|,
modifier|*
name|lasteqv
init|=
name|eqvclass
operator|+
name|nequiv
decl_stmt|;
name|int
name|k
decl_stmt|,
name|last_type
init|=
operator|-
literal|1
decl_stmt|,
name|t
decl_stmt|;
for|for
control|(
name|eqv
operator|=
name|eqvclass
init|;
name|eqv
operator|<
name|lasteqv
condition|;
name|eqv
operator|++
control|)
if|if
condition|(
operator|!
name|eqv
operator|->
name|eqvinit
operator|&&
name|eqv
operator|->
name|eqvtop
operator|!=
name|eqv
operator|->
name|eqvbottom
condition|)
block|{
if|if
condition|(
operator|!
operator|*
name|did_one
condition|)
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"/* System generated locals */\n"
argument_list|)
expr_stmt|;
name|t
operator|=
name|eqv
operator|->
name|eqvtype
expr_stmt|;
if|if
condition|(
name|last_type
operator|==
name|t
condition|)
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|*
name|did_one
condition|)
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|";\n"
argument_list|)
expr_stmt|;
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"static %s "
argument_list|,
name|c_type_decl
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|k
operator|=
name|typesize
index|[
name|t
index|]
expr_stmt|;
block|}
comment|/* else */
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"%s"
argument_list|,
name|equiv_name
argument_list|(
call|(
name|int
call|)
argument_list|(
name|eqv
operator|-
name|eqvclass
argument_list|)
argument_list|,
name|CNULL
argument_list|)
argument_list|)
expr_stmt|;
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"[%ld]"
argument_list|,
operator|(
name|eqv
operator|->
name|eqvtop
operator|-
name|eqv
operator|->
name|eqvbottom
operator|+
name|k
operator|-
literal|1
operator|)
operator|/
name|k
argument_list|)
expr_stmt|;
name|last_type
operator|=
name|t
expr_stmt|;
operator|*
name|did_one
operator|=
literal|1
expr_stmt|;
block|}
comment|/* if !eqv -> eqvinit */
block|}
end_function

begin_comment
comment|/* do_uninit_equivs */
end_comment

begin_comment
comment|/* wr_ardecls -- Writes the brackets and size for an array    declaration.  Because of the inner workings of the compiler,    multi-dimensional arrays get mapped directly into a one-dimensional    array, so we have to compute the size of the array here.  When the    dimension is greater than 1, a string comment about the original size    is returned */
end_comment

begin_function
name|char
modifier|*
ifdef|#
directive|ifdef
name|KR_headers
name|wr_ardecls
parameter_list|(
name|outfile
parameter_list|,
name|dimp
parameter_list|,
name|size
parameter_list|)
name|FILE
modifier|*
name|outfile
decl_stmt|;
name|struct
name|Dimblock
modifier|*
name|dimp
decl_stmt|;
name|long
name|size
decl_stmt|;
else|#
directive|else
function|wr_ardecls
parameter_list|(
name|FILE
modifier|*
name|outfile
parameter_list|,
name|struct
name|Dimblock
modifier|*
name|dimp
parameter_list|,
name|long
name|size
parameter_list|)
endif|#
directive|endif
block|{
name|int
name|i
decl_stmt|,
name|k
decl_stmt|;
name|ftnint
name|j
decl_stmt|;
specifier|static
name|char
name|buf
index|[
literal|1000
index|]
decl_stmt|;
if|if
condition|(
name|dimp
operator|==
operator|(
expr|struct
name|Dimblock
operator|*
operator|)
name|NULL
condition|)
return|return
name|NULL
return|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"\t/* was "
argument_list|)
expr_stmt|;
comment|/* would like to say  k = sprintf(...), but */
name|k
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|/* BSD doesn't return char transmitted count */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dimp
operator|->
name|ndim
condition|;
name|i
operator|++
control|)
block|{
name|expptr
name|this_size
init|=
name|dimp
operator|->
name|dims
index|[
name|i
index|]
operator|.
name|dimsize
decl_stmt|;
if|if
condition|(
name|ISCONST
argument_list|(
name|this_size
argument_list|)
condition|)
block|{
if|if
condition|(
name|ISINT
argument_list|(
name|this_size
operator|->
name|constblock
operator|.
name|vtype
argument_list|)
condition|)
name|j
operator|=
name|this_size
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
expr_stmt|;
elseif|else
if|if
condition|(
name|ISREAL
argument_list|(
name|this_size
operator|->
name|constblock
operator|.
name|vtype
argument_list|)
condition|)
name|j
operator|=
operator|(
name|ftnint
operator|)
name|this_size
operator|->
name|constblock
operator|.
name|Const
operator|.
name|cd
index|[
literal|0
index|]
expr_stmt|;
else|else
goto|goto
name|non_const
goto|;
name|size
operator|*=
name|j
expr_stmt|;
name|sprintf
argument_list|(
name|buf
operator|+
name|k
argument_list|,
literal|"[%ld]"
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|k
operator|+=
name|strlen
argument_list|(
name|buf
operator|+
name|k
argument_list|)
expr_stmt|;
comment|/* BSD prevents getting strlen from sprintf */
block|}
else|else
block|{
name|non_const
label|:
name|err
argument_list|(
literal|"wr_ardecls:  nonconstant array size"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* for i = 0 */
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"[%ld]"
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buf
operator|+
name|k
argument_list|,
literal|" */"
argument_list|)
expr_stmt|;
return|return
operator|(
name|i
operator|>
literal|1
operator|)
condition|?
name|buf
else|:
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* wr_ardecls */
end_comment

begin_comment
comment|/* ----------------------------------------------------------------------  	The following routines read from the p1 intermediate file.  If    that format changes, only these routines need be changed     ---------------------------------------------------------------------- */
end_comment

begin_function
specifier|static
name|int
ifdef|#
directive|ifdef
name|KR_headers
name|get_p1_token
parameter_list|(
name|infile
parameter_list|)
name|FILE
modifier|*
name|infile
decl_stmt|;
else|#
directive|else
function|get_p1_token
parameter_list|(
name|FILE
modifier|*
name|infile
parameter_list|)
endif|#
directive|endif
block|{
name|int
name|token
init|=
name|P1_UNKNOWN
decl_stmt|;
comment|/* NOT PORTABLE!! */
if|if
condition|(
name|fscanf
argument_list|(
name|infile
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|token
argument_list|)
operator|==
name|EOF
condition|)
return|return
name|P1_EOF
return|;
comment|/* Skip over the ": " */
if|if
condition|(
name|getc
argument_list|(
name|infile
argument_list|)
operator|!=
literal|'\n'
condition|)
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
return|return
name|token
return|;
block|}
end_function

begin_comment
comment|/* get_p1_token */
end_comment

begin_comment
comment|/* Returns a (null terminated) string from the input file */
end_comment

begin_function
specifier|static
name|int
ifdef|#
directive|ifdef
name|KR_headers
name|p1gets
parameter_list|(
name|fp
parameter_list|,
name|str
parameter_list|,
name|size
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|size
decl_stmt|;
else|#
directive|else
function|p1gets
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|char
modifier|*
name|str
parameter_list|,
name|int
name|size
parameter_list|)
endif|#
directive|endif
block|{
name|char
name|c
decl_stmt|;
if|if
condition|(
name|str
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
literal|' '
condition|)
name|ungetc
argument_list|(
name|c
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|fgets
argument_list|(
name|str
argument_list|,
name|size
argument_list|,
name|fp
argument_list|)
condition|)
block|{
name|int
name|length
decl_stmt|;
name|str
index|[
name|size
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|length
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
comment|/* Get rid of the newline */
if|if
condition|(
name|str
index|[
name|length
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|str
index|[
name|length
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|feof
argument_list|(
name|fp
argument_list|)
condition|)
return|return
name|EOF
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* p1gets */
end_comment

begin_function
specifier|static
name|int
ifdef|#
directive|ifdef
name|KR_headers
name|p1get_const
parameter_list|(
name|infile
parameter_list|,
name|type
parameter_list|,
name|resultp
parameter_list|)
name|FILE
modifier|*
name|infile
decl_stmt|;
name|int
name|type
decl_stmt|;
name|struct
name|Constblock
modifier|*
modifier|*
name|resultp
decl_stmt|;
else|#
directive|else
function|p1get_const
parameter_list|(
name|FILE
modifier|*
name|infile
parameter_list|,
name|int
name|type
parameter_list|,
name|struct
name|Constblock
modifier|*
modifier|*
name|resultp
parameter_list|)
endif|#
directive|endif
block|{
name|int
name|status
decl_stmt|;
name|struct
name|Constblock
modifier|*
name|result
decl_stmt|;
if|if
condition|(
name|type
operator|!=
name|TYCHAR
condition|)
block|{
operator|*
name|resultp
operator|=
name|result
operator|=
name|ALLOC
argument_list|(
name|Constblock
argument_list|)
expr_stmt|;
name|result
operator|->
name|tag
operator|=
name|TCONST
expr_stmt|;
name|result
operator|->
name|vtype
operator|=
name|type
expr_stmt|;
block|}
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|TYINT1
case|:
case|case
name|TYSHORT
case|:
case|case
name|TYLONG
case|:
case|case
name|TYLOGICAL
case|:
ifdef|#
directive|ifdef
name|TYQUAD
case|case
name|TYQUAD
case|:
endif|#
directive|endif
case|case
name|TYLOGICAL1
case|:
case|case
name|TYLOGICAL2
case|:
name|status
operator|=
name|p1getd
argument_list|(
name|infile
argument_list|,
operator|&
operator|(
name|result
operator|->
name|Const
operator|.
name|ci
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYREAL
case|:
case|case
name|TYDREAL
case|:
name|status
operator|=
name|p1getf
argument_list|(
name|infile
argument_list|,
operator|&
name|result
operator|->
name|Const
operator|.
name|cds
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|result
operator|->
name|vstg
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|TYCOMPLEX
case|:
case|case
name|TYDCOMPLEX
case|:
name|status
operator|=
name|p1getf
argument_list|(
name|infile
argument_list|,
operator|&
name|result
operator|->
name|Const
operator|.
name|cds
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&&
name|status
operator|!=
name|EOF
condition|)
name|status
operator|=
name|p1getf
argument_list|(
name|infile
argument_list|,
operator|&
name|result
operator|->
name|Const
operator|.
name|cds
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|result
operator|->
name|vstg
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|TYCHAR
case|:
name|status
operator|=
name|fscanf
argument_list|(
name|infile
argument_list|,
literal|"%lx"
argument_list|,
name|resultp
argument_list|)
expr_stmt|;
break|break;
default|default:
name|erri
argument_list|(
literal|"p1get_const:  bad constant type '%d'"
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|status
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* switch */
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/* p1get_const */
end_comment

begin_function
specifier|static
name|int
ifdef|#
directive|ifdef
name|KR_headers
name|p1getd
parameter_list|(
name|infile
parameter_list|,
name|result
parameter_list|)
name|FILE
modifier|*
name|infile
decl_stmt|;
name|long
modifier|*
name|result
decl_stmt|;
else|#
directive|else
function|p1getd
parameter_list|(
name|FILE
modifier|*
name|infile
parameter_list|,
name|long
modifier|*
name|result
parameter_list|)
endif|#
directive|endif
block|{
return|return
name|fscanf
argument_list|(
name|infile
argument_list|,
literal|"%ld"
argument_list|,
name|result
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* p1getd */
end_comment

begin_function
specifier|static
name|int
ifdef|#
directive|ifdef
name|KR_headers
name|p1getf
parameter_list|(
name|infile
parameter_list|,
name|result
parameter_list|)
name|FILE
modifier|*
name|infile
decl_stmt|;
name|char
modifier|*
modifier|*
name|result
decl_stmt|;
else|#
directive|else
function|p1getf
parameter_list|(
name|FILE
modifier|*
name|infile
parameter_list|,
name|char
modifier|*
modifier|*
name|result
parameter_list|)
endif|#
directive|endif
block|{
name|char
name|buf
index|[
literal|1324
index|]
decl_stmt|;
specifier|register
name|int
name|k
decl_stmt|;
name|k
operator|=
name|fscanf
argument_list|(
name|infile
argument_list|,
literal|"%s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|<
literal|1
condition|)
name|k
operator|=
name|EOF
expr_stmt|;
else|else
name|strcpy
argument_list|(
operator|*
name|result
operator|=
name|mem
argument_list|(
name|strlen
argument_list|(
name|buf
argument_list|)
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
name|k
return|;
block|}
end_function

begin_function
specifier|static
name|int
ifdef|#
directive|ifdef
name|KR_headers
name|p1getn
parameter_list|(
name|infile
parameter_list|,
name|count
parameter_list|,
name|result
parameter_list|)
name|FILE
modifier|*
name|infile
decl_stmt|;
name|int
name|count
decl_stmt|;
name|char
modifier|*
modifier|*
name|result
decl_stmt|;
else|#
directive|else
function|p1getn
parameter_list|(
name|FILE
modifier|*
name|infile
parameter_list|,
name|int
name|count
parameter_list|,
name|char
modifier|*
modifier|*
name|result
parameter_list|)
endif|#
directive|endif
block|{
name|char
modifier|*
name|bufptr
decl_stmt|;
name|bufptr
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
operator|*
name|result
operator|=
name|bufptr
expr_stmt|;
for|for
control|(
init|;
operator|!
name|feof
argument_list|(
name|infile
argument_list|)
operator|&&
name|count
operator|>
literal|0
condition|;
name|count
operator|--
control|)
operator|*
name|bufptr
operator|++
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
return|return
name|feof
argument_list|(
name|infile
argument_list|)
condition|?
name|EOF
else|:
literal|1
return|;
block|}
end_function

begin_comment
comment|/* p1getn */
end_comment

begin_function
specifier|static
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|proto
parameter_list|(
name|outfile
parameter_list|,
name|at
parameter_list|,
name|fname
parameter_list|)
name|FILE
modifier|*
name|outfile
decl_stmt|;
name|Argtypes
modifier|*
name|at
decl_stmt|;
name|char
modifier|*
name|fname
decl_stmt|;
else|#
directive|else
function|proto
parameter_list|(
name|FILE
modifier|*
name|outfile
parameter_list|,
name|Argtypes
modifier|*
name|at
parameter_list|,
name|char
modifier|*
name|fname
parameter_list|)
endif|#
directive|endif
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|n
decl_stmt|;
name|char
modifier|*
name|comma
decl_stmt|;
name|Atype
modifier|*
name|atypes
decl_stmt|;
name|Namep
name|np
decl_stmt|;
name|chainp
name|cp
decl_stmt|;
if|if
condition|(
name|at
condition|)
block|{
comment|/* Correct types that we learn on the fly, e.g. 			subroutine gotcha(foo) 			external foo 			call zap(...,foo,...) 			call foo(...) 		*/
name|atypes
operator|=
name|at
operator|->
name|atypes
expr_stmt|;
name|n
operator|=
name|at
operator|->
name|defined
condition|?
name|at
operator|->
name|dnargs
else|:
name|at
operator|->
name|nargs
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|++
operator|<
name|n
condition|;
name|atypes
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|cp
operator|=
name|atypes
operator|->
name|cp
operator|)
condition|)
continue|continue;
name|j
operator|=
name|atypes
operator|->
name|type
expr_stmt|;
do|do
block|{
name|np
operator|=
operator|(
name|Namep
operator|)
name|cp
operator|->
name|datap
expr_stmt|;
name|k
operator|=
name|np
operator|->
name|vtype
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|vclass
operator|==
name|CLPROC
condition|)
block|{
if|if
condition|(
operator|!
name|np
operator|->
name|vimpltype
operator|&&
name|k
condition|)
name|k
operator|+=
literal|200
expr_stmt|;
else|else
block|{
if|if
condition|(
name|j
operator|>=
literal|300
condition|)
name|j
operator|=
name|TYUNKNOWN
operator|+
literal|200
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|j
operator|==
name|k
condition|)
continue|continue;
if|if
condition|(
name|j
operator|>=
literal|300
operator|||
name|j
operator|==
literal|200
operator|&&
name|k
operator|>=
literal|200
condition|)
name|j
operator|=
name|k
expr_stmt|;
else|else
block|{
if|if
condition|(
name|at
operator|->
name|nargs
operator|>=
literal|0
condition|)
name|bad_atypes
argument_list|(
name|at
argument_list|,
name|fname
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
literal|""
argument_list|,
literal|" and"
argument_list|)
expr_stmt|;
goto|goto
name|break2
goto|;
block|}
block|}
do|while
condition|(
name|cp
operator|=
name|cp
operator|->
name|nextp
condition|)
do|;
name|atypes
operator|->
name|type
operator|=
name|j
expr_stmt|;
name|frchain
argument_list|(
operator|&
name|atypes
operator|->
name|cp
argument_list|)
expr_stmt|;
block|}
block|}
name|break2
label|:
if|if
condition|(
name|parens
condition|)
block|{
name|nice_printf
argument_list|(
name|outfile
argument_list|,
name|parens
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|at
operator|||
operator|(
name|n
operator|=
name|at
operator|->
name|defined
condition|?
name|at
operator|->
name|dnargs
else|:
name|at
operator|->
name|nargs
operator|)
operator|<
literal|0
condition|)
block|{
name|nice_printf
argument_list|(
name|outfile
argument_list|,
name|Ansi
operator|==
literal|1
condition|?
literal|"()"
else|:
literal|"(...)"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
name|nice_printf
argument_list|(
name|outfile
argument_list|,
name|Ansi
operator|==
literal|1
condition|?
literal|"(void)"
else|:
literal|"()"
argument_list|)
expr_stmt|;
return|return;
block|}
name|atypes
operator|=
name|at
operator|->
name|atypes
expr_stmt|;
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|comma
operator|=
literal|""
expr_stmt|;
for|for
control|(
init|;
operator|--
name|n
operator|>=
literal|0
condition|;
name|atypes
operator|++
control|)
block|{
name|k
operator|=
name|atypes
operator|->
name|type
expr_stmt|;
if|if
condition|(
name|k
operator|==
name|TYADDR
condition|)
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"%schar **"
argument_list|,
name|comma
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|k
operator|>=
literal|200
condition|)
block|{
name|k
operator|-=
literal|200
expr_stmt|;
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"%s%s"
argument_list|,
name|comma
argument_list|,
name|usedcasts
index|[
name|k
index|]
operator|=
name|casttypes
index|[
name|k
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|k
operator|>=
literal|100
condition|)
name|nice_printf
argument_list|(
name|outfile
argument_list|,
name|k
operator|==
name|TYCHAR
operator|+
literal|100
condition|?
literal|"%s%s *"
else|:
literal|"%s%s"
argument_list|,
name|comma
argument_list|,
name|c_type_decl
argument_list|(
name|k
operator|-
literal|100
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"%s%s *"
argument_list|,
name|comma
argument_list|,
name|c_type_decl
argument_list|(
name|k
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|comma
operator|=
literal|", "
expr_stmt|;
block|}
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|protowrite
parameter_list|(
name|protofile
parameter_list|,
name|type
parameter_list|,
name|name
parameter_list|,
name|e
parameter_list|,
name|lengths
parameter_list|)
name|FILE
modifier|*
name|protofile
decl_stmt|;
name|int
name|type
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|Entrypoint
modifier|*
name|e
decl_stmt|;
name|chainp
name|lengths
decl_stmt|;
else|#
directive|else
function|protowrite
parameter_list|(
name|FILE
modifier|*
name|protofile
parameter_list|,
name|int
name|type
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|Entrypoint
modifier|*
name|e
parameter_list|,
name|chainp
name|lengths
parameter_list|)
endif|#
directive|endif
block|{
specifier|extern
name|char
name|used_rets
index|[]
decl_stmt|;
name|int
name|asave
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|asave
operator|=
name|Ansi
operator|)
condition|)
name|Castargs
operator|=
name|Ansi
operator|=
literal|1
expr_stmt|;
name|nice_printf
argument_list|(
name|protofile
argument_list|,
literal|"extern %s %s"
argument_list|,
name|protorettypes
index|[
name|type
index|]
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|list_arg_types
argument_list|(
name|protofile
argument_list|,
name|e
argument_list|,
name|lengths
argument_list|,
literal|0
argument_list|,
literal|";\n"
argument_list|)
expr_stmt|;
name|used_rets
index|[
name|type
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|Ansi
operator|=
name|asave
operator|)
condition|)
name|Castargs
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|do_p1_1while
parameter_list|(
name|outfile
parameter_list|)
name|FILE
modifier|*
name|outfile
decl_stmt|;
else|#
directive|else
function|do_p1_1while
parameter_list|(
name|FILE
modifier|*
name|outfile
parameter_list|)
endif|#
directive|endif
block|{
if|if
condition|(
operator|*
name|wh_next
condition|)
block|{
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"for(;;) { /* while(complicated condition) */\n"
comment|/*}*/
argument_list|)
expr_stmt|;
name|next_tab
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
block|}
else|else
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"while("
comment|/*)*/
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|do_p1_2while
parameter_list|(
name|infile
parameter_list|,
name|outfile
parameter_list|)
name|FILE
modifier|*
name|infile
decl_stmt|;
name|FILE
modifier|*
name|outfile
decl_stmt|;
else|#
directive|else
function|do_p1_2while
parameter_list|(
name|FILE
modifier|*
name|infile
parameter_list|,
name|FILE
modifier|*
name|outfile
parameter_list|)
endif|#
directive|endif
block|{
name|expptr
name|test
decl_stmt|;
name|test
operator|=
name|do_format
argument_list|(
name|infile
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|wh_next
condition|)
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"if (!("
argument_list|)
expr_stmt|;
name|expr_out
argument_list|(
name|outfile
argument_list|,
name|test
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|wh_next
operator|++
condition|)
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"))\n\tbreak;\n"
argument_list|)
expr_stmt|;
else|else
block|{
name|nice_printf
argument_list|(
name|outfile
argument_list|,
comment|/*(*/
literal|") {\n"
argument_list|)
expr_stmt|;
name|next_tab
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|do_p1_elseifstart
parameter_list|(
name|outfile
parameter_list|)
name|FILE
modifier|*
name|outfile
decl_stmt|;
else|#
directive|else
function|do_p1_elseifstart
parameter_list|(
name|FILE
modifier|*
name|outfile
parameter_list|)
endif|#
directive|endif
block|{
comment|/* with sufficiently illegal input, ei_next == ei_last == 0 is possible */
if|if
condition|(
name|ei_next
operator|<
name|ei_last
operator|&&
operator|*
name|ei_next
operator|++
condition|)
block|{
name|prev_tab
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
name|nice_printf
argument_list|(
name|outfile
argument_list|,
comment|/*{*/
literal|"} else /* if(complicated condition) */ {\n"
comment|/*}*/
argument_list|)
expr_stmt|;
name|next_tab
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

