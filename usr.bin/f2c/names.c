begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**************************************************************** Copyright 1990, 1992 - 1996 by AT&T, Lucent Technologies and Bellcore.  Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that the copyright notice and this permission notice and warranty disclaimer appear in supporting documentation, and that the names of AT&T, Bell Laboratories, Lucent or Bellcore or any of their entities not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  AT&T, Lucent and Bellcore disclaim all warranties with regard to this software, including all implied warranties of merchantability and fitness.  In no event shall AT&T, Lucent or Bellcore be liable for any special, indirect or consequential damages or any damages whatsoever resulting from loss of use, data or profits, whether in an action of contract, negligence or other tortious action, arising out of or in connection with the use or performance of this software. ****************************************************************/
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"names.h"
end_include

begin_include
include|#
directive|include
file|"iob.h"
end_include

begin_comment
comment|/* Names generated by the translator are guaranteed to be unique from the    Fortan names because Fortran does not allow underscores in identifiers,    and all of the system generated names do have underscores.  The various    naming conventions are outlined below:  	FORMAT		APPLICATION    ---------------------------------------------------------------------- 	io_#		temporaries generated by IO calls; these will 			contain the device number (e.g. 5, 6, 0) 	ret_val		function return value, required for complex and 			character functions. 	ret_val_len	length of the return value in character functions  	ssss_len	length of character argument "ssss"  	c_#		member of the literal pool, where # is an 			arbitrary label assigned by the system 	cs_#		short integer constant in the literal pool 	t_#		expression temporary, # is the depth of arguments 			on the stack. 	L#		label "#", given by user in the Fortran program. 			This is unique because Fortran labels are numeric 	pad_#		label on an init field required for alignment 	xxx_init	label on a common block union, if a block data 			requires a separate declaration */
end_comment

begin_comment
comment|/* generate variable references */
end_comment

begin_function
name|char
modifier|*
ifdef|#
directive|ifdef
name|KR_headers
name|c_type_decl
parameter_list|(
name|type
parameter_list|,
name|is_extern
parameter_list|)
name|int
name|type
decl_stmt|;
name|int
name|is_extern
decl_stmt|;
else|#
directive|else
function|c_type_decl
parameter_list|(
name|int
name|type
parameter_list|,
name|int
name|is_extern
parameter_list|)
endif|#
directive|endif
block|{
specifier|static
name|char
name|buff
index|[
literal|100
index|]
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|TYREAL
case|:
if|if
condition|(
operator|!
name|is_extern
operator|||
operator|!
name|forcedouble
condition|)
block|{
name|strcpy
argument_list|(
name|buff
argument_list|,
literal|"real"
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|TYDREAL
case|:
name|strcpy
argument_list|(
name|buff
argument_list|,
literal|"doublereal"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYCOMPLEX
case|:
if|if
condition|(
name|is_extern
condition|)
name|strcpy
argument_list|(
name|buff
argument_list|,
literal|"/* Complex */ VOID"
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|buff
argument_list|,
literal|"complex"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYDCOMPLEX
case|:
if|if
condition|(
name|is_extern
condition|)
name|strcpy
argument_list|(
name|buff
argument_list|,
literal|"/* Double Complex */ VOID"
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|buff
argument_list|,
literal|"doublecomplex"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYADDR
case|:
case|case
name|TYINT1
case|:
case|case
name|TYSHORT
case|:
case|case
name|TYLONG
case|:
ifdef|#
directive|ifdef
name|TYQUAD
case|case
name|TYQUAD
case|:
endif|#
directive|endif
case|case
name|TYLOGICAL1
case|:
case|case
name|TYLOGICAL2
case|:
case|case
name|TYLOGICAL
case|:
name|strcpy
argument_list|(
name|buff
argument_list|,
name|typename
index|[
name|type
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYCHAR
case|:
if|if
condition|(
name|is_extern
condition|)
name|strcpy
argument_list|(
name|buff
argument_list|,
literal|"/* Character */ VOID"
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|buff
argument_list|,
literal|"char"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYUNKNOWN
case|:
name|strcpy
argument_list|(
name|buff
argument_list|,
literal|"UNKNOWN"
argument_list|)
expr_stmt|;
comment|/* If a procedure's type is unknown, assume it's a subroutine */
if|if
condition|(
operator|!
name|is_extern
condition|)
break|break;
comment|/* Subroutines must return an INT, because they might return a label    value.  Even if one doesn't, the caller will EXPECT it to. */
case|case
name|TYSUBR
case|:
name|strcpy
argument_list|(
name|buff
argument_list|,
literal|"/* Subroutine */ int"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYERROR
case|:
name|strcpy
argument_list|(
name|buff
argument_list|,
literal|"ERROR"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYVOID
case|:
name|strcpy
argument_list|(
name|buff
argument_list|,
literal|"void"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYCILIST
case|:
name|strcpy
argument_list|(
name|buff
argument_list|,
literal|"cilist"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYICILIST
case|:
name|strcpy
argument_list|(
name|buff
argument_list|,
literal|"icilist"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYOLIST
case|:
name|strcpy
argument_list|(
name|buff
argument_list|,
literal|"olist"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYCLLIST
case|:
name|strcpy
argument_list|(
name|buff
argument_list|,
literal|"cllist"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYALIST
case|:
name|strcpy
argument_list|(
name|buff
argument_list|,
literal|"alist"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYINLIST
case|:
name|strcpy
argument_list|(
name|buff
argument_list|,
literal|"inlist"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYFTNLEN
case|:
name|strcpy
argument_list|(
name|buff
argument_list|,
literal|"ftnlen"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"BAD DECL '%d'"
argument_list|,
name|type
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* switch */
return|return
name|buff
return|;
block|}
end_function

begin_comment
comment|/* c_type_decl */
end_comment

begin_function
name|char
modifier|*
name|new_func_length
parameter_list|(
name|Void
parameter_list|)
block|{
return|return
literal|"ret_val_len"
return|;
block|}
end_function

begin_function
name|char
modifier|*
ifdef|#
directive|ifdef
name|KR_headers
name|new_arg_length
parameter_list|(
name|arg
parameter_list|)
name|Namep
name|arg
decl_stmt|;
else|#
directive|else
function|new_arg_length
parameter_list|(
name|Namep
name|arg
parameter_list|)
endif|#
directive|endif
block|{
specifier|static
name|char
name|buf
index|[
literal|64
index|]
decl_stmt|;
name|char
modifier|*
name|fmt
init|=
literal|"%s_len"
decl_stmt|,
modifier|*
name|s
init|=
name|arg
operator|->
name|fvarname
decl_stmt|;
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|'r'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|s
operator|+
literal|1
argument_list|,
literal|"et_val"
argument_list|)
condition|)
goto|goto
name|adjust_fmt
goto|;
break|break;
case|case
literal|'h'
case|:
case|case
literal|'i'
case|:
if|if
condition|(
operator|!
name|s
index|[
literal|1
index|]
condition|)
block|{
name|adjust_fmt
label|:
name|fmt
operator|=
literal|"%s_length"
expr_stmt|;
comment|/* avoid conflict with libF77 */
block|}
block|}
name|sprintf
argument_list|(
name|buf
argument_list|,
name|fmt
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_comment
comment|/* new_arg_length */
end_comment

begin_comment
comment|/* declare_new_addr -- Add a new local variable to the function, given a    pointer to an Addrblock structure (which must have the uname_tag set)    This list of idents will be printed in reverse (i.e., chronological)    order */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|declare_new_addr
parameter_list|(
name|addrp
parameter_list|)
name|struct
name|Addrblock
modifier|*
name|addrp
decl_stmt|;
else|#
directive|else
function|declare_new_addr
parameter_list|(
name|struct
name|Addrblock
modifier|*
name|addrp
parameter_list|)
endif|#
directive|endif
block|{
specifier|extern
name|chainp
name|new_vars
decl_stmt|;
name|new_vars
operator|=
name|mkchain
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cpexpr
argument_list|(
operator|(
name|expptr
operator|)
name|addrp
argument_list|)
argument_list|,
name|new_vars
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* declare_new_addr */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|wr_nv_ident_help
parameter_list|(
name|outfile
parameter_list|,
name|addrp
parameter_list|)
name|FILE
modifier|*
name|outfile
decl_stmt|;
name|struct
name|Addrblock
modifier|*
name|addrp
decl_stmt|;
else|#
directive|else
function|wr_nv_ident_help
parameter_list|(
name|FILE
modifier|*
name|outfile
parameter_list|,
name|struct
name|Addrblock
modifier|*
name|addrp
parameter_list|)
endif|#
directive|endif
block|{
name|int
name|eltcount
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|addrp
operator|==
operator|(
expr|struct
name|Addrblock
operator|*
operator|)
name|NULL
condition|)
return|return;
if|if
condition|(
name|addrp
operator|->
name|isarray
condition|)
block|{
name|frexpr
argument_list|(
name|addrp
operator|->
name|memoffset
argument_list|)
expr_stmt|;
name|addrp
operator|->
name|memoffset
operator|=
name|ICON
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|eltcount
operator|=
name|addrp
operator|->
name|ntempelt
expr_stmt|;
name|addrp
operator|->
name|ntempelt
operator|=
literal|0
expr_stmt|;
name|addrp
operator|->
name|isarray
operator|=
literal|0
expr_stmt|;
block|}
comment|/* if */
name|out_addr
argument_list|(
name|outfile
argument_list|,
name|addrp
argument_list|)
expr_stmt|;
if|if
condition|(
name|eltcount
condition|)
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"[%d]"
argument_list|,
name|eltcount
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* wr_nv_ident_help */
end_comment

begin_function
name|int
ifdef|#
directive|ifdef
name|KR_headers
name|nv_type_help
parameter_list|(
name|addrp
parameter_list|)
name|struct
name|Addrblock
modifier|*
name|addrp
decl_stmt|;
else|#
directive|else
function|nv_type_help
parameter_list|(
name|struct
name|Addrblock
modifier|*
name|addrp
parameter_list|)
endif|#
directive|endif
block|{
if|if
condition|(
name|addrp
operator|==
operator|(
expr|struct
name|Addrblock
operator|*
operator|)
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|addrp
operator|->
name|vtype
return|;
block|}
end_function

begin_comment
comment|/* nv_type_help */
end_comment

begin_comment
comment|/* lit_name -- returns a unique identifier for the given literal.  Make    the label useful, when possible.  For example:  	1 -> c_1		(constant 1) 	2 -> c_2		(constant 2) 	1000 -> c_1000		(constant 1000) 	1000000 -> c_b<memno>	(big constant number) 	1.2 -> c_1_2		(constant 1.2) 	1.234345 -> c_b<memno>	(big constant number) 	-1 -> c_n1		(constant -1) 	-1.0 -> c_n1_0		(constant -1.0) 	.true. -> c_true	(constant true) 	.false. -> c_false	(constant false) 	default -> c_b<memno>	(default label) */
end_comment

begin_function
name|char
modifier|*
ifdef|#
directive|ifdef
name|KR_headers
name|lit_name
parameter_list|(
name|litp
parameter_list|)
name|struct
name|Literal
modifier|*
name|litp
decl_stmt|;
else|#
directive|else
function|lit_name
parameter_list|(
name|struct
name|Literal
modifier|*
name|litp
parameter_list|)
endif|#
directive|endif
block|{
specifier|static
name|char
name|buf
index|[
name|CONST_IDENT_MAX
index|]
decl_stmt|;
name|ftnint
name|val
decl_stmt|;
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|litp
operator|==
operator|(
expr|struct
name|Literal
operator|*
operator|)
name|NULL
condition|)
return|return
name|NULL
return|;
switch|switch
condition|(
name|litp
operator|->
name|littype
condition|)
block|{
case|case
name|TYINT1
case|:
name|val
operator|=
name|litp
operator|->
name|litval
operator|.
name|litival
expr_stmt|;
if|if
condition|(
name|val
operator|>=
literal|256
operator|||
name|val
operator|<
operator|-
literal|255
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"ci1_b%ld"
argument_list|,
name|litp
operator|->
name|litnum
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|val
operator|<
literal|0
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"ci1_n%ld"
argument_list|,
operator|-
name|val
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"ci1__%ld"
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYSHORT
case|:
name|val
operator|=
name|litp
operator|->
name|litval
operator|.
name|litival
expr_stmt|;
if|if
condition|(
name|val
operator|>=
literal|32768
operator|||
name|val
operator|<=
operator|-
literal|32769
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"cs_b%ld"
argument_list|,
name|litp
operator|->
name|litnum
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|val
operator|<
literal|0
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"cs_n%ld"
argument_list|,
operator|-
name|val
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"cs__%ld"
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYLONG
case|:
ifdef|#
directive|ifdef
name|TYQUAD
case|case
name|TYQUAD
case|:
endif|#
directive|endif
name|val
operator|=
name|litp
operator|->
name|litval
operator|.
name|litival
expr_stmt|;
if|if
condition|(
name|val
operator|>=
literal|100000
operator|||
name|val
operator|<=
operator|-
literal|10000
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"c_b%ld"
argument_list|,
name|litp
operator|->
name|litnum
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|val
operator|<
literal|0
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"c_n%ld"
argument_list|,
operator|-
name|val
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"c__%ld"
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYLOGICAL1
case|:
name|fmt
operator|=
literal|"cl1_%s"
expr_stmt|;
goto|goto
name|spr_logical
goto|;
case|case
name|TYLOGICAL2
case|:
name|fmt
operator|=
literal|"cl2_%s"
expr_stmt|;
goto|goto
name|spr_logical
goto|;
case|case
name|TYLOGICAL
case|:
name|fmt
operator|=
literal|"c_%s"
expr_stmt|;
name|spr_logical
label|:
name|sprintf
argument_list|(
name|buf
argument_list|,
name|fmt
argument_list|,
operator|(
name|litp
operator|->
name|litval
operator|.
name|litival
condition|?
literal|"true"
else|:
literal|"false"
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYREAL
case|:
case|case
name|TYDREAL
case|:
comment|/* Given a limit of 6 or 8 character on external names,	*/
comment|/* few f.p. values can be meaningfully encoded in the	*/
comment|/* constant name.  Just going with the default cb_#	*/
comment|/* seems to be the best course for floating-point	*/
comment|/* constants.	*/
case|case
name|TYCHAR
case|:
comment|/* Shouldn't be any of these */
case|case
name|TYADDR
case|:
case|case
name|TYCOMPLEX
case|:
case|case
name|TYDCOMPLEX
case|:
case|case
name|TYSUBR
case|:
default|default:
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"c_b%ld"
argument_list|,
name|litp
operator|->
name|litnum
argument_list|)
expr_stmt|;
block|}
comment|/* switch */
return|return
name|buf
return|;
block|}
end_function

begin_comment
comment|/* lit_name */
end_comment

begin_function
name|char
modifier|*
ifdef|#
directive|ifdef
name|KR_headers
name|comm_union_name
parameter_list|(
name|count
parameter_list|)
name|int
name|count
decl_stmt|;
else|#
directive|else
function|comm_union_name
parameter_list|(
name|int
name|count
parameter_list|)
endif|#
directive|endif
block|{
specifier|static
name|char
name|buf
index|[
literal|12
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d"
argument_list|,
name|count
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_comment
comment|/* wr_globals -- after every function has been translated, we need to    output the global declarations, such as the static table of constant    values */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|wr_globals
parameter_list|(
name|outfile
parameter_list|)
name|FILE
modifier|*
name|outfile
decl_stmt|;
else|#
directive|else
function|wr_globals
parameter_list|(
name|FILE
modifier|*
name|outfile
parameter_list|)
endif|#
directive|endif
block|{
name|struct
name|Literal
modifier|*
name|litp
decl_stmt|,
modifier|*
name|lastlit
decl_stmt|;
specifier|extern
name|int
name|hsize
decl_stmt|;
name|char
modifier|*
name|litname
decl_stmt|;
name|int
name|did_one
decl_stmt|,
name|t
decl_stmt|;
name|struct
name|Constblock
name|cb
decl_stmt|;
name|ftnint
name|x
decl_stmt|,
name|y
decl_stmt|;
if|if
condition|(
name|nliterals
operator|==
literal|0
condition|)
return|return;
name|lastlit
operator|=
name|litpool
operator|+
name|nliterals
expr_stmt|;
name|did_one
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|litp
operator|=
name|litpool
init|;
name|litp
operator|<
name|lastlit
condition|;
name|litp
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|litp
operator|->
name|lituse
condition|)
continue|continue;
name|litname
operator|=
name|lit_name
argument_list|(
name|litp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|did_one
condition|)
block|{
name|margin_printf
argument_list|(
name|outfile
argument_list|,
literal|"/* Table of constant values */\n\n"
argument_list|)
expr_stmt|;
name|did_one
operator|=
literal|1
expr_stmt|;
block|}
name|cb
operator|.
name|vtype
operator|=
name|litp
operator|->
name|littype
expr_stmt|;
if|if
condition|(
name|litp
operator|->
name|littype
operator|==
name|TYCHAR
condition|)
block|{
name|x
operator|=
name|litp
operator|->
name|litval
operator|.
name|litival2
index|[
literal|0
index|]
operator|+
name|litp
operator|->
name|litval
operator|.
name|litival2
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|y
operator|=
name|x
operator|%
name|hsize
condition|)
name|x
operator|+=
name|y
operator|=
name|hsize
operator|-
name|y
expr_stmt|;
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"static struct { %s fill; char val[%ld+1];"
argument_list|,
name|halign
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|" char fill2[%ld];"
argument_list|,
name|hsize
operator|-
literal|1
argument_list|)
expr_stmt|;
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|" } %s_st = { 0,"
argument_list|,
name|litname
argument_list|)
expr_stmt|;
name|cb
operator|.
name|vleng
operator|=
name|ICON
argument_list|(
name|litp
operator|->
name|litval
operator|.
name|litival2
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|cb
operator|.
name|Const
operator|.
name|ccp
operator|=
name|litp
operator|->
name|cds
index|[
literal|0
index|]
expr_stmt|;
name|cb
operator|.
name|Const
operator|.
name|ccp1
operator|.
name|blanks
operator|=
name|litp
operator|->
name|litval
operator|.
name|litival2
index|[
literal|1
index|]
operator|+
name|y
expr_stmt|;
name|cb
operator|.
name|vtype
operator|=
name|TYCHAR
expr_stmt|;
name|out_const
argument_list|(
name|outfile
argument_list|,
operator|&
name|cb
argument_list|)
expr_stmt|;
name|frexpr
argument_list|(
name|cb
operator|.
name|vleng
argument_list|)
expr_stmt|;
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|" };\n"
argument_list|)
expr_stmt|;
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"#define %s %s_st.val\n"
argument_list|,
name|litname
argument_list|,
name|litname
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"static %s %s = "
argument_list|,
name|c_type_decl
argument_list|(
name|litp
operator|->
name|littype
argument_list|,
literal|0
argument_list|)
argument_list|,
name|litname
argument_list|)
expr_stmt|;
name|t
operator|=
name|litp
operator|->
name|littype
expr_stmt|;
if|if
condition|(
name|ONEOF
argument_list|(
name|t
argument_list|,
name|MSKREAL
operator||
name|MSKCOMPLEX
argument_list|)
condition|)
block|{
name|cb
operator|.
name|vstg
operator|=
literal|1
expr_stmt|;
name|cb
operator|.
name|Const
operator|.
name|cds
index|[
literal|0
index|]
operator|=
name|litp
operator|->
name|cds
index|[
literal|0
index|]
expr_stmt|;
name|cb
operator|.
name|Const
operator|.
name|cds
index|[
literal|1
index|]
operator|=
name|litp
operator|->
name|cds
index|[
literal|1
index|]
expr_stmt|;
block|}
else|else
block|{
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|cb
operator|.
name|Const
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|litp
operator|->
name|litval
argument_list|,
sizeof|sizeof
argument_list|(
name|cb
operator|.
name|Const
argument_list|)
argument_list|)
expr_stmt|;
name|cb
operator|.
name|vstg
operator|=
literal|0
expr_stmt|;
block|}
name|out_const
argument_list|(
name|outfile
argument_list|,
operator|&
name|cb
argument_list|)
expr_stmt|;
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|";\n"
argument_list|)
expr_stmt|;
block|}
comment|/* for */
if|if
condition|(
name|did_one
condition|)
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* wr_globals */
end_comment

begin_function
name|ftnint
ifdef|#
directive|ifdef
name|KR_headers
name|commlen
parameter_list|(
name|vl
parameter_list|)
specifier|register
name|chainp
name|vl
decl_stmt|;
else|#
directive|else
function|commlen
parameter_list|(
specifier|register
name|chainp
name|vl
parameter_list|)
endif|#
directive|endif
block|{
name|ftnint
name|size
decl_stmt|;
name|int
name|type
decl_stmt|;
name|struct
name|Dimblock
modifier|*
name|t
decl_stmt|;
name|Namep
name|v
decl_stmt|;
while|while
condition|(
name|vl
operator|->
name|nextp
condition|)
name|vl
operator|=
name|vl
operator|->
name|nextp
expr_stmt|;
name|v
operator|=
operator|(
name|Namep
operator|)
name|vl
operator|->
name|datap
expr_stmt|;
name|type
operator|=
name|v
operator|->
name|vtype
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|TYCHAR
condition|)
name|size
operator|=
name|v
operator|->
name|vleng
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
expr_stmt|;
else|else
name|size
operator|=
name|typesize
index|[
name|type
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|t
operator|=
name|v
operator|->
name|vdim
operator|)
operator|&&
name|ISCONST
argument_list|(
name|t
operator|->
name|nelt
argument_list|)
condition|)
name|size
operator|*=
name|t
operator|->
name|nelt
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
expr_stmt|;
return|return
name|size
operator|+
name|v
operator|->
name|voffset
return|;
block|}
end_function

begin_function
specifier|static
name|void
comment|/* Pad common block if an EQUIVALENCE extended it. */
ifdef|#
directive|ifdef
name|KR_headers
name|pad_common
parameter_list|(
name|c
parameter_list|)
name|Extsym
modifier|*
name|c
decl_stmt|;
else|#
directive|else
function|pad_common
parameter_list|(
name|Extsym
modifier|*
name|c
parameter_list|)
endif|#
directive|endif
block|{
specifier|register
name|chainp
name|cvl
decl_stmt|;
specifier|register
name|Namep
name|v
decl_stmt|;
name|long
name|L
init|=
name|c
operator|->
name|maxleng
decl_stmt|;
name|int
name|type
decl_stmt|;
name|struct
name|Dimblock
modifier|*
name|t
decl_stmt|;
name|int
name|szshort
init|=
name|typesize
index|[
name|TYSHORT
index|]
decl_stmt|;
for|for
control|(
name|cvl
operator|=
name|c
operator|->
name|allextp
init|;
name|cvl
condition|;
name|cvl
operator|=
name|cvl
operator|->
name|nextp
control|)
if|if
condition|(
name|commlen
argument_list|(
operator|(
name|chainp
operator|)
name|cvl
operator|->
name|datap
argument_list|)
operator|>=
name|L
condition|)
return|return;
name|v
operator|=
name|ALLOC
argument_list|(
name|Nameblock
argument_list|)
expr_stmt|;
name|v
operator|->
name|vtype
operator|=
name|type
operator|=
name|L
operator|%
name|szshort
condition|?
name|TYCHAR
else|:
name|type_choice
index|[
name|L
operator|/
name|szshort
operator|%
literal|4
index|]
expr_stmt|;
name|v
operator|->
name|vstg
operator|=
name|STGCOMMON
expr_stmt|;
name|v
operator|->
name|vclass
operator|=
name|CLVAR
expr_stmt|;
name|v
operator|->
name|tag
operator|=
name|TNAME
expr_stmt|;
name|v
operator|->
name|vdim
operator|=
name|t
operator|=
name|ALLOC
argument_list|(
name|Dimblock
argument_list|)
expr_stmt|;
name|t
operator|->
name|ndim
operator|=
literal|1
expr_stmt|;
name|t
operator|->
name|dims
index|[
literal|0
index|]
operator|.
name|dimsize
operator|=
name|ICON
argument_list|(
name|L
operator|/
name|typesize
index|[
name|type
index|]
argument_list|)
expr_stmt|;
name|v
operator|->
name|fvarname
operator|=
name|v
operator|->
name|cvarname
operator|=
literal|"eqv_pad"
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|TYCHAR
condition|)
name|v
operator|->
name|vleng
operator|=
name|ICON
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|c
operator|->
name|allextp
operator|=
name|mkchain
argument_list|(
operator|(
name|char
operator|*
operator|)
name|mkchain
argument_list|(
operator|(
name|char
operator|*
operator|)
name|v
argument_list|,
name|CHNULL
argument_list|)
argument_list|,
name|c
operator|->
name|allextp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* wr_common_decls -- outputs the common declarations in one of three    formats.  If all references to a common block look the same (field    names and types agree), only one actual declaration will appear.    Otherwise, the same block will require many structs.  If there is no    block data, these structs will be union'ed together (so the linker    knows the size of the largest one).  If there IS a block data, only    that version will be associated with the variable, others will only be    defined as types, so the pointer can be cast to it.  e.g.  	FORTRAN				C ---------------------------------------------------------------------- 	common /com1/ a, b, c		struct { real a, b, c; } com1_;  	common /com1/ a, b, c		union { 	common /com1/ i, j, k		    struct { real a, b, c; } _1; 					    struct { integer i, j, k; } _2; 					} com1_;  	common /com1/ a, b, c		struct com1_1_ { real a, b, c; }; 	block data			struct { integer i, j, k; } com1_ = 	common /com1/ i, j, k		  { 1, 2, 3 }; 	data i/1/, j/2/, k/3/      All of these versions will be followed by #defines, since the code in    the function bodies can't know ahead of time which of these options    will be taken */
end_comment

begin_comment
comment|/* Macros for deciding the output type */
end_comment

begin_define
define|#
directive|define
name|ONE_STRUCT
value|1
end_define

begin_define
define|#
directive|define
name|UNION_STRUCT
value|2
end_define

begin_define
define|#
directive|define
name|INIT_STRUCT
value|3
end_define

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|wr_common_decls
parameter_list|(
name|outfile
parameter_list|)
name|FILE
modifier|*
name|outfile
decl_stmt|;
else|#
directive|else
function|wr_common_decls
parameter_list|(
name|FILE
modifier|*
name|outfile
parameter_list|)
endif|#
directive|endif
block|{
name|Extsym
modifier|*
name|ext
decl_stmt|;
specifier|extern
name|int
name|extcomm
decl_stmt|;
specifier|static
name|char
modifier|*
name|Extern
index|[
literal|4
index|]
init|=
block|{
literal|""
block|,
literal|"Extern "
block|,
literal|"extern "
block|}
decl_stmt|;
name|char
modifier|*
name|E
decl_stmt|,
modifier|*
name|E0
init|=
name|Extern
index|[
name|extcomm
index|]
decl_stmt|;
name|int
name|did_one
init|=
literal|0
decl_stmt|;
for|for
control|(
name|ext
operator|=
name|extsymtab
init|;
name|ext
operator|<
name|nextext
condition|;
name|ext
operator|++
control|)
block|{
if|if
condition|(
name|ext
operator|->
name|extstg
operator|==
name|STGCOMMON
operator|&&
name|ext
operator|->
name|allextp
condition|)
block|{
name|chainp
name|comm
decl_stmt|;
name|int
name|count
init|=
literal|1
decl_stmt|;
name|int
name|which
decl_stmt|;
comment|/* which display to use; 					   ONE_STRUCT, UNION or INIT */
if|if
condition|(
operator|!
name|did_one
condition|)
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"/* Common Block Declarations */\n\n"
argument_list|)
expr_stmt|;
name|pad_common
argument_list|(
name|ext
argument_list|)
expr_stmt|;
comment|/* Construct the proper, condensed list of structs; eliminate duplicates    from the initial list   ext -> allextp   */
name|comm
operator|=
name|ext
operator|->
name|allextp
operator|=
name|revchain
argument_list|(
name|ext
operator|->
name|allextp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ext
operator|->
name|extinit
condition|)
name|which
operator|=
name|INIT_STRUCT
expr_stmt|;
elseif|else
if|if
condition|(
name|comm
operator|->
name|nextp
condition|)
block|{
name|which
operator|=
name|UNION_STRUCT
expr_stmt|;
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"%sunion {\n"
argument_list|,
name|E0
argument_list|)
expr_stmt|;
name|next_tab
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
name|E
operator|=
literal|""
expr_stmt|;
block|}
else|else
block|{
name|which
operator|=
name|ONE_STRUCT
expr_stmt|;
name|E
operator|=
name|E0
expr_stmt|;
block|}
for|for
control|(
init|;
name|comm
condition|;
name|comm
operator|=
name|comm
operator|->
name|nextp
operator|,
name|count
operator|++
control|)
block|{
if|if
condition|(
name|which
operator|==
name|INIT_STRUCT
condition|)
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"struct %s%d_ {\n"
argument_list|,
name|ext
operator|->
name|cextname
argument_list|,
name|count
argument_list|)
expr_stmt|;
else|else
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"%sstruct {\n"
argument_list|,
name|E
argument_list|)
expr_stmt|;
name|next_tab
argument_list|(
name|c_file
argument_list|)
expr_stmt|;
name|wr_struct
argument_list|(
name|outfile
argument_list|,
operator|(
name|chainp
operator|)
name|comm
operator|->
name|datap
argument_list|)
expr_stmt|;
name|prev_tab
argument_list|(
name|c_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|which
operator|==
name|UNION_STRUCT
condition|)
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"} _%d;\n"
argument_list|,
name|count
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|which
operator|==
name|ONE_STRUCT
condition|)
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"} %s;\n"
argument_list|,
name|ext
operator|->
name|cextname
argument_list|)
expr_stmt|;
else|else
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"};\n"
argument_list|)
expr_stmt|;
block|}
comment|/* for */
if|if
condition|(
name|which
operator|==
name|UNION_STRUCT
condition|)
block|{
name|prev_tab
argument_list|(
name|c_file
argument_list|)
expr_stmt|;
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"} %s;\n"
argument_list|,
name|ext
operator|->
name|cextname
argument_list|)
expr_stmt|;
block|}
comment|/* if */
name|did_one
operator|=
literal|1
expr_stmt|;
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|1
operator|,
name|comm
operator|=
name|ext
operator|->
name|allextp
init|;
name|comm
condition|;
name|comm
operator|=
name|comm
operator|->
name|nextp
operator|,
name|count
operator|++
control|)
block|{
name|def_start
argument_list|(
name|outfile
argument_list|,
name|ext
operator|->
name|cextname
argument_list|,
name|comm_union_name
argument_list|(
name|count
argument_list|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|which
condition|)
block|{
case|case
name|ONE_STRUCT
case|:
name|extern_out
argument_list|(
name|outfile
argument_list|,
name|ext
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNION_STRUCT
case|:
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|extern_out
argument_list|(
name|outfile
argument_list|,
name|ext
argument_list|)
expr_stmt|;
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"._%d)"
argument_list|,
name|count
argument_list|)
expr_stmt|;
break|break;
case|case
name|INIT_STRUCT
case|:
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"(*(struct "
argument_list|)
expr_stmt|;
name|extern_out
argument_list|(
name|outfile
argument_list|,
name|ext
argument_list|)
expr_stmt|;
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"%d_ *)&"
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|extern_out
argument_list|(
name|outfile
argument_list|,
name|ext
argument_list|)
expr_stmt|;
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* switch */
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/* for count = 1, comm = ext -> allextp */
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/* if ext -> extstg == STGCOMMON */
block|}
comment|/* for ext = extsymtab */
block|}
end_function

begin_comment
comment|/* wr_common_decls */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|wr_struct
parameter_list|(
name|outfile
parameter_list|,
name|var_list
parameter_list|)
name|FILE
modifier|*
name|outfile
decl_stmt|;
name|chainp
name|var_list
decl_stmt|;
else|#
directive|else
function|wr_struct
parameter_list|(
name|FILE
modifier|*
name|outfile
parameter_list|,
name|chainp
name|var_list
parameter_list|)
endif|#
directive|endif
block|{
name|int
name|last_type
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|did_one
init|=
literal|0
decl_stmt|;
name|chainp
name|this_var
decl_stmt|;
for|for
control|(
name|this_var
operator|=
name|var_list
init|;
name|this_var
condition|;
name|this_var
operator|=
name|this_var
operator|->
name|nextp
control|)
block|{
name|Namep
name|var
init|=
operator|(
name|Namep
operator|)
name|this_var
operator|->
name|datap
decl_stmt|;
name|int
name|type
decl_stmt|;
name|char
modifier|*
name|comment
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|var
operator|==
operator|(
name|Namep
operator|)
name|NULL
condition|)
name|err
argument_list|(
literal|"wr_struct:  null variable"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|var
operator|->
name|tag
operator|!=
name|TNAME
condition|)
name|erri
argument_list|(
literal|"wr_struct:  bad tag on variable '%d'"
argument_list|,
name|var
operator|->
name|tag
argument_list|)
expr_stmt|;
name|type
operator|=
name|var
operator|->
name|vtype
expr_stmt|;
if|if
condition|(
name|last_type
operator|==
name|type
operator|&&
name|did_one
condition|)
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|did_one
condition|)
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|";\n"
argument_list|)
expr_stmt|;
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"%s "
argument_list|,
name|c_type_decl
argument_list|(
name|type
argument_list|,
name|var
operator|->
name|vclass
operator|==
name|CLPROC
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* else */
comment|/* Character type is really a string type.  Put out a '*' for parameters    with unknown length and functions returning character */
if|if
condition|(
name|var
operator|->
name|vtype
operator|==
name|TYCHAR
operator|&&
operator|(
operator|!
name|ISICON
argument_list|(
operator|(
name|var
operator|->
name|vleng
operator|)
argument_list|)
operator|||
name|var
operator|->
name|vclass
operator|==
name|CLPROC
operator|)
condition|)
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"*"
argument_list|)
expr_stmt|;
name|var
operator|->
name|vstg
operator|=
name|STGAUTO
expr_stmt|;
name|out_name
argument_list|(
name|outfile
argument_list|,
name|var
argument_list|)
expr_stmt|;
if|if
condition|(
name|var
operator|->
name|vclass
operator|==
name|CLPROC
condition|)
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"()"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|var
operator|->
name|vdim
condition|)
name|comment
operator|=
name|wr_ardecls
argument_list|(
name|outfile
argument_list|,
name|var
operator|->
name|vdim
argument_list|,
name|var
operator|->
name|vtype
operator|==
name|TYCHAR
operator|&&
name|ISICON
argument_list|(
name|var
operator|->
name|vleng
argument_list|)
condition|?
name|var
operator|->
name|vleng
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
else|:
literal|1L
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|var
operator|->
name|vtype
operator|==
name|TYCHAR
operator|&&
name|var
operator|->
name|vclass
operator|!=
name|CLPROC
operator|&&
name|ISICON
argument_list|(
operator|(
name|var
operator|->
name|vleng
operator|)
argument_list|)
condition|)
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"[%ld]"
argument_list|,
name|var
operator|->
name|vleng
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
argument_list|)
expr_stmt|;
if|if
condition|(
name|comment
condition|)
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"%s"
argument_list|,
name|comment
argument_list|)
expr_stmt|;
name|did_one
operator|=
literal|1
expr_stmt|;
name|last_type
operator|=
name|type
expr_stmt|;
block|}
comment|/* for this_var */
if|if
condition|(
name|did_one
condition|)
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|";\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* wr_struct */
end_comment

begin_function
name|char
modifier|*
ifdef|#
directive|ifdef
name|KR_headers
name|user_label
parameter_list|(
name|stateno
parameter_list|)
name|ftnint
name|stateno
decl_stmt|;
else|#
directive|else
function|user_label
parameter_list|(
name|ftnint
name|stateno
parameter_list|)
endif|#
directive|endif
block|{
specifier|static
name|char
name|buf
index|[
name|USER_LABEL_MAX
operator|+
literal|1
index|]
decl_stmt|;
specifier|static
name|char
modifier|*
name|Lfmt
index|[
literal|2
index|]
init|=
block|{
literal|"L_%ld"
block|,
literal|"L%ld"
block|}
decl_stmt|;
if|if
condition|(
name|stateno
operator|>=
literal|0
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
name|Lfmt
index|[
name|shiftcase
index|]
argument_list|,
name|stateno
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"L_%s"
argument_list|,
name|extsymtab
index|[
operator|-
literal|1
operator|-
name|stateno
index|]
operator|.
name|fextname
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_comment
comment|/* user_label */
end_comment

begin_function
name|char
modifier|*
ifdef|#
directive|ifdef
name|KR_headers
name|temp_name
parameter_list|(
name|starter
parameter_list|,
name|num
parameter_list|,
name|storage
parameter_list|)
name|char
modifier|*
name|starter
decl_stmt|;
name|int
name|num
decl_stmt|;
name|char
modifier|*
name|storage
decl_stmt|;
else|#
directive|else
function|temp_name
parameter_list|(
name|char
modifier|*
name|starter
parameter_list|,
name|int
name|num
parameter_list|,
name|char
modifier|*
name|storage
parameter_list|)
endif|#
directive|endif
block|{
specifier|static
name|char
name|buf
index|[
name|IDENT_LEN
index|]
decl_stmt|;
name|char
modifier|*
name|pointer
init|=
name|buf
decl_stmt|;
name|char
modifier|*
name|prefix
init|=
literal|"t"
decl_stmt|;
if|if
condition|(
name|storage
condition|)
name|pointer
operator|=
name|storage
expr_stmt|;
if|if
condition|(
name|starter
operator|&&
operator|*
name|starter
condition|)
name|prefix
operator|=
name|starter
expr_stmt|;
name|sprintf
argument_list|(
name|pointer
argument_list|,
literal|"%s__%d"
argument_list|,
name|prefix
argument_list|,
name|num
argument_list|)
expr_stmt|;
return|return
name|pointer
return|;
block|}
end_function

begin_comment
comment|/* temp_name */
end_comment

begin_function
name|char
modifier|*
ifdef|#
directive|ifdef
name|KR_headers
name|equiv_name
parameter_list|(
name|memno
parameter_list|,
name|store
parameter_list|)
name|int
name|memno
decl_stmt|;
name|char
modifier|*
name|store
decl_stmt|;
else|#
directive|else
function|equiv_name
parameter_list|(
name|int
name|memno
parameter_list|,
name|char
modifier|*
name|store
parameter_list|)
endif|#
directive|endif
block|{
specifier|static
name|char
name|buf
index|[
name|IDENT_LEN
index|]
decl_stmt|;
name|char
modifier|*
name|pointer
init|=
name|buf
decl_stmt|;
if|if
condition|(
name|store
condition|)
name|pointer
operator|=
name|store
expr_stmt|;
name|sprintf
argument_list|(
name|pointer
argument_list|,
literal|"%s_%d"
argument_list|,
name|EQUIV_INIT_NAME
argument_list|,
name|memno
argument_list|)
expr_stmt|;
return|return
name|pointer
return|;
block|}
end_function

begin_comment
comment|/* equiv_name */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|def_commons
parameter_list|(
name|of
parameter_list|)
name|FILE
modifier|*
name|of
decl_stmt|;
else|#
directive|else
function|def_commons
parameter_list|(
name|FILE
modifier|*
name|of
parameter_list|)
endif|#
directive|endif
block|{
name|Extsym
modifier|*
name|ext
decl_stmt|;
name|int
name|c
decl_stmt|,
name|onefile
decl_stmt|,
name|Union
decl_stmt|;
name|chainp
name|comm
decl_stmt|;
specifier|extern
name|int
name|ext1comm
decl_stmt|;
name|FILE
modifier|*
name|c_filesave
init|=
name|c_file
decl_stmt|;
if|if
condition|(
name|ext1comm
operator|==
literal|1
condition|)
block|{
name|onefile
operator|=
literal|1
expr_stmt|;
name|c_file
operator|=
name|of
expr_stmt|;
name|fprintf
argument_list|(
name|of
argument_list|,
literal|"/*>>>'/dev/null'<<<*/\n\ #ifdef Define_COMMONs\n\ /*<<</dev/null>>>*/\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|onefile
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ext
operator|=
name|extsymtab
init|;
name|ext
operator|<
name|nextext
condition|;
name|ext
operator|++
control|)
if|if
condition|(
name|ext
operator|->
name|extstg
operator|==
name|STGCOMMON
operator|&&
operator|!
name|ext
operator|->
name|extinit
operator|&&
operator|(
name|comm
operator|=
name|ext
operator|->
name|allextp
operator|)
condition|)
block|{
name|sprintf
argument_list|(
name|outbtail
argument_list|,
literal|"%scom.c"
argument_list|,
name|ext
operator|->
name|cextname
argument_list|)
expr_stmt|;
if|if
condition|(
name|onefile
condition|)
name|fprintf
argument_list|(
name|of
argument_list|,
literal|"/*>>>'%s'<<<*/\n"
argument_list|,
name|outbtail
argument_list|)
expr_stmt|;
else|else
block|{
name|c_file
operator|=
name|of
operator|=
name|fopen
argument_list|(
name|outbuf
argument_list|,
name|textwrite
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|of
condition|)
name|fatalstr
argument_list|(
literal|"can't open %s"
argument_list|,
name|outbuf
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|of
argument_list|,
literal|"#include \"f2c.h\"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|Ansi
operator|==
literal|2
condition|)
name|fprintf
argument_list|(
name|of
argument_list|,
literal|"\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|comm
operator|->
name|nextp
condition|)
block|{
name|Union
operator|=
literal|1
expr_stmt|;
name|nice_printf
argument_list|(
name|of
argument_list|,
literal|"union {\n"
argument_list|)
expr_stmt|;
name|next_tab
argument_list|(
name|of
argument_list|)
expr_stmt|;
block|}
else|else
name|Union
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|1
init|;
name|comm
condition|;
name|comm
operator|=
name|comm
operator|->
name|nextp
control|)
block|{
name|nice_printf
argument_list|(
name|of
argument_list|,
literal|"struct {\n"
argument_list|)
expr_stmt|;
name|next_tab
argument_list|(
name|of
argument_list|)
expr_stmt|;
name|wr_struct
argument_list|(
name|of
argument_list|,
operator|(
name|chainp
operator|)
name|comm
operator|->
name|datap
argument_list|)
expr_stmt|;
name|prev_tab
argument_list|(
name|of
argument_list|)
expr_stmt|;
if|if
condition|(
name|Union
condition|)
name|nice_printf
argument_list|(
name|of
argument_list|,
literal|"} _%d;\n"
argument_list|,
name|c
operator|++
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Union
condition|)
name|prev_tab
argument_list|(
name|of
argument_list|)
expr_stmt|;
name|nice_printf
argument_list|(
name|of
argument_list|,
literal|"} %s;\n"
argument_list|,
name|ext
operator|->
name|cextname
argument_list|)
expr_stmt|;
if|if
condition|(
name|Ansi
operator|==
literal|2
condition|)
name|fprintf
argument_list|(
name|of
argument_list|,
literal|"\n#ifdef __cplusplus\n}\n#endif\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|onefile
condition|)
name|fprintf
argument_list|(
name|of
argument_list|,
literal|"/*<<<%s>>>*/\n"
argument_list|,
name|outbtail
argument_list|)
expr_stmt|;
else|else
name|fclose
argument_list|(
name|of
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|onefile
condition|)
name|fprintf
argument_list|(
name|of
argument_list|,
literal|"/*>>>'/dev/null'<<<*/\n#endif\n\ /*<<</dev/null>>>*/\n"
argument_list|)
expr_stmt|;
name|c_file
operator|=
name|c_filesave
expr_stmt|;
block|}
end_function

begin_comment
comment|/* C Language keywords.  Needed to filter unwanted fortran identifiers like  * "int", etc.  Source:  Kernighan& Ritchie, eds. 1 and 2; Stroustrup.  * Also includes C++ keywords and types used for I/O in f2c.h .  * These keywords must be in alphabetical order (as defined by strcmp()).  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|c_keywords
index|[]
init|=
block|{
literal|"Long"
block|,
literal|"Multitype"
block|,
literal|"Namelist"
block|,
literal|"Vardesc"
block|,
literal|"abs"
block|,
literal|"acos"
block|,
literal|"addr"
block|,
literal|"address"
block|,
literal|"aerr"
block|,
literal|"alist"
block|,
literal|"asin"
block|,
literal|"asm"
block|,
literal|"atan"
block|,
literal|"atan2"
block|,
literal|"aunit"
block|,
literal|"auto"
block|,
literal|"break"
block|,
literal|"c"
block|,
literal|"case"
block|,
literal|"catch"
block|,
literal|"cerr"
block|,
literal|"char"
block|,
literal|"ciend"
block|,
literal|"cierr"
block|,
literal|"cifmt"
block|,
literal|"cilist"
block|,
literal|"cirec"
block|,
literal|"ciunit"
block|,
literal|"class"
block|,
literal|"cllist"
block|,
literal|"complex"
block|,
literal|"const"
block|,
literal|"continue"
block|,
literal|"cos"
block|,
literal|"cosh"
block|,
literal|"csta"
block|,
literal|"cunit"
block|,
literal|"d"
block|,
literal|"dabs"
block|,
literal|"default"
block|,
literal|"defined"
block|,
literal|"delete"
block|,
literal|"dims"
block|,
literal|"dmax"
block|,
literal|"dmin"
block|,
literal|"do"
block|,
literal|"double"
block|,
literal|"doublecomplex"
block|,
literal|"doublereal"
block|,
literal|"else"
block|,
literal|"entry"
block|,
literal|"enum"
block|,
literal|"exp"
block|,
literal|"extern"
block|,
literal|"far"
block|,
literal|"flag"
block|,
literal|"float"
block|,
literal|"for"
block|,
literal|"friend"
block|,
literal|"ftnint"
block|,
literal|"ftnlen"
block|,
literal|"goto"
block|,
literal|"h"
block|,
literal|"huge"
block|,
literal|"i"
block|,
literal|"iciend"
block|,
literal|"icierr"
block|,
literal|"icifmt"
block|,
literal|"icilist"
block|,
literal|"icirlen"
block|,
literal|"icirnum"
block|,
literal|"iciunit"
block|,
literal|"if"
block|,
literal|"inacc"
block|,
literal|"inacclen"
block|,
literal|"inblank"
block|,
literal|"inblanklen"
block|,
literal|"include"
block|,
literal|"indir"
block|,
literal|"indirlen"
block|,
literal|"inerr"
block|,
literal|"inex"
block|,
literal|"infile"
block|,
literal|"infilen"
block|,
literal|"infmt"
block|,
literal|"infmtlen"
block|,
literal|"inform"
block|,
literal|"informlen"
block|,
literal|"inline"
block|,
literal|"inlist"
block|,
literal|"inname"
block|,
literal|"innamed"
block|,
literal|"innamlen"
block|,
literal|"innrec"
block|,
literal|"innum"
block|,
literal|"inopen"
block|,
literal|"inrecl"
block|,
literal|"inseq"
block|,
literal|"inseqlen"
block|,
literal|"int"
block|,
literal|"integer"
block|,
literal|"integer1"
block|,
literal|"inunf"
block|,
literal|"inunflen"
block|,
literal|"inunit"
block|,
literal|"log"
block|,
literal|"logical"
block|,
literal|"logical1"
block|,
literal|"long"
block|,
literal|"longint"
block|,
literal|"max"
block|,
literal|"min"
block|,
literal|"name"
block|,
literal|"near"
block|,
literal|"new"
block|,
literal|"nvars"
block|,
literal|"oacc"
block|,
literal|"oblnk"
block|,
literal|"oerr"
block|,
literal|"ofm"
block|,
literal|"ofnm"
block|,
literal|"ofnmlen"
block|,
literal|"olist"
block|,
literal|"operator"
block|,
literal|"orl"
block|,
literal|"osta"
block|,
literal|"ounit"
block|,
literal|"overload"
block|,
literal|"private"
block|,
literal|"protected"
block|,
literal|"public"
block|,
literal|"r"
block|,
literal|"real"
block|,
literal|"register"
block|,
literal|"return"
block|,
literal|"short"
block|,
literal|"shortint"
block|,
literal|"shortlogical"
block|,
literal|"signed"
block|,
literal|"sin"
block|,
literal|"sinh"
block|,
literal|"sizeof"
block|,
literal|"sqrt"
block|,
literal|"static"
block|,
literal|"struct"
block|,
literal|"switch"
block|,
literal|"tan"
block|,
literal|"tanh"
block|,
literal|"template"
block|,
literal|"this"
block|,
literal|"try"
block|,
literal|"type"
block|,
literal|"typedef"
block|,
literal|"uinteger"
block|,
literal|"ulongint"
block|,
literal|"union"
block|,
literal|"unsigned"
block|,
literal|"vars"
block|,
literal|"virtual"
block|,
literal|"void"
block|,
literal|"volatile"
block|,
literal|"while"
block|,
literal|"z"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* c_keywords */
end_comment

begin_decl_stmt
name|int
name|n_keywords
init|=
sizeof|sizeof
argument_list|(
name|c_keywords
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
decl_stmt|;
end_decl_stmt

end_unit

