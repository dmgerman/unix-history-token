begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**************************************************************** Copyright 1990, 1992, 1993, 1994 by AT&T, Lucent Technologies and Bellcore.  Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that the copyright notice and this permission notice and warranty disclaimer appear in supporting documentation, and that the names of AT&T, Bell Laboratories, Lucent or Bellcore or any of their entities not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  AT&T, Lucent and Bellcore disclaim all warranties with regard to this software, including all implied warranties of merchantability and fitness.  In no event shall AT&T, Lucent or Bellcore be liable for any special, indirect or consequential damages or any damages whatsoever resulting from loss of use, data or profits, whether in an action of contract, negligence or other tortious action, arising out of or in connection with the use or performance of this software. ****************************************************************/
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_decl_stmt
specifier|static
name|char
name|Ptok
index|[
literal|128
index|]
decl_stmt|,
name|Pct
index|[
name|Table_size
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|Pfname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|Plineno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|Pbad
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
modifier|*
name|tfirst
decl_stmt|,
modifier|*
name|tlast
decl_stmt|,
modifier|*
name|tnext
decl_stmt|,
name|tmax
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|P_space
value|1
end_define

begin_define
define|#
directive|define
name|P_anum
value|2
end_define

begin_define
define|#
directive|define
name|P_delim
value|3
end_define

begin_define
define|#
directive|define
name|P_slash
value|4
end_define

begin_define
define|#
directive|define
name|TGULP
value|100
end_define

begin_function
specifier|static
name|void
name|trealloc
parameter_list|(
name|Void
parameter_list|)
block|{
name|int
name|k
init|=
name|tmax
decl_stmt|;
name|tfirst
operator|=
operator|(
name|int
operator|*
operator|)
name|realloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tfirst
argument_list|,
operator|(
name|tmax
operator|+=
name|TGULP
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tfirst
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Pfile: realloc failure!\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
name|tlast
operator|=
name|tfirst
operator|+
name|tmax
expr_stmt|;
name|tnext
operator|=
name|tfirst
operator|+
name|k
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|badchar
parameter_list|(
name|c
parameter_list|)
name|int
name|c
decl_stmt|;
else|#
directive|else
function|badchar
parameter_list|(
name|int
name|c
parameter_list|)
endif|#
directive|endif
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"unexpected character 0x%.2x = '%c' on line %ld of %s\n"
argument_list|,
name|c
argument_list|,
name|c
argument_list|,
name|Plineno
argument_list|,
name|Pfname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bad_type
parameter_list|(
name|Void
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"unexpected type \"%s\" on line %ld of %s\n"
argument_list|,
name|Ptok
argument_list|,
name|Plineno
argument_list|,
name|Pfname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|badflag
parameter_list|(
name|tname
parameter_list|,
name|option
parameter_list|)
name|char
modifier|*
name|tname
decl_stmt|;
name|char
modifier|*
name|option
decl_stmt|;
else|#
directive|else
function|badflag
parameter_list|(
name|char
modifier|*
name|tname
parameter_list|,
name|char
modifier|*
name|option
parameter_list|)
endif|#
directive|endif
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s type from `f2c -%s` on line %ld of %s\n"
argument_list|,
name|tname
argument_list|,
name|option
argument_list|,
name|Plineno
argument_list|,
name|Pfname
argument_list|)
expr_stmt|;
name|Pbad
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|detected
parameter_list|(
name|msg
parameter_list|)
name|char
modifier|*
name|msg
decl_stmt|;
else|#
directive|else
function|detected
parameter_list|(
name|char
modifier|*
name|msg
parameter_list|)
endif|#
directive|endif
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%sdetected on line %ld of %s\n"
argument_list|,
name|msg
argument_list|,
name|Plineno
argument_list|,
name|Pfname
argument_list|)
expr_stmt|;
name|Pbad
operator|++
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_ifdef
unit|static void
ifdef|#
directive|ifdef
name|KR_headers
end_ifdef

begin_else
unit|checklogical(k) 	int k;
else|#
directive|else
end_else

begin_endif
unit|checklogical(int k)
endif|#
directive|endif
end_endif

begin_else
unit|{ 	static int lastmsg = 0; 	static int seen[2] = {0,0};  	seen[k] = 1; 	if (seen[1-k]) { 		if (lastmsg< 3) { 			lastmsg = 3; 			detected( 	"Illegal combination of LOGICAL types -- mixing -I4 with -I2 or -i2\n\t"); 			} 		return; 		} 	if (k) { 		if (tylogical == TYLONG || lastmsg>= 2) 			return; 		if (!lastmsg) { 			lastmsg = 2; 			badflag("LOGICAL", "I4"); 			} 		} 	else { 		if (tylogical == TYSHORT || lastmsg& 1) 			return; 		if (!lastmsg) { 			lastmsg = 1; 			badflag("LOGICAL", "i2` or `f2c -I2"); 			} 		} 	}
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|checklogical
parameter_list|(
name|n
parameter_list|)
end_define

begin_comment
comment|/* */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|checkreal
parameter_list|(
name|k
parameter_list|)
name|int
name|k
decl_stmt|;
else|#
directive|else
function|checkreal
parameter_list|(
name|int
name|k
parameter_list|)
endif|#
directive|endif
block|{
specifier|static
name|int
name|warned
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|seen
index|[
literal|2
index|]
init|=
block|{
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|seen
index|[
name|k
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|seen
index|[
literal|1
operator|-
name|k
index|]
condition|)
block|{
if|if
condition|(
name|warned
operator|<
literal|2
condition|)
name|detected
argument_list|(
literal|"Illegal mixture of -R and -!R "
argument_list|)
expr_stmt|;
name|warned
operator|=
literal|2
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|k
operator|==
name|forcedouble
operator|||
name|warned
condition|)
return|return;
name|warned
operator|=
literal|1
expr_stmt|;
name|badflag
argument_list|(
literal|"REAL return"
argument_list|,
name|k
condition|?
literal|"!R"
else|:
literal|"R"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|Pnotboth
parameter_list|(
name|e
parameter_list|)
name|Extsym
modifier|*
name|e
decl_stmt|;
else|#
directive|else
function|Pnotboth
parameter_list|(
name|Extsym
modifier|*
name|e
parameter_list|)
endif|#
directive|endif
block|{
if|if
condition|(
name|e
operator|->
name|curno
condition|)
return|return;
name|Pbad
operator|++
expr_stmt|;
name|e
operator|->
name|curno
operator|=
literal|1
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s cannot be both a procedure and a common block (line %ld of %s)\n"
argument_list|,
name|e
operator|->
name|fextname
argument_list|,
name|Plineno
argument_list|,
name|Pfname
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
ifdef|#
directive|ifdef
name|KR_headers
name|numread
parameter_list|(
name|pf
parameter_list|,
name|n
parameter_list|)
specifier|register
name|FILE
modifier|*
name|pf
decl_stmt|;
name|int
modifier|*
name|n
decl_stmt|;
else|#
directive|else
function|numread
parameter_list|(
specifier|register
name|FILE
modifier|*
name|pf
parameter_list|,
name|int
modifier|*
name|n
parameter_list|)
endif|#
directive|endif
block|{
specifier|register
name|int
name|c
decl_stmt|,
name|k
decl_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|pf
argument_list|)
operator|)
operator|<
literal|'0'
operator|||
name|c
operator|>
literal|'9'
condition|)
return|return
name|c
return|;
name|k
operator|=
name|c
operator|-
literal|'0'
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|pf
argument_list|)
operator|)
operator|==
literal|' '
condition|)
block|{
operator|*
name|n
operator|=
name|k
expr_stmt|;
return|return
name|c
return|;
block|}
if|if
condition|(
name|c
operator|<
literal|'0'
operator|||
name|c
operator|>
literal|'9'
condition|)
break|break;
name|k
operator|=
literal|10
operator|*
name|k
operator|+
name|c
operator|-
literal|'0'
expr_stmt|;
block|}
return|return
name|c
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|argverify
name|Argdcl
argument_list|(
operator|(
name|int
operator|,
name|Extsym
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|Pbadret
name|Argdcl
argument_list|(
operator|(
name|int
name|ftype
operator|,
name|Extsym
operator|*
name|p
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
ifdef|#
directive|ifdef
name|KR_headers
name|readref
parameter_list|(
name|pf
parameter_list|,
name|e
parameter_list|,
name|ftype
parameter_list|)
specifier|register
name|FILE
modifier|*
name|pf
decl_stmt|;
name|Extsym
modifier|*
name|e
decl_stmt|;
name|int
name|ftype
decl_stmt|;
else|#
directive|else
function|readref
parameter_list|(
specifier|register
name|FILE
modifier|*
name|pf
parameter_list|,
name|Extsym
modifier|*
name|e
parameter_list|,
name|int
name|ftype
parameter_list|)
endif|#
directive|endif
block|{
specifier|register
name|int
name|c
decl_stmt|,
modifier|*
name|t
decl_stmt|;
name|int
name|i
decl_stmt|,
name|nargs
decl_stmt|,
name|type
decl_stmt|;
name|Argtypes
modifier|*
name|at
decl_stmt|;
name|Atype
modifier|*
name|a
decl_stmt|,
modifier|*
name|ae
decl_stmt|;
if|if
condition|(
name|ftype
operator|>
name|TYSUBR
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|c
operator|=
name|numread
argument_list|(
name|pf
argument_list|,
operator|&
name|nargs
argument_list|)
operator|)
operator|!=
literal|' '
condition|)
block|{
if|if
condition|(
name|c
operator|!=
literal|':'
condition|)
return|return
name|c
operator|==
name|EOF
return|;
comment|/* just a typed external */
if|if
condition|(
name|e
operator|->
name|extstg
operator|==
name|STGUNKNOWN
condition|)
block|{
name|at
operator|=
literal|0
expr_stmt|;
goto|goto
name|justsym
goto|;
block|}
if|if
condition|(
name|e
operator|->
name|extstg
operator|==
name|STGEXT
condition|)
block|{
if|if
condition|(
name|e
operator|->
name|extype
operator|!=
name|ftype
condition|)
name|Pbadret
argument_list|(
name|ftype
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
else|else
name|Pnotboth
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|tnext
operator|=
name|tfirst
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nargs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
name|numread
argument_list|(
name|pf
argument_list|,
operator|&
name|type
argument_list|)
operator|)
operator|!=
literal|' '
operator|||
name|type
operator|>=
literal|500
operator|||
name|type
operator|!=
name|TYFTNLEN
operator|+
literal|100
operator|&&
name|type
operator|%
literal|100
operator|>
name|TYSUBR
condition|)
return|return
name|c
operator|==
name|EOF
return|;
if|if
condition|(
name|tnext
operator|>=
name|tlast
condition|)
name|trealloc
argument_list|()
expr_stmt|;
operator|*
name|tnext
operator|++
operator|=
name|type
expr_stmt|;
block|}
if|if
condition|(
name|e
operator|->
name|extstg
operator|==
name|STGUNKNOWN
condition|)
block|{
name|save_at
label|:
name|at
operator|=
operator|(
name|Argtypes
operator|*
operator|)
name|gmem
argument_list|(
sizeof|sizeof
argument_list|(
name|Argtypes
argument_list|)
operator|+
operator|(
name|nargs
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|Atype
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|at
operator|->
name|dnargs
operator|=
name|at
operator|->
name|nargs
operator|=
name|nargs
expr_stmt|;
name|at
operator|->
name|changes
operator|=
literal|0
expr_stmt|;
name|t
operator|=
name|tfirst
expr_stmt|;
name|a
operator|=
name|at
operator|->
name|atypes
expr_stmt|;
for|for
control|(
name|ae
operator|=
name|a
operator|+
name|nargs
init|;
name|a
operator|<
name|ae
condition|;
name|a
operator|++
control|)
block|{
name|a
operator|->
name|type
operator|=
operator|*
name|t
operator|++
expr_stmt|;
name|a
operator|->
name|cp
operator|=
literal|0
expr_stmt|;
block|}
name|justsym
label|:
name|e
operator|->
name|extstg
operator|=
name|STGEXT
expr_stmt|;
name|e
operator|->
name|extype
operator|=
name|ftype
expr_stmt|;
name|e
operator|->
name|arginfo
operator|=
name|at
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|e
operator|->
name|extstg
operator|!=
name|STGEXT
condition|)
block|{
name|Pnotboth
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|e
operator|->
name|arginfo
condition|)
block|{
if|if
condition|(
name|e
operator|->
name|extype
operator|!=
name|ftype
condition|)
name|Pbadret
argument_list|(
name|ftype
argument_list|,
name|e
argument_list|)
expr_stmt|;
else|else
goto|goto
name|save_at
goto|;
block|}
else|else
name|argverify
argument_list|(
name|ftype
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
ifdef|#
directive|ifdef
name|KR_headers
name|comlen
parameter_list|(
name|pf
parameter_list|)
specifier|register
name|FILE
modifier|*
name|pf
decl_stmt|;
else|#
directive|else
function|comlen
parameter_list|(
specifier|register
name|FILE
modifier|*
name|pf
parameter_list|)
endif|#
directive|endif
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|se
decl_stmt|;
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|,
name|cbuf
index|[
literal|128
index|]
decl_stmt|;
name|int
name|refread
decl_stmt|;
name|long
name|L
decl_stmt|;
name|Extsym
modifier|*
name|e
decl_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|pf
argument_list|)
operator|)
operator|==
name|EOF
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|c
operator|==
literal|' '
condition|)
block|{
name|refread
operator|=
literal|0
expr_stmt|;
name|s
operator|=
literal|"comlen "
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|':'
condition|)
block|{
name|refread
operator|=
literal|1
expr_stmt|;
name|s
operator|=
literal|"ref: "
expr_stmt|;
block|}
else|else
block|{
name|ret0
label|:
if|if
condition|(
name|c
operator|==
literal|'*'
condition|)
name|ungetc
argument_list|(
name|c
argument_list|,
name|pf
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
while|while
condition|(
operator|*
name|s
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|pf
argument_list|)
operator|)
operator|==
name|EOF
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|c
operator|!=
operator|*
name|s
operator|++
condition|)
goto|goto
name|ret0
goto|;
block|}
name|s
operator|=
name|buf
expr_stmt|;
name|se
operator|=
name|buf
operator|+
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|pf
argument_list|)
operator|)
operator|==
name|EOF
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|c
operator|==
literal|' '
condition|)
break|break;
if|if
condition|(
name|s
operator|>=
name|se
operator|||
name|Pct
index|[
name|c
index|]
operator|!=
name|P_anum
condition|)
goto|goto
name|ret0
goto|;
operator|*
name|s
operator|++
operator|=
name|c
expr_stmt|;
block|}
operator|*
name|s
operator|--
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|s
operator|<=
name|buf
operator|||
operator|*
name|s
operator|!=
literal|'_'
condition|)
return|return
literal|0
return|;
name|strcpy
argument_list|(
name|cbuf
argument_list|,
name|buf
argument_list|)
expr_stmt|;
operator|*
name|s
operator|--
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'_'
condition|)
block|{
operator|*
name|s
operator|--
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|s
operator|<=
name|buf
condition|)
return|return
literal|0
return|;
block|}
for|for
control|(
name|L
operator|=
literal|0
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|pf
argument_list|)
operator|)
operator|==
name|EOF
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|c
operator|==
literal|' '
condition|)
break|break;
if|if
condition|(
name|c
operator|<
literal|'0'
operator|&&
name|c
operator|>
literal|'9'
condition|)
goto|goto
name|ret0
goto|;
name|L
operator|=
literal|10
operator|*
name|L
operator|+
name|c
operator|-
literal|'0'
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|L
operator|&&
operator|!
name|refread
condition|)
return|return
literal|0
return|;
name|e
operator|=
name|mkext1
argument_list|(
name|buf
argument_list|,
name|cbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|refread
condition|)
return|return
name|readref
argument_list|(
name|pf
argument_list|,
name|e
argument_list|,
operator|(
name|int
operator|)
name|L
argument_list|)
return|;
if|if
condition|(
name|e
operator|->
name|extstg
operator|==
name|STGUNKNOWN
condition|)
block|{
name|e
operator|->
name|extstg
operator|=
name|STGCOMMON
expr_stmt|;
name|e
operator|->
name|maxleng
operator|=
name|L
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|e
operator|->
name|extstg
operator|!=
name|STGCOMMON
condition|)
name|Pnotboth
argument_list|(
name|e
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|e
operator|->
name|maxleng
operator|!=
name|L
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"incompatible lengths for common block %s (line %ld of %s)\n"
argument_list|,
name|buf
argument_list|,
name|Plineno
argument_list|,
name|Pfname
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|maxleng
operator|<
name|L
condition|)
name|e
operator|->
name|maxleng
operator|=
name|L
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
ifdef|#
directive|ifdef
name|KR_headers
name|Ptoken
parameter_list|(
name|pf
parameter_list|,
name|canend
parameter_list|)
name|FILE
modifier|*
name|pf
decl_stmt|;
name|int
name|canend
decl_stmt|;
else|#
directive|else
function|Ptoken
parameter_list|(
name|FILE
modifier|*
name|pf
parameter_list|,
name|int
name|canend
parameter_list|)
endif|#
directive|endif
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|se
decl_stmt|;
name|top
label|:
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
name|getc
argument_list|(
name|pf
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
if|if
condition|(
name|canend
condition|)
return|return
literal|0
return|;
goto|goto
name|badeof
goto|;
block|}
if|if
condition|(
name|Pct
index|[
name|c
index|]
operator|!=
name|P_space
condition|)
break|break;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
name|Plineno
operator|++
expr_stmt|;
block|}
switch|switch
condition|(
name|Pct
index|[
name|c
index|]
condition|)
block|{
case|case
name|P_anum
case|:
if|if
condition|(
name|c
operator|==
literal|'_'
condition|)
name|badchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|s
operator|=
name|Ptok
expr_stmt|;
name|se
operator|=
name|s
operator|+
sizeof|sizeof
argument_list|(
name|Ptok
argument_list|)
operator|-
literal|1
expr_stmt|;
do|do
block|{
if|if
condition|(
name|s
operator|<
name|se
condition|)
operator|*
name|s
operator|++
operator|=
name|c
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|pf
argument_list|)
operator|)
operator|==
name|EOF
condition|)
block|{
name|badeof
label|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"unexpected end of file in %s\n"
argument_list|,
name|Pfname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|Pct
index|[
name|c
index|]
operator|==
name|P_anum
condition|)
do|;
name|ungetc
argument_list|(
name|c
argument_list|,
name|pf
argument_list|)
expr_stmt|;
operator|*
name|s
operator|=
literal|0
expr_stmt|;
return|return
name|P_anum
return|;
case|case
name|P_delim
case|:
return|return
name|c
return|;
case|case
name|P_slash
case|:
if|if
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|pf
argument_list|)
operator|)
operator|!=
literal|'*'
condition|)
block|{
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
goto|goto
name|badeof
goto|;
name|badchar
argument_list|(
literal|'/'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|canend
operator|&&
name|comlen
argument_list|(
name|pf
argument_list|)
condition|)
goto|goto
name|badeof
goto|;
for|for
control|(
init|;
condition|;
control|)
block|{
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|pf
argument_list|)
operator|)
operator|!=
literal|'*'
condition|)
block|{
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
goto|goto
name|badeof
goto|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
name|Plineno
operator|++
expr_stmt|;
block|}
name|slashseek
label|:
switch|switch
condition|(
name|getc
argument_list|(
name|pf
argument_list|)
condition|)
block|{
case|case
literal|'/'
case|:
goto|goto
name|top
goto|;
case|case
name|EOF
case|:
goto|goto
name|badeof
goto|;
case|case
literal|'*'
case|:
goto|goto
name|slashseek
goto|;
block|}
block|}
default|default:
name|badchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
comment|/* NOT REACHED */
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|Pftype
parameter_list|(
name|Void
parameter_list|)
block|{
switch|switch
condition|(
name|Ptok
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'C'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|Ptok
operator|+
literal|1
argument_list|,
literal|"_f"
argument_list|)
condition|)
return|return
name|TYCOMPLEX
return|;
break|break;
case|case
literal|'E'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|Ptok
operator|+
literal|1
argument_list|,
literal|"_f"
argument_list|)
condition|)
block|{
comment|/* TYREAL under forcedouble */
name|checkreal
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
name|TYREAL
return|;
block|}
break|break;
case|case
literal|'H'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|Ptok
operator|+
literal|1
argument_list|,
literal|"_f"
argument_list|)
condition|)
return|return
name|TYCHAR
return|;
break|break;
case|case
literal|'Z'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|Ptok
operator|+
literal|1
argument_list|,
literal|"_f"
argument_list|)
condition|)
return|return
name|TYDCOMPLEX
return|;
break|break;
case|case
literal|'d'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|Ptok
operator|+
literal|1
argument_list|,
literal|"oublereal"
argument_list|)
condition|)
return|return
name|TYDREAL
return|;
break|break;
case|case
literal|'i'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|Ptok
operator|+
literal|1
argument_list|,
literal|"nt"
argument_list|)
condition|)
return|return
name|TYSUBR
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|Ptok
operator|+
literal|1
argument_list|,
literal|"nteger"
argument_list|)
condition|)
return|return
name|TYLONG
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|Ptok
operator|+
literal|1
argument_list|,
literal|"nteger1"
argument_list|)
condition|)
return|return
name|TYINT1
return|;
break|break;
case|case
literal|'l'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|Ptok
operator|+
literal|1
argument_list|,
literal|"ogical"
argument_list|)
condition|)
block|{
name|checklogical
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
name|TYLOGICAL
return|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|Ptok
operator|+
literal|1
argument_list|,
literal|"ogical1"
argument_list|)
condition|)
return|return
name|TYLOGICAL1
return|;
ifdef|#
directive|ifdef
name|TYQUAD
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|Ptok
operator|+
literal|1
argument_list|,
literal|"ongint"
argument_list|)
condition|)
return|return
name|TYQUAD
return|;
endif|#
directive|endif
break|break;
case|case
literal|'r'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|Ptok
operator|+
literal|1
argument_list|,
literal|"eal"
argument_list|)
condition|)
block|{
name|checkreal
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|TYREAL
return|;
block|}
break|break;
case|case
literal|'s'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|Ptok
operator|+
literal|1
argument_list|,
literal|"hortint"
argument_list|)
condition|)
return|return
name|TYSHORT
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|Ptok
operator|+
literal|1
argument_list|,
literal|"hortlogical"
argument_list|)
condition|)
block|{
name|checklogical
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|TYLOGICAL2
return|;
block|}
break|break;
block|}
name|bad_type
argument_list|()
expr_stmt|;
comment|/* NOT REACHED */
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|wanted
parameter_list|(
name|i
parameter_list|,
name|what
parameter_list|)
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|what
decl_stmt|;
else|#
directive|else
function|wanted
parameter_list|(
name|int
name|i
parameter_list|,
name|char
modifier|*
name|what
parameter_list|)
endif|#
directive|endif
block|{
if|if
condition|(
name|i
operator|!=
name|P_anum
condition|)
block|{
name|Ptok
index|[
literal|0
index|]
operator|=
name|i
expr_stmt|;
name|Ptok
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error: expected %s, not \"%s\" (line %ld of %s)\n"
argument_list|,
name|what
argument_list|,
name|Ptok
argument_list|,
name|Plineno
argument_list|,
name|Pfname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
ifdef|#
directive|ifdef
name|KR_headers
name|Ptype
parameter_list|(
name|pf
parameter_list|)
name|FILE
modifier|*
name|pf
decl_stmt|;
else|#
directive|else
function|Ptype
parameter_list|(
name|FILE
modifier|*
name|pf
parameter_list|)
endif|#
directive|endif
block|{
name|int
name|i
decl_stmt|,
name|rv
decl_stmt|;
name|i
operator|=
name|Ptoken
argument_list|(
name|pf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|')'
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|i
operator|!=
name|P_anum
condition|)
name|badchar
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|rv
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|Ptok
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'C'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|Ptok
operator|+
literal|1
argument_list|,
literal|"_fp"
argument_list|)
condition|)
name|rv
operator|=
name|TYCOMPLEX
operator|+
literal|200
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|Ptok
operator|+
literal|1
argument_list|,
literal|"_fp"
argument_list|)
condition|)
name|rv
operator|=
name|TYDREAL
operator|+
literal|200
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
case|case
literal|'R'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|Ptok
operator|+
literal|1
argument_list|,
literal|"_fp"
argument_list|)
condition|)
name|rv
operator|=
name|TYREAL
operator|+
literal|200
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|Ptok
operator|+
literal|1
argument_list|,
literal|"_fp"
argument_list|)
condition|)
name|rv
operator|=
name|TYCHAR
operator|+
literal|200
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|Ptok
operator|+
literal|1
argument_list|,
literal|"_fp"
argument_list|)
condition|)
name|rv
operator|=
name|TYLONG
operator|+
literal|200
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|Ptok
operator|+
literal|1
argument_list|,
literal|"1_fp"
argument_list|)
condition|)
name|rv
operator|=
name|TYINT1
operator|+
literal|200
expr_stmt|;
ifdef|#
directive|ifdef
name|TYQUAD
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|Ptok
operator|+
literal|1
argument_list|,
literal|"8_fp"
argument_list|)
condition|)
name|rv
operator|=
name|TYQUAD
operator|+
literal|200
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|'J'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|Ptok
operator|+
literal|1
argument_list|,
literal|"_fp"
argument_list|)
condition|)
name|rv
operator|=
name|TYSHORT
operator|+
literal|200
expr_stmt|;
break|break;
case|case
literal|'K'
case|:
name|checklogical
argument_list|(
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|Logical
goto|;
case|case
literal|'L'
case|:
name|checklogical
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|Logical
label|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|Ptok
operator|+
literal|1
argument_list|,
literal|"_fp"
argument_list|)
condition|)
name|rv
operator|=
name|TYLOGICAL
operator|+
literal|200
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|Ptok
operator|+
literal|1
argument_list|,
literal|"1_fp"
argument_list|)
condition|)
name|rv
operator|=
name|TYLOGICAL1
operator|+
literal|200
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|Ptok
operator|+
literal|1
argument_list|,
literal|"2_fp"
argument_list|)
condition|)
name|rv
operator|=
name|TYLOGICAL2
operator|+
literal|200
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|Ptok
operator|+
literal|1
argument_list|,
literal|"_fp"
argument_list|)
condition|)
name|rv
operator|=
name|TYSUBR
operator|+
literal|200
expr_stmt|;
break|break;
case|case
literal|'U'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|Ptok
operator|+
literal|1
argument_list|,
literal|"_fp"
argument_list|)
condition|)
name|rv
operator|=
name|TYUNKNOWN
operator|+
literal|300
expr_stmt|;
break|break;
case|case
literal|'Z'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|Ptok
operator|+
literal|1
argument_list|,
literal|"_fp"
argument_list|)
condition|)
name|rv
operator|=
name|TYDCOMPLEX
operator|+
literal|200
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|Ptok
operator|+
literal|1
argument_list|,
literal|"har"
argument_list|)
condition|)
name|rv
operator|=
name|TYCHAR
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|Ptok
operator|+
literal|1
argument_list|,
literal|"omplex"
argument_list|)
condition|)
name|rv
operator|=
name|TYCOMPLEX
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|Ptok
operator|+
literal|1
argument_list|,
literal|"oublereal"
argument_list|)
condition|)
name|rv
operator|=
name|TYDREAL
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|Ptok
operator|+
literal|1
argument_list|,
literal|"oublecomplex"
argument_list|)
condition|)
name|rv
operator|=
name|TYDCOMPLEX
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|Ptok
operator|+
literal|1
argument_list|,
literal|"tnlen"
argument_list|)
condition|)
name|rv
operator|=
name|TYFTNLEN
operator|+
literal|100
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|Ptok
operator|+
literal|1
argument_list|,
literal|"nteger"
argument_list|,
literal|6
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|Ptok
index|[
literal|7
index|]
condition|)
name|rv
operator|=
name|TYLONG
expr_stmt|;
elseif|else
if|if
condition|(
name|Ptok
index|[
literal|7
index|]
operator|==
literal|'1'
operator|&&
operator|!
name|Ptok
index|[
literal|8
index|]
condition|)
name|rv
operator|=
name|TYINT1
expr_stmt|;
block|}
break|break;
case|case
literal|'l'
case|:
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|Ptok
operator|+
literal|1
argument_list|,
literal|"ogical"
argument_list|,
literal|6
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|Ptok
index|[
literal|7
index|]
condition|)
block|{
name|checklogical
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|rv
operator|=
name|TYLOGICAL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Ptok
index|[
literal|7
index|]
operator|==
literal|'1'
operator|&&
operator|!
name|Ptok
index|[
literal|8
index|]
condition|)
name|rv
operator|=
name|TYLOGICAL1
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|TYQUAD
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|Ptok
operator|+
literal|1
argument_list|,
literal|"ongint"
argument_list|)
condition|)
name|rv
operator|=
name|TYQUAD
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|'r'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|Ptok
operator|+
literal|1
argument_list|,
literal|"eal"
argument_list|)
condition|)
name|rv
operator|=
name|TYREAL
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|Ptok
operator|+
literal|1
argument_list|,
literal|"hortint"
argument_list|)
condition|)
name|rv
operator|=
name|TYSHORT
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|Ptok
operator|+
literal|1
argument_list|,
literal|"hortlogical"
argument_list|)
condition|)
block|{
name|checklogical
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|rv
operator|=
name|TYLOGICAL2
expr_stmt|;
block|}
break|break;
case|case
literal|'v'
case|:
if|if
condition|(
name|tnext
operator|==
name|tfirst
operator|&&
operator|!
name|strcmp
argument_list|(
name|Ptok
operator|+
literal|1
argument_list|,
literal|"oid"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|i
operator|=
name|Ptoken
argument_list|(
name|pf
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
comment|/*(*/
literal|')'
condition|)
name|wanted
argument_list|(
name|i
argument_list|,
comment|/*(*/
literal|"\")\""
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
if|if
condition|(
operator|!
name|rv
condition|)
name|bad_type
argument_list|()
expr_stmt|;
if|if
condition|(
name|rv
operator|<
literal|100
operator|&&
operator|(
name|i
operator|=
name|Ptoken
argument_list|(
name|pf
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|'*'
condition|)
name|wanted
argument_list|(
name|i
argument_list|,
literal|"\"*\""
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|Ptoken
argument_list|(
name|pf
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|P_anum
condition|)
name|i
operator|=
name|Ptoken
argument_list|(
name|pf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* skip variable name */
switch|switch
condition|(
name|i
condition|)
block|{
case|case
literal|')'
case|:
name|ungetc
argument_list|(
name|i
argument_list|,
name|pf
argument_list|)
expr_stmt|;
break|break;
case|case
literal|','
case|:
break|break;
default|default:
name|wanted
argument_list|(
name|i
argument_list|,
literal|"\",\" or \")\""
argument_list|)
expr_stmt|;
block|}
return|return
name|rv
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|trimunder
parameter_list|(
name|Void
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
specifier|static
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|;
name|s
operator|=
name|Ptok
operator|+
name|strlen
argument_list|(
name|Ptok
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|!=
literal|'_'
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"warning: %s does not end in _ (line %ld of %s)\n"
argument_list|,
name|Ptok
argument_list|,
name|Plineno
argument_list|,
name|Pfname
argument_list|)
expr_stmt|;
return|return
name|Ptok
return|;
block|}
if|if
condition|(
name|s
index|[
operator|-
literal|1
index|]
operator|==
literal|'_'
condition|)
name|s
operator|--
expr_stmt|;
name|strncpy
argument_list|(
name|buf
argument_list|,
name|Ptok
argument_list|,
name|n
operator|=
name|s
operator|-
name|Ptok
argument_list|)
expr_stmt|;
name|buf
index|[
name|n
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_function
specifier|static
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|Pbadmsg
parameter_list|(
name|msg
parameter_list|,
name|p
parameter_list|)
name|char
modifier|*
name|msg
decl_stmt|;
name|Extsym
modifier|*
name|p
decl_stmt|;
else|#
directive|else
function|Pbadmsg
parameter_list|(
name|char
modifier|*
name|msg
parameter_list|,
name|Extsym
modifier|*
name|p
parameter_list|)
endif|#
directive|endif
block|{
name|Pbad
operator|++
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s for %s (line %ld of %s):\n\t"
argument_list|,
name|msg
argument_list|,
name|p
operator|->
name|fextname
argument_list|,
name|Plineno
argument_list|,
name|Pfname
argument_list|)
expr_stmt|;
name|p
operator|->
name|arginfo
operator|->
name|nargs
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|Pbadret
parameter_list|(
name|ftype
parameter_list|,
name|p
parameter_list|)
name|int
name|ftype
decl_stmt|;
name|Extsym
modifier|*
name|p
decl_stmt|;
else|#
directive|else
function|Pbadret
parameter_list|(
name|int
name|ftype
parameter_list|,
name|Extsym
modifier|*
name|p
parameter_list|)
endif|#
directive|endif
block|{
name|char
name|buf1
index|[
literal|32
index|]
decl_stmt|,
name|buf2
index|[
literal|32
index|]
decl_stmt|;
name|Pbadmsg
argument_list|(
literal|"inconsistent types"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"here %s, previously %s\n"
argument_list|,
name|Argtype
argument_list|(
name|ftype
operator|+
literal|200
argument_list|,
name|buf1
argument_list|)
argument_list|,
name|Argtype
argument_list|(
name|p
operator|->
name|extype
operator|+
literal|200
argument_list|,
name|buf2
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|argverify
parameter_list|(
name|ftype
parameter_list|,
name|p
parameter_list|)
name|int
name|ftype
decl_stmt|;
name|Extsym
modifier|*
name|p
decl_stmt|;
else|#
directive|else
function|argverify
parameter_list|(
name|int
name|ftype
parameter_list|,
name|Extsym
modifier|*
name|p
parameter_list|)
endif|#
directive|endif
block|{
name|Argtypes
modifier|*
name|at
decl_stmt|;
specifier|register
name|Atype
modifier|*
name|aty
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
specifier|register
name|int
modifier|*
name|t
decl_stmt|,
modifier|*
name|te
decl_stmt|;
name|char
name|buf1
index|[
literal|32
index|]
decl_stmt|,
name|buf2
index|[
literal|32
index|]
decl_stmt|;
name|at
operator|=
name|p
operator|->
name|arginfo
expr_stmt|;
if|if
condition|(
name|at
operator|->
name|nargs
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|p
operator|->
name|extype
operator|!=
name|ftype
condition|)
block|{
name|Pbadret
argument_list|(
name|ftype
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return;
block|}
name|t
operator|=
name|tfirst
expr_stmt|;
name|te
operator|=
name|tnext
expr_stmt|;
name|i
operator|=
name|te
operator|-
name|t
expr_stmt|;
if|if
condition|(
name|at
operator|->
name|nargs
operator|!=
name|i
condition|)
block|{
name|j
operator|=
name|at
operator|->
name|nargs
expr_stmt|;
name|Pbadmsg
argument_list|(
literal|"differing numbers of arguments"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"here %d, previously %d\n"
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|aty
operator|=
name|at
operator|->
name|atypes
init|;
name|t
operator|<
name|te
condition|;
name|t
operator|++
operator|,
name|aty
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|t
operator|==
name|aty
operator|->
name|type
condition|)
continue|continue;
name|j
operator|=
name|aty
operator|->
name|type
expr_stmt|;
name|k
operator|=
operator|*
name|t
expr_stmt|;
if|if
condition|(
name|k
operator|>=
literal|300
operator|||
name|k
operator|==
name|j
condition|)
continue|continue;
if|if
condition|(
name|j
operator|>=
literal|300
condition|)
block|{
if|if
condition|(
name|k
operator|>=
literal|200
condition|)
block|{
if|if
condition|(
name|k
operator|==
name|TYUNKNOWN
operator|+
literal|200
condition|)
continue|continue;
if|if
condition|(
name|j
operator|%
literal|100
operator|!=
name|k
operator|-
literal|200
operator|&&
name|k
operator|!=
name|TYSUBR
operator|+
literal|200
operator|&&
name|j
operator|!=
name|TYUNKNOWN
operator|+
literal|300
operator|&&
operator|!
name|type_fixup
argument_list|(
name|at
argument_list|,
name|aty
argument_list|,
name|k
argument_list|)
condition|)
goto|goto
name|badtypes
goto|;
block|}
elseif|else
if|if
condition|(
name|j
operator|%
literal|100
operator|%
name|TYSUBR
operator|!=
name|k
operator|%
name|TYSUBR
operator|&&
operator|!
name|type_fixup
argument_list|(
name|at
argument_list|,
name|aty
argument_list|,
name|k
argument_list|)
condition|)
goto|goto
name|badtypes
goto|;
block|}
elseif|else
if|if
condition|(
name|k
operator|<
literal|200
operator|||
name|j
operator|<
literal|200
condition|)
goto|goto
name|badtypes
goto|;
elseif|else
if|if
condition|(
name|k
operator|==
name|TYUNKNOWN
operator|+
literal|200
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|j
operator|!=
name|TYUNKNOWN
operator|+
literal|200
condition|)
block|{
name|badtypes
label|:
name|Pbadmsg
argument_list|(
literal|"differing calling sequences"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|i
operator|=
name|t
operator|-
name|tfirst
operator|+
literal|1
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"arg %d: here %s, prevously %s\n"
argument_list|,
name|i
argument_list|,
name|Argtype
argument_list|(
name|k
argument_list|,
name|buf1
argument_list|)
argument_list|,
name|Argtype
argument_list|(
name|j
argument_list|,
name|buf2
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* We've subsequently learned the right type, 		   as in the call on zoo below...  			subroutine foo(x, zap) 			external zap 			call goo(zap) 			x = zap(3) 			call zoo(zap) 			end 		 */
name|aty
operator|->
name|type
operator|=
name|k
expr_stmt|;
name|at
operator|->
name|changes
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|newarg
parameter_list|(
name|ftype
parameter_list|,
name|p
parameter_list|)
name|int
name|ftype
decl_stmt|;
name|Extsym
modifier|*
name|p
decl_stmt|;
else|#
directive|else
function|newarg
parameter_list|(
name|int
name|ftype
parameter_list|,
name|Extsym
modifier|*
name|p
parameter_list|)
endif|#
directive|endif
block|{
name|Argtypes
modifier|*
name|at
decl_stmt|;
specifier|register
name|Atype
modifier|*
name|aty
decl_stmt|;
specifier|register
name|int
modifier|*
name|t
decl_stmt|,
modifier|*
name|te
decl_stmt|;
name|int
name|i
decl_stmt|,
name|k
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|extstg
operator|==
name|STGCOMMON
condition|)
block|{
name|Pnotboth
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return;
block|}
name|p
operator|->
name|extstg
operator|=
name|STGEXT
expr_stmt|;
name|p
operator|->
name|extype
operator|=
name|ftype
expr_stmt|;
name|p
operator|->
name|exproto
operator|=
literal|1
expr_stmt|;
name|t
operator|=
name|tfirst
expr_stmt|;
name|te
operator|=
name|tnext
expr_stmt|;
name|i
operator|=
name|te
operator|-
name|t
expr_stmt|;
name|k
operator|=
sizeof|sizeof
argument_list|(
name|Argtypes
argument_list|)
operator|+
operator|(
name|i
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|Atype
argument_list|)
expr_stmt|;
name|at
operator|=
name|p
operator|->
name|arginfo
operator|=
operator|(
name|Argtypes
operator|*
operator|)
name|gmem
argument_list|(
name|k
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|at
operator|->
name|dnargs
operator|=
name|at
operator|->
name|nargs
operator|=
name|i
expr_stmt|;
name|at
operator|->
name|defined
operator|=
name|at
operator|->
name|changes
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|aty
operator|=
name|at
operator|->
name|atypes
init|;
name|t
operator|<
name|te
condition|;
name|aty
operator|++
control|)
block|{
name|aty
operator|->
name|type
operator|=
operator|*
name|t
operator|++
expr_stmt|;
name|aty
operator|->
name|cp
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
ifdef|#
directive|ifdef
name|KR_headers
name|Pfile
parameter_list|(
name|fname
parameter_list|)
name|char
modifier|*
name|fname
decl_stmt|;
else|#
directive|else
function|Pfile
parameter_list|(
name|char
modifier|*
name|fname
parameter_list|)
endif|#
directive|endif
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|ftype
decl_stmt|,
name|i
decl_stmt|;
name|FILE
modifier|*
name|pf
decl_stmt|;
name|Extsym
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|s
operator|=
name|fname
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|s
operator|-
name|fname
operator|<
literal|2
operator|||
name|s
index|[
operator|-
literal|2
index|]
operator|!=
literal|'.'
operator|||
operator|(
name|s
index|[
operator|-
literal|1
index|]
operator|!=
literal|'P'
operator|&&
name|s
index|[
operator|-
literal|1
index|]
operator|!=
literal|'p'
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
operator|(
name|pf
operator|=
name|fopen
argument_list|(
name|fname
argument_list|,
name|textread
argument_list|)
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"can't open %s\n"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
name|Pfname
operator|=
name|fname
expr_stmt|;
name|Plineno
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|Pct
index|[
literal|' '
index|]
condition|)
block|{
for|for
control|(
name|s
operator|=
literal|" \t\n\r\v\f"
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
name|Pct
index|[
operator|*
name|s
index|]
operator|=
name|P_space
expr_stmt|;
for|for
control|(
name|s
operator|=
literal|"*,();"
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
name|Pct
index|[
operator|*
name|s
index|]
operator|=
name|P_delim
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|'0'
init|;
name|i
operator|<=
literal|'9'
condition|;
name|i
operator|++
control|)
name|Pct
index|[
name|i
index|]
operator|=
name|P_anum
expr_stmt|;
for|for
control|(
name|s
operator|=
literal|"abcdefghijklmnopqrstuvwxyz"
init|;
name|i
operator|=
operator|*
name|s
condition|;
name|s
operator|++
control|)
name|Pct
index|[
name|i
index|]
operator|=
name|Pct
index|[
name|i
operator|+
literal|'A'
operator|-
literal|'a'
index|]
operator|=
name|P_anum
expr_stmt|;
name|Pct
index|[
literal|'_'
index|]
operator|=
name|P_anum
expr_stmt|;
name|Pct
index|[
literal|'/'
index|]
operator|=
name|P_slash
expr_stmt|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|i
operator|=
name|Ptoken
argument_list|(
name|pf
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
break|break;
if|if
condition|(
name|i
operator|!=
name|P_anum
operator|||
operator|!
name|strcmp
argument_list|(
name|Ptok
argument_list|,
literal|"extern"
argument_list|)
operator|&&
operator|(
name|i
operator|=
name|Ptoken
argument_list|(
name|pf
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
name|P_anum
condition|)
name|badchar
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|ftype
operator|=
name|Pftype
argument_list|()
expr_stmt|;
name|getname
label|:
if|if
condition|(
operator|(
name|i
operator|=
name|Ptoken
argument_list|(
name|pf
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
name|P_anum
condition|)
name|badchar
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|p
operator|=
name|mkext1
argument_list|(
name|trimunder
argument_list|()
argument_list|,
name|Ptok
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|Ptoken
argument_list|(
name|pf
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|'('
condition|)
name|badchar
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|tnext
operator|=
name|tfirst
expr_stmt|;
while|while
condition|(
name|i
operator|=
name|Ptype
argument_list|(
name|pf
argument_list|)
condition|)
block|{
if|if
condition|(
name|tnext
operator|>=
name|tlast
condition|)
name|trealloc
argument_list|()
expr_stmt|;
operator|*
name|tnext
operator|++
operator|=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|arginfo
condition|)
block|{
name|argverify
argument_list|(
name|ftype
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|arginfo
operator|->
name|nargs
operator|<
literal|0
condition|)
name|newarg
argument_list|(
name|ftype
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
else|else
name|newarg
argument_list|(
name|ftype
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|arginfo
operator|->
name|defined
operator|=
literal|1
expr_stmt|;
name|i
operator|=
name|Ptoken
argument_list|(
name|pf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|i
condition|)
block|{
case|case
literal|';'
case|:
break|break;
case|case
literal|','
case|:
goto|goto
name|getname
goto|;
default|default:
name|wanted
argument_list|(
name|i
argument_list|,
literal|"\";\" or \",\""
argument_list|)
expr_stmt|;
block|}
block|}
name|fclose
argument_list|(
name|pf
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|read_Pfiles
parameter_list|(
name|ffiles
parameter_list|)
name|char
modifier|*
modifier|*
name|ffiles
decl_stmt|;
else|#
directive|else
function|read_Pfiles
parameter_list|(
name|char
modifier|*
modifier|*
name|ffiles
parameter_list|)
endif|#
directive|endif
block|{
name|char
modifier|*
modifier|*
name|f1files
decl_stmt|,
modifier|*
modifier|*
name|f1files0
decl_stmt|,
modifier|*
name|s
decl_stmt|;
name|int
name|k
decl_stmt|;
specifier|register
name|Extsym
modifier|*
name|e
decl_stmt|,
modifier|*
name|ee
decl_stmt|;
specifier|register
name|Argtypes
modifier|*
name|at
decl_stmt|;
specifier|extern
name|int
name|retcode
decl_stmt|;
name|f1files0
operator|=
name|f1files
operator|=
name|ffiles
expr_stmt|;
while|while
condition|(
name|s
operator|=
operator|*
name|ffiles
operator|++
condition|)
if|if
condition|(
operator|!
name|Pfile
argument_list|(
name|s
argument_list|)
condition|)
operator|*
name|f1files
operator|++
operator|=
name|s
expr_stmt|;
if|if
condition|(
name|Pbad
condition|)
name|retcode
operator|=
literal|8
expr_stmt|;
if|if
condition|(
name|tfirst
condition|)
block|{
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tfirst
argument_list|)
expr_stmt|;
comment|/* following should be unnecessary, as we won't be back here */
name|tfirst
operator|=
name|tnext
operator|=
name|tlast
operator|=
literal|0
expr_stmt|;
name|tmax
operator|=
literal|0
expr_stmt|;
block|}
operator|*
name|f1files
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|f1files
operator|==
name|f1files0
condition|)
name|f1files
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|k
operator|=
literal|0
expr_stmt|;
name|ee
operator|=
name|nextext
expr_stmt|;
for|for
control|(
name|e
operator|=
name|extsymtab
init|;
name|e
operator|<
name|ee
condition|;
name|e
operator|++
control|)
if|if
condition|(
name|e
operator|->
name|extstg
operator|==
name|STGEXT
operator|&&
operator|(
name|at
operator|=
name|e
operator|->
name|arginfo
operator|)
condition|)
block|{
if|if
condition|(
name|at
operator|->
name|nargs
operator|<
literal|0
operator|||
name|at
operator|->
name|changes
condition|)
name|k
operator|++
expr_stmt|;
name|at
operator|->
name|changes
operator|=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|k
condition|)
block|{
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"%d prototype%s updated while reading prototypes.\n"
argument_list|,
name|k
argument_list|,
name|k
operator|>
literal|1
condition|?
literal|"s"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
name|fflush
argument_list|(
name|diagfile
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

