begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**************************************************************** Copyright 1990, 1993-6 by AT&T, Lucent Technologies and Bellcore.  Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that the copyright notice and this permission notice and warranty disclaimer appear in supporting documentation, and that the names of AT&T, Bell Laboratories, Lucent or Bellcore or any of their entities not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  AT&T, Lucent and Bellcore disclaim all warranties with regard to this software, including all implied warranties of merchantability and fitness.  In no event shall AT&T, Lucent or Bellcore be liable for any special, indirect or consequential damages or any damages whatsoever resulting from loss of use, data or profits, whether in an action of contract, negligence or other tortious action, arising out of or in connection with the use or performance of this software. ****************************************************************/
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_decl_stmt
specifier|static
name|void
name|eqvcommon
name|Argdcl
argument_list|(
operator|(
expr|struct
name|Equivblock
operator|*
operator|,
name|int
operator|,
name|long
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|eqveqv
name|Argdcl
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
name|long
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nsubs
name|Argdcl
argument_list|(
operator|(
expr|struct
name|Listblock
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ROUTINES RELATED TO EQUIVALENCE CLASS PROCESSING */
end_comment

begin_comment
comment|/* called at end of declarations section to process chains    created by EQUIVALENCE statements  */
end_comment

begin_function
name|void
name|doequiv
parameter_list|(
name|Void
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|inequiv
decl_stmt|;
comment|/* True if one namep occurs in 					   several EQUIV declarations */
name|int
name|comno
decl_stmt|;
comment|/* Index into Extsym table of the last 				   COMMON block seen (implicitly assuming 				   that only one will be given) */
name|int
name|ovarno
decl_stmt|;
name|ftnint
name|comoffset
decl_stmt|;
comment|/* Index into the COMMON block */
name|ftnint
name|offset
decl_stmt|;
comment|/* Offset from array base */
name|ftnint
name|leng
decl_stmt|;
specifier|register
name|struct
name|Equivblock
modifier|*
name|equivdecl
decl_stmt|;
specifier|register
name|struct
name|Eqvchain
modifier|*
name|q
decl_stmt|;
name|struct
name|Primblock
modifier|*
name|primp
decl_stmt|;
specifier|register
name|Namep
name|np
decl_stmt|;
name|int
name|k
decl_stmt|,
name|k1
decl_stmt|,
name|ns
decl_stmt|,
name|pref
decl_stmt|,
name|t
decl_stmt|;
name|chainp
name|cp
decl_stmt|;
specifier|extern
name|int
name|type_pref
index|[]
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nequiv
condition|;
operator|++
name|i
control|)
block|{
comment|/* Handle each equivalence declaration */
name|equivdecl
operator|=
operator|&
name|eqvclass
index|[
name|i
index|]
expr_stmt|;
name|equivdecl
operator|->
name|eqvbottom
operator|=
name|equivdecl
operator|->
name|eqvtop
operator|=
literal|0
expr_stmt|;
name|comno
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|q
operator|=
name|equivdecl
operator|->
name|equivs
init|;
name|q
condition|;
name|q
operator|=
name|q
operator|->
name|eqvnextp
control|)
block|{
name|offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|primp
operator|=
name|q
operator|->
name|eqvitem
operator|.
name|eqvlhs
operator|)
condition|)
continue|continue;
name|vardcl
argument_list|(
name|np
operator|=
name|primp
operator|->
name|namep
argument_list|)
expr_stmt|;
if|if
condition|(
name|primp
operator|->
name|argsp
operator|||
name|primp
operator|->
name|fcharp
condition|)
block|{
name|expptr
name|offp
decl_stmt|;
comment|/* Pad ones onto the end of an array declaration when needed */
if|if
condition|(
name|np
operator|->
name|vdim
operator|!=
name|NULL
operator|&&
name|np
operator|->
name|vdim
operator|->
name|ndim
operator|>
literal|1
operator|&&
name|nsubs
argument_list|(
name|primp
operator|->
name|argsp
argument_list|)
operator|==
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|ftn66flag
condition|)
name|warni
argument_list|(
literal|"1-dim subscript in EQUIVALENCE, %d-dim declared"
argument_list|,
name|np
operator|->
name|vdim
operator|->
name|ndim
argument_list|)
expr_stmt|;
name|cp
operator|=
name|NULL
expr_stmt|;
name|ns
operator|=
name|np
operator|->
name|vdim
operator|->
name|ndim
expr_stmt|;
while|while
condition|(
operator|--
name|ns
operator|>
literal|0
condition|)
name|cp
operator|=
name|mkchain
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ICON
argument_list|(
literal|1
argument_list|)
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|primp
operator|->
name|argsp
operator|->
name|listp
operator|->
name|nextp
operator|=
name|cp
expr_stmt|;
block|}
name|offp
operator|=
name|suboffset
argument_list|(
name|primp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISICON
argument_list|(
name|offp
argument_list|)
condition|)
name|offset
operator|=
name|offp
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
expr_stmt|;
else|else
block|{
name|dclerr
argument_list|(
literal|"nonconstant subscript in equivalence "
argument_list|,
name|np
argument_list|)
expr_stmt|;
name|np
operator|=
name|NULL
expr_stmt|;
block|}
name|frexpr
argument_list|(
name|offp
argument_list|)
expr_stmt|;
block|}
comment|/* Free up the primblock, since we now have a hash table (Namep) entry */
name|frexpr
argument_list|(
operator|(
name|expptr
operator|)
name|primp
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|&&
operator|(
name|leng
operator|=
name|iarrlen
argument_list|(
name|np
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|dclerr
argument_list|(
literal|"adjustable in equivalence"
argument_list|,
name|np
argument_list|)
expr_stmt|;
name|np
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|np
condition|)
switch|switch
condition|(
name|np
operator|->
name|vstg
condition|)
block|{
case|case
name|STGUNKNOWN
case|:
case|case
name|STGBSS
case|:
case|case
name|STGEQUIV
case|:
break|break;
case|case
name|STGCOMMON
case|:
comment|/* The code assumes that all COMMON references in a given EQUIVALENCE will    be to the same COMMON block, and will all be consistent */
name|comno
operator|=
name|np
operator|->
name|vardesc
operator|.
name|varno
expr_stmt|;
name|comoffset
operator|=
name|np
operator|->
name|voffset
operator|+
name|offset
expr_stmt|;
break|break;
default|default:
name|dclerr
argument_list|(
literal|"bad storage class in equivalence"
argument_list|,
name|np
argument_list|)
expr_stmt|;
name|np
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|np
condition|)
block|{
name|q
operator|->
name|eqvoffset
operator|=
name|offset
expr_stmt|;
comment|/* eqvbottom   gets the largest difference between the array base address    and the address specified in the EQUIV declaration */
name|equivdecl
operator|->
name|eqvbottom
operator|=
name|lmin
argument_list|(
name|equivdecl
operator|->
name|eqvbottom
argument_list|,
operator|-
name|offset
argument_list|)
expr_stmt|;
comment|/* eqvtop   gets the largest difference between the end of the array and    the address given in the EQUIVALENCE */
name|equivdecl
operator|->
name|eqvtop
operator|=
name|lmax
argument_list|(
name|equivdecl
operator|->
name|eqvtop
argument_list|,
name|leng
operator|-
name|offset
argument_list|)
expr_stmt|;
block|}
name|q
operator|->
name|eqvitem
operator|.
name|eqvname
operator|=
name|np
expr_stmt|;
block|}
comment|/* Now all equivalenced variables are in the hash table with the proper    offset, and   eqvtop and eqvbottom   are set. */
if|if
condition|(
name|comno
operator|>=
literal|0
condition|)
comment|/* Get rid of all STGEQUIVS, they will be mapped onto STGCOMMON variables    */
name|eqvcommon
argument_list|(
name|equivdecl
argument_list|,
name|comno
argument_list|,
name|comoffset
argument_list|)
expr_stmt|;
else|else
for|for
control|(
name|q
operator|=
name|equivdecl
operator|->
name|equivs
init|;
name|q
condition|;
name|q
operator|=
name|q
operator|->
name|eqvnextp
control|)
block|{
if|if
condition|(
name|np
operator|=
name|q
operator|->
name|eqvitem
operator|.
name|eqvname
condition|)
block|{
name|inequiv
operator|=
name|NO
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|vstg
operator|==
name|STGEQUIV
condition|)
if|if
condition|(
operator|(
name|ovarno
operator|=
name|np
operator|->
name|vardesc
operator|.
name|varno
operator|)
operator|==
name|i
condition|)
block|{
comment|/* Can't EQUIV different elements of the same array */
if|if
condition|(
name|np
operator|->
name|voffset
operator|+
name|q
operator|->
name|eqvoffset
operator|!=
literal|0
condition|)
name|dclerr
argument_list|(
literal|"inconsistent equivalence"
argument_list|,
name|np
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|offset
operator|=
name|np
operator|->
name|voffset
expr_stmt|;
name|inequiv
operator|=
name|YES
expr_stmt|;
block|}
name|np
operator|->
name|vstg
operator|=
name|STGEQUIV
expr_stmt|;
name|np
operator|->
name|vardesc
operator|.
name|varno
operator|=
name|i
expr_stmt|;
name|np
operator|->
name|voffset
operator|=
operator|-
name|q
operator|->
name|eqvoffset
expr_stmt|;
if|if
condition|(
name|inequiv
condition|)
comment|/* Combine 2 equivalence declarations */
name|eqveqv
argument_list|(
name|i
argument_list|,
name|ovarno
argument_list|,
name|q
operator|->
name|eqvoffset
operator|+
name|offset
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Now each equivalence declaration is distinct (all connections have been    merged in eqveqv()), and some may be empty. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nequiv
condition|;
operator|++
name|i
control|)
block|{
name|equivdecl
operator|=
operator|&
name|eqvclass
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|equivdecl
operator|->
name|eqvbottom
operator|!=
literal|0
operator|||
name|equivdecl
operator|->
name|eqvtop
operator|!=
literal|0
condition|)
block|{
comment|/* a live chain */
name|k
operator|=
name|TYCHAR
expr_stmt|;
name|pref
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|q
operator|=
name|equivdecl
operator|->
name|equivs
init|;
name|q
condition|;
name|q
operator|=
name|q
operator|->
name|eqvnextp
control|)
if|if
condition|(
operator|(
name|np
operator|=
name|q
operator|->
name|eqvitem
operator|.
name|eqvname
operator|)
operator|&&
operator|!
name|np
operator|->
name|veqvadjust
condition|)
block|{
name|np
operator|->
name|veqvadjust
operator|=
literal|1
expr_stmt|;
name|np
operator|->
name|voffset
operator|-=
name|equivdecl
operator|->
name|eqvbottom
expr_stmt|;
name|t
operator|=
name|typealign
index|[
name|k1
operator|=
name|np
operator|->
name|vtype
index|]
expr_stmt|;
if|if
condition|(
name|pref
operator|<
name|type_pref
index|[
name|k1
index|]
condition|)
block|{
name|k
operator|=
name|k1
expr_stmt|;
name|pref
operator|=
name|type_pref
index|[
name|k1
index|]
expr_stmt|;
block|}
if|if
condition|(
name|np
operator|->
name|voffset
operator|%
name|t
operator|!=
literal|0
condition|)
block|{
name|dclerr
argument_list|(
literal|"bad alignment forced by equivalence"
argument_list|,
name|np
argument_list|)
expr_stmt|;
operator|--
name|nerr
expr_stmt|;
comment|/* don't give bad return code for this */
block|}
block|}
name|equivdecl
operator|->
name|eqvtype
operator|=
name|k
expr_stmt|;
block|}
name|freqchain
argument_list|(
name|equivdecl
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* put equivalence chain p at common block comno + comoffset */
end_comment

begin_function
name|LOCAL
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|eqvcommon
parameter_list|(
name|p
parameter_list|,
name|comno
parameter_list|,
name|comoffset
parameter_list|)
name|struct
name|Equivblock
modifier|*
name|p
decl_stmt|;
name|int
name|comno
decl_stmt|;
name|ftnint
name|comoffset
decl_stmt|;
else|#
directive|else
function|eqvcommon
parameter_list|(
name|struct
name|Equivblock
modifier|*
name|p
parameter_list|,
name|int
name|comno
parameter_list|,
name|ftnint
name|comoffset
parameter_list|)
endif|#
directive|endif
block|{
name|int
name|ovarno
decl_stmt|;
name|ftnint
name|k
decl_stmt|,
name|offq
decl_stmt|;
specifier|register
name|Namep
name|np
decl_stmt|;
specifier|register
name|struct
name|Eqvchain
modifier|*
name|q
decl_stmt|;
if|if
condition|(
name|comoffset
operator|+
name|p
operator|->
name|eqvbottom
operator|<
literal|0
condition|)
block|{
name|errstr
argument_list|(
literal|"attempt to extend common %s backward"
argument_list|,
name|extsymtab
index|[
name|comno
index|]
operator|.
name|fextname
argument_list|)
expr_stmt|;
name|freqchain
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|k
operator|=
name|comoffset
operator|+
name|p
operator|->
name|eqvtop
operator|)
operator|>
name|extsymtab
index|[
name|comno
index|]
operator|.
name|extleng
condition|)
name|extsymtab
index|[
name|comno
index|]
operator|.
name|extleng
operator|=
name|k
expr_stmt|;
for|for
control|(
name|q
operator|=
name|p
operator|->
name|equivs
init|;
name|q
condition|;
name|q
operator|=
name|q
operator|->
name|eqvnextp
control|)
if|if
condition|(
name|np
operator|=
name|q
operator|->
name|eqvitem
operator|.
name|eqvname
condition|)
block|{
switch|switch
condition|(
name|np
operator|->
name|vstg
condition|)
block|{
case|case
name|STGUNKNOWN
case|:
case|case
name|STGBSS
case|:
name|np
operator|->
name|vstg
operator|=
name|STGCOMMON
expr_stmt|;
name|np
operator|->
name|vcommequiv
operator|=
literal|1
expr_stmt|;
name|np
operator|->
name|vardesc
operator|.
name|varno
operator|=
name|comno
expr_stmt|;
comment|/* np -> voffset   will point to the base of the array */
name|np
operator|->
name|voffset
operator|=
name|comoffset
operator|-
name|q
operator|->
name|eqvoffset
expr_stmt|;
break|break;
case|case
name|STGEQUIV
case|:
name|ovarno
operator|=
name|np
operator|->
name|vardesc
operator|.
name|varno
expr_stmt|;
comment|/* offq   will point to the current element, even if it's in an array */
name|offq
operator|=
name|comoffset
operator|-
name|q
operator|->
name|eqvoffset
operator|-
name|np
operator|->
name|voffset
expr_stmt|;
name|np
operator|->
name|vstg
operator|=
name|STGCOMMON
expr_stmt|;
name|np
operator|->
name|vcommequiv
operator|=
literal|1
expr_stmt|;
name|np
operator|->
name|vardesc
operator|.
name|varno
operator|=
name|comno
expr_stmt|;
comment|/* np -> voffset   will point to the base of the array */
name|np
operator|->
name|voffset
operator|+=
name|offq
expr_stmt|;
if|if
condition|(
name|ovarno
operator|!=
operator|(
name|p
operator|-
name|eqvclass
operator|)
condition|)
name|eqvcommon
argument_list|(
operator|&
name|eqvclass
index|[
name|ovarno
index|]
argument_list|,
name|comno
argument_list|,
name|offq
argument_list|)
expr_stmt|;
break|break;
case|case
name|STGCOMMON
case|:
if|if
condition|(
name|comno
operator|!=
name|np
operator|->
name|vardesc
operator|.
name|varno
operator|||
name|comoffset
operator|!=
name|np
operator|->
name|voffset
operator|+
name|q
operator|->
name|eqvoffset
condition|)
name|dclerr
argument_list|(
literal|"inconsistent common usage"
argument_list|,
name|np
argument_list|)
expr_stmt|;
break|break;
default|default:
name|badstg
argument_list|(
literal|"eqvcommon"
argument_list|,
name|np
operator|->
name|vstg
argument_list|)
expr_stmt|;
block|}
block|}
name|freqchain
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|eqvbottom
operator|=
name|p
operator|->
name|eqvtop
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Move all items on ovarno chain to the front of   nvarno   chain.  * adjust offsets of ovarno elements and top and bottom of nvarno chain  */
end_comment

begin_function
name|LOCAL
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|eqveqv
parameter_list|(
name|nvarno
parameter_list|,
name|ovarno
parameter_list|,
name|delta
parameter_list|)
name|int
name|nvarno
decl_stmt|;
name|int
name|ovarno
decl_stmt|;
name|ftnint
name|delta
decl_stmt|;
else|#
directive|else
function|eqveqv
parameter_list|(
name|int
name|nvarno
parameter_list|,
name|int
name|ovarno
parameter_list|,
name|ftnint
name|delta
parameter_list|)
endif|#
directive|endif
block|{
specifier|register
name|struct
name|Equivblock
modifier|*
name|neweqv
decl_stmt|,
modifier|*
name|oldeqv
decl_stmt|;
specifier|register
name|Namep
name|np
decl_stmt|;
name|struct
name|Eqvchain
modifier|*
name|q
decl_stmt|,
modifier|*
name|q1
decl_stmt|;
name|neweqv
operator|=
name|eqvclass
operator|+
name|nvarno
expr_stmt|;
name|oldeqv
operator|=
name|eqvclass
operator|+
name|ovarno
expr_stmt|;
name|neweqv
operator|->
name|eqvbottom
operator|=
name|lmin
argument_list|(
name|neweqv
operator|->
name|eqvbottom
argument_list|,
name|oldeqv
operator|->
name|eqvbottom
operator|-
name|delta
argument_list|)
expr_stmt|;
name|neweqv
operator|->
name|eqvtop
operator|=
name|lmax
argument_list|(
name|neweqv
operator|->
name|eqvtop
argument_list|,
name|oldeqv
operator|->
name|eqvtop
operator|-
name|delta
argument_list|)
expr_stmt|;
name|oldeqv
operator|->
name|eqvbottom
operator|=
name|oldeqv
operator|->
name|eqvtop
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|q
operator|=
name|oldeqv
operator|->
name|equivs
init|;
name|q
condition|;
name|q
operator|=
name|q1
control|)
block|{
name|q1
operator|=
name|q
operator|->
name|eqvnextp
expr_stmt|;
if|if
condition|(
operator|(
name|np
operator|=
name|q
operator|->
name|eqvitem
operator|.
name|eqvname
operator|)
operator|&&
name|np
operator|->
name|vardesc
operator|.
name|varno
operator|==
name|ovarno
condition|)
block|{
name|q
operator|->
name|eqvnextp
operator|=
name|neweqv
operator|->
name|equivs
expr_stmt|;
name|neweqv
operator|->
name|equivs
operator|=
name|q
expr_stmt|;
name|q
operator|->
name|eqvoffset
operator|+=
name|delta
expr_stmt|;
name|np
operator|->
name|vardesc
operator|.
name|varno
operator|=
name|nvarno
expr_stmt|;
name|np
operator|->
name|voffset
operator|-=
name|delta
expr_stmt|;
block|}
else|else
name|free
argument_list|(
operator|(
name|charptr
operator|)
name|q
argument_list|)
expr_stmt|;
block|}
name|oldeqv
operator|->
name|equivs
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|freqchain
parameter_list|(
name|p
parameter_list|)
specifier|register
name|struct
name|Equivblock
modifier|*
name|p
decl_stmt|;
else|#
directive|else
function|freqchain
parameter_list|(
specifier|register
name|struct
name|Equivblock
modifier|*
name|p
parameter_list|)
endif|#
directive|endif
block|{
specifier|register
name|struct
name|Eqvchain
modifier|*
name|q
decl_stmt|,
modifier|*
name|oq
decl_stmt|;
for|for
control|(
name|q
operator|=
name|p
operator|->
name|equivs
init|;
name|q
condition|;
name|q
operator|=
name|oq
control|)
block|{
name|oq
operator|=
name|q
operator|->
name|eqvnextp
expr_stmt|;
name|free
argument_list|(
operator|(
name|charptr
operator|)
name|q
argument_list|)
expr_stmt|;
block|}
name|p
operator|->
name|equivs
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* nsubs -- number of subscripts in this arglist (just the length of the    list) */
end_comment

begin_function
name|LOCAL
name|int
ifdef|#
directive|ifdef
name|KR_headers
name|nsubs
parameter_list|(
name|p
parameter_list|)
specifier|register
name|struct
name|Listblock
modifier|*
name|p
decl_stmt|;
else|#
directive|else
function|nsubs
parameter_list|(
specifier|register
name|struct
name|Listblock
modifier|*
name|p
parameter_list|)
endif|#
directive|endif
block|{
specifier|register
name|int
name|n
decl_stmt|;
specifier|register
name|chainp
name|q
decl_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p
condition|)
for|for
control|(
name|q
operator|=
name|p
operator|->
name|listp
init|;
name|q
condition|;
name|q
operator|=
name|q
operator|->
name|nextp
control|)
operator|++
name|n
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|Primblock
modifier|*
ifdef|#
directive|ifdef
name|KR_headers
name|primchk
parameter_list|(
name|e
parameter_list|)
name|expptr
name|e
decl_stmt|;
else|#
directive|else
function|primchk
parameter_list|(
name|expptr
name|e
parameter_list|)
endif|#
directive|endif
block|{
if|if
condition|(
name|e
operator|->
name|headblock
operator|.
name|tag
operator|!=
name|TPRIM
condition|)
block|{
name|err
argument_list|(
literal|"Invalid name in EQUIVALENCE."
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
operator|&
name|e
operator|->
name|primblock
return|;
block|}
end_function

end_unit

