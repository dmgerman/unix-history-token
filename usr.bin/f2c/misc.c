begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**************************************************************** Copyright 1990, 1992 - 1995 by AT&T, Lucent Technologies and Bellcore.  Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that the copyright notice and this permission notice and warranty disclaimer appear in supporting documentation, and that the names of AT&T, Bell Laboratories, Lucent or Bellcore or any of their entities not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  AT&T, Lucent and Bellcore disclaim all warranties with regard to this software, including all implied warranties of merchantability and fitness.  In no event shall AT&T, Lucent or Bellcore be liable for any special, indirect or consequential damages or any damages whatsoever resulting from loss of use, data or profits, whether in an action of contract, negligence or other tortious action, arising out of or in connection with the use or performance of this software. ****************************************************************/
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"limits.h"
end_include

begin_function
name|int
ifdef|#
directive|ifdef
name|KR_headers
name|oneof_stg
parameter_list|(
name|name
parameter_list|,
name|stg
parameter_list|,
name|mask
parameter_list|)
name|Namep
name|name
decl_stmt|;
name|int
name|stg
decl_stmt|;
name|int
name|mask
decl_stmt|;
else|#
directive|else
function|oneof_stg
parameter_list|(
name|Namep
name|name
parameter_list|,
name|int
name|stg
parameter_list|,
name|int
name|mask
parameter_list|)
endif|#
directive|endif
block|{
if|if
condition|(
name|stg
operator|==
name|STGCOMMON
operator|&&
name|name
condition|)
block|{
if|if
condition|(
operator|(
name|mask
operator|&
name|M
argument_list|(
name|STGEQUIV
argument_list|)
operator|)
condition|)
return|return
name|name
operator|->
name|vcommequiv
return|;
if|if
condition|(
operator|(
name|mask
operator|&
name|M
argument_list|(
name|STGCOMMON
argument_list|)
operator|)
condition|)
return|return
operator|!
name|name
operator|->
name|vcommequiv
return|;
block|}
return|return
name|ONEOF
argument_list|(
name|stg
argument_list|,
name|mask
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* op_assign -- given a binary opcode, return the associated assignment    operator */
end_comment

begin_function
name|int
ifdef|#
directive|ifdef
name|KR_headers
name|op_assign
parameter_list|(
name|opcode
parameter_list|)
name|int
name|opcode
decl_stmt|;
else|#
directive|else
function|op_assign
parameter_list|(
name|int
name|opcode
parameter_list|)
endif|#
directive|endif
block|{
name|int
name|retval
init|=
operator|-
literal|1
decl_stmt|;
switch|switch
condition|(
name|opcode
condition|)
block|{
case|case
name|OPPLUS
case|:
name|retval
operator|=
name|OPPLUSEQ
expr_stmt|;
break|break;
case|case
name|OPMINUS
case|:
name|retval
operator|=
name|OPMINUSEQ
expr_stmt|;
break|break;
case|case
name|OPSTAR
case|:
name|retval
operator|=
name|OPSTAREQ
expr_stmt|;
break|break;
case|case
name|OPSLASH
case|:
name|retval
operator|=
name|OPSLASHEQ
expr_stmt|;
break|break;
case|case
name|OPMOD
case|:
name|retval
operator|=
name|OPMODEQ
expr_stmt|;
break|break;
case|case
name|OPLSHIFT
case|:
name|retval
operator|=
name|OPLSHIFTEQ
expr_stmt|;
break|break;
case|case
name|OPRSHIFT
case|:
name|retval
operator|=
name|OPRSHIFTEQ
expr_stmt|;
break|break;
case|case
name|OPBITAND
case|:
name|retval
operator|=
name|OPBITANDEQ
expr_stmt|;
break|break;
case|case
name|OPBITXOR
case|:
name|retval
operator|=
name|OPBITXOREQ
expr_stmt|;
break|break;
case|case
name|OPBITOR
case|:
name|retval
operator|=
name|OPBITOREQ
expr_stmt|;
break|break;
default|default:
name|erri
argument_list|(
literal|"op_assign:  bad opcode '%d'"
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* switch */
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* op_assign */
end_comment

begin_function
name|char
modifier|*
ifdef|#
directive|ifdef
name|KR_headers
name|Alloc
parameter_list|(
name|n
parameter_list|)
name|int
name|n
decl_stmt|;
else|#
directive|else
function|Alloc
parameter_list|(
name|int
name|n
parameter_list|)
endif|#
directive|endif
comment|/* error-checking version of malloc */
comment|/* ckalloc initializes memory to 0; Alloc does not */
block|{
name|char
name|errbuf
index|[
literal|32
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|rv
decl_stmt|;
name|rv
operator|=
name|malloc
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rv
condition|)
block|{
name|sprintf
argument_list|(
name|errbuf
argument_list|,
literal|"malloc(%d) failure!"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|Fatal
argument_list|(
name|errbuf
argument_list|)
expr_stmt|;
block|}
return|return
name|rv
return|;
block|}
end_function

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|cpn
parameter_list|(
name|n
parameter_list|,
name|a
parameter_list|,
name|b
parameter_list|)
specifier|register
name|int
name|n
decl_stmt|;
specifier|register
name|char
modifier|*
name|a
decl_stmt|;
specifier|register
name|char
modifier|*
name|b
decl_stmt|;
else|#
directive|else
function|cpn
parameter_list|(
specifier|register
name|int
name|n
parameter_list|,
specifier|register
name|char
modifier|*
name|a
parameter_list|,
specifier|register
name|char
modifier|*
name|b
parameter_list|)
endif|#
directive|endif
block|{
while|while
condition|(
operator|--
name|n
operator|>=
literal|0
condition|)
operator|*
name|b
operator|++
operator|=
operator|*
name|a
operator|++
expr_stmt|;
block|}
end_function

begin_function
name|int
ifdef|#
directive|ifdef
name|KR_headers
name|eqn
parameter_list|(
name|n
parameter_list|,
name|a
parameter_list|,
name|b
parameter_list|)
specifier|register
name|int
name|n
decl_stmt|;
specifier|register
name|char
modifier|*
name|a
decl_stmt|;
specifier|register
name|char
modifier|*
name|b
decl_stmt|;
else|#
directive|else
function|eqn
parameter_list|(
specifier|register
name|int
name|n
parameter_list|,
specifier|register
name|char
modifier|*
name|a
parameter_list|,
specifier|register
name|char
modifier|*
name|b
parameter_list|)
endif|#
directive|endif
block|{
while|while
condition|(
operator|--
name|n
operator|>=
literal|0
condition|)
if|if
condition|(
operator|*
name|a
operator|++
operator|!=
operator|*
name|b
operator|++
condition|)
return|return
operator|(
name|NO
operator|)
return|;
return|return
operator|(
name|YES
operator|)
return|;
block|}
end_function

begin_function
name|int
ifdef|#
directive|ifdef
name|KR_headers
name|cmpstr
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|la
parameter_list|,
name|lb
parameter_list|)
specifier|register
name|char
modifier|*
name|a
decl_stmt|;
specifier|register
name|char
modifier|*
name|b
decl_stmt|;
name|ftnint
name|la
decl_stmt|;
name|ftnint
name|lb
decl_stmt|;
else|#
directive|else
function|cmpstr
parameter_list|(
specifier|register
name|char
modifier|*
name|a
parameter_list|,
specifier|register
name|char
modifier|*
name|b
parameter_list|,
name|ftnint
name|la
parameter_list|,
name|ftnint
name|lb
parameter_list|)
endif|#
directive|endif
comment|/* compare two strings */
block|{
specifier|register
name|char
modifier|*
name|aend
decl_stmt|,
modifier|*
name|bend
decl_stmt|;
name|aend
operator|=
name|a
operator|+
name|la
expr_stmt|;
name|bend
operator|=
name|b
operator|+
name|lb
expr_stmt|;
if|if
condition|(
name|la
operator|<=
name|lb
condition|)
block|{
while|while
condition|(
name|a
operator|<
name|aend
condition|)
if|if
condition|(
operator|*
name|a
operator|!=
operator|*
name|b
condition|)
return|return
operator|(
operator|*
name|a
operator|-
operator|*
name|b
operator|)
return|;
else|else
block|{
operator|++
name|a
expr_stmt|;
operator|++
name|b
expr_stmt|;
block|}
while|while
condition|(
name|b
operator|<
name|bend
condition|)
if|if
condition|(
operator|*
name|b
operator|!=
literal|' '
condition|)
return|return
operator|(
literal|' '
operator|-
operator|*
name|b
operator|)
return|;
else|else
operator|++
name|b
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|b
operator|<
name|bend
condition|)
if|if
condition|(
operator|*
name|a
operator|!=
operator|*
name|b
condition|)
return|return
operator|(
operator|*
name|a
operator|-
operator|*
name|b
operator|)
return|;
else|else
block|{
operator|++
name|a
expr_stmt|;
operator|++
name|b
expr_stmt|;
block|}
while|while
condition|(
name|a
operator|<
name|aend
condition|)
if|if
condition|(
operator|*
name|a
operator|!=
literal|' '
condition|)
return|return
operator|(
operator|*
name|a
operator|-
literal|' '
operator|)
return|;
else|else
operator|++
name|a
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* hookup -- Same as LISP NCONC, that is a destructive append of two lists */
end_comment

begin_function
name|chainp
ifdef|#
directive|ifdef
name|KR_headers
name|hookup
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
specifier|register
name|chainp
name|x
decl_stmt|;
specifier|register
name|chainp
name|y
decl_stmt|;
else|#
directive|else
function|hookup
parameter_list|(
specifier|register
name|chainp
name|x
parameter_list|,
specifier|register
name|chainp
name|y
parameter_list|)
endif|#
directive|endif
block|{
specifier|register
name|chainp
name|p
decl_stmt|;
if|if
condition|(
name|x
operator|==
name|NULL
condition|)
return|return
operator|(
name|y
operator|)
return|;
for|for
control|(
name|p
operator|=
name|x
init|;
name|p
operator|->
name|nextp
condition|;
name|p
operator|=
name|p
operator|->
name|nextp
control|)
empty_stmt|;
name|p
operator|->
name|nextp
operator|=
name|y
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|Listblock
modifier|*
ifdef|#
directive|ifdef
name|KR_headers
name|mklist
parameter_list|(
name|p
parameter_list|)
name|chainp
name|p
decl_stmt|;
else|#
directive|else
function|mklist
parameter_list|(
name|chainp
name|p
parameter_list|)
endif|#
directive|endif
block|{
specifier|register
name|struct
name|Listblock
modifier|*
name|q
decl_stmt|;
name|q
operator|=
name|ALLOC
argument_list|(
name|Listblock
argument_list|)
expr_stmt|;
name|q
operator|->
name|tag
operator|=
name|TLIST
expr_stmt|;
name|q
operator|->
name|listp
operator|=
name|p
expr_stmt|;
return|return
operator|(
name|q
operator|)
return|;
block|}
end_function

begin_function
name|chainp
ifdef|#
directive|ifdef
name|KR_headers
name|mkchain
parameter_list|(
name|p
parameter_list|,
name|q
parameter_list|)
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|chainp
name|q
decl_stmt|;
else|#
directive|else
function|mkchain
parameter_list|(
specifier|register
name|char
modifier|*
name|p
parameter_list|,
specifier|register
name|chainp
name|q
parameter_list|)
endif|#
directive|endif
block|{
specifier|register
name|chainp
name|r
decl_stmt|;
if|if
condition|(
name|chains
condition|)
block|{
name|r
operator|=
name|chains
expr_stmt|;
name|chains
operator|=
name|chains
operator|->
name|nextp
expr_stmt|;
block|}
else|else
name|r
operator|=
name|ALLOC
argument_list|(
name|Chain
argument_list|)
expr_stmt|;
name|r
operator|->
name|datap
operator|=
name|p
expr_stmt|;
name|r
operator|->
name|nextp
operator|=
name|q
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_function
name|chainp
ifdef|#
directive|ifdef
name|KR_headers
name|revchain
parameter_list|(
name|next
parameter_list|)
specifier|register
name|chainp
name|next
decl_stmt|;
else|#
directive|else
function|revchain
parameter_list|(
specifier|register
name|chainp
name|next
parameter_list|)
endif|#
directive|endif
block|{
specifier|register
name|chainp
name|p
decl_stmt|,
name|prev
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|p
operator|=
name|next
condition|)
block|{
name|next
operator|=
name|p
operator|->
name|nextp
expr_stmt|;
name|p
operator|->
name|nextp
operator|=
name|prev
expr_stmt|;
name|prev
operator|=
name|p
expr_stmt|;
block|}
return|return
name|prev
return|;
block|}
end_function

begin_comment
comment|/* addunder -- turn a cvarname into an external name */
end_comment

begin_comment
comment|/* The cvarname may already end in _ (to avoid C keywords); */
end_comment

begin_comment
comment|/* if not, it has room for appending an _. */
end_comment

begin_function
name|char
modifier|*
ifdef|#
directive|ifdef
name|KR_headers
name|addunder
parameter_list|(
name|s
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
else|#
directive|else
function|addunder
parameter_list|(
specifier|register
name|char
modifier|*
name|s
parameter_list|)
endif|#
directive|endif
block|{
specifier|register
name|int
name|c
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
name|char
modifier|*
name|s0
init|=
name|s
decl_stmt|;
name|i
operator|=
name|j
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|c
operator|=
operator|*
name|s
operator|++
condition|)
if|if
condition|(
name|c
operator|==
literal|'_'
condition|)
name|i
operator|++
operator|,
name|j
operator|++
expr_stmt|;
else|else
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|i
condition|)
block|{
operator|*
name|s
operator|--
operator|=
literal|0
expr_stmt|;
operator|*
name|s
operator|=
literal|'_'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|j
operator|==
literal|2
condition|)
name|s
index|[
operator|-
literal|2
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|s0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* copyn -- return a new copy of the input Fortran-string */
end_comment

begin_function
name|char
modifier|*
ifdef|#
directive|ifdef
name|KR_headers
name|copyn
parameter_list|(
name|n
parameter_list|,
name|s
parameter_list|)
specifier|register
name|int
name|n
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
else|#
directive|else
function|copyn
parameter_list|(
specifier|register
name|int
name|n
parameter_list|,
specifier|register
name|char
modifier|*
name|s
parameter_list|)
endif|#
directive|endif
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|p
operator|=
name|q
operator|=
operator|(
name|char
operator|*
operator|)
name|Alloc
argument_list|(
name|n
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|n
operator|>=
literal|0
condition|)
operator|*
name|q
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/* copys -- return a new copy of the input C-string */
end_comment

begin_function
name|char
modifier|*
ifdef|#
directive|ifdef
name|KR_headers
name|copys
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
else|#
directive|else
function|copys
parameter_list|(
name|char
modifier|*
name|s
parameter_list|)
endif|#
directive|endif
block|{
return|return
operator|(
name|copyn
argument_list|(
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
argument_list|,
name|s
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* convci -- Convert Fortran-string to integer; assumes that input is a    legal number, with no trailing blanks */
end_comment

begin_function
name|ftnint
ifdef|#
directive|ifdef
name|KR_headers
name|convci
parameter_list|(
name|n
parameter_list|,
name|s
parameter_list|)
specifier|register
name|int
name|n
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
else|#
directive|else
function|convci
parameter_list|(
specifier|register
name|int
name|n
parameter_list|,
specifier|register
name|char
modifier|*
name|s
parameter_list|)
endif|#
directive|endif
block|{
name|ftnint
name|sum
decl_stmt|,
name|t
decl_stmt|;
name|char
name|buff
index|[
literal|100
index|]
decl_stmt|,
modifier|*
name|s0
decl_stmt|;
name|int
name|n0
decl_stmt|;
name|s0
operator|=
name|s
expr_stmt|;
name|n0
operator|=
name|n
expr_stmt|;
name|sum
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|n
operator|--
operator|>
literal|0
condition|)
block|{
comment|/* sum = 10*sum + (*s++ - '0'); */
name|t
operator|=
operator|*
name|s
operator|++
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|sum
operator|>
name|LONG_MAX
operator|/
literal|10
condition|)
block|{
name|ovfl
label|:
if|if
condition|(
name|n0
operator|>
literal|60
condition|)
name|n0
operator|=
literal|60
expr_stmt|;
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"integer constant %.*s truncated."
argument_list|,
name|n0
argument_list|,
name|s0
argument_list|)
expr_stmt|;
name|err
argument_list|(
name|buff
argument_list|)
expr_stmt|;
return|return
name|LONG_MAX
return|;
block|}
name|sum
operator|*=
literal|10
expr_stmt|;
if|if
condition|(
name|sum
operator|>
name|LONG_MAX
operator|-
name|t
condition|)
goto|goto
name|ovfl
goto|;
name|sum
operator|+=
name|t
expr_stmt|;
block|}
return|return
operator|(
name|sum
operator|)
return|;
block|}
end_function

begin_comment
comment|/* convic - Convert Integer constant to string */
end_comment

begin_function
name|char
modifier|*
ifdef|#
directive|ifdef
name|KR_headers
name|convic
parameter_list|(
name|n
parameter_list|)
name|ftnint
name|n
decl_stmt|;
else|#
directive|else
function|convic
parameter_list|(
name|ftnint
name|n
parameter_list|)
endif|#
directive|endif
block|{
specifier|static
name|char
name|s
index|[
literal|20
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|t
decl_stmt|;
name|s
index|[
literal|19
index|]
operator|=
literal|'\0'
expr_stmt|;
name|t
operator|=
name|s
operator|+
literal|19
expr_stmt|;
do|do
block|{
operator|*
operator|--
name|t
operator|=
literal|'0'
operator|+
name|n
operator|%
literal|10
expr_stmt|;
name|n
operator|/=
literal|10
expr_stmt|;
block|}
do|while
condition|(
name|n
operator|>
literal|0
condition|)
do|;
return|return
operator|(
name|t
operator|)
return|;
block|}
end_function

begin_comment
comment|/* mkname -- add a new identifier to the environment, including the closed    hash table. */
end_comment

begin_function
name|Namep
ifdef|#
directive|ifdef
name|KR_headers
name|mkname
parameter_list|(
name|s
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
else|#
directive|else
function|mkname
parameter_list|(
specifier|register
name|char
modifier|*
name|s
parameter_list|)
endif|#
directive|endif
block|{
name|struct
name|Hashentry
modifier|*
name|hp
decl_stmt|;
specifier|register
name|Namep
name|q
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|,
name|hash
decl_stmt|,
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|t
decl_stmt|;
name|char
modifier|*
name|s0
decl_stmt|;
name|char
name|errbuf
index|[
literal|64
index|]
decl_stmt|;
name|hash
operator|=
name|i
operator|=
literal|0
expr_stmt|;
name|s0
operator|=
name|s
expr_stmt|;
while|while
condition|(
name|c
operator|=
operator|*
name|s
operator|++
condition|)
block|{
name|hash
operator|+=
name|c
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'_'
condition|)
name|i
operator|=
literal|2
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|i
operator|&&
name|in_vector
argument_list|(
name|s0
argument_list|,
name|c_keywords
argument_list|,
name|n_keywords
argument_list|)
operator|>=
literal|0
condition|)
name|i
operator|=
literal|2
expr_stmt|;
name|hash
operator|%=
name|maxhash
expr_stmt|;
comment|/* Add the name to the closed hash table */
name|hp
operator|=
name|hashtab
operator|+
name|hash
expr_stmt|;
while|while
condition|(
name|q
operator|=
name|hp
operator|->
name|varp
condition|)
if|if
condition|(
name|hash
operator|==
name|hp
operator|->
name|hashval
operator|&&
operator|!
name|strcmp
argument_list|(
name|s0
argument_list|,
name|q
operator|->
name|fvarname
argument_list|)
condition|)
return|return
operator|(
name|q
operator|)
return|;
elseif|else
if|if
condition|(
operator|++
name|hp
operator|>=
name|lasthash
condition|)
name|hp
operator|=
name|hashtab
expr_stmt|;
if|if
condition|(
operator|++
name|nintnames
operator|>=
name|maxhash
operator|-
literal|1
condition|)
name|many
argument_list|(
literal|"names"
argument_list|,
literal|'n'
argument_list|,
name|maxhash
argument_list|)
expr_stmt|;
comment|/* Fatal error */
name|hp
operator|->
name|varp
operator|=
name|q
operator|=
name|ALLOC
argument_list|(
name|Nameblock
argument_list|)
expr_stmt|;
name|hp
operator|->
name|hashval
operator|=
name|hash
expr_stmt|;
name|q
operator|->
name|tag
operator|=
name|TNAME
expr_stmt|;
comment|/* TNAME means the tag type is NAME */
name|c
operator|=
name|s
operator|-
name|s0
expr_stmt|;
if|if
condition|(
name|c
operator|>
literal|7
operator|&&
name|noextflag
condition|)
block|{
name|sprintf
argument_list|(
name|errbuf
argument_list|,
literal|"\"%.35s%s\" over 6 characters long"
argument_list|,
name|s0
argument_list|,
name|c
operator|>
literal|36
condition|?
literal|"..."
else|:
literal|""
argument_list|)
expr_stmt|;
name|errext
argument_list|(
name|errbuf
argument_list|)
expr_stmt|;
block|}
name|q
operator|->
name|fvarname
operator|=
name|strcpy
argument_list|(
name|mem
argument_list|(
name|c
argument_list|,
literal|0
argument_list|)
argument_list|,
name|s0
argument_list|)
expr_stmt|;
name|t
operator|=
name|q
operator|->
name|cvarname
operator|=
name|mem
argument_list|(
name|c
operator|+
name|i
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|s
operator|=
name|s0
expr_stmt|;
comment|/* add __ to the end of any name containing _ and to any C keyword */
while|while
condition|(
operator|*
name|t
operator|=
operator|*
name|s
operator|++
condition|)
name|t
operator|++
expr_stmt|;
if|if
condition|(
name|i
condition|)
block|{
do|do
operator|*
name|t
operator|++
operator|=
literal|'_'
expr_stmt|;
do|while
condition|(
operator|--
name|i
operator|>
literal|0
condition|)
do|;
operator|*
name|t
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|q
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|Labelblock
modifier|*
ifdef|#
directive|ifdef
name|KR_headers
name|mklabel
parameter_list|(
name|l
parameter_list|)
name|ftnint
name|l
decl_stmt|;
else|#
directive|else
function|mklabel
parameter_list|(
name|ftnint
name|l
parameter_list|)
endif|#
directive|endif
block|{
specifier|register
name|struct
name|Labelblock
modifier|*
name|lp
decl_stmt|;
if|if
condition|(
name|l
operator|<=
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
for|for
control|(
name|lp
operator|=
name|labeltab
init|;
name|lp
operator|<
name|highlabtab
condition|;
operator|++
name|lp
control|)
if|if
condition|(
name|lp
operator|->
name|stateno
operator|==
name|l
condition|)
return|return
operator|(
name|lp
operator|)
return|;
if|if
condition|(
operator|++
name|highlabtab
operator|>
name|labtabend
condition|)
name|many
argument_list|(
literal|"statement labels"
argument_list|,
literal|'s'
argument_list|,
name|maxstno
argument_list|)
expr_stmt|;
name|lp
operator|->
name|stateno
operator|=
name|l
expr_stmt|;
name|lp
operator|->
name|labelno
operator|=
operator|(
name|int
operator|)
name|newlabel
argument_list|()
expr_stmt|;
name|lp
operator|->
name|blklevel
operator|=
literal|0
expr_stmt|;
name|lp
operator|->
name|labused
operator|=
name|NO
expr_stmt|;
name|lp
operator|->
name|fmtlabused
operator|=
name|NO
expr_stmt|;
name|lp
operator|->
name|labdefined
operator|=
name|NO
expr_stmt|;
name|lp
operator|->
name|labinacc
operator|=
name|NO
expr_stmt|;
name|lp
operator|->
name|labtype
operator|=
name|LABUNKNOWN
expr_stmt|;
name|lp
operator|->
name|fmtstring
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|lp
operator|)
return|;
block|}
end_function

begin_function
name|long
name|newlabel
parameter_list|(
name|Void
parameter_list|)
block|{
return|return
operator|++
name|lastlabno
return|;
block|}
end_function

begin_comment
comment|/* this label appears in a branch context */
end_comment

begin_function
name|struct
name|Labelblock
modifier|*
ifdef|#
directive|ifdef
name|KR_headers
name|execlab
parameter_list|(
name|stateno
parameter_list|)
name|ftnint
name|stateno
decl_stmt|;
else|#
directive|else
function|execlab
parameter_list|(
name|ftnint
name|stateno
parameter_list|)
endif|#
directive|endif
block|{
specifier|register
name|struct
name|Labelblock
modifier|*
name|lp
decl_stmt|;
if|if
condition|(
name|lp
operator|=
name|mklabel
argument_list|(
name|stateno
argument_list|)
condition|)
block|{
if|if
condition|(
name|lp
operator|->
name|labinacc
condition|)
name|warn1
argument_list|(
literal|"illegal branch to inner block, statement label %s"
argument_list|,
name|convic
argument_list|(
name|stateno
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|lp
operator|->
name|labdefined
operator|==
name|NO
condition|)
name|lp
operator|->
name|blklevel
operator|=
name|blklevel
expr_stmt|;
if|if
condition|(
name|lp
operator|->
name|labtype
operator|==
name|LABFORMAT
condition|)
name|err
argument_list|(
literal|"may not branch to a format"
argument_list|)
expr_stmt|;
else|else
name|lp
operator|->
name|labtype
operator|=
name|LABEXEC
expr_stmt|;
block|}
else|else
name|execerr
argument_list|(
literal|"illegal label %s"
argument_list|,
name|convic
argument_list|(
name|stateno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|lp
operator|)
return|;
block|}
end_function

begin_comment
comment|/* find or put a name in the external symbol table */
end_comment

begin_function
name|Extsym
modifier|*
ifdef|#
directive|ifdef
name|KR_headers
name|mkext1
parameter_list|(
name|f
parameter_list|,
name|s
parameter_list|)
name|char
modifier|*
name|f
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
else|#
directive|else
function|mkext1
parameter_list|(
name|char
modifier|*
name|f
parameter_list|,
name|char
modifier|*
name|s
parameter_list|)
endif|#
directive|endif
block|{
name|Extsym
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|extsymtab
init|;
name|p
operator|<
name|nextext
condition|;
operator|++
name|p
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|s
argument_list|,
name|p
operator|->
name|cextname
argument_list|)
condition|)
return|return
operator|(
name|p
operator|)
return|;
if|if
condition|(
name|nextext
operator|>=
name|lastext
condition|)
name|many
argument_list|(
literal|"external symbols"
argument_list|,
literal|'x'
argument_list|,
name|maxext
argument_list|)
expr_stmt|;
name|nextext
operator|->
name|fextname
operator|=
name|strcpy
argument_list|(
name|gmem
argument_list|(
name|strlen
argument_list|(
name|f
argument_list|)
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|nextext
operator|->
name|cextname
operator|=
name|f
operator|==
name|s
condition|?
name|nextext
operator|->
name|fextname
else|:
name|strcpy
argument_list|(
name|gmem
argument_list|(
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|nextext
operator|->
name|extstg
operator|=
name|STGUNKNOWN
expr_stmt|;
name|nextext
operator|->
name|extp
operator|=
literal|0
expr_stmt|;
name|nextext
operator|->
name|allextp
operator|=
literal|0
expr_stmt|;
name|nextext
operator|->
name|extleng
operator|=
literal|0
expr_stmt|;
name|nextext
operator|->
name|maxleng
operator|=
literal|0
expr_stmt|;
name|nextext
operator|->
name|extinit
operator|=
literal|0
expr_stmt|;
name|nextext
operator|->
name|curno
operator|=
name|nextext
operator|->
name|maxno
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|nextext
operator|++
operator|)
return|;
block|}
end_function

begin_function
name|Extsym
modifier|*
ifdef|#
directive|ifdef
name|KR_headers
name|mkext
parameter_list|(
name|f
parameter_list|,
name|s
parameter_list|)
name|char
modifier|*
name|f
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
else|#
directive|else
function|mkext
parameter_list|(
name|char
modifier|*
name|f
parameter_list|,
name|char
modifier|*
name|s
parameter_list|)
endif|#
directive|endif
block|{
name|Extsym
modifier|*
name|e
init|=
name|mkext1
argument_list|(
name|f
argument_list|,
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|e
operator|->
name|extstg
operator|==
name|STGCOMMON
condition|)
name|errstr
argument_list|(
literal|"%.52s cannot be a subprogram: it is a common block."
argument_list|,
name|f
argument_list|)
expr_stmt|;
return|return
name|e
return|;
block|}
end_function

begin_function
name|Addrp
ifdef|#
directive|ifdef
name|KR_headers
name|builtin
parameter_list|(
name|t
parameter_list|,
name|s
parameter_list|,
name|dbi
parameter_list|)
name|int
name|t
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|dbi
decl_stmt|;
else|#
directive|else
function|builtin
parameter_list|(
name|int
name|t
parameter_list|,
name|char
modifier|*
name|s
parameter_list|,
name|int
name|dbi
parameter_list|)
endif|#
directive|endif
block|{
specifier|register
name|Extsym
modifier|*
name|p
decl_stmt|;
specifier|register
name|Addrp
name|q
decl_stmt|;
specifier|extern
name|chainp
name|used_builtins
decl_stmt|;
name|p
operator|=
name|mkext
argument_list|(
name|s
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|extstg
operator|==
name|STGUNKNOWN
condition|)
name|p
operator|->
name|extstg
operator|=
name|STGEXT
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|->
name|extstg
operator|!=
name|STGEXT
condition|)
block|{
name|errstr
argument_list|(
literal|"improper use of builtin %s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|q
operator|=
name|ALLOC
argument_list|(
name|Addrblock
argument_list|)
expr_stmt|;
name|q
operator|->
name|tag
operator|=
name|TADDR
expr_stmt|;
name|q
operator|->
name|vtype
operator|=
name|t
expr_stmt|;
name|q
operator|->
name|vclass
operator|=
name|CLPROC
expr_stmt|;
name|q
operator|->
name|vstg
operator|=
name|STGEXT
expr_stmt|;
name|q
operator|->
name|memno
operator|=
name|p
operator|-
name|extsymtab
expr_stmt|;
name|q
operator|->
name|dbl_builtin
operator|=
name|dbi
expr_stmt|;
comment|/* A NULL pointer here tells you to use   memno   to check the external    symbol table */
name|q
operator|->
name|uname_tag
operator|=
name|UNAM_EXTERN
expr_stmt|;
comment|/* Add to the list of used builtins */
if|if
condition|(
name|dbi
operator|>=
literal|0
condition|)
name|add_extern_to_list
argument_list|(
name|q
argument_list|,
operator|&
name|used_builtins
argument_list|)
expr_stmt|;
return|return
operator|(
name|q
operator|)
return|;
block|}
end_function

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|add_extern_to_list
parameter_list|(
name|addr
parameter_list|,
name|list_store
parameter_list|)
name|Addrp
name|addr
decl_stmt|;
name|chainp
modifier|*
name|list_store
decl_stmt|;
else|#
directive|else
function|add_extern_to_list
parameter_list|(
name|Addrp
name|addr
parameter_list|,
name|chainp
modifier|*
name|list_store
parameter_list|)
endif|#
directive|endif
block|{
name|chainp
name|last
init|=
name|CHNULL
decl_stmt|;
name|chainp
name|list
decl_stmt|;
name|int
name|memno
decl_stmt|;
if|if
condition|(
name|list_store
operator|==
operator|(
name|chainp
operator|*
operator|)
name|NULL
operator|||
name|addr
operator|==
operator|(
name|Addrp
operator|)
name|NULL
condition|)
return|return;
name|list
operator|=
operator|*
name|list_store
expr_stmt|;
name|memno
operator|=
name|addr
operator|->
name|memno
expr_stmt|;
for|for
control|(
init|;
name|list
condition|;
name|last
operator|=
name|list
operator|,
name|list
operator|=
name|list
operator|->
name|nextp
control|)
block|{
name|Addrp
name|this
init|=
call|(
name|Addrp
call|)
argument_list|(
name|list
operator|->
name|datap
argument_list|)
decl_stmt|;
if|if
condition|(
name|this
operator|->
name|tag
operator|==
name|TADDR
operator|&&
name|this
operator|->
name|uname_tag
operator|==
name|UNAM_EXTERN
operator|&&
name|this
operator|->
name|memno
operator|==
name|memno
condition|)
return|return;
block|}
comment|/* for */
if|if
condition|(
operator|*
name|list_store
operator|==
name|CHNULL
condition|)
operator|*
name|list_store
operator|=
name|mkchain
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cpexpr
argument_list|(
operator|(
name|expptr
operator|)
name|addr
argument_list|)
argument_list|,
name|CHNULL
argument_list|)
expr_stmt|;
else|else
name|last
operator|->
name|nextp
operator|=
name|mkchain
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cpexpr
argument_list|(
operator|(
name|expptr
operator|)
name|addr
argument_list|)
argument_list|,
name|CHNULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* add_extern_to_list */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|frchain
parameter_list|(
name|p
parameter_list|)
specifier|register
name|chainp
modifier|*
name|p
decl_stmt|;
else|#
directive|else
function|frchain
parameter_list|(
specifier|register
name|chainp
modifier|*
name|p
parameter_list|)
endif|#
directive|endif
block|{
specifier|register
name|chainp
name|q
decl_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
operator|||
operator|*
name|p
operator|==
literal|0
condition|)
return|return;
for|for
control|(
name|q
operator|=
operator|*
name|p
init|;
name|q
operator|->
name|nextp
condition|;
name|q
operator|=
name|q
operator|->
name|nextp
control|)
empty_stmt|;
name|q
operator|->
name|nextp
operator|=
name|chains
expr_stmt|;
name|chains
operator|=
operator|*
name|p
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|frexchain
parameter_list|(
name|p
parameter_list|)
specifier|register
name|chainp
modifier|*
name|p
decl_stmt|;
else|#
directive|else
function|frexchain
parameter_list|(
specifier|register
name|chainp
modifier|*
name|p
parameter_list|)
endif|#
directive|endif
block|{
specifier|register
name|chainp
name|q
decl_stmt|,
name|r
decl_stmt|;
if|if
condition|(
name|q
operator|=
operator|*
name|p
condition|)
block|{
for|for
control|(
init|;
condition|;
name|q
operator|=
name|r
control|)
block|{
name|frexpr
argument_list|(
operator|(
name|expptr
operator|)
name|q
operator|->
name|datap
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|r
operator|=
name|q
operator|->
name|nextp
operator|)
condition|)
break|break;
block|}
name|q
operator|->
name|nextp
operator|=
name|chains
expr_stmt|;
name|chains
operator|=
operator|*
name|p
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
name|tagptr
ifdef|#
directive|ifdef
name|KR_headers
name|cpblock
parameter_list|(
name|n
parameter_list|,
name|p
parameter_list|)
specifier|register
name|int
name|n
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
else|#
directive|else
function|cpblock
parameter_list|(
specifier|register
name|int
name|n
parameter_list|,
specifier|register
name|char
modifier|*
name|p
parameter_list|)
endif|#
directive|endif
block|{
specifier|register
name|ptr
name|q
decl_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|q
operator|=
name|ckalloc
argument_list|(
name|n
argument_list|)
operator|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|p
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|tagptr
operator|)
name|q
operator|)
return|;
block|}
end_function

begin_function
name|ftnint
ifdef|#
directive|ifdef
name|KR_headers
name|lmax
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
name|ftnint
name|a
decl_stmt|;
name|ftnint
name|b
decl_stmt|;
else|#
directive|else
function|lmax
parameter_list|(
name|ftnint
name|a
parameter_list|,
name|ftnint
name|b
parameter_list|)
endif|#
directive|endif
block|{
return|return
operator|(
name|a
operator|>
name|b
condition|?
name|a
else|:
name|b
operator|)
return|;
block|}
end_function

begin_function
name|ftnint
ifdef|#
directive|ifdef
name|KR_headers
name|lmin
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
name|ftnint
name|a
decl_stmt|;
name|ftnint
name|b
decl_stmt|;
else|#
directive|else
function|lmin
parameter_list|(
name|ftnint
name|a
parameter_list|,
name|ftnint
name|b
parameter_list|)
endif|#
directive|endif
block|{
return|return
operator|(
name|a
operator|<
name|b
condition|?
name|a
else|:
name|b
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|KR_headers
end_ifdef

begin_macro
name|maxtype
argument_list|(
argument|t1
argument_list|,
argument|t2
argument_list|)
end_macro

begin_decl_stmt
name|int
name|t1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|t2
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_macro
name|maxtype
argument_list|(
argument|int t1
argument_list|,
argument|int t2
argument_list|)
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|int
name|t
decl_stmt|;
name|t
operator|=
name|t1
operator|>=
name|t2
condition|?
name|t1
else|:
name|t2
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|TYCOMPLEX
operator|&&
operator|(
name|t1
operator|==
name|TYDREAL
operator|||
name|t2
operator|==
name|TYDREAL
operator|)
condition|)
name|t
operator|=
name|TYDCOMPLEX
expr_stmt|;
return|return
operator|(
name|t
operator|)
return|;
block|}
end_block

begin_comment
comment|/* return log base 2 of n if n a power of 2; otherwise -1 */
end_comment

begin_function
name|int
ifdef|#
directive|ifdef
name|KR_headers
name|log_2
parameter_list|(
name|n
parameter_list|)
name|ftnint
name|n
decl_stmt|;
else|#
directive|else
function|log_2
parameter_list|(
name|ftnint
name|n
parameter_list|)
endif|#
directive|endif
block|{
name|int
name|k
decl_stmt|;
comment|/* trick based on binary representation */
if|if
condition|(
name|n
operator|<=
literal|0
operator|||
operator|(
name|n
operator|&
operator|(
name|n
operator|-
literal|1
operator|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|n
operator|>>=
literal|1
condition|;
operator|++
name|k
control|)
empty_stmt|;
return|return
operator|(
name|k
operator|)
return|;
block|}
end_function

begin_function
name|void
name|frrpl
parameter_list|(
name|Void
parameter_list|)
block|{
name|struct
name|Rplblock
modifier|*
name|rp
decl_stmt|;
while|while
condition|(
name|rpllist
condition|)
block|{
name|rp
operator|=
name|rpllist
operator|->
name|rplnextp
expr_stmt|;
name|free
argument_list|(
operator|(
name|charptr
operator|)
name|rpllist
argument_list|)
expr_stmt|;
name|rpllist
operator|=
name|rp
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Call a Fortran function with an arbitrary list of arguments */
end_comment

begin_decl_stmt
name|int
name|callk_kludge
decl_stmt|;
end_decl_stmt

begin_function
name|expptr
ifdef|#
directive|ifdef
name|KR_headers
name|callk
parameter_list|(
name|type
parameter_list|,
name|name
parameter_list|,
name|args
parameter_list|)
name|int
name|type
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|chainp
name|args
decl_stmt|;
else|#
directive|else
function|callk
parameter_list|(
name|int
name|type
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|chainp
name|args
parameter_list|)
endif|#
directive|endif
block|{
specifier|register
name|expptr
name|p
decl_stmt|;
name|p
operator|=
name|mkexpr
argument_list|(
name|OPCALL
argument_list|,
operator|(
name|expptr
operator|)
name|builtin
argument_list|(
name|callk_kludge
condition|?
name|callk_kludge
else|:
name|type
argument_list|,
name|name
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|(
name|expptr
operator|)
name|args
argument_list|)
expr_stmt|;
name|p
operator|->
name|exprblock
operator|.
name|vtype
operator|=
name|type
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_function
name|expptr
ifdef|#
directive|ifdef
name|KR_headers
name|call4
parameter_list|(
name|type
parameter_list|,
name|name
parameter_list|,
name|arg1
parameter_list|,
name|arg2
parameter_list|,
name|arg3
parameter_list|,
name|arg4
parameter_list|)
name|int
name|type
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|expptr
name|arg1
decl_stmt|;
name|expptr
name|arg2
decl_stmt|;
name|expptr
name|arg3
decl_stmt|;
name|expptr
name|arg4
decl_stmt|;
else|#
directive|else
function|call4
parameter_list|(
name|int
name|type
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|expptr
name|arg1
parameter_list|,
name|expptr
name|arg2
parameter_list|,
name|expptr
name|arg3
parameter_list|,
name|expptr
name|arg4
parameter_list|)
endif|#
directive|endif
block|{
name|struct
name|Listblock
modifier|*
name|args
decl_stmt|;
name|args
operator|=
name|mklist
argument_list|(
name|mkchain
argument_list|(
operator|(
name|char
operator|*
operator|)
name|arg1
argument_list|,
name|mkchain
argument_list|(
operator|(
name|char
operator|*
operator|)
name|arg2
argument_list|,
name|mkchain
argument_list|(
operator|(
name|char
operator|*
operator|)
name|arg3
argument_list|,
name|mkchain
argument_list|(
operator|(
name|char
operator|*
operator|)
name|arg4
argument_list|,
name|CHNULL
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|callk
argument_list|(
name|type
argument_list|,
name|name
argument_list|,
operator|(
name|chainp
operator|)
name|args
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|expptr
ifdef|#
directive|ifdef
name|KR_headers
name|call3
parameter_list|(
name|type
parameter_list|,
name|name
parameter_list|,
name|arg1
parameter_list|,
name|arg2
parameter_list|,
name|arg3
parameter_list|)
name|int
name|type
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|expptr
name|arg1
decl_stmt|;
name|expptr
name|arg2
decl_stmt|;
name|expptr
name|arg3
decl_stmt|;
else|#
directive|else
function|call3
parameter_list|(
name|int
name|type
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|expptr
name|arg1
parameter_list|,
name|expptr
name|arg2
parameter_list|,
name|expptr
name|arg3
parameter_list|)
endif|#
directive|endif
block|{
name|struct
name|Listblock
modifier|*
name|args
decl_stmt|;
name|args
operator|=
name|mklist
argument_list|(
name|mkchain
argument_list|(
operator|(
name|char
operator|*
operator|)
name|arg1
argument_list|,
name|mkchain
argument_list|(
operator|(
name|char
operator|*
operator|)
name|arg2
argument_list|,
name|mkchain
argument_list|(
operator|(
name|char
operator|*
operator|)
name|arg3
argument_list|,
name|CHNULL
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|callk
argument_list|(
name|type
argument_list|,
name|name
argument_list|,
operator|(
name|chainp
operator|)
name|args
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|expptr
ifdef|#
directive|ifdef
name|KR_headers
name|call2
parameter_list|(
name|type
parameter_list|,
name|name
parameter_list|,
name|arg1
parameter_list|,
name|arg2
parameter_list|)
name|int
name|type
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|expptr
name|arg1
decl_stmt|;
name|expptr
name|arg2
decl_stmt|;
else|#
directive|else
function|call2
parameter_list|(
name|int
name|type
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|expptr
name|arg1
parameter_list|,
name|expptr
name|arg2
parameter_list|)
endif|#
directive|endif
block|{
name|struct
name|Listblock
modifier|*
name|args
decl_stmt|;
name|args
operator|=
name|mklist
argument_list|(
name|mkchain
argument_list|(
operator|(
name|char
operator|*
operator|)
name|arg1
argument_list|,
name|mkchain
argument_list|(
operator|(
name|char
operator|*
operator|)
name|arg2
argument_list|,
name|CHNULL
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|callk
argument_list|(
name|type
argument_list|,
name|name
argument_list|,
operator|(
name|chainp
operator|)
name|args
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|expptr
ifdef|#
directive|ifdef
name|KR_headers
name|call1
parameter_list|(
name|type
parameter_list|,
name|name
parameter_list|,
name|arg
parameter_list|)
name|int
name|type
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|expptr
name|arg
decl_stmt|;
else|#
directive|else
function|call1
parameter_list|(
name|int
name|type
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|expptr
name|arg
parameter_list|)
endif|#
directive|endif
block|{
return|return
operator|(
name|callk
argument_list|(
name|type
argument_list|,
name|name
argument_list|,
operator|(
name|chainp
operator|)
name|mklist
argument_list|(
name|mkchain
argument_list|(
operator|(
name|char
operator|*
operator|)
name|arg
argument_list|,
name|CHNULL
argument_list|)
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|expptr
ifdef|#
directive|ifdef
name|KR_headers
name|call0
parameter_list|(
name|type
parameter_list|,
name|name
parameter_list|)
name|int
name|type
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
else|#
directive|else
function|call0
parameter_list|(
name|int
name|type
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
endif|#
directive|endif
block|{
return|return
operator|(
name|callk
argument_list|(
name|type
argument_list|,
name|name
argument_list|,
name|CHNULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|Impldoblock
modifier|*
ifdef|#
directive|ifdef
name|KR_headers
name|mkiodo
parameter_list|(
name|dospec
parameter_list|,
name|list
parameter_list|)
name|chainp
name|dospec
decl_stmt|;
name|chainp
name|list
decl_stmt|;
else|#
directive|else
function|mkiodo
parameter_list|(
name|chainp
name|dospec
parameter_list|,
name|chainp
name|list
parameter_list|)
endif|#
directive|endif
block|{
specifier|register
name|struct
name|Impldoblock
modifier|*
name|q
decl_stmt|;
name|q
operator|=
name|ALLOC
argument_list|(
name|Impldoblock
argument_list|)
expr_stmt|;
name|q
operator|->
name|tag
operator|=
name|TIMPLDO
expr_stmt|;
name|q
operator|->
name|impdospec
operator|=
name|dospec
expr_stmt|;
name|q
operator|->
name|datalist
operator|=
name|list
expr_stmt|;
return|return
operator|(
name|q
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ckalloc -- Allocate 1 memory unit of size   n,   checking for out of    memory error */
end_comment

begin_function
name|ptr
ifdef|#
directive|ifdef
name|KR_headers
name|ckalloc
parameter_list|(
name|n
parameter_list|)
specifier|register
name|int
name|n
decl_stmt|;
else|#
directive|else
function|ckalloc
parameter_list|(
specifier|register
name|int
name|n
parameter_list|)
endif|#
directive|endif
block|{
specifier|register
name|ptr
name|p
decl_stmt|;
name|p
operator|=
operator|(
name|ptr
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
operator|(
name|unsigned
operator|)
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|||
operator|!
name|n
condition|)
return|return
operator|(
name|p
operator|)
return|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"failing to get %d bytes\n"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|Fatal
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
comment|/* NOT REACHED */
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
ifdef|#
directive|ifdef
name|KR_headers
name|isaddr
parameter_list|(
name|p
parameter_list|)
specifier|register
name|expptr
name|p
decl_stmt|;
else|#
directive|else
function|isaddr
parameter_list|(
specifier|register
name|expptr
name|p
parameter_list|)
endif|#
directive|endif
block|{
if|if
condition|(
name|p
operator|->
name|tag
operator|==
name|TADDR
condition|)
return|return
operator|(
name|YES
operator|)
return|;
if|if
condition|(
name|p
operator|->
name|tag
operator|==
name|TEXPR
condition|)
switch|switch
condition|(
name|p
operator|->
name|exprblock
operator|.
name|opcode
condition|)
block|{
case|case
name|OPCOMMA
case|:
return|return
operator|(
name|isaddr
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|rightp
argument_list|)
operator|)
return|;
case|case
name|OPASSIGN
case|:
case|case
name|OPASSIGNI
case|:
case|case
name|OPPLUSEQ
case|:
case|case
name|OPMINUSEQ
case|:
case|case
name|OPSLASHEQ
case|:
case|case
name|OPMODEQ
case|:
case|case
name|OPLSHIFTEQ
case|:
case|case
name|OPRSHIFTEQ
case|:
case|case
name|OPBITANDEQ
case|:
case|case
name|OPBITXOREQ
case|:
case|case
name|OPBITOREQ
case|:
return|return
operator|(
name|isaddr
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|leftp
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
name|NO
operator|)
return|;
block|}
end_function

begin_function
name|int
ifdef|#
directive|ifdef
name|KR_headers
name|isstatic
parameter_list|(
name|p
parameter_list|)
specifier|register
name|expptr
name|p
decl_stmt|;
else|#
directive|else
function|isstatic
parameter_list|(
specifier|register
name|expptr
name|p
parameter_list|)
endif|#
directive|endif
block|{
specifier|extern
name|int
name|useauto
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|headblock
operator|.
name|vleng
operator|&&
operator|!
name|ISCONST
argument_list|(
name|p
operator|->
name|headblock
operator|.
name|vleng
argument_list|)
condition|)
return|return
operator|(
name|NO
operator|)
return|;
switch|switch
condition|(
name|p
operator|->
name|tag
condition|)
block|{
case|case
name|TCONST
case|:
return|return
operator|(
name|YES
operator|)
return|;
case|case
name|TADDR
case|:
if|if
condition|(
name|ONEOF
argument_list|(
name|p
operator|->
name|addrblock
operator|.
name|vstg
argument_list|,
name|MSKSTATIC
argument_list|)
operator|&&
name|ISCONST
argument_list|(
name|p
operator|->
name|addrblock
operator|.
name|memoffset
argument_list|)
operator|&&
operator|!
name|useauto
condition|)
return|return
operator|(
name|YES
operator|)
return|;
default|default:
return|return
operator|(
name|NO
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* addressable -- return True iff it is a constant value, or can be    referenced by constant values */
end_comment

begin_function
name|int
ifdef|#
directive|ifdef
name|KR_headers
name|addressable
parameter_list|(
name|p
parameter_list|)
specifier|register
name|expptr
name|p
decl_stmt|;
else|#
directive|else
function|addressable
parameter_list|(
specifier|register
name|expptr
name|p
parameter_list|)
endif|#
directive|endif
block|{
switch|switch
condition|(
name|p
operator|->
name|tag
condition|)
block|{
case|case
name|TCONST
case|:
return|return
operator|(
name|YES
operator|)
return|;
case|case
name|TADDR
case|:
return|return
operator|(
name|addressable
argument_list|(
name|p
operator|->
name|addrblock
operator|.
name|memoffset
argument_list|)
operator|)
return|;
default|default:
return|return
operator|(
name|NO
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* isnegative_const -- returns true if the constant is negative.  Returns    false for imaginary and nonnumeric constants */
end_comment

begin_function
name|int
ifdef|#
directive|ifdef
name|KR_headers
name|isnegative_const
parameter_list|(
name|cp
parameter_list|)
name|struct
name|Constblock
modifier|*
name|cp
decl_stmt|;
else|#
directive|else
function|isnegative_const
parameter_list|(
name|struct
name|Constblock
modifier|*
name|cp
parameter_list|)
endif|#
directive|endif
block|{
name|int
name|retval
decl_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|cp
operator|->
name|vtype
condition|)
block|{
case|case
name|TYINT1
case|:
case|case
name|TYSHORT
case|:
case|case
name|TYLONG
case|:
ifdef|#
directive|ifdef
name|TYQUAD
case|case
name|TYQUAD
case|:
endif|#
directive|endif
name|retval
operator|=
name|cp
operator|->
name|Const
operator|.
name|ci
operator|<
literal|0
expr_stmt|;
break|break;
case|case
name|TYREAL
case|:
case|case
name|TYDREAL
case|:
name|retval
operator|=
name|cp
operator|->
name|vstg
condition|?
operator|*
name|cp
operator|->
name|Const
operator|.
name|cds
index|[
literal|0
index|]
operator|==
literal|'-'
else|:
name|cp
operator|->
name|Const
operator|.
name|cd
index|[
literal|0
index|]
operator|<
literal|0.0
expr_stmt|;
break|break;
default|default:
name|retval
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* switch */
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* isnegative_const */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|negate_const
parameter_list|(
name|cp
parameter_list|)
name|Constp
name|cp
decl_stmt|;
else|#
directive|else
function|negate_const
parameter_list|(
name|Constp
name|cp
parameter_list|)
endif|#
directive|endif
block|{
if|if
condition|(
name|cp
operator|==
operator|(
expr|struct
name|Constblock
operator|*
operator|)
name|NULL
condition|)
return|return;
switch|switch
condition|(
name|cp
operator|->
name|vtype
condition|)
block|{
case|case
name|TYINT1
case|:
case|case
name|TYSHORT
case|:
case|case
name|TYLONG
case|:
ifdef|#
directive|ifdef
name|TYQUAD
case|case
name|TYQUAD
case|:
endif|#
directive|endif
name|cp
operator|->
name|Const
operator|.
name|ci
operator|=
operator|-
name|cp
operator|->
name|Const
operator|.
name|ci
expr_stmt|;
break|break;
case|case
name|TYCOMPLEX
case|:
case|case
name|TYDCOMPLEX
case|:
if|if
condition|(
name|cp
operator|->
name|vstg
condition|)
switch|switch
condition|(
operator|*
name|cp
operator|->
name|Const
operator|.
name|cds
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'-'
case|:
operator|++
name|cp
operator|->
name|Const
operator|.
name|cds
index|[
literal|1
index|]
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
break|break;
default|default:
operator|--
name|cp
operator|->
name|Const
operator|.
name|cds
index|[
literal|1
index|]
expr_stmt|;
block|}
else|else
name|cp
operator|->
name|Const
operator|.
name|cd
index|[
literal|1
index|]
operator|=
operator|-
name|cp
operator|->
name|Const
operator|.
name|cd
index|[
literal|1
index|]
expr_stmt|;
comment|/* no break */
case|case
name|TYREAL
case|:
case|case
name|TYDREAL
case|:
if|if
condition|(
name|cp
operator|->
name|vstg
condition|)
switch|switch
condition|(
operator|*
name|cp
operator|->
name|Const
operator|.
name|cds
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'-'
case|:
operator|++
name|cp
operator|->
name|Const
operator|.
name|cds
index|[
literal|0
index|]
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
break|break;
default|default:
operator|--
name|cp
operator|->
name|Const
operator|.
name|cds
index|[
literal|0
index|]
expr_stmt|;
block|}
else|else
name|cp
operator|->
name|Const
operator|.
name|cd
index|[
literal|0
index|]
operator|=
operator|-
name|cp
operator|->
name|Const
operator|.
name|cd
index|[
literal|0
index|]
expr_stmt|;
break|break;
case|case
name|TYCHAR
case|:
case|case
name|TYLOGICAL1
case|:
case|case
name|TYLOGICAL2
case|:
case|case
name|TYLOGICAL
case|:
name|erri
argument_list|(
literal|"negate_const:  can't negate type '%d'"
argument_list|,
name|cp
operator|->
name|vtype
argument_list|)
expr_stmt|;
break|break;
default|default:
name|erri
argument_list|(
literal|"negate_const:  bad type '%d'"
argument_list|,
name|cp
operator|->
name|vtype
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* switch */
block|}
end_function

begin_comment
comment|/* negate_const */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|ffilecopy
parameter_list|(
name|infp
parameter_list|,
name|outfp
parameter_list|)
name|FILE
modifier|*
name|infp
decl_stmt|;
name|FILE
modifier|*
name|outfp
decl_stmt|;
else|#
directive|else
function|ffilecopy
parameter_list|(
name|FILE
modifier|*
name|infp
parameter_list|,
name|FILE
modifier|*
name|outfp
parameter_list|)
endif|#
directive|endif
block|{
while|while
condition|(
operator|!
name|feof
argument_list|(
name|infp
argument_list|)
condition|)
block|{
specifier|register
name|c
operator|=
name|getc
argument_list|(
name|infp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|feof
argument_list|(
name|infp
argument_list|)
condition|)
name|putc
argument_list|(
name|c
argument_list|,
name|outfp
argument_list|)
expr_stmt|;
block|}
comment|/* while */
block|}
end_function

begin_comment
comment|/* ffilecopy */
end_comment

begin_comment
comment|/* in_vector -- verifies whether   str   is in c_keywords.    If so, the index is returned else  -1  is returned.    c_keywords must be in alphabetical order (as defined by strcmp). */
end_comment

begin_function
name|int
ifdef|#
directive|ifdef
name|KR_headers
name|in_vector
parameter_list|(
name|str
parameter_list|,
name|keywds
parameter_list|,
name|n
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|char
modifier|*
modifier|*
name|keywds
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
else|#
directive|else
function|in_vector
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|char
modifier|*
modifier|*
name|keywds
parameter_list|,
specifier|register
name|int
name|n
parameter_list|)
endif|#
directive|endif
block|{
specifier|register
name|char
modifier|*
modifier|*
name|K
init|=
name|keywds
decl_stmt|;
specifier|register
name|int
name|n1
decl_stmt|,
name|t
decl_stmt|;
do|do
block|{
name|n1
operator|=
name|n
operator|>>
literal|1
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|t
operator|=
name|strcmp
argument_list|(
name|str
argument_list|,
name|K
index|[
name|n1
index|]
argument_list|)
operator|)
condition|)
return|return
name|K
operator|-
name|keywds
operator|+
name|n1
return|;
if|if
condition|(
name|t
operator|<
literal|0
condition|)
name|n
operator|=
name|n1
expr_stmt|;
else|else
block|{
name|n
operator|-=
operator|++
name|n1
expr_stmt|;
name|K
operator|+=
name|n1
expr_stmt|;
block|}
block|}
do|while
condition|(
name|n
operator|>
literal|0
condition|)
do|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* in_vector */
end_comment

begin_function
name|int
ifdef|#
directive|ifdef
name|KR_headers
name|is_negatable
parameter_list|(
name|Const
parameter_list|)
name|Constp
name|Const
decl_stmt|;
else|#
directive|else
function|is_negatable
parameter_list|(
name|Constp
name|Const
parameter_list|)
endif|#
directive|endif
block|{
name|int
name|retval
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|Const
operator|!=
operator|(
name|Constp
operator|)
name|NULL
condition|)
switch|switch
condition|(
name|Const
operator|->
name|vtype
condition|)
block|{
case|case
name|TYINT1
case|:
name|retval
operator|=
name|Const
operator|->
name|Const
operator|.
name|ci
operator|>=
operator|-
name|BIGGEST_CHAR
expr_stmt|;
break|break;
case|case
name|TYSHORT
case|:
name|retval
operator|=
name|Const
operator|->
name|Const
operator|.
name|ci
operator|>=
operator|-
name|BIGGEST_SHORT
expr_stmt|;
break|break;
case|case
name|TYLONG
case|:
ifdef|#
directive|ifdef
name|TYQUAD
case|case
name|TYQUAD
case|:
endif|#
directive|endif
name|retval
operator|=
name|Const
operator|->
name|Const
operator|.
name|ci
operator|>=
operator|-
name|BIGGEST_LONG
expr_stmt|;
break|break;
case|case
name|TYREAL
case|:
case|case
name|TYDREAL
case|:
case|case
name|TYCOMPLEX
case|:
case|case
name|TYDCOMPLEX
case|:
name|retval
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|TYLOGICAL1
case|:
case|case
name|TYLOGICAL2
case|:
case|case
name|TYLOGICAL
case|:
case|case
name|TYCHAR
case|:
case|case
name|TYSUBR
case|:
default|default:
name|retval
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* switch */
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* is_negatable */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|backup
parameter_list|(
name|fname
parameter_list|,
name|bname
parameter_list|)
name|char
modifier|*
name|fname
decl_stmt|;
name|char
modifier|*
name|bname
decl_stmt|;
else|#
directive|else
function|backup
parameter_list|(
name|char
modifier|*
name|fname
parameter_list|,
name|char
modifier|*
name|bname
parameter_list|)
endif|#
directive|endif
block|{
name|FILE
modifier|*
name|b
decl_stmt|,
modifier|*
name|f
decl_stmt|;
specifier|static
name|char
name|couldnt
index|[]
init|=
literal|"Couldn't open %.80s"
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|f
operator|=
name|fopen
argument_list|(
name|fname
argument_list|,
name|binread
argument_list|)
operator|)
condition|)
block|{
name|warn1
argument_list|(
name|couldnt
argument_list|,
name|fname
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
operator|(
name|b
operator|=
name|fopen
argument_list|(
name|bname
argument_list|,
name|binwrite
argument_list|)
operator|)
condition|)
block|{
name|warn1
argument_list|(
name|couldnt
argument_list|,
name|bname
argument_list|)
expr_stmt|;
return|return;
block|}
name|ffilecopy
argument_list|(
name|f
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* struct_eq -- returns YES if structures have the same field names and    types, NO otherwise */
end_comment

begin_function
name|int
ifdef|#
directive|ifdef
name|KR_headers
name|struct_eq
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|)
name|chainp
name|s1
decl_stmt|;
name|chainp
name|s2
decl_stmt|;
else|#
directive|else
function|struct_eq
parameter_list|(
name|chainp
name|s1
parameter_list|,
name|chainp
name|s2
parameter_list|)
endif|#
directive|endif
block|{
name|struct
name|Dimblock
modifier|*
name|d1
decl_stmt|,
modifier|*
name|d2
decl_stmt|;
name|Constp
name|cp1
decl_stmt|,
name|cp2
decl_stmt|;
if|if
condition|(
name|s1
operator|==
name|CHNULL
operator|&&
name|s2
operator|==
name|CHNULL
condition|)
return|return
name|YES
return|;
for|for
control|(
init|;
name|s1
operator|&&
name|s2
condition|;
name|s1
operator|=
name|s1
operator|->
name|nextp
operator|,
name|s2
operator|=
name|s2
operator|->
name|nextp
control|)
block|{
specifier|register
name|Namep
name|v1
init|=
operator|(
name|Namep
operator|)
name|s1
operator|->
name|datap
decl_stmt|;
specifier|register
name|Namep
name|v2
init|=
operator|(
name|Namep
operator|)
name|s2
operator|->
name|datap
decl_stmt|;
if|if
condition|(
name|v1
operator|==
operator|(
name|Namep
operator|)
name|NULL
operator|||
name|v1
operator|->
name|tag
operator|!=
name|TNAME
operator|||
name|v2
operator|==
operator|(
name|Namep
operator|)
name|NULL
operator|||
name|v2
operator|->
name|tag
operator|!=
name|TNAME
condition|)
return|return
name|NO
return|;
if|if
condition|(
name|v1
operator|->
name|vtype
operator|!=
name|v2
operator|->
name|vtype
operator|||
name|v1
operator|->
name|vclass
operator|!=
name|v2
operator|->
name|vclass
operator|||
name|strcmp
argument_list|(
name|v1
operator|->
name|fvarname
argument_list|,
name|v2
operator|->
name|fvarname
argument_list|)
condition|)
return|return
name|NO
return|;
comment|/* compare dimensions (needed for comparing COMMON blocks) */
if|if
condition|(
name|d1
operator|=
name|v1
operator|->
name|vdim
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|cp1
operator|=
operator|(
name|Constp
operator|)
name|d1
operator|->
name|nelt
operator|)
operator|||
name|cp1
operator|->
name|tag
operator|!=
name|TCONST
operator|||
operator|!
operator|(
name|d2
operator|=
name|v2
operator|->
name|vdim
operator|)
operator|||
operator|!
operator|(
name|cp2
operator|=
operator|(
name|Constp
operator|)
name|d2
operator|->
name|nelt
operator|)
operator|||
name|cp2
operator|->
name|tag
operator|!=
name|TCONST
operator|||
name|cp1
operator|->
name|Const
operator|.
name|ci
operator|!=
name|cp2
operator|->
name|Const
operator|.
name|ci
condition|)
return|return
name|NO
return|;
block|}
elseif|else
if|if
condition|(
name|v2
operator|->
name|vdim
condition|)
return|return
name|NO
return|;
block|}
comment|/* while s1 != CHNULL&& s2 != CHNULL */
return|return
name|s1
operator|==
name|CHNULL
operator|&&
name|s2
operator|==
name|CHNULL
return|;
block|}
end_function

begin_comment
comment|/* struct_eq */
end_comment

end_unit

