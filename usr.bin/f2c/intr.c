begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**************************************************************** Copyright 1990, 1992, 1994-5 by AT&T Bell Laboratories and Bellcore.  Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that the copyright notice and this permission notice and warranty disclaimer appear in supporting documentation, and that the names of AT&T Bell Laboratories or Bellcore or any of their entities not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  AT&T and Bellcore disclaim all warranties with regard to this software, including all implied warranties of merchantability and fitness.  In no event shall AT&T or Bellcore be liable for any special, indirect or consequential damages or any damages whatsoever resulting from loss of use, data or profits, whether in an action of contract, negligence or other tortious action, arising out of or in connection with the use or performance of this software. ****************************************************************/
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"names.h"
end_include

begin_union
union|union
block|{
name|int
name|ijunk
decl_stmt|;
name|struct
name|Intrpacked
name|bits
decl_stmt|;
block|}
name|packed
union|;
end_union

begin_struct
struct|struct
name|Intrbits
block|{
name|char
name|intrgroup
comment|/* :3 */
decl_stmt|;
name|char
name|intrstuff
comment|/* result type or number of generics */
decl_stmt|;
name|char
name|intrno
comment|/* :7 */
decl_stmt|;
name|char
name|dblcmplx
decl_stmt|;
name|char
name|dblintrno
decl_stmt|;
comment|/* for -r8 */
block|}
struct|;
end_struct

begin_comment
comment|/* List of all intrinsic functions.  */
end_comment

begin_macro
name|LOCAL
end_macro

begin_struct
struct|struct
name|Intrblock
block|{
name|char
name|intrfname
index|[
literal|8
index|]
decl_stmt|;
name|struct
name|Intrbits
name|intrval
decl_stmt|;
block|}
name|intrtab
index|[ ]
init|=
block|{
literal|"int"
block|,
block|{
name|INTRCONV
block|,
name|TYLONG
block|}
block|,
literal|"real"
block|,
block|{
name|INTRCONV
block|,
name|TYREAL
block|,
literal|1
block|}
block|,
comment|/* 1 ==> real(TYDCOMPLEX) yields TYDREAL */
literal|"dble"
block|,
block|{
name|INTRCONV
block|,
name|TYDREAL
block|}
block|,
literal|"cmplx"
block|,
block|{
name|INTRCONV
block|,
name|TYCOMPLEX
block|}
block|,
literal|"dcmplx"
block|,
block|{
name|INTRCONV
block|,
name|TYDCOMPLEX
block|,
literal|0
block|,
literal|1
block|}
block|,
literal|"ifix"
block|,
block|{
name|INTRCONV
block|,
name|TYLONG
block|}
block|,
literal|"idint"
block|,
block|{
name|INTRCONV
block|,
name|TYLONG
block|}
block|,
literal|"float"
block|,
block|{
name|INTRCONV
block|,
name|TYREAL
block|}
block|,
literal|"dfloat"
block|,
block|{
name|INTRCONV
block|,
name|TYDREAL
block|}
block|,
literal|"sngl"
block|,
block|{
name|INTRCONV
block|,
name|TYREAL
block|}
block|,
literal|"ichar"
block|,
block|{
name|INTRCONV
block|,
name|TYLONG
block|}
block|,
literal|"iachar"
block|,
block|{
name|INTRCONV
block|,
name|TYLONG
block|}
block|,
literal|"char"
block|,
block|{
name|INTRCONV
block|,
name|TYCHAR
block|}
block|,
literal|"achar"
block|,
block|{
name|INTRCONV
block|,
name|TYCHAR
block|}
block|,
comment|/* any MAX or MIN can be used with any types; the compiler will cast them    correctly.  So rules against bad syntax in these expressions are not    enforced */
literal|"max"
block|,
block|{
name|INTRMAX
block|,
name|TYUNKNOWN
block|}
block|,
literal|"max0"
block|,
block|{
name|INTRMAX
block|,
name|TYLONG
block|}
block|,
literal|"amax0"
block|,
block|{
name|INTRMAX
block|,
name|TYREAL
block|}
block|,
literal|"max1"
block|,
block|{
name|INTRMAX
block|,
name|TYLONG
block|}
block|,
literal|"amax1"
block|,
block|{
name|INTRMAX
block|,
name|TYREAL
block|}
block|,
literal|"dmax1"
block|,
block|{
name|INTRMAX
block|,
name|TYDREAL
block|}
block|,
literal|"and"
block|,
block|{
name|INTRBOOL
block|,
name|TYUNKNOWN
block|,
name|OPBITAND
block|}
block|,
literal|"or"
block|,
block|{
name|INTRBOOL
block|,
name|TYUNKNOWN
block|,
name|OPBITOR
block|}
block|,
literal|"xor"
block|,
block|{
name|INTRBOOL
block|,
name|TYUNKNOWN
block|,
name|OPBITXOR
block|}
block|,
literal|"not"
block|,
block|{
name|INTRBOOL
block|,
name|TYUNKNOWN
block|,
name|OPBITNOT
block|}
block|,
literal|"lshift"
block|,
block|{
name|INTRBOOL
block|,
name|TYUNKNOWN
block|,
name|OPLSHIFT
block|}
block|,
literal|"rshift"
block|,
block|{
name|INTRBOOL
block|,
name|TYUNKNOWN
block|,
name|OPRSHIFT
block|}
block|,
literal|"min"
block|,
block|{
name|INTRMIN
block|,
name|TYUNKNOWN
block|}
block|,
literal|"min0"
block|,
block|{
name|INTRMIN
block|,
name|TYLONG
block|}
block|,
literal|"amin0"
block|,
block|{
name|INTRMIN
block|,
name|TYREAL
block|}
block|,
literal|"min1"
block|,
block|{
name|INTRMIN
block|,
name|TYLONG
block|}
block|,
literal|"amin1"
block|,
block|{
name|INTRMIN
block|,
name|TYREAL
block|}
block|,
literal|"dmin1"
block|,
block|{
name|INTRMIN
block|,
name|TYDREAL
block|}
block|,
literal|"aint"
block|,
block|{
name|INTRGEN
block|,
literal|2
block|,
literal|0
block|}
block|,
literal|"dint"
block|,
block|{
name|INTRSPEC
block|,
name|TYDREAL
block|,
literal|1
block|}
block|,
literal|"anint"
block|,
block|{
name|INTRGEN
block|,
literal|2
block|,
literal|2
block|}
block|,
literal|"dnint"
block|,
block|{
name|INTRSPEC
block|,
name|TYDREAL
block|,
literal|3
block|}
block|,
literal|"nint"
block|,
block|{
name|INTRGEN
block|,
literal|4
block|,
literal|4
block|}
block|,
literal|"idnint"
block|,
block|{
name|INTRGEN
block|,
literal|2
block|,
literal|6
block|}
block|,
literal|"abs"
block|,
block|{
name|INTRGEN
block|,
literal|6
block|,
literal|8
block|}
block|,
literal|"iabs"
block|,
block|{
name|INTRGEN
block|,
literal|2
block|,
literal|9
block|}
block|,
literal|"dabs"
block|,
block|{
name|INTRSPEC
block|,
name|TYDREAL
block|,
literal|11
block|}
block|,
literal|"cabs"
block|,
block|{
name|INTRSPEC
block|,
name|TYREAL
block|,
literal|12
block|,
literal|0
block|,
literal|13
block|}
block|,
literal|"zabs"
block|,
block|{
name|INTRSPEC
block|,
name|TYDREAL
block|,
literal|13
block|,
literal|1
block|}
block|,
literal|"mod"
block|,
block|{
name|INTRGEN
block|,
literal|4
block|,
literal|14
block|}
block|,
literal|"amod"
block|,
block|{
name|INTRSPEC
block|,
name|TYREAL
block|,
literal|16
block|,
literal|0
block|,
literal|17
block|}
block|,
literal|"dmod"
block|,
block|{
name|INTRSPEC
block|,
name|TYDREAL
block|,
literal|17
block|}
block|,
literal|"sign"
block|,
block|{
name|INTRGEN
block|,
literal|4
block|,
literal|18
block|}
block|,
literal|"isign"
block|,
block|{
name|INTRGEN
block|,
literal|2
block|,
literal|19
block|}
block|,
literal|"dsign"
block|,
block|{
name|INTRSPEC
block|,
name|TYDREAL
block|,
literal|21
block|}
block|,
literal|"dim"
block|,
block|{
name|INTRGEN
block|,
literal|4
block|,
literal|22
block|}
block|,
literal|"idim"
block|,
block|{
name|INTRGEN
block|,
literal|2
block|,
literal|23
block|}
block|,
literal|"ddim"
block|,
block|{
name|INTRSPEC
block|,
name|TYDREAL
block|,
literal|25
block|}
block|,
literal|"dprod"
block|,
block|{
name|INTRSPEC
block|,
name|TYDREAL
block|,
literal|26
block|}
block|,
literal|"len"
block|,
block|{
name|INTRSPEC
block|,
name|TYLONG
block|,
literal|27
block|}
block|,
literal|"index"
block|,
block|{
name|INTRSPEC
block|,
name|TYLONG
block|,
literal|29
block|}
block|,
literal|"imag"
block|,
block|{
name|INTRGEN
block|,
literal|2
block|,
literal|31
block|}
block|,
literal|"aimag"
block|,
block|{
name|INTRSPEC
block|,
name|TYREAL
block|,
literal|31
block|,
literal|0
block|,
literal|32
block|}
block|,
literal|"dimag"
block|,
block|{
name|INTRSPEC
block|,
name|TYDREAL
block|,
literal|32
block|}
block|,
literal|"conjg"
block|,
block|{
name|INTRGEN
block|,
literal|2
block|,
literal|33
block|}
block|,
literal|"dconjg"
block|,
block|{
name|INTRSPEC
block|,
name|TYDCOMPLEX
block|,
literal|34
block|,
literal|1
block|}
block|,
literal|"sqrt"
block|,
block|{
name|INTRGEN
block|,
literal|4
block|,
literal|35
block|}
block|,
literal|"dsqrt"
block|,
block|{
name|INTRSPEC
block|,
name|TYDREAL
block|,
literal|36
block|}
block|,
literal|"csqrt"
block|,
block|{
name|INTRSPEC
block|,
name|TYCOMPLEX
block|,
literal|37
block|,
literal|0
block|,
literal|38
block|}
block|,
literal|"zsqrt"
block|,
block|{
name|INTRSPEC
block|,
name|TYDCOMPLEX
block|,
literal|38
block|,
literal|1
block|}
block|,
literal|"exp"
block|,
block|{
name|INTRGEN
block|,
literal|4
block|,
literal|39
block|}
block|,
literal|"dexp"
block|,
block|{
name|INTRSPEC
block|,
name|TYDREAL
block|,
literal|40
block|}
block|,
literal|"cexp"
block|,
block|{
name|INTRSPEC
block|,
name|TYCOMPLEX
block|,
literal|41
block|,
literal|0
block|,
literal|42
block|}
block|,
literal|"zexp"
block|,
block|{
name|INTRSPEC
block|,
name|TYDCOMPLEX
block|,
literal|42
block|,
literal|1
block|}
block|,
literal|"log"
block|,
block|{
name|INTRGEN
block|,
literal|4
block|,
literal|43
block|}
block|,
literal|"alog"
block|,
block|{
name|INTRSPEC
block|,
name|TYREAL
block|,
literal|43
block|,
literal|0
block|,
literal|44
block|}
block|,
literal|"dlog"
block|,
block|{
name|INTRSPEC
block|,
name|TYDREAL
block|,
literal|44
block|}
block|,
literal|"clog"
block|,
block|{
name|INTRSPEC
block|,
name|TYCOMPLEX
block|,
literal|45
block|,
literal|0
block|,
literal|46
block|}
block|,
literal|"zlog"
block|,
block|{
name|INTRSPEC
block|,
name|TYDCOMPLEX
block|,
literal|46
block|,
literal|1
block|}
block|,
literal|"log10"
block|,
block|{
name|INTRGEN
block|,
literal|2
block|,
literal|47
block|}
block|,
literal|"alog10"
block|,
block|{
name|INTRSPEC
block|,
name|TYREAL
block|,
literal|47
block|,
literal|0
block|,
literal|48
block|}
block|,
literal|"dlog10"
block|,
block|{
name|INTRSPEC
block|,
name|TYDREAL
block|,
literal|48
block|}
block|,
literal|"sin"
block|,
block|{
name|INTRGEN
block|,
literal|4
block|,
literal|49
block|}
block|,
literal|"dsin"
block|,
block|{
name|INTRSPEC
block|,
name|TYDREAL
block|,
literal|50
block|}
block|,
literal|"csin"
block|,
block|{
name|INTRSPEC
block|,
name|TYCOMPLEX
block|,
literal|51
block|,
literal|0
block|,
literal|52
block|}
block|,
literal|"zsin"
block|,
block|{
name|INTRSPEC
block|,
name|TYDCOMPLEX
block|,
literal|52
block|,
literal|1
block|}
block|,
literal|"cos"
block|,
block|{
name|INTRGEN
block|,
literal|4
block|,
literal|53
block|}
block|,
literal|"dcos"
block|,
block|{
name|INTRSPEC
block|,
name|TYDREAL
block|,
literal|54
block|}
block|,
literal|"ccos"
block|,
block|{
name|INTRSPEC
block|,
name|TYCOMPLEX
block|,
literal|55
block|,
literal|0
block|,
literal|56
block|}
block|,
literal|"zcos"
block|,
block|{
name|INTRSPEC
block|,
name|TYDCOMPLEX
block|,
literal|56
block|,
literal|1
block|}
block|,
literal|"tan"
block|,
block|{
name|INTRGEN
block|,
literal|2
block|,
literal|57
block|}
block|,
literal|"dtan"
block|,
block|{
name|INTRSPEC
block|,
name|TYDREAL
block|,
literal|58
block|}
block|,
literal|"asin"
block|,
block|{
name|INTRGEN
block|,
literal|2
block|,
literal|59
block|}
block|,
literal|"dasin"
block|,
block|{
name|INTRSPEC
block|,
name|TYDREAL
block|,
literal|60
block|}
block|,
literal|"acos"
block|,
block|{
name|INTRGEN
block|,
literal|2
block|,
literal|61
block|}
block|,
literal|"dacos"
block|,
block|{
name|INTRSPEC
block|,
name|TYDREAL
block|,
literal|62
block|}
block|,
literal|"atan"
block|,
block|{
name|INTRGEN
block|,
literal|2
block|,
literal|63
block|}
block|,
literal|"datan"
block|,
block|{
name|INTRSPEC
block|,
name|TYDREAL
block|,
literal|64
block|}
block|,
literal|"atan2"
block|,
block|{
name|INTRGEN
block|,
literal|2
block|,
literal|65
block|}
block|,
literal|"datan2"
block|,
block|{
name|INTRSPEC
block|,
name|TYDREAL
block|,
literal|66
block|}
block|,
literal|"sinh"
block|,
block|{
name|INTRGEN
block|,
literal|2
block|,
literal|67
block|}
block|,
literal|"dsinh"
block|,
block|{
name|INTRSPEC
block|,
name|TYDREAL
block|,
literal|68
block|}
block|,
literal|"cosh"
block|,
block|{
name|INTRGEN
block|,
literal|2
block|,
literal|69
block|}
block|,
literal|"dcosh"
block|,
block|{
name|INTRSPEC
block|,
name|TYDREAL
block|,
literal|70
block|}
block|,
literal|"tanh"
block|,
block|{
name|INTRGEN
block|,
literal|2
block|,
literal|71
block|}
block|,
literal|"dtanh"
block|,
block|{
name|INTRSPEC
block|,
name|TYDREAL
block|,
literal|72
block|}
block|,
literal|"lge"
block|,
block|{
name|INTRSPEC
block|,
name|TYLOGICAL
block|,
literal|73
block|}
block|,
literal|"lgt"
block|,
block|{
name|INTRSPEC
block|,
name|TYLOGICAL
block|,
literal|75
block|}
block|,
literal|"lle"
block|,
block|{
name|INTRSPEC
block|,
name|TYLOGICAL
block|,
literal|77
block|}
block|,
literal|"llt"
block|,
block|{
name|INTRSPEC
block|,
name|TYLOGICAL
block|,
literal|79
block|}
block|,
if|#
directive|if
literal|0
block|"epbase",	{ INTRCNST, 4, 0 }, "epprec",	{ INTRCNST, 4, 4 }, "epemin",	{ INTRCNST, 2, 8 }, "epemax",	{ INTRCNST, 2, 10 }, "eptiny",	{ INTRCNST, 2, 12 }, "ephuge",	{ INTRCNST, 4, 14 }, "epmrsp",	{ INTRCNST, 2, 18 },
endif|#
directive|endif
literal|"fpexpn"
block|,
block|{
name|INTRGEN
block|,
literal|4
block|,
literal|81
block|}
block|,
literal|"fpabsp"
block|,
block|{
name|INTRGEN
block|,
literal|2
block|,
literal|85
block|}
block|,
literal|"fprrsp"
block|,
block|{
name|INTRGEN
block|,
literal|2
block|,
literal|87
block|}
block|,
literal|"fpfrac"
block|,
block|{
name|INTRGEN
block|,
literal|2
block|,
literal|89
block|}
block|,
literal|"fpmake"
block|,
block|{
name|INTRGEN
block|,
literal|2
block|,
literal|91
block|}
block|,
literal|"fpscal"
block|,
block|{
name|INTRGEN
block|,
literal|2
block|,
literal|93
block|}
block|,
literal|""
block|}
struct|;
end_struct

begin_macro
name|LOCAL
end_macro

begin_struct
struct|struct
name|Specblock
block|{
name|char
name|atype
decl_stmt|;
comment|/* Argument type; every arg must have 				   this type */
name|char
name|rtype
decl_stmt|;
comment|/* Result type */
name|char
name|nargs
decl_stmt|;
comment|/* Number of arguments */
name|char
name|spxname
index|[
literal|8
index|]
decl_stmt|;
comment|/* Name of the function in Fortran */
name|char
name|othername
decl_stmt|;
comment|/* index into callbyvalue table */
block|}
name|spectab
index|[ ]
init|=
block|{
block|{
name|TYREAL
block|,
name|TYREAL
block|,
literal|1
block|,
literal|"r_int"
block|}
block|,
block|{
name|TYDREAL
block|,
name|TYDREAL
block|,
literal|1
block|,
literal|"d_int"
block|}
block|,
block|{
name|TYREAL
block|,
name|TYREAL
block|,
literal|1
block|,
literal|"r_nint"
block|}
block|,
block|{
name|TYDREAL
block|,
name|TYDREAL
block|,
literal|1
block|,
literal|"d_nint"
block|}
block|,
block|{
name|TYREAL
block|,
name|TYSHORT
block|,
literal|1
block|,
literal|"h_nint"
block|}
block|,
block|{
name|TYREAL
block|,
name|TYLONG
block|,
literal|1
block|,
literal|"i_nint"
block|}
block|,
block|{
name|TYDREAL
block|,
name|TYSHORT
block|,
literal|1
block|,
literal|"h_dnnt"
block|}
block|,
block|{
name|TYDREAL
block|,
name|TYLONG
block|,
literal|1
block|,
literal|"i_dnnt"
block|}
block|,
block|{
name|TYREAL
block|,
name|TYREAL
block|,
literal|1
block|,
literal|"r_abs"
block|}
block|,
block|{
name|TYSHORT
block|,
name|TYSHORT
block|,
literal|1
block|,
literal|"h_abs"
block|}
block|,
block|{
name|TYLONG
block|,
name|TYLONG
block|,
literal|1
block|,
literal|"i_abs"
block|}
block|,
block|{
name|TYDREAL
block|,
name|TYDREAL
block|,
literal|1
block|,
literal|"d_abs"
block|}
block|,
block|{
name|TYCOMPLEX
block|,
name|TYREAL
block|,
literal|1
block|,
literal|"c_abs"
block|}
block|,
block|{
name|TYDCOMPLEX
block|,
name|TYDREAL
block|,
literal|1
block|,
literal|"z_abs"
block|}
block|,
block|{
name|TYSHORT
block|,
name|TYSHORT
block|,
literal|2
block|,
literal|"h_mod"
block|}
block|,
block|{
name|TYLONG
block|,
name|TYLONG
block|,
literal|2
block|,
literal|"i_mod"
block|}
block|,
block|{
name|TYREAL
block|,
name|TYREAL
block|,
literal|2
block|,
literal|"r_mod"
block|}
block|,
block|{
name|TYDREAL
block|,
name|TYDREAL
block|,
literal|2
block|,
literal|"d_mod"
block|}
block|,
block|{
name|TYREAL
block|,
name|TYREAL
block|,
literal|2
block|,
literal|"r_sign"
block|}
block|,
block|{
name|TYSHORT
block|,
name|TYSHORT
block|,
literal|2
block|,
literal|"h_sign"
block|}
block|,
block|{
name|TYLONG
block|,
name|TYLONG
block|,
literal|2
block|,
literal|"i_sign"
block|}
block|,
block|{
name|TYDREAL
block|,
name|TYDREAL
block|,
literal|2
block|,
literal|"d_sign"
block|}
block|,
block|{
name|TYREAL
block|,
name|TYREAL
block|,
literal|2
block|,
literal|"r_dim"
block|}
block|,
block|{
name|TYSHORT
block|,
name|TYSHORT
block|,
literal|2
block|,
literal|"h_dim"
block|}
block|,
block|{
name|TYLONG
block|,
name|TYLONG
block|,
literal|2
block|,
literal|"i_dim"
block|}
block|,
block|{
name|TYDREAL
block|,
name|TYDREAL
block|,
literal|2
block|,
literal|"d_dim"
block|}
block|,
block|{
name|TYREAL
block|,
name|TYDREAL
block|,
literal|2
block|,
literal|"d_prod"
block|}
block|,
block|{
name|TYCHAR
block|,
name|TYSHORT
block|,
literal|1
block|,
literal|"h_len"
block|}
block|,
block|{
name|TYCHAR
block|,
name|TYLONG
block|,
literal|1
block|,
literal|"i_len"
block|}
block|,
block|{
name|TYCHAR
block|,
name|TYSHORT
block|,
literal|2
block|,
literal|"h_indx"
block|}
block|,
block|{
name|TYCHAR
block|,
name|TYLONG
block|,
literal|2
block|,
literal|"i_indx"
block|}
block|,
block|{
name|TYCOMPLEX
block|,
name|TYREAL
block|,
literal|1
block|,
literal|"r_imag"
block|}
block|,
block|{
name|TYDCOMPLEX
block|,
name|TYDREAL
block|,
literal|1
block|,
literal|"d_imag"
block|}
block|,
block|{
name|TYCOMPLEX
block|,
name|TYCOMPLEX
block|,
literal|1
block|,
literal|"r_cnjg"
block|}
block|,
block|{
name|TYDCOMPLEX
block|,
name|TYDCOMPLEX
block|,
literal|1
block|,
literal|"d_cnjg"
block|}
block|,
block|{
name|TYREAL
block|,
name|TYREAL
block|,
literal|1
block|,
literal|"r_sqrt"
block|,
literal|1
block|}
block|,
block|{
name|TYDREAL
block|,
name|TYDREAL
block|,
literal|1
block|,
literal|"d_sqrt"
block|,
literal|1
block|}
block|,
block|{
name|TYCOMPLEX
block|,
name|TYCOMPLEX
block|,
literal|1
block|,
literal|"c_sqrt"
block|}
block|,
block|{
name|TYDCOMPLEX
block|,
name|TYDCOMPLEX
block|,
literal|1
block|,
literal|"z_sqrt"
block|}
block|,
block|{
name|TYREAL
block|,
name|TYREAL
block|,
literal|1
block|,
literal|"r_exp"
block|,
literal|2
block|}
block|,
block|{
name|TYDREAL
block|,
name|TYDREAL
block|,
literal|1
block|,
literal|"d_exp"
block|,
literal|2
block|}
block|,
block|{
name|TYCOMPLEX
block|,
name|TYCOMPLEX
block|,
literal|1
block|,
literal|"c_exp"
block|}
block|,
block|{
name|TYDCOMPLEX
block|,
name|TYDCOMPLEX
block|,
literal|1
block|,
literal|"z_exp"
block|}
block|,
block|{
name|TYREAL
block|,
name|TYREAL
block|,
literal|1
block|,
literal|"r_log"
block|,
literal|3
block|}
block|,
block|{
name|TYDREAL
block|,
name|TYDREAL
block|,
literal|1
block|,
literal|"d_log"
block|,
literal|3
block|}
block|,
block|{
name|TYCOMPLEX
block|,
name|TYCOMPLEX
block|,
literal|1
block|,
literal|"c_log"
block|}
block|,
block|{
name|TYDCOMPLEX
block|,
name|TYDCOMPLEX
block|,
literal|1
block|,
literal|"z_log"
block|}
block|,
block|{
name|TYREAL
block|,
name|TYREAL
block|,
literal|1
block|,
literal|"r_lg10"
block|}
block|,
block|{
name|TYDREAL
block|,
name|TYDREAL
block|,
literal|1
block|,
literal|"d_lg10"
block|}
block|,
block|{
name|TYREAL
block|,
name|TYREAL
block|,
literal|1
block|,
literal|"r_sin"
block|,
literal|4
block|}
block|,
block|{
name|TYDREAL
block|,
name|TYDREAL
block|,
literal|1
block|,
literal|"d_sin"
block|,
literal|4
block|}
block|,
block|{
name|TYCOMPLEX
block|,
name|TYCOMPLEX
block|,
literal|1
block|,
literal|"c_sin"
block|}
block|,
block|{
name|TYDCOMPLEX
block|,
name|TYDCOMPLEX
block|,
literal|1
block|,
literal|"z_sin"
block|}
block|,
block|{
name|TYREAL
block|,
name|TYREAL
block|,
literal|1
block|,
literal|"r_cos"
block|,
literal|5
block|}
block|,
block|{
name|TYDREAL
block|,
name|TYDREAL
block|,
literal|1
block|,
literal|"d_cos"
block|,
literal|5
block|}
block|,
block|{
name|TYCOMPLEX
block|,
name|TYCOMPLEX
block|,
literal|1
block|,
literal|"c_cos"
block|}
block|,
block|{
name|TYDCOMPLEX
block|,
name|TYDCOMPLEX
block|,
literal|1
block|,
literal|"z_cos"
block|}
block|,
block|{
name|TYREAL
block|,
name|TYREAL
block|,
literal|1
block|,
literal|"r_tan"
block|,
literal|6
block|}
block|,
block|{
name|TYDREAL
block|,
name|TYDREAL
block|,
literal|1
block|,
literal|"d_tan"
block|,
literal|6
block|}
block|,
block|{
name|TYREAL
block|,
name|TYREAL
block|,
literal|1
block|,
literal|"r_asin"
block|,
literal|7
block|}
block|,
block|{
name|TYDREAL
block|,
name|TYDREAL
block|,
literal|1
block|,
literal|"d_asin"
block|,
literal|7
block|}
block|,
block|{
name|TYREAL
block|,
name|TYREAL
block|,
literal|1
block|,
literal|"r_acos"
block|,
literal|8
block|}
block|,
block|{
name|TYDREAL
block|,
name|TYDREAL
block|,
literal|1
block|,
literal|"d_acos"
block|,
literal|8
block|}
block|,
block|{
name|TYREAL
block|,
name|TYREAL
block|,
literal|1
block|,
literal|"r_atan"
block|,
literal|9
block|}
block|,
block|{
name|TYDREAL
block|,
name|TYDREAL
block|,
literal|1
block|,
literal|"d_atan"
block|,
literal|9
block|}
block|,
block|{
name|TYREAL
block|,
name|TYREAL
block|,
literal|2
block|,
literal|"r_atn2"
block|,
literal|10
block|}
block|,
block|{
name|TYDREAL
block|,
name|TYDREAL
block|,
literal|2
block|,
literal|"d_atn2"
block|,
literal|10
block|}
block|,
block|{
name|TYREAL
block|,
name|TYREAL
block|,
literal|1
block|,
literal|"r_sinh"
block|,
literal|11
block|}
block|,
block|{
name|TYDREAL
block|,
name|TYDREAL
block|,
literal|1
block|,
literal|"d_sinh"
block|,
literal|11
block|}
block|,
block|{
name|TYREAL
block|,
name|TYREAL
block|,
literal|1
block|,
literal|"r_cosh"
block|,
literal|12
block|}
block|,
block|{
name|TYDREAL
block|,
name|TYDREAL
block|,
literal|1
block|,
literal|"d_cosh"
block|,
literal|12
block|}
block|,
block|{
name|TYREAL
block|,
name|TYREAL
block|,
literal|1
block|,
literal|"r_tanh"
block|,
literal|13
block|}
block|,
block|{
name|TYDREAL
block|,
name|TYDREAL
block|,
literal|1
block|,
literal|"d_tanh"
block|,
literal|13
block|}
block|,
block|{
name|TYCHAR
block|,
name|TYLOGICAL
block|,
literal|2
block|,
literal|"hl_ge"
block|}
block|,
block|{
name|TYCHAR
block|,
name|TYLOGICAL
block|,
literal|2
block|,
literal|"l_ge"
block|}
block|,
block|{
name|TYCHAR
block|,
name|TYLOGICAL
block|,
literal|2
block|,
literal|"hl_gt"
block|}
block|,
block|{
name|TYCHAR
block|,
name|TYLOGICAL
block|,
literal|2
block|,
literal|"l_gt"
block|}
block|,
block|{
name|TYCHAR
block|,
name|TYLOGICAL
block|,
literal|2
block|,
literal|"hl_le"
block|}
block|,
block|{
name|TYCHAR
block|,
name|TYLOGICAL
block|,
literal|2
block|,
literal|"l_le"
block|}
block|,
block|{
name|TYCHAR
block|,
name|TYLOGICAL
block|,
literal|2
block|,
literal|"hl_lt"
block|}
block|,
block|{
name|TYCHAR
block|,
name|TYLOGICAL
block|,
literal|2
block|,
literal|"l_lt"
block|}
block|,
block|{
name|TYREAL
block|,
name|TYSHORT
block|,
literal|1
block|,
literal|"hr_expn"
block|}
block|,
block|{
name|TYREAL
block|,
name|TYLONG
block|,
literal|1
block|,
literal|"ir_expn"
block|}
block|,
block|{
name|TYDREAL
block|,
name|TYSHORT
block|,
literal|1
block|,
literal|"hd_expn"
block|}
block|,
block|{
name|TYDREAL
block|,
name|TYLONG
block|,
literal|1
block|,
literal|"id_expn"
block|}
block|,
block|{
name|TYREAL
block|,
name|TYREAL
block|,
literal|1
block|,
literal|"r_absp"
block|}
block|,
block|{
name|TYDREAL
block|,
name|TYDREAL
block|,
literal|1
block|,
literal|"d_absp"
block|}
block|,
block|{
name|TYREAL
block|,
name|TYDREAL
block|,
literal|1
block|,
literal|"r_rrsp"
block|}
block|,
block|{
name|TYDREAL
block|,
name|TYDREAL
block|,
literal|1
block|,
literal|"d_rrsp"
block|}
block|,
block|{
name|TYREAL
block|,
name|TYREAL
block|,
literal|1
block|,
literal|"r_frac"
block|}
block|,
block|{
name|TYDREAL
block|,
name|TYDREAL
block|,
literal|1
block|,
literal|"d_frac"
block|}
block|,
block|{
name|TYREAL
block|,
name|TYREAL
block|,
literal|2
block|,
literal|"r_make"
block|}
block|,
block|{
name|TYDREAL
block|,
name|TYDREAL
block|,
literal|2
block|,
literal|"d_make"
block|}
block|,
block|{
name|TYREAL
block|,
name|TYREAL
block|,
literal|2
block|,
literal|"r_scal"
block|}
block|,
block|{
name|TYDREAL
block|,
name|TYDREAL
block|,
literal|2
block|,
literal|"d_scal"
block|}
block|,
block|{
literal|0
block|}
block|}
struct|;
end_struct

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|LOCAL struct Incstblock 	{ 	char atype; 	char rtype; 	char constno; 	} consttab[ ] = { 	{ TYSHORT, TYLONG, 0 }, 	{ TYLONG, TYLONG, 1 }, 	{ TYREAL, TYLONG, 2 }, 	{ TYDREAL, TYLONG, 3 },  	{ TYSHORT, TYLONG, 4 }, 	{ TYLONG, TYLONG, 5 }, 	{ TYREAL, TYLONG, 6 }, 	{ TYDREAL, TYLONG, 7 },  	{ TYREAL, TYLONG, 8 }, 	{ TYDREAL, TYLONG, 9 },  	{ TYREAL, TYLONG, 10 }, 	{ TYDREAL, TYLONG, 11 },  	{ TYREAL, TYREAL, 0 }, 	{ TYDREAL, TYDREAL, 1 },  	{ TYSHORT, TYLONG, 12 }, 	{ TYLONG, TYLONG, 13 }, 	{ TYREAL, TYREAL, 2 }, 	{ TYDREAL, TYDREAL, 3 },  	{ TYREAL, TYREAL, 4 }, 	{ TYDREAL, TYDREAL, 5 } };
endif|#
directive|endif
end_endif

begin_decl_stmt
name|char
modifier|*
name|callbyvalue
index|[ ]
init|=
block|{
literal|0
block|,
literal|"sqrt"
block|,
literal|"exp"
block|,
literal|"log"
block|,
literal|"sin"
block|,
literal|"cos"
block|,
literal|"tan"
block|,
literal|"asin"
block|,
literal|"acos"
block|,
literal|"atan"
block|,
literal|"atan2"
block|,
literal|"sinh"
block|,
literal|"cosh"
block|,
literal|"tanh"
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|r8fix
parameter_list|(
name|Void
parameter_list|)
comment|/* adjust tables for -r8 */
block|{
specifier|register
name|struct
name|Intrblock
modifier|*
name|I
decl_stmt|;
specifier|register
name|struct
name|Specblock
modifier|*
name|S
decl_stmt|;
for|for
control|(
name|I
operator|=
name|intrtab
init|;
name|I
operator|->
name|intrfname
index|[
literal|0
index|]
condition|;
name|I
operator|++
control|)
if|if
condition|(
name|I
operator|->
name|intrval
operator|.
name|intrgroup
operator|!=
name|INTRGEN
condition|)
switch|switch
condition|(
name|I
operator|->
name|intrval
operator|.
name|intrstuff
condition|)
block|{
case|case
name|TYREAL
case|:
name|I
operator|->
name|intrval
operator|.
name|intrstuff
operator|=
name|TYDREAL
expr_stmt|;
name|I
operator|->
name|intrval
operator|.
name|intrno
operator|=
name|I
operator|->
name|intrval
operator|.
name|dblintrno
expr_stmt|;
break|break;
case|case
name|TYCOMPLEX
case|:
name|I
operator|->
name|intrval
operator|.
name|intrstuff
operator|=
name|TYDCOMPLEX
expr_stmt|;
name|I
operator|->
name|intrval
operator|.
name|intrno
operator|=
name|I
operator|->
name|intrval
operator|.
name|dblintrno
expr_stmt|;
name|I
operator|->
name|intrval
operator|.
name|dblcmplx
operator|=
literal|1
expr_stmt|;
block|}
for|for
control|(
name|S
operator|=
name|spectab
init|;
name|S
operator|->
name|atype
condition|;
name|S
operator|++
control|)
switch|switch
condition|(
name|S
operator|->
name|atype
condition|)
block|{
case|case
name|TYCOMPLEX
case|:
name|S
operator|->
name|atype
operator|=
name|TYDCOMPLEX
expr_stmt|;
if|if
condition|(
name|S
operator|->
name|rtype
operator|==
name|TYREAL
condition|)
name|S
operator|->
name|rtype
operator|=
name|TYDREAL
expr_stmt|;
elseif|else
if|if
condition|(
name|S
operator|->
name|rtype
operator|==
name|TYCOMPLEX
condition|)
name|S
operator|->
name|rtype
operator|=
name|TYDCOMPLEX
expr_stmt|;
switch|switch
condition|(
name|S
operator|->
name|spxname
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'r'
case|:
name|S
operator|->
name|spxname
index|[
literal|0
index|]
operator|=
literal|'d'
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|S
operator|->
name|spxname
index|[
literal|0
index|]
operator|=
literal|'z'
expr_stmt|;
break|break;
default|default:
name|Fatal
argument_list|(
literal|"r8fix bug"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYREAL
case|:
name|S
operator|->
name|atype
operator|=
name|TYDREAL
expr_stmt|;
switch|switch
condition|(
name|S
operator|->
name|rtype
condition|)
block|{
case|case
name|TYREAL
case|:
name|S
operator|->
name|rtype
operator|=
name|TYDREAL
expr_stmt|;
if|if
condition|(
name|S
operator|->
name|spxname
index|[
literal|0
index|]
operator|!=
literal|'r'
condition|)
name|Fatal
argument_list|(
literal|"r8fix bug"
argument_list|)
expr_stmt|;
name|S
operator|->
name|spxname
index|[
literal|0
index|]
operator|=
literal|'d'
expr_stmt|;
case|case
name|TYDREAL
case|:
comment|/* d_prod */
break|break;
case|case
name|TYSHORT
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|S
operator|->
name|spxname
argument_list|,
literal|"hr_expn"
argument_list|)
condition|)
name|S
operator|->
name|spxname
index|[
literal|1
index|]
operator|=
literal|'d'
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|S
operator|->
name|spxname
argument_list|,
literal|"h_nint"
argument_list|)
condition|)
name|strcpy
argument_list|(
name|S
operator|->
name|spxname
argument_list|,
literal|"h_dnnt"
argument_list|)
expr_stmt|;
else|else
name|Fatal
argument_list|(
literal|"r8fix bug"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYLONG
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|S
operator|->
name|spxname
argument_list|,
literal|"ir_expn"
argument_list|)
condition|)
name|S
operator|->
name|spxname
index|[
literal|1
index|]
operator|=
literal|'d'
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|S
operator|->
name|spxname
argument_list|,
literal|"i_nint"
argument_list|)
condition|)
name|strcpy
argument_list|(
name|S
operator|->
name|spxname
argument_list|,
literal|"i_dnnt"
argument_list|)
expr_stmt|;
else|else
name|Fatal
argument_list|(
literal|"r8fix bug"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|Fatal
argument_list|(
literal|"r8fix bug"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|expptr
ifdef|#
directive|ifdef
name|KR_headers
name|intrcall
parameter_list|(
name|np
parameter_list|,
name|argsp
parameter_list|,
name|nargs
parameter_list|)
name|Namep
name|np
decl_stmt|;
name|struct
name|Listblock
modifier|*
name|argsp
decl_stmt|;
name|int
name|nargs
decl_stmt|;
else|#
directive|else
function|intrcall
parameter_list|(
name|Namep
name|np
parameter_list|,
name|struct
name|Listblock
modifier|*
name|argsp
parameter_list|,
name|int
name|nargs
parameter_list|)
endif|#
directive|endif
block|{
name|int
name|i
decl_stmt|,
name|rettype
decl_stmt|;
name|Addrp
name|ap
decl_stmt|;
specifier|register
name|struct
name|Specblock
modifier|*
name|sp
decl_stmt|;
specifier|register
name|struct
name|Chain
modifier|*
name|cp
decl_stmt|;
name|expptr
name|q
decl_stmt|,
name|ep
decl_stmt|;
name|int
name|mtype
decl_stmt|;
name|int
name|op
decl_stmt|;
name|int
name|f1field
decl_stmt|,
name|f2field
decl_stmt|,
name|f3field
decl_stmt|;
name|packed
operator|.
name|ijunk
operator|=
name|np
operator|->
name|vardesc
operator|.
name|varno
expr_stmt|;
name|f1field
operator|=
name|packed
operator|.
name|bits
operator|.
name|f1
expr_stmt|;
name|f2field
operator|=
name|packed
operator|.
name|bits
operator|.
name|f2
expr_stmt|;
name|f3field
operator|=
name|packed
operator|.
name|bits
operator|.
name|f3
expr_stmt|;
if|if
condition|(
name|nargs
operator|==
literal|0
condition|)
goto|goto
name|badnargs
goto|;
name|mtype
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|argsp
operator|->
name|listp
init|;
name|cp
condition|;
name|cp
operator|=
name|cp
operator|->
name|nextp
control|)
block|{
name|ep
operator|=
operator|(
name|expptr
operator|)
name|cp
operator|->
name|datap
expr_stmt|;
if|if
condition|(
name|ISCONST
argument_list|(
name|ep
argument_list|)
operator|&&
name|ep
operator|->
name|headblock
operator|.
name|vtype
operator|==
name|TYSHORT
condition|)
name|cp
operator|->
name|datap
operator|=
operator|(
name|char
operator|*
operator|)
name|mkconv
argument_list|(
name|tyint
argument_list|,
name|ep
argument_list|)
expr_stmt|;
name|mtype
operator|=
name|maxtype
argument_list|(
name|mtype
argument_list|,
name|ep
operator|->
name|headblock
operator|.
name|vtype
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|f1field
condition|)
block|{
case|case
name|INTRBOOL
case|:
name|op
operator|=
name|f3field
expr_stmt|;
if|if
condition|(
operator|!
name|ONEOF
argument_list|(
name|mtype
argument_list|,
name|MSKINT
operator||
name|MSKLOGICAL
argument_list|)
condition|)
goto|goto
name|badtype
goto|;
if|if
condition|(
name|op
operator|==
name|OPBITNOT
condition|)
block|{
if|if
condition|(
name|nargs
operator|!=
literal|1
condition|)
goto|goto
name|badnargs
goto|;
name|q
operator|=
name|mkexpr
argument_list|(
name|OPBITNOT
argument_list|,
operator|(
name|expptr
operator|)
name|argsp
operator|->
name|listp
operator|->
name|datap
argument_list|,
name|ENULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|nargs
operator|!=
literal|2
condition|)
goto|goto
name|badnargs
goto|;
name|q
operator|=
name|mkexpr
argument_list|(
name|op
argument_list|,
operator|(
name|expptr
operator|)
name|argsp
operator|->
name|listp
operator|->
name|datap
argument_list|,
operator|(
name|expptr
operator|)
name|argsp
operator|->
name|listp
operator|->
name|nextp
operator|->
name|datap
argument_list|)
expr_stmt|;
block|}
name|frchain
argument_list|(
operator|&
operator|(
name|argsp
operator|->
name|listp
operator|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|charptr
operator|)
name|argsp
argument_list|)
expr_stmt|;
return|return
operator|(
name|q
operator|)
return|;
case|case
name|INTRCONV
case|:
name|rettype
operator|=
name|f2field
expr_stmt|;
switch|switch
condition|(
name|rettype
condition|)
block|{
case|case
name|TYLONG
case|:
name|rettype
operator|=
name|tyint
expr_stmt|;
break|break;
case|case
name|TYLOGICAL
case|:
name|rettype
operator|=
name|tylog
expr_stmt|;
block|}
if|if
condition|(
name|ISCOMPLEX
argument_list|(
name|rettype
argument_list|)
operator|&&
name|nargs
operator|==
literal|2
condition|)
block|{
name|expptr
name|qr
decl_stmt|,
name|qi
decl_stmt|;
name|qr
operator|=
operator|(
name|expptr
operator|)
name|argsp
operator|->
name|listp
operator|->
name|datap
expr_stmt|;
name|qi
operator|=
operator|(
name|expptr
operator|)
name|argsp
operator|->
name|listp
operator|->
name|nextp
operator|->
name|datap
expr_stmt|;
if|if
condition|(
name|qr
operator|->
name|headblock
operator|.
name|vtype
operator|==
name|TYDREAL
operator|||
name|qi
operator|->
name|headblock
operator|.
name|vtype
operator|==
name|TYDREAL
condition|)
name|rettype
operator|=
name|TYDCOMPLEX
expr_stmt|;
if|if
condition|(
name|ISCONST
argument_list|(
name|qr
argument_list|)
operator|&&
name|ISCONST
argument_list|(
name|qi
argument_list|)
condition|)
name|q
operator|=
name|mkcxcon
argument_list|(
name|qr
argument_list|,
name|qi
argument_list|)
expr_stmt|;
else|else
name|q
operator|=
name|mkexpr
argument_list|(
name|OPCONV
argument_list|,
name|mkconv
argument_list|(
name|rettype
operator|-
literal|2
argument_list|,
name|qr
argument_list|)
argument_list|,
name|mkconv
argument_list|(
name|rettype
operator|-
literal|2
argument_list|,
name|qi
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nargs
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|f3field
operator|&&
operator|(
operator|(
name|Exprp
operator|)
name|argsp
operator|->
name|listp
operator|->
name|datap
operator|)
operator|->
name|vtype
operator|==
name|TYDCOMPLEX
condition|)
name|rettype
operator|=
name|TYDREAL
expr_stmt|;
name|q
operator|=
name|mkconv
argument_list|(
name|rettype
operator|+
literal|100
argument_list|,
operator|(
name|expptr
operator|)
name|argsp
operator|->
name|listp
operator|->
name|datap
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|tag
operator|==
name|TADDR
condition|)
name|q
operator|->
name|addrblock
operator|.
name|parenused
operator|=
literal|1
expr_stmt|;
block|}
else|else
goto|goto
name|badnargs
goto|;
name|q
operator|->
name|headblock
operator|.
name|vtype
operator|=
name|rettype
expr_stmt|;
name|frchain
argument_list|(
operator|&
operator|(
name|argsp
operator|->
name|listp
operator|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|charptr
operator|)
name|argsp
argument_list|)
expr_stmt|;
return|return
operator|(
name|q
operator|)
return|;
if|#
directive|if
literal|0
block|case INTRCNST:
comment|/* Machine-dependent f77 stuff that f2c omits:  intcon contains 	radix for short int 	radix for long int 	radix for single precision 	radix for double precision 	precision for short int 	precision for long int 	precision for single precision 	precision for double precision 	emin for single precision 	emin for double precision 	emax for single precision 	emax for double prcision 	largest short int 	largest long int  realcon contains 	tiny for single precision 	tiny for double precision 	huge for single precision 	huge for double precision 	mrsp (epsilon) for single precision 	mrsp (epsilon) for double precision */
block|{	register struct Incstblock *cstp; 		extern ftnint intcon[14]; 		extern double realcon[6];  		cstp = consttab + f3field; 		for(i=0 ; i<f2field ; ++i) 			if(cstp->atype == mtype) 				goto foundconst; 			else 				++cstp; 		goto badtype;  foundconst: 		switch(cstp->rtype) 		{ 		case TYLONG: 			return(mkintcon(intcon[cstp->constno]));  		case TYREAL: 		case TYDREAL: 			return(mkrealcon(cstp->rtype, 			    realcon[cstp->constno]) );  		default: 			Fatal("impossible intrinsic constant"); 		} 	}
endif|#
directive|endif
case|case
name|INTRGEN
case|:
name|sp
operator|=
name|spectab
operator|+
name|f3field
expr_stmt|;
if|if
condition|(
name|no66flag
condition|)
if|if
condition|(
name|sp
operator|->
name|atype
operator|==
name|mtype
condition|)
goto|goto
name|specfunct
goto|;
else|else
name|err66
argument_list|(
literal|"generic function"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|f2field
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|sp
operator|->
name|atype
operator|==
name|mtype
condition|)
goto|goto
name|specfunct
goto|;
else|else
operator|++
name|sp
expr_stmt|;
name|warn1
argument_list|(
literal|"bad argument type to intrinsic %s"
argument_list|,
name|np
operator|->
name|fvarname
argument_list|)
expr_stmt|;
comment|/* Made this a warning rather than an error so things like "log (5) ==>    log (5.0)" can be accommodated.  When none of these cases matches, the    argument is cast up to the first type in the spectab list; this first    type is assumed to be the "smallest" type, e.g. REAL before DREAL    before COMPLEX, before DCOMPLEX */
name|sp
operator|=
name|spectab
operator|+
name|f3field
expr_stmt|;
name|mtype
operator|=
name|sp
operator|->
name|atype
expr_stmt|;
goto|goto
name|specfunct
goto|;
case|case
name|INTRSPEC
case|:
name|sp
operator|=
name|spectab
operator|+
name|f3field
expr_stmt|;
name|specfunct
label|:
if|if
condition|(
name|tyint
operator|==
name|TYLONG
operator|&&
name|ONEOF
argument_list|(
name|sp
operator|->
name|rtype
argument_list|,
name|M
argument_list|(
name|TYSHORT
argument_list|)
operator||
name|M
argument_list|(
name|TYLOGICAL
argument_list|)
argument_list|)
operator|&&
operator|(
name|sp
operator|+
literal|1
operator|)
operator|->
name|atype
operator|==
name|sp
operator|->
name|atype
condition|)
operator|++
name|sp
expr_stmt|;
if|if
condition|(
name|nargs
operator|!=
name|sp
operator|->
name|nargs
condition|)
goto|goto
name|badnargs
goto|;
if|if
condition|(
name|mtype
operator|!=
name|sp
operator|->
name|atype
condition|)
goto|goto
name|badtype
goto|;
comment|/* NOTE!!  I moved fixargs (YES) into the ELSE branch so that constants in    the inline expression wouldn't get put into the constant table */
name|fixargs
argument_list|(
name|NO
argument_list|,
name|argsp
argument_list|)
expr_stmt|;
name|cast_args
argument_list|(
name|mtype
argument_list|,
name|argsp
operator|->
name|listp
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|=
name|Inline
argument_list|(
call|(
name|int
call|)
argument_list|(
name|sp
operator|-
name|spectab
argument_list|)
argument_list|,
name|mtype
argument_list|,
name|argsp
operator|->
name|listp
argument_list|)
condition|)
block|{
name|frchain
argument_list|(
operator|&
operator|(
name|argsp
operator|->
name|listp
operator|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|charptr
operator|)
name|argsp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|sp
operator|->
name|othername
condition|)
block|{
comment|/* C library routines that return double... */
comment|/* sp->rtype might be TYREAL */
name|ap
operator|=
name|builtin
argument_list|(
name|sp
operator|->
name|rtype
argument_list|,
name|callbyvalue
index|[
name|sp
operator|->
name|othername
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|q
operator|=
name|fixexpr
argument_list|(
operator|(
name|Exprp
operator|)
name|mkexpr
argument_list|(
name|OPCCALL
argument_list|,
operator|(
name|expptr
operator|)
name|ap
argument_list|,
operator|(
name|expptr
operator|)
name|argsp
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fixargs
argument_list|(
name|YES
argument_list|,
name|argsp
argument_list|)
expr_stmt|;
name|ap
operator|=
name|builtin
argument_list|(
name|sp
operator|->
name|rtype
argument_list|,
name|sp
operator|->
name|spxname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|q
operator|=
name|fixexpr
argument_list|(
operator|(
name|Exprp
operator|)
name|mkexpr
argument_list|(
name|OPCALL
argument_list|,
operator|(
name|expptr
operator|)
name|ap
argument_list|,
operator|(
name|expptr
operator|)
name|argsp
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* else */
block|}
comment|/* else */
return|return
operator|(
name|q
operator|)
return|;
case|case
name|INTRMIN
case|:
case|case
name|INTRMAX
case|:
if|if
condition|(
name|nargs
operator|<
literal|2
condition|)
goto|goto
name|badnargs
goto|;
if|if
condition|(
operator|!
name|ONEOF
argument_list|(
name|mtype
argument_list|,
name|MSKINT
operator||
name|MSKREAL
argument_list|)
condition|)
goto|goto
name|badtype
goto|;
name|argsp
operator|->
name|vtype
operator|=
name|mtype
expr_stmt|;
name|q
operator|=
name|mkexpr
argument_list|(
operator|(
name|f1field
operator|==
name|INTRMIN
condition|?
name|OPMIN
else|:
name|OPMAX
operator|)
argument_list|,
operator|(
name|expptr
operator|)
name|argsp
argument_list|,
name|ENULL
argument_list|)
expr_stmt|;
name|q
operator|->
name|headblock
operator|.
name|vtype
operator|=
name|mtype
expr_stmt|;
name|rettype
operator|=
name|f2field
expr_stmt|;
if|if
condition|(
name|rettype
operator|==
name|TYLONG
condition|)
name|rettype
operator|=
name|tyint
expr_stmt|;
elseif|else
if|if
condition|(
name|rettype
operator|==
name|TYUNKNOWN
condition|)
name|rettype
operator|=
name|mtype
expr_stmt|;
return|return
operator|(
name|mkconv
argument_list|(
name|rettype
argument_list|,
name|q
argument_list|)
operator|)
return|;
default|default:
name|fatali
argument_list|(
literal|"intrcall: bad intrgroup %d"
argument_list|,
name|f1field
argument_list|)
expr_stmt|;
block|}
name|badnargs
label|:
name|errstr
argument_list|(
literal|"bad number of arguments to intrinsic %s"
argument_list|,
name|np
operator|->
name|fvarname
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
name|badtype
label|:
name|errstr
argument_list|(
literal|"bad argument type to intrinsic %s"
argument_list|,
name|np
operator|->
name|fvarname
argument_list|)
expr_stmt|;
name|bad
label|:
return|return
operator|(
name|errnode
argument_list|()
operator|)
return|;
block|}
end_function

begin_function
name|int
ifdef|#
directive|ifdef
name|KR_headers
name|intrfunct
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
else|#
directive|else
function|intrfunct
parameter_list|(
name|char
modifier|*
name|s
parameter_list|)
endif|#
directive|endif
block|{
specifier|register
name|struct
name|Intrblock
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|intrtab
init|;
name|p
operator|->
name|intrval
operator|.
name|intrgroup
operator|!=
name|INTREND
condition|;
operator|++
name|p
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|s
argument_list|,
name|p
operator|->
name|intrfname
argument_list|)
condition|)
block|{
name|packed
operator|.
name|bits
operator|.
name|f1
operator|=
name|p
operator|->
name|intrval
operator|.
name|intrgroup
expr_stmt|;
name|packed
operator|.
name|bits
operator|.
name|f2
operator|=
name|p
operator|->
name|intrval
operator|.
name|intrstuff
expr_stmt|;
name|packed
operator|.
name|bits
operator|.
name|f3
operator|=
name|p
operator|->
name|intrval
operator|.
name|intrno
expr_stmt|;
name|packed
operator|.
name|bits
operator|.
name|f4
operator|=
name|p
operator|->
name|intrval
operator|.
name|dblcmplx
expr_stmt|;
return|return
operator|(
name|packed
operator|.
name|ijunk
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|Addrp
ifdef|#
directive|ifdef
name|KR_headers
name|intraddr
parameter_list|(
name|np
parameter_list|)
name|Namep
name|np
decl_stmt|;
else|#
directive|else
function|intraddr
parameter_list|(
name|Namep
name|np
parameter_list|)
endif|#
directive|endif
block|{
name|Addrp
name|q
decl_stmt|;
specifier|register
name|struct
name|Specblock
modifier|*
name|sp
decl_stmt|;
name|int
name|f3field
decl_stmt|;
if|if
condition|(
name|np
operator|->
name|vclass
operator|!=
name|CLPROC
operator|||
name|np
operator|->
name|vprocclass
operator|!=
name|PINTRINSIC
condition|)
name|fatalstr
argument_list|(
literal|"intraddr: %s is not intrinsic"
argument_list|,
name|np
operator|->
name|fvarname
argument_list|)
expr_stmt|;
name|packed
operator|.
name|ijunk
operator|=
name|np
operator|->
name|vardesc
operator|.
name|varno
expr_stmt|;
name|f3field
operator|=
name|packed
operator|.
name|bits
operator|.
name|f3
expr_stmt|;
switch|switch
condition|(
name|packed
operator|.
name|bits
operator|.
name|f1
condition|)
block|{
case|case
name|INTRGEN
case|:
comment|/* imag, log, and log10 arent specific functions */
if|if
condition|(
name|f3field
operator|==
literal|31
operator|||
name|f3field
operator|==
literal|43
operator|||
name|f3field
operator|==
literal|47
condition|)
goto|goto
name|bad
goto|;
case|case
name|INTRSPEC
case|:
name|sp
operator|=
name|spectab
operator|+
name|f3field
expr_stmt|;
if|if
condition|(
name|tyint
operator|==
name|TYLONG
operator|&&
operator|(
name|sp
operator|->
name|rtype
operator|==
name|TYSHORT
operator|||
name|sp
operator|->
name|rtype
operator|==
name|TYLOGICAL
operator|)
condition|)
operator|++
name|sp
expr_stmt|;
name|q
operator|=
name|builtin
argument_list|(
name|sp
operator|->
name|rtype
argument_list|,
name|sp
operator|->
name|spxname
argument_list|,
name|sp
operator|->
name|othername
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|q
operator|)
return|;
case|case
name|INTRCONV
case|:
case|case
name|INTRMIN
case|:
case|case
name|INTRMAX
case|:
case|case
name|INTRBOOL
case|:
case|case
name|INTRCNST
case|:
name|bad
label|:
name|errstr
argument_list|(
literal|"cannot pass %s as actual"
argument_list|,
name|np
operator|->
name|fvarname
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|Addrp
operator|)
name|errnode
argument_list|()
operator|)
return|;
block|}
name|fatali
argument_list|(
literal|"intraddr: impossible f1=%d\n"
argument_list|,
operator|(
name|int
operator|)
name|packed
operator|.
name|bits
operator|.
name|f1
argument_list|)
expr_stmt|;
comment|/* NOT REACHED */
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|cast_args
parameter_list|(
name|maxtype
parameter_list|,
name|args
parameter_list|)
name|int
name|maxtype
decl_stmt|;
name|chainp
name|args
decl_stmt|;
else|#
directive|else
function|cast_args
parameter_list|(
name|int
name|maxtype
parameter_list|,
name|chainp
name|args
parameter_list|)
endif|#
directive|endif
block|{
for|for
control|(
init|;
name|args
condition|;
name|args
operator|=
name|args
operator|->
name|nextp
control|)
block|{
name|expptr
name|e
init|=
operator|(
name|expptr
operator|)
name|args
operator|->
name|datap
decl_stmt|;
if|if
condition|(
name|e
operator|->
name|headblock
operator|.
name|vtype
operator|!=
name|maxtype
condition|)
if|if
condition|(
name|e
operator|->
name|tag
operator|==
name|TCONST
condition|)
name|args
operator|->
name|datap
operator|=
operator|(
name|char
operator|*
operator|)
name|mkconv
argument_list|(
name|maxtype
argument_list|,
name|e
argument_list|)
expr_stmt|;
else|else
block|{
name|Addrp
name|temp
init|=
name|mktmp
argument_list|(
name|maxtype
argument_list|,
name|ENULL
argument_list|)
decl_stmt|;
name|puteq
argument_list|(
name|cpexpr
argument_list|(
operator|(
name|expptr
operator|)
name|temp
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|args
operator|->
name|datap
operator|=
operator|(
name|char
operator|*
operator|)
name|temp
expr_stmt|;
block|}
comment|/* else */
block|}
comment|/* for */
block|}
end_function

begin_comment
comment|/* cast_args */
end_comment

begin_function
name|expptr
ifdef|#
directive|ifdef
name|KR_headers
name|Inline
parameter_list|(
name|fno
parameter_list|,
name|type
parameter_list|,
name|args
parameter_list|)
name|int
name|fno
decl_stmt|;
name|int
name|type
decl_stmt|;
name|struct
name|Chain
modifier|*
name|args
decl_stmt|;
else|#
directive|else
function|Inline
parameter_list|(
name|int
name|fno
parameter_list|,
name|int
name|type
parameter_list|,
name|struct
name|Chain
modifier|*
name|args
parameter_list|)
endif|#
directive|endif
block|{
specifier|register
name|expptr
name|q
decl_stmt|,
name|t
decl_stmt|,
name|t1
decl_stmt|;
switch|switch
condition|(
name|fno
condition|)
block|{
case|case
literal|8
case|:
comment|/* real abs */
case|case
literal|9
case|:
comment|/* short int abs */
case|case
literal|10
case|:
comment|/* long int abs */
case|case
literal|11
case|:
comment|/* double precision abs */
if|if
condition|(
name|addressable
argument_list|(
name|q
operator|=
operator|(
name|expptr
operator|)
name|args
operator|->
name|datap
argument_list|)
condition|)
block|{
name|t
operator|=
name|q
expr_stmt|;
name|q
operator|=
name|NULL
expr_stmt|;
block|}
else|else
name|t
operator|=
operator|(
name|expptr
operator|)
name|mktmp
argument_list|(
name|type
argument_list|,
name|ENULL
argument_list|)
expr_stmt|;
name|t1
operator|=
name|mkexpr
argument_list|(
name|type
operator|==
name|TYREAL
operator|&&
name|forcedouble
condition|?
name|OPDABS
else|:
name|OPABS
argument_list|,
name|cpexpr
argument_list|(
name|t
argument_list|)
argument_list|,
name|ENULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
condition|)
name|t1
operator|=
name|mkexpr
argument_list|(
name|OPCOMMA
argument_list|,
name|mkexpr
argument_list|(
name|OPASSIGN
argument_list|,
name|cpexpr
argument_list|(
name|t
argument_list|)
argument_list|,
name|q
argument_list|)
argument_list|,
name|t1
argument_list|)
expr_stmt|;
name|frexpr
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|t1
operator|)
return|;
case|case
literal|26
case|:
comment|/* dprod */
name|q
operator|=
name|mkexpr
argument_list|(
name|OPSTAR
argument_list|,
name|mkconv
argument_list|(
name|TYDREAL
argument_list|,
operator|(
name|expptr
operator|)
name|args
operator|->
name|datap
argument_list|)
argument_list|,
operator|(
name|expptr
operator|)
name|args
operator|->
name|nextp
operator|->
name|datap
argument_list|)
expr_stmt|;
return|return
operator|(
name|q
operator|)
return|;
case|case
literal|27
case|:
comment|/* len of character string */
name|q
operator|=
operator|(
name|expptr
operator|)
name|cpexpr
argument_list|(
operator|(
operator|(
name|tagptr
operator|)
name|args
operator|->
name|datap
operator|)
operator|->
name|headblock
operator|.
name|vleng
argument_list|)
expr_stmt|;
name|frexpr
argument_list|(
operator|(
name|expptr
operator|)
name|args
operator|->
name|datap
argument_list|)
expr_stmt|;
return|return
name|mkconv
argument_list|(
name|tyioint
argument_list|,
name|q
argument_list|)
return|;
case|case
literal|14
case|:
comment|/* half-integer mod */
case|case
literal|15
case|:
comment|/* mod */
return|return
name|mkexpr
argument_list|(
name|OPMOD
argument_list|,
operator|(
name|expptr
operator|)
name|args
operator|->
name|datap
argument_list|,
operator|(
name|expptr
operator|)
name|args
operator|->
name|nextp
operator|->
name|datap
argument_list|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

end_unit

