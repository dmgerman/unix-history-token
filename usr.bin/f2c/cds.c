begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**************************************************************** Copyright 1990, 1993, 1994 by AT&T, Lucent Technologies and Bellcore.  Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that the copyright notice and this permission notice and warranty disclaimer appear in supporting documentation, and that the names of AT&T, Bell Laboratories, Lucent or Bellcore or any of their entities not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  AT&T, Lucent and Bellcore disclaim all warranties with regard to this software, including all implied warranties of merchantability and fitness.  In no event shall AT&T, Lucent or Bellcore be liable for any special, indirect or consequential damages or any damages whatsoever resulting from loss of use, data or profits, whether in an action of contract, negligence or other tortious action, arising out of or in connection with the use or performance of this software. ****************************************************************/
end_comment

begin_comment
comment|/* Put strings representing decimal floating-point numbers  * into canonical form: always have a decimal point or  * exponent field; if using an exponent field, have the  * number before it start with a digit and decimal point  * (if the number has more than one digit); only have an  * exponent field if it saves space.  *  * Arrange that the return value, rv, satisfies rv[0] == '-' || rv[-1] == '-' .  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_function
name|char
modifier|*
ifdef|#
directive|ifdef
name|KR_headers
name|cds
parameter_list|(
name|s
parameter_list|,
name|z0
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|z0
decl_stmt|;
else|#
directive|else
function|cds
parameter_list|(
name|char
modifier|*
name|s
parameter_list|,
name|char
modifier|*
name|z0
parameter_list|)
endif|#
directive|endif
block|{
name|int
name|ea
decl_stmt|,
name|esign
decl_stmt|,
name|et
decl_stmt|,
name|i
decl_stmt|,
name|k
decl_stmt|,
name|nd
init|=
literal|0
decl_stmt|,
name|sign
init|=
literal|0
decl_stmt|,
name|tz
decl_stmt|;
name|char
name|c
decl_stmt|,
modifier|*
name|z
decl_stmt|;
name|char
name|ebuf
index|[
literal|24
index|]
decl_stmt|;
name|long
name|ex
init|=
literal|0
decl_stmt|;
specifier|static
name|char
name|etype
index|[
name|Table_size
index|]
decl_stmt|,
modifier|*
name|db
decl_stmt|;
specifier|static
name|int
name|dblen
init|=
literal|64
decl_stmt|;
if|if
condition|(
operator|!
name|db
condition|)
block|{
name|etype
index|[
literal|'E'
index|]
operator|=
literal|1
expr_stmt|;
name|etype
index|[
literal|'e'
index|]
operator|=
literal|1
expr_stmt|;
name|etype
index|[
literal|'D'
index|]
operator|=
literal|1
expr_stmt|;
name|etype
index|[
literal|'d'
index|]
operator|=
literal|1
expr_stmt|;
name|etype
index|[
literal|'+'
index|]
operator|=
literal|2
expr_stmt|;
name|etype
index|[
literal|'-'
index|]
operator|=
literal|3
expr_stmt|;
name|db
operator|=
name|Alloc
argument_list|(
name|dblen
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|s
operator|++
operator|)
operator|==
literal|'0'
condition|)
empty_stmt|;
if|if
condition|(
name|c
operator|==
literal|'-'
condition|)
block|{
name|sign
operator|=
literal|1
expr_stmt|;
name|c
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'+'
condition|)
name|c
operator|=
operator|*
name|s
operator|++
expr_stmt|;
name|k
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|2
expr_stmt|;
if|if
condition|(
name|k
operator|>=
name|dblen
condition|)
block|{
do|do
name|dblen
operator|<<=
literal|1
expr_stmt|;
do|while
condition|(
name|k
operator|>=
name|dblen
condition|)
do|;
name|free
argument_list|(
name|db
argument_list|)
expr_stmt|;
name|db
operator|=
name|Alloc
argument_list|(
name|dblen
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|etype
index|[
operator|(
name|unsigned
name|char
operator|)
name|c
index|]
operator|>=
literal|2
condition|)
while|while
condition|(
name|c
operator|==
literal|'0'
condition|)
name|c
operator|=
operator|*
name|s
operator|++
expr_stmt|;
name|tz
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'0'
condition|)
name|tz
operator|++
expr_stmt|;
else|else
block|{
if|if
condition|(
name|nd
condition|)
for|for
control|(
init|;
name|tz
condition|;
operator|--
name|tz
control|)
name|db
index|[
name|nd
operator|++
index|]
operator|=
literal|'0'
expr_stmt|;
else|else
name|tz
operator|=
literal|0
expr_stmt|;
name|db
index|[
name|nd
operator|++
index|]
operator|=
name|c
expr_stmt|;
block|}
name|c
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
name|ea
operator|=
operator|-
name|tz
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'.'
condition|)
block|{
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|s
operator|++
operator|)
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'0'
condition|)
name|tz
operator|++
expr_stmt|;
else|else
block|{
if|if
condition|(
name|tz
condition|)
block|{
name|ea
operator|+=
name|tz
expr_stmt|;
if|if
condition|(
name|nd
condition|)
for|for
control|(
init|;
name|tz
condition|;
operator|--
name|tz
control|)
name|db
index|[
name|nd
operator|++
index|]
operator|=
literal|'0'
expr_stmt|;
else|else
name|tz
operator|=
literal|0
expr_stmt|;
block|}
name|db
index|[
name|nd
operator|++
index|]
operator|=
name|c
expr_stmt|;
name|ea
operator|++
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|et
operator|=
name|etype
index|[
operator|(
name|unsigned
name|char
operator|)
name|c
index|]
condition|)
block|{
name|esign
operator|=
name|et
operator|==
literal|3
expr_stmt|;
name|c
operator|=
operator|*
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|et
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|etype
index|[
operator|(
name|unsigned
name|char
operator|)
name|c
index|]
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'-'
condition|)
name|esign
operator|=
literal|1
expr_stmt|;
name|c
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
block|}
while|while
condition|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
block|{
name|ex
operator|=
literal|10
operator|*
name|ex
operator|+
operator|(
name|c
operator|-
literal|'0'
operator|)
expr_stmt|;
name|c
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|esign
condition|)
name|ex
operator|=
operator|-
name|ex
expr_stmt|;
block|}
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|0
case|:
break|break;
ifndef|#
directive|ifndef
name|VAX
case|case
literal|'i'
case|:
case|case
literal|'I'
case|:
name|Fatal
argument_list|(
literal|"Overflow evaluating constant expression."
argument_list|)
expr_stmt|;
case|case
literal|'n'
case|:
case|case
literal|'N'
case|:
name|Fatal
argument_list|(
literal|"Constant expression yields NaN."
argument_list|)
expr_stmt|;
endif|#
directive|endif
default|default:
name|Fatal
argument_list|(
literal|"unexpected character in cds."
argument_list|)
expr_stmt|;
block|}
name|ex
operator|-=
name|ea
expr_stmt|;
if|if
condition|(
operator|!
name|nd
condition|)
block|{
if|if
condition|(
operator|!
name|z0
condition|)
name|z0
operator|=
name|mem
argument_list|(
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|z0
argument_list|,
literal|"-0."
argument_list|)
expr_stmt|;
name|sign
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ex
operator|>
literal|2
operator|||
name|ex
operator|+
name|nd
operator|<
operator|-
literal|2
condition|)
block|{
name|sprintf
argument_list|(
name|ebuf
argument_list|,
literal|"%ld"
argument_list|,
name|ex
operator|+
name|nd
operator|-
literal|1
argument_list|)
expr_stmt|;
name|k
operator|=
name|strlen
argument_list|(
name|ebuf
argument_list|)
operator|+
name|nd
operator|+
literal|3
expr_stmt|;
if|if
condition|(
name|nd
operator|>
literal|1
condition|)
name|k
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|z0
condition|)
name|z0
operator|=
name|mem
argument_list|(
name|k
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|z
operator|=
name|z0
expr_stmt|;
operator|*
name|z
operator|++
operator|=
literal|'-'
expr_stmt|;
operator|*
name|z
operator|++
operator|=
operator|*
name|db
expr_stmt|;
if|if
condition|(
name|nd
operator|>
literal|1
condition|)
block|{
operator|*
name|z
operator|++
operator|=
literal|'.'
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|1
init|;
name|k
operator|<
name|nd
condition|;
name|k
operator|++
control|)
operator|*
name|z
operator|++
operator|=
name|db
index|[
name|k
index|]
expr_stmt|;
block|}
operator|*
name|z
operator|++
operator|=
literal|'e'
expr_stmt|;
name|strcpy
argument_list|(
name|z
argument_list|,
name|ebuf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|k
operator|=
call|(
name|int
call|)
argument_list|(
name|ex
operator|+
name|nd
argument_list|)
expr_stmt|;
name|i
operator|=
name|nd
operator|+
literal|3
expr_stmt|;
if|if
condition|(
name|k
operator|<
literal|0
condition|)
name|i
operator|-=
name|k
expr_stmt|;
elseif|else
if|if
condition|(
name|ex
operator|>
literal|0
condition|)
name|i
operator|+=
name|ex
expr_stmt|;
if|if
condition|(
operator|!
name|z0
condition|)
name|z0
operator|=
name|mem
argument_list|(
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|z
operator|=
name|z0
expr_stmt|;
operator|*
name|z
operator|++
operator|=
literal|'-'
expr_stmt|;
if|if
condition|(
name|ex
operator|>=
literal|0
condition|)
block|{
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|nd
condition|;
name|k
operator|++
control|)
operator|*
name|z
operator|++
operator|=
name|db
index|[
name|k
index|]
expr_stmt|;
while|while
condition|(
operator|--
name|ex
operator|>=
literal|0
condition|)
operator|*
name|z
operator|++
operator|=
literal|'0'
expr_stmt|;
operator|*
name|z
operator|++
operator|=
literal|'.'
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|k
condition|;
control|)
operator|*
name|z
operator|++
operator|=
name|db
index|[
name|i
operator|++
index|]
expr_stmt|;
operator|*
name|z
operator|++
operator|=
literal|'.'
expr_stmt|;
while|while
condition|(
operator|++
name|k
operator|<=
literal|0
condition|)
operator|*
name|z
operator|++
operator|=
literal|'0'
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|nd
condition|)
operator|*
name|z
operator|++
operator|=
name|db
index|[
name|i
operator|++
index|]
expr_stmt|;
block|}
operator|*
name|z
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|sign
condition|?
name|z0
else|:
name|z0
operator|+
literal|1
return|;
block|}
end_function

end_unit

