begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**************************************************************** Copyright 1990, 1994 by AT&T, Lucent Technologies and Bellcore.  Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that the copyright notice and this permission notice and warranty disclaimer appear in supporting documentation, and that the names of AT&T, Bell Laboratories, Lucent or Bellcore or any of their entities not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  AT&T, Lucent and Bellcore disclaim all warranties with regard to this software, including all implied warranties of merchantability and fitness.  In no event shall AT&T, Lucent or Bellcore be liable for any special, indirect or consequential damages or any damages whatsoever resulting from loss of use, data or profits, whether in an action of contract, negligence or other tortious action, arising out of or in connection with the use or performance of this software. ****************************************************************/
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CRAY
end_ifndef

begin_define
define|#
directive|define
name|STACKMIN
value|512
end_define

begin_define
define|#
directive|define
name|MINBLK
value|(2*sizeof(struct mem) + 16)
end_define

begin_define
define|#
directive|define
name|F
value|_malloc_free_
end_define

begin_define
define|#
directive|define
name|SBGULP
value|8192
end_define

begin_include
include|#
directive|include
file|"string.h"
end_include

begin_comment
comment|/* for memcpy */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|KR_headers
end_ifdef

begin_define
define|#
directive|define
name|Char
value|char
end_define

begin_define
define|#
directive|define
name|Unsigned
value|unsigned
end_define

begin_define
define|#
directive|define
name|Int
end_define

begin_comment
comment|/*int*/
end_comment

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|Char
value|void
end_define

begin_define
define|#
directive|define
name|Unsigned
value|size_t
end_define

begin_define
define|#
directive|define
name|Int
value|int
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_typedef
typedef|typedef
struct|struct
name|mem
block|{
name|struct
name|mem
modifier|*
name|next
decl_stmt|;
name|Unsigned
name|len
decl_stmt|;
block|}
name|mem
typedef|;
end_typedef

begin_decl_stmt
name|mem
modifier|*
name|F
decl_stmt|;
end_decl_stmt

begin_function
name|Char
modifier|*
ifdef|#
directive|ifdef
name|KR_headers
name|malloc
parameter_list|(
name|size
parameter_list|)
specifier|register
name|Unsigned
name|size
decl_stmt|;
else|#
directive|else
function|malloc
parameter_list|(
specifier|register
name|Unsigned
name|size
parameter_list|)
endif|#
directive|endif
block|{
specifier|register
name|mem
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|,
modifier|*
name|r
decl_stmt|,
modifier|*
name|s
decl_stmt|;
name|unsigned
specifier|register
name|k
decl_stmt|,
name|m
decl_stmt|;
specifier|extern
name|Char
modifier|*
name|sbrk
argument_list|(
name|Int
argument_list|)
decl_stmt|;
name|char
modifier|*
name|top
decl_stmt|,
modifier|*
name|top1
decl_stmt|;
name|size
operator|=
operator|(
name|size
operator|+
literal|7
operator|)
operator|&
operator|~
literal|7
expr_stmt|;
name|r
operator|=
operator|(
name|mem
operator|*
operator|)
operator|&
name|F
expr_stmt|;
for|for
control|(
name|p
operator|=
name|F
operator|,
name|q
operator|=
literal|0
init|;
name|p
condition|;
name|r
operator|=
name|p
operator|,
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|k
operator|=
name|p
operator|->
name|len
operator|)
operator|>=
name|size
operator|&&
operator|(
operator|!
name|q
operator|||
name|m
operator|>
name|k
operator|)
condition|)
block|{
name|m
operator|=
name|k
expr_stmt|;
name|q
operator|=
name|p
expr_stmt|;
name|s
operator|=
name|r
expr_stmt|;
block|}
block|}
if|if
condition|(
name|q
condition|)
block|{
if|if
condition|(
name|q
operator|->
name|len
operator|-
name|size
operator|>=
name|MINBLK
condition|)
block|{
comment|/* split block */
name|p
operator|=
operator|(
name|mem
operator|*
operator|)
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
name|q
operator|+
literal|1
operator|)
operator|)
operator|+
name|size
operator|)
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|q
operator|->
name|next
expr_stmt|;
name|p
operator|->
name|len
operator|=
name|q
operator|->
name|len
operator|-
name|size
operator|-
sizeof|sizeof
argument_list|(
name|mem
argument_list|)
expr_stmt|;
name|s
operator|->
name|next
operator|=
name|p
expr_stmt|;
name|q
operator|->
name|len
operator|=
name|size
expr_stmt|;
block|}
else|else
name|s
operator|->
name|next
operator|=
name|q
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
name|top
operator|=
operator|(
name|Char
operator|*
operator|)
operator|(
operator|(
operator|(
name|long
operator|)
name|sbrk
argument_list|(
literal|0
argument_list|)
operator|+
literal|7
operator|)
operator|&
operator|~
literal|7
operator|)
expr_stmt|;
if|if
condition|(
name|F
operator|&&
operator|(
name|char
operator|*
operator|)
operator|(
name|F
operator|+
literal|1
operator|)
operator|+
name|F
operator|->
name|len
operator|==
name|top
condition|)
block|{
name|q
operator|=
name|F
expr_stmt|;
name|F
operator|=
name|F
operator|->
name|next
expr_stmt|;
block|}
else|else
name|q
operator|=
operator|(
name|mem
operator|*
operator|)
name|top
expr_stmt|;
name|top1
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|q
operator|+
literal|1
operator|)
operator|+
name|size
expr_stmt|;
if|if
condition|(
name|sbrk
argument_list|(
call|(
name|int
call|)
argument_list|(
name|top1
operator|-
name|top
operator|+
name|SBGULP
argument_list|)
argument_list|)
operator|==
operator|(
name|Char
operator|*
operator|)
operator|-
literal|1
condition|)
return|return
literal|0
return|;
name|r
operator|=
operator|(
name|mem
operator|*
operator|)
name|top1
expr_stmt|;
name|r
operator|->
name|len
operator|=
name|SBGULP
operator|-
sizeof|sizeof
argument_list|(
name|mem
argument_list|)
expr_stmt|;
name|r
operator|->
name|next
operator|=
name|F
expr_stmt|;
name|F
operator|=
name|r
expr_stmt|;
name|q
operator|->
name|len
operator|=
name|size
expr_stmt|;
block|}
return|return
operator|(
name|Char
operator|*
operator|)
operator|(
name|q
operator|+
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|void
ifdef|#
directive|ifdef
name|KR_headers
name|free
parameter_list|(
name|f
parameter_list|)
name|Char
modifier|*
name|f
decl_stmt|;
else|#
directive|else
function|free
parameter_list|(
name|Char
modifier|*
name|f
parameter_list|)
endif|#
directive|endif
block|{
name|mem
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|,
modifier|*
name|r
decl_stmt|;
name|char
modifier|*
name|pn
decl_stmt|,
modifier|*
name|qn
decl_stmt|;
if|if
condition|(
operator|!
name|f
condition|)
return|return;
name|q
operator|=
operator|(
name|mem
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|f
operator|-
sizeof|sizeof
argument_list|(
name|mem
argument_list|)
operator|)
expr_stmt|;
name|qn
operator|=
operator|(
name|char
operator|*
operator|)
name|f
operator|+
name|q
operator|->
name|len
expr_stmt|;
for|for
control|(
name|p
operator|=
name|F
operator|,
name|r
operator|=
operator|(
name|mem
operator|*
operator|)
operator|&
name|F
init|;
condition|;
name|r
operator|=
name|p
operator|,
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
name|qn
operator|==
operator|(
name|Char
operator|*
operator|)
name|p
condition|)
block|{
name|q
operator|->
name|len
operator|+=
name|p
operator|->
name|len
operator|+
sizeof|sizeof
argument_list|(
name|mem
argument_list|)
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|next
expr_stmt|;
block|}
name|pn
operator|=
name|p
condition|?
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
name|p
operator|+
literal|1
operator|)
operator|)
operator|+
name|p
operator|->
name|len
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|pn
operator|==
operator|(
name|Char
operator|*
operator|)
name|q
condition|)
block|{
name|p
operator|->
name|len
operator|+=
sizeof|sizeof
argument_list|(
name|mem
argument_list|)
operator|+
name|q
operator|->
name|len
expr_stmt|;
name|q
operator|->
name|len
operator|=
literal|0
expr_stmt|;
name|q
operator|->
name|next
operator|=
name|p
expr_stmt|;
name|r
operator|->
name|next
operator|=
name|p
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|pn
operator|<
operator|(
name|char
operator|*
operator|)
name|q
condition|)
block|{
name|r
operator|->
name|next
operator|=
name|q
expr_stmt|;
name|q
operator|->
name|next
operator|=
name|p
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_function
name|Char
modifier|*
ifdef|#
directive|ifdef
name|KR_headers
name|realloc
parameter_list|(
name|f
parameter_list|,
name|size
parameter_list|)
name|Char
modifier|*
name|f
decl_stmt|;
name|Unsigned
name|size
decl_stmt|;
else|#
directive|else
function|realloc
parameter_list|(
name|Char
modifier|*
name|f
parameter_list|,
name|Unsigned
name|size
parameter_list|)
endif|#
directive|endif
block|{
name|mem
modifier|*
name|p
decl_stmt|;
name|Char
modifier|*
name|q
decl_stmt|,
modifier|*
name|f1
decl_stmt|;
name|Unsigned
name|s1
decl_stmt|;
if|if
condition|(
operator|!
name|f
condition|)
return|return
name|malloc
argument_list|(
name|size
argument_list|)
return|;
name|p
operator|=
operator|(
name|mem
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|f
operator|-
sizeof|sizeof
argument_list|(
name|mem
argument_list|)
operator|)
expr_stmt|;
name|s1
operator|=
name|p
operator|->
name|len
expr_stmt|;
name|free
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|s1
operator|>
name|size
condition|)
name|s1
operator|=
name|size
operator|+
literal|7
operator|&
operator|~
literal|7
expr_stmt|;
if|if
condition|(
operator|!
name|p
operator|->
name|len
condition|)
block|{
name|f1
operator|=
operator|(
name|Char
operator|*
operator|)
operator|(
name|p
operator|->
name|next
operator|+
literal|1
operator|)
expr_stmt|;
name|memcpy
argument_list|(
name|f1
argument_list|,
name|f
argument_list|,
name|s1
argument_list|)
expr_stmt|;
name|f
operator|=
name|f1
expr_stmt|;
block|}
name|q
operator|=
name|malloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|&&
name|q
operator|!=
name|f
condition|)
name|memcpy
argument_list|(
name|q
argument_list|,
name|f
argument_list|,
name|s1
argument_list|)
expr_stmt|;
return|return
name|q
return|;
block|}
end_function

begin_comment
comment|/* The following (calloc) should really be in a separate file, */
end_comment

begin_comment
comment|/* but defining it here sometimes avoids confusion on systems */
end_comment

begin_comment
comment|/* that do not provide calloc in its own file. */
end_comment

begin_function
name|Char
modifier|*
ifdef|#
directive|ifdef
name|KR_headers
name|calloc
parameter_list|(
name|n
parameter_list|,
name|m
parameter_list|)
name|Unsigned
name|m
decl_stmt|,
name|n
decl_stmt|;
else|#
directive|else
function|calloc
parameter_list|(
name|Unsigned
name|n
parameter_list|,
name|Unsigned
name|m
parameter_list|)
endif|#
directive|endif
block|{
name|Char
modifier|*
name|rv
init|=
name|malloc
argument_list|(
name|n
operator|*=
name|m
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|&&
name|rv
condition|)
name|memset
argument_list|(
name|rv
argument_list|,
literal|0
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
name|rv
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

