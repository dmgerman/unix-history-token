begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**************************************************************** Copyright 1990 by AT&T Bell Laboratories and Bellcore.  Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that the copyright notice and this permission notice and warranty disclaimer appear in supporting documentation, and that the names of AT&T Bell Laboratories or Bellcore or any of their entities not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  AT&T and Bellcore disclaim all warranties with regard to this software, including all implied warranties of merchantability and fitness.  In no event shall AT&T or Bellcore be liable for any special, indirect or consequential damages or any damages whatsoever resulting from loss of use, data or profits, whether in an action of contract, negligence or other tortious action, arising out of or in connection with the use or performance of this software. ****************************************************************/
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CRAY
end_ifndef

begin_define
define|#
directive|define
name|STACKMIN
value|512
end_define

begin_define
define|#
directive|define
name|MINBLK
value|(2*sizeof(struct mem) + 16)
end_define

begin_define
define|#
directive|define
name|MSTUFF
value|_malloc_stuff_
end_define

begin_define
define|#
directive|define
name|F
value|MSTUFF.free
end_define

begin_define
define|#
directive|define
name|B
value|MSTUFF.busy
end_define

begin_define
define|#
directive|define
name|SBGULP
value|8192
end_define

begin_function_decl
name|char
modifier|*
name|memcpy
parameter_list|()
function_decl|;
end_function_decl

begin_struct
struct|struct
name|mem
block|{
name|struct
name|mem
modifier|*
name|next
decl_stmt|;
name|unsigned
name|len
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
block|{
name|struct
name|mem
modifier|*
name|free
decl_stmt|;
name|char
modifier|*
name|busy
decl_stmt|;
block|}
name|MSTUFF
struct|;
end_struct

begin_function
name|char
modifier|*
name|malloc
parameter_list|(
name|size
parameter_list|)
specifier|register
name|unsigned
name|size
decl_stmt|;
block|{
specifier|register
name|struct
name|mem
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|,
modifier|*
name|r
decl_stmt|,
modifier|*
name|s
decl_stmt|;
name|unsigned
specifier|register
name|k
decl_stmt|,
name|m
decl_stmt|;
specifier|extern
name|char
modifier|*
name|sbrk
parameter_list|()
function_decl|;
name|char
modifier|*
name|top
decl_stmt|,
modifier|*
name|top1
decl_stmt|;
name|size
operator|=
operator|(
name|size
operator|+
literal|7
operator|)
operator|&
operator|~
literal|7
expr_stmt|;
name|r
operator|=
operator|(
expr|struct
name|mem
operator|*
operator|)
operator|&
name|F
expr_stmt|;
for|for
control|(
name|p
operator|=
name|F
operator|,
name|q
operator|=
literal|0
init|;
name|p
condition|;
name|r
operator|=
name|p
operator|,
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|k
operator|=
name|p
operator|->
name|len
operator|)
operator|>=
name|size
operator|&&
operator|(
operator|!
name|q
operator|||
name|m
operator|>
name|k
operator|)
condition|)
block|{
name|m
operator|=
name|k
expr_stmt|;
name|q
operator|=
name|p
expr_stmt|;
name|s
operator|=
name|r
expr_stmt|;
block|}
block|}
if|if
condition|(
name|q
condition|)
block|{
if|if
condition|(
name|q
operator|->
name|len
operator|-
name|size
operator|>=
name|MINBLK
condition|)
block|{
comment|/* split block */
name|p
operator|=
operator|(
expr|struct
name|mem
operator|*
operator|)
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
name|q
operator|+
literal|1
operator|)
operator|)
operator|+
name|size
operator|)
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|q
operator|->
name|next
expr_stmt|;
name|p
operator|->
name|len
operator|=
name|q
operator|->
name|len
operator|-
name|size
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|mem
argument_list|)
expr_stmt|;
name|s
operator|->
name|next
operator|=
name|p
expr_stmt|;
name|q
operator|->
name|len
operator|=
name|size
expr_stmt|;
block|}
else|else
name|s
operator|->
name|next
operator|=
name|q
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
name|top
operator|=
name|B
condition|?
name|B
else|:
operator|(
name|char
operator|*
operator|)
operator|(
operator|(
operator|(
name|long
operator|)
name|sbrk
argument_list|(
literal|0
argument_list|)
operator|+
literal|7
operator|)
operator|&
operator|~
literal|7
operator|)
expr_stmt|;
if|if
condition|(
name|F
operator|&&
operator|(
name|char
operator|*
operator|)
operator|(
name|F
operator|+
literal|1
operator|)
operator|+
name|F
operator|->
name|len
operator|==
name|B
condition|)
block|{
name|q
operator|=
name|F
expr_stmt|;
name|F
operator|=
name|F
operator|->
name|next
expr_stmt|;
block|}
else|else
name|q
operator|=
operator|(
expr|struct
name|mem
operator|*
operator|)
name|top
expr_stmt|;
name|top1
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|q
operator|+
literal|1
operator|)
operator|+
name|size
expr_stmt|;
if|if
condition|(
name|top1
operator|>
name|top
condition|)
block|{
if|if
condition|(
name|sbrk
argument_list|(
call|(
name|int
call|)
argument_list|(
name|top1
operator|-
name|top
operator|+
name|SBGULP
argument_list|)
argument_list|)
operator|==
operator|(
name|char
operator|*
operator|)
operator|-
literal|1
condition|)
return|return
literal|0
return|;
name|r
operator|=
operator|(
expr|struct
name|mem
operator|*
operator|)
name|top1
expr_stmt|;
name|r
operator|->
name|len
operator|=
name|SBGULP
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|mem
argument_list|)
expr_stmt|;
name|r
operator|->
name|next
operator|=
name|F
expr_stmt|;
name|F
operator|=
name|r
expr_stmt|;
name|top1
operator|+=
name|SBGULP
expr_stmt|;
block|}
name|q
operator|->
name|len
operator|=
name|size
expr_stmt|;
name|B
operator|=
name|top1
expr_stmt|;
block|}
return|return
operator|(
name|char
operator|*
operator|)
operator|(
name|q
operator|+
literal|1
operator|)
return|;
block|}
end_function

begin_macro
name|free
argument_list|(
argument|f
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|f
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|mem
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|,
modifier|*
name|r
decl_stmt|;
name|char
modifier|*
name|pn
decl_stmt|,
modifier|*
name|qn
decl_stmt|;
if|if
condition|(
operator|!
name|f
condition|)
return|return;
name|q
operator|=
operator|(
expr|struct
name|mem
operator|*
operator|)
operator|(
name|f
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|mem
argument_list|)
operator|)
expr_stmt|;
name|qn
operator|=
name|f
operator|+
name|q
operator|->
name|len
expr_stmt|;
for|for
control|(
name|p
operator|=
name|F
operator|,
name|r
operator|=
operator|(
expr|struct
name|mem
operator|*
operator|)
operator|&
name|F
init|;
condition|;
name|r
operator|=
name|p
operator|,
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
name|qn
operator|==
operator|(
name|char
operator|*
operator|)
name|p
condition|)
block|{
name|q
operator|->
name|len
operator|+=
name|p
operator|->
name|len
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|mem
argument_list|)
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|next
expr_stmt|;
block|}
name|pn
operator|=
name|p
condition|?
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
name|p
operator|+
literal|1
operator|)
operator|)
operator|+
name|p
operator|->
name|len
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|pn
operator|==
operator|(
name|char
operator|*
operator|)
name|q
condition|)
block|{
name|p
operator|->
name|len
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|mem
argument_list|)
operator|+
name|q
operator|->
name|len
expr_stmt|;
name|q
operator|->
name|len
operator|=
literal|0
expr_stmt|;
name|q
operator|->
name|next
operator|=
name|p
expr_stmt|;
name|r
operator|->
name|next
operator|=
name|p
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|pn
operator|<
operator|(
name|char
operator|*
operator|)
name|q
condition|)
block|{
name|r
operator|->
name|next
operator|=
name|q
expr_stmt|;
name|q
operator|->
name|next
operator|=
name|p
expr_stmt|;
break|break;
block|}
block|}
block|}
end_block

begin_function
name|char
modifier|*
name|realloc
parameter_list|(
name|f
parameter_list|,
name|size
parameter_list|)
name|char
modifier|*
name|f
decl_stmt|;
name|unsigned
name|size
decl_stmt|;
block|{
name|struct
name|mem
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|q
decl_stmt|,
modifier|*
name|f1
decl_stmt|;
name|unsigned
name|s1
decl_stmt|;
if|if
condition|(
operator|!
name|f
condition|)
return|return
name|malloc
argument_list|(
name|size
argument_list|)
return|;
name|p
operator|=
operator|(
expr|struct
name|mem
operator|*
operator|)
operator|(
name|f
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|mem
argument_list|)
operator|)
expr_stmt|;
name|s1
operator|=
name|p
operator|->
name|len
expr_stmt|;
name|free
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|s1
operator|>
name|size
condition|)
name|s1
operator|=
name|size
operator|+
literal|7
operator|&
operator|~
literal|7
expr_stmt|;
if|if
condition|(
operator|!
name|p
operator|->
name|len
condition|)
block|{
name|f1
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|p
operator|->
name|next
operator|+
literal|1
operator|)
expr_stmt|;
name|memcpy
argument_list|(
name|f1
argument_list|,
name|f
argument_list|,
name|s1
argument_list|)
expr_stmt|;
name|f
operator|=
name|f1
expr_stmt|;
block|}
name|q
operator|=
name|malloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|&&
name|q
operator|!=
name|f
condition|)
name|memcpy
argument_list|(
name|q
argument_list|,
name|f
argument_list|,
name|s1
argument_list|)
expr_stmt|;
return|return
name|q
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

