begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**************************************************************** Copyright 1990, 1991, 1992, 1993 by AT&T Bell Laboratories and Bellcore.  Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that the copyright notice and this permission notice and warranty disclaimer appear in supporting documentation, and that the names of AT&T Bell Laboratories or Bellcore or any of their entities not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  AT&T and Bellcore disclaim all warranties with regard to this software, including all implied warranties of merchantability and fitness.  In no event shall AT&T or Bellcore be liable for any special, indirect or consequential damages or any damages whatsoever resulting from loss of use, data or profits, whether in an action of contract, negligence or other tortious action, arising out of or in connection with the use or performance of this software. ****************************************************************/
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"names.h"
end_include

begin_decl_stmt
name|LOCAL
name|void
name|conspower
argument_list|()
decl_stmt|,
name|consbinop
argument_list|()
decl_stmt|,
name|zdiv
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LOCAL
name|expptr
name|fold
argument_list|()
decl_stmt|,
name|mkpower
argument_list|()
decl_stmt|,
name|stfcall
argument_list|()
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|stfcall_MAX
end_ifndef

begin_define
define|#
directive|define
name|stfcall_MAX
value|144
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_typedef
typedef|typedef
struct|struct
block|{
name|double
name|dreal
decl_stmt|,
name|dimag
decl_stmt|;
block|}
name|dcomplex
typedef|;
end_typedef

begin_decl_stmt
specifier|extern
name|char
name|dflttype
index|[
literal|26
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|htype
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* little routines to create constant blocks */
end_comment

begin_function
name|Constp
name|mkconst
parameter_list|(
name|t
parameter_list|)
specifier|register
name|int
name|t
decl_stmt|;
block|{
specifier|register
name|Constp
name|p
decl_stmt|;
name|p
operator|=
name|ALLOC
argument_list|(
name|Constblock
argument_list|)
expr_stmt|;
name|p
operator|->
name|tag
operator|=
name|TCONST
expr_stmt|;
name|p
operator|->
name|vtype
operator|=
name|t
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/* mklogcon -- Make Logical Constant */
end_comment

begin_function
name|expptr
name|mklogcon
parameter_list|(
name|l
parameter_list|)
specifier|register
name|int
name|l
decl_stmt|;
block|{
specifier|register
name|Constp
name|p
decl_stmt|;
name|p
operator|=
name|mkconst
argument_list|(
name|tylog
argument_list|)
expr_stmt|;
name|p
operator|->
name|Const
operator|.
name|ci
operator|=
name|l
expr_stmt|;
return|return
operator|(
operator|(
name|expptr
operator|)
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/* mkintcon -- Make Integer Constant */
end_comment

begin_function
name|expptr
name|mkintcon
parameter_list|(
name|l
parameter_list|)
name|ftnint
name|l
decl_stmt|;
block|{
specifier|register
name|Constp
name|p
decl_stmt|;
name|p
operator|=
name|mkconst
argument_list|(
name|tyint
argument_list|)
expr_stmt|;
name|p
operator|->
name|Const
operator|.
name|ci
operator|=
name|l
expr_stmt|;
return|return
operator|(
operator|(
name|expptr
operator|)
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/* mkaddcon -- Make Address Constant, given integer value */
end_comment

begin_function
name|expptr
name|mkaddcon
parameter_list|(
name|l
parameter_list|)
specifier|register
name|long
name|l
decl_stmt|;
block|{
specifier|register
name|Constp
name|p
decl_stmt|;
name|p
operator|=
name|mkconst
argument_list|(
name|TYADDR
argument_list|)
expr_stmt|;
name|p
operator|->
name|Const
operator|.
name|ci
operator|=
name|l
expr_stmt|;
return|return
operator|(
operator|(
name|expptr
operator|)
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/* mkrealcon -- Make Real Constant.  The type t is assumed    to be TYREAL or TYDREAL */
end_comment

begin_function
name|expptr
name|mkrealcon
parameter_list|(
name|t
parameter_list|,
name|d
parameter_list|)
specifier|register
name|int
name|t
decl_stmt|;
name|char
modifier|*
name|d
decl_stmt|;
block|{
specifier|register
name|Constp
name|p
decl_stmt|;
name|p
operator|=
name|mkconst
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|p
operator|->
name|Const
operator|.
name|cds
index|[
literal|0
index|]
operator|=
name|cds
argument_list|(
name|d
argument_list|,
name|CNULL
argument_list|)
expr_stmt|;
name|p
operator|->
name|vstg
operator|=
literal|1
expr_stmt|;
return|return
operator|(
operator|(
name|expptr
operator|)
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/* mkbitcon -- Make bit constant.  Reads the input string, which is    assumed to correctly specify a number in base 2^shift (where   shift    is the input parameter).   shift   may not exceed 4, i.e. only binary,    quad, octal and hex bases may be input.  Constants may not exceed 32    bits, or whatever the size of (struct Constblock).ci may be. */
end_comment

begin_function
name|expptr
name|mkbitcon
parameter_list|(
name|shift
parameter_list|,
name|leng
parameter_list|,
name|s
parameter_list|)
name|int
name|shift
decl_stmt|;
name|int
name|leng
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|Constp
name|p
decl_stmt|;
specifier|register
name|long
name|x
decl_stmt|;
name|p
operator|=
name|mkconst
argument_list|(
name|TYLONG
argument_list|)
expr_stmt|;
name|x
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|--
name|leng
operator|>=
literal|0
condition|)
if|if
condition|(
operator|*
name|s
operator|!=
literal|' '
condition|)
name|x
operator|=
operator|(
name|x
operator|<<
name|shift
operator|)
operator||
name|hextoi
argument_list|(
operator|*
name|s
operator|++
argument_list|)
expr_stmt|;
comment|/* mwm wanted to change the type to short for short constants, 	 * but this is dangerous -- there is no syntax for long constants 	 * with small values. 	 */
name|p
operator|->
name|Const
operator|.
name|ci
operator|=
name|x
expr_stmt|;
return|return
operator|(
operator|(
name|expptr
operator|)
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/* mkstrcon -- Make string constant.  Allocates storage and initializes    the memory for a copy of the input Fortran-string. */
end_comment

begin_function
name|expptr
name|mkstrcon
parameter_list|(
name|l
parameter_list|,
name|v
parameter_list|)
name|int
name|l
decl_stmt|;
specifier|register
name|char
modifier|*
name|v
decl_stmt|;
block|{
specifier|register
name|Constp
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
name|p
operator|=
name|mkconst
argument_list|(
name|TYCHAR
argument_list|)
expr_stmt|;
name|p
operator|->
name|vleng
operator|=
name|ICON
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|p
operator|->
name|Const
operator|.
name|ccp
operator|=
name|s
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
name|l
operator|+
literal|1
argument_list|)
expr_stmt|;
name|p
operator|->
name|Const
operator|.
name|ccp1
operator|.
name|blanks
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|--
name|l
operator|>=
literal|0
condition|)
operator|*
name|s
operator|++
operator|=
operator|*
name|v
operator|++
expr_stmt|;
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
operator|(
name|expptr
operator|)
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/* mkcxcon -- Make complex contsant.  A complex number is a pair of    values, each of which may be integer, real or double. */
end_comment

begin_function
name|expptr
name|mkcxcon
parameter_list|(
name|realp
parameter_list|,
name|imagp
parameter_list|)
specifier|register
name|expptr
name|realp
decl_stmt|,
name|imagp
decl_stmt|;
block|{
name|int
name|rtype
decl_stmt|,
name|itype
decl_stmt|;
specifier|register
name|Constp
name|p
decl_stmt|;
name|expptr
name|errnode
parameter_list|()
function_decl|;
name|rtype
operator|=
name|realp
operator|->
name|headblock
operator|.
name|vtype
expr_stmt|;
name|itype
operator|=
name|imagp
operator|->
name|headblock
operator|.
name|vtype
expr_stmt|;
if|if
condition|(
name|ISCONST
argument_list|(
name|realp
argument_list|)
operator|&&
name|ISNUMERIC
argument_list|(
name|rtype
argument_list|)
operator|&&
name|ISCONST
argument_list|(
name|imagp
argument_list|)
operator|&&
name|ISNUMERIC
argument_list|(
name|itype
argument_list|)
condition|)
block|{
name|p
operator|=
name|mkconst
argument_list|(
operator|(
name|rtype
operator|==
name|TYDREAL
operator|||
name|itype
operator|==
name|TYDREAL
operator|)
condition|?
name|TYDCOMPLEX
else|:
name|tycomplex
argument_list|)
expr_stmt|;
if|if
condition|(
name|realp
operator|->
name|constblock
operator|.
name|vstg
operator|||
name|imagp
operator|->
name|constblock
operator|.
name|vstg
condition|)
block|{
name|p
operator|->
name|vstg
operator|=
literal|1
expr_stmt|;
name|p
operator|->
name|Const
operator|.
name|cds
index|[
literal|0
index|]
operator|=
name|ISINT
argument_list|(
name|rtype
argument_list|)
condition|?
name|string_num
argument_list|(
literal|""
argument_list|,
name|realp
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
argument_list|)
else|:
name|realp
operator|->
name|constblock
operator|.
name|vstg
condition|?
name|realp
operator|->
name|constblock
operator|.
name|Const
operator|.
name|cds
index|[
literal|0
index|]
else|:
name|dtos
argument_list|(
name|realp
operator|->
name|constblock
operator|.
name|Const
operator|.
name|cd
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|p
operator|->
name|Const
operator|.
name|cds
index|[
literal|1
index|]
operator|=
name|ISINT
argument_list|(
name|itype
argument_list|)
condition|?
name|string_num
argument_list|(
literal|""
argument_list|,
name|imagp
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
argument_list|)
else|:
name|imagp
operator|->
name|constblock
operator|.
name|vstg
condition|?
name|imagp
operator|->
name|constblock
operator|.
name|Const
operator|.
name|cds
index|[
literal|0
index|]
else|:
name|dtos
argument_list|(
name|imagp
operator|->
name|constblock
operator|.
name|Const
operator|.
name|cd
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p
operator|->
name|Const
operator|.
name|cd
index|[
literal|0
index|]
operator|=
name|ISINT
argument_list|(
name|rtype
argument_list|)
condition|?
name|realp
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
else|:
name|realp
operator|->
name|constblock
operator|.
name|Const
operator|.
name|cd
index|[
literal|0
index|]
expr_stmt|;
name|p
operator|->
name|Const
operator|.
name|cd
index|[
literal|1
index|]
operator|=
name|ISINT
argument_list|(
name|itype
argument_list|)
condition|?
name|imagp
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
else|:
name|imagp
operator|->
name|constblock
operator|.
name|Const
operator|.
name|cd
index|[
literal|0
index|]
expr_stmt|;
block|}
block|}
else|else
block|{
name|err
argument_list|(
literal|"invalid complex constant"
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
name|Constp
operator|)
name|errnode
argument_list|()
expr_stmt|;
block|}
name|frexpr
argument_list|(
name|realp
argument_list|)
expr_stmt|;
name|frexpr
argument_list|(
name|imagp
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|expptr
operator|)
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/* errnode -- Allocate a new error block */
end_comment

begin_function
name|expptr
name|errnode
parameter_list|()
block|{
name|struct
name|Errorblock
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|ALLOC
argument_list|(
name|Errorblock
argument_list|)
expr_stmt|;
name|p
operator|->
name|tag
operator|=
name|TERROR
expr_stmt|;
name|p
operator|->
name|vtype
operator|=
name|TYERROR
expr_stmt|;
return|return
operator|(
operator|(
name|expptr
operator|)
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/* mkconv -- Make type conversion.  Cast expression   p   into type   t.    Note that casting to a character copies only the first sizeof(char)    bytes. */
end_comment

begin_function
name|expptr
name|mkconv
parameter_list|(
name|t
parameter_list|,
name|p
parameter_list|)
specifier|register
name|int
name|t
decl_stmt|;
specifier|register
name|expptr
name|p
decl_stmt|;
block|{
specifier|register
name|expptr
name|q
decl_stmt|;
specifier|register
name|int
name|pt
decl_stmt|,
name|charwarn
init|=
literal|1
decl_stmt|;
name|expptr
name|opconv
parameter_list|()
function_decl|;
if|if
condition|(
name|t
operator|>=
literal|100
condition|)
block|{
name|t
operator|-=
literal|100
expr_stmt|;
name|charwarn
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|==
name|TYUNKNOWN
operator|||
name|t
operator|==
name|TYERROR
condition|)
name|badtype
argument_list|(
literal|"mkconv"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|pt
operator|=
name|p
operator|->
name|headblock
operator|.
name|vtype
expr_stmt|;
comment|/* Casting to the same type is a no-op */
if|if
condition|(
name|t
operator|==
name|pt
condition|)
return|return
operator|(
name|p
operator|)
return|;
comment|/* If we're casting a constant which is not in the literal table ... */
elseif|else
if|if
condition|(
name|ISCONST
argument_list|(
name|p
argument_list|)
operator|&&
name|pt
operator|!=
name|TYADDR
operator|&&
name|pt
operator|!=
name|TYCHAR
condition|)
block|{
if|if
condition|(
name|ISINT
argument_list|(
name|t
argument_list|)
operator|&&
name|ISINT
argument_list|(
name|pt
argument_list|)
operator|||
name|ISREAL
argument_list|(
name|t
argument_list|)
operator|&&
name|ISREAL
argument_list|(
name|pt
argument_list|)
condition|)
block|{
comment|/* avoid trouble with -i2 */
name|p
operator|->
name|headblock
operator|.
name|vtype
operator|=
name|t
expr_stmt|;
return|return
name|p
return|;
block|}
name|q
operator|=
operator|(
name|expptr
operator|)
name|mkconst
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|consconv
argument_list|(
name|t
argument_list|,
operator|&
name|q
operator|->
name|constblock
argument_list|,
operator|&
name|p
operator|->
name|constblock
argument_list|)
expr_stmt|;
name|frexpr
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|pt
operator|==
name|TYCHAR
operator|&&
name|t
operator|!=
name|TYADDR
operator|&&
name|charwarn
operator|&&
operator|(
operator|!
name|halign
operator|||
name|p
operator|->
name|tag
operator|!=
name|TADDR
operator|||
name|p
operator|->
name|addrblock
operator|.
name|uname_tag
operator|!=
name|UNAM_CONST
operator|)
condition|)
name|warn
argument_list|(
literal|"ichar([first char. of] char. string) assumed for conversion to numeric"
argument_list|)
expr_stmt|;
name|q
operator|=
name|opconv
argument_list|(
name|p
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|==
name|TYCHAR
condition|)
name|q
operator|->
name|constblock
operator|.
name|vleng
operator|=
name|ICON
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|q
operator|)
return|;
block|}
end_function

begin_comment
comment|/* opconv -- Convert expression   p   to type   t   using the main    expression evaluator; returns an OPCONV expression, I think  14-jun-88 mwm */
end_comment

begin_function
name|expptr
name|opconv
parameter_list|(
name|p
parameter_list|,
name|t
parameter_list|)
name|expptr
name|p
decl_stmt|;
name|int
name|t
decl_stmt|;
block|{
specifier|register
name|expptr
name|q
decl_stmt|;
if|if
condition|(
name|t
operator|==
name|TYSUBR
condition|)
name|err
argument_list|(
literal|"illegal use of subroutine name"
argument_list|)
expr_stmt|;
name|q
operator|=
name|mkexpr
argument_list|(
name|OPCONV
argument_list|,
name|p
argument_list|,
name|ENULL
argument_list|)
expr_stmt|;
name|q
operator|->
name|headblock
operator|.
name|vtype
operator|=
name|t
expr_stmt|;
return|return
operator|(
name|q
operator|)
return|;
block|}
end_function

begin_comment
comment|/* addrof -- Create an ADDR expression operation */
end_comment

begin_function
name|expptr
name|addrof
parameter_list|(
name|p
parameter_list|)
name|expptr
name|p
decl_stmt|;
block|{
return|return
operator|(
name|mkexpr
argument_list|(
name|OPADDR
argument_list|,
name|p
argument_list|,
name|ENULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* cpexpr - Returns a new copy of input expression   p   */
end_comment

begin_function
name|tagptr
name|cpexpr
parameter_list|(
name|p
parameter_list|)
specifier|register
name|tagptr
name|p
decl_stmt|;
block|{
specifier|register
name|tagptr
name|e
decl_stmt|;
name|int
name|tag
decl_stmt|;
specifier|register
name|chainp
name|ep
decl_stmt|,
name|pp
decl_stmt|;
name|tagptr
name|cpblock
parameter_list|()
function_decl|;
comment|/* This table depends on the ordering of the T macros, e.g. TNAME */
specifier|static
name|int
name|blksize
index|[ ]
init|=
block|{
literal|0
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|Nameblock
argument_list|)
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|Constblock
argument_list|)
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|Exprblock
argument_list|)
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|Addrblock
argument_list|)
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|Primblock
argument_list|)
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|Listblock
argument_list|)
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|Impldoblock
argument_list|)
block|,
expr|sizeof
operator|(
expr|struct
name|Errorblock
operator|)
block|}
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* TNAMEs are special, and don't get copied.  Each name in the current    symbol table has a unique TNAME structure. */
if|if
condition|(
operator|(
name|tag
operator|=
name|p
operator|->
name|tag
operator|)
operator|==
name|TNAME
condition|)
return|return
operator|(
name|p
operator|)
return|;
name|e
operator|=
name|cpblock
argument_list|(
name|blksize
index|[
name|p
operator|->
name|tag
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
name|p
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|tag
condition|)
block|{
case|case
name|TCONST
case|:
if|if
condition|(
name|e
operator|->
name|constblock
operator|.
name|vtype
operator|==
name|TYCHAR
condition|)
block|{
name|e
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ccp
operator|=
name|copyn
argument_list|(
operator|(
name|int
operator|)
name|e
operator|->
name|constblock
operator|.
name|vleng
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
operator|+
literal|1
argument_list|,
name|e
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ccp
argument_list|)
expr_stmt|;
name|e
operator|->
name|constblock
operator|.
name|vleng
operator|=
operator|(
name|expptr
operator|)
name|cpexpr
argument_list|(
name|e
operator|->
name|constblock
operator|.
name|vleng
argument_list|)
expr_stmt|;
block|}
case|case
name|TERROR
case|:
break|break;
case|case
name|TEXPR
case|:
name|e
operator|->
name|exprblock
operator|.
name|leftp
operator|=
operator|(
name|expptr
operator|)
name|cpexpr
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|leftp
argument_list|)
expr_stmt|;
name|e
operator|->
name|exprblock
operator|.
name|rightp
operator|=
operator|(
name|expptr
operator|)
name|cpexpr
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|rightp
argument_list|)
expr_stmt|;
break|break;
case|case
name|TLIST
case|:
if|if
condition|(
name|pp
operator|=
name|p
operator|->
name|listblock
operator|.
name|listp
condition|)
block|{
name|ep
operator|=
name|e
operator|->
name|listblock
operator|.
name|listp
operator|=
name|mkchain
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cpexpr
argument_list|(
operator|(
name|tagptr
operator|)
name|pp
operator|->
name|datap
argument_list|)
argument_list|,
name|CHNULL
argument_list|)
expr_stmt|;
for|for
control|(
name|pp
operator|=
name|pp
operator|->
name|nextp
init|;
name|pp
condition|;
name|pp
operator|=
name|pp
operator|->
name|nextp
control|)
name|ep
operator|=
name|ep
operator|->
name|nextp
operator|=
name|mkchain
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cpexpr
argument_list|(
operator|(
name|tagptr
operator|)
name|pp
operator|->
name|datap
argument_list|)
argument_list|,
name|CHNULL
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TADDR
case|:
name|e
operator|->
name|addrblock
operator|.
name|vleng
operator|=
operator|(
name|expptr
operator|)
name|cpexpr
argument_list|(
name|e
operator|->
name|addrblock
operator|.
name|vleng
argument_list|)
expr_stmt|;
name|e
operator|->
name|addrblock
operator|.
name|memoffset
operator|=
operator|(
name|expptr
operator|)
name|cpexpr
argument_list|(
name|e
operator|->
name|addrblock
operator|.
name|memoffset
argument_list|)
expr_stmt|;
name|e
operator|->
name|addrblock
operator|.
name|istemp
operator|=
name|NO
expr_stmt|;
break|break;
case|case
name|TPRIM
case|:
name|e
operator|->
name|primblock
operator|.
name|argsp
operator|=
operator|(
expr|struct
name|Listblock
operator|*
operator|)
name|cpexpr
argument_list|(
operator|(
name|expptr
operator|)
name|e
operator|->
name|primblock
operator|.
name|argsp
argument_list|)
expr_stmt|;
name|e
operator|->
name|primblock
operator|.
name|fcharp
operator|=
operator|(
name|expptr
operator|)
name|cpexpr
argument_list|(
name|e
operator|->
name|primblock
operator|.
name|fcharp
argument_list|)
expr_stmt|;
name|e
operator|->
name|primblock
operator|.
name|lcharp
operator|=
operator|(
name|expptr
operator|)
name|cpexpr
argument_list|(
name|e
operator|->
name|primblock
operator|.
name|lcharp
argument_list|)
expr_stmt|;
break|break;
default|default:
name|badtag
argument_list|(
literal|"cpexpr"
argument_list|,
name|tag
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|e
operator|)
return|;
block|}
end_function

begin_comment
comment|/* frexpr -- Free expression -- frees up memory used by expression   p   */
end_comment

begin_expr_stmt
name|frexpr
argument_list|(
name|p
argument_list|)
specifier|register
name|tagptr
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|chainp
name|q
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return;
switch|switch
condition|(
name|p
operator|->
name|tag
condition|)
block|{
case|case
name|TCONST
case|:
if|if
condition|(
name|ISCHAR
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|free
argument_list|(
call|(
name|charptr
call|)
argument_list|(
name|p
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ccp
argument_list|)
argument_list|)
expr_stmt|;
name|frexpr
argument_list|(
name|p
operator|->
name|constblock
operator|.
name|vleng
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TADDR
case|:
if|if
condition|(
name|p
operator|->
name|addrblock
operator|.
name|vtype
operator|>
name|TYERROR
condition|)
comment|/* i/o block */
break|break;
name|frexpr
argument_list|(
name|p
operator|->
name|addrblock
operator|.
name|vleng
argument_list|)
expr_stmt|;
name|frexpr
argument_list|(
name|p
operator|->
name|addrblock
operator|.
name|memoffset
argument_list|)
expr_stmt|;
break|break;
case|case
name|TERROR
case|:
break|break;
comment|/* TNAME blocks don't get free'd - probably because they're pointed to in    the hash table. 14-Jun-88 -- mwm */
case|case
name|TNAME
case|:
return|return;
case|case
name|TPRIM
case|:
name|frexpr
argument_list|(
operator|(
name|expptr
operator|)
name|p
operator|->
name|primblock
operator|.
name|argsp
argument_list|)
expr_stmt|;
name|frexpr
argument_list|(
name|p
operator|->
name|primblock
operator|.
name|fcharp
argument_list|)
expr_stmt|;
name|frexpr
argument_list|(
name|p
operator|->
name|primblock
operator|.
name|lcharp
argument_list|)
expr_stmt|;
break|break;
case|case
name|TEXPR
case|:
name|frexpr
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|leftp
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|exprblock
operator|.
name|rightp
condition|)
name|frexpr
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|rightp
argument_list|)
expr_stmt|;
break|break;
case|case
name|TLIST
case|:
for|for
control|(
name|q
operator|=
name|p
operator|->
name|listblock
operator|.
name|listp
init|;
name|q
condition|;
name|q
operator|=
name|q
operator|->
name|nextp
control|)
name|frexpr
argument_list|(
operator|(
name|tagptr
operator|)
name|q
operator|->
name|datap
argument_list|)
expr_stmt|;
name|frchain
argument_list|(
operator|&
operator|(
name|p
operator|->
name|listblock
operator|.
name|listp
operator|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|badtag
argument_list|(
literal|"frexpr"
argument_list|,
name|p
operator|->
name|tag
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
operator|(
name|charptr
operator|)
name|p
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|void
name|wronginf
parameter_list|(
name|np
parameter_list|)
name|Namep
name|np
decl_stmt|;
block|{
name|int
name|c
decl_stmt|,
name|k
decl_stmt|;
name|warn1
argument_list|(
literal|"fixing wrong type inferred for %.65s"
argument_list|,
name|np
operator|->
name|fvarname
argument_list|)
expr_stmt|;
name|np
operator|->
name|vinftype
operator|=
literal|0
expr_stmt|;
name|c
operator|=
name|letter
argument_list|(
name|np
operator|->
name|fvarname
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|np
operator|->
name|vtype
operator|=
name|impltype
index|[
name|c
index|]
operator|)
operator|==
name|TYCHAR
operator|&&
operator|(
name|k
operator|=
name|implleng
index|[
name|c
index|]
operator|)
condition|)
name|np
operator|->
name|vleng
operator|=
name|ICON
argument_list|(
name|k
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* fix up types in expression; replace subtrees and convert    names to address blocks */
end_comment

begin_function
name|expptr
name|fixtype
parameter_list|(
name|p
parameter_list|)
specifier|register
name|tagptr
name|p
decl_stmt|;
block|{
if|if
condition|(
name|p
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
switch|switch
condition|(
name|p
operator|->
name|tag
condition|)
block|{
case|case
name|TCONST
case|:
if|if
condition|(
name|ONEOF
argument_list|(
name|p
operator|->
name|constblock
operator|.
name|vtype
argument_list|,
name|MSKINT
operator||
name|MSKLOGICAL
operator||
name|MSKADDR
operator||
name|MSKREAL
argument_list|)
condition|)
return|return
operator|(
operator|(
name|expptr
operator|)
name|p
operator|)
return|;
return|return
operator|(
operator|(
name|expptr
operator|)
name|putconst
argument_list|(
operator|(
name|Constp
operator|)
name|p
argument_list|)
operator|)
return|;
case|case
name|TADDR
case|:
name|p
operator|->
name|addrblock
operator|.
name|memoffset
operator|=
name|fixtype
argument_list|(
name|p
operator|->
name|addrblock
operator|.
name|memoffset
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|expptr
operator|)
name|p
operator|)
return|;
case|case
name|TERROR
case|:
return|return
operator|(
operator|(
name|expptr
operator|)
name|p
operator|)
return|;
default|default:
name|badtag
argument_list|(
literal|"fixtype"
argument_list|,
name|p
operator|->
name|tag
argument_list|)
expr_stmt|;
comment|/* This case means that   fixexpr   can't call   fixtype   with any expr,    only a subexpr of its parameter. */
case|case
name|TEXPR
case|:
return|return
operator|(
name|fixexpr
argument_list|(
operator|(
name|Exprp
operator|)
name|p
argument_list|)
operator|)
return|;
case|case
name|TLIST
case|:
return|return
operator|(
operator|(
name|expptr
operator|)
name|p
operator|)
return|;
case|case
name|TPRIM
case|:
if|if
condition|(
name|p
operator|->
name|primblock
operator|.
name|argsp
operator|&&
name|p
operator|->
name|primblock
operator|.
name|namep
operator|->
name|vclass
operator|!=
name|CLVAR
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|primblock
operator|.
name|namep
operator|->
name|vtype
operator|==
name|TYSUBR
condition|)
block|{
name|err
argument_list|(
literal|"function invocation of subroutine"
argument_list|)
expr_stmt|;
return|return
operator|(
name|errnode
argument_list|()
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|p
operator|->
name|primblock
operator|.
name|namep
operator|->
name|vinftype
condition|)
name|wronginf
argument_list|(
name|p
operator|->
name|primblock
operator|.
name|namep
argument_list|)
expr_stmt|;
return|return
operator|(
name|mkfunct
argument_list|(
name|p
argument_list|)
operator|)
return|;
block|}
block|}
comment|/* The lack of args makes   p   a function name, substring reference    or variable name. */
else|else
return|return
name|mklhs
argument_list|(
operator|(
expr|struct
name|Primblock
operator|*
operator|)
name|p
argument_list|,
name|keepsubs
argument_list|)
return|;
block|}
block|}
end_function

begin_function
name|int
name|badchleng
parameter_list|(
name|p
parameter_list|)
specifier|register
name|expptr
name|p
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|p
operator|->
name|headblock
operator|.
name|vleng
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|headblock
operator|.
name|tag
operator|==
name|TADDR
operator|&&
name|p
operator|->
name|addrblock
operator|.
name|uname_tag
operator|==
name|UNAM_NAME
condition|)
name|errstr
argument_list|(
literal|"bad use of character*(*) variable %.60s"
argument_list|,
name|p
operator|->
name|addrblock
operator|.
name|user
operator|.
name|name
operator|->
name|fvarname
argument_list|)
expr_stmt|;
else|else
name|err
argument_list|(
literal|"Bad use of character*(*)"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|expptr
name|cplenexpr
parameter_list|(
name|p
parameter_list|)
name|expptr
name|p
decl_stmt|;
block|{
name|expptr
name|rv
decl_stmt|;
if|if
condition|(
name|badchleng
argument_list|(
name|p
argument_list|)
condition|)
return|return
name|ICON
argument_list|(
literal|1
argument_list|)
return|;
name|rv
operator|=
name|cpexpr
argument_list|(
name|p
operator|->
name|headblock
operator|.
name|vleng
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISCONST
argument_list|(
name|p
argument_list|)
operator|&&
name|p
operator|->
name|constblock
operator|.
name|vtype
operator|==
name|TYCHAR
condition|)
name|rv
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
operator|+=
name|p
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ccp1
operator|.
name|blanks
expr_stmt|;
return|return
name|rv
return|;
block|}
end_function

begin_comment
comment|/* special case tree transformations and cleanups of expression trees.    Parameter   p   should have a TEXPR tag at its root, else an error is    returned */
end_comment

begin_function
name|expptr
name|fixexpr
parameter_list|(
name|p
parameter_list|)
specifier|register
name|Exprp
name|p
decl_stmt|;
block|{
name|expptr
name|lp
decl_stmt|;
specifier|register
name|expptr
name|rp
decl_stmt|;
specifier|register
name|expptr
name|q
decl_stmt|;
name|int
name|opcode
decl_stmt|,
name|ltype
decl_stmt|,
name|rtype
decl_stmt|,
name|ptype
decl_stmt|,
name|mtype
decl_stmt|;
if|if
condition|(
name|ISERROR
argument_list|(
name|p
argument_list|)
condition|)
return|return
operator|(
operator|(
name|expptr
operator|)
name|p
operator|)
return|;
elseif|else
if|if
condition|(
name|p
operator|->
name|tag
operator|!=
name|TEXPR
condition|)
name|badtag
argument_list|(
literal|"fixexpr"
argument_list|,
name|p
operator|->
name|tag
argument_list|)
expr_stmt|;
name|opcode
operator|=
name|p
operator|->
name|opcode
expr_stmt|;
comment|/* First set the types of the left and right subexpressions */
name|lp
operator|=
name|p
operator|->
name|leftp
expr_stmt|;
if|if
condition|(
operator|!
name|ISCONST
argument_list|(
name|lp
argument_list|)
operator|||
name|lp
operator|->
name|constblock
operator|.
name|vtype
operator|!=
name|TYCHAR
condition|)
name|lp
operator|=
name|p
operator|->
name|leftp
operator|=
name|fixtype
argument_list|(
name|lp
argument_list|)
expr_stmt|;
name|ltype
operator|=
name|lp
operator|->
name|headblock
operator|.
name|vtype
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
name|OPASSIGN
operator|&&
name|lp
operator|->
name|tag
operator|!=
name|TADDR
condition|)
block|{
name|err
argument_list|(
literal|"left side of assignment must be variable"
argument_list|)
expr_stmt|;
name|frexpr
argument_list|(
operator|(
name|expptr
operator|)
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|errnode
argument_list|()
operator|)
return|;
block|}
if|if
condition|(
name|rp
operator|=
name|p
operator|->
name|rightp
condition|)
block|{
if|if
condition|(
operator|!
name|ISCONST
argument_list|(
name|rp
argument_list|)
operator|||
name|rp
operator|->
name|constblock
operator|.
name|vtype
operator|!=
name|TYCHAR
condition|)
name|rp
operator|=
name|p
operator|->
name|rightp
operator|=
name|fixtype
argument_list|(
name|rp
argument_list|)
expr_stmt|;
name|rtype
operator|=
name|rp
operator|->
name|headblock
operator|.
name|vtype
expr_stmt|;
block|}
else|else
name|rtype
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ltype
operator|==
name|TYERROR
operator|||
name|rtype
operator|==
name|TYERROR
condition|)
block|{
name|frexpr
argument_list|(
operator|(
name|expptr
operator|)
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|errnode
argument_list|()
operator|)
return|;
block|}
comment|/* Now work on the whole expression */
comment|/* force folding if possible */
if|if
condition|(
name|ISCONST
argument_list|(
name|lp
argument_list|)
operator|&&
operator|(
name|rp
operator|==
name|NULL
operator|||
name|ISCONST
argument_list|(
name|rp
argument_list|)
operator|)
condition|)
block|{
name|q
operator|=
name|opcode
operator|==
name|OPCONV
operator|&&
name|lp
operator|->
name|constblock
operator|.
name|vtype
operator|==
name|p
operator|->
name|vtype
condition|?
name|lp
else|:
name|mkexpr
argument_list|(
name|opcode
argument_list|,
name|lp
argument_list|,
name|rp
argument_list|)
expr_stmt|;
comment|/* mkexpr is expected to reduce constant expressions */
if|if
condition|(
name|ISCONST
argument_list|(
name|q
argument_list|)
condition|)
block|{
name|p
operator|->
name|leftp
operator|=
name|p
operator|->
name|rightp
operator|=
literal|0
expr_stmt|;
name|frexpr
argument_list|(
operator|(
name|expptr
operator|)
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|q
operator|)
return|;
block|}
name|free
argument_list|(
operator|(
name|charptr
operator|)
name|q
argument_list|)
expr_stmt|;
comment|/* constants did not fold */
block|}
if|if
condition|(
operator|(
name|ptype
operator|=
name|cktype
argument_list|(
name|opcode
argument_list|,
name|ltype
argument_list|,
name|rtype
argument_list|)
operator|)
operator|==
name|TYERROR
condition|)
block|{
name|frexpr
argument_list|(
operator|(
name|expptr
operator|)
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|errnode
argument_list|()
operator|)
return|;
block|}
if|if
condition|(
name|ltype
operator|==
name|TYCHAR
operator|&&
name|ISCONST
argument_list|(
name|lp
argument_list|)
condition|)
name|p
operator|->
name|leftp
operator|=
name|lp
operator|=
operator|(
name|expptr
operator|)
name|putconst
argument_list|(
operator|(
name|Constp
operator|)
name|lp
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtype
operator|==
name|TYCHAR
operator|&&
name|ISCONST
argument_list|(
name|rp
argument_list|)
condition|)
name|p
operator|->
name|rightp
operator|=
name|rp
operator|=
operator|(
name|expptr
operator|)
name|putconst
argument_list|(
operator|(
name|Constp
operator|)
name|rp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|opcode
condition|)
block|{
case|case
name|OPCONCAT
case|:
if|if
condition|(
name|p
operator|->
name|vleng
operator|==
name|NULL
condition|)
name|p
operator|->
name|vleng
operator|=
name|mkexpr
argument_list|(
name|OPPLUS
argument_list|,
name|cplenexpr
argument_list|(
name|lp
argument_list|)
argument_list|,
name|cplenexpr
argument_list|(
name|rp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPASSIGN
case|:
if|if
condition|(
name|rtype
operator|==
name|TYREAL
operator|||
name|ISLOGICAL
argument_list|(
name|ptype
argument_list|)
condition|)
break|break;
case|case
name|OPPLUSEQ
case|:
case|case
name|OPSTAREQ
case|:
if|if
condition|(
name|ltype
operator|==
name|rtype
condition|)
break|break;
if|if
condition|(
operator|!
name|ISCONST
argument_list|(
name|rp
argument_list|)
operator|&&
name|ISREAL
argument_list|(
name|ltype
argument_list|)
operator|&&
name|ISREAL
argument_list|(
name|rtype
argument_list|)
condition|)
break|break;
if|if
condition|(
name|ISCOMPLEX
argument_list|(
name|ltype
argument_list|)
operator|||
name|ISCOMPLEX
argument_list|(
name|rtype
argument_list|)
condition|)
break|break;
if|if
condition|(
name|ONEOF
argument_list|(
name|ltype
argument_list|,
name|MSKADDR
operator||
name|MSKINT
argument_list|)
operator|&&
name|ONEOF
argument_list|(
name|rtype
argument_list|,
name|MSKADDR
operator||
name|MSKINT
argument_list|)
operator|&&
name|typesize
index|[
name|ltype
index|]
operator|>=
name|typesize
index|[
name|rtype
index|]
condition|)
break|break;
comment|/* Cast the right hand side to match the type of the expression */
name|p
operator|->
name|rightp
operator|=
name|fixtype
argument_list|(
name|mkconv
argument_list|(
name|ptype
argument_list|,
name|rp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPSLASH
case|:
if|if
condition|(
name|ISCOMPLEX
argument_list|(
name|rtype
argument_list|)
condition|)
block|{
name|p
operator|=
operator|(
name|Exprp
operator|)
name|call2
argument_list|(
name|ptype
argument_list|,
comment|/* Handle double precision complex variables */
name|ptype
operator|==
name|TYCOMPLEX
condition|?
literal|"c_div"
else|:
literal|"z_div"
argument_list|,
name|mkconv
argument_list|(
name|ptype
argument_list|,
name|lp
argument_list|)
argument_list|,
name|mkconv
argument_list|(
name|ptype
argument_list|,
name|rp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|OPPLUS
case|:
case|case
name|OPMINUS
case|:
case|case
name|OPSTAR
case|:
case|case
name|OPMOD
case|:
if|if
condition|(
name|ptype
operator|==
name|TYDREAL
operator|&&
operator|(
operator|(
name|ltype
operator|==
name|TYREAL
operator|&&
operator|!
name|ISCONST
argument_list|(
name|lp
argument_list|)
operator|)
operator|||
operator|(
name|rtype
operator|==
name|TYREAL
operator|&&
operator|!
name|ISCONST
argument_list|(
name|rp
argument_list|)
operator|)
operator|)
condition|)
break|break;
if|if
condition|(
name|ISCOMPLEX
argument_list|(
name|ptype
argument_list|)
condition|)
break|break;
comment|/* Cast both sides of the expression to match the type of the whole    expression.  */
if|if
condition|(
name|ltype
operator|!=
name|ptype
operator|&&
operator|(
name|ltype
operator|<
name|TYINT1
operator|||
name|ptype
operator|>
name|TYDREAL
operator|)
condition|)
name|p
operator|->
name|leftp
operator|=
name|fixtype
argument_list|(
name|mkconv
argument_list|(
name|ptype
argument_list|,
name|lp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtype
operator|!=
name|ptype
operator|&&
operator|(
name|rtype
operator|<
name|TYINT1
operator|||
name|ptype
operator|>
name|TYDREAL
operator|)
condition|)
name|p
operator|->
name|rightp
operator|=
name|fixtype
argument_list|(
name|mkconv
argument_list|(
name|ptype
argument_list|,
name|rp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPPOWER
case|:
return|return
operator|(
name|mkpower
argument_list|(
operator|(
name|expptr
operator|)
name|p
argument_list|)
operator|)
return|;
case|case
name|OPLT
case|:
case|case
name|OPLE
case|:
case|case
name|OPGT
case|:
case|case
name|OPGE
case|:
case|case
name|OPEQ
case|:
case|case
name|OPNE
case|:
if|if
condition|(
name|ltype
operator|==
name|rtype
condition|)
break|break;
if|if
condition|(
name|htype
condition|)
block|{
if|if
condition|(
name|ltype
operator|==
name|TYCHAR
condition|)
block|{
name|p
operator|->
name|leftp
operator|=
name|fixtype
argument_list|(
name|mkconv
argument_list|(
name|rtype
argument_list|,
name|lp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|rtype
operator|==
name|TYCHAR
condition|)
block|{
name|p
operator|->
name|rightp
operator|=
name|fixtype
argument_list|(
name|mkconv
argument_list|(
name|ltype
argument_list|,
name|rp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|mtype
operator|=
name|cktype
argument_list|(
name|OPMINUS
argument_list|,
name|ltype
argument_list|,
name|rtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtype
operator|==
name|TYDREAL
operator|&&
operator|(
operator|(
name|ltype
operator|==
name|TYREAL
operator|&&
operator|!
name|ISCONST
argument_list|(
name|lp
argument_list|)
operator|)
operator|||
operator|(
name|rtype
operator|==
name|TYREAL
operator|&&
operator|!
name|ISCONST
argument_list|(
name|rp
argument_list|)
operator|)
operator|)
condition|)
break|break;
if|if
condition|(
name|ISCOMPLEX
argument_list|(
name|mtype
argument_list|)
condition|)
break|break;
if|if
condition|(
name|ltype
operator|!=
name|mtype
condition|)
name|p
operator|->
name|leftp
operator|=
name|fixtype
argument_list|(
name|mkconv
argument_list|(
name|mtype
argument_list|,
name|lp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtype
operator|!=
name|mtype
condition|)
name|p
operator|->
name|rightp
operator|=
name|fixtype
argument_list|(
name|mkconv
argument_list|(
name|mtype
argument_list|,
name|rp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPCONV
case|:
name|ptype
operator|=
name|cktype
argument_list|(
name|OPCONV
argument_list|,
name|p
operator|->
name|vtype
argument_list|,
name|ltype
argument_list|)
expr_stmt|;
if|if
condition|(
name|lp
operator|->
name|tag
operator|==
name|TEXPR
operator|&&
name|lp
operator|->
name|exprblock
operator|.
name|opcode
operator|==
name|OPCOMMA
operator|&&
operator|!
name|ISCOMPLEX
argument_list|(
name|ptype
argument_list|)
condition|)
block|{
name|lp
operator|->
name|exprblock
operator|.
name|rightp
operator|=
name|fixtype
argument_list|(
name|mkconv
argument_list|(
name|ptype
argument_list|,
name|lp
operator|->
name|exprblock
operator|.
name|rightp
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|charptr
operator|)
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
name|Exprp
operator|)
name|lp
expr_stmt|;
block|}
break|break;
case|case
name|OPADDR
case|:
if|if
condition|(
name|lp
operator|->
name|tag
operator|==
name|TEXPR
operator|&&
name|lp
operator|->
name|exprblock
operator|.
name|opcode
operator|==
name|OPADDR
condition|)
name|Fatal
argument_list|(
literal|"addr of addr"
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPCOMMA
case|:
case|case
name|OPQUEST
case|:
case|case
name|OPCOLON
case|:
break|break;
case|case
name|OPMIN
case|:
case|case
name|OPMAX
case|:
case|case
name|OPMIN2
case|:
case|case
name|OPMAX2
case|:
case|case
name|OPDMIN
case|:
case|case
name|OPDMAX
case|:
case|case
name|OPABS
case|:
case|case
name|OPDABS
case|:
name|ptype
operator|=
name|p
operator|->
name|vtype
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|p
operator|->
name|vtype
operator|=
name|ptype
expr_stmt|;
return|return
operator|(
operator|(
name|expptr
operator|)
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/* fix an argument list, taking due care for special first level cases */
end_comment

begin_macro
name|fixargs
argument_list|(
argument|doput
argument_list|,
argument|p0
argument_list|)
end_macro

begin_decl_stmt
name|int
name|doput
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* doput is true if constants need to be passed by reference */
end_comment

begin_decl_stmt
name|struct
name|Listblock
modifier|*
name|p0
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|chainp
name|p
decl_stmt|;
specifier|register
name|tagptr
name|q
decl_stmt|,
name|t
decl_stmt|;
specifier|register
name|int
name|qtag
decl_stmt|;
name|int
name|nargs
decl_stmt|;
name|Addrp
name|mkscalar
parameter_list|()
function_decl|;
name|nargs
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p0
condition|)
for|for
control|(
name|p
operator|=
name|p0
operator|->
name|listp
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|nextp
control|)
block|{
operator|++
name|nargs
expr_stmt|;
name|q
operator|=
operator|(
name|tagptr
operator|)
name|p
operator|->
name|datap
expr_stmt|;
name|qtag
operator|=
name|q
operator|->
name|tag
expr_stmt|;
if|if
condition|(
name|qtag
operator|==
name|TCONST
condition|)
block|{
comment|/* Call putconst() to store values in a constant table.  Since even    constants must be passed by reference, this can optimize on the storage    required */
name|p
operator|->
name|datap
operator|=
name|doput
condition|?
operator|(
name|char
operator|*
operator|)
name|putconst
argument_list|(
operator|(
name|Constp
operator|)
name|q
argument_list|)
else|:
operator|(
name|char
operator|*
operator|)
name|q
expr_stmt|;
block|}
comment|/* Take a function name and turn it into an Addr.  This only happens when    nothing else has figured out the function beforehand */
elseif|else
if|if
condition|(
name|qtag
operator|==
name|TPRIM
operator|&&
name|q
operator|->
name|primblock
operator|.
name|argsp
operator|==
literal|0
operator|&&
name|q
operator|->
name|primblock
operator|.
name|namep
operator|->
name|vclass
operator|==
name|CLPROC
operator|&&
name|q
operator|->
name|primblock
operator|.
name|namep
operator|->
name|vprocclass
operator|!=
name|PTHISPROC
condition|)
name|p
operator|->
name|datap
operator|=
operator|(
name|char
operator|*
operator|)
name|mkaddr
argument_list|(
name|q
operator|->
name|primblock
operator|.
name|namep
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|qtag
operator|==
name|TPRIM
operator|&&
name|q
operator|->
name|primblock
operator|.
name|argsp
operator|==
literal|0
operator|&&
name|q
operator|->
name|primblock
operator|.
name|namep
operator|->
name|vdim
operator|!=
name|NULL
condition|)
name|p
operator|->
name|datap
operator|=
operator|(
name|char
operator|*
operator|)
name|mkscalar
argument_list|(
name|q
operator|->
name|primblock
operator|.
name|namep
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|qtag
operator|==
name|TPRIM
operator|&&
name|q
operator|->
name|primblock
operator|.
name|argsp
operator|==
literal|0
operator|&&
name|q
operator|->
name|primblock
operator|.
name|namep
operator|->
name|vdovar
operator|&&
operator|(
name|t
operator|=
operator|(
name|tagptr
operator|)
name|memversion
argument_list|(
name|q
operator|->
name|primblock
operator|.
name|namep
argument_list|)
operator|)
condition|)
name|p
operator|->
name|datap
operator|=
operator|(
name|char
operator|*
operator|)
name|fixtype
argument_list|(
name|t
argument_list|)
expr_stmt|;
else|else
name|p
operator|->
name|datap
operator|=
operator|(
name|char
operator|*
operator|)
name|fixtype
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|nargs
operator|)
return|;
block|}
end_block

begin_comment
comment|/* mkscalar -- only called by   fixargs   above, and by some routines in    io.c */
end_comment

begin_function
name|Addrp
name|mkscalar
parameter_list|(
name|np
parameter_list|)
specifier|register
name|Namep
name|np
decl_stmt|;
block|{
specifier|register
name|Addrp
name|ap
decl_stmt|;
name|vardcl
argument_list|(
name|np
argument_list|)
expr_stmt|;
name|ap
operator|=
name|mkaddr
argument_list|(
name|np
argument_list|)
expr_stmt|;
comment|/* The prolog causes array arguments to point to the 	 * (0,...,0) element, unless subscript checking is on. 	 */
if|if
condition|(
operator|!
name|checksubs
operator|&&
name|np
operator|->
name|vstg
operator|==
name|STGARG
condition|)
block|{
specifier|register
name|struct
name|Dimblock
modifier|*
name|dp
decl_stmt|;
name|dp
operator|=
name|np
operator|->
name|vdim
expr_stmt|;
name|frexpr
argument_list|(
name|ap
operator|->
name|memoffset
argument_list|)
expr_stmt|;
name|ap
operator|->
name|memoffset
operator|=
name|mkexpr
argument_list|(
name|OPSTAR
argument_list|,
operator|(
name|np
operator|->
name|vtype
operator|==
name|TYCHAR
condition|?
name|cpexpr
argument_list|(
name|np
operator|->
name|vleng
argument_list|)
else|:
operator|(
name|tagptr
operator|)
name|ICON
argument_list|(
name|typesize
index|[
name|np
operator|->
name|vtype
index|]
argument_list|)
operator|)
argument_list|,
name|cpexpr
argument_list|(
name|dp
operator|->
name|baseoffset
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ap
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|adjust_arginfo
parameter_list|(
name|np
parameter_list|)
comment|/* adjust arginfo to omit the length arg for the 			   arg that we now know to be a character-valued 			   function */
specifier|register
name|Namep
name|np
decl_stmt|;
block|{
name|struct
name|Entrypoint
modifier|*
name|ep
decl_stmt|;
specifier|register
name|chainp
name|args
decl_stmt|;
name|Argtypes
modifier|*
name|at
decl_stmt|;
for|for
control|(
name|ep
operator|=
name|entries
init|;
name|ep
condition|;
name|ep
operator|=
name|ep
operator|->
name|entnextp
control|)
for|for
control|(
name|args
operator|=
name|ep
operator|->
name|arglist
init|;
name|args
condition|;
name|args
operator|=
name|args
operator|->
name|nextp
control|)
if|if
condition|(
name|np
operator|==
operator|(
name|Namep
operator|)
name|args
operator|->
name|datap
operator|&&
operator|(
name|at
operator|=
name|ep
operator|->
name|entryname
operator|->
name|arginfo
operator|)
condition|)
operator|--
name|at
operator|->
name|nargs
expr_stmt|;
block|}
end_function

begin_function
name|expptr
name|mkfunct
parameter_list|(
name|p0
parameter_list|)
name|expptr
name|p0
decl_stmt|;
block|{
specifier|register
name|struct
name|Primblock
modifier|*
name|p
init|=
operator|(
expr|struct
name|Primblock
operator|*
operator|)
name|p0
decl_stmt|;
name|struct
name|Entrypoint
modifier|*
name|ep
decl_stmt|;
name|Addrp
name|ap
decl_stmt|;
name|Extsym
modifier|*
name|extp
decl_stmt|;
specifier|register
name|Namep
name|np
decl_stmt|;
specifier|register
name|expptr
name|q
decl_stmt|;
name|expptr
name|intrcall
parameter_list|()
function_decl|;
specifier|extern
name|chainp
name|new_procs
decl_stmt|;
name|int
name|k
decl_stmt|,
name|nargs
decl_stmt|;
name|int
name|class
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|tag
operator|!=
name|TPRIM
condition|)
return|return
operator|(
name|errnode
argument_list|()
operator|)
return|;
name|np
operator|=
name|p
operator|->
name|namep
expr_stmt|;
name|class
operator|=
name|np
operator|->
name|vclass
expr_stmt|;
if|if
condition|(
name|class
operator|==
name|CLUNKNOWN
condition|)
block|{
name|np
operator|->
name|vclass
operator|=
name|class
operator|=
name|CLPROC
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|vstg
operator|==
name|STGUNKNOWN
condition|)
block|{
if|if
condition|(
name|np
operator|->
name|vtype
operator|!=
name|TYSUBR
operator|&&
operator|(
name|k
operator|=
name|intrfunct
argument_list|(
name|np
operator|->
name|fvarname
argument_list|)
operator|)
operator|&&
operator|(
name|zflag
operator|||
operator|!
operator|(
operator|*
operator|(
expr|struct
name|Intrpacked
operator|*
operator|)
operator|&
name|k
operator|)
operator|.
name|f4
operator|||
name|dcomplex_seen
operator|)
condition|)
block|{
name|np
operator|->
name|vstg
operator|=
name|STGINTR
expr_stmt|;
name|np
operator|->
name|vardesc
operator|.
name|varno
operator|=
name|k
expr_stmt|;
name|np
operator|->
name|vprocclass
operator|=
name|PINTRINSIC
expr_stmt|;
block|}
else|else
block|{
name|extp
operator|=
name|mkext
argument_list|(
name|np
operator|->
name|fvarname
argument_list|,
name|addunder
argument_list|(
name|np
operator|->
name|cvarname
argument_list|)
argument_list|)
expr_stmt|;
name|extp
operator|->
name|extstg
operator|=
name|STGEXT
expr_stmt|;
name|np
operator|->
name|vstg
operator|=
name|STGEXT
expr_stmt|;
name|np
operator|->
name|vardesc
operator|.
name|varno
operator|=
name|extp
operator|-
name|extsymtab
expr_stmt|;
name|np
operator|->
name|vprocclass
operator|=
name|PEXTERNAL
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|np
operator|->
name|vstg
operator|==
name|STGARG
condition|)
block|{
if|if
condition|(
name|np
operator|->
name|vtype
operator|==
name|TYCHAR
condition|)
block|{
name|adjust_arginfo
argument_list|(
name|np
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|vpassed
condition|)
block|{
name|char
name|wbuf
index|[
literal|160
index|]
decl_stmt|,
modifier|*
name|who
decl_stmt|;
name|who
operator|=
name|np
operator|->
name|fvarname
expr_stmt|;
name|sprintf
argument_list|(
name|wbuf
argument_list|,
literal|"%s%s%s\n\t%s%s%s"
argument_list|,
literal|"Character-valued dummy procedure "
argument_list|,
name|who
argument_list|,
literal|" not declared EXTERNAL."
argument_list|,
literal|"Code may be wrong for previous function calls having "
argument_list|,
name|who
argument_list|,
literal|" as a parameter."
argument_list|)
expr_stmt|;
name|warn
argument_list|(
name|wbuf
argument_list|)
expr_stmt|;
block|}
block|}
name|np
operator|->
name|vprocclass
operator|=
name|PEXTERNAL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|class
operator|!=
name|CLPROC
condition|)
block|{
if|if
condition|(
name|np
operator|->
name|vstg
operator|==
name|STGCOMMON
condition|)
name|fatalstr
argument_list|(
literal|"Cannot invoke common variable %.50s as a function."
argument_list|,
name|np
operator|->
name|fvarname
argument_list|)
expr_stmt|;
name|fatali
argument_list|(
literal|"invalid class code %d for function"
argument_list|,
name|class
argument_list|)
expr_stmt|;
block|}
comment|/* F77 doesn't allow subscripting of function calls */
if|if
condition|(
name|p
operator|->
name|fcharp
operator|||
name|p
operator|->
name|lcharp
condition|)
block|{
name|err
argument_list|(
literal|"no substring of function call"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|impldcl
argument_list|(
name|np
argument_list|)
expr_stmt|;
name|np
operator|->
name|vimpltype
operator|=
literal|0
expr_stmt|;
comment|/* invoking as function ==> inferred type */
name|np
operator|->
name|vcalled
operator|=
literal|1
expr_stmt|;
name|nargs
operator|=
name|fixargs
argument_list|(
name|np
operator|->
name|vprocclass
operator|!=
name|PINTRINSIC
argument_list|,
name|p
operator|->
name|argsp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|np
operator|->
name|vprocclass
condition|)
block|{
case|case
name|PEXTERNAL
case|:
if|if
condition|(
name|np
operator|->
name|vtype
operator|==
name|TYUNKNOWN
condition|)
block|{
name|dclerr
argument_list|(
literal|"attempt to use untyped function"
argument_list|,
name|np
argument_list|)
expr_stmt|;
name|np
operator|->
name|vtype
operator|=
name|dflttype
index|[
name|letter
argument_list|(
name|np
operator|->
name|fvarname
index|[
literal|0
index|]
argument_list|)
index|]
expr_stmt|;
block|}
name|ap
operator|=
name|mkaddr
argument_list|(
name|np
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|extsymtab
index|[
name|np
operator|->
name|vardesc
operator|.
name|varno
index|]
operator|.
name|extseen
condition|)
block|{
name|new_procs
operator|=
name|mkchain
argument_list|(
operator|(
name|char
operator|*
operator|)
name|np
argument_list|,
name|new_procs
argument_list|)
expr_stmt|;
name|extsymtab
index|[
name|np
operator|->
name|vardesc
operator|.
name|varno
index|]
operator|.
name|extseen
operator|=
literal|1
expr_stmt|;
block|}
name|call
label|:
name|q
operator|=
name|mkexpr
argument_list|(
name|OPCALL
argument_list|,
operator|(
name|expptr
operator|)
name|ap
argument_list|,
operator|(
name|expptr
operator|)
name|p
operator|->
name|argsp
argument_list|)
expr_stmt|;
name|q
operator|->
name|exprblock
operator|.
name|vtype
operator|=
name|np
operator|->
name|vtype
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|vleng
condition|)
name|q
operator|->
name|exprblock
operator|.
name|vleng
operator|=
operator|(
name|expptr
operator|)
name|cpexpr
argument_list|(
name|np
operator|->
name|vleng
argument_list|)
expr_stmt|;
break|break;
case|case
name|PINTRINSIC
case|:
name|q
operator|=
name|intrcall
argument_list|(
name|np
argument_list|,
name|p
operator|->
name|argsp
argument_list|,
name|nargs
argument_list|)
expr_stmt|;
break|break;
case|case
name|PSTFUNCT
case|:
name|q
operator|=
name|stfcall
argument_list|(
name|np
argument_list|,
name|p
operator|->
name|argsp
argument_list|)
expr_stmt|;
break|break;
case|case
name|PTHISPROC
case|:
name|warn
argument_list|(
literal|"recursive call"
argument_list|)
expr_stmt|;
comment|/* entries   is the list of multiple entry points */
for|for
control|(
name|ep
operator|=
name|entries
init|;
name|ep
condition|;
name|ep
operator|=
name|ep
operator|->
name|entnextp
control|)
if|if
condition|(
name|ep
operator|->
name|enamep
operator|==
name|np
condition|)
break|break;
if|if
condition|(
name|ep
operator|==
name|NULL
condition|)
name|Fatal
argument_list|(
literal|"mkfunct: impossible recursion"
argument_list|)
expr_stmt|;
name|ap
operator|=
name|builtin
argument_list|(
name|np
operator|->
name|vtype
argument_list|,
name|ep
operator|->
name|entryname
operator|->
name|cextname
argument_list|,
operator|-
literal|2
argument_list|)
expr_stmt|;
comment|/* the negative last arg prevents adding */
comment|/* this name to the list of used builtins */
goto|goto
name|call
goto|;
default|default:
name|fatali
argument_list|(
literal|"mkfunct: impossible vprocclass %d"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|np
operator|->
name|vprocclass
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
operator|(
name|charptr
operator|)
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|q
operator|)
return|;
name|error
label|:
name|frexpr
argument_list|(
operator|(
name|expptr
operator|)
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|errnode
argument_list|()
operator|)
return|;
block|}
end_function

begin_function
name|LOCAL
name|expptr
name|stfcall
parameter_list|(
name|np
parameter_list|,
name|actlist
parameter_list|)
name|Namep
name|np
decl_stmt|;
name|struct
name|Listblock
modifier|*
name|actlist
decl_stmt|;
block|{
specifier|register
name|chainp
name|actuals
decl_stmt|;
name|int
name|nargs
decl_stmt|;
name|chainp
name|oactp
decl_stmt|,
name|formals
decl_stmt|;
name|int
name|type
decl_stmt|;
name|expptr
name|Ln
decl_stmt|,
name|Lq
decl_stmt|,
name|q
decl_stmt|,
name|q1
decl_stmt|,
name|rhs
decl_stmt|,
name|ap
decl_stmt|;
name|Namep
name|tnp
decl_stmt|;
specifier|register
name|struct
name|Rplblock
modifier|*
name|rp
decl_stmt|;
name|struct
name|Rplblock
modifier|*
name|tlist
decl_stmt|;
specifier|static
name|int
name|inv_count
decl_stmt|;
if|if
condition|(
operator|++
name|inv_count
operator|>
name|stfcall_MAX
condition|)
name|Fatal
argument_list|(
literal|"Loop invoking recursive statement function?"
argument_list|)
expr_stmt|;
if|if
condition|(
name|actlist
condition|)
block|{
name|actuals
operator|=
name|actlist
operator|->
name|listp
expr_stmt|;
name|free
argument_list|(
operator|(
name|charptr
operator|)
name|actlist
argument_list|)
expr_stmt|;
block|}
else|else
name|actuals
operator|=
name|NULL
expr_stmt|;
name|oactp
operator|=
name|actuals
expr_stmt|;
name|nargs
operator|=
literal|0
expr_stmt|;
name|tlist
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|type
operator|=
name|np
operator|->
name|vtype
operator|)
operator|==
name|TYUNKNOWN
condition|)
block|{
name|dclerr
argument_list|(
literal|"attempt to use untyped statement function"
argument_list|,
name|np
argument_list|)
expr_stmt|;
name|type
operator|=
name|np
operator|->
name|vtype
operator|=
name|dflttype
index|[
name|letter
argument_list|(
name|np
operator|->
name|fvarname
index|[
literal|0
index|]
argument_list|)
index|]
expr_stmt|;
block|}
name|formals
operator|=
operator|(
name|chainp
operator|)
name|np
operator|->
name|varxptr
operator|.
name|vstfdesc
operator|->
name|datap
expr_stmt|;
name|rhs
operator|=
call|(
name|expptr
call|)
argument_list|(
name|np
operator|->
name|varxptr
operator|.
name|vstfdesc
operator|->
name|nextp
argument_list|)
expr_stmt|;
comment|/* copy actual arguments into temporaries */
while|while
condition|(
name|actuals
operator|!=
name|NULL
operator|&&
name|formals
operator|!=
name|NULL
condition|)
block|{
name|rp
operator|=
name|ALLOC
argument_list|(
name|Rplblock
argument_list|)
expr_stmt|;
name|rp
operator|->
name|rplnp
operator|=
name|tnp
operator|=
operator|(
name|Namep
operator|)
name|formals
operator|->
name|datap
expr_stmt|;
name|ap
operator|=
name|fixtype
argument_list|(
operator|(
name|tagptr
operator|)
name|actuals
operator|->
name|datap
argument_list|)
expr_stmt|;
if|if
condition|(
name|tnp
operator|->
name|vtype
operator|==
name|ap
operator|->
name|headblock
operator|.
name|vtype
operator|&&
name|tnp
operator|->
name|vtype
operator|!=
name|TYCHAR
operator|&&
operator|(
name|ap
operator|->
name|tag
operator|==
name|TCONST
operator|||
name|ap
operator|->
name|tag
operator|==
name|TADDR
operator|)
condition|)
block|{
comment|/* If actuals are constants or variable names, no temporaries are required */
name|rp
operator|->
name|rplvp
operator|=
operator|(
name|expptr
operator|)
name|ap
expr_stmt|;
name|rp
operator|->
name|rplxp
operator|=
name|NULL
expr_stmt|;
name|rp
operator|->
name|rpltag
operator|=
name|ap
operator|->
name|tag
expr_stmt|;
block|}
else|else
block|{
name|rp
operator|->
name|rplvp
operator|=
operator|(
name|expptr
operator|)
name|mktmp
argument_list|(
name|tnp
operator|->
name|vtype
argument_list|,
name|tnp
operator|->
name|vleng
argument_list|)
expr_stmt|;
name|rp
operator|->
name|rplxp
operator|=
name|NULL
expr_stmt|;
name|putexpr
argument_list|(
name|mkexpr
argument_list|(
name|OPASSIGN
argument_list|,
name|cpexpr
argument_list|(
name|rp
operator|->
name|rplvp
argument_list|)
argument_list|,
name|ap
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rp
operator|->
name|rpltag
operator|=
name|rp
operator|->
name|rplvp
operator|->
name|tag
operator|)
operator|==
name|TERROR
condition|)
name|err
argument_list|(
literal|"disagreement of argument types in statement function call"
argument_list|)
expr_stmt|;
block|}
name|rp
operator|->
name|rplnextp
operator|=
name|tlist
expr_stmt|;
name|tlist
operator|=
name|rp
expr_stmt|;
name|actuals
operator|=
name|actuals
operator|->
name|nextp
expr_stmt|;
name|formals
operator|=
name|formals
operator|->
name|nextp
expr_stmt|;
operator|++
name|nargs
expr_stmt|;
block|}
if|if
condition|(
name|actuals
operator|!=
name|NULL
operator|||
name|formals
operator|!=
name|NULL
condition|)
name|err
argument_list|(
literal|"statement function definition and argument list differ"
argument_list|)
expr_stmt|;
comment|/*    now push down names involved in formal argument list, then    evaluate rhs of statement function definition in this environment */
if|if
condition|(
name|tlist
condition|)
comment|/* put tlist in front of the rpllist */
block|{
for|for
control|(
name|rp
operator|=
name|tlist
init|;
name|rp
operator|->
name|rplnextp
condition|;
name|rp
operator|=
name|rp
operator|->
name|rplnextp
control|)
empty_stmt|;
name|rp
operator|->
name|rplnextp
operator|=
name|rpllist
expr_stmt|;
name|rpllist
operator|=
name|tlist
expr_stmt|;
block|}
comment|/* So when the expression finally gets evaled, that evaluator must read    from the globl   rpllist   14-jun-88 mwm */
name|q
operator|=
operator|(
name|expptr
operator|)
name|mkconv
argument_list|(
name|type
argument_list|,
name|fixtype
argument_list|(
name|cpexpr
argument_list|(
name|rhs
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* get length right of character-valued statement functions... */
if|if
condition|(
name|type
operator|==
name|TYCHAR
operator|&&
operator|(
name|Ln
operator|=
name|np
operator|->
name|vleng
operator|)
operator|&&
name|q
operator|->
name|tag
operator|!=
name|TERROR
operator|&&
operator|(
name|Lq
operator|=
name|q
operator|->
name|exprblock
operator|.
name|vleng
operator|)
operator|&&
operator|(
name|Lq
operator|->
name|tag
operator|!=
name|TCONST
operator|||
name|Ln
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
operator|!=
name|Lq
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
operator|)
condition|)
block|{
name|q1
operator|=
operator|(
name|expptr
operator|)
name|mktmp
argument_list|(
name|type
argument_list|,
name|Ln
argument_list|)
expr_stmt|;
name|putexpr
argument_list|(
name|mkexpr
argument_list|(
name|OPASSIGN
argument_list|,
name|cpexpr
argument_list|(
name|q1
argument_list|)
argument_list|,
name|q
argument_list|)
argument_list|)
expr_stmt|;
name|q
operator|=
name|q1
expr_stmt|;
block|}
comment|/* now generate the tree ( t1=a1, (t2=a2,... , f))))) */
while|while
condition|(
operator|--
name|nargs
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|rpllist
operator|->
name|rplxp
condition|)
name|q
operator|=
name|mkexpr
argument_list|(
name|OPCOMMA
argument_list|,
name|rpllist
operator|->
name|rplxp
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|rp
operator|=
name|rpllist
operator|->
name|rplnextp
expr_stmt|;
name|frexpr
argument_list|(
name|rpllist
operator|->
name|rplvp
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|rpllist
argument_list|)
expr_stmt|;
name|rpllist
operator|=
name|rp
expr_stmt|;
block|}
name|frchain
argument_list|(
operator|&
name|oactp
argument_list|)
expr_stmt|;
operator|--
name|inv_count
expr_stmt|;
return|return
operator|(
name|q
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|replaced
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* mkplace -- Figure out the proper storage class for the input name and    return an addrp with the appropriate stuff */
end_comment

begin_function
name|Addrp
name|mkplace
parameter_list|(
name|np
parameter_list|)
specifier|register
name|Namep
name|np
decl_stmt|;
block|{
specifier|register
name|Addrp
name|s
decl_stmt|;
specifier|register
name|struct
name|Rplblock
modifier|*
name|rp
decl_stmt|;
name|int
name|regn
decl_stmt|;
comment|/* is name on the replace list? */
for|for
control|(
name|rp
operator|=
name|rpllist
init|;
name|rp
condition|;
name|rp
operator|=
name|rp
operator|->
name|rplnextp
control|)
block|{
if|if
condition|(
name|np
operator|==
name|rp
operator|->
name|rplnp
condition|)
block|{
name|replaced
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|rp
operator|->
name|rpltag
operator|==
name|TNAME
condition|)
block|{
name|np
operator|=
call|(
name|Namep
call|)
argument_list|(
name|rp
operator|->
name|rplvp
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
return|return
operator|(
operator|(
name|Addrp
operator|)
name|cpexpr
argument_list|(
name|rp
operator|->
name|rplvp
argument_list|)
operator|)
return|;
block|}
block|}
comment|/* is variable a DO index in a register ? */
if|if
condition|(
name|np
operator|->
name|vdovar
operator|&&
operator|(
operator|(
name|regn
operator|=
name|inregister
argument_list|(
name|np
argument_list|)
operator|)
operator|>=
literal|0
operator|)
condition|)
if|if
condition|(
name|np
operator|->
name|vtype
operator|==
name|TYERROR
condition|)
return|return
operator|(
operator|(
name|Addrp
operator|)
name|errnode
argument_list|()
operator|)
return|;
else|else
block|{
name|s
operator|=
name|ALLOC
argument_list|(
name|Addrblock
argument_list|)
expr_stmt|;
name|s
operator|->
name|tag
operator|=
name|TADDR
expr_stmt|;
name|s
operator|->
name|vstg
operator|=
name|STGREG
expr_stmt|;
name|s
operator|->
name|vtype
operator|=
name|TYIREG
expr_stmt|;
name|s
operator|->
name|memno
operator|=
name|regn
expr_stmt|;
name|s
operator|->
name|memoffset
operator|=
name|ICON
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|s
operator|->
name|uname_tag
operator|=
name|UNAM_NAME
expr_stmt|;
name|s
operator|->
name|user
operator|.
name|name
operator|=
name|np
expr_stmt|;
return|return
operator|(
name|s
operator|)
return|;
block|}
if|if
condition|(
name|np
operator|->
name|vclass
operator|==
name|CLPROC
operator|&&
name|np
operator|->
name|vprocclass
operator|!=
name|PTHISPROC
condition|)
name|errstr
argument_list|(
literal|"external %.60s used as a variable"
argument_list|,
name|np
operator|->
name|fvarname
argument_list|)
expr_stmt|;
name|vardcl
argument_list|(
name|np
argument_list|)
expr_stmt|;
return|return
operator|(
name|mkaddr
argument_list|(
name|np
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|expptr
name|subskept
parameter_list|(
name|p
parameter_list|,
name|a
parameter_list|)
name|struct
name|Primblock
modifier|*
name|p
decl_stmt|;
name|Addrp
name|a
decl_stmt|;
block|{
name|expptr
name|ep
decl_stmt|;
name|struct
name|Listblock
modifier|*
name|Lb
decl_stmt|;
name|chainp
name|cp
decl_stmt|;
if|if
condition|(
name|a
operator|->
name|uname_tag
operator|!=
name|UNAM_NAME
condition|)
name|erri
argument_list|(
literal|"subskept: uname_tag %d"
argument_list|,
name|a
operator|->
name|uname_tag
argument_list|)
expr_stmt|;
name|a
operator|->
name|user
operator|.
name|name
operator|->
name|vrefused
operator|=
literal|1
expr_stmt|;
name|a
operator|->
name|user
operator|.
name|name
operator|->
name|visused
operator|=
literal|1
expr_stmt|;
name|a
operator|->
name|uname_tag
operator|=
name|UNAM_REF
expr_stmt|;
name|Lb
operator|=
operator|(
expr|struct
name|Listblock
operator|*
operator|)
name|cpexpr
argument_list|(
operator|(
name|tagptr
operator|)
name|p
operator|->
name|argsp
argument_list|)
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|Lb
operator|->
name|listp
init|;
name|cp
condition|;
name|cp
operator|=
name|cp
operator|->
name|nextp
control|)
name|cp
operator|->
name|datap
operator|=
operator|(
name|char
operator|*
operator|)
name|putx
argument_list|(
name|fixtype
argument_list|(
operator|(
name|tagptr
operator|)
name|cp
operator|->
name|datap
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|vtype
operator|==
name|TYCHAR
condition|)
block|{
name|ep
operator|=
name|p
operator|->
name|fcharp
condition|?
name|mkexpr
argument_list|(
name|OPMINUS
argument_list|,
name|cpexpr
argument_list|(
name|p
operator|->
name|fcharp
argument_list|)
argument_list|,
name|ICON
argument_list|(
literal|1
argument_list|)
argument_list|)
else|:
name|ICON
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|Lb
operator|->
name|listp
operator|=
name|mkchain
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ep
argument_list|,
name|Lb
operator|->
name|listp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|expptr
operator|)
name|Lb
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|doing_vleng
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* mklhs -- Compute the actual address of the given expression; account    for array subscripts, stack offset, and substring offsets.  The f -> C    translator will need this only to worry about the subscript stuff */
end_comment

begin_function
name|expptr
name|mklhs
parameter_list|(
name|p
parameter_list|,
name|subkeep
parameter_list|)
specifier|register
name|struct
name|Primblock
modifier|*
name|p
decl_stmt|;
name|int
name|subkeep
decl_stmt|;
block|{
name|expptr
name|suboffset
parameter_list|()
function_decl|;
specifier|register
name|Addrp
name|s
decl_stmt|;
name|Namep
name|np
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|tag
operator|!=
name|TPRIM
condition|)
return|return
operator|(
operator|(
name|expptr
operator|)
name|p
operator|)
return|;
name|np
operator|=
name|p
operator|->
name|namep
expr_stmt|;
name|replaced
operator|=
literal|0
expr_stmt|;
name|s
operator|=
name|mkplace
argument_list|(
name|np
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|tag
operator|!=
name|TADDR
operator|||
name|s
operator|->
name|vstg
operator|==
name|STGREG
condition|)
block|{
name|free
argument_list|(
operator|(
name|charptr
operator|)
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|expptr
operator|)
name|s
operator|)
return|;
block|}
name|s
operator|->
name|parenused
operator|=
name|p
operator|->
name|parenused
expr_stmt|;
comment|/* compute the address modified by subscripts */
if|if
condition|(
operator|!
name|replaced
condition|)
name|s
operator|->
name|memoffset
operator|=
operator|(
name|subkeep
operator|&&
name|np
operator|->
name|vdim
operator|&&
operator|(
name|np
operator|->
name|vdim
operator|->
name|ndim
operator|>
literal|1
operator|||
name|np
operator|->
name|vtype
operator|==
name|TYCHAR
operator|&&
operator|(
operator|!
name|ISCONST
argument_list|(
name|np
operator|->
name|vleng
argument_list|)
operator|||
name|np
operator|->
name|vleng
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
operator|!=
literal|1
operator|)
operator|)
operator|)
condition|?
name|subskept
argument_list|(
name|p
argument_list|,
name|s
argument_list|)
else|:
name|mkexpr
argument_list|(
name|OPPLUS
argument_list|,
name|s
operator|->
name|memoffset
argument_list|,
name|suboffset
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|frexpr
argument_list|(
operator|(
name|expptr
operator|)
name|p
operator|->
name|argsp
argument_list|)
expr_stmt|;
name|p
operator|->
name|argsp
operator|=
name|NULL
expr_stmt|;
comment|/* now do substring part */
if|if
condition|(
name|p
operator|->
name|fcharp
operator|||
name|p
operator|->
name|lcharp
condition|)
block|{
if|if
condition|(
name|np
operator|->
name|vtype
operator|!=
name|TYCHAR
condition|)
name|errstr
argument_list|(
literal|"substring of noncharacter %s"
argument_list|,
name|np
operator|->
name|fvarname
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|p
operator|->
name|lcharp
operator|==
name|NULL
condition|)
name|p
operator|->
name|lcharp
operator|=
operator|(
name|expptr
operator|)
name|cpexpr
argument_list|(
name|s
operator|->
name|vleng
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|fcharp
condition|)
block|{
name|doing_vleng
operator|=
literal|1
expr_stmt|;
name|s
operator|->
name|vleng
operator|=
name|fixtype
argument_list|(
name|mkexpr
argument_list|(
name|OPMINUS
argument_list|,
name|p
operator|->
name|lcharp
argument_list|,
name|mkexpr
argument_list|(
name|OPMINUS
argument_list|,
name|p
operator|->
name|fcharp
argument_list|,
name|ICON
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|doing_vleng
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|frexpr
argument_list|(
name|s
operator|->
name|vleng
argument_list|)
expr_stmt|;
name|s
operator|->
name|vleng
operator|=
name|p
operator|->
name|lcharp
expr_stmt|;
block|}
block|}
block|}
name|s
operator|->
name|vleng
operator|=
name|fixtype
argument_list|(
name|s
operator|->
name|vleng
argument_list|)
expr_stmt|;
name|s
operator|->
name|memoffset
operator|=
name|fixtype
argument_list|(
name|s
operator|->
name|memoffset
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|charptr
operator|)
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|expptr
operator|)
name|s
operator|)
return|;
block|}
end_function

begin_comment
comment|/* deregister -- remove a register allocation from the list; assumes that    names are deregistered in stack order (LIFO order - Last In First Out) */
end_comment

begin_macro
name|deregister
argument_list|(
argument|np
argument_list|)
end_macro

begin_decl_stmt
name|Namep
name|np
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|nregvar
operator|>
literal|0
operator|&&
name|regnamep
index|[
name|nregvar
operator|-
literal|1
index|]
operator|==
name|np
condition|)
block|{
operator|--
name|nregvar
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* memversion -- moves a DO index REGISTER into a memory location; other    objects are passed through untouched */
end_comment

begin_function
name|Addrp
name|memversion
parameter_list|(
name|np
parameter_list|)
specifier|register
name|Namep
name|np
decl_stmt|;
block|{
specifier|register
name|Addrp
name|s
decl_stmt|;
if|if
condition|(
name|np
operator|->
name|vdovar
operator|==
name|NO
operator|||
operator|(
name|inregister
argument_list|(
name|np
argument_list|)
operator|<
literal|0
operator|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|np
operator|->
name|vdovar
operator|=
name|NO
expr_stmt|;
name|s
operator|=
name|mkplace
argument_list|(
name|np
argument_list|)
expr_stmt|;
name|np
operator|->
name|vdovar
operator|=
name|YES
expr_stmt|;
return|return
operator|(
name|s
operator|)
return|;
block|}
end_function

begin_comment
comment|/* inregister -- looks for the input name in the global list   regnamep */
end_comment

begin_expr_stmt
name|inregister
argument_list|(
name|np
argument_list|)
specifier|register
name|Namep
name|np
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nregvar
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|regnamep
index|[
name|i
index|]
operator|==
name|np
condition|)
return|return
operator|(
name|regnum
index|[
name|i
index|]
operator|)
return|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/* suboffset -- Compute the offset from the start of the array, given the    subscripts as arguments */
end_comment

begin_function
name|expptr
name|suboffset
parameter_list|(
name|p
parameter_list|)
specifier|register
name|struct
name|Primblock
modifier|*
name|p
decl_stmt|;
block|{
name|int
name|n
decl_stmt|;
name|expptr
name|si
decl_stmt|,
name|size
decl_stmt|;
name|chainp
name|cp
decl_stmt|;
name|expptr
name|e
decl_stmt|,
name|e1
decl_stmt|,
name|offp
decl_stmt|,
name|prod
decl_stmt|;
name|expptr
name|subcheck
parameter_list|()
function_decl|;
name|struct
name|Dimblock
modifier|*
name|dimp
decl_stmt|;
name|expptr
name|sub
index|[
name|MAXDIM
operator|+
literal|1
index|]
decl_stmt|;
specifier|register
name|Namep
name|np
decl_stmt|;
name|np
operator|=
name|p
operator|->
name|namep
expr_stmt|;
name|offp
operator|=
name|ICON
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|argsp
condition|)
for|for
control|(
name|cp
operator|=
name|p
operator|->
name|argsp
operator|->
name|listp
init|;
name|cp
condition|;
name|cp
operator|=
name|cp
operator|->
name|nextp
control|)
block|{
name|si
operator|=
name|fixtype
argument_list|(
name|cpexpr
argument_list|(
operator|(
name|tagptr
operator|)
name|cp
operator|->
name|datap
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ISINT
argument_list|(
name|si
operator|->
name|headblock
operator|.
name|vtype
argument_list|)
condition|)
block|{
name|NOEXT
argument_list|(
literal|"non-integer subscript"
argument_list|)
expr_stmt|;
name|si
operator|=
name|mkconv
argument_list|(
name|TYLONG
argument_list|,
name|si
argument_list|)
expr_stmt|;
block|}
name|sub
index|[
name|n
operator|++
index|]
operator|=
name|si
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|maxdim
condition|)
block|{
name|erri
argument_list|(
literal|"more than %d subscripts"
argument_list|,
name|maxdim
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|dimp
operator|=
name|np
operator|->
name|vdim
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
operator|&&
name|dimp
operator|==
name|NULL
condition|)
name|errstr
argument_list|(
literal|"subscripts on scalar variable %.68s"
argument_list|,
name|np
operator|->
name|fvarname
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|dimp
operator|&&
name|dimp
operator|->
name|ndim
operator|!=
name|n
condition|)
name|errstr
argument_list|(
literal|"wrong number of subscripts on %.68s"
argument_list|,
name|np
operator|->
name|fvarname
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|prod
operator|=
name|sub
index|[
operator|--
name|n
index|]
expr_stmt|;
while|while
condition|(
operator|--
name|n
operator|>=
literal|0
condition|)
name|prod
operator|=
name|mkexpr
argument_list|(
name|OPPLUS
argument_list|,
name|sub
index|[
name|n
index|]
argument_list|,
name|mkexpr
argument_list|(
name|OPSTAR
argument_list|,
name|prod
argument_list|,
name|cpexpr
argument_list|(
name|dimp
operator|->
name|dims
index|[
name|n
index|]
operator|.
name|dimsize
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|checksubs
operator|||
name|np
operator|->
name|vstg
operator|!=
name|STGARG
condition|)
name|prod
operator|=
name|mkexpr
argument_list|(
name|OPMINUS
argument_list|,
name|prod
argument_list|,
name|cpexpr
argument_list|(
name|dimp
operator|->
name|baseoffset
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Add in the run-time bounds check */
if|if
condition|(
name|checksubs
condition|)
name|prod
operator|=
name|subcheck
argument_list|(
name|np
argument_list|,
name|prod
argument_list|)
expr_stmt|;
name|size
operator|=
name|np
operator|->
name|vtype
operator|==
name|TYCHAR
condition|?
operator|(
name|expptr
operator|)
name|cpexpr
argument_list|(
name|np
operator|->
name|vleng
argument_list|)
else|:
name|ICON
argument_list|(
name|typesize
index|[
name|np
operator|->
name|vtype
index|]
argument_list|)
expr_stmt|;
name|prod
operator|=
name|mkexpr
argument_list|(
name|OPSTAR
argument_list|,
name|prod
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|offp
operator|=
name|mkexpr
argument_list|(
name|OPPLUS
argument_list|,
name|offp
argument_list|,
name|prod
argument_list|)
expr_stmt|;
block|}
comment|/* Check for substring indicator */
if|if
condition|(
name|p
operator|->
name|fcharp
operator|&&
name|np
operator|->
name|vtype
operator|==
name|TYCHAR
condition|)
block|{
name|e
operator|=
name|p
operator|->
name|fcharp
expr_stmt|;
name|e1
operator|=
name|mkexpr
argument_list|(
name|OPMINUS
argument_list|,
name|cpexpr
argument_list|(
name|e
argument_list|)
argument_list|,
name|ICON
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ISCONST
argument_list|(
name|e
argument_list|)
operator|&&
operator|(
name|e
operator|->
name|tag
operator|!=
name|TPRIM
operator|||
name|e
operator|->
name|primblock
operator|.
name|argsp
operator|)
condition|)
block|{
name|e
operator|=
operator|(
name|expptr
operator|)
name|mktmp
argument_list|(
name|TYLONG
argument_list|,
name|ENULL
argument_list|)
expr_stmt|;
name|putout
argument_list|(
name|putassign
argument_list|(
name|cpexpr
argument_list|(
name|e
argument_list|)
argument_list|,
name|e1
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|fcharp
operator|=
name|mkexpr
argument_list|(
name|OPPLUS
argument_list|,
name|cpexpr
argument_list|(
name|e
argument_list|)
argument_list|,
name|ICON
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|e1
operator|=
name|e
expr_stmt|;
block|}
name|offp
operator|=
name|mkexpr
argument_list|(
name|OPPLUS
argument_list|,
name|offp
argument_list|,
name|e1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|offp
operator|)
return|;
block|}
end_function

begin_function
name|expptr
name|subcheck
parameter_list|(
name|np
parameter_list|,
name|p
parameter_list|)
name|Namep
name|np
decl_stmt|;
specifier|register
name|expptr
name|p
decl_stmt|;
block|{
name|struct
name|Dimblock
modifier|*
name|dimp
decl_stmt|;
name|expptr
name|t
decl_stmt|,
name|checkvar
decl_stmt|,
name|checkcond
decl_stmt|,
name|badcall
decl_stmt|;
name|dimp
operator|=
name|np
operator|->
name|vdim
expr_stmt|;
if|if
condition|(
name|dimp
operator|->
name|nelt
operator|==
name|NULL
condition|)
return|return
operator|(
name|p
operator|)
return|;
comment|/* don't check arrays with * bounds */
name|np
operator|->
name|vlastdim
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ISICON
argument_list|(
name|p
argument_list|)
condition|)
block|{
comment|/* check for negative (constant) offset */
if|if
condition|(
name|p
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
operator|<
literal|0
condition|)
goto|goto
name|badsub
goto|;
if|if
condition|(
name|ISICON
argument_list|(
name|dimp
operator|->
name|nelt
argument_list|)
condition|)
comment|/* see if constant offset exceeds the array declaration */
if|if
condition|(
name|p
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
operator|<
name|dimp
operator|->
name|nelt
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
condition|)
return|return
operator|(
name|p
operator|)
return|;
else|else
goto|goto
name|badsub
goto|;
block|}
comment|/* We know that the subscript offset   p   or   dimp -> nelt   is not a constant.    Now find a register to use for run-time bounds checking */
if|if
condition|(
name|p
operator|->
name|tag
operator|==
name|TADDR
operator|&&
name|p
operator|->
name|addrblock
operator|.
name|vstg
operator|==
name|STGREG
condition|)
block|{
name|checkvar
operator|=
operator|(
name|expptr
operator|)
name|cpexpr
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|t
operator|=
name|p
expr_stmt|;
block|}
else|else
block|{
name|checkvar
operator|=
operator|(
name|expptr
operator|)
name|mktmp
argument_list|(
name|p
operator|->
name|headblock
operator|.
name|vtype
argument_list|,
name|ENULL
argument_list|)
expr_stmt|;
name|t
operator|=
name|mkexpr
argument_list|(
name|OPASSIGN
argument_list|,
name|cpexpr
argument_list|(
name|checkvar
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
name|checkcond
operator|=
name|mkexpr
argument_list|(
name|OPLT
argument_list|,
name|t
argument_list|,
name|cpexpr
argument_list|(
name|dimp
operator|->
name|nelt
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ISICON
argument_list|(
name|p
argument_list|)
condition|)
name|checkcond
operator|=
name|mkexpr
argument_list|(
name|OPAND
argument_list|,
name|checkcond
argument_list|,
name|mkexpr
argument_list|(
name|OPLE
argument_list|,
name|ICON
argument_list|(
literal|0
argument_list|)
argument_list|,
name|cpexpr
argument_list|(
name|checkvar
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Construct the actual test */
name|badcall
operator|=
name|call4
argument_list|(
name|p
operator|->
name|headblock
operator|.
name|vtype
argument_list|,
literal|"s_rnge"
argument_list|,
name|mkstrcon
argument_list|(
name|strlen
argument_list|(
name|np
operator|->
name|fvarname
argument_list|)
argument_list|,
name|np
operator|->
name|fvarname
argument_list|)
argument_list|,
name|mkconv
argument_list|(
name|TYLONG
argument_list|,
name|cpexpr
argument_list|(
name|checkvar
argument_list|)
argument_list|)
argument_list|,
name|mkstrcon
argument_list|(
name|strlen
argument_list|(
name|procname
argument_list|)
argument_list|,
name|procname
argument_list|)
argument_list|,
name|ICON
argument_list|(
name|lineno
argument_list|)
argument_list|)
expr_stmt|;
name|badcall
operator|->
name|exprblock
operator|.
name|opcode
operator|=
name|OPCCALL
expr_stmt|;
name|p
operator|=
name|mkexpr
argument_list|(
name|OPQUEST
argument_list|,
name|checkcond
argument_list|,
name|mkexpr
argument_list|(
name|OPCOLON
argument_list|,
name|checkvar
argument_list|,
name|badcall
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
name|badsub
label|:
name|frexpr
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|errstr
argument_list|(
literal|"subscript on variable %s out of range"
argument_list|,
name|np
operator|->
name|fvarname
argument_list|)
expr_stmt|;
return|return
operator|(
name|ICON
argument_list|(
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|Addrp
name|mkaddr
parameter_list|(
name|p
parameter_list|)
specifier|register
name|Namep
name|p
decl_stmt|;
block|{
name|Extsym
modifier|*
name|extp
decl_stmt|;
specifier|register
name|Addrp
name|t
decl_stmt|;
name|Addrp
name|intraddr
parameter_list|()
function_decl|;
name|int
name|k
decl_stmt|;
switch|switch
condition|(
name|p
operator|->
name|vstg
condition|)
block|{
case|case
name|STGAUTO
case|:
if|if
condition|(
name|p
operator|->
name|vclass
operator|==
name|CLPROC
operator|&&
name|p
operator|->
name|vprocclass
operator|==
name|PTHISPROC
condition|)
return|return
operator|(
name|Addrp
operator|)
name|cpexpr
argument_list|(
operator|(
name|expptr
operator|)
name|xretslot
index|[
name|p
operator|->
name|vtype
index|]
argument_list|)
return|;
goto|goto
name|other
goto|;
case|case
name|STGUNKNOWN
case|:
if|if
condition|(
name|p
operator|->
name|vclass
operator|!=
name|CLPROC
condition|)
break|break;
comment|/* Error */
name|extp
operator|=
name|mkext
argument_list|(
name|p
operator|->
name|fvarname
argument_list|,
name|addunder
argument_list|(
name|p
operator|->
name|cvarname
argument_list|)
argument_list|)
expr_stmt|;
name|extp
operator|->
name|extstg
operator|=
name|STGEXT
expr_stmt|;
name|p
operator|->
name|vstg
operator|=
name|STGEXT
expr_stmt|;
name|p
operator|->
name|vardesc
operator|.
name|varno
operator|=
name|extp
operator|-
name|extsymtab
expr_stmt|;
name|p
operator|->
name|vprocclass
operator|=
name|PEXTERNAL
expr_stmt|;
if|if
condition|(
operator|(
name|extp
operator|->
name|exproto
operator|||
name|infertypes
operator|)
operator|&&
operator|(
name|p
operator|->
name|vtype
operator|==
name|TYUNKNOWN
operator|||
name|p
operator|->
name|vimpltype
operator|)
operator|&&
operator|(
name|k
operator|=
name|extp
operator|->
name|extype
operator|)
condition|)
name|inferdcl
argument_list|(
name|p
argument_list|,
name|k
argument_list|)
expr_stmt|;
case|case
name|STGCOMMON
case|:
case|case
name|STGEXT
case|:
case|case
name|STGBSS
case|:
case|case
name|STGINIT
case|:
case|case
name|STGEQUIV
case|:
case|case
name|STGARG
case|:
case|case
name|STGLENG
case|:
name|other
label|:
name|t
operator|=
name|ALLOC
argument_list|(
name|Addrblock
argument_list|)
expr_stmt|;
name|t
operator|->
name|tag
operator|=
name|TADDR
expr_stmt|;
name|t
operator|->
name|vclass
operator|=
name|p
operator|->
name|vclass
expr_stmt|;
name|t
operator|->
name|vtype
operator|=
name|p
operator|->
name|vtype
expr_stmt|;
name|t
operator|->
name|vstg
operator|=
name|p
operator|->
name|vstg
expr_stmt|;
name|t
operator|->
name|memno
operator|=
name|p
operator|->
name|vardesc
operator|.
name|varno
expr_stmt|;
name|t
operator|->
name|memoffset
operator|=
name|ICON
argument_list|(
name|p
operator|->
name|voffset
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|vdim
condition|)
name|t
operator|->
name|isarray
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|vleng
condition|)
block|{
name|t
operator|->
name|vleng
operator|=
operator|(
name|expptr
operator|)
name|cpexpr
argument_list|(
name|p
operator|->
name|vleng
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISICON
argument_list|(
name|t
operator|->
name|vleng
argument_list|)
condition|)
name|t
operator|->
name|varleng
operator|=
name|t
operator|->
name|vleng
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
expr_stmt|;
block|}
comment|/* Keep the original name around for the C code generation */
name|t
operator|->
name|uname_tag
operator|=
name|UNAM_NAME
expr_stmt|;
name|t
operator|->
name|user
operator|.
name|name
operator|=
name|p
expr_stmt|;
return|return
operator|(
name|t
operator|)
return|;
case|case
name|STGINTR
case|:
return|return
operator|(
name|intraddr
argument_list|(
name|p
argument_list|)
operator|)
return|;
block|}
name|badstg
argument_list|(
literal|"mkaddr"
argument_list|,
name|p
operator|->
name|vstg
argument_list|)
expr_stmt|;
comment|/* NOT REACHED */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* mkarg -- create storage for a new parameter.  This is called when a    function returns a string (for the return value, which is the first    parameter), or when a variable-length string is passed to a function. */
end_comment

begin_function
name|Addrp
name|mkarg
parameter_list|(
name|type
parameter_list|,
name|argno
parameter_list|)
name|int
name|type
decl_stmt|,
name|argno
decl_stmt|;
block|{
specifier|register
name|Addrp
name|p
decl_stmt|;
name|p
operator|=
name|ALLOC
argument_list|(
name|Addrblock
argument_list|)
expr_stmt|;
name|p
operator|->
name|tag
operator|=
name|TADDR
expr_stmt|;
name|p
operator|->
name|vtype
operator|=
name|type
expr_stmt|;
name|p
operator|->
name|vclass
operator|=
name|CLVAR
expr_stmt|;
comment|/* TYLENG is the type of the field holding the length of a character string */
name|p
operator|->
name|vstg
operator|=
operator|(
name|type
operator|==
name|TYLENG
condition|?
name|STGLENG
else|:
name|STGARG
operator|)
expr_stmt|;
name|p
operator|->
name|memno
operator|=
name|argno
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/* mkprim -- Create a PRIM (primary/primitive) block consisting of a    Nameblock (or Paramblock), arguments (actual params or array    subscripts) and substring bounds.  Requires that   v   have lots of    extra (uninitialized) storage, since it could be a paramblock or    nameblock */
end_comment

begin_function
name|expptr
name|mkprim
parameter_list|(
name|v0
parameter_list|,
name|args
parameter_list|,
name|substr
parameter_list|)
name|Namep
name|v0
decl_stmt|;
name|struct
name|Listblock
modifier|*
name|args
decl_stmt|;
name|chainp
name|substr
decl_stmt|;
block|{
typedef|typedef
union|union
block|{
name|struct
name|Paramblock
name|paramblock
decl_stmt|;
name|struct
name|Nameblock
name|nameblock
decl_stmt|;
name|struct
name|Headblock
name|headblock
decl_stmt|;
block|}
typedef|*
name|Primu
typedef|;
specifier|register
name|Primu
name|v
init|=
operator|(
name|Primu
operator|)
name|v0
decl_stmt|;
specifier|register
name|struct
name|Primblock
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|v
operator|->
name|headblock
operator|.
name|vclass
operator|==
name|CLPARAM
condition|)
block|{
comment|/* v   is to be a Paramblock */
if|if
condition|(
name|args
operator|||
name|substr
condition|)
block|{
name|errstr
argument_list|(
literal|"no qualifiers on parameter name %s"
argument_list|,
name|v
operator|->
name|paramblock
operator|.
name|fvarname
argument_list|)
expr_stmt|;
name|frexpr
argument_list|(
operator|(
name|expptr
operator|)
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|substr
condition|)
block|{
name|frexpr
argument_list|(
operator|(
name|tagptr
operator|)
name|substr
operator|->
name|datap
argument_list|)
expr_stmt|;
name|frexpr
argument_list|(
operator|(
name|tagptr
operator|)
name|substr
operator|->
name|nextp
operator|->
name|datap
argument_list|)
expr_stmt|;
name|frchain
argument_list|(
operator|&
name|substr
argument_list|)
expr_stmt|;
block|}
name|frexpr
argument_list|(
operator|(
name|expptr
operator|)
name|v
argument_list|)
expr_stmt|;
return|return
operator|(
name|errnode
argument_list|()
operator|)
return|;
block|}
return|return
operator|(
operator|(
name|expptr
operator|)
name|cpexpr
argument_list|(
name|v
operator|->
name|paramblock
operator|.
name|paramval
argument_list|)
operator|)
return|;
block|}
name|p
operator|=
name|ALLOC
argument_list|(
name|Primblock
argument_list|)
expr_stmt|;
name|p
operator|->
name|tag
operator|=
name|TPRIM
expr_stmt|;
name|p
operator|->
name|vtype
operator|=
name|v
operator|->
name|nameblock
operator|.
name|vtype
expr_stmt|;
comment|/* v   is to be a Nameblock */
name|p
operator|->
name|namep
operator|=
operator|(
name|Namep
operator|)
name|v
expr_stmt|;
name|p
operator|->
name|argsp
operator|=
name|args
expr_stmt|;
if|if
condition|(
name|substr
condition|)
block|{
name|p
operator|->
name|fcharp
operator|=
operator|(
name|expptr
operator|)
name|substr
operator|->
name|datap
expr_stmt|;
name|p
operator|->
name|lcharp
operator|=
operator|(
name|expptr
operator|)
name|substr
operator|->
name|nextp
operator|->
name|datap
expr_stmt|;
name|frchain
argument_list|(
operator|&
name|substr
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|(
name|expptr
operator|)
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/* vardcl -- attempt to fill out the Name template for variable   v.    This function is called on identifiers known to be variables or    recursive references to the same function */
end_comment

begin_expr_stmt
name|vardcl
argument_list|(
name|v
argument_list|)
specifier|register
name|Namep
name|v
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|Dimblock
modifier|*
name|t
decl_stmt|;
name|expptr
name|neltp
decl_stmt|;
specifier|extern
name|int
name|doing_stmtfcn
decl_stmt|;
if|if
condition|(
name|v
operator|->
name|vclass
operator|==
name|CLUNKNOWN
condition|)
block|{
name|v
operator|->
name|vclass
operator|=
name|CLVAR
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|vinftype
condition|)
block|{
name|v
operator|->
name|vtype
operator|=
name|TYUNKNOWN
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|vdcldone
condition|)
block|{
name|v
operator|->
name|vdcldone
operator|=
literal|0
expr_stmt|;
name|impldcl
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|v
operator|->
name|vdcldone
condition|)
return|return;
if|if
condition|(
name|v
operator|->
name|vclass
operator|==
name|CLNAMELIST
condition|)
return|return;
if|if
condition|(
name|v
operator|->
name|vtype
operator|==
name|TYUNKNOWN
condition|)
name|impldcl
argument_list|(
name|v
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|v
operator|->
name|vclass
operator|!=
name|CLVAR
operator|&&
name|v
operator|->
name|vprocclass
operator|!=
name|PTHISPROC
condition|)
block|{
name|dclerr
argument_list|(
literal|"used as variable"
argument_list|,
name|v
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|v
operator|->
name|vstg
operator|==
name|STGUNKNOWN
condition|)
block|{
if|if
condition|(
name|doing_stmtfcn
condition|)
block|{
comment|/* neither declare this variable if its only use */
comment|/* is in defining a stmt function, nor complain  */
comment|/* that it is never used */
name|v
operator|->
name|vimpldovar
operator|=
literal|1
expr_stmt|;
return|return;
block|}
name|v
operator|->
name|vstg
operator|=
name|implstg
index|[
name|letter
argument_list|(
name|v
operator|->
name|fvarname
index|[
literal|0
index|]
argument_list|)
index|]
expr_stmt|;
name|v
operator|->
name|vimplstg
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Compute the actual storage location, i.e. offsets from base addresses,    possibly the stack pointer */
switch|switch
condition|(
name|v
operator|->
name|vstg
condition|)
block|{
case|case
name|STGBSS
case|:
name|v
operator|->
name|vardesc
operator|.
name|varno
operator|=
operator|++
name|lastvarno
expr_stmt|;
break|break;
case|case
name|STGAUTO
case|:
if|if
condition|(
name|v
operator|->
name|vclass
operator|==
name|CLPROC
operator|&&
name|v
operator|->
name|vprocclass
operator|==
name|PTHISPROC
condition|)
break|break;
if|if
condition|(
name|t
operator|=
name|v
operator|->
name|vdim
condition|)
if|if
condition|(
operator|(
name|neltp
operator|=
name|t
operator|->
name|nelt
operator|)
operator|&&
name|ISCONST
argument_list|(
name|neltp
argument_list|)
condition|)
empty_stmt|;
else|else
name|dclerr
argument_list|(
literal|"adjustable automatic array"
argument_list|,
name|v
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|v
operator|->
name|vdcldone
operator|=
name|YES
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Set the implicit type declaration of parameter   p   based on its first    letter */
end_comment

begin_expr_stmt
name|impldcl
argument_list|(
name|p
argument_list|)
specifier|register
name|Namep
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|k
decl_stmt|;
name|int
name|type
decl_stmt|;
name|ftnint
name|leng
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|vdcldone
operator|||
operator|(
name|p
operator|->
name|vclass
operator|==
name|CLPROC
operator|&&
name|p
operator|->
name|vprocclass
operator|==
name|PINTRINSIC
operator|)
condition|)
return|return;
if|if
condition|(
name|p
operator|->
name|vtype
operator|==
name|TYUNKNOWN
condition|)
block|{
name|k
operator|=
name|letter
argument_list|(
name|p
operator|->
name|fvarname
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|type
operator|=
name|impltype
index|[
name|k
index|]
expr_stmt|;
name|leng
operator|=
name|implleng
index|[
name|k
index|]
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|TYUNKNOWN
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|vclass
operator|==
name|CLPROC
condition|)
return|return;
name|dclerr
argument_list|(
literal|"attempt to use undefined variable"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|type
operator|=
name|dflttype
index|[
name|k
index|]
expr_stmt|;
name|leng
operator|=
literal|0
expr_stmt|;
block|}
name|settype
argument_list|(
name|p
argument_list|,
name|type
argument_list|,
name|leng
argument_list|)
expr_stmt|;
name|p
operator|->
name|vimpltype
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_block

begin_function
name|void
name|inferdcl
parameter_list|(
name|np
parameter_list|,
name|type
parameter_list|)
name|Namep
name|np
decl_stmt|;
name|int
name|type
decl_stmt|;
block|{
name|int
name|k
init|=
name|impltype
index|[
name|letter
argument_list|(
name|np
operator|->
name|fvarname
index|[
literal|0
index|]
argument_list|)
index|]
decl_stmt|;
if|if
condition|(
name|k
operator|!=
name|type
condition|)
block|{
name|np
operator|->
name|vinftype
operator|=
literal|1
expr_stmt|;
name|np
operator|->
name|vtype
operator|=
name|type
expr_stmt|;
name|frexpr
argument_list|(
name|np
operator|->
name|vleng
argument_list|)
expr_stmt|;
name|np
operator|->
name|vleng
operator|=
literal|0
expr_stmt|;
block|}
name|np
operator|->
name|vimpltype
operator|=
literal|0
expr_stmt|;
name|np
operator|->
name|vinfproc
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|ICONEQ
parameter_list|(
name|z
parameter_list|,
name|c
parameter_list|)
value|(ISICON(z)&& z->constblock.Const.ci==c)
end_define

begin_define
define|#
directive|define
name|COMMUTE
value|{ e = lp;  lp = rp;  rp = e; }
end_define

begin_comment
comment|/* mkexpr -- Make expression, and simplify constant subcomponents (tree    order is not preserved).  Assumes that   lp   is nonempty, and uses    fold()   to simplify adjacent constants */
end_comment

begin_function
name|expptr
name|mkexpr
parameter_list|(
name|opcode
parameter_list|,
name|lp
parameter_list|,
name|rp
parameter_list|)
name|int
name|opcode
decl_stmt|;
specifier|register
name|expptr
name|lp
decl_stmt|,
name|rp
decl_stmt|;
block|{
specifier|register
name|expptr
name|e
decl_stmt|,
name|e1
decl_stmt|;
name|int
name|etype
decl_stmt|;
name|int
name|ltype
decl_stmt|,
name|rtype
decl_stmt|;
name|int
name|ltag
decl_stmt|,
name|rtag
decl_stmt|;
name|long
name|L
decl_stmt|;
name|ltype
operator|=
name|lp
operator|->
name|headblock
operator|.
name|vtype
expr_stmt|;
name|ltag
operator|=
name|lp
operator|->
name|tag
expr_stmt|;
if|if
condition|(
name|rp
operator|&&
name|opcode
operator|!=
name|OPCALL
operator|&&
name|opcode
operator|!=
name|OPCCALL
condition|)
block|{
name|rtype
operator|=
name|rp
operator|->
name|headblock
operator|.
name|vtype
expr_stmt|;
name|rtag
operator|=
name|rp
operator|->
name|tag
expr_stmt|;
block|}
else|else
name|rtype
operator|=
literal|0
expr_stmt|;
name|etype
operator|=
name|cktype
argument_list|(
name|opcode
argument_list|,
name|ltype
argument_list|,
name|rtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|etype
operator|==
name|TYERROR
condition|)
goto|goto
name|error
goto|;
switch|switch
condition|(
name|opcode
condition|)
block|{
comment|/* check for multiplication by 0 and 1 and addition to 0 */
case|case
name|OPSTAR
case|:
if|if
condition|(
name|ISCONST
argument_list|(
name|lp
argument_list|)
condition|)
name|COMMUTE
if|if
condition|(
name|ISICON
argument_list|(
name|rp
argument_list|)
condition|)
block|{
if|if
condition|(
name|rp
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
operator|==
literal|0
condition|)
goto|goto
name|retright
goto|;
goto|goto
name|mulop
goto|;
block|}
break|break;
case|case
name|OPSLASH
case|:
case|case
name|OPMOD
case|:
if|if
condition|(
name|ICONEQ
argument_list|(
name|rp
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|err
argument_list|(
literal|"attempted division by zero"
argument_list|)
expr_stmt|;
name|rp
operator|=
name|ICON
argument_list|(
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|opcode
operator|==
name|OPMOD
condition|)
break|break;
comment|/* Handle multiplying or dividing by 1, -1 */
name|mulop
label|:
if|if
condition|(
name|ISICON
argument_list|(
name|rp
argument_list|)
condition|)
block|{
if|if
condition|(
name|rp
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
operator|==
literal|1
condition|)
goto|goto
name|retleft
goto|;
if|if
condition|(
name|rp
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
operator|==
operator|-
literal|1
condition|)
block|{
name|frexpr
argument_list|(
name|rp
argument_list|)
expr_stmt|;
return|return
operator|(
name|mkexpr
argument_list|(
name|OPNEG
argument_list|,
name|lp
argument_list|,
name|ENULL
argument_list|)
operator|)
return|;
block|}
block|}
comment|/* Group all constants together.  In particular,  	(x * CONST1) * CONST2 ==> x * (CONST1 * CONST2) 	(x * CONST1) / CONST2 ==> x * (CONST1 / CONST2) */
if|if
condition|(
name|lp
operator|->
name|tag
operator|!=
name|TEXPR
operator|||
operator|!
name|lp
operator|->
name|exprblock
operator|.
name|rightp
operator|||
operator|!
name|ISICON
argument_list|(
name|lp
operator|->
name|exprblock
operator|.
name|rightp
argument_list|)
condition|)
break|break;
if|if
condition|(
name|lp
operator|->
name|exprblock
operator|.
name|opcode
operator|==
name|OPLSHIFT
condition|)
block|{
name|L
operator|=
literal|1
operator|<<
name|lp
operator|->
name|exprblock
operator|.
name|rightp
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
name|OPSTAR
operator|||
name|ISICON
argument_list|(
name|rp
argument_list|)
operator|&&
operator|!
operator|(
name|L
operator|%
name|rp
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
operator|)
condition|)
block|{
name|lp
operator|->
name|exprblock
operator|.
name|opcode
operator|=
name|OPSTAR
expr_stmt|;
name|lp
operator|->
name|exprblock
operator|.
name|rightp
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
operator|=
name|L
expr_stmt|;
block|}
block|}
if|if
condition|(
name|lp
operator|->
name|exprblock
operator|.
name|opcode
operator|==
name|OPSTAR
condition|)
block|{
if|if
condition|(
name|opcode
operator|==
name|OPSTAR
condition|)
name|e
operator|=
name|mkexpr
argument_list|(
name|OPSTAR
argument_list|,
name|lp
operator|->
name|exprblock
operator|.
name|rightp
argument_list|,
name|rp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ISICON
argument_list|(
name|rp
argument_list|)
operator|&&
operator|(
name|lp
operator|->
name|exprblock
operator|.
name|rightp
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
operator|%
name|rp
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
operator|)
operator|==
literal|0
condition|)
name|e
operator|=
name|mkexpr
argument_list|(
name|OPSLASH
argument_list|,
name|lp
operator|->
name|exprblock
operator|.
name|rightp
argument_list|,
name|rp
argument_list|)
expr_stmt|;
else|else
break|break;
name|e1
operator|=
name|lp
operator|->
name|exprblock
operator|.
name|leftp
expr_stmt|;
name|free
argument_list|(
operator|(
name|charptr
operator|)
name|lp
argument_list|)
expr_stmt|;
return|return
operator|(
name|mkexpr
argument_list|(
name|OPSTAR
argument_list|,
name|e1
argument_list|,
name|e
argument_list|)
operator|)
return|;
block|}
break|break;
case|case
name|OPPLUS
case|:
if|if
condition|(
name|ISCONST
argument_list|(
name|lp
argument_list|)
condition|)
name|COMMUTE
goto|goto
name|addop
goto|;
case|case
name|OPMINUS
case|:
if|if
condition|(
name|ICONEQ
argument_list|(
name|lp
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|frexpr
argument_list|(
name|lp
argument_list|)
expr_stmt|;
return|return
operator|(
name|mkexpr
argument_list|(
name|OPNEG
argument_list|,
name|rp
argument_list|,
name|ENULL
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|ISCONST
argument_list|(
name|rp
argument_list|)
operator|&&
name|is_negatable
argument_list|(
operator|(
name|Constp
operator|)
name|rp
argument_list|)
condition|)
block|{
name|opcode
operator|=
name|OPPLUS
expr_stmt|;
name|consnegop
argument_list|(
operator|(
name|Constp
operator|)
name|rp
argument_list|)
expr_stmt|;
block|}
comment|/* Group constants in an addition expression (also subtraction, since the    subtracted value was negated above).  In particular,  	(x + CONST1) + CONST2 ==> x + (CONST1 + CONST2) */
name|addop
label|:
if|if
condition|(
name|ISICON
argument_list|(
name|rp
argument_list|)
condition|)
block|{
if|if
condition|(
name|rp
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
operator|==
literal|0
condition|)
goto|goto
name|retleft
goto|;
if|if
condition|(
name|ISPLUSOP
argument_list|(
name|lp
argument_list|)
operator|&&
name|ISICON
argument_list|(
name|lp
operator|->
name|exprblock
operator|.
name|rightp
argument_list|)
condition|)
block|{
name|e
operator|=
name|mkexpr
argument_list|(
name|OPPLUS
argument_list|,
name|lp
operator|->
name|exprblock
operator|.
name|rightp
argument_list|,
name|rp
argument_list|)
expr_stmt|;
name|e1
operator|=
name|lp
operator|->
name|exprblock
operator|.
name|leftp
expr_stmt|;
name|free
argument_list|(
operator|(
name|charptr
operator|)
name|lp
argument_list|)
expr_stmt|;
return|return
operator|(
name|mkexpr
argument_list|(
name|OPPLUS
argument_list|,
name|e1
argument_list|,
name|e
argument_list|)
operator|)
return|;
block|}
block|}
if|if
condition|(
name|opcode
operator|==
name|OPMINUS
operator|&&
operator|(
name|ISINT
argument_list|(
name|etype
argument_list|)
operator|||
name|doing_vleng
operator|)
condition|)
block|{
comment|/* check for (i [+const]) - (i [+const]) */
if|if
condition|(
name|lp
operator|->
name|tag
operator|==
name|TPRIM
condition|)
name|e
operator|=
name|lp
expr_stmt|;
elseif|else
if|if
condition|(
name|lp
operator|->
name|tag
operator|==
name|TEXPR
operator|&&
name|lp
operator|->
name|exprblock
operator|.
name|opcode
operator|==
name|OPPLUS
operator|&&
name|lp
operator|->
name|exprblock
operator|.
name|rightp
operator|->
name|tag
operator|==
name|TCONST
condition|)
block|{
name|e
operator|=
name|lp
operator|->
name|exprblock
operator|.
name|leftp
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|tag
operator|!=
name|TPRIM
condition|)
break|break;
block|}
else|else
break|break;
if|if
condition|(
name|e
operator|->
name|primblock
operator|.
name|argsp
condition|)
break|break;
if|if
condition|(
name|rp
operator|->
name|tag
operator|==
name|TPRIM
condition|)
name|e1
operator|=
name|rp
expr_stmt|;
elseif|else
if|if
condition|(
name|rp
operator|->
name|tag
operator|==
name|TEXPR
operator|&&
name|rp
operator|->
name|exprblock
operator|.
name|opcode
operator|==
name|OPPLUS
operator|&&
name|rp
operator|->
name|exprblock
operator|.
name|rightp
operator|->
name|tag
operator|==
name|TCONST
condition|)
block|{
name|e1
operator|=
name|rp
operator|->
name|exprblock
operator|.
name|leftp
expr_stmt|;
if|if
condition|(
name|e1
operator|->
name|tag
operator|!=
name|TPRIM
condition|)
break|break;
block|}
else|else
break|break;
if|if
condition|(
name|e
operator|->
name|primblock
operator|.
name|namep
operator|!=
name|e1
operator|->
name|primblock
operator|.
name|namep
operator|||
name|e1
operator|->
name|primblock
operator|.
name|argsp
condition|)
break|break;
name|L
operator|=
name|e
operator|==
name|lp
condition|?
literal|0
else|:
name|lp
operator|->
name|exprblock
operator|.
name|rightp
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
expr_stmt|;
if|if
condition|(
name|e1
operator|!=
name|rp
condition|)
name|L
operator|-=
name|rp
operator|->
name|exprblock
operator|.
name|rightp
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
expr_stmt|;
name|frexpr
argument_list|(
name|lp
argument_list|)
expr_stmt|;
name|frexpr
argument_list|(
name|rp
argument_list|)
expr_stmt|;
return|return
name|ICON
argument_list|(
name|L
argument_list|)
return|;
block|}
break|break;
case|case
name|OPPOWER
case|:
break|break;
comment|/* Eliminate outermost double negations */
case|case
name|OPNEG
case|:
case|case
name|OPNEG1
case|:
if|if
condition|(
name|ltag
operator|==
name|TEXPR
operator|&&
name|lp
operator|->
name|exprblock
operator|.
name|opcode
operator|==
name|OPNEG
condition|)
block|{
name|e
operator|=
name|lp
operator|->
name|exprblock
operator|.
name|leftp
expr_stmt|;
name|free
argument_list|(
operator|(
name|charptr
operator|)
name|lp
argument_list|)
expr_stmt|;
return|return
operator|(
name|e
operator|)
return|;
block|}
break|break;
comment|/* Eliminate outermost double NOTs */
case|case
name|OPNOT
case|:
if|if
condition|(
name|ltag
operator|==
name|TEXPR
operator|&&
name|lp
operator|->
name|exprblock
operator|.
name|opcode
operator|==
name|OPNOT
condition|)
block|{
name|e
operator|=
name|lp
operator|->
name|exprblock
operator|.
name|leftp
expr_stmt|;
name|free
argument_list|(
operator|(
name|charptr
operator|)
name|lp
argument_list|)
expr_stmt|;
return|return
operator|(
name|e
operator|)
return|;
block|}
break|break;
case|case
name|OPCALL
case|:
case|case
name|OPCCALL
case|:
name|etype
operator|=
name|ltype
expr_stmt|;
if|if
condition|(
name|rp
operator|!=
name|NULL
operator|&&
name|rp
operator|->
name|listblock
operator|.
name|listp
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
operator|(
name|charptr
operator|)
name|rp
argument_list|)
expr_stmt|;
name|rp
operator|=
name|NULL
expr_stmt|;
block|}
break|break;
case|case
name|OPAND
case|:
case|case
name|OPOR
case|:
if|if
condition|(
name|ISCONST
argument_list|(
name|lp
argument_list|)
condition|)
name|COMMUTE
if|if
condition|(
name|ISCONST
argument_list|(
name|rp
argument_list|)
condition|)
block|{
if|if
condition|(
name|rp
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
operator|==
literal|0
condition|)
if|if
condition|(
name|opcode
operator|==
name|OPOR
condition|)
goto|goto
name|retleft
goto|;
else|else
goto|goto
name|retright
goto|;
elseif|else
if|if
condition|(
name|opcode
operator|==
name|OPOR
condition|)
goto|goto
name|retright
goto|;
else|else
goto|goto
name|retleft
goto|;
block|}
case|case
name|OPEQV
case|:
case|case
name|OPNEQV
case|:
case|case
name|OPBITAND
case|:
case|case
name|OPBITOR
case|:
case|case
name|OPBITXOR
case|:
case|case
name|OPBITNOT
case|:
case|case
name|OPLSHIFT
case|:
case|case
name|OPRSHIFT
case|:
case|case
name|OPLT
case|:
case|case
name|OPGT
case|:
case|case
name|OPLE
case|:
case|case
name|OPGE
case|:
case|case
name|OPEQ
case|:
case|case
name|OPNE
case|:
case|case
name|OPCONCAT
case|:
break|break;
case|case
name|OPMIN
case|:
case|case
name|OPMAX
case|:
case|case
name|OPMIN2
case|:
case|case
name|OPMAX2
case|:
case|case
name|OPDMIN
case|:
case|case
name|OPDMAX
case|:
case|case
name|OPASSIGN
case|:
case|case
name|OPASSIGNI
case|:
case|case
name|OPPLUSEQ
case|:
case|case
name|OPSTAREQ
case|:
case|case
name|OPMINUSEQ
case|:
case|case
name|OPSLASHEQ
case|:
case|case
name|OPMODEQ
case|:
case|case
name|OPLSHIFTEQ
case|:
case|case
name|OPRSHIFTEQ
case|:
case|case
name|OPBITANDEQ
case|:
case|case
name|OPBITXOREQ
case|:
case|case
name|OPBITOREQ
case|:
case|case
name|OPCONV
case|:
case|case
name|OPADDR
case|:
case|case
name|OPWHATSIN
case|:
case|case
name|OPCOMMA
case|:
case|case
name|OPCOMMA_ARG
case|:
case|case
name|OPQUEST
case|:
case|case
name|OPCOLON
case|:
case|case
name|OPDOT
case|:
case|case
name|OPARROW
case|:
case|case
name|OPIDENTITY
case|:
case|case
name|OPCHARCAST
case|:
case|case
name|OPABS
case|:
case|case
name|OPDABS
case|:
break|break;
default|default:
name|badop
argument_list|(
literal|"mkexpr"
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
block|}
name|e
operator|=
operator|(
name|expptr
operator|)
name|ALLOC
argument_list|(
name|Exprblock
argument_list|)
expr_stmt|;
name|e
operator|->
name|exprblock
operator|.
name|tag
operator|=
name|TEXPR
expr_stmt|;
name|e
operator|->
name|exprblock
operator|.
name|opcode
operator|=
name|opcode
expr_stmt|;
name|e
operator|->
name|exprblock
operator|.
name|vtype
operator|=
name|etype
expr_stmt|;
name|e
operator|->
name|exprblock
operator|.
name|leftp
operator|=
name|lp
expr_stmt|;
name|e
operator|->
name|exprblock
operator|.
name|rightp
operator|=
name|rp
expr_stmt|;
if|if
condition|(
name|ltag
operator|==
name|TCONST
operator|&&
operator|(
name|rp
operator|==
literal|0
operator|||
name|rtag
operator|==
name|TCONST
operator|)
condition|)
name|e
operator|=
name|fold
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
operator|(
name|e
operator|)
return|;
name|retleft
label|:
name|frexpr
argument_list|(
name|rp
argument_list|)
expr_stmt|;
if|if
condition|(
name|lp
operator|->
name|tag
operator|==
name|TPRIM
condition|)
name|lp
operator|->
name|primblock
operator|.
name|parenused
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|lp
operator|)
return|;
name|retright
label|:
name|frexpr
argument_list|(
name|lp
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp
operator|->
name|tag
operator|==
name|TPRIM
condition|)
name|rp
operator|->
name|primblock
operator|.
name|parenused
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|rp
operator|)
return|;
name|error
label|:
name|frexpr
argument_list|(
name|lp
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp
operator|&&
name|opcode
operator|!=
name|OPCALL
operator|&&
name|opcode
operator|!=
name|OPCCALL
condition|)
name|frexpr
argument_list|(
name|rp
argument_list|)
expr_stmt|;
return|return
operator|(
name|errnode
argument_list|()
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|ERR
parameter_list|(
name|s
parameter_list|)
value|{ errs = s; goto error; }
end_define

begin_comment
comment|/* cktype -- Check and return the type of the expression */
end_comment

begin_expr_stmt
name|cktype
argument_list|(
name|op
argument_list|,
name|lt
argument_list|,
name|rt
argument_list|)
specifier|register
name|int
name|op
operator|,
name|lt
operator|,
name|rt
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|char
modifier|*
name|errs
decl_stmt|;
if|if
condition|(
name|lt
operator|==
name|TYERROR
operator|||
name|rt
operator|==
name|TYERROR
condition|)
goto|goto
name|error1
goto|;
if|if
condition|(
name|lt
operator|==
name|TYUNKNOWN
condition|)
return|return
operator|(
name|TYUNKNOWN
operator|)
return|;
if|if
condition|(
name|rt
operator|==
name|TYUNKNOWN
condition|)
comment|/* If not unary operation, return UNKNOWN */
if|if
condition|(
operator|!
name|is_unary_op
argument_list|(
name|op
argument_list|)
operator|&&
name|op
operator|!=
name|OPCALL
operator|&&
name|op
operator|!=
name|OPCCALL
condition|)
return|return
operator|(
name|TYUNKNOWN
operator|)
return|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|OPPLUS
case|:
case|case
name|OPMINUS
case|:
case|case
name|OPSTAR
case|:
case|case
name|OPSLASH
case|:
case|case
name|OPPOWER
case|:
case|case
name|OPMOD
case|:
if|if
condition|(
name|ISNUMERIC
argument_list|(
name|lt
argument_list|)
operator|&&
name|ISNUMERIC
argument_list|(
name|rt
argument_list|)
condition|)
return|return
operator|(
name|maxtype
argument_list|(
name|lt
argument_list|,
name|rt
argument_list|)
operator|)
return|;
name|ERR
argument_list|(
literal|"nonarithmetic operand of arithmetic operator"
argument_list|)
case|case
name|OPNEG
case|:
case|case
name|OPNEG1
case|:
if|if
condition|(
name|ISNUMERIC
argument_list|(
name|lt
argument_list|)
condition|)
return|return
operator|(
name|lt
operator|)
return|;
name|ERR
argument_list|(
literal|"nonarithmetic operand of negation"
argument_list|)
case|case
name|OPNOT
case|:
if|if
condition|(
name|ISLOGICAL
argument_list|(
name|lt
argument_list|)
condition|)
return|return
operator|(
name|lt
operator|)
return|;
name|ERR
argument_list|(
literal|"NOT of nonlogical"
argument_list|)
case|case
name|OPAND
case|:
case|case
name|OPOR
case|:
case|case
name|OPEQV
case|:
case|case
name|OPNEQV
case|:
if|if
condition|(
name|ISLOGICAL
argument_list|(
name|lt
argument_list|)
operator|&&
name|ISLOGICAL
argument_list|(
name|rt
argument_list|)
condition|)
return|return
operator|(
name|maxtype
argument_list|(
name|lt
argument_list|,
name|rt
argument_list|)
operator|)
return|;
name|ERR
argument_list|(
literal|"nonlogical operand of logical operator"
argument_list|)
case|case
name|OPLT
case|:
case|case
name|OPGT
case|:
case|case
name|OPLE
case|:
case|case
name|OPGE
case|:
case|case
name|OPEQ
case|:
case|case
name|OPNE
case|:
if|if
condition|(
name|lt
operator|==
name|TYCHAR
operator|||
name|rt
operator|==
name|TYCHAR
operator|||
name|ISLOGICAL
argument_list|(
name|lt
argument_list|)
operator|||
name|ISLOGICAL
argument_list|(
name|rt
argument_list|)
condition|)
block|{
if|if
condition|(
name|lt
operator|!=
name|rt
condition|)
block|{
if|if
condition|(
name|htype
operator|&&
operator|(
name|lt
operator|==
name|TYCHAR
operator|&&
name|ISNUMERIC
argument_list|(
name|rt
argument_list|)
operator|||
name|rt
operator|==
name|TYCHAR
operator|&&
name|ISNUMERIC
argument_list|(
name|lt
argument_list|)
operator|)
condition|)
return|return
name|TYLOGICAL
return|;
name|ERR
argument_list|(
literal|"illegal comparison"
argument_list|)
block|}
block|}
elseif|else
if|if
condition|(
name|ISCOMPLEX
argument_list|(
name|lt
argument_list|)
operator|||
name|ISCOMPLEX
argument_list|(
name|rt
argument_list|)
condition|)
block|{
if|if
condition|(
name|op
operator|!=
name|OPEQ
operator|&&
name|op
operator|!=
name|OPNE
condition|)
name|ERR
argument_list|(
literal|"order comparison of complex data"
argument_list|)
block|}
elseif|else
if|if
condition|(
operator|!
name|ISNUMERIC
argument_list|(
name|lt
argument_list|)
operator|||
operator|!
name|ISNUMERIC
argument_list|(
name|rt
argument_list|)
condition|)
name|ERR
argument_list|(
literal|"comparison of nonarithmetic data"
argument_list|)
return|return
operator|(
name|TYLOGICAL
operator|)
return|;
case|case
name|OPCONCAT
case|:
if|if
condition|(
name|lt
operator|==
name|TYCHAR
operator|&&
name|rt
operator|==
name|TYCHAR
condition|)
return|return
operator|(
name|TYCHAR
operator|)
return|;
name|ERR
argument_list|(
literal|"concatenation of nonchar data"
argument_list|)
case|case
name|OPCALL
case|:
case|case
name|OPCCALL
case|:
case|case
name|OPIDENTITY
case|:
return|return
operator|(
name|lt
operator|)
return|;
case|case
name|OPADDR
case|:
case|case
name|OPCHARCAST
case|:
return|return
operator|(
name|TYADDR
operator|)
return|;
case|case
name|OPCONV
case|:
if|if
condition|(
name|rt
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|lt
operator|==
name|TYCHAR
operator|&&
name|ISINT
argument_list|(
name|rt
argument_list|)
condition|)
return|return
operator|(
name|TYCHAR
operator|)
return|;
if|if
condition|(
name|ISLOGICAL
argument_list|(
name|lt
argument_list|)
operator|&&
name|ISLOGICAL
argument_list|(
name|rt
argument_list|)
condition|)
return|return
name|lt
return|;
case|case
name|OPASSIGN
case|:
case|case
name|OPASSIGNI
case|:
case|case
name|OPMINUSEQ
case|:
case|case
name|OPPLUSEQ
case|:
case|case
name|OPSTAREQ
case|:
case|case
name|OPSLASHEQ
case|:
case|case
name|OPMODEQ
case|:
case|case
name|OPLSHIFTEQ
case|:
case|case
name|OPRSHIFTEQ
case|:
case|case
name|OPBITANDEQ
case|:
case|case
name|OPBITXOREQ
case|:
case|case
name|OPBITOREQ
case|:
if|if
condition|(
name|ISINT
argument_list|(
name|lt
argument_list|)
operator|&&
name|rt
operator|==
name|TYCHAR
condition|)
return|return
operator|(
name|lt
operator|)
return|;
if|if
condition|(
name|ISLOGICAL
argument_list|(
name|lt
argument_list|)
operator|&&
name|ISLOGICAL
argument_list|(
name|rt
argument_list|)
operator|&&
name|op
operator|==
name|OPASSIGN
condition|)
return|return
name|lt
return|;
if|if
condition|(
name|lt
operator|==
name|TYCHAR
operator|||
name|rt
operator|==
name|TYCHAR
operator|||
name|ISLOGICAL
argument_list|(
name|lt
argument_list|)
operator|||
name|ISLOGICAL
argument_list|(
name|rt
argument_list|)
condition|)
if|if
condition|(
operator|(
name|op
operator|!=
name|OPASSIGN
operator|&&
name|op
operator|!=
name|OPPLUSEQ
operator|&&
name|op
operator|!=
name|OPMINUSEQ
operator|)
operator|||
operator|(
name|lt
operator|!=
name|rt
operator|)
condition|)
block|{
name|ERR
argument_list|(
literal|"impossible conversion"
argument_list|)
block|}
return|return
operator|(
name|lt
operator|)
return|;
case|case
name|OPMIN
case|:
case|case
name|OPMAX
case|:
case|case
name|OPDMIN
case|:
case|case
name|OPDMAX
case|:
case|case
name|OPMIN2
case|:
case|case
name|OPMAX2
case|:
case|case
name|OPBITOR
case|:
case|case
name|OPBITAND
case|:
case|case
name|OPBITXOR
case|:
case|case
name|OPBITNOT
case|:
case|case
name|OPLSHIFT
case|:
case|case
name|OPRSHIFT
case|:
case|case
name|OPWHATSIN
case|:
case|case
name|OPABS
case|:
case|case
name|OPDABS
case|:
return|return
operator|(
name|lt
operator|)
return|;
case|case
name|OPCOMMA
case|:
case|case
name|OPCOMMA_ARG
case|:
case|case
name|OPQUEST
case|:
case|case
name|OPCOLON
case|:
comment|/* Only checks the rightmost type because 				   of C language definition (rightmost 				   comma-expr is the value of the expr) */
return|return
operator|(
name|rt
operator|)
return|;
case|case
name|OPDOT
case|:
case|case
name|OPARROW
case|:
return|return
operator|(
name|lt
operator|)
return|;
break|break;
default|default:
name|badop
argument_list|(
literal|"cktype"
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
name|error
label|:
name|err
argument_list|(
name|errs
argument_list|)
expr_stmt|;
name|error1
label|:
return|return
operator|(
name|TYERROR
operator|)
return|;
block|}
end_block

begin_comment
comment|/* fold -- simplifies constant expressions; it assumes that e -> leftp and    e -> rightp are TCONST or NULL */
end_comment

begin_function
name|LOCAL
name|expptr
name|fold
parameter_list|(
name|e
parameter_list|)
specifier|register
name|expptr
name|e
decl_stmt|;
block|{
name|Constp
name|p
decl_stmt|;
specifier|register
name|expptr
name|lp
decl_stmt|,
name|rp
decl_stmt|;
name|int
name|etype
decl_stmt|,
name|mtype
decl_stmt|,
name|ltype
decl_stmt|,
name|rtype
decl_stmt|,
name|opcode
decl_stmt|;
name|int
name|i
decl_stmt|,
name|bl
decl_stmt|,
name|ll
decl_stmt|,
name|lr
decl_stmt|;
name|char
modifier|*
name|q
decl_stmt|,
modifier|*
name|s
decl_stmt|;
name|struct
name|Constblock
name|lcon
decl_stmt|,
name|rcon
decl_stmt|;
name|long
name|L
decl_stmt|;
name|double
name|d
decl_stmt|;
name|opcode
operator|=
name|e
operator|->
name|exprblock
operator|.
name|opcode
expr_stmt|;
name|etype
operator|=
name|e
operator|->
name|exprblock
operator|.
name|vtype
expr_stmt|;
name|lp
operator|=
name|e
operator|->
name|exprblock
operator|.
name|leftp
expr_stmt|;
name|ltype
operator|=
name|lp
operator|->
name|headblock
operator|.
name|vtype
expr_stmt|;
name|rp
operator|=
name|e
operator|->
name|exprblock
operator|.
name|rightp
expr_stmt|;
if|if
condition|(
name|rp
operator|==
literal|0
condition|)
switch|switch
condition|(
name|opcode
condition|)
block|{
case|case
name|OPNOT
case|:
name|lp
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
operator|=
operator|!
name|lp
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
expr_stmt|;
name|retlp
label|:
name|e
operator|->
name|exprblock
operator|.
name|leftp
operator|=
literal|0
expr_stmt|;
name|frexpr
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
operator|(
name|lp
operator|)
return|;
case|case
name|OPBITNOT
case|:
name|lp
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
operator|=
operator|~
name|lp
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
expr_stmt|;
goto|goto
name|retlp
goto|;
case|case
name|OPNEG
case|:
case|case
name|OPNEG1
case|:
name|consnegop
argument_list|(
operator|(
name|Constp
operator|)
name|lp
argument_list|)
expr_stmt|;
goto|goto
name|retlp
goto|;
case|case
name|OPCONV
case|:
case|case
name|OPADDR
case|:
return|return
operator|(
name|e
operator|)
return|;
case|case
name|OPABS
case|:
case|case
name|OPDABS
case|:
switch|switch
condition|(
name|ltype
condition|)
block|{
case|case
name|TYINT1
case|:
case|case
name|TYSHORT
case|:
case|case
name|TYLONG
case|:
ifdef|#
directive|ifdef
name|TYQUAD
case|case
name|TYQUAD
case|:
endif|#
directive|endif
if|if
condition|(
operator|(
name|L
operator|=
name|lp
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
operator|)
operator|<
literal|0
condition|)
name|lp
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
operator|=
operator|-
name|L
expr_stmt|;
goto|goto
name|retlp
goto|;
case|case
name|TYREAL
case|:
case|case
name|TYDREAL
case|:
if|if
condition|(
name|lp
operator|->
name|constblock
operator|.
name|vstg
condition|)
block|{
name|s
operator|=
name|lp
operator|->
name|constblock
operator|.
name|Const
operator|.
name|cds
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'-'
condition|)
name|lp
operator|->
name|constblock
operator|.
name|Const
operator|.
name|cds
index|[
literal|0
index|]
operator|=
name|s
operator|+
literal|1
expr_stmt|;
goto|goto
name|retlp
goto|;
block|}
if|if
condition|(
operator|(
name|d
operator|=
name|lp
operator|->
name|constblock
operator|.
name|Const
operator|.
name|cd
index|[
literal|0
index|]
operator|)
operator|<
literal|0.
condition|)
name|lp
operator|->
name|constblock
operator|.
name|Const
operator|.
name|cd
index|[
literal|0
index|]
operator|=
operator|-
name|d
expr_stmt|;
case|case
name|TYCOMPLEX
case|:
case|case
name|TYDCOMPLEX
case|:
return|return
name|e
return|;
comment|/* lazy way out */
block|}
default|default:
name|badop
argument_list|(
literal|"fold"
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
block|}
name|rtype
operator|=
name|rp
operator|->
name|headblock
operator|.
name|vtype
expr_stmt|;
name|p
operator|=
name|ALLOC
argument_list|(
name|Constblock
argument_list|)
expr_stmt|;
name|p
operator|->
name|tag
operator|=
name|TCONST
expr_stmt|;
name|p
operator|->
name|vtype
operator|=
name|etype
expr_stmt|;
name|p
operator|->
name|vleng
operator|=
name|e
operator|->
name|exprblock
operator|.
name|vleng
expr_stmt|;
switch|switch
condition|(
name|opcode
condition|)
block|{
case|case
name|OPCOMMA
case|:
case|case
name|OPCOMMA_ARG
case|:
case|case
name|OPQUEST
case|:
case|case
name|OPCOLON
case|:
return|return
operator|(
name|e
operator|)
return|;
case|case
name|OPAND
case|:
name|p
operator|->
name|Const
operator|.
name|ci
operator|=
name|lp
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
operator|&&
name|rp
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
expr_stmt|;
break|break;
case|case
name|OPOR
case|:
name|p
operator|->
name|Const
operator|.
name|ci
operator|=
name|lp
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
operator|||
name|rp
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
expr_stmt|;
break|break;
case|case
name|OPEQV
case|:
name|p
operator|->
name|Const
operator|.
name|ci
operator|=
name|lp
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
operator|==
name|rp
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
expr_stmt|;
break|break;
case|case
name|OPNEQV
case|:
name|p
operator|->
name|Const
operator|.
name|ci
operator|=
name|lp
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
operator|!=
name|rp
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
expr_stmt|;
break|break;
case|case
name|OPBITAND
case|:
name|p
operator|->
name|Const
operator|.
name|ci
operator|=
name|lp
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
operator|&
name|rp
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
expr_stmt|;
break|break;
case|case
name|OPBITOR
case|:
name|p
operator|->
name|Const
operator|.
name|ci
operator|=
name|lp
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
operator||
name|rp
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
expr_stmt|;
break|break;
case|case
name|OPBITXOR
case|:
name|p
operator|->
name|Const
operator|.
name|ci
operator|=
name|lp
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
operator|^
name|rp
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
expr_stmt|;
break|break;
case|case
name|OPLSHIFT
case|:
name|p
operator|->
name|Const
operator|.
name|ci
operator|=
name|lp
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
operator|<<
name|rp
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
expr_stmt|;
break|break;
case|case
name|OPRSHIFT
case|:
name|p
operator|->
name|Const
operator|.
name|ci
operator|=
name|lp
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
operator|>>
name|rp
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
expr_stmt|;
break|break;
case|case
name|OPCONCAT
case|:
name|ll
operator|=
name|lp
operator|->
name|constblock
operator|.
name|vleng
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
expr_stmt|;
name|lr
operator|=
name|rp
operator|->
name|constblock
operator|.
name|vleng
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
expr_stmt|;
name|bl
operator|=
name|lp
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ccp1
operator|.
name|blanks
expr_stmt|;
name|p
operator|->
name|Const
operator|.
name|ccp
operator|=
name|q
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
name|ll
operator|+
name|lr
operator|+
name|bl
argument_list|)
expr_stmt|;
name|p
operator|->
name|Const
operator|.
name|ccp1
operator|.
name|blanks
operator|=
name|rp
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ccp1
operator|.
name|blanks
expr_stmt|;
name|p
operator|->
name|vleng
operator|=
name|ICON
argument_list|(
name|ll
operator|+
name|lr
operator|+
name|bl
argument_list|)
expr_stmt|;
name|s
operator|=
name|lp
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ccp
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ll
condition|;
operator|++
name|i
control|)
operator|*
name|q
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bl
condition|;
name|i
operator|++
control|)
operator|*
name|q
operator|++
operator|=
literal|' '
expr_stmt|;
name|s
operator|=
name|rp
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ccp
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lr
condition|;
operator|++
name|i
control|)
operator|*
name|q
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
break|break;
case|case
name|OPPOWER
case|:
if|if
condition|(
operator|!
name|ISINT
argument_list|(
name|rtype
argument_list|)
condition|)
return|return
operator|(
name|e
operator|)
return|;
name|conspower
argument_list|(
name|p
argument_list|,
operator|(
name|Constp
operator|)
name|lp
argument_list|,
name|rp
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|ltype
operator|==
name|TYCHAR
condition|)
block|{
name|lcon
operator|.
name|Const
operator|.
name|ci
operator|=
name|cmpstr
argument_list|(
name|lp
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ccp
argument_list|,
name|rp
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ccp
argument_list|,
name|lp
operator|->
name|constblock
operator|.
name|vleng
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
argument_list|,
name|rp
operator|->
name|constblock
operator|.
name|vleng
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
argument_list|)
expr_stmt|;
name|rcon
operator|.
name|Const
operator|.
name|ci
operator|=
literal|0
expr_stmt|;
name|mtype
operator|=
name|tyint
expr_stmt|;
block|}
else|else
block|{
name|mtype
operator|=
name|maxtype
argument_list|(
name|ltype
argument_list|,
name|rtype
argument_list|)
expr_stmt|;
name|consconv
argument_list|(
name|mtype
argument_list|,
operator|&
name|lcon
argument_list|,
operator|&
name|lp
operator|->
name|constblock
argument_list|)
expr_stmt|;
name|consconv
argument_list|(
name|mtype
argument_list|,
operator|&
name|rcon
argument_list|,
operator|&
name|rp
operator|->
name|constblock
argument_list|)
expr_stmt|;
block|}
name|consbinop
argument_list|(
name|opcode
argument_list|,
name|mtype
argument_list|,
name|p
argument_list|,
operator|&
name|lcon
argument_list|,
operator|&
name|rcon
argument_list|)
expr_stmt|;
break|break;
block|}
name|frexpr
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|expptr
operator|)
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/* assign constant l = r , doing coercion */
end_comment

begin_macro
name|consconv
argument_list|(
argument|lt
argument_list|,
argument|lc
argument_list|,
argument|rc
argument_list|)
end_macro

begin_decl_stmt
name|int
name|lt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|Constp
name|lc
decl_stmt|,
name|rc
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|rt
init|=
name|rc
operator|->
name|vtype
decl_stmt|;
specifier|register
name|union
name|Constant
modifier|*
name|lv
init|=
operator|&
name|lc
operator|->
name|Const
decl_stmt|,
modifier|*
name|rv
init|=
operator|&
name|rc
operator|->
name|Const
decl_stmt|;
name|lc
operator|->
name|vtype
operator|=
name|lt
expr_stmt|;
if|if
condition|(
name|ONEOF
argument_list|(
name|lt
argument_list|,
name|MSKREAL
operator||
name|MSKCOMPLEX
argument_list|)
operator|&&
name|ONEOF
argument_list|(
name|rt
argument_list|,
name|MSKREAL
operator||
name|MSKCOMPLEX
argument_list|)
condition|)
block|{
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|lv
argument_list|,
operator|(
name|char
operator|*
operator|)
name|rv
argument_list|,
sizeof|sizeof
argument_list|(
expr|union
name|Constant
argument_list|)
argument_list|)
expr_stmt|;
name|lc
operator|->
name|vstg
operator|=
name|rc
operator|->
name|vstg
expr_stmt|;
if|if
condition|(
name|ISCOMPLEX
argument_list|(
name|lt
argument_list|)
operator|&&
name|ISREAL
argument_list|(
name|rt
argument_list|)
condition|)
block|{
if|if
condition|(
name|rc
operator|->
name|vstg
condition|)
name|lv
operator|->
name|cds
index|[
literal|1
index|]
operator|=
name|cds
argument_list|(
literal|"0"
argument_list|,
name|CNULL
argument_list|)
expr_stmt|;
else|else
name|lv
operator|->
name|cd
index|[
literal|1
index|]
operator|=
literal|0.
expr_stmt|;
block|}
return|return;
block|}
name|lc
operator|->
name|vstg
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|lt
condition|)
block|{
comment|/* Casting to character means just copying the first sizeof (character)    bytes into a new 1 character string.  This is weird. */
case|case
name|TYCHAR
case|:
operator|*
operator|(
name|lv
operator|->
name|ccp
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
literal|1
argument_list|)
operator|)
operator|=
name|rv
operator|->
name|ci
expr_stmt|;
name|lv
operator|->
name|ccp1
operator|.
name|blanks
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|TYINT1
case|:
case|case
name|TYSHORT
case|:
case|case
name|TYLONG
case|:
ifdef|#
directive|ifdef
name|TYQUAD
case|case
name|TYQUAD
case|:
endif|#
directive|endif
if|if
condition|(
name|rt
operator|==
name|TYCHAR
condition|)
name|lv
operator|->
name|ci
operator|=
name|rv
operator|->
name|ccp
index|[
literal|0
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|ISINT
argument_list|(
name|rt
argument_list|)
condition|)
name|lv
operator|->
name|ci
operator|=
name|rv
operator|->
name|ci
expr_stmt|;
else|else
name|lv
operator|->
name|ci
operator|=
name|rc
operator|->
name|vstg
condition|?
name|atof
argument_list|(
name|rv
operator|->
name|cds
index|[
literal|0
index|]
argument_list|)
else|:
name|rv
operator|->
name|cd
index|[
literal|0
index|]
expr_stmt|;
break|break;
case|case
name|TYCOMPLEX
case|:
case|case
name|TYDCOMPLEX
case|:
name|lv
operator|->
name|cd
index|[
literal|1
index|]
operator|=
literal|0.
expr_stmt|;
name|lv
operator|->
name|cd
index|[
literal|0
index|]
operator|=
name|rv
operator|->
name|ci
expr_stmt|;
break|break;
case|case
name|TYREAL
case|:
case|case
name|TYDREAL
case|:
name|lv
operator|->
name|cd
index|[
literal|0
index|]
operator|=
name|rv
operator|->
name|ci
expr_stmt|;
break|break;
case|case
name|TYLOGICAL
case|:
case|case
name|TYLOGICAL1
case|:
case|case
name|TYLOGICAL2
case|:
name|lv
operator|->
name|ci
operator|=
name|rv
operator|->
name|ci
expr_stmt|;
break|break;
block|}
block|}
end_block

begin_comment
comment|/* Negate constant value -- changes the input node's value */
end_comment

begin_expr_stmt
name|consnegop
argument_list|(
name|p
argument_list|)
specifier|register
name|Constp
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|vstg
condition|)
block|{
if|if
condition|(
name|ISCOMPLEX
argument_list|(
name|p
operator|->
name|vtype
argument_list|)
condition|)
block|{
name|s
operator|=
name|p
operator|->
name|Const
operator|.
name|cds
index|[
literal|1
index|]
expr_stmt|;
name|p
operator|->
name|Const
operator|.
name|cds
index|[
literal|1
index|]
operator|=
operator|*
name|s
operator|==
literal|'-'
condition|?
name|s
operator|+
literal|1
else|:
operator|*
name|s
operator|==
literal|'0'
condition|?
name|s
else|:
name|s
operator|-
literal|1
expr_stmt|;
block|}
name|s
operator|=
name|p
operator|->
name|Const
operator|.
name|cds
index|[
literal|0
index|]
expr_stmt|;
name|p
operator|->
name|Const
operator|.
name|cds
index|[
literal|0
index|]
operator|=
operator|*
name|s
operator|==
literal|'-'
condition|?
name|s
operator|+
literal|1
else|:
operator|*
name|s
operator|==
literal|'0'
condition|?
name|s
else|:
name|s
operator|-
literal|1
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|p
operator|->
name|vtype
condition|)
block|{
case|case
name|TYINT1
case|:
case|case
name|TYSHORT
case|:
case|case
name|TYLONG
case|:
ifdef|#
directive|ifdef
name|TYQUAD
case|case
name|TYQUAD
case|:
endif|#
directive|endif
name|p
operator|->
name|Const
operator|.
name|ci
operator|=
operator|-
name|p
operator|->
name|Const
operator|.
name|ci
expr_stmt|;
break|break;
case|case
name|TYCOMPLEX
case|:
case|case
name|TYDCOMPLEX
case|:
name|p
operator|->
name|Const
operator|.
name|cd
index|[
literal|1
index|]
operator|=
operator|-
name|p
operator|->
name|Const
operator|.
name|cd
index|[
literal|1
index|]
expr_stmt|;
comment|/* fall through and do the real parts */
case|case
name|TYREAL
case|:
case|case
name|TYDREAL
case|:
name|p
operator|->
name|Const
operator|.
name|cd
index|[
literal|0
index|]
operator|=
operator|-
name|p
operator|->
name|Const
operator|.
name|cd
index|[
literal|0
index|]
expr_stmt|;
break|break;
default|default:
name|badtype
argument_list|(
literal|"consnegop"
argument_list|,
name|p
operator|->
name|vtype
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* conspower -- Expand out an exponentiation */
end_comment

begin_function
name|LOCAL
name|void
name|conspower
parameter_list|(
name|p
parameter_list|,
name|ap
parameter_list|,
name|n
parameter_list|)
name|Constp
name|p
decl_stmt|,
name|ap
decl_stmt|;
name|ftnint
name|n
decl_stmt|;
block|{
specifier|register
name|union
name|Constant
modifier|*
name|powp
init|=
operator|&
name|p
operator|->
name|Const
decl_stmt|;
specifier|register
name|int
name|type
decl_stmt|;
name|struct
name|Constblock
name|x
decl_stmt|,
name|x0
decl_stmt|;
if|if
condition|(
name|n
operator|==
literal|1
condition|)
block|{
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|powp
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ap
operator|->
name|Const
argument_list|,
sizeof|sizeof
argument_list|(
name|ap
operator|->
name|Const
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|type
operator|=
name|ap
operator|->
name|vtype
condition|)
comment|/* pow = 1 */
block|{
case|case
name|TYINT1
case|:
case|case
name|TYSHORT
case|:
case|case
name|TYLONG
case|:
ifdef|#
directive|ifdef
name|TYQUAD
case|case
name|TYQUAD
case|:
endif|#
directive|endif
name|powp
operator|->
name|ci
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|TYCOMPLEX
case|:
case|case
name|TYDCOMPLEX
case|:
name|powp
operator|->
name|cd
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
case|case
name|TYREAL
case|:
case|case
name|TYDREAL
case|:
name|powp
operator|->
name|cd
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|badtype
argument_list|(
literal|"conspower"
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|==
literal|0
condition|)
return|return;
switch|switch
condition|(
name|type
condition|)
comment|/* x0 = ap */
block|{
case|case
name|TYINT1
case|:
case|case
name|TYSHORT
case|:
case|case
name|TYLONG
case|:
ifdef|#
directive|ifdef
name|TYQUAD
case|case
name|TYQUAD
case|:
endif|#
directive|endif
name|x0
operator|.
name|Const
operator|.
name|ci
operator|=
name|ap
operator|->
name|Const
operator|.
name|ci
expr_stmt|;
break|break;
case|case
name|TYCOMPLEX
case|:
case|case
name|TYDCOMPLEX
case|:
name|x0
operator|.
name|Const
operator|.
name|cd
index|[
literal|1
index|]
operator|=
name|ap
operator|->
name|vstg
condition|?
name|atof
argument_list|(
name|ap
operator|->
name|Const
operator|.
name|cds
index|[
literal|1
index|]
argument_list|)
else|:
name|ap
operator|->
name|Const
operator|.
name|cd
index|[
literal|1
index|]
expr_stmt|;
case|case
name|TYREAL
case|:
case|case
name|TYDREAL
case|:
name|x0
operator|.
name|Const
operator|.
name|cd
index|[
literal|0
index|]
operator|=
name|ap
operator|->
name|vstg
condition|?
name|atof
argument_list|(
name|ap
operator|->
name|Const
operator|.
name|cds
index|[
literal|0
index|]
argument_list|)
else|:
name|ap
operator|->
name|Const
operator|.
name|cd
index|[
literal|0
index|]
expr_stmt|;
break|break;
block|}
name|x0
operator|.
name|vtype
operator|=
name|type
expr_stmt|;
name|x0
operator|.
name|vstg
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|ISINT
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|err
argument_list|(
literal|"integer ** negative number"
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
operator|!
name|x0
operator|.
name|Const
operator|.
name|cd
index|[
literal|0
index|]
operator|&&
operator|(
operator|!
name|ISCOMPLEX
argument_list|(
name|type
argument_list|)
operator|||
operator|!
name|x0
operator|.
name|Const
operator|.
name|cd
index|[
literal|1
index|]
operator|)
condition|)
block|{
name|err
argument_list|(
literal|"0.0 ** negative number"
argument_list|)
expr_stmt|;
return|return;
block|}
name|n
operator|=
operator|-
name|n
expr_stmt|;
name|consbinop
argument_list|(
name|OPSLASH
argument_list|,
name|type
argument_list|,
operator|&
name|x
argument_list|,
name|p
argument_list|,
operator|&
name|x0
argument_list|)
expr_stmt|;
block|}
else|else
name|consbinop
argument_list|(
name|OPSTAR
argument_list|,
name|type
argument_list|,
operator|&
name|x
argument_list|,
name|p
argument_list|,
operator|&
name|x0
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|n
operator|&
literal|01
condition|)
name|consbinop
argument_list|(
name|OPSTAR
argument_list|,
name|type
argument_list|,
name|p
argument_list|,
name|p
argument_list|,
operator|&
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>>=
literal|1
condition|)
name|consbinop
argument_list|(
name|OPSTAR
argument_list|,
name|type
argument_list|,
operator|&
name|x
argument_list|,
operator|&
name|x
argument_list|,
operator|&
name|x
argument_list|)
expr_stmt|;
else|else
break|break;
block|}
block|}
end_function

begin_comment
comment|/* do constant operation cp = a op b -- assumes that   ap and bp   have data    matching the input   type */
end_comment

begin_function
name|LOCAL
name|void
name|zerodiv
parameter_list|()
block|{
name|Fatal
argument_list|(
literal|"division by zero during constant evaluation; cannot recover"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|LOCAL
name|void
name|consbinop
parameter_list|(
name|opcode
parameter_list|,
name|type
parameter_list|,
name|cpp
parameter_list|,
name|app
parameter_list|,
name|bpp
parameter_list|)
name|int
name|opcode
decl_stmt|,
name|type
decl_stmt|;
name|Constp
name|cpp
decl_stmt|,
name|app
decl_stmt|,
name|bpp
decl_stmt|;
block|{
specifier|register
name|union
name|Constant
modifier|*
name|ap
init|=
operator|&
name|app
operator|->
name|Const
decl_stmt|,
modifier|*
name|bp
init|=
operator|&
name|bpp
operator|->
name|Const
decl_stmt|,
modifier|*
name|cp
init|=
operator|&
name|cpp
operator|->
name|Const
decl_stmt|;
name|int
name|k
decl_stmt|;
name|double
name|ad
index|[
literal|2
index|]
decl_stmt|,
name|bd
index|[
literal|2
index|]
decl_stmt|,
name|temp
decl_stmt|;
name|cpp
operator|->
name|vstg
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ONEOF
argument_list|(
name|type
argument_list|,
name|MSKREAL
operator||
name|MSKCOMPLEX
argument_list|)
condition|)
block|{
name|ad
index|[
literal|0
index|]
operator|=
name|app
operator|->
name|vstg
condition|?
name|atof
argument_list|(
name|ap
operator|->
name|cds
index|[
literal|0
index|]
argument_list|)
else|:
name|ap
operator|->
name|cd
index|[
literal|0
index|]
expr_stmt|;
name|bd
index|[
literal|0
index|]
operator|=
name|bpp
operator|->
name|vstg
condition|?
name|atof
argument_list|(
name|bp
operator|->
name|cds
index|[
literal|0
index|]
argument_list|)
else|:
name|bp
operator|->
name|cd
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|ISCOMPLEX
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|ad
index|[
literal|1
index|]
operator|=
name|app
operator|->
name|vstg
condition|?
name|atof
argument_list|(
name|ap
operator|->
name|cds
index|[
literal|1
index|]
argument_list|)
else|:
name|ap
operator|->
name|cd
index|[
literal|1
index|]
expr_stmt|;
name|bd
index|[
literal|1
index|]
operator|=
name|bpp
operator|->
name|vstg
condition|?
name|atof
argument_list|(
name|bp
operator|->
name|cds
index|[
literal|1
index|]
argument_list|)
else|:
name|bp
operator|->
name|cd
index|[
literal|1
index|]
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|opcode
condition|)
block|{
case|case
name|OPPLUS
case|:
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|TYINT1
case|:
case|case
name|TYSHORT
case|:
case|case
name|TYLONG
case|:
ifdef|#
directive|ifdef
name|TYQUAD
case|case
name|TYQUAD
case|:
endif|#
directive|endif
name|cp
operator|->
name|ci
operator|=
name|ap
operator|->
name|ci
operator|+
name|bp
operator|->
name|ci
expr_stmt|;
break|break;
case|case
name|TYCOMPLEX
case|:
case|case
name|TYDCOMPLEX
case|:
name|cp
operator|->
name|cd
index|[
literal|1
index|]
operator|=
name|ad
index|[
literal|1
index|]
operator|+
name|bd
index|[
literal|1
index|]
expr_stmt|;
case|case
name|TYREAL
case|:
case|case
name|TYDREAL
case|:
name|cp
operator|->
name|cd
index|[
literal|0
index|]
operator|=
name|ad
index|[
literal|0
index|]
operator|+
name|bd
index|[
literal|0
index|]
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|OPMINUS
case|:
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|TYINT1
case|:
case|case
name|TYSHORT
case|:
case|case
name|TYLONG
case|:
ifdef|#
directive|ifdef
name|TYQUAD
case|case
name|TYQUAD
case|:
endif|#
directive|endif
name|cp
operator|->
name|ci
operator|=
name|ap
operator|->
name|ci
operator|-
name|bp
operator|->
name|ci
expr_stmt|;
break|break;
case|case
name|TYCOMPLEX
case|:
case|case
name|TYDCOMPLEX
case|:
name|cp
operator|->
name|cd
index|[
literal|1
index|]
operator|=
name|ad
index|[
literal|1
index|]
operator|-
name|bd
index|[
literal|1
index|]
expr_stmt|;
case|case
name|TYREAL
case|:
case|case
name|TYDREAL
case|:
name|cp
operator|->
name|cd
index|[
literal|0
index|]
operator|=
name|ad
index|[
literal|0
index|]
operator|-
name|bd
index|[
literal|0
index|]
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|OPSTAR
case|:
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|TYINT1
case|:
case|case
name|TYSHORT
case|:
case|case
name|TYLONG
case|:
ifdef|#
directive|ifdef
name|TYQUAD
case|case
name|TYQUAD
case|:
endif|#
directive|endif
name|cp
operator|->
name|ci
operator|=
name|ap
operator|->
name|ci
operator|*
name|bp
operator|->
name|ci
expr_stmt|;
break|break;
case|case
name|TYREAL
case|:
case|case
name|TYDREAL
case|:
name|cp
operator|->
name|cd
index|[
literal|0
index|]
operator|=
name|ad
index|[
literal|0
index|]
operator|*
name|bd
index|[
literal|0
index|]
expr_stmt|;
break|break;
case|case
name|TYCOMPLEX
case|:
case|case
name|TYDCOMPLEX
case|:
name|temp
operator|=
name|ad
index|[
literal|0
index|]
operator|*
name|bd
index|[
literal|0
index|]
operator|-
name|ad
index|[
literal|1
index|]
operator|*
name|bd
index|[
literal|1
index|]
expr_stmt|;
name|cp
operator|->
name|cd
index|[
literal|1
index|]
operator|=
name|ad
index|[
literal|0
index|]
operator|*
name|bd
index|[
literal|1
index|]
operator|+
name|ad
index|[
literal|1
index|]
operator|*
name|bd
index|[
literal|0
index|]
expr_stmt|;
name|cp
operator|->
name|cd
index|[
literal|0
index|]
operator|=
name|temp
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|OPSLASH
case|:
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|TYINT1
case|:
case|case
name|TYSHORT
case|:
case|case
name|TYLONG
case|:
ifdef|#
directive|ifdef
name|TYQUAD
case|case
name|TYQUAD
case|:
endif|#
directive|endif
if|if
condition|(
operator|!
name|bp
operator|->
name|ci
condition|)
name|zerodiv
argument_list|()
expr_stmt|;
name|cp
operator|->
name|ci
operator|=
name|ap
operator|->
name|ci
operator|/
name|bp
operator|->
name|ci
expr_stmt|;
break|break;
case|case
name|TYREAL
case|:
case|case
name|TYDREAL
case|:
if|if
condition|(
operator|!
name|bd
index|[
literal|0
index|]
condition|)
name|zerodiv
argument_list|()
expr_stmt|;
name|cp
operator|->
name|cd
index|[
literal|0
index|]
operator|=
name|ad
index|[
literal|0
index|]
operator|/
name|bd
index|[
literal|0
index|]
expr_stmt|;
break|break;
case|case
name|TYCOMPLEX
case|:
case|case
name|TYDCOMPLEX
case|:
if|if
condition|(
operator|!
name|bd
index|[
literal|0
index|]
operator|&&
operator|!
name|bd
index|[
literal|1
index|]
condition|)
name|zerodiv
argument_list|()
expr_stmt|;
name|zdiv
argument_list|(
operator|(
name|dcomplex
operator|*
operator|)
name|cp
argument_list|,
operator|(
name|dcomplex
operator|*
operator|)
name|ad
argument_list|,
operator|(
name|dcomplex
operator|*
operator|)
name|bd
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|OPMOD
case|:
if|if
condition|(
name|ISINT
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|cp
operator|->
name|ci
operator|=
name|ap
operator|->
name|ci
operator|%
name|bp
operator|->
name|ci
expr_stmt|;
break|break;
block|}
else|else
name|Fatal
argument_list|(
literal|"inline mod of noninteger"
argument_list|)
expr_stmt|;
case|case
name|OPMIN2
case|:
case|case
name|OPDMIN
case|:
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|TYINT1
case|:
case|case
name|TYSHORT
case|:
case|case
name|TYLONG
case|:
ifdef|#
directive|ifdef
name|TYQUAD
case|case
name|TYQUAD
case|:
endif|#
directive|endif
name|cp
operator|->
name|ci
operator|=
name|ap
operator|->
name|ci
operator|<=
name|bp
operator|->
name|ci
condition|?
name|ap
operator|->
name|ci
else|:
name|bp
operator|->
name|ci
expr_stmt|;
break|break;
case|case
name|TYREAL
case|:
case|case
name|TYDREAL
case|:
name|cp
operator|->
name|cd
index|[
literal|0
index|]
operator|=
name|ad
index|[
literal|0
index|]
operator|<=
name|bd
index|[
literal|0
index|]
condition|?
name|ad
index|[
literal|0
index|]
else|:
name|bd
index|[
literal|0
index|]
expr_stmt|;
break|break;
default|default:
name|Fatal
argument_list|(
literal|"inline min of exected type"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|OPMAX2
case|:
case|case
name|OPDMAX
case|:
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|TYINT1
case|:
case|case
name|TYSHORT
case|:
case|case
name|TYLONG
case|:
ifdef|#
directive|ifdef
name|TYQUAD
case|case
name|TYQUAD
case|:
endif|#
directive|endif
name|cp
operator|->
name|ci
operator|=
name|ap
operator|->
name|ci
operator|>=
name|bp
operator|->
name|ci
condition|?
name|ap
operator|->
name|ci
else|:
name|bp
operator|->
name|ci
expr_stmt|;
break|break;
case|case
name|TYREAL
case|:
case|case
name|TYDREAL
case|:
name|cp
operator|->
name|cd
index|[
literal|0
index|]
operator|=
name|ad
index|[
literal|0
index|]
operator|>=
name|bd
index|[
literal|0
index|]
condition|?
name|ad
index|[
literal|0
index|]
else|:
name|bd
index|[
literal|0
index|]
expr_stmt|;
break|break;
default|default:
name|Fatal
argument_list|(
literal|"inline max of exected type"
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
comment|/* relational ops */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|TYINT1
case|:
case|case
name|TYSHORT
case|:
case|case
name|TYLONG
case|:
ifdef|#
directive|ifdef
name|TYQUAD
case|case
name|TYQUAD
case|:
endif|#
directive|endif
if|if
condition|(
name|ap
operator|->
name|ci
operator|<
name|bp
operator|->
name|ci
condition|)
name|k
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|ap
operator|->
name|ci
operator|==
name|bp
operator|->
name|ci
condition|)
name|k
operator|=
literal|0
expr_stmt|;
else|else
name|k
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|TYREAL
case|:
case|case
name|TYDREAL
case|:
if|if
condition|(
name|ad
index|[
literal|0
index|]
operator|<
name|bd
index|[
literal|0
index|]
condition|)
name|k
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|ad
index|[
literal|0
index|]
operator|==
name|bd
index|[
literal|0
index|]
condition|)
name|k
operator|=
literal|0
expr_stmt|;
else|else
name|k
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|TYCOMPLEX
case|:
case|case
name|TYDCOMPLEX
case|:
if|if
condition|(
name|ad
index|[
literal|0
index|]
operator|==
name|bd
index|[
literal|0
index|]
operator|&&
name|ad
index|[
literal|1
index|]
operator|==
name|bd
index|[
literal|1
index|]
condition|)
name|k
operator|=
literal|0
expr_stmt|;
else|else
name|k
operator|=
literal|1
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|opcode
condition|)
block|{
case|case
name|OPEQ
case|:
name|cp
operator|->
name|ci
operator|=
operator|(
name|k
operator|==
literal|0
operator|)
expr_stmt|;
break|break;
case|case
name|OPNE
case|:
name|cp
operator|->
name|ci
operator|=
operator|(
name|k
operator|!=
literal|0
operator|)
expr_stmt|;
break|break;
case|case
name|OPGT
case|:
name|cp
operator|->
name|ci
operator|=
operator|(
name|k
operator|==
literal|1
operator|)
expr_stmt|;
break|break;
case|case
name|OPLT
case|:
name|cp
operator|->
name|ci
operator|=
operator|(
name|k
operator|==
operator|-
literal|1
operator|)
expr_stmt|;
break|break;
case|case
name|OPGE
case|:
name|cp
operator|->
name|ci
operator|=
operator|(
name|k
operator|>=
literal|0
operator|)
expr_stmt|;
break|break;
case|case
name|OPLE
case|:
name|cp
operator|->
name|ci
operator|=
operator|(
name|k
operator|<=
literal|0
operator|)
expr_stmt|;
break|break;
block|}
break|break;
block|}
block|}
end_function

begin_comment
comment|/* conssgn - returns the sign of a Fortran constant */
end_comment

begin_expr_stmt
name|conssgn
argument_list|(
name|p
argument_list|)
specifier|register
name|expptr
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
operator|!
name|ISCONST
argument_list|(
name|p
argument_list|)
condition|)
name|Fatal
argument_list|(
literal|"sgn(nonconstant)"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|p
operator|->
name|headblock
operator|.
name|vtype
condition|)
block|{
case|case
name|TYINT1
case|:
case|case
name|TYSHORT
case|:
case|case
name|TYLONG
case|:
ifdef|#
directive|ifdef
name|TYQUAD
case|case
name|TYQUAD
case|:
endif|#
directive|endif
if|if
condition|(
name|p
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
operator|>
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|p
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|TYREAL
case|:
case|case
name|TYDREAL
case|:
if|if
condition|(
name|p
operator|->
name|constblock
operator|.
name|vstg
condition|)
block|{
name|s
operator|=
name|p
operator|->
name|constblock
operator|.
name|Const
operator|.
name|cds
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'-'
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'0'
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|p
operator|->
name|constblock
operator|.
name|Const
operator|.
name|cd
index|[
literal|0
index|]
operator|>
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|p
operator|->
name|constblock
operator|.
name|Const
operator|.
name|cd
index|[
literal|0
index|]
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* The sign of a complex number is 0 iff the number is 0 + 0i, else it's 1 */
case|case
name|TYCOMPLEX
case|:
case|case
name|TYDCOMPLEX
case|:
if|if
condition|(
name|p
operator|->
name|constblock
operator|.
name|vstg
condition|)
return|return
operator|*
name|p
operator|->
name|constblock
operator|.
name|Const
operator|.
name|cds
index|[
literal|0
index|]
operator|!=
literal|'0'
operator|&&
operator|*
name|p
operator|->
name|constblock
operator|.
name|Const
operator|.
name|cds
index|[
literal|1
index|]
operator|!=
literal|'0'
return|;
return|return
operator|(
name|p
operator|->
name|constblock
operator|.
name|Const
operator|.
name|cd
index|[
literal|0
index|]
operator|!=
literal|0
operator|||
name|p
operator|->
name|constblock
operator|.
name|Const
operator|.
name|cd
index|[
literal|1
index|]
operator|!=
literal|0
operator|)
return|;
default|default:
name|badtype
argument_list|(
literal|"conssgn"
argument_list|,
name|p
operator|->
name|constblock
operator|.
name|vtype
argument_list|)
expr_stmt|;
block|}
comment|/* NOT REACHED */
return|return
literal|0
return|;
block|}
end_block

begin_decl_stmt
name|char
modifier|*
name|powint
index|[ ]
init|=
block|{
literal|"pow_ii"
block|,
ifdef|#
directive|ifdef
name|TYQUAD
literal|"pow_qi"
block|,
endif|#
directive|endif
literal|"pow_ri"
block|,
literal|"pow_di"
block|,
literal|"pow_ci"
block|,
literal|"pow_zi"
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|LOCAL
name|expptr
name|mkpower
parameter_list|(
name|p
parameter_list|)
specifier|register
name|expptr
name|p
decl_stmt|;
block|{
specifier|register
name|expptr
name|q
decl_stmt|,
name|lp
decl_stmt|,
name|rp
decl_stmt|;
name|int
name|ltype
decl_stmt|,
name|rtype
decl_stmt|,
name|mtype
decl_stmt|,
name|tyi
decl_stmt|;
name|lp
operator|=
name|p
operator|->
name|exprblock
operator|.
name|leftp
expr_stmt|;
name|rp
operator|=
name|p
operator|->
name|exprblock
operator|.
name|rightp
expr_stmt|;
name|ltype
operator|=
name|lp
operator|->
name|headblock
operator|.
name|vtype
expr_stmt|;
name|rtype
operator|=
name|rp
operator|->
name|headblock
operator|.
name|vtype
expr_stmt|;
if|if
condition|(
name|lp
operator|->
name|tag
operator|==
name|TADDR
condition|)
name|lp
operator|->
name|addrblock
operator|.
name|parenused
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rp
operator|->
name|tag
operator|==
name|TADDR
condition|)
name|rp
operator|->
name|addrblock
operator|.
name|parenused
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ISICON
argument_list|(
name|rp
argument_list|)
condition|)
block|{
if|if
condition|(
name|rp
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
operator|==
literal|0
condition|)
block|{
name|frexpr
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISINT
argument_list|(
name|ltype
argument_list|)
condition|)
return|return
operator|(
name|ICON
argument_list|(
literal|1
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
name|ISREAL
argument_list|(
name|ltype
argument_list|)
condition|)
return|return
name|mkconv
argument_list|(
name|ltype
argument_list|,
name|ICON
argument_list|(
literal|1
argument_list|)
argument_list|)
return|;
else|else
return|return
operator|(
operator|(
name|expptr
operator|)
name|putconst
argument_list|(
operator|(
name|Constp
operator|)
name|mkconv
argument_list|(
name|ltype
argument_list|,
name|ICON
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|rp
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|ISINT
argument_list|(
name|ltype
argument_list|)
condition|)
block|{
name|frexpr
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|err
argument_list|(
literal|"integer**negative"
argument_list|)
expr_stmt|;
return|return
operator|(
name|errnode
argument_list|()
operator|)
return|;
block|}
name|rp
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
operator|=
operator|-
name|rp
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
expr_stmt|;
name|p
operator|->
name|exprblock
operator|.
name|leftp
operator|=
name|lp
operator|=
name|fixexpr
argument_list|(
operator|(
name|Exprp
operator|)
name|mkexpr
argument_list|(
name|OPSLASH
argument_list|,
name|ICON
argument_list|(
literal|1
argument_list|)
argument_list|,
name|lp
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rp
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
operator|==
literal|1
condition|)
block|{
name|frexpr
argument_list|(
name|rp
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|charptr
operator|)
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|lp
operator|)
return|;
block|}
if|if
condition|(
name|ONEOF
argument_list|(
name|ltype
argument_list|,
name|MSKINT
operator||
name|MSKREAL
argument_list|)
condition|)
block|{
name|p
operator|->
name|exprblock
operator|.
name|vtype
operator|=
name|ltype
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
block|}
if|if
condition|(
name|ISINT
argument_list|(
name|rtype
argument_list|)
condition|)
block|{
if|if
condition|(
name|ltype
operator|==
name|TYSHORT
operator|&&
name|rtype
operator|==
name|TYSHORT
operator|&&
operator|(
operator|!
name|ISCONST
argument_list|(
name|lp
argument_list|)
operator|||
name|tyint
operator|==
name|TYSHORT
operator|)
condition|)
name|q
operator|=
name|call2
argument_list|(
name|TYSHORT
argument_list|,
literal|"pow_hh"
argument_list|,
name|lp
argument_list|,
name|rp
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|ONEOF
argument_list|(
name|ltype
argument_list|,
name|M
argument_list|(
name|TYINT1
argument_list|)
operator||
name|M
argument_list|(
name|TYSHORT
argument_list|)
argument_list|)
condition|)
block|{
name|ltype
operator|=
name|TYLONG
expr_stmt|;
name|lp
operator|=
name|mkconv
argument_list|(
name|TYLONG
argument_list|,
name|lp
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|TYQUAD
if|if
condition|(
name|ltype
operator|==
name|TYQUAD
condition|)
name|rp
operator|=
name|mkconv
argument_list|(
name|TYQUAD
argument_list|,
name|rp
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|rp
operator|=
name|mkconv
argument_list|(
name|TYLONG
argument_list|,
name|rp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISCONST
argument_list|(
name|rp
argument_list|)
condition|)
block|{
name|tyi
operator|=
name|tyint
expr_stmt|;
name|tyint
operator|=
name|TYLONG
expr_stmt|;
name|rp
operator|=
operator|(
name|expptr
operator|)
name|putconst
argument_list|(
operator|(
name|Constp
operator|)
name|rp
argument_list|)
expr_stmt|;
name|tyint
operator|=
name|tyi
expr_stmt|;
block|}
name|q
operator|=
name|call2
argument_list|(
name|ltype
argument_list|,
name|powint
index|[
name|ltype
operator|-
name|TYLONG
index|]
argument_list|,
name|lp
argument_list|,
name|rp
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ISREAL
argument_list|(
operator|(
name|mtype
operator|=
name|maxtype
argument_list|(
name|ltype
argument_list|,
name|rtype
argument_list|)
operator|)
argument_list|)
condition|)
block|{
specifier|extern
name|int
name|callk_kludge
decl_stmt|;
name|callk_kludge
operator|=
name|TYDREAL
expr_stmt|;
name|q
operator|=
name|call2
argument_list|(
name|mtype
argument_list|,
literal|"pow_dd"
argument_list|,
name|mkconv
argument_list|(
name|TYDREAL
argument_list|,
name|lp
argument_list|)
argument_list|,
name|mkconv
argument_list|(
name|TYDREAL
argument_list|,
name|rp
argument_list|)
argument_list|)
expr_stmt|;
name|callk_kludge
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|q
operator|=
name|call2
argument_list|(
name|TYDCOMPLEX
argument_list|,
literal|"pow_zz"
argument_list|,
name|mkconv
argument_list|(
name|TYDCOMPLEX
argument_list|,
name|lp
argument_list|)
argument_list|,
name|mkconv
argument_list|(
name|TYDCOMPLEX
argument_list|,
name|rp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtype
operator|==
name|TYCOMPLEX
condition|)
name|q
operator|=
name|mkconv
argument_list|(
name|TYCOMPLEX
argument_list|,
name|q
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
operator|(
name|charptr
operator|)
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|q
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Complex Division.  Same code as in Runtime Library */
end_comment

begin_function
name|LOCAL
name|void
name|zdiv
parameter_list|(
name|c
parameter_list|,
name|a
parameter_list|,
name|b
parameter_list|)
specifier|register
name|dcomplex
modifier|*
name|a
decl_stmt|,
decl|*
name|b
decl_stmt|,
modifier|*
name|c
decl_stmt|;
end_function

begin_block
block|{
name|double
name|ratio
decl_stmt|,
name|den
decl_stmt|;
name|double
name|abr
decl_stmt|,
name|abi
decl_stmt|;
if|if
condition|(
operator|(
name|abr
operator|=
name|b
operator|->
name|dreal
operator|)
operator|<
literal|0.
condition|)
name|abr
operator|=
operator|-
name|abr
expr_stmt|;
if|if
condition|(
operator|(
name|abi
operator|=
name|b
operator|->
name|dimag
operator|)
operator|<
literal|0.
condition|)
name|abi
operator|=
operator|-
name|abi
expr_stmt|;
if|if
condition|(
name|abr
operator|<=
name|abi
condition|)
block|{
if|if
condition|(
name|abi
operator|==
literal|0
condition|)
name|Fatal
argument_list|(
literal|"complex division by zero"
argument_list|)
expr_stmt|;
name|ratio
operator|=
name|b
operator|->
name|dreal
operator|/
name|b
operator|->
name|dimag
expr_stmt|;
name|den
operator|=
name|b
operator|->
name|dimag
operator|*
operator|(
literal|1
operator|+
name|ratio
operator|*
name|ratio
operator|)
expr_stmt|;
name|c
operator|->
name|dreal
operator|=
operator|(
name|a
operator|->
name|dreal
operator|*
name|ratio
operator|+
name|a
operator|->
name|dimag
operator|)
operator|/
name|den
expr_stmt|;
name|c
operator|->
name|dimag
operator|=
operator|(
name|a
operator|->
name|dimag
operator|*
name|ratio
operator|-
name|a
operator|->
name|dreal
operator|)
operator|/
name|den
expr_stmt|;
block|}
else|else
block|{
name|ratio
operator|=
name|b
operator|->
name|dimag
operator|/
name|b
operator|->
name|dreal
expr_stmt|;
name|den
operator|=
name|b
operator|->
name|dreal
operator|*
operator|(
literal|1
operator|+
name|ratio
operator|*
name|ratio
operator|)
expr_stmt|;
name|c
operator|->
name|dreal
operator|=
operator|(
name|a
operator|->
name|dreal
operator|+
name|a
operator|->
name|dimag
operator|*
name|ratio
operator|)
operator|/
name|den
expr_stmt|;
name|c
operator|->
name|dimag
operator|=
operator|(
name|a
operator|->
name|dimag
operator|-
name|a
operator|->
name|dreal
operator|*
name|ratio
operator|)
operator|/
name|den
expr_stmt|;
block|}
block|}
end_block

end_unit

