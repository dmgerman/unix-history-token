begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**************************************************************** Copyright 1990, 1992, 1993 by AT&T Bell Laboratories and Bellcore.  Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that the copyright notice and this permission notice and warranty disclaimer appear in supporting documentation, and that the names of AT&T Bell Laboratories or Bellcore or any of their entities not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  AT&T and Bellcore disclaim all warranties with regard to this software, including all implied warranties of merchantability and fitness.  In no event shall AT&T or Bellcore be liable for any special, indirect or consequential damages or any damages whatsoever resulting from loss of use, data or profits, whether in an action of contract, negligence or other tortious action, arising out of or in connection with the use or performance of this software. ****************************************************************/
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"pccdefs.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_decl_stmt
name|int
name|regnum
index|[]
init|=
block|{
literal|11
block|,
literal|10
block|,
literal|9
block|,
literal|8
block|,
literal|7
block|,
literal|6
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Put out a constant integer */
end_comment

begin_macro
name|prconi
argument_list|(
argument|fp
argument_list|,
argument|n
argument_list|)
end_macro

begin_decl_stmt
name|FILEP
name|fp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ftnint
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t%ld\n"
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Put out a constant address */
end_comment

begin_macro
name|prcona
argument_list|(
argument|fp
argument_list|,
argument|a
argument_list|)
end_macro

begin_decl_stmt
name|FILEP
name|fp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ftnint
name|a
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\tL%ld\n"
argument_list|,
name|a
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|prconr
argument_list|(
argument|fp
argument_list|,
argument|x
argument_list|,
argument|k
argument_list|)
end_macro

begin_decl_stmt
name|FILEP
name|fp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|k
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Constp
name|x
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|x0
decl_stmt|,
modifier|*
name|x1
decl_stmt|;
name|char
name|cdsbuf0
index|[
literal|64
index|]
decl_stmt|,
name|cdsbuf1
index|[
literal|64
index|]
decl_stmt|;
if|if
condition|(
name|k
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|x
operator|->
name|vstg
condition|)
block|{
name|x0
operator|=
name|x
operator|->
name|Const
operator|.
name|cds
index|[
literal|0
index|]
expr_stmt|;
name|x1
operator|=
name|x
operator|->
name|Const
operator|.
name|cds
index|[
literal|1
index|]
expr_stmt|;
block|}
else|else
block|{
name|x0
operator|=
name|cds
argument_list|(
name|dtos
argument_list|(
name|x
operator|->
name|Const
operator|.
name|cd
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|cdsbuf0
argument_list|)
expr_stmt|;
name|x1
operator|=
name|cds
argument_list|(
name|dtos
argument_list|(
name|x
operator|->
name|Const
operator|.
name|cd
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|cdsbuf1
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t%s %s\n"
argument_list|,
name|x0
argument_list|,
name|x1
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t%s\n"
argument_list|,
name|x
operator|->
name|vstg
condition|?
name|x
operator|->
name|Const
operator|.
name|cds
index|[
literal|0
index|]
else|:
name|cds
argument_list|(
name|dtos
argument_list|(
name|x
operator|->
name|Const
operator|.
name|cd
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|cdsbuf0
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|char
modifier|*
name|memname
parameter_list|(
name|stg
parameter_list|,
name|mem
parameter_list|)
name|int
name|stg
decl_stmt|;
name|long
name|mem
decl_stmt|;
block|{
specifier|static
name|char
name|s
index|[
literal|20
index|]
decl_stmt|;
switch|switch
condition|(
name|stg
condition|)
block|{
case|case
name|STGCOMMON
case|:
case|case
name|STGEXT
case|:
name|sprintf
argument_list|(
name|s
argument_list|,
literal|"_%s"
argument_list|,
name|extsymtab
index|[
name|mem
index|]
operator|.
name|cextname
argument_list|)
expr_stmt|;
break|break;
case|case
name|STGBSS
case|:
case|case
name|STGINIT
case|:
name|sprintf
argument_list|(
name|s
argument_list|,
literal|"v.%ld"
argument_list|,
name|mem
argument_list|)
expr_stmt|;
break|break;
case|case
name|STGCONST
case|:
name|sprintf
argument_list|(
name|s
argument_list|,
literal|"L%ld"
argument_list|,
name|mem
argument_list|)
expr_stmt|;
break|break;
case|case
name|STGEQUIV
case|:
name|sprintf
argument_list|(
name|s
argument_list|,
literal|"q.%ld"
argument_list|,
name|mem
operator|+
name|eqvstart
argument_list|)
expr_stmt|;
break|break;
default|default:
name|badstg
argument_list|(
literal|"memname"
argument_list|,
name|stg
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|s
operator|)
return|;
block|}
end_function

begin_comment
comment|/* make_int_expr -- takes an arbitrary expression, and replaces all    occurrences of arguments with indirection */
end_comment

begin_function
name|expptr
name|make_int_expr
parameter_list|(
name|e
parameter_list|)
name|expptr
name|e
decl_stmt|;
block|{
if|if
condition|(
name|e
operator|!=
name|ENULL
condition|)
switch|switch
condition|(
name|e
operator|->
name|tag
condition|)
block|{
case|case
name|TADDR
case|:
if|if
condition|(
name|e
operator|->
name|addrblock
operator|.
name|vstg
operator|==
name|STGARG
operator|&&
operator|!
name|e
operator|->
name|addrblock
operator|.
name|isarray
condition|)
name|e
operator|=
name|mkexpr
argument_list|(
name|OPWHATSIN
argument_list|,
name|e
argument_list|,
name|ENULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|TEXPR
case|:
name|e
operator|->
name|exprblock
operator|.
name|leftp
operator|=
name|make_int_expr
argument_list|(
name|e
operator|->
name|exprblock
operator|.
name|leftp
argument_list|)
expr_stmt|;
name|e
operator|->
name|exprblock
operator|.
name|rightp
operator|=
name|make_int_expr
argument_list|(
name|e
operator|->
name|exprblock
operator|.
name|rightp
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* switch */
return|return
name|e
return|;
block|}
end_function

begin_comment
comment|/* make_int_expr */
end_comment

begin_comment
comment|/* prune_left_conv -- used in prolog() to strip type cast away from    left-hand side of parameter adjustments.  This is necessary to avoid    error messages from cktype() */
end_comment

begin_function
name|expptr
name|prune_left_conv
parameter_list|(
name|e
parameter_list|)
name|expptr
name|e
decl_stmt|;
block|{
name|struct
name|Exprblock
modifier|*
name|leftp
decl_stmt|;
if|if
condition|(
name|e
operator|&&
name|e
operator|->
name|tag
operator|==
name|TEXPR
operator|&&
name|e
operator|->
name|exprblock
operator|.
name|leftp
operator|&&
name|e
operator|->
name|exprblock
operator|.
name|leftp
operator|->
name|tag
operator|==
name|TEXPR
condition|)
block|{
name|leftp
operator|=
operator|&
operator|(
name|e
operator|->
name|exprblock
operator|.
name|leftp
operator|->
name|exprblock
operator|)
expr_stmt|;
if|if
condition|(
name|leftp
operator|->
name|opcode
operator|==
name|OPCONV
condition|)
block|{
name|e
operator|->
name|exprblock
operator|.
name|leftp
operator|=
name|leftp
operator|->
name|leftp
expr_stmt|;
name|free
argument_list|(
operator|(
name|charptr
operator|)
name|leftp
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|e
return|;
block|}
end_function

begin_comment
comment|/* prune_left_conv */
end_comment

begin_decl_stmt
specifier|static
name|int
name|wrote_comment
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|comment_file
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|write_comment
parameter_list|()
block|{
if|if
condition|(
operator|!
name|wrote_comment
condition|)
block|{
name|wrote_comment
operator|=
literal|1
expr_stmt|;
name|nice_printf
argument_list|(
name|comment_file
argument_list|,
literal|"/* Parameter adjustments */\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
modifier|*
name|count_args
parameter_list|()
block|{
specifier|register
name|int
modifier|*
name|ac
decl_stmt|;
specifier|register
name|chainp
name|cp
decl_stmt|;
specifier|register
name|struct
name|Entrypoint
modifier|*
name|ep
decl_stmt|;
specifier|register
name|Namep
name|q
decl_stmt|;
name|ac
operator|=
operator|(
name|int
operator|*
operator|)
name|ckalloc
argument_list|(
name|nallargs
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|ep
operator|=
name|entries
init|;
name|ep
condition|;
name|ep
operator|=
name|ep
operator|->
name|entnextp
control|)
for|for
control|(
name|cp
operator|=
name|ep
operator|->
name|arglist
init|;
name|cp
condition|;
name|cp
operator|=
name|cp
operator|->
name|nextp
control|)
if|if
condition|(
name|q
operator|=
operator|(
name|Namep
operator|)
name|cp
operator|->
name|datap
condition|)
name|ac
index|[
name|q
operator|->
name|argno
index|]
operator|++
expr_stmt|;
return|return
name|ac
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|nu
decl_stmt|,
modifier|*
name|refs
decl_stmt|,
modifier|*
name|used
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|awalk
parameter_list|()
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|aawalk
parameter_list|(
name|P
parameter_list|)
name|struct
name|Primblock
modifier|*
name|P
decl_stmt|;
block|{
name|chainp
name|p
decl_stmt|;
name|expptr
name|q
decl_stmt|;
for|for
control|(
name|p
operator|=
name|P
operator|->
name|argsp
operator|->
name|listp
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|nextp
control|)
block|{
name|q
operator|=
operator|(
name|expptr
operator|)
name|p
operator|->
name|datap
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|tag
operator|!=
name|TCONST
condition|)
name|awalk
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|P
operator|->
name|namep
operator|->
name|vtype
operator|==
name|TYCHAR
condition|)
block|{
if|if
condition|(
name|q
operator|=
name|P
operator|->
name|fcharp
condition|)
name|awalk
argument_list|(
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|=
name|P
operator|->
name|lcharp
condition|)
name|awalk
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|afwalk
parameter_list|(
name|P
parameter_list|)
name|struct
name|Primblock
modifier|*
name|P
decl_stmt|;
block|{
name|chainp
name|p
decl_stmt|;
name|expptr
name|q
decl_stmt|;
name|Namep
name|np
decl_stmt|;
for|for
control|(
name|p
operator|=
name|P
operator|->
name|argsp
operator|->
name|listp
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|nextp
control|)
block|{
name|q
operator|=
operator|(
name|expptr
operator|)
name|p
operator|->
name|datap
expr_stmt|;
switch|switch
condition|(
name|q
operator|->
name|tag
condition|)
block|{
case|case
name|TPRIM
case|:
name|np
operator|=
name|q
operator|->
name|primblock
operator|.
name|namep
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|vknownarg
condition|)
if|if
condition|(
operator|!
name|refs
index|[
name|np
operator|->
name|argno
index|]
operator|++
condition|)
name|used
index|[
name|nu
operator|++
index|]
operator|=
name|np
operator|->
name|argno
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|primblock
operator|.
name|argsp
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|q
operator|->
name|primblock
operator|.
name|namep
operator|->
name|vclass
operator|==
name|CLPROC
operator|&&
name|q
operator|->
name|primblock
operator|.
name|namep
operator|->
name|vprocclass
operator|!=
name|PTHISPROC
operator|||
name|q
operator|->
name|primblock
operator|.
name|namep
operator|->
name|vdim
operator|!=
name|NULL
condition|)
continue|continue;
block|}
default|default:
name|awalk
argument_list|(
name|q
argument_list|)
expr_stmt|;
comment|/* no break */
case|case
name|TCONST
case|:
continue|continue;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|awalk
parameter_list|(
name|e
parameter_list|)
name|expptr
name|e
decl_stmt|;
block|{
name|Namep
name|np
decl_stmt|;
name|top
label|:
if|if
condition|(
operator|!
name|e
condition|)
return|return;
switch|switch
condition|(
name|e
operator|->
name|tag
condition|)
block|{
default|default:
name|badtag
argument_list|(
literal|"awalk"
argument_list|,
name|e
argument_list|)
expr_stmt|;
case|case
name|TCONST
case|:
case|case
name|TERROR
case|:
case|case
name|TLIST
case|:
return|return;
case|case
name|TADDR
case|:
if|if
condition|(
name|e
operator|->
name|addrblock
operator|.
name|uname_tag
operator|==
name|UNAM_NAME
condition|)
block|{
name|np
operator|=
name|e
operator|->
name|addrblock
operator|.
name|user
operator|.
name|name
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|vknownarg
operator|&&
operator|!
name|refs
index|[
name|np
operator|->
name|argno
index|]
operator|++
condition|)
name|used
index|[
name|nu
operator|++
index|]
operator|=
name|np
operator|->
name|argno
expr_stmt|;
block|}
name|e
operator|=
name|e
operator|->
name|addrblock
operator|.
name|memoffset
expr_stmt|;
goto|goto
name|top
goto|;
case|case
name|TPRIM
case|:
name|np
operator|=
name|e
operator|->
name|primblock
operator|.
name|namep
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|vknownarg
operator|&&
operator|!
name|refs
index|[
name|np
operator|->
name|argno
index|]
operator|++
condition|)
name|used
index|[
name|nu
operator|++
index|]
operator|=
name|np
operator|->
name|argno
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|primblock
operator|.
name|argsp
operator|&&
name|np
operator|->
name|vclass
operator|!=
name|CLVAR
condition|)
name|afwalk
argument_list|(
operator|(
expr|struct
name|Primblock
operator|*
operator|)
name|e
argument_list|)
expr_stmt|;
else|else
name|aawalk
argument_list|(
operator|(
expr|struct
name|Primblock
operator|*
operator|)
name|e
argument_list|)
expr_stmt|;
return|return;
case|case
name|TEXPR
case|:
name|awalk
argument_list|(
name|e
operator|->
name|exprblock
operator|.
name|rightp
argument_list|)
expr_stmt|;
name|e
operator|=
name|e
operator|->
name|exprblock
operator|.
name|leftp
expr_stmt|;
goto|goto
name|top
goto|;
block|}
block|}
end_function

begin_function
specifier|static
name|chainp
name|argsort
parameter_list|(
name|p0
parameter_list|)
name|chainp
name|p0
decl_stmt|;
block|{
name|Namep
modifier|*
name|args
decl_stmt|,
name|q
decl_stmt|,
modifier|*
name|stack
decl_stmt|;
name|int
name|i
decl_stmt|,
name|nargs
decl_stmt|,
name|nout
decl_stmt|,
name|nst
decl_stmt|;
name|chainp
modifier|*
name|d
decl_stmt|,
modifier|*
name|da
decl_stmt|,
name|p
decl_stmt|,
name|rv
decl_stmt|,
modifier|*
name|rvp
decl_stmt|;
name|struct
name|Dimblock
modifier|*
name|dp
decl_stmt|;
if|if
condition|(
operator|!
name|p0
condition|)
return|return
name|p0
return|;
for|for
control|(
name|nargs
operator|=
literal|0
operator|,
name|p
operator|=
name|p0
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|nextp
control|)
name|nargs
operator|++
expr_stmt|;
name|args
operator|=
operator|(
name|Namep
operator|*
operator|)
name|ckalloc
argument_list|(
name|i
operator|=
name|nargs
operator|*
operator|(
sizeof|sizeof
argument_list|(
name|Namep
argument_list|)
operator|+
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|chainp
argument_list|)
operator|+
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|args
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|stack
operator|=
name|args
operator|+
name|nargs
expr_stmt|;
name|d
operator|=
operator|(
name|chainp
operator|*
operator|)
operator|(
name|stack
operator|+
name|nargs
operator|)
expr_stmt|;
name|refs
operator|=
operator|(
name|int
operator|*
operator|)
operator|(
name|d
operator|+
name|nargs
operator|)
expr_stmt|;
name|used
operator|=
name|refs
operator|+
name|nargs
expr_stmt|;
for|for
control|(
name|p
operator|=
name|p0
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|nextp
control|)
block|{
name|q
operator|=
operator|(
name|Namep
operator|)
name|p
operator|->
name|datap
expr_stmt|;
name|args
index|[
name|q
operator|->
name|argno
index|]
operator|=
name|q
expr_stmt|;
block|}
for|for
control|(
name|p
operator|=
name|p0
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|nextp
control|)
block|{
name|q
operator|=
operator|(
name|Namep
operator|)
name|p
operator|->
name|datap
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|dp
operator|=
name|q
operator|->
name|vdim
operator|)
condition|)
continue|continue;
name|i
operator|=
name|dp
operator|->
name|ndim
expr_stmt|;
while|while
condition|(
operator|--
name|i
operator|>=
literal|0
condition|)
name|awalk
argument_list|(
name|dp
operator|->
name|dims
index|[
name|i
index|]
operator|.
name|dimexpr
argument_list|)
expr_stmt|;
name|awalk
argument_list|(
name|dp
operator|->
name|basexpr
argument_list|)
expr_stmt|;
while|while
condition|(
name|nu
operator|>
literal|0
condition|)
block|{
name|refs
index|[
name|i
operator|=
name|used
index|[
operator|--
name|nu
index|]
index|]
operator|=
literal|0
expr_stmt|;
name|d
index|[
name|i
index|]
operator|=
name|mkchain
argument_list|(
operator|(
name|char
operator|*
operator|)
name|q
argument_list|,
name|d
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
name|nst
operator|=
literal|0
init|;
name|i
operator|<
name|nargs
condition|;
name|i
operator|++
control|)
for|for
control|(
name|p
operator|=
name|d
index|[
name|i
index|]
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|nextp
control|)
name|refs
index|[
operator|(
operator|(
name|Namep
operator|)
name|p
operator|->
name|datap
operator|)
operator|->
name|argno
index|]
operator|++
expr_stmt|;
while|while
condition|(
operator|--
name|i
operator|>=
literal|0
condition|)
if|if
condition|(
operator|!
name|refs
index|[
name|i
index|]
condition|)
name|stack
index|[
name|nst
operator|++
index|]
operator|=
name|args
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|nst
operator|==
name|nargs
condition|)
block|{
name|rv
operator|=
name|p0
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|nout
operator|=
literal|0
expr_stmt|;
name|rv
operator|=
literal|0
expr_stmt|;
name|rvp
operator|=
operator|&
name|rv
expr_stmt|;
while|while
condition|(
name|nst
operator|>
literal|0
condition|)
block|{
name|nout
operator|++
expr_stmt|;
name|q
operator|=
name|stack
index|[
operator|--
name|nst
index|]
expr_stmt|;
operator|*
name|rvp
operator|=
name|p
operator|=
name|mkchain
argument_list|(
operator|(
name|char
operator|*
operator|)
name|q
argument_list|,
name|CHNULL
argument_list|)
expr_stmt|;
name|rvp
operator|=
operator|&
name|p
operator|->
name|nextp
expr_stmt|;
name|da
operator|=
name|d
operator|+
name|q
operator|->
name|argno
expr_stmt|;
for|for
control|(
name|p
operator|=
operator|*
name|da
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|nextp
control|)
if|if
condition|(
operator|!
operator|--
name|refs
index|[
operator|(
name|q
operator|=
operator|(
name|Namep
operator|)
name|p
operator|->
name|datap
operator|)
operator|->
name|argno
index|]
condition|)
name|stack
index|[
name|nst
operator|++
index|]
operator|=
name|q
expr_stmt|;
name|frchain
argument_list|(
operator|*
name|da
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nout
operator|<
name|nargs
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nargs
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|refs
index|[
name|i
index|]
condition|)
block|{
name|q
operator|=
name|args
index|[
name|i
index|]
expr_stmt|;
name|errstr
argument_list|(
literal|"Can't adjust %.38s correctly\n\ 	due to dependencies among arguments."
argument_list|,
name|q
operator|->
name|fvarname
argument_list|)
expr_stmt|;
operator|*
name|rvp
operator|=
name|p
operator|=
name|mkchain
argument_list|(
operator|(
name|char
operator|*
operator|)
name|q
argument_list|,
name|CHNULL
argument_list|)
expr_stmt|;
name|rvp
operator|=
operator|&
name|p
operator|->
name|nextp
expr_stmt|;
name|frchain
argument_list|(
name|d
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|done
label|:
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|args
argument_list|)
expr_stmt|;
return|return
name|rv
return|;
block|}
end_function

begin_macro
name|prolog
argument_list|(
argument|outfile
argument_list|,
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|outfile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|chainp
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|addif
decl_stmt|,
name|addif0
decl_stmt|,
name|i
decl_stmt|,
name|nd
decl_stmt|,
name|size
decl_stmt|;
name|int
modifier|*
name|ac
decl_stmt|;
specifier|register
name|Namep
name|q
decl_stmt|;
specifier|register
name|struct
name|Dimblock
modifier|*
name|dp
decl_stmt|;
name|chainp
name|p0
decl_stmt|,
name|p1
decl_stmt|;
if|if
condition|(
name|procclass
operator|==
name|CLBLOCK
condition|)
return|return;
name|p0
operator|=
name|p
expr_stmt|;
name|p1
operator|=
name|p
operator|=
name|argsort
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|wrote_comment
operator|=
literal|0
expr_stmt|;
name|comment_file
operator|=
name|outfile
expr_stmt|;
name|ac
operator|=
literal|0
expr_stmt|;
comment|/* Compute the base addresses and offsets for the array parameters, and    assign these values to local variables */
name|addif
operator|=
name|addif0
operator|=
name|nentry
operator|>
literal|1
expr_stmt|;
for|for
control|(
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|nextp
control|)
block|{
name|q
operator|=
operator|(
name|Namep
operator|)
name|p
operator|->
name|datap
expr_stmt|;
if|if
condition|(
name|dp
operator|=
name|q
operator|->
name|vdim
condition|)
comment|/* if this param is an array ... */
block|{
name|expptr
name|Q
decl_stmt|,
name|expr
decl_stmt|;
comment|/* See whether to protect the following with an if. */
comment|/* This only happens when there are multiple entries. */
name|nd
operator|=
name|dp
operator|->
name|ndim
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|addif0
condition|)
block|{
if|if
condition|(
operator|!
name|ac
condition|)
name|ac
operator|=
name|count_args
argument_list|()
expr_stmt|;
if|if
condition|(
name|ac
index|[
name|q
operator|->
name|argno
index|]
operator|==
name|nentry
condition|)
name|addif
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|dp
operator|->
name|basexpr
operator|||
name|dp
operator|->
name|baseoffset
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
condition|)
name|addif
operator|=
literal|1
expr_stmt|;
else|else
for|for
control|(
name|addif
operator|=
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|nd
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|dp
operator|->
name|dims
index|[
name|i
index|]
operator|.
name|dimexpr
operator|&&
operator|(
name|i
operator|<
name|nd
operator|||
operator|!
name|q
operator|->
name|vlastdim
operator|)
condition|)
block|{
name|addif
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|addif
condition|)
block|{
name|write_comment
argument_list|()
expr_stmt|;
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"if (%s) {\n"
argument_list|,
comment|/*}*/
name|q
operator|->
name|cvarname
argument_list|)
expr_stmt|;
name|next_tab
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|nd
condition|;
operator|++
name|i
control|)
comment|/* Store the variable length of each dimension (which is fixed upon    runtime procedure entry) into a local variable */
if|if
condition|(
operator|(
name|Q
operator|=
name|dp
operator|->
name|dims
index|[
name|i
index|]
operator|.
name|dimexpr
operator|)
operator|&&
operator|(
name|i
operator|<
name|nd
operator|||
operator|!
name|q
operator|->
name|vlastdim
operator|)
condition|)
block|{
name|expr
operator|=
operator|(
name|expptr
operator|)
name|cpexpr
argument_list|(
name|Q
argument_list|)
expr_stmt|;
name|write_comment
argument_list|()
expr_stmt|;
name|out_and_free_statement
argument_list|(
name|outfile
argument_list|,
name|mkexpr
argument_list|(
name|OPASSIGN
argument_list|,
name|fixtype
argument_list|(
name|cpexpr
argument_list|(
name|dp
operator|->
name|dims
index|[
name|i
index|]
operator|.
name|dimsize
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* if dp -> dims[i].dimexpr */
comment|/* size   will equal the size of a single element, or -1 if the type is    variable length character type */
name|size
operator|=
name|typesize
index|[
name|q
operator|->
name|vtype
index|]
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|vtype
operator|==
name|TYCHAR
condition|)
if|if
condition|(
name|ISICON
argument_list|(
name|q
operator|->
name|vleng
argument_list|)
condition|)
name|size
operator|*=
name|q
operator|->
name|vleng
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
expr_stmt|;
else|else
name|size
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Fudge the argument pointers for arrays so subscripts 		 * are 0-based. Not done if array bounds are being checked. 		 */
if|if
condition|(
name|dp
operator|->
name|basexpr
condition|)
block|{
comment|/* Compute the base offset for this procedure */
name|write_comment
argument_list|()
expr_stmt|;
name|out_and_free_statement
argument_list|(
name|outfile
argument_list|,
name|mkexpr
argument_list|(
name|OPASSIGN
argument_list|,
name|cpexpr
argument_list|(
name|fixtype
argument_list|(
name|dp
operator|->
name|baseoffset
argument_list|)
argument_list|)
argument_list|,
name|cpexpr
argument_list|(
name|fixtype
argument_list|(
name|dp
operator|->
name|basexpr
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* if dp -> basexpr */
if|if
condition|(
operator|!
name|checksubs
condition|)
block|{
if|if
condition|(
name|dp
operator|->
name|basexpr
condition|)
block|{
name|expptr
name|tp
decl_stmt|;
comment|/* If the base of this array has a variable adjustment ... */
name|tp
operator|=
operator|(
name|expptr
operator|)
name|cpexpr
argument_list|(
name|dp
operator|->
name|baseoffset
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|<
literal|0
operator|||
name|q
operator|->
name|vtype
operator|==
name|TYCHAR
condition|)
name|tp
operator|=
name|mkexpr
argument_list|(
name|OPSTAR
argument_list|,
name|tp
argument_list|,
name|cpexpr
argument_list|(
name|q
operator|->
name|vleng
argument_list|)
argument_list|)
expr_stmt|;
name|write_comment
argument_list|()
expr_stmt|;
name|tp
operator|=
name|mkexpr
argument_list|(
name|OPMINUSEQ
argument_list|,
name|mkconv
argument_list|(
name|TYADDR
argument_list|,
operator|(
name|expptr
operator|)
name|p
operator|->
name|datap
argument_list|)
argument_list|,
name|mkconv
argument_list|(
name|TYINT
argument_list|,
name|fixtype
argument_list|(
name|fixtype
argument_list|(
name|tp
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Avoid type clash by removing the type conversion */
name|tp
operator|=
name|prune_left_conv
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|out_and_free_statement
argument_list|(
name|outfile
argument_list|,
name|tp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dp
operator|->
name|baseoffset
operator|->
name|constblock
operator|.
name|Const
operator|.
name|ci
operator|!=
literal|0
condition|)
block|{
comment|/* if the base of this array has a nonzero constant adjustment ... */
name|expptr
name|tp
decl_stmt|;
name|write_comment
argument_list|()
expr_stmt|;
if|if
condition|(
name|size
operator|>
literal|0
operator|&&
name|q
operator|->
name|vtype
operator|!=
name|TYCHAR
condition|)
block|{
name|tp
operator|=
name|prune_left_conv
argument_list|(
name|mkexpr
argument_list|(
name|OPMINUSEQ
argument_list|,
name|mkconv
argument_list|(
name|TYADDR
argument_list|,
operator|(
name|expptr
operator|)
name|p
operator|->
name|datap
argument_list|)
argument_list|,
name|mkconv
argument_list|(
name|TYINT
argument_list|,
name|fixtype
argument_list|(
name|cpexpr
argument_list|(
name|dp
operator|->
name|baseoffset
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|out_and_free_statement
argument_list|(
name|outfile
argument_list|,
name|tp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tp
operator|=
name|prune_left_conv
argument_list|(
name|mkexpr
argument_list|(
name|OPMINUSEQ
argument_list|,
name|mkconv
argument_list|(
name|TYADDR
argument_list|,
operator|(
name|expptr
operator|)
name|p
operator|->
name|datap
argument_list|)
argument_list|,
name|mkconv
argument_list|(
name|TYINT
argument_list|,
name|fixtype
argument_list|(
name|mkexpr
argument_list|(
name|OPSTAR
argument_list|,
name|cpexpr
argument_list|(
name|dp
operator|->
name|baseoffset
argument_list|)
argument_list|,
name|cpexpr
argument_list|(
name|q
operator|->
name|vleng
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|out_and_free_statement
argument_list|(
name|outfile
argument_list|,
name|tp
argument_list|)
expr_stmt|;
block|}
comment|/* else */
block|}
comment|/* if dp -> baseoffset -> const */
block|}
comment|/* if !checksubs */
if|if
condition|(
name|addif
condition|)
block|{
name|nice_printf
argument_list|(
name|outfile
argument_list|,
comment|/*{*/
literal|"}\n"
argument_list|)
expr_stmt|;
name|prev_tab
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|wrote_comment
condition|)
name|nice_printf
argument_list|(
name|outfile
argument_list|,
literal|"\n/* Function Body */\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ac
condition|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ac
argument_list|)
expr_stmt|;
if|if
condition|(
name|p0
operator|!=
name|p1
condition|)
name|frchain
argument_list|(
name|p1
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* prolog */
end_comment

end_unit

