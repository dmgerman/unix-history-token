begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * This code is derived from software copyrighted by the Free Software  * Foundation.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)cplus-dem.c	8.1 (Berkeley) 6/6/93"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/* Demangler for GNU C++     Copyright (C) 1989 Free Software Foundation, Inc.    written by James Clark (jjc@jclark.uucp)        This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 1, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* This is for g++ 1.36.1 (November 6 version). It will probably    require changes for any other version.     Modified for g++ 1.36.2 (November 18 version).  */
end_comment

begin_comment
comment|/* This file exports one function     char *cplus_demangle (const char *name)        If `name' is a mangled function name produced by g++, then    a pointer to a malloced string giving a C++ representation    of the name will be returned; otherwise NULL will be returned.    It is the caller's responsibility to free the string which    is returned.     For example,        cplus_demangle ("_foo__1Ai")        returns     "A::foo(int)"     This file imports xmalloc and xrealloc, which are like malloc and    realloc except that they generate a fatal error if there is no    available memory. */
end_comment

begin_comment
comment|/* #define nounderscore 1 /* define this is names don't start with _ */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|USG
end_ifdef

begin_include
include|#
directive|include
file|<memory.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_define
define|#
directive|define
name|memcpy
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|,
name|n
parameter_list|)
value|bcopy ((s2), (s1), (n))
end_define

begin_define
define|#
directive|define
name|memcmp
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|,
name|n
parameter_list|)
value|bcmp ((s2), (s1), (n))
end_define

begin_define
define|#
directive|define
name|strchr
value|index
end_define

begin_define
define|#
directive|define
name|strrchr
value|rindex
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_function_decl
specifier|extern
name|char
modifier|*
name|cplus_demangle
parameter_list|(
specifier|const
name|char
modifier|*
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_function_decl
specifier|extern
name|char
modifier|*
name|cplus_demangle
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_function_decl
specifier|extern
name|char
modifier|*
name|xmalloc
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|xrealloc
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_function_decl
specifier|extern
name|char
modifier|*
name|xmalloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|xrealloc
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|typevec
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ntypes
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|typevec_size
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_struct
specifier|static
struct|struct
block|{
specifier|const
name|char
modifier|*
name|in
decl_stmt|;
specifier|const
name|char
modifier|*
name|out
decl_stmt|;
block|}
name|optable
index|[]
init|=
block|{
literal|"new"
block|,
literal|" new"
block|,
literal|"delete"
block|,
literal|" delete"
block|,
literal|"ne"
block|,
literal|"!="
block|,
literal|"eq"
block|,
literal|"=="
block|,
literal|"ge"
block|,
literal|">="
block|,
literal|"gt"
block|,
literal|">"
block|,
literal|"le"
block|,
literal|"<="
block|,
literal|"lt"
block|,
literal|"<"
block|,
literal|"plus"
block|,
literal|"+"
block|,
literal|"minus"
block|,
literal|"-"
block|,
literal|"mult"
block|,
literal|"*"
block|,
literal|"convert"
block|,
literal|"+"
block|,
comment|/* unary + */
literal|"negate"
block|,
literal|"-"
block|,
comment|/* unary - */
literal|"trunc_mod"
block|,
literal|"%"
block|,
literal|"trunc_div"
block|,
literal|"/"
block|,
literal|"truth_andif"
block|,
literal|"&&"
block|,
literal|"truth_orif"
block|,
literal|"||"
block|,
literal|"truth_not"
block|,
literal|"!"
block|,
literal|"postincrement"
block|,
literal|"++"
block|,
literal|"postdecrement"
block|,
literal|"--"
block|,
literal|"bit_ior"
block|,
literal|"|"
block|,
literal|"bit_xor"
block|,
literal|"^"
block|,
literal|"bit_and"
block|,
literal|"&"
block|,
literal|"bit_not"
block|,
literal|"~"
block|,
literal|"call"
block|,
literal|"()"
block|,
literal|"cond"
block|,
literal|"?:"
block|,
literal|"alshift"
block|,
literal|"<<"
block|,
literal|"arshift"
block|,
literal|">>"
block|,
literal|"component"
block|,
literal|"->"
block|,
literal|"indirect"
block|,
literal|"*"
block|,
literal|"method_call"
block|,
literal|"->()"
block|,
literal|"addr"
block|,
literal|"&"
block|,
comment|/* unary& */
literal|"array"
block|,
literal|"[]"
block|,
literal|"nop"
block|,
literal|""
block|,
comment|/* for operator= */
block|}
struct|;
end_struct

begin_comment
comment|/* Beware: these aren't '\0' terminated. */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|char
modifier|*
name|b
decl_stmt|;
comment|/* pointer to start of string */
name|char
modifier|*
name|p
decl_stmt|;
comment|/* pointer after last character */
name|char
modifier|*
name|e
decl_stmt|;
comment|/* pointer after end of allocated space */
block|}
name|string
typedef|;
end_typedef

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_function_decl
specifier|static
name|void
name|string_need
parameter_list|(
name|string
modifier|*
name|s
parameter_list|,
name|int
name|n
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|string_delete
parameter_list|(
name|string
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|string_init
parameter_list|(
name|string
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|string_clear
parameter_list|(
name|string
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|string_empty
parameter_list|(
name|string
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|string_append
parameter_list|(
name|string
modifier|*
name|p
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|string_appends
parameter_list|(
name|string
modifier|*
name|p
parameter_list|,
name|string
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|string_appendn
parameter_list|(
name|string
modifier|*
name|p
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|int
name|n
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|string_prepend
parameter_list|(
name|string
modifier|*
name|p
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static void string_prepends (string *p, string *s);
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|string_prependn
parameter_list|(
name|string
modifier|*
name|p
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|int
name|n
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_count
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|type
parameter_list|,
name|int
modifier|*
name|count
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|do_args
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|type
parameter_list|,
name|string
modifier|*
name|decl
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|do_type
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|type
parameter_list|,
name|string
modifier|*
name|result
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|do_arg
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|type
parameter_list|,
name|string
modifier|*
name|result
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|do_args
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|type
parameter_list|,
name|string
modifier|*
name|decl
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|munge_function_name
parameter_list|(
name|string
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|remember_type
parameter_list|(
specifier|const
name|char
modifier|*
name|type
parameter_list|,
name|int
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_function_decl
specifier|static
name|void
name|string_need
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|string_delete
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|string_init
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|string_clear
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|string_empty
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|string_append
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|string_appends
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|string_appendn
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|string_prepend
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|string_prepends
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|string_prependn
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_count
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|do_args
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|do_type
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|do_arg
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|do_args
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|munge_function_name
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|remember_type
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|char
modifier|*
name|cplus_demangle
parameter_list|(
name|type
parameter_list|)
specifier|const
name|char
modifier|*
name|type
decl_stmt|;
block|{
name|string
name|decl
decl_stmt|;
name|int
name|n
decl_stmt|;
name|int
name|success
init|=
literal|0
decl_stmt|;
name|int
name|constructor
init|=
literal|0
decl_stmt|;
name|int
name|const_flag
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
ifndef|#
directive|ifndef
name|LONGERNAMES
specifier|const
name|char
modifier|*
name|premangle
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|type
operator|==
name|NULL
operator|||
operator|*
name|type
operator|==
literal|'\0'
condition|)
return|return
name|NULL
return|;
ifndef|#
directive|ifndef
name|nounderscore
if|if
condition|(
operator|*
name|type
operator|++
operator|!=
literal|'_'
condition|)
return|return
name|NULL
return|;
endif|#
directive|endif
name|p
operator|=
name|type
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
operator|!
operator|(
operator|*
name|p
operator|==
literal|'_'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'_'
operator|)
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
comment|/* destructor */
if|if
condition|(
name|type
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
name|type
index|[
literal|1
index|]
operator|==
literal|'$'
operator|&&
name|type
index|[
literal|2
index|]
operator|==
literal|'_'
condition|)
block|{
name|int
name|n
init|=
operator|(
name|strlen
argument_list|(
name|type
argument_list|)
operator|-
literal|3
operator|)
operator|*
literal|2
operator|+
literal|3
operator|+
literal|2
operator|+
literal|1
decl_stmt|;
name|char
modifier|*
name|tem
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|n
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|tem
argument_list|,
name|type
operator|+
literal|3
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tem
argument_list|,
literal|"::~"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tem
argument_list|,
name|type
operator|+
literal|3
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tem
argument_list|,
literal|"()"
argument_list|)
expr_stmt|;
return|return
name|tem
return|;
block|}
comment|/* static data member */
if|if
condition|(
operator|*
name|type
operator|!=
literal|'_'
operator|&&
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|type
argument_list|,
literal|'$'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|int
name|n
init|=
name|strlen
argument_list|(
name|type
argument_list|)
operator|+
literal|2
decl_stmt|;
name|char
modifier|*
name|tem
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|n
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|tem
argument_list|,
name|type
argument_list|,
name|p
operator|-
name|type
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|tem
operator|+
operator|(
name|p
operator|-
name|type
operator|)
argument_list|,
literal|"::"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|tem
operator|+
operator|(
name|p
operator|-
name|type
operator|)
operator|+
literal|2
argument_list|,
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|tem
return|;
block|}
comment|/* virtual table */
if|if
condition|(
name|type
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
name|type
index|[
literal|1
index|]
operator|==
literal|'v'
operator|&&
name|type
index|[
literal|2
index|]
operator|==
literal|'t'
operator|&&
name|type
index|[
literal|3
index|]
operator|==
literal|'$'
condition|)
block|{
name|int
name|n
init|=
name|strlen
argument_list|(
name|type
operator|+
literal|4
argument_list|)
operator|+
literal|14
operator|+
literal|1
decl_stmt|;
name|char
modifier|*
name|tem
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|n
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|tem
argument_list|,
name|type
operator|+
literal|4
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tem
argument_list|,
literal|" virtual table"
argument_list|)
expr_stmt|;
return|return
name|tem
return|;
block|}
return|return
name|NULL
return|;
block|}
name|string_init
argument_list|(
operator|&
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|type
condition|)
block|{
if|if
condition|(
operator|!
name|isdigit
argument_list|(
name|p
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
name|string_delete
argument_list|(
operator|&
name|decl
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|constructor
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|string_appendn
argument_list|(
operator|&
name|decl
argument_list|,
name|type
argument_list|,
name|p
operator|-
name|type
argument_list|)
expr_stmt|;
name|munge_function_name
argument_list|(
operator|&
name|decl
argument_list|)
expr_stmt|;
block|}
name|p
operator|+=
literal|2
expr_stmt|;
ifndef|#
directive|ifndef
name|LONGERNAMES
name|premangle
operator|=
name|p
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|'C'
case|:
comment|/* a const member function */
if|if
condition|(
operator|!
name|isdigit
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|string_delete
argument_list|(
operator|&
name|decl
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|p
operator|+=
literal|1
expr_stmt|;
name|const_flag
operator|=
literal|1
expr_stmt|;
comment|/* fall through */
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
name|n
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|n
operator|*=
literal|10
expr_stmt|;
name|n
operator|+=
operator|*
name|p
operator|-
literal|'0'
expr_stmt|;
name|p
operator|+=
literal|1
expr_stmt|;
block|}
do|while
condition|(
name|isdigit
argument_list|(
operator|*
name|p
argument_list|)
condition|)
do|;
if|if
condition|(
name|strlen
argument_list|(
name|p
argument_list|)
operator|<
name|n
condition|)
block|{
name|string_delete
argument_list|(
operator|&
name|decl
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|constructor
condition|)
block|{
name|string_appendn
argument_list|(
operator|&
name|decl
argument_list|,
name|p
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
operator|&
name|decl
argument_list|,
literal|"::"
argument_list|)
expr_stmt|;
name|string_appendn
argument_list|(
operator|&
name|decl
argument_list|,
name|p
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|string_prepend
argument_list|(
operator|&
name|decl
argument_list|,
literal|"::"
argument_list|)
expr_stmt|;
name|string_prependn
argument_list|(
operator|&
name|decl
argument_list|,
name|p
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
name|p
operator|+=
name|n
expr_stmt|;
ifndef|#
directive|ifndef
name|LONGERNAMES
name|remember_type
argument_list|(
name|premangle
argument_list|,
name|p
operator|-
name|premangle
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|success
operator|=
name|do_args
argument_list|(
operator|&
name|p
argument_list|,
operator|&
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|const_flag
condition|)
name|string_append
argument_list|(
operator|&
name|decl
argument_list|,
literal|" const"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
name|p
operator|+=
literal|1
expr_stmt|;
name|success
operator|=
name|do_args
argument_list|(
operator|&
name|p
argument_list|,
operator|&
name|decl
argument_list|)
expr_stmt|;
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ntypes
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|typevec
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|typevec
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ntypes
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|typevec
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|typevec
argument_list|)
expr_stmt|;
name|typevec
operator|=
name|NULL
expr_stmt|;
name|typevec_size
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|success
condition|)
block|{
name|string_appendn
argument_list|(
operator|&
name|decl
argument_list|,
literal|""
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|decl
operator|.
name|b
return|;
block|}
else|else
block|{
name|string_delete
argument_list|(
operator|&
name|decl
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|get_count
parameter_list|(
name|type
parameter_list|,
name|count
parameter_list|)
specifier|const
name|char
modifier|*
modifier|*
name|type
decl_stmt|;
name|int
modifier|*
name|count
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
operator|*
name|type
argument_list|)
condition|)
return|return
literal|0
return|;
operator|*
name|count
operator|=
operator|*
operator|*
name|type
operator|-
literal|'0'
expr_stmt|;
operator|*
name|type
operator|+=
literal|1
expr_stmt|;
comment|/* see flush_repeats in cplus-method.c */
if|if
condition|(
name|isdigit
argument_list|(
operator|*
operator|*
name|type
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|p
init|=
operator|*
name|type
decl_stmt|;
name|int
name|n
init|=
operator|*
name|count
decl_stmt|;
do|do
block|{
name|n
operator|*=
literal|10
expr_stmt|;
name|n
operator|+=
operator|*
name|p
operator|-
literal|'0'
expr_stmt|;
name|p
operator|+=
literal|1
expr_stmt|;
block|}
do|while
condition|(
name|isdigit
argument_list|(
operator|*
name|p
argument_list|)
condition|)
do|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'_'
condition|)
block|{
operator|*
name|type
operator|=
name|p
operator|+
literal|1
expr_stmt|;
operator|*
name|count
operator|=
name|n
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* result will be initialised here; it will be freed on failure */
end_comment

begin_function
specifier|static
name|int
name|do_type
parameter_list|(
name|type
parameter_list|,
name|result
parameter_list|)
specifier|const
name|char
modifier|*
modifier|*
name|type
decl_stmt|;
name|string
modifier|*
name|result
decl_stmt|;
block|{
name|int
name|n
decl_stmt|;
name|int
name|done
decl_stmt|;
name|int
name|non_empty
init|=
literal|0
decl_stmt|;
name|int
name|success
decl_stmt|;
name|string
name|decl
decl_stmt|;
specifier|const
name|char
modifier|*
name|remembered_type
decl_stmt|;
name|string_init
argument_list|(
operator|&
name|decl
argument_list|)
expr_stmt|;
name|string_init
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|done
operator|=
literal|0
expr_stmt|;
name|success
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|success
operator|&&
operator|!
name|done
condition|)
block|{
name|int
name|member
decl_stmt|;
switch|switch
condition|(
operator|*
operator|*
name|type
condition|)
block|{
case|case
literal|'P'
case|:
operator|*
name|type
operator|+=
literal|1
expr_stmt|;
name|string_prepend
argument_list|(
operator|&
name|decl
argument_list|,
literal|"*"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
operator|*
name|type
operator|+=
literal|1
expr_stmt|;
name|string_prepend
argument_list|(
operator|&
name|decl
argument_list|,
literal|"&"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
operator|*
name|type
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|get_count
argument_list|(
name|type
argument_list|,
operator|&
name|n
argument_list|)
operator|||
name|n
operator|>=
name|ntypes
condition|)
name|success
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|remembered_type
operator|=
name|typevec
index|[
name|n
index|]
expr_stmt|;
name|type
operator|=
operator|&
name|remembered_type
expr_stmt|;
block|}
break|break;
case|case
literal|'F'
case|:
operator|*
name|type
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|string_empty
argument_list|(
operator|&
name|decl
argument_list|)
operator|&&
name|decl
operator|.
name|b
index|[
literal|0
index|]
operator|==
literal|'*'
condition|)
block|{
name|string_prepend
argument_list|(
operator|&
name|decl
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
operator|&
name|decl
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|do_args
argument_list|(
name|type
argument_list|,
operator|&
name|decl
argument_list|)
operator|||
operator|*
operator|*
name|type
operator|!=
literal|'_'
condition|)
name|success
operator|=
literal|0
expr_stmt|;
else|else
operator|*
name|type
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
case|case
literal|'O'
case|:
block|{
name|int
name|constp
init|=
literal|0
decl_stmt|;
name|int
name|volatilep
init|=
literal|0
decl_stmt|;
name|member
operator|=
operator|*
operator|*
name|type
operator|==
literal|'M'
expr_stmt|;
operator|*
name|type
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
operator|*
name|type
argument_list|)
condition|)
block|{
name|success
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|n
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|n
operator|*=
literal|10
expr_stmt|;
name|n
operator|+=
operator|*
operator|*
name|type
operator|-
literal|'0'
expr_stmt|;
operator|*
name|type
operator|+=
literal|1
expr_stmt|;
block|}
do|while
condition|(
name|isdigit
argument_list|(
operator|*
operator|*
name|type
argument_list|)
condition|)
do|;
if|if
condition|(
name|strlen
argument_list|(
operator|*
name|type
argument_list|)
operator|<
name|n
condition|)
block|{
name|success
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|string_append
argument_list|(
operator|&
name|decl
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
name|string_prepend
argument_list|(
operator|&
name|decl
argument_list|,
literal|"::"
argument_list|)
expr_stmt|;
name|string_prependn
argument_list|(
operator|&
name|decl
argument_list|,
operator|*
name|type
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|string_prepend
argument_list|(
operator|&
name|decl
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
operator|*
name|type
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|member
condition|)
block|{
if|if
condition|(
operator|*
operator|*
name|type
operator|==
literal|'C'
condition|)
block|{
operator|*
name|type
operator|+=
literal|1
expr_stmt|;
name|constp
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|*
operator|*
name|type
operator|==
literal|'V'
condition|)
block|{
operator|*
name|type
operator|+=
literal|1
expr_stmt|;
name|volatilep
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|*
operator|(
operator|*
name|type
operator|)
operator|++
operator|!=
literal|'F'
condition|)
block|{
name|success
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|(
name|member
operator|&&
operator|!
name|do_args
argument_list|(
name|type
argument_list|,
operator|&
name|decl
argument_list|)
operator|)
operator|||
operator|*
operator|*
name|type
operator|!=
literal|'_'
condition|)
block|{
name|success
operator|=
literal|0
expr_stmt|;
break|break;
block|}
operator|*
name|type
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|constp
condition|)
block|{
if|if
condition|(
name|non_empty
condition|)
name|string_append
argument_list|(
operator|&
name|decl
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
else|else
name|non_empty
operator|=
literal|1
expr_stmt|;
name|string_append
argument_list|(
operator|&
name|decl
argument_list|,
literal|"const"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|volatilep
condition|)
block|{
if|if
condition|(
name|non_empty
condition|)
name|string_append
argument_list|(
operator|&
name|decl
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
else|else
name|non_empty
operator|=
literal|1
expr_stmt|;
name|string_append
argument_list|(
operator|&
name|decl
argument_list|,
literal|"volatilep"
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
literal|'C'
case|:
if|if
condition|(
operator|(
operator|*
name|type
operator|)
index|[
literal|1
index|]
operator|==
literal|'P'
condition|)
block|{
operator|*
name|type
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|string_empty
argument_list|(
operator|&
name|decl
argument_list|)
condition|)
name|string_prepend
argument_list|(
operator|&
name|decl
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|string_prepend
argument_list|(
operator|&
name|decl
argument_list|,
literal|"const"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* fall through */
default|default:
name|done
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
name|done
operator|=
literal|0
expr_stmt|;
name|non_empty
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|success
operator|&&
operator|!
name|done
condition|)
block|{
switch|switch
condition|(
operator|*
operator|*
name|type
condition|)
block|{
case|case
literal|'C'
case|:
operator|*
name|type
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|non_empty
condition|)
name|string_append
argument_list|(
name|result
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
else|else
name|non_empty
operator|=
literal|1
expr_stmt|;
name|string_append
argument_list|(
name|result
argument_list|,
literal|"const"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'U'
case|:
operator|*
name|type
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|non_empty
condition|)
name|string_append
argument_list|(
name|result
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
else|else
name|non_empty
operator|=
literal|1
expr_stmt|;
name|string_append
argument_list|(
name|result
argument_list|,
literal|"unsigned"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
operator|*
name|type
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|non_empty
condition|)
name|string_append
argument_list|(
name|result
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
else|else
name|non_empty
operator|=
literal|1
expr_stmt|;
name|string_append
argument_list|(
name|result
argument_list|,
literal|"volatile"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|done
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|success
condition|)
switch|switch
condition|(
operator|*
operator|*
name|type
condition|)
block|{
case|case
literal|'\0'
case|:
case|case
literal|'_'
case|:
break|break;
case|case
literal|'v'
case|:
operator|*
name|type
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|non_empty
condition|)
name|string_append
argument_list|(
name|result
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|result
argument_list|,
literal|"void"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
operator|*
name|type
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|non_empty
condition|)
name|string_append
argument_list|(
name|result
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|result
argument_list|,
literal|"long long"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
operator|*
name|type
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|non_empty
condition|)
name|string_append
argument_list|(
name|result
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|result
argument_list|,
literal|"long"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
operator|*
name|type
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|non_empty
condition|)
name|string_append
argument_list|(
name|result
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|result
argument_list|,
literal|"int"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
operator|*
name|type
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|non_empty
condition|)
name|string_append
argument_list|(
name|result
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|result
argument_list|,
literal|"short"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
operator|*
name|type
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|non_empty
condition|)
name|string_append
argument_list|(
name|result
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|result
argument_list|,
literal|"char"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
operator|*
name|type
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|non_empty
condition|)
name|string_append
argument_list|(
name|result
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|result
argument_list|,
literal|"long double"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
operator|*
name|type
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|non_empty
condition|)
name|string_append
argument_list|(
name|result
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|result
argument_list|,
literal|"double"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
operator|*
name|type
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|non_empty
condition|)
name|string_append
argument_list|(
name|result
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|result
argument_list|,
literal|"float"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'G'
case|:
operator|*
name|type
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
operator|*
name|type
argument_list|)
condition|)
block|{
name|success
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* fall through */
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
name|n
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|n
operator|*=
literal|10
expr_stmt|;
name|n
operator|+=
operator|*
operator|*
name|type
operator|-
literal|'0'
expr_stmt|;
operator|*
name|type
operator|+=
literal|1
expr_stmt|;
block|}
do|while
condition|(
name|isdigit
argument_list|(
operator|*
operator|*
name|type
argument_list|)
condition|)
do|;
if|if
condition|(
name|strlen
argument_list|(
operator|*
name|type
argument_list|)
operator|<
name|n
condition|)
block|{
name|success
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|non_empty
condition|)
name|string_append
argument_list|(
name|result
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|string_appendn
argument_list|(
name|result
argument_list|,
operator|*
name|type
argument_list|,
name|n
argument_list|)
expr_stmt|;
operator|*
name|type
operator|+=
name|n
expr_stmt|;
break|break;
default|default:
name|success
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
operator|!
name|string_empty
argument_list|(
operator|&
name|decl
argument_list|)
condition|)
block|{
name|string_append
argument_list|(
name|result
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|string_appends
argument_list|(
name|result
argument_list|,
operator|&
name|decl
argument_list|)
expr_stmt|;
block|}
name|string_delete
argument_list|(
operator|&
name|decl
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
block|{
name|string_delete
argument_list|(
operator|&
name|decl
argument_list|)
expr_stmt|;
name|string_delete
argument_list|(
name|result
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* `result' will be initialised in do_type; it will be freed on failure */
end_comment

begin_function
specifier|static
name|int
name|do_arg
parameter_list|(
name|type
parameter_list|,
name|result
parameter_list|)
specifier|const
name|char
modifier|*
modifier|*
name|type
decl_stmt|;
name|string
modifier|*
name|result
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|start
init|=
operator|*
name|type
decl_stmt|;
if|if
condition|(
operator|!
name|do_type
argument_list|(
name|type
argument_list|,
name|result
argument_list|)
condition|)
return|return
literal|0
return|;
name|remember_type
argument_list|(
name|start
argument_list|,
operator|*
name|type
operator|-
name|start
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|remember_type
parameter_list|(
name|start
parameter_list|,
name|len
parameter_list|)
specifier|const
name|char
modifier|*
name|start
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|char
modifier|*
name|tem
decl_stmt|;
if|if
condition|(
name|ntypes
operator|>=
name|typevec_size
condition|)
block|{
if|if
condition|(
name|typevec_size
operator|==
literal|0
condition|)
block|{
name|typevec_size
operator|=
literal|3
expr_stmt|;
name|typevec
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
name|typevec_size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|typevec_size
operator|*=
literal|2
expr_stmt|;
name|typevec
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|typevec
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
name|typevec_size
argument_list|)
expr_stmt|;
block|}
block|}
name|tem
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|tem
argument_list|,
name|start
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|tem
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|typevec
index|[
name|ntypes
operator|++
index|]
operator|=
name|tem
expr_stmt|;
block|}
end_function

begin_comment
comment|/* `decl' must be already initialised, usually non-empty;    it won't be freed on failure */
end_comment

begin_function
specifier|static
name|int
name|do_args
parameter_list|(
name|type
parameter_list|,
name|decl
parameter_list|)
specifier|const
name|char
modifier|*
modifier|*
name|type
decl_stmt|;
name|string
modifier|*
name|decl
decl_stmt|;
block|{
name|string
name|arg
decl_stmt|;
name|int
name|need_comma
init|=
literal|0
decl_stmt|;
name|string_append
argument_list|(
name|decl
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
operator|*
name|type
operator|!=
literal|'_'
operator|&&
operator|*
operator|*
name|type
operator|!=
literal|'\0'
operator|&&
operator|*
operator|*
name|type
operator|!=
literal|'e'
operator|&&
operator|*
operator|*
name|type
operator|!=
literal|'v'
condition|)
block|{
if|if
condition|(
operator|*
operator|*
name|type
operator|==
literal|'N'
condition|)
block|{
name|int
name|r
decl_stmt|;
name|int
name|t
decl_stmt|;
operator|*
name|type
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|get_count
argument_list|(
name|type
argument_list|,
operator|&
name|r
argument_list|)
operator|||
operator|!
name|get_count
argument_list|(
name|type
argument_list|,
operator|&
name|t
argument_list|)
operator|||
name|t
operator|>=
name|ntypes
condition|)
return|return
literal|0
return|;
while|while
condition|(
operator|--
name|r
operator|>=
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|tem
init|=
name|typevec
index|[
name|t
index|]
decl_stmt|;
if|if
condition|(
name|need_comma
condition|)
name|string_append
argument_list|(
name|decl
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|do_arg
argument_list|(
operator|&
name|tem
argument_list|,
operator|&
name|arg
argument_list|)
condition|)
return|return
literal|0
return|;
name|string_appends
argument_list|(
name|decl
argument_list|,
operator|&
name|arg
argument_list|)
expr_stmt|;
name|string_delete
argument_list|(
operator|&
name|arg
argument_list|)
expr_stmt|;
name|need_comma
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|need_comma
condition|)
name|string_append
argument_list|(
name|decl
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|do_arg
argument_list|(
name|type
argument_list|,
operator|&
name|arg
argument_list|)
condition|)
return|return
literal|0
return|;
name|string_appends
argument_list|(
name|decl
argument_list|,
operator|&
name|arg
argument_list|)
expr_stmt|;
name|string_delete
argument_list|(
operator|&
name|arg
argument_list|)
expr_stmt|;
name|need_comma
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|*
operator|*
name|type
operator|==
literal|'v'
condition|)
operator|*
name|type
operator|+=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
operator|*
name|type
operator|==
literal|'e'
condition|)
block|{
operator|*
name|type
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|need_comma
condition|)
name|string_append
argument_list|(
name|decl
argument_list|,
literal|","
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|decl
argument_list|,
literal|"..."
argument_list|)
expr_stmt|;
block|}
name|string_append
argument_list|(
name|decl
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|munge_function_name
parameter_list|(
name|name
parameter_list|)
name|string
modifier|*
name|name
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|string_empty
argument_list|(
name|name
argument_list|)
operator|&&
name|name
operator|->
name|p
operator|-
name|name
operator|->
name|b
operator|>=
literal|3
operator|&&
name|name
operator|->
name|b
index|[
literal|0
index|]
operator|==
literal|'o'
operator|&&
name|name
operator|->
name|b
index|[
literal|1
index|]
operator|==
literal|'p'
operator|&&
name|name
operator|->
name|b
index|[
literal|2
index|]
operator|==
literal|'$'
condition|)
block|{
name|int
name|i
decl_stmt|;
comment|/* see if it's an assignment expression */
if|if
condition|(
name|name
operator|->
name|p
operator|-
name|name
operator|->
name|b
operator|>=
literal|10
comment|/* op$assign_ */
operator|&&
name|memcmp
argument_list|(
name|name
operator|->
name|b
operator|+
literal|3
argument_list|,
literal|"assign_"
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|optable
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|optable
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|int
name|len
init|=
name|name
operator|->
name|p
operator|-
name|name
operator|->
name|b
operator|-
literal|10
decl_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|optable
index|[
name|i
index|]
operator|.
name|in
argument_list|)
operator|==
name|len
operator|&&
name|memcmp
argument_list|(
name|optable
index|[
name|i
index|]
operator|.
name|in
argument_list|,
name|name
operator|->
name|b
operator|+
literal|10
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
block|{
name|string_clear
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|name
argument_list|,
literal|"operator"
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|name
argument_list|,
name|optable
index|[
name|i
index|]
operator|.
name|out
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|name
argument_list|,
literal|"="
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|optable
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|optable
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|int
name|len
init|=
name|name
operator|->
name|p
operator|-
name|name
operator|->
name|b
operator|-
literal|3
decl_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|optable
index|[
name|i
index|]
operator|.
name|in
argument_list|)
operator|==
name|len
operator|&&
name|memcmp
argument_list|(
name|optable
index|[
name|i
index|]
operator|.
name|in
argument_list|,
name|name
operator|->
name|b
operator|+
literal|3
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
block|{
name|string_clear
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|name
argument_list|,
literal|"operator"
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|name
argument_list|,
name|optable
index|[
name|i
index|]
operator|.
name|out
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
return|return;
block|}
elseif|else
if|if
condition|(
operator|!
name|string_empty
argument_list|(
name|name
argument_list|)
operator|&&
name|name
operator|->
name|p
operator|-
name|name
operator|->
name|b
operator|>=
literal|5
operator|&&
name|memcmp
argument_list|(
name|name
operator|->
name|b
argument_list|,
literal|"type$"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* type conversion operator */
name|string
name|type
decl_stmt|;
specifier|const
name|char
modifier|*
name|tem
init|=
name|name
operator|->
name|b
operator|+
literal|5
decl_stmt|;
if|if
condition|(
name|do_type
argument_list|(
operator|&
name|tem
argument_list|,
operator|&
name|type
argument_list|)
condition|)
block|{
name|string_clear
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|name
argument_list|,
literal|"operator "
argument_list|)
expr_stmt|;
name|string_appends
argument_list|(
name|name
argument_list|,
operator|&
name|type
argument_list|)
expr_stmt|;
name|string_delete
argument_list|(
operator|&
name|type
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
end_function

begin_comment
comment|/* a mini string-handling package */
end_comment

begin_function
specifier|static
name|void
name|string_need
parameter_list|(
name|s
parameter_list|,
name|n
parameter_list|)
name|string
modifier|*
name|s
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
if|if
condition|(
name|s
operator|->
name|b
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|n
operator|<
literal|32
condition|)
name|n
operator|=
literal|32
expr_stmt|;
name|s
operator|->
name|p
operator|=
name|s
operator|->
name|b
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|s
operator|->
name|e
operator|=
name|s
operator|->
name|b
operator|+
name|n
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
operator|->
name|e
operator|-
name|s
operator|->
name|p
operator|<
name|n
condition|)
block|{
name|int
name|tem
init|=
name|s
operator|->
name|p
operator|-
name|s
operator|->
name|b
decl_stmt|;
name|n
operator|+=
name|tem
expr_stmt|;
name|n
operator|*=
literal|2
expr_stmt|;
name|s
operator|->
name|b
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|s
operator|->
name|b
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|s
operator|->
name|p
operator|=
name|s
operator|->
name|b
operator|+
name|tem
expr_stmt|;
name|s
operator|->
name|e
operator|=
name|s
operator|->
name|b
operator|+
name|n
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|string_delete
parameter_list|(
name|s
parameter_list|)
name|string
modifier|*
name|s
decl_stmt|;
block|{
if|if
condition|(
name|s
operator|->
name|b
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|s
operator|->
name|b
argument_list|)
expr_stmt|;
name|s
operator|->
name|b
operator|=
name|s
operator|->
name|e
operator|=
name|s
operator|->
name|p
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|string_init
parameter_list|(
name|s
parameter_list|)
name|string
modifier|*
name|s
decl_stmt|;
block|{
name|s
operator|->
name|b
operator|=
name|s
operator|->
name|p
operator|=
name|s
operator|->
name|e
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|string_clear
parameter_list|(
name|s
parameter_list|)
name|string
modifier|*
name|s
decl_stmt|;
block|{
name|s
operator|->
name|p
operator|=
name|s
operator|->
name|b
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|string_empty
parameter_list|(
name|s
parameter_list|)
name|string
modifier|*
name|s
decl_stmt|;
block|{
return|return
name|s
operator|->
name|b
operator|==
name|s
operator|->
name|p
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|string_append
parameter_list|(
name|p
parameter_list|,
name|s
parameter_list|)
name|string
modifier|*
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|int
name|n
decl_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|*
name|s
operator|==
literal|'\0'
condition|)
return|return;
name|n
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|string_need
argument_list|(
name|p
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|p
operator|->
name|p
argument_list|,
name|s
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|p
operator|->
name|p
operator|+=
name|n
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|string_appends
parameter_list|(
name|p
parameter_list|,
name|s
parameter_list|)
name|string
modifier|*
name|p
decl_stmt|,
decl|*
name|s
decl_stmt|;
end_function

begin_block
block|{
name|int
name|n
decl_stmt|;
if|if
condition|(
name|s
operator|->
name|b
operator|==
name|s
operator|->
name|p
condition|)
return|return;
name|n
operator|=
name|s
operator|->
name|p
operator|-
name|s
operator|->
name|b
expr_stmt|;
name|string_need
argument_list|(
name|p
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|p
operator|->
name|p
argument_list|,
name|s
operator|->
name|b
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|p
operator|->
name|p
operator|+=
name|n
expr_stmt|;
block|}
end_block

begin_function
specifier|static
name|void
name|string_appendn
parameter_list|(
name|p
parameter_list|,
name|s
parameter_list|,
name|n
parameter_list|)
name|string
modifier|*
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
if|if
condition|(
name|n
operator|==
literal|0
condition|)
return|return;
name|string_need
argument_list|(
name|p
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|p
operator|->
name|p
argument_list|,
name|s
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|p
operator|->
name|p
operator|+=
name|n
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|string_prepend
parameter_list|(
name|p
parameter_list|,
name|s
parameter_list|)
name|string
modifier|*
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
block|{
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|*
name|s
operator|==
literal|'\0'
condition|)
return|return;
name|string_prependn
argument_list|(
name|p
argument_list|,
name|s
argument_list|,
name|strlen
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static void string_prepends (p, s)      string *p, *s; {   if (s->b == s->p)     return;   string_prependn (p, s->b, s->p - s->b); }
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|string_prependn
parameter_list|(
name|p
parameter_list|,
name|s
parameter_list|,
name|n
parameter_list|)
name|string
modifier|*
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
name|char
modifier|*
name|q
decl_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
return|return;
name|string_need
argument_list|(
name|p
argument_list|,
name|n
argument_list|)
expr_stmt|;
for|for
control|(
name|q
operator|=
name|p
operator|->
name|p
operator|-
literal|1
init|;
name|q
operator|>=
name|p
operator|->
name|b
condition|;
name|q
operator|--
control|)
name|q
index|[
name|n
index|]
operator|=
name|q
index|[
literal|0
index|]
expr_stmt|;
name|memcpy
argument_list|(
name|p
operator|->
name|b
argument_list|,
name|s
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|p
operator|->
name|p
operator|+=
name|n
expr_stmt|;
block|}
end_function

end_unit

