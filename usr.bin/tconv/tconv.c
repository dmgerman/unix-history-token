begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * tconv.c  *  * Ross Ridge  * Public Domain  * 92/02/01 07:30:23  *  * tconv [-b] [-c [-OUGd]] [-i] [-B [-D dir]] [-I] [-k] [-V] [-t term] [file]  *  * -c		convert from termcap  * -i		convert from terminfo source  * -b		convert from terminfo binary  * -B		convert to terminfo binary  * -I		convert to terminfo source  * -V		print version info  *  * The following switches are available when converting from termcap:  * -d		don't supply any defaults for missing capabilities  * -O		include obsolete termcap capabilities  * -G		include GNU capabilities  * -U		include UW capabilities  *  * -k		keep comments  * -D dir	directory to put terminfo binaries in  *  * -t term	name of terminal to translate  * file		filename of termcap/terminfo database to use  *  * If a file is specifed and no terminal is given the entire file we be  * translated.  * If no terminal and no file is specified then the terminal name will be  * taken from the environment variable TERM.  * Unless compiling to a terminfo binary, output is to stdout.  *  */
end_comment

begin_define
define|#
directive|define
name|NOTLIB
end_define

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_define
define|#
directive|define
name|SINGLE
end_define

begin_include
include|#
directive|include
file|<term.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|USE_STDDEF
end_ifdef

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|__FreeBSD__
end_ifndef

begin_include
include|#
directive|include
file|"strtok.c"
end_include

begin_include
include|#
directive|include
file|"mkdir.c"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|SCCSid
index|[]
init|=
literal|"@(#) mytinfo tconv.c 3.2 92/02/01 public domain, By Ross Ridge"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the right margin of the output */
end_comment

begin_define
define|#
directive|define
name|LINELEN
value|76
end_define

begin_decl_stmt
name|struct
name|term_path
modifier|*
name|path
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* returned from _buildpath */
end_comment

begin_decl_stmt
name|TERMINAL
name|_term_buf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|buf
index|[
name|MAX_BUF
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* buffer for the termcap entry */
end_comment

begin_decl_stmt
name|int
name|noOT
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -O */
end_comment

begin_decl_stmt
name|int
name|noGNU
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -G */
end_comment

begin_decl_stmt
name|int
name|noUW
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -W */
end_comment

begin_decl_stmt
name|int
name|dodefault
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -d */
end_comment

begin_decl_stmt
name|int
name|keepcomments
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -k */
end_comment

begin_decl_stmt
name|int
name|compile
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -B */
end_comment

begin_decl_stmt
name|int
name|from_tcap
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -c */
end_comment

begin_decl_stmt
name|int
name|from_tinfo
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -i */
end_comment

begin_decl_stmt
name|int
name|from_tbin
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -b */
end_comment

begin_decl_stmt
name|char
modifier|*
name|directory
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -D */
end_comment

begin_decl_stmt
name|int
name|continued
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|termcap
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|lineno
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current line number */
end_comment

begin_comment
comment|/* print the first part of a warning message */
end_comment

begin_function
name|void
name|warn
parameter_list|()
block|{
if|if
condition|(
name|lineno
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"warning: "
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"(%s)%d: warning: "
argument_list|,
name|_term_buf
operator|.
name|name_long
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* output a string indenting at the beginning of a line, and wraping  * at the right margin.  */
end_comment

begin_function
name|void
name|putstr
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
specifier|static
name|pos
operator|=
literal|0
expr_stmt|;
name|int
name|l
decl_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|pos
operator|!=
literal|0
condition|)
block|{
name|pos
operator|=
literal|0
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|termcap
operator|&&
name|noOT
operator|&&
operator|*
name|s
operator|==
literal|'O'
condition|)
return|return;
if|if
condition|(
name|termcap
operator|&&
name|noGNU
operator|&&
operator|*
name|s
operator|==
literal|'G'
condition|)
return|return;
if|if
condition|(
name|termcap
operator|&&
name|noUW
operator|&&
operator|*
name|s
operator|==
literal|'U'
condition|)
return|return;
name|l
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|2
expr_stmt|;
if|if
condition|(
name|l
operator|+
name|pos
operator|>
name|LINELEN
operator|&&
name|pos
operator|!=
literal|0
condition|)
block|{
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|pos
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|pos
operator|==
literal|0
condition|)
block|{
name|putchar
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
name|pos
operator|=
literal|8
expr_stmt|;
block|}
else|else
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s,"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|pos
operator|+=
name|l
expr_stmt|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|MAX_PUSHED
end_ifndef

begin_comment
comment|/* maximum # of parameters that can be pushed onto the stack */
end_comment

begin_define
define|#
directive|define
name|MAX_PUSHED
value|16
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|stack
index|[
name|MAX_PUSHED
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the stack */
end_comment

begin_decl_stmt
name|int
name|stackptr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the next empty place on the stack */
end_comment

begin_decl_stmt
name|int
name|onstack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the top of stack */
end_comment

begin_decl_stmt
name|int
name|seenm
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* seen a %m */
end_comment

begin_decl_stmt
name|int
name|seenn
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* seen a %n */
end_comment

begin_decl_stmt
name|int
name|seenr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* seen a %r */
end_comment

begin_decl_stmt
name|int
name|param
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current parameter */
end_comment

begin_decl_stmt
name|char
modifier|*
name|dp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pointer to the end of the converted string */
end_comment

begin_comment
comment|/* push onstack on to the stack */
end_comment

begin_function
name|void
name|push
parameter_list|()
block|{
if|if
condition|(
name|stackptr
operator|>
name|MAX_PUSHED
condition|)
block|{
name|warn
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"string to complex to covert\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|stack
index|[
name|stackptr
operator|++
index|]
operator|=
name|onstack
expr_stmt|;
block|}
end_function

begin_comment
comment|/* pop the top of the stack into onstack */
end_comment

begin_function
name|void
name|pop
parameter_list|()
block|{
if|if
condition|(
name|stackptr
operator|==
literal|0
condition|)
if|if
condition|(
name|onstack
operator|==
literal|0
condition|)
block|{
name|warn
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"I'm confused\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|onstack
operator|=
literal|0
expr_stmt|;
else|else
name|onstack
operator|=
name|stack
index|[
operator|--
name|stackptr
index|]
expr_stmt|;
name|param
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* convert a character to a terminfo push */
end_comment

begin_function
specifier|static
name|int
name|cvtchar
parameter_list|(
name|sp
parameter_list|)
specifier|register
name|char
modifier|*
name|sp
decl_stmt|;
block|{
name|char
name|c
decl_stmt|;
name|int
name|l
decl_stmt|;
switch|switch
condition|(
operator|*
name|sp
condition|)
block|{
case|case
literal|'\\'
case|:
switch|switch
condition|(
operator|*
operator|++
name|sp
condition|)
block|{
case|case
literal|'\''
case|:
case|case
literal|'$'
case|:
case|case
literal|'\\'
case|:
case|case
literal|'%'
case|:
name|c
operator|=
operator|*
name|sp
expr_stmt|;
name|l
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'\0'
case|:
name|c
operator|=
literal|'\\'
expr_stmt|;
name|l
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
if|if
condition|(
name|sp
index|[
literal|1
index|]
operator|==
literal|'0'
operator|&&
name|sp
index|[
literal|2
index|]
operator|==
literal|'0'
condition|)
block|{
name|c
operator|=
literal|'\0'
expr_stmt|;
name|l
operator|=
literal|4
expr_stmt|;
block|}
else|else
block|{
name|c
operator|=
literal|'\200'
expr_stmt|;
comment|/* '\0' ???? */
name|l
operator|=
literal|2
expr_stmt|;
block|}
break|break;
default|default:
name|c
operator|=
operator|*
name|sp
expr_stmt|;
name|l
operator|=
literal|2
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|c
operator|=
operator|*
name|sp
expr_stmt|;
name|l
operator|=
literal|1
expr_stmt|;
block|}
name|c
operator|&=
literal|0177
expr_stmt|;
if|if
condition|(
name|isgraph
argument_list|(
name|c
argument_list|)
operator|&&
name|c
operator|!=
literal|','
operator|&&
name|c
operator|!=
literal|'\''
operator|&&
name|c
operator|!=
literal|'\\'
operator|&&
name|c
operator|!=
literal|':'
condition|)
block|{
operator|*
name|dp
operator|++
operator|=
literal|'%'
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
literal|'\''
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
name|c
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
literal|'\''
expr_stmt|;
block|}
else|else
block|{
operator|*
name|dp
operator|++
operator|=
literal|'%'
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
literal|'{'
expr_stmt|;
if|if
condition|(
name|c
operator|>
literal|99
condition|)
operator|*
name|dp
operator|++
operator|=
name|c
operator|/
literal|100
operator|+
literal|'0'
expr_stmt|;
if|if
condition|(
name|c
operator|>
literal|9
condition|)
operator|*
name|dp
operator|++
operator|=
operator|(
name|c
operator|/
literal|10
operator|)
operator|%
literal|10
operator|+
literal|'0'
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
name|c
operator|%
literal|10
operator|+
literal|'0'
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
literal|'}'
expr_stmt|;
block|}
return|return
name|l
return|;
block|}
end_function

begin_comment
comment|/* push n copies of param on the terminfo stack if not already there */
end_comment

begin_function
name|void
name|getparm
parameter_list|(
name|parm
parameter_list|,
name|n
parameter_list|)
name|int
name|parm
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
if|if
condition|(
name|seenr
condition|)
block|{
if|if
condition|(
name|parm
operator|==
literal|1
condition|)
name|parm
operator|=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|parm
operator|==
literal|2
condition|)
name|parm
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|onstack
operator|==
name|parm
condition|)
block|{
if|if
condition|(
name|n
operator|>
literal|1
condition|)
block|{
name|warn
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"string may not be optimal"
argument_list|)
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
literal|'%'
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
literal|'P'
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
literal|'a'
expr_stmt|;
while|while
condition|(
name|n
operator|--
condition|)
block|{
operator|*
name|dp
operator|++
operator|=
literal|'%'
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
literal|'g'
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
literal|'a'
expr_stmt|;
block|}
block|}
return|return;
block|}
if|if
condition|(
name|onstack
operator|!=
literal|0
condition|)
name|push
argument_list|()
expr_stmt|;
name|onstack
operator|=
name|parm
expr_stmt|;
while|while
condition|(
name|n
operator|--
condition|)
block|{
comment|/* %p0 */
operator|*
name|dp
operator|++
operator|=
literal|'%'
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
literal|'p'
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
literal|'0'
operator|+
name|parm
expr_stmt|;
block|}
if|if
condition|(
name|seenn
operator|&&
name|parm
operator|<
literal|3
condition|)
block|{
comment|/* %{96}%^ */
operator|*
name|dp
operator|++
operator|=
literal|'%'
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
literal|'{'
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
literal|'9'
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
literal|'6'
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
literal|'}'
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
literal|'%'
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
literal|'^'
expr_stmt|;
block|}
if|if
condition|(
name|seenm
operator|&&
name|parm
operator|<
literal|3
condition|)
block|{
comment|/* %{127}%^ */
operator|*
name|dp
operator|++
operator|=
literal|'%'
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
literal|'{'
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
literal|'1'
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
literal|'2'
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
literal|'7'
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
literal|'}'
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
literal|'%'
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
literal|'^'
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* convert a string to terminfo format */
end_comment

begin_function
name|char
modifier|*
name|convstr
parameter_list|(
name|s
parameter_list|,
name|i
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|i
decl_stmt|;
block|{
specifier|static
name|char
name|line
index|[
name|MAX_LINE
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|cap
decl_stmt|;
name|int
name|nocode
init|=
literal|0
decl_stmt|;
name|stackptr
operator|=
literal|0
expr_stmt|;
name|onstack
operator|=
literal|0
expr_stmt|;
name|seenm
operator|=
literal|0
expr_stmt|;
name|seenn
operator|=
literal|0
expr_stmt|;
name|seenr
operator|=
literal|0
expr_stmt|;
name|param
operator|=
literal|1
expr_stmt|;
name|dp
operator|=
name|line
expr_stmt|;
name|cap
operator|=
name|strnames
index|[
name|i
index|]
expr_stmt|;
if|#
directive|if
literal|0
block|if (cap[0] == 'k' 	    || ((cap[0] == 'i' || cap[0] == 'r')&& cap[1] == 's'&& (cap[2] == '1' || cap[2] == '2' || cap[2] == '3')))
comment|/* if (k.* || [ir]s[123]) */
block|nocode = 1;
else|#
directive|else
if|if
condition|(
name|_strflags
index|[
name|i
index|]
operator|!=
literal|'G'
condition|)
name|nocode
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|nocode
condition|)
block|{
name|char
modifier|*
name|d
init|=
name|s
decl_stmt|;
while|while
condition|(
operator|*
name|s
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|s
index|[
literal|0
index|]
operator|==
literal|'\\'
operator|&&
name|s
index|[
literal|1
index|]
operator|!=
literal|'\0'
condition|)
name|s
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|s
index|[
literal|0
index|]
operator|==
literal|'%'
operator|&&
name|s
index|[
literal|1
index|]
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'p'
condition|)
block|{
if|if
condition|(
name|termcap
condition|)
block|{
name|warn
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"string '%s' already in terminfo format\n"
argument_list|,
name|strcodes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|nocode
operator|=
literal|1
expr_stmt|;
break|break;
block|}
else|else
name|nocode
operator|=
literal|1
expr_stmt|;
block|}
name|s
operator|++
expr_stmt|;
block|}
name|s
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|nocode
operator|&&
operator|!
name|termcap
condition|)
block|{
name|warn
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"string '%s' not in terminfo format, converting...\n"
argument_list|,
name|cap
argument_list|)
expr_stmt|;
block|}
name|s
operator|=
name|d
expr_stmt|;
block|}
while|while
condition|(
operator|*
name|s
operator|!=
literal|'\0'
condition|)
block|{
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|'%'
case|:
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|nocode
condition|)
block|{
operator|*
name|dp
operator|++
operator|=
literal|'%'
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
operator|*
name|s
operator|++
condition|)
block|{
case|case
literal|'%'
case|:
operator|*
name|dp
operator|++
operator|=
literal|'%'
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
if|if
condition|(
name|seenr
operator|++
operator|==
literal|1
condition|)
block|{
name|warn
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"seen %%r twice\n"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'m'
case|:
if|if
condition|(
name|seenm
operator|++
operator|==
literal|1
condition|)
block|{
name|warn
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"seen %%m twice\n"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'n'
case|:
if|if
condition|(
name|seenn
operator|++
operator|==
literal|1
condition|)
block|{
name|warn
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"seen %%n twice\n"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'i'
case|:
operator|*
name|dp
operator|++
operator|=
literal|'%'
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
literal|'i'
expr_stmt|;
break|break;
case|case
literal|'6'
case|:
case|case
literal|'B'
case|:
name|getparm
argument_list|(
name|param
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* %{6}%*%+ */
operator|*
name|dp
operator|++
operator|=
literal|'%'
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
literal|'{'
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
literal|'6'
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
literal|'}'
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
literal|'%'
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
literal|'*'
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
literal|'%'
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
literal|'+'
expr_stmt|;
break|break;
case|case
literal|'8'
case|:
case|case
literal|'D'
case|:
name|getparm
argument_list|(
name|param
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* %{2}%*%- */
operator|*
name|dp
operator|++
operator|=
literal|'%'
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
literal|'{'
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
literal|'2'
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
literal|'}'
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
literal|'%'
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
literal|'*'
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
literal|'%'
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
literal|'-'
expr_stmt|;
break|break;
case|case
literal|'>'
case|:
name|getparm
argument_list|(
name|param
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* %?%{x}%>%t%{y}%+%; */
operator|*
name|dp
operator|++
operator|=
literal|'%'
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
literal|'?'
expr_stmt|;
name|s
operator|+=
name|cvtchar
argument_list|(
name|s
argument_list|)
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
literal|'%'
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
literal|'>'
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
literal|'%'
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
literal|'t'
expr_stmt|;
name|s
operator|+=
name|cvtchar
argument_list|(
name|s
argument_list|)
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
literal|'%'
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
literal|'+'
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
literal|'%'
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
literal|';'
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
if|if
condition|(
operator|(
operator|*
name|s
operator|==
literal|'='
operator|||
operator|*
name|s
operator|==
literal|'+'
operator|||
operator|*
name|s
operator|==
literal|'-'
operator|||
operator|*
name|s
operator|==
literal|'*'
operator|||
operator|*
name|s
operator|==
literal|'/'
operator|)
operator|&&
operator|(
name|s
index|[
literal|1
index|]
operator|==
literal|'p'
operator|||
name|s
index|[
literal|1
index|]
operator|==
literal|'c'
operator|)
operator|&&
name|s
index|[
literal|2
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|int
name|l
decl_stmt|;
name|l
operator|=
literal|2
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|!=
literal|'='
condition|)
name|getparm
argument_list|(
name|param
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'p'
condition|)
block|{
name|getparm
argument_list|(
name|param
operator|+
name|s
index|[
literal|2
index|]
operator|-
literal|'@'
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|param
operator|!=
name|onstack
condition|)
block|{
name|pop
argument_list|()
expr_stmt|;
name|param
operator|--
expr_stmt|;
block|}
name|l
operator|++
expr_stmt|;
block|}
else|else
name|l
operator|+=
name|cvtchar
argument_list|(
name|s
operator|+
literal|2
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|'+'
case|:
operator|*
name|dp
operator|++
operator|=
literal|'%'
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
literal|'+'
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
operator|*
name|dp
operator|++
operator|=
literal|'%'
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
literal|'-'
expr_stmt|;
break|break;
case|case
literal|'*'
case|:
operator|*
name|dp
operator|++
operator|=
literal|'%'
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
literal|'*'
expr_stmt|;
break|break;
case|case
literal|'/'
case|:
operator|*
name|dp
operator|++
operator|=
literal|'%'
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
literal|'/'
expr_stmt|;
break|break;
case|case
literal|'='
case|:
if|if
condition|(
name|seenr
condition|)
if|if
condition|(
name|param
operator|==
literal|1
condition|)
name|onstack
operator|=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|param
operator|==
literal|2
condition|)
name|onstack
operator|=
literal|1
expr_stmt|;
else|else
name|onstack
operator|=
name|param
expr_stmt|;
else|else
name|onstack
operator|=
name|param
expr_stmt|;
break|break;
block|}
name|s
operator|+=
name|l
expr_stmt|;
break|break;
block|}
name|getparm
argument_list|(
name|param
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|s
operator|+=
name|cvtchar
argument_list|(
name|s
argument_list|)
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
literal|'%'
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
literal|'+'
expr_stmt|;
break|break;
case|case
literal|'+'
case|:
name|getparm
argument_list|(
name|param
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|s
operator|+=
name|cvtchar
argument_list|(
name|s
argument_list|)
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
literal|'%'
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
literal|'+'
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
literal|'%'
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
literal|'c'
expr_stmt|;
name|pop
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|s
operator|+=
name|cvtchar
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|getparm
argument_list|(
name|param
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
literal|'%'
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
literal|'-'
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
name|s
operator|+=
name|cvtchar
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|getparm
argument_list|(
name|param
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
literal|'%'
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
literal|'-'
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
literal|'%'
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
literal|'c'
expr_stmt|;
name|pop
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'.'
case|:
name|getparm
argument_list|(
name|param
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
literal|'%'
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
literal|'c'
expr_stmt|;
name|pop
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'2'
case|:
name|getparm
argument_list|(
name|param
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
literal|'%'
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
literal|'0'
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
literal|'2'
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
literal|'d'
expr_stmt|;
name|pop
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'3'
case|:
name|getparm
argument_list|(
name|param
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
literal|'%'
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
literal|'0'
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
literal|'3'
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
literal|'d'
expr_stmt|;
name|pop
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|getparm
argument_list|(
name|param
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
literal|'%'
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
literal|'d'
expr_stmt|;
name|pop
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|param
operator|++
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|param
operator|--
expr_stmt|;
break|break;
default|default:
name|warn
argument_list|()
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
literal|'%'
expr_stmt|;
name|s
operator|--
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"'%s' unknown %% code %c"
argument_list|,
name|strcodes
index|[
name|i
index|]
argument_list|,
operator|*
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|>=
literal|0
operator|&&
operator|*
name|s
operator|<
literal|32
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"^%c\n"
argument_list|,
operator|*
name|s
operator|+
literal|'@'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|s
operator|<
literal|0
operator|||
operator|*
name|s
operator|>=
literal|127
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\\%03o\n"
argument_list|,
operator|*
name|s
operator|&
literal|0377
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%c\n"
argument_list|,
operator|*
name|s
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'\\'
case|:
if|if
condition|(
operator|!
name|compile
condition|)
block|{
operator|*
name|dp
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
break|break;
block|}
comment|/* FALLTHROUGH */
case|case
literal|'\n'
case|:
if|if
condition|(
operator|!
name|compile
condition|)
block|{
operator|*
name|dp
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
literal|'n'
expr_stmt|;
name|s
operator|++
expr_stmt|;
break|break;
block|}
comment|/* FALLTHROUGH */
case|case
literal|'\t'
case|:
if|if
condition|(
operator|!
name|compile
condition|)
block|{
operator|*
name|dp
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
literal|'t'
expr_stmt|;
name|s
operator|++
expr_stmt|;
break|break;
block|}
comment|/* FALLTHROUGH */
case|case
literal|'\r'
case|:
if|if
condition|(
operator|!
name|compile
condition|)
block|{
operator|*
name|dp
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
literal|'r'
expr_stmt|;
name|s
operator|++
expr_stmt|;
break|break;
block|}
comment|/* FALLTHROUGH */
case|case
literal|'\200'
case|:
if|if
condition|(
operator|!
name|compile
condition|)
block|{
operator|*
name|dp
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
literal|'0'
expr_stmt|;
name|s
operator|++
expr_stmt|;
break|break;
block|}
comment|/* FALLTHROUGH */
case|case
literal|'\f'
case|:
if|if
condition|(
operator|!
name|compile
condition|)
block|{
operator|*
name|dp
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
literal|'f'
expr_stmt|;
name|s
operator|++
expr_stmt|;
break|break;
block|}
comment|/* FALLTHROUGH */
case|case
literal|'\b'
case|:
if|if
condition|(
operator|!
name|compile
condition|)
block|{
operator|*
name|dp
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
literal|'b'
expr_stmt|;
name|s
operator|++
expr_stmt|;
break|break;
block|}
comment|/* FALLTHROUGH */
case|case
literal|' '
case|:
if|if
condition|(
operator|!
name|compile
condition|)
block|{
operator|*
name|dp
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
literal|'s'
expr_stmt|;
name|s
operator|++
expr_stmt|;
break|break;
block|}
comment|/* FALLTHROUGH */
case|case
literal|'^'
case|:
if|if
condition|(
operator|!
name|compile
condition|)
block|{
operator|*
name|dp
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
literal|'^'
expr_stmt|;
name|s
operator|++
expr_stmt|;
break|break;
block|}
comment|/* FALLTHROUGH */
case|case
literal|':'
case|:
if|if
condition|(
operator|!
name|compile
condition|)
block|{
operator|*
name|dp
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
literal|':'
expr_stmt|;
name|s
operator|++
expr_stmt|;
break|break;
block|}
comment|/* FALLTHROUGH */
case|case
literal|','
case|:
if|if
condition|(
operator|!
name|compile
condition|)
block|{
operator|*
name|dp
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
literal|','
expr_stmt|;
name|s
operator|++
expr_stmt|;
break|break;
block|}
comment|/* FALLTHROUGH */
if|#
directive|if
literal|0
block|case '\'': 			if (!compile) {*dp++ = '\\'; *dp++ = '\''; s++; break;}
comment|/* FALLTHROUGH */
endif|#
directive|endif
default|default:
if|if
condition|(
name|compile
condition|)
operator|*
name|dp
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|s
operator|>
literal|0
operator|&&
operator|*
name|s
operator|<
literal|32
condition|)
block|{
operator|*
name|dp
operator|++
operator|=
literal|'^'
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
operator|*
name|s
operator|+
literal|'@'
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|s
operator|<=
literal|0
operator|||
operator|*
name|s
operator|>=
literal|127
condition|)
block|{
operator|*
name|dp
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
operator|(
operator|(
operator|*
name|s
operator|&
literal|0300
operator|)
operator|>>
literal|6
operator|)
operator|+
literal|'0'
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
operator|(
operator|(
operator|*
name|s
operator|&
literal|0070
operator|)
operator|>>
literal|3
operator|)
operator|+
literal|'0'
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
operator|(
operator|*
name|s
operator|&
literal|0007
operator|)
operator|+
literal|'0'
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
else|else
operator|*
name|dp
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
break|break;
block|}
block|}
operator|*
name|dp
operator|=
literal|'\0'
expr_stmt|;
return|return
name|line
return|;
block|}
end_function

begin_define
define|#
directive|define
name|LSB
parameter_list|(
name|n
parameter_list|)
value|((unsigned) (n)& 0377)
end_define

begin_define
define|#
directive|define
name|MSB
parameter_list|(
name|n
parameter_list|)
value|(((unsigned) (n)>> 8)& 0377)
end_define

begin_function
name|void
name|writebin
parameter_list|(
name|fd
parameter_list|,
name|name
parameter_list|)
name|int
name|fd
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|static
name|char
name|bin
index|[
name|MAX_BUF
operator|+
literal|1
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|char
modifier|*
name|d
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|t
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
name|char
modifier|*
name|strtbl
decl_stmt|;
name|int
name|sz_name
decl_stmt|,
name|n_bools
decl_stmt|,
name|n_nums
decl_stmt|,
name|n_offs
decl_stmt|,
name|sz_strs
decl_stmt|;
specifier|extern
name|int
name|_boolorder
index|[]
decl_stmt|,
name|_numorder
index|[]
decl_stmt|,
name|_strorder
index|[]
decl_stmt|;
name|strncpy
argument_list|(
name|bin
operator|+
literal|12
argument_list|,
name|name
argument_list|,
literal|127
argument_list|)
expr_stmt|;
name|bin
index|[
literal|12
operator|+
literal|128
index|]
operator|=
literal|'\0'
expr_stmt|;
name|sz_name
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|sz_name
operator|>
literal|128
condition|)
name|sz_name
operator|=
literal|128
expr_stmt|;
name|s
operator|=
name|bin
operator|+
literal|12
operator|+
name|sz_name
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|_boolorder
index|[
name|i
index|]
operator|!=
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|_term_buf
operator|.
name|bools
index|[
name|i
index|]
condition|)
block|{
case|case
operator|-
literal|1
case|:
operator|*
name|s
operator|++
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|0
case|:
operator|*
name|s
operator|++
operator|=
literal|0377
expr_stmt|;
break|break;
default|default:
operator|*
name|s
operator|++
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
name|n_bools
operator|=
name|i
expr_stmt|;
if|if
condition|(
operator|(
name|sz_name
operator|+
name|n_bools
operator|)
operator|&
literal|1
condition|)
name|n_bools
operator|++
expr_stmt|;
name|s
operator|=
name|bin
operator|+
literal|12
operator|+
name|sz_name
operator|+
name|n_bools
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|_numorder
index|[
name|i
index|]
operator|!=
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|n
operator|=
name|_term_buf
operator|.
name|nums
index|[
name|_numorder
index|[
name|i
index|]
index|]
expr_stmt|;
switch|switch
condition|(
name|n
condition|)
block|{
case|case
operator|-
literal|2
case|:
operator|*
name|s
operator|++
operator|=
literal|0377
expr_stmt|;
operator|*
name|s
operator|++
operator|=
literal|0377
expr_stmt|;
break|break;
case|case
operator|-
literal|1
case|:
operator|*
name|s
operator|++
operator|=
literal|0376
expr_stmt|;
operator|*
name|s
operator|++
operator|=
literal|0377
expr_stmt|;
break|break;
default|default:
operator|*
name|s
operator|++
operator|=
name|LSB
argument_list|(
name|n
argument_list|)
expr_stmt|;
operator|*
name|s
operator|++
operator|=
name|MSB
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
block|}
name|n_nums
operator|=
name|i
expr_stmt|;
name|s
operator|=
name|bin
operator|+
literal|12
operator|+
name|sz_name
operator|+
name|n_bools
operator|+
name|n_nums
operator|*
literal|2
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|_strorder
index|[
name|i
index|]
operator|!=
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|_term_buf
operator|.
name|strs
index|[
name|_strorder
index|[
name|i
index|]
index|]
operator|==
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
block|{
operator|*
name|s
operator|++
operator|=
literal|0376
expr_stmt|;
operator|*
name|s
operator|++
operator|=
literal|0377
expr_stmt|;
block|}
else|else
block|{
operator|*
name|s
operator|++
operator|=
literal|0377
expr_stmt|;
operator|*
name|s
operator|++
operator|=
literal|0377
expr_stmt|;
block|}
block|}
name|n_offs
operator|=
name|i
expr_stmt|;
name|s
operator|=
name|bin
operator|+
literal|12
operator|+
name|sz_name
operator|+
name|n_bools
operator|+
name|n_nums
operator|*
literal|2
expr_stmt|;
name|strtbl
operator|=
name|d
operator|=
name|s
operator|+
name|n_offs
operator|*
literal|2
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|_strorder
index|[
name|i
index|]
operator|!=
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|t
operator|=
name|_term_buf
operator|.
name|strs
index|[
name|_strorder
index|[
name|i
index|]
index|]
expr_stmt|;
if|if
condition|(
name|t
operator|==
operator|(
name|char
operator|*
operator|)
operator|-
literal|1
operator|||
name|t
operator|==
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
name|s
operator|+=
literal|2
expr_stmt|;
else|else
block|{
name|n
operator|=
name|d
operator|-
name|strtbl
expr_stmt|;
operator|*
name|s
operator|++
operator|=
name|LSB
argument_list|(
name|n
argument_list|)
expr_stmt|;
operator|*
name|s
operator|++
operator|=
name|MSB
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|t
operator|=
name|convstr
argument_list|(
name|t
argument_list|,
name|_strorder
index|[
name|i
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|t
operator|!=
literal|'\0'
condition|)
block|{
operator|*
name|d
operator|++
operator|=
operator|*
name|t
operator|++
expr_stmt|;
if|if
condition|(
name|d
operator|>=
name|bin
operator|+
name|MAX_BUF
operator|-
literal|1
condition|)
block|{
name|warn
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"compiled entry to big\n"
argument_list|)
expr_stmt|;
operator|*
name|d
operator|++
operator|=
literal|'\0'
expr_stmt|;
goto|goto
name|toobig
goto|;
block|}
block|}
operator|*
name|d
operator|++
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
name|toobig
label|:
name|sz_strs
operator|=
name|d
operator|-
name|strtbl
expr_stmt|;
name|bin
index|[
literal|0
index|]
operator|=
literal|032
expr_stmt|;
name|bin
index|[
literal|1
index|]
operator|=
literal|01
expr_stmt|;
name|bin
index|[
literal|2
index|]
operator|=
name|LSB
argument_list|(
name|sz_name
argument_list|)
expr_stmt|;
name|bin
index|[
literal|3
index|]
operator|=
name|MSB
argument_list|(
name|sz_name
argument_list|)
expr_stmt|;
name|bin
index|[
literal|4
index|]
operator|=
name|LSB
argument_list|(
name|n_bools
argument_list|)
expr_stmt|;
name|bin
index|[
literal|5
index|]
operator|=
name|MSB
argument_list|(
name|n_bools
argument_list|)
expr_stmt|;
name|bin
index|[
literal|6
index|]
operator|=
name|LSB
argument_list|(
name|n_nums
argument_list|)
expr_stmt|;
name|bin
index|[
literal|7
index|]
operator|=
name|MSB
argument_list|(
name|n_nums
argument_list|)
expr_stmt|;
name|bin
index|[
literal|8
index|]
operator|=
name|LSB
argument_list|(
name|n_offs
argument_list|)
expr_stmt|;
name|bin
index|[
literal|9
index|]
operator|=
name|MSB
argument_list|(
name|n_offs
argument_list|)
expr_stmt|;
name|bin
index|[
literal|10
index|]
operator|=
name|LSB
argument_list|(
name|sz_strs
argument_list|)
expr_stmt|;
name|bin
index|[
literal|11
index|]
operator|=
name|MSB
argument_list|(
name|sz_strs
argument_list|)
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|fd
argument_list|,
name|bin
argument_list|,
name|d
operator|-
name|bin
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|quit
argument_list|(
name|errno
argument_list|,
literal|"can't write binary file"
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|find_directory
parameter_list|()
block|{
name|struct
name|term_path
modifier|*
name|p
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
if|if
condition|(
name|directory
operator|!=
name|NULL
condition|)
return|return;
name|p
operator|=
name|path
expr_stmt|;
while|while
condition|(
name|p
operator|->
name|type
operator|!=
operator|-
literal|1
operator|&&
name|p
operator|->
name|file
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|stat
argument_list|(
name|p
operator|->
name|file
argument_list|,
operator|&
name|st
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|st
operator|.
name|st_mode
operator|&
literal|0170000
operator|)
operator|==
literal|0040000
condition|)
block|{
name|directory
operator|=
name|p
operator|->
name|file
expr_stmt|;
return|return;
block|}
block|}
name|p
operator|++
expr_stmt|;
block|}
name|quit
argument_list|(
operator|-
literal|1
argument_list|,
literal|"can't find a terminfo directory"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* convert a terminal name to a binary filename */
end_comment

begin_function
name|char
modifier|*
name|binfile
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|static
name|char
name|line
index|[
name|MAX_LINE
operator|+
literal|1
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"%s/%c/%s"
argument_list|,
name|directory
argument_list|,
operator|*
name|name
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|line
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|bindir
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|static
name|char
name|line
index|[
name|MAX_LINE
operator|+
literal|1
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"%s/%c"
argument_list|,
name|directory
argument_list|,
operator|*
name|name
argument_list|)
expr_stmt|;
return|return
name|line
return|;
block|}
end_function

begin_function
name|int
name|badname
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
while|while
condition|(
operator|*
name|name
condition|)
block|{
if|if
condition|(
operator|*
name|name
operator|==
literal|'/'
operator|||
operator|!
name|isgraph
argument_list|(
operator|*
name|name
argument_list|)
condition|)
return|return
literal|1
return|;
name|name
operator|++
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* output a terminfo binary */
end_comment

begin_function
name|void
name|outputbin
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|d
decl_stmt|,
modifier|*
name|last
decl_stmt|;
name|char
name|tmp
index|[
name|MAX_LINE
operator|+
literal|1
index|]
decl_stmt|;
name|char
name|line
index|[
name|MAX_LINE
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|find_directory
argument_list|()
expr_stmt|;
name|s
operator|=
name|name
expr_stmt|;
name|d
operator|=
name|line
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|!=
literal|'\0'
operator|&&
name|d
operator|<
name|line
operator|+
name|MAX_LINE
condition|)
block|{
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|d
operator|>
name|line
operator|&&
name|d
index|[
operator|-
literal|1
index|]
operator|==
literal|'|'
condition|)
block|{
name|d
operator|--
expr_stmt|;
block|}
operator|*
name|d
operator|=
literal|'\0'
expr_stmt|;
name|s
operator|=
name|strtok
argument_list|(
name|line
argument_list|,
literal|"|"
argument_list|)
expr_stmt|;
name|last
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|s
operator|!=
name|NULL
operator|&&
name|last
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'\0'
condition|)
block|{
empty_stmt|;
block|}
elseif|else
if|if
condition|(
name|badname
argument_list|(
name|s
argument_list|)
condition|)
block|{
if|if
condition|(
name|lineno
condition|)
name|warn
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"bad terminal name '%s', ingored.\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|access
argument_list|(
name|bindir
argument_list|(
name|s
argument_list|)
argument_list|,
literal|2
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|ENOENT
condition|)
name|quit
argument_list|(
name|errno
argument_list|,
literal|"can't access directory '%s'"
argument_list|,
name|bindir
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mkdir
argument_list|(
name|bindir
argument_list|(
name|s
argument_list|)
argument_list|,
literal|0777
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|quit
argument_list|(
name|errno
argument_list|,
literal|"can't make directory '%s'"
argument_list|,
name|bindir
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fd
operator|=
name|open
argument_list|(
name|binfile
argument_list|(
name|s
argument_list|)
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_EXCL
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EEXIST
condition|)
name|quit
argument_list|(
name|errno
argument_list|,
literal|"can't open file '%s'"
argument_list|,
name|binfile
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlink
argument_list|(
name|binfile
argument_list|(
name|s
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|quit
argument_list|(
name|errno
argument_list|,
literal|"can't unlink file '%s'"
argument_list|,
name|binfile
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|binfile
argument_list|(
name|s
argument_list|)
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_EXCL
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|==
operator|-
literal|1
condition|)
name|quit
argument_list|(
name|errno
argument_list|,
literal|"can't create file '%s'"
argument_list|,
name|binfile
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|writebin
argument_list|(
name|fd
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|last
operator|=
name|s
expr_stmt|;
block|}
name|s
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|"|"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|last
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|lineno
condition|)
name|warn
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"no terminal name, entry ignored.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|s
operator|!=
name|NULL
operator|&&
name|s
operator|+
name|strlen
argument_list|(
name|s
argument_list|)
operator|!=
name|d
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'\0'
operator|||
name|strcmp
argument_list|(
name|s
argument_list|,
name|last
argument_list|)
operator|==
literal|0
condition|)
block|{
empty_stmt|;
block|}
elseif|else
if|if
condition|(
name|badname
argument_list|(
name|s
argument_list|)
condition|)
block|{
if|if
condition|(
name|lineno
condition|)
name|warn
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"bad terminal name '%s', ingored.\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|access
argument_list|(
name|bindir
argument_list|(
name|s
argument_list|)
argument_list|,
literal|2
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|ENOENT
condition|)
name|quit
argument_list|(
name|errno
argument_list|,
literal|"can't access directory '%s'"
argument_list|,
name|bindir
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mkdir
argument_list|(
name|bindir
argument_list|(
name|s
argument_list|)
argument_list|,
literal|0777
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|quit
argument_list|(
name|errno
argument_list|,
literal|"can't make directory '%s'"
argument_list|,
name|bindir
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|access
argument_list|(
name|binfile
argument_list|(
name|s
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|ENOENT
condition|)
name|quit
argument_list|(
name|errno
argument_list|,
literal|"can't access file '%s'"
argument_list|,
name|binfile
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|unlink
argument_list|(
name|binfile
argument_list|(
name|s
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|quit
argument_list|(
name|errno
argument_list|,
literal|"can't unlink file '%s'"
argument_list|,
name|binfile
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|tmp
argument_list|,
name|binfile
argument_list|(
name|last
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|link
argument_list|(
name|tmp
argument_list|,
name|binfile
argument_list|(
name|s
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|quit
argument_list|(
name|errno
argument_list|,
literal|"can't link '%s' to '%s'"
argument_list|,
name|last
argument_list|,
name|binfile
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|s
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|"|"
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* output an entry in terminfo source format */
end_comment

begin_function
name|void
name|outputinfo
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|char
name|line
index|[
name|MAX_LINE
index|]
decl_stmt|;
name|printf
argument_list|(
literal|"%s,\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_OF_BOOLS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|_term_buf
operator|.
name|bools
index|[
name|i
index|]
operator|==
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"%s@"
argument_list|,
name|boolnames
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|_term_buf
operator|.
name|bools
index|[
name|i
index|]
operator|!=
operator|-
literal|1
condition|)
name|putstr
argument_list|(
name|boolnames
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_OF_NUMS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|_term_buf
operator|.
name|nums
index|[
name|i
index|]
operator|==
operator|-
literal|1
condition|)
block|{
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"%s@"
argument_list|,
name|numnames
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|_term_buf
operator|.
name|nums
index|[
name|i
index|]
operator|!=
operator|-
literal|2
condition|)
block|{
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"%s#%d"
argument_list|,
name|numnames
index|[
name|i
index|]
argument_list|,
name|_term_buf
operator|.
name|nums
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_OF_STRS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|_term_buf
operator|.
name|strs
index|[
name|i
index|]
operator|==
name|NULL
condition|)
block|{
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"%s@"
argument_list|,
name|strnames
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|_term_buf
operator|.
name|strs
index|[
name|i
index|]
operator|!=
operator|(
name|char
operator|*
operator|)
operator|-
literal|1
condition|)
block|{
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"%s=%s"
argument_list|,
name|strnames
index|[
name|i
index|]
argument_list|,
name|convstr
argument_list|(
name|_term_buf
operator|.
name|strs
index|[
name|i
index|]
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
name|putstr
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* convert a terminfo entry to binary format */
end_comment

begin_function
name|void
name|convtinfo
parameter_list|()
block|{
name|int
name|i
decl_stmt|,
name|r
decl_stmt|;
name|termcap
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_OF_BOOLS
condition|;
name|i
operator|++
control|)
name|_term_buf
operator|.
name|bools
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_OF_NUMS
condition|;
name|i
operator|++
control|)
name|_term_buf
operator|.
name|nums
index|[
name|i
index|]
operator|=
operator|-
literal|2
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_OF_STRS
condition|;
name|i
operator|++
control|)
name|_term_buf
operator|.
name|strs
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|*
operator|)
operator|-
literal|1
expr_stmt|;
name|_term_buf
operator|.
name|name_all
operator|=
name|NULL
expr_stmt|;
name|r
operator|=
name|_gettinfo
argument_list|(
name|buf
argument_list|,
operator|&
name|_term_buf
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|lineno
operator|==
literal|0
condition|)
name|quit
argument_list|(
operator|-
literal|1
argument_list|,
literal|"problem reading entry"
argument_list|)
expr_stmt|;
else|else
block|{
name|warn
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"problem reading entry\n"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|compile
condition|)
name|outputbin
argument_list|(
name|_term_buf
operator|.
name|name_all
argument_list|)
expr_stmt|;
else|else
name|outputinfo
argument_list|(
name|_term_buf
operator|.
name|name_all
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* convert a terminfo binary to terminfo source */
end_comment

begin_function
name|void
name|convtbin
parameter_list|()
block|{
name|int
name|i
decl_stmt|,
name|r
decl_stmt|;
name|termcap
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_OF_BOOLS
condition|;
name|i
operator|++
control|)
name|_term_buf
operator|.
name|bools
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_OF_NUMS
condition|;
name|i
operator|++
control|)
name|_term_buf
operator|.
name|nums
index|[
name|i
index|]
operator|=
operator|-
literal|2
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_OF_STRS
condition|;
name|i
operator|++
control|)
name|_term_buf
operator|.
name|strs
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|*
operator|)
operator|-
literal|1
expr_stmt|;
name|_term_buf
operator|.
name|name_all
operator|=
name|NULL
expr_stmt|;
name|r
operator|=
name|_gettbin
argument_list|(
name|buf
argument_list|,
operator|&
name|_term_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|lineno
operator|==
literal|0
condition|)
name|quit
argument_list|(
operator|-
literal|1
argument_list|,
literal|"problem reading entry"
argument_list|)
expr_stmt|;
else|else
block|{
name|warn
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"problem reading entry\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|outputinfo
argument_list|(
name|_term_buf
operator|.
name|name_all
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* convert a termcap entry to terminfo format */
end_comment

begin_function
name|void
name|convtcap
parameter_list|()
block|{
name|int
name|i
decl_stmt|,
name|r
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|termcap
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_OF_BOOLS
condition|;
name|i
operator|++
control|)
name|_term_buf
operator|.
name|bools
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_OF_NUMS
condition|;
name|i
operator|++
control|)
name|_term_buf
operator|.
name|nums
index|[
name|i
index|]
operator|=
operator|-
literal|2
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_OF_STRS
condition|;
name|i
operator|++
control|)
name|_term_buf
operator|.
name|strs
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|*
operator|)
operator|-
literal|1
expr_stmt|;
name|_term_buf
operator|.
name|name_all
operator|=
name|NULL
expr_stmt|;
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|r
operator|=
name|_gettcap
argument_list|(
name|buf
argument_list|,
operator|&
name|_term_buf
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|lineno
operator|==
literal|0
condition|)
name|quit
argument_list|(
operator|-
literal|1
argument_list|,
literal|"problem reading entry"
argument_list|)
expr_stmt|;
else|else
block|{
name|warn
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"problem reading entry\n"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dodefault
operator|&&
operator|!
name|continued
condition|)
name|_tcapdefault
argument_list|()
expr_stmt|;
name|_tcapconv
argument_list|()
expr_stmt|;
name|name
operator|=
name|_term_buf
operator|.
name|name_all
expr_stmt|;
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"...%s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|&&
name|name
index|[
literal|1
index|]
operator|!=
literal|'\0'
operator|&&
name|name
index|[
literal|2
index|]
operator|==
literal|'|'
condition|)
name|name
operator|+=
literal|3
expr_stmt|;
comment|/* skip the 2 letter code */
if|if
condition|(
name|compile
condition|)
name|outputbin
argument_list|(
name|name
argument_list|)
expr_stmt|;
else|else
name|outputinfo
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|convbinfile
parameter_list|(
name|file
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
block|{
specifier|register
name|FILE
modifier|*
name|f
decl_stmt|;
name|int
name|r
decl_stmt|;
name|f
operator|=
name|fopen
argument_list|(
name|file
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
name|quit
argument_list|(
name|errno
argument_list|,
literal|"can't open '%s'"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|r
operator|=
name|fread
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
name|MAX_BUF
argument_list|,
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|12
operator|||
name|buf
index|[
literal|0
index|]
operator|!=
literal|032
operator|||
name|buf
index|[
literal|1
index|]
operator|!=
literal|01
condition|)
name|quit
argument_list|(
operator|-
literal|1
argument_list|,
literal|"file '%s' corrupted"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|convtbin
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* convert a termcap file to terminfo format */
end_comment

begin_function
name|void
name|convtcfile
parameter_list|(
name|file
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
block|{
name|int
name|nocolon
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|d
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|f
decl_stmt|;
name|f
operator|=
name|fopen
argument_list|(
name|file
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
name|quit
argument_list|(
name|errno
argument_list|,
literal|"can't open '%s'"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|d
operator|=
name|buf
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|f
argument_list|)
expr_stmt|;
while|while
condition|(
name|c
operator|!=
name|EOF
condition|)
block|{
name|lineno
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'#'
condition|)
block|{
if|if
condition|(
name|keepcomments
condition|)
block|{
do|do
block|{
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|c
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
name|EOF
condition|)
do|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
else|else
do|do
name|c
operator|=
name|getc
argument_list|(
name|f
argument_list|)
expr_stmt|;
do|while
condition|(
name|c
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
name|EOF
condition|)
do|;
if|if
condition|(
name|c
operator|!=
name|EOF
condition|)
name|c
operator|=
name|getc
argument_list|(
name|f
argument_list|)
expr_stmt|;
continue|continue;
block|}
while|while
condition|(
name|isspace
argument_list|(
name|c
argument_list|)
operator|&&
name|c
operator|!=
literal|'\n'
condition|)
name|c
operator|=
name|getc
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
operator|&&
name|buf
operator|==
name|d
condition|)
block|{
name|c
operator|=
name|getc
argument_list|(
name|f
argument_list|)
expr_stmt|;
continue|continue;
block|}
while|while
condition|(
name|c
operator|!=
name|EOF
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
name|c
operator|=
name|getc
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
break|break;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
name|c
operator|=
name|getc
argument_list|(
name|f
argument_list|)
expr_stmt|;
break|break;
block|}
operator|*
name|d
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|d
operator|++
operator|=
name|c
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
operator|*
name|d
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|*
operator|--
name|d
operator|==
literal|':'
condition|)
block|{
name|nocolon
operator|=
literal|0
expr_stmt|;
operator|*
name|d
operator|--
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
name|nocolon
operator|=
literal|1
expr_stmt|;
block|}
while|while
condition|(
name|d
operator|>
name|buf
operator|&&
operator|*
name|d
operator|!=
literal|':'
condition|)
name|d
operator|--
expr_stmt|;
if|if
condition|(
name|d
index|[
literal|1
index|]
operator|==
literal|'t'
operator|&&
name|d
index|[
literal|2
index|]
operator|==
literal|'c'
operator|&&
name|d
index|[
literal|3
index|]
operator|==
literal|'='
condition|)
block|{
name|continued
operator|=
literal|1
expr_stmt|;
name|d
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
name|continued
operator|=
literal|0
expr_stmt|;
name|convtcap
argument_list|()
expr_stmt|;
if|if
condition|(
name|nocolon
condition|)
block|{
name|warn
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"entry doesn't end with :\n"
argument_list|)
expr_stmt|;
block|}
name|_term_buf
operator|.
name|strbuf
operator|=
name|_endstr
argument_list|()
expr_stmt|;
name|_del_strs
argument_list|(
operator|&
name|_term_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|continued
condition|)
block|{
name|printf
argument_list|(
literal|"\tuse=%s,\n"
argument_list|,
name|d
operator|+
literal|4
argument_list|)
expr_stmt|;
block|}
name|d
operator|=
name|buf
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|f
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
operator|*
name|d
operator|++
operator|=
name|c
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|getln
parameter_list|(
name|f
parameter_list|,
name|buf
parameter_list|,
name|len
parameter_list|)
name|FILE
modifier|*
name|f
decl_stmt|;
specifier|register
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|,
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|f
argument_list|)
operator|)
operator|==
literal|'#'
condition|)
block|{
name|lineno
operator|++
expr_stmt|;
if|if
condition|(
name|keepcomments
condition|)
block|{
name|putchar
argument_list|(
literal|'#'
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|f
argument_list|)
operator|)
operator|!=
literal|'\n'
condition|)
block|{
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
return|return
operator|-
literal|1
return|;
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|f
argument_list|)
operator|)
operator|!=
literal|'\n'
condition|)
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
return|return
operator|-
literal|1
return|;
block|}
block|}
name|lineno
operator|++
expr_stmt|;
while|while
condition|(
name|c
operator|!=
literal|'\n'
condition|)
block|{
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|i
operator|<
name|len
condition|)
block|{
name|i
operator|++
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
name|c
expr_stmt|;
block|}
name|c
operator|=
name|getc
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|isspace
argument_list|(
operator|*
operator|(
name|buf
operator|-
literal|1
operator|)
argument_list|)
condition|)
block|{
name|buf
operator|--
expr_stmt|;
name|i
operator|--
expr_stmt|;
block|}
operator|*
name|buf
operator|=
literal|'\0'
expr_stmt|;
return|return
name|i
return|;
block|}
end_function

begin_function
name|void
name|convtifile
parameter_list|(
name|file
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
block|{
specifier|static
name|char
name|line
index|[
name|MAX_LINE
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|l
decl_stmt|;
name|int
name|n
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|f
decl_stmt|;
name|f
operator|=
name|fopen
argument_list|(
name|file
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
name|quit
argument_list|(
name|errno
argument_list|,
literal|"can't open '%s'"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|lineno
operator|=
literal|0
expr_stmt|;
name|l
operator|=
name|getln
argument_list|(
name|f
argument_list|,
name|line
argument_list|,
name|MAX_LINE
argument_list|)
expr_stmt|;
while|while
condition|(
name|l
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|line
index|[
name|l
operator|-
literal|1
index|]
operator|==
literal|':'
condition|)
block|{
name|strncpy
argument_list|(
name|buf
argument_list|,
name|line
argument_list|,
name|MAX_BUF
argument_list|)
expr_stmt|;
name|convtcap
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|line
index|[
name|l
operator|-
literal|1
index|]
operator|==
literal|'\\'
condition|)
block|{
name|n
operator|=
name|MAX_BUF
expr_stmt|;
do|do
block|{
name|line
index|[
operator|--
name|l
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
condition|)
name|strncpy
argument_list|(
name|buf
operator|+
name|MAX_BUF
operator|-
name|n
argument_list|,
name|line
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|n
operator|-=
name|l
expr_stmt|;
name|l
operator|=
name|getln
argument_list|(
name|f
argument_list|,
name|line
argument_list|,
name|MAX_LINE
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|l
operator|!=
operator|-
literal|1
operator|&&
name|line
index|[
name|l
operator|-
literal|1
index|]
operator|==
literal|'\\'
condition|)
do|;
if|if
condition|(
name|n
operator|>
literal|0
operator|&&
name|l
operator|!=
operator|-
literal|1
condition|)
name|strncpy
argument_list|(
name|buf
operator|+
name|MAX_BUF
operator|-
name|n
argument_list|,
name|line
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|convtcap
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|line
index|[
name|l
operator|-
literal|1
index|]
operator|==
literal|','
condition|)
block|{
name|n
operator|=
name|MAX_BUF
expr_stmt|;
do|do
block|{
if|if
condition|(
name|n
operator|>
literal|0
condition|)
name|strncpy
argument_list|(
name|buf
operator|+
name|MAX_BUF
operator|-
name|n
argument_list|,
name|line
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|n
operator|-=
name|l
expr_stmt|;
name|l
operator|=
name|getln
argument_list|(
name|f
argument_list|,
name|line
argument_list|,
name|MAX_LINE
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|l
operator|!=
operator|-
literal|1
operator|&&
name|isspace
argument_list|(
name|line
index|[
literal|0
index|]
argument_list|)
condition|)
do|;
if|#
directive|if
literal|0
block|printf("buf = '%s'\n", buf);
endif|#
directive|endif
name|convtinfo
argument_list|()
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|line
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|warn
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"malformed line\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|keepcomments
condition|)
block|{
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
block|}
name|l
operator|=
name|getln
argument_list|(
name|f
argument_list|,
name|line
argument_list|,
name|MAX_LINE
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* dummy routine for quit */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|void
name|do_cleanup
parameter_list|(
name|e
parameter_list|)
name|int
name|e
decl_stmt|;
block|{
return|return;
block|}
end_function

begin_comment
comment|/* print out usage, called by quit */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|void
name|usage
parameter_list|(
name|e
parameter_list|)
name|int
name|e
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: %s [-b] [-c [-OUGd]] [-i] [-B [-D dir]] [-I] [-k] [-V]\n\t[-t term] [file]\n"
argument_list|,
name|prg_name
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
specifier|extern
name|char
modifier|*
name|optarg
decl_stmt|;
specifier|extern
name|int
name|optind
decl_stmt|;
specifier|extern
name|int
name|opterr
decl_stmt|;
name|char
modifier|*
name|term
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|file
init|=
name|NULL
decl_stmt|;
name|int
name|r
decl_stmt|;
name|char
name|c
decl_stmt|;
name|int
name|pversion
init|=
literal|0
decl_stmt|;
name|prg_name
operator|=
name|strrchr
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|prg_name
operator|==
name|NULL
condition|)
name|prg_name
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
else|else
name|prg_name
operator|++
expr_stmt|;
name|cleanup
operator|=
name|usage
expr_stmt|;
name|opterr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|prg_name
argument_list|,
literal|"tic"
argument_list|)
operator|==
literal|0
condition|)
name|compile
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"bciBIOGUdkVD:t:"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'O'
case|:
name|noOT
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'G'
case|:
name|noGNU
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'U'
case|:
name|noUW
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
if|if
condition|(
name|directory
operator|!=
name|NULL
condition|)
name|quit
argument_list|(
operator|-
literal|1
argument_list|,
literal|"more than one directory specified"
argument_list|)
expr_stmt|;
name|directory
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
if|if
condition|(
name|term
operator|!=
name|NULL
condition|)
name|quit
argument_list|(
operator|-
literal|1
argument_list|,
literal|"more than one terminal specified"
argument_list|)
expr_stmt|;
name|term
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|dodefault
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
name|keepcomments
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|from_tbin
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|from_tcap
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|from_tinfo
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
name|compile
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
name|compile
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
name|pversion
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
default|default:
name|quit
argument_list|(
operator|-
literal|1
argument_list|,
literal|"bad or missing command line argument"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|pversion
condition|)
block|{
name|quit
argument_list|(
literal|0
argument_list|,
literal|"%s\n%s"
argument_list|,
name|_mytinfo_version
argument_list|,
name|SCCSid
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|optind
operator|==
name|argc
operator|-
literal|1
condition|)
name|file
operator|=
name|argv
index|[
name|optind
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|optind
operator|!=
name|argc
condition|)
name|quit
argument_list|(
operator|-
literal|1
argument_list|,
literal|"wrong number of arguments"
argument_list|)
expr_stmt|;
if|if
condition|(
name|from_tbin
operator|+
name|from_tcap
operator|+
name|from_tinfo
operator|>
literal|1
condition|)
name|quit
argument_list|(
operator|-
literal|1
argument_list|,
literal|"more than one input file type specified"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|from_tcap
operator|&&
operator|!
name|from_tinfo
operator|&&
operator|!
name|from_tbin
operator|&&
name|file
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|prg_name
argument_list|,
literal|"cap2info"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|prg_name
argument_list|,
literal|"captoinfo"
argument_list|)
operator|==
literal|0
condition|)
name|from_tcap
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|prg_name
argument_list|,
literal|"tic"
argument_list|)
operator|==
literal|0
condition|)
name|from_tinfo
operator|=
literal|1
expr_stmt|;
else|else
name|quit
argument_list|(
operator|-
literal|1
argument_list|,
literal|"no input file type specified"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|from_tbin
operator|&&
name|compile
condition|)
name|quit
argument_list|(
operator|-
literal|1
argument_list|,
literal|"can't convert from binary to binary"
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|from_tbin
condition|)
block|{
name|cleanup
operator|=
name|do_cleanup
expr_stmt|;
name|convbinfile
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|compile
condition|)
name|path
operator|=
name|_buildpath
argument_list|(
name|file
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
name|path
operator|=
name|_buildpath
argument_list|(
name|file
argument_list|,
literal|0
argument_list|,
literal|"$TERMINFO"
argument_list|,
literal|2
argument_list|,
literal|"$MYTERMINFO"
argument_list|,
literal|2
argument_list|,
ifdef|#
directive|ifdef
name|TERMINFODIR
name|TERMINFODIR
argument_list|,
literal|0
argument_list|,
endif|#
directive|endif
name|NULL
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|path
operator|==
name|NULL
condition|)
name|quit
argument_list|(
operator|-
literal|1
argument_list|,
literal|"can't build path"
argument_list|)
expr_stmt|;
if|if
condition|(
name|term
operator|==
name|NULL
condition|)
block|{
name|cleanup
operator|=
name|do_cleanup
expr_stmt|;
if|if
condition|(
name|from_tcap
operator|&&
operator|!
name|compile
condition|)
name|convtcfile
argument_list|(
name|file
argument_list|)
expr_stmt|;
else|else
name|convtifile
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|from_tcap
operator|&&
operator|!
name|compile
condition|)
name|path
operator|=
name|_buildpath
argument_list|(
literal|"$TERMCAP"
argument_list|,
literal|1
argument_list|,
ifdef|#
directive|ifdef
name|TERMCAPFILE
name|TERMCAPFILE
argument_list|,
literal|0
argument_list|,
endif|#
directive|endif
name|NULL
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|from_tinfo
operator|||
name|from_tbin
condition|)
name|path
operator|=
name|_buildpath
argument_list|(
literal|"$TERMINFO"
argument_list|,
literal|2
argument_list|,
literal|"$MYTERMINFO"
argument_list|,
literal|2
argument_list|,
ifdef|#
directive|ifdef
name|TERMINFODIR
name|TERMINFODIR
argument_list|,
literal|0
argument_list|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TERMINFOSRC
name|TERMINFOSRC
argument_list|,
literal|0
argument_list|,
endif|#
directive|endif
name|NULL
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|from_tcap
condition|)
name|path
operator|=
name|_buildpath
argument_list|(
literal|"$TERMCAP"
argument_list|,
literal|1
argument_list|,
ifdef|#
directive|ifdef
name|TERMCAPFILE
name|TERMCAPFILE
argument_list|,
literal|0
argument_list|,
endif|#
directive|endif
literal|"$TERMINFO"
argument_list|,
literal|2
argument_list|,
literal|"$MYTERMINFO"
argument_list|,
literal|2
argument_list|,
ifdef|#
directive|ifdef
name|TERMINFODIR
name|TERMINFODIR
argument_list|,
literal|0
argument_list|,
endif|#
directive|endif
name|NULL
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
name|path
operator|=
name|_buildpath
argument_list|(
ifdef|#
directive|ifdef
name|USE_TERMINFO
literal|"$MYTERMINFO"
argument_list|,
literal|2
argument_list|,
literal|"$TERMINFO"
argument_list|,
literal|2
argument_list|,
ifdef|#
directive|ifdef
name|TERMINFODIR
name|TERMINFODIR
argument_list|,
literal|0
argument_list|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TERMINFOSRC
name|TERMINFOSRC
argument_list|,
literal|0
argument_list|,
endif|#
directive|endif
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USE_TERMCAP
literal|"$TERMCAP"
argument_list|,
literal|1
argument_list|,
ifdef|#
directive|ifdef
name|TERMCAPFILE
name|TERMCAPFILE
argument_list|,
literal|0
argument_list|,
endif|#
directive|endif
endif|#
directive|endif
name|NULL
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|term
operator|==
name|NULL
condition|)
block|{
name|term
operator|=
name|getenv
argument_list|(
literal|"TERM"
argument_list|)
expr_stmt|;
if|if
condition|(
name|term
operator|==
name|NULL
condition|)
name|quit
argument_list|(
operator|-
literal|1
argument_list|,
literal|"no terminal type given"
argument_list|)
expr_stmt|;
block|}
name|cleanup
operator|=
name|do_cleanup
expr_stmt|;
name|r
operator|=
name|_findterm
argument_list|(
name|term
argument_list|,
name|path
argument_list|,
name|buf
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|r
condition|)
block|{
case|case
literal|1
case|:
name|convtcap
argument_list|()
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|convtinfo
argument_list|()
expr_stmt|;
break|break;
case|case
literal|3
case|:
if|if
condition|(
name|compile
condition|)
name|quit
argument_list|(
operator|-
literal|1
argument_list|,
literal|"entry is already compiled"
argument_list|)
expr_stmt|;
name|convtbin
argument_list|()
expr_stmt|;
break|break;
default|default:
name|quit
argument_list|(
operator|-
literal|1
argument_list|,
literal|"can't find a terminal entry for '%s'"
argument_list|,
name|term
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

