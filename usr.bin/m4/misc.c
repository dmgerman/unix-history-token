begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  File   : misc.c     Author : Ozan Yigit     Updated: 26-Mar-1993     Purpose: Miscellaneous support code for PD M4. */
end_comment

begin_include
include|#
directive|include
file|"mdef.h"
end_include

begin_include
include|#
directive|include
file|"extr.h"
end_include

begin_include
include|#
directive|include
file|"ourlims.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DUFFCP
end_ifdef

begin_comment
comment|/*  This version of the ANSI standard function memcpy()     uses Duff's Device (tm Tom Duff)  to unroll the copying loop: 	while (count--> 0) *to++ = *from++; */
end_comment

begin_function
name|void
name|memcpy
parameter_list|(
name|to
parameter_list|,
name|from
parameter_list|,
name|count
parameter_list|)
specifier|register
name|char
modifier|*
name|from
decl_stmt|,
decl|*
name|to
decl_stmt|;
end_function

begin_decl_stmt
specifier|register
name|int
name|count
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
specifier|register
name|int
name|loops
init|=
operator|(
name|count
operator|+
literal|8
operator|-
literal|1
operator|)
operator|>>
literal|3
decl_stmt|;
comment|/* div 8 round up */
switch|switch
condition|(
name|count
operator|&
operator|(
literal|8
operator|-
literal|1
operator|)
condition|)
block|{
comment|/* mod 8 */
case|case
literal|0
case|:
do|do
block|{
operator|*
name|to
operator|++
operator|=
operator|*
name|from
operator|++
expr_stmt|;
case|case
literal|7
case|:
operator|*
name|to
operator|++
operator|=
operator|*
name|from
operator|++
expr_stmt|;
case|case
literal|6
case|:
operator|*
name|to
operator|++
operator|=
operator|*
name|from
operator|++
expr_stmt|;
case|case
literal|5
case|:
operator|*
name|to
operator|++
operator|=
operator|*
name|from
operator|++
expr_stmt|;
case|case
literal|4
case|:
operator|*
name|to
operator|++
operator|=
operator|*
name|from
operator|++
expr_stmt|;
case|case
literal|3
case|:
operator|*
name|to
operator|++
operator|=
operator|*
name|from
operator|++
expr_stmt|;
case|case
literal|2
case|:
operator|*
name|to
operator|++
operator|=
operator|*
name|from
operator|++
expr_stmt|;
case|case
literal|1
case|:
operator|*
name|to
operator|++
operator|=
operator|*
name|from
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|loops
operator|>
literal|0
condition|)
do|;
block|}
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  strsave(s)     return a new malloc()ed copy of s -- same as V.3's strdup(). */
end_comment

begin_function
name|char
modifier|*
name|strsave
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|int
name|n
init|=
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|malloc
argument_list|(
name|n
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
condition|)
name|memcpy
argument_list|(
name|p
argument_list|,
name|s
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/*  indx(s1, s2)     if s1 can be decomposed as alpha || s2 || omega, return the length     of the shortest such alpha, otherwise return -1. */
end_comment

begin_function
name|int
name|indx
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|)
name|char
modifier|*
name|s1
decl_stmt|;
name|char
modifier|*
name|s2
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|t
decl_stmt|;
specifier|register
name|char
modifier|*
name|m
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|s1
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
block|{
for|for
control|(
name|t
operator|=
name|p
operator|,
name|m
operator|=
name|s2
init|;
operator|*
name|m
operator|&&
operator|*
name|m
operator|==
operator|*
name|t
condition|;
name|m
operator|++
operator|,
name|t
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|!
operator|*
name|m
condition|)
return|return
name|p
operator|-
name|s1
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_decl_stmt
name|char
name|pbmsg
index|[]
init|=
literal|"m4: too many characters pushed back"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  Xputback(c)     push character c back onto the input stream.     This is now macro putback() in misc.h */
end_comment

begin_function
name|void
name|Xputback
parameter_list|(
name|c
parameter_list|)
name|char
name|c
decl_stmt|;
block|{
if|if
condition|(
name|bp
operator|<
name|endpbb
condition|)
operator|*
name|bp
operator|++
operator|=
name|c
expr_stmt|;
else|else
name|error
argument_list|(
name|pbmsg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  pbstr(s)     push string s back onto the input stream.     putback() has been unfolded here to improve performance.     Example: 	s =<ABC> 	bp =<more stuff>     After the call: 	bp =<more stuffCBA>     It would be more efficient if we ran the pushback buffer in the     opposite direction */
end_comment

begin_function
name|void
name|pbstr
parameter_list|(
name|s
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|es
decl_stmt|;
specifier|register
name|char
modifier|*
name|zp
decl_stmt|;
name|zp
operator|=
name|bp
expr_stmt|;
for|for
control|(
name|es
operator|=
name|s
init|;
operator|*
name|es
condition|;
control|)
name|es
operator|++
expr_stmt|;
comment|/* now es points to terminating NUL */
name|bp
operator|+=
name|es
operator|-
name|s
expr_stmt|;
comment|/* advance bp as far as it should go */
if|if
condition|(
name|bp
operator|>=
name|endpbb
condition|)
name|error
argument_list|(
literal|"m4: too many characters to push back"
argument_list|)
expr_stmt|;
while|while
condition|(
name|es
operator|>
name|s
condition|)
operator|*
name|zp
operator|++
operator|=
operator|*
operator|--
name|es
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  pbqtd(s)     pushes string s back "quoted", doing whatever has to be done to it to     make sure that the result will evaluate to the original value.  As it     happens, we have only to add lquote and rquote. */
end_comment

begin_function
name|void
name|pbqtd
parameter_list|(
name|s
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|es
decl_stmt|;
specifier|register
name|char
modifier|*
name|zp
decl_stmt|;
name|zp
operator|=
name|bp
expr_stmt|;
for|for
control|(
name|es
operator|=
name|s
init|;
operator|*
name|es
condition|;
control|)
name|es
operator|++
expr_stmt|;
comment|/* now es points to terminating NUL */
name|bp
operator|+=
literal|2
operator|+
name|es
operator|-
name|s
expr_stmt|;
comment|/* advance bp as far as it should go */
if|if
condition|(
name|bp
operator|>=
name|endpbb
condition|)
name|error
argument_list|(
literal|"m4: too many characters to push back"
argument_list|)
expr_stmt|;
operator|*
name|zp
operator|++
operator|=
name|rquote
expr_stmt|;
while|while
condition|(
name|es
operator|>
name|s
condition|)
operator|*
name|zp
operator|++
operator|=
operator|*
operator|--
name|es
expr_stmt|;
operator|*
name|zp
operator|++
operator|=
name|lquote
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  pbnum(n)     convert a number to a (decimal) string and push it back.     The original definition did not work for MININT; this does. */
end_comment

begin_function
name|void
name|pbnum
parameter_list|(
name|n
parameter_list|)
name|int
name|n
decl_stmt|;
block|{
specifier|register
name|int
name|num
decl_stmt|;
name|num
operator|=
name|n
operator|>
literal|0
condition|?
operator|-
name|n
else|:
name|n
expr_stmt|;
comment|/* MININT<= num<= 0 */
do|do
block|{
name|putback
argument_list|(
literal|'0'
operator|-
operator|(
name|num
operator|%
literal|10
operator|)
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|num
operator|/=
literal|10
operator|)
operator|<
literal|0
condition|)
do|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
name|putback
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  pbrad(n, r, m)     converts a number n to base r ([-36..-2] U [2..36]), with at least     m digits.  If r == 10 and m == 1, this is exactly the same as pbnum.     However, this uses the function int2str() from R.A.O'Keefe's public     domain string library, and puts the results of that back.     The Unix System V Release 3 version of m4 accepts radix 1;     THIS VERSION OF M4 DOES NOT ACCEPT RADIX 1 OR -1,     nor do we accept radix< -36 or radix> 36.  At the moment such bad     radices quietly produce nothing.  The V.3 treatment of radix 1 is 	push back abs(n) "1"s, then 	if n< 0, push back one "-".     Until I come across something which uses it, I can't bring myself to     implement this.      I have, however, found a use for radix 0.  Unsurprisingly, it is     related to radix 0 in Edinburgh Prolog. 	eval('c1c2...cn', 0, m)     pushes back max(m-n,0) blanks and the characters c1...cn.  This can     adjust to any byte size as long as UCHAR_MAX = (1<< CHAR_BIT) - 1.     In particular, eval(c, 0) where 0< c<= UCHAR_MAX, pushes back the     character with code c.  Note that this has to agree with eval(); so     both of them have to use the same byte ordering. */
end_comment

begin_function
name|void
name|pbrad
parameter_list|(
name|n
parameter_list|,
name|r
parameter_list|,
name|m
parameter_list|)
name|long
name|int
name|n
decl_stmt|;
name|int
name|r
decl_stmt|,
name|m
decl_stmt|;
block|{
name|char
name|buffer
index|[
literal|34
index|]
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|L
decl_stmt|;
if|if
condition|(
name|r
operator|==
literal|0
condition|)
block|{
name|unsigned
name|long
name|int
name|x
init|=
operator|(
name|unsigned
name|long
operator|)
name|n
decl_stmt|;
name|int
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|x
condition|;
name|x
operator|>>=
name|CHAR_BIT
operator|,
name|n
operator|++
control|)
name|buffer
index|[
name|n
index|]
operator|=
name|x
operator|&
name|UCHAR_MAX
expr_stmt|;
for|for
control|(
name|L
operator|=
name|n
init|;
operator|--
name|L
operator|>=
literal|0
condition|;
control|)
name|putback
argument_list|(
name|buffer
index|[
name|L
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|L
operator|=
name|m
operator|-
name|n
init|;
operator|--
name|L
operator|>=
literal|0
condition|;
control|)
name|putback
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
return|return;
block|}
name|L
operator|=
name|m
operator|-
operator|(
name|int2str
argument_list|(
name|p
operator|=
name|buffer
argument_list|,
operator|-
name|r
argument_list|,
name|n
argument_list|)
operator|-
name|buffer
operator|)
expr_stmt|;
if|if
condition|(
name|buffer
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
name|L
operator|++
operator|,
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|L
operator|>
literal|0
condition|)
block|{
name|pbstr
argument_list|(
name|p
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|L
operator|>=
literal|0
condition|)
name|putback
argument_list|(
literal|'0'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|buffer
condition|)
name|putback
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pbstr
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
name|char
name|csmsg
index|[]
init|=
literal|"m4: string space overflow"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  chrsave(c)     put the character c in the string space. */
end_comment

begin_function
name|void
name|Xchrsave
parameter_list|(
name|c
parameter_list|)
name|char
name|c
decl_stmt|;
block|{
if|#
directive|if
literal|0
block|if (sp< 0) putc(c, active); else
endif|#
directive|endif
if|if
condition|(
name|ep
operator|<
name|endest
condition|)
operator|*
name|ep
operator|++
operator|=
name|c
expr_stmt|;
else|else
name|error
argument_list|(
name|csmsg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  getdiv(ind)     read in a diversion file and then delete it. */
end_comment

begin_function
name|void
name|getdiv
parameter_list|(
name|ind
parameter_list|)
name|int
name|ind
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|dfil
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|afil
decl_stmt|;
name|afil
operator|=
name|active
expr_stmt|;
if|if
condition|(
name|outfile
index|[
name|ind
index|]
operator|==
name|afil
condition|)
name|error
argument_list|(
literal|"m4: undivert: diversion still active."
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|outfile
index|[
name|ind
index|]
argument_list|)
expr_stmt|;
name|outfile
index|[
name|ind
index|]
operator|=
name|NULL
expr_stmt|;
name|m4temp
index|[
name|UNIQUE
index|]
operator|=
literal|'0'
operator|+
name|ind
expr_stmt|;
if|if
condition|(
operator|(
name|dfil
operator|=
name|fopen
argument_list|(
name|m4temp
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"m4: cannot undivert."
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|dfil
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
name|putc
argument_list|(
name|c
argument_list|,
name|afil
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|dfil
argument_list|)
expr_stmt|;
if|#
directive|if
name|vms
if|if
condition|(
name|remove
argument_list|(
name|m4temp
argument_list|)
condition|)
name|error
argument_list|(
literal|"m4: cannot unlink."
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|unlink
argument_list|(
name|m4temp
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|"m4: cannot unlink."
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  killdiv()     delete all the diversion files which have been created. */
end_comment

begin_function
name|void
name|killdiv
parameter_list|()
block|{
specifier|register
name|int
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|MAXOUT
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|outfile
index|[
name|n
index|]
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|outfile
index|[
name|n
index|]
argument_list|)
expr_stmt|;
name|m4temp
index|[
name|UNIQUE
index|]
operator|=
literal|'0'
operator|+
name|n
expr_stmt|;
if|#
directive|if
name|unix
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|m4temp
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|remove
argument_list|(
name|m4temp
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
block|}
end_function

begin_comment
comment|/*  error(s)     close all files, report a fatal error, and quit, letting the caller know. */
end_comment

begin_function
name|void
name|error
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|killdiv
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  Interrupt handling */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|msg
init|=
literal|"\ninterrupted."
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_function
name|void
name|onintr
parameter_list|(
name|int
name|signo
parameter_list|)
else|#
directive|else
function|onintr
parameter_list|()
endif|#
directive|endif
block|{
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|usage
parameter_list|()
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: m4 [-e] [-[BHST]int] [-Dname[=val]] [-Uname]\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|GETOPT
end_ifdef

begin_comment
comment|/* Henry Spencer's getopt() - get option letter from argv */
end_comment

begin_decl_stmt
name|char
modifier|*
name|optarg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Global argument pointer. */
end_comment

begin_decl_stmt
name|int
name|optind
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Global argv index. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|scan
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Private scan pointer. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__STDC__
end_ifndef

begin_function_decl
specifier|extern
name|char
modifier|*
name|index
parameter_list|()
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|strchr
value|index
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|getopt
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|optstring
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|char
modifier|*
name|optstring
decl_stmt|;
block|{
specifier|register
name|char
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|place
decl_stmt|;
name|optarg
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|scan
operator|==
name|NULL
operator|||
operator|*
name|scan
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|optind
operator|==
literal|0
condition|)
name|optind
operator|++
expr_stmt|;
if|if
condition|(
name|optind
operator|>=
name|argc
operator|||
name|argv
index|[
name|optind
index|]
index|[
literal|0
index|]
operator|!=
literal|'-'
operator|||
name|argv
index|[
name|optind
index|]
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
return|return
name|EOF
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|optind
index|]
argument_list|,
literal|"--"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|optind
operator|++
expr_stmt|;
return|return
name|EOF
return|;
block|}
name|scan
operator|=
name|argv
index|[
name|optind
index|]
operator|+
literal|1
expr_stmt|;
name|optind
operator|++
expr_stmt|;
block|}
name|c
operator|=
operator|*
name|scan
operator|++
expr_stmt|;
name|place
operator|=
name|strchr
argument_list|(
name|optstring
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|place
operator|==
name|NULL
operator|||
name|c
operator|==
literal|':'
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: unknown option -%c\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return
literal|'?'
return|;
block|}
name|place
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|place
operator|==
literal|':'
condition|)
block|{
if|if
condition|(
operator|*
name|scan
operator|!=
literal|'\0'
condition|)
block|{
name|optarg
operator|=
name|scan
expr_stmt|;
name|scan
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|optarg
operator|=
name|argv
index|[
name|optind
index|]
expr_stmt|;
name|optind
operator|++
expr_stmt|;
block|}
block|}
return|return
name|c
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

