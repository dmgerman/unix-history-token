begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  File   : main.c     Author : Ozan Yigit     Updated: 4 May 1992     Defines: M4 macro processor. */
end_comment

begin_include
include|#
directive|include
file|"mdef.h"
end_include

begin_include
include|#
directive|include
file|"extr.h"
end_include

begin_include
include|#
directive|include
file|"ourlims.h"
end_include

begin_decl_stmt
name|char
name|chtype
index|[
literal|1
operator|-
name|EOF
operator|+
name|UCHAR_MAX
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|is_sym1
parameter_list|(
name|c
parameter_list|)
value|(chtype[(c)-EOF]> 10)
end_define

begin_define
define|#
directive|define
name|is_sym2
parameter_list|(
name|c
parameter_list|)
value|(chtype[(c)-EOF]>  0)
end_define

begin_define
define|#
directive|define
name|is_blnk
parameter_list|(
name|c
parameter_list|)
value|((unsigned)((c)-1)< ' ')
end_define

begin_comment
comment|/*  * m4 - macro processor  *  * PD m4 is based on the macro tool distributed with the software   * tools (VOS) package, and described in the "SOFTWARE TOOLS" and   * "SOFTWARE TOOLS IN PASCAL" books. It has been expanded to include   * most of the command set of SysV m4, the standard UN*X macro processor.  *  * Since both PD m4 and UN*X m4 are based on SOFTWARE TOOLS macro,  * there may be certain implementation similarities between  * the two. The PD m4 was produced without ANY references to m4  * sources.  *  * References:  *  *	Software Tools distribution: macro  *  *	Kernighan, Brian W. and P. J. Plauger, SOFTWARE  *	TOOLS IN PASCAL, Addison-Wesley, Mass. 1981  *  *	Kernighan, Brian W. and P. J. Plauger, SOFTWARE  *	TOOLS, Addison-Wesley, Mass. 1976  *  *	Kernighan, Brian W. and Dennis M. Ritchie,  *	THE M4 MACRO PROCESSOR, Unix Programmer's Manual,  *	Seventh Edition, Vol. 2, Bell Telephone Labs, 1979  *  *	System V man page for M4  *  * Modification History:  *  * Mar 26 1992 RAOK	1.  Eliminated magic numbers 8, 255, 256 in favour  *			of the standard limits CHAR_BIT, UCHAR_MAX, which   *			are in the new header ourlims.h.  This is part of  *			the "8-bit-clean M4" project.  To the best of my  *			belief, all of the code should work in EBCDIC,  *			ASCII, DEC MNCS, ISO 8859/n, or the Mac character  *			set, as long as chars are unsigned.  There are  *			still some places where signed bytes can cause  *			trouble.  *			  *			2.  Changed expr() to use long int rather than int.  *			This is so that we'd get 32-bit arithmetic on a Sun,  *			Encore, PC, Mac&c.  As part of this, the code for  *			shifts has been elaborated to yield signed shifts  *			on all machines.  The charcon() function didn't work  *			with multi-character literals, although it was meant  *			to.  Now it does.  pbrad() has been changed so that  *			eval('abcd',0) => abcd, not dcba, which was useless.  *			  *			3.  I finally got sick of the fact that&&, ||, and  *			?: always evaluate all their arguments.  This is  *			consistent with UNIX System V Release 3, but I for  *			one don't see anything to gain by having eval(0&&1/0)  *			crash when it would simply yield 0 in C.  Now these  *			operators are more consistent with the C preprocessor.  *  * Nov 13 1992 RAOK	Added the quoter facility.  The purpose of this is  *			to make it easier to generate data for a variety of  *			programming languages, including sh, awk, Lisp, C.  *			There are two holes in the implementation:  dumpdef  *			prints junk and undefine doesn't release everything.  *			This was mainly intended as a prototype to show that  *			it could be done.  *  * Jun 16 1992 RAOK	Added vquote and gave changequote a 3rd argument.  *			The idea of this is to make it possible to quote  *			ANY string, including one with unbalanced ` or '.  *			I also made eval(c,0) convert decimal->ASCII, so  *			that eval(39,0) yields ' and eval(96,0) yields `.  *  * Apr 28 1992 RAOK	Used gcc to find and fix ANSI clashes, so that  *			PD M4 could be ported to MS-DOS (Turbo C 3).  *			Main known remaining problem:  use of mktemp().  *			Also, command line handling needs to be worked out.  *  * Mar 26 1992 RAOK	PD M4 now accepts file names on the command line  *			just like UNIX M4.  Warning:  macro calls must NOT  *			cross file boundaries.  UNIX M4 doesn't mind;  *			(m4 a b c) and (cat a b c | m4) are just the same  *			except for error messages.  PD M4 will report an  *			unexpected EOF if a file ends while a macro call or  *			string is still being parsed.  When there is one  *			file name argument, or none, you can't tell the  *			difference, and that's all I need.  *  * May 15 1991 RAOK	DIVNAM was a string constant, but was changed!  *			Fixed that and a couple of other things to make  *			GCC happy.  (Also made "foo$bar" get through.)  *  * Apr 17 1991 RAOK	There was a major mistake.  If you did  *			define(foo, `1 include(bar) 2') where  *			file bar held "-bar-" you would naturally  *			expect "1 -bar- 2" as the output, but you  *			got "1  2-bar-".  That is, include file  *			processing was postponed until all macros  *			had been expanded.  The macro gpbc() was  *			at fault.  I added bb, bbstack[], and the  *			code in main.c and serv.c that maintains  *			them, in order to work around this bug.  *  * Apr 12 1991 RAOK	inspect() didn't handle overflow well.  *			Added the automatically maintained macro  *			__FILE__, just as in C.  To suppress it,  *			define NO__FILE.  At some point, $# had  *			been made to return a value that was off  *			by one; it now agrees with SysV M4.  *  * Aug 13 1990 RAOK	The System V expr() has three arguments:  *			expression [, radix:10 [, mindigits: 1]]  *			Brought in my int2str() and wrote pbrad()  *			to make this work here.  With the wrong #  *			of args, acts like System V.  *  * Aug 11 1990 RAOK	Told expr.c about the Pascal operators  *			not, div, mod, and, or  *			so that Pascal constant expressions could  *			be evaluated.  (It still doesn't handle  *			floats.)  Fixed a mistake in 'character's.  *  * Apr 23 1988 RAOK	Sped it up, mainly by making putback() and  *			chrsave() into macros.  *			Finished the -o option (was half done).  *			Added the System V -e (interactive) option.  *  * Jan 28 1986 Oz	Break the whole thing into little  *			pieces, for easier (?) maintenance.  *  * Dec 12 1985 Oz	Optimize the code, try to squeeze  *			few microseconds out.. [didn't try very hard]  *  * Dec 05 1985 Oz	Add getopt interface, define (-D),  *			undefine (-U) options.  *  * Oct 21 1985 Oz	Clean up various bugs, add comment handling.  *  * June 7 1985 Oz	Add some of SysV m4 stuff (m4wrap, pushdef,  *			popdef, decr, shift etc.).  *  * June 5 1985 Oz	Initial cut.  *  * Implementation Notes:  *  * [1]	PD m4 uses a different (and simpler) stack mechanism than the one   *	described in Software Tools and Software Tools in Pascal books.   *	The triple stack nonsense is replaced with a single stack containing   *	the call frames and the arguments. Each frame is back-linked to a   * 	previous stack frame, which enables us to rewind the stack after   * 	each nested call is completed. Each argument is a character pointer   *	to the beginning of the argument string within the string space.  *	The only exceptions to this are (*) arg 0 and arg 1, which are  * 	the macro definition and macro name strings, stored dynamically  *	for the hash table.  *  *	    .					   .  *	|   .	|<-- sp			|  .  |  *	+-------+				+-----+  *	| arg 3 ------------------------------->| str |  *	+-------+				|  .  |  *	| arg 2 --------------+ 		   .  *	+-------+	      |  *	    *		      |			|     |  *	+-------+	      | 		+-----+  *	| plev	|<-- fp     +---------------->| str |  *	+-------+				|  .  |  *	| type	|				   .  *	+-------+  *	| prcf	-----------+		plev: paren level  *	+-------+  	   |		type: call type  *	|   .	| 	   |		prcf: prev. call frame  *	    .	   	   |  *	+-------+	   |  *	|<----------+  *	+-------+  *  * [2]	We have three types of null values:  *  *		nil  - nodeblock pointer type 0  *		null - null string ("")  *		NULL - Stdio-defined NULL  *  */
end_comment

begin_decl_stmt
name|char
name|buf
index|[
name|BUFSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* push-back buffer	       */
end_comment

begin_decl_stmt
name|char
modifier|*
name|bp
init|=
name|buf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* first available character   */
end_comment

begin_decl_stmt
name|char
modifier|*
name|bb
init|=
name|buf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* buffer beginning            */
end_comment

begin_decl_stmt
name|char
modifier|*
name|endpbb
init|=
name|buf
operator|+
name|BUFSIZE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* end of push-back buffer     */
end_comment

begin_decl_stmt
name|stae
name|mstack
index|[
name|STACKMAX
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* stack of m4 machine         */
end_comment

begin_decl_stmt
name|char
name|strspace
index|[
name|STRSPMAX
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* string space for evaluation */
end_comment

begin_decl_stmt
name|char
modifier|*
name|ep
init|=
name|strspace
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* first free char in strspace */
end_comment

begin_decl_stmt
name|char
modifier|*
name|endest
init|=
name|strspace
operator|+
name|STRSPMAX
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* end of string space	       */
end_comment

begin_decl_stmt
name|int
name|sp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current m4  stack pointer   */
end_comment

begin_decl_stmt
name|int
name|fp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* m4 call frame pointer       */
end_comment

begin_decl_stmt
name|char
modifier|*
name|bbstack
index|[
name|MAXINP
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* stack where bb is saved     */
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|infile
index|[
name|MAXINP
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* input file stack (0=stdin)  */
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|outfile
index|[
name|MAXOUT
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* diversion array(0=bitbucket)*/
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|active
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* active output file pointer  */
end_comment

begin_decl_stmt
name|int
name|ilevel
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* input file stack pointer    */
end_comment

begin_decl_stmt
name|int
name|oindex
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* diversion index..	       */
end_comment

begin_decl_stmt
name|char
modifier|*
name|null
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* as it says.. just a null..  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|m4wraps
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* m4wrap string default..     */
end_comment

begin_decl_stmt
name|char
name|lquote
init|=
name|LQUOTE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* left quote character  (`)   */
end_comment

begin_decl_stmt
name|char
name|rquote
init|=
name|RQUOTE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* right quote character (')   */
end_comment

begin_decl_stmt
name|char
name|vquote
init|=
name|VQUOTE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* verbatim quote character ^V */
end_comment

begin_decl_stmt
name|char
name|scommt
init|=
name|SCOMMT
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* start character for comment */
end_comment

begin_decl_stmt
name|char
name|ecommt
init|=
name|ECOMMT
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* end character for comment   */
end_comment

begin_decl_stmt
name|int
name|strip
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* throw away comments?        */
end_comment

begin_comment
comment|/*  Definitions of diversion files.  The last 6 characters MUST be     "XXXXXX" -- that is a requirement of mktemp().  The character     '0' is to be replaced by the diversion number; we assume here     that it is just before the Xs.  If not, you will have to alter     the definition of UNIQUE. */
end_comment

begin_if
if|#
directive|if
name|unix
end_if

begin_decl_stmt
specifier|static
name|char
name|DIVNAM
index|[]
init|=
literal|"/tmp/m40XXXXXX"
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|vms
end_if

begin_decl_stmt
specifier|static
name|char
name|DIVNAM
index|[]
init|=
literal|"sys$login:m40XXXXXX"
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|char
name|DIVNAM
index|[]
init|=
literal|"M40XXXXXX"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* was \M4, should it be \\M4? */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|UNIQUE
init|=
sizeof|sizeof
name|DIVNAM
operator|-
literal|7
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* where to change m4temp.     */
end_comment

begin_decl_stmt
name|char
modifier|*
name|m4temp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* filename for diversions     */
end_comment

begin_function_decl
specifier|extern
name|char
modifier|*
name|mktemp
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|void
name|cantread
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"m4: %s: "
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"cannot open for input."
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  initkwds()     initialises the hash table to contain all the m4 built-in functions.     The original version breached module boundaries, but there did not     seem to be any benefit in that. */
end_comment

begin_function
specifier|static
name|void
name|initkwds
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|static
struct|struct
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|type
decl_stmt|;
block|}
name|keyword
index|[]
init|=
block|{
literal|"include"
block|,
name|INCLTYPE
block|,
literal|"sinclude"
block|,
name|SINCTYPE
block|,
literal|"define"
block|,
name|DEFITYPE
block|,
literal|"defn"
block|,
name|DEFNTYPE
block|,
literal|"divert"
block|,
name|DIVRTYPE
block|,
literal|"expr"
block|,
name|EXPRTYPE
block|,
literal|"eval"
block|,
name|EXPRTYPE
block|,
literal|"substr"
block|,
name|SUBSTYPE
block|,
literal|"ifelse"
block|,
name|IFELTYPE
block|,
literal|"ifdef"
block|,
name|IFDFTYPE
block|,
literal|"len"
block|,
name|LENGTYPE
block|,
literal|"incr"
block|,
name|INCRTYPE
block|,
literal|"decr"
block|,
name|DECRTYPE
block|,
literal|"dnl"
block|,
name|DNLNTYPE
block|,
literal|"changequote"
block|,
name|CHNQTYPE
block|,
literal|"changecom"
block|,
name|CHNCTYPE
block|,
literal|"index"
block|,
name|INDXTYPE
block|,
ifdef|#
directive|ifdef
name|EXTENDED
literal|"paste"
block|,
name|PASTTYPE
block|,
literal|"spaste"
block|,
name|SPASTYPE
block|,
literal|"m4trim"
block|,
name|TRIMTYPE
block|,
literal|"defquote"
block|,
name|DEFQTYPE
block|,
endif|#
directive|endif
literal|"popdef"
block|,
name|POPDTYPE
block|,
literal|"pushdef"
block|,
name|PUSDTYPE
block|,
literal|"dumpdef"
block|,
name|DUMPTYPE
block|,
literal|"shift"
block|,
name|SHIFTYPE
block|,
literal|"translit"
block|,
name|TRNLTYPE
block|,
literal|"undefine"
block|,
name|UNDFTYPE
block|,
literal|"undivert"
block|,
name|UNDVTYPE
block|,
literal|"divnum"
block|,
name|DIVNTYPE
block|,
literal|"maketemp"
block|,
name|MKTMTYPE
block|,
literal|"errprint"
block|,
name|ERRPTYPE
block|,
literal|"m4wrap"
block|,
name|M4WRTYPE
block|,
literal|"m4exit"
block|,
name|EXITTYPE
block|,
if|#
directive|if
name|unix
operator|||
name|vms
literal|"syscmd"
block|,
name|SYSCTYPE
block|,
literal|"sysval"
block|,
name|SYSVTYPE
block|,
endif|#
directive|endif
if|#
directive|if
name|unix
literal|"unix"
block|,
name|MACRTYPE
block|,
else|#
directive|else
if|#
directive|if
name|vms
literal|"vms"
block|,
name|MACRTYPE
block|,
endif|#
directive|endif
endif|#
directive|endif
operator|(
name|char
operator|*
operator|)
literal|0
block|,
literal|0
block|}
struct|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|keyword
index|[
name|i
index|]
operator|.
name|type
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
name|addkywd
argument_list|(
name|keyword
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|keyword
index|[
name|i
index|]
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  inspect(Name)     Build an input token.., considering only those which start with     [A-Za-z_].  This is fused with lookup() to speed things up.     name must point to an array of at least MAXTOK characters. */
end_comment

begin_function
name|ndptr
name|inspect
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|tp
init|=
name|name
decl_stmt|;
specifier|register
name|char
modifier|*
name|etp
init|=
name|name
operator|+
operator|(
name|MAXTOK
operator|-
literal|1
operator|)
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|unsigned
name|long
name|h
init|=
literal|0
decl_stmt|;
specifier|register
name|ndptr
name|p
decl_stmt|;
while|while
condition|(
name|is_sym2
argument_list|(
name|c
operator|=
name|gpbc
argument_list|()
argument_list|)
condition|)
block|{
if|if
condition|(
name|tp
operator|==
name|etp
condition|)
name|error
argument_list|(
literal|"m4: token too long"
argument_list|)
expr_stmt|;
operator|*
name|tp
operator|++
operator|=
name|c
operator|,
name|h
operator|=
operator|(
name|h
operator|<<
literal|5
operator|)
operator|+
name|h
operator|+
name|c
expr_stmt|;
block|}
name|putback
argument_list|(
name|c
argument_list|)
expr_stmt|;
operator|*
name|tp
operator|=
name|EOS
expr_stmt|;
for|for
control|(
name|p
operator|=
name|hashtab
index|[
name|h
operator|%
name|HASHSIZE
index|]
init|;
name|p
operator|!=
name|nil
condition|;
name|p
operator|=
name|p
operator|->
name|nxtptr
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|p
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|p
return|;
return|return
name|nil
return|;
block|}
end_function

begin_comment
comment|/*  * macro - the work horse..  *  */
end_comment

begin_function
name|void
name|macro
parameter_list|()
block|{
name|char
name|token
index|[
name|MAXTOK
index|]
decl_stmt|;
specifier|register
name|int
name|t
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|op
init|=
name|active
decl_stmt|;
specifier|static
name|char
name|ovmsg
index|[]
init|=
literal|"m4: internal stack overflow"
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|t
operator|=
name|gpbc
argument_list|()
expr_stmt|;
if|if
condition|(
name|is_sym1
argument_list|(
name|t
argument_list|)
condition|)
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|ndptr
name|p
decl_stmt|;
name|putback
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|inspect
argument_list|(
name|s
operator|=
name|token
argument_list|)
operator|)
operator|==
name|nil
condition|)
block|{
if|if
condition|(
name|sp
operator|<
literal|0
condition|)
block|{
while|while
condition|(
name|t
operator|=
operator|*
name|s
operator|++
condition|)
name|putc
argument_list|(
name|t
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|t
operator|=
operator|*
name|s
operator|++
condition|)
name|chrsave
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* real thing.. First build a call frame */
if|if
condition|(
name|sp
operator|>=
name|STACKMAX
operator|-
literal|6
condition|)
name|error
argument_list|(
name|ovmsg
argument_list|)
expr_stmt|;
name|mstack
index|[
literal|1
operator|+
name|sp
index|]
operator|.
name|sfra
operator|=
name|fp
expr_stmt|;
comment|/* previous call frm */
name|mstack
index|[
literal|2
operator|+
name|sp
index|]
operator|.
name|sfra
operator|=
name|p
operator|->
name|type
expr_stmt|;
comment|/* type of the call  */
name|mstack
index|[
literal|3
operator|+
name|sp
index|]
operator|.
name|sfra
operator|=
literal|0
expr_stmt|;
comment|/* parenthesis level */
name|fp
operator|=
name|sp
operator|+
literal|3
expr_stmt|;
comment|/* new frame pointer */
comment|/* now push the string arguments */
name|mstack
index|[
literal|4
operator|+
name|sp
index|]
operator|.
name|sstr
operator|=
name|p
operator|->
name|defn
expr_stmt|;
comment|/* defn string */
name|mstack
index|[
literal|5
operator|+
name|sp
index|]
operator|.
name|sstr
operator|=
name|p
operator|->
name|name
expr_stmt|;
comment|/* macro name  */
name|mstack
index|[
literal|6
operator|+
name|sp
index|]
operator|.
name|sstr
operator|=
name|ep
expr_stmt|;
comment|/* start next.. */
name|sp
operator|+=
literal|6
expr_stmt|;
name|t
operator|=
name|gpbc
argument_list|()
expr_stmt|;
name|putback
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|!=
name|LPAREN
condition|)
block|{
name|putback
argument_list|(
name|RPAREN
argument_list|)
expr_stmt|;
name|putback
argument_list|(
name|LPAREN
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|t
operator|==
name|EOF
condition|)
block|{
if|if
condition|(
name|sp
operator|>=
literal|0
condition|)
name|error
argument_list|(
literal|"m4: unexpected end of input"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|ilevel
operator|<
literal|0
condition|)
break|break;
comment|/* all done thanks */
ifndef|#
directive|ifndef
name|NO__FILE
name|remhash
argument_list|(
literal|"__FILE__"
argument_list|,
name|TOP
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bb
operator|=
name|bbstack
index|[
name|ilevel
operator|+
literal|1
index|]
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|infile
index|[
name|ilevel
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
comment|/* non-alpha single-char token seen.. 		[the order of else if .. stmts is important.]  	    */
if|if
condition|(
name|t
operator|==
name|lquote
condition|)
block|{
comment|/* strip quotes */
specifier|register
name|int
name|nlpar
decl_stmt|;
for|for
control|(
name|nlpar
operator|=
literal|1
init|;
condition|;
control|)
block|{
name|t
operator|=
name|gpbc
argument_list|()
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|rquote
condition|)
block|{
if|if
condition|(
operator|--
name|nlpar
operator|==
literal|0
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|t
operator|==
name|lquote
condition|)
block|{
name|nlpar
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|t
operator|==
name|vquote
condition|)
name|t
operator|=
name|gpbc
argument_list|()
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|EOF
condition|)
block|{
name|error
argument_list|(
literal|"m4: missing right quote"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sp
operator|<
literal|0
condition|)
block|{
name|putc
argument_list|(
name|t
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|chrsave
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|sp
operator|<
literal|0
condition|)
block|{
comment|/* not in a macro at all */
if|if
condition|(
name|t
operator|!=
name|scommt
condition|)
block|{
comment|/* not a comment, so */
name|putc
argument_list|(
name|t
argument_list|,
name|op
argument_list|)
expr_stmt|;
comment|/* copy it to output */
block|}
elseif|else
if|if
condition|(
name|strip
condition|)
block|{
comment|/* discard a comment */
do|do
block|{
name|t
operator|=
name|gpbc
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|t
operator|!=
name|ecommt
operator|&&
name|t
operator|!=
name|EOF
condition|)
do|;
block|}
else|else
block|{
comment|/* copy comment to output */
do|do
block|{
name|putc
argument_list|(
name|t
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|t
operator|=
name|gpbc
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|t
operator|!=
name|ecommt
operator|&&
name|t
operator|!=
name|EOF
condition|)
do|;
name|putc
argument_list|(
name|t
argument_list|,
name|op
argument_list|)
expr_stmt|;
comment|/*  A note on comment handling:  this is NOT robust. 		    |   We should do something safe with comments that 		    |   are missing their ecommt termination. 		    */
block|}
block|}
else|else
switch|switch
condition|(
name|t
condition|)
block|{
comment|/*  There is a peculiar detail to notice here. 		    Layout is _always_ discarded after left parentheses, 		    but it is only discarded after commas if they separate 		    arguments.  For example, 		    define(foo,`|$1|$2|') 		    foo( a, b)		=> |a|b| 		    foo(( a ), ( b ))	=> |(a )|(b )| 		    foo((a, x), (b, y))	=> |(a, x)|(b, y)| 		    I find this counter-intuitive, and would expect the code 		    for LPAREN to read something like this:  		    if (PARLEV == 0) { 			(* top level left parenthesis: skip layout *) 			do t = gpbc(); while (is_blnk(t)); 			putback(t); 		    } else { 			(* left parenthesis inside an argument *) 			chrsave(t); 		    } 		    PARLEV++;  		    However, it turned out that Oz wrote the actual code 		    very carefully to mimic the behaviour of "real" m4; 		    UNIX m4 really does skip layout after all left parens 		    but only some commas in just this fashion.  Sigh. 		*/
case|case
name|LPAREN
case|:
if|if
condition|(
name|PARLEV
operator|>
literal|0
condition|)
name|chrsave
argument_list|(
name|t
argument_list|)
expr_stmt|;
do|do
name|t
operator|=
name|gpbc
argument_list|()
expr_stmt|;
do|while
condition|(
name|is_blnk
argument_list|(
name|t
argument_list|)
condition|)
do|;
comment|/* skip layout */
name|putback
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|PARLEV
operator|++
expr_stmt|;
break|break;
case|case
name|COMMA
case|:
if|if
condition|(
name|PARLEV
operator|==
literal|1
condition|)
block|{
name|chrsave
argument_list|(
name|EOS
argument_list|)
expr_stmt|;
comment|/* new argument   */
if|if
condition|(
name|sp
operator|>=
name|STACKMAX
condition|)
name|error
argument_list|(
name|ovmsg
argument_list|)
expr_stmt|;
do|do
name|t
operator|=
name|gpbc
argument_list|()
expr_stmt|;
do|while
condition|(
name|is_blnk
argument_list|(
name|t
argument_list|)
condition|)
do|;
comment|/* skip layout */
name|putback
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|mstack
index|[
operator|++
name|sp
index|]
operator|.
name|sstr
operator|=
name|ep
expr_stmt|;
block|}
else|else
block|{
name|chrsave
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|RPAREN
case|:
if|if
condition|(
operator|--
name|PARLEV
operator|>
literal|0
condition|)
block|{
name|chrsave
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
modifier|*
name|argv
init|=
operator|(
name|char
operator|*
operator|*
operator|)
operator|(
name|mstack
operator|+
name|fp
operator|+
literal|1
operator|)
decl_stmt|;
name|int
name|argc
init|=
name|sp
operator|-
name|fp
decl_stmt|;
if|#
directive|if
name|unix
operator||
name|vms
specifier|static
name|int
name|sysval
decl_stmt|;
endif|#
directive|endif
name|chrsave
argument_list|(
name|EOS
argument_list|)
expr_stmt|;
comment|/* last argument */
if|if
condition|(
name|sp
operator|>=
name|STACKMAX
condition|)
name|error
argument_list|(
name|ovmsg
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"argc = %d\n"
argument_list|,
name|argc
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
literal|0
init|;
name|t
operator|<
name|argc
condition|;
name|t
operator|++
control|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"argv[%d] = %s\n"
argument_list|,
name|t
argument_list|,
name|argv
index|[
name|t
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*  If argc == 3 and argv[2] is null, then we 			    have a call like `macro_or_builtin()'.  We 			    adjust argc to avoid further checking.. 			*/
if|if
condition|(
name|argc
operator|==
literal|3
operator|&&
operator|!
name|argv
index|[
literal|2
index|]
index|[
literal|0
index|]
condition|)
name|argc
operator|--
expr_stmt|;
switch|switch
condition|(
name|CALTYP
operator|&
operator|~
name|STATIC
condition|)
block|{
case|case
name|MACRTYPE
case|:
name|expand
argument_list|(
name|argv
argument_list|,
name|argc
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEFITYPE
case|:
comment|/* define(..) */
for|for
control|(
init|;
name|argc
operator|>
literal|2
condition|;
name|argc
operator|-=
literal|2
operator|,
name|argv
operator|+=
literal|2
control|)
name|dodefine
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|,
name|argc
operator|>
literal|3
condition|?
name|argv
index|[
literal|3
index|]
else|:
name|null
argument_list|)
expr_stmt|;
break|break;
case|case
name|PUSDTYPE
case|:
comment|/* pushdef(..) */
for|for
control|(
init|;
name|argc
operator|>
literal|2
condition|;
name|argc
operator|-=
literal|2
operator|,
name|argv
operator|+=
literal|2
control|)
name|dopushdef
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|,
name|argc
operator|>
literal|3
condition|?
name|argv
index|[
literal|3
index|]
else|:
name|null
argument_list|)
expr_stmt|;
break|break;
case|case
name|DUMPTYPE
case|:
name|dodump
argument_list|(
name|argv
argument_list|,
name|argc
argument_list|)
expr_stmt|;
break|break;
case|case
name|EXPRTYPE
case|:
comment|/* eval(Expr) */
block|{
comment|/* evaluate arithmetic expression */
comment|/* eval([val: 0[, radix:10 [,min: 1]]]) */
comment|/* excess arguments are ignored */
comment|/* eval() with no arguments returns 0 */
comment|/* this is based on V.3 behaviour */
name|int
name|min_digits
init|=
literal|1
decl_stmt|;
name|int
name|radix
init|=
literal|10
decl_stmt|;
name|long
name|int
name|value
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|argc
condition|)
block|{
default|default:
comment|/* ignore excess arguments */
case|case
literal|5
case|:
name|min_digits
operator|=
name|expr
argument_list|(
name|argv
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
case|case
literal|4
case|:
name|radix
operator|=
name|expr
argument_list|(
name|argv
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
case|case
literal|3
case|:
name|value
operator|=
name|expr
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
case|case
literal|2
case|:
break|break;
block|}
name|pbrad
argument_list|(
name|value
argument_list|,
name|radix
argument_list|,
name|min_digits
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|IFELTYPE
case|:
comment|/* ifelse(X,Y,IFX=Y,Else) */
name|doifelse
argument_list|(
name|argv
argument_list|,
name|argc
argument_list|)
expr_stmt|;
break|break;
case|case
name|IFDFTYPE
case|:
comment|/* ifdef(Mac,IfDef[,IfNotDef]) */
comment|/* select one of two alternatives based on the existence */
comment|/* of another definition */
if|if
condition|(
name|argc
operator|>
literal|3
condition|)
block|{
if|if
condition|(
name|lookup
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|)
operator|!=
name|nil
condition|)
block|{
name|pbstr
argument_list|(
name|argv
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argc
operator|>
literal|4
condition|)
block|{
name|pbstr
argument_list|(
name|argv
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|LENGTYPE
case|:
comment|/* len(Arg) */
comment|/* find the length of the argument */
name|pbnum
argument_list|(
name|argc
operator|>
literal|2
condition|?
name|strlen
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|)
else|:
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|INCRTYPE
case|:
comment|/* incr(Expr) */
comment|/* increment the value of the argument */
if|if
condition|(
name|argc
operator|>
literal|2
condition|)
name|pbnum
argument_list|(
name|expr
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|DECRTYPE
case|:
comment|/* decr(Expr) */
comment|/* decrement the value of the argument */
if|if
condition|(
name|argc
operator|>
literal|2
condition|)
name|pbnum
argument_list|(
name|expr
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
if|#
directive|if
name|unix
operator|||
name|vms
case|case
name|SYSCTYPE
case|:
comment|/* syscmd(Command) */
comment|/* execute system command */
comment|/* Make sure m4 output is NOT interrupted */
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|>
literal|2
condition|)
name|sysval
operator|=
name|system
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|SYSVTYPE
case|:
comment|/* sysval() */
comment|/* return value of the last system call.  */
name|pbnum
argument_list|(
name|sysval
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|INCLTYPE
case|:
comment|/* include(File) */
for|for
control|(
name|t
operator|=
literal|2
init|;
name|t
operator|<
name|argc
condition|;
name|t
operator|++
control|)
if|if
condition|(
operator|!
name|doincl
argument_list|(
name|argv
index|[
name|t
index|]
argument_list|)
condition|)
name|cantread
argument_list|(
name|argv
index|[
name|t
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|SINCTYPE
case|:
comment|/* sinclude(File) */
for|for
control|(
name|t
operator|=
literal|2
init|;
name|t
operator|<
name|argc
condition|;
name|t
operator|++
control|)
operator|(
name|void
operator|)
name|doincl
argument_list|(
name|argv
index|[
name|t
index|]
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|EXTENDED
case|case
name|PASTTYPE
case|:
comment|/* paste(File) */
for|for
control|(
name|t
operator|=
literal|2
init|;
name|t
operator|<
name|argc
condition|;
name|t
operator|++
control|)
if|if
condition|(
operator|!
name|dopaste
argument_list|(
name|argv
index|[
name|t
index|]
argument_list|)
condition|)
name|cantread
argument_list|(
name|argv
index|[
name|t
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|SPASTYPE
case|:
comment|/* spaste(File) */
for|for
control|(
name|t
operator|=
literal|2
init|;
name|t
operator|<
name|argc
condition|;
name|t
operator|++
control|)
operator|(
name|void
operator|)
name|dopaste
argument_list|(
name|argv
index|[
name|t
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|TRIMTYPE
case|:
comment|/* m4trim(Source,..) */
if|if
condition|(
name|argc
operator|>
literal|2
condition|)
name|m4trim
argument_list|(
name|argv
argument_list|,
name|argc
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEFQTYPE
case|:
comment|/* defquote(Mac,...) */
name|dodefqt
argument_list|(
name|argv
argument_list|,
name|argc
argument_list|)
expr_stmt|;
break|break;
case|case
name|QUTRTYPE
case|:
comment|/*<quote>(text...) */
name|doqutr
argument_list|(
name|argv
argument_list|,
name|argc
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|CHNQTYPE
case|:
comment|/* changequote([Left[,Right]]) */
name|dochq
argument_list|(
name|argv
argument_list|,
name|argc
argument_list|)
expr_stmt|;
break|break;
case|case
name|CHNCTYPE
case|:
comment|/* changecom([Left[,Right]]) */
name|dochc
argument_list|(
name|argv
argument_list|,
name|argc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SUBSTYPE
case|:
comment|/* substr(Source[,Offset[,Length]]) */
comment|/* select substring */
if|if
condition|(
name|argc
operator|>
literal|3
condition|)
name|dosub
argument_list|(
name|argv
argument_list|,
name|argc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SHIFTYPE
case|:
comment|/* shift(~args~) */
comment|/* push back all arguments except the first one */
comment|/* (i.e.  skip argv[2]) */
if|if
condition|(
name|argc
operator|>
literal|3
condition|)
block|{
for|for
control|(
name|t
operator|=
name|argc
operator|-
literal|1
init|;
name|t
operator|>
literal|3
condition|;
name|t
operator|--
control|)
block|{
name|pbqtd
argument_list|(
name|argv
index|[
name|t
index|]
argument_list|)
expr_stmt|;
name|putback
argument_list|(
literal|','
argument_list|)
expr_stmt|;
block|}
name|pbqtd
argument_list|(
name|argv
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DIVRTYPE
case|:
comment|/* divert(N) */
if|if
condition|(
name|argc
operator|>
literal|2
operator|&&
operator|(
name|t
operator|=
name|expr
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|dodiv
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|active
operator|=
name|stdout
expr_stmt|;
name|oindex
operator|=
literal|0
expr_stmt|;
block|}
name|op
operator|=
name|active
expr_stmt|;
break|break;
case|case
name|UNDVTYPE
case|:
comment|/* undivert(N...) */
name|doundiv
argument_list|(
name|argv
argument_list|,
name|argc
argument_list|)
expr_stmt|;
name|op
operator|=
name|active
expr_stmt|;
break|break;
case|case
name|DIVNTYPE
case|:
comment|/* divnum() */
comment|/* return the number of current output diversion */
name|pbnum
argument_list|(
name|oindex
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNDFTYPE
case|:
comment|/* undefine(..) */
comment|/* undefine a previously defined macro(s) or m4 keyword(s). */
for|for
control|(
name|t
operator|=
literal|2
init|;
name|t
operator|<
name|argc
condition|;
name|t
operator|++
control|)
name|remhash
argument_list|(
name|argv
index|[
name|t
index|]
argument_list|,
name|ALL
argument_list|)
expr_stmt|;
break|break;
case|case
name|POPDTYPE
case|:
comment|/* popdef(Mac...) */
comment|/* remove the topmost definitions of macro(s) or m4 keyword(s). */
for|for
control|(
name|t
operator|=
literal|2
init|;
name|t
operator|<
name|argc
condition|;
name|t
operator|++
control|)
name|remhash
argument_list|(
name|argv
index|[
name|t
index|]
argument_list|,
name|TOP
argument_list|)
expr_stmt|;
break|break;
case|case
name|MKTMTYPE
case|:
comment|/* maketemp(Pattern) */
comment|/* create a temporary file */
if|if
condition|(
name|argc
operator|>
literal|2
condition|)
name|pbstr
argument_list|(
name|mktemp
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TRNLTYPE
case|:
comment|/* translit(Source,Dom,Rng) */
comment|/* replace all characters in the source string that */
comment|/* appears in the "from" string with the corresponding */
comment|/* characters in the "to" string. */
if|if
condition|(
name|argc
operator|>
literal|3
condition|)
block|{
name|char
name|temp
index|[
name|MAXTOK
index|]
decl_stmt|;
if|if
condition|(
name|argc
operator|>
literal|4
condition|)
name|map
argument_list|(
name|temp
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
name|argv
index|[
literal|3
index|]
argument_list|,
name|argv
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
else|else
name|map
argument_list|(
name|temp
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
name|argv
index|[
literal|3
index|]
argument_list|,
name|null
argument_list|)
expr_stmt|;
name|pbstr
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argc
operator|>
literal|2
condition|)
name|pbstr
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|INDXTYPE
case|:
comment|/* index(Source,Target) */
comment|/* find the index of the second argument string in */
comment|/* the first argument string. -1 if not present. */
name|pbnum
argument_list|(
name|argc
operator|>
literal|3
condition|?
name|indx
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|,
name|argv
index|[
literal|3
index|]
argument_list|)
else|:
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|ERRPTYPE
case|:
comment|/* errprint(W,...,W) */
comment|/* print the arguments to stderr file */
for|for
control|(
name|t
operator|=
literal|2
init|;
name|t
operator|<
name|argc
condition|;
name|t
operator|++
control|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s "
argument_list|,
name|argv
index|[
name|t
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DNLNTYPE
case|:
comment|/* dnl() */
comment|/* eat upto and including newline */
while|while
condition|(
operator|(
name|t
operator|=
name|gpbc
argument_list|()
operator|)
operator|!=
literal|'\n'
operator|&&
name|t
operator|!=
name|EOF
condition|)
empty_stmt|;
break|break;
case|case
name|M4WRTYPE
case|:
comment|/* m4wrap(AtExit) */
comment|/* set up for wrap-up/wind-down activity.   */
comment|/* NB: if there are several calls to m4wrap */
comment|/* only the last is effective; strange, but */
comment|/* that's what System V does.               */
name|m4wraps
operator|=
name|argc
operator|>
literal|2
condition|?
name|strsave
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|)
else|:
name|null
expr_stmt|;
break|break;
case|case
name|EXITTYPE
case|:
comment|/* m4exit(Expr) */
comment|/* immediate exit from m4.  */
name|killdiv
argument_list|()
expr_stmt|;
comment|/* mustn't forget that one! */
name|exit
argument_list|(
name|argc
operator|>
literal|2
condition|?
name|expr
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|)
else|:
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEFNTYPE
case|:
comment|/* defn(Mac) */
for|for
control|(
name|t
operator|=
literal|2
init|;
name|t
operator|<
name|argc
condition|;
name|t
operator|++
control|)
name|dodefn
argument_list|(
name|argv
index|[
name|t
index|]
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"m4: major botch in eval."
argument_list|)
expr_stmt|;
break|break;
block|}
name|ep
operator|=
name|PREVEP
expr_stmt|;
comment|/* flush strspace */
name|sp
operator|=
name|PREVSP
expr_stmt|;
comment|/* previous sp..  */
name|fp
operator|=
name|PREVFP
expr_stmt|;
comment|/* rewind stack... */
block|}
break|break;
default|default:
name|chrsave
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* stack the char */
break|break;
block|}
block|}
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
ifdef|#
directive|ifdef
name|SIGINT
if|if
condition|(
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|onintr
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*  Initialise the chtype[] table. 	    '0' .. '9' -> 1..10 	    'A' .. 'Z' -> 11..37 	    'a' .. 'z' -> 11..37 	    '_' -> 38 	    all other characters -> 0 	*/
for|for
control|(
name|c
operator|=
name|EOF
init|;
name|c
operator|<=
name|UCHAR_MAX
condition|;
name|c
operator|++
control|)
name|chtype
index|[
name|c
operator|-
name|EOF
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|1
operator|,
name|p
operator|=
literal|"0123456789"
init|;
operator|*
name|p
condition|;
name|p
operator|++
operator|,
name|c
operator|++
control|)
name|chtype
index|[
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|)
name|p
operator|-
name|EOF
index|]
operator|=
name|c
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|11
operator|,
name|p
operator|=
literal|"abcdefghijklmnopqrstuvwxyz"
init|;
operator|*
name|p
condition|;
name|p
operator|++
operator|,
name|c
operator|++
control|)
name|chtype
index|[
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|)
name|p
operator|-
name|EOF
index|]
operator|=
name|c
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|11
operator|,
name|p
operator|=
literal|"ABCDEFGHIJKLMNOPQRSTUVWXYZ"
init|;
operator|*
name|p
condition|;
name|p
operator|++
operator|,
name|c
operator|++
control|)
name|chtype
index|[
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|)
name|p
operator|-
name|EOF
index|]
operator|=
name|c
expr_stmt|;
name|chtype
index|[
literal|'_'
operator|-
name|EOF
index|]
operator|=
literal|38
expr_stmt|;
ifdef|#
directive|ifdef
name|NONZEROPAGES
comment|/*  If your system does not initialise global variables to  */
comment|/*  0 bits, do it here.					    */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|HASHSIZE
condition|;
name|n
operator|++
control|)
name|hashtab
index|[
name|n
index|]
operator|=
name|nil
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|MAXOUT
condition|;
name|n
operator|++
control|)
name|outfile
index|[
name|n
index|]
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
name|initkwds
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"cetD:U:o:B:H:S:T:"
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
if|#
directive|if
literal|0
block|case 's':
comment|/* enable #line sync in output */
block|fprintf(stderr, "m4: this version does not support -s\n"); 		    exit(2);
endif|#
directive|endif
case|case
literal|'c'
case|:
comment|/* strip comments */
name|strip
operator|^=
literal|1
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
comment|/* interactive */
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|setbuf
argument_list|(
name|stdout
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
comment|/* define something..*/
for|for
control|(
name|p
operator|=
name|optarg
init|;
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|'='
condition|;
name|p
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|p
condition|)
operator|*
name|p
operator|++
operator|=
name|EOS
expr_stmt|;
name|dodefine
argument_list|(
name|optarg
argument_list|,
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'U'
case|:
comment|/* undefine...       */
name|remhash
argument_list|(
name|optarg
argument_list|,
name|TOP
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
case|case
literal|'H'
case|:
comment|/* System V compatibility */
case|case
literal|'S'
case|:
case|case
literal|'T'
case|:
comment|/* ignore them */
break|break;
case|case
literal|'o'
case|:
comment|/* specific output   */
if|if
condition|(
operator|!
name|freopen
argument_list|(
name|optarg
argument_list|,
literal|"w"
argument_list|,
name|stdout
argument_list|)
condition|)
block|{
name|perror
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'?'
case|:
default|default:
name|usage
argument_list|()
expr_stmt|;
block|}
block|}
name|active
operator|=
name|stdout
expr_stmt|;
comment|/* default active output     */
name|m4temp
operator|=
name|mktemp
argument_list|(
name|DIVNAM
argument_list|)
expr_stmt|;
comment|/* filename for diversions   */
name|sp
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* stack pointer initialized */
name|fp
operator|=
literal|0
expr_stmt|;
comment|/* frame pointer initialized */
if|if
condition|(
name|optind
operator|==
name|argc
condition|)
block|{
comment|/* no more args; read stdin  */
name|infile
index|[
literal|0
index|]
operator|=
name|stdin
expr_stmt|;
comment|/* default input (naturally) */
ifndef|#
directive|ifndef
name|NO__FILE
name|dodefine
argument_list|(
literal|"__FILE__"
argument_list|,
literal|"-"
argument_list|)
expr_stmt|;
comment|/* Helas */
endif|#
directive|endif
name|macro
argument_list|()
expr_stmt|;
comment|/* process that file         */
block|}
else|else
comment|/* file names in commandline */
for|for
control|(
init|;
name|optind
operator|<
name|argc
condition|;
name|optind
operator|++
control|)
block|{
name|char
modifier|*
name|name
init|=
name|argv
index|[
name|optind
index|]
decl_stmt|;
comment|/* next file name            */
name|infile
index|[
literal|0
index|]
operator|=
name|fopen
argument_list|(
name|name
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|infile
index|[
literal|0
index|]
condition|)
name|cantread
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|sp
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* stack pointer initialized */
name|fp
operator|=
literal|0
expr_stmt|;
comment|/* frame pointer initialized */
name|ilevel
operator|=
literal|0
expr_stmt|;
comment|/* reset input file stack ptr*/
ifndef|#
directive|ifndef
name|NO__FILE
name|dodefine
argument_list|(
literal|"__FILE__"
argument_list|,
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|macro
argument_list|()
expr_stmt|;
name|fclose
argument_list|(
name|infile
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|m4wraps
condition|)
block|{
comment|/* anything for rundown ??   */
name|ilevel
operator|=
literal|0
expr_stmt|;
comment|/* in case m4wrap includes.. */
name|putback
argument_list|(
name|EOF
argument_list|)
expr_stmt|;
comment|/* eof is a must !!	     */
name|pbstr
argument_list|(
name|m4wraps
argument_list|)
expr_stmt|;
comment|/* user-defined wrapup act   */
name|macro
argument_list|()
expr_stmt|;
comment|/* last will and testament   */
block|}
if|if
condition|(
name|active
operator|!=
name|stdout
condition|)
name|active
operator|=
name|stdout
expr_stmt|;
comment|/* reset output just in case */
for|for
control|(
name|n
operator|=
literal|1
init|;
name|n
operator|<
name|MAXOUT
condition|;
name|n
operator|++
control|)
comment|/* default wrap-up: undivert */
if|if
condition|(
name|outfile
index|[
name|n
index|]
operator|!=
name|NULL
condition|)
name|getdiv
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|outfile
index|[
literal|0
index|]
operator|!=
name|NULL
condition|)
block|{
comment|/* remove bitbucket if used  */
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|outfile
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|m4temp
index|[
name|UNIQUE
index|]
operator|=
literal|'0'
expr_stmt|;
if|#
directive|if
name|unix
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|m4temp
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|remove
argument_list|(
name|m4temp
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

