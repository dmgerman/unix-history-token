begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  File   : int2str.c     Author : Richard A. O'Keefe     Updated: 6 February 1993     Defines: int2str()      int2str(dst, radix, val)     converts the (long) integer "val" to character form and moves it to     the destination string "dst" followed by a terminating NUL.  The     result is normally a pointer to this NUL character, but if the radix     is dud the result will be NullS and nothing will be changed.      If radix is -2..-36, val is taken to be SIGNED.     If radix is  2.. 36, val is taken to be UNSIGNED.     That is, val is signed if and only if radix is.  You will normally     use radix -10 only through itoa and ltoa, for radix 2, 8, or 16     unsigned is what you generally want. */
end_comment

begin_decl_stmt
specifier|static
name|char
name|dig_vec
index|[]
init|=
literal|"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
decl_stmt|;
end_decl_stmt

begin_function
name|char
modifier|*
name|int2str
parameter_list|(
name|dst
parameter_list|,
name|radix
parameter_list|,
name|val
parameter_list|)
specifier|register
name|char
modifier|*
name|dst
decl_stmt|;
specifier|register
name|int
name|radix
decl_stmt|;
specifier|register
name|long
name|val
decl_stmt|;
block|{
name|char
name|buffer
index|[
literal|65
index|]
decl_stmt|;
comment|/* Ready for 64-bit machines */
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|radix
operator|<
literal|2
operator|||
name|radix
operator|>
literal|36
condition|)
block|{
comment|/* Not 2..36 */
if|if
condition|(
name|radix
operator|>
operator|-
literal|2
operator|||
name|radix
operator|<
operator|-
literal|36
condition|)
return|return
operator|(
name|char
operator|*
operator|)
literal|0
return|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
block|{
operator|*
name|dst
operator|++
operator|=
literal|'-'
expr_stmt|;
name|val
operator|=
operator|-
name|val
expr_stmt|;
block|}
name|radix
operator|=
operator|-
name|radix
expr_stmt|;
block|}
comment|/*  The slightly contorted code which follows is due to the 	    fact that few machines directly support unsigned long / and %. 	    Certainly the VAX C compiler generates a subroutine call.  In 	    the interests of efficiency (hollow laugh) I let this happen 	    for the first digit only; after that "val" will be in range so 	    that signed integer division will do.  Sorry 'bout that. 	    CHECK THE CODE PRODUCED BY YOUR C COMPILER.  The first % and / 	    should be unsigned, the second % and / signed, but C compilers 	    tend to be extraordinarily sensitive to minor details of style. 	    This works on a VAX, that's all I claim for it. 	*/
name|p
operator|=
operator|&
name|buffer
index|[
sizeof|sizeof
name|buffer
index|]
expr_stmt|;
operator|*
operator|--
name|p
operator|=
literal|'\0'
expr_stmt|;
operator|*
operator|--
name|p
operator|=
name|dig_vec
index|[
operator|(
name|unsigned
name|long
operator|)
name|val
operator|%
operator|(
name|unsigned
name|long
operator|)
name|radix
index|]
expr_stmt|;
name|val
operator|=
operator|(
name|unsigned
name|long
operator|)
name|val
operator|/
operator|(
name|unsigned
name|long
operator|)
name|radix
expr_stmt|;
while|while
condition|(
name|val
operator|!=
literal|0
condition|)
operator|*
operator|--
name|p
operator|=
name|dig_vec
index|[
name|val
operator|%
name|radix
index|]
operator|,
name|val
operator|/=
name|radix
expr_stmt|;
while|while
condition|(
operator|*
name|dst
operator|++
operator|=
operator|*
name|p
operator|++
condition|)
empty_stmt|;
return|return
name|dst
operator|-
literal|1
return|;
block|}
end_function

end_unit

