begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  File   : serv.c     Author : Ozan Yigit     Updated: 4 May 1992     Defines: Principal built-in macros for PD M4. */
end_comment

begin_include
include|#
directive|include
file|"mdef.h"
end_include

begin_include
include|#
directive|include
file|"extr.h"
end_include

begin_include
include|#
directive|include
file|"ourlims.h"
end_include

begin_define
define|#
directive|define
name|ucArgv
parameter_list|(
name|n
parameter_list|)
value|((unsigned char *)argv[n])
end_define

begin_comment
comment|/*  26-Mar-1993		Made m4trim() 8-bit clean. */
end_comment

begin_comment
comment|/*  expand(<DS FN A1 ... An>) 	     0  1  2      n+1		-- initial indices in argv[] 	    -1  0  1      n		-- after adjusting argv++, argc--     This expands a user-defined macro;  FN is the name of the macro, DS     is its definition string, and A1 ... An are its arguments. */
end_comment

begin_function
name|void
name|expand
parameter_list|(
name|argv
parameter_list|,
name|argc
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|int
name|argc
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|t
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"expand(%s,%d)\n"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
name|argc
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|argc
operator|--
expr_stmt|;
comment|/* discount definition string (-1th arg) */
name|t
operator|=
operator|*
name|argv
operator|++
expr_stmt|;
comment|/* definition string as a whole */
for|for
control|(
name|p
operator|=
name|t
init|;
operator|*
name|p
operator|++
condition|;
control|)
empty_stmt|;
name|p
operator|-=
literal|2
expr_stmt|;
comment|/* points to last character of definition */
while|while
condition|(
name|p
operator|>
name|t
condition|)
block|{
comment|/* if definition is empty, fails at once  */
if|if
condition|(
operator|*
operator|--
name|p
operator|!=
name|ARGFLAG
condition|)
block|{
name|putback
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|p
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'#'
case|:
name|pbnum
argument_list|(
name|argc
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
if|if
condition|(
operator|(
name|n
operator|=
name|p
index|[
literal|1
index|]
operator|-
literal|'0'
operator|)
operator|<
name|argc
condition|)
name|pbstr
argument_list|(
name|argv
index|[
name|n
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'*'
case|:
comment|/* push all arguments back */
for|for
control|(
name|n
operator|=
name|argc
operator|-
literal|1
init|;
name|n
operator|>
literal|1
condition|;
name|n
operator|--
control|)
block|{
name|pbstr
argument_list|(
name|argv
index|[
name|n
index|]
argument_list|)
expr_stmt|;
name|putback
argument_list|(
literal|','
argument_list|)
expr_stmt|;
block|}
name|pbstr
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'@'
case|:
comment|/* push arguments back quoted */
for|for
control|(
name|n
operator|=
name|argc
operator|-
literal|1
init|;
name|n
operator|>
literal|1
condition|;
name|n
operator|--
control|)
block|{
name|pbqtd
argument_list|(
name|argv
index|[
name|n
index|]
argument_list|)
expr_stmt|;
name|putback
argument_list|(
literal|','
argument_list|)
expr_stmt|;
block|}
name|pbqtd
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'$'
case|:
comment|/* $$ => $ */
break|break;
default|default:
name|putback
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|putback
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
name|p
operator|--
expr_stmt|;
block|}
block|}
if|if
condition|(
name|p
operator|==
name|t
condition|)
name|putback
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
comment|/* do last character */
block|}
end_function

begin_decl_stmt
specifier|static
name|char
name|nuldefmsg
index|[]
init|=
literal|"m4: defining null name."
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|recdefmsg
index|[]
init|=
literal|"m4: macro defined as itself."
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  dodefine(Name, Definition)     install Definition as the only definition of Name in the hash table.  */
end_comment

begin_function
name|void
name|dodefine
parameter_list|(
name|name
parameter_list|,
name|defn
parameter_list|)
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
specifier|register
name|char
modifier|*
name|defn
decl_stmt|;
block|{
specifier|register
name|ndptr
name|p
decl_stmt|;
if|if
condition|(
operator|!
name|name
operator|||
operator|!
operator|*
name|name
condition|)
name|error
argument_list|(
name|nuldefmsg
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|defn
argument_list|)
operator|==
literal|0
condition|)
name|error
argument_list|(
name|recdefmsg
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"define(%s,--)\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|p
operator|=
name|lookup
argument_list|(
name|name
argument_list|)
operator|)
operator|==
name|nil
condition|)
block|{
name|p
operator|=
name|addent
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|defn
operator|!=
name|null
condition|)
block|{
comment|/* what if p->type& STATIC ? */
name|free
argument_list|(
name|p
operator|->
name|defn
argument_list|)
expr_stmt|;
block|}
name|p
operator|->
name|defn
operator|=
operator|!
name|defn
operator|||
operator|!
operator|*
name|defn
condition|?
name|null
else|:
name|strsave
argument_list|(
name|defn
argument_list|)
expr_stmt|;
name|p
operator|->
name|type
operator|=
name|MACRTYPE
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  dopushdef(Name, Definition)     install Definition as the *first* definition of Name in the hash table,     but do not remove any existing definitions.  The new definition will     hide any old ones until a popdef() removes it. */
end_comment

begin_function
name|void
name|dopushdef
parameter_list|(
name|name
parameter_list|,
name|defn
parameter_list|)
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
specifier|register
name|char
modifier|*
name|defn
decl_stmt|;
block|{
specifier|register
name|ndptr
name|p
decl_stmt|;
if|if
condition|(
operator|!
name|name
operator|||
operator|!
operator|*
name|name
condition|)
name|error
argument_list|(
name|nuldefmsg
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|defn
argument_list|)
operator|==
literal|0
condition|)
name|error
argument_list|(
name|recdefmsg
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"pushdef(%s,--)\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|p
operator|=
name|addent
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|p
operator|->
name|defn
operator|=
operator|!
name|defn
operator|||
operator|!
operator|*
name|defn
condition|?
name|null
else|:
name|strsave
argument_list|(
name|defn
argument_list|)
expr_stmt|;
name|p
operator|->
name|type
operator|=
name|MACRTYPE
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  dodefn(Name)     push back a *quoted* copy of Name's definition. */
end_comment

begin_function
name|void
name|dodefn
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|ndptr
name|p
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|lookup
argument_list|(
name|name
argument_list|)
operator|)
operator|!=
name|nil
operator|&&
name|p
operator|->
name|defn
operator|!=
name|null
condition|)
name|pbqtd
argument_list|(
name|p
operator|->
name|defn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  dodump(<? dump>)		dump all definition in the hash table     dodump(<? dump F1 ... Fn>)	dump the definitions of F1 ... Fn in that order     The requested definitions are written to stderr.  What happens to names     which have a built-in (numeric) definition? */
end_comment

begin_function
name|void
name|dodump
parameter_list|(
name|argv
parameter_list|,
name|argc
parameter_list|)
specifier|register
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
specifier|register
name|int
name|argc
decl_stmt|;
block|{
specifier|register
name|int
name|n
decl_stmt|;
name|ndptr
name|p
decl_stmt|;
specifier|static
name|char
name|dumpfmt
index|[]
init|=
literal|"define(`%s',\t`%s')\n"
decl_stmt|;
if|if
condition|(
name|argc
operator|>
literal|2
condition|)
block|{
for|for
control|(
name|n
operator|=
literal|2
init|;
name|n
operator|<
name|argc
condition|;
name|n
operator|++
control|)
if|if
condition|(
operator|(
name|p
operator|=
name|lookup
argument_list|(
name|argv
index|[
name|n
index|]
argument_list|)
operator|)
operator|!=
name|nil
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|dumpfmt
argument_list|,
name|p
operator|->
name|name
argument_list|,
name|p
operator|->
name|defn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|HASHSIZE
condition|;
name|n
operator|++
control|)
for|for
control|(
name|p
operator|=
name|hashtab
index|[
name|n
index|]
init|;
name|p
operator|!=
name|nil
condition|;
name|p
operator|=
name|p
operator|->
name|nxtptr
control|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|dumpfmt
argument_list|,
name|p
operator|->
name|name
argument_list|,
name|p
operator|->
name|defn
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  doifelse(<? ifelse {x y ifx=y}... [else]>) 	      0 1       2 3 4         [2 when we get to it] */
end_comment

begin_function
name|void
name|doifelse
parameter_list|(
name|argv
parameter_list|,
name|argc
parameter_list|)
specifier|register
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
specifier|register
name|int
name|argc
decl_stmt|;
block|{
for|for
control|(
init|;
name|argc
operator|>=
literal|5
condition|;
name|argv
operator|+=
literal|3
operator|,
name|argc
operator|-=
literal|3
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|,
name|argv
index|[
literal|3
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
name|pbstr
argument_list|(
name|argv
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|argc
operator|>=
literal|3
condition|)
name|pbstr
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  doinclude(FileName)     include a given file. */
end_comment

begin_function
name|int
name|doincl
parameter_list|(
name|FileName
parameter_list|)
name|char
modifier|*
name|FileName
decl_stmt|;
block|{
if|if
condition|(
name|ilevel
operator|+
literal|1
operator|==
name|MAXINP
condition|)
name|error
argument_list|(
literal|"m4: too many include files."
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"include(%s)\n"
argument_list|,
name|FileName
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|infile
index|[
name|ilevel
operator|+
literal|1
index|]
operator|=
name|fopen
argument_list|(
name|FileName
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
ifndef|#
directive|ifndef
name|NO__FILE
name|dopushdef
argument_list|(
literal|"__FILE__"
argument_list|,
name|FileName
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bbstack
index|[
name|ilevel
operator|+
literal|1
index|]
operator|=
name|bb
expr_stmt|;
name|bb
operator|=
name|bp
expr_stmt|;
name|ilevel
operator|++
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
block|{
return|return
literal|0
return|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|EXTENDED
end_ifdef

begin_comment
comment|/*  dopaste(FileName)     copy a given file to the output stream without any macro processing. */
end_comment

begin_function
name|int
name|dopaste
parameter_list|(
name|FileName
parameter_list|)
name|char
modifier|*
name|FileName
decl_stmt|;
block|{
specifier|register
name|FILE
modifier|*
name|pf
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|afil
init|=
name|active
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
if|if
condition|(
operator|(
name|pf
operator|=
name|fopen
argument_list|(
name|FileName
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|pf
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
name|putc
argument_list|(
name|c
argument_list|,
name|afil
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|pf
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
block|{
return|return
literal|0
return|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  dochq(<? changequote [left [right [verbatim]]]>) 	   0 1            2     3      4     change the quote characters; to single characters only.     Empty arguments result in no change for that parameter.     Missing arguments result in defaults: 	changequote		=> ` ' ^V 	changequote(q)		=> q q ^V 	changequote(l,r)	=> l r ^V 	changequote(l,r,v)	=> l r v     There isn't any way of switching the verbatim-quote off,     but if you make it the same as the right quote it won't     be able to do anything (we check for R, L, V in that order). */
end_comment

begin_function
name|void
name|dochq
parameter_list|(
name|argv
parameter_list|,
name|argc
parameter_list|)
specifier|register
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
specifier|register
name|int
name|argc
decl_stmt|;
block|{
if|if
condition|(
name|argc
operator|>
literal|2
condition|)
block|{
if|if
condition|(
operator|*
name|argv
index|[
literal|2
index|]
condition|)
name|lquote
operator|=
operator|*
name|argv
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|argc
operator|>
literal|3
condition|)
block|{
if|if
condition|(
operator|*
name|argv
index|[
literal|3
index|]
condition|)
name|rquote
operator|=
operator|*
name|argv
index|[
literal|3
index|]
expr_stmt|;
if|if
condition|(
name|argc
operator|>
literal|4
operator|&&
operator|*
name|argv
index|[
literal|4
index|]
condition|)
name|vquote
operator|=
operator|*
name|argv
index|[
literal|4
index|]
expr_stmt|;
block|}
else|else
block|{
name|rquote
operator|=
name|lquote
expr_stmt|;
block|}
block|}
else|else
block|{
name|lquote
operator|=
name|LQUOTE
expr_stmt|;
name|rquote
operator|=
name|RQUOTE
expr_stmt|;
name|vquote
operator|=
name|VQUOTE
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  dochc(<? changecomment [left [right]]>)            0 1		    2     3     change the comment delimiters; to single characters only. */
end_comment

begin_function
name|void
name|dochc
parameter_list|(
name|argv
parameter_list|,
name|argc
parameter_list|)
specifier|register
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
specifier|register
name|int
name|argc
decl_stmt|;
block|{
if|if
condition|(
name|argc
operator|>
literal|2
condition|)
block|{
if|if
condition|(
operator|*
name|argv
index|[
literal|2
index|]
condition|)
name|scommt
operator|=
operator|*
name|argv
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|argc
operator|>
literal|3
condition|)
block|{
if|if
condition|(
operator|*
name|argv
index|[
literal|3
index|]
condition|)
name|ecommt
operator|=
operator|*
name|argv
index|[
literal|3
index|]
expr_stmt|;
block|}
else|else
block|{
name|ecommt
operator|=
name|ECOMMT
expr_stmt|;
block|}
block|}
else|else
block|{
name|scommt
operator|=
literal|'\0'
expr_stmt|;
comment|/* assuming no nulls in input */
name|ecommt
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  dodivert - divert the output to a temporary file */
end_comment

begin_function
name|void
name|dodiv
parameter_list|(
name|n
parameter_list|)
specifier|register
name|int
name|n
decl_stmt|;
block|{
if|if
condition|(
name|n
operator|<
literal|0
operator|||
name|n
operator|>=
name|MAXOUT
condition|)
name|n
operator|=
literal|0
expr_stmt|;
comment|/* bitbucket */
if|if
condition|(
name|outfile
index|[
name|n
index|]
operator|==
name|NULL
condition|)
block|{
name|m4temp
index|[
name|UNIQUE
index|]
operator|=
literal|'0'
operator|+
name|n
expr_stmt|;
if|if
condition|(
operator|(
name|outfile
index|[
name|n
index|]
operator|=
name|fopen
argument_list|(
name|m4temp
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"m4: cannot divert."
argument_list|)
expr_stmt|;
block|}
name|oindex
operator|=
name|n
expr_stmt|;
name|active
operator|=
name|outfile
index|[
name|n
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  doundivert - undivert a specified output, or all  *              other outputs, in numerical order. */
end_comment

begin_function
name|void
name|doundiv
parameter_list|(
name|argv
parameter_list|,
name|argc
parameter_list|)
specifier|register
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
specifier|register
name|int
name|argc
decl_stmt|;
block|{
specifier|register
name|int
name|ind
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
if|if
condition|(
name|argc
operator|>
literal|2
condition|)
block|{
for|for
control|(
name|ind
operator|=
literal|2
init|;
name|ind
operator|<
name|argc
condition|;
name|ind
operator|++
control|)
block|{
name|n
operator|=
name|expr
argument_list|(
name|argv
index|[
name|ind
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
operator|&&
name|n
operator|<
name|MAXOUT
operator|&&
name|outfile
index|[
name|n
index|]
operator|!=
name|NULL
condition|)
name|getdiv
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|n
operator|=
literal|1
init|;
name|n
operator|<
name|MAXOUT
condition|;
name|n
operator|++
control|)
if|if
condition|(
name|outfile
index|[
name|n
index|]
operator|!=
name|NULL
condition|)
name|getdiv
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  dosub(<? substr {offset} [{length}]>)     The System V Interface Definition does not say what happens when the     offset or length are out of range.  I have chosen to force them into     range, with the result that unlike the former version of this code,     dosub cannot be tricked into SIGSEGV.      BUG:  This is not 8-bit clean yet. */
end_comment

begin_function
name|void
name|dosub
parameter_list|(
name|argv
parameter_list|,
name|argc
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|int
name|argc
decl_stmt|;
block|{
specifier|register
name|int
name|nc
decl_stmt|;
comment|/* number of characters */
specifier|register
name|char
modifier|*
name|ap
init|=
name|argv
index|[
literal|2
index|]
decl_stmt|;
comment|/* target string */
specifier|register
name|int
name|al
init|=
name|strlen
argument_list|(
name|ap
argument_list|)
decl_stmt|;
comment|/* its length */
specifier|register
name|int
name|df
init|=
name|expr
argument_list|(
name|argv
index|[
literal|3
index|]
argument_list|)
decl_stmt|;
comment|/* offset */
if|if
condition|(
name|df
operator|<
literal|0
condition|)
name|df
operator|=
literal|0
expr_stmt|;
elseif|else
comment|/* force df back into the range */
if|if
condition|(
name|df
operator|>
name|al
condition|)
name|df
operator|=
name|al
expr_stmt|;
comment|/* 0<= df<= al */
name|al
operator|-=
name|df
expr_stmt|;
comment|/* now al limits nc */
if|if
condition|(
name|argc
operator|>=
literal|5
condition|)
block|{
comment|/* nc is provided */
name|nc
operator|=
name|expr
argument_list|(
name|argv
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|nc
operator|<
literal|0
condition|)
name|nc
operator|=
literal|0
expr_stmt|;
elseif|else
comment|/* force nc back into the range */
if|if
condition|(
name|nc
operator|>
name|al
condition|)
name|nc
operator|=
name|al
expr_stmt|;
comment|/* 0<= nc<= strlen(ap)-df */
block|}
else|else
block|{
name|nc
operator|=
name|al
expr_stmt|;
comment|/* default is all rest of ap */
block|}
name|ap
operator|+=
name|df
operator|+
name|nc
expr_stmt|;
while|while
condition|(
operator|--
name|nc
operator|>=
literal|0
condition|)
name|putback
argument_list|(
operator|*
operator|--
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* map(dest, src, from, to)     map every character of src that is specified in from      into "to" and replace in dest. (source "src" remains untouched)      This is a standard implementation of Icon's map(s,from,to) function.     Within mapvec, we replace every character of "from" with the     corresponding character in "to".  If "to" is shorter than "from",     then the corresponding entries are null, which means that those     characters disappear altogether.  Furthermore, imagine a call like     map(dest, "sourcestring", "srtin", "rn..*"). In this case, `s' maps     to `r', `r' maps to `n' and `n' maps to `*'. Thus, `s' ultimately     maps to `*'. In order to achieve this effect in an efficient manner     (i.e. without multiple passes over the destination string), we loop     over mapvec, starting with the initial source character.  If the     character value (dch) in this location is different from the source     character (sch), sch becomes dch, once again to index into mapvec,     until the character value stabilizes (i.e. sch = dch, in other words     mapvec[n] == n).  Even if the entry in the mapvec is null for an     ordinary character, it will stabilize, since mapvec[0] == 0 at all     times.  At the end, we restore mapvec* back to normal where     mapvec[n] == n for 0<= n<= 127.  This strategy, along with the     restoration of mapvec, is about 5 times faster than any algorithm     that makes multiple passes over the destination string. */
end_comment

begin_function
name|void
name|map
parameter_list|(
name|d
parameter_list|,
name|s
parameter_list|,
name|f
parameter_list|,
name|t
parameter_list|)
name|char
modifier|*
name|d
decl_stmt|,
decl|*
name|s
decl_stmt|,
modifier|*
name|f
decl_stmt|,
modifier|*
name|t
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|unsigned
name|char
modifier|*
name|dest
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|d
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|src
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s
decl_stmt|;
name|unsigned
name|char
modifier|*
name|from
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|f
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|to
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|t
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|tmp
decl_stmt|;
specifier|register
name|unsigned
name|char
name|sch
decl_stmt|,
name|dch
decl_stmt|;
specifier|static
name|unsigned
name|char
name|mapvec
index|[
literal|1
operator|+
name|UCHAR_MAX
index|]
init|=
block|{
literal|1
block|}
decl_stmt|;
if|if
condition|(
name|mapvec
index|[
literal|0
index|]
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|UCHAR_MAX
condition|;
name|i
operator|++
control|)
name|mapvec
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|src
operator|&&
operator|*
name|src
condition|)
block|{
comment|/* create a mapping between "from" and "to" */
if|if
condition|(
name|to
operator|&&
operator|*
name|to
condition|)
for|for
control|(
name|tmp
operator|=
name|from
init|;
name|sch
operator|=
operator|*
name|tmp
operator|++
condition|;
control|)
name|mapvec
index|[
name|sch
index|]
operator|=
operator|*
name|to
operator|++
expr_stmt|;
else|else
for|for
control|(
name|tmp
operator|=
name|from
init|;
name|sch
operator|=
operator|*
name|tmp
operator|++
condition|;
control|)
name|mapvec
index|[
name|sch
index|]
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|sch
operator|=
operator|*
name|src
operator|++
condition|)
block|{
while|while
condition|(
operator|(
name|dch
operator|=
name|mapvec
index|[
name|sch
index|]
operator|)
operator|!=
name|sch
condition|)
name|sch
operator|=
name|dch
expr_stmt|;
if|if
condition|(
operator|*
name|dest
operator|=
name|dch
condition|)
name|dest
operator|++
expr_stmt|;
block|}
comment|/* restore all the changed characters */
for|for
control|(
name|tmp
operator|=
name|from
init|;
name|sch
operator|=
operator|*
name|tmp
operator|++
condition|;
control|)
name|mapvec
index|[
name|sch
index|]
operator|=
name|sch
expr_stmt|;
block|}
operator|*
name|dest
operator|=
literal|'\0'
expr_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|EXTENDED
end_ifdef

begin_comment
comment|/*  m4trim(<? m4trim [string [leading [trailing [middle [rep]]]]]>) 	    0 1       2       3        4         5       6          (1) Any prefix consisting of characters in the "leading" set is removed. 	The default is " \t\n".     (2) Any suffix consisting of characters in the "trailing" set is removed. 	The default is to be the same as leading.     (3) Any block of consecutive characters in the "middle" set is replaced 	by the rep string.  The default for middle is " \t\n", and the 	default for rep is the first character of middle. */
end_comment

begin_function
name|void
name|m4trim
parameter_list|(
name|argv
parameter_list|,
name|argc
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|int
name|argc
decl_stmt|;
block|{
specifier|static
name|unsigned
name|char
name|repbuf
index|[
literal|2
index|]
init|=
literal|" "
decl_stmt|;
specifier|static
name|unsigned
name|char
name|layout
index|[]
init|=
literal|" \t\n\r\f"
decl_stmt|;
name|unsigned
name|char
modifier|*
name|string
init|=
name|argc
operator|>
literal|2
condition|?
name|ucArgv
argument_list|(
literal|2
argument_list|)
else|:
name|repbuf
operator|+
literal|1
decl_stmt|;
name|unsigned
name|char
modifier|*
name|leading
init|=
name|argc
operator|>
literal|3
condition|?
name|ucArgv
argument_list|(
literal|3
argument_list|)
else|:
name|layout
decl_stmt|;
name|unsigned
name|char
modifier|*
name|trailing
init|=
name|argc
operator|>
literal|4
condition|?
name|ucArgv
argument_list|(
literal|4
argument_list|)
else|:
name|leading
decl_stmt|;
name|unsigned
name|char
modifier|*
name|middle
init|=
name|argc
operator|>
literal|5
condition|?
name|ucArgv
argument_list|(
literal|5
argument_list|)
else|:
name|trailing
decl_stmt|;
name|unsigned
name|char
modifier|*
name|rep
init|=
name|argc
operator|>
literal|6
condition|?
name|ucArgv
argument_list|(
literal|6
argument_list|)
else|:
operator|(
name|repbuf
index|[
literal|0
index|]
operator|=
operator|*
name|middle
expr|,
name|repbuf
operator|)
decl_stmt|;
specifier|static
name|unsigned
name|char
name|sets
index|[
literal|1
operator|+
name|UCHAR_MAX
index|]
decl_stmt|;
define|#
directive|define
name|PREF
value|1
define|#
directive|define
name|SUFF
value|2
define|#
directive|define
name|MIDL
value|4
specifier|register
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
for|for
control|(
name|i
operator|=
name|UCHAR_MAX
init|;
name|i
operator|>=
literal|0
condition|;
control|)
name|sets
index|[
name|i
operator|--
index|]
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|leading
condition|)
name|sets
index|[
operator|*
name|leading
operator|++
index|]
operator||=
name|PREF
expr_stmt|;
while|while
condition|(
operator|*
name|trailing
condition|)
name|sets
index|[
operator|*
name|trailing
operator|++
index|]
operator||=
name|SUFF
expr_stmt|;
while|while
condition|(
operator|*
name|middle
condition|)
name|sets
index|[
operator|*
name|middle
operator|++
index|]
operator||=
name|MIDL
expr_stmt|;
while|while
condition|(
operator|*
name|string
operator|&&
name|sets
index|[
operator|*
name|string
index|]
operator|&
name|PREF
condition|)
name|string
operator|++
expr_stmt|;
name|n
operator|=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|string
argument_list|)
expr_stmt|;
while|while
condition|(
name|n
operator|>
literal|0
operator|&&
name|sets
index|[
name|string
index|[
name|n
operator|-
literal|1
index|]
index|]
operator|&
name|SUFF
condition|)
name|n
operator|--
expr_stmt|;
while|while
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|i
operator|=
name|string
index|[
operator|--
name|n
index|]
expr_stmt|;
if|if
condition|(
name|sets
index|[
name|i
index|]
operator|&
name|MIDL
condition|)
block|{
name|pbstr
argument_list|(
operator|(
name|char
operator|*
operator|)
name|rep
argument_list|)
expr_stmt|;
while|while
condition|(
name|n
operator|>
literal|0
operator|&&
name|sets
index|[
name|string
index|[
name|n
operator|-
literal|1
index|]
index|]
operator|&
name|MIDL
condition|)
name|n
operator|--
expr_stmt|;
block|}
else|else
block|{
name|putback
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  defquote(MacroName	# The name of the "quoter" macro to be defined. 	[, Opener	# default: "'".  The characters to place at the 			# beginning of the result. 	[, Separator	# default: ",".  The characters to place between 			# successive arguments. 	[, Closer	# default: same as Opener.  The characters to 			# place at the end of the result. 	[, Escape	# default: `'  The escape character to put in 			# front of things that need escaping. 	[, Default	# default: simple.  Possible values are 			# [lL].* = letter, corresponds to PLAIN1. 			# [dD].* = digit,  corresponds to PLAIN2. 			# [sS].* = simple, corresponds to SIMPLE. 			# [eE].* = escaped,corresponds to SCAPED. 			# .*,              corresponds to FANCY 	[, Letters	# default: `'.  The characters of type "L". 	[, Digits	# default: `'.  The characters of type "D". 	[, Simple	# default: `'.  The characters of type "S". 	[, Escaped	# default: `'.  The characters of type "E". 	{, Fancy	# default: none.  Each has the form `C'`Repr' 			# saying that the character C is to be represented 			# as Repr.  Can be used for trigraphs, \n,&c. 	}]]]]]]]]])      Examples: 	defquote(DOUBLEQT, ") 	defquote(SINGLEQT, ')     After these definitions, 	DOUBLEQT(a, " b", c)	=> "a,"" b"",c" 	SINGLEQT("Don't`, 'he said.") => '"Don''t, he said."'     Other examples defining quote styles for several languages will be     provided later.      A quoter is represented in M4 by a special identifying number and a     pointer to a Quoter record.  I expect that there will be few quoters     but that they will need to go fairly fast.  */
end_comment

begin_define
define|#
directive|define
name|PLAIN1
value|0
end_define

begin_define
define|#
directive|define
name|PLAIN2
value|1
end_define

begin_define
define|#
directive|define
name|SIMPLE
value|2
end_define

begin_define
define|#
directive|define
name|SCAPED
value|3
end_define

begin_define
define|#
directive|define
name|FANCY
value|4
end_define

begin_struct
struct|struct
name|Quoter
block|{
name|char
modifier|*
name|opener
decl_stmt|;
name|char
modifier|*
name|separator
decl_stmt|;
name|char
modifier|*
name|closer
decl_stmt|;
name|char
modifier|*
name|escape
decl_stmt|;
name|char
modifier|*
name|fancy
index|[
literal|1
operator|+
name|UCHAR_MAX
index|]
decl_stmt|;
name|char
name|class
index|[
literal|1
operator|+
name|UCHAR_MAX
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|void
name|freeQuoter
parameter_list|(
name|q
parameter_list|)
name|struct
name|Quoter
modifier|*
name|q
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|free
argument_list|(
name|q
operator|->
name|opener
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|q
operator|->
name|separator
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|q
operator|->
name|closer
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|q
operator|->
name|escape
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|UCHAR_MAX
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|q
operator|->
name|fancy
index|[
name|i
index|]
condition|)
name|free
argument_list|(
name|q
operator|->
name|fancy
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|q
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  dodefqt(< 	0	? 	1	defquote 	2	MacroName       [	3	Opener       [ 4	Separator       [ 5	Closer       [ 6	Escape       [ 7	Default       [ 8	Letters       [ 9	Digits       [10	Simple       [11	Escaped       [11+i	Fancy[i]	]]]]]]]]]]>) */
end_comment

begin_function
name|void
name|dodefqt
parameter_list|(
name|argv
parameter_list|,
name|argc
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|int
name|argc
decl_stmt|;
block|{
name|struct
name|Quoter
name|q
decl_stmt|,
modifier|*
name|r
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|ndptr
name|p
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|argc
operator|>
literal|2
operator|&&
operator|*
name|argv
index|[
literal|2
index|]
operator|)
condition|)
name|error
argument_list|(
name|nuldefmsg
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|argc
operator|>
literal|7
condition|?
name|argv
index|[
literal|7
index|]
index|[
literal|0
index|]
else|:
literal|'\0'
condition|)
block|{
case|case
literal|'l'
case|:
case|case
literal|'L'
case|:
name|c
operator|=
name|PLAIN1
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
case|case
literal|'D'
case|:
name|c
operator|=
name|PLAIN2
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
case|case
literal|'E'
case|:
name|c
operator|=
name|SCAPED
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
case|case
literal|'F'
case|:
name|c
operator|=
name|FANCY
expr_stmt|;
break|break;
default|default:
name|c
operator|=
name|SIMPLE
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|UCHAR_MAX
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
name|q
operator|.
name|class
index|[
name|i
index|]
operator|=
name|c
expr_stmt|;
for|for
control|(
name|i
operator|=
name|UCHAR_MAX
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
name|q
operator|.
name|fancy
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|q
operator|.
name|opener
operator|=
name|strsave
argument_list|(
name|argc
operator|>
literal|3
condition|?
name|argv
index|[
literal|3
index|]
else|:
literal|""
argument_list|)
expr_stmt|;
name|q
operator|.
name|separator
operator|=
name|strsave
argument_list|(
name|argc
operator|>
literal|4
condition|?
name|argv
index|[
literal|4
index|]
else|:
literal|","
argument_list|)
expr_stmt|;
name|q
operator|.
name|closer
operator|=
name|strsave
argument_list|(
name|argc
operator|>
literal|5
condition|?
name|argv
index|[
literal|5
index|]
else|:
name|q
operator|.
name|opener
argument_list|)
expr_stmt|;
name|q
operator|.
name|escape
operator|=
name|strsave
argument_list|(
name|argc
operator|>
literal|6
condition|?
name|argv
index|[
literal|6
index|]
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|>
literal|8
condition|)
for|for
control|(
name|s
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|argv
index|[
literal|8
index|]
init|;
name|c
operator|=
operator|*
name|s
operator|++
condition|;
control|)
name|q
operator|.
name|class
index|[
name|c
index|]
operator|=
name|PLAIN1
expr_stmt|;
if|if
condition|(
name|argc
operator|>
literal|9
condition|)
for|for
control|(
name|s
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|argv
index|[
literal|9
index|]
init|;
name|c
operator|=
operator|*
name|s
operator|++
condition|;
control|)
name|q
operator|.
name|class
index|[
name|c
index|]
operator|=
name|PLAIN2
expr_stmt|;
if|if
condition|(
name|argc
operator|>
literal|10
condition|)
for|for
control|(
name|s
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|argv
index|[
literal|10
index|]
init|;
name|c
operator|=
operator|*
name|s
operator|++
condition|;
control|)
name|q
operator|.
name|class
index|[
name|c
index|]
operator|=
name|SIMPLE
expr_stmt|;
if|if
condition|(
name|argc
operator|>
literal|11
condition|)
for|for
control|(
name|s
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|argv
index|[
literal|11
index|]
init|;
name|c
operator|=
operator|*
name|s
operator|++
condition|;
control|)
name|q
operator|.
name|class
index|[
name|c
index|]
operator|=
name|SCAPED
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|12
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|argv
index|[
name|i
index|]
expr_stmt|;
name|c
operator|=
operator|*
name|s
operator|++
expr_stmt|;
name|q
operator|.
name|fancy
index|[
name|c
index|]
operator|=
name|strsave
argument_list|(
operator|(
name|char
operator|*
operator|)
name|s
argument_list|)
expr_stmt|;
name|q
operator|.
name|class
index|[
name|c
index|]
operator|=
name|FANCY
expr_stmt|;
block|}
comment|/*  Now we have to make sure that the closing quote works.  */
if|if
condition|(
operator|(
name|c
operator|=
name|q
operator|.
name|closer
index|[
literal|0
index|]
operator|)
operator|&&
name|q
operator|.
name|class
index|[
name|c
index|]
operator|<=
name|SIMPLE
condition|)
block|{
if|if
condition|(
name|q
operator|.
name|escape
index|[
literal|0
index|]
condition|)
block|{
name|q
operator|.
name|class
index|[
name|c
index|]
operator|=
name|SCAPED
expr_stmt|;
block|}
else|else
block|{
name|char
name|buf
index|[
literal|3
index|]
decl_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
name|c
operator|,
name|buf
index|[
literal|1
index|]
operator|=
name|c
operator|,
name|buf
index|[
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
name|q
operator|.
name|fancy
index|[
name|c
index|]
operator|=
name|strsave
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|q
operator|.
name|class
index|[
name|c
index|]
operator|=
name|FANCY
expr_stmt|;
block|}
block|}
comment|/*  We also have to make sure that the escape (if any) works.  */
if|if
condition|(
operator|(
name|c
operator|=
name|q
operator|.
name|escape
index|[
literal|0
index|]
operator|)
operator|&&
name|q
operator|.
name|class
index|[
name|c
index|]
operator|<=
name|SIMPLE
condition|)
block|{
name|q
operator|.
name|class
index|[
name|c
index|]
operator|=
name|SCAPED
expr_stmt|;
block|}
name|r
operator|=
operator|(
expr|struct
name|Quoter
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"m4: no more memory"
argument_list|)
expr_stmt|;
operator|*
name|r
operator|=
name|q
expr_stmt|;
name|p
operator|=
name|addent
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|p
operator|->
name|defn
operator|=
operator|(
name|char
operator|*
operator|)
name|r
expr_stmt|;
name|p
operator|->
name|type
operator|=
name|QUTRTYPE
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  doqutr(<DB MN A1 ... An>) 	     0  1  2      n+1 argc     argv[0] points to the struct Quoter.     argv[1] points to the name of this quoting macro     argv[2..argc-1] point to the arguments.     This applies a user-defined quoting macro.  For example, we could     define a macro to produce Prolog identifiers: 	defquote(plid, ', , ', , simple, 	    abcdefghijklmnopqrstuvwxyz, 	    ABCDEFGHIJKLMNOPQRSTUVWXYZ_0123456789)      After doing that, 	plid(foo)		=> foo 	plid(*)			=> '*' 	plid(Don't)		=> 'Don''t' 	plid(foo,)		=> 'foo' */
end_comment

begin_function
name|void
name|doqutr
parameter_list|(
name|argv
parameter_list|,
name|argc
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|int
name|argc
decl_stmt|;
comment|/* DEFINITION-BLOCK MacroName Arg1 ... Argn        0                1         2        n-1   argc     */
block|{
name|struct
name|Quoter
modifier|*
name|r
init|=
operator|(
expr|struct
name|Quoter
operator|*
operator|)
name|argv
index|[
literal|0
index|]
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|b
decl_stmt|,
modifier|*
name|e
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* does not actually loop */
if|if
condition|(
name|argc
operator|!=
literal|3
condition|)
break|break;
name|b
operator|=
name|ucArgv
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|e
operator|=
name|b
operator|+
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|==
name|b
condition|)
break|break;
if|if
condition|(
name|r
operator|->
name|class
index|[
operator|*
name|b
operator|++
index|]
operator|!=
name|PLAIN1
condition|)
break|break;
while|while
condition|(
name|b
operator|!=
name|e
operator|&&
name|r
operator|->
name|class
index|[
operator|*
name|b
index|]
operator|<=
name|PLAIN2
condition|)
name|b
operator|++
expr_stmt|;
if|if
condition|(
name|b
operator|!=
name|e
condition|)
break|break;
name|pbstr
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
name|p
operator|=
name|r
operator|->
name|closer
expr_stmt|;
if|if
condition|(
name|argc
operator|<
literal|3
condition|)
block|{
name|pbstr
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
else|else
for|for
control|(
name|i
operator|=
name|argc
operator|-
literal|1
init|;
name|i
operator|>=
literal|2
condition|;
name|i
operator|--
control|)
block|{
name|pbstr
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|b
operator|=
name|ucArgv
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|e
operator|=
name|b
operator|+
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|b
argument_list|)
expr_stmt|;
while|while
condition|(
name|e
operator|!=
name|b
condition|)
switch|switch
condition|(
name|r
operator|->
name|class
index|[
name|c
operator|=
operator|*
operator|--
name|e
index|]
condition|)
block|{
case|case
name|FANCY
case|:
name|p
operator|=
name|r
operator|->
name|fancy
index|[
name|c
index|]
expr_stmt|;
if|if
condition|(
name|p
condition|)
block|{
name|pbstr
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pbrad
argument_list|(
name|c
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pbstr
argument_list|(
name|r
operator|->
name|escape
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SCAPED
case|:
name|putback
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|pbstr
argument_list|(
name|r
operator|->
name|escape
argument_list|)
expr_stmt|;
break|break;
default|default:
name|putback
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
block|}
name|p
operator|=
name|r
operator|->
name|separator
expr_stmt|;
block|}
name|pbstr
argument_list|(
name|r
operator|->
name|opener
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

