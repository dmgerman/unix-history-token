begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$OpenBSD: sdiff.c,v 1.36 2015/12/29 19:04:46 gsoares Exp $ */
end_comment

begin_comment
comment|/*  * Written by Raymond Lai<ray@cyth.net>.  * Public domain.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<getopt.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<paths.h>
end_include

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<libutil.h>
end_include

begin_include
include|#
directive|include
file|"common.h"
end_include

begin_include
include|#
directive|include
file|"extern.h"
end_include

begin_define
define|#
directive|define
name|DIFF_PATH
value|"/usr/bin/diff"
end_define

begin_define
define|#
directive|define
name|WIDTH
value|126
end_define

begin_comment
comment|/*  * Each column must be at least one character wide, plus three  * characters between the columns (space, [<|>], space).  */
end_comment

begin_define
define|#
directive|define
name|WIDTH_MIN
value|5
end_define

begin_comment
comment|/* 3 kilobytes of chars */
end_comment

begin_define
define|#
directive|define
name|MAX_CHECK
value|768
end_define

begin_comment
comment|/* A single diff line. */
end_comment

begin_struct
struct|struct
name|diffline
block|{
name|STAILQ_ENTRY
argument_list|(
argument|diffline
argument_list|)
name|diffentries
expr_stmt|;
name|char
modifier|*
name|left
decl_stmt|;
name|char
name|div
decl_stmt|;
name|char
modifier|*
name|right
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|void
name|astrcat
parameter_list|(
name|char
modifier|*
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|enqueue
parameter_list|(
name|char
modifier|*
parameter_list|,
name|char
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|mktmpcpy
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|istextfile
parameter_list|(
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|void
name|binexec
argument_list|(
name|char
operator|*
argument_list|,
name|char
operator|*
argument_list|,
name|char
operator|*
argument_list|)
name|__dead2
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|freediff
parameter_list|(
name|struct
name|diffline
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|int_usage
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|parsecmd
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|printa
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|printc
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|FILE
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|printcol
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|,
specifier|const
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|printd
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|println
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|processq
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|prompt
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|void
name|usage
argument_list|(
name|void
argument_list|)
name|__dead2
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|char
modifier|*
name|xfgets
parameter_list|(
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
specifier|static
name|STAILQ_HEAD
argument_list|(
argument_list|,
argument|diffline
argument_list|)
name|diffhead
operator|=
name|STAILQ_HEAD_INITIALIZER
argument_list|(
name|diffhead
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|size_t
name|line_width
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* width of a line (two columns and divider) */
end_comment

begin_decl_stmt
specifier|static
name|size_t
name|width
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* width of each column */
end_comment

begin_decl_stmt
specifier|static
name|size_t
name|file1ln
decl_stmt|,
name|file2ln
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* line number of file1 and file2 */
end_comment

begin_decl_stmt
specifier|static
name|int
name|Iflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ignore sets matching regexp */
end_comment

begin_decl_stmt
specifier|static
name|int
name|lflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* print only left column for identical lines */
end_comment

begin_decl_stmt
specifier|static
name|int
name|sflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* skip identical lines */
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|outfp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* file to save changes to */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|tmpdir
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* TMPDIR or /tmp */
end_comment

begin_enum
enum|enum
block|{
name|HELP_OPT
init|=
name|CHAR_MAX
operator|+
literal|1
block|,
name|NORMAL_OPT
block|,
name|FCASE_SENSITIVE_OPT
block|,
name|FCASE_IGNORE_OPT
block|,
name|FROMFILE_OPT
block|,
name|TOFILE_OPT
block|,
name|UNIDIR_OPT
block|,
name|STRIPCR_OPT
block|,
name|HORIZ_OPT
block|,
name|LEFTC_OPT
block|,
name|SUPCL_OPT
block|,
name|LF_OPT
block|,
comment|/* the following groupings must be in sequence */
name|OLDGF_OPT
block|,
name|NEWGF_OPT
block|,
name|UNCGF_OPT
block|,
name|CHGF_OPT
block|,
name|OLDLF_OPT
block|,
name|NEWLF_OPT
block|,
name|UNCLF_OPT
block|,
comment|/* end order-sensitive enums */
name|TSIZE_OPT
block|,
name|HLINES_OPT
block|,
name|LFILES_OPT
block|,
name|DIFFPROG_OPT
block|,
name|PIPE_FD
block|,
comment|/* pid from the diff parent (if applicable) */
name|DIFF_PID
block|,
name|NOOP_OPT
block|, }
enum|;
end_enum

begin_decl_stmt
specifier|static
name|struct
name|option
name|longopts
index|[]
init|=
block|{
comment|/* options only processed in sdiff */
block|{
literal|"left-column"
block|,
name|no_argument
block|,
name|NULL
block|,
name|LEFTC_OPT
block|}
block|,
block|{
literal|"suppress-common-lines"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'s'
block|}
block|,
block|{
literal|"width"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'w'
block|}
block|,
block|{
literal|"output"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'o'
block|}
block|,
block|{
literal|"diff-program"
block|,
name|required_argument
block|,
name|NULL
block|,
name|DIFFPROG_OPT
block|}
block|,
block|{
literal|"pipe-fd"
block|,
name|required_argument
block|,
name|NULL
block|,
name|PIPE_FD
block|}
block|,
block|{
literal|"diff-pid"
block|,
name|required_argument
block|,
name|NULL
block|,
name|DIFF_PID
block|}
block|,
comment|/* Options processed by diff. */
block|{
literal|"ignore-file-name-case"
block|,
name|no_argument
block|,
name|NULL
block|,
name|FCASE_IGNORE_OPT
block|}
block|,
block|{
literal|"no-ignore-file-name-case"
block|,
name|no_argument
block|,
name|NULL
block|,
name|FCASE_SENSITIVE_OPT
block|}
block|,
block|{
literal|"strip-trailing-cr"
block|,
name|no_argument
block|,
name|NULL
block|,
name|STRIPCR_OPT
block|}
block|,
block|{
literal|"tabsize"
block|,
name|required_argument
block|,
name|NULL
block|,
name|TSIZE_OPT
block|}
block|,
block|{
literal|"help"
block|,
name|no_argument
block|,
name|NULL
block|,
name|HELP_OPT
block|}
block|,
block|{
literal|"text"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'a'
block|}
block|,
block|{
literal|"ignore-blank-lines"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'B'
block|}
block|,
block|{
literal|"ignore-space-change"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'b'
block|}
block|,
block|{
literal|"minimal"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'d'
block|}
block|,
block|{
literal|"ignore-tab-expansion"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'E'
block|}
block|,
block|{
literal|"ignore-matching-lines"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'I'
block|}
block|,
block|{
literal|"ignore-case"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'i'
block|}
block|,
block|{
literal|"expand-tabs"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'t'
block|}
block|,
block|{
literal|"speed-large-files"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'H'
block|}
block|,
block|{
literal|"ignore-all-space"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'W'
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
name|NULL
block|,
literal|'\0'
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|help_msg
index|[]
init|=
block|{
literal|"\nusage: sdiff [-abdilstW] [-I regexp] [-o outfile] [-w width] file1 file2\n"
block|,
literal|"\t-l, --left-column, Only print the left column for identical lines."
block|,
literal|"\t-o OUTFILE, --output=OUTFILE, nteractively merge file1 and file2 into outfile."
block|,
literal|"\t-s, --suppress-common-lines, Skip identical lines."
block|,
literal|"\t-w WIDTH, --width=WIDTH, Print a maximum of WIDTH characters on each line."
block|,
literal|"\tOptions passed to diff(1) are:"
block|,
literal|"\t\t-a, --text, Treat file1 and file2 as text files."
block|,
literal|"\t\t-b, --ignore-trailing-cr, Ignore trailing blank spaces."
block|,
literal|"\t\t-d, --minimal, Minimize diff size."
block|,
literal|"\t\t-I RE, --ignore-matching-lines=RE, Ignore changes whose line matches RE."
block|,
literal|"\t\t-i, --ignore-case, Do a case-insensitive comparison."
block|,
literal|"\t\t-t, --expand-tabs Expand tabs to spaces."
block|,
literal|"\t\t-W, --ignore-all-spaces, Ignore all spaces."
block|,
literal|"\t\t--speed-large-files, Assume large file with scattered changes."
block|,
literal|"\t\t--strip-trailing-cr, Strip trailing carriage return."
block|,
literal|"\t\t--ignore-file-name-case, Ignore case of file names."
block|,
literal|"\t\t--no-ignore-file-name-case, Do not ignore file name case"
block|,
literal|"\t\t--tabsize NUM, Change size of tabs (default 8.)"
block|,
name|NULL
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Create temporary file if source_file is not a regular file.  * Returns temporary file name if one was malloced, NULL if unnecessary.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|mktmpcpy
parameter_list|(
specifier|const
name|char
modifier|*
name|source_file
parameter_list|)
block|{
name|struct
name|stat
name|sb
decl_stmt|;
name|ssize_t
name|rcount
decl_stmt|;
name|int
name|ifd
decl_stmt|,
name|ofd
decl_stmt|;
name|u_char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|char
modifier|*
name|target_file
decl_stmt|;
comment|/* Open input and output. */
name|ifd
operator|=
name|open
argument_list|(
name|source_file
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* File was opened successfully. */
if|if
condition|(
name|ifd
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|fstat
argument_list|(
name|ifd
argument_list|,
operator|&
name|sb
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|2
argument_list|,
literal|"error getting file status from %s"
argument_list|,
name|source_file
argument_list|)
expr_stmt|;
comment|/* Regular file. */
if|if
condition|(
name|S_ISREG
argument_list|(
name|sb
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|close
argument_list|(
name|ifd
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/* If ``-'' does not exist the user meant stdin. */
if|if
condition|(
name|errno
operator|==
name|ENOENT
operator|&&
name|strcmp
argument_list|(
name|source_file
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
name|ifd
operator|=
name|STDIN_FILENO
expr_stmt|;
else|else
name|err
argument_list|(
literal|2
argument_list|,
literal|"error opening %s"
argument_list|,
name|source_file
argument_list|)
expr_stmt|;
block|}
comment|/* Not a regular file, so copy input into temporary file. */
if|if
condition|(
name|asprintf
argument_list|(
operator|&
name|target_file
argument_list|,
literal|"%s/sdiff.XXXXXXXXXX"
argument_list|,
name|tmpdir
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|2
argument_list|,
literal|"asprintf"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ofd
operator|=
name|mkstemp
argument_list|(
name|target_file
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|warn
argument_list|(
literal|"error opening %s"
argument_list|,
name|target_file
argument_list|)
expr_stmt|;
goto|goto
name|FAIL
goto|;
block|}
while|while
condition|(
operator|(
name|rcount
operator|=
name|read
argument_list|(
name|ifd
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
operator|)
operator|!=
operator|-
literal|1
operator|&&
name|rcount
operator|!=
literal|0
condition|)
block|{
name|ssize_t
name|wcount
decl_stmt|;
name|wcount
operator|=
name|write
argument_list|(
name|ofd
argument_list|,
name|buf
argument_list|,
operator|(
name|size_t
operator|)
name|rcount
argument_list|)
expr_stmt|;
if|if
condition|(
operator|-
literal|1
operator|==
name|wcount
operator|||
name|rcount
operator|!=
name|wcount
condition|)
block|{
name|warn
argument_list|(
literal|"error writing to %s"
argument_list|,
name|target_file
argument_list|)
expr_stmt|;
goto|goto
name|FAIL
goto|;
block|}
block|}
if|if
condition|(
name|rcount
operator|==
operator|-
literal|1
condition|)
block|{
name|warn
argument_list|(
literal|"error reading from %s"
argument_list|,
name|source_file
argument_list|)
expr_stmt|;
goto|goto
name|FAIL
goto|;
block|}
name|close
argument_list|(
name|ifd
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|ofd
argument_list|)
expr_stmt|;
return|return
operator|(
name|target_file
operator|)
return|;
name|FAIL
label|:
name|unlink
argument_list|(
name|target_file
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|FILE
modifier|*
name|diffpipe
init|=
name|NULL
decl_stmt|,
modifier|*
name|file1
decl_stmt|,
modifier|*
name|file2
decl_stmt|;
name|size_t
name|diffargc
init|=
literal|0
decl_stmt|,
name|wflag
init|=
name|WIDTH
decl_stmt|;
name|int
name|ch
decl_stmt|,
name|fd
index|[
literal|2
index|]
init|=
block|{
operator|-
literal|1
block|}
decl_stmt|,
name|status
decl_stmt|;
name|pid_t
name|pid
init|=
literal|0
decl_stmt|;
name|pid_t
name|ppid
init|=
operator|-
literal|1
decl_stmt|;
specifier|const
name|char
modifier|*
name|outfile
init|=
name|NULL
decl_stmt|;
name|struct
name|option
modifier|*
name|popt
decl_stmt|;
name|char
modifier|*
modifier|*
name|diffargv
decl_stmt|,
modifier|*
name|diffprog
init|=
name|DIFF_PATH
decl_stmt|,
modifier|*
name|filename1
decl_stmt|,
modifier|*
name|filename2
decl_stmt|,
modifier|*
name|tmp1
decl_stmt|,
modifier|*
name|tmp2
decl_stmt|,
modifier|*
name|s1
decl_stmt|,
modifier|*
name|s2
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * Process diff flags. 	 */
comment|/* 	 * Allocate memory for diff arguments and NULL. 	 * Each flag has at most one argument, so doubling argc gives an 	 * upper limit of how many diff args can be passed.  argv[0], 	 * file1, and file2 won't have arguments so doubling them will 	 * waste some memory; however we need an extra space for the 	 * NULL at the end, so it sort of works out. 	 */
if|if
condition|(
operator|!
operator|(
name|diffargv
operator|=
name|calloc
argument_list|(
name|argc
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
operator|*
argument_list|)
operator|*
literal|2
argument_list|)
operator|)
condition|)
name|err
argument_list|(
literal|2
argument_list|,
literal|"main"
argument_list|)
expr_stmt|;
comment|/* Add first argument, the program name. */
name|diffargv
index|[
name|diffargc
operator|++
index|]
operator|=
name|diffprog
expr_stmt|;
comment|/* create a dynamic string for merging single-switch options */
if|if
condition|(
name|asprintf
argument_list|(
operator|&
name|diffargv
index|[
name|diffargc
operator|++
index|]
argument_list|,
literal|"-"
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|2
argument_list|,
literal|"main"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|getopt_long
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"aBbdEHI:ilo:stWw:"
argument_list|,
name|longopts
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
specifier|const
name|char
modifier|*
name|errstr
decl_stmt|;
switch|switch
condition|(
name|ch
condition|)
block|{
comment|/* only compatible --long-name-form with diff */
case|case
name|FCASE_IGNORE_OPT
case|:
case|case
name|FCASE_SENSITIVE_OPT
case|:
case|case
name|STRIPCR_OPT
case|:
case|case
name|TSIZE_OPT
case|:
case|case
literal|'S'
case|:
break|break;
comment|/* combine no-arg single switches */
case|case
literal|'a'
case|:
case|case
literal|'B'
case|:
case|case
literal|'b'
case|:
case|case
literal|'d'
case|:
case|case
literal|'E'
case|:
case|case
literal|'i'
case|:
case|case
literal|'t'
case|:
case|case
literal|'H'
case|:
case|case
literal|'W'
case|:
for|for
control|(
name|popt
operator|=
name|longopts
init|;
name|ch
operator|!=
name|popt
operator|->
name|val
operator|&&
name|popt
operator|->
name|name
operator|!=
name|NULL
condition|;
name|popt
operator|++
control|)
empty_stmt|;
name|diffargv
index|[
literal|1
index|]
operator|=
name|realloc
argument_list|(
name|diffargv
index|[
literal|1
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|*
name|strlen
argument_list|(
name|diffargv
index|[
literal|1
index|]
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
comment|/* 			 * In diff, the 'W' option is 'w' and the 'w' is 'W'. 			 */
if|if
condition|(
name|ch
operator|==
literal|'W'
condition|)
name|sprintf
argument_list|(
name|diffargv
index|[
literal|1
index|]
argument_list|,
literal|"%sw"
argument_list|,
name|diffargv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|diffargv
index|[
literal|1
index|]
argument_list|,
literal|"%s%c"
argument_list|,
name|diffargv
index|[
literal|1
index|]
argument_list|,
name|ch
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIFFPROG_OPT
case|:
name|diffargv
index|[
literal|0
index|]
operator|=
name|diffprog
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
name|Iflag
operator|=
literal|1
expr_stmt|;
name|diffargv
index|[
name|diffargc
operator|++
index|]
operator|=
literal|"-I"
expr_stmt|;
name|diffargv
index|[
name|diffargc
operator|++
index|]
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|lflag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|outfile
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|sflag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|wflag
operator|=
name|strtonum
argument_list|(
name|optarg
argument_list|,
name|WIDTH_MIN
argument_list|,
name|INT_MAX
argument_list|,
operator|&
name|errstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|errstr
condition|)
name|errx
argument_list|(
literal|2
argument_list|,
literal|"width is %s: %s"
argument_list|,
name|errstr
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIFF_PID
case|:
name|ppid
operator|=
name|strtonum
argument_list|(
name|optarg
argument_list|,
literal|0
argument_list|,
name|INT_MAX
argument_list|,
operator|&
name|errstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|errstr
condition|)
name|errx
argument_list|(
literal|2
argument_list|,
literal|"diff pid value is %s: %s"
argument_list|,
name|errstr
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
name|HELP_OPT
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|help_msg
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|help_msg
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
comment|/* no single switches were used */
if|if
condition|(
name|strcmp
argument_list|(
name|diffargv
index|[
literal|1
index|]
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|diffargv
index|[
name|i
index|]
operator|=
name|diffargv
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
block|}
name|diffargv
index|[
name|diffargc
operator|-
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
name|diffargc
operator|--
expr_stmt|;
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|2
condition|)
name|usage
argument_list|()
expr_stmt|;
if|if
condition|(
name|outfile
operator|&&
operator|(
name|outfp
operator|=
name|fopen
argument_list|(
name|outfile
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|2
argument_list|,
literal|"could not open: %s"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tmpdir
operator|=
name|getenv
argument_list|(
literal|"TMPDIR"
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|*
name|tmpdir
operator|==
literal|'\0'
condition|)
name|tmpdir
operator|=
name|_PATH_TMP
expr_stmt|;
name|filename1
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|filename2
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
comment|/* 	 * Create temporary files for diff and sdiff to share if file1 	 * or file2 are not regular files.  This allows sdiff and diff 	 * to read the same inputs if one or both inputs are stdin. 	 * 	 * If any temporary files were created, their names would be 	 * saved in tmp1 or tmp2.  tmp1 should never equal tmp2. 	 */
name|tmp1
operator|=
name|tmp2
operator|=
name|NULL
expr_stmt|;
comment|/* file1 and file2 are the same, so copy to same temp file. */
if|if
condition|(
name|strcmp
argument_list|(
name|filename1
argument_list|,
name|filename2
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|tmp1
operator|=
name|mktmpcpy
argument_list|(
name|filename1
argument_list|)
operator|)
condition|)
name|filename1
operator|=
name|filename2
operator|=
name|tmp1
expr_stmt|;
comment|/* Copy file1 and file2 into separate temp files. */
block|}
else|else
block|{
if|if
condition|(
operator|(
name|tmp1
operator|=
name|mktmpcpy
argument_list|(
name|filename1
argument_list|)
operator|)
condition|)
name|filename1
operator|=
name|tmp1
expr_stmt|;
if|if
condition|(
operator|(
name|tmp2
operator|=
name|mktmpcpy
argument_list|(
name|filename2
argument_list|)
operator|)
condition|)
name|filename2
operator|=
name|tmp2
expr_stmt|;
block|}
name|diffargv
index|[
name|diffargc
operator|++
index|]
operator|=
name|filename1
expr_stmt|;
name|diffargv
index|[
name|diffargc
operator|++
index|]
operator|=
name|filename2
expr_stmt|;
comment|/* Add NULL to end of array to indicate end of array. */
name|diffargv
index|[
name|diffargc
operator|++
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* Subtract column divider and divide by two. */
name|width
operator|=
operator|(
name|wflag
operator|-
literal|3
operator|)
operator|/
literal|2
expr_stmt|;
comment|/* Make sure line_width can fit in size_t. */
if|if
condition|(
name|width
operator|>
operator|(
name|SIZE_MAX
operator|-
literal|3
operator|)
operator|/
literal|2
condition|)
name|errx
argument_list|(
literal|2
argument_list|,
literal|"width is too large: %zu"
argument_list|,
name|width
argument_list|)
expr_stmt|;
name|line_width
operator|=
name|width
operator|*
literal|2
operator|+
literal|3
expr_stmt|;
if|if
condition|(
name|ppid
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|pipe
argument_list|(
name|fd
argument_list|)
condition|)
name|err
argument_list|(
literal|2
argument_list|,
literal|"pipe"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pid
operator|=
name|fork
argument_list|()
condition|)
block|{
case|case
literal|0
case|:
comment|/* child */
comment|/* We don't read from the pipe. */
name|close
argument_list|(
name|fd
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|dup2
argument_list|(
name|fd
index|[
literal|1
index|]
argument_list|,
name|STDOUT_FILENO
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|2
argument_list|,
literal|"child could not duplicate descriptor"
argument_list|)
expr_stmt|;
comment|/* Free unused descriptor. */
name|close
argument_list|(
name|fd
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|execvp
argument_list|(
name|diffprog
argument_list|,
name|diffargv
argument_list|)
expr_stmt|;
name|err
argument_list|(
literal|2
argument_list|,
literal|"could not execute diff: %s"
argument_list|,
name|diffprog
argument_list|)
expr_stmt|;
break|break;
case|case
operator|-
literal|1
case|:
name|err
argument_list|(
literal|2
argument_list|,
literal|"could not fork"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* parent */
comment|/* We don't write to the pipe. */
name|close
argument_list|(
name|fd
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* Open pipe to diff command. */
if|if
condition|(
operator|(
name|diffpipe
operator|=
name|fdopen
argument_list|(
name|fd
index|[
literal|0
index|]
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|2
argument_list|,
literal|"could not open diff pipe"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|file1
operator|=
name|fopen
argument_list|(
name|filename1
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|2
argument_list|,
literal|"could not open %s"
argument_list|,
name|filename1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|file2
operator|=
name|fopen
argument_list|(
name|filename2
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|2
argument_list|,
literal|"could not open %s"
argument_list|,
name|filename2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|istextfile
argument_list|(
name|file1
argument_list|)
operator|||
operator|!
name|istextfile
argument_list|(
name|file2
argument_list|)
condition|)
block|{
comment|/* Close open files and pipe, delete temps */
name|fclose
argument_list|(
name|file1
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|file2
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|diffpipe
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp1
condition|)
if|if
condition|(
name|unlink
argument_list|(
name|tmp1
argument_list|)
condition|)
name|warn
argument_list|(
literal|"Error deleting %s."
argument_list|,
name|tmp1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp2
condition|)
if|if
condition|(
name|unlink
argument_list|(
name|tmp2
argument_list|)
condition|)
name|warn
argument_list|(
literal|"Error deleting %s."
argument_list|,
name|tmp2
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tmp1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tmp2
argument_list|)
expr_stmt|;
name|binexec
argument_list|(
name|diffprog
argument_list|,
name|filename1
argument_list|,
name|filename2
argument_list|)
expr_stmt|;
block|}
comment|/* Line numbers start at one. */
name|file1ln
operator|=
name|file2ln
operator|=
literal|1
expr_stmt|;
comment|/* Read and parse diff output. */
while|while
condition|(
name|parsecmd
argument_list|(
name|diffpipe
argument_list|,
name|file1
argument_list|,
name|file2
argument_list|)
operator|!=
name|EOF
condition|)
empty_stmt|;
name|fclose
argument_list|(
name|diffpipe
argument_list|)
expr_stmt|;
comment|/* Wait for diff to exit. */
if|if
condition|(
name|waitpid
argument_list|(
name|pid
argument_list|,
operator|&
name|status
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
operator|||
operator|!
name|WIFEXITED
argument_list|(
name|status
argument_list|)
operator|||
name|WEXITSTATUS
argument_list|(
name|status
argument_list|)
operator|>=
literal|2
condition|)
name|err
argument_list|(
literal|2
argument_list|,
literal|"diff exited abnormally."
argument_list|)
expr_stmt|;
comment|/* Delete and free unneeded temporary files. */
if|if
condition|(
name|tmp1
condition|)
if|if
condition|(
name|unlink
argument_list|(
name|tmp1
argument_list|)
condition|)
name|warn
argument_list|(
literal|"Error deleting %s."
argument_list|,
name|tmp1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp2
condition|)
if|if
condition|(
name|unlink
argument_list|(
name|tmp2
argument_list|)
condition|)
name|warn
argument_list|(
literal|"Error deleting %s."
argument_list|,
name|tmp2
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tmp1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tmp2
argument_list|)
expr_stmt|;
name|filename1
operator|=
name|filename2
operator|=
name|tmp1
operator|=
name|tmp2
operator|=
name|NULL
expr_stmt|;
comment|/* No more diffs, so print common lines. */
if|if
condition|(
name|lflag
condition|)
while|while
condition|(
operator|(
name|s1
operator|=
name|xfgets
argument_list|(
name|file1
argument_list|)
operator|)
condition|)
name|enqueue
argument_list|(
name|s1
argument_list|,
literal|' '
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
for|for
control|(
init|;
condition|;
control|)
block|{
name|s1
operator|=
name|xfgets
argument_list|(
name|file1
argument_list|)
expr_stmt|;
name|s2
operator|=
name|xfgets
argument_list|(
name|file2
argument_list|)
expr_stmt|;
if|if
condition|(
name|s1
operator|||
name|s2
condition|)
name|enqueue
argument_list|(
name|s1
argument_list|,
literal|' '
argument_list|,
name|s2
argument_list|)
expr_stmt|;
else|else
break|break;
block|}
name|fclose
argument_list|(
name|file1
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|file2
argument_list|)
expr_stmt|;
comment|/* Process unmodified lines. */
name|processq
argument_list|()
expr_stmt|;
comment|/* Return diff exit status. */
return|return
operator|(
name|WEXITSTATUS
argument_list|(
name|status
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * When sdiff/zsdiff detects a binary file as input, executes them with  * diff/zdiff to maintain the same behavior as GNU sdiff with binary input.  */
end_comment

begin_function
specifier|static
name|void
name|binexec
parameter_list|(
name|char
modifier|*
name|diffprog
parameter_list|,
name|char
modifier|*
name|f1
parameter_list|,
name|char
modifier|*
name|f2
parameter_list|)
block|{
name|char
modifier|*
name|args
index|[]
init|=
block|{
name|diffprog
block|,
name|f1
block|,
name|f2
block|,
operator|(
name|char
operator|*
operator|)
literal|0
block|}
decl_stmt|;
name|execv
argument_list|(
name|diffprog
argument_list|,
name|args
argument_list|)
expr_stmt|;
comment|/* If execv() fails, sdiff's execution will continue below. */
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Could not execute diff process.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Checks whether a file appears to be a text file.  */
end_comment

begin_function
specifier|static
name|int
name|istextfile
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|)
block|{
name|int
name|ch
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|rewind
argument_list|(
name|f
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|MAX_CHECK
condition|;
name|i
operator|++
control|)
block|{
name|ch
operator|=
name|fgetc
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'\0'
condition|)
block|{
name|rewind
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|ch
operator|==
name|EOF
condition|)
break|break;
block|}
name|rewind
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Prints an individual column (left or right), taking into account  * that tabs are variable-width.  Takes a string, the current column  * the cursor is on the screen, and the maximum value of the column.  * The column value is updated as we go along.  */
end_comment

begin_function
specifier|static
name|void
name|printcol
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|size_t
modifier|*
name|col
parameter_list|,
specifier|const
name|size_t
name|col_max
parameter_list|)
block|{
for|for
control|(
init|;
operator|*
name|s
operator|&&
operator|*
name|col
operator|<
name|col_max
condition|;
operator|++
name|s
control|)
block|{
name|size_t
name|new_col
decl_stmt|;
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|'\t'
case|:
comment|/* 			 * If rounding to next multiple of eight causes 			 * an integer overflow, just return. 			 */
if|if
condition|(
operator|*
name|col
operator|>
name|SIZE_MAX
operator|-
literal|8
condition|)
return|return;
comment|/* Round to next multiple of eight. */
name|new_col
operator|=
operator|(
operator|*
name|col
operator|/
literal|8
operator|+
literal|1
operator|)
operator|*
literal|8
expr_stmt|;
comment|/* 			 * If printing the tab goes past the column 			 * width, don't print it and just quit. 			 */
if|if
condition|(
name|new_col
operator|>
name|col_max
condition|)
return|return;
operator|*
name|col
operator|=
name|new_col
expr_stmt|;
break|break;
default|default:
operator|++
operator|(
operator|*
name|col
operator|)
expr_stmt|;
block|}
name|putchar
argument_list|(
operator|*
name|s
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Prompts user to either choose between two strings or edit one, both,  * or neither.  */
end_comment

begin_function
specifier|static
name|void
name|prompt
parameter_list|(
specifier|const
name|char
modifier|*
name|s1
parameter_list|,
specifier|const
name|char
modifier|*
name|s2
parameter_list|)
block|{
name|char
modifier|*
name|cmd
decl_stmt|;
comment|/* Print command prompt. */
name|putchar
argument_list|(
literal|'%'
argument_list|)
expr_stmt|;
comment|/* Get user input. */
for|for
control|(
init|;
operator|(
name|cmd
operator|=
name|xfgets
argument_list|(
name|stdin
argument_list|)
operator|)
condition|;
name|free
argument_list|(
name|cmd
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
comment|/* Skip leading whitespace. */
for|for
control|(
name|p
operator|=
name|cmd
init|;
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|;
operator|++
name|p
control|)
empty_stmt|;
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|'e'
case|:
comment|/* Skip `e'. */
operator|++
name|p
expr_stmt|;
if|if
condition|(
name|eparse
argument_list|(
name|p
argument_list|,
name|s1
argument_list|,
name|s2
argument_list|)
operator|==
operator|-
literal|1
condition|)
goto|goto
name|USAGE
goto|;
break|break;
case|case
literal|'l'
case|:
case|case
literal|'1'
case|:
comment|/* Choose left column as-is. */
if|if
condition|(
name|s1
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|outfp
argument_list|,
literal|"%s\n"
argument_list|,
name|s1
argument_list|)
expr_stmt|;
comment|/* End of command parsing. */
break|break;
case|case
literal|'q'
case|:
goto|goto
name|QUIT
goto|;
case|case
literal|'r'
case|:
case|case
literal|'2'
case|:
comment|/* Choose right column as-is. */
if|if
condition|(
name|s2
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|outfp
argument_list|,
literal|"%s\n"
argument_list|,
name|s2
argument_list|)
expr_stmt|;
comment|/* End of command parsing. */
break|break;
case|case
literal|'s'
case|:
name|sflag
operator|=
literal|1
expr_stmt|;
goto|goto
name|PROMPT
goto|;
case|case
literal|'v'
case|:
name|sflag
operator|=
literal|0
expr_stmt|;
comment|/* FALLTHROUGH */
default|default:
comment|/* Interactive usage help. */
name|USAGE
label|:
name|int_usage
argument_list|()
expr_stmt|;
name|PROMPT
label|:
name|putchar
argument_list|(
literal|'%'
argument_list|)
expr_stmt|;
comment|/* Prompt user again. */
continue|continue;
block|}
name|free
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * If there was no error, we received an EOF from stdin, so we 	 * should quit. 	 */
name|QUIT
label|:
name|fclose
argument_list|(
name|outfp
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Takes two strings, separated by a column divider.  NULL strings are  * treated as empty columns.  If the divider is the ` ' character, the  * second column is not printed (-l flag).  In this case, the second  * string must be NULL.  When the second column is NULL, the divider  * does not print the trailing space following the divider character.  *  * Takes into account that tabs can take multiple columns.  */
end_comment

begin_function
specifier|static
name|void
name|println
parameter_list|(
specifier|const
name|char
modifier|*
name|s1
parameter_list|,
specifier|const
name|char
name|div
parameter_list|,
specifier|const
name|char
modifier|*
name|s2
parameter_list|)
block|{
name|size_t
name|col
decl_stmt|;
comment|/* Print first column.  Skips if s1 == NULL. */
name|col
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|s1
condition|)
block|{
comment|/* Skip angle bracket and space. */
name|printcol
argument_list|(
name|s1
argument_list|,
operator|&
name|col
argument_list|,
name|width
argument_list|)
expr_stmt|;
block|}
comment|/* Otherwise, we pad this column up to width. */
for|for
control|(
init|;
name|col
operator|<
name|width
condition|;
operator|++
name|col
control|)
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
comment|/* Only print left column. */
if|if
condition|(
name|div
operator|==
literal|' '
operator|&&
operator|!
name|s2
condition|)
block|{
name|printf
argument_list|(
literal|" (\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Print column divider.  If there is no second column, we don't 	 * need to add the space for padding. 	 */
if|if
condition|(
operator|!
name|s2
condition|)
block|{
name|printf
argument_list|(
literal|" %c\n"
argument_list|,
name|div
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|" %c "
argument_list|,
name|div
argument_list|)
expr_stmt|;
name|col
operator|+=
literal|3
expr_stmt|;
comment|/* Skip angle bracket and space. */
name|printcol
argument_list|(
name|s2
argument_list|,
operator|&
name|col
argument_list|,
name|line_width
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Reads a line from file and returns as a string.  If EOF is reached,  * NULL is returned.  The returned string must be freed afterwards.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|xfgets
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|)
block|{
specifier|const
name|char
name|delim
index|[
literal|3
index|]
init|=
block|{
literal|'\0'
block|,
literal|'\0'
block|,
literal|'\0'
block|}
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
comment|/* XXX - Is this necessary? */
name|clearerr
argument_list|(
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|s
operator|=
name|fparseln
argument_list|(
name|file
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|delim
argument_list|,
literal|0
argument_list|)
operator|)
operator|&&
name|ferror
argument_list|(
name|file
argument_list|)
condition|)
name|err
argument_list|(
literal|2
argument_list|,
literal|"error reading file"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|s
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Parse ed commands from diffpipe and print lines from file1 (lines  * to change or delete) or file2 (lines to add or change).  * Returns EOF or 0.  */
end_comment

begin_function
specifier|static
name|int
name|parsecmd
parameter_list|(
name|FILE
modifier|*
name|diffpipe
parameter_list|,
name|FILE
modifier|*
name|file1
parameter_list|,
name|FILE
modifier|*
name|file2
parameter_list|)
block|{
name|size_t
name|file1start
decl_stmt|,
name|file1end
decl_stmt|,
name|file2start
decl_stmt|,
name|file2end
decl_stmt|,
name|n
decl_stmt|;
comment|/* ed command line and pointer to characters in line */
name|char
modifier|*
name|line
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
specifier|const
name|char
modifier|*
name|errstr
decl_stmt|;
name|char
name|c
decl_stmt|,
name|cmd
decl_stmt|;
comment|/* Read ed command. */
if|if
condition|(
operator|!
operator|(
name|line
operator|=
name|xfgets
argument_list|(
name|diffpipe
argument_list|)
operator|)
condition|)
return|return
operator|(
name|EOF
operator|)
return|;
name|p
operator|=
name|line
expr_stmt|;
comment|/* Go to character after line number. */
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|p
argument_list|)
condition|)
operator|++
name|p
expr_stmt|;
name|c
operator|=
operator|*
name|p
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
name|file1start
operator|=
name|strtonum
argument_list|(
name|line
argument_list|,
literal|0
argument_list|,
name|INT_MAX
argument_list|,
operator|&
name|errstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|errstr
condition|)
name|errx
argument_list|(
literal|2
argument_list|,
literal|"file1 start is %s: %s"
argument_list|,
name|errstr
argument_list|,
name|line
argument_list|)
expr_stmt|;
comment|/* A range is specified for file1. */
if|if
condition|(
name|c
operator|==
literal|','
condition|)
block|{
name|q
operator|=
name|p
expr_stmt|;
comment|/* Go to character after file2end. */
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|p
argument_list|)
condition|)
operator|++
name|p
expr_stmt|;
name|c
operator|=
operator|*
name|p
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
name|file1end
operator|=
name|strtonum
argument_list|(
name|q
argument_list|,
literal|0
argument_list|,
name|INT_MAX
argument_list|,
operator|&
name|errstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|errstr
condition|)
name|errx
argument_list|(
literal|2
argument_list|,
literal|"file1 end is %s: %s"
argument_list|,
name|errstr
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|file1start
operator|>
name|file1end
condition|)
name|errx
argument_list|(
literal|2
argument_list|,
literal|"invalid line range in file1: %s"
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
else|else
name|file1end
operator|=
name|file1start
expr_stmt|;
name|cmd
operator|=
name|c
expr_stmt|;
comment|/* Check that cmd is valid. */
if|if
condition|(
operator|!
operator|(
name|cmd
operator|==
literal|'a'
operator|||
name|cmd
operator|==
literal|'c'
operator|||
name|cmd
operator|==
literal|'d'
operator|)
condition|)
name|errx
argument_list|(
literal|2
argument_list|,
literal|"ed command not recognized: %c: %s"
argument_list|,
name|cmd
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|q
operator|=
name|p
expr_stmt|;
comment|/* Go to character after line number. */
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|p
argument_list|)
condition|)
operator|++
name|p
expr_stmt|;
name|c
operator|=
operator|*
name|p
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
name|file2start
operator|=
name|strtonum
argument_list|(
name|q
argument_list|,
literal|0
argument_list|,
name|INT_MAX
argument_list|,
operator|&
name|errstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|errstr
condition|)
name|errx
argument_list|(
literal|2
argument_list|,
literal|"file2 start is %s: %s"
argument_list|,
name|errstr
argument_list|,
name|line
argument_list|)
expr_stmt|;
comment|/* 	 * There should either be a comma signifying a second line 	 * number or the line should just end here. 	 */
if|if
condition|(
name|c
operator|!=
literal|','
operator|&&
name|c
operator|!=
literal|'\0'
condition|)
name|errx
argument_list|(
literal|2
argument_list|,
literal|"invalid line range in file2: %c: %s"
argument_list|,
name|c
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|','
condition|)
block|{
name|file2end
operator|=
name|strtonum
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
name|INT_MAX
argument_list|,
operator|&
name|errstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|errstr
condition|)
name|errx
argument_list|(
literal|2
argument_list|,
literal|"file2 end is %s: %s"
argument_list|,
name|errstr
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|file2start
operator|>=
name|file2end
condition|)
name|errx
argument_list|(
literal|2
argument_list|,
literal|"invalid line range in file2: %s"
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
else|else
name|file2end
operator|=
name|file2start
expr_stmt|;
comment|/* Appends happen _after_ stated line. */
if|if
condition|(
name|cmd
operator|==
literal|'a'
condition|)
block|{
if|if
condition|(
name|file1start
operator|!=
name|file1end
condition|)
name|errx
argument_list|(
literal|2
argument_list|,
literal|"append cannot have a file1 range: %s"
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|file1start
operator|==
name|SIZE_MAX
condition|)
name|errx
argument_list|(
literal|2
argument_list|,
literal|"file1 line range too high: %s"
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|file1start
operator|=
operator|++
name|file1end
expr_stmt|;
block|}
comment|/* 	 * I'm not sure what the deal is with the line numbers for 	 * deletes, though. 	 */
elseif|else
if|if
condition|(
name|cmd
operator|==
literal|'d'
condition|)
block|{
if|if
condition|(
name|file2start
operator|!=
name|file2end
condition|)
name|errx
argument_list|(
literal|2
argument_list|,
literal|"delete cannot have a file2 range: %s"
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|file2start
operator|==
name|SIZE_MAX
condition|)
name|errx
argument_list|(
literal|2
argument_list|,
literal|"file2 line range too high: %s"
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|file2start
operator|=
operator|++
name|file2end
expr_stmt|;
block|}
comment|/* 	 * Continue reading file1 and file2 until we reach line numbers 	 * specified by diff.  Should only happen with -I flag. 	 */
for|for
control|(
init|;
name|file1ln
operator|<
name|file1start
operator|&&
name|file2ln
operator|<
name|file2start
condition|;
operator|++
name|file1ln
operator|,
operator|++
name|file2ln
control|)
block|{
name|char
modifier|*
name|s1
decl_stmt|,
modifier|*
name|s2
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|s1
operator|=
name|xfgets
argument_list|(
name|file1
argument_list|)
operator|)
condition|)
name|errx
argument_list|(
literal|2
argument_list|,
literal|"file1 shorter than expected"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|s2
operator|=
name|xfgets
argument_list|(
name|file2
argument_list|)
operator|)
condition|)
name|errx
argument_list|(
literal|2
argument_list|,
literal|"file2 shorter than expected"
argument_list|)
expr_stmt|;
comment|/* If the -l flag was specified, print only left column. */
if|if
condition|(
name|lflag
condition|)
block|{
name|free
argument_list|(
name|s2
argument_list|)
expr_stmt|;
comment|/* 			 * XXX - If -l and -I are both specified, all 			 * unchanged or ignored lines are shown with a 			 * `(' divider.  This matches GNU sdiff, but I 			 * believe it is a bug.  Just check out: 			 * gsdiff -l -I '^$' samefile samefile. 			 */
if|if
condition|(
name|Iflag
condition|)
name|enqueue
argument_list|(
name|s1
argument_list|,
literal|'('
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|enqueue
argument_list|(
name|s1
argument_list|,
literal|' '
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
name|enqueue
argument_list|(
name|s1
argument_list|,
literal|' '
argument_list|,
name|s2
argument_list|)
expr_stmt|;
block|}
comment|/* Ignore deleted lines. */
for|for
control|(
init|;
name|file1ln
operator|<
name|file1start
condition|;
operator|++
name|file1ln
control|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|s
operator|=
name|xfgets
argument_list|(
name|file1
argument_list|)
operator|)
condition|)
name|errx
argument_list|(
literal|2
argument_list|,
literal|"file1 shorter than expected"
argument_list|)
expr_stmt|;
name|enqueue
argument_list|(
name|s
argument_list|,
literal|'('
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* Ignore added lines. */
for|for
control|(
init|;
name|file2ln
operator|<
name|file2start
condition|;
operator|++
name|file2ln
control|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|s
operator|=
name|xfgets
argument_list|(
name|file2
argument_list|)
operator|)
condition|)
name|errx
argument_list|(
literal|2
argument_list|,
literal|"file2 shorter than expected"
argument_list|)
expr_stmt|;
comment|/* If -l flag was given, don't print right column. */
if|if
condition|(
name|lflag
condition|)
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
else|else
name|enqueue
argument_list|(
name|NULL
argument_list|,
literal|')'
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
comment|/* Process unmodified or skipped lines. */
name|processq
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
literal|'a'
case|:
name|printa
argument_list|(
name|file2
argument_list|,
name|file2end
argument_list|)
expr_stmt|;
name|n
operator|=
name|file2end
operator|-
name|file2start
operator|+
literal|1
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|printc
argument_list|(
name|file1
argument_list|,
name|file1end
argument_list|,
name|file2
argument_list|,
name|file2end
argument_list|)
expr_stmt|;
name|n
operator|=
name|file1end
operator|-
name|file1start
operator|+
literal|1
operator|+
literal|1
operator|+
name|file2end
operator|-
name|file2start
operator|+
literal|1
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|printd
argument_list|(
name|file1
argument_list|,
name|file1end
argument_list|)
expr_stmt|;
name|n
operator|=
name|file1end
operator|-
name|file1start
operator|+
literal|1
expr_stmt|;
break|break;
default|default:
name|errx
argument_list|(
literal|2
argument_list|,
literal|"invalid diff command: %c: %s"
argument_list|,
name|cmd
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
comment|/* Skip to next ed line. */
while|while
condition|(
name|n
operator|--
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|line
operator|=
name|xfgets
argument_list|(
name|diffpipe
argument_list|)
operator|)
condition|)
name|errx
argument_list|(
literal|2
argument_list|,
literal|"diff ended early"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Queues up a diff line.  */
end_comment

begin_function
specifier|static
name|void
name|enqueue
parameter_list|(
name|char
modifier|*
name|left
parameter_list|,
name|char
name|div
parameter_list|,
name|char
modifier|*
name|right
parameter_list|)
block|{
name|struct
name|diffline
modifier|*
name|diffp
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|diffp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|diffline
argument_list|)
argument_list|)
operator|)
condition|)
name|err
argument_list|(
literal|2
argument_list|,
literal|"enqueue"
argument_list|)
expr_stmt|;
name|diffp
operator|->
name|left
operator|=
name|left
expr_stmt|;
name|diffp
operator|->
name|div
operator|=
name|div
expr_stmt|;
name|diffp
operator|->
name|right
operator|=
name|right
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|diffhead
argument_list|,
name|diffp
argument_list|,
name|diffentries
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Free a diffline structure and its elements.  */
end_comment

begin_function
specifier|static
name|void
name|freediff
parameter_list|(
name|struct
name|diffline
modifier|*
name|diffp
parameter_list|)
block|{
name|free
argument_list|(
name|diffp
operator|->
name|left
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|diffp
operator|->
name|right
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|diffp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Append second string into first.  Repeated appends to the same string  * are cached, making this an O(n) function, where n = strlen(append).  */
end_comment

begin_function
specifier|static
name|void
name|astrcat
parameter_list|(
name|char
modifier|*
modifier|*
name|s
parameter_list|,
specifier|const
name|char
modifier|*
name|append
parameter_list|)
block|{
comment|/* Length of string in previous run. */
specifier|static
name|size_t
name|offset
init|=
literal|0
decl_stmt|;
name|size_t
name|newsiz
decl_stmt|;
comment|/* 	 * String from previous run.  Compared to *s to see if we are 	 * dealing with the same string.  If so, we can use offset. 	 */
specifier|static
specifier|const
name|char
modifier|*
name|oldstr
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|newstr
decl_stmt|;
comment|/* 	 * First string is NULL, so just copy append. 	 */
if|if
condition|(
operator|!
operator|*
name|s
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|*
name|s
operator|=
name|strdup
argument_list|(
name|append
argument_list|)
operator|)
condition|)
name|err
argument_list|(
literal|2
argument_list|,
literal|"astrcat"
argument_list|)
expr_stmt|;
comment|/* Keep track of string. */
name|offset
operator|=
name|strlen
argument_list|(
operator|*
name|s
argument_list|)
expr_stmt|;
name|oldstr
operator|=
operator|*
name|s
expr_stmt|;
return|return;
block|}
comment|/* 	 * *s is a string so concatenate. 	 */
comment|/* Did we process the same string in the last run? */
comment|/* 	 * If this is a different string from the one we just processed 	 * cache new string. 	 */
if|if
condition|(
name|oldstr
operator|!=
operator|*
name|s
condition|)
block|{
name|offset
operator|=
name|strlen
argument_list|(
operator|*
name|s
argument_list|)
expr_stmt|;
name|oldstr
operator|=
operator|*
name|s
expr_stmt|;
block|}
comment|/* Size = strlen(*s) + \n + strlen(append) + '\0'. */
name|newsiz
operator|=
name|offset
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|append
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* Resize *s to fit new string. */
name|newstr
operator|=
name|realloc
argument_list|(
operator|*
name|s
argument_list|,
name|newsiz
argument_list|)
expr_stmt|;
if|if
condition|(
name|newstr
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|2
argument_list|,
literal|"astrcat"
argument_list|)
expr_stmt|;
operator|*
name|s
operator|=
name|newstr
expr_stmt|;
comment|/* *s + offset should be end of string. */
comment|/* Concatenate. */
name|strlcpy
argument_list|(
operator|*
name|s
operator|+
name|offset
argument_list|,
literal|"\n"
argument_list|,
name|newsiz
operator|-
name|offset
argument_list|)
expr_stmt|;
name|strlcat
argument_list|(
operator|*
name|s
operator|+
name|offset
argument_list|,
name|append
argument_list|,
name|newsiz
operator|-
name|offset
argument_list|)
expr_stmt|;
comment|/* New string length should be exactly newsiz - 1 characters. */
comment|/* Store generated string's values. */
name|offset
operator|=
name|newsiz
operator|-
literal|1
expr_stmt|;
name|oldstr
operator|=
operator|*
name|s
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process diff set queue, printing, prompting, and saving each diff  * line stored in queue.  */
end_comment

begin_function
specifier|static
name|void
name|processq
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|diffline
modifier|*
name|diffp
decl_stmt|;
name|char
name|divc
decl_stmt|,
modifier|*
name|left
decl_stmt|,
modifier|*
name|right
decl_stmt|;
comment|/* Don't process empty queue. */
if|if
condition|(
name|STAILQ_EMPTY
argument_list|(
operator|&
name|diffhead
argument_list|)
condition|)
return|return;
comment|/* Remember the divider. */
name|divc
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|diffhead
argument_list|)
operator|->
name|div
expr_stmt|;
name|left
operator|=
name|NULL
expr_stmt|;
name|right
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Go through set of diffs, concatenating each line in left or 	 * right column into two long strings, `left' and `right'. 	 */
name|STAILQ_FOREACH
argument_list|(
argument|diffp
argument_list|,
argument|&diffhead
argument_list|,
argument|diffentries
argument_list|)
block|{
comment|/* 		 * Print changed lines if -s was given, 		 * print all lines if -s was not given. 		 */
if|if
condition|(
operator|!
name|sflag
operator|||
name|diffp
operator|->
name|div
operator|==
literal|'|'
operator|||
name|diffp
operator|->
name|div
operator|==
literal|'<'
operator|||
name|diffp
operator|->
name|div
operator|==
literal|'>'
condition|)
name|println
argument_list|(
name|diffp
operator|->
name|left
argument_list|,
name|diffp
operator|->
name|div
argument_list|,
name|diffp
operator|->
name|right
argument_list|)
expr_stmt|;
comment|/* Append new lines to diff set. */
if|if
condition|(
name|diffp
operator|->
name|left
condition|)
name|astrcat
argument_list|(
operator|&
name|left
argument_list|,
name|diffp
operator|->
name|left
argument_list|)
expr_stmt|;
if|if
condition|(
name|diffp
operator|->
name|right
condition|)
name|astrcat
argument_list|(
operator|&
name|right
argument_list|,
name|diffp
operator|->
name|right
argument_list|)
expr_stmt|;
block|}
comment|/* Empty queue and free each diff line and its elements. */
while|while
condition|(
operator|!
name|STAILQ_EMPTY
argument_list|(
operator|&
name|diffhead
argument_list|)
condition|)
block|{
name|diffp
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|diffhead
argument_list|)
expr_stmt|;
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|diffhead
argument_list|,
name|diffentries
argument_list|)
expr_stmt|;
name|freediff
argument_list|(
name|diffp
argument_list|)
expr_stmt|;
block|}
comment|/* Write to outfp, prompting user if lines are different. */
if|if
condition|(
name|outfp
condition|)
switch|switch
condition|(
name|divc
condition|)
block|{
case|case
literal|' '
case|:
case|case
literal|'('
case|:
case|case
literal|')'
case|:
name|fprintf
argument_list|(
name|outfp
argument_list|,
literal|"%s\n"
argument_list|,
name|left
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'|'
case|:
case|case
literal|'<'
case|:
case|case
literal|'>'
case|:
name|prompt
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
expr_stmt|;
break|break;
default|default:
name|errx
argument_list|(
literal|2
argument_list|,
literal|"invalid divider: %c"
argument_list|,
name|divc
argument_list|)
expr_stmt|;
block|}
comment|/* Free left and right. */
name|free
argument_list|(
name|left
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|right
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Print lines following an (a)ppend command.  */
end_comment

begin_function
specifier|static
name|void
name|printa
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|size_t
name|line2
parameter_list|)
block|{
name|char
modifier|*
name|line
decl_stmt|;
for|for
control|(
init|;
name|file2ln
operator|<=
name|line2
condition|;
operator|++
name|file2ln
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|line
operator|=
name|xfgets
argument_list|(
name|file
argument_list|)
operator|)
condition|)
name|errx
argument_list|(
literal|2
argument_list|,
literal|"append ended early"
argument_list|)
expr_stmt|;
name|enqueue
argument_list|(
name|NULL
argument_list|,
literal|'>'
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
name|processq
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Print lines following a (c)hange command, from file1ln to file1end  * and from file2ln to file2end.  */
end_comment

begin_function
specifier|static
name|void
name|printc
parameter_list|(
name|FILE
modifier|*
name|file1
parameter_list|,
name|size_t
name|file1end
parameter_list|,
name|FILE
modifier|*
name|file2
parameter_list|,
name|size_t
name|file2end
parameter_list|)
block|{
struct|struct
name|fileline
block|{
name|STAILQ_ENTRY
argument_list|(
argument|fileline
argument_list|)
name|fileentries
expr_stmt|;
name|char
modifier|*
name|line
decl_stmt|;
block|}
struct|;
name|STAILQ_HEAD
argument_list|(
argument_list|,
argument|fileline
argument_list|)
name|delqhead
operator|=
name|STAILQ_HEAD_INITIALIZER
argument_list|(
name|delqhead
argument_list|)
expr_stmt|;
comment|/* Read lines to be deleted. */
for|for
control|(
init|;
name|file1ln
operator|<=
name|file1end
condition|;
operator|++
name|file1ln
control|)
block|{
name|struct
name|fileline
modifier|*
name|linep
decl_stmt|;
name|char
modifier|*
name|line1
decl_stmt|;
comment|/* Read lines from both. */
if|if
condition|(
operator|!
operator|(
name|line1
operator|=
name|xfgets
argument_list|(
name|file1
argument_list|)
operator|)
condition|)
name|errx
argument_list|(
literal|2
argument_list|,
literal|"error reading file1 in delete in change"
argument_list|)
expr_stmt|;
comment|/* Add to delete queue. */
if|if
condition|(
operator|!
operator|(
name|linep
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|fileline
argument_list|)
argument_list|)
operator|)
condition|)
name|err
argument_list|(
literal|2
argument_list|,
literal|"printc"
argument_list|)
expr_stmt|;
name|linep
operator|->
name|line
operator|=
name|line1
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|delqhead
argument_list|,
name|linep
argument_list|,
name|fileentries
argument_list|)
expr_stmt|;
block|}
comment|/* Process changed lines.. */
for|for
control|(
init|;
operator|!
name|STAILQ_EMPTY
argument_list|(
operator|&
name|delqhead
argument_list|)
operator|&&
name|file2ln
operator|<=
name|file2end
condition|;
operator|++
name|file2ln
control|)
block|{
name|struct
name|fileline
modifier|*
name|del
decl_stmt|;
name|char
modifier|*
name|add
decl_stmt|;
comment|/* Get add line. */
if|if
condition|(
operator|!
operator|(
name|add
operator|=
name|xfgets
argument_list|(
name|file2
argument_list|)
operator|)
condition|)
name|errx
argument_list|(
literal|2
argument_list|,
literal|"error reading add in change"
argument_list|)
expr_stmt|;
name|del
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|delqhead
argument_list|)
expr_stmt|;
name|enqueue
argument_list|(
name|del
operator|->
name|line
argument_list|,
literal|'|'
argument_list|,
name|add
argument_list|)
expr_stmt|;
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|delqhead
argument_list|,
name|fileentries
argument_list|)
expr_stmt|;
comment|/* 		 * Free fileline structure but not its elements since 		 * they are queued up. 		 */
name|free
argument_list|(
name|del
argument_list|)
expr_stmt|;
block|}
name|processq
argument_list|()
expr_stmt|;
comment|/* Process remaining lines to add. */
for|for
control|(
init|;
name|file2ln
operator|<=
name|file2end
condition|;
operator|++
name|file2ln
control|)
block|{
name|char
modifier|*
name|add
decl_stmt|;
comment|/* Get add line. */
if|if
condition|(
operator|!
operator|(
name|add
operator|=
name|xfgets
argument_list|(
name|file2
argument_list|)
operator|)
condition|)
name|errx
argument_list|(
literal|2
argument_list|,
literal|"error reading add in change"
argument_list|)
expr_stmt|;
name|enqueue
argument_list|(
name|NULL
argument_list|,
literal|'>'
argument_list|,
name|add
argument_list|)
expr_stmt|;
block|}
name|processq
argument_list|()
expr_stmt|;
comment|/* Process remaining lines to delete. */
while|while
condition|(
operator|!
name|STAILQ_EMPTY
argument_list|(
operator|&
name|delqhead
argument_list|)
condition|)
block|{
name|struct
name|fileline
modifier|*
name|filep
decl_stmt|;
name|filep
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|delqhead
argument_list|)
expr_stmt|;
name|enqueue
argument_list|(
name|filep
operator|->
name|line
argument_list|,
literal|'<'
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|delqhead
argument_list|,
name|fileentries
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|filep
argument_list|)
expr_stmt|;
block|}
name|processq
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Print deleted lines from file, from file1ln to file1end.  */
end_comment

begin_function
specifier|static
name|void
name|printd
parameter_list|(
name|FILE
modifier|*
name|file1
parameter_list|,
name|size_t
name|file1end
parameter_list|)
block|{
name|char
modifier|*
name|line1
decl_stmt|;
comment|/* Print out lines file1ln to line2. */
for|for
control|(
init|;
name|file1ln
operator|<=
name|file1end
condition|;
operator|++
name|file1ln
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|line1
operator|=
name|xfgets
argument_list|(
name|file1
argument_list|)
operator|)
condition|)
name|errx
argument_list|(
literal|2
argument_list|,
literal|"file1 ended early in delete"
argument_list|)
expr_stmt|;
name|enqueue
argument_list|(
name|line1
argument_list|,
literal|'<'
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|processq
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Interactive mode usage.  */
end_comment

begin_function
specifier|static
name|void
name|int_usage
parameter_list|(
name|void
parameter_list|)
block|{
name|puts
argument_list|(
literal|"e:\tedit blank diff\n"
literal|"eb:\tedit both diffs concatenated\n"
literal|"el:\tedit left diff\n"
literal|"er:\tedit right diff\n"
literal|"l | 1:\tchoose left diff\n"
literal|"r | 2:\tchoose right diff\n"
literal|"s:\tsilent mode--don't print identical lines\n"
literal|"v:\tverbose mode--print identical lines\n"
literal|"q:\tquit"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: sdiff [-abdilstW] [-I regexp] [-o outfile] [-w width] file1"
literal|" file2\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

