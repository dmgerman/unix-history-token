begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1988, 1993  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|copyright
index|[]
init|=
literal|"@(#) Copyright (c) 1988, 1993\n\ 	The Regents of the University of California.  All rights reserved.\n"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static char sccsid[] = "@(#)kdump.c	8.1 (Berkeley) 6/6/93";
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_define
define|#
directive|define
name|_KERNEL
end_define

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_undef
undef|#
directive|undef
name|_KERNEL
end_undef

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktrace.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/ptrace.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<locale.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<vis.h>
end_include

begin_include
include|#
directive|include
file|"ktrace.h"
end_include

begin_decl_stmt
name|int
name|timestamp
decl_stmt|,
name|decimal
decl_stmt|,
name|fancy
init|=
literal|1
decl_stmt|,
name|tail
decl_stmt|,
name|maxdata
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|tracefile
init|=
name|DEF_TRACEFILE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|ktr_header
name|ktr_header
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|eqs
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|)
value|(strcmp((s1), (s2)) == 0)
end_define

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|int
name|ch
decl_stmt|,
name|ktrlen
decl_stmt|,
name|size
decl_stmt|;
specifier|register
name|void
modifier|*
name|m
decl_stmt|;
name|int
name|trpoints
init|=
name|ALL_POINTS
decl_stmt|;
operator|(
name|void
operator|)
name|setlocale
argument_list|(
name|LC_CTYPE
argument_list|,
literal|""
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"f:dlm:nRTt:"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
switch|switch
condition|(
operator|(
name|char
operator|)
name|ch
condition|)
block|{
case|case
literal|'f'
case|:
name|tracefile
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|decimal
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|tail
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|maxdata
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|fancy
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|timestamp
operator|=
literal|2
expr_stmt|;
comment|/* relative timestamp */
break|break;
case|case
literal|'T'
case|:
name|timestamp
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|trpoints
operator|=
name|getpoints
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|trpoints
operator|<
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"unknown trace point in %s"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|>
name|optind
condition|)
name|usage
argument_list|()
expr_stmt|;
name|m
operator|=
operator|(
name|void
operator|*
operator|)
name|malloc
argument_list|(
name|size
operator|=
literal|1025
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s"
argument_list|,
name|strerror
argument_list|(
name|ENOMEM
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|freopen
argument_list|(
name|tracefile
argument_list|,
literal|"r"
argument_list|,
name|stdin
argument_list|)
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"%s"
argument_list|,
name|tracefile
argument_list|)
expr_stmt|;
while|while
condition|(
name|fread_tail
argument_list|(
operator|&
name|ktr_header
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ktr_header
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
name|trpoints
operator|&
operator|(
literal|1
operator|<<
name|ktr_header
operator|.
name|ktr_type
operator|)
condition|)
name|dumpheader
argument_list|(
operator|&
name|ktr_header
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ktrlen
operator|=
name|ktr_header
operator|.
name|ktr_len
operator|)
operator|<
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"bogus length 0x%x"
argument_list|,
name|ktrlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|ktrlen
operator|>
name|size
condition|)
block|{
name|m
operator|=
operator|(
name|void
operator|*
operator|)
name|realloc
argument_list|(
name|m
argument_list|,
name|ktrlen
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s"
argument_list|,
name|strerror
argument_list|(
name|ENOMEM
argument_list|)
argument_list|)
expr_stmt|;
name|size
operator|=
name|ktrlen
expr_stmt|;
block|}
if|if
condition|(
name|ktrlen
operator|&&
name|fread_tail
argument_list|(
name|m
argument_list|,
name|ktrlen
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"data too short"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|trpoints
operator|&
operator|(
literal|1
operator|<<
name|ktr_header
operator|.
name|ktr_type
operator|)
operator|)
operator|==
literal|0
condition|)
continue|continue;
switch|switch
condition|(
name|ktr_header
operator|.
name|ktr_type
condition|)
block|{
case|case
name|KTR_SYSCALL
case|:
name|ktrsyscall
argument_list|(
operator|(
expr|struct
name|ktr_syscall
operator|*
operator|)
name|m
argument_list|)
expr_stmt|;
break|break;
case|case
name|KTR_SYSRET
case|:
name|ktrsysret
argument_list|(
operator|(
expr|struct
name|ktr_sysret
operator|*
operator|)
name|m
argument_list|)
expr_stmt|;
break|break;
case|case
name|KTR_NAMEI
case|:
name|ktrnamei
argument_list|(
name|m
argument_list|,
name|ktrlen
argument_list|)
expr_stmt|;
break|break;
case|case
name|KTR_GENIO
case|:
name|ktrgenio
argument_list|(
operator|(
expr|struct
name|ktr_genio
operator|*
operator|)
name|m
argument_list|,
name|ktrlen
argument_list|)
expr_stmt|;
break|break;
case|case
name|KTR_PSIG
case|:
name|ktrpsig
argument_list|(
operator|(
expr|struct
name|ktr_psig
operator|*
operator|)
name|m
argument_list|)
expr_stmt|;
break|break;
case|case
name|KTR_CSW
case|:
name|ktrcsw
argument_list|(
operator|(
expr|struct
name|ktr_csw
operator|*
operator|)
name|m
argument_list|)
expr_stmt|;
break|break;
case|case
name|KTR_USER
case|:
name|ktruser
argument_list|(
name|ktrlen
argument_list|,
name|m
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|tail
condition|)
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_macro
name|fread_tail
argument_list|(
argument|buf
argument_list|,
argument|size
argument_list|,
argument|num
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|num
decl_stmt|,
name|size
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
while|while
condition|(
operator|(
name|i
operator|=
name|fread
argument_list|(
name|buf
argument_list|,
name|size
argument_list|,
name|num
argument_list|,
name|stdin
argument_list|)
operator|)
operator|==
literal|0
operator|&&
name|tail
condition|)
block|{
operator|(
name|void
operator|)
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|clearerr
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|i
operator|)
return|;
block|}
end_block

begin_macro
name|dumpheader
argument_list|(
argument|kth
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|ktr_header
modifier|*
name|kth
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|static
name|char
name|unknown
index|[
literal|64
index|]
decl_stmt|;
specifier|static
name|struct
name|timeval
name|prevtime
decl_stmt|,
name|temp
decl_stmt|;
name|char
modifier|*
name|type
decl_stmt|;
switch|switch
condition|(
name|kth
operator|->
name|ktr_type
condition|)
block|{
case|case
name|KTR_SYSCALL
case|:
name|type
operator|=
literal|"CALL"
expr_stmt|;
break|break;
case|case
name|KTR_SYSRET
case|:
name|type
operator|=
literal|"RET "
expr_stmt|;
break|break;
case|case
name|KTR_NAMEI
case|:
name|type
operator|=
literal|"NAMI"
expr_stmt|;
break|break;
case|case
name|KTR_GENIO
case|:
name|type
operator|=
literal|"GIO "
expr_stmt|;
break|break;
case|case
name|KTR_PSIG
case|:
name|type
operator|=
literal|"PSIG"
expr_stmt|;
break|break;
case|case
name|KTR_CSW
case|:
name|type
operator|=
literal|"CSW"
expr_stmt|;
break|break;
case|case
name|KTR_USER
case|:
name|type
operator|=
literal|"USER"
expr_stmt|;
break|break;
default|default:
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|unknown
argument_list|,
literal|"UNKNOWN(%d)"
argument_list|,
name|kth
operator|->
name|ktr_type
argument_list|)
expr_stmt|;
name|type
operator|=
name|unknown
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%6d %-8.*s "
argument_list|,
name|kth
operator|->
name|ktr_pid
argument_list|,
name|MAXCOMLEN
argument_list|,
name|kth
operator|->
name|ktr_comm
argument_list|)
expr_stmt|;
if|if
condition|(
name|timestamp
condition|)
block|{
if|if
condition|(
name|timestamp
operator|==
literal|2
condition|)
block|{
name|temp
operator|=
name|kth
operator|->
name|ktr_time
expr_stmt|;
name|timevalsub
argument_list|(
operator|&
name|kth
operator|->
name|ktr_time
argument_list|,
operator|&
name|prevtime
argument_list|)
expr_stmt|;
name|prevtime
operator|=
name|temp
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%ld.%06ld "
argument_list|,
name|kth
operator|->
name|ktr_time
operator|.
name|tv_sec
argument_list|,
name|kth
operator|->
name|ktr_time
operator|.
name|tv_usec
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s  "
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
end_block

begin_include
include|#
directive|include
file|<sys/syscall.h>
end_include

begin_define
define|#
directive|define
name|KTRACE
end_define

begin_include
include|#
directive|include
file|<sys/kern/syscalls.c>
end_include

begin_undef
undef|#
directive|undef
name|KTRACE
end_undef

begin_decl_stmt
name|int
name|nsyscalls
init|=
sizeof|sizeof
argument_list|(
name|syscallnames
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|syscallnames
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ptrace_ops
index|[]
init|=
block|{
literal|"PT_TRACE_ME"
block|,
literal|"PT_READ_I"
block|,
literal|"PT_READ_D"
block|,
literal|"PT_READ_U"
block|,
literal|"PT_WRITE_I"
block|,
literal|"PT_WRITE_D"
block|,
literal|"PT_WRITE_U"
block|,
literal|"PT_CONTINUE"
block|,
literal|"PT_KILL"
block|,
literal|"PT_STEP"
block|,
literal|"PT_ATTACH"
block|,
literal|"PT_DETACH"
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|ktrsyscall
argument_list|(
name|ktr
argument_list|)
specifier|register
expr|struct
name|ktr_syscall
operator|*
name|ktr
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|narg
operator|=
name|ktr
operator|->
name|ktr_narg
expr_stmt|;
specifier|register
name|register_t
modifier|*
name|ip
decl_stmt|;
name|char
modifier|*
name|ioctlname
parameter_list|()
function_decl|;
if|if
condition|(
name|ktr
operator|->
name|ktr_code
operator|>=
name|nsyscalls
operator|||
name|ktr
operator|->
name|ktr_code
operator|<
literal|0
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"[%d]"
argument_list|,
name|ktr
operator|->
name|ktr_code
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|syscallnames
index|[
name|ktr
operator|->
name|ktr_code
index|]
argument_list|)
expr_stmt|;
name|ip
operator|=
operator|&
name|ktr
operator|->
name|ktr_args
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|narg
condition|)
block|{
name|char
name|c
init|=
literal|'('
decl_stmt|;
if|if
condition|(
name|fancy
condition|)
block|{
if|if
condition|(
name|ktr
operator|->
name|ktr_code
operator|==
name|SYS_ioctl
condition|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|decimal
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"(%ld"
argument_list|,
operator|(
name|long
operator|)
operator|*
name|ip
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"(%#lx"
argument_list|,
operator|(
name|long
operator|)
operator|*
name|ip
argument_list|)
expr_stmt|;
name|ip
operator|++
expr_stmt|;
name|narg
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|ioctlname
argument_list|(
operator|*
name|ip
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|",%s"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|decimal
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|",%ld"
argument_list|,
operator|(
name|long
operator|)
operator|*
name|ip
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|",%#lx "
argument_list|,
operator|(
name|long
operator|)
operator|*
name|ip
argument_list|)
expr_stmt|;
block|}
name|c
operator|=
literal|','
expr_stmt|;
name|ip
operator|++
expr_stmt|;
name|narg
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ktr
operator|->
name|ktr_code
operator|==
name|SYS_ptrace
condition|)
block|{
if|if
condition|(
operator|*
name|ip
operator|<
sizeof|sizeof
argument_list|(
name|ptrace_ops
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|ptrace_ops
index|[
literal|0
index|]
argument_list|)
operator|&&
operator|*
name|ip
operator|>=
literal|0
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"(%s"
argument_list|,
name|ptrace_ops
index|[
operator|*
name|ip
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PT_GETREGS
elseif|else
if|if
condition|(
operator|*
name|ip
operator|==
name|PT_GETREGS
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"(%s"
argument_list|,
literal|"PT_GETREGS"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PT_SETREGS
elseif|else
if|if
condition|(
operator|*
name|ip
operator|==
name|PT_SETREGS
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"(%s"
argument_list|,
literal|"PT_SETREGS"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PT_GETFPREGS
elseif|else
if|if
condition|(
operator|*
name|ip
operator|==
name|PT_GETFPREGS
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"(%s"
argument_list|,
literal|"PT_GETFPREGS"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PT_SETFPREGS
elseif|else
if|if
condition|(
operator|*
name|ip
operator|==
name|PT_SETFPREGS
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"(%s"
argument_list|,
literal|"PT_SETFPREGS"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PT_GETDBREGS
elseif|else
if|if
condition|(
operator|*
name|ip
operator|==
name|PT_GETDBREGS
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"(%s"
argument_list|,
literal|"PT_GETDBREGS"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PT_SETDBREGS
elseif|else
if|if
condition|(
operator|*
name|ip
operator|==
name|PT_SETDBREGS
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"(%s"
argument_list|,
literal|"PT_SETDBREGS"
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|else
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"(%ld"
argument_list|,
operator|(
name|long
operator|)
operator|*
name|ip
argument_list|)
expr_stmt|;
name|c
operator|=
literal|','
expr_stmt|;
name|ip
operator|++
expr_stmt|;
name|narg
operator|--
expr_stmt|;
block|}
block|}
while|while
condition|(
name|narg
condition|)
block|{
if|if
condition|(
name|decimal
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%c%ld"
argument_list|,
name|c
argument_list|,
operator|(
name|long
operator|)
operator|*
name|ip
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%c%#lx"
argument_list|,
name|c
argument_list|,
operator|(
name|long
operator|)
operator|*
name|ip
argument_list|)
expr_stmt|;
name|c
operator|=
literal|','
expr_stmt|;
name|ip
operator|++
expr_stmt|;
name|narg
operator|--
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|putchar
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ktrsysret
argument_list|(
argument|ktr
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|ktr_sysret
modifier|*
name|ktr
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|register_t
name|ret
init|=
name|ktr
operator|->
name|ktr_retval
decl_stmt|;
specifier|register
name|int
name|error
init|=
name|ktr
operator|->
name|ktr_error
decl_stmt|;
specifier|register
name|int
name|code
init|=
name|ktr
operator|->
name|ktr_code
decl_stmt|;
if|if
condition|(
name|code
operator|>=
name|nsyscalls
operator|||
name|code
operator|<
literal|0
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"[%d] "
argument_list|,
name|code
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s "
argument_list|,
name|syscallnames
index|[
name|code
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|fancy
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%d"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
operator|||
name|ret
operator|>
literal|9
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"/%#lx"
argument_list|,
operator|(
name|long
operator|)
name|ret
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|decimal
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%ld"
argument_list|,
operator|(
name|long
operator|)
name|ret
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%#lx"
argument_list|,
operator|(
name|long
operator|)
name|ret
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|error
operator|==
name|ERESTART
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"RESTART"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|error
operator|==
name|EJUSTRETURN
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"JUSTRETURN"
argument_list|)
expr_stmt|;
else|else
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"-1 errno %d"
argument_list|,
name|ktr
operator|->
name|ktr_error
argument_list|)
expr_stmt|;
if|if
condition|(
name|fancy
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|" %s"
argument_list|,
name|strerror
argument_list|(
name|ktr
operator|->
name|ktr_error
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ktrnamei
argument_list|(
argument|cp
argument_list|,
argument|len
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|cp
decl_stmt|;
end_decl_stmt

begin_block
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\"%.*s\"\n"
argument_list|,
name|len
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ktrgenio
argument_list|(
argument|ktr
argument_list|,
argument|len
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|ktr_genio
modifier|*
name|ktr
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|datalen
init|=
name|len
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ktr_genio
argument_list|)
decl_stmt|;
specifier|register
name|char
modifier|*
name|dp
init|=
operator|(
name|char
operator|*
operator|)
name|ktr
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ktr_genio
argument_list|)
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|int
name|col
init|=
literal|0
decl_stmt|;
specifier|register
name|width
expr_stmt|;
name|char
name|visbuf
index|[
literal|5
index|]
decl_stmt|;
specifier|static
name|screenwidth
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|screenwidth
operator|==
literal|0
condition|)
block|{
name|struct
name|winsize
name|ws
decl_stmt|;
if|if
condition|(
name|fancy
operator|&&
name|ioctl
argument_list|(
name|fileno
argument_list|(
name|stderr
argument_list|)
argument_list|,
name|TIOCGWINSZ
argument_list|,
operator|&
name|ws
argument_list|)
operator|!=
operator|-
literal|1
operator|&&
name|ws
operator|.
name|ws_col
operator|>
literal|8
condition|)
name|screenwidth
operator|=
name|ws
operator|.
name|ws_col
expr_stmt|;
else|else
name|screenwidth
operator|=
literal|80
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"fd %d %s %d byte%s\n"
argument_list|,
name|ktr
operator|->
name|ktr_fd
argument_list|,
name|ktr
operator|->
name|ktr_rw
operator|==
name|UIO_READ
condition|?
literal|"read"
else|:
literal|"wrote"
argument_list|,
name|datalen
argument_list|,
name|datalen
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|)
expr_stmt|;
if|if
condition|(
name|maxdata
operator|&&
name|datalen
operator|>
name|maxdata
condition|)
name|datalen
operator|=
name|maxdata
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"       \""
argument_list|)
expr_stmt|;
name|col
operator|=
literal|8
expr_stmt|;
for|for
control|(
init|;
name|datalen
operator|>
literal|0
condition|;
name|datalen
operator|--
operator|,
name|dp
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|vis
argument_list|(
name|visbuf
argument_list|,
operator|*
name|dp
argument_list|,
name|VIS_CSTYLE
argument_list|,
operator|*
operator|(
name|dp
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|cp
operator|=
name|visbuf
expr_stmt|;
comment|/* 		 * Keep track of printables and 		 * space chars (like fold(1)). 		 */
if|if
condition|(
name|col
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|putchar
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
name|col
operator|=
literal|8
expr_stmt|;
block|}
switch|switch
condition|(
operator|*
name|cp
condition|)
block|{
case|case
literal|'\n'
case|:
name|col
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'\t'
case|:
name|width
operator|=
literal|8
operator|-
operator|(
name|col
operator|&
literal|07
operator|)
expr_stmt|;
break|break;
default|default:
name|width
operator|=
name|strlen
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|col
operator|+
name|width
operator|>
operator|(
name|screenwidth
operator|-
literal|2
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\\\n\t"
argument_list|)
expr_stmt|;
name|col
operator|=
literal|8
expr_stmt|;
block|}
name|col
operator|+=
name|width
expr_stmt|;
do|do
block|{
operator|(
name|void
operator|)
name|putchar
argument_list|(
operator|*
name|cp
operator|++
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|cp
condition|)
do|;
block|}
if|if
condition|(
name|col
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"       "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|char
modifier|*
name|signames
index|[]
init|=
block|{
literal|"NULL"
block|,
literal|"HUP"
block|,
literal|"INT"
block|,
literal|"QUIT"
block|,
literal|"ILL"
block|,
literal|"TRAP"
block|,
literal|"IOT"
block|,
comment|/*  1 - 6  */
literal|"EMT"
block|,
literal|"FPE"
block|,
literal|"KILL"
block|,
literal|"BUS"
block|,
literal|"SEGV"
block|,
literal|"SYS"
block|,
comment|/*  7 - 12 */
literal|"PIPE"
block|,
literal|"ALRM"
block|,
literal|"TERM"
block|,
literal|"URG"
block|,
literal|"STOP"
block|,
literal|"TSTP"
block|,
comment|/* 13 - 18 */
literal|"CONT"
block|,
literal|"CHLD"
block|,
literal|"TTIN"
block|,
literal|"TTOU"
block|,
literal|"IO"
block|,
literal|"XCPU"
block|,
comment|/* 19 - 24 */
literal|"XFSZ"
block|,
literal|"VTALRM"
block|,
literal|"PROF"
block|,
literal|"WINCH"
block|,
literal|"29"
block|,
literal|"USR1"
block|,
comment|/* 25 - 30 */
literal|"USR2"
block|,
name|NULL
block|,
comment|/* 31 - 32 */
block|}
decl_stmt|;
end_decl_stmt

begin_macro
name|ktrpsig
argument_list|(
argument|psig
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|ktr_psig
modifier|*
name|psig
decl_stmt|;
end_decl_stmt

begin_block
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"SIG%s "
argument_list|,
name|signames
index|[
name|psig
operator|->
name|signo
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|psig
operator|->
name|action
operator|==
name|SIG_DFL
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"SIG_DFL\n"
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"caught handler=0x%lx mask=0x%x code=0x%x\n"
argument_list|,
operator|(
name|u_long
operator|)
name|psig
operator|->
name|action
argument_list|,
name|psig
operator|->
name|mask
argument_list|,
name|psig
operator|->
name|code
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ktrcsw
argument_list|(
argument|cs
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|ktr_csw
modifier|*
name|cs
decl_stmt|;
end_decl_stmt

begin_block
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s %s\n"
argument_list|,
name|cs
operator|->
name|out
condition|?
literal|"stop"
else|:
literal|"resume"
argument_list|,
name|cs
operator|->
name|user
condition|?
literal|"user"
else|:
literal|"kernel"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ktruser
argument_list|(
argument|len
argument_list|,
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|int
name|len
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%d "
argument_list|,
name|len
argument_list|)
expr_stmt|;
while|while
condition|(
name|len
operator|--
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|" %02x"
argument_list|,
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|usage
argument_list|()
end_macro

begin_block
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: kdump [-dnlRT] [-f trfile] [-m maxdata] [-t [cnisuw]]\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

