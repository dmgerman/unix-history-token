begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2003-2007 Tim Kientzle  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"test.h"
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|LOOP_MAX
value|170
end_define

begin_function
specifier|static
name|void
name|create_tree
parameter_list|(
name|void
parameter_list|)
block|{
name|char
name|buff
index|[
literal|260
index|]
decl_stmt|;
name|char
name|buff2
index|[
literal|260
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|assertEqualInt
argument_list|(
literal|0
argument_list|,
name|mkdir
argument_list|(
literal|"original"
argument_list|,
literal|0775
argument_list|)
argument_list|)
expr_stmt|;
name|chdir
argument_list|(
literal|"original"
argument_list|)
expr_stmt|;
name|assertEqualInt
argument_list|(
literal|0
argument_list|,
name|mkdir
argument_list|(
literal|"f"
argument_list|,
literal|0775
argument_list|)
argument_list|)
expr_stmt|;
name|assertEqualInt
argument_list|(
literal|0
argument_list|,
name|mkdir
argument_list|(
literal|"l"
argument_list|,
literal|0775
argument_list|)
argument_list|)
expr_stmt|;
name|assertEqualInt
argument_list|(
literal|0
argument_list|,
name|mkdir
argument_list|(
literal|"m"
argument_list|,
literal|0775
argument_list|)
argument_list|)
expr_stmt|;
name|assertEqualInt
argument_list|(
literal|0
argument_list|,
name|mkdir
argument_list|(
literal|"s"
argument_list|,
literal|0775
argument_list|)
argument_list|)
expr_stmt|;
name|assertEqualInt
argument_list|(
literal|0
argument_list|,
name|mkdir
argument_list|(
literal|"d"
argument_list|,
literal|0775
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LOOP_MAX
condition|;
name|i
operator|++
control|)
block|{
name|buff
index|[
literal|0
index|]
operator|=
literal|'f'
expr_stmt|;
name|buff
index|[
literal|1
index|]
operator|=
literal|'/'
expr_stmt|;
comment|/* Create a file named "f/abcdef..." */
name|buff
index|[
name|i
operator|+
literal|2
index|]
operator|=
literal|'a'
operator|+
operator|(
name|i
operator|%
literal|26
operator|)
expr_stmt|;
name|buff
index|[
name|i
operator|+
literal|3
index|]
operator|=
literal|'\0'
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|buff
argument_list|,
name|O_CREAT
operator||
name|O_WRONLY
argument_list|,
literal|0644
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|fd
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|assertEqualInt
argument_list|(
name|i
operator|+
literal|3
argument_list|,
name|write
argument_list|(
name|fd
argument_list|,
name|buff
argument_list|,
name|strlen
argument_list|(
name|buff
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
comment|/* Create a link named "l/abcdef..." to the above. */
name|strcpy
argument_list|(
name|buff2
argument_list|,
name|buff
argument_list|)
expr_stmt|;
name|buff2
index|[
literal|0
index|]
operator|=
literal|'l'
expr_stmt|;
name|assertEqualInt
argument_list|(
literal|0
argument_list|,
name|link
argument_list|(
name|buff
argument_list|,
name|buff2
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create a link named "m/abcdef..." to the above. */
name|strcpy
argument_list|(
name|buff2
argument_list|,
name|buff
argument_list|)
expr_stmt|;
name|buff2
index|[
literal|0
index|]
operator|=
literal|'m'
expr_stmt|;
name|assertEqualInt
argument_list|(
literal|0
argument_list|,
name|link
argument_list|(
name|buff
argument_list|,
name|buff2
argument_list|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|_WIN32
comment|/* Create a symlink named "s/abcdef..." to the above. */
name|strcpy
argument_list|(
name|buff2
operator|+
literal|3
argument_list|,
name|buff
argument_list|)
expr_stmt|;
name|buff
index|[
literal|0
index|]
operator|=
literal|'s'
expr_stmt|;
name|buff2
index|[
literal|0
index|]
operator|=
literal|'.'
expr_stmt|;
name|buff2
index|[
literal|1
index|]
operator|=
literal|'.'
expr_stmt|;
name|buff2
index|[
literal|2
index|]
operator|=
literal|'/'
expr_stmt|;
name|assertEqualInt
argument_list|(
literal|0
argument_list|,
name|symlink
argument_list|(
name|buff2
argument_list|,
name|buff
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|skipping
argument_list|(
literal|"create a symlink to the above"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Create a dir named "d/abcdef...". */
name|buff
index|[
literal|0
index|]
operator|=
literal|'d'
expr_stmt|;
name|assertEqualInt
argument_list|(
literal|0
argument_list|,
name|mkdir
argument_list|(
name|buff
argument_list|,
literal|0775
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|chdir
argument_list|(
literal|".."
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|LIMIT_NONE
value|0
end_define

begin_define
define|#
directive|define
name|LIMIT_USTAR
value|1
end_define

begin_function
specifier|static
name|void
name|verify_tree
parameter_list|(
name|int
name|limit
parameter_list|)
block|{
name|struct
name|stat
name|st
decl_stmt|,
name|st2
decl_stmt|;
name|char
name|filename
index|[
literal|260
index|]
decl_stmt|;
name|char
name|name1
index|[
literal|260
index|]
decl_stmt|;
name|char
name|name2
index|[
literal|260
index|]
decl_stmt|;
name|char
name|contents
index|[
literal|260
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|r
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|int
name|len
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|dp
decl_stmt|;
name|DIR
modifier|*
name|d
decl_stmt|;
name|struct
name|dirent
modifier|*
name|de
decl_stmt|;
comment|/* Generate the names we know should be there and verify them. */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|LOOP_MAX
condition|;
name|i
operator|++
control|)
block|{
comment|/* Generate a base name of the correct length. */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
operator|++
name|j
control|)
name|filename
index|[
name|j
index|]
operator|=
literal|'a'
operator|+
operator|(
name|j
operator|%
literal|26
operator|)
expr_stmt|;
if|#
directive|if
literal|0
block|for (n = i; n> 0; n /= 10) 			filename[--j] = '0' + (n % 10);
endif|#
directive|endif
name|filename
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Verify a file named "f/abcdef..." */
name|strcpy
argument_list|(
name|name1
argument_list|,
literal|"f/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|name1
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|limit
operator|!=
name|LIMIT_USTAR
operator|||
name|strlen
argument_list|(
name|filename
argument_list|)
operator|<=
literal|100
condition|)
block|{
name|fd
operator|=
name|open
argument_list|(
name|name1
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
name|failure
argument_list|(
literal|"Couldn't open \"%s\": %s"
argument_list|,
name|name1
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|assert
argument_list|(
name|fd
operator|>=
literal|0
argument_list|)
condition|)
block|{
name|len
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|contents
argument_list|,
name|i
operator|+
literal|10
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|assertEqualInt
argument_list|(
name|len
argument_list|,
name|i
operator|+
literal|2
argument_list|)
expr_stmt|;
comment|/* Verify contents of 'contents' */
name|contents
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|failure
argument_list|(
literal|"Each test file contains its own name"
argument_list|)
expr_stmt|;
name|assertEqualString
argument_list|(
name|name1
argument_list|,
name|contents
argument_list|)
expr_stmt|;
comment|/* stat() for dev/ino for next check */
name|assertEqualInt
argument_list|(
literal|0
argument_list|,
name|lstat
argument_list|(
name|name1
argument_list|,
operator|&
name|st
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 		 * ustar allows 100 chars for links, and we have 		 * "original/" as part of the name, so the link 		 * names here can't exceed 91 chars. 		 */
name|strcpy
argument_list|(
name|name2
argument_list|,
literal|"l/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|name2
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|limit
operator|!=
name|LIMIT_USTAR
operator|||
name|strlen
argument_list|(
name|name2
argument_list|)
operator|<=
literal|100
condition|)
block|{
comment|/* Verify hardlink "l/abcdef..." */
name|assertEqualInt
argument_list|(
literal|0
argument_list|,
operator|(
name|r
operator|=
name|lstat
argument_list|(
name|name2
argument_list|,
operator|&
name|st2
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
literal|0
condition|)
block|{
name|assertEqualInt
argument_list|(
name|st2
operator|.
name|st_dev
argument_list|,
name|st
operator|.
name|st_dev
argument_list|)
expr_stmt|;
name|assertEqualInt
argument_list|(
name|st2
operator|.
name|st_ino
argument_list|,
name|st
operator|.
name|st_ino
argument_list|)
expr_stmt|;
block|}
comment|/* Verify hardlink "m_abcdef..." */
name|name2
index|[
literal|0
index|]
operator|=
literal|'m'
expr_stmt|;
name|assertEqualInt
argument_list|(
literal|0
argument_list|,
operator|(
name|r
operator|=
name|lstat
argument_list|(
name|name2
argument_list|,
operator|&
name|st2
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
literal|0
condition|)
block|{
name|assertEqualInt
argument_list|(
name|st2
operator|.
name|st_dev
argument_list|,
name|st
operator|.
name|st_dev
argument_list|)
expr_stmt|;
name|assertEqualInt
argument_list|(
name|st2
operator|.
name|st_ino
argument_list|,
name|st
operator|.
name|st_ino
argument_list|)
expr_stmt|;
block|}
block|}
ifndef|#
directive|ifndef
name|_WIN32
comment|/* 		 * Symlink text doesn't include the 'original/' prefix, 		 * so the limit here is 100 characters. 		 */
comment|/* Verify symlink "s/abcdef..." */
name|strcpy
argument_list|(
name|name2
argument_list|,
literal|"../s/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|name2
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|limit
operator|!=
name|LIMIT_USTAR
operator|||
name|strlen
argument_list|(
name|name2
argument_list|)
operator|<=
literal|100
condition|)
block|{
comment|/* This is a symlink. */
name|failure
argument_list|(
literal|"Couldn't stat %s (length %d)"
argument_list|,
name|filename
argument_list|,
name|strlen
argument_list|(
name|filename
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|assertEqualInt
argument_list|(
literal|0
argument_list|,
name|lstat
argument_list|(
name|name2
operator|+
literal|3
argument_list|,
operator|&
name|st2
argument_list|)
argument_list|)
condition|)
block|{
name|assert
argument_list|(
name|S_ISLNK
argument_list|(
name|st2
operator|.
name|st_mode
argument_list|)
argument_list|)
expr_stmt|;
comment|/* This is a symlink to the file above. */
name|failure
argument_list|(
literal|"Couldn't stat %s"
argument_list|,
name|name2
operator|+
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|assertEqualInt
argument_list|(
literal|0
argument_list|,
name|stat
argument_list|(
name|name2
operator|+
literal|3
argument_list|,
operator|&
name|st2
argument_list|)
argument_list|)
condition|)
block|{
name|assertEqualInt
argument_list|(
name|st2
operator|.
name|st_dev
argument_list|,
name|st
operator|.
name|st_dev
argument_list|)
expr_stmt|;
name|assertEqualInt
argument_list|(
name|st2
operator|.
name|st_ino
argument_list|,
name|st
operator|.
name|st_ino
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|#
directive|else
name|skipping
argument_list|(
literal|"verify symlink"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Verify dir "d/abcdef...". */
name|strcpy
argument_list|(
name|name1
argument_list|,
literal|"d/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|name1
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|limit
operator|!=
name|LIMIT_USTAR
operator|||
name|strlen
argument_list|(
name|filename
argument_list|)
operator|<
literal|100
condition|)
block|{
comment|/* This is a dir. */
name|failure
argument_list|(
literal|"Couldn't stat %s (length %d)"
argument_list|,
name|name1
argument_list|,
name|strlen
argument_list|(
name|filename
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|assertEqualInt
argument_list|(
literal|0
argument_list|,
name|lstat
argument_list|(
name|name1
argument_list|,
operator|&
name|st2
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|assert
argument_list|(
name|S_ISDIR
argument_list|(
name|st2
operator|.
name|st_mode
argument_list|)
argument_list|)
condition|)
block|{
comment|/* TODO: opendir/readdir this 					 * directory and make sure 					 * it's empty. 					 */
block|}
block|}
block|}
block|}
comment|/* Now make sure nothing is there that shouldn't be. */
for|for
control|(
name|dp
operator|=
literal|"dflms"
init|;
operator|*
name|dp
operator|!=
literal|'\0'
condition|;
operator|++
name|dp
control|)
block|{
name|char
name|dir
index|[
literal|2
index|]
decl_stmt|;
name|dir
index|[
literal|0
index|]
operator|=
operator|*
name|dp
expr_stmt|;
name|dir
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|d
operator|=
name|opendir
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|failure
argument_list|(
literal|"Unable to open dir '%s'"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|assert
argument_list|(
name|d
operator|!=
name|NULL
argument_list|)
condition|)
continue|continue;
while|while
condition|(
operator|(
name|de
operator|=
name|readdir
argument_list|(
name|d
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|p
operator|=
name|de
operator|->
name|d_name
expr_stmt|;
switch|switch
condition|(
name|dp
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'l'
case|:
case|case
literal|'m'
case|:
if|if
condition|(
name|limit
operator|==
name|LIMIT_USTAR
condition|)
block|{
name|failure
argument_list|(
literal|"strlen(p) = %d"
argument_list|,
name|strlen
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|strlen
argument_list|(
name|p
argument_list|)
operator|<=
literal|100
argument_list|)
expr_stmt|;
block|}
case|case
literal|'d'
case|:
if|if
condition|(
name|limit
operator|==
name|LIMIT_USTAR
condition|)
block|{
name|failure
argument_list|(
literal|"strlen(p)=%d"
argument_list|,
name|strlen
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|strlen
argument_list|(
name|p
argument_list|)
operator|<
literal|100
argument_list|)
expr_stmt|;
block|}
case|case
literal|'f'
case|:
case|case
literal|'s'
case|:
if|if
condition|(
name|limit
operator|==
name|LIMIT_USTAR
condition|)
block|{
name|failure
argument_list|(
literal|"strlen(p)=%d"
argument_list|,
name|strlen
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|strlen
argument_list|(
name|p
argument_list|)
operator|<
literal|101
argument_list|)
expr_stmt|;
block|}
comment|/* Our files have very particular filename patterns. */
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|!=
literal|'.'
operator|||
operator|(
name|p
index|[
literal|1
index|]
operator|!=
literal|'.'
operator|&&
name|p
index|[
literal|1
index|]
operator|!=
literal|'\0'
operator|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|p
index|[
name|i
index|]
operator|!=
literal|'\0'
operator|&&
name|i
operator|<
name|LOOP_MAX
condition|;
name|i
operator|++
control|)
block|{
name|failure
argument_list|(
literal|"i=%d, p[i]='%c' 'a'+(i%%26)='%c'"
argument_list|,
name|i
argument_list|,
name|p
index|[
name|i
index|]
argument_list|,
literal|'a'
operator|+
operator|(
name|i
operator|%
literal|26
operator|)
argument_list|)
expr_stmt|;
name|assertEqualInt
argument_list|(
name|p
index|[
name|i
index|]
argument_list|,
literal|'a'
operator|+
operator|(
name|i
operator|%
literal|26
operator|)
argument_list|)
expr_stmt|;
block|}
name|assert
argument_list|(
name|p
index|[
name|i
index|]
operator|==
literal|'\0'
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'.'
case|:
name|assert
argument_list|(
name|p
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|||
operator|(
name|p
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
name|p
index|[
literal|2
index|]
operator|==
literal|'\0'
operator|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|failure
argument_list|(
literal|"File %s shouldn't be here"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|closedir
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|copy_basic
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
name|assertEqualInt
argument_list|(
literal|0
argument_list|,
name|mkdir
argument_list|(
literal|"plain"
argument_list|,
literal|0775
argument_list|)
argument_list|)
expr_stmt|;
name|assertEqualInt
argument_list|(
literal|0
argument_list|,
name|chdir
argument_list|(
literal|"plain"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Use the tar program to create an archive. 	 */
name|r
operator|=
name|systemf
argument_list|(
literal|"%s cf archive -C ../original f d l m s>pack.out 2>pack.err"
argument_list|,
name|testprog
argument_list|)
expr_stmt|;
name|failure
argument_list|(
literal|"Error invoking \"%s cf\""
argument_list|,
name|testprog
argument_list|)
expr_stmt|;
name|assertEqualInt
argument_list|(
name|r
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Verify that nothing went to stdout or stderr. */
name|assertEmptyFile
argument_list|(
literal|"pack.err"
argument_list|)
expr_stmt|;
name|assertEmptyFile
argument_list|(
literal|"pack.out"
argument_list|)
expr_stmt|;
comment|/* 	 * Use tar to unpack the archive into another directory. 	 */
name|r
operator|=
name|systemf
argument_list|(
literal|"%s xf archive>unpack.out 2>unpack.err"
argument_list|,
name|testprog
argument_list|)
expr_stmt|;
name|failure
argument_list|(
literal|"Error invoking %s xf archive"
argument_list|,
name|testprog
argument_list|)
expr_stmt|;
name|assertEqualInt
argument_list|(
name|r
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Verify that nothing went to stdout or stderr. */
name|assertEmptyFile
argument_list|(
literal|"unpack.err"
argument_list|)
expr_stmt|;
name|assertEmptyFile
argument_list|(
literal|"unpack.out"
argument_list|)
expr_stmt|;
name|verify_tree
argument_list|(
name|LIMIT_NONE
argument_list|)
expr_stmt|;
name|assertEqualInt
argument_list|(
literal|0
argument_list|,
name|chdir
argument_list|(
literal|".."
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|copy_ustar
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|target
init|=
literal|"ustar"
decl_stmt|;
name|int
name|r
decl_stmt|;
name|assertEqualInt
argument_list|(
literal|0
argument_list|,
name|mkdir
argument_list|(
name|target
argument_list|,
literal|0775
argument_list|)
argument_list|)
expr_stmt|;
name|assertEqualInt
argument_list|(
literal|0
argument_list|,
name|chdir
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Use the tar program to create an archive. 	 */
name|r
operator|=
name|systemf
argument_list|(
literal|"%s cf archive --format=ustar -C ../original f d l m s>pack.out 2>pack.err"
argument_list|,
name|testprog
argument_list|)
expr_stmt|;
name|failure
argument_list|(
literal|"Error invoking \"%s cf archive --format=ustar\""
argument_list|,
name|testprog
argument_list|)
expr_stmt|;
name|assertEqualInt
argument_list|(
name|r
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Verify that nothing went to stdout. */
name|assertEmptyFile
argument_list|(
literal|"pack.out"
argument_list|)
expr_stmt|;
comment|/* Stderr is non-empty, since there are a bunch of files 	 * with filenames too long to archive. */
comment|/* 	 * Use tar to unpack the archive into another directory. 	 */
name|r
operator|=
name|systemf
argument_list|(
literal|"%s xf archive>unpack.out 2>unpack.err"
argument_list|,
name|testprog
argument_list|)
expr_stmt|;
name|failure
argument_list|(
literal|"Error invoking %s xf archive"
argument_list|,
name|testprog
argument_list|)
expr_stmt|;
name|assertEqualInt
argument_list|(
name|r
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Verify that nothing went to stdout or stderr. */
name|assertEmptyFile
argument_list|(
literal|"unpack.err"
argument_list|)
expr_stmt|;
name|assertEmptyFile
argument_list|(
literal|"unpack.out"
argument_list|)
expr_stmt|;
name|chdir
argument_list|(
literal|"original"
argument_list|)
expr_stmt|;
name|verify_tree
argument_list|(
name|LIMIT_USTAR
argument_list|)
expr_stmt|;
name|chdir
argument_list|(
literal|"../.."
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|DEFINE_TEST
argument_list|(
argument|test_copy
argument_list|)
end_macro

begin_block
block|{
name|int
name|oldumask
decl_stmt|;
name|oldumask
operator|=
name|umask
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|create_tree
argument_list|()
expr_stmt|;
comment|/* Create sample files in "original" dir. */
comment|/* Test simple "tar -c | tar -x" pipeline copy. */
name|copy_basic
argument_list|()
expr_stmt|;
comment|/* Same, but constrain to ustar format. */
name|copy_ustar
argument_list|()
expr_stmt|;
name|umask
argument_list|(
name|oldumask
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

