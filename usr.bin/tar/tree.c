begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2003-2004 Tim Kientzle  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer  *    in this position and unchanged.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*-  * This is a new directory-walking system that addresses a number  * of problems I've had with fts(3).  In particular, it has no  * pathname-length limits (other than the size of 'int'), handles  * deep logical traversals, uses considerably less memory, and has  * an opaque interface (easier to modify in the future).  *  * Internally, it keeps a single list of "tree_entry" items that  * represent filesystem objects that require further attention.  * Non-directories are not kept in memory: they are pulled from  * readdir(), returned to the client, then freed as soon as possible.  * Any directory entry to be traversed gets pushed onto the stack.  *  * There is surprisingly little information that needs to be kept for  * each item on the stack.  Just the name, depth (represented here as the  * string length of the parent directory's pathname), and some markers  * indicating how to get back to the parent (via chdir("..") for a  * regular dir or via fchdir(2) for a symlink).  */
end_comment

begin_include
include|#
directive|include
file|"bsdtar_platform.h"
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<dirent.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_comment
comment|/*  * TODO:  *    1) Loop checking.  *    3) Arbitrary logical traversals by closing/reopening intermediate fds.  */
end_comment

begin_struct
struct|struct
name|tree_entry
block|{
name|struct
name|tree_entry
modifier|*
name|next
decl_stmt|;
name|struct
name|tree_entry
modifier|*
name|parent
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|size_t
name|dirname_length
decl_stmt|;
name|dev_t
name|dev
decl_stmt|;
name|ino_t
name|ino
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Definitions for tree_entry.flags bitmap. */
end_comment

begin_define
define|#
directive|define
name|isDir
value|1
end_define

begin_comment
comment|/* This entry is a regular directory. */
end_comment

begin_define
define|#
directive|define
name|isDirLink
value|2
end_define

begin_comment
comment|/* This entry is a symbolic link to a directory. */
end_comment

begin_define
define|#
directive|define
name|needsPreVisit
value|4
end_define

begin_comment
comment|/* This entry needs to be previsited. */
end_comment

begin_define
define|#
directive|define
name|needsPostVisit
value|8
end_define

begin_comment
comment|/* This entry needs to be postvisited. */
end_comment

begin_comment
comment|/*  * Local data for this package.  */
end_comment

begin_struct
struct|struct
name|tree
block|{
name|struct
name|tree_entry
modifier|*
name|stack
decl_stmt|;
name|struct
name|tree_entry
modifier|*
name|current
decl_stmt|;
name|DIR
modifier|*
name|d
decl_stmt|;
name|int
name|initialDirFd
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|int
name|visit_type
decl_stmt|;
name|int
name|tree_errno
decl_stmt|;
comment|/* Error code from last failed operation. */
name|char
modifier|*
name|buff
decl_stmt|;
specifier|const
name|char
modifier|*
name|basename
decl_stmt|;
name|size_t
name|buff_length
decl_stmt|;
name|size_t
name|path_length
decl_stmt|;
name|size_t
name|dirname_length
decl_stmt|;
name|int
name|depth
decl_stmt|;
name|int
name|openCount
decl_stmt|;
name|int
name|maxOpenCount
decl_stmt|;
name|struct
name|stat
name|lst
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Definitions for tree.flags bitmap. */
end_comment

begin_define
define|#
directive|define
name|needsReturn
value|8
end_define

begin_comment
comment|/* Marks first entry as not having been returned yet. */
end_comment

begin_define
define|#
directive|define
name|hasStat
value|16
end_define

begin_comment
comment|/* The st entry is set. */
end_comment

begin_define
define|#
directive|define
name|hasLstat
value|32
end_define

begin_comment
comment|/* The lst entry is set. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_DIRENT_D_NAMLEN
end_ifdef

begin_comment
comment|/* BSD extension; avoids need for a strlen() call. */
end_comment

begin_define
define|#
directive|define
name|D_NAMELEN
parameter_list|(
name|dp
parameter_list|)
value|(dp)->d_namlen
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|D_NAMELEN
parameter_list|(
name|dp
parameter_list|)
value|(strlen((dp)->d_name))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
literal|0
end_if

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_endif
unit|void tree_dump(struct tree *t, FILE *out) { 	struct tree_entry *te;  	fprintf(out, "\tdepth: %d\n", t->depth); 	fprintf(out, "\tbuff: %s\n", t->buff); 	fprintf(out, "\tpwd: "); fflush(stdout); system("pwd"); 	fprintf(out, "\taccess: %s\n", t->basename); 	fprintf(out, "\tstack:\n"); 	for(te = t->stack; te != NULL; te = te->next) { 		fprintf(out, "\t\tte->name: %s%s%s\n", te->name, 		    te->flags& needsPreVisit ? "" : " *", 		    t->current == te ? " (current)" : ""); 	} }
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Add a directory path to the current stack.  */
end_comment

begin_function
specifier|static
name|void
name|tree_push
parameter_list|(
name|struct
name|tree
modifier|*
name|t
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|struct
name|tree_entry
modifier|*
name|te
decl_stmt|;
name|te
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|te
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|te
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|te
argument_list|)
argument_list|)
expr_stmt|;
name|te
operator|->
name|next
operator|=
name|t
operator|->
name|stack
expr_stmt|;
name|t
operator|->
name|stack
operator|=
name|te
expr_stmt|;
name|te
operator|->
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
name|te
operator|->
name|name
operator|=
name|strdup
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|te
operator|->
name|flags
operator|=
name|needsPreVisit
operator||
name|needsPostVisit
expr_stmt|;
name|te
operator|->
name|dirname_length
operator|=
name|t
operator|->
name|dirname_length
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Append a name to the current path.  */
end_comment

begin_function
specifier|static
name|void
name|tree_append
parameter_list|(
name|struct
name|tree
modifier|*
name|t
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|size_t
name|name_length
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|t
operator|->
name|buff
operator|!=
name|NULL
condition|)
name|t
operator|->
name|buff
index|[
name|t
operator|->
name|dirname_length
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Strip trailing '/' from name, unless entire name is "/". */
while|while
condition|(
name|name_length
operator|>
literal|1
operator|&&
name|name
index|[
name|name_length
operator|-
literal|1
index|]
operator|==
literal|'/'
condition|)
name|name_length
operator|--
expr_stmt|;
comment|/* Resize pathname buffer as needed. */
while|while
condition|(
name|name_length
operator|+
literal|1
operator|+
name|t
operator|->
name|dirname_length
operator|>=
name|t
operator|->
name|buff_length
condition|)
block|{
name|t
operator|->
name|buff_length
operator|*=
literal|2
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|buff_length
operator|<
literal|1024
condition|)
name|t
operator|->
name|buff_length
operator|=
literal|1024
expr_stmt|;
name|t
operator|->
name|buff
operator|=
name|realloc
argument_list|(
name|t
operator|->
name|buff
argument_list|,
name|t
operator|->
name|buff_length
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|t
operator|->
name|buff
operator|+
name|t
operator|->
name|dirname_length
expr_stmt|;
name|t
operator|->
name|path_length
operator|=
name|t
operator|->
name|dirname_length
operator|+
name|name_length
expr_stmt|;
comment|/* Add a separating '/' if it's needed. */
if|if
condition|(
name|t
operator|->
name|dirname_length
operator|>
literal|0
operator|&&
name|p
index|[
operator|-
literal|1
index|]
operator|!=
literal|'/'
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|'/'
expr_stmt|;
name|t
operator|->
name|path_length
operator|++
expr_stmt|;
block|}
name|strncpy
argument_list|(
name|p
argument_list|,
name|name
argument_list|,
name|name_length
argument_list|)
expr_stmt|;
name|p
index|[
name|name_length
index|]
operator|=
literal|'\0'
expr_stmt|;
name|t
operator|->
name|basename
operator|=
name|p
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Open a directory tree for traversal.  */
end_comment

begin_function
name|struct
name|tree
modifier|*
name|tree_open
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|struct
name|tree
modifier|*
name|t
decl_stmt|;
name|t
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|t
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|tree_append
argument_list|(
name|t
argument_list|,
name|path
argument_list|,
name|strlen
argument_list|(
name|path
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|->
name|initialDirFd
operator|=
name|open
argument_list|(
literal|"."
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
comment|/* 	 * During most of the traversal, items are set up and then 	 * returned immediately from tree_next().  That doesn't work 	 * for the very first entry, so we set a flag for this special 	 * case. 	 */
name|t
operator|->
name|flags
operator|=
name|needsReturn
expr_stmt|;
return|return
operator|(
name|t
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * We've finished a directory; ascend back to the parent.  */
end_comment

begin_function
specifier|static
name|void
name|tree_ascend
parameter_list|(
name|struct
name|tree
modifier|*
name|t
parameter_list|)
block|{
name|struct
name|tree_entry
modifier|*
name|te
decl_stmt|;
name|te
operator|=
name|t
operator|->
name|stack
expr_stmt|;
name|t
operator|->
name|depth
operator|--
expr_stmt|;
if|if
condition|(
name|te
operator|->
name|flags
operator|&
name|isDirLink
condition|)
block|{
name|fchdir
argument_list|(
name|te
operator|->
name|fd
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|te
operator|->
name|fd
argument_list|)
expr_stmt|;
name|t
operator|->
name|openCount
operator|--
expr_stmt|;
block|}
else|else
block|{
name|chdir
argument_list|(
literal|".."
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Pop the working stack.  */
end_comment

begin_function
specifier|static
name|void
name|tree_pop
parameter_list|(
name|struct
name|tree
modifier|*
name|t
parameter_list|)
block|{
name|struct
name|tree_entry
modifier|*
name|te
decl_stmt|;
name|t
operator|->
name|buff
index|[
name|t
operator|->
name|dirname_length
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|stack
operator|==
name|t
operator|->
name|current
operator|&&
name|t
operator|->
name|current
operator|!=
name|NULL
condition|)
name|t
operator|->
name|current
operator|=
name|t
operator|->
name|current
operator|->
name|parent
expr_stmt|;
name|te
operator|=
name|t
operator|->
name|stack
expr_stmt|;
name|t
operator|->
name|stack
operator|=
name|te
operator|->
name|next
expr_stmt|;
name|t
operator|->
name|dirname_length
operator|=
name|te
operator|->
name|dirname_length
expr_stmt|;
name|t
operator|->
name|basename
operator|=
name|t
operator|->
name|buff
operator|+
name|t
operator|->
name|dirname_length
expr_stmt|;
comment|/* Special case: starting dir doesn't skip leading '/'. */
if|if
condition|(
name|t
operator|->
name|dirname_length
operator|>
literal|0
condition|)
name|t
operator|->
name|basename
operator|++
expr_stmt|;
name|free
argument_list|(
name|te
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|te
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Get the next item in the tree traversal.  */
end_comment

begin_function
name|int
name|tree_next
parameter_list|(
name|struct
name|tree
modifier|*
name|t
parameter_list|)
block|{
name|struct
name|dirent
modifier|*
name|de
init|=
name|NULL
decl_stmt|;
comment|/* Handle the startup case by returning the initial entry. */
if|if
condition|(
name|t
operator|->
name|flags
operator|&
name|needsReturn
condition|)
block|{
name|t
operator|->
name|flags
operator|&=
operator|~
name|needsReturn
expr_stmt|;
return|return
operator|(
name|t
operator|->
name|visit_type
operator|=
name|TREE_REGULAR
operator|)
return|;
block|}
while|while
condition|(
name|t
operator|->
name|stack
operator|!=
name|NULL
condition|)
block|{
comment|/* If there's an open dir, get the next entry from there. */
while|while
condition|(
name|t
operator|->
name|d
operator|!=
name|NULL
condition|)
block|{
name|de
operator|=
name|readdir
argument_list|(
name|t
operator|->
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|de
operator|==
name|NULL
condition|)
block|{
name|closedir
argument_list|(
name|t
operator|->
name|d
argument_list|)
expr_stmt|;
name|t
operator|->
name|d
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|de
operator|->
name|d_name
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|de
operator|->
name|d_name
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
comment|/* Skip '.' */
block|}
elseif|else
if|if
condition|(
name|de
operator|->
name|d_name
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|de
operator|->
name|d_name
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
name|de
operator|->
name|d_name
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
block|{
comment|/* Skip '..' */
block|}
else|else
block|{
comment|/* 				 * Append the path to the current path 				 * and return it. 				 */
name|tree_append
argument_list|(
name|t
argument_list|,
name|de
operator|->
name|d_name
argument_list|,
name|D_NAMELEN
argument_list|(
name|de
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|->
name|flags
operator|&=
operator|~
name|hasLstat
expr_stmt|;
name|t
operator|->
name|flags
operator|&=
operator|~
name|hasStat
expr_stmt|;
return|return
operator|(
name|t
operator|->
name|visit_type
operator|=
name|TREE_REGULAR
operator|)
return|;
block|}
block|}
comment|/* If the current dir needs to be visited, set it up. */
if|if
condition|(
name|t
operator|->
name|stack
operator|->
name|flags
operator|&
name|needsPreVisit
condition|)
block|{
name|t
operator|->
name|current
operator|=
name|t
operator|->
name|stack
expr_stmt|;
name|tree_append
argument_list|(
name|t
argument_list|,
name|t
operator|->
name|stack
operator|->
name|name
argument_list|,
name|strlen
argument_list|(
name|t
operator|->
name|stack
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|->
name|stack
operator|->
name|flags
operator|&=
operator|~
name|needsPreVisit
expr_stmt|;
comment|/* If it is a link, set up fd for the ascent. */
if|if
condition|(
name|t
operator|->
name|stack
operator|->
name|flags
operator|&
name|isDirLink
condition|)
block|{
name|t
operator|->
name|stack
operator|->
name|fd
operator|=
name|open
argument_list|(
literal|"."
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
name|t
operator|->
name|openCount
operator|++
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|openCount
operator|>
name|t
operator|->
name|maxOpenCount
condition|)
name|t
operator|->
name|maxOpenCount
operator|=
name|t
operator|->
name|openCount
expr_stmt|;
block|}
name|t
operator|->
name|dirname_length
operator|=
name|t
operator|->
name|path_length
expr_stmt|;
if|if
condition|(
name|chdir
argument_list|(
name|t
operator|->
name|stack
operator|->
name|name
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* chdir() failed; return error */
name|tree_pop
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|t
operator|->
name|tree_errno
operator|=
name|errno
expr_stmt|;
return|return
operator|(
name|t
operator|->
name|visit_type
operator|=
name|TREE_ERROR_DIR
operator|)
return|;
block|}
name|t
operator|->
name|depth
operator|++
expr_stmt|;
name|t
operator|->
name|d
operator|=
name|opendir
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|d
operator|==
name|NULL
condition|)
block|{
name|tree_ascend
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Undo "chdir" */
name|tree_pop
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|t
operator|->
name|tree_errno
operator|=
name|errno
expr_stmt|;
return|return
operator|(
name|t
operator|->
name|visit_type
operator|=
name|TREE_ERROR_DIR
operator|)
return|;
block|}
name|t
operator|->
name|flags
operator|&=
operator|~
name|hasLstat
expr_stmt|;
name|t
operator|->
name|flags
operator|&=
operator|~
name|hasStat
expr_stmt|;
name|t
operator|->
name|basename
operator|=
literal|"."
expr_stmt|;
return|return
operator|(
name|t
operator|->
name|visit_type
operator|=
name|TREE_POSTDESCENT
operator|)
return|;
block|}
comment|/* We've done everything necessary for the top stack entry. */
if|if
condition|(
name|t
operator|->
name|stack
operator|->
name|flags
operator|&
name|needsPostVisit
condition|)
block|{
name|tree_ascend
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|tree_pop
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|t
operator|->
name|flags
operator|&=
operator|~
name|hasLstat
expr_stmt|;
name|t
operator|->
name|flags
operator|&=
operator|~
name|hasStat
expr_stmt|;
return|return
operator|(
name|t
operator|->
name|visit_type
operator|=
name|TREE_POSTASCENT
operator|)
return|;
block|}
block|}
return|return
operator|(
name|t
operator|->
name|visit_type
operator|=
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return error code.  */
end_comment

begin_function
name|int
name|tree_errno
parameter_list|(
name|struct
name|tree
modifier|*
name|t
parameter_list|)
block|{
return|return
operator|(
name|t
operator|->
name|tree_errno
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Called by the client to mark the directory just returned from  * tree_next() as needing to be visited.  */
end_comment

begin_function
name|void
name|tree_descend
parameter_list|(
name|struct
name|tree
modifier|*
name|t
parameter_list|)
block|{
if|if
condition|(
name|t
operator|->
name|visit_type
operator|!=
name|TREE_REGULAR
condition|)
return|return;
if|if
condition|(
name|tree_current_is_physical_dir
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|tree_push
argument_list|(
name|t
argument_list|,
name|t
operator|->
name|basename
argument_list|)
expr_stmt|;
name|t
operator|->
name|stack
operator|->
name|flags
operator||=
name|isDir
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tree_current_is_dir
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|tree_push
argument_list|(
name|t
argument_list|,
name|t
operator|->
name|basename
argument_list|)
expr_stmt|;
name|t
operator|->
name|stack
operator|->
name|flags
operator||=
name|isDirLink
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Get the stat() data for the entry just returned from tree_next().  */
end_comment

begin_function
specifier|const
name|struct
name|stat
modifier|*
name|tree_current_stat
parameter_list|(
name|struct
name|tree
modifier|*
name|t
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|t
operator|->
name|flags
operator|&
name|hasStat
operator|)
condition|)
block|{
if|if
condition|(
name|stat
argument_list|(
name|t
operator|->
name|basename
argument_list|,
operator|&
name|t
operator|->
name|st
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|NULL
return|;
name|t
operator|->
name|flags
operator||=
name|hasStat
expr_stmt|;
block|}
return|return
operator|(
operator|&
name|t
operator|->
name|st
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get the lstat() data for the entry just returned from tree_next().  */
end_comment

begin_function
specifier|const
name|struct
name|stat
modifier|*
name|tree_current_lstat
parameter_list|(
name|struct
name|tree
modifier|*
name|t
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|t
operator|->
name|flags
operator|&
name|hasLstat
operator|)
condition|)
block|{
if|if
condition|(
name|lstat
argument_list|(
name|t
operator|->
name|basename
argument_list|,
operator|&
name|t
operator|->
name|lst
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|NULL
return|;
name|t
operator|->
name|flags
operator||=
name|hasLstat
expr_stmt|;
block|}
return|return
operator|(
operator|&
name|t
operator|->
name|lst
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Test whether current entry is a dir or dir link.  */
end_comment

begin_function
name|int
name|tree_current_is_dir
parameter_list|(
name|struct
name|tree
modifier|*
name|t
parameter_list|)
block|{
comment|/* If we've already pulled stat(), just use that. */
if|if
condition|(
name|t
operator|->
name|flags
operator|&
name|hasStat
condition|)
return|return
operator|(
name|S_ISDIR
argument_list|(
name|tree_current_stat
argument_list|(
name|t
argument_list|)
operator|->
name|st_mode
argument_list|)
operator|)
return|;
comment|/* If we've already pulled lstat(), we may be able to use that. */
if|if
condition|(
name|t
operator|->
name|flags
operator|&
name|hasLstat
condition|)
block|{
comment|/* If lstat() says it's a dir, it must be a dir. */
if|if
condition|(
name|S_ISDIR
argument_list|(
name|tree_current_lstat
argument_list|(
name|t
argument_list|)
operator|->
name|st_mode
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* If it's not a dir and not a link, we're done. */
if|if
condition|(
operator|!
name|S_ISLNK
argument_list|(
name|tree_current_lstat
argument_list|(
name|t
argument_list|)
operator|->
name|st_mode
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* 		 * If the above two tests fail, then it's a link, but 		 * we don't know whether it's a link to a dir or a 		 * non-dir. 		 */
block|}
comment|/* TODO: Use a more efficient mechanism when available. */
return|return
operator|(
name|S_ISDIR
argument_list|(
name|tree_current_stat
argument_list|(
name|t
argument_list|)
operator|->
name|st_mode
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Test whether current entry is a physical directory.  */
end_comment

begin_function
name|int
name|tree_current_is_physical_dir
parameter_list|(
name|struct
name|tree
modifier|*
name|t
parameter_list|)
block|{
comment|/* If we've already pulled lstat(), just use that. */
if|if
condition|(
name|t
operator|->
name|flags
operator|&
name|hasLstat
condition|)
return|return
operator|(
name|S_ISDIR
argument_list|(
name|tree_current_lstat
argument_list|(
name|t
argument_list|)
operator|->
name|st_mode
argument_list|)
operator|)
return|;
comment|/* TODO: Use a more efficient mechanism when available. */
return|return
operator|(
name|S_ISDIR
argument_list|(
name|tree_current_lstat
argument_list|(
name|t
argument_list|)
operator|->
name|st_mode
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Test whether current entry is a symbolic link.  */
end_comment

begin_function
name|int
name|tree_current_is_physical_link
parameter_list|(
name|struct
name|tree
modifier|*
name|t
parameter_list|)
block|{
comment|/* If we've already pulled lstat(), just use that. */
if|if
condition|(
name|t
operator|->
name|flags
operator|&
name|hasLstat
condition|)
return|return
operator|(
name|S_ISLNK
argument_list|(
name|tree_current_lstat
argument_list|(
name|t
argument_list|)
operator|->
name|st_mode
argument_list|)
operator|)
return|;
comment|/* TODO: Use a more efficient mechanism when available. */
return|return
operator|(
name|S_ISLNK
argument_list|(
name|tree_current_lstat
argument_list|(
name|t
argument_list|)
operator|->
name|st_mode
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the access path for the entry just returned from tree_next().  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|tree_current_access_path
parameter_list|(
name|struct
name|tree
modifier|*
name|t
parameter_list|)
block|{
return|return
operator|(
name|t
operator|->
name|basename
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the full path for the entry just returned from tree_next().  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|tree_current_path
parameter_list|(
name|struct
name|tree
modifier|*
name|t
parameter_list|)
block|{
return|return
operator|(
name|t
operator|->
name|buff
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the length of the path for the entry just returned from tree_next().  */
end_comment

begin_function
name|size_t
name|tree_current_pathlen
parameter_list|(
name|struct
name|tree
modifier|*
name|t
parameter_list|)
block|{
return|return
operator|(
name|t
operator|->
name|path_length
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the nesting depth of the entry just returned from tree_next().  */
end_comment

begin_function
name|int
name|tree_current_depth
parameter_list|(
name|struct
name|tree
modifier|*
name|t
parameter_list|)
block|{
return|return
operator|(
name|t
operator|->
name|depth
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Terminate the traversal and release any resources.  */
end_comment

begin_function
name|void
name|tree_close
parameter_list|(
name|struct
name|tree
modifier|*
name|t
parameter_list|)
block|{
comment|/* Release anything remaining in the stack. */
while|while
condition|(
name|t
operator|->
name|stack
operator|!=
name|NULL
condition|)
name|tree_pop
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|buff
condition|)
name|free
argument_list|(
name|t
operator|->
name|buff
argument_list|)
expr_stmt|;
comment|/* chdir() back to where we started. */
if|if
condition|(
name|t
operator|->
name|initialDirFd
operator|>=
literal|0
condition|)
block|{
name|fchdir
argument_list|(
name|t
operator|->
name|initialDirFd
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|t
operator|->
name|initialDirFd
argument_list|)
expr_stmt|;
name|t
operator|->
name|initialDirFd
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|free
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

