begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1996  *	Michael Smith.  All rights reserved.  * Copyright (c) 1992, 1993, 1996  *	Berkeley Software Design, Inc.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by Berkeley Software  *	Design, Inc.  *  * THIS SOFTWARE IS PROVIDED BY Berkeley Software Design, Inc. ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL Berkeley Software Design, Inc. BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	BSDI int21.c,v 2.2 1996/04/08 19:32:51 bostic Exp  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<dirent.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<glob.h>
end_include

begin_include
include|#
directive|include
file|<paths.h>
end_include

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"doscmd.h"
end_include

begin_include
include|#
directive|include
file|"cwd.h"
end_include

begin_include
include|#
directive|include
file|"dispatch.h"
end_include

begin_include
include|#
directive|include
file|"tty.h"
end_include

begin_comment
comment|/* Country Info */
end_comment

begin_struct
struct|struct
block|{
name|ushort
name|ciDateFormat
decl_stmt|;
name|char
name|ciCurrency
index|[
literal|5
index|]
decl_stmt|;
name|char
name|ciThousands
index|[
literal|2
index|]
decl_stmt|;
name|char
name|ciDecimal
index|[
literal|2
index|]
decl_stmt|;
name|char
name|ciDateSep
index|[
literal|2
index|]
decl_stmt|;
name|char
name|ciTimeSep
index|[
literal|2
index|]
decl_stmt|;
name|char
name|ciCurrencyFormat
decl_stmt|;
name|char
name|ciCurrencyPlaces
decl_stmt|;
name|char
name|ciTimeFormat
decl_stmt|;
name|ushort
name|ciCaseMapOffset
decl_stmt|;
name|ushort
name|ciCaseMapSegment
decl_stmt|;
name|char
name|ciDataSep
index|[
literal|2
index|]
decl_stmt|;
if|#
directive|if
literal|0
block|char    ciReserved[10];
endif|#
directive|endif
block|}
name|countryinfo
init|=
block|{
literal|0
block|,
literal|"$"
block|,
literal|","
block|,
literal|"."
block|,
literal|"-"
block|,
literal|":"
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
literal|0xffff
block|,
literal|0xffff
block|,
literal|"?"
block|}
struct|;
end_struct

begin_comment
comment|/* DOS File Control Block */
end_comment

begin_struct
struct|struct
name|fcb
block|{
name|u_char
name|fcbMagic
decl_stmt|;
name|u_char
name|fcbResoived
index|[
literal|5
index|]
decl_stmt|;
name|u_char
name|fcbAttribute
decl_stmt|;
name|u_char
name|fcbDriveID
decl_stmt|;
name|u_char
name|fcbFileName
index|[
literal|8
index|]
decl_stmt|;
name|u_char
name|fcbExtent
index|[
literal|3
index|]
decl_stmt|;
name|u_short
name|fcbCurBlockNo
decl_stmt|;
name|u_short
name|fcbRecSize
decl_stmt|;
name|u_long
name|fcbFileSize
decl_stmt|;
name|u_short
name|fcbFileDate
decl_stmt|;
name|u_short
name|fcbFileTime
decl_stmt|;
name|int
name|fcbReserved
decl_stmt|;
name|int
name|fcb_fd
decl_stmt|;
comment|/* hide UNIX FD here */
name|u_char
name|fcbCurRecNo
decl_stmt|;
name|u_long
name|fcbRandomRecNo
decl_stmt|;
block|}
comment|/* __attribute__((__packed__))*/
struct|;
end_struct

begin_comment
comment|/* exports */
end_comment

begin_decl_stmt
name|int
name|diskdrive
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* C: */
end_comment

begin_decl_stmt
name|char
modifier|*
name|InDOS
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* locals */
end_comment

begin_function_decl
specifier|static
name|void
name|fcb_to_string
parameter_list|(
name|struct
name|fcb
modifier|*
parameter_list|,
name|u_char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|ctrl_c_flag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|return_status
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|doserrno
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|memory_strategy
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* first fit (we ignore this) */
end_comment

begin_decl_stmt
specifier|static
name|u_long
name|upcase_vector
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
name|upc_table
index|[
literal|0x80
index|]
init|=
block|{
literal|0x80
block|,
literal|0x9a
block|,
literal|'E'
block|,
literal|'A'
block|,
literal|0x8e
block|,
literal|'A'
block|,
literal|0x8f
block|,
literal|0x80
block|,
literal|'E'
block|,
literal|'E'
block|,
literal|'E'
block|,
literal|'I'
block|,
literal|'I'
block|,
literal|'I'
block|,
literal|0x8e
block|,
literal|0x8f
block|,
literal|0x90
block|,
literal|0x92
block|,
literal|0x92
block|,
literal|'O'
block|,
literal|0x99
block|,
literal|'O'
block|,
literal|'U'
block|,
literal|'U'
block|,
literal|'Y'
block|,
literal|0x99
block|,
literal|0x9a
block|,
literal|0x9b
block|,
literal|0x9c
block|,
literal|0x9d
block|,
literal|0x9e
block|,
literal|0x9f
block|,
literal|'A'
block|,
literal|'I'
block|,
literal|'O'
block|,
literal|'U'
block|,
literal|0xa5
block|,
literal|0xa5
block|,
literal|0xa6
block|,
literal|0xa7
block|,
literal|0xa8
block|,
literal|0xa9
block|,
literal|0xaa
block|,
literal|0xab
block|,
literal|0xac
block|,
literal|0xad
block|,
literal|0xae
block|,
literal|0xaf
block|,
literal|0xb0
block|,
literal|0xb1
block|,
literal|0xb2
block|,
literal|0xb3
block|,
literal|0xb4
block|,
literal|0xb5
block|,
literal|0xb6
block|,
literal|0xb7
block|,
literal|0xb8
block|,
literal|0xb9
block|,
literal|0xba
block|,
literal|0xbb
block|,
literal|0xbc
block|,
literal|0xbd
block|,
literal|0xbe
block|,
literal|0xbf
block|,
literal|0xc0
block|,
literal|0xc1
block|,
literal|0xc2
block|,
literal|0xc3
block|,
literal|0xc4
block|,
literal|0xc5
block|,
literal|0xc6
block|,
literal|0xc7
block|,
literal|0xc8
block|,
literal|0xc9
block|,
literal|0xca
block|,
literal|0xcb
block|,
literal|0xcc
block|,
literal|0xcd
block|,
literal|0xce
block|,
literal|0xcf
block|,
literal|0xd0
block|,
literal|0xd1
block|,
literal|0xd2
block|,
literal|0xd3
block|,
literal|0xd4
block|,
literal|0xd5
block|,
literal|0xd6
block|,
literal|0xd7
block|,
literal|0xd8
block|,
literal|0xd9
block|,
literal|0xda
block|,
literal|0xdb
block|,
literal|0xdc
block|,
literal|0xdd
block|,
literal|0xde
block|,
literal|0xdf
block|,
literal|0xe0
block|,
literal|0xe1
block|,
literal|0xe2
block|,
literal|0xe3
block|,
literal|0xe4
block|,
literal|0xe5
block|,
literal|0xe6
block|,
literal|0xe7
block|,
literal|0xe8
block|,
literal|0xe9
block|,
literal|0xea
block|,
literal|0xeb
block|,
literal|0xec
block|,
literal|0xed
block|,
literal|0xee
block|,
literal|0xef
block|,
literal|0xf0
block|,
literal|0xf1
block|,
literal|0xf2
block|,
literal|0xf3
block|,
literal|0xf4
block|,
literal|0xf5
block|,
literal|0xf6
block|,
literal|0xf7
block|,
literal|0xf8
block|,
literal|0xf9
block|,
literal|0xfa
block|,
literal|0xfb
block|,
literal|0xfc
block|,
literal|0xfd
block|,
literal|0xfe
block|,
literal|0xff
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/****************************************************************************** ** utility functions */
end_comment

begin_function
specifier|static
name|u_char
name|upcase
parameter_list|(
name|u_char
name|c
parameter_list|)
block|{
if|if
condition|(
name|islower
argument_list|(
name|c
argument_list|)
condition|)
return|return
operator|(
name|toupper
argument_list|(
name|c
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
name|c
operator|>=
literal|0x80
condition|)
return|return
operator|(
name|upc_table
index|[
name|c
operator|-
literal|0x80
index|]
operator|)
return|;
else|else
return|return
operator|(
name|c
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|upcase_entry
parameter_list|(
name|regcontext_t
modifier|*
name|REGS
parameter_list|)
block|{
name|R_AL
operator|=
name|upcase
argument_list|(
name|R_AL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** Handle the DOS drive info/free space/etc. calls. */
end_comment

begin_function
specifier|static
name|int
name|int21_free
parameter_list|(
name|regcontext_t
modifier|*
name|REGS
parameter_list|)
block|{
name|fsstat_t
name|fs
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|drive
decl_stmt|;
comment|/* work out drive */
switch|switch
condition|(
name|R_AH
condition|)
block|{
case|case
literal|0x1c
case|:
case|case
literal|0x36
case|:
name|drive
operator|=
name|R_DL
expr_stmt|;
if|if
condition|(
name|drive
condition|)
break|break;
comment|/* FALLTHROUGH */
case|case
literal|0x1b
case|:
name|drive
operator|=
name|diskdrive
expr_stmt|;
break|break;
default|default:
name|fatal
argument_list|(
literal|"int21_free called on unknown function %x\n"
argument_list|,
name|R_AH
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|get_space
argument_list|(
name|drive
argument_list|,
operator|&
name|fs
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|R_AL
operator|=
name|fs
operator|.
name|sectors_cluster
expr_stmt|;
comment|/* sectors per cluster */
name|R_CX
operator|=
name|fs
operator|.
name|bytes_sector
expr_stmt|;
comment|/* bytes per sector */
name|R_DX
operator|=
name|fs
operator|.
name|total_clusters
expr_stmt|;
comment|/* total clusters */
switch|switch
condition|(
name|R_AH
condition|)
block|{
case|case
literal|0x1b
case|:
case|case
literal|0x1c
case|:
name|BIOSDATA
index|[
literal|0xb4
index|]
operator|=
literal|0xf0
expr_stmt|;
comment|/* "reserved" area, "other media" FAT ID */
name|R_DX
operator|=
literal|0x40
expr_stmt|;
comment|/* BIOS data area */
name|R_BX
operator|=
literal|0xb4
expr_stmt|;
break|break;
case|case
literal|0x36
case|:
name|R_BX
operator|=
name|fs
operator|.
name|avail_clusters
expr_stmt|;
comment|/* number of available clusters */
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pack_name
parameter_list|(
name|u_char
modifier|*
name|p
parameter_list|,
name|u_char
modifier|*
name|q
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|8
init|;
name|i
operator|>
literal|0
operator|&&
operator|*
name|p
operator|!=
literal|' '
condition|;
name|i
operator|--
control|)
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|p
operator|+=
name|i
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|' '
condition|)
block|{
operator|*
name|q
operator|++
operator|=
literal|'.'
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|3
init|;
name|i
operator|>
literal|0
operator|&&
operator|*
name|p
operator|!=
literal|' '
condition|;
name|i
operator|--
control|)
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|p
operator|+=
name|i
expr_stmt|;
block|}
operator|*
name|q
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dosdir_to_dta
parameter_list|(
name|dosdir_t
modifier|*
name|dosdir
parameter_list|,
name|find_block_t
modifier|*
name|dta
parameter_list|)
block|{
name|dta
operator|->
name|attr
operator|=
name|dosdir
operator|->
name|attr
expr_stmt|;
name|dta
operator|->
name|time
operator|=
name|dosdir
operator|->
name|time
expr_stmt|;
name|dta
operator|->
name|date
operator|=
name|dosdir
operator|->
name|date
expr_stmt|;
name|dta
operator|->
name|size
operator|=
name|dosdir
operator|->
name|size
expr_stmt|;
name|pack_name
argument_list|(
name|dosdir
operator|->
name|name
argument_list|,
name|dta
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* exported */
end_comment

begin_function
name|void
name|encode_dos_file_time
parameter_list|(
name|time_t
name|t
parameter_list|,
name|u_short
modifier|*
name|dosdatep
parameter_list|,
name|u_short
modifier|*
name|dostimep
parameter_list|)
block|{
name|struct
name|tm
name|tm
decl_stmt|;
name|tm
operator|=
operator|*
name|localtime
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
operator|*
name|dostimep
operator|=
operator|(
name|tm
operator|.
name|tm_hour
operator|<<
literal|11
operator|)
operator||
operator|(
name|tm
operator|.
name|tm_min
operator|<<
literal|5
operator|)
operator||
operator|(
operator|(
name|tm
operator|.
name|tm_sec
operator|/
literal|2
operator|)
operator|<<
literal|0
operator|)
expr_stmt|;
operator|*
name|dosdatep
operator|=
operator|(
operator|(
name|tm
operator|.
name|tm_year
operator|-
literal|80
operator|)
operator|<<
literal|9
operator|)
operator||
operator|(
operator|(
name|tm
operator|.
name|tm_mon
operator|+
literal|1
operator|)
operator|<<
literal|5
operator|)
operator||
operator|(
name|tm
operator|.
name|tm_mday
operator|<<
literal|0
operator|)
expr_stmt|;
block|}
end_function

begin_function
name|time_t
name|decode_dos_file_time
parameter_list|(
name|u_short
name|dosdate
parameter_list|,
name|u_short
name|dostime
parameter_list|)
block|{
name|struct
name|tm
name|tm
decl_stmt|;
name|time_t
name|then
decl_stmt|;
name|tm
operator|.
name|tm_hour
operator|=
operator|(
name|dostime
operator|>>
literal|11
operator|)
operator|&
literal|0x1f
expr_stmt|;
name|tm
operator|.
name|tm_min
operator|=
operator|(
name|dostime
operator|>>
literal|5
operator|)
operator|&
literal|0x3f
expr_stmt|;
name|tm
operator|.
name|tm_sec
operator|=
operator|(
operator|(
name|dostime
operator|>>
literal|0
operator|)
operator|&
literal|0x1f
operator|)
operator|*
literal|2
expr_stmt|;
name|tm
operator|.
name|tm_year
operator|=
operator|(
operator|(
name|dosdate
operator|>>
literal|9
operator|)
operator|&
literal|0x7f
operator|)
operator|+
literal|80
expr_stmt|;
name|tm
operator|.
name|tm_mon
operator|=
operator|(
operator|(
name|dosdate
operator|>>
literal|5
operator|)
operator|&
literal|0x0f
operator|)
operator|-
literal|1
expr_stmt|;
name|tm
operator|.
name|tm_mday
operator|=
operator|(
name|dosdate
operator|>>
literal|0
operator|)
operator|&
literal|0x1f
expr_stmt|;
comment|/* tm_wday and tm_yday are ignored. */
name|tm
operator|.
name|tm_isdst
operator|=
literal|0
expr_stmt|;
comment|/* tm_gmtoff is ignored. */
name|then
operator|=
name|mktime
argument_list|(
operator|&
name|tm
argument_list|)
expr_stmt|;
return|return
operator|(
name|then
operator|)
return|;
block|}
end_function

begin_function
name|int
name|translate_filename
parameter_list|(
name|u_char
modifier|*
name|dname
parameter_list|,
name|u_char
modifier|*
name|uname
parameter_list|,
name|int
modifier|*
name|drivep
parameter_list|)
block|{
name|u_char
name|newpath
index|[
literal|1024
index|]
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|dname
argument_list|,
literal|"con"
argument_list|)
condition|)
block|{
operator|*
name|drivep
operator|=
operator|-
literal|1
expr_stmt|;
name|strcpy
argument_list|(
name|uname
argument_list|,
name|_PATH_TTY
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* XXX KLUDGE for EMS support w/o booting DOS */
comment|/* Really need a better way to handle devices */
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|dname
argument_list|,
literal|"emmxxxx0"
argument_list|)
condition|)
block|{
operator|*
name|drivep
operator|=
operator|-
literal|1
expr_stmt|;
name|strcpy
argument_list|(
name|uname
argument_list|,
name|_PATH_DEVNULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|error
operator|=
name|dos_makepath
argument_list|(
name|dname
argument_list|,
name|newpath
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|dos_to_real_path
argument_list|(
name|newpath
argument_list|,
name|uname
argument_list|,
name|drivep
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|u_char
name|magic
index|[
literal|0x7e
index|]
init|=
block|{
literal|0x06
block|,
literal|0x06
block|,
literal|0x06
block|,
literal|0x06
block|,
literal|0x06
block|,
literal|0x06
block|,
literal|0x06
block|,
literal|0x06
block|,
literal|0x06
block|,
literal|0x00
block|,
literal|0x06
block|,
literal|0x06
block|,
literal|0x06
block|,
literal|0x06
block|,
literal|0x06
block|,
literal|0x06
block|,
literal|0x06
block|,
literal|0x06
block|,
literal|0x06
block|,
literal|0x06
block|,
literal|0x06
block|,
literal|0x06
block|,
literal|0x06
block|,
literal|0x06
block|,
literal|0x06
block|,
literal|0x06
block|,
literal|0x06
block|,
literal|0x06
block|,
literal|0x06
block|,
literal|0x06
block|,
literal|0x06
block|,
literal|0x06
block|,
literal|0x08
block|,
literal|0x0f
block|,
literal|0x06
block|,
literal|0x0f
block|,
literal|0x0f
block|,
literal|0x0f
block|,
literal|0x0f
block|,
literal|0x0f
block|,
literal|0x0f
block|,
literal|0x0f
block|,
literal|0x0f
block|,
literal|0x04
block|,
literal|0x04
block|,
literal|0x0f
block|,
literal|0x0e
block|,
literal|0x06
block|,
literal|0x0f
block|,
literal|0x0f
block|,
literal|0x0f
block|,
literal|0x0f
block|,
literal|0x0f
block|,
literal|0x0f
block|,
literal|0x0f
block|,
literal|0x0f
block|,
literal|0x0f
block|,
literal|0x0f
block|,
literal|0x04
block|,
literal|0x04
block|,
literal|0x04
block|,
literal|0x04
block|,
literal|0x04
block|,
literal|0x0f
block|,
literal|0x0f
block|,
literal|0x0f
block|,
literal|0x0f
block|,
literal|0x0f
block|,
literal|0x0f
block|,
literal|0x0f
block|,
literal|0x0f
block|,
literal|0x0f
block|,
literal|0x0f
block|,
literal|0x0f
block|,
literal|0x0f
block|,
literal|0x0f
block|,
literal|0x0f
block|,
literal|0x0f
block|,
literal|0x0f
block|,
literal|0x0f
block|,
literal|0x0f
block|,
literal|0x0f
block|,
literal|0x0f
block|,
literal|0x0f
block|,
literal|0x0f
block|,
literal|0x0f
block|,
literal|0x0f
block|,
literal|0x0f
block|,
literal|0x0f
block|,
literal|0x0f
block|,
literal|0x0f
block|,
literal|0x06
block|,
literal|0x06
block|,
literal|0x06
block|,
literal|0x0f
block|,
literal|0x0f
block|,
literal|0x0f
block|,
literal|0x0f
block|,
literal|0x0f
block|,
literal|0x0f
block|,
literal|0x0f
block|,
literal|0x0f
block|,
literal|0x0f
block|,
literal|0x0f
block|,
literal|0x0f
block|,
literal|0x0f
block|,
literal|0x0f
block|,
literal|0x0f
block|,
literal|0x0f
block|,
literal|0x0f
block|,
literal|0x0f
block|,
literal|0x0f
block|,
literal|0x0f
block|,
literal|0x0f
block|,
literal|0x0f
block|,
literal|0x0f
block|,
literal|0x0f
block|,
literal|0x0f
block|,
literal|0x0f
block|,
literal|0x0f
block|,
literal|0x0f
block|,
literal|0x0f
block|,
literal|0x0f
block|,
literal|0x0f
block|,
literal|0x04
block|,
literal|0x0f
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|isvalid
parameter_list|(
name|x
parameter_list|)
value|((magic[(int)(x)]& 0x01) != 0)
end_define

begin_define
define|#
directive|define
name|issep
parameter_list|(
name|x
parameter_list|)
value|((magic[(int)(x)]& 0x02) == 0)
end_define

begin_define
define|#
directive|define
name|iswhite
parameter_list|(
name|x
parameter_list|)
value|((magic[(int)(x)]& 0x04) == 0)
end_define

begin_function
specifier|static
name|char
modifier|*
name|skipwhite
parameter_list|(
name|char
modifier|*
name|p
parameter_list|)
block|{
while|while
condition|(
name|iswhite
argument_list|(
operator|*
name|p
argument_list|)
condition|)
operator|++
name|p
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|get_drive_letter
parameter_list|(
name|x
parameter_list|)
value|((x) - 0x40)
end_define

begin_function
name|int
name|parse_filename
parameter_list|(
name|int
name|flag
parameter_list|,
name|char
modifier|*
name|str
parameter_list|,
name|char
modifier|*
name|fcb
parameter_list|,
name|int
modifier|*
name|nb
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|p
operator|=
name|str
expr_stmt|;
name|p
operator|=
name|skipwhite
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag
operator|&
literal|1
condition|)
block|{
if|if
condition|(
name|issep
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
operator|++
name|p
expr_stmt|;
name|p
operator|=
name|skipwhite
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|isvalid
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|':'
condition|)
block|{
operator|*
name|fcb
operator|++
operator|=
name|get_drive_letter
argument_list|(
name|upcase
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flag
operator|&
literal|2
condition|)
block|{
name|fcb
operator|++
expr_stmt|;
block|}
else|else
block|{
operator|*
name|fcb
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* default drive */
block|}
name|i
operator|=
literal|8
expr_stmt|;
if|if
condition|(
name|isvalid
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|!
name|isvalid
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
for|for
control|(
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
operator|*
name|fcb
operator|++
operator|=
literal|' '
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|'*'
case|:
name|ret
operator|=
literal|1
expr_stmt|;
for|for
control|(
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
operator|*
name|fcb
operator|++
operator|=
literal|'?'
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
name|ret
operator|=
literal|1
expr_stmt|;
default|default:
operator|*
name|fcb
operator|++
operator|=
name|upcase
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
name|i
operator|--
expr_stmt|;
break|break;
block|}
block|}
operator|++
name|p
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|flag
operator|&
literal|4
condition|)
block|{
name|fcb
operator|+=
name|i
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
operator|*
name|fcb
operator|++
operator|=
literal|' '
expr_stmt|;
block|}
name|i
operator|=
literal|3
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'.'
condition|)
block|{
operator|++
name|p
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|!
name|isvalid
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
for|for
control|(
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
operator|*
name|fcb
operator|++
operator|=
literal|' '
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|'*'
case|:
name|ret
operator|=
literal|1
expr_stmt|;
for|for
control|(
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
operator|*
name|fcb
operator|++
operator|=
literal|'?'
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
name|ret
operator|=
literal|1
expr_stmt|;
default|default:
operator|*
name|fcb
operator|++
operator|=
name|upcase
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
name|i
operator|--
expr_stmt|;
break|break;
block|}
block|}
operator|++
name|p
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|flag
operator|&
literal|8
condition|)
block|{
name|fcb
operator|+=
name|i
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
operator|*
name|fcb
operator|++
operator|=
literal|' '
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|4
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
operator|*
name|fcb
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* filler */
operator|*
name|nb
operator|=
name|p
operator|-
name|str
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************** ** int21 functions */
end_comment

begin_comment
comment|/* ** 21:00 **  ** terminate */
end_comment

begin_function
specifier|static
name|int
name|int21_00
parameter_list|(
name|regcontext_t
modifier|*
name|REGS
parameter_list|)
block|{
name|done
argument_list|(
name|REGS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* keep `gcc -Wall' happy */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** 21:01 ** ** read character with echo */
end_comment

begin_function
specifier|static
name|int
name|int21_01
parameter_list|(
name|regcontext_t
modifier|*
name|REGS
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|tty_read
argument_list|(
operator|(
name|regcontext_t
operator|*
operator|)
operator|&
name|REGS
operator|->
name|sc
argument_list|,
name|TTYF_BLOCKALL
argument_list|)
operator|)
operator|>=
literal|0
condition|)
name|R_AL
operator|=
name|n
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** 21:02 ** ** write char to stdout */
end_comment

begin_function
specifier|static
name|int
name|int21_02
parameter_list|(
name|regcontext_t
modifier|*
name|REGS
parameter_list|)
block|{
name|tty_write
argument_list|(
name|R_DL
argument_list|,
name|TTYF_REDIRECT
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** 21:06 ** ** direct console I/O ** ** (dl) is output char unless 0xff, when we read instead */
end_comment

begin_function
specifier|static
name|int
name|int21_06
parameter_list|(
name|regcontext_t
modifier|*
name|REGS
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
comment|/* XXX - should be able to read a file */
if|if
condition|(
name|R_DL
operator|==
literal|0xff
condition|)
block|{
name|n
operator|=
name|tty_read
argument_list|(
operator|(
name|regcontext_t
operator|*
operator|)
operator|&
name|REGS
operator|->
name|sc
argument_list|,
name|TTYF_ECHO
operator||
name|TTYF_REDIRECT
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|R_FLAGS
operator||=
name|PSL_Z
expr_stmt|;
comment|/* nothing available */
name|R_AL
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|R_AL
operator|=
name|n
expr_stmt|;
comment|/* got character */
name|R_FLAGS
operator|&=
operator|~
name|PSL_Z
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* write and return char in %al */
name|tty_write
argument_list|(
name|R_DL
argument_list|,
name|TTYF_REDIRECT
argument_list|)
expr_stmt|;
name|R_AL
operator|=
name|R_DL
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** 21:07 ** ** direct console input with no echo */
end_comment

begin_function
specifier|static
name|int
name|int21_07
parameter_list|(
name|regcontext_t
modifier|*
name|REGS
parameter_list|)
block|{
name|R_AL
operator|=
name|tty_read
argument_list|(
operator|(
name|regcontext_t
operator|*
operator|)
operator|&
name|REGS
operator|->
name|sc
argument_list|,
name|TTYF_BLOCK
operator||
name|TTYF_REDIRECT
argument_list|)
operator|&
literal|0xff
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** 21:08 ** ** character input with no echo */
end_comment

begin_function
specifier|static
name|int
name|int21_08
parameter_list|(
name|regcontext_t
modifier|*
name|REGS
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|tty_read
argument_list|(
operator|(
name|regcontext_t
operator|*
operator|)
operator|&
name|REGS
operator|->
name|sc
argument_list|,
name|TTYF_BLOCK
operator||
name|TTYF_CTRL
operator||
name|TTYF_REDIRECT
argument_list|)
operator|)
operator|>=
literal|0
condition|)
name|R_AL
operator|=
name|n
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** 21:09 ** ** write string to standard out. ** ** We're a little paranoid here; if the string is very long, truncate it. */
end_comment

begin_function
specifier|static
name|int
name|int21_09
parameter_list|(
name|regcontext_t
modifier|*
name|REGS
parameter_list|)
block|{
name|char
modifier|*
name|addr
decl_stmt|;
name|int
name|len
decl_stmt|;
comment|/* pointer to string */
name|addr
operator|=
operator|(
name|char
operator|*
operator|)
name|MAKEPTR
argument_list|(
name|R_DS
argument_list|,
name|R_DX
argument_list|)
expr_stmt|;
comment|/* walk string looking for terminator or overlength */
for|for
control|(
name|len
operator|=
literal|0
init|;
name|len
operator|<
literal|10000
condition|;
name|len
operator|++
operator|,
name|addr
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|addr
operator|==
literal|'$'
condition|)
break|break;
name|tty_write
argument_list|(
operator|*
name|addr
argument_list|,
name|TTYF_REDIRECT
argument_list|)
expr_stmt|;
block|}
name|R_AL
operator|=
literal|0x24
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** 21:0a ** ** buffered input */
end_comment

begin_function
specifier|static
name|int
name|int21_0a
parameter_list|(
name|regcontext_t
modifier|*
name|REGS
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|addr
decl_stmt|;
name|int
name|nbytes
decl_stmt|,
name|avail
decl_stmt|;
name|int
name|n
decl_stmt|;
comment|/* pointer to buffer */
name|addr
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|MAKEPTR
argument_list|(
name|R_DS
argument_list|,
name|R_DX
argument_list|)
expr_stmt|;
comment|/* capacity of buffer */
name|avail
operator|=
name|addr
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|avail
operator|==
literal|0
condition|)
comment|/* no space */
return|return
operator|(
literal|0
operator|)
return|;
name|nbytes
operator|=
literal|0
expr_stmt|;
comment|/* read nothing yet */
comment|/* read loop */
while|while
condition|(
literal|1
condition|)
block|{
name|n
operator|=
name|tty_read
argument_list|(
operator|(
name|regcontext_t
operator|*
operator|)
operator|&
name|REGS
operator|->
name|sc
argument_list|,
name|TTYF_BLOCK
operator||
name|TTYF_CTRL
operator||
name|TTYF_REDIRECT
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
comment|/* end of input */
name|n
operator|=
literal|'\r'
expr_stmt|;
comment|/* make like CR */
switch|switch
condition|(
name|n
condition|)
block|{
case|case
literal|'\r'
case|:
comment|/* done */
name|addr
index|[
literal|1
index|]
operator|=
name|nbytes
expr_stmt|;
name|addr
index|[
name|nbytes
operator|+
literal|2
index|]
operator|=
literal|'\r'
expr_stmt|;
name|addr
index|[
name|nbytes
operator|+
literal|3
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* XXX is this necessary? */
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|'\n'
case|:
comment|/* ignore */
case|case
literal|'\0'
case|:
break|break;
case|case
literal|'\b'
case|:
comment|/* backspace */
if|if
condition|(
name|nbytes
operator|>
literal|0
condition|)
block|{
operator|--
name|nbytes
expr_stmt|;
name|tty_write
argument_list|(
literal|'\b'
argument_list|,
name|TTYF_REDIRECT
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
index|[
name|nbytes
operator|+
literal|2
index|]
operator|<
literal|' '
condition|)
name|tty_write
argument_list|(
literal|'\b'
argument_list|,
name|TTYF_REDIRECT
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
if|if
condition|(
name|nbytes
operator|>=
operator|(
name|avail
operator|-
literal|2
operator|)
condition|)
block|{
comment|/* buffer full */
name|tty_write
argument_list|(
literal|'\007'
argument_list|,
name|TTYF_REDIRECT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* add to end */
name|addr
index|[
operator|(
name|nbytes
operator|++
operator|)
operator|+
literal|2
index|]
operator|=
name|n
expr_stmt|;
if|if
condition|(
name|n
operator|!=
literal|'\t'
operator|&&
name|n
operator|<
literal|' '
condition|)
block|{
name|tty_write
argument_list|(
literal|'^'
argument_list|,
name|TTYF_REDIRECT
argument_list|)
expr_stmt|;
name|tty_write
argument_list|(
name|n
operator|+
literal|'@'
argument_list|,
name|TTYF_REDIRECT
argument_list|)
expr_stmt|;
block|}
else|else
name|tty_write
argument_list|(
name|n
argument_list|,
name|TTYF_REDIRECT
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* ** 21:0b ** ** get stdin status ** ** This is a favorite for camping on, so we do some poll-counting ** here as well. */
end_comment

begin_function
specifier|static
name|int
name|int21_0b
parameter_list|(
name|regcontext_t
modifier|*
name|REGS
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
comment|/* XXX this is pretty bogus, actually */
if|if
condition|(
operator|!
name|xmode
condition|)
block|{
name|R_AL
operator|=
literal|0xff
expr_stmt|;
comment|/* no X mode, always claim data available */
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* XXX tty_peek is broken */
name|n
operator|=
name|tty_peek
argument_list|(
name|REGS
argument_list|,
name|poll_cnt
condition|?
literal|0
else|:
name|TTYF_POLL
argument_list|)
condition|?
literal|0xff
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
comment|/* control-break */
return|return
operator|(
literal|0
operator|)
return|;
name|R_AL
operator|=
name|n
expr_stmt|;
comment|/* will be 0 or 0xff */
if|if
condition|(
name|poll_cnt
condition|)
operator|--
name|poll_cnt
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** 21:0c ** ** flush stdin and read using other function */
end_comment

begin_function
specifier|static
name|int
name|int21_0c
parameter_list|(
name|regcontext_t
modifier|*
name|REGS
parameter_list|)
block|{
if|if
condition|(
name|xmode
condition|)
comment|/* XXX should always flush! */
name|tty_flush
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|R_AL
condition|)
block|{
comment|/* which subfunction? */
case|case
literal|0x01
case|:
return|return
operator|(
name|int21_01
argument_list|(
name|REGS
argument_list|)
operator|)
return|;
case|case
literal|0x06
case|:
return|return
operator|(
name|int21_06
argument_list|(
name|REGS
argument_list|)
operator|)
return|;
case|case
literal|0x07
case|:
return|return
operator|(
name|int21_07
argument_list|(
name|REGS
argument_list|)
operator|)
return|;
case|case
literal|0x08
case|:
return|return
operator|(
name|int21_08
argument_list|(
name|REGS
argument_list|)
operator|)
return|;
case|case
literal|0x0a
case|:
return|return
operator|(
name|int21_0a
argument_list|(
name|REGS
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** 21:0e ** ** select default drive */
end_comment

begin_function
specifier|static
name|int
name|int21_0e
parameter_list|(
name|regcontext_t
modifier|*
name|REGS
parameter_list|)
block|{
name|diskdrive
operator|=
name|R_DL
expr_stmt|;
comment|/* XXX rangecheck? */
name|R_AL
operator|=
name|ndisks
operator|+
literal|2
expr_stmt|;
comment|/* report actual limit */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** 21:19 ** ** get default drive */
end_comment

begin_function
specifier|static
name|int
name|int21_19
parameter_list|(
name|regcontext_t
modifier|*
name|REGS
parameter_list|)
block|{
name|R_AL
operator|=
name|diskdrive
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** 21:1a ** ** set DTA */
end_comment

begin_function
specifier|static
name|int
name|int21_1a
parameter_list|(
name|regcontext_t
modifier|*
name|REGS
parameter_list|)
block|{
name|debug
argument_list|(
name|D_FILE_OPS
argument_list|,
literal|"set dta to %x:%x\n"
argument_list|,
name|R_DS
argument_list|,
name|R_DX
argument_list|)
expr_stmt|;
name|disk_transfer_addr
operator|=
name|MAKEVEC
argument_list|(
name|R_DS
argument_list|,
name|R_DX
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** 21:23 ** ** Get file size for fcb ** DS:DX -> unopened FCB, no wildcards. ** pcb random record field filled in with number of records, rounded up. */
end_comment

begin_function
specifier|static
name|int
name|int21_23
parameter_list|(
name|regcontext_t
modifier|*
name|REGS
parameter_list|)
block|{
name|debug
argument_list|(
name|D_HALF
argument_list|,
literal|"Returning failure from get file size for fcb 21:23\n"
argument_list|)
expr_stmt|;
name|R_AL
operator|=
literal|0xff
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** 21:25 ** ** set interrupt vector */
end_comment

begin_function
specifier|static
name|int
name|int21_25
parameter_list|(
name|regcontext_t
modifier|*
name|REGS
parameter_list|)
block|{
name|debug
argument_list|(
name|D_MEMORY
argument_list|,
literal|"%02x -> %04x:%04x\n"
argument_list|,
name|R_AL
argument_list|,
name|R_DS
argument_list|,
name|R_DX
argument_list|)
expr_stmt|;
name|ivec
index|[
name|R_AL
index|]
operator|=
name|MAKEVEC
argument_list|(
name|R_DS
argument_list|,
name|R_DX
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** 21:26 ** ** Create PSP */
end_comment

begin_function
specifier|static
name|int
name|int21_26
parameter_list|(
name|regcontext_t
modifier|*
name|REGS
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|addr
decl_stmt|;
comment|/* address of new PSP */
name|addr
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|MAKEPTR
argument_list|(
name|R_DX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* copy this process' PSP - XXX needs some work 8( */
name|memcpy
argument_list|(
name|addr
argument_list|,
name|dosmem
argument_list|,
literal|256
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** 21:2a ** ** Get date */
end_comment

begin_function
specifier|static
name|int
name|int21_2a
parameter_list|(
name|regcontext_t
modifier|*
name|REGS
parameter_list|)
block|{
name|struct
name|timeval
name|tv
decl_stmt|;
name|struct
name|timezone
name|tz
decl_stmt|;
name|struct
name|tm
name|tm
decl_stmt|;
name|time_t
name|now
decl_stmt|;
name|gettimeofday
argument_list|(
operator|&
name|tv
argument_list|,
operator|&
name|tz
argument_list|)
expr_stmt|;
comment|/* get time and apply DOS offset */
name|now
operator|=
name|tv
operator|.
name|tv_sec
operator|+
name|delta_clock
expr_stmt|;
name|tm
operator|=
operator|*
name|localtime
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
comment|/* deconstruct and timezoneify */
name|R_CX
operator|=
name|tm
operator|.
name|tm_year
operator|+
literal|1900
expr_stmt|;
name|R_DH
operator|=
name|tm
operator|.
name|tm_mon
operator|+
literal|1
expr_stmt|;
name|R_DL
operator|=
name|tm
operator|.
name|tm_mday
expr_stmt|;
name|R_AL
operator|=
name|tm
operator|.
name|tm_wday
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** 21:2b ** ** set date */
end_comment

begin_function
specifier|static
name|int
name|int21_2b
parameter_list|(
name|regcontext_t
modifier|*
name|REGS
parameter_list|)
block|{
name|struct
name|timeval
name|tv
decl_stmt|;
name|struct
name|timezone
name|tz
decl_stmt|;
name|struct
name|tm
name|tm
decl_stmt|;
name|time_t
name|now
decl_stmt|;
name|gettimeofday
argument_list|(
operator|&
name|tv
argument_list|,
operator|&
name|tz
argument_list|)
expr_stmt|;
comment|/* get time and apply DOS offset */
name|now
operator|=
name|tv
operator|.
name|tv_sec
operator|+
name|delta_clock
expr_stmt|;
name|tm
operator|=
operator|*
name|localtime
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|tm
operator|.
name|tm_year
operator|=
name|R_CX
operator|-
literal|1900
expr_stmt|;
name|tm
operator|.
name|tm_mon
operator|=
name|R_DH
operator|-
literal|1
expr_stmt|;
name|tm
operator|.
name|tm_mday
operator|=
name|R_DL
expr_stmt|;
name|tm
operator|.
name|tm_wday
operator|=
name|R_AL
expr_stmt|;
name|now
operator|=
name|mktime
argument_list|(
operator|&
name|tm
argument_list|)
expr_stmt|;
if|if
condition|(
name|now
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|DATA_INVALID
operator|)
return|;
name|delta_clock
operator|=
name|now
operator|-
name|tv
operator|.
name|tv_sec
expr_stmt|;
comment|/* compute new offset? */
name|R_AL
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** 21:2c ** ** Get time */
end_comment

begin_function
specifier|static
name|int
name|int21_2c
parameter_list|(
name|regcontext_t
modifier|*
name|REGS
parameter_list|)
block|{
name|struct
name|timeval
name|tv
decl_stmt|;
name|struct
name|timezone
name|tz
decl_stmt|;
name|struct
name|tm
name|tm
decl_stmt|;
name|time_t
name|now
decl_stmt|;
name|gettimeofday
argument_list|(
operator|&
name|tv
argument_list|,
operator|&
name|tz
argument_list|)
expr_stmt|;
name|now
operator|=
name|tv
operator|.
name|tv_sec
operator|+
name|delta_clock
expr_stmt|;
name|tm
operator|=
operator|*
name|localtime
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|R_CH
operator|=
name|tm
operator|.
name|tm_hour
expr_stmt|;
name|R_CL
operator|=
name|tm
operator|.
name|tm_min
expr_stmt|;
name|R_DH
operator|=
name|tm
operator|.
name|tm_sec
expr_stmt|;
name|R_DL
operator|=
name|tv
operator|.
name|tv_usec
operator|/
literal|10000
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** 21:2d ** ** Set time */
end_comment

begin_function
specifier|static
name|int
name|int21_2d
parameter_list|(
name|regcontext_t
modifier|*
name|REGS
parameter_list|)
block|{
name|struct
name|timeval
name|tv
decl_stmt|;
name|struct
name|timezone
name|tz
decl_stmt|;
name|struct
name|tm
name|tm
decl_stmt|;
name|time_t
name|now
decl_stmt|;
name|gettimeofday
argument_list|(
operator|&
name|tv
argument_list|,
operator|&
name|tz
argument_list|)
expr_stmt|;
name|now
operator|=
name|tv
operator|.
name|tv_sec
operator|+
name|delta_clock
expr_stmt|;
name|tm
operator|=
operator|*
name|localtime
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|tm
operator|.
name|tm_hour
operator|=
name|R_CH
expr_stmt|;
name|tm
operator|.
name|tm_min
operator|=
name|R_CL
expr_stmt|;
name|tm
operator|.
name|tm_sec
operator|=
name|R_DH
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
name|R_DL
operator|*
literal|10000
expr_stmt|;
name|now
operator|=
name|mktime
argument_list|(
operator|&
name|tm
argument_list|)
expr_stmt|;
if|if
condition|(
name|now
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|DATA_INVALID
operator|)
return|;
name|delta_clock
operator|=
name|now
operator|-
name|tv
operator|.
name|tv_sec
expr_stmt|;
name|R_AL
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** 21:2f ** ** get DTA */
end_comment

begin_function
specifier|static
name|int
name|int21_2f
parameter_list|(
name|regcontext_t
modifier|*
name|REGS
parameter_list|)
block|{
name|PUTVEC
argument_list|(
name|R_ES
argument_list|,
name|R_BX
argument_list|,
name|disk_transfer_addr
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|D_FILE_OPS
argument_list|,
literal|"get dta at %x:%x\n"
argument_list|,
name|R_ES
argument_list|,
name|R_BX
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** 21:30 ** ** get DOS version number. ** ** XXX begging for a rewrite */
end_comment

begin_function
specifier|static
name|int
name|int21_30
parameter_list|(
name|regcontext_t
modifier|*
name|REGS
parameter_list|)
block|{
name|int
name|v
decl_stmt|;
name|char
modifier|*
name|cmd
init|=
operator|(
name|char
operator|*
operator|)
name|MAKEPTR
argument_list|(
name|get_env
argument_list|()
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/*       * retch.  I think this skips the environment and looks for the name      * of the current command.      */
do|do
block|{
while|while
condition|(
operator|*
name|cmd
condition|)
operator|++
name|cmd
expr_stmt|;
block|}
do|while
condition|(
operator|*
operator|++
name|cmd
condition|)
do|;
operator|++
name|cmd
expr_stmt|;
name|cmd
operator|+=
operator|*
operator|(
name|short
operator|*
operator|)
name|cmd
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|cmd
index|[
operator|-
literal|1
index|]
operator|&&
name|cmd
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\\'
operator|&&
name|cmd
index|[
operator|-
literal|1
index|]
operator|!=
literal|':'
condition|)
operator|--
name|cmd
expr_stmt|;
comment|/* get the version we're pretending to be for this sucker */
name|v
operator|=
name|getver
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|R_AL
operator|=
operator|(
name|v
operator|/
literal|100
operator|)
operator|&
literal|0xff
expr_stmt|;
name|R_AH
operator|=
name|v
operator|%
literal|100
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** 21:33:05 ** ** Get boot drive */
end_comment

begin_function
specifier|static
name|int
name|int21_33_5
parameter_list|(
name|regcontext_t
modifier|*
name|REGS
parameter_list|)
block|{
name|R_DL
operator|=
literal|3
expr_stmt|;
comment|/* always booted from C */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** 21:33:06 ** ** get true DOS version */
end_comment

begin_function
specifier|static
name|int
name|int21_33_6
parameter_list|(
name|regcontext_t
modifier|*
name|REGS
parameter_list|)
block|{
name|int
name|v
decl_stmt|;
name|v
operator|=
name|getver
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|R_BL
operator|=
operator|(
name|v
operator|/
literal|100
operator|)
operator|&
literal|0xff
expr_stmt|;
name|R_BH
operator|=
name|v
operator|%
literal|100
expr_stmt|;
name|R_DH
operator|=
literal|0
expr_stmt|;
name|R_DL
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** 21:33 ** ** extended break checking */
end_comment

begin_function
specifier|static
name|int
name|int21_33
parameter_list|(
name|regcontext_t
modifier|*
name|REGS
parameter_list|)
block|{
name|int
name|ftemp
decl_stmt|;
switch|switch
condition|(
name|R_AL
condition|)
block|{
case|case
literal|0x00
case|:
name|R_DL
operator|=
name|ctrl_c_flag
expr_stmt|;
break|break;
case|case
literal|0x01
case|:
name|ctrl_c_flag
operator|=
name|R_DL
expr_stmt|;
break|break;
case|case
literal|0x02
case|:
name|ftemp
operator|=
name|ctrl_c_flag
expr_stmt|;
name|ctrl_c_flag
operator|=
name|R_DL
expr_stmt|;
name|R_DL
operator|=
name|ftemp
expr_stmt|;
break|break;
default|default:
name|unknown_int3
argument_list|(
literal|0x21
argument_list|,
literal|0x33
argument_list|,
name|R_AL
argument_list|,
name|REGS
argument_list|)
expr_stmt|;
return|return
operator|(
name|FUNC_NUM_IVALID
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** 21:34 ** ** Get address of InDos flag ** ** XXX check interrupt list WRT location of critical error flag too. */
end_comment

begin_function
specifier|static
name|int
name|int21_34
parameter_list|(
name|regcontext_t
modifier|*
name|REGS
parameter_list|)
block|{
name|PUTVEC
argument_list|(
name|R_ES
argument_list|,
name|R_BX
argument_list|,
operator|(
name|u_long
operator|)
name|InDOS
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** 21:35 ** ** get interrupt vector */
end_comment

begin_function
specifier|static
name|int
name|int21_35
parameter_list|(
name|regcontext_t
modifier|*
name|REGS
parameter_list|)
block|{
name|PUTVEC
argument_list|(
name|R_ES
argument_list|,
name|R_BX
argument_list|,
name|ivec
index|[
name|R_AL
index|]
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|D_MEMORY
argument_list|,
literal|"%02x<- %04x:%04x\n"
argument_list|,
name|R_AL
argument_list|,
name|R_ES
argument_list|,
name|R_BX
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** 21:37 ** ** switch character manipulation ** */
end_comment

begin_function
specifier|static
name|int
name|int21_37
parameter_list|(
name|regcontext_t
modifier|*
name|REGS
parameter_list|)
block|{
switch|switch
condition|(
name|R_AL
condition|)
block|{
case|case
literal|0
case|:
comment|/* get switch character */
name|R_DL
operator|=
literal|'/'
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* set switch character (normally /) */
comment|/* ignored by most versions of DOS */
break|break;
default|default:
name|unknown_int3
argument_list|(
literal|0x21
argument_list|,
literal|0x37
argument_list|,
name|R_AL
argument_list|,
name|REGS
argument_list|)
expr_stmt|;
return|return
operator|(
name|FUNC_NUM_IVALID
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** 21:38 ** ** country code information ** ** XXX internat guru? */
end_comment

begin_function
specifier|static
name|int
name|int21_38
parameter_list|(
name|regcontext_t
modifier|*
name|REGS
parameter_list|)
block|{
name|char
modifier|*
name|addr
decl_stmt|;
if|if
condition|(
name|R_DX
operator|==
literal|0xffff
condition|)
block|{
name|debug
argument_list|(
name|D_HALF
argument_list|,
literal|"warning: set country code ignored"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|addr
operator|=
operator|(
name|char
operator|*
operator|)
name|MAKEPTR
argument_list|(
name|R_DS
argument_list|,
name|R_DX
argument_list|)
expr_stmt|;
name|PUTVEC
argument_list|(
name|countryinfo
operator|.
name|ciCaseMapSegment
argument_list|,
name|countryinfo
operator|.
name|ciCaseMapOffset
argument_list|,
name|upcase_vector
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|addr
argument_list|,
operator|&
name|countryinfo
argument_list|,
sizeof|sizeof
argument_list|(
name|countryinfo
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** 21:39 ** 21:3a ** 21:41 ** 21:56 ** ** mkdir, rmdir, unlink, rename */
end_comment

begin_function
specifier|static
name|int
name|int21_dirfn
parameter_list|(
name|regcontext_t
modifier|*
name|REGS
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|char
name|fname
index|[
name|PATH_MAX
index|]
decl_stmt|,
name|tname
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|int
name|drive
decl_stmt|;
name|error
operator|=
name|translate_filename
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|MAKEPTR
argument_list|(
name|R_DS
argument_list|,
name|R_DX
argument_list|)
argument_list|,
name|fname
argument_list|,
operator|&
name|drive
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|dos_readonly
argument_list|(
name|drive
argument_list|)
condition|)
return|return
operator|(
name|WRITE_PROT_DISK
operator|)
return|;
switch|switch
condition|(
name|R_AH
condition|)
block|{
case|case
literal|0x39
case|:
name|debug
argument_list|(
name|D_FILE_OPS
argument_list|,
literal|"mkdir(%s)\n"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|error
operator|=
name|mkdir
argument_list|(
name|fname
argument_list|,
literal|0777
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x3a
case|:
name|debug
argument_list|(
name|D_FILE_OPS
argument_list|,
literal|"rmdir(%s)\n"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|error
operator|=
name|rmdir
argument_list|(
name|fname
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x41
case|:
name|debug
argument_list|(
name|D_FILE_OPS
argument_list|,
literal|"unlink(%s)\n"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|error
operator|=
name|unlink
argument_list|(
name|fname
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x56
case|:
comment|/* rename - some extra work */
name|error
operator|=
name|translate_filename
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|MAKEPTR
argument_list|(
name|R_ES
argument_list|,
name|R_DI
argument_list|)
argument_list|,
name|tname
argument_list|,
operator|&
name|drive
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|debug
argument_list|(
name|D_FILE_OPS
argument_list|,
literal|"rename(%s, %s)\n"
argument_list|,
name|fname
argument_list|,
name|tname
argument_list|)
expr_stmt|;
name|error
operator|=
name|rename
argument_list|(
name|fname
argument_list|,
name|tname
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fatal
argument_list|(
literal|"call to int21_dirfn for unknown function %x\n"
argument_list|,
name|R_AH
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|<
literal|0
condition|)
block|{
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|ENOTDIR
case|:
case|case
name|ENOENT
case|:
return|return
operator|(
name|PATH_NOT_FOUND
operator|)
return|;
case|case
name|EXDEV
case|:
return|return
operator|(
name|NOT_SAME_DEV
operator|)
return|;
default|default:
return|return
operator|(
name|ACCESS_DENIED
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** 21:3b ** ** chdir */
end_comment

begin_function
specifier|static
name|int
name|int21_3b
parameter_list|(
name|regcontext_t
modifier|*
name|REGS
parameter_list|)
block|{
name|debug
argument_list|(
name|D_FILE_OPS
argument_list|,
literal|"chdir(%s)\n"
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|MAKEPTR
argument_list|(
name|R_DS
argument_list|,
name|R_DX
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|dos_setcwd
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|MAKEPTR
argument_list|(
name|R_DS
argument_list|,
name|R_DX
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** 21:3c ** 21:5b ** 21:6c ** ** open, creat, creat new, multipurpose creat */
end_comment

begin_function
specifier|static
name|int
name|int21_open
parameter_list|(
name|regcontext_t
modifier|*
name|REGS
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|char
name|fname
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|struct
name|stat
name|sb
decl_stmt|;
name|int
name|mode
decl_stmt|,
name|action
decl_stmt|,
name|status
decl_stmt|;
name|char
modifier|*
name|pname
decl_stmt|;
name|int
name|drive
decl_stmt|;
name|int
name|fd
decl_stmt|;
switch|switch
condition|(
name|R_AH
condition|)
block|{
case|case
literal|0x3c
case|:
comment|/* creat */
name|pname
operator|=
operator|(
name|char
operator|*
operator|)
name|MAKEPTR
argument_list|(
name|R_DS
argument_list|,
name|R_DX
argument_list|)
expr_stmt|;
name|action
operator|=
literal|0x12
expr_stmt|;
comment|/* create/truncate regardless */
name|mode
operator|=
name|O_RDWR
expr_stmt|;
name|debug
argument_list|(
name|D_FILE_OPS
argument_list|,
literal|"creat"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x3d
case|:
comment|/* open */
name|pname
operator|=
operator|(
name|char
operator|*
operator|)
name|MAKEPTR
argument_list|(
name|R_DS
argument_list|,
name|R_DX
argument_list|)
expr_stmt|;
name|action
operator|=
literal|0x01
expr_stmt|;
comment|/* fail if not exist, open if exists */
switch|switch
condition|(
name|R_AL
operator|&
literal|3
condition|)
block|{
case|case
literal|0
case|:
name|mode
operator|=
name|O_RDONLY
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|mode
operator|=
name|O_WRONLY
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|mode
operator|=
name|O_RDWR
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|FUNC_NUM_IVALID
operator|)
return|;
block|}
name|debug
argument_list|(
name|D_FILE_OPS
argument_list|,
literal|"open"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x5b
case|:
comment|/* creat new */
name|pname
operator|=
operator|(
name|char
operator|*
operator|)
name|MAKEPTR
argument_list|(
name|R_DS
argument_list|,
name|R_DL
argument_list|)
expr_stmt|;
name|action
operator|=
literal|0x10
expr_stmt|;
comment|/* create if not exist, fail if exists */
name|mode
operator|=
name|O_RDWR
expr_stmt|;
name|debug
argument_list|(
name|D_FILE_OPS
argument_list|,
literal|"creat_new"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x6c
case|:
comment|/* multipurpose */
name|pname
operator|=
operator|(
name|char
operator|*
operator|)
name|MAKEPTR
argument_list|(
name|R_DS
argument_list|,
name|R_SI
argument_list|)
expr_stmt|;
name|action
operator|=
name|R_DX
expr_stmt|;
switch|switch
condition|(
name|R_BL
operator|&
literal|3
condition|)
block|{
case|case
literal|0
case|:
name|mode
operator|=
name|O_RDONLY
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|mode
operator|=
name|O_WRONLY
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|mode
operator|=
name|O_RDWR
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|FUNC_NUM_IVALID
operator|)
return|;
block|}
name|debug
argument_list|(
name|D_FILE_OPS
argument_list|,
literal|"mopen"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fatal
argument_list|(
literal|"called int21_creat for unknown function %x\n"
argument_list|,
name|R_AH
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|action
operator|&
literal|0x02
condition|)
comment|/* replace/open mode */
name|mode
operator||=
name|O_TRUNC
expr_stmt|;
comment|/* consider proposed name */
name|error
operator|=
name|translate_filename
argument_list|(
name|pname
argument_list|,
name|fname
argument_list|,
operator|&
name|drive
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|debug
argument_list|(
name|D_FILE_OPS
argument_list|,
literal|"(%s)\n"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|dos_readonly
argument_list|(
name|drive
argument_list|)
operator|&&
operator|(
name|mode
operator|!=
name|O_RDONLY
operator|)
condition|)
return|return
operator|(
name|WRITE_PROT_DISK
operator|)
return|;
if|if
condition|(
name|ustat
argument_list|(
name|fname
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* file does not exist */
if|if
condition|(
name|action
operator|&
literal|0x10
condition|)
block|{
comment|/* create? */
name|sb
operator|.
name|st_ino
operator|=
literal|0
expr_stmt|;
name|mode
operator||=
name|O_CREAT
expr_stmt|;
comment|/* have to create as we go */
name|status
operator|=
literal|0x02
expr_stmt|;
comment|/* file created */
block|}
else|else
block|{
return|return
operator|(
name|FILE_NOT_FOUND
operator|)
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|S_ISDIR
argument_list|(
name|sb
operator|.
name|st_mode
argument_list|)
condition|)
return|return
operator|(
name|ACCESS_DENIED
operator|)
return|;
if|if
condition|(
name|action
operator|&
literal|0x03
condition|)
block|{
comment|/* exists, work with it */
if|if
condition|(
name|action
operator|&
literal|0x02
condition|)
block|{
if|if
condition|(
operator|!
name|S_ISREG
argument_list|(
name|sb
operator|.
name|st_mode
argument_list|)
condition|)
block|{
comment|/* only allowed for files */
name|debug
argument_list|(
name|D_FILE_OPS
argument_list|,
literal|"attempt to truncate non-regular file\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ACCESS_DENIED
operator|)
return|;
block|}
name|status
operator|=
literal|0x03
expr_stmt|;
comment|/* we're going to truncate it */
block|}
else|else
block|{
name|status
operator|=
literal|0x01
expr_stmt|;
comment|/* just open it */
block|}
block|}
else|else
block|{
return|return
operator|(
name|FILE_ALREADY_EXISTS
operator|)
return|;
comment|/* exists, fail */
block|}
block|}
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|fname
argument_list|,
name|mode
argument_list|,
name|from_dos_attr
argument_list|(
name|R_CX
argument_list|)
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|debug
argument_list|(
name|D_FILE_OPS
argument_list|,
literal|"failed to open %s : %s\n"
argument_list|,
name|fname
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ACCESS_DENIED
operator|)
return|;
block|}
if|if
condition|(
name|R_AH
operator|==
literal|0x6c
condition|)
comment|/* need to return status too */
name|R_CX
operator|=
name|status
expr_stmt|;
name|R_AX
operator|=
name|fd
expr_stmt|;
comment|/* return fd */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** 21:3e ** ** close */
end_comment

begin_function
specifier|static
name|int
name|int21_3e
parameter_list|(
name|regcontext_t
modifier|*
name|REGS
parameter_list|)
block|{
name|debug
argument_list|(
name|D_FILE_OPS
argument_list|,
literal|"close(%d)\n"
argument_list|,
name|R_BX
argument_list|)
expr_stmt|;
if|if
condition|(
name|R_BX
operator|==
name|fileno
argument_list|(
name|debugf
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"attempt to close debugging fd\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|HANDLE_INVALID
operator|)
return|;
block|}
if|if
condition|(
name|close
argument_list|(
name|R_BX
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|HANDLE_INVALID
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** 21:3f ** ** read */
end_comment

begin_function
specifier|static
name|int
name|int21_3f
parameter_list|(
name|regcontext_t
modifier|*
name|REGS
parameter_list|)
block|{
name|char
modifier|*
name|addr
decl_stmt|;
name|int
name|n
decl_stmt|;
name|int
name|avail
decl_stmt|;
name|addr
operator|=
operator|(
name|char
operator|*
operator|)
name|MAKEPTR
argument_list|(
name|R_DS
argument_list|,
name|R_DX
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|D_FILE_OPS
argument_list|,
literal|"read(%d, %d)\n"
argument_list|,
name|R_BX
argument_list|,
name|R_CX
argument_list|)
expr_stmt|;
if|if
condition|(
name|R_BX
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|redirect0
condition|)
block|{
name|n
operator|=
name|read
argument_list|(
name|R_BX
argument_list|,
name|addr
argument_list|,
name|R_CX
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|n
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|n
operator|<
name|R_CX
condition|)
block|{
name|avail
operator|=
name|tty_read
argument_list|(
name|REGS
argument_list|,
name|TTYF_BLOCK
operator||
name|TTYF_CTRL
operator||
name|TTYF_ECHONL
argument_list|)
expr_stmt|;
if|if
condition|(
name|avail
operator|<
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|(
name|addr
index|[
name|n
operator|++
index|]
operator|=
name|avail
operator|)
operator|==
literal|'\r'
condition|)
break|break;
block|}
block|}
block|}
else|else
block|{
name|n
operator|=
name|read
argument_list|(
name|R_BX
argument_list|,
name|addr
argument_list|,
name|R_CX
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|<
literal|0
condition|)
return|return
operator|(
name|READ_FAULT
operator|)
return|;
name|R_AX
operator|=
name|n
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** 21:40 ** ** write */
end_comment

begin_function
specifier|static
name|int
name|write_or_truncate
parameter_list|(
name|int
name|fd
parameter_list|,
name|char
modifier|*
name|addr
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|off_t
name|offset
decl_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
name|offset
operator|=
name|lseek
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
name|SEEK_CUR
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
else|else
return|return
name|ftruncate
argument_list|(
name|fd
argument_list|,
name|offset
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|write
argument_list|(
name|fd
argument_list|,
name|addr
argument_list|,
name|len
argument_list|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|int21_40
parameter_list|(
name|regcontext_t
modifier|*
name|REGS
parameter_list|)
block|{
name|char
modifier|*
name|addr
decl_stmt|;
name|int
name|nbytes
decl_stmt|,
name|n
decl_stmt|;
name|addr
operator|=
operator|(
name|char
operator|*
operator|)
name|MAKEPTR
argument_list|(
name|R_DS
argument_list|,
name|R_DX
argument_list|)
expr_stmt|;
name|nbytes
operator|=
name|R_CX
expr_stmt|;
name|debug
argument_list|(
name|D_FILE_OPS
argument_list|,
literal|"write(%d, %d)\n"
argument_list|,
name|R_BX
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|R_BX
condition|)
block|{
case|case
literal|0
case|:
if|if
condition|(
name|redirect0
condition|)
block|{
name|n
operator|=
name|write_or_truncate
argument_list|(
name|R_BX
argument_list|,
name|addr
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
break|break;
block|}
name|n
operator|=
name|nbytes
expr_stmt|;
while|while
condition|(
name|nbytes
operator|--
operator|>
literal|0
condition|)
name|tty_write
argument_list|(
operator|*
name|addr
operator|++
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
if|if
condition|(
name|redirect1
condition|)
block|{
name|n
operator|=
name|write_or_truncate
argument_list|(
name|R_BX
argument_list|,
name|addr
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
break|break;
block|}
name|n
operator|=
name|nbytes
expr_stmt|;
while|while
condition|(
name|nbytes
operator|--
operator|>
literal|0
condition|)
name|tty_write
argument_list|(
operator|*
name|addr
operator|++
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
if|if
condition|(
name|redirect2
condition|)
block|{
name|n
operator|=
name|write_or_truncate
argument_list|(
name|R_BX
argument_list|,
name|addr
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
break|break;
block|}
name|n
operator|=
name|nbytes
expr_stmt|;
while|while
condition|(
name|nbytes
operator|--
operator|>
literal|0
condition|)
name|tty_write
argument_list|(
operator|*
name|addr
operator|++
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
default|default:
name|n
operator|=
name|write_or_truncate
argument_list|(
name|R_BX
argument_list|,
name|addr
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|n
operator|<
literal|0
condition|)
return|return
operator|(
name|WRITE_FAULT
operator|)
return|;
name|R_AX
operator|=
name|n
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** 21:42 ** ** seek */
end_comment

begin_function
specifier|static
name|int
name|int21_42
parameter_list|(
name|regcontext_t
modifier|*
name|REGS
parameter_list|)
block|{
name|int
name|whence
decl_stmt|;
name|off_t
name|offset
decl_stmt|;
name|offset
operator|=
call|(
name|off_t
call|)
argument_list|(
call|(
name|int
call|)
argument_list|(
name|R_CX
operator|<<
literal|16
argument_list|)
operator|+
name|R_DX
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|R_AL
condition|)
block|{
case|case
literal|0
case|:
name|whence
operator|=
name|SEEK_SET
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|whence
operator|=
name|SEEK_CUR
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|whence
operator|=
name|SEEK_END
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|FUNC_NUM_IVALID
operator|)
return|;
block|}
name|debug
argument_list|(
name|D_FILE_OPS
argument_list|,
literal|"seek(%d, 0x%qx, %d)\n"
argument_list|,
name|R_BX
argument_list|,
name|offset
argument_list|,
name|whence
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|offset
operator|=
name|lseek
argument_list|(
name|R_BX
argument_list|,
name|offset
argument_list|,
name|whence
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EBADF
condition|)
return|return
operator|(
name|HANDLE_INVALID
operator|)
return|;
else|else
return|return
operator|(
name|SEEK_ERROR
operator|)
return|;
block|}
name|R_DX
operator|=
operator|(
name|offset
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
expr_stmt|;
name|R_AX
operator|=
name|offset
operator|&
literal|0xffff
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** 21:43 ** ** get/set attributes */
end_comment

begin_function
specifier|static
name|int
name|int21_43
parameter_list|(
name|regcontext_t
modifier|*
name|REGS
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|char
name|fname
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|struct
name|stat
name|sb
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|int
name|drive
decl_stmt|;
name|error
operator|=
name|translate_filename
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|MAKEPTR
argument_list|(
name|R_DS
argument_list|,
name|R_DX
argument_list|)
argument_list|,
name|fname
argument_list|,
operator|&
name|drive
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|debug
argument_list|(
name|D_FILE_OPS
argument_list|,
literal|"get/set attributes: %s, cx=%x, al=%d\n"
argument_list|,
name|fname
argument_list|,
name|R_CX
argument_list|,
name|R_AL
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|fname
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|debug
argument_list|(
name|D_FILE_OPS
argument_list|,
literal|"stat failed for %s\n"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
return|return
operator|(
name|FILE_NOT_FOUND
operator|)
return|;
block|}
switch|switch
condition|(
name|R_AL
condition|)
block|{
case|case
literal|0
case|:
comment|/* get attributes */
name|mode
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dos_readonly
argument_list|(
name|drive
argument_list|)
operator|||
name|access
argument_list|(
name|fname
argument_list|,
name|W_OK
argument_list|)
condition|)
name|mode
operator||=
literal|0x01
expr_stmt|;
if|if
condition|(
name|S_ISDIR
argument_list|(
name|sb
operator|.
name|st_mode
argument_list|)
condition|)
name|mode
operator||=
literal|0x10
expr_stmt|;
name|R_CX
operator|=
name|mode
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* set attributes - XXX ignored */
if|if
condition|(
name|R_CX
operator|&
literal|0x18
condition|)
return|return
operator|(
name|ACCESS_DENIED
operator|)
return|;
break|break;
default|default:
return|return
operator|(
name|FUNC_NUM_IVALID
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** 21:44:0 ** ** ioctl - get device info ** ** XXX it would be nice to detect EOF. */
end_comment

begin_function
specifier|static
name|int
name|int21_44_0
parameter_list|(
name|regcontext_t
modifier|*
name|REGS
parameter_list|)
block|{
name|debug
argument_list|(
name|D_FILE_OPS
argument_list|,
literal|"ioctl get %d\n"
argument_list|,
name|R_BX
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|R_BX
condition|)
block|{
case|case
literal|0
case|:
name|R_DX
operator|=
literal|0x80
operator||
literal|0x01
expr_stmt|;
comment|/* is device, is standard output */
break|break;
case|case
literal|1
case|:
name|R_DX
operator|=
literal|0x80
operator||
literal|0x02
expr_stmt|;
comment|/* is device, is standard input */
break|break;
case|case
literal|2
case|:
name|R_DX
operator|=
literal|0x80
expr_stmt|;
comment|/* is device */
break|break;
default|default:
if|if
condition|(
name|isatty
argument_list|(
name|R_BX
argument_list|)
condition|)
name|R_DX
operator|=
literal|0x80
expr_stmt|;
comment|/* is a device */
else|else
name|R_DX
operator|=
literal|0
expr_stmt|;
comment|/* is a file */
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** 21:44:01 ** ** ioctl - set device info */
end_comment

begin_function
specifier|static
name|int
name|int21_44_1
parameter_list|(
name|regcontext_t
modifier|*
name|REGS
parameter_list|)
block|{
name|debug
argument_list|(
name|D_FILE_OPS
argument_list|,
literal|"ioctl set device info %d flags %x (ignored)\n"
argument_list|,
name|R_BX
argument_list|,
name|R_DX
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** 21:44:7 ** ** Get output status */
end_comment

begin_function
specifier|static
name|int
name|int21_44_7
parameter_list|(
name|regcontext_t
modifier|*
name|REGS
parameter_list|)
block|{
comment|/* XXX Should really check to see if BX is open or not */
name|R_AX
operator|=
literal|0xFF
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** 21:44:8 ** ** test for removable block device */
end_comment

begin_function
specifier|static
name|int
name|int21_44_8
parameter_list|(
name|regcontext_t
modifier|*
name|REGS
parameter_list|)
block|{
name|R_AX
operator|=
literal|1
expr_stmt|;
comment|/* fixed */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** 21:44:0 ** ** test for remote device (disallow direct I/O) */
end_comment

begin_function
specifier|static
name|int
name|int21_44_9
parameter_list|(
name|regcontext_t
modifier|*
name|REGS
parameter_list|)
block|{
name|R_DX
operator|=
literal|0x1200
expr_stmt|;
comment|/* disk is remote, direct I/O not allowed */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** 21:45 ** ** dup */
end_comment

begin_function
specifier|static
name|int
name|int21_45
parameter_list|(
name|regcontext_t
modifier|*
name|REGS
parameter_list|)
block|{
name|int
name|nfd
decl_stmt|;
name|debug
argument_list|(
name|D_FILE_OPS
argument_list|,
literal|"dup(%d)\n"
argument_list|,
name|R_BX
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|nfd
operator|=
name|dup
argument_list|(
name|R_BX
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EBADF
condition|)
return|return
operator|(
name|HANDLE_INVALID
operator|)
return|;
else|else
return|return
operator|(
name|TOO_MANY_OPEN_FILES
operator|)
return|;
block|}
name|R_AX
operator|=
name|nfd
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** 21:46 ** ** dup2 */
end_comment

begin_function
specifier|static
name|int
name|int21_46
parameter_list|(
name|regcontext_t
modifier|*
name|REGS
parameter_list|)
block|{
name|debug
argument_list|(
name|D_FILE_OPS
argument_list|,
literal|"dup2(%d, %d)\n"
argument_list|,
name|R_BX
argument_list|,
name|R_CX
argument_list|)
expr_stmt|;
if|if
condition|(
name|dup2
argument_list|(
name|R_BX
argument_list|,
name|R_CX
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EMFILE
condition|)
return|return
operator|(
name|TOO_MANY_OPEN_FILES
operator|)
return|;
else|else
return|return
operator|(
name|HANDLE_INVALID
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** 21:47 ** ** getcwd */
end_comment

begin_function
specifier|static
name|int
name|int21_47
parameter_list|(
name|regcontext_t
modifier|*
name|REGS
parameter_list|)
block|{
name|int
name|n
decl_stmt|,
name|nbytes
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|addr
decl_stmt|;
name|n
operator|=
name|R_DL
expr_stmt|;
if|if
condition|(
operator|!
name|n
operator|--
condition|)
name|n
operator|=
name|diskdrive
expr_stmt|;
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|dos_getcwd
argument_list|(
name|n
argument_list|)
operator|+
literal|1
expr_stmt|;
name|addr
operator|=
operator|(
name|char
operator|*
operator|)
name|MAKEPTR
argument_list|(
name|R_DS
argument_list|,
name|R_SI
argument_list|)
expr_stmt|;
name|nbytes
operator|=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbytes
operator|>
literal|63
condition|)
name|nbytes
operator|=
literal|63
expr_stmt|;
name|memcpy
argument_list|(
name|addr
argument_list|,
name|p
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
name|addr
index|[
name|nbytes
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** 21:48 ** ** allocate memory */
end_comment

begin_function
specifier|static
name|int
name|int21_48
parameter_list|(
name|regcontext_t
modifier|*
name|REGS
parameter_list|)
block|{
name|int
name|memseg
decl_stmt|,
name|avail
decl_stmt|;
name|memseg
operator|=
name|mem_alloc
argument_list|(
name|R_BX
argument_list|,
name|pspseg
argument_list|,
operator|&
name|avail
argument_list|)
expr_stmt|;
if|if
condition|(
name|memseg
operator|==
literal|0L
condition|)
block|{
name|R_BX
operator|=
name|avail
expr_stmt|;
return|return
operator|(
name|INSUF_MEM
operator|)
return|;
block|}
name|R_AX
operator|=
name|memseg
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** 21:49 ** ** free memory */
end_comment

begin_function
specifier|static
name|int
name|int21_49
parameter_list|(
name|regcontext_t
modifier|*
name|REGS
parameter_list|)
block|{
if|if
condition|(
name|mem_adjust
argument_list|(
name|R_ES
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|MEM_BLK_ADDR_IVALID
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** 21:4a ** ** resize memory block */
end_comment

begin_function
specifier|static
name|int
name|int21_4a
parameter_list|(
name|regcontext_t
modifier|*
name|REGS
parameter_list|)
block|{
name|int
name|n
decl_stmt|,
name|avail
decl_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|mem_adjust
argument_list|(
name|R_ES
argument_list|,
name|R_BX
argument_list|,
operator|&
name|avail
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|R_BX
operator|=
name|avail
expr_stmt|;
if|if
condition|(
name|n
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|INSUF_MEM
operator|)
return|;
else|else
return|return
operator|(
name|MEM_BLK_ADDR_IVALID
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** 21:4b ** ** exec ** ** XXX verify! */
end_comment

begin_function
specifier|static
name|int
name|int21_4b
parameter_list|(
name|regcontext_t
modifier|*
name|REGS
parameter_list|)
block|{
name|int
name|fd
decl_stmt|;
name|u_short
modifier|*
name|param
decl_stmt|;
name|debug
argument_list|(
name|D_EXEC
argument_list|,
literal|"exec(%s)\n"
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|MAKEPTR
argument_list|(
name|R_DS
argument_list|,
name|R_DX
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open_prog
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|MAKEPTR
argument_list|(
name|R_DS
argument_list|,
name|R_DX
argument_list|)
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|debug
argument_list|(
name|D_EXEC
argument_list|,
literal|"%s: command not found\n"
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|MAKEPTR
argument_list|(
name|R_DS
argument_list|,
name|R_DX
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|FILE_NOT_FOUND
operator|)
return|;
block|}
comment|/* child */
name|param
operator|=
operator|(
name|u_short
operator|*
operator|)
name|MAKEPTR
argument_list|(
name|R_ES
argument_list|,
name|R_BX
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|R_AL
condition|)
block|{
case|case
literal|0x00
case|:
comment|/* load and execute */
name|exec_command
argument_list|(
name|REGS
argument_list|,
literal|1
argument_list|,
name|fd
argument_list|,
name|cmdname
argument_list|,
name|param
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x01
case|:
comment|/* just load */
name|exec_command
argument_list|(
name|REGS
argument_list|,
literal|0
argument_list|,
name|fd
argument_list|,
name|cmdname
argument_list|,
name|param
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x03
case|:
comment|/* load overlay */
name|load_overlay
argument_list|(
name|fd
argument_list|,
name|param
index|[
literal|0
index|]
argument_list|,
name|param
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
break|break;
default|default:
name|unknown_int3
argument_list|(
literal|0x21
argument_list|,
literal|0x4b
argument_list|,
name|R_AL
argument_list|,
name|REGS
argument_list|)
expr_stmt|;
return|return
operator|(
name|FUNC_NUM_IVALID
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** 21:4c ** ** return with code */
end_comment

begin_function
specifier|static
name|int
name|int21_4c
parameter_list|(
name|regcontext_t
modifier|*
name|REGS
parameter_list|)
block|{
name|return_status
operator|=
name|R_AL
expr_stmt|;
name|done
argument_list|(
name|REGS
argument_list|,
name|R_AL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ** 21:4d ** ** get return code of child */
end_comment

begin_function
specifier|static
name|int
name|int21_4d
parameter_list|(
name|regcontext_t
modifier|*
name|REGS
parameter_list|)
block|{
name|R_AX
operator|=
name|return_status
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** 21:4e ** 21:4f ** ** find first, find next */
end_comment

begin_function
specifier|static
name|int
name|int21_find
parameter_list|(
name|regcontext_t
modifier|*
name|REGS
parameter_list|)
block|{
name|find_block_t
modifier|*
name|dta
decl_stmt|;
name|dosdir_t
name|dosdir
decl_stmt|;
name|int
name|error
decl_stmt|;
name|dta
operator|=
operator|(
name|find_block_t
operator|*
operator|)
name|VECPTR
argument_list|(
name|disk_transfer_addr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|R_AH
condition|)
block|{
case|case
literal|0x4e
case|:
comment|/* find first */
name|error
operator|=
name|find_first
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|MAKEPTR
argument_list|(
name|R_DS
argument_list|,
name|R_DX
argument_list|)
argument_list|,
name|R_CX
argument_list|,
operator|&
name|dosdir
argument_list|,
name|dta
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x4f
case|:
name|error
operator|=
name|find_next
argument_list|(
operator|&
name|dosdir
argument_list|,
name|dta
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fatal
argument_list|(
literal|"called int21_find for unknown function %x\n"
argument_list|,
name|R_AH
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|dosdir_to_dta
argument_list|(
operator|&
name|dosdir
argument_list|,
name|dta
argument_list|)
expr_stmt|;
name|R_AX
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** 21:50 ** ** set PSP */
end_comment

begin_function
specifier|static
name|int
name|int21_50
parameter_list|(
name|regcontext_t
modifier|*
name|REGS
parameter_list|)
block|{
name|pspseg
operator|=
name|R_BX
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** 21:57:00 ** ** get mtime for handle */
end_comment

begin_function
specifier|static
name|int
name|int21_57_0
parameter_list|(
name|regcontext_t
modifier|*
name|REGS
parameter_list|)
block|{
name|struct
name|stat
name|sb
decl_stmt|;
name|u_short
name|date
decl_stmt|,
name|mtime
decl_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|R_BX
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|HANDLE_INVALID
operator|)
return|;
name|encode_dos_file_time
argument_list|(
name|sb
operator|.
name|st_mtime
argument_list|,
operator|&
name|date
argument_list|,
operator|&
name|mtime
argument_list|)
expr_stmt|;
name|R_CX
operator|=
name|mtime
expr_stmt|;
name|R_DX
operator|=
name|date
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** 21:57:01 ** ** set mtime for handle */
end_comment

begin_function
specifier|static
name|int
name|int21_57_1
parameter_list|(
name|regcontext_t
modifier|*
name|REGS
name|__unused
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|__NetBSD__
comment|/* XXX need futimes() */
name|struct
name|stat
name|sb
decl_stmt|;
name|struct
name|timeval
name|tv
index|[
literal|2
index|]
decl_stmt|;
name|u_short
name|date
decl_stmt|,
name|time
decl_stmt|;
name|time
operator|=
name|R_CX
expr_stmt|;
name|date
operator|=
name|R_DX
expr_stmt|;
name|tv
index|[
literal|0
index|]
operator|.
name|tv_sec
operator|=
name|tv
index|[
literal|1
index|]
operator|.
name|tv_sec
operator|=
name|decode_dos_file_time
argument_list|(
name|date
argument_list|,
name|time
argument_list|)
expr_stmt|;
name|tv
index|[
literal|0
index|]
operator|.
name|tv_usec
operator|=
name|tv
index|[
literal|1
index|]
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|futimes
argument_list|(
name|R_BX
argument_list|,
name|tv
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|HANDLE_INVALID
operator|)
return|;
break|break;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** 21:58 ** ** get/set memory strategy ** get/set UMB link state */
end_comment

begin_function
specifier|static
name|int
name|int21_58
parameter_list|(
name|regcontext_t
modifier|*
name|REGS
parameter_list|)
block|{
switch|switch
condition|(
name|R_AL
condition|)
block|{
case|case
literal|0x00
case|:
comment|/* get memory strategy */
name|R_AX
operator|=
name|memory_strategy
expr_stmt|;
break|break;
case|case
literal|0x01
case|:
comment|/* set memory strategy */
name|memory_strategy
operator|=
name|R_BL
expr_stmt|;
if|if
condition|(
name|memory_strategy
operator|>
literal|2
condition|)
comment|/* higher make no sense without UMBs */
name|memory_strategy
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|0x02
case|:
comment|/* get UMB link state */
name|R_AL
operator|=
literal|0
expr_stmt|;
comment|/* UMBs not in link chain */
break|break;
default|default:
comment|/* includes set, which is invalid */
name|unknown_int3
argument_list|(
literal|0x21
argument_list|,
literal|0x58
argument_list|,
name|R_AL
argument_list|,
name|REGS
argument_list|)
expr_stmt|;
return|return
operator|(
name|FUNC_NUM_IVALID
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** 21:59 ** ** get extended error information */
end_comment

begin_function
specifier|static
name|int
name|int21_59
parameter_list|(
name|regcontext_t
modifier|*
name|REGS
parameter_list|)
block|{
name|R_AX
operator|=
name|doserrno
expr_stmt|;
switch|switch
condition|(
name|doserrno
condition|)
block|{
case|case
literal|1
case|:
case|case
literal|6
case|:
case|case
literal|9
case|:
case|case
literal|10
case|:
case|case
literal|11
case|:
case|case
literal|12
case|:
case|case
literal|13
case|:
case|case
literal|15
case|:
name|R_BH
operator|=
literal|7
expr_stmt|;
comment|/* application error */
break|break;
case|case
literal|2
case|:
case|case
literal|3
case|:
case|case
literal|4
case|:
case|case
literal|5
case|:
name|R_BH
operator|=
literal|8
expr_stmt|;
comment|/* not found */
break|break;
case|case
literal|7
case|:
case|case
literal|8
case|:
name|R_BH
operator|=
literal|1
expr_stmt|;
comment|/* out of resource */
break|break;
default|default:
name|R_BH
operator|=
literal|12
expr_stmt|;
comment|/* already exists */
break|break;
block|}
name|R_BL
operator|=
literal|6
expr_stmt|;
comment|/* always ignore! */
name|R_CH
operator|=
literal|1
expr_stmt|;
comment|/* unknown/inappropriate */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** 21:5a ** ** create temporary file */
end_comment

begin_function
specifier|static
name|int
name|int21_5a
parameter_list|(
name|regcontext_t
modifier|*
name|REGS
parameter_list|)
block|{
name|char
name|fname
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|char
modifier|*
name|pname
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|n
decl_stmt|;
name|int
name|drive
decl_stmt|;
name|int
name|fd
decl_stmt|;
comment|/* get and check proposed path */
name|pname
operator|=
operator|(
name|char
operator|*
operator|)
name|MAKEPTR
argument_list|(
name|R_DS
argument_list|,
name|R_DX
argument_list|)
expr_stmt|;
name|error
operator|=
name|translate_filename
argument_list|(
name|pname
argument_list|,
name|fname
argument_list|,
operator|&
name|drive
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|debug
argument_list|(
name|D_FILE_OPS
argument_list|,
literal|"tempname(%s)\n"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|dos_readonly
argument_list|(
name|drive
argument_list|)
condition|)
return|return
operator|(
name|WRITE_PROT_DISK
operator|)
return|;
name|n
operator|=
name|strlen
argument_list|(
name|fname
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|fname
argument_list|,
literal|"__dostmp.XXX"
argument_list|)
expr_stmt|;
name|fd
operator|=
name|mkstemp
argument_list|(
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
return|return
operator|(
name|ACCESS_DENIED
operator|)
return|;
name|strcat
argument_list|(
name|pname
argument_list|,
name|fname
operator|+
name|n
argument_list|)
expr_stmt|;
comment|/* give back the full name */
name|R_AX
operator|=
name|fd
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** 21:60 ** ** canonicalise name */
end_comment

begin_function
specifier|static
name|int
name|int21_60
parameter_list|(
name|regcontext_t
modifier|*
name|REGS
parameter_list|)
block|{
return|return
operator|(
name|dos_makepath
argument_list|(
operator|(
name|char
operator|*
operator|)
name|MAKEPTR
argument_list|(
name|R_DS
argument_list|,
name|R_SI
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|MAKEPTR
argument_list|(
name|R_ES
argument_list|,
name|R_DI
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** 21:62 ** ** get current PSP */
end_comment

begin_function
specifier|static
name|int
name|int21_62
parameter_list|(
name|regcontext_t
modifier|*
name|REGS
parameter_list|)
block|{
name|R_BX
operator|=
name|pspseg
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** 21:65:23 ** ** determine yes/no ** (mostly for humour value 8) */
end_comment

begin_function
specifier|static
name|int
name|int21_65_23
parameter_list|(
name|regcontext_t
modifier|*
name|REGS
parameter_list|)
block|{
switch|switch
condition|(
name|R_DL
condition|)
block|{
case|case
literal|'n'
case|:
comment|/* no, nein, non, nyet */
case|case
literal|'N'
case|:
name|R_AX
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'y'
case|:
comment|/* yes */
case|case
literal|'Y'
case|:
case|case
literal|'j'
case|:
comment|/* ja */
case|case
literal|'J'
case|:
case|case
literal|'o'
case|:
comment|/* oui */
case|case
literal|'O'
case|:
case|case
literal|'d'
case|:
comment|/* da */
case|case
literal|'D'
case|:
name|R_AX
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
comment|/* maybe */
name|R_AX
operator|=
literal|2
expr_stmt|;
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** 21:68 ** 21:6a ** ** fflush/commit file */
end_comment

begin_function
specifier|static
name|int
name|int21_fflush
parameter_list|(
name|regcontext_t
modifier|*
name|REGS
parameter_list|)
block|{
name|debug
argument_list|(
name|D_FILE_OPS
argument_list|,
literal|"fsync(%d)\n"
argument_list|,
name|R_BX
argument_list|)
expr_stmt|;
if|if
condition|(
name|fsync
argument_list|(
name|R_BX
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|HANDLE_INVALID
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************** ** 21:0f 21:10 21:11 21:12 21:16 21:27 21:28:21:29 ** ** FCB functions */
end_comment

begin_function
specifier|static
name|void
name|openfcb
parameter_list|(
name|struct
name|fcb
modifier|*
name|fcbp
parameter_list|)
block|{
name|struct
name|stat
name|statb
decl_stmt|;
name|fcbp
operator|->
name|fcbDriveID
operator|=
literal|3
expr_stmt|;
comment|/* drive C */
name|fcbp
operator|->
name|fcbCurBlockNo
operator|=
literal|0
expr_stmt|;
name|fcbp
operator|->
name|fcbRecSize
operator|=
literal|128
expr_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|fcbp
operator|->
name|fcb_fd
argument_list|,
operator|&
name|statb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|debug
argument_list|(
name|D_FILE_OPS
argument_list|,
literal|"open not complete with errno %d\n"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
return|return;
block|}
name|encode_dos_file_time
argument_list|(
name|statb
operator|.
name|st_mtime
argument_list|,
operator|&
name|fcbp
operator|->
name|fcbFileDate
argument_list|,
operator|&
name|fcbp
operator|->
name|fcbFileTime
argument_list|)
expr_stmt|;
name|fcbp
operator|->
name|fcbFileSize
operator|=
name|statb
operator|.
name|st_size
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|getfcb_rec
parameter_list|(
name|struct
name|fcb
modifier|*
name|fcbp
parameter_list|,
name|int
name|nrec
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
name|n
operator|=
name|fcbp
operator|->
name|fcbRandomRecNo
expr_stmt|;
if|if
condition|(
name|fcbp
operator|->
name|fcbRecSize
operator|>=
literal|64
condition|)
name|n
operator|&=
literal|0xffffff
expr_stmt|;
name|fcbp
operator|->
name|fcbCurRecNo
operator|=
name|n
operator|%
literal|128
expr_stmt|;
name|fcbp
operator|->
name|fcbCurBlockNo
operator|=
name|n
operator|/
literal|128
expr_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|fcbp
operator|->
name|fcb_fd
argument_list|,
name|n
operator|*
name|fcbp
operator|->
name|fcbRecSize
argument_list|,
name|SEEK_SET
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
name|nrec
operator|*
name|fcbp
operator|->
name|fcbRecSize
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|setfcb_rec
parameter_list|(
name|struct
name|fcb
modifier|*
name|fcbp
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|int
name|recs
decl_stmt|,
name|total
decl_stmt|;
name|total
operator|=
name|fcbp
operator|->
name|fcbRandomRecNo
expr_stmt|;
if|if
condition|(
name|fcbp
operator|->
name|fcbRecSize
operator|>=
literal|64
condition|)
name|total
operator|&=
literal|0xffffff
expr_stmt|;
name|recs
operator|=
operator|(
name|n
operator|+
name|fcbp
operator|->
name|fcbRecSize
operator|-
literal|1
operator|)
operator|/
name|fcbp
operator|->
name|fcbRecSize
expr_stmt|;
name|total
operator|+=
name|recs
expr_stmt|;
name|fcbp
operator|->
name|fcbRandomRecNo
operator|=
name|total
expr_stmt|;
name|fcbp
operator|->
name|fcbCurRecNo
operator|=
name|total
operator|%
literal|128
expr_stmt|;
name|fcbp
operator|->
name|fcbCurBlockNo
operator|=
name|total
operator|/
literal|128
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fcb_to_string
parameter_list|(
name|fcbp
parameter_list|,
name|buf
parameter_list|)
name|struct
name|fcb
modifier|*
name|fcbp
decl_stmt|;
name|u_char
modifier|*
name|buf
decl_stmt|;
block|{
if|if
condition|(
name|fcbp
operator|->
name|fcbDriveID
operator|!=
literal|0x00
condition|)
block|{
operator|*
name|buf
operator|++
operator|=
name|drntol
argument_list|(
name|fcbp
operator|->
name|fcbDriveID
operator|-
literal|1
argument_list|)
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
literal|':'
expr_stmt|;
block|}
name|pack_name
argument_list|(
name|fcbp
operator|->
name|fcbFileName
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|int21_fcb
parameter_list|(
name|regcontext_t
modifier|*
name|REGS
parameter_list|)
block|{
name|char
name|buf
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|char
name|fname
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|struct
name|stat
name|sb
decl_stmt|;
name|dosdir_t
name|dosdir
decl_stmt|;
name|struct
name|fcb
modifier|*
name|fcbp
decl_stmt|;
name|find_block_t
modifier|*
name|dta
decl_stmt|;
name|u_char
modifier|*
name|addr
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|drive
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|int
name|nbytes
decl_stmt|,
name|n
decl_stmt|;
name|fcbp
operator|=
operator|(
expr|struct
name|fcb
operator|*
operator|)
name|MAKEPTR
argument_list|(
name|R_DS
argument_list|,
name|R_DX
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|R_AH
condition|)
block|{
case|case
literal|0x0f
case|:
comment|/* open file with FCB */
name|fcb_to_string
argument_list|(
name|fcbp
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|error
operator|=
name|translate_filename
argument_list|(
name|buf
argument_list|,
name|fname
argument_list|,
operator|&
name|drive
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|debug
argument_list|(
name|D_FILE_OPS
argument_list|,
literal|"open FCB(%s)\n"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|ustat
argument_list|(
name|fname
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
name|sb
operator|.
name|st_ino
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dos_readonly
argument_list|(
name|drive
argument_list|)
condition|)
return|return
operator|(
name|WRITE_PROT_DISK
operator|)
return|;
if|if
condition|(
name|sb
operator|.
name|st_ino
operator|==
literal|0
operator|||
name|S_ISDIR
argument_list|(
name|sb
operator|.
name|st_mode
argument_list|)
condition|)
return|return
operator|(
name|FILE_NOT_FOUND
operator|)
return|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|fname
argument_list|,
name|O_RDWR
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOENT
condition|)
return|return
operator|(
name|FILE_NOT_FOUND
operator|)
return|;
else|else
return|return
operator|(
name|ACCESS_DENIED
operator|)
return|;
block|}
name|fcbp
operator|->
name|fcb_fd
operator|=
name|fd
expr_stmt|;
name|openfcb
argument_list|(
name|fcbp
argument_list|)
expr_stmt|;
name|R_AL
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|0x10
case|:
comment|/* close file with FCB */
name|debug
argument_list|(
name|D_FILE_OPS
argument_list|,
literal|"close FCB(%d)\n"
argument_list|,
name|fcbp
operator|->
name|fcb_fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
name|fcbp
operator|->
name|fcb_fd
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|HANDLE_INVALID
operator|)
return|;
name|fcbp
operator|->
name|fcb_fd
operator|=
operator|-
literal|1
expr_stmt|;
name|R_AL
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|0x11
case|:
comment|/* find_first with FCB */
name|dta
operator|=
operator|(
name|find_block_t
operator|*
operator|)
name|VECPTR
argument_list|(
name|disk_transfer_addr
argument_list|)
expr_stmt|;
name|fcb_to_string
argument_list|(
name|fcbp
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|error
operator|=
name|find_first
argument_list|(
name|buf
argument_list|,
name|fcbp
operator|->
name|fcbAttribute
argument_list|,
operator|&
name|dosdir
argument_list|,
name|dta
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|dosdir_to_dta
argument_list|(
operator|&
name|dosdir
argument_list|,
name|dta
argument_list|)
expr_stmt|;
name|R_AL
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|0x12
case|:
comment|/* find_next with FCB */
name|dta
operator|=
operator|(
name|find_block_t
operator|*
operator|)
name|VECPTR
argument_list|(
name|disk_transfer_addr
argument_list|)
expr_stmt|;
name|error
operator|=
name|find_next
argument_list|(
operator|&
name|dosdir
argument_list|,
name|dta
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|dosdir_to_dta
argument_list|(
operator|&
name|dosdir
argument_list|,
name|dta
argument_list|)
expr_stmt|;
name|R_AL
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|0x16
case|:
comment|/* create file with FCB */
name|fcb_to_string
argument_list|(
name|fcbp
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|error
operator|=
name|translate_filename
argument_list|(
name|buf
argument_list|,
name|fname
argument_list|,
operator|&
name|drive
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|debug
argument_list|(
name|D_FILE_OPS
argument_list|,
literal|"creat FCB(%s)\n"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|ustat
argument_list|(
name|fname
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
name|sb
operator|.
name|st_ino
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dos_readonly
argument_list|(
name|drive
argument_list|)
condition|)
return|return
operator|(
name|WRITE_PROT_DISK
operator|)
return|;
if|if
condition|(
name|sb
operator|.
name|st_ino
operator|&&
operator|!
name|S_ISREG
argument_list|(
name|sb
operator|.
name|st_mode
argument_list|)
condition|)
return|return
operator|(
name|ACCESS_DENIED
operator|)
return|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|fname
argument_list|,
name|O_CREAT
operator||
name|O_TRUNC
operator||
name|O_RDWR
argument_list|,
literal|0666
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|ACCESS_DENIED
operator|)
return|;
name|fcbp
operator|->
name|fcb_fd
operator|=
name|fd
expr_stmt|;
name|openfcb
argument_list|(
name|fcbp
argument_list|)
expr_stmt|;
name|R_AL
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|0x27
case|:
comment|/* random block read */
name|addr
operator|=
operator|(
name|u_char
operator|*
operator|)
name|VECPTR
argument_list|(
name|disk_transfer_addr
argument_list|)
expr_stmt|;
name|nbytes
operator|=
name|getfcb_rec
argument_list|(
name|fcbp
argument_list|,
name|R_CX
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbytes
operator|<
literal|0
condition|)
return|return
operator|(
name|READ_FAULT
operator|)
return|;
name|n
operator|=
name|read
argument_list|(
name|fcbp
operator|->
name|fcb_fd
argument_list|,
name|addr
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
return|return
operator|(
name|READ_FAULT
operator|)
return|;
name|R_CX
operator|=
name|setfcb_rec
argument_list|(
name|fcbp
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
name|nbytes
condition|)
block|{
name|nbytes
operator|=
name|n
operator|%
name|fcbp
operator|->
name|fcbRecSize
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|nbytes
condition|)
block|{
name|R_AL
operator|=
literal|0x01
expr_stmt|;
block|}
else|else
block|{
name|bzero
argument_list|(
name|addr
operator|+
name|n
argument_list|,
name|fcbp
operator|->
name|fcbRecSize
operator|-
name|nbytes
argument_list|)
expr_stmt|;
name|R_AL
operator|=
literal|0x03
expr_stmt|;
block|}
block|}
else|else
block|{
name|R_AL
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
literal|0x28
case|:
comment|/* random block write */
name|addr
operator|=
operator|(
name|u_char
operator|*
operator|)
name|VECPTR
argument_list|(
name|disk_transfer_addr
argument_list|)
expr_stmt|;
name|nbytes
operator|=
name|getfcb_rec
argument_list|(
name|fcbp
argument_list|,
name|R_CX
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbytes
operator|<
literal|0
condition|)
return|return
operator|(
name|WRITE_FAULT
operator|)
return|;
name|n
operator|=
name|write
argument_list|(
name|fcbp
operator|->
name|fcb_fd
argument_list|,
name|addr
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
return|return
operator|(
name|WRITE_FAULT
operator|)
return|;
name|R_CX
operator|=
name|setfcb_rec
argument_list|(
name|fcbp
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
name|nbytes
condition|)
block|{
name|R_AL
operator|=
literal|0x01
expr_stmt|;
block|}
else|else
block|{
name|R_AL
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
literal|0x29
case|:
comment|/* parse filename */
name|debug
argument_list|(
name|D_FILE_OPS
argument_list|,
literal|"parse filename: flag=%d, "
argument_list|,
name|R_AL
argument_list|)
expr_stmt|;
name|R_AX
operator|=
name|parse_filename
argument_list|(
name|R_AL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|MAKEPTR
argument_list|(
name|R_DS
argument_list|,
name|R_SI
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|MAKEPTR
argument_list|(
name|R_ES
argument_list|,
name|R_DI
argument_list|)
argument_list|,
operator|&
name|nbytes
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|D_FILE_OPS
argument_list|,
literal|"%d %s, FCB: %d, %.11s\n"
argument_list|,
name|nbytes
argument_list|,
operator|(
name|char
operator|*
operator|)
name|MAKEPTR
argument_list|(
name|R_DS
argument_list|,
name|R_SI
argument_list|)
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|MAKEPTR
argument_list|(
name|R_ES
argument_list|,
name|R_DI
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|MAKEPTR
argument_list|(
name|R_ES
argument_list|,
name|R_DI
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|R_SI
operator|+=
name|nbytes
expr_stmt|;
break|break;
default|default:
name|fatal
argument_list|(
literal|"called int21_fcb with unknown function %x\n"
argument_list|,
name|R_AH
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** 21:5d ** 21:5e ** 21:5f ** ** network functions ** XXX relevant? */
end_comment

begin_function
specifier|static
name|int
name|int21_net
parameter_list|(
name|regcontext_t
modifier|*
name|REGS
parameter_list|)
block|{
switch|switch
condition|(
name|R_AH
condition|)
block|{
case|case
literal|0x5d
case|:
switch|switch
condition|(
name|R_AL
condition|)
block|{
case|case
literal|0x06
case|:
name|debug
argument_list|(
name|D_HALF
argument_list|,
literal|"Get Swapable Area\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ACCESS_DENIED
operator|)
return|;
case|case
literal|0x08
case|:
comment|/* Set redirected printer mode */
name|debug
argument_list|(
name|D_HALF
argument_list|,
literal|"Redirection is %s\n"
argument_list|,
name|R_DL
condition|?
literal|"separate jobs"
else|:
literal|"combined"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x09
case|:
comment|/* Flush redirected printer output */
break|break;
default|default:
name|unknown_int3
argument_list|(
literal|0x21
argument_list|,
literal|0x5d
argument_list|,
name|R_AL
argument_list|,
name|REGS
argument_list|)
expr_stmt|;
return|return
operator|(
name|FUNC_NUM_IVALID
operator|)
return|;
block|}
break|break;
case|case
literal|0x5e
case|:
case|case
literal|0x5f
case|:
name|unknown_int2
argument_list|(
literal|0x21
argument_list|,
name|R_AH
argument_list|,
name|REGS
argument_list|)
expr_stmt|;
return|return
operator|(
name|FUNC_NUM_IVALID
operator|)
return|;
default|default:
name|fatal
argument_list|(
literal|"called int21_net with unknown function %x\n"
argument_list|,
name|R_AH
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** 21:?? ** ** Unknown/unsupported */
end_comment

begin_function
specifier|static
name|int
name|int21_NOFUNC
parameter_list|(
name|regcontext_t
modifier|*
name|REGS
parameter_list|)
block|{
name|unknown_int2
argument_list|(
literal|0x21
argument_list|,
name|R_AH
argument_list|,
name|REGS
argument_list|)
expr_stmt|;
return|return
operator|(
name|FUNC_NUM_IVALID
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** 21:?? ** ** Null function; no error, no action */
end_comment

begin_function
specifier|static
name|int
name|int21_NULLFUNC
parameter_list|(
name|regcontext_t
modifier|*
name|REGS
parameter_list|)
block|{
name|R_AL
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|intfunc_table
name|int21_table
index|[]
init|=
block|{
block|{
literal|0x00
block|,
name|IFT_NOSUBFUNC
block|,
name|int21_00
block|,
literal|"terminate"
block|}
block|,
block|{
literal|0x01
block|,
name|IFT_NOSUBFUNC
block|,
name|int21_01
block|,
literal|"read character with echo"
block|}
block|,
block|{
literal|0x02
block|,
name|IFT_NOSUBFUNC
block|,
name|int21_02
block|,
literal|"write char to stdout"
block|}
block|,
block|{
literal|0x03
block|,
name|IFT_NOSUBFUNC
block|,
name|int21_NOFUNC
block|,
literal|"read char from stdaux"
block|}
block|,
block|{
literal|0x04
block|,
name|IFT_NOSUBFUNC
block|,
name|int21_NOFUNC
block|,
literal|"write char to stdaux"
block|}
block|,
block|{
literal|0x05
block|,
name|IFT_NOSUBFUNC
block|,
name|int21_NOFUNC
block|,
literal|"write char to printer"
block|}
block|,
block|{
literal|0x06
block|,
name|IFT_NOSUBFUNC
block|,
name|int21_06
block|,
literal|"direct console I/O"
block|}
block|,
block|{
literal|0x07
block|,
name|IFT_NOSUBFUNC
block|,
name|int21_07
block|,
literal|"direct console in without echo"
block|}
block|,
block|{
literal|0x08
block|,
name|IFT_NOSUBFUNC
block|,
name|int21_08
block|,
literal|"read character, no echo"
block|}
block|,
block|{
literal|0x09
block|,
name|IFT_NOSUBFUNC
block|,
name|int21_09
block|,
literal|"write string to standard out"
block|}
block|,
block|{
literal|0x0a
block|,
name|IFT_NOSUBFUNC
block|,
name|int21_0a
block|,
literal|"buffered input"
block|}
block|,
block|{
literal|0x0b
block|,
name|IFT_NOSUBFUNC
block|,
name|int21_0b
block|,
literal|"get stdin status"
block|}
block|,
block|{
literal|0x0c
block|,
name|IFT_NOSUBFUNC
block|,
name|int21_0c
block|,
literal|"flush stdin and read"
block|}
block|,
block|{
literal|0x0d
block|,
name|IFT_NOSUBFUNC
block|,
name|int21_NULLFUNC
block|,
literal|"disk reset"
block|}
block|,
block|{
literal|0x0e
block|,
name|IFT_NOSUBFUNC
block|,
name|int21_0e
block|,
literal|"select default drive"
block|}
block|,
block|{
literal|0x19
block|,
name|IFT_NOSUBFUNC
block|,
name|int21_19
block|,
literal|"get default drive"
block|}
block|,
block|{
literal|0x1a
block|,
name|IFT_NOSUBFUNC
block|,
name|int21_1a
block|,
literal|"set DTA"
block|}
block|,
block|{
literal|0x1b
block|,
name|IFT_NOSUBFUNC
block|,
name|int21_free
block|,
literal|"get allocation for default drive"
block|}
block|,
block|{
literal|0x1c
block|,
name|IFT_NOSUBFUNC
block|,
name|int21_free
block|,
literal|"get allocation for specific drive"
block|}
block|,
block|{
literal|0x1f
block|,
name|IFT_NOSUBFUNC
block|,
name|int21_NOFUNC
block|,
literal|"get DPB for current drive"
block|}
block|,
block|{
literal|0x23
block|,
name|IFT_NOSUBFUNC
block|,
name|int21_23
block|,
literal|"Get file size (old)"
block|}
block|,
block|{
literal|0x25
block|,
name|IFT_NOSUBFUNC
block|,
name|int21_25
block|,
literal|"set interrupt vector"
block|}
block|,
block|{
literal|0x26
block|,
name|IFT_NOSUBFUNC
block|,
name|int21_26
block|,
literal|"create new PSP"
block|}
block|,
block|{
literal|0x2a
block|,
name|IFT_NOSUBFUNC
block|,
name|int21_2a
block|,
literal|"get date"
block|}
block|,
block|{
literal|0x2b
block|,
name|IFT_NOSUBFUNC
block|,
name|int21_2b
block|,
literal|"set date"
block|}
block|,
block|{
literal|0x2c
block|,
name|IFT_NOSUBFUNC
block|,
name|int21_2c
block|,
literal|"get time"
block|}
block|,
block|{
literal|0x2d
block|,
name|IFT_NOSUBFUNC
block|,
name|int21_2d
block|,
literal|"set time"
block|}
block|,
block|{
literal|0x2e
block|,
name|IFT_NOSUBFUNC
block|,
name|int21_NULLFUNC
block|,
literal|"set verify flag"
block|}
block|,
block|{
literal|0x2f
block|,
name|IFT_NOSUBFUNC
block|,
name|int21_2f
block|,
literal|"get DTA"
block|}
block|,
block|{
literal|0x30
block|,
name|IFT_NOSUBFUNC
block|,
name|int21_30
block|,
literal|"get DOS version"
block|}
block|,
block|{
literal|0x31
block|,
name|IFT_NOSUBFUNC
block|,
name|int21_NOFUNC
block|,
literal|"terminate and stay resident"
block|}
block|,
block|{
literal|0x32
block|,
name|IFT_NOSUBFUNC
block|,
name|int21_NOFUNC
block|,
literal|"get DPB for specific drive"
block|}
block|,
block|{
literal|0x33
block|,
literal|0x05
block|,
name|int21_33_5
block|,
literal|"get boot drive"
block|}
block|,
block|{
literal|0x33
block|,
literal|0x06
block|,
name|int21_33_6
block|,
literal|"get true version number"
block|}
block|,
block|{
literal|0x33
block|,
name|IFT_NOSUBFUNC
block|,
name|int21_33
block|,
literal|"extended break checking"
block|}
block|,
block|{
literal|0x34
block|,
name|IFT_NOSUBFUNC
block|,
name|int21_34
block|,
literal|"get address of InDos flag"
block|}
block|,
block|{
literal|0x35
block|,
name|IFT_NOSUBFUNC
block|,
name|int21_35
block|,
literal|"get interrupt vector"
block|}
block|,
block|{
literal|0x36
block|,
name|IFT_NOSUBFUNC
block|,
name|int21_free
block|,
literal|"get disk free space"
block|}
block|,
block|{
literal|0x37
block|,
name|IFT_NOSUBFUNC
block|,
name|int21_37
block|,
literal|"switch character"
block|}
block|,
block|{
literal|0x38
block|,
name|IFT_NOSUBFUNC
block|,
name|int21_38
block|,
literal|"country code/information"
block|}
block|,
block|{
literal|0x39
block|,
name|IFT_NOSUBFUNC
block|,
name|int21_dirfn
block|,
literal|"mkdir"
block|}
block|,
block|{
literal|0x3a
block|,
name|IFT_NOSUBFUNC
block|,
name|int21_dirfn
block|,
literal|"rmdir"
block|}
block|,
block|{
literal|0x3b
block|,
name|IFT_NOSUBFUNC
block|,
name|int21_3b
block|,
literal|"chdir"
block|}
block|,
block|{
literal|0x3c
block|,
name|IFT_NOSUBFUNC
block|,
name|int21_open
block|,
literal|"creat"
block|}
block|,
block|{
literal|0x3d
block|,
name|IFT_NOSUBFUNC
block|,
name|int21_open
block|,
literal|"open"
block|}
block|,
block|{
literal|0x3e
block|,
name|IFT_NOSUBFUNC
block|,
name|int21_3e
block|,
literal|"close"
block|}
block|,
block|{
literal|0x3f
block|,
name|IFT_NOSUBFUNC
block|,
name|int21_3f
block|,
literal|"read"
block|}
block|,
block|{
literal|0x40
block|,
name|IFT_NOSUBFUNC
block|,
name|int21_40
block|,
literal|"write"
block|}
block|,
block|{
literal|0x41
block|,
name|IFT_NOSUBFUNC
block|,
name|int21_dirfn
block|,
literal|"unlink"
block|}
block|,
block|{
literal|0x42
block|,
name|IFT_NOSUBFUNC
block|,
name|int21_42
block|,
literal|"lseek"
block|}
block|,
block|{
literal|0x43
block|,
name|IFT_NOSUBFUNC
block|,
name|int21_43
block|,
literal|"get/set file attributes"
block|}
block|,
block|{
literal|0x44
block|,
literal|0x00
block|,
name|int21_44_0
block|,
literal|"ioctl(get)"
block|}
block|,
block|{
literal|0x44
block|,
literal|0x01
block|,
name|int21_44_1
block|,
literal|"ioctl(set)"
block|}
block|,
block|{
literal|0x44
block|,
literal|0x07
block|,
name|int21_44_7
block|,
literal|"ioctl(Check output status)"
block|}
block|,
block|{
literal|0x44
block|,
literal|0x08
block|,
name|int21_44_8
block|,
literal|"ioctl(test removable)"
block|}
block|,
block|{
literal|0x44
block|,
literal|0x09
block|,
name|int21_44_9
block|,
literal|"ioctl(test remote)"
block|}
block|,
block|{
literal|0x45
block|,
name|IFT_NOSUBFUNC
block|,
name|int21_45
block|,
literal|"dup"
block|}
block|,
block|{
literal|0x46
block|,
name|IFT_NOSUBFUNC
block|,
name|int21_46
block|,
literal|"dup2"
block|}
block|,
block|{
literal|0x47
block|,
name|IFT_NOSUBFUNC
block|,
name|int21_47
block|,
literal|"getwd"
block|}
block|,
block|{
literal|0x48
block|,
name|IFT_NOSUBFUNC
block|,
name|int21_48
block|,
literal|"allocate memory"
block|}
block|,
block|{
literal|0x49
block|,
name|IFT_NOSUBFUNC
block|,
name|int21_49
block|,
literal|"free memory"
block|}
block|,
block|{
literal|0x4a
block|,
name|IFT_NOSUBFUNC
block|,
name|int21_4a
block|,
literal|"resize memory block"
block|}
block|,
block|{
literal|0x4b
block|,
name|IFT_NOSUBFUNC
block|,
name|int21_4b
block|,
literal|"exec"
block|}
block|,
block|{
literal|0x4c
block|,
name|IFT_NOSUBFUNC
block|,
name|int21_4c
block|,
literal|"exit with return code"
block|}
block|,
block|{
literal|0x4d
block|,
name|IFT_NOSUBFUNC
block|,
name|int21_4d
block|,
literal|"get return code from child"
block|}
block|,
block|{
literal|0x4e
block|,
name|IFT_NOSUBFUNC
block|,
name|int21_find
block|,
literal|"findfirst"
block|}
block|,
block|{
literal|0x4f
block|,
name|IFT_NOSUBFUNC
block|,
name|int21_find
block|,
literal|"findnext"
block|}
block|,
block|{
literal|0x50
block|,
name|IFT_NOSUBFUNC
block|,
name|int21_50
block|,
literal|"set psp"
block|}
block|,
block|{
literal|0x51
block|,
name|IFT_NOSUBFUNC
block|,
name|int21_62
block|,
literal|"get psp"
block|}
block|,
block|{
literal|0x52
block|,
name|IFT_NOSUBFUNC
block|,
name|int21_NOFUNC
block|,
literal|"get LoL"
block|}
block|,
block|{
literal|0x53
block|,
name|IFT_NOSUBFUNC
block|,
name|int21_NOFUNC
block|,
literal|"translate BPB to DPB"
block|}
block|,
block|{
literal|0x54
block|,
name|IFT_NOSUBFUNC
block|,
name|int21_NULLFUNC
block|,
literal|"get verify flag"
block|}
block|,
block|{
literal|0x55
block|,
name|IFT_NOSUBFUNC
block|,
name|int21_NOFUNC
block|,
literal|"create PSP"
block|}
block|,
block|{
literal|0x56
block|,
name|IFT_NOSUBFUNC
block|,
name|int21_dirfn
block|,
literal|"rename"
block|}
block|,
block|{
literal|0x57
block|,
literal|0x00
block|,
name|int21_57_0
block|,
literal|"get mtime"
block|}
block|,
block|{
literal|0x57
block|,
literal|0x01
block|,
name|int21_57_1
block|,
literal|"set mtime"
block|}
block|,
block|{
literal|0x58
block|,
name|IFT_NOSUBFUNC
block|,
name|int21_58
block|,
literal|"get/set memory strategy"
block|}
block|,
block|{
literal|0x59
block|,
name|IFT_NOSUBFUNC
block|,
name|int21_59
block|,
literal|"get extended error information"
block|}
block|,
block|{
literal|0x5a
block|,
name|IFT_NOSUBFUNC
block|,
name|int21_5a
block|,
literal|"create temporary file"
block|}
block|,
block|{
literal|0x5b
block|,
name|IFT_NOSUBFUNC
block|,
name|int21_open
block|,
literal|"create new file"
block|}
block|,
block|{
literal|0x5c
block|,
name|IFT_NOSUBFUNC
block|,
name|int21_NOFUNC
block|,
literal|"flock"
block|}
block|,
block|{
literal|0x5d
block|,
name|IFT_NOSUBFUNC
block|,
name|int21_net
block|,
literal|"network functions"
block|}
block|,
block|{
literal|0x5e
block|,
name|IFT_NOSUBFUNC
block|,
name|int21_net
block|,
literal|"network functions"
block|}
block|,
block|{
literal|0x5f
block|,
name|IFT_NOSUBFUNC
block|,
name|int21_net
block|,
literal|"network functions"
block|}
block|,
block|{
literal|0x60
block|,
name|IFT_NOSUBFUNC
block|,
name|int21_60
block|,
literal|"canonicalise name/path"
block|}
block|,
block|{
literal|0x61
block|,
name|IFT_NOSUBFUNC
block|,
name|int21_NULLFUNC
block|,
literal|"network functions (reserved)"
block|}
block|,
block|{
literal|0x62
block|,
name|IFT_NOSUBFUNC
block|,
name|int21_62
block|,
literal|"get current PSP"
block|}
block|,
block|{
literal|0x63
block|,
name|IFT_NOSUBFUNC
block|,
name|int21_NOFUNC
block|,
literal|"get DBCS lead-byte table"
block|}
block|,
block|{
literal|0x64
block|,
name|IFT_NOSUBFUNC
block|,
name|int21_NOFUNC
block|,
literal|"set device-driver lookahead"
block|}
block|,
block|{
literal|0x65
block|,
literal|0x23
block|,
name|int21_65_23
block|,
literal|"determine yes/no"
block|}
block|,
block|{
literal|0x65
block|,
name|IFT_NOSUBFUNC
block|,
name|int21_NOFUNC
block|,
literal|"get extended country information"
block|}
block|,
block|{
literal|0x66
block|,
name|IFT_NOSUBFUNC
block|,
name|int21_NOFUNC
block|,
literal|"get/set codepage table"
block|}
block|,
block|{
literal|0x67
block|,
name|IFT_NOSUBFUNC
block|,
name|int21_NULLFUNC
block|,
literal|"set handle count"
block|}
block|,
block|{
literal|0x68
block|,
name|IFT_NOSUBFUNC
block|,
name|int21_fflush
block|,
literal|"fflush"
block|}
block|,
block|{
literal|0x69
block|,
name|IFT_NOSUBFUNC
block|,
name|int21_NOFUNC
block|,
literal|"get/set disk serial number"
block|}
block|,
block|{
literal|0x6a
block|,
name|IFT_NOSUBFUNC
block|,
name|int21_fflush
block|,
literal|"commit file"
block|}
block|,
block|{
literal|0x6b
block|,
name|IFT_NOSUBFUNC
block|,
name|int21_NULLFUNC
block|,
literal|"IFS ioctl"
block|}
block|,
block|{
literal|0x6c
block|,
name|IFT_NOSUBFUNC
block|,
name|int21_open
block|,
literal|"extended open/create"
block|}
block|,
comment|/* FCB functions */
block|{
literal|0x0f
block|,
name|IFT_NOSUBFUNC
block|,
name|int21_fcb
block|,
literal|"open file"
block|}
block|,
block|{
literal|0x10
block|,
name|IFT_NOSUBFUNC
block|,
name|int21_fcb
block|,
literal|"close file"
block|}
block|,
block|{
literal|0x11
block|,
name|IFT_NOSUBFUNC
block|,
name|int21_fcb
block|,
literal|"find first"
block|}
block|,
block|{
literal|0x12
block|,
name|IFT_NOSUBFUNC
block|,
name|int21_fcb
block|,
literal|"find next"
block|}
block|,
block|{
literal|0x13
block|,
name|IFT_NOSUBFUNC
block|,
name|int21_NOFUNC
block|,
literal|"delete"
block|}
block|,
block|{
literal|0x14
block|,
name|IFT_NOSUBFUNC
block|,
name|int21_NOFUNC
block|,
literal|"sequential read"
block|}
block|,
block|{
literal|0x15
block|,
name|IFT_NOSUBFUNC
block|,
name|int21_NOFUNC
block|,
literal|"sequential write"
block|}
block|,
block|{
literal|0x16
block|,
name|IFT_NOSUBFUNC
block|,
name|int21_fcb
block|,
literal|"create/truncate"
block|}
block|,
block|{
literal|0x17
block|,
name|IFT_NOSUBFUNC
block|,
name|int21_NOFUNC
block|,
literal|"rename"
block|}
block|,
block|{
literal|0x21
block|,
name|IFT_NOSUBFUNC
block|,
name|int21_NOFUNC
block|,
literal|"read random"
block|}
block|,
block|{
literal|0x22
block|,
name|IFT_NOSUBFUNC
block|,
name|int21_NOFUNC
block|,
literal|"write random"
block|}
block|,
block|{
literal|0x23
block|,
name|IFT_NOSUBFUNC
block|,
name|int21_NOFUNC
block|,
literal|"get file size"
block|}
block|,
block|{
literal|0x24
block|,
name|IFT_NOSUBFUNC
block|,
name|int21_NOFUNC
block|,
literal|"set random record number"
block|}
block|,
block|{
literal|0x27
block|,
name|IFT_NOSUBFUNC
block|,
name|int21_fcb
block|,
literal|"random block read"
block|}
block|,
block|{
literal|0x28
block|,
name|IFT_NOSUBFUNC
block|,
name|int21_fcb
block|,
literal|"random block write"
block|}
block|,
block|{
literal|0x29
block|,
name|IFT_NOSUBFUNC
block|,
name|int21_fcb
block|,
literal|"parse filename into FCB"
block|}
block|,
comment|/* CPM compactability */
block|{
literal|0x18
block|,
name|IFT_NOSUBFUNC
block|,
name|int21_NULLFUNC
block|,
literal|"CPM"
block|}
block|,
block|{
literal|0x1d
block|,
name|IFT_NOSUBFUNC
block|,
name|int21_NULLFUNC
block|,
literal|"CPM"
block|}
block|,
block|{
literal|0x1e
block|,
name|IFT_NOSUBFUNC
block|,
name|int21_NULLFUNC
block|,
literal|"CPM"
block|}
block|,
block|{
literal|0x20
block|,
name|IFT_NOSUBFUNC
block|,
name|int21_NULLFUNC
block|,
literal|"CPM"
block|}
block|,
block|{
operator|-
literal|1
block|,
name|IFT_NOSUBFUNC
block|,
name|NULL
block|,
name|NULL
block|}
comment|/* terminator */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|int21_fastlookup
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|dos_return
index|[]
init|=
block|{
literal|"OK"
block|,
literal|"FUNC_NUM_IVALID"
block|,
literal|"FILE_NOT_FOUND"
block|,
literal|"PATH_NOT_FOUND"
block|,
literal|"TOO_MANY_OPEN_FILES"
block|,
literal|"ACCESS_DENIED"
block|,
literal|"HANDLE_INVALID"
block|,
literal|"MEM_CB_DEST"
block|,
literal|"INSUF_MEM"
block|,
literal|"MEM_BLK_ADDR_IVALID"
block|,
literal|"ENV_INVALID"
block|,
literal|"FORMAT_INVALID"
block|,
literal|"ACCESS_CODE_INVALID"
block|,
literal|"DATA_INVALID"
block|,
literal|"UNKNOWN_UNIT"
block|,
literal|"DISK_DRIVE_INVALID"
block|,
literal|"ATT_REM_CUR_DIR"
block|,
literal|"NOT_SAME_DEV"
block|,
literal|"NO_MORE_FILES"
block|,
literal|"WRITE_PROT_DISK"
block|,
literal|"UNKNOWN_UNIT_CERR"
block|,
literal|"DRIVE_NOT_READY"
block|,
literal|"UNKNOWN_COMMAND"
block|,
literal|"DATA_ERROR_CRC"
block|,
literal|"BAD_REQ_STRUCT_LEN"
block|,
literal|"SEEK_ERROR"
block|,
literal|"UNKNOWN_MEDIA_TYPE"
block|,
literal|"SECTOR_NOT_FOUND"
block|,
literal|"PRINTER_OUT_OF_PAPER"
block|,
literal|"WRITE_FAULT"
block|,
literal|"READ_FAULT"
block|,
literal|"GENERAL_FAILURE"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|dos_ret_size
init|=
operator|(
sizeof|sizeof
argument_list|(
name|dos_return
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ** for want of anywhere better to go */
end_comment

begin_function
specifier|static
name|void
name|int20
parameter_list|(
name|regcontext_t
modifier|*
name|REGS
parameter_list|)
block|{
comment|/* int 20 = exit(0) */
name|done
argument_list|(
name|REGS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|int29
parameter_list|(
name|regcontext_t
modifier|*
name|REGS
parameter_list|)
block|{
name|tty_write
argument_list|(
name|R_AL
argument_list|,
name|TTYF_REDIRECT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************** ** entrypoint for MS-DOS functions */
end_comment

begin_function
specifier|static
name|void
name|int21
parameter_list|(
name|regcontext_t
modifier|*
name|REGS
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|int
name|idx
decl_stmt|;
comment|/* look for a handler */
name|idx
operator|=
name|intfunc_find
argument_list|(
name|int21_table
argument_list|,
name|int21_fastlookup
argument_list|,
name|R_AH
argument_list|,
name|R_AL
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* no matching functions */
name|unknown_int3
argument_list|(
literal|0x21
argument_list|,
name|R_AH
argument_list|,
name|R_AL
argument_list|,
name|REGS
argument_list|)
expr_stmt|;
name|R_FLAGS
operator||=
name|PSL_C
expr_stmt|;
comment|/* Flag an error */
name|R_AX
operator|=
literal|0xff
expr_stmt|;
return|return;
block|}
comment|/* call the handler */
name|error
operator|=
name|int21_table
index|[
name|idx
index|]
operator|.
name|handler
argument_list|(
name|REGS
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|D_DOSCALL
argument_list|,
literal|"msdos call %02x (%s) returns %d (%s)\n"
argument_list|,
name|int21_table
index|[
name|idx
index|]
operator|.
name|func
argument_list|,
name|int21_table
index|[
name|idx
index|]
operator|.
name|desc
argument_list|,
name|error
argument_list|,
operator|(
operator|(
name|error
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|error
operator|<=
name|dos_ret_size
operator|)
operator|)
condition|?
name|dos_return
index|[
name|error
index|]
else|:
literal|"unknown"
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|doserrno
operator|=
name|error
expr_stmt|;
name|R_FLAGS
operator||=
name|PSL_C
expr_stmt|;
comment|/* XXX is this entirely legitimate? */
if|if
condition|(
name|R_AH
operator|>=
literal|0x2f
condition|)
name|R_AX
operator|=
name|error
expr_stmt|;
else|else
name|R_AX
operator|=
literal|0xff
expr_stmt|;
block|}
else|else
block|{
name|R_FLAGS
operator|&=
operator|~
name|PSL_C
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|int67
parameter_list|(
name|regcontext_t
modifier|*
name|REGS
parameter_list|)
block|{
name|ems_entry
argument_list|(
name|REGS
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|u_char
name|upcase_trampoline
index|[]
init|=
block|{
literal|0xf4
block|,
comment|/* HLT */
literal|0xcb
block|,
comment|/* RETF */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ** initialise thyself */
end_comment

begin_function
name|void
name|dos_init
parameter_list|(
name|void
parameter_list|)
block|{
name|u_long
name|vec
decl_stmt|;
comment|/* hook vectors */
name|vec
operator|=
name|insert_softint_trampoline
argument_list|()
expr_stmt|;
name|ivec
index|[
literal|0x20
index|]
operator|=
name|vec
expr_stmt|;
name|register_callback
argument_list|(
name|vec
argument_list|,
name|int20
argument_list|,
literal|"int 20"
argument_list|)
expr_stmt|;
name|vec
operator|=
name|insert_softint_trampoline
argument_list|()
expr_stmt|;
name|ivec
index|[
literal|0x21
index|]
operator|=
name|vec
expr_stmt|;
name|register_callback
argument_list|(
name|vec
argument_list|,
name|int21
argument_list|,
literal|"int 21"
argument_list|)
expr_stmt|;
name|vec
operator|=
name|insert_softint_trampoline
argument_list|()
expr_stmt|;
name|ivec
index|[
literal|0x29
index|]
operator|=
name|vec
expr_stmt|;
name|register_callback
argument_list|(
name|vec
argument_list|,
name|int29
argument_list|,
literal|"int 29"
argument_list|)
expr_stmt|;
name|vec
operator|=
name|insert_softint_trampoline
argument_list|()
expr_stmt|;
name|ivec
index|[
literal|0x67
index|]
operator|=
name|vec
expr_stmt|;
name|register_callback
argument_list|(
name|vec
argument_list|,
name|int67
argument_list|,
literal|"int 67 (EMS)"
argument_list|)
expr_stmt|;
name|vec
operator|=
name|insert_null_trampoline
argument_list|()
expr_stmt|;
name|ivec
index|[
literal|0x28
index|]
operator|=
name|vec
expr_stmt|;
comment|/* dos idle */
name|ivec
index|[
literal|0x2b
index|]
operator|=
name|vec
expr_stmt|;
comment|/* reserved */
name|ivec
index|[
literal|0x2c
index|]
operator|=
name|vec
expr_stmt|;
comment|/* reserved */
name|ivec
index|[
literal|0x2d
index|]
operator|=
name|vec
expr_stmt|;
comment|/* reserved */
name|upcase_vector
operator|=
name|insert_generic_trampoline
argument_list|(
sizeof|sizeof
argument_list|(
name|upcase_trampoline
argument_list|)
argument_list|,
name|upcase_trampoline
argument_list|)
expr_stmt|;
name|register_callback
argument_list|(
name|upcase_vector
argument_list|,
name|upcase_entry
argument_list|,
literal|"upcase"
argument_list|)
expr_stmt|;
comment|/* build fastlookup index into the monster table of interrupts */
name|intfunc_init
argument_list|(
name|int21_table
argument_list|,
name|int21_fastlookup
argument_list|)
expr_stmt|;
name|ems_init
argument_list|()
expr_stmt|;
block|}
end_function

end_unit

