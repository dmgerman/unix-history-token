begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ** Copyright (c) 1996 **	Michael Smith.  All rights reserved. ** ** Redistribution and use in source and binary forms, with or without ** modification, are permitted provided that the following conditions ** are met: ** 1. Redistributions of source code must retain the above copyright **    notice, this list of conditions and the following disclaimer. ** 2. Redistributions in binary form must reproduce the above copyright **    notice, this list of conditions and the following disclaimer in the **    documentation and/or other materials provided with the distribution. ** ** THIS SOFTWARE IS PROVIDED BY Michael Smith ``AS IS'' AND ** ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE ** IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ** ARE DISCLAIMED.  IN NO EVENT SHALL Michael Smith BE LIABLE ** FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL ** DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS ** OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) ** HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT ** LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY ** OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF ** SUCH DAMAGE. ** ** $FreeBSD$ */
end_comment

begin_comment
comment|/* ** Interrupt dispatcher assistants. */
end_comment

begin_comment
comment|/* ** Declare a static, initialised array of these, with one ** entry per function/subfunction. ** ** The last element should be a dummy with a 'func' of -1 */
end_comment

begin_struct
struct|struct
name|intfunc_table
block|{
name|int
name|func
decl_stmt|;
comment|/* interrupt function number */
name|int
name|subfunc
decl_stmt|;
comment|/* subfunction number */
name|int
function_decl|(
modifier|*
name|handler
function_decl|)
parameter_list|(
name|regcontext_t
modifier|*
name|REGS
parameter_list|)
function_decl|;
comment|/* handling function */
specifier|const
name|char
modifier|*
name|desc
decl_stmt|;
comment|/* textual description */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|IFT_NOSUBFUNC
value|-1
end_define

begin_comment
comment|/* ** Declare a static array of 256 integers to use as a fast lookup  ** into the table of handlers. ** ** Call this function to initialise the lookup.  Note that the table ** must be arranged with all handlers for a given function together, and ** that the handler listed with IFT_NOSUBFUNC should be last. */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|intfunc_init
parameter_list|(
name|struct
name|intfunc_table
name|table
index|[]
parameter_list|,
name|int
name|idx
index|[]
parameter_list|)
block|{
name|int
name|hn
decl_stmt|;
for|for
control|(
name|hn
operator|=
literal|0
init|;
name|hn
operator|<
literal|256
condition|;
name|hn
operator|++
control|)
comment|/* initialise all no-handler state */
name|idx
index|[
name|hn
index|]
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* default to no handler */
for|for
control|(
name|hn
operator|=
literal|0
init|;
name|table
index|[
name|hn
index|]
operator|.
name|func
operator|>=
literal|0
condition|;
name|hn
operator|++
control|)
comment|/* walk list of handlers and add references */
if|if
condition|(
name|idx
index|[
name|table
index|[
name|hn
index|]
operator|.
name|func
index|]
operator|==
operator|-
literal|1
condition|)
comment|/* reference first handler */
name|idx
index|[
name|table
index|[
name|hn
index|]
operator|.
name|func
index|]
operator|=
name|hn
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** Call this to get an index matching the function/subfunction  ** described by (sc), or -1 if none exist */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|intfunc_find
parameter_list|(
name|struct
name|intfunc_table
name|table
index|[]
parameter_list|,
name|int
name|idx
index|[]
parameter_list|,
name|int
name|func
parameter_list|,
name|int
name|subfunc
parameter_list|)
block|{
name|int
name|ent
init|=
name|idx
index|[
name|func
index|]
decl_stmt|;
comment|/* look for handler */
while|while
condition|(
operator|(
name|ent
operator|>=
literal|0
operator|)
operator|&&
comment|/* scan entries for function */
operator|(
name|table
index|[
name|ent
index|]
operator|.
name|func
operator|==
name|func
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|table
index|[
name|ent
index|]
operator|.
name|subfunc
operator|==
name|IFT_NOSUBFUNC
operator|)
operator|||
comment|/* handles all */
operator|(
name|table
index|[
name|ent
index|]
operator|.
name|subfunc
operator|==
name|subfunc
operator|)
condition|)
block|{
comment|/* handles this one */
return|return
operator|(
name|ent
operator|)
return|;
block|}
name|ent
operator|++
expr_stmt|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** A slower lookup for a set of function handlers, but one that requires ** no initialisation calls. ** Again, handlers with IFT_NOSUBFUNC should be listed after any with ** specific subfunction values. */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|intfunc_search
parameter_list|(
name|struct
name|intfunc_table
name|table
index|[]
parameter_list|,
name|int
name|func
parameter_list|,
name|int
name|subfunc
parameter_list|)
block|{
name|int
name|ent
decl_stmt|;
for|for
control|(
name|ent
operator|=
literal|0
init|;
name|table
index|[
name|ent
index|]
operator|.
name|func
operator|>=
literal|0
condition|;
name|ent
operator|++
control|)
if|if
condition|(
operator|(
name|table
index|[
name|ent
index|]
operator|.
name|func
operator|==
name|func
operator|)
operator|&&
comment|/* matches required function */
operator|(
operator|(
name|table
index|[
name|ent
index|]
operator|.
name|subfunc
operator|==
name|IFT_NOSUBFUNC
operator|)
operator|||
name|table
index|[
name|ent
index|]
operator|.
name|subfunc
operator|==
name|subfunc
operator|)
condition|)
return|return
operator|(
name|ent
operator|)
return|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

end_unit

