begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1992, 1993, 1996  *	Berkeley Software Design, Inc.  All rights reserved.  *  * This code is derived from software contributed to Berkeley Software  * Design, Inc. by Mark Linoman.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by Berkeley Software  *	Design, Inc.  *  * THIS SOFTWARE IS PROVIDED BY Berkeley Software Design, Inc. ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL Berkeley Software Design, Inc. BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	BSDI int14.c,v 2.2 1996/04/08 19:32:45 bostic Exp  *  * $Id: int14.c,v 1.3 1996/09/22 15:42:53 miff Exp $  */
end_comment

begin_include
include|#
directive|include
file|"doscmd.h"
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<termios.h>
end_include

begin_include
include|#
directive|include
file|"com.h"
end_include

begin_decl_stmt
name|struct
name|com_data_struct
name|com_data
index|[
name|N_COMS_MAX
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|struct
name|queue
modifier|*
name|create_queue
parameter_list|()
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|get_char_q
parameter_list|()
block|{}
end_function

begin_function
name|int
name|queue_not_empty
parameter_list|()
block|{}
end_function

begin_function
name|int
name|reset_irq_request
parameter_list|()
block|{}
end_function

begin_function
name|int
name|set_irq_request
parameter_list|()
block|{}
end_function

begin_function
name|int
name|test_irq_request
parameter_list|()
block|{}
end_function

begin_function
name|int
name|write_div_latches
parameter_list|()
block|{}
end_function

begin_function
name|void
name|int14
parameter_list|(
name|regcontext_t
modifier|*
name|REGS
parameter_list|)
block|{
name|int
name|reg_num
decl_stmt|;
name|struct
name|com_data_struct
modifier|*
name|cdsp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|nbytes
decl_stmt|;
name|char
name|c
decl_stmt|;
name|debug
argument_list|(
name|D_PORT
argument_list|,
literal|"int14: dl = 0x%02X, al = 0x%02X.\n"
argument_list|,
name|R_DL
argument_list|,
name|R_AL
argument_list|)
expr_stmt|;
if|if
condition|(
name|R_DL
operator|>=
name|N_COMS_MAX
condition|)
block|{
if|if
condition|(
name|vflag
condition|)
name|dump_regs
argument_list|(
name|REGS
argument_list|)
expr_stmt|;
name|fatal
argument_list|(
literal|"int14: illegal com port COM%d"
argument_list|,
name|R_DL
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|cdsp
operator|=
operator|&
operator|(
name|com_data
index|[
name|R_DL
index|]
operator|)
expr_stmt|;
switch|switch
condition|(
name|R_AH
condition|)
block|{
case|case
literal|0x00
case|:
comment|/* Initialize Serial Port */
if|#
directive|if
literal|0
comment|/* hold off: try to defeat stupid DOS defaults */
block|com_set_line(cdsp, R_DL + 1, R_AL); 	R_AH = LS_X_SHFT_E | LS_X_HOLD_E; 	R_AL = 0;
endif|#
directive|endif
endif|0
break|break;
case|case
literal|0x01
case|:
comment|/* Write Character */
name|errno
operator|=
literal|0
expr_stmt|;
name|c
operator|=
name|R_AL
expr_stmt|;
name|nbytes
operator|=
name|write
argument_list|(
name|cdsp
operator|->
name|fd
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|D_PORT
argument_list|,
literal|"write of 0x%02x to fd %d on '%s' returned %d %s\n"
argument_list|,
name|R_AL
argument_list|,
name|cdsp
operator|->
name|fd
argument_list|,
name|cdsp
operator|->
name|path
argument_list|,
name|nbytes
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbytes
operator|==
literal|1
condition|)
block|{
name|R_AH
operator|=
name|LS_X_SHFT_E
operator||
name|LS_X_HOLD_E
expr_stmt|;
name|R_AL
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|debug
argument_list|(
name|D_PORT
argument_list|,
literal|"int14: lost output character 0x%02x\n"
argument_list|,
name|R_AL
argument_list|)
expr_stmt|;
name|R_AH
operator|=
name|LS_SW_TIME_OUT
expr_stmt|;
name|R_AL
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
literal|0x02
case|:
comment|/* Read Character */
name|errno
operator|=
literal|0
expr_stmt|;
name|nbytes
operator|=
name|read
argument_list|(
name|cdsp
operator|->
name|fd
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|D_PORT
argument_list|,
literal|"read of fd %d on '%s' returned %d byte 0x%02x %s\n"
argument_list|,
name|cdsp
operator|->
name|fd
argument_list|,
name|cdsp
operator|->
name|path
argument_list|,
name|nbytes
argument_list|,
name|c
argument_list|,
name|errno
condition|?
name|strerror
argument_list|(
name|errno
argument_list|)
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbytes
operator|==
literal|1
condition|)
block|{
name|R_AH
operator|=
name|LS_X_SHFT_E
operator||
name|LS_X_HOLD_E
expr_stmt|;
name|R_AL
operator|=
name|c
expr_stmt|;
block|}
else|else
block|{
name|R_AH
operator|=
name|LS_SW_TIME_OUT
expr_stmt|;
name|R_AL
operator|=
literal|0x60
expr_stmt|;
block|}
break|break;
case|case
literal|0x03
case|:
comment|/* Status Request */
name|R_AX
operator|=
operator|(
name|LS_X_SHFT_E
operator||
name|LS_X_HOLD_E
operator|)
operator|<<
literal|8
expr_stmt|;
break|break;
case|case
literal|0x04
case|:
comment|/* Extended Initialization */
name|R_AX
operator|=
operator|(
name|LS_SW_TIME_OUT
operator|)
operator|<<
literal|8
expr_stmt|;
break|break;
case|case
literal|0x05
case|:
comment|/* Modem Control Register operations */
switch|switch
condition|(
name|R_AH
condition|)
block|{
case|case
literal|0x00
case|:
comment|/* Read Modem Control Register */
name|R_AX
operator|=
operator|(
name|LS_SW_TIME_OUT
operator|)
operator|<<
literal|8
expr_stmt|;
break|break;
case|case
literal|0x01
case|:
comment|/* Write Modem Control Register */
name|R_AX
operator|=
operator|(
name|LS_SW_TIME_OUT
operator|)
operator|<<
literal|8
expr_stmt|;
break|break;
default|default:
name|unknown_int3
argument_list|(
literal|0x14
argument_list|,
literal|0x05
argument_list|,
name|R_AL
argument_list|,
name|REGS
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|unknown_int2
argument_list|(
literal|0x14
argument_list|,
name|R_AH
argument_list|,
name|REGS
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* called when doscmd initializes a single line */
end_comment

begin_function
name|void
name|com_set_line
parameter_list|(
name|struct
name|com_data_struct
modifier|*
name|cdsp
parameter_list|,
name|unsigned
name|char
name|port
parameter_list|,
name|unsigned
name|char
name|param
parameter_list|)
block|{
name|struct
name|termios
name|tty
decl_stmt|;
name|struct
name|stat
name|stat_buf
decl_stmt|;
name|int
name|mode
init|=
literal|0
decl_stmt|;
comment|/* read|write */
name|int
name|speed
decl_stmt|;
name|int
name|reg_num
decl_stmt|;
name|int
name|ret_val
decl_stmt|;
name|debug
argument_list|(
name|D_PORT
argument_list|,
literal|"com_set_line: cdsp = 0x%08X, port = 0x%04x,"
literal|"param = 0x%04X.\n"
argument_list|,
name|cdsp
argument_list|,
name|port
argument_list|,
name|param
argument_list|)
expr_stmt|;
if|if
condition|(
name|cdsp
operator|->
name|fd
operator|>
literal|0
condition|)
block|{
name|debug
argument_list|(
name|D_PORT
argument_list|,
literal|"Re-initialize serial port com%d\n"
argument_list|,
name|port
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|cdsp
operator|->
name|fd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|debug
argument_list|(
name|D_PORT
argument_list|,
literal|"Initialize serial port com%d\n"
argument_list|,
name|port
argument_list|)
expr_stmt|;
block|}
name|stat
argument_list|(
name|cdsp
operator|->
name|path
argument_list|,
operator|&
name|stat_buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|S_ISCHR
argument_list|(
name|stat_buf
operator|.
name|st_mode
argument_list|)
operator|||
operator|(
operator|(
name|cdsp
operator|->
name|fd
operator|=
name|open
argument_list|(
name|cdsp
operator|->
name|path
argument_list|,
name|O_RDWR
operator||
name|O_NONBLOCK
argument_list|,
literal|0666
argument_list|)
operator|)
operator|==
operator|-
literal|1
operator|)
condition|)
block|{
name|debug
argument_list|(
name|D_PORT
argument_list|,
literal|"Could not initialize serial port com%d on path '%s'\n"
argument_list|,
name|port
argument_list|,
name|cdsp
operator|->
name|path
argument_list|)
expr_stmt|;
return|return;
block|}
name|cdsp
operator|->
name|flags
operator|=
literal|0x00
expr_stmt|;
name|cdsp
operator|->
name|last_char_read
operator|=
literal|0x00
expr_stmt|;
if|#
directive|if
literal|0
block|if ((param& PARITY_EVEN) == PARITY_NONE) 	    tty.c_iflag = IGNBRK | IGNPAR | IXON | IXOFF
comment|/* | IXANY */
block|;     else 	    tty.c_iflag = IGNBRK | IXON | IXOFF
comment|/* | IXANY */
block|;     tty.c_oflag = 0;                tty.c_lflag = 0;     tty.c_cc[VTIME] = 0;      tty.c_cc[VMIN] = 1;     tty.c_cflag = CREAD | CLOCAL | HUPCL;
comment|/* MCL WHY CLOCAL ??????; but, gets errno EIO on writes, else */
block|if ((param& TXLEN_8BITS) == TXLEN_8BITS) 	    tty.c_cflag |= CS8;     else 	    tty.c_cflag |= CS7;     if ((param& STOPBIT_2) == STOPBIT_2) 	    tty.c_cflag |= CSTOPB;     switch (param& PARITY_EVEN) { 	    case (PARITY_ODD): 		    tty.c_cflag |= (PARENB | PARODD); 		    break; 	    case (PARITY_EVEN): 		    tty.c_cflag |= PARENB; 		    break; 	    case (PARITY_NONE): 	    default: 		    break;     }     switch (param& BITRATE_9600) {     case (BITRATE_110): 	speed = B110; 	break;     case (BITRATE_150): 	speed = B150; 	break;     case (BITRATE_300): 	speed = B300; 	break;     case (BITRATE_600): 	speed = B600; 	break;     case (BITRATE_1200): 	speed = B1200; 	break;     case (BITRATE_2400): 	speed = B2400; 	break;     case (BITRATE_4800): 	speed = B4800; 	break;     case (BITRATE_9600): 	speed = B9600; 	break;     }     debug (D_PORT, "com_set_line: going with cflag 0x%X iflag 0x%X speed %d.\n",     tty.c_cflag, tty.c_iflag, speed);     errno = 0;     ret_val = cfsetispeed(&tty, speed);     debug (D_PORT, "com_set_line: cfsetispeed returned 0x%X.\n", ret_val);     errno = 0;     ret_val = cfsetospeed(&tty, speed);     debug (D_PORT, "com_set_line: cfsetospeed returned 0x%X.\n", ret_val);     errno = 0;     ret_val = tcsetattr(cdsp->fd, 0,&tty);     debug (D_PORT, "com_set_line: tcsetattr returned 0x%X.\n", ret_val);      errno = 0;     ret_val = fcntl(cdsp->fd, F_SETFL, O_NDELAY);     debug (D_PORT, "fcntl of 0x%X, 0x%X to fd %d returned %d errno %d\n",     F_SETFL, O_NDELAY, cdsp->fd, ret_val, errno);     errno = 0;     ret_val = ioctl(cdsp->fd, TIOCFLUSH,&mode);     debug (D_PORT, "ioctl of 0x%02x to fd %d on 0x%X returned %d errno %d\n",     TIOCFLUSH, cdsp->fd, mode, ret_val, errno);
endif|#
directive|endif
for|for
control|(
name|reg_num
operator|=
literal|0
init|;
name|reg_num
operator|<
name|N_OF_COM_REGS
condition|;
name|reg_num
operator|++
control|)
block|{
name|define_input_port_handler
argument_list|(
name|cdsp
operator|->
name|addr
operator|+
name|reg_num
argument_list|,
name|com_port_in
argument_list|)
expr_stmt|;
name|define_output_port_handler
argument_list|(
name|cdsp
operator|->
name|addr
operator|+
name|reg_num
argument_list|,
name|com_port_out
argument_list|)
expr_stmt|;
block|}
name|cdsp
operator|->
name|com_queue
operator|=
name|create_queue
argument_list|(
name|cdsp
operator|->
name|irq
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|D_PORT
argument_list|,
literal|"com%d: attached '%s' at addr 0x%04x irq %d\n"
argument_list|,
name|port
argument_list|,
name|cdsp
operator|->
name|path
argument_list|,
name|cdsp
operator|->
name|addr
argument_list|,
name|cdsp
operator|->
name|irq
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* called when config.c initializes a single line */
end_comment

begin_function
name|void
name|init_com
parameter_list|(
name|int
name|port
parameter_list|,
name|char
modifier|*
name|path
parameter_list|,
name|int
name|addr
parameter_list|,
name|unsigned
name|char
name|irq
parameter_list|)
block|{
name|struct
name|com_data_struct
modifier|*
name|cdsp
decl_stmt|;
name|debug
argument_list|(
name|D_PORT
argument_list|,
literal|"init_com: port = 0x%04x, addr = 0x%04X, irq = %d.\n"
argument_list|,
name|port
argument_list|,
name|addr
argument_list|,
name|irq
argument_list|)
expr_stmt|;
name|cdsp
operator|=
operator|&
operator|(
name|com_data
index|[
name|port
index|]
operator|)
expr_stmt|;
name|cdsp
operator|->
name|path
operator|=
name|path
expr_stmt|;
comment|/* XXX DEBUG strcpy? */
name|cdsp
operator|->
name|addr
operator|=
name|addr
expr_stmt|;
name|cdsp
operator|->
name|irq
operator|=
name|irq
expr_stmt|;
name|cdsp
operator|->
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
name|com_set_line
argument_list|(
name|cdsp
argument_list|,
name|port
operator|+
literal|1
argument_list|,
name|TXLEN_8BITS
operator||
name|BITRATE_9600
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* called when DOS wants to read directly from a physical port */
end_comment

begin_function
name|unsigned
name|char
name|com_port_in
parameter_list|(
name|int
name|port
parameter_list|)
block|{
name|struct
name|com_data_struct
modifier|*
name|cdsp
decl_stmt|;
name|unsigned
name|char
name|rs
decl_stmt|;
name|unsigned
name|char
name|i
decl_stmt|;
name|int
name|nbytes
decl_stmt|;
comment|/* search for a valid COM ???or MOUSE??? port */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N_COMS_MAX
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|com_data
index|[
name|i
index|]
operator|.
name|addr
operator|==
operator|(
operator|(
name|unsigned
name|short
operator|)
name|port
operator|&
literal|0xfff8
operator|)
condition|)
block|{
name|cdsp
operator|=
operator|&
operator|(
name|com_data
index|[
name|i
index|]
operator|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
name|N_COMS_MAX
condition|)
block|{
name|debug
argument_list|(
name|D_PORT
argument_list|,
literal|"com port 0x%04x not found\n"
argument_list|,
name|port
argument_list|)
expr_stmt|;
return|return
literal|0xff
return|;
block|}
switch|switch
condition|(
name|port
operator|-
name|cdsp
operator|->
name|addr
condition|)
block|{
comment|/* 0x03F8 - (receive buffer) or (divisor latch LO) */
case|case
literal|0
case|:
if|if
condition|(
name|cdsp
operator|->
name|line_ctrl
operator|&
name|LC_DIV_ACC
condition|)
name|rs
operator|=
name|cdsp
operator|->
name|div_latch
index|[
name|DIV_LATCH_LOW
index|]
expr_stmt|;
else|else
block|{
if|#
directive|if
literal|0
block|if (queue_not_empty(cdsp->com_queue)) { 		rs = get_char_q(cdsp->com_queue); 		cdsp->last_char_read = rs; 		if (queue_not_empty(cdsp->com_queue)&& 		    (cdsp->int_enable& IE_RCV_DATA) != 0) { 		    debug(D_PORT, 			  "com_port_in: setting irq %d because bytes yet to be read.\n", 			  cdsp->irq); 		    set_irq_request(cdsp->irq); 		} 	    } else
else|#
directive|else
name|errno
operator|=
literal|0
expr_stmt|;
name|nbytes
operator|=
name|read
argument_list|(
name|cdsp
operator|->
name|fd
argument_list|,
operator|&
name|rs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|D_PORT
argument_list|,
literal|"read of fd %d on '%s' returned %d byte 0x%02x errno %d\n"
argument_list|,
name|cdsp
operator|->
name|fd
argument_list|,
name|cdsp
operator|->
name|path
argument_list|,
name|nbytes
argument_list|,
name|rs
argument_list|,
name|errno
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbytes
operator|!=
literal|1
condition|)
endif|#
directive|endif
name|rs
operator|=
name|cdsp
operator|->
name|last_char_read
expr_stmt|;
block|}
break|break;
comment|/* 0x03F9 - (interrupt enable) or (divisor latch HI) */
case|case
literal|1
case|:
if|if
condition|(
name|cdsp
operator|->
name|line_ctrl
operator|&
name|LC_DIV_ACC
condition|)
name|rs
operator|=
name|cdsp
operator|->
name|div_latch
index|[
name|DIV_LATCH_HIGH
index|]
expr_stmt|;
else|else
name|rs
operator|=
name|cdsp
operator|->
name|int_enable
expr_stmt|;
comment|/* 0x03FA - interrupt identification register */
case|case
literal|2
case|:
comment|/* rs = cdsp->int_id;	* XXX DEBUG not initialized */
name|rs
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|queue_not_empty
argument_list|(
name|cdsp
operator|->
name|com_queue
argument_list|)
operator|)
operator|&&
operator|(
name|test_irq_request
argument_list|(
name|cdsp
operator|->
name|irq
argument_list|)
operator|!=
literal|0
operator|)
condition|)
name|rs
operator||=
name|II_PEND_INT
operator||
name|II_RCV_DATA
expr_stmt|;
if|if
condition|(
operator|(
name|cdsp
operator|->
name|fifo_ctrl
operator|&
name|FC_FIFO_EN
operator|)
operator|==
name|FC_FIFO_EN
condition|)
name|rs
operator||=
name|II_FIFOS_EN
expr_stmt|;
break|break;
comment|/* 0x03FB - line control register */
case|case
literal|3
case|:
name|rs
operator|=
name|cdsp
operator|->
name|line_ctrl
expr_stmt|;
break|break;
comment|/* 0x03FC - modem control register */
case|case
literal|4
case|:
name|rs
operator|=
name|cdsp
operator|->
name|modem_ctrl
expr_stmt|;
break|break;
comment|/* 0x03FD - line status register */
case|case
literal|5
case|:
name|rs
operator|=
name|LS_X_SHFT_E
operator||
name|LS_X_HOLD_E
expr_stmt|;
comment|/* if (queue_not_empty(cdsp->com_queue)) */
name|ioctl
argument_list|(
name|cdsp
operator|->
name|fd
argument_list|,
name|FIONREAD
argument_list|,
operator|&
name|nbytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbytes
operator|>
literal|0
condition|)
empty_stmt|;
name|rs
operator||=
name|LS_RCV_DATA_RD
expr_stmt|;
break|break;
comment|/* 0x03FE - modem status register */
case|case
literal|6
case|:
name|rs
operator|=
name|cdsp
operator|->
name|modem_stat
operator||
name|MS_DCD
operator||
name|MS_DSR
operator||
name|MS_CTS
expr_stmt|;
break|break;
comment|/* 0x03FF - spare register */
case|case
literal|7
case|:
name|rs
operator|=
name|cdsp
operator|->
name|uart_spare
expr_stmt|;
break|break;
default|default:
name|debug
argument_list|(
name|D_PORT
argument_list|,
literal|"com_port_in: illegal port index 0x%04x - 0x%04x\n"
argument_list|,
name|port
argument_list|,
name|cdsp
operator|->
name|addr
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|rs
return|;
block|}
end_function

begin_comment
comment|/* called when DOS wants to write directly to a physical port */
end_comment

begin_function
name|void
name|com_port_out
parameter_list|(
name|int
name|port
parameter_list|,
name|unsigned
name|char
name|val
parameter_list|)
block|{
name|struct
name|com_data_struct
modifier|*
name|cdsp
decl_stmt|;
name|int
name|nbytes
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* search for a valid COM ???or MOUSE??? port */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N_COMS_MAX
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|com_data
index|[
name|i
index|]
operator|.
name|addr
operator|==
operator|(
operator|(
name|unsigned
name|short
operator|)
name|port
operator|&
literal|0xfff8
operator|)
condition|)
block|{
name|cdsp
operator|=
operator|&
operator|(
name|com_data
index|[
name|i
index|]
operator|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
name|N_COMS_MAX
condition|)
block|{
name|debug
argument_list|(
name|D_PORT
argument_list|,
literal|"com port 0x%04x not found\n"
argument_list|,
name|port
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|port
operator|-
name|cdsp
operator|->
name|addr
condition|)
block|{
comment|/* 0x03F8 - (transmit buffer) or (divisor latch LO) */
case|case
literal|0
case|:
if|if
condition|(
name|cdsp
operator|->
name|line_ctrl
operator|&
name|LC_DIV_ACC
condition|)
block|{
name|cdsp
operator|->
name|div_latch
index|[
name|DIV_LATCH_LOW
index|]
operator|=
name|val
expr_stmt|;
name|cdsp
operator|->
name|flags
operator||=
name|DIV_LATCH_LOW_WRITTEN
expr_stmt|;
name|write_div_latches
argument_list|(
name|cdsp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|errno
operator|=
literal|0
expr_stmt|;
name|nbytes
operator|=
name|write
argument_list|(
name|cdsp
operator|->
name|fd
argument_list|,
name|val
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|D_PORT
argument_list|,
literal|"write of 0x%02x to fd %d on '%s' returned %d errno %d\n"
argument_list|,
name|val
argument_list|,
name|cdsp
operator|->
name|fd
argument_list|,
name|cdsp
operator|->
name|path
argument_list|,
name|nbytes
argument_list|,
name|errno
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbytes
operator|!=
literal|1
condition|)
name|debug
argument_list|(
name|D_PORT
argument_list|,
literal|"int14: lost output character 0x%02x\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* 0x03F9 - (interrupt enable) or (divisor latch HI) */
case|case
literal|1
case|:
if|if
condition|(
name|cdsp
operator|->
name|line_ctrl
operator|&
name|LC_DIV_ACC
condition|)
block|{
name|cdsp
operator|->
name|div_latch
index|[
name|DIV_LATCH_HIGH
index|]
operator|=
name|val
expr_stmt|;
name|cdsp
operator|->
name|flags
operator||=
name|DIV_LATCH_HIGH_WRITTEN
expr_stmt|;
name|write_div_latches
argument_list|(
name|cdsp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cdsp
operator|->
name|int_enable
operator|=
name|val
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|&
name|IE_RCV_DATA
operator|)
operator|==
literal|0
condition|)
block|{
name|reset_irq_request
argument_list|(
name|cdsp
operator|->
name|irq
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|queue_not_empty
argument_list|(
name|cdsp
operator|->
name|com_queue
argument_list|)
condition|)
block|{
name|set_irq_request
argument_list|(
name|cdsp
operator|->
name|irq
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
comment|/* 0x03FA - FIFO control register */
case|case
literal|2
case|:
name|cdsp
operator|->
name|fifo_ctrl
operator|=
name|val
expr_stmt|;
break|break;
comment|/* 0x03FB - line control register */
case|case
literal|3
case|:
name|cdsp
operator|->
name|line_ctrl
operator|=
name|val
expr_stmt|;
break|break;
comment|/* 0x03FC - modem control register */
case|case
literal|4
case|:
name|cdsp
operator|->
name|modem_ctrl
operator|=
name|val
expr_stmt|;
break|break;
comment|/* 0x03FD - line status register */
case|case
literal|5
case|:
name|cdsp
operator|->
name|line_stat
operator|=
name|val
expr_stmt|;
break|break;
comment|/* 0x03FE - modem status register */
case|case
literal|6
case|:
name|cdsp
operator|->
name|modem_stat
operator|=
name|val
expr_stmt|;
break|break;
comment|/* 0x03FF - spare register */
case|case
literal|7
case|:
name|cdsp
operator|->
name|uart_spare
operator|=
name|val
expr_stmt|;
break|break;
default|default:
name|debug
argument_list|(
name|D_PORT
argument_list|,
literal|"com_port_out: illegal port index 0x%04x - 0x%04x\n"
argument_list|,
name|port
argument_list|,
name|cdsp
operator|->
name|addr
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/*  * called when BSD has bytes ready (as discovered via select) for DOS  */
end_comment

begin_endif
unit|static void do_com_input(int fd) {     struct com_data_struct *cdsp;     unsigned char buffer[BUFSIZE];     int i, nbytes;          dp = search_com_device_by_fd(fd);     if (dp == NULL) 	return;     do { 	nbytes = read(cdsp->fd, buffer, BUFSIZE); 	if (nbytes> 0) { 	    debug(D_PORT, "do_com_input: read %d bytes from fd %d (aka %d): ", 		  nbytes, fd, cdsp->fd); 	    for (i = 0; i< nbytes; i++) { 		put_char_q(cdsp->com_queue, buffer[i]); 		if (cdsp->int_enable& IE_RCV_DATA) { 		    debug(D_PORT, "\n"); 		    debug(D_PORT, "do_com_input: setting irq %d because %d bytes read.\n", 			  dp->irq, nbytes); 		    debug(D_PORT, "do_com_input: "); 		    set_irq_request(dp->irq); 		} 		debug(D_PORT, "%02x ", buffer[i]); 	    } 	    debug(D_PORT, "\n"); 	}     } while (nbytes == BUFSIZE); }
endif|#
directive|endif
endif|0
end_endif

end_unit

