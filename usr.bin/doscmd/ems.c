begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1997 Helmut Wirth<hfwirth@ping.at>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice immediately at the beginning of the file, witout modification,  *    this list of conditions, and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT   * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_comment
comment|/*   * EMS memory emulation  *  * To emulate Expanded Memory we use a DOS driver (emsdriv.sys) which  * routes calls to int 0x67 to this emulator routine. The main entry point  * is ems_entry(..). The emulator needs to be initialized before the first  * call. The first step of the initialization is done during program startup  * the second part is done during DOS boot, from a call of the DOS driver.  * The DOS driver is neccessary because DOS programs look for it to  * determine if EMS is available.  *  * To emulate a configurable amount of EMS memory we use a file created  * at startup with the size of the configured EMS memory. This file is  * mapped into the EMS window like any DOS memory manager would do, using  * mmap calls.  *  * The emulation follows the LIM EMS 4.0 standard. Not all functions of it  * are implemented yet. The "alter page map and jump" and "alter page map  * and call" functions are not implemented, because they are rather hard to  * do. (It would mean a call to the emulator executes a routine in EMS   * memory and returns to the emulator, the emulator switches the page map  * and then returns to the DOS program.) LINUX does not emulate this   * functions and I think they were very rarely used by DOS applications.  *  * Credits: To the writers of LINUX dosemu, I looked at their code  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"doscmd.h"
end_include

begin_include
include|#
directive|include
file|"ems.h"
end_include

begin_comment
comment|/* Will be configurable */
end_comment

begin_decl_stmt
name|u_long
name|ems_max_size
init|=
name|EMS_MAXSIZE
operator|*
literal|1024
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_long
name|ems_frame_addr
init|=
name|EMS_FRAME_ADDR
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Method for EMS: Allocate a mapfile with the size of EMS memory  * and map the needed part into the page frame   */
end_comment

begin_define
define|#
directive|define
name|EMS_MAP_PATH
value|"/var/tmp/"
end_define

begin_comment
comment|/* Use a big file system */
end_comment

begin_define
define|#
directive|define
name|EMS_MAP_FILE
value|"doscmd.XXXXXX"
end_define

begin_decl_stmt
specifier|static
name|int
name|mapfile_fd
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pages are always 16 kB in size. The page frame is 64 kB, there are  * 4 positions (0..3) for a page to map in. The pages are numbered from 0 to  * the highest 16 kB page in the mapfile, depending on the EMS size  */
end_comment

begin_decl_stmt
name|EMS_mapping_context
name|ems_mapping_context
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Handle and page management (see ems.h) */
end_comment

begin_comment
comment|/* The handle array. If the pointer is NULL, the handle is unallocated */
end_comment

begin_decl_stmt
specifier|static
name|EMS_handle
modifier|*
name|ems_handle
index|[
name|EMS_NUM_HANDLES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_long
name|ems_alloc_handles
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The active handle, if any */
end_comment

begin_decl_stmt
specifier|static
name|short
name|active_handle
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The page array. It is malloced at runtime, depending on the total  * allocation size  */
end_comment

begin_decl_stmt
specifier|static
name|EMS_page
modifier|*
name|ems_page
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_long
name|ems_total_pages
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_long
name|ems_alloc_pages
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_long
name|ems_free_pages
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Local structure used for region copy and move operations */
end_comment

begin_struct
struct|struct
name|copydesc
block|{
define|#
directive|define
name|SRC_EMS
value|1
define|#
directive|define
name|DST_EMS
value|2
name|short
name|copytype
decl_stmt|;
comment|/* Type of source and destination memory */
name|EMS_addr
name|src_addr
decl_stmt|;
comment|/* Combined pointer for source */
name|EMS_addr
name|dst_addr
decl_stmt|;
comment|/* Combined pointer for destination */
name|u_long
name|rest_len
decl_stmt|;
comment|/* Lenght to copy */
block|}
struct|;
end_struct

begin_comment
comment|/* Local prototypes */
end_comment

begin_function_decl
specifier|static
name|int
name|init_mapfile
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|map_page
parameter_list|(
name|u_long
name|pagenum
parameter_list|,
name|u_char
name|position
parameter_list|,
name|short
name|handle
parameter_list|,
name|int
name|unmaponly
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|EMS_handle
modifier|*
name|get_new_handle
parameter_list|(
name|long
name|npages
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|context_to_handle
parameter_list|(
name|short
name|handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|long
name|find_next_free_handle
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|short
name|lookup_handle
parameter_list|(
name|Hname
modifier|*
name|hp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|allocate_pages_to_handle
parameter_list|(
name|u_short
name|handle
parameter_list|,
name|long
name|npages
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|allocate_handle
parameter_list|(
name|short
name|handle
parameter_list|,
name|long
name|npages
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|reallocate_pages_to_handle
parameter_list|(
name|u_short
name|handle
parameter_list|,
name|long
name|npages
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_handle
parameter_list|(
name|short
name|handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_pages_of_handle
parameter_list|(
name|short
name|handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|restore_context
parameter_list|(
name|EMS_mapping_context
modifier|*
name|emc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|save_context_to_dos
parameter_list|(
name|EMScontext
modifier|*
name|emp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|check_saved_context
parameter_list|(
name|EMScontext
modifier|*
name|emp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|get_valid_pointer
parameter_list|(
name|u_short
name|seg
parameter_list|,
name|u_short
name|offs
parameter_list|,
name|u_long
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_long
name|move_ems_to_conv
parameter_list|(
name|short
name|handle
parameter_list|,
name|u_short
name|src_seg
parameter_list|,
name|u_short
name|src_offset
parameter_list|,
name|u_long
name|dst_addr
parameter_list|,
name|u_long
name|length
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_long
name|move_conv_to_ems
parameter_list|(
name|u_long
name|src_addr
parameter_list|,
name|u_short
name|dst_handle
parameter_list|,
name|u_short
name|dst_seg
parameter_list|,
name|u_short
name|dst_offset
parameter_list|,
name|u_long
name|length
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_long
name|move_ems_to_ems
parameter_list|(
name|u_short
name|src_hande
parameter_list|,
name|u_short
name|src_seg
parameter_list|,
name|u_short
name|src_offset
parameter_list|,
name|u_short
name|dst_handle
parameter_list|,
name|u_short
name|dst_seg
parameter_list|,
name|u_short
name|dst_offset
parameter_list|,
name|u_long
name|length
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*   * EMS initialization routine: Return 1, if successful, return 0 if  * init problem or EMS disabled  */
end_comment

begin_function
name|int
name|ems_init
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|ems_max_size
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|init_mapfile
argument_list|()
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Sanity */
name|bzero
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
operator|&
name|ems_handle
index|[
literal|0
index|]
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|ems_handle
argument_list|)
argument_list|)
expr_stmt|;
name|ems_total_pages
operator|=
name|ems_max_size
operator|/
name|EMS_PAGESIZE
expr_stmt|;
name|ems_alloc_pages
operator|=
literal|0
expr_stmt|;
name|ems_free_pages
operator|=
name|ems_total_pages
expr_stmt|;
name|ems_alloc_handles
operator|=
literal|0
expr_stmt|;
name|active_handle
operator|=
literal|0
expr_stmt|;
comment|/* Malloc the page array */
name|ems_page
operator|=
operator|(
name|EMS_page
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|EMS_page
argument_list|)
operator|*
name|ems_total_pages
argument_list|)
expr_stmt|;
if|if
condition|(
name|ems_page
operator|==
name|NULL
condition|)
block|{
name|debug
argument_list|(
name|D_ALWAYS
argument_list|,
literal|"Could not malloc page array, EMS disabled\n"
argument_list|)
expr_stmt|;
name|ems_frame_addr
operator|=
literal|0
expr_stmt|;
name|ems_max_size
operator|=
literal|0
expr_stmt|;
name|ems_total_pages
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ems_total_pages
condition|;
name|i
operator|++
control|)
block|{
name|ems_page
index|[
name|i
index|]
operator|.
name|handle
operator|=
literal|0
expr_stmt|;
name|ems_page
index|[
name|i
index|]
operator|.
name|status
operator|=
name|EMS_FREE
expr_stmt|;
block|}
name|debug
argument_list|(
name|D_EMS
argument_list|,
literal|"EMS: Emulation init OK.\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Main entry point */
end_comment

begin_function
name|void
name|ems_entry
parameter_list|(
name|regcontext_t
modifier|*
name|REGS
parameter_list|)
block|{
comment|/*      * If EMS is not enabled, the DOS ems.exe module should not have      * been loaded. If it is loaded anyway, report software malfunction      */
if|if
condition|(
name|ems_max_size
operator|==
literal|0
condition|)
block|{
name|R_AH
operator|=
name|EMS_SW_MALFUNC
expr_stmt|;
name|debug
argument_list|(
name|D_EMS
argument_list|,
literal|"EMS emulation not enabled\n"
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|R_AH
condition|)
block|{
case|case
name|GET_MANAGER_STATUS
case|:
name|debug
argument_list|(
name|D_EMS
argument_list|,
literal|"EMS: Get manager status\n"
argument_list|)
expr_stmt|;
name|R_AH
operator|=
name|EMS_SUCCESS
expr_stmt|;
break|break;
case|case
name|GET_PAGE_FRAME_SEGMENT
case|:
name|debug
argument_list|(
name|D_EMS
argument_list|,
literal|"EMS: Get page frame segment\n"
argument_list|)
expr_stmt|;
name|R_BX
operator|=
name|ems_frame_addr
operator|>>
literal|4
expr_stmt|;
name|R_AH
operator|=
name|EMS_SUCCESS
expr_stmt|;
break|break;
case|case
name|GET_PAGE_COUNTS
case|:
name|R_BX
operator|=
name|ems_total_pages
operator|-
name|ems_alloc_pages
expr_stmt|;
name|R_DX
operator|=
name|ems_total_pages
expr_stmt|;
name|debug
argument_list|(
name|D_EMS
argument_list|,
literal|"EMS: Get page count: Returned total=%d, free=%d\n"
argument_list|,
name|R_DX
argument_list|,
name|R_BX
argument_list|)
expr_stmt|;
name|R_AH
operator|=
name|EMS_SUCCESS
expr_stmt|;
break|break;
case|case
name|GET_HANDLE_AND_ALLOCATE
case|:
block|{
name|u_short
name|npages
decl_stmt|;
name|short
name|handle
decl_stmt|;
name|npages
operator|=
name|R_BX
expr_stmt|;
name|debug
argument_list|(
name|D_EMS
argument_list|,
literal|"EMS: Get handle and allocate %d pages: "
argument_list|,
name|npages
argument_list|)
expr_stmt|;
comment|/* Enough handles? */
if|if
condition|(
operator|(
name|handle
operator|=
name|find_next_free_handle
argument_list|()
operator|)
operator|<
literal|0
condition|)
block|{
name|debug
argument_list|(
name|D_EMS
argument_list|,
literal|"Return error:No handles\n"
argument_list|)
expr_stmt|;
name|R_AH
operator|=
name|EMS_OUT_OF_HANDLES
expr_stmt|;
break|break;
block|}
comment|/* Enough memory for this request ? */
if|if
condition|(
name|npages
operator|>
name|ems_free_pages
condition|)
block|{
name|debug
argument_list|(
name|D_EMS
argument_list|,
literal|"Return error:Request too big\n"
argument_list|)
expr_stmt|;
name|R_AH
operator|=
name|EMS_OUT_OF_LOG
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|npages
operator|>
name|ems_total_pages
condition|)
block|{
name|debug
argument_list|(
name|D_EMS
argument_list|,
literal|"Return error:Request too big\n"
argument_list|)
expr_stmt|;
name|R_AH
operator|=
name|EMS_OUT_OF_PHYS
expr_stmt|;
break|break;
block|}
comment|/* Not allowed to allocate zero pages with this function */
if|if
condition|(
name|npages
operator|==
literal|0
condition|)
block|{
name|debug
argument_list|(
name|D_EMS
argument_list|,
literal|"Return error:Cannot allocate 0 pages\n"
argument_list|)
expr_stmt|;
name|R_AH
operator|=
name|EMS_ZERO_PAGES
expr_stmt|;
break|break;
block|}
comment|/* Allocate the handle */
name|allocate_handle
argument_list|(
name|handle
argument_list|,
name|npages
argument_list|)
expr_stmt|;
comment|/* Allocate the pages */
name|allocate_pages_to_handle
argument_list|(
name|handle
argument_list|,
name|npages
argument_list|)
expr_stmt|;
name|R_DX
operator|=
name|handle
expr_stmt|;
name|R_AH
operator|=
name|EMS_SUCCESS
expr_stmt|;
name|debug
argument_list|(
name|D_EMS
argument_list|,
literal|"Return success:Handle = %d\n"
argument_list|,
name|handle
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|MAP_UNMAP
case|:
block|{
name|u_char
name|position
decl_stmt|;
name|u_short
name|hpagenum
decl_stmt|,
name|spagenum
decl_stmt|;
name|short
name|handle
decl_stmt|;
name|debug
argument_list|(
name|D_EMS
argument_list|,
literal|"EMS: Map/Unmap handle=%d, pos=%d, pagenum=%d "
argument_list|,
name|R_DX
argument_list|,
name|R_AL
argument_list|,
name|R_BX
argument_list|)
expr_stmt|;
name|handle
operator|=
name|R_DX
expr_stmt|;
name|position
operator|=
name|R_AL
expr_stmt|;
if|if
condition|(
name|position
operator|>
literal|3
condition|)
block|{
name|debug
argument_list|(
name|D_EMS
argument_list|,
literal|"invalid position\n"
argument_list|)
expr_stmt|;
name|R_AH
operator|=
name|EMS_ILL_PHYS
expr_stmt|;
break|break;
block|}
name|hpagenum
operator|=
name|R_BX
expr_stmt|;
comment|/* This succeeds without a valid handle ! */
if|if
condition|(
name|hpagenum
operator|==
literal|0xffff
condition|)
block|{
comment|/* Unmap only */
name|map_page
argument_list|(
literal|0
argument_list|,
name|position
argument_list|,
name|handle
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|D_EMS
argument_list|,
literal|"(unmap only) success\n"
argument_list|)
expr_stmt|;
name|R_AH
operator|=
name|EMS_SUCCESS
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|handle
operator|>
literal|255
operator|||
name|handle
operator|==
literal|0
operator|||
name|ems_handle
index|[
name|handle
index|]
operator|==
name|NULL
condition|)
block|{
name|R_AH
operator|=
name|EMS_INV_HANDLE
expr_stmt|;
name|debug
argument_list|(
name|D_EMS
argument_list|,
literal|"invalid handle\n"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|hpagenum
operator|>=
name|ems_handle
index|[
name|handle
index|]
operator|->
name|npages
condition|)
block|{
name|R_AH
operator|=
name|EMS_LOGPAGE_TOOBIG
expr_stmt|;
name|debug
argument_list|(
name|D_EMS
argument_list|,
literal|"invalid pagenumber\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|spagenum
operator|=
name|ems_handle
index|[
name|handle
index|]
operator|->
name|pagenum
index|[
name|hpagenum
index|]
expr_stmt|;
name|map_page
argument_list|(
name|spagenum
argument_list|,
name|position
argument_list|,
name|handle
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|D_EMS
argument_list|,
literal|"success\n"
argument_list|)
expr_stmt|;
name|R_AH
operator|=
name|EMS_SUCCESS
expr_stmt|;
break|break;
block|}
case|case
name|DEALLOCATE_HANDLE
case|:
block|{
name|short
name|handle
decl_stmt|;
comment|/* Handle valid ? */
name|handle
operator|=
name|R_DX
expr_stmt|;
name|debug
argument_list|(
name|D_EMS
argument_list|,
literal|"EMS: Deallocate handle %d\n"
argument_list|,
name|handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|handle
operator|>
literal|255
operator|||
name|ems_handle
index|[
name|handle
index|]
operator|==
name|NULL
condition|)
block|{
name|R_AH
operator|=
name|EMS_INV_HANDLE
expr_stmt|;
break|break;
block|}
comment|/* Mapping context saved ? */
if|if
condition|(
name|ems_handle
index|[
name|handle
index|]
operator|->
name|mcontext
operator|!=
name|NULL
condition|)
block|{
name|R_AH
operator|=
name|EMS_SAVED_MAP
expr_stmt|;
break|break;
block|}
name|free_pages_of_handle
argument_list|(
name|handle
argument_list|)
expr_stmt|;
name|free_handle
argument_list|(
name|handle
argument_list|)
expr_stmt|;
name|R_AH
operator|=
name|EMS_SUCCESS
expr_stmt|;
break|break;
block|}
case|case
name|GET_EMM_VERSION
case|:
name|debug
argument_list|(
name|D_EMS
argument_list|,
literal|"EMS: Get version\n"
argument_list|)
expr_stmt|;
name|R_AL
operator|=
name|EMS_VERSION
expr_stmt|;
name|R_AH
operator|=
name|EMS_SUCCESS
expr_stmt|;
break|break;
case|case
name|SAVE_PAGE_MAP
case|:
block|{
name|short
name|handle
decl_stmt|;
name|debug
argument_list|(
name|D_EMS
argument_list|,
literal|"EMS: Save page map\n"
argument_list|)
expr_stmt|;
name|handle
operator|=
name|R_DX
expr_stmt|;
if|if
condition|(
name|handle
operator|>
literal|255
operator|||
name|handle
operator|==
literal|0
operator|||
name|ems_handle
index|[
name|handle
index|]
operator|==
name|NULL
condition|)
block|{
name|R_AH
operator|=
name|EMS_INV_HANDLE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ems_handle
index|[
name|handle
index|]
operator|->
name|mcontext
operator|!=
name|NULL
condition|)
block|{
comment|/* There is already a context saved */
if|if
condition|(
name|memcmp
argument_list|(
operator|(
name|void
operator|*
operator|)
name|ems_handle
index|[
name|handle
index|]
operator|->
name|mcontext
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|ems_mapping_context
argument_list|,
sizeof|sizeof
argument_list|(
name|EMS_mapping_context
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|R_AH
operator|=
name|EMS_ALREADY_SAVED
expr_stmt|;
else|else
name|R_AH
operator|=
name|EMS_NO_ROOM_TO_SAVE
expr_stmt|;
break|break;
block|}
name|context_to_handle
argument_list|(
name|handle
argument_list|)
expr_stmt|;
name|R_AH
operator|=
name|EMS_SUCCESS
expr_stmt|;
break|break;
block|}
case|case
name|RESTORE_PAGE_MAP
case|:
block|{
name|short
name|handle
decl_stmt|;
name|debug
argument_list|(
name|D_EMS
argument_list|,
literal|"EMS: Restore page map\n"
argument_list|)
expr_stmt|;
name|handle
operator|=
name|R_DX
expr_stmt|;
if|if
condition|(
name|handle
operator|>
literal|255
operator|||
name|handle
operator|==
literal|0
operator|||
name|ems_handle
index|[
name|handle
index|]
operator|==
name|NULL
condition|)
block|{
name|R_AH
operator|=
name|EMS_INV_HANDLE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ems_handle
index|[
name|handle
index|]
operator|->
name|mcontext
operator|==
name|NULL
condition|)
block|{
name|R_AH
operator|=
name|EMS_NO_SAVED_CONTEXT
expr_stmt|;
break|break;
block|}
name|restore_context
argument_list|(
name|ems_handle
index|[
name|handle
index|]
operator|->
name|mcontext
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|ems_handle
index|[
name|handle
index|]
operator|->
name|mcontext
argument_list|)
expr_stmt|;
name|ems_handle
index|[
name|handle
index|]
operator|->
name|mcontext
operator|=
name|NULL
expr_stmt|;
name|R_AH
operator|=
name|EMS_SUCCESS
expr_stmt|;
break|break;
block|}
case|case
name|RESERVED_1
case|:
case|case
name|RESERVED_2
case|:
name|debug
argument_list|(
name|D_ALWAYS
argument_list|,
literal|"Reserved function called: %02x\n"
argument_list|,
name|R_AH
argument_list|)
expr_stmt|;
name|R_AH
operator|=
name|EMS_FUNC_NOSUP
expr_stmt|;
break|break;
case|case
name|GET_HANDLE_COUNT
case|:
name|debug
argument_list|(
name|D_EMS
argument_list|,
literal|"EMS: Get handle count\n"
argument_list|)
expr_stmt|;
name|R_BX
operator|=
name|ems_alloc_handles
operator|+
literal|1
expr_stmt|;
name|R_AH
operator|=
name|EMS_SUCCESS
expr_stmt|;
break|break;
case|case
name|GET_PAGES_OWNED
case|:
block|{
name|short
name|handle
decl_stmt|;
name|debug
argument_list|(
name|D_EMS
argument_list|,
literal|"EMS: Get pages owned\n"
argument_list|)
expr_stmt|;
comment|/* Handle valid ? */
name|handle
operator|=
name|R_DX
expr_stmt|;
if|if
condition|(
name|handle
operator|>
literal|255
operator|||
name|ems_handle
index|[
name|handle
index|]
operator|==
name|NULL
condition|)
block|{
name|R_AH
operator|=
name|EMS_INV_HANDLE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|handle
operator|==
literal|0
condition|)
name|R_BX
operator|=
literal|0
expr_stmt|;
else|else
name|R_BX
operator|=
name|ems_handle
index|[
name|handle
index|]
operator|->
name|npages
expr_stmt|;
name|R_AH
operator|=
name|EMS_SUCCESS
expr_stmt|;
break|break;
block|}
case|case
name|GET_PAGES_FOR_ALL
case|:
block|{
name|EMShandlepage
modifier|*
name|ehp
decl_stmt|;
name|int
name|safecount
decl_stmt|;
name|int
name|i
decl_stmt|;
name|debug
argument_list|(
name|D_EMS
argument_list|,
literal|"EMS: Get pages for all\n"
argument_list|)
expr_stmt|;
comment|/* Get the address passed from DOS app */
name|ehp
operator|=
operator|(
name|EMShandlepage
operator|*
operator|)
name|get_valid_pointer
argument_list|(
name|R_ES
argument_list|,
name|R_DI
argument_list|,
sizeof|sizeof
argument_list|(
name|EMShandlepage
argument_list|)
operator|*
name|ems_alloc_handles
argument_list|)
expr_stmt|;
if|if
condition|(
name|ehp
operator|==
name|NULL
condition|)
block|{
name|R_AH
operator|=
name|EMS_SW_MALFUNC
expr_stmt|;
break|break;
block|}
name|R_BX
operator|=
name|ems_alloc_handles
expr_stmt|;
name|safecount
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|255
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ems_handle
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|safecount
operator|>
operator|(
name|ems_alloc_handles
operator|+
literal|1
operator|)
condition|)
name|fatal
argument_list|(
literal|"EMS: ems_alloc_handles is wrong, cannot continue\n"
argument_list|)
expr_stmt|;
name|ehp
operator|->
name|handle
operator|=
name|i
expr_stmt|;
name|ehp
operator|->
name|npages
operator|=
name|ems_handle
index|[
name|i
index|]
operator|->
name|npages
expr_stmt|;
name|ehp
operator|++
expr_stmt|;
name|safecount
operator|++
expr_stmt|;
block|}
block|}
name|R_AH
operator|=
name|EMS_SUCCESS
expr_stmt|;
break|break;
block|}
case|case
name|PAGE_MAP
case|:
comment|/* This function is a nuisance. It was invented to save time and          * memory, but in our case it is useless. We have to support it          * but we use the same save memory as for the page map function.          * It uses only 20 bytes anyway. We store/restore the entire mapping 	 */
case|case
name|PAGE_MAP_PARTIAL
case|:
block|{
name|u_long
name|addr
decl_stmt|;
name|int
name|subfunction
decl_stmt|;
name|EMScontext
modifier|*
name|src
decl_stmt|,
modifier|*
name|dest
decl_stmt|;
name|debug
argument_list|(
name|D_EMS
argument_list|,
literal|"EMS: Page map "
argument_list|)
expr_stmt|;
name|subfunction
operator|=
name|R_AL
expr_stmt|;
if|if
condition|(
name|R_AH
operator|==
name|PAGE_MAP_PARTIAL
condition|)
block|{
name|debug
argument_list|(
name|D_EMS
argument_list|,
literal|"partial "
argument_list|)
expr_stmt|;
comment|/* Page map partial has slightly different subfunctions 		 * GET_SET does not exist and is GET_SIZE in this case  		 */
if|if
condition|(
name|subfunction
operator|==
name|GET_SET
condition|)
name|subfunction
operator|=
name|GET_SIZE
expr_stmt|;
block|}
switch|switch
condition|(
name|subfunction
condition|)
block|{
case|case
name|GET
case|:
block|{
name|debug
argument_list|(
name|D_EMS
argument_list|,
literal|"get\n"
argument_list|)
expr_stmt|;
comment|/* Get the address passed from DOS app */
name|dest
operator|=
operator|(
name|EMScontext
operator|*
operator|)
name|get_valid_pointer
argument_list|(
name|R_ES
argument_list|,
name|R_DI
argument_list|,
sizeof|sizeof
argument_list|(
name|EMScontext
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dest
operator|==
name|NULL
condition|)
block|{
name|R_AH
operator|=
name|EMS_SW_MALFUNC
expr_stmt|;
break|break;
block|}
name|save_context_to_dos
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|R_AH
operator|=
name|EMS_SUCCESS
expr_stmt|;
break|break;
block|}
case|case
name|SET
case|:
block|{
name|debug
argument_list|(
name|D_EMS
argument_list|,
literal|"set\n"
argument_list|)
expr_stmt|;
name|src
operator|=
operator|(
name|EMScontext
operator|*
operator|)
name|get_valid_pointer
argument_list|(
name|R_DS
argument_list|,
name|R_SI
argument_list|,
sizeof|sizeof
argument_list|(
name|EMScontext
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|src
operator|==
name|NULL
condition|)
block|{
name|R_AH
operator|=
name|EMS_SW_MALFUNC
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|check_saved_context
argument_list|(
name|src
argument_list|)
operator|==
literal|0
condition|)
block|{
name|R_AH
operator|=
name|EMS_SAVED_CONTEXT_BAD
expr_stmt|;
break|break;
block|}
name|restore_context
argument_list|(
operator|&
name|src
operator|->
name|ems_saved_context
argument_list|)
expr_stmt|;
name|R_AH
operator|=
name|EMS_SUCCESS
expr_stmt|;
break|break;
block|}
case|case
name|GET_SET
case|:
block|{
name|debug
argument_list|(
name|D_EMS
argument_list|,
literal|"get/set\n"
argument_list|)
expr_stmt|;
name|dest
operator|=
operator|(
name|EMScontext
operator|*
operator|)
name|get_valid_pointer
argument_list|(
name|R_ES
argument_list|,
name|R_DI
argument_list|,
sizeof|sizeof
argument_list|(
name|EMScontext
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dest
operator|==
name|NULL
condition|)
block|{
name|R_AH
operator|=
name|EMS_SW_MALFUNC
expr_stmt|;
break|break;
block|}
name|save_context_to_dos
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|src
operator|=
operator|(
name|EMScontext
operator|*
operator|)
name|get_valid_pointer
argument_list|(
name|R_DS
argument_list|,
name|R_SI
argument_list|,
sizeof|sizeof
argument_list|(
name|EMScontext
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|src
operator|==
name|NULL
condition|)
block|{
name|R_AH
operator|=
name|EMS_SW_MALFUNC
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|check_saved_context
argument_list|(
name|src
argument_list|)
operator|==
literal|0
condition|)
block|{
name|R_AH
operator|=
name|EMS_SAVED_CONTEXT_BAD
expr_stmt|;
break|break;
block|}
name|restore_context
argument_list|(
operator|&
name|src
operator|->
name|ems_saved_context
argument_list|)
expr_stmt|;
name|R_AH
operator|=
name|EMS_SUCCESS
expr_stmt|;
break|break;
block|}
case|case
name|GET_SIZE
case|:
name|debug
argument_list|(
name|D_EMS
argument_list|,
literal|"get size\n"
argument_list|)
expr_stmt|;
name|R_AL
operator|=
operator|(
sizeof|sizeof
argument_list|(
name|EMScontext
argument_list|)
operator|+
literal|1
operator|)
operator|&
literal|0xfe
expr_stmt|;
name|R_AH
operator|=
name|EMS_SUCCESS
expr_stmt|;
break|break;
default|default:
name|debug
argument_list|(
name|D_EMS
argument_list|,
literal|"invalid subfunction\n"
argument_list|)
expr_stmt|;
name|R_AH
operator|=
name|EMS_INVALID_SUB
expr_stmt|;
break|break;
block|}
break|break;
block|}
case|case
name|MAP_UNMAP_MULTI_HANDLE
case|:
block|{
name|u_char
name|position
decl_stmt|;
name|u_short
name|hpagenum
decl_stmt|,
name|spagenum
decl_stmt|;
name|short
name|handle
decl_stmt|;
name|EMSmapunmap
modifier|*
name|mp
decl_stmt|;
name|int
name|n_entry
decl_stmt|,
name|i
decl_stmt|;
name|debug
argument_list|(
name|D_EMS
argument_list|,
literal|"EMS: Map/Unmap multiple "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|n_entry
operator|=
name|R_CX
operator|)
operator|>
literal|3
condition|)
block|{
name|R_AH
operator|=
name|EMS_ILL_PHYS
expr_stmt|;
block|}
comment|/* This is valid according to the LIM EMS 4.0 spec */
if|if
condition|(
name|n_entry
operator|==
literal|0
condition|)
block|{
name|R_AH
operator|=
name|EMS_SUCCESS
expr_stmt|;
break|break;
block|}
name|handle
operator|=
name|R_DX
expr_stmt|;
if|if
condition|(
name|handle
operator|>
literal|255
operator|||
name|handle
operator|==
literal|0
operator|||
name|ems_handle
index|[
name|handle
index|]
operator|==
name|NULL
condition|)
block|{
name|R_AH
operator|=
name|EMS_INV_HANDLE
expr_stmt|;
break|break;
block|}
name|mp
operator|=
operator|(
name|EMSmapunmap
operator|*
operator|)
name|get_valid_pointer
argument_list|(
name|R_DS
argument_list|,
name|R_SI
argument_list|,
sizeof|sizeof
argument_list|(
name|EMSmapunmap
argument_list|)
operator|*
name|n_entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|==
name|NULL
condition|)
block|{
name|R_AH
operator|=
name|EMS_SW_MALFUNC
expr_stmt|;
break|break;
block|}
name|R_AH
operator|=
name|EMS_SUCCESS
expr_stmt|;
comment|/* Walk through the table and map/unmap */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_entry
condition|;
name|i
operator|++
control|)
block|{
name|hpagenum
operator|=
name|mp
operator|->
name|log
expr_stmt|;
comment|/* Method is in R_AL */
if|if
condition|(
name|R_AL
operator|==
literal|0
condition|)
block|{
name|debug
argument_list|(
name|D_EMS
argument_list|,
literal|"phys page method\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|phys
operator|<=
literal|3
condition|)
block|{
name|position
operator|=
name|mp
operator|->
name|phys
expr_stmt|;
block|}
else|else
block|{
name|R_AH
operator|=
name|EMS_ILL_PHYS
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|R_AL
operator|==
literal|1
condition|)
block|{
comment|/* Compute position from segment address */
name|u_short
name|p_seg
decl_stmt|;
name|debug
argument_list|(
name|D_EMS
argument_list|,
literal|"segment method\n"
argument_list|)
expr_stmt|;
name|p_seg
operator|=
name|mp
operator|->
name|phys
expr_stmt|;
name|p_seg
operator|-=
name|ems_frame_addr
expr_stmt|;
name|p_seg
operator|/=
name|EMS_PAGESIZE
expr_stmt|;
if|if
condition|(
name|p_seg
operator|<=
literal|3
condition|)
block|{
name|position
operator|=
name|p_seg
expr_stmt|;
block|}
else|else
block|{
name|R_AH
operator|=
name|EMS_ILL_PHYS
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|debug
argument_list|(
name|D_EMS
argument_list|,
literal|"invalid subfunction\n"
argument_list|)
expr_stmt|;
name|R_AH
operator|=
name|EMS_INVALID_SUB
expr_stmt|;
break|break;
block|}
name|mp
operator|++
expr_stmt|;
if|if
condition|(
name|hpagenum
operator|==
literal|0xffff
condition|)
block|{
comment|/* Unmap only */
name|map_page
argument_list|(
literal|0
argument_list|,
name|position
argument_list|,
name|handle
argument_list|,
literal|1
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|hpagenum
operator|>=
name|ems_handle
index|[
name|handle
index|]
operator|->
name|npages
condition|)
block|{
name|R_AH
operator|=
name|EMS_LOGPAGE_TOOBIG
expr_stmt|;
break|break;
block|}
name|spagenum
operator|=
name|ems_handle
index|[
name|handle
index|]
operator|->
name|pagenum
index|[
name|hpagenum
index|]
expr_stmt|;
name|map_page
argument_list|(
name|spagenum
argument_list|,
name|position
argument_list|,
name|handle
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|REALLOC_PAGES
case|:
block|{
name|short
name|handle
decl_stmt|;
name|u_long
name|newpages
decl_stmt|;
name|debug
argument_list|(
name|D_EMS
argument_list|,
literal|"EMS: Realloc pages "
argument_list|)
expr_stmt|;
name|handle
operator|=
name|R_DX
expr_stmt|;
if|if
condition|(
name|handle
operator|>
literal|255
operator|||
name|handle
operator|==
literal|0
operator|||
name|ems_handle
index|[
name|handle
index|]
operator|==
name|NULL
condition|)
block|{
name|R_AH
operator|=
name|EMS_INV_HANDLE
expr_stmt|;
name|debug
argument_list|(
name|D_EMS
argument_list|,
literal|"invalid handle\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|newpages
operator|=
name|R_BX
expr_stmt|;
name|debug
argument_list|(
name|D_EMS
argument_list|,
literal|"changed from %d to %d pages\n"
argument_list|,
name|ems_handle
index|[
name|handle
index|]
operator|->
name|npages
argument_list|,
name|newpages
argument_list|)
expr_stmt|;
comment|/* Case 1: Realloc to zero pages */
if|if
condition|(
name|newpages
operator|==
literal|0
condition|)
block|{
name|free_pages_of_handle
argument_list|(
name|handle
argument_list|)
expr_stmt|;
name|R_AH
operator|=
name|EMS_SUCCESS
expr_stmt|;
break|break;
block|}
comment|/* Case 2: New allocation is equal to allocated number */
if|if
condition|(
name|newpages
operator|==
name|ems_handle
index|[
name|handle
index|]
operator|->
name|npages
condition|)
block|{
name|R_AH
operator|=
name|EMS_SUCCESS
expr_stmt|;
break|break;
block|}
comment|/* Case 3: Reallocate to bigger and smaller sizes */
if|if
condition|(
name|newpages
operator|>
name|ems_handle
index|[
name|handle
index|]
operator|->
name|npages
condition|)
block|{
if|if
condition|(
name|newpages
operator|>
name|ems_free_pages
condition|)
block|{
name|R_AH
operator|=
name|EMS_OUT_OF_LOG
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|newpages
operator|>
name|ems_total_pages
condition|)
block|{
name|R_AH
operator|=
name|EMS_OUT_OF_PHYS
expr_stmt|;
break|break;
block|}
block|}
name|reallocate_pages_to_handle
argument_list|(
name|handle
argument_list|,
name|newpages
argument_list|)
expr_stmt|;
name|R_AH
operator|=
name|EMS_SUCCESS
expr_stmt|;
break|break;
block|}
comment|/* We do not support nonvolatile pages */
case|case
name|HANDLE_ATTRIBUTES
case|:
name|debug
argument_list|(
name|D_EMS
argument_list|,
literal|"Handle attributes called\n"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|R_AL
condition|)
block|{
case|case
name|GET
case|:
case|case
name|SET
case|:
name|R_AH
operator|=
name|EMS_FEAT_NOSUP
expr_stmt|;
break|break;
case|case
name|HANDLE_CAPABILITY
case|:
name|R_AL
operator|=
literal|0
expr_stmt|;
comment|/* Volatile only */
name|R_AH
operator|=
name|EMS_SUCCESS
expr_stmt|;
break|break;
default|default:
name|R_AH
operator|=
name|EMS_FUNC_NOSUP
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|HANDLE_NAME
case|:
block|{
name|short
name|handle
decl_stmt|;
name|Hname
modifier|*
name|hp
decl_stmt|;
name|handle
operator|=
name|R_DX
expr_stmt|;
if|if
condition|(
name|handle
operator|>
literal|255
operator|||
name|handle
operator|==
literal|0
operator|||
name|ems_handle
index|[
name|handle
index|]
operator|==
name|NULL
condition|)
block|{
name|R_AH
operator|=
name|EMS_INV_HANDLE
expr_stmt|;
name|debug
argument_list|(
name|D_EMS
argument_list|,
literal|"invalid handle\n"
argument_list|)
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|R_AL
condition|)
block|{
case|case
name|GET
case|:
if|if
condition|(
operator|(
name|hp
operator|=
operator|(
name|Hname
operator|*
operator|)
name|get_valid_pointer
argument_list|(
name|R_ES
argument_list|,
name|R_DI
argument_list|,
literal|8
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|R_AH
operator|=
name|EMS_SW_MALFUNC
expr_stmt|;
break|break;
block|}
operator|*
name|hp
operator|=
name|ems_handle
index|[
name|handle
index|]
operator|->
name|hname
expr_stmt|;
name|R_AH
operator|=
name|EMS_SUCCESS
expr_stmt|;
break|break;
case|case
name|SET
case|:
if|if
condition|(
operator|(
name|hp
operator|=
operator|(
name|Hname
operator|*
operator|)
name|get_valid_pointer
argument_list|(
name|R_DS
argument_list|,
name|R_SI
argument_list|,
literal|8
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|R_AH
operator|=
name|EMS_SW_MALFUNC
expr_stmt|;
break|break;
block|}
comment|/* If the handle name is not 0, it may not exist */
if|if
condition|(
operator|(
name|hp
operator|->
name|ul_hn
index|[
literal|0
index|]
operator||
name|hp
operator|->
name|ul_hn
index|[
literal|1
index|]
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|lookup_handle
argument_list|(
name|hp
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ems_handle
index|[
name|handle
index|]
operator|->
name|hname
operator|=
operator|*
name|hp
expr_stmt|;
name|R_AH
operator|=
name|EMS_SUCCESS
expr_stmt|;
block|}
else|else
block|{
name|R_AH
operator|=
name|EMS_NAME_EXISTS
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
comment|/* Name is deleted (set to zeros) */
name|ems_handle
index|[
name|handle
index|]
operator|->
name|hname
operator|=
operator|*
name|hp
expr_stmt|;
name|R_AH
operator|=
name|EMS_SUCCESS
expr_stmt|;
block|}
break|break;
default|default:
name|R_AH
operator|=
name|EMS_FUNC_NOSUP
expr_stmt|;
break|break;
block|}
break|break;
block|}
case|case
name|HANDLE_DIRECTORY
case|:
block|{
name|int
name|i
decl_stmt|;
name|EMShandledir
modifier|*
name|hdp
decl_stmt|;
name|Hname
modifier|*
name|hp
decl_stmt|;
name|short
name|handle
decl_stmt|;
switch|switch
condition|(
name|R_AL
condition|)
block|{
case|case
name|GET
case|:
name|hdp
operator|=
operator|(
name|EMShandledir
operator|*
operator|)
name|get_valid_pointer
argument_list|(
name|R_ES
argument_list|,
name|R_DI
argument_list|,
sizeof|sizeof
argument_list|(
name|EMShandledir
argument_list|)
operator|*
name|ems_alloc_handles
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdp
operator|==
name|NULL
condition|)
block|{
name|R_AH
operator|=
name|EMS_SW_MALFUNC
expr_stmt|;
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|EMS_NUM_HANDLES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ems_handle
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
name|hdp
operator|->
name|log
operator|=
name|i
expr_stmt|;
name|hdp
operator|->
name|name
operator|=
name|ems_handle
index|[
name|i
index|]
operator|->
name|hname
expr_stmt|;
block|}
block|}
name|R_AH
operator|=
name|EMS_SUCCESS
expr_stmt|;
break|break;
case|case
name|HANDLE_SEARCH
case|:
name|hp
operator|=
operator|(
name|Hname
operator|*
operator|)
name|get_valid_pointer
argument_list|(
name|R_DS
argument_list|,
name|R_SI
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|==
name|NULL
condition|)
block|{
name|R_AH
operator|=
name|EMS_SW_MALFUNC
expr_stmt|;
break|break;
block|}
comment|/* Cannot search for NULL handle name */
if|if
condition|(
operator|(
name|hp
operator|->
name|ul_hn
index|[
literal|0
index|]
operator||
name|hp
operator|->
name|ul_hn
index|[
literal|1
index|]
operator|)
operator|!=
literal|0
condition|)
block|{
name|R_AH
operator|=
name|EMS_NAME_EXISTS
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|handle
operator|=
name|lookup_handle
argument_list|(
name|hp
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|R_AH
operator|=
name|EMS_HNAME_NOT_FOUND
expr_stmt|;
block|}
else|else
block|{
name|R_DX
operator|=
name|handle
expr_stmt|;
name|R_AH
operator|=
name|EMS_SUCCESS
expr_stmt|;
block|}
break|break;
case|case
name|GET_TOTAL_HANDLES
case|:
name|R_AH
operator|=
name|EMS_SUCCESS
expr_stmt|;
name|R_BX
operator|=
name|EMS_NUM_HANDLES
expr_stmt|;
comment|/* Includes OS handle */
break|break;
default|default:
name|R_AH
operator|=
name|EMS_FUNC_NOSUP
expr_stmt|;
break|break;
block|}
break|break;
block|}
comment|/* I do not know if we need this. LINUX emulation leaves it out          * so I leave it out too for now. 	 */
case|case
name|ALTER_PAGEMAP_JUMP
case|:
name|debug
argument_list|(
name|D_ALWAYS
argument_list|,
literal|"Alter pagemap and jump used!\n"
argument_list|)
expr_stmt|;
name|R_AH
operator|=
name|EMS_FUNC_NOSUP
expr_stmt|;
break|break;
case|case
name|ALTER_PAGEMAP_CALL
case|:
name|debug
argument_list|(
name|D_ALWAYS
argument_list|,
literal|"Alter pagemap and call used!\n"
argument_list|)
expr_stmt|;
name|R_AH
operator|=
name|EMS_FUNC_NOSUP
expr_stmt|;
break|break;
case|case
name|MOVE_MEMORY_REGION
case|:
block|{
name|EMSmovemem
modifier|*
name|emvp
decl_stmt|;
name|u_long
name|src_addr
decl_stmt|,
name|dst_addr
decl_stmt|;
name|u_short
name|src_handle
decl_stmt|,
name|dst_handle
decl_stmt|;
if|if
condition|(
name|R_AL
operator|==
name|EXCHANGE
condition|)
name|debug
argument_list|(
name|D_EMS
argument_list|,
literal|"EMS: Exchange memory region "
argument_list|)
expr_stmt|;
else|else
name|debug
argument_list|(
name|D_EMS
argument_list|,
literal|"EMS: Move memory region "
argument_list|)
expr_stmt|;
name|emvp
operator|=
operator|(
name|EMSmovemem
operator|*
operator|)
name|get_valid_pointer
argument_list|(
name|R_DS
argument_list|,
name|R_SI
argument_list|,
sizeof|sizeof
argument_list|(
name|EMSmovemem
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|emvp
operator|==
name|NULL
condition|)
block|{
name|debug
argument_list|(
name|D_EMS
argument_list|,
literal|"Invalid structure pointer\n"
argument_list|)
expr_stmt|;
name|R_AH
operator|=
name|EMS_SW_MALFUNC
expr_stmt|;
break|break;
block|}
comment|/* Zero length is not an error */
if|if
condition|(
name|emvp
operator|->
name|length
operator|==
literal|0
condition|)
block|{
name|debug
argument_list|(
name|D_EMS
argument_list|,
literal|"Zero length\n"
argument_list|)
expr_stmt|;
name|R_AH
operator|=
name|EMS_SUCCESS
expr_stmt|;
break|break;
block|}
comment|/* Some checks */
if|if
condition|(
name|emvp
operator|->
name|src_type
operator|==
name|EMS_MOVE_CONV
condition|)
block|{
comment|/* Conventional memory source */
name|src_addr
operator|=
name|MAKEPTR
argument_list|(
name|emvp
operator|->
name|src_seg
argument_list|,
name|emvp
operator|->
name|src_offset
argument_list|)
expr_stmt|;
comment|/* May not exceed conventional memory */
if|if
condition|(
operator|(
name|src_addr
operator|+
name|emvp
operator|->
name|length
operator|)
operator|>
literal|640
operator|*
literal|1024
condition|)
block|{
name|R_AH
operator|=
name|EMS_SW_MALFUNC
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
comment|/* Check the handle */
name|src_handle
operator|=
name|emvp
operator|->
name|src_handle
expr_stmt|;
if|if
condition|(
name|src_handle
operator|>
literal|255
operator|||
name|src_handle
operator|==
literal|0
operator|||
name|ems_handle
index|[
name|src_handle
index|]
operator|==
name|NULL
condition|)
block|{
name|R_AH
operator|=
name|EMS_INV_HANDLE
expr_stmt|;
name|debug
argument_list|(
name|D_EMS
argument_list|,
literal|"invalid source handle\n"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Offset may not exceed page size */
if|if
condition|(
name|emvp
operator|->
name|src_offset
operator|>=
operator|(
literal|16
operator|*
literal|1024
operator|)
condition|)
block|{
name|R_AH
operator|=
name|EMS_PAGEOFFSET
expr_stmt|;
name|debug
argument_list|(
name|D_EMS
argument_list|,
literal|"source page offset too big\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|emvp
operator|->
name|dst_type
operator|==
name|EMS_MOVE_CONV
condition|)
block|{
comment|/* Conventional memory source */
name|dst_addr
operator|=
name|MAKEPTR
argument_list|(
name|emvp
operator|->
name|dst_seg
argument_list|,
name|emvp
operator|->
name|dst_offset
argument_list|)
expr_stmt|;
comment|/* May not exceed conventional memory */
if|if
condition|(
operator|(
name|dst_addr
operator|+
name|emvp
operator|->
name|length
operator|)
operator|>
literal|640
operator|*
literal|1024
condition|)
block|{
name|R_AH
operator|=
name|EMS_SW_MALFUNC
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
comment|/* Check the handle */
name|dst_handle
operator|=
name|emvp
operator|->
name|dst_handle
expr_stmt|;
if|if
condition|(
name|dst_handle
operator|>
literal|255
operator|||
name|dst_handle
operator|==
literal|0
operator|||
name|ems_handle
index|[
name|dst_handle
index|]
operator|==
name|NULL
condition|)
block|{
name|R_AH
operator|=
name|EMS_INV_HANDLE
expr_stmt|;
name|debug
argument_list|(
name|D_EMS
argument_list|,
literal|"invalid destination handle\n"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Offset may not exceed page size */
if|if
condition|(
name|emvp
operator|->
name|dst_offset
operator|>=
operator|(
literal|16
operator|*
literal|1024
operator|)
condition|)
block|{
name|R_AH
operator|=
name|EMS_PAGEOFFSET
expr_stmt|;
name|debug
argument_list|(
name|D_EMS
argument_list|,
literal|"destination page offset too big\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|R_AL
operator|==
name|MOVE
condition|)
block|{
comment|/* If it is conventional memory only, do it */
if|if
condition|(
name|emvp
operator|->
name|src_type
operator|==
name|EMS_MOVE_CONV
operator|&&
name|emvp
operator|->
name|dst_type
operator|==
name|EMS_MOVE_CONV
condition|)
block|{
name|memmove
argument_list|(
operator|(
name|void
operator|*
operator|)
name|dst_addr
argument_list|,
operator|(
name|void
operator|*
operator|)
name|src_addr
argument_list|,
operator|(
name|size_t
operator|)
name|emvp
operator|->
name|length
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|D_EMS
argument_list|,
literal|"conventional to conventional memory done\n"
argument_list|)
expr_stmt|;
name|R_AH
operator|=
name|EMS_SUCCESS
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|emvp
operator|->
name|src_type
operator|==
name|EMS_MOVE_EMS
operator|&&
name|emvp
operator|->
name|dst_type
operator|==
name|EMS_MOVE_CONV
condition|)
name|R_AH
operator|=
name|move_ems_to_conv
argument_list|(
name|src_handle
argument_list|,
name|emvp
operator|->
name|src_seg
argument_list|,
name|emvp
operator|->
name|src_offset
argument_list|,
name|dst_addr
argument_list|,
name|emvp
operator|->
name|length
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|emvp
operator|->
name|src_type
operator|==
name|EMS_MOVE_CONV
operator|&&
name|emvp
operator|->
name|dst_type
operator|==
name|EMS_MOVE_EMS
condition|)
name|R_AH
operator|=
name|move_conv_to_ems
argument_list|(
name|src_addr
argument_list|,
name|dst_handle
argument_list|,
name|emvp
operator|->
name|dst_seg
argument_list|,
name|emvp
operator|->
name|dst_offset
argument_list|,
name|emvp
operator|->
name|length
argument_list|)
expr_stmt|;
else|else
name|R_AH
operator|=
name|move_ems_to_ems
argument_list|(
name|src_handle
argument_list|,
name|emvp
operator|->
name|src_seg
argument_list|,
name|emvp
operator|->
name|src_offset
argument_list|,
name|dst_handle
argument_list|,
name|emvp
operator|->
name|dst_seg
argument_list|,
name|emvp
operator|->
name|dst_offset
argument_list|,
name|emvp
operator|->
name|length
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|D_EMS
argument_list|,
literal|" done\n"
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
comment|/* exchange memory region */
comment|/* We need a scratch area for the exchange */
name|void
modifier|*
name|buffer
decl_stmt|;
if|if
condition|(
operator|(
name|buffer
operator|=
name|malloc
argument_list|(
name|emvp
operator|->
name|length
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"EMS: Could not malloc scratch area for exchange"
argument_list|)
expr_stmt|;
comment|/* If it is conventional memory only, do it */
if|if
condition|(
name|emvp
operator|->
name|src_type
operator|==
name|EMS_MOVE_CONV
operator|&&
name|emvp
operator|->
name|dst_type
operator|==
name|EMS_MOVE_CONV
condition|)
block|{
comment|/* destination -> buffer */
name|memmove
argument_list|(
name|buffer
argument_list|,
operator|(
name|void
operator|*
operator|)
name|dst_addr
argument_list|,
operator|(
name|size_t
operator|)
name|emvp
operator|->
name|length
argument_list|)
expr_stmt|;
comment|/* Source -> destination */
name|memmove
argument_list|(
operator|(
name|void
operator|*
operator|)
name|dst_addr
argument_list|,
operator|(
name|void
operator|*
operator|)
name|src_addr
argument_list|,
operator|(
name|size_t
operator|)
name|emvp
operator|->
name|length
argument_list|)
expr_stmt|;
comment|/* Buffer -> source */
name|memmove
argument_list|(
operator|(
name|void
operator|*
operator|)
name|src_addr
argument_list|,
name|buffer
argument_list|,
operator|(
name|size_t
operator|)
name|emvp
operator|->
name|length
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|D_EMS
argument_list|,
literal|"conventional to conventional memory done\n"
argument_list|)
expr_stmt|;
name|R_AH
operator|=
name|EMS_SUCCESS
expr_stmt|;
break|break;
block|}
comment|/* Exchange EMS with conventional */
if|if
condition|(
name|emvp
operator|->
name|src_type
operator|==
name|EMS_MOVE_EMS
operator|&&
name|emvp
operator|->
name|dst_type
operator|==
name|EMS_MOVE_CONV
condition|)
block|{
comment|/* Destination -> buffer */
name|memmove
argument_list|(
name|buffer
argument_list|,
operator|(
name|void
operator|*
operator|)
name|dst_addr
argument_list|,
operator|(
name|size_t
operator|)
name|emvp
operator|->
name|length
argument_list|)
expr_stmt|;
comment|/* Source -> destination */
name|R_AH
operator|=
name|move_ems_to_conv
argument_list|(
name|src_handle
argument_list|,
name|emvp
operator|->
name|src_seg
argument_list|,
name|emvp
operator|->
name|src_offset
argument_list|,
name|dst_addr
argument_list|,
name|emvp
operator|->
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|R_AH
operator|!=
name|EMS_SUCCESS
condition|)
block|{
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Buffer -> source */
name|R_AH
operator|=
name|move_conv_to_ems
argument_list|(
operator|(
name|u_long
operator|)
name|buffer
argument_list|,
name|src_handle
argument_list|,
name|emvp
operator|->
name|src_seg
argument_list|,
name|emvp
operator|->
name|src_offset
argument_list|,
name|emvp
operator|->
name|length
argument_list|)
expr_stmt|;
comment|/* Exchange conventional with EMS */
block|}
elseif|else
if|if
condition|(
name|emvp
operator|->
name|src_type
operator|==
name|EMS_MOVE_CONV
operator|&&
name|emvp
operator|->
name|dst_type
operator|==
name|EMS_MOVE_EMS
condition|)
block|{
comment|/* Destination -> buffer */
name|R_AH
operator|=
name|move_ems_to_conv
argument_list|(
name|dst_handle
argument_list|,
name|emvp
operator|->
name|dst_seg
argument_list|,
name|emvp
operator|->
name|dst_offset
argument_list|,
operator|(
name|u_long
operator|)
name|buffer
argument_list|,
name|emvp
operator|->
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|R_AH
operator|!=
name|EMS_SUCCESS
condition|)
block|{
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Source -> destination */
name|R_AH
operator|=
name|move_conv_to_ems
argument_list|(
operator|(
name|u_long
operator|)
name|buffer
argument_list|,
name|dst_handle
argument_list|,
name|emvp
operator|->
name|dst_seg
argument_list|,
name|emvp
operator|->
name|dst_offset
argument_list|,
name|emvp
operator|->
name|length
argument_list|)
expr_stmt|;
comment|/* Buffer -> source */
name|memmove
argument_list|(
name|buffer
argument_list|,
operator|(
name|void
operator|*
operator|)
name|src_addr
argument_list|,
operator|(
name|size_t
operator|)
name|emvp
operator|->
name|length
argument_list|)
expr_stmt|;
comment|/* Exchange EMS with EMS */
block|}
else|else
block|{
comment|/* Destination -> buffer */
name|R_AH
operator|=
name|move_ems_to_conv
argument_list|(
name|dst_handle
argument_list|,
name|emvp
operator|->
name|dst_seg
argument_list|,
name|emvp
operator|->
name|dst_offset
argument_list|,
operator|(
name|u_long
operator|)
name|buffer
argument_list|,
name|emvp
operator|->
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|R_AH
operator|!=
name|EMS_SUCCESS
condition|)
block|{
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Source -> destination */
name|R_AH
operator|=
name|move_ems_to_ems
argument_list|(
name|src_handle
argument_list|,
name|emvp
operator|->
name|src_seg
argument_list|,
name|emvp
operator|->
name|src_offset
argument_list|,
name|dst_handle
argument_list|,
name|emvp
operator|->
name|dst_seg
argument_list|,
name|emvp
operator|->
name|dst_offset
argument_list|,
name|emvp
operator|->
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|R_AH
operator|!=
name|EMS_SUCCESS
condition|)
block|{
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Buffer -> source */
name|R_AH
operator|=
name|move_conv_to_ems
argument_list|(
operator|(
name|u_long
operator|)
name|buffer
argument_list|,
name|src_handle
argument_list|,
name|emvp
operator|->
name|src_seg
argument_list|,
name|emvp
operator|->
name|src_offset
argument_list|,
name|emvp
operator|->
name|length
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
name|debug
argument_list|(
name|D_EMS
argument_list|,
literal|" done\n"
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|GET_MAPPABLE_PHYS_ADDR
case|:
block|{
switch|switch
condition|(
name|R_AL
condition|)
block|{
case|case
name|GET_ARRAY
case|:
block|{
name|EMSaddrarray
modifier|*
name|eadp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|u_short
name|seg
decl_stmt|;
name|eadp
operator|=
operator|(
name|EMSaddrarray
operator|*
operator|)
name|get_valid_pointer
argument_list|(
name|R_ES
argument_list|,
name|R_DI
argument_list|,
sizeof|sizeof
argument_list|(
name|EMSaddrarray
argument_list|)
operator|*
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|eadp
operator|==
name|NULL
condition|)
block|{
name|R_AH
operator|=
name|EMS_SW_MALFUNC
expr_stmt|;
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|seg
operator|=
operator|(
name|ems_frame_addr
operator|>>
literal|4
operator|)
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|eadp
operator|->
name|segm
operator|=
name|seg
expr_stmt|;
name|eadp
operator|->
name|phys
operator|=
name|i
expr_stmt|;
name|eadp
operator|++
expr_stmt|;
name|seg
operator|+=
literal|1024
expr_stmt|;
block|}
name|R_AH
operator|=
name|EMS_SUCCESS
expr_stmt|;
break|break;
block|}
case|case
name|GET_ARRAY_ENTRIES
case|:
comment|/* There are always 4 positions, 4*16kB = 64kB */
name|R_CX
operator|=
literal|4
expr_stmt|;
name|R_AH
operator|=
name|EMS_SUCCESS
expr_stmt|;
break|break;
default|default:
name|R_AH
operator|=
name|EMS_FUNC_NOSUP
expr_stmt|;
break|break;
block|}
break|break;
block|}
comment|/* This is an OS function in the LIM EMS 4.0 standard: It is 	 * usable only by an OS and its use can be disabled for all other 	 * programs. I think we do not need to support it. It is not 	 * implemented and it reports "disabled" to any caller. 	 */
case|case
name|GET_HW_CONFIGURATION
case|:
name|R_AH
operator|=
name|EMS_FUNCTION_DISABLED
expr_stmt|;
break|break;
comment|/* This function is a little different, it was defined with 	 * LIM EMS 4.0: It is allowed to allocate zero pages and raw 	 * page size (i.e. page size != 16kB) is supported. We have  	 * only 16kB pages, so the second difference does not matter. 	 */
case|case
name|ALLOCATE_PAGES
case|:
block|{
name|u_short
name|npages
decl_stmt|;
name|short
name|handle
decl_stmt|;
name|npages
operator|=
name|R_BX
expr_stmt|;
name|debug
argument_list|(
name|D_EMS
argument_list|,
literal|"EMS: Get handle and allocate %d pages: "
argument_list|,
name|npages
argument_list|)
expr_stmt|;
comment|/* Enough handles? */
if|if
condition|(
operator|(
name|handle
operator|=
name|find_next_free_handle
argument_list|()
operator|)
operator|<
literal|0
condition|)
block|{
name|debug
argument_list|(
name|D_EMS
argument_list|,
literal|"Return error:No handles\n"
argument_list|)
expr_stmt|;
name|R_AH
operator|=
name|EMS_OUT_OF_HANDLES
expr_stmt|;
break|break;
block|}
comment|/* Enough memory for this request ? */
if|if
condition|(
name|npages
operator|>
name|ems_free_pages
condition|)
block|{
name|debug
argument_list|(
name|D_EMS
argument_list|,
literal|"Return error:Request too big\n"
argument_list|)
expr_stmt|;
name|R_AH
operator|=
name|EMS_OUT_OF_LOG
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|npages
operator|>
name|ems_total_pages
condition|)
block|{
name|debug
argument_list|(
name|D_EMS
argument_list|,
literal|"Return error:Request too big\n"
argument_list|)
expr_stmt|;
name|R_AH
operator|=
name|EMS_OUT_OF_PHYS
expr_stmt|;
break|break;
block|}
comment|/* Allocate the handle */
name|allocate_handle
argument_list|(
name|handle
argument_list|,
name|npages
argument_list|)
expr_stmt|;
comment|/* Allocate the pages */
name|allocate_pages_to_handle
argument_list|(
name|handle
argument_list|,
name|npages
argument_list|)
expr_stmt|;
name|R_DX
operator|=
name|handle
expr_stmt|;
name|R_AH
operator|=
name|EMS_SUCCESS
expr_stmt|;
name|debug
argument_list|(
name|D_EMS
argument_list|,
literal|"Return success:Handle = %d\n"
argument_list|,
name|handle
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* This is an OS function in the LIM EMS 4.0 standard: It is 	 * usable only by an OS and its use can be disabled for all other 	 * programs. I think we do not need to support it. It is not 	 * implemented and it reports "disabled" to any caller. 	 */
case|case
name|ALTERNATE_MAP_REGISTER
case|:
name|R_AH
operator|=
name|EMS_FUNCTION_DISABLED
expr_stmt|;
break|break;
comment|/* We cannot support that ! */
case|case
name|PREPARE_WARMBOOT
case|:
name|R_AH
operator|=
name|EMS_FUNC_NOSUP
expr_stmt|;
break|break;
case|case
name|OS_FUNCTION_SET
case|:
name|R_AH
operator|=
name|EMS_FUNCTION_DISABLED
expr_stmt|;
break|break;
name|unknown
label|:
default|default:
name|debug
argument_list|(
name|D_ALWAYS
argument_list|,
literal|"EMS: Unknown function called: %02x\n"
argument_list|,
name|R_AH
argument_list|)
expr_stmt|;
name|R_AH
operator|=
name|EMS_FUNC_NOSUP
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Initialize the EMS memory: Return 1 on success, 0 on failure */
end_comment

begin_function
specifier|static
name|int
name|init_mapfile
parameter_list|()
block|{
name|char
name|path
index|[
literal|256
index|]
decl_stmt|;
name|int
name|mfd
decl_stmt|;
comment|/* Sanity */
if|if
condition|(
name|ems_max_size
operator|==
literal|0
condition|)
return|return;
name|strcpy
argument_list|(
name|path
argument_list|,
name|EMS_MAP_PATH
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|path
argument_list|,
name|EMS_MAP_FILE
argument_list|)
expr_stmt|;
name|mfd
operator|=
name|mkstemp
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|mfd
operator|<
literal|0
condition|)
block|{
name|debug
argument_list|(
name|D_ALWAYS
argument_list|,
literal|"Could not create EMS mapfile, "
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|unlink
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|mapfile_fd
operator|=
name|squirrel_fd
argument_list|(
name|mfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|mapfile_fd
argument_list|,
call|(
name|off_t
call|)
argument_list|(
name|ems_max_size
operator|-
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|debug
argument_list|(
name|D_ALWAYS
argument_list|,
literal|"Could not seek into EMS mapfile, "
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|write
argument_list|(
name|mapfile_fd
argument_list|,
literal|""
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
block|{
name|debug
argument_list|(
name|D_ALWAYS
argument_list|,
literal|"Could not write to EMS mapfile, "
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Unmap the entire page frame */
if|if
condition|(
name|munmap
argument_list|(
operator|(
name|caddr_t
operator|)
name|ems_frame_addr
argument_list|,
literal|64
operator|*
literal|1024
argument_list|)
operator|<
literal|0
condition|)
block|{
name|debug
argument_list|(
name|D_ALWAYS
argument_list|,
literal|"Could not unmap EMS page frame, "
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* DOS programs will access the page frame without allocating       * pages first. Microsoft diagnose MSD.EXE does this, for example      * We need to have memory here to avoid segmentation violation      */
if|if
condition|(
name|mmap
argument_list|(
operator|(
name|caddr_t
operator|)
name|ems_frame_addr
argument_list|,
literal|64
operator|*
literal|1024
argument_list|,
name|PROT_EXEC
operator||
name|PROT_READ
operator||
name|PROT_WRITE
argument_list|,
name|MAP_ANON
operator||
name|MAP_FIXED
operator||
name|MAP_INHERIT
operator||
name|MAP_SHARED
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|debug
argument_list|(
name|D_ALWAYS
argument_list|,
literal|"Could not map EMS page frame, "
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|bzero
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|ems_mapping_context
argument_list|,
sizeof|sizeof
argument_list|(
name|EMS_mapping_context
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
name|fail
label|:
name|debug
argument_list|(
name|D_ALWAYS
argument_list|,
literal|"EMS disabled\n"
argument_list|)
expr_stmt|;
name|ems_max_size
operator|=
literal|0
expr_stmt|;
name|ems_frame_addr
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Map/Unmap pages into one of four positions in the frame segment */
end_comment

begin_function
specifier|static
name|void
name|map_page
parameter_list|(
name|u_long
name|pagenum
parameter_list|,
name|u_char
name|position
parameter_list|,
name|short
name|handle
parameter_list|,
name|int
name|unmaponly
parameter_list|)
block|{
name|caddr_t
name|map_addr
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|off_t
name|file_offs
decl_stmt|;
if|if
condition|(
name|position
operator|>
literal|3
condition|)
name|fatal
argument_list|(
literal|"EMS: Internal error: Mapping position\n"
argument_list|)
expr_stmt|;
name|map_addr
operator|=
call|(
name|caddr_t
call|)
argument_list|(
name|ems_frame_addr
operator|+
operator|(
literal|1024
operator|*
literal|16
operator|*
operator|(
name|u_long
operator|)
name|position
operator|)
argument_list|)
expr_stmt|;
name|len
operator|=
literal|1024
operator|*
literal|16
expr_stmt|;
name|file_offs
operator|=
call|(
name|off_t
call|)
argument_list|(
name|pagenum
operator|*
literal|16
operator|*
literal|1024
argument_list|)
expr_stmt|;
if|if
condition|(
name|ems_mapping_context
operator|.
name|pos_mapped
index|[
name|position
index|]
condition|)
block|{
if|if
condition|(
name|munmap
argument_list|(
name|map_addr
argument_list|,
name|len
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fatal
argument_list|(
literal|"EMS unmapping error: %s\nCannot recover\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ems_page
index|[
name|ems_mapping_context
operator|.
name|pos_pagenum
index|[
name|position
index|]
index|]
operator|.
name|status
operator|&=
operator|~
name|EMS_MAPPED
expr_stmt|;
name|ems_mapping_context
operator|.
name|pos_mapped
index|[
name|position
index|]
operator|=
literal|0
expr_stmt|;
name|ems_mapping_context
operator|.
name|handle
index|[
name|position
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|unmaponly
condition|)
block|{
comment|/* DOS programs will access the page frame without allocating           * pages first. Microsoft diagnose MSD.EXE does this, for example          * We need to have memory here to avoid segmentation violation          */
if|if
condition|(
name|mmap
argument_list|(
operator|(
name|caddr_t
operator|)
name|ems_frame_addr
argument_list|,
literal|64
operator|*
literal|1024
argument_list|,
name|PROT_EXEC
operator||
name|PROT_READ
operator||
name|PROT_WRITE
argument_list|,
name|MAP_ANON
operator||
name|MAP_FIXED
operator||
name|MAP_INHERIT
operator||
name|MAP_SHARED
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|fatal
argument_list|(
literal|"Could not map EMS page frame during unmap only\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|mmap
argument_list|(
name|map_addr
argument_list|,
name|len
argument_list|,
name|PROT_EXEC
operator||
name|PROT_READ
operator||
name|PROT_WRITE
argument_list|,
name|MAP_FILE
operator||
name|MAP_FIXED
operator||
name|MAP_INHERIT
operator||
name|MAP_SHARED
argument_list|,
name|mapfile_fd
argument_list|,
name|file_offs
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fatal
argument_list|(
literal|"EMS mapping error: %s\nCannot recover\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ems_mapping_context
operator|.
name|pos_mapped
index|[
name|position
index|]
operator|=
literal|1
expr_stmt|;
name|ems_mapping_context
operator|.
name|pos_pagenum
index|[
name|position
index|]
operator|=
name|pagenum
expr_stmt|;
name|ems_mapping_context
operator|.
name|handle
index|[
name|position
index|]
operator|=
name|handle
expr_stmt|;
name|ems_page
index|[
name|pagenum
index|]
operator|.
name|status
operator||=
name|EMS_MAPPED
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get a pointer from VM86 app, check it and return it. This returns NULL  * if the pointer is not valid. We can check only for very limited  * criteria: The pointer and the area defined by size may not point to  * memory over 1MB and it may not may to addresses under 1kB, because there  * is the VM86 interrupt table.  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|get_valid_pointer
parameter_list|(
name|u_short
name|seg
parameter_list|,
name|u_short
name|offs
parameter_list|,
name|u_long
name|size
parameter_list|)
block|{
name|u_long
name|addr
decl_stmt|;
name|addr
operator|=
name|MAKEPTR
argument_list|(
name|seg
argument_list|,
name|offs
argument_list|)
expr_stmt|;
comment|/* Check bounds */
if|if
condition|(
operator|(
name|addr
operator|+
name|size
operator|)
operator|>=
operator|(
literal|1024
operator|*
literal|1024
operator|)
operator|||
name|addr
operator|<
literal|1024
condition|)
return|return
name|NULL
return|;
else|else
return|return
operator|(
name|void
operator|*
operator|)
name|addr
return|;
block|}
end_function

begin_comment
comment|/* Malloc a new handle */
end_comment

begin_function
specifier|static
name|EMS_handle
modifier|*
name|get_new_handle
parameter_list|(
name|long
name|npages
parameter_list|)
block|{
name|EMS_handle
modifier|*
name|ehp
decl_stmt|;
name|size_t
name|dynsize
init|=
sizeof|sizeof
argument_list|(
name|EMS_handle
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|short
argument_list|)
operator|*
name|npages
decl_stmt|;
if|if
condition|(
operator|(
name|ehp
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
name|dynsize
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"Cannot malloc EMS handle, cannot continue\n"
argument_list|)
expr_stmt|;
return|return
name|ehp
return|;
block|}
end_function

begin_comment
comment|/* Allocate a mapping context to a handle */
end_comment

begin_function
specifier|static
name|void
name|context_to_handle
parameter_list|(
name|short
name|handle
parameter_list|)
block|{
name|EMS_mapping_context
modifier|*
name|emc
decl_stmt|;
if|if
condition|(
name|ems_handle
index|[
name|handle
index|]
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"EMS context_to_handle called with invalid handle\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|emc
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|EMS_mapping_context
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"EMS Cannot malloc mapping context, cannot continue\n"
argument_list|)
expr_stmt|;
name|ems_handle
index|[
name|handle
index|]
operator|->
name|mcontext
operator|=
name|emc
expr_stmt|;
name|memmove
argument_list|(
operator|(
name|void
operator|*
operator|)
name|emc
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|ems_mapping_context
argument_list|,
sizeof|sizeof
argument_list|(
name|EMS_mapping_context
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Find the next free handle, returns -1 if there are no more handles */
end_comment

begin_function
specifier|static
name|long
name|find_next_free_handle
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|ems_alloc_handles
operator|>=
literal|255
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* handle 0 is OS handle */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|EMS_NUM_HANDLES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ems_handle
index|[
name|i
index|]
operator|==
name|NULL
condition|)
return|return
operator|(
name|i
operator|)
return|;
block|}
name|fatal
argument_list|(
literal|"EMS handle count garbled, should not happen\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Look for a named handle, returns 0 if not found, else handle */
end_comment

begin_function
specifier|static
name|short
name|lookup_handle
parameter_list|(
name|Hname
modifier|*
name|hp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|EMS_NUM_HANDLES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ems_handle
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|hp
operator|->
name|ul_hn
index|[
literal|0
index|]
operator|==
name|ems_handle
index|[
name|i
index|]
operator|->
name|hname
operator|.
name|ul_hn
index|[
literal|0
index|]
operator|&&
name|hp
operator|->
name|ul_hn
index|[
literal|1
index|]
operator|==
name|ems_handle
index|[
name|i
index|]
operator|->
name|hname
operator|.
name|ul_hn
index|[
literal|1
index|]
condition|)
return|return
operator|(
name|i
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Malloc a new handle struct and put into array at index handle */
end_comment

begin_function
specifier|static
name|void
name|allocate_handle
parameter_list|(
name|short
name|handle
parameter_list|,
name|long
name|npages
parameter_list|)
block|{
if|if
condition|(
name|ems_handle
index|[
name|handle
index|]
operator|!=
name|NULL
condition|)
name|fatal
argument_list|(
literal|"EMS allocate_handle, handle was not free\n"
argument_list|)
expr_stmt|;
name|ems_handle
index|[
name|handle
index|]
operator|=
name|get_new_handle
argument_list|(
name|npages
argument_list|)
expr_stmt|;
name|ems_alloc_handles
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Free a handle, return its memory. Call this *after* freeing the  * allocated pages !  */
end_comment

begin_function
specifier|static
name|void
name|free_handle
parameter_list|(
name|short
name|handle
parameter_list|)
block|{
if|if
condition|(
name|ems_handle
index|[
name|handle
index|]
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"EMS free_handle, handle was free\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ems_handle
index|[
name|handle
index|]
operator|->
name|mcontext
operator|!=
name|NULL
condition|)
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|ems_handle
index|[
name|handle
index|]
operator|->
name|mcontext
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|ems_handle
index|[
name|handle
index|]
argument_list|)
expr_stmt|;
name|ems_handle
index|[
name|handle
index|]
operator|=
name|NULL
expr_stmt|;
name|ems_alloc_handles
operator|--
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Allocates npages to handle. Call this routine only after you have  * ensured there are enough free pages *and* the new handle is in place  * in the handle array !  */
end_comment

begin_function
specifier|static
name|void
name|allocate_pages_to_handle
parameter_list|(
name|u_short
name|handle
parameter_list|,
name|long
name|npages
parameter_list|)
block|{
name|int
name|syspagenum
decl_stmt|;
name|int
name|pages_to_alloc
init|=
name|npages
decl_stmt|;
name|int
name|allocpagenum
init|=
literal|0
decl_stmt|;
comment|/* sanity */
if|if
condition|(
name|handle
operator|>
literal|255
operator|||
name|ems_handle
index|[
name|handle
index|]
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"EMS allocate_pages_to_handle called with invalid handle\n"
argument_list|)
expr_stmt|;
name|ems_handle
index|[
name|handle
index|]
operator|->
name|npages
operator|=
name|npages
expr_stmt|;
for|for
control|(
name|syspagenum
operator|=
literal|0
init|;
name|syspagenum
operator|<
name|ems_total_pages
condition|;
name|syspagenum
operator|++
control|)
block|{
if|if
condition|(
name|ems_page
index|[
name|syspagenum
index|]
operator|.
name|status
operator|==
name|EMS_FREE
condition|)
block|{
name|ems_page
index|[
name|syspagenum
index|]
operator|.
name|handle
operator|=
name|handle
expr_stmt|;
name|ems_page
index|[
name|syspagenum
index|]
operator|.
name|status
operator|=
name|EMS_ALLOCED
expr_stmt|;
name|ems_handle
index|[
name|handle
index|]
operator|->
name|pagenum
index|[
name|allocpagenum
index|]
operator|=
name|syspagenum
expr_stmt|;
name|allocpagenum
operator|++
expr_stmt|;
name|pages_to_alloc
operator|--
expr_stmt|;
if|if
condition|(
name|pages_to_alloc
operator|==
literal|0
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|pages_to_alloc
operator|>
literal|0
condition|)
name|fatal
argument_list|(
literal|"EMS allocate_pages_to_handle found not enough free pages\n"
argument_list|)
expr_stmt|;
name|ems_alloc_pages
operator|+=
name|npages
expr_stmt|;
name|ems_free_pages
operator|-=
name|npages
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Reallocates npages to handle. Call this routine only after you have  * ensured there are enough free pages *and* the new handle is in place  * in the handle array !  */
end_comment

begin_function
specifier|static
name|void
name|reallocate_pages_to_handle
parameter_list|(
name|u_short
name|handle
parameter_list|,
name|long
name|npages
parameter_list|)
block|{
name|int
name|syspagenum
decl_stmt|;
name|int
name|pages_to_alloc
decl_stmt|;
name|int
name|allocpagenum
decl_stmt|;
name|long
name|delta
decl_stmt|;
name|size_t
name|dynsize
decl_stmt|;
name|EMS_handle
modifier|*
name|emp
decl_stmt|;
comment|/* sanity */
if|if
condition|(
name|handle
operator|>
literal|255
operator|||
name|ems_handle
index|[
name|handle
index|]
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"EMS allocate_pages_to_handle called with invalid handle\n"
argument_list|)
expr_stmt|;
name|delta
operator|=
name|npages
operator|-
name|ems_handle
index|[
name|handle
index|]
operator|->
name|npages
expr_stmt|;
if|if
condition|(
name|delta
operator|>
literal|0
condition|)
block|{
comment|/* Grow array size and allocation */
name|emp
operator|=
name|ems_handle
index|[
name|handle
index|]
expr_stmt|;
name|dynsize
operator|=
sizeof|sizeof
argument_list|(
name|EMS_handle
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|short
argument_list|)
operator|*
name|npages
expr_stmt|;
comment|/* First step: Make room in the handle pagenum array */
if|if
condition|(
operator|(
name|emp
operator|=
operator|(
name|EMS_handle
operator|*
operator|)
name|realloc
argument_list|(
operator|(
name|void
operator|*
operator|)
name|emp
argument_list|,
name|dynsize
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"Cannot malloc EMS handle, cannot continue\n"
argument_list|)
expr_stmt|;
name|ems_handle
index|[
name|handle
index|]
operator|=
name|emp
expr_stmt|;
comment|/* Second step: Add pages to the handle */
name|pages_to_alloc
operator|=
name|delta
expr_stmt|;
name|allocpagenum
operator|=
name|ems_handle
index|[
name|handle
index|]
operator|->
name|npages
expr_stmt|;
name|ems_handle
index|[
name|handle
index|]
operator|->
name|npages
operator|=
name|npages
expr_stmt|;
for|for
control|(
name|syspagenum
operator|=
literal|0
init|;
name|syspagenum
operator|<
name|ems_total_pages
condition|;
name|syspagenum
operator|++
control|)
block|{
if|if
condition|(
name|ems_page
index|[
name|syspagenum
index|]
operator|.
name|status
operator|==
name|EMS_FREE
condition|)
block|{
name|ems_page
index|[
name|syspagenum
index|]
operator|.
name|handle
operator|=
name|handle
expr_stmt|;
name|ems_page
index|[
name|syspagenum
index|]
operator|.
name|status
operator|=
name|EMS_ALLOCED
expr_stmt|;
name|ems_handle
index|[
name|handle
index|]
operator|->
name|pagenum
index|[
name|allocpagenum
index|]
operator|=
name|syspagenum
expr_stmt|;
name|allocpagenum
operator|++
expr_stmt|;
name|pages_to_alloc
operator|--
expr_stmt|;
if|if
condition|(
name|pages_to_alloc
operator|==
literal|0
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|pages_to_alloc
operator|>
literal|0
condition|)
name|fatal
argument_list|(
literal|"EMS allocate_pages_to_handle found not enough free pages\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Shrink array size and allocation */
comment|/* First step: Deallocate all pages from new size to old size */
for|for
control|(
name|allocpagenum
operator|=
name|npages
init|;
name|allocpagenum
operator|<
name|ems_handle
index|[
name|handle
index|]
operator|->
name|npages
condition|;
name|allocpagenum
operator|++
control|)
block|{
name|syspagenum
operator|=
name|ems_handle
index|[
name|handle
index|]
operator|->
name|pagenum
index|[
name|allocpagenum
index|]
expr_stmt|;
comment|/* sanity */
if|if
condition|(
name|syspagenum
operator|>
name|ems_total_pages
condition|)
name|fatal
argument_list|(
literal|"EMS free_pages_of_handle found invalid page number\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ems_page
index|[
name|syspagenum
index|]
operator|.
name|status
operator|&
name|EMS_ALLOCED
operator|)
condition|)
name|fatal
argument_list|(
literal|"EMS free_pages_of_handle tried to free page already free\n"
argument_list|)
expr_stmt|;
name|ems_page
index|[
name|syspagenum
index|]
operator|.
name|handle
operator|=
literal|0
expr_stmt|;
name|ems_page
index|[
name|syspagenum
index|]
operator|.
name|status
operator|=
name|EMS_FREE
expr_stmt|;
block|}
comment|/* Second step: Shrink the dynamic array of the handle */
name|dynsize
operator|=
sizeof|sizeof
argument_list|(
name|EMS_handle
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|short
argument_list|)
operator|*
name|npages
expr_stmt|;
name|emp
operator|=
name|ems_handle
index|[
name|handle
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|emp
operator|=
operator|(
name|EMS_handle
operator|*
operator|)
name|realloc
argument_list|(
operator|(
name|void
operator|*
operator|)
name|emp
argument_list|,
name|dynsize
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"Cannot realloc EMS handle, cannot continue\n"
argument_list|)
expr_stmt|;
name|ems_handle
index|[
name|handle
index|]
operator|=
name|emp
expr_stmt|;
name|ems_handle
index|[
name|handle
index|]
operator|->
name|npages
operator|=
name|npages
expr_stmt|;
block|}
name|ems_alloc_pages
operator|+=
name|delta
expr_stmt|;
name|ems_free_pages
operator|-=
name|delta
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Free all pages belonging to a handle, handle must be valid */
end_comment

begin_function
specifier|static
name|void
name|free_pages_of_handle
parameter_list|(
name|short
name|handle
parameter_list|)
block|{
name|int
name|allocpagenum
decl_stmt|;
name|int
name|syspagenum
decl_stmt|;
name|int
name|npages
decl_stmt|;
comment|/* sanity */
if|if
condition|(
name|handle
operator|>
literal|255
operator|||
name|ems_handle
index|[
name|handle
index|]
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"EMS free_pages_of_handle called with invalid handle\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|npages
operator|=
name|ems_handle
index|[
name|handle
index|]
operator|->
name|npages
operator|)
operator|==
literal|0
condition|)
return|return;
for|for
control|(
name|allocpagenum
operator|=
literal|0
init|;
name|allocpagenum
operator|<
name|npages
condition|;
name|allocpagenum
operator|++
control|)
block|{
name|syspagenum
operator|=
name|ems_handle
index|[
name|handle
index|]
operator|->
name|pagenum
index|[
name|allocpagenum
index|]
expr_stmt|;
comment|/* sanity */
if|if
condition|(
name|syspagenum
operator|>
name|ems_total_pages
condition|)
name|fatal
argument_list|(
literal|"EMS free_pages_of_handle found invalid page number\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ems_page
index|[
name|syspagenum
index|]
operator|.
name|status
operator|&
name|EMS_ALLOCED
operator|)
condition|)
name|fatal
argument_list|(
literal|"EMS free_pages_of_handle tried to free page already free\n"
argument_list|)
expr_stmt|;
name|ems_page
index|[
name|syspagenum
index|]
operator|.
name|handle
operator|=
literal|0
expr_stmt|;
name|ems_page
index|[
name|syspagenum
index|]
operator|.
name|status
operator|=
name|EMS_FREE
expr_stmt|;
block|}
name|ems_alloc_pages
operator|-=
name|npages
expr_stmt|;
name|ems_free_pages
operator|+=
name|npages
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Restore a saved mapping context, overwrites current mapping context */
end_comment

begin_function
specifier|static
name|void
name|restore_context
parameter_list|(
name|EMS_mapping_context
modifier|*
name|emc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|ems_mapping_context
operator|.
name|handle
index|[
name|i
index|]
operator|=
name|emc
operator|->
name|handle
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|emc
operator|->
name|pos_mapped
index|[
name|i
index|]
operator|!=
literal|0
operator|&&
name|ems_mapping_context
operator|.
name|pos_pagenum
index|[
name|i
index|]
operator|!=
name|emc
operator|->
name|pos_pagenum
index|[
name|i
index|]
condition|)
block|{
name|map_page
argument_list|(
name|emc
operator|->
name|pos_pagenum
index|[
name|i
index|]
argument_list|,
operator|(
name|u_char
operator|)
name|i
argument_list|,
name|emc
operator|->
name|handle
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ems_mapping_context
operator|.
name|pos_mapped
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Prepare a special context save block for DOS and save it to  * VM86 memory  */
end_comment

begin_function
specifier|static
name|void
name|save_context_to_dos
parameter_list|(
name|EMScontext
modifier|*
name|emp
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|end
decl_stmt|;
name|EMScontext
name|context
decl_stmt|;
name|u_short
modifier|*
name|sp
decl_stmt|;
name|u_short
name|sum
decl_stmt|;
name|context
operator|.
name|ems_saved_context
operator|=
name|ems_mapping_context
expr_stmt|;
name|context
operator|.
name|magic
operator|=
name|EMS_SAVEMAGIC
expr_stmt|;
name|context
operator|.
name|checksum
operator|=
literal|0
expr_stmt|;
name|sp
operator|=
operator|(
name|u_short
operator|*
operator|)
operator|&
name|context
expr_stmt|;
name|end
operator|=
sizeof|sizeof
argument_list|(
name|EMScontext
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|short
argument_list|)
expr_stmt|;
comment|/* Generate checksum */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|sum
operator|=
literal|0
init|;
name|i
operator|<
name|end
condition|;
name|i
operator|++
control|)
block|{
name|sum
operator|+=
operator|*
name|sp
operator|++
expr_stmt|;
name|sum
operator|&=
literal|0xffff
expr_stmt|;
block|}
name|context
operator|.
name|checksum
operator|=
literal|0x10000L
operator|-
name|sum
expr_stmt|;
comment|/* Save it to VM86 memory */
operator|*
name|emp
operator|=
name|context
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Check a context returned from VM86 app for validity, return 0, if  * not valid, else return 1  */
end_comment

begin_function
specifier|static
name|int
name|check_saved_context
parameter_list|(
name|EMScontext
modifier|*
name|emp
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|end
decl_stmt|;
name|u_short
modifier|*
name|sp
decl_stmt|;
name|u_short
name|sum
decl_stmt|;
if|if
condition|(
name|emp
operator|->
name|magic
operator|!=
name|EMS_SAVEMAGIC
condition|)
return|return
literal|0
return|;
name|sp
operator|=
operator|(
name|u_short
operator|*
operator|)
name|emp
expr_stmt|;
name|end
operator|=
sizeof|sizeof
argument_list|(
name|EMScontext
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|short
argument_list|)
expr_stmt|;
comment|/* Generate checksum */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|sum
operator|=
literal|0
init|;
name|i
operator|<
name|end
condition|;
name|i
operator|++
control|)
block|{
name|sum
operator|+=
operator|*
name|sp
operator|++
expr_stmt|;
name|sum
operator|&=
literal|0xffff
expr_stmt|;
block|}
if|if
condition|(
name|sum
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
else|else
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Helper routine for the move routines below: Check if length bytes  * can be moved from/to handle pages (i.e are there enough pages)  */
end_comment

begin_function
specifier|static
name|int
name|check_alloc_pages
parameter_list|(
name|u_short
name|handle
parameter_list|,
name|u_short
name|firstpage
parameter_list|,
name|u_short
name|offset
parameter_list|,
name|u_long
name|length
parameter_list|)
block|{
name|u_long
name|nbytes
decl_stmt|;
if|if
condition|(
name|firstpage
operator|>
name|ems_handle
index|[
name|handle
index|]
operator|->
name|npages
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|nbytes
operator|=
operator|(
name|ems_handle
index|[
name|handle
index|]
operator|->
name|npages
operator|-
name|firstpage
operator|)
operator|*
name|EMS_PAGESIZE
operator|-
name|offset
expr_stmt|;
return|return
operator|(
name|ems_handle
index|[
name|handle
index|]
operator|->
name|npages
operator|>=
name|nbytes
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Copy a block of memory up to the next 16kB boundary in the source  * to the destination in upward direction (i.e. with ascending addresses)  * XXX Could be an inline function.  */
end_comment

begin_function
specifier|static
name|void
name|copy_block_up
parameter_list|(
name|struct
name|copydesc
modifier|*
name|cdp
parameter_list|)
block|{
name|size_t
name|size
decl_stmt|;
name|void
modifier|*
name|srcp
decl_stmt|;
name|void
modifier|*
name|dstp
decl_stmt|;
comment|/* If source or both memory types are EMS, source determines the      * block lenght, else destination determines the block lenght      */
if|if
condition|(
name|cdp
operator|->
name|copytype
operator|&
name|SRC_EMS
condition|)
name|size
operator|=
name|EMS_PAGESIZE
operator|-
name|cdp
operator|->
name|EMS_OFFS
argument_list|(
name|src_addr
argument_list|)
expr_stmt|;
else|else
name|size
operator|=
name|EMS_PAGESIZE
operator|-
name|cdp
operator|->
name|EMS_OFFS
argument_list|(
name|dst_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|>
name|cdp
operator|->
name|rest_len
condition|)
name|size
operator|=
name|cdp
operator|->
name|rest_len
expr_stmt|;
comment|/* If src is EMS memory, it is mapped into position 0 */
if|if
condition|(
name|cdp
operator|->
name|copytype
operator|&
name|SRC_EMS
condition|)
name|srcp
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|ems_frame_addr
operator|+
name|cdp
operator|->
name|EMS_OFFS
argument_list|(
name|src_addr
argument_list|)
operator|)
expr_stmt|;
else|else
name|srcp
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|cdp
operator|->
name|EMS_PTR
argument_list|(
name|src_addr
argument_list|)
operator|)
expr_stmt|;
comment|/* If dest is EMS memory, it is mapped into position 1,2 */
if|if
condition|(
name|cdp
operator|->
name|copytype
operator|&
name|DST_EMS
condition|)
name|dstp
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|ems_frame_addr
operator|+
name|EMS_PAGESIZE
operator|+
name|cdp
operator|->
name|EMS_OFFS
argument_list|(
name|dst_addr
argument_list|)
operator|)
expr_stmt|;
else|else
name|dstp
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|cdp
operator|->
name|EMS_PTR
argument_list|(
name|dst_addr
argument_list|)
operator|)
expr_stmt|;
comment|/* Move this block */
name|memmove
argument_list|(
name|dstp
argument_list|,
name|srcp
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|/* Update the copy descriptor: This updates the address of both       * conventional and EMS memory       */
name|cdp
operator|->
name|EMS_PTR
argument_list|(
name|src_addr
argument_list|)
operator|+=
name|size
expr_stmt|;
name|cdp
operator|->
name|EMS_PTR
argument_list|(
name|dst_addr
argument_list|)
operator|+=
name|size
expr_stmt|;
name|cdp
operator|->
name|rest_len
operator|-=
name|size
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Move EMS memory starting with handle page src_seg and offset src_offset  * to conventional memory dst_addr for length bytes  * dst_addr is checked, handle is valid   */
end_comment

begin_function
specifier|static
name|u_long
name|move_ems_to_conv
parameter_list|(
name|short
name|src_handle
parameter_list|,
name|u_short
name|src_seg
parameter_list|,
name|u_short
name|src_offset
parameter_list|,
name|u_long
name|dst_addr
parameter_list|,
name|u_long
name|length
parameter_list|)
block|{
name|EMS_mapping_context
name|ems_saved_context
decl_stmt|;
name|EMS_handle
modifier|*
name|ehp
decl_stmt|;
name|int
name|pageindx
init|=
name|src_seg
decl_stmt|;
name|struct
name|copydesc
name|cd
decl_stmt|;
if|if
condition|(
name|check_alloc_pages
argument_list|(
name|src_handle
argument_list|,
name|src_seg
argument_list|,
name|src_offset
argument_list|,
name|length
argument_list|)
operator|==
literal|0
condition|)
return|return
name|EMS_MOVE_OVERFLOW
return|;
name|ehp
operator|=
name|ems_handle
index|[
name|src_handle
index|]
expr_stmt|;
comment|/* Prepare the move: Save the mapping context */
name|ems_saved_context
operator|=
name|ems_mapping_context
expr_stmt|;
comment|/* Setup the copy descriptor struct */
name|cd
operator|.
name|copytype
operator|=
name|SRC_EMS
expr_stmt|;
name|cd
operator|.
name|EMS_PAGE
argument_list|(
name|src_addr
argument_list|)
operator|=
name|ehp
operator|->
name|pagenum
index|[
name|pageindx
index|]
expr_stmt|;
name|cd
operator|.
name|EMS_OFFS
argument_list|(
name|src_addr
argument_list|)
operator|=
name|src_offset
expr_stmt|;
name|cd
operator|.
name|EMS_PTR
argument_list|(
name|dst_addr
argument_list|)
operator|=
name|dst_addr
expr_stmt|;
name|cd
operator|.
name|rest_len
operator|=
name|length
expr_stmt|;
do|do
block|{
comment|/* Map for the first block copy, source is mapped to position zero */
name|map_page
argument_list|(
name|cd
operator|.
name|EMS_PAGE
argument_list|(
name|src_addr
argument_list|)
argument_list|,
literal|0
argument_list|,
name|src_handle
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|copy_block_up
argument_list|(
operator|&
name|cd
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|cd
operator|.
name|rest_len
operator|>
literal|0
condition|)
do|;
comment|/* Restore the original mapping */
name|restore_context
argument_list|(
operator|&
name|ems_saved_context
argument_list|)
expr_stmt|;
return|return
name|EMS_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* Move conventional memory starting with src_addr  * to EMS memory starting with handle page src_seg and offset src_offset  * for length bytes  * dst_addr is checked, handle is valid   */
end_comment

begin_function
specifier|static
name|u_long
name|move_conv_to_ems
parameter_list|(
name|u_long
name|src_addr
parameter_list|,
name|u_short
name|dst_handle
parameter_list|,
name|u_short
name|dst_seg
parameter_list|,
name|u_short
name|dst_offset
parameter_list|,
name|u_long
name|length
parameter_list|)
block|{
name|EMS_mapping_context
name|ems_saved_context
decl_stmt|;
name|EMS_handle
modifier|*
name|ehp
decl_stmt|;
name|int
name|pageindx
init|=
name|dst_seg
decl_stmt|;
name|struct
name|copydesc
name|cd
decl_stmt|;
if|if
condition|(
name|check_alloc_pages
argument_list|(
name|dst_handle
argument_list|,
name|dst_seg
argument_list|,
name|dst_offset
argument_list|,
name|length
argument_list|)
operator|==
literal|0
condition|)
return|return
name|EMS_MOVE_OVERFLOW
return|;
name|ehp
operator|=
name|ems_handle
index|[
name|dst_handle
index|]
expr_stmt|;
comment|/* Prepare the move: Save the mapping context */
name|ems_saved_context
operator|=
name|ems_mapping_context
expr_stmt|;
comment|/* Setup the copy descriptor struct */
name|cd
operator|.
name|copytype
operator|=
name|DST_EMS
expr_stmt|;
name|cd
operator|.
name|EMS_PAGE
argument_list|(
name|dst_addr
argument_list|)
operator|=
name|ehp
operator|->
name|pagenum
index|[
name|pageindx
index|]
expr_stmt|;
name|cd
operator|.
name|EMS_OFFS
argument_list|(
name|dst_addr
argument_list|)
operator|=
name|dst_offset
expr_stmt|;
name|cd
operator|.
name|EMS_PTR
argument_list|(
name|src_addr
argument_list|)
operator|=
name|src_addr
expr_stmt|;
name|cd
operator|.
name|rest_len
operator|=
name|length
expr_stmt|;
do|do
block|{
name|map_page
argument_list|(
name|cd
operator|.
name|EMS_PAGE
argument_list|(
name|dst_addr
argument_list|)
argument_list|,
literal|1
argument_list|,
name|dst_handle
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|copy_block_up
argument_list|(
operator|&
name|cd
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|cd
operator|.
name|rest_len
operator|>
literal|0
condition|)
do|;
comment|/* Restore the original mapping */
name|restore_context
argument_list|(
operator|&
name|ems_saved_context
argument_list|)
expr_stmt|;
return|return
name|EMS_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|u_long
name|move_ems_to_ems
parameter_list|(
name|u_short
name|src_handle
parameter_list|,
name|u_short
name|src_seg
parameter_list|,
name|u_short
name|src_offset
parameter_list|,
name|u_short
name|dst_handle
parameter_list|,
name|u_short
name|dst_seg
parameter_list|,
name|u_short
name|dst_offset
parameter_list|,
name|u_long
name|length
parameter_list|)
block|{
name|EMS_mapping_context
name|ems_saved_context
decl_stmt|;
name|EMS_handle
modifier|*
name|src_hp
decl_stmt|,
modifier|*
name|dst_hp
decl_stmt|;
name|struct
name|copydesc
name|cd
decl_stmt|;
if|if
condition|(
name|check_alloc_pages
argument_list|(
name|src_handle
argument_list|,
name|src_seg
argument_list|,
name|src_offset
argument_list|,
name|length
argument_list|)
operator|==
literal|0
condition|)
return|return
name|EMS_MOVE_OVERFLOW
return|;
if|if
condition|(
name|check_alloc_pages
argument_list|(
name|dst_handle
argument_list|,
name|dst_seg
argument_list|,
name|dst_offset
argument_list|,
name|length
argument_list|)
operator|==
literal|0
condition|)
return|return
name|EMS_MOVE_OVERFLOW
return|;
name|src_hp
operator|=
name|ems_handle
index|[
name|src_handle
index|]
expr_stmt|;
name|dst_hp
operator|=
name|ems_handle
index|[
name|dst_handle
index|]
expr_stmt|;
comment|/* Prepare the move: Save the mapping context */
name|ems_saved_context
operator|=
name|ems_mapping_context
expr_stmt|;
comment|/* Setup the copy descriptor struct */
name|cd
operator|.
name|copytype
operator|=
name|SRC_EMS
operator||
name|DST_EMS
expr_stmt|;
name|cd
operator|.
name|EMS_PAGE
argument_list|(
name|src_addr
argument_list|)
operator|=
name|src_hp
operator|->
name|pagenum
index|[
name|src_seg
index|]
expr_stmt|;
name|cd
operator|.
name|EMS_OFFS
argument_list|(
name|src_addr
argument_list|)
operator|=
name|src_offset
expr_stmt|;
name|cd
operator|.
name|EMS_PAGE
argument_list|(
name|dst_addr
argument_list|)
operator|=
name|dst_hp
operator|->
name|pagenum
index|[
name|dst_seg
index|]
expr_stmt|;
name|cd
operator|.
name|EMS_OFFS
argument_list|(
name|dst_addr
argument_list|)
operator|=
name|dst_offset
expr_stmt|;
name|cd
operator|.
name|rest_len
operator|=
name|length
expr_stmt|;
comment|/* Copy */
do|do
block|{
name|map_page
argument_list|(
name|cd
operator|.
name|EMS_PAGE
argument_list|(
name|src_addr
argument_list|)
argument_list|,
literal|0
argument_list|,
name|src_handle
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|map_page
argument_list|(
name|cd
operator|.
name|EMS_PAGE
argument_list|(
name|dst_addr
argument_list|)
argument_list|,
literal|1
argument_list|,
name|dst_handle
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If there are more pages, map the next destination page to          * position 2. This removes a compare between source and dest          * offsets.          */
if|if
condition|(
name|cd
operator|.
name|EMS_PAGE
argument_list|(
name|dst_addr
argument_list|)
operator|<
name|dst_hp
operator|->
name|npages
condition|)
name|map_page
argument_list|(
operator|(
name|cd
operator|.
name|EMS_PAGE
argument_list|(
name|dst_addr
argument_list|)
operator|+
literal|1
operator|)
argument_list|,
literal|2
argument_list|,
name|dst_handle
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|copy_block_up
argument_list|(
operator|&
name|cd
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|cd
operator|.
name|rest_len
operator|>
literal|0
condition|)
do|;
comment|/* Restore the original mapping */
name|restore_context
argument_list|(
operator|&
name|ems_saved_context
argument_list|)
expr_stmt|;
return|return
name|EMS_SUCCESS
return|;
block|}
end_function

end_unit

