begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1992, 1993, 1996  *	Berkeley Software Design, Inc.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by Berkeley Software  *	Design, Inc.  *  * THIS SOFTWARE IS PROVIDED BY Berkeley Software Design, Inc. ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL Berkeley Software Design, Inc. BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	BSDI int13.c,v 2.3 1996/04/08 19:32:43 bostic Exp  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"doscmd.h"
end_include

begin_define
define|#
directive|define
name|FDCHANGED
value|_IOR('F', 64, int)
end_define

begin_define
define|#
directive|define
name|INT13_ERR_NONE
value|0x00
end_define

begin_define
define|#
directive|define
name|INT13_ERR_BAD_COMMAND
value|0x01
end_define

begin_define
define|#
directive|define
name|INT13_ERR_BAD_ADDRESS_MARK
value|0x02
end_define

begin_define
define|#
directive|define
name|INT13_ERR_WRITE_PROTECT
value|0x03
end_define

begin_define
define|#
directive|define
name|INT13_ERR_SECTOR_ID_BAD
value|0x04
end_define

begin_define
define|#
directive|define
name|INT13_ERR_RESET_FAILURE
value|0x05
end_define

begin_define
define|#
directive|define
name|INT13_ERR_CLL_ACTIVE
value|0x06
end_define

begin_define
define|#
directive|define
name|INT13_ERR_ACT_FAILED
value|0x07
end_define

begin_define
define|#
directive|define
name|INT13_ERR_DMA_OVERRUN
value|0x08
end_define

begin_define
define|#
directive|define
name|INT13_ERR_DMA_BOUNDARY
value|0x09
end_define

begin_define
define|#
directive|define
name|INT13_ERR_BAD_TRACK_FLAG
value|0x0B
end_define

begin_define
define|#
directive|define
name|INT13_ERR_MEDIA_TYP_UNKNOWN
value|0x0C
end_define

begin_define
define|#
directive|define
name|INT13_ERR_CRC
value|0x10
end_define

begin_define
define|#
directive|define
name|INT13_ERR_CORRECTED
value|0x11
end_define

begin_define
define|#
directive|define
name|INT13_ERR_CTRLR_FAILURE
value|0x20
end_define

begin_define
define|#
directive|define
name|INT13_ERR_SEEK
value|0x40
end_define

begin_define
define|#
directive|define
name|INT13_ERR_TIME_OUT
value|0x80
end_define

begin_define
define|#
directive|define
name|INT13_ERR_NOT_READY
value|0xAA
end_define

begin_define
define|#
directive|define
name|INT13_ERR_UNDEFINED
value|0xBB
end_define

begin_define
define|#
directive|define
name|INT13_ERR_SENSE_OPERATION
value|0xFF
end_define

begin_typedef
typedef|typedef
struct|struct
block|{
name|u_char
name|bootIndicator
decl_stmt|;
name|u_char
name|beginHead
decl_stmt|;
name|u_char
name|beginSector
decl_stmt|;
name|u_char
name|beginCyl
decl_stmt|;
name|u_char
name|systemID
decl_stmt|;
name|u_char
name|endHead
decl_stmt|;
name|u_char
name|endSector
decl_stmt|;
name|u_char
name|endCyl
decl_stmt|;
name|u_long
name|relSector
decl_stmt|;
name|u_long
name|numSectors
decl_stmt|;
block|}
name|PTAB
typedef|;
end_typedef

begin_struct
struct|struct
name|diskinfo
block|{
name|int
name|type
decl_stmt|;
name|int
name|sectors
decl_stmt|;
name|int
name|cylinders
decl_stmt|;
name|int
name|sides
decl_stmt|;
name|int
name|secsize
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|char
modifier|*
name|path
decl_stmt|;
name|u_long
name|location
decl_stmt|;
name|u_char
modifier|*
name|sector0
decl_stmt|;
name|u_long
name|offset
decl_stmt|;
name|char
modifier|*
name|list
index|[
literal|4
index|]
decl_stmt|;
comment|/* Up to 4 devices allowed */
name|unsigned
name|multi
range|:
literal|2
decl_stmt|;
name|int
name|read_only
range|:
literal|1
decl_stmt|;
name|int
name|removeable
range|:
literal|1
decl_stmt|;
name|int
name|changed
range|:
literal|1
decl_stmt|;
comment|/* Set if we change format */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|hd_status
value|(*(u_char *)0x474)
end_define

begin_define
define|#
directive|define
name|fd_status
value|(*(u_char *)0x441)
end_define

begin_function
specifier|static
specifier|inline
name|int
name|disize
parameter_list|(
name|struct
name|diskinfo
modifier|*
name|di
parameter_list|)
block|{
return|return
operator|(
name|di
operator|->
name|sectors
operator|*
name|di
operator|->
name|cylinders
operator|*
name|di
operator|->
name|sides
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|cylsize
parameter_list|(
name|struct
name|diskinfo
modifier|*
name|di
parameter_list|)
block|{
return|return
operator|(
name|di
operator|->
name|sectors
operator|*
name|di
operator|->
name|sides
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|u_long
name|ftable
init|=
literal|0xF1000
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Floppy table */
end_comment

begin_decl_stmt
specifier|static
name|u_long
name|htable
init|=
literal|0xF1020
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Hard disk table */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|diskinfo
name|diskinfo
index|[
literal|26
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|diskinfo
name|floppyinfo
index|[]
init|=
block|{
block|{
literal|0
block|,
literal|9
block|,
literal|40
block|,
literal|1
block|,
literal|512
block|,
operator|-
literal|1
block|,
literal|0
block|,
literal|0
block|, }
block|,
comment|/* Probably not correct */
block|{
literal|1
block|,
literal|9
block|,
literal|40
block|,
literal|2
block|,
literal|512
block|,
operator|-
literal|1
block|,
literal|0
block|,
literal|0
block|, }
block|,
block|{
literal|2
block|,
literal|9
block|,
literal|80
block|,
literal|2
block|,
literal|512
block|,
operator|-
literal|1
block|,
literal|0
block|,
literal|0
block|, }
block|,
block|{
literal|3
block|,
literal|15
block|,
literal|80
block|,
literal|2
block|,
literal|512
block|,
operator|-
literal|1
block|,
literal|0
block|,
literal|0
block|, }
block|,
block|{
literal|4
block|,
literal|18
block|,
literal|80
block|,
literal|2
block|,
literal|512
block|,
operator|-
literal|1
block|,
literal|0
block|,
literal|0
block|, }
block|,
block|{
literal|6
block|,
literal|36
block|,
literal|80
block|,
literal|2
block|,
literal|512
block|,
operator|-
literal|1
block|,
literal|0
block|,
literal|0
block|, }
block|,
block|{
operator|-
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|, }
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|struct
name|diskinfo
modifier|*
name|getdisk
parameter_list|(
name|int
name|drive
parameter_list|)
block|{
name|struct
name|diskinfo
modifier|*
name|di
decl_stmt|;
if|if
condition|(
name|drive
operator|>=
literal|2
operator|&&
name|drive
operator|<
literal|0x80
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|drive
operator|>=
literal|0x80
condition|)
block|{
name|drive
operator|-=
literal|0x80
expr_stmt|;
name|drive
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|drive
operator|>
literal|25
operator|||
name|diskinfo
index|[
name|drive
index|]
operator|.
name|path
operator|==
literal|0
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|di
operator|=
operator|&
name|diskinfo
index|[
name|drive
index|]
expr_stmt|;
if|if
condition|(
name|di
operator|->
name|fd
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|di
operator|->
name|removeable
condition|)
block|{
name|di
operator|->
name|read_only
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|di
operator|->
name|path
operator|=
name|di
operator|->
name|list
index|[
name|di
operator|->
name|multi
index|]
operator|)
condition|)
name|di
operator|->
name|path
operator|=
name|di
operator|->
name|list
index|[
name|di
operator|->
name|multi
operator|=
literal|0
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|di
operator|->
name|fd
operator|=
name|open
argument_list|(
name|di
operator|->
name|path
argument_list|,
name|di
operator|->
name|read_only
condition|?
name|O_RDONLY
else|:
name|O_RDWR
operator||
name|O_FSYNC
argument_list|)
operator|)
operator|<
literal|0
operator|&&
operator|(
name|di
operator|->
name|read_only
operator|=
literal|1
operator|)
operator|&&
operator|(
name|di
operator|->
name|fd
operator|=
name|open
argument_list|(
name|di
operator|->
name|path
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|di
operator|->
name|fd
operator|=
name|squirrel_fd
argument_list|(
name|di
operator|->
name|fd
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|di
operator|)
return|;
block|}
end_function

begin_function
name|int
name|disk_fd
parameter_list|(
name|int
name|drive
parameter_list|)
block|{
name|struct
name|diskinfo
modifier|*
name|di
decl_stmt|;
if|if
condition|(
name|drive
operator|>
literal|1
condition|)
name|drive
operator|+=
literal|0x80
operator|-
literal|2
expr_stmt|;
name|di
operator|=
name|getdisk
argument_list|(
name|drive
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|di
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
name|di
operator|->
name|fd
operator|)
return|;
block|}
end_function

begin_function
name|void
name|make_readonly
parameter_list|(
name|int
name|drive
parameter_list|)
block|{
if|if
condition|(
name|drive
operator|<
literal|0
operator|||
name|drive
operator|>=
literal|26
condition|)
return|return;
name|diskinfo
index|[
name|drive
index|]
operator|.
name|read_only
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|int
name|init_hdisk
parameter_list|(
name|int
name|drive
parameter_list|,
name|int
name|cyl
parameter_list|,
name|int
name|head
parameter_list|,
name|int
name|tracksize
parameter_list|,
name|char
modifier|*
name|file
parameter_list|,
name|char
modifier|*
name|fake_ptab
parameter_list|)
block|{
name|struct
name|diskinfo
modifier|*
name|di
decl_stmt|;
name|u_long
name|table
decl_stmt|;
if|if
condition|(
name|drive
operator|<
literal|0
condition|)
block|{
for|for
control|(
name|drive
operator|=
literal|2
init|;
name|drive
operator|<
literal|26
condition|;
operator|++
name|drive
control|)
block|{
if|if
condition|(
name|diskinfo
index|[
name|drive
index|]
operator|.
name|path
operator|==
literal|0
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|drive
operator|<
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Only floppies may be assigned to A: or B:\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|drive
operator|>=
literal|26
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Too many disk drives (only 24 allowed)\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|di
operator|=
operator|&
name|diskinfo
index|[
name|drive
index|]
expr_stmt|;
if|if
condition|(
name|di
operator|->
name|path
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Drive %c: already assigned to %s\n"
argument_list|,
name|drntol
argument_list|(
name|drive
argument_list|)
argument_list|,
name|di
operator|->
name|path
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|di
operator|->
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
name|di
operator|->
name|sectors
operator|=
name|tracksize
expr_stmt|;
name|di
operator|->
name|cylinders
operator|=
name|cyl
expr_stmt|;
name|di
operator|->
name|sides
operator|=
name|head
expr_stmt|;
name|di
operator|->
name|sector0
operator|=
literal|0
expr_stmt|;
name|di
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fake_ptab
condition|)
block|{
name|u_char
name|buf
index|[
literal|512
index|]
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|PTAB
modifier|*
name|ptab
decl_stmt|;
name|int
name|clusters
decl_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|fake_ptab
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
name|fake_ptab
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|di
operator|->
name|sector0
operator|=
name|malloc
argument_list|(
literal|512
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|di
operator|->
name|sector0
condition|)
block|{
name|perror
argument_list|(
literal|"malloc in init_hdisk"
argument_list|)
expr_stmt|;
name|quit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|read
argument_list|(
name|fd
argument_list|,
name|di
operator|->
name|sector0
argument_list|,
literal|512
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|ptab
operator|=
operator|(
name|PTAB
operator|*
operator|)
operator|(
name|di
operator|->
name|sector0
operator|+
literal|0x01BE
operator|)
expr_stmt|;
for|for
control|(
name|fd
operator|=
literal|0
init|;
name|fd
operator|<
literal|4
condition|;
operator|++
name|fd
control|)
block|{
if|if
condition|(
operator|*
operator|(
name|u_short
operator|*
operator|)
operator|(
name|di
operator|->
name|sector0
operator|+
literal|0x1FE
operator|)
operator|==
literal|0xAA55
operator|&&
name|ptab
index|[
name|fd
index|]
operator|.
name|numSectors
operator|==
name|head
operator|*
name|tracksize
operator|*
name|cyl
operator|&&
operator|(
name|ptab
index|[
name|fd
index|]
operator|.
name|systemID
operator|==
literal|1
operator|||
name|ptab
index|[
name|fd
index|]
operator|.
name|systemID
operator|==
literal|4
operator|||
name|ptab
index|[
name|fd
index|]
operator|.
name|systemID
operator|==
literal|6
operator|)
condition|)
break|break;
block|}
if|if
condition|(
name|fd
operator|<
literal|4
condition|)
block|{
if|if
condition|(
name|fd
condition|)
name|memcpy
argument_list|(
name|ptab
argument_list|,
name|ptab
operator|+
name|fd
argument_list|,
sizeof|sizeof
argument_list|(
name|PTAB
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|ptab
operator|+
literal|1
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|PTAB
argument_list|)
operator|*
literal|3
argument_list|)
expr_stmt|;
name|di
operator|->
name|offset
operator|=
name|ptab
index|[
literal|0
index|]
operator|.
name|relSector
expr_stmt|;
name|di
operator|->
name|cylinders
operator|+=
name|di
operator|->
name|offset
operator|/
name|cylsize
argument_list|(
name|di
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|memset
argument_list|(
name|ptab
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|PTAB
argument_list|)
operator|*
literal|4
argument_list|)
expr_stmt|;
name|ptab
operator|->
name|beginHead
operator|=
literal|0
expr_stmt|;
name|ptab
operator|->
name|beginSector
operator|=
literal|1
expr_stmt|;
comment|/* this is 1 based */
name|ptab
operator|->
name|beginCyl
operator|=
literal|1
expr_stmt|;
name|ptab
operator|->
name|endHead
operator|=
name|head
operator|-
literal|1
expr_stmt|;
name|ptab
operator|->
name|endSector
operator|=
name|tracksize
expr_stmt|;
comment|/* this is 1 based */
name|ptab
operator|->
name|endCyl
operator|=
name|cyl
operator|&
literal|0xff
expr_stmt|;
name|ptab
operator|->
name|endSector
operator||=
operator|(
name|cyl
operator|&
literal|0x300
operator|)
operator|>>
literal|2
expr_stmt|;
name|ptab
operator|->
name|relSector
operator|=
name|head
operator|*
name|tracksize
expr_stmt|;
name|ptab
operator|->
name|numSectors
operator|=
name|head
operator|*
name|tracksize
operator|*
name|cyl
expr_stmt|;
operator|*
operator|(
name|u_short
operator|*
operator|)
operator|(
name|di
operator|->
name|sector0
operator|+
literal|0x1FE
operator|)
operator|=
literal|0xAA55
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|file
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
name|file
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|memset
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
literal|512
argument_list|)
expr_stmt|;
name|read
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
literal|512
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|clusters
operator|=
name|buf
index|[
literal|0x0D
index|]
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|disize
argument_list|(
name|di
argument_list|)
operator|<=
literal|128
operator|*
literal|2048
condition|)
name|clusters
operator|=
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|disize
argument_list|(
name|di
argument_list|)
operator|<=
literal|256
operator|*
literal|2048
condition|)
name|clusters
operator|=
literal|8
expr_stmt|;
elseif|else
if|if
condition|(
name|disize
argument_list|(
name|di
argument_list|)
operator|<=
literal|8
operator|*
literal|1024
operator|*
literal|2048
condition|)
name|clusters
operator|=
literal|16
expr_stmt|;
elseif|else
if|if
condition|(
name|disize
argument_list|(
name|di
argument_list|)
operator|<=
literal|16
operator|*
literal|1024
operator|*
literal|2048
condition|)
name|clusters
operator|=
literal|32
expr_stmt|;
else|else
name|clusters
operator|=
literal|64
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|disize
argument_list|(
name|di
argument_list|)
operator|/
name|clusters
operator|)
operator|<=
literal|4096
condition|)
block|{
name|ptab
operator|->
name|systemID
operator|=
literal|0x01
expr_stmt|;
block|}
else|else
block|{
name|ptab
operator|->
name|systemID
operator|=
literal|0x04
expr_stmt|;
block|}
name|di
operator|->
name|cylinders
operator|+=
literal|1
expr_stmt|;
comment|/* Extra cylinder for partition table, etc. */
block|}
name|ptab
operator|->
name|bootIndicator
operator|=
literal|0x80
expr_stmt|;
block|}
name|di
operator|->
name|type
operator|=
literal|0xf8
expr_stmt|;
name|di
operator|->
name|path
operator|=
name|file
expr_stmt|;
name|di
operator|->
name|secsize
operator|=
literal|512
expr_stmt|;
name|di
operator|->
name|path
operator|=
name|strdup
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|di
operator|->
name|location
operator|=
operator|(
operator|(
name|table
operator|&
literal|0xf0000
operator|)
operator|<<
literal|12
operator|)
operator||
operator|(
name|table
operator|&
literal|0xffff
operator|)
expr_stmt|;
if|if
condition|(
name|drive
operator|==
literal|0
condition|)
block|{
name|ivec
index|[
literal|0x41
index|]
operator|=
name|di
operator|->
name|location
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|drive
operator|==
literal|1
condition|)
block|{
name|ivec
index|[
literal|0x46
index|]
operator|=
name|di
operator|->
name|location
expr_stmt|;
block|}
name|table
operator|=
name|htable
operator|+
operator|(
name|drive
operator|-
literal|2
operator|)
operator|*
literal|0x10
expr_stmt|;
operator|*
operator|(
name|u_short
operator|*
operator|)
operator|(
name|table
operator|+
literal|0x00
operator|)
operator|=
name|di
operator|->
name|cylinders
operator|-
literal|1
expr_stmt|;
comment|/* Cylinders */
operator|*
operator|(
name|u_char
operator|*
operator|)
operator|(
name|table
operator|+
literal|0x02
operator|)
operator|=
name|di
operator|->
name|sides
expr_stmt|;
comment|/* Heads */
operator|*
operator|(
name|u_short
operator|*
operator|)
operator|(
name|table
operator|+
literal|0x03
operator|)
operator|=
literal|0
expr_stmt|;
comment|/* 0 */
operator|*
operator|(
name|u_short
operator|*
operator|)
operator|(
name|table
operator|+
literal|0x05
operator|)
operator|=
literal|0xffff
expr_stmt|;
comment|/* write pre-comp */
operator|*
operator|(
name|u_char
operator|*
operator|)
operator|(
name|table
operator|+
literal|0x07
operator|)
operator|=
literal|0
expr_stmt|;
comment|/* ECC Burst length */
operator|*
operator|(
name|u_char
operator|*
operator|)
operator|(
name|table
operator|+
literal|0x08
operator|)
operator|=
literal|0
expr_stmt|;
comment|/* Control Byte */
operator|*
operator|(
name|u_char
operator|*
operator|)
operator|(
name|table
operator|+
literal|0x09
operator|)
operator|=
literal|0
expr_stmt|;
comment|/* standard timeout */
operator|*
operator|(
name|u_char
operator|*
operator|)
operator|(
name|table
operator|+
literal|0x0a
operator|)
operator|=
literal|0
expr_stmt|;
comment|/* formatting timeout */
operator|*
operator|(
name|u_char
operator|*
operator|)
operator|(
name|table
operator|+
literal|0x0b
operator|)
operator|=
literal|0
expr_stmt|;
comment|/* timeout for checking drive */
operator|*
operator|(
name|u_short
operator|*
operator|)
operator|(
name|table
operator|+
literal|0x0c
operator|)
operator|=
name|di
operator|->
name|cylinders
operator|-
literal|1
expr_stmt|;
comment|/* landing zone */
operator|*
operator|(
name|u_char
operator|*
operator|)
operator|(
name|table
operator|+
literal|0x0e
operator|)
operator|=
name|di
operator|->
name|sectors
expr_stmt|;
comment|/* sectors/track */
operator|*
operator|(
name|u_char
operator|*
operator|)
operator|(
name|table
operator|+
literal|0x0f
operator|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|drive
operator|-
literal|1
operator|)
operator|>=
name|ndisks
condition|)
name|ndisks
operator|=
name|drive
operator|-
literal|1
expr_stmt|;
return|return
operator|(
name|drive
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|bps
parameter_list|(
name|int
name|size
parameter_list|)
block|{
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|128
case|:
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|256
case|:
return|return
operator|(
literal|1
operator|)
return|;
case|case
literal|512
case|:
return|return
operator|(
literal|2
operator|)
return|;
case|case
literal|1024
case|:
return|return
operator|(
literal|3
operator|)
return|;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Invalid sector size: %d\n"
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|quit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* keep `gcc -Wall' happy */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|init_floppy
parameter_list|(
name|int
name|drive
parameter_list|,
name|int
name|type
parameter_list|,
name|char
modifier|*
name|file
parameter_list|)
block|{
name|struct
name|diskinfo
modifier|*
name|di
init|=
name|floppyinfo
decl_stmt|;
name|u_long
name|table
decl_stmt|;
name|struct
name|stat
name|sb
decl_stmt|;
while|while
condition|(
name|di
operator|->
name|type
operator|>=
literal|0
operator|&&
name|di
operator|->
name|type
operator|!=
name|type
operator|&&
name|disize
argument_list|(
name|di
argument_list|)
operator|/
literal|2
operator|!=
name|type
condition|)
operator|++
name|di
expr_stmt|;
if|if
condition|(
operator|!
name|di
operator|->
name|type
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Invalid floppy type: %d\n"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|drive
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|diskinfo
index|[
literal|0
index|]
operator|.
name|path
operator|==
literal|0
condition|)
block|{
name|drive
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|diskinfo
index|[
literal|1
index|]
operator|.
name|path
operator|==
literal|0
condition|)
block|{
name|drive
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Too many floppy drives (only 2 allowed)\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
name|drive
operator|>
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Floppies must be either drive A: or B:\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|drive
operator|>=
name|nfloppies
condition|)
name|nfloppies
operator|=
name|drive
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|diskinfo
index|[
name|drive
index|]
operator|.
name|path
operator|==
literal|0
condition|)
block|{
name|diskinfo
index|[
name|drive
index|]
operator|=
operator|*
name|di
expr_stmt|;
block|}
name|di
operator|=
operator|&
name|diskinfo
index|[
name|drive
index|]
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|file
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Drive %c: Could not stat %s\n"
argument_list|,
name|drntol
argument_list|(
name|drive
argument_list|)
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|drive
operator|<
literal|2
operator|&&
operator|(
name|S_ISCHR
argument_list|(
name|sb
operator|.
name|st_mode
argument_list|)
operator|||
name|S_ISBLK
argument_list|(
name|sb
operator|.
name|st_mode
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|di
operator|->
name|path
operator|&&
operator|!
name|di
operator|->
name|removeable
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Drive %c: is not removeable and hence can only have one assignment\n"
argument_list|,
name|drntol
argument_list|(
name|drive
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|di
operator|->
name|removeable
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|di
operator|->
name|removeable
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Drive %c: already assigned to %s\n"
argument_list|,
name|drntol
argument_list|(
name|drive
argument_list|)
argument_list|,
name|di
operator|->
name|path
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|di
operator|->
name|removeable
condition|)
block|{
if|#
directive|if
literal|0
comment|/*XXXXX*/
block|if (di->multi == 4) { 	    fprintf(stderr, "Drive %c: already assigned 4 devices\n", 			     drntol(drive)); 	    return(-1); 	}
endif|#
directive|endif
name|di
operator|->
name|path
operator|=
name|di
operator|->
name|list
index|[
name|di
operator|->
name|multi
operator|++
index|]
operator|=
name|strdup
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|di
operator|->
name|path
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Drive %c: already assigned to %s\n"
argument_list|,
name|drntol
argument_list|(
name|drive
argument_list|)
argument_list|,
name|di
operator|->
name|path
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|di
operator|->
name|path
operator|=
name|strdup
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
name|di
operator|->
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
name|di
operator|->
name|location
operator|=
operator|(
operator|(
name|table
operator|&
literal|0xf0000
operator|)
operator|<<
literal|12
operator|)
operator||
operator|(
name|table
operator|&
literal|0xffff
operator|)
expr_stmt|;
name|di
operator|->
name|sector0
operator|=
literal|0
expr_stmt|;
name|di
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
name|ivec
index|[
literal|0x1e
index|]
operator|=
operator|(
operator|(
name|ftable
operator|&
literal|0xf0000
operator|)
operator|<<
literal|12
operator|)
operator||
operator|(
name|ftable
operator|&
literal|0xffff
operator|)
expr_stmt|;
name|table
operator|=
name|ftable
operator|+
name|drive
operator|*
literal|0x0a
expr_stmt|;
operator|*
operator|(
name|u_char
operator|*
operator|)
operator|(
name|table
operator|+
literal|0x00
operator|)
operator|=
literal|0xdf
expr_stmt|;
comment|/* First Specify Byte */
operator|*
operator|(
name|u_char
operator|*
operator|)
operator|(
name|table
operator|+
literal|0x01
operator|)
operator|=
literal|0x02
expr_stmt|;
comment|/* Second Specify Byte */
operator|*
operator|(
name|u_char
operator|*
operator|)
operator|(
name|table
operator|+
literal|0x02
operator|)
operator|=
literal|0x25
expr_stmt|;
comment|/* Timer ticks to wait 'til motor OFF */
operator|*
operator|(
name|u_char
operator|*
operator|)
operator|(
name|table
operator|+
literal|0x03
operator|)
operator|=
name|bps
argument_list|(
name|di
operator|->
name|secsize
argument_list|)
expr_stmt|;
comment|/* Number of bytes/sector */
operator|*
operator|(
name|u_char
operator|*
operator|)
operator|(
name|table
operator|+
literal|0x04
operator|)
operator|=
name|di
operator|->
name|sectors
expr_stmt|;
comment|/* Number of sectors/track */
operator|*
operator|(
name|u_char
operator|*
operator|)
operator|(
name|table
operator|+
literal|0x05
operator|)
operator|=
literal|0x1b
expr_stmt|;
comment|/* Gap length, in bytes */
operator|*
operator|(
name|u_char
operator|*
operator|)
operator|(
name|table
operator|+
literal|0x06
operator|)
operator|=
literal|0xff
expr_stmt|;
comment|/* Data length, in bytes */
operator|*
operator|(
name|u_char
operator|*
operator|)
operator|(
name|table
operator|+
literal|0x07
operator|)
operator|=
literal|0x6c
expr_stmt|;
comment|/* Gap length for format */
operator|*
operator|(
name|u_char
operator|*
operator|)
operator|(
name|table
operator|+
literal|0x09
operator|)
operator|=
literal|0xf6
expr_stmt|;
comment|/* Fill byte for formatting */
operator|*
operator|(
name|u_char
operator|*
operator|)
operator|(
name|table
operator|+
literal|0x09
operator|)
operator|=
literal|0x0f
expr_stmt|;
comment|/* Head settle time, in milliseconds */
operator|*
operator|(
name|u_char
operator|*
operator|)
operator|(
name|table
operator|+
literal|0x0a
operator|)
operator|=
literal|0x08
expr_stmt|;
comment|/* Motor startup time, in 1/8 seconds */
return|return
operator|(
name|drive
operator|)
return|;
block|}
end_function

begin_function
name|int
name|search_floppy
parameter_list|(
name|int
name|i
parameter_list|)
block|{
return|return
operator|(
name|i
operator|<
name|nfloppies
condition|?
name|diskinfo
index|[
name|i
index|]
operator|.
name|type
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|seterror
parameter_list|(
name|err
parameter_list|)
value|{			\     if (drive& 0x80)				\ 	hd_status = err; 			\     else					\ 	fd_status = err;			\     R_AH = err;					\     R_FLAGS |= PSL_C;				\ }
end_define

begin_function
specifier|static
name|int
name|trynext
parameter_list|(
name|struct
name|diskinfo
modifier|*
name|di
parameter_list|)
block|{
name|close
argument_list|(
name|di
operator|->
name|fd
argument_list|)
expr_stmt|;
name|di
operator|->
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
name|di
operator|->
name|changed
operator|=
literal|1
expr_stmt|;
if|#
directive|if
literal|0
comment|/*XXXXX*/
block|if (di->multi++>= 4) 	return(0);
endif|#
directive|endif
if|if
condition|(
name|di
operator|->
name|list
index|[
name|di
operator|->
name|multi
index|]
operator|&&
operator|(
name|di
operator|=
name|getdisk
argument_list|(
name|di
operator|-
name|diskinfo
argument_list|)
operator|)
condition|)
block|{
name|di
operator|->
name|multi
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|diread
parameter_list|(
name|struct
name|diskinfo
modifier|*
name|di
parameter_list|,
name|regcontext_t
modifier|*
name|REGS
parameter_list|,
name|off_t
name|start
parameter_list|,
name|char
modifier|*
name|addr
parameter_list|,
name|int
name|sectors
parameter_list|)
block|{
name|off_t
name|res
decl_stmt|;
name|int
name|drive
init|=
name|di
operator|-
name|diskinfo
decl_stmt|;
name|di
operator|->
name|multi
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|drive
operator|>
literal|1
condition|)
block|{
name|drive
operator|-=
literal|2
expr_stmt|;
name|drive
operator||=
literal|0x80
expr_stmt|;
block|}
name|again
label|:
name|res
operator|=
name|lseek
argument_list|(
name|di
operator|->
name|fd
argument_list|,
name|start
operator|*
name|di
operator|->
name|secsize
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|<
literal|0
operator|&&
name|di
operator|->
name|removeable
operator|&&
name|trynext
argument_list|(
name|di
argument_list|)
condition|)
goto|goto
name|again
goto|;
if|if
condition|(
name|res
operator|<
literal|0
condition|)
block|{
name|seterror
argument_list|(
name|INT13_ERR_SEEK
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|res
operator|=
name|read
argument_list|(
name|di
operator|->
name|fd
argument_list|,
name|addr
argument_list|,
name|sectors
operator|*
name|di
operator|->
name|secsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|<
literal|0
operator|&&
name|di
operator|->
name|removeable
operator|&&
name|trynext
argument_list|(
name|di
argument_list|)
condition|)
goto|goto
name|again
goto|;
if|if
condition|(
name|di
operator|->
name|removeable
condition|)
block|{
if|if
condition|(
name|res
operator|<
literal|0
condition|)
block|{
name|seterror
argument_list|(
name|INT13_ERR_NOT_READY
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
name|res
operator|/
name|di
operator|->
name|secsize
operator|)
return|;
block|}
comment|/*      * reads always work, if if they don't.      * Just pretend any byte not read was actually a 0      */
if|if
condition|(
name|res
operator|<
literal|0
condition|)
name|memset
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|,
name|sectors
operator|*
name|di
operator|->
name|secsize
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|res
operator|<
name|sectors
operator|*
name|di
operator|->
name|secsize
condition|)
name|memset
argument_list|(
name|addr
operator|+
name|res
argument_list|,
literal|0
argument_list|,
name|sectors
operator|*
name|di
operator|->
name|secsize
operator|-
name|res
argument_list|)
expr_stmt|;
return|return
operator|(
name|sectors
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|diwrite
parameter_list|(
name|struct
name|diskinfo
modifier|*
name|di
parameter_list|,
name|regcontext_t
modifier|*
name|REGS
parameter_list|,
name|off_t
name|start
parameter_list|,
name|char
modifier|*
name|addr
parameter_list|,
name|int
name|sectors
parameter_list|)
block|{
name|off_t
name|res
decl_stmt|;
name|int
name|drive
init|=
name|di
operator|-
name|diskinfo
decl_stmt|;
name|di
operator|->
name|multi
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|drive
operator|>
literal|1
condition|)
block|{
name|drive
operator|-=
literal|2
expr_stmt|;
name|drive
operator||=
literal|0x80
expr_stmt|;
block|}
name|again
label|:
name|res
operator|=
name|lseek
argument_list|(
name|di
operator|->
name|fd
argument_list|,
name|start
operator|*
name|di
operator|->
name|secsize
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|<
literal|0
operator|&&
name|di
operator|->
name|removeable
operator|&&
name|trynext
argument_list|(
name|di
argument_list|)
condition|)
goto|goto
name|again
goto|;
if|if
condition|(
name|res
operator|<
literal|0
condition|)
block|{
name|seterror
argument_list|(
name|INT13_ERR_SEEK
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|res
operator|=
name|write
argument_list|(
name|di
operator|->
name|fd
argument_list|,
name|addr
argument_list|,
name|sectors
operator|*
name|di
operator|->
name|secsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|<
literal|0
operator|&&
name|di
operator|->
name|removeable
operator|&&
name|trynext
argument_list|(
name|di
argument_list|)
condition|)
goto|goto
name|again
goto|;
if|if
condition|(
name|di
operator|->
name|removeable
condition|)
block|{
if|if
condition|(
name|res
operator|<
literal|0
condition|)
block|{
name|seterror
argument_list|(
name|INT13_ERR_NOT_READY
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|res
operator|<
literal|0
condition|)
block|{
name|seterror
argument_list|(
name|INT13_ERR_WRITE_PROTECT
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
name|res
operator|/
name|di
operator|->
name|secsize
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|int13
parameter_list|(
name|regcontext_t
modifier|*
name|REGS
parameter_list|)
block|{
name|char
modifier|*
name|addr
decl_stmt|;
name|int
name|sectors
decl_stmt|;
name|struct
name|diskinfo
modifier|*
name|di
decl_stmt|;
name|off_t
name|start
decl_stmt|;
name|int
name|did
decl_stmt|;
name|int
name|cyl
decl_stmt|;
name|int
name|sector
decl_stmt|;
name|int
name|side
decl_stmt|;
name|int
name|drive
decl_stmt|;
name|reset_poll
argument_list|()
expr_stmt|;
name|R_FLAGS
operator|&=
operator|~
name|PSL_C
expr_stmt|;
name|drive
operator|=
name|R_DL
expr_stmt|;
if|if
condition|(
name|R_AX
operator|!=
literal|0x01
condition|)
block|{
if|if
condition|(
name|drive
operator|&
literal|0x80
condition|)
name|hd_status
operator|=
literal|0
expr_stmt|;
else|else
name|fd_status
operator|=
literal|0
expr_stmt|;
block|}
switch|switch
condition|(
name|R_AH
condition|)
block|{
case|case
literal|0x00
case|:
comment|/* Reset */
break|break;
case|case
literal|0x01
case|:
comment|/* Read disk status */
if|if
condition|(
name|drive
operator|&
literal|0x80
condition|)
name|R_AH
operator|=
name|hd_status
expr_stmt|;
else|else
name|R_AH
operator|=
name|fd_status
expr_stmt|;
if|if
condition|(
name|R_AH
condition|)
name|R_FLAGS
operator||=
name|PSL_C
expr_stmt|;
break|break;
case|case
literal|0x02
case|:
comment|/* Read */
name|R_AH
operator|=
literal|0
expr_stmt|;
name|addr
operator|=
operator|(
name|char
operator|*
operator|)
name|MAKEPTR
argument_list|(
name|R_ES
argument_list|,
name|R_BX
argument_list|)
expr_stmt|;
name|sectors
operator|=
name|R_AL
expr_stmt|;
name|side
operator|=
name|R_DH
expr_stmt|;
name|R_AL
operator|=
literal|0
expr_stmt|;
comment|/* Start out with nothing read */
if|if
condition|(
name|drive
operator|&
literal|0x80
condition|)
block|{
name|cyl
operator|=
name|R_CH
operator||
operator|(
operator|(
name|R_CL
operator|&
literal|0xc0
operator|)
operator|<<
literal|2
operator|)
expr_stmt|;
name|sector
operator|=
operator|(
name|R_CL
operator|&
literal|0x3f
operator|)
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|sector
operator|=
name|R_CL
operator|-
literal|1
expr_stmt|;
name|cyl
operator|=
name|R_CH
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|di
operator|=
name|getdisk
argument_list|(
name|drive
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|debug
argument_list|(
name|D_DISK
argument_list|,
literal|"Bad drive: %02x (%d : %d : %d)\n"
argument_list|,
name|drive
argument_list|,
name|cyl
argument_list|,
name|side
argument_list|,
name|sector
argument_list|)
expr_stmt|;
name|seterror
argument_list|(
name|INT13_ERR_BAD_COMMAND
argument_list|)
expr_stmt|;
break|break;
block|}
name|start
operator|=
name|cyl
operator|*
name|di
operator|->
name|sectors
operator|*
name|di
operator|->
name|sides
operator|+
name|side
operator|*
name|di
operator|->
name|sectors
operator|+
name|sector
expr_stmt|;
if|if
condition|(
name|start
operator|>=
name|disize
argument_list|(
name|di
argument_list|)
condition|)
block|{
name|debug
argument_list|(
name|D_DISK
argument_list|,
literal|"Read past end of disk\n"
argument_list|)
expr_stmt|;
name|seterror
argument_list|(
name|INT13_ERR_SEEK
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|sectors
operator|+
name|start
operator|>=
name|disize
argument_list|(
name|di
argument_list|)
condition|)
block|{
name|sectors
operator|=
name|disize
argument_list|(
name|di
argument_list|)
operator|-
name|start
expr_stmt|;
block|}
if|if
condition|(
name|di
operator|->
name|sector0
condition|)
block|{
if|if
condition|(
name|start
operator|<
name|di
operator|->
name|offset
condition|)
block|{
name|R_AL
operator|=
name|sectors
expr_stmt|;
if|if
condition|(
name|start
operator|==
literal|0
condition|)
block|{
name|memcpy
argument_list|(
name|addr
argument_list|,
name|di
operator|->
name|sector0
argument_list|,
name|di
operator|->
name|secsize
argument_list|)
expr_stmt|;
name|addr
operator|+=
name|di
operator|->
name|secsize
expr_stmt|;
operator|--
name|sectors
expr_stmt|;
block|}
name|memset
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|,
name|sectors
operator|*
name|di
operator|->
name|secsize
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
name|start
operator|-=
name|di
operator|->
name|offset
expr_stmt|;
block|}
block|}
name|debug
argument_list|(
name|D_DISK
argument_list|,
literal|"%02x: Read %2d sectors from %qd to %04x:%04x\n"
argument_list|,
name|drive
argument_list|,
name|sectors
argument_list|,
name|start
argument_list|,
name|R_ES
argument_list|,
name|R_BX
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|did
operator|=
name|diread
argument_list|(
name|di
argument_list|,
name|REGS
argument_list|,
name|start
argument_list|,
name|addr
argument_list|,
name|sectors
argument_list|)
operator|)
operator|>=
literal|0
condition|)
name|R_AL
operator|=
name|did
expr_stmt|;
if|#
directive|if
literal|0
block|callint(0x0d); 	    callint(0x76);
endif|#
directive|endif
break|break;
case|case
literal|0x03
case|:
comment|/* Write */
name|R_AH
operator|=
literal|0
expr_stmt|;
name|addr
operator|=
operator|(
name|char
operator|*
operator|)
name|MAKEPTR
argument_list|(
name|R_ES
argument_list|,
name|R_BX
argument_list|)
expr_stmt|;
name|sectors
operator|=
name|R_AL
expr_stmt|;
name|side
operator|=
name|R_DH
expr_stmt|;
name|R_AL
operator|=
literal|0
expr_stmt|;
comment|/* Start out with nothing written */
if|if
condition|(
name|drive
operator|&
literal|0x80
condition|)
block|{
name|cyl
operator|=
name|R_CH
operator||
operator|(
operator|(
name|R_CL
operator|&
literal|0xc0
operator|)
operator|<<
literal|2
operator|)
expr_stmt|;
name|sector
operator|=
operator|(
name|R_CL
operator|&
literal|0x3f
operator|)
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|sector
operator|=
name|R_CL
operator|-
literal|1
expr_stmt|;
name|cyl
operator|=
name|R_CH
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|di
operator|=
name|getdisk
argument_list|(
name|drive
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|debug
argument_list|(
name|D_DISK
argument_list|,
literal|"Bad drive: %d (%d : %d : %d)\n"
argument_list|,
name|drive
argument_list|,
name|cyl
argument_list|,
name|side
argument_list|,
name|sector
argument_list|)
expr_stmt|;
name|seterror
argument_list|(
name|INT13_ERR_BAD_COMMAND
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|di
operator|->
name|read_only
condition|)
block|{
name|debug
argument_list|(
name|D_DISK
argument_list|,
literal|"%02x: Attempt to write readonly disk\n"
argument_list|,
name|drive
argument_list|)
expr_stmt|;
name|seterror
argument_list|(
name|INT13_ERR_WRITE_PROTECT
argument_list|)
expr_stmt|;
break|break;
block|}
name|start
operator|=
name|cyl
operator|*
name|di
operator|->
name|sectors
operator|*
name|di
operator|->
name|sides
operator|+
name|side
operator|*
name|di
operator|->
name|sectors
operator|+
name|sector
expr_stmt|;
if|if
condition|(
name|start
operator|>=
name|disize
argument_list|(
name|di
argument_list|)
condition|)
block|{
name|debug
argument_list|(
name|D_DISK
argument_list|,
literal|"Write past end of disk\n"
argument_list|)
expr_stmt|;
name|seterror
argument_list|(
name|INT13_ERR_SEEK
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|sectors
operator|+
name|start
operator|>=
name|disize
argument_list|(
name|di
argument_list|)
condition|)
name|sectors
operator|=
name|disize
argument_list|(
name|di
argument_list|)
operator|-
name|start
expr_stmt|;
if|if
condition|(
name|di
operator|->
name|sector0
condition|)
block|{
if|if
condition|(
name|start
operator|<
name|di
operator|->
name|offset
condition|)
block|{
name|R_AL
operator|=
name|sectors
expr_stmt|;
break|break;
block|}
else|else
block|{
name|start
operator|-=
name|di
operator|->
name|offset
expr_stmt|;
block|}
block|}
name|debug
argument_list|(
name|D_DISK
argument_list|,
literal|"%02x: Write %2d sectors from %qd to %04x:%04x\n"
argument_list|,
name|drive
argument_list|,
name|sectors
argument_list|,
name|start
argument_list|,
name|R_ES
argument_list|,
name|R_BX
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|did
operator|=
name|diwrite
argument_list|(
name|di
argument_list|,
name|REGS
argument_list|,
name|start
argument_list|,
name|addr
argument_list|,
name|sectors
argument_list|)
operator|)
operator|>=
literal|0
condition|)
name|R_AL
operator|=
name|did
expr_stmt|;
if|#
directive|if
literal|0
block|callint(0x0d); 	    callint(0x76);
endif|#
directive|endif
break|break;
case|case
literal|0x04
case|:
comment|/* Verify */
name|R_AH
operator|=
literal|0
expr_stmt|;
name|sectors
operator|=
name|R_AL
expr_stmt|;
name|side
operator|=
name|R_DH
expr_stmt|;
if|if
condition|(
name|drive
operator|&
literal|0x80
condition|)
block|{
name|cyl
operator|=
name|R_CH
operator||
operator|(
operator|(
name|R_CL
operator|&
literal|0xc0
operator|)
operator|<<
literal|2
operator|)
expr_stmt|;
name|sector
operator|=
operator|(
name|R_CL
operator|&
literal|0x3f
operator|)
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|sector
operator|=
name|R_CL
operator|-
literal|1
expr_stmt|;
name|cyl
operator|=
name|R_CH
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|di
operator|=
name|getdisk
argument_list|(
name|drive
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|debug
argument_list|(
name|D_DISK
argument_list|,
literal|"Bad drive: %d (%d : %d : %d)\n"
argument_list|,
name|drive
argument_list|,
name|cyl
argument_list|,
name|side
argument_list|,
name|sector
argument_list|)
expr_stmt|;
name|seterror
argument_list|(
name|INT13_ERR_BAD_COMMAND
argument_list|)
expr_stmt|;
break|break;
block|}
name|start
operator|=
name|cyl
operator|*
name|di
operator|->
name|sectors
operator|*
name|di
operator|->
name|sides
operator|+
name|side
operator|*
name|di
operator|->
name|sectors
operator|+
name|sector
expr_stmt|;
if|if
condition|(
name|start
operator|>=
name|disize
argument_list|(
name|di
argument_list|)
condition|)
block|{
name|debug
argument_list|(
name|D_DISK
argument_list|,
literal|"Verify past end of disk\n"
argument_list|)
expr_stmt|;
name|seterror
argument_list|(
name|INT13_ERR_SEEK
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|sectors
operator|+
name|start
operator|>=
name|disize
argument_list|(
name|di
argument_list|)
condition|)
name|sectors
operator|=
name|disize
argument_list|(
name|di
argument_list|)
operator|-
name|start
expr_stmt|;
if|if
condition|(
name|di
operator|->
name|sector0
condition|)
block|{
if|if
condition|(
name|start
operator|<
name|di
operator|->
name|offset
condition|)
break|break;
else|else
name|start
operator|-=
name|di
operator|->
name|offset
expr_stmt|;
block|}
name|debug
argument_list|(
name|D_DISK
argument_list|,
literal|"Verify %2d sectors from %d\n"
argument_list|,
name|sectors
argument_list|,
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|di
operator|->
name|fd
argument_list|,
name|start
operator|*
name|di
operator|->
name|secsize
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|debug
argument_list|(
name|D_DISK
argument_list|,
literal|"Seek error\n"
argument_list|)
expr_stmt|;
name|seterror
argument_list|(
name|INT13_ERR_SEEK
argument_list|)
expr_stmt|;
break|break;
block|}
while|while
condition|(
name|sectors
operator|>
literal|0
condition|)
block|{
name|char
name|buf
index|[
literal|512
index|]
decl_stmt|;
if|if
condition|(
name|read
argument_list|(
name|di
operator|->
name|fd
argument_list|,
name|buf
argument_list|,
name|di
operator|->
name|secsize
argument_list|)
operator|!=
name|di
operator|->
name|secsize
condition|)
block|{
name|debug
argument_list|(
name|D_DISK
argument_list|,
literal|"Verify error\n"
argument_list|)
expr_stmt|;
name|seterror
argument_list|(
literal|0x04
argument_list|)
expr_stmt|;
break|break;
block|}
operator|--
name|sectors
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|callint(0x0d); 	    callint(0x76);
endif|#
directive|endif
break|break;
case|case
literal|0x05
case|:
comment|/* Format track */
name|seterror
argument_list|(
name|INT13_ERR_BAD_COMMAND
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x08
case|:
comment|/* Status */
name|R_AH
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|di
operator|=
name|getdisk
argument_list|(
name|drive
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|debug
argument_list|(
name|D_DISK
argument_list|,
literal|"Bad drive: %d\n"
argument_list|,
name|drive
argument_list|)
expr_stmt|;
name|seterror
argument_list|(
name|INT13_ERR_BAD_COMMAND
argument_list|)
expr_stmt|;
break|break;
block|}
name|R_AX
operator|=
literal|0
expr_stmt|;
name|R_BX
operator|=
name|di
operator|->
name|type
expr_stmt|;
if|if
condition|(
operator|(
name|drive
operator|&
literal|0x80
operator|)
operator|==
literal|0
condition|)
name|PUTVEC
argument_list|(
name|R_ES
argument_list|,
name|R_DI
argument_list|,
name|di
operator|->
name|location
argument_list|)
expr_stmt|;
name|R_CL
operator|=
name|di
operator|->
name|sectors
operator||
operator|(
operator|(
name|di
operator|->
name|cylinders
operator|>>
literal|2
operator|)
operator|&
literal|0xc0
operator|)
expr_stmt|;
name|R_CH
operator|=
name|di
operator|->
name|cylinders
operator|&
literal|0xff
expr_stmt|;
name|R_DL
operator|=
operator|(
name|drive
operator|&
literal|0x80
operator|)
condition|?
name|ndisks
else|:
name|nfloppies
expr_stmt|;
name|R_DH
operator|=
name|di
operator|->
name|sides
operator|-
literal|1
expr_stmt|;
name|debug
argument_list|(
name|D_DISK
argument_list|,
literal|"%02x: Status requested: sec %d cyl %d side %d drive %d\n"
argument_list|,
name|drive
argument_list|,
name|R_CL
argument_list|,
name|R_CH
argument_list|,
name|R_DH
argument_list|,
name|R_DL
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|callint(0x0d); 	callint(0x76);
endif|#
directive|endif
break|break;
case|case
literal|0x0c
case|:
comment|/* Move read/write head */
case|case
literal|0x0d
case|:
comment|/* Reset */
break|break;
case|case
literal|0x10
case|:
comment|/* check for disk ready */
name|R_AH
operator|=
literal|0
expr_stmt|;
comment|/* always open for business */
break|break;
case|case
literal|0x15
case|:
if|if
condition|(
operator|(
name|di
operator|=
name|getdisk
argument_list|(
name|drive
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|R_AH
operator|=
literal|0
expr_stmt|;
name|R_FLAGS
operator||=
name|PSL_C
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|drive
operator|&
literal|0x80
condition|)
block|{
name|start
operator|=
name|di
operator|->
name|sectors
operator|*
name|di
operator|->
name|cylinders
operator|*
name|di
operator|->
name|sides
expr_stmt|;
name|R_CX
operator|=
name|start
operator|>>
literal|16
expr_stmt|;
name|R_DX
operator|=
name|start
expr_stmt|;
name|R_AH
operator|=
literal|3
expr_stmt|;
block|}
else|else
block|{
name|R_AH
operator|=
literal|1
expr_stmt|;
comment|/* Non-changeable disk */
block|}
break|break;
case|case
literal|0x16
case|:
comment|/* Media change */
name|R_AH
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|di
operator|=
name|getdisk
argument_list|(
name|drive
argument_list|)
operator|)
operator|&&
name|di
operator|->
name|changed
condition|)
block|{
name|di
operator|->
name|changed
operator|=
literal|0
expr_stmt|;
name|R_AH
operator|=
literal|6
expr_stmt|;
block|}
break|break;
case|case
literal|0x17
case|:
comment|/* Determine floppy disk format */
name|seterror
argument_list|(
name|INT13_ERR_BAD_COMMAND
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x18
case|:
comment|/* Determine disk format */
if|if
condition|(
operator|(
name|di
operator|=
name|getdisk
argument_list|(
name|drive
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|R_AH
operator|=
literal|0
expr_stmt|;
name|R_FLAGS
operator||=
name|PSL_C
expr_stmt|;
break|break;
block|}
comment|/* XXX incomplete? */
break|break;
default|default:
name|unknown_int2
argument_list|(
literal|0x13
argument_list|,
name|R_AH
argument_list|,
name|REGS
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
name|void
name|disk_bios_init
parameter_list|(
name|void
parameter_list|)
block|{
name|u_long
name|vec
decl_stmt|;
name|vec
operator|=
name|insert_softint_trampoline
argument_list|()
expr_stmt|;
name|ivec
index|[
literal|0x13
index|]
operator|=
name|vec
expr_stmt|;
name|register_callback
argument_list|(
name|vec
argument_list|,
name|int13
argument_list|,
literal|"int 13"
argument_list|)
expr_stmt|;
name|vec
operator|=
name|insert_null_trampoline
argument_list|()
expr_stmt|;
name|ivec
index|[
literal|0x76
index|]
operator|=
name|vec
expr_stmt|;
block|}
end_function

end_unit

