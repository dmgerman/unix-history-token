begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* No copyright?! ** ** $FreeBSD$ */
end_comment

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|"doscmd.h"
end_include

begin_comment
comment|/* ** Callbacks are used for chaining interrupt handlers  ** off interrupt vectors */
end_comment

begin_struct
struct|struct
name|callback
block|{
name|LIST_ENTRY
argument_list|(
argument|callback
argument_list|)
name|chain
expr_stmt|;
name|u_long
name|vec
decl_stmt|;
name|callback_t
name|func
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|}
struct|;
end_struct

begin_macro
name|LIST_HEAD
argument_list|(
argument|cbhead
argument_list|,
argument|callback
argument_list|)
end_macro

begin_expr_stmt
name|cbhead
index|[
literal|127
index|]
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|CBHASH
parameter_list|(
name|x
parameter_list|)
value|(((x) * 17) % 127)
end_define

begin_comment
comment|/* ** Register (func) as a handler for (vec) */
end_comment

begin_function
name|void
name|register_callback
parameter_list|(
name|u_long
name|vec
parameter_list|,
name|callback_t
name|func
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|cbhead
modifier|*
name|head
decl_stmt|;
name|struct
name|callback
modifier|*
name|elm
decl_stmt|;
name|elm
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|callback
argument_list|)
argument_list|)
expr_stmt|;
name|elm
operator|->
name|vec
operator|=
name|vec
expr_stmt|;
name|elm
operator|->
name|func
operator|=
name|func
expr_stmt|;
name|elm
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|head
operator|=
operator|&
name|cbhead
index|[
name|CBHASH
argument_list|(
name|vec
argument_list|)
index|]
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
name|head
argument_list|,
name|elm
argument_list|,
name|chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** Find a handler for (vec) */
end_comment

begin_function
name|callback_t
name|find_callback
parameter_list|(
name|u_long
name|vec
parameter_list|)
block|{
name|struct
name|cbhead
modifier|*
name|head
decl_stmt|;
name|struct
name|callback
modifier|*
name|elm
decl_stmt|;
name|head
operator|=
operator|&
name|cbhead
index|[
name|CBHASH
argument_list|(
name|vec
argument_list|)
index|]
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|elm
argument_list|,
argument|head
argument_list|,
argument|chain
argument_list|)
if|if
condition|(
name|elm
operator|->
name|vec
operator|==
name|vec
condition|)
break|break;
if|if
condition|(
name|elm
condition|)
block|{
name|debug
argument_list|(
name|D_TRAPS2
argument_list|,
literal|"callback %s\n"
argument_list|,
name|elm
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|elm
operator|->
name|func
operator|)
return|;
block|}
else|else
return|return
operator|(
operator|(
name|callback_t
operator|)
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|u_long
name|trampoline_rover
init|=
literal|0xF1000000
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Interrupts are disabled on an INTn call, so we must restore interrupts  * before via STI returning.  IRET is not used here because 1) some DOS  * calls want to return status via the FLAGS register, and 2) external  * routines which hook INTn calls do not always put a FLAGS image on the  * stack which re-enables interrupts.  */
end_comment

begin_decl_stmt
name|u_char
name|softint_trampoline
index|[]
init|=
block|{
literal|0xf4
block|,
comment|/* HLT */
literal|0xfb
block|,
comment|/* STI */
literal|0xca
block|,
comment|/* RETF 2 */
literal|2
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_char
name|hardint_trampoline
index|[]
init|=
block|{
literal|0xf4
block|,
comment|/* HLT */
literal|0xcf
block|,
comment|/* IRET */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_char
name|null_trampoline
index|[]
init|=
block|{
literal|0xcf
block|,
comment|/* IRET */
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|u_long
name|insert_generic_trampoline
parameter_list|(
name|size_t
name|len
parameter_list|,
name|u_char
modifier|*
name|p
parameter_list|)
block|{
name|u_char
modifier|*
name|q
decl_stmt|;
name|u_long
name|where
decl_stmt|;
name|where
operator|=
name|trampoline_rover
expr_stmt|;
name|q
operator|=
operator|(
name|u_char
operator|*
operator|)
name|VECPTR
argument_list|(
name|where
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|q
argument_list|,
name|p
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|trampoline_rover
operator|+=
name|len
expr_stmt|;
return|return
operator|(
name|where
operator|)
return|;
block|}
end_function

begin_function
name|u_long
name|insert_softint_trampoline
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|insert_generic_trampoline
argument_list|(
sizeof|sizeof
argument_list|(
name|softint_trampoline
argument_list|)
argument_list|,
name|softint_trampoline
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|u_long
name|insert_hardint_trampoline
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|insert_generic_trampoline
argument_list|(
sizeof|sizeof
argument_list|(
name|hardint_trampoline
argument_list|)
argument_list|,
name|hardint_trampoline
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|u_long
name|insert_null_trampoline
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|insert_generic_trampoline
argument_list|(
sizeof|sizeof
argument_list|(
name|null_trampoline
argument_list|)
argument_list|,
name|null_trampoline
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

