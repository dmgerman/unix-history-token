begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ** No copyright?! ** ** $FreeBSD$ */
end_comment

begin_include
include|#
directive|include
file|"doscmd.h"
end_include

begin_comment
comment|/* ** Cause a software interrupt to happen immediately after we ** return to vm86 mode */
end_comment

begin_function
name|void
name|softint
parameter_list|(
name|int
name|intnum
parameter_list|)
block|{
name|regcontext_t
modifier|*
name|REGS
init|=
name|saved_regcontext
decl_stmt|;
name|u_long
name|vec
init|=
name|ivec
index|[
name|intnum
index|]
decl_stmt|;
comment|/*     ** if we're dead, or there's no vector or the saved registers are     ** invalid     */
if|if
condition|(
name|dead
operator|||
operator|!
name|saved_valid
operator|||
name|vec
operator|==
literal|0
condition|)
return|return;
comment|/*      ** if the vector points into the BIOS, or the handler at the other     ** end is just an IRET, don't bother.     */
if|if
condition|(
operator|(
name|vec
operator|>>
literal|16
operator|)
operator|==
literal|0xf000
operator|||
operator|*
operator|(
name|u_char
operator|*
operator|)
name|VECPTR
argument_list|(
name|vec
argument_list|)
operator|==
literal|0xcf
condition|)
return|return;
if|#
directive|if
literal|0
comment|/*      * software interrupts are always taken      */
block|if ((R_EFLAGS& PSL_VIF) == 0) {         delay_interrupt(intnum, softint);         return;     }
endif|#
directive|endif
name|debug
argument_list|(
name|D_TRAPS
operator||
name|intnum
argument_list|,
literal|"INT%x [%04lx:%04lx]\n"
argument_list|,
name|intnum
argument_list|,
name|vec
operator|>>
literal|16
argument_list|,
name|vec
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
name|PUSH
argument_list|(
operator|(
name|R_FLAGS
operator|&
operator|~
name|PSL_I
operator|)
operator||
operator|(
name|R_EFLAGS
operator|&
name|PSL_VIF
condition|?
name|PSL_I
else|:
literal|0
operator|)
argument_list|,
name|REGS
argument_list|)
expr_stmt|;
name|PUSH
argument_list|(
name|R_CS
argument_list|,
name|REGS
argument_list|)
expr_stmt|;
name|PUSH
argument_list|(
name|R_IP
argument_list|,
name|REGS
argument_list|)
expr_stmt|;
if|#
directive|if
literal|1
name|R_EFLAGS
operator|&=
operator|~
name|PSL_VIF
expr_stmt|;
comment|/* XXX disable interrupts? */
else|#
directive|else
name|R_EFLAGS
operator||=
name|PSL_VIF
expr_stmt|;
endif|#
directive|endif
name|PUTVEC
argument_list|(
name|R_CS
argument_list|,
name|R_IP
argument_list|,
name|vec
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** Cause a hardware interrupt to happen immediately after ** we return to vm86 mode */
end_comment

begin_function
name|void
name|hardint
parameter_list|(
name|int
name|intnum
parameter_list|)
block|{
name|regcontext_t
modifier|*
name|REGS
init|=
name|saved_regcontext
decl_stmt|;
name|u_long
name|vec
init|=
name|ivec
index|[
name|intnum
index|]
decl_stmt|;
comment|/*      * XXXXX      * We should simulate the IRQ mask in the PIC.      */
comment|/*  	** if we're dead, or there's no vector, or the saved registers 	** are invalid 	*/
if|if
condition|(
name|dead
operator|||
operator|!
name|saved_valid
operator|||
name|vec
operator|==
literal|0
condition|)
return|return;
comment|/*  	** if the vector points into the BIOS, or the handler at the 	** other end is just an IRET, don't bother  	*/
if|if
condition|(
operator|(
name|vec
operator|>>
literal|16
operator|)
operator|==
literal|0xf000
operator|||
operator|*
operator|(
name|u_char
operator|*
operator|)
name|VECPTR
argument_list|(
name|vec
argument_list|)
operator|==
literal|0xcf
condition|)
return|return;
if|if
condition|(
operator|(
name|R_EFLAGS
operator|&
name|PSL_VIF
operator|)
operator|==
literal|0
condition|)
block|{
name|delay_interrupt
argument_list|(
name|intnum
argument_list|,
name|hardint
argument_list|)
expr_stmt|;
return|return;
block|}
name|debug
argument_list|(
name|D_TRAPS
operator||
name|intnum
argument_list|,
literal|"INT%x [%04lx:%04lx]\n"
argument_list|,
name|intnum
argument_list|,
name|vec
operator|>>
literal|16
argument_list|,
name|vec
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
name|PUSH
argument_list|(
operator|(
name|R_FLAGS
operator|&
operator|~
name|PSL_I
operator|)
operator||
operator|(
name|R_EFLAGS
operator|&
name|PSL_VIF
condition|?
name|PSL_I
else|:
literal|0
operator|)
argument_list|,
name|REGS
argument_list|)
expr_stmt|;
name|PUSH
argument_list|(
name|R_CS
argument_list|,
name|REGS
argument_list|)
expr_stmt|;
name|PUSH
argument_list|(
name|R_IP
argument_list|,
name|REGS
argument_list|)
expr_stmt|;
if|#
directive|if
literal|1
name|R_EFLAGS
operator|&=
operator|~
name|PSL_VIF
expr_stmt|;
comment|/* XXX disable interrupts */
else|#
directive|else
name|R_EFLAGS
operator||=
name|PSL_VIF
expr_stmt|;
endif|#
directive|endif
name|PUTVEC
argument_list|(
name|R_CS
argument_list|,
name|R_IP
argument_list|,
name|vec
argument_list|)
expr_stmt|;
block|}
end_function

begin_typedef
typedef|typedef
name|void
function_decl|(
modifier|*
name|foo_t
function_decl|)
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_typedef

begin_function
name|void
name|resume_interrupt
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|regcontext_t
modifier|*
name|REGS
init|=
name|saved_regcontext
decl_stmt|;
name|n_pending
operator|--
expr_stmt|;
if|if
condition|(
name|n_pending
operator|==
literal|0
condition|)
name|R_EFLAGS
operator|&=
operator|~
name|PSL_VIP
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pending
index|[
name|i
index|]
condition|)
block|{
operator|(
call|(
name|foo_t
call|)
argument_list|(
name|pending
index|[
name|i
index|]
argument_list|)
operator|)
operator|(
name|i
operator|)
expr_stmt|;
name|pending
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_function
name|void
name|delay_interrupt
parameter_list|(
name|int
name|intnum
parameter_list|,
name|void
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|int
parameter_list|)
parameter_list|)
block|{
name|regcontext_t
modifier|*
name|REGS
init|=
name|saved_regcontext
decl_stmt|;
if|#
directive|if
literal|0
block|printf("DELAY [%x/%d]\n", intnum, n_pending);
endif|#
directive|endif
if|if
condition|(
name|pending
index|[
name|intnum
index|]
operator|==
literal|0
condition|)
block|{
name|pending
index|[
name|intnum
index|]
operator|=
operator|(
name|u_long
operator|)
name|func
expr_stmt|;
name|n_pending
operator|++
expr_stmt|;
block|}
name|R_EFLAGS
operator||=
name|PSL_VIP
expr_stmt|;
block|}
end_function

end_unit

