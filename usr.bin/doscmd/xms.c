begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1997 Helmut Wirth<hfwirth@ping.at>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice immediately at the beginning of the file, witout modification,  *    this list of conditions, and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT   * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_comment
comment|/*  * XMS memory manmagement   *  * To emulate DOS extended memory (EMM) we use an implementation of  * HIMEM.SYS driver capabitlities, according to the XMS 3.0 Spec.  * The actual memory allocated via XMS calls from DOS is allocated  * via malloc by the emulator. Maximum memory allocation is configureable.  *  * Credits to:  *	The original author of this file, some parts are still here  *	Linux dosemu programmers. I looked into their code.  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"doscmd.h"
end_include

begin_include
include|#
directive|include
file|"xms.h"
end_include

begin_comment
comment|/* Extended memory handle management */
end_comment

begin_decl_stmt
specifier|static
name|XMS_handle
name|xms_hand
index|[
name|NUM_HANDLES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|num_free_handle
init|=
name|NUM_HANDLES
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is planned to be selectable from .doscmdrc */
end_comment

begin_decl_stmt
name|u_long
name|xms_maxsize
init|=
name|DEFAULT_EMM_SIZE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_long
name|xms_free_mem
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_long
name|xms_used_mem
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
name|vec_grabbed
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Address entry for zero size allocated handles */
end_comment

begin_define
define|#
directive|define
name|XMS_NULL_ALLOC
value|0xffffffff
end_define

begin_comment
comment|/* High memory area (HMA) management */
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|HMA_allocated
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
name|HMA_a20
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|HMA_fd_off
decl_stmt|,
name|HMA_fd_on
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* high memory mapfiles */
end_comment

begin_decl_stmt
specifier|static
name|char
name|memfile
index|[]
init|=
literal|"/tmp/doscmd.XXXXXX"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Upper memory block (UMB) management */
end_comment

begin_decl_stmt
name|UMB_block
modifier|*
name|UMB_freelist
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|UMB_block
modifier|*
name|UMB_alloclist
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Calls to emulator */
end_comment

begin_decl_stmt
name|u_long
name|xms_vector
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
name|xms_trampoline
index|[]
init|=
block|{
literal|0xeb
block|,
comment|/* JMP 5 */
literal|0x03
block|,
literal|0x90
block|,
comment|/* NOP */
literal|0x90
block|,
comment|/* NOP */
literal|0x90
block|,
comment|/* NOP */
literal|0xf4
block|,
comment|/* HLT */
literal|0xcb
block|,
comment|/* RETF */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Local prototypes */
end_comment

begin_function_decl
specifier|static
name|void
name|add_block
parameter_list|(
name|UMB_block
modifier|*
modifier|*
name|listp
parameter_list|,
name|UMB_block
modifier|*
name|blk
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|UMB_block
modifier|*
name|create_block
parameter_list|(
name|u_long
name|addr
parameter_list|,
name|u_long
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|disable_a20
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|enable_a20
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_free_handle
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|merge_blocks
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xms_entry
parameter_list|(
name|regcontext_t
modifier|*
name|REGS
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Init the entire module */
end_comment

begin_function
name|void
name|xms_init
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Initialize handle table: xms_handle.addr == 0 means free */
name|bzero
argument_list|(
operator|(
name|void
operator|*
operator|)
name|xms_hand
argument_list|,
sizeof|sizeof
argument_list|(
name|XMS_handle
argument_list|)
operator|*
name|NUM_HANDLES
argument_list|)
expr_stmt|;
name|xms_free_mem
operator|=
name|xms_maxsize
expr_stmt|;
name|xms_used_mem
operator|=
literal|0
expr_stmt|;
name|vec_grabbed
operator|=
literal|0
expr_stmt|;
name|HMA_allocated
operator|=
literal|0
expr_stmt|;
comment|/* Initialize UMB blocks */
comment|/* 0xD0000 to 0xDffff */
name|add_block
argument_list|(
operator|&
name|UMB_freelist
argument_list|,
name|create_block
argument_list|(
literal|0xd0000
argument_list|,
literal|64
operator|*
literal|1024
argument_list|)
argument_list|)
expr_stmt|;
comment|/*XXX check for EMS emulation, when it is done! */
comment|/* 0xE0000 to 0xEffff */
comment|/* This is used as window for EMS, will be configurable ! */
comment|/*    add_block(&UMB_freelist, create_block(0xe0000, 64*1024)); */
name|merge_blocks
argument_list|()
expr_stmt|;
name|xms_vector
operator|=
name|insert_generic_trampoline
argument_list|(
sizeof|sizeof
argument_list|(
name|xms_trampoline
argument_list|)
argument_list|,
name|xms_trampoline
argument_list|)
expr_stmt|;
name|register_callback
argument_list|(
name|xms_vector
operator|+
literal|5
argument_list|,
name|xms_entry
argument_list|,
literal|"xms"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * UMB management routines: UMBs normally lie between 0xd0000 and  * 0xefff0 in VM86 memory space and are accessible for all DOS applictions.  * We could enable more space, but with the emulator we do not  * need many drivers, so I think 2 * 64kB will suffice. If EMS emulation  * exists, a 64kB segment (0xe0000 - 0xeffff for example) is needed for  * the EMS mapping, in this case we have 64kB UMB space. This is more than   * many PCs are able to do.  * This emulation does only the management for the memory, the memory  * is present and read/write/excutable for VM86 applications.  */
end_comment

begin_comment
comment|/* Add a block to a list, maintain ascending start address order */
end_comment

begin_function
specifier|static
name|void
name|add_block
parameter_list|(
name|UMB_block
modifier|*
modifier|*
name|listp
parameter_list|,
name|UMB_block
modifier|*
name|blk
parameter_list|)
block|{
name|UMB_block
modifier|*
name|bp
decl_stmt|,
modifier|*
name|obp
decl_stmt|;
comment|/* No blocks there, attach the new block to the head */
if|if
condition|(
operator|*
name|listp
operator|==
name|NULL
condition|)
block|{
operator|*
name|listp
operator|=
name|blk
expr_stmt|;
name|blk
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* Insert at the start */
name|bp
operator|=
name|obp
operator|=
operator|*
name|listp
expr_stmt|;
if|if
condition|(
name|blk
operator|->
name|addr
operator|<
name|bp
operator|->
name|addr
condition|)
block|{
name|blk
operator|->
name|next
operator|=
operator|*
name|listp
expr_stmt|;
operator|*
name|listp
operator|=
name|blk
expr_stmt|;
return|return;
block|}
comment|/* Not at the start, insert into the list */
for|for
control|(
init|;
name|bp
operator|!=
name|NULL
condition|;
name|bp
operator|=
name|bp
operator|->
name|next
control|)
block|{
if|if
condition|(
name|blk
operator|->
name|addr
operator|>
name|bp
operator|->
name|addr
condition|)
block|{
name|obp
operator|=
name|bp
expr_stmt|;
continue|continue;
block|}
else|else
block|{
name|obp
operator|->
name|next
operator|=
name|blk
expr_stmt|;
name|blk
operator|->
name|next
operator|=
name|bp
expr_stmt|;
return|return;
block|}
block|}
comment|/* Append to the end of the list */
name|obp
operator|->
name|next
operator|=
name|blk
expr_stmt|;
name|blk
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* Find a block with address addr in the alloc list */
end_comment

begin_function
specifier|static
name|UMB_block
modifier|*
name|find_allocated_block
parameter_list|(
name|u_long
name|addr
parameter_list|)
block|{
name|UMB_block
modifier|*
name|bp
decl_stmt|;
if|if
condition|(
name|UMB_alloclist
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
for|for
control|(
name|bp
operator|=
name|UMB_alloclist
init|;
name|bp
operator|!=
name|NULL
condition|;
name|bp
operator|=
name|bp
operator|->
name|next
control|)
if|if
condition|(
name|bp
operator|->
name|addr
operator|==
name|addr
condition|)
return|return
name|bp
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Remove a block blk from a list, the block must exist on the list */
end_comment

begin_function
specifier|static
name|void
name|remove_block
parameter_list|(
name|UMB_block
modifier|*
modifier|*
name|listp
parameter_list|,
name|UMB_block
modifier|*
name|blk
parameter_list|)
block|{
name|UMB_block
modifier|*
name|bp
decl_stmt|;
if|if
condition|(
operator|*
name|listp
operator|==
name|NULL
condition|)
goto|goto
name|faterr
goto|;
if|if
condition|(
operator|*
name|listp
operator|==
name|blk
condition|)
block|{
operator|*
name|listp
operator|=
operator|(
operator|*
name|listp
operator|)
operator|->
name|next
expr_stmt|;
return|return;
block|}
name|bp
operator|=
operator|*
name|listp
expr_stmt|;
do|do
block|{
if|if
condition|(
name|bp
operator|->
name|next
operator|==
name|blk
condition|)
block|{
name|bp
operator|->
name|next
operator|=
name|bp
operator|->
name|next
operator|->
name|next
expr_stmt|;
return|return;
block|}
name|bp
operator|=
name|bp
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|bp
operator|!=
name|NULL
condition|)
do|;
name|faterr
label|:
name|fatal
argument_list|(
literal|"XMS: UMB remove_block did not find block\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Try to merge neighbouring blocks in the free list */
end_comment

begin_function
specifier|static
name|void
name|merge_blocks
parameter_list|()
block|{
name|UMB_block
modifier|*
name|bp
decl_stmt|;
name|u_long
name|endaddr
decl_stmt|;
if|if
condition|(
name|UMB_freelist
operator|==
name|NULL
condition|)
return|return;
name|bp
operator|=
name|UMB_freelist
expr_stmt|;
do|do
block|{
name|endaddr
operator|=
name|bp
operator|->
name|addr
operator|+
name|bp
operator|->
name|size
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|next
operator|!=
name|NULL
operator|&&
name|endaddr
operator|==
name|bp
operator|->
name|next
operator|->
name|addr
condition|)
block|{
comment|/* Merge the current and the next block */
name|UMB_block
modifier|*
name|mergebp
init|=
name|bp
operator|->
name|next
decl_stmt|;
name|bp
operator|->
name|size
operator|+=
name|mergebp
operator|->
name|size
expr_stmt|;
name|bp
operator|->
name|next
operator|=
name|mergebp
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|mergebp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Goto next block */
name|bp
operator|=
name|bp
operator|->
name|next
expr_stmt|;
block|}
block|}
do|while
condition|(
name|bp
operator|!=
name|NULL
condition|)
do|;
block|}
end_function

begin_comment
comment|/* Try to find a free block of size exactly siz */
end_comment

begin_function
specifier|static
name|UMB_block
modifier|*
name|find_exact_block
parameter_list|(
name|u_long
name|siz
parameter_list|)
block|{
name|UMB_block
modifier|*
name|bp
decl_stmt|;
if|if
condition|(
name|UMB_freelist
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
for|for
control|(
name|bp
operator|=
name|UMB_freelist
init|;
name|bp
operator|!=
name|NULL
condition|;
name|bp
operator|=
name|bp
operator|->
name|next
control|)
if|if
condition|(
name|bp
operator|->
name|size
operator|==
name|siz
condition|)
return|return
name|bp
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Try to find a block with a size bigger than requested. If there is  * no such block, return the block with the biggest size. If there is  * no free block at all, return NULL  */
end_comment

begin_function
specifier|static
name|UMB_block
modifier|*
name|find_block
parameter_list|(
name|u_long
name|siz
parameter_list|)
block|{
name|UMB_block
modifier|*
name|bp
decl_stmt|;
name|UMB_block
modifier|*
name|biggest
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|UMB_freelist
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
for|for
control|(
name|bp
operator|=
name|UMB_freelist
init|;
name|bp
operator|!=
name|NULL
condition|;
name|bp
operator|=
name|bp
operator|->
name|next
control|)
block|{
if|if
condition|(
name|bp
operator|->
name|size
operator|>
name|siz
condition|)
return|return
name|bp
return|;
if|if
condition|(
name|biggest
operator|==
name|NULL
condition|)
block|{
name|biggest
operator|=
name|bp
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|biggest
operator|->
name|size
operator|<
name|bp
operator|->
name|size
condition|)
name|biggest
operator|=
name|bp
expr_stmt|;
block|}
return|return
name|biggest
return|;
block|}
end_function

begin_comment
comment|/* Create a block structure, memory is allocated. The structure lives  * until the block is merged into another block, then it is freed */
end_comment

begin_function
specifier|static
name|UMB_block
modifier|*
name|create_block
parameter_list|(
name|u_long
name|addr
parameter_list|,
name|u_long
name|size
parameter_list|)
block|{
name|UMB_block
modifier|*
name|blk
decl_stmt|;
if|if
condition|(
operator|(
name|blk
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|UMB_block
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"XMS: Cannot allocate UMB structure\n"
argument_list|)
expr_stmt|;
name|blk
operator|->
name|addr
operator|=
name|addr
expr_stmt|;
name|blk
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|blk
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
return|return
name|blk
return|;
block|}
end_function

begin_comment
comment|/*  * initHMA(): The first 64kB of memory are mapped from 1MB (0x100000)  * again to emulate the address wrap around of the 808x. The HMA area  * is a cheap trick, usable only with 80386 and higher. The 80[345..]86  * does not have this address wrap around. If more than 1MB is installed  * the processor can address more than 1MB: load 0xFFFF to the segment  * register and using the full offset of 0xffff the resulting highest  * address is (0xffff<< 4) + 0xffff = 0x10ffef. Nearly 64kB are accessible   * from real or VM86 mode. The mmap calls emulate the address wrap by  * mapping the lowest 64kB the the first 64kB after the 1MB limit.  * In hardware this is achieved by setting and resetting the a20 bit,  * an ugly compatibility hack: The hardware simlpy clamps the address 20  * line of the processor to low and hence the wrap around is forced.  * This is switchable via the BIOS or via HIMEM.SYS and therefore the  * first 64kB over 1MB can be enabled or disabled at will by software.  * DOS uses this trick to load itself high, if the memory is present.  * We emulate this behaviour by mapping and unmapping the HMA area.  * (Linux has implemented this feature using shared memory (SHM) calls.)  *  * This routine is called from doscmd.c at startup. A20 is disabled after  * startup.  */
end_comment

begin_function
name|void
name|initHMA
parameter_list|()
block|{
name|int
name|mfd
decl_stmt|;
comment|/*      * We need two files, one for the wrap around mapping and one       * for the HMA contents      */
name|mfd
operator|=
name|mkstemp
argument_list|(
name|memfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|mfd
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"memfile: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"High memory will not be mapped\n"
argument_list|)
expr_stmt|;
comment|/* We need this for XMS services. If it fails, turn HMA off */
name|HMA_a20
operator|=
operator|-
literal|1
expr_stmt|;
return|return;
block|}
name|unlink
argument_list|(
name|memfile
argument_list|)
expr_stmt|;
name|HMA_fd_off
operator|=
name|squirrel_fd
argument_list|(
name|mfd
argument_list|)
expr_stmt|;
name|lseek
argument_list|(
name|HMA_fd_off
argument_list|,
literal|64
operator|*
literal|1024
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|HMA_fd_off
argument_list|,
literal|""
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|mfd
operator|=
name|mkstemp
argument_list|(
name|memfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|mfd
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"memfile: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"High memory will not be mapped\n"
argument_list|)
expr_stmt|;
comment|/* We need this for XMS services. If it fails, turn HMA off */
name|HMA_a20
operator|=
operator|-
literal|1
expr_stmt|;
return|return;
block|}
name|unlink
argument_list|(
name|memfile
argument_list|)
expr_stmt|;
name|HMA_fd_on
operator|=
name|squirrel_fd
argument_list|(
name|mfd
argument_list|)
expr_stmt|;
name|lseek
argument_list|(
name|HMA_fd_on
argument_list|,
literal|64
operator|*
literal|1024
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|HMA_fd_on
argument_list|,
literal|""
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|mmap
argument_list|(
operator|(
name|caddr_t
operator|)
literal|0x000000
argument_list|,
literal|0x100000
argument_list|,
name|PROT_EXEC
operator||
name|PROT_READ
operator||
name|PROT_WRITE
argument_list|,
name|MAP_ANON
operator||
name|MAP_FIXED
operator||
name|MAP_SHARED
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
operator|==
name|MAP_FAILED
condition|)
block|{
name|perror
argument_list|(
literal|"Error mapping HMA, HMA disabled: "
argument_list|)
expr_stmt|;
name|HMA_a20
operator|=
operator|-
literal|1
expr_stmt|;
name|close
argument_list|(
name|HMA_fd_off
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|HMA_fd_on
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|mmap
argument_list|(
operator|(
name|caddr_t
operator|)
literal|0x000000
argument_list|,
literal|64
operator|*
literal|1024
argument_list|,
name|PROT_EXEC
operator||
name|PROT_READ
operator||
name|PROT_WRITE
argument_list|,
name|MAP_FILE
operator||
name|MAP_FIXED
operator||
name|MAP_SHARED
argument_list|,
name|HMA_fd_off
argument_list|,
literal|0
argument_list|)
operator|==
name|MAP_FAILED
condition|)
block|{
name|perror
argument_list|(
literal|"Error mapping HMA, HMA disabled: "
argument_list|)
expr_stmt|;
name|HMA_a20
operator|=
operator|-
literal|1
expr_stmt|;
name|close
argument_list|(
name|HMA_fd_off
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|HMA_fd_on
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|mmap
argument_list|(
operator|(
name|caddr_t
operator|)
literal|0x100000
argument_list|,
literal|64
operator|*
literal|1024
argument_list|,
name|PROT_EXEC
operator||
name|PROT_READ
operator||
name|PROT_WRITE
argument_list|,
name|MAP_FILE
operator||
name|MAP_FIXED
operator||
name|MAP_SHARED
argument_list|,
name|HMA_fd_off
argument_list|,
literal|0
argument_list|)
operator|==
name|MAP_FAILED
condition|)
block|{
name|perror
argument_list|(
literal|"Error mapping HMA, HMA disabled: "
argument_list|)
expr_stmt|;
name|HMA_a20
operator|=
operator|-
literal|1
expr_stmt|;
name|close
argument_list|(
name|HMA_fd_off
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|HMA_fd_on
argument_list|)
expr_stmt|;
return|return;
block|}
name|HMA_a20
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Enable the a20 "address line" by unmapping the 64kB over 1MB */
end_comment

begin_function
specifier|static
name|void
name|enable_a20
parameter_list|()
block|{
if|if
condition|(
name|HMA_a20
operator|<
literal|0
condition|)
return|return;
comment|/* Unmap the wrap around portion (fd = HMA_fd_off) */
comment|/* XXX Not sure about this: Should I unmap first, then map new or      * does it suffice to map new "over' the existing mapping ? Both      * works (define to #if 0 next line and some lines below to try.      */
if|#
directive|if
literal|1
if|if
condition|(
name|munmap
argument_list|(
operator|(
name|caddr_t
operator|)
literal|0x100000
argument_list|,
literal|64
operator|*
literal|1024
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fatal
argument_list|(
literal|"HMA unmapping error: %s\nCannot recover\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Map memory for the HMA with fd = HMA_fd_on */
if|if
condition|(
name|mmap
argument_list|(
operator|(
name|caddr_t
operator|)
literal|0x100000
argument_list|,
literal|64
operator|*
literal|1024
argument_list|,
name|PROT_EXEC
operator||
name|PROT_READ
operator||
name|PROT_WRITE
argument_list|,
name|MAP_FILE
operator||
name|MAP_FIXED
operator||
name|MAP_SHARED
argument_list|,
name|HMA_fd_on
argument_list|,
literal|0
argument_list|)
operator|==
name|MAP_FAILED
condition|)
block|{
name|fatal
argument_list|(
literal|"HMA mapping error: %s\nCannot recover\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Disable the a20 "address line" by mapping the 64kB over 1MB again */
end_comment

begin_function
specifier|static
name|void
name|disable_a20
parameter_list|()
block|{
if|if
condition|(
name|HMA_a20
operator|<
literal|0
condition|)
return|return;
if|#
directive|if
literal|1
comment|/* Unmap the HMA (fd = HMA_fd_on) */
if|if
condition|(
name|munmap
argument_list|(
operator|(
name|caddr_t
operator|)
literal|0x100000
argument_list|,
literal|64
operator|*
literal|1024
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fatal
argument_list|(
literal|"HMA unmapping error: %s\nCannot recover\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Remap the wrap around area */
if|if
condition|(
name|mmap
argument_list|(
operator|(
name|caddr_t
operator|)
literal|0x100000
argument_list|,
literal|64
operator|*
literal|1024
argument_list|,
name|PROT_EXEC
operator||
name|PROT_READ
operator||
name|PROT_WRITE
argument_list|,
name|MAP_FILE
operator||
name|MAP_FIXED
operator||
name|MAP_SHARED
argument_list|,
name|HMA_fd_off
argument_list|,
literal|0
argument_list|)
operator|==
name|MAP_FAILED
condition|)
block|{
name|fatal
argument_list|(
literal|"HMA mapping error: %s\nCannot recover\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * This handles calls to int15 function 88: BIOS extended memory  * request. XMS spec says: "In order to maintain compatibility with existing   * device drivers, DOS XMS drivers must not hook INT 15h until the first   * non-Version Number call to the control function is made."  */
end_comment

begin_function
name|void
name|get_raw_extmemory_info
parameter_list|(
name|regcontext_t
modifier|*
name|REGS
parameter_list|)
block|{
if|if
condition|(
name|vec_grabbed
condition|)
name|R_AX
operator|=
literal|0x0
expr_stmt|;
else|else
name|R_AX
operator|=
name|xms_maxsize
operator|/
literal|1024
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* Handle management routine: Find next free handle */
end_comment

begin_function
specifier|static
name|int
name|get_free_handle
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
comment|/* Linear search, there are only a few handles */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_HANDLES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|xms_hand
index|[
name|i
index|]
operator|.
name|addr
operator|==
literal|0
condition|)
return|return
name|i
operator|+
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Installation check */
end_comment

begin_function
name|int
name|int2f_43
parameter_list|(
name|regcontext_t
modifier|*
name|REGS
parameter_list|)
block|{
switch|switch
condition|(
name|R_AL
condition|)
block|{
case|case
literal|0x00
case|:
comment|/* installation check */
name|R_AL
operator|=
literal|0x80
expr_stmt|;
break|break;
case|case
literal|0x10
case|:
comment|/* get handler address */
name|PUTVEC
argument_list|(
name|R_ES
argument_list|,
name|R_BX
argument_list|,
name|xms_vector
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Main call entry point for the XMS handler from DOS */
end_comment

begin_function
specifier|static
name|void
name|xms_entry
parameter_list|(
name|regcontext_t
modifier|*
name|REGS
parameter_list|)
block|{
if|if
condition|(
name|R_AH
operator|!=
literal|0
condition|)
name|vec_grabbed
operator|=
literal|1
expr_stmt|;
comment|/* If the HMA feature is disabled these calls are "not managed" */
if|if
condition|(
name|HMA_a20
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|R_AH
operator|==
name|XMS_ALLOCATE_HIGH_MEMORY
operator|||
name|R_AH
operator|==
name|XMS_FREE_HIGH_MEMORY
operator|||
name|R_AH
operator|==
name|XMS_GLOBAL_ENABLE_A20
operator|||
name|R_AH
operator|==
name|XMS_GLOBAL_DISABLE_A20
operator|||
name|R_AH
operator|==
name|XMS_LOCAL_ENABLE_A20
operator|||
name|R_AH
operator|==
name|XMS_LOCAL_DISABLE_A20
operator|||
name|R_AH
operator|==
name|XMS_QUERY_A20
condition|)
block|{
name|R_AX
operator|=
literal|0x0
expr_stmt|;
name|R_BL
operator|=
name|XMS_HMA_NOT_MANAGED
expr_stmt|;
return|return;
block|}
block|}
switch|switch
condition|(
name|R_AH
condition|)
block|{
case|case
name|XMS_GET_VERSION
case|:
name|debug
argument_list|(
name|D_XMS
argument_list|,
literal|"XMS: Get Version\n"
argument_list|)
expr_stmt|;
name|R_AX
operator|=
name|XMS_VERSION
expr_stmt|;
comment|/* 3.0 */
name|R_BX
operator|=
name|XMS_REVISION
expr_stmt|;
comment|/* internal revision 0 */
name|R_DX
operator|=
operator|(
name|HMA_a20
operator|<
literal|0
operator|)
condition|?
literal|0x0000
else|:
literal|0x0001
expr_stmt|;
break|break;
comment|/*      * XXX Not exact! Spec says compare size to a HMAMIN parameter and      * refuse HMA, if space is too small. With MSDOS 5.0 and higher DOS      * itself uses the HMA (DOS=HIGH), so I think we can safely ignore      * that.      */
case|case
name|XMS_ALLOCATE_HIGH_MEMORY
case|:
name|debug
argument_list|(
name|D_XMS
argument_list|,
literal|"XMS: Allocate HMA\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HMA_allocated
condition|)
block|{
name|R_AX
operator|=
literal|0x0
expr_stmt|;
name|R_BL
operator|=
name|XMS_HMA_ALREADY_USED
expr_stmt|;
block|}
else|else
block|{
name|HMA_allocated
operator|=
literal|1
expr_stmt|;
name|R_AX
operator|=
literal|0x1
expr_stmt|;
name|R_BL
operator|=
name|XMS_SUCCESS
expr_stmt|;
block|}
break|break;
case|case
name|XMS_FREE_HIGH_MEMORY
case|:
name|debug
argument_list|(
name|D_XMS
argument_list|,
literal|"XMS: Free HMA\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HMA_allocated
condition|)
block|{
name|HMA_allocated
operator|=
literal|0
expr_stmt|;
name|R_AX
operator|=
literal|0x1
expr_stmt|;
name|R_BL
operator|=
name|XMS_SUCCESS
expr_stmt|;
block|}
else|else
block|{
name|R_AX
operator|=
literal|0x0
expr_stmt|;
name|R_BL
operator|=
name|XMS_HMA_NOT_ALLOCATED
expr_stmt|;
block|}
break|break;
case|case
name|XMS_GLOBAL_ENABLE_A20
case|:
name|debug
argument_list|(
name|D_XMS
argument_list|,
literal|"XMS: Global enable A20\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HMA_a20
operator|==
literal|0
condition|)
name|enable_a20
argument_list|()
expr_stmt|;
name|HMA_a20
operator|=
literal|1
expr_stmt|;
name|R_AX
operator|=
literal|0x1
expr_stmt|;
name|R_BL
operator|=
name|XMS_SUCCESS
expr_stmt|;
break|break;
case|case
name|XMS_GLOBAL_DISABLE_A20
case|:
name|debug
argument_list|(
name|D_XMS
argument_list|,
literal|"XMS: Global disable A20\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HMA_a20
operator|!=
literal|0
condition|)
name|disable_a20
argument_list|()
expr_stmt|;
name|HMA_a20
operator|=
literal|0
expr_stmt|;
name|R_AX
operator|=
literal|0x1
expr_stmt|;
name|R_BL
operator|=
name|XMS_SUCCESS
expr_stmt|;
break|break;
comment|/*      * This is an accumulating call. Every call increments HMA_a20.     * Caller must use LOCAL_DISBALE_A20 once for each previous call     * to LOCAL_ENABLE_A20.     */
case|case
name|XMS_LOCAL_ENABLE_A20
case|:
name|debug
argument_list|(
name|D_XMS
argument_list|,
literal|"XMS: Local enable A20\n"
argument_list|)
expr_stmt|;
name|HMA_a20
operator|++
expr_stmt|;
if|if
condition|(
name|HMA_a20
operator|==
literal|1
condition|)
name|enable_a20
argument_list|()
expr_stmt|;
name|R_AX
operator|=
literal|0x1
expr_stmt|;
name|R_BL
operator|=
name|XMS_SUCCESS
expr_stmt|;
break|break;
case|case
name|XMS_LOCAL_DISABLE_A20
case|:
name|debug
argument_list|(
name|D_XMS
argument_list|,
literal|"XMS: Local disable A20\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HMA_a20
operator|>
literal|0
condition|)
name|HMA_a20
operator|--
expr_stmt|;
if|if
condition|(
name|HMA_a20
operator|==
literal|0
condition|)
name|disable_a20
argument_list|()
expr_stmt|;
name|R_AX
operator|=
literal|0x1
expr_stmt|;
name|R_BL
operator|=
name|XMS_SUCCESS
expr_stmt|;
break|break;
case|case
name|XMS_QUERY_A20
case|:
comment|/*      * Disabled because DOS permanently scans this, to avoid endless output.      */
if|#
directive|if
literal|0
block|debug(D_XMS, "XMS: Query A20\n"); */
endif|#
directive|endif
name|R_AX
operator|=
operator|(
name|HMA_a20
operator|>
literal|0
operator|)
operator|?
literal|0x1
operator|:
literal|0x0
expr_stmt|;
name|R_BL
operator|=
name|XMS_SUCCESS
expr_stmt|;
break|break;
case|case
name|XMS_QUERY_FREE_EXTENDED_MEMORY
case|:
comment|/* DOS MEM.EXE chokes, if the HMA is enabled and the reported 	 * free space includes the HMA. So we subtract 64kB from the 	 * space reported, if the HMA is enabled. 	 */
if|if
condition|(
name|HMA_a20
operator|<
literal|0
condition|)
name|R_EAX
operator|=
name|R_EDX
operator|=
name|xms_free_mem
operator|/
literal|1024
expr_stmt|;
else|else
name|R_EAX
operator|=
name|R_EDX
operator|=
operator|(
name|xms_free_mem
operator|/
literal|1024
operator|)
operator|-
literal|64
expr_stmt|;
if|if
condition|(
name|xms_free_mem
operator|==
literal|0
condition|)
name|R_BL
operator|=
name|XMS_FULL
expr_stmt|;
else|else
name|R_BL
operator|=
name|XMS_SUCCESS
expr_stmt|;
name|debug
argument_list|(
name|D_XMS
argument_list|,
literal|"XMS: Query free EMM: Returned %dkB\n"
argument_list|,
name|R_AX
argument_list|)
expr_stmt|;
break|break;
case|case
name|XMS_ALLOCATE_EXTENDED_MEMORY
case|:
block|{
name|size_t
name|req_siz
decl_stmt|;
name|int
name|hindx
decl_stmt|,
name|hnum
decl_stmt|;
name|void
modifier|*
name|mem
decl_stmt|;
name|debug
argument_list|(
name|D_XMS
argument_list|,
literal|"XMS: Allocate EMM: "
argument_list|)
expr_stmt|;
comment|/* Enough handles ? */
if|if
condition|(
operator|(
name|hnum
operator|=
name|get_free_handle
argument_list|()
operator|)
operator|==
literal|0
condition|)
block|{
name|R_AX
operator|=
literal|0x00
expr_stmt|;
name|R_BL
operator|=
name|XMS_OUT_OF_HANDLES
expr_stmt|;
name|debug
argument_list|(
name|D_XMS
argument_list|,
literal|" Out of handles\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|hindx
operator|=
name|hnum
operator|-
literal|1
expr_stmt|;
name|req_siz
operator|=
name|R_DX
operator|*
literal|1024
expr_stmt|;
comment|/* Enough memory ? */
if|if
condition|(
name|req_siz
operator|>
name|xms_free_mem
condition|)
block|{
name|R_AX
operator|=
literal|0x00
expr_stmt|;
name|R_BL
operator|=
name|XMS_FULL
expr_stmt|;
name|debug
argument_list|(
name|D_XMS
argument_list|,
literal|" No memory left\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|xms_hand
index|[
name|hindx
index|]
operator|.
name|size
operator|=
name|req_siz
expr_stmt|;
name|xms_hand
index|[
name|hindx
index|]
operator|.
name|num_locks
operator|=
literal|0
expr_stmt|;
comment|/* XXX 	     * Not sure about that: Is it possible to reserve a handle  	     * but with no memory attached ? XMS specs are unclear on 	     * that point. Linux implementation does it this way. 	     */
if|if
condition|(
name|req_siz
operator|==
literal|0
condition|)
block|{
comment|/* This handle is reserved, but has size 0 and no address */
name|xms_hand
index|[
name|hindx
index|]
operator|.
name|addr
operator|=
name|XMS_NULL_ALLOC
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|mem
operator|=
name|malloc
argument_list|(
name|req_siz
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"XMS: Cannot malloc !"
argument_list|)
expr_stmt|;
name|xms_hand
index|[
name|hindx
index|]
operator|.
name|addr
operator|=
operator|(
name|u_long
operator|)
name|mem
expr_stmt|;
block|}
name|xms_free_mem
operator|-=
name|req_siz
expr_stmt|;
name|xms_used_mem
operator|+=
name|req_siz
expr_stmt|;
name|num_free_handle
operator|--
expr_stmt|;
name|R_AX
operator|=
literal|0x1
expr_stmt|;
name|R_DX
operator|=
name|hnum
expr_stmt|;
name|R_BL
operator|=
name|XMS_SUCCESS
expr_stmt|;
name|debug
argument_list|(
name|D_XMS
argument_list|,
literal|" Allocated %d kB, handle %d\n"
argument_list|,
name|req_siz
operator|/
literal|1024
argument_list|,
name|hnum
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XMS_FREE_EXTENDED_MEMORY
case|:
block|{
name|int
name|hnum
decl_stmt|,
name|hindx
decl_stmt|;
name|debug
argument_list|(
name|D_XMS
argument_list|,
literal|"XMS: Free EMM: "
argument_list|)
expr_stmt|;
name|hnum
operator|=
name|R_DX
expr_stmt|;
if|if
condition|(
name|hnum
operator|>
name|NUM_HANDLES
operator|||
name|hnum
operator|==
literal|0
condition|)
block|{
name|R_AX
operator|=
literal|0x0
expr_stmt|;
name|R_BL
operator|=
name|XMS_INVALID_HANDLE
expr_stmt|;
name|debug
argument_list|(
name|D_XMS
argument_list|,
literal|" Invalid handle\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|hindx
operator|=
name|hnum
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|xms_hand
index|[
name|hindx
index|]
operator|.
name|addr
operator|==
literal|0
condition|)
block|{
name|R_AX
operator|=
literal|0x0
expr_stmt|;
name|R_BL
operator|=
name|XMS_INVALID_HANDLE
expr_stmt|;
name|debug
argument_list|(
name|D_XMS
argument_list|,
literal|" Invalid handle\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|xms_hand
index|[
name|hindx
index|]
operator|.
name|num_locks
operator|>
literal|0
condition|)
block|{
name|R_AX
operator|=
literal|0x0
expr_stmt|;
name|R_BL
operator|=
name|XMS_BLOCK_IS_LOCKED
expr_stmt|;
name|debug
argument_list|(
name|D_XMS
argument_list|,
literal|" Is locked\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|xms_hand
index|[
name|hindx
index|]
operator|.
name|addr
operator|!=
name|XMS_NULL_ALLOC
condition|)
block|{
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|xms_hand
index|[
name|hindx
index|]
operator|.
name|addr
argument_list|)
expr_stmt|;
name|xms_free_mem
operator|+=
name|xms_hand
index|[
name|hindx
index|]
operator|.
name|size
expr_stmt|;
name|xms_used_mem
operator|-=
name|xms_hand
index|[
name|hindx
index|]
operator|.
name|size
expr_stmt|;
block|}
name|xms_hand
index|[
name|hindx
index|]
operator|.
name|addr
operator|=
literal|0
expr_stmt|;
name|xms_hand
index|[
name|hindx
index|]
operator|.
name|size
operator|=
literal|0
expr_stmt|;
name|xms_hand
index|[
name|hindx
index|]
operator|.
name|num_locks
operator|=
literal|0
expr_stmt|;
name|num_free_handle
operator|++
expr_stmt|;
name|debug
argument_list|(
name|D_XMS
argument_list|,
literal|" Success for handle %d\n"
argument_list|,
name|hnum
argument_list|)
expr_stmt|;
name|R_AX
operator|=
literal|0x1
expr_stmt|;
name|R_BL
operator|=
name|XMS_SUCCESS
expr_stmt|;
block|}
break|break;
block|}
case|case
name|XMS_MOVE_EXTENDED_MEMORY_BLOCK
case|:
block|{
name|u_long
name|srcptr
decl_stmt|,
name|dstptr
decl_stmt|;
name|u_long
name|srcoffs
decl_stmt|,
name|dstoffs
decl_stmt|;
name|int
name|srcidx
decl_stmt|,
name|dstidx
decl_stmt|;
specifier|const
name|struct
name|EMM
modifier|*
name|eptr
decl_stmt|;
name|int
name|n
decl_stmt|;
name|debug
argument_list|(
name|D_XMS
argument_list|,
literal|"XMS: Move EMM block: "
argument_list|)
expr_stmt|;
name|eptr
operator|=
operator|(
expr|struct
name|EMM
operator|*
operator|)
name|MAKEPTR
argument_list|(
name|R_DS
argument_list|,
name|R_SI
argument_list|)
expr_stmt|;
comment|/* Sanity check: Don't allow eptr pointing to emulator data */
if|if
condition|(
operator|(
operator|(
name|u_long
operator|)
name|eptr
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|EMM
argument_list|)
operator|)
operator|>=
literal|0x100000
condition|)
block|{
name|R_AX
operator|=
literal|0x0
expr_stmt|;
name|R_BL
operator|=
name|XMS_GENERAL_ERROR
expr_stmt|;
name|debug
argument_list|(
name|D_XMS
argument_list|,
literal|" Offset to EMM structure wrong\n"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Validate handles and offsets */
if|if
condition|(
name|eptr
operator|->
name|src_handle
operator|>
name|NUM_HANDLES
condition|)
block|{
name|R_AX
operator|=
literal|0x0
expr_stmt|;
name|R_BL
operator|=
name|XMS_INVALID_SOURCE_HANDLE
expr_stmt|;
name|debug
argument_list|(
name|D_XMS
argument_list|,
literal|" Invalid handle\n"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|eptr
operator|->
name|dst_handle
operator|>
name|NUM_HANDLES
condition|)
block|{
name|R_AX
operator|=
literal|0x0
expr_stmt|;
name|R_BL
operator|=
name|XMS_INVALID_DESTINATION_HANDLE
expr_stmt|;
name|debug
argument_list|(
name|D_XMS
argument_list|,
literal|" Invalid handle\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|srcidx
operator|=
name|eptr
operator|->
name|src_handle
operator|-
literal|1
expr_stmt|;
name|dstidx
operator|=
name|eptr
operator|->
name|dst_handle
operator|-
literal|1
expr_stmt|;
name|srcoffs
operator|=
name|eptr
operator|->
name|src_offset
expr_stmt|;
name|dstoffs
operator|=
name|eptr
operator|->
name|dst_offset
expr_stmt|;
name|n
operator|=
name|eptr
operator|->
name|nbytes
expr_stmt|;
comment|/* Length must be even, see XMS spec */
if|if
condition|(
name|n
operator|&
literal|1
condition|)
block|{
name|R_AX
operator|=
literal|0x0
expr_stmt|;
name|R_BL
operator|=
name|XMS_INVALID_LENGTH
expr_stmt|;
name|debug
argument_list|(
name|D_XMS
argument_list|,
literal|" Length not even\n"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|eptr
operator|->
name|src_handle
operator|!=
literal|0
condition|)
block|{
name|srcptr
operator|=
name|xms_hand
index|[
name|srcidx
index|]
operator|.
name|addr
expr_stmt|;
if|if
condition|(
name|srcptr
operator|==
literal|0
operator|||
name|srcptr
operator|==
name|XMS_NULL_ALLOC
condition|)
block|{
name|R_AX
operator|=
literal|0x0
expr_stmt|;
name|R_BL
operator|=
name|XMS_INVALID_SOURCE_HANDLE
expr_stmt|;
name|debug
argument_list|(
name|D_XMS
argument_list|,
literal|" Invalid source handle\n"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|srcoffs
operator|+
name|n
operator|)
operator|>
name|xms_hand
index|[
name|srcidx
index|]
operator|.
name|size
condition|)
block|{
name|R_AX
operator|=
literal|0x0
expr_stmt|;
name|R_BL
operator|=
name|XMS_INVALID_SOURCE_OFFSET
expr_stmt|;
name|debug
argument_list|(
name|D_XMS
argument_list|,
literal|" Invalid source offset\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|srcptr
operator|+=
name|srcoffs
expr_stmt|;
block|}
else|else
block|{
name|srcptr
operator|=
name|VECPTR
argument_list|(
name|srcoffs
argument_list|)
expr_stmt|;
comment|/* Sanity check: Don't allow srcptr pointing to  		 * emulator data above 1M 		 */
if|if
condition|(
operator|(
name|srcptr
operator|+
name|n
operator|)
operator|>=
literal|0x100000
condition|)
block|{
name|R_AX
operator|=
literal|0x0
expr_stmt|;
name|R_BL
operator|=
name|XMS_GENERAL_ERROR
expr_stmt|;
name|debug
argument_list|(
name|D_XMS
argument_list|,
literal|" Source segment invalid\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|eptr
operator|->
name|dst_handle
operator|!=
literal|0
condition|)
block|{
name|dstptr
operator|=
name|xms_hand
index|[
name|dstidx
index|]
operator|.
name|addr
expr_stmt|;
if|if
condition|(
name|dstptr
operator|==
name|NULL
operator|||
name|dstptr
operator|==
name|XMS_NULL_ALLOC
condition|)
block|{
name|R_AX
operator|=
literal|0x0
expr_stmt|;
name|R_BL
operator|=
name|XMS_INVALID_DESTINATION_HANDLE
expr_stmt|;
name|debug
argument_list|(
name|D_XMS
argument_list|,
literal|" Invalid dest handle\n"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|dstoffs
operator|+
name|n
operator|)
operator|>
name|xms_hand
index|[
name|dstidx
index|]
operator|.
name|size
condition|)
block|{
name|R_AX
operator|=
literal|0x0
expr_stmt|;
name|R_BL
operator|=
name|XMS_INVALID_DESTINATION_OFFSET
expr_stmt|;
name|debug
argument_list|(
name|D_XMS
argument_list|,
literal|" Invalid dest offset\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|dstptr
operator|+=
name|dstoffs
expr_stmt|;
block|}
else|else
block|{
name|dstptr
operator|=
name|VECPTR
argument_list|(
name|dstoffs
argument_list|)
expr_stmt|;
comment|/* Sanity check: Don't allow dstptr pointing to  		 * emulator data above 1M 		 */
if|if
condition|(
operator|(
name|dstptr
operator|+
name|n
operator|)
operator|>=
literal|0x100000
condition|)
block|{
name|R_AX
operator|=
literal|0x0
expr_stmt|;
name|R_BL
operator|=
name|XMS_GENERAL_ERROR
expr_stmt|;
name|debug
argument_list|(
name|D_XMS
argument_list|,
literal|" Dest segment invalid\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|memmove
argument_list|(
operator|(
name|void
operator|*
operator|)
name|dstptr
argument_list|,
operator|(
name|void
operator|*
operator|)
name|srcptr
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|D_XMS
argument_list|,
literal|"Moved from %08lx to %08lx, %04x bytes\n"
argument_list|,
name|srcptr
argument_list|,
name|dstptr
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|R_AX
operator|=
literal|0x1
expr_stmt|;
name|R_BL
operator|=
name|XMS_SUCCESS
expr_stmt|;
break|break;
block|}
case|case
name|XMS_LOCK_EXTENDED_MEMORY_BLOCK
case|:
block|{
name|int
name|hnum
decl_stmt|,
name|hindx
decl_stmt|;
name|debug
argument_list|(
name|D_XMS
argument_list|,
literal|"XMS: Lock EMM block\n"
argument_list|)
expr_stmt|;
name|hnum
operator|=
name|R_DX
expr_stmt|;
if|if
condition|(
name|hnum
operator|>
name|NUM_HANDLES
operator|||
name|hnum
operator|==
literal|0
condition|)
block|{
name|R_AX
operator|=
literal|0x0
expr_stmt|;
name|R_BL
operator|=
name|XMS_INVALID_HANDLE
expr_stmt|;
break|break;
block|}
name|hindx
operator|=
name|hnum
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|xms_hand
index|[
name|hindx
index|]
operator|.
name|addr
operator|==
literal|0
condition|)
block|{
name|R_AX
operator|=
literal|0x0
expr_stmt|;
name|R_BL
operator|=
name|XMS_INVALID_HANDLE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|xms_hand
index|[
name|hindx
index|]
operator|.
name|num_locks
operator|==
literal|255
condition|)
block|{
name|R_AX
operator|=
literal|0x0
expr_stmt|;
name|R_BL
operator|=
name|XMS_BLOCK_LOCKCOUNT_OVERFLOW
expr_stmt|;
break|break;
block|}
name|xms_hand
index|[
name|hindx
index|]
operator|.
name|num_locks
operator|++
expr_stmt|;
name|R_AX
operator|=
literal|0x1
expr_stmt|;
comment|/*  	     * The 32 bit "physical" address is returned here. I hope 	     * the solution to simply return the linear address of the 	     * malloced area is good enough. Most DOS programs won't 	     * need this anyway. It could be important for future DPMI. 	     */
name|R_BX
operator|=
name|xms_hand
index|[
name|hindx
index|]
operator|.
name|addr
operator|&
literal|0xffff
expr_stmt|;
name|R_DX
operator|=
operator|(
name|xms_hand
index|[
name|hindx
index|]
operator|.
name|addr
operator|&
literal|0xffff0000
operator|)
operator|>>
literal|16
expr_stmt|;
break|break;
block|}
case|case
name|XMS_UNLOCK_EXTENDED_MEMORY_BLOCK
case|:
block|{
name|int
name|hnum
decl_stmt|,
name|hindx
decl_stmt|;
name|debug
argument_list|(
name|D_XMS
argument_list|,
literal|"XMS: Unlock EMM block\n"
argument_list|)
expr_stmt|;
name|hnum
operator|=
name|R_DX
expr_stmt|;
if|if
condition|(
name|hnum
operator|>
name|NUM_HANDLES
operator|||
name|hnum
operator|==
literal|0
condition|)
block|{
name|R_AX
operator|=
literal|0x0
expr_stmt|;
name|R_BL
operator|=
name|XMS_INVALID_HANDLE
expr_stmt|;
break|break;
block|}
name|hindx
operator|=
name|hnum
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|xms_hand
index|[
name|hindx
index|]
operator|.
name|addr
operator|==
literal|0
condition|)
block|{
name|R_AX
operator|=
literal|0x0
expr_stmt|;
name|R_BL
operator|=
name|XMS_INVALID_HANDLE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|xms_hand
index|[
name|hindx
index|]
operator|.
name|num_locks
operator|==
literal|0
condition|)
block|{
name|R_AX
operator|=
literal|0x0
expr_stmt|;
name|R_BL
operator|=
name|XMS_BLOCK_NOT_LOCKED
expr_stmt|;
break|break;
block|}
name|xms_hand
index|[
name|hindx
index|]
operator|.
name|num_locks
operator|--
expr_stmt|;
name|R_AX
operator|=
literal|0x1
expr_stmt|;
name|R_BL
operator|=
name|XMS_SUCCESS
expr_stmt|;
break|break;
block|}
case|case
name|XMS_GET_EMB_HANDLE_INFORMATION
case|:
block|{
name|int
name|hnum
decl_stmt|,
name|hindx
decl_stmt|;
name|debug
argument_list|(
name|D_XMS
argument_list|,
literal|"XMS: Get handle information: DX=%04x\n"
argument_list|,
name|R_DX
argument_list|)
expr_stmt|;
name|hnum
operator|=
name|R_DX
expr_stmt|;
if|if
condition|(
name|hnum
operator|>
name|NUM_HANDLES
operator|||
name|hnum
operator|==
literal|0
condition|)
block|{
name|R_AX
operator|=
literal|0x0
expr_stmt|;
name|R_BL
operator|=
name|XMS_INVALID_HANDLE
expr_stmt|;
break|break;
block|}
name|hindx
operator|=
name|hnum
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|xms_hand
index|[
name|hindx
index|]
operator|.
name|addr
operator|==
literal|0
condition|)
block|{
name|R_AX
operator|=
literal|0x0
expr_stmt|;
name|R_BL
operator|=
name|XMS_INVALID_HANDLE
expr_stmt|;
break|break;
block|}
name|R_AX
operator|=
literal|0x1
expr_stmt|;
name|R_BH
operator|=
name|xms_hand
index|[
name|hindx
index|]
operator|.
name|num_locks
expr_stmt|;
name|R_BL
operator|=
name|num_free_handle
expr_stmt|;
name|R_DX
operator|=
name|xms_hand
index|[
name|hindx
index|]
operator|.
name|size
operator|/
literal|1024
expr_stmt|;
break|break;
block|}
case|case
name|XMS_RESIZE_EXTENDED_MEMORY_BLOCK
case|:
block|{
name|int
name|hnum
decl_stmt|,
name|hindx
decl_stmt|;
name|size_t
name|req_siz
decl_stmt|;
name|long
name|sizediff
decl_stmt|;
name|void
modifier|*
name|mem
decl_stmt|;
name|debug
argument_list|(
name|D_XMS
argument_list|,
literal|"XMS: Resize EMM block\n"
argument_list|)
expr_stmt|;
name|hnum
operator|=
name|R_DX
expr_stmt|;
name|req_siz
operator|=
name|R_BX
operator|*
literal|1024
expr_stmt|;
if|if
condition|(
name|hnum
operator|>
name|NUM_HANDLES
operator|||
name|hnum
operator|==
literal|0
condition|)
block|{
name|R_AX
operator|=
literal|0x0
expr_stmt|;
name|R_BL
operator|=
name|XMS_INVALID_HANDLE
expr_stmt|;
break|break;
block|}
name|hindx
operator|=
name|hnum
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|xms_hand
index|[
name|hindx
index|]
operator|.
name|addr
operator|==
literal|0
condition|)
block|{
name|R_AX
operator|=
literal|0x0
expr_stmt|;
name|R_BL
operator|=
name|XMS_INVALID_HANDLE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|xms_hand
index|[
name|hindx
index|]
operator|.
name|num_locks
operator|>
literal|0
condition|)
block|{
name|R_AX
operator|=
literal|0x0
expr_stmt|;
name|R_BL
operator|=
name|XMS_BLOCK_IS_LOCKED
expr_stmt|;
break|break;
block|}
name|sizediff
operator|=
name|req_siz
operator|-
name|xms_hand
index|[
name|hindx
index|]
operator|.
name|size
expr_stmt|;
if|if
condition|(
name|sizediff
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|sizediff
operator|+
name|xms_used_mem
operator|)
operator|>
name|xms_maxsize
condition|)
block|{
name|R_AX
operator|=
literal|0x0
expr_stmt|;
name|R_BL
operator|=
name|XMS_FULL
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|sizediff
operator|==
literal|0
condition|)
block|{
comment|/* Never trust DOS programs */
name|R_AX
operator|=
literal|0x1
expr_stmt|;
name|R_BL
operator|=
name|XMS_SUCCESS
expr_stmt|;
break|break;
block|}
name|xms_used_mem
operator|+=
name|sizediff
expr_stmt|;
name|xms_free_mem
operator|-=
name|sizediff
expr_stmt|;
if|if
condition|(
name|xms_hand
index|[
name|hindx
index|]
operator|.
name|addr
operator|==
name|XMS_NULL_ALLOC
condition|)
block|{
if|if
condition|(
operator|(
name|mem
operator|=
name|malloc
argument_list|(
name|req_siz
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"XMS: Cannot malloc !"
argument_list|)
expr_stmt|;
name|xms_hand
index|[
name|hindx
index|]
operator|.
name|addr
operator|=
operator|(
name|u_long
operator|)
name|mem
expr_stmt|;
name|xms_hand
index|[
name|hindx
index|]
operator|.
name|size
operator|=
name|req_siz
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|mem
operator|=
name|realloc
argument_list|(
operator|(
name|void
operator|*
operator|)
name|xms_hand
index|[
name|hindx
index|]
operator|.
name|addr
argument_list|,
name|req_siz
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"XMS: Cannot realloc !"
argument_list|)
expr_stmt|;
name|xms_hand
index|[
name|hindx
index|]
operator|.
name|addr
operator|=
operator|(
name|u_long
operator|)
name|mem
expr_stmt|;
name|xms_hand
index|[
name|hindx
index|]
operator|.
name|size
operator|=
name|req_siz
expr_stmt|;
block|}
name|R_AX
operator|=
literal|0x1
expr_stmt|;
name|R_BL
operator|=
name|XMS_SUCCESS
expr_stmt|;
break|break;
block|}
case|case
name|XMS_ALLOCATE_UMB
case|:
block|{
name|u_long
name|req_siz
decl_stmt|;
name|UMB_block
modifier|*
name|bp
decl_stmt|;
name|debug
argument_list|(
name|D_XMS
argument_list|,
literal|"XMS: Allocate UMB: DX=%04x\n"
argument_list|,
name|R_DX
argument_list|)
expr_stmt|;
name|req_siz
operator|=
name|R_DX
operator|*
literal|16
expr_stmt|;
comment|/* Some programs try to allocate 0 bytes. XMS spec says 	     * nothing about this. So the driver grants the request 	     * but it rounds up to the next paragraph size (1) and 	     * returns this amount of memory 	     */
if|if
condition|(
name|req_siz
operator|==
literal|0
condition|)
name|req_siz
operator|=
literal|0x10
expr_stmt|;
comment|/* First try to find an exact fit */
if|if
condition|(
operator|(
name|bp
operator|=
name|find_exact_block
argument_list|(
name|req_siz
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* Found ! Move block from free list to alloc list */
name|remove_block
argument_list|(
operator|&
name|UMB_freelist
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|add_block
argument_list|(
operator|&
name|UMB_alloclist
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|R_AX
operator|=
literal|0x1
expr_stmt|;
name|R_DX
operator|=
name|req_siz
operator|>>
literal|4
expr_stmt|;
name|R_BX
operator|=
name|bp
operator|->
name|addr
operator|>>
literal|4
expr_stmt|;
break|break;
block|}
comment|/* Try to find a block big enough */
name|bp
operator|=
name|find_block
argument_list|(
name|req_siz
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
block|{
name|R_AX
operator|=
literal|0x0
expr_stmt|;
name|R_BL
operator|=
name|XMS_NO_UMBS_AVAILABLE
expr_stmt|;
name|R_DX
operator|=
literal|0x0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bp
operator|->
name|size
operator|<
name|req_siz
condition|)
block|{
name|R_AX
operator|=
literal|0x0
expr_stmt|;
name|R_BL
operator|=
name|XMS_REQUESTED_UMB_TOO_BIG
expr_stmt|;
name|R_DX
operator|=
name|bp
operator|->
name|size
operator|/
literal|16
expr_stmt|;
block|}
else|else
block|{
name|UMB_block
modifier|*
name|newbp
decl_stmt|;
comment|/* Found a block large enough. Split it into the size 		 * we need, rest remains on the free list. New block 		 * goes to the alloc list 		 */
name|newbp
operator|=
name|create_block
argument_list|(
name|bp
operator|->
name|addr
argument_list|,
name|req_siz
argument_list|)
expr_stmt|;
name|bp
operator|->
name|addr
operator|+=
name|req_siz
expr_stmt|;
name|bp
operator|->
name|size
operator|-=
name|req_siz
expr_stmt|;
name|add_block
argument_list|(
operator|&
name|UMB_alloclist
argument_list|,
name|newbp
argument_list|)
expr_stmt|;
name|R_AX
operator|=
literal|0x1
expr_stmt|;
name|R_BX
operator|=
name|newbp
operator|->
name|addr
operator|>>
literal|4
expr_stmt|;
name|R_DX
operator|=
name|req_siz
operator|/
literal|16
expr_stmt|;
block|}
break|break;
block|}
case|case
name|XMS_DEALLOCATE_UMB
case|:
block|{
name|u_long
name|req_addr
decl_stmt|;
name|UMB_block
modifier|*
name|blk
decl_stmt|;
name|debug
argument_list|(
name|D_XMS
argument_list|,
literal|"XMS: Deallocate UMB: DX=%04x\n"
argument_list|,
name|R_DX
argument_list|)
expr_stmt|;
name|req_addr
operator|=
name|R_DX
operator|<<
literal|4
expr_stmt|;
if|if
condition|(
operator|(
name|blk
operator|=
name|find_allocated_block
argument_list|(
name|req_addr
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|R_AX
operator|=
literal|0x0
expr_stmt|;
name|R_BL
operator|=
name|XMS_INVALID_UMB_SEGMENT
expr_stmt|;
block|}
else|else
block|{
comment|/* Move the block from the alloc list to the free list 		 * and try to do garbage collection 		 */
name|remove_block
argument_list|(
operator|&
name|UMB_alloclist
argument_list|,
name|blk
argument_list|)
expr_stmt|;
name|add_block
argument_list|(
operator|&
name|UMB_freelist
argument_list|,
name|blk
argument_list|)
expr_stmt|;
name|merge_blocks
argument_list|()
expr_stmt|;
name|R_AX
operator|=
literal|0x1
expr_stmt|;
name|R_BL
operator|=
name|XMS_SUCCESS
expr_stmt|;
block|}
break|break;
block|}
comment|/*       * If the option DOS=UMB is enabled, DOS grabs the entire UMB      * at boot time. In any other case this is used to load resident      * utilities. I don't think this function is neccesary here.      */
case|case
name|XMS_REALLOCATE_UMB
case|:
name|debug
argument_list|(
name|D_XMS
argument_list|,
literal|"XMS: Reallocate UMB\n"
argument_list|)
expr_stmt|;
name|R_AX
operator|=
literal|0x0
expr_stmt|;
name|R_BL
operator|=
name|XMS_NOT_IMPLEMENTED
expr_stmt|;
break|break;
comment|/* Some test programs use this call */
case|case
name|XMS_QUERY_FREE_EXTENDED_MEMORY_LARGE
case|:
comment|/* DOS MEM.EXE chokes, if the HMA is enabled and the reported 	 * free space includes the HMA. So we subtract 64kB from the 	 * space reported, if the HMA is enabled. 	 */
if|if
condition|(
name|HMA_a20
operator|<
literal|0
condition|)
name|R_EAX
operator|=
name|R_EDX
operator|=
name|xms_free_mem
operator|/
literal|1024
expr_stmt|;
else|else
name|R_EAX
operator|=
name|R_EDX
operator|=
operator|(
name|xms_free_mem
operator|/
literal|1024
operator|)
operator|-
literal|64
expr_stmt|;
comment|/* ECX should return the highest address of any memory block 	 * We return 1MB + size of extended memory  	 */
name|R_ECX
operator|=
literal|1024
operator|*
literal|1024
operator|+
name|xms_maxsize
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|xms_free_mem
operator|==
literal|0
condition|)
name|R_BL
operator|=
name|XMS_FULL
expr_stmt|;
else|else
name|R_BL
operator|=
name|XMS_SUCCESS
expr_stmt|;
name|debug
argument_list|(
name|D_XMS
argument_list|,
literal|"XMS: Query free EMM(large): Returned %dkB\n"
argument_list|,
name|R_AX
argument_list|)
expr_stmt|;
break|break;
comment|/* These are the same as the above functions, but they use 32 bit      * registers (i.e. EDX instead of DX). This is for allocations of       * more than 64MB. I think this will hardly be used in the emulator      * It seems to work without them, but the functions are in the XMS 3.0      * spec. If something breaks because they are not here, I can implement      * them      */
case|case
name|XMS_ALLOCATE_EXTENDED_MEMORY_LARGE
case|:
case|case
name|XMS_FREE_EXTENDED_MEMORY_LARGE
case|:
name|debug
argument_list|(
name|D_XMS
argument_list|,
literal|"XMS: %02x function called, not implemented\n"
argument_list|,
name|R_AH
argument_list|)
expr_stmt|;
name|R_AX
operator|=
literal|0x0
expr_stmt|;
name|R_BL
operator|=
name|XMS_NOT_IMPLEMENTED
expr_stmt|;
break|break;
default|default:
name|debug
argument_list|(
name|D_ALWAYS
argument_list|,
literal|"XMS: Unimplemented function %02x, \n"
argument_list|,
name|R_AH
argument_list|)
expr_stmt|;
name|R_AX
operator|=
literal|0
expr_stmt|;
name|R_BL
operator|=
name|XMS_NOT_IMPLEMENTED
expr_stmt|;
break|break;
block|}
block|}
end_function

end_unit

