begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2001 The FreeBSD Project, Inc.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY The FreeBSD Project, Inc. AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED  * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL The FreeBSD Project, Inc. OR  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;  * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR  * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF  * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<paths.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"doscmd.h"
end_include

begin_include
include|#
directive|include
file|"AsyncIO.h"
end_include

begin_include
include|#
directive|include
file|"tty.h"
end_include

begin_include
include|#
directive|include
file|"video.h"
end_include

begin_include
include|#
directive|include
file|"vparams.h"
end_include

begin_comment
comment|/*  * Global variables  */
end_comment

begin_comment
comment|/* VGA registers */
end_comment

begin_decl_stmt
name|u_int8_t
name|VGA_CRTC
index|[
name|CRTC_Size
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int8_t
name|VGA_ATC
index|[
name|ATC_Size
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int8_t
name|VGA_TSC
index|[
name|TSC_Size
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int8_t
name|VGA_GDC
index|[
name|GDC_Size
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* VGA status information */
end_comment

begin_decl_stmt
name|u_int8_t
name|vga_status
index|[
literal|64
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Table of supported video modes. */
end_comment

begin_decl_stmt
name|vmode_t
name|vmodelist
index|[]
init|=
block|{
block|{
literal|0x00
block|,
literal|0x17
block|,
name|TEXT
block|,
literal|16
block|,
literal|8
block|,
literal|2
block|,
literal|0xb8000
block|,
name|FONT8x16
block|}
block|,
block|{
literal|0x01
block|,
literal|0x17
block|,
name|TEXT
block|,
literal|16
block|,
literal|8
block|,
literal|2
block|,
literal|0xb8000
block|,
name|FONT8x16
block|}
block|,
block|{
literal|0x02
block|,
literal|0x18
block|,
name|TEXT
block|,
literal|16
block|,
literal|8
block|,
literal|2
block|,
literal|0xb8000
block|,
name|FONT8x16
block|}
block|,
block|{
literal|0x03
block|,
literal|0x18
block|,
name|TEXT
block|,
literal|16
block|,
literal|8
block|,
literal|2
block|,
literal|0xb8000
block|,
name|FONT8x16
block|}
block|,
block|{
literal|0x04
block|,
literal|0x04
block|,
name|GRAPHICS
block|,
literal|4
block|,
literal|1
block|,
literal|0
block|,
literal|0xb8000
block|,
name|FONT8x8
block|}
block|,
block|{
literal|0x05
block|,
literal|0x05
block|,
name|GRAPHICS
block|,
literal|4
block|,
literal|1
block|,
literal|0
block|,
literal|0xb8000
block|,
name|FONT8x8
block|}
block|,
block|{
literal|0x06
block|,
literal|0x06
block|,
name|GRAPHICS
block|,
literal|2
block|,
literal|1
block|,
literal|0
block|,
literal|0xb8000
block|,
name|FONT8x8
block|}
block|,
block|{
literal|0x07
block|,
literal|0x19
block|,
name|TEXT
block|,
literal|1
block|,
literal|8
block|,
literal|2
block|,
literal|0xb0000
block|,
name|FONT8x16
block|}
block|,
block|{
literal|0x08
block|,
literal|0x08
block|,
name|NOMODE
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0x09
block|,
literal|0x09
block|,
name|NOMODE
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0x0a
block|,
literal|0x0a
block|,
name|NOMODE
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0x0b
block|,
literal|0x0b
block|,
name|NOMODE
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0x0c
block|,
literal|0x0c
block|,
name|NOMODE
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0x0d
block|,
literal|0x0d
block|,
name|GRAPHICS
block|,
literal|16
block|,
literal|8
block|,
literal|0
block|,
literal|0xa0000
block|,
name|FONT8x8
block|}
block|,
block|{
literal|0x0e
block|,
literal|0x0e
block|,
name|GRAPHICS
block|,
literal|16
block|,
literal|4
block|,
literal|0
block|,
literal|0xa0000
block|,
name|FONT8x8
block|}
block|,
block|{
literal|0x0f
block|,
literal|0x11
block|,
name|GRAPHICS
block|,
literal|1
block|,
literal|2
block|,
literal|1
block|,
literal|0xa0000
block|,
name|FONT8x14
block|}
block|,
block|{
literal|0x10
block|,
literal|0x12
block|,
name|GRAPHICS
block|,
literal|16
block|,
literal|2
block|,
literal|1
block|,
literal|0xa0000
block|,
name|FONT8x14
block|}
block|,
block|{
literal|0x11
block|,
literal|0x1a
block|,
name|GRAPHICS
block|,
literal|2
block|,
literal|1
block|,
literal|3
block|,
literal|0xa0000
block|,
name|FONT8x16
block|}
block|,
block|{
literal|0x12
block|,
literal|0x1b
block|,
name|GRAPHICS
block|,
literal|16
block|,
literal|1
block|,
literal|3
block|,
literal|0xa0000
block|,
name|FONT8x16
block|}
block|,
comment|/*     {0x13, 0x1c, GRAPHICS, 256, 1, 0, 0xa0000, FONT8x8}, */
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NUMMODES
value|(sizeof(vmodelist) / sizeof(vmode_t))
end_define

begin_comment
comment|/*  * Local functions  */
end_comment

begin_function_decl
specifier|static
name|void
name|init_vga
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int8_t
name|video_inb
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|video_outb
parameter_list|(
name|int
parameter_list|,
name|u_int8_t
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Local types and variables  */
end_comment

begin_comment
comment|/* Save Table and assorted variables */
end_comment

begin_struct
struct|struct
name|VideoSaveTable
block|{
name|u_short
name|video_parameter_table
index|[
literal|2
index|]
decl_stmt|;
name|u_short
name|parameter_dynamic_save_area
index|[
literal|2
index|]
decl_stmt|;
comment|/* Not used */
name|u_short
name|alphanumeric_character_set_override
index|[
literal|2
index|]
decl_stmt|;
comment|/* Not used */
name|u_short
name|graphics_character_set_override
index|[
literal|2
index|]
decl_stmt|;
comment|/* Not used */
name|u_short
name|secondary_save_table
index|[
literal|2
index|]
decl_stmt|;
comment|/* Not used */
name|u_short
name|mbz
index|[
literal|4
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|SecondaryVideoSaveTable
block|{
name|u_short
name|length
decl_stmt|;
name|u_short
name|display_combination_code_table
index|[
literal|2
index|]
decl_stmt|;
name|u_short
name|alphanumeric_character_set_override
index|[
literal|2
index|]
decl_stmt|;
comment|/* Not used */
name|u_short
name|user_palette_profile_table
index|[
literal|2
index|]
decl_stmt|;
comment|/* Not used */
name|u_short
name|mbz
index|[
literal|6
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|VideoSaveTable
modifier|*
name|vsp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|SecondaryVideoSaveTable
modifier|*
name|svsp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Read and write the VGA port  */
end_comment

begin_comment
comment|/* Save the selected index register */
end_comment

begin_decl_stmt
specifier|static
name|u_int8_t
name|crtc_index
decl_stmt|,
name|atc_index
decl_stmt|,
name|tsc_index
decl_stmt|,
name|gdc_index
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Toggle between index and data on port ATC_WritePort */
end_comment

begin_decl_stmt
specifier|static
name|u_int8_t
name|set_atc_index
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|u_int8_t
name|video_inb
parameter_list|(
name|int
name|port
parameter_list|)
block|{
switch|switch
condition|(
name|port
condition|)
block|{
case|case
name|CRTC_DataPortColor
case|:
return|return
name|VGA_CRTC
index|[
name|crtc_index
index|]
return|;
case|case
name|CRTC_IndexPortColor
case|:
return|return
name|crtc_index
return|;
case|case
name|ATC_ReadPort
case|:
return|return
name|VGA_ATC
index|[
name|atc_index
index|]
return|;
case|case
name|TSC_DataPort
case|:
return|return
name|VGA_TSC
index|[
name|tsc_index
index|]
return|;
case|case
name|TSC_IndexPort
case|:
return|return
name|tsc_index
return|;
case|case
name|GDC_DataPort
case|:
return|return
name|VGA_GDC
index|[
name|gdc_index
index|]
return|;
case|case
name|GDC_IndexPort
case|:
return|return
name|gdc_index
return|;
case|case
name|VGA_InputStatus1Port
case|:
name|set_atc_index
operator|=
literal|1
expr_stmt|;
return|return
name|VGA_InputStatus1
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|video_outb
parameter_list|(
name|int
name|port
parameter_list|,
name|u_int8_t
name|value
parameter_list|)
block|{
comment|/* XXX */
define|#
directive|define
name|row
value|(CursRow0)
define|#
directive|define
name|col
value|(CursCol0)
name|int
name|cp
decl_stmt|;
switch|switch
condition|(
name|port
condition|)
block|{
case|case
name|CRTC_IndexPortColor
case|:
name|crtc_index
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|CRTC_DataPortColor
case|:
name|VGA_CRTC
index|[
name|crtc_index
index|]
operator|=
name|value
expr_stmt|;
switch|switch
condition|(
name|crtc_index
condition|)
block|{
case|case
name|CRTC_CurLocHi
case|:
comment|/* Update cursor position in BIOS */
name|cp
operator|=
name|row
operator|*
name|DpyCols
operator|+
name|col
expr_stmt|;
name|cp
operator|&=
literal|0xff
expr_stmt|;
name|cp
operator||=
name|value
operator|<<
literal|8
expr_stmt|;
name|row
operator|=
name|cp
operator|/
name|DpyCols
expr_stmt|;
name|col
operator|=
name|cp
operator|%
name|DpyCols
expr_stmt|;
break|break;
case|case
name|CRTC_CurLocLo
case|:
comment|/* Update cursor position in BIOS */
name|cp
operator|=
name|row
operator|*
name|DpyCols
operator|+
name|col
expr_stmt|;
name|cp
operator|&=
literal|0xff00
expr_stmt|;
name|cp
operator||=
name|value
expr_stmt|;
name|row
operator|=
name|cp
operator|/
name|DpyCols
expr_stmt|;
name|col
operator|=
name|cp
operator|%
name|DpyCols
expr_stmt|;
break|break;
default|default:
name|debug
argument_list|(
name|D_VIDEO
argument_list|,
literal|"outb 0x%04x, 0x%02x at index 0x%02x\n"
argument_list|,
name|port
argument_list|,
name|value
argument_list|,
name|crtc_index
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|CRTC_IndexPortMono
case|:
comment|/* Not used */
break|break;
case|case
name|CRTC_DataPortMono
case|:
comment|/* Not used */
break|break;
case|case
name|ATC_WritePort
case|:
if|if
condition|(
name|set_atc_index
condition|)
name|atc_index
operator|=
name|value
expr_stmt|;
else|else
block|{
name|VGA_ATC
index|[
name|atc_index
index|]
operator|=
name|value
expr_stmt|;
switch|switch
condition|(
name|atc_index
condition|)
block|{
default|default:
name|debug
argument_list|(
name|D_VIDEO
argument_list|,
literal|"outb 0x%04x, 0x%02x at index 0x%02x\n"
argument_list|,
name|port
argument_list|,
name|value
argument_list|,
name|crtc_index
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|set_atc_index
operator|=
literal|1
operator|-
name|set_atc_index
expr_stmt|;
break|break;
case|case
name|TSC_IndexPort
case|:
name|tsc_index
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|TSC_DataPort
case|:
name|VGA_TSC
index|[
name|tsc_index
index|]
operator|=
name|value
expr_stmt|;
switch|switch
condition|(
name|tsc_index
condition|)
block|{
default|default:
name|debug
argument_list|(
name|D_VIDEO
argument_list|,
literal|"outb 0x%04x, 0x%02x at index 0x%02x\n"
argument_list|,
name|port
argument_list|,
name|value
argument_list|,
name|crtc_index
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|GDC_IndexPort
case|:
name|gdc_index
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|GDC_DataPort
case|:
name|VGA_GDC
index|[
name|gdc_index
index|]
operator|=
name|value
expr_stmt|;
if|#
directive|if
literal|0
block|switch (gdc_index) { 	default: 	    debug(D_VIDEO, "outb 0x%04x, 0x%02x at index 0x%02x\n", 		  port, value, crtc_index);  	    break; 	}
endif|#
directive|endif
break|break;
default|default:
name|debug
argument_list|(
name|D_ALWAYS
argument_list|,
literal|"Unknown port 0x%4x\n"
argument_list|,
name|port
argument_list|)
expr_stmt|;
break|break;
block|}
return|return;
undef|#
directive|undef
name|row
undef|#
directive|undef
name|col
block|}
end_function

begin_function
name|void
name|video_init
parameter_list|()
block|{
comment|/* If we are running under X, get a connection to the X server and create        an empty window of size (1, 1). It makes a couple of init functions a        lot easier. */
if|if
condition|(
name|xmode
condition|)
block|{
name|init_window
argument_list|()
expr_stmt|;
comment|/* Set VGA emulator to a sane state */
name|init_vga
argument_list|()
expr_stmt|;
comment|/* Initialize mode 3 (text, 80x25, 16 colors) */
name|init_mode
argument_list|(
literal|3
argument_list|)
expr_stmt|;
block|}
comment|/* Define all known I/O port handlers */
if|if
condition|(
operator|!
name|raw_kbd
condition|)
block|{
name|define_input_port_handler
argument_list|(
name|CRTC_IndexPortColor
argument_list|,
name|video_inb
argument_list|)
expr_stmt|;
name|define_input_port_handler
argument_list|(
name|CRTC_DataPortColor
argument_list|,
name|video_inb
argument_list|)
expr_stmt|;
name|define_input_port_handler
argument_list|(
name|ATC_ReadPort
argument_list|,
name|video_inb
argument_list|)
expr_stmt|;
name|define_input_port_handler
argument_list|(
name|TSC_IndexPort
argument_list|,
name|video_inb
argument_list|)
expr_stmt|;
name|define_input_port_handler
argument_list|(
name|TSC_DataPort
argument_list|,
name|video_inb
argument_list|)
expr_stmt|;
name|define_input_port_handler
argument_list|(
name|GDC_IndexPort
argument_list|,
name|video_inb
argument_list|)
expr_stmt|;
name|define_input_port_handler
argument_list|(
name|GDC_DataPort
argument_list|,
name|video_inb
argument_list|)
expr_stmt|;
name|define_output_port_handler
argument_list|(
name|CRTC_IndexPortColor
argument_list|,
name|video_outb
argument_list|)
expr_stmt|;
name|define_output_port_handler
argument_list|(
name|CRTC_DataPortColor
argument_list|,
name|video_outb
argument_list|)
expr_stmt|;
name|define_output_port_handler
argument_list|(
name|ATC_WritePort
argument_list|,
name|video_outb
argument_list|)
expr_stmt|;
name|define_output_port_handler
argument_list|(
name|TSC_IndexPort
argument_list|,
name|video_outb
argument_list|)
expr_stmt|;
name|define_output_port_handler
argument_list|(
name|TSC_DataPort
argument_list|,
name|video_outb
argument_list|)
expr_stmt|;
name|define_output_port_handler
argument_list|(
name|GDC_IndexPort
argument_list|,
name|video_outb
argument_list|)
expr_stmt|;
name|define_output_port_handler
argument_list|(
name|GDC_DataPort
argument_list|,
name|video_outb
argument_list|)
expr_stmt|;
block|}
name|redirect0
operator|=
name|isatty
argument_list|(
literal|0
argument_list|)
operator|==
literal|0
operator|||
operator|!
name|xmode
expr_stmt|;
name|redirect1
operator|=
name|isatty
argument_list|(
literal|1
argument_list|)
operator|==
literal|0
operator|||
operator|!
name|xmode
expr_stmt|;
name|redirect2
operator|=
name|isatty
argument_list|(
literal|2
argument_list|)
operator|==
literal|0
operator|||
operator|!
name|xmode
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|video_bios_init
parameter_list|()
block|{
name|u_char
modifier|*
name|p
decl_stmt|;
name|u_long
name|vec
decl_stmt|;
if|if
condition|(
name|raw_kbd
condition|)
return|return;
comment|/*      * Put the Video Save Table Pointer @ C000:0000      * Put the Secondary Video Save Table Pointer @ C000:0020      * Put the Display Combination Code table @ C000:0040      * Put the Video Parameter table @ C000:1000 - C000:2FFF      */
name|BIOS_SaveTablePointer
operator|=
literal|0xC0000000
expr_stmt|;
name|vsp
operator|=
operator|(
expr|struct
name|VideoSaveTable
operator|*
operator|)
literal|0xC0000L
expr_stmt|;
name|memset
argument_list|(
name|vsp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|VideoSaveTable
argument_list|)
argument_list|)
expr_stmt|;
name|svsp
operator|=
operator|(
expr|struct
name|SecondaryVideoSaveTable
operator|*
operator|)
literal|0xC0020L
expr_stmt|;
name|vsp
operator|->
name|video_parameter_table
index|[
literal|0
index|]
operator|=
literal|0x1000
expr_stmt|;
name|vsp
operator|->
name|video_parameter_table
index|[
literal|1
index|]
operator|=
literal|0xC000
expr_stmt|;
name|vsp
operator|->
name|secondary_save_table
index|[
literal|0
index|]
operator|=
literal|0x0020
expr_stmt|;
name|vsp
operator|->
name|secondary_save_table
index|[
literal|1
index|]
operator|=
literal|0xC000
expr_stmt|;
name|svsp
operator|->
name|display_combination_code_table
index|[
literal|0
index|]
operator|=
literal|0x0040
expr_stmt|;
name|svsp
operator|->
name|display_combination_code_table
index|[
literal|1
index|]
operator|=
literal|0xC000
expr_stmt|;
name|p
operator|=
operator|(
name|u_char
operator|*
operator|)
literal|0xC0040
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|2
expr_stmt|;
comment|/* Only support 2 combinations currently */
operator|*
name|p
operator|++
operator|=
literal|1
expr_stmt|;
comment|/* Version # */
operator|*
name|p
operator|++
operator|=
literal|8
expr_stmt|;
comment|/* We won't use more than type 8 */
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* Reserved */
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* No Display No Display */
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|8
expr_stmt|;
comment|/* No Display VGA Color */
name|memcpy
argument_list|(
operator|(
name|void
operator|*
operator|)
literal|0xC1000
argument_list|,
name|videoparams
argument_list|,
sizeof|sizeof
argument_list|(
name|videoparams
argument_list|)
argument_list|)
expr_stmt|;
name|ivec
index|[
literal|0x1d
index|]
operator|=
literal|0xC0001000L
expr_stmt|;
comment|/* Video Parameter Table */
name|ivec
index|[
literal|0x42
index|]
operator|=
name|ivec
index|[
literal|0x10
index|]
expr_stmt|;
comment|/* Copy of video interrupt */
comment|/* Put the current font at C000:3000; the pixels are copied in        'tty.c:load_font()'. */
name|ivec
index|[
literal|0x1f
index|]
operator|=
literal|0xC0003000L
expr_stmt|;
name|ivec
index|[
literal|0x43
index|]
operator|=
literal|0xC0003000L
expr_stmt|;
name|BIOSDATA
index|[
literal|0x8a
index|]
operator|=
literal|1
expr_stmt|;
comment|/* Index into DCC table */
name|vec
operator|=
name|insert_softint_trampoline
argument_list|()
expr_stmt|;
name|ivec
index|[
literal|0x10
index|]
operator|=
name|vec
expr_stmt|;
name|register_callback
argument_list|(
name|vec
argument_list|,
name|int10
argument_list|,
literal|"int 10"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize the VGA emulator     XXX This is not nearly finished right now. */
end_comment

begin_function
specifier|static
name|void
name|init_vga
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* Zero-fill 'dac_rgb' on allocation; the default (EGA) table has only        64 entries. */
name|dac_rgb
operator|=
operator|(
expr|struct
name|dac_colors
operator|*
operator|)
name|calloc
argument_list|(
literal|256
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dac_colors
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dac_rgb
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"Get memory for dac_rgb"
argument_list|)
expr_stmt|;
comment|/* Copy the default DAC table to a working copy we can trash. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|64
condition|;
name|i
operator|++
control|)
name|dac_rgb
index|[
name|i
index|]
operator|=
name|dac_default64
index|[
name|i
index|]
expr_stmt|;
comment|/* Structure copy */
comment|/* Point 'palette[]' to the Attribute Controller space. We will only use        the first 16 slots. */
name|palette
operator|=
name|VGA_ATC
expr_stmt|;
comment|/* Get memory for the video RAM and adjust the plane pointers. */
name|vram
operator|=
name|calloc
argument_list|(
literal|256
operator|*
literal|1024
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* XXX */
if|if
condition|(
name|vram
operator|==
name|NULL
condition|)
name|warn
argument_list|(
literal|"Could not get video memory; graphics modes not available."
argument_list|)
expr_stmt|;
comment|/* XXX There is probably a more efficient memory layout... */
name|vplane0
operator|=
name|vram
expr_stmt|;
name|vplane1
operator|=
name|vram
operator|+
literal|0x10000
expr_stmt|;
name|vplane2
operator|=
name|vram
operator|+
literal|0x20000
expr_stmt|;
name|vplane3
operator|=
name|vram
operator|+
literal|0x30000
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize the requested video mode.  */
end_comment

begin_comment
comment|/* Indices into the video parameter table. We will use that array to    initialize the registers on startup and when the video mode changes. */
end_comment

begin_define
define|#
directive|define
name|CRTC_Ofs
value|10
end_define

begin_define
define|#
directive|define
name|ATC_Ofs
value|35
end_define

begin_define
define|#
directive|define
name|TSC_Ofs
value|5
end_define

begin_define
define|#
directive|define
name|GDC_Ofs
value|55
end_define

begin_define
define|#
directive|define
name|MiscOutput_Ofs
value|9
end_define

begin_function
name|void
name|init_mode
parameter_list|(
name|int
name|mode
parameter_list|)
block|{
name|vmode_t
name|vmode
decl_stmt|;
name|int
name|idx
decl_stmt|;
comment|/* Index into vmode */
name|int
name|pidx
decl_stmt|;
comment|/* Index into videoparams */
name|debug
argument_list|(
name|D_VIDEO
argument_list|,
literal|"Set video mode to 0x%02x\n"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|idx
operator|=
name|find_vmode
argument_list|(
name|mode
operator|&
literal|0x7f
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|==
operator|-
literal|1
operator|||
name|vmodelist
index|[
name|idx
index|]
operator|.
name|type
operator|==
name|NOMODE
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"Mode 0x%02x is not supported"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|vmode
operator|=
name|vmodelist
index|[
name|idx
index|]
expr_stmt|;
name|pidx
operator|=
name|vmode
operator|.
name|paramindex
expr_stmt|;
comment|/* Preset VGA registers. */
name|memcpy
argument_list|(
name|VGA_CRTC
argument_list|,
operator|(
name|u_int8_t
operator|*
operator|)
operator|&
name|videoparams
index|[
name|pidx
index|]
index|[
name|CRTC_Ofs
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|VGA_CRTC
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|VGA_ATC
argument_list|,
operator|(
name|u_int8_t
operator|*
operator|)
operator|&
name|videoparams
index|[
name|pidx
index|]
index|[
name|ATC_Ofs
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|VGA_ATC
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Warning: the video parameter table does not contain the Sequencer's        Reset register. Its default value is 0x03.*/
name|VGA_TSC
index|[
name|TSC_Reset
index|]
operator|=
literal|0x03
expr_stmt|;
name|memcpy
argument_list|(
name|VGA_TSC
operator|+
literal|1
argument_list|,
operator|(
name|u_int8_t
operator|*
operator|)
operator|&
name|videoparams
index|[
name|pidx
index|]
index|[
name|TSC_Ofs
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|VGA_TSC
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|VGA_GDC
argument_list|,
operator|(
name|u_int8_t
operator|*
operator|)
operator|&
name|videoparams
index|[
name|pidx
index|]
index|[
name|GDC_Ofs
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|VGA_GDC
argument_list|)
argument_list|)
expr_stmt|;
name|VGA_MiscOutput
operator|=
name|videoparams
index|[
name|pidx
index|]
index|[
name|MiscOutput_Ofs
index|]
expr_stmt|;
comment|/* Paranoia */
if|if
condition|(
operator|(
name|VGA_ATC
index|[
name|ATC_ModeCtrl
index|]
operator|&
literal|1
operator|)
operator|==
literal|1
operator|&&
name|vmode
operator|.
name|type
operator|==
name|TEXT
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"Text mode requested, but ATC switched to graphics mode!"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|VGA_ATC
index|[
name|ATC_ModeCtrl
index|]
operator|&
literal|1
operator|)
operator|==
literal|0
operator|&&
name|vmode
operator|.
name|type
operator|==
name|GRAPHICS
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"Graphics mode requested, but ATC switched to text mode!"
argument_list|)
expr_stmt|;
name|VideoMode
operator|=
name|mode
operator|&
literal|0x7f
expr_stmt|;
name|DpyCols
operator|=
operator|(
name|u_int16_t
operator|)
name|videoparams
index|[
name|pidx
index|]
index|[
literal|0
index|]
expr_stmt|;
name|DpyPageSize
operator|=
operator|*
operator|(
name|u_int16_t
operator|*
operator|)
operator|&
name|videoparams
index|[
name|pidx
index|]
index|[
literal|3
index|]
expr_stmt|;
name|ActivePageOfs
operator|=
literal|0
expr_stmt|;
name|CursCol0
operator|=
literal|0
expr_stmt|;
name|CursRow0
operator|=
literal|0
expr_stmt|;
name|CursCol1
operator|=
literal|0
expr_stmt|;
name|CursRow1
operator|=
literal|0
expr_stmt|;
name|CursCol2
operator|=
literal|0
expr_stmt|;
name|CursRow2
operator|=
literal|0
expr_stmt|;
name|CursCol3
operator|=
literal|0
expr_stmt|;
name|CursRow3
operator|=
literal|0
expr_stmt|;
name|CursCol4
operator|=
literal|0
expr_stmt|;
name|CursRow4
operator|=
literal|0
expr_stmt|;
name|CursCol5
operator|=
literal|0
expr_stmt|;
name|CursRow5
operator|=
literal|0
expr_stmt|;
name|CursCol6
operator|=
literal|0
expr_stmt|;
name|CursRow6
operator|=
literal|0
expr_stmt|;
name|CursCol7
operator|=
literal|0
expr_stmt|;
name|CursRow7
operator|=
literal|0
expr_stmt|;
name|CursStart
operator|=
name|VGA_CRTC
index|[
name|CRTC_CursStart
index|]
expr_stmt|;
name|CursEnd
operator|=
name|VGA_CRTC
index|[
name|CRTC_CursEnd
index|]
expr_stmt|;
name|ActivePage
operator|=
literal|0
expr_stmt|;
name|DpyRows
operator|=
name|videoparams
index|[
name|pidx
index|]
index|[
literal|1
index|]
expr_stmt|;
name|CharHeight
operator|=
name|videoparams
index|[
name|pidx
index|]
index|[
literal|2
index|]
expr_stmt|;
name|CRTCPort
operator|=
name|vmode
operator|.
name|numcolors
operator|>
literal|1
condition|?
name|CRTC_IndexPortColor
else|:
name|CRTC_IndexPortMono
expr_stmt|;
name|NumColors
operator|=
name|vmode
operator|.
name|numcolors
expr_stmt|;
name|NumPages
operator|=
name|vmode
operator|.
name|numpages
expr_stmt|;
name|VertResolution
operator|=
name|vmode
operator|.
name|vrescode
expr_stmt|;
name|vmem
operator|=
operator|(
name|u_int16_t
operator|*
operator|)
name|vmode
operator|.
name|vmemaddr
expr_stmt|;
comment|/* Copy VGA related BIOS variables from 'vga_status'. */
name|memcpy
argument_list|(
operator|&
name|BIOS_VideoMode
argument_list|,
operator|&
name|VideoMode
argument_list|,
literal|33
argument_list|)
expr_stmt|;
name|BIOS_DpyRows
operator|=
name|DpyRows
expr_stmt|;
name|BIOS_CharHeight
operator|=
name|CharHeight
expr_stmt|;
name|_BlockIO
argument_list|()
expr_stmt|;
comment|/* Load 'pixels[]' from default DAC values. */
name|update_pixels
argument_list|()
expr_stmt|;
comment|/* Update font. */
name|xfont
operator|=
name|vmode
operator|.
name|fontname
expr_stmt|;
name|load_font
argument_list|()
expr_stmt|;
comment|/* Resize window if necessary. */
name|resize_window
argument_list|()
expr_stmt|;
name|_UnblockIO
argument_list|()
expr_stmt|;
comment|/* Mmap video memory for the graphics modes. Write access to 0xa0000 -        0xaffff will generate a T_PAGEFAULT trap in VM86 mode (aside: why not a        SIGSEGV?), which is handled in 'trap.c:sigbus()'. */
if|if
condition|(
name|vmode
operator|.
name|type
operator|==
name|GRAPHICS
condition|)
block|{
name|vmem
operator|=
name|mmap
argument_list|(
operator|(
name|void
operator|*
operator|)
literal|0xa0000
argument_list|,
literal|64
operator|*
literal|1024
argument_list|,
name|PROT_READ
argument_list|,
name|MAP_ANON
operator||
name|MAP_FIXED
operator||
name|MAP_INHERIT
operator||
name|MAP_SHARED
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|vmem
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"Could not mmap() video memory"
argument_list|)
expr_stmt|;
comment|/* Create an XImage to display the graphics screen. */
name|get_ximage
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|int
name|i
decl_stmt|;
name|get_lines
argument_list|()
expr_stmt|;
if|if
condition|(
name|mode
operator|&
literal|0x80
condition|)
return|return;
comment|/* Initialize video memory with black background, white foreground */
name|vattr
operator|=
literal|0x0700
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DpyPageSize
operator|/
literal|2
condition|;
operator|++
name|i
control|)
name|vmem
index|[
name|i
index|]
operator|=
name|vattr
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* Find the requested mode in the 'vmodelist' table. This function returns the    index into this table; we will also use the index for accessing the    'videoparams' array. */
end_comment

begin_function
name|int
name|find_vmode
parameter_list|(
name|int
name|mode
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUMMODES
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|vmodelist
index|[
name|i
index|]
operator|.
name|modenumber
operator|==
name|mode
condition|)
return|return
name|i
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Handle access to the graphics memory.     Simply changing the protection for the memory is not enough, unfortunately.    It would only work for the 256 color modes, where a memory byte contains    the color value of one pixel. The 16 color modes (and 4 color modes) make    use of four bit planes which overlay the first 64K of video memory. The    bits are distributed into these bit planes according to the GDC state, so    we will have to emulate the CPU instructions (see 'cpu.c:emu_instr()').     Handling the 256 color modes will be a bit easier, once we support those at    all. */
end_comment

begin_function
name|int
name|vmem_pageflt
parameter_list|(
name|struct
name|sigframe
modifier|*
name|sf
parameter_list|)
block|{
name|regcontext_t
modifier|*
name|REGS
init|=
operator|(
name|regcontext_t
operator|*
operator|)
operator|(
operator|&
name|sf
operator|->
name|sf_uc
operator|.
name|uc_mcontext
operator|)
decl_stmt|;
comment|/* The ATC's Mode Control register tells us whether 4 or 8 color bits are        used */
if|if
condition|(
name|VGA_ATC
index|[
name|ATC_ModeCtrl
index|]
operator|&
operator|(
literal|1
operator|<<
literal|6
operator|)
condition|)
block|{
comment|/* 256 colors, allow writes; the protection will be set back to            PROT_READ at the next display update */
name|mprotect
argument_list|(
name|vmem
argument_list|,
literal|64
operator|*
literal|1024
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* There's no need to change the protection in the 16 color modes, we will        write to 'vram'. Just emulate the next instruction. */
return|return
name|emu_instr
argument_list|(
name|REGS
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Write a byte to the video memory. 'vga_write()' is called from    'cpu.c:write_word()' and will emulate the VGA write modes. Not all four    modes are implemented yet, nor are the addressing modes (odd/even, chain4).    (NB: I think the latter will have to be done in 'tty_graphics_update()').    */
end_comment

begin_function
name|void
name|vga_write
parameter_list|(
name|u_int32_t
name|addr
parameter_list|,
name|u_int8_t
name|val
parameter_list|)
block|{
name|u_int32_t
name|dst
decl_stmt|;
name|u_int8_t
modifier|*
name|latch0
decl_stmt|,
modifier|*
name|latch1
decl_stmt|,
modifier|*
name|latch2
decl_stmt|,
modifier|*
name|latch3
decl_stmt|;
name|u_int8_t
name|c0
decl_stmt|,
name|c1
decl_stmt|,
name|c2
decl_stmt|,
name|c3
decl_stmt|;
name|u_int8_t
name|m0
decl_stmt|,
name|m1
decl_stmt|,
name|m2
decl_stmt|,
name|m3
decl_stmt|;
name|u_int8_t
name|mask
decl_stmt|;
if|#
directive|if
literal|0
block|int i;          debug(D_VIDEO, "Write 0x%02x to 0x%x\n", val, addr);     debug(D_VIDEO, "GDC: ");     for (i = 0; i< sizeof(VGA_GDC); i++) 	debug(D_VIDEO, "%02x ", VGA_GDC[i]);     debug(D_VIDEO, "\n");     debug(D_VIDEO, "TSC: ");     for (i = 0; i< sizeof(VGA_TSC); i++) 	debug(D_VIDEO, "%02x ", VGA_TSC[i]);     debug(D_VIDEO, "\n");
endif|#
directive|endif
comment|/* 'addr' lies between 0xa0000 and 0xaffff */
name|dst
operator|=
name|addr
operator|-
literal|0xa0000
expr_stmt|;
comment|/* fill latches */
name|latch0
operator|=
name|vplane0
operator|+
name|dst
expr_stmt|;
name|latch1
operator|=
name|vplane1
operator|+
name|dst
expr_stmt|;
name|latch2
operator|=
name|vplane2
operator|+
name|dst
expr_stmt|;
name|latch3
operator|=
name|vplane3
operator|+
name|dst
expr_stmt|;
name|c0
operator|=
operator|*
name|latch0
expr_stmt|;
name|c1
operator|=
operator|*
name|latch1
expr_stmt|;
name|c2
operator|=
operator|*
name|latch2
expr_stmt|;
name|c3
operator|=
operator|*
name|latch3
expr_stmt|;
comment|/* select write mode */
switch|switch
condition|(
name|VGA_GDC
index|[
name|GDC_Mode
index|]
operator|&
literal|3
condition|)
block|{
case|case
literal|0
case|:
comment|/* XXX to do: Enable Set Reset register */
name|mask
operator|=
name|VGA_GDC
index|[
name|GDC_BitMask
index|]
expr_stmt|;
comment|/* select function */
switch|switch
condition|(
name|VGA_GDC
index|[
name|GDC_DataRotate
index|]
operator|&
literal|0x18
condition|)
block|{
case|case
literal|0x00
case|:
comment|/* replace */
name|m0
operator|=
name|VGA_GDC
index|[
name|GDC_SetReset
index|]
operator|&
literal|1
condition|?
name|mask
else|:
literal|0x00
expr_stmt|;
name|m1
operator|=
name|VGA_GDC
index|[
name|GDC_SetReset
index|]
operator|&
literal|2
condition|?
name|mask
else|:
literal|0x00
expr_stmt|;
name|m2
operator|=
name|VGA_GDC
index|[
name|GDC_SetReset
index|]
operator|&
literal|4
condition|?
name|mask
else|:
literal|0x00
expr_stmt|;
name|m3
operator|=
name|VGA_GDC
index|[
name|GDC_SetReset
index|]
operator|&
literal|8
condition|?
name|mask
else|:
literal|0x00
expr_stmt|;
name|c0
operator|&=
operator|~
name|mask
expr_stmt|;
name|c1
operator|&=
operator|~
name|mask
expr_stmt|;
name|c2
operator|&=
operator|~
name|mask
expr_stmt|;
name|c3
operator|&=
operator|~
name|mask
expr_stmt|;
name|c0
operator||=
name|m0
expr_stmt|;
name|c1
operator||=
name|m1
expr_stmt|;
name|c2
operator||=
name|m2
expr_stmt|;
name|c3
operator||=
name|m3
expr_stmt|;
break|break;
case|case
literal|0x08
case|:
comment|/* and */
name|m0
operator|=
name|VGA_GDC
index|[
name|GDC_SetReset
index|]
operator|&
literal|1
condition|?
literal|0xff
else|:
operator|~
name|mask
expr_stmt|;
name|m1
operator|=
name|VGA_GDC
index|[
name|GDC_SetReset
index|]
operator|&
literal|2
condition|?
literal|0xff
else|:
operator|~
name|mask
expr_stmt|;
name|m2
operator|=
name|VGA_GDC
index|[
name|GDC_SetReset
index|]
operator|&
literal|4
condition|?
literal|0xff
else|:
operator|~
name|mask
expr_stmt|;
name|m3
operator|=
name|VGA_GDC
index|[
name|GDC_SetReset
index|]
operator|&
literal|8
condition|?
literal|0xff
else|:
operator|~
name|mask
expr_stmt|;
name|c0
operator|&=
name|m0
expr_stmt|;
name|c1
operator|&=
name|m1
expr_stmt|;
name|c2
operator|&=
name|m2
expr_stmt|;
name|c3
operator|&=
name|m3
expr_stmt|;
break|break;
case|case
literal|0x10
case|:
comment|/* or */
name|m0
operator|=
name|VGA_GDC
index|[
name|GDC_SetReset
index|]
operator|&
literal|1
condition|?
name|mask
else|:
literal|0x00
expr_stmt|;
name|m1
operator|=
name|VGA_GDC
index|[
name|GDC_SetReset
index|]
operator|&
literal|2
condition|?
name|mask
else|:
literal|0x00
expr_stmt|;
name|m2
operator|=
name|VGA_GDC
index|[
name|GDC_SetReset
index|]
operator|&
literal|4
condition|?
name|mask
else|:
literal|0x00
expr_stmt|;
name|m3
operator|=
name|VGA_GDC
index|[
name|GDC_SetReset
index|]
operator|&
literal|8
condition|?
name|mask
else|:
literal|0x00
expr_stmt|;
name|c0
operator||=
name|m0
expr_stmt|;
name|c1
operator||=
name|m1
expr_stmt|;
name|c2
operator||=
name|m2
expr_stmt|;
name|c3
operator||=
name|m3
expr_stmt|;
break|break;
case|case
literal|0x18
case|:
comment|/* xor */
name|m0
operator|=
name|VGA_GDC
index|[
name|GDC_SetReset
index|]
operator|&
literal|1
condition|?
name|mask
else|:
literal|0x00
expr_stmt|;
name|m1
operator|=
name|VGA_GDC
index|[
name|GDC_SetReset
index|]
operator|&
literal|2
condition|?
name|mask
else|:
literal|0x00
expr_stmt|;
name|m2
operator|=
name|VGA_GDC
index|[
name|GDC_SetReset
index|]
operator|&
literal|4
condition|?
name|mask
else|:
literal|0x00
expr_stmt|;
name|m3
operator|=
name|VGA_GDC
index|[
name|GDC_SetReset
index|]
operator|&
literal|8
condition|?
name|mask
else|:
literal|0x00
expr_stmt|;
name|c0
operator|^=
name|m0
expr_stmt|;
name|c1
operator|^=
name|m1
expr_stmt|;
name|c2
operator|^=
name|m2
expr_stmt|;
name|c3
operator|^=
name|m3
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|1
case|:
comment|/* not yet */
break|break;
case|case
literal|2
case|:
name|mask
operator|=
name|VGA_GDC
index|[
name|GDC_BitMask
index|]
expr_stmt|;
comment|/* select function */
switch|switch
condition|(
name|VGA_GDC
index|[
name|GDC_DataRotate
index|]
operator|&
literal|0x18
condition|)
block|{
case|case
literal|0x00
case|:
comment|/* replace */
name|m0
operator|=
operator|(
name|val
operator|&
literal|1
condition|?
literal|0xff
else|:
literal|0x00
operator|)
operator|&
name|mask
expr_stmt|;
name|m1
operator|=
operator|(
name|val
operator|&
literal|2
condition|?
literal|0xff
else|:
literal|0x00
operator|)
operator|&
name|mask
expr_stmt|;
name|m2
operator|=
operator|(
name|val
operator|&
literal|4
condition|?
literal|0xff
else|:
literal|0x00
operator|)
operator|&
name|mask
expr_stmt|;
name|m3
operator|=
operator|(
name|val
operator|&
literal|8
condition|?
literal|0xff
else|:
literal|0x00
operator|)
operator|&
name|mask
expr_stmt|;
name|c0
operator|&=
operator|~
name|mask
expr_stmt|;
name|c1
operator|&=
operator|~
name|mask
expr_stmt|;
name|c2
operator|&=
operator|~
name|mask
expr_stmt|;
name|c3
operator|&=
operator|~
name|mask
expr_stmt|;
name|c0
operator||=
name|m0
expr_stmt|;
name|c1
operator||=
name|m1
expr_stmt|;
name|c2
operator||=
name|m2
expr_stmt|;
name|c3
operator||=
name|m3
expr_stmt|;
break|break;
case|case
literal|0x08
case|:
comment|/* AND */
name|m0
operator|=
operator|(
name|val
operator|&
literal|1
condition|?
literal|0xff
else|:
literal|0x00
operator|)
operator||
operator|~
name|mask
expr_stmt|;
name|m1
operator|=
operator|(
name|val
operator|&
literal|2
condition|?
literal|0xff
else|:
literal|0x00
operator|)
operator||
operator|~
name|mask
expr_stmt|;
name|m2
operator|=
operator|(
name|val
operator|&
literal|4
condition|?
literal|0xff
else|:
literal|0x00
operator|)
operator||
operator|~
name|mask
expr_stmt|;
name|m3
operator|=
operator|(
name|val
operator|&
literal|8
condition|?
literal|0xff
else|:
literal|0x00
operator|)
operator||
operator|~
name|mask
expr_stmt|;
name|c0
operator|&=
name|m0
expr_stmt|;
name|c1
operator|&=
name|m1
expr_stmt|;
name|c2
operator|&=
name|m2
expr_stmt|;
name|c3
operator|&=
name|m3
expr_stmt|;
break|break;
case|case
literal|0x10
case|:
comment|/* OR */
name|m0
operator|=
operator|(
name|val
operator|&
literal|1
condition|?
literal|0xff
else|:
literal|0x00
operator|)
operator|&
name|mask
expr_stmt|;
name|m1
operator|=
operator|(
name|val
operator|&
literal|2
condition|?
literal|0xff
else|:
literal|0x00
operator|)
operator|&
name|mask
expr_stmt|;
name|m2
operator|=
operator|(
name|val
operator|&
literal|4
condition|?
literal|0xff
else|:
literal|0x00
operator|)
operator|&
name|mask
expr_stmt|;
name|m3
operator|=
operator|(
name|val
operator|&
literal|8
condition|?
literal|0xff
else|:
literal|0x00
operator|)
operator|&
name|mask
expr_stmt|;
name|c0
operator||=
name|m0
expr_stmt|;
name|c1
operator||=
name|m1
expr_stmt|;
name|c2
operator||=
name|m2
expr_stmt|;
name|c3
operator||=
name|m3
expr_stmt|;
break|break;
case|case
literal|0x18
case|:
comment|/* XOR */
name|m0
operator|=
operator|(
name|val
operator|&
literal|1
condition|?
literal|0xff
else|:
literal|0x00
operator|)
operator|&
name|mask
expr_stmt|;
name|m1
operator|=
operator|(
name|val
operator|&
literal|2
condition|?
literal|0xff
else|:
literal|0x00
operator|)
operator|&
name|mask
expr_stmt|;
name|m2
operator|=
operator|(
name|val
operator|&
literal|4
condition|?
literal|0xff
else|:
literal|0x00
operator|)
operator|&
name|mask
expr_stmt|;
name|m3
operator|=
operator|(
name|val
operator|&
literal|8
condition|?
literal|0xff
else|:
literal|0x00
operator|)
operator|&
name|mask
expr_stmt|;
name|c0
operator|^=
name|m0
expr_stmt|;
name|c1
operator|^=
name|m1
expr_stmt|;
name|c2
operator|^=
name|m2
expr_stmt|;
name|c3
operator|^=
name|m3
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|3
case|:
comment|/* not yet */
break|break;
block|}
comment|/* write back changed byte, depending on Map Mask register */
if|if
condition|(
name|VGA_TSC
index|[
name|TSC_MapMask
index|]
operator|&
literal|1
condition|)
operator|*
name|latch0
operator|=
name|c0
expr_stmt|;
if|if
condition|(
name|VGA_TSC
index|[
name|TSC_MapMask
index|]
operator|&
literal|2
condition|)
operator|*
name|latch1
operator|=
name|c1
expr_stmt|;
if|if
condition|(
name|VGA_TSC
index|[
name|TSC_MapMask
index|]
operator|&
literal|4
condition|)
operator|*
name|latch2
operator|=
name|c2
expr_stmt|;
if|if
condition|(
name|VGA_TSC
index|[
name|TSC_MapMask
index|]
operator|&
literal|8
condition|)
operator|*
name|latch3
operator|=
name|c3
expr_stmt|;
return|return;
block|}
end_function

end_unit

