begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1992, 1993, 1996  *	Berkeley Software Design, Inc.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by Berkeley Software  *	Design, Inc.  *  * THIS SOFTWARE IS PROVIDED BY Berkeley Software Design, Inc. ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL Berkeley Software Design, Inc. BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	BSDI mem.c,v 2.2 1996/04/08 19:32:57 bostic Exp  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"doscmd.h"
end_include

begin_define
define|#
directive|define
name|Mark
parameter_list|(
name|x
parameter_list|)
value|(*(char *) (x))
end_define

begin_define
define|#
directive|define
name|Owner
parameter_list|(
name|x
parameter_list|)
value|(*(u_short *) ((char *)(x)+1))
end_define

begin_define
define|#
directive|define
name|Size
parameter_list|(
name|x
parameter_list|)
value|(*(u_short *) ((char *)(x)+3))
end_define

begin_define
define|#
directive|define
name|Next
parameter_list|(
name|x
parameter_list|)
value|((char *)(x) + (Size(x)+1)*16)
end_define

begin_comment
comment|/* exports */
end_comment

begin_decl_stmt
name|char
modifier|*
name|dosmem
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* locals */
end_comment

begin_decl_stmt
specifier|static
name|int
name|dosmem_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|next_p
init|=
operator|(
name|char
operator|*
operator|)
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|end_p
init|=
operator|(
name|char
operator|*
operator|)
literal|0xB0000L
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|char
modifier|*
name|core_alloc
parameter_list|(
name|int
modifier|*
name|size
parameter_list|)
block|{
name|char
modifier|*
name|ret
decl_stmt|;
if|if
condition|(
operator|*
name|size
condition|)
block|{
if|if
condition|(
operator|*
name|size
operator|&
literal|0xfff
condition|)
block|{
operator|*
name|size
operator|=
operator|(
operator|*
name|size
operator|&
operator|~
literal|0xfff
operator|)
operator|+
literal|0x1000
expr_stmt|;
block|}
block|}
else|else
block|{
operator|*
name|size
operator|=
name|end_p
operator|-
name|next_p
expr_stmt|;
block|}
if|if
condition|(
name|next_p
operator|+
operator|*
name|size
operator|>
name|end_p
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|ret
operator|=
name|next_p
expr_stmt|;
name|next_p
operator|+=
operator|*
name|size
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|void
name|mem_free_owner
parameter_list|(
name|int
name|owner
parameter_list|)
block|{
name|char
modifier|*
name|mp
decl_stmt|;
name|debug
argument_list|(
name|D_MEMORY
argument_list|,
literal|"    : freeow(%04x)\n"
argument_list|,
name|owner
argument_list|)
expr_stmt|;
for|for
control|(
name|mp
operator|=
name|dosmem
init|;
condition|;
name|mp
operator|=
name|Next
argument_list|(
name|mp
argument_list|)
control|)
block|{
if|if
condition|(
name|Owner
argument_list|(
name|mp
argument_list|)
operator|==
name|owner
condition|)
name|Owner
argument_list|(
name|mp
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|Mark
argument_list|(
name|mp
argument_list|)
operator|!=
literal|'M'
condition|)
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|mem_print
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|mp
decl_stmt|;
for|for
control|(
name|mp
operator|=
name|dosmem
init|;
condition|;
name|mp
operator|=
name|Next
argument_list|(
name|mp
argument_list|)
control|)
block|{
name|debug
argument_list|(
name|D_ALWAYS
argument_list|,
literal|"%8p: mark %c owner %04x size %04x\n"
argument_list|,
name|mp
argument_list|,
name|Mark
argument_list|(
name|mp
argument_list|)
argument_list|,
name|Owner
argument_list|(
name|mp
argument_list|)
argument_list|,
name|Size
argument_list|(
name|mp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|Mark
argument_list|(
name|mp
argument_list|)
operator|!=
literal|'M'
condition|)
break|break;
block|}
block|}
end_function

begin_function
name|void
name|mem_change_owner
parameter_list|(
name|int
name|addr
parameter_list|,
name|int
name|owner
parameter_list|)
block|{
name|char
modifier|*
name|mp
decl_stmt|;
name|debug
argument_list|(
name|D_MEMORY
argument_list|,
literal|"%04x: owner (%04x)\n"
argument_list|,
name|addr
argument_list|,
name|owner
argument_list|)
expr_stmt|;
name|addr
operator|<<=
literal|4
expr_stmt|;
for|for
control|(
name|mp
operator|=
name|dosmem
init|;
condition|;
name|mp
operator|=
name|Next
argument_list|(
name|mp
argument_list|)
control|)
block|{
if|if
condition|(
call|(
name|int
call|)
argument_list|(
name|mp
operator|+
literal|16
argument_list|)
operator|==
name|addr
condition|)
goto|goto
name|found
goto|;
if|if
condition|(
name|Mark
argument_list|(
name|mp
argument_list|)
operator|!=
literal|'M'
condition|)
break|break;
block|}
name|debug
argument_list|(
name|D_ALWAYS
argument_list|,
literal|"%05x: illegal block in change owner\n"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|mem_print
argument_list|()
expr_stmt|;
return|return;
name|found
label|:
name|Owner
argument_list|(
name|mp
argument_list|)
operator|=
name|owner
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mem_init
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|base
decl_stmt|,
name|avail_memory
decl_stmt|;
name|base
operator|=
literal|0x600
expr_stmt|;
name|core_alloc
argument_list|(
operator|&
name|base
argument_list|)
expr_stmt|;
name|avail_memory
operator|=
name|MAX_AVAIL_SEG
operator|*
literal|16
operator|-
name|base
expr_stmt|;
name|dosmem
operator|=
name|core_alloc
argument_list|(
operator|&
name|avail_memory
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dosmem
operator|||
name|dosmem
operator|!=
operator|(
name|char
operator|*
operator|)
name|base
condition|)
name|fatal
argument_list|(
literal|"internal memory error\n"
argument_list|)
expr_stmt|;
name|dosmem_size
operator|=
name|avail_memory
operator|/
literal|16
expr_stmt|;
name|debug
argument_list|(
name|D_MEMORY
argument_list|,
literal|"dosmem = %p base = 0x%x avail = 0x%x (%dK)\n"
argument_list|,
name|dosmem
argument_list|,
name|base
argument_list|,
name|dosmem_size
argument_list|,
name|avail_memory
operator|/
literal|1024
argument_list|)
expr_stmt|;
name|Mark
argument_list|(
name|dosmem
argument_list|)
operator|=
literal|'Z'
expr_stmt|;
name|Owner
argument_list|(
name|dosmem
argument_list|)
operator|=
literal|0
expr_stmt|;
name|Size
argument_list|(
name|dosmem
argument_list|)
operator|=
name|dosmem_size
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mem_unsplit
parameter_list|(
name|char
modifier|*
name|mp
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|char
modifier|*
name|nmp
decl_stmt|;
while|while
condition|(
name|Mark
argument_list|(
name|mp
argument_list|)
operator|==
literal|'M'
operator|&&
name|Size
argument_list|(
name|mp
argument_list|)
operator|<
name|size
condition|)
block|{
name|nmp
operator|=
name|Next
argument_list|(
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
name|Owner
argument_list|(
name|nmp
argument_list|)
operator|!=
literal|0
condition|)
break|break;
name|Size
argument_list|(
name|mp
argument_list|)
operator|+=
name|Size
argument_list|(
name|nmp
argument_list|)
operator|+
literal|1
expr_stmt|;
name|Mark
argument_list|(
name|mp
argument_list|)
operator|=
name|Mark
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|mem_split
parameter_list|(
name|char
modifier|*
name|mp
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|char
modifier|*
name|nmp
decl_stmt|;
name|int
name|rest
decl_stmt|;
name|rest
operator|=
name|Size
argument_list|(
name|mp
argument_list|)
operator|-
name|size
expr_stmt|;
name|Size
argument_list|(
name|mp
argument_list|)
operator|=
name|size
expr_stmt|;
name|nmp
operator|=
name|Next
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|Mark
argument_list|(
name|nmp
argument_list|)
operator|=
name|Mark
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|Mark
argument_list|(
name|mp
argument_list|)
operator|=
literal|'M'
expr_stmt|;
name|Owner
argument_list|(
name|nmp
argument_list|)
operator|=
literal|0
expr_stmt|;
name|Size
argument_list|(
name|nmp
argument_list|)
operator|=
name|rest
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|int
name|mem_alloc
parameter_list|(
name|int
name|size
parameter_list|,
name|int
name|owner
parameter_list|,
name|int
modifier|*
name|biggestp
parameter_list|)
block|{
name|char
modifier|*
name|mp
decl_stmt|;
name|int
name|biggest
decl_stmt|;
name|biggest
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|mp
operator|=
name|dosmem
init|;
condition|;
name|mp
operator|=
name|Next
argument_list|(
name|mp
argument_list|)
control|)
block|{
if|if
condition|(
name|Owner
argument_list|(
name|mp
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|Size
argument_list|(
name|mp
argument_list|)
operator|<
name|size
condition|)
name|mem_unsplit
argument_list|(
name|mp
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|Size
argument_list|(
name|mp
argument_list|)
operator|>=
name|size
condition|)
goto|goto
name|got
goto|;
if|if
condition|(
name|Size
argument_list|(
name|mp
argument_list|)
operator|>
name|biggest
condition|)
name|biggest
operator|=
name|Size
argument_list|(
name|mp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Mark
argument_list|(
name|mp
argument_list|)
operator|!=
literal|'M'
condition|)
break|break;
block|}
name|debug
argument_list|(
name|D_MEMORY
argument_list|,
literal|"%04x: alloc(%04x, owner %04x) failed -> %d\n"
argument_list|,
literal|0
argument_list|,
name|size
argument_list|,
name|owner
argument_list|,
name|biggest
argument_list|)
expr_stmt|;
if|if
condition|(
name|biggestp
condition|)
operator|*
name|biggestp
operator|=
name|biggest
expr_stmt|;
return|return
literal|0
return|;
name|got
label|:
if|if
condition|(
name|Size
argument_list|(
name|mp
argument_list|)
operator|>
name|size
condition|)
name|mem_split
argument_list|(
name|mp
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|Owner
argument_list|(
name|mp
argument_list|)
operator|=
name|owner
expr_stmt|;
name|debug
argument_list|(
name|D_MEMORY
argument_list|,
literal|"%04x: alloc(%04x, owner %04x)\n"
argument_list|,
operator|(
name|int
operator|)
name|mp
operator|/
literal|16
operator|+
literal|1
argument_list|,
name|size
argument_list|,
name|owner
argument_list|)
expr_stmt|;
if|if
condition|(
name|biggestp
condition|)
operator|*
name|biggestp
operator|=
name|size
expr_stmt|;
return|return
operator|(
name|int
operator|)
name|mp
operator|/
literal|16
operator|+
literal|1
return|;
block|}
end_function

begin_function
name|int
name|mem_adjust
parameter_list|(
name|int
name|addr
parameter_list|,
name|int
name|size
parameter_list|,
name|int
modifier|*
name|availp
parameter_list|)
block|{
name|char
modifier|*
name|mp
decl_stmt|;
name|debug
argument_list|(
name|D_MEMORY
argument_list|,
literal|"%04x: adjust(%05x)\n"
argument_list|,
name|addr
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|addr
operator|<<=
literal|4
expr_stmt|;
for|for
control|(
name|mp
operator|=
name|dosmem
init|;
condition|;
name|mp
operator|=
name|Next
argument_list|(
name|mp
argument_list|)
control|)
block|{
if|if
condition|(
call|(
name|int
call|)
argument_list|(
name|mp
operator|+
literal|16
argument_list|)
operator|==
name|addr
condition|)
goto|goto
name|found
goto|;
if|if
condition|(
name|Mark
argument_list|(
name|mp
argument_list|)
operator|!=
literal|'M'
condition|)
break|break;
block|}
name|debug
argument_list|(
name|D_ALWAYS
argument_list|,
literal|"%05x: illegal block in adjust\n"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|mem_print
argument_list|()
expr_stmt|;
return|return
operator|-
literal|2
return|;
name|found
label|:
if|if
condition|(
name|Size
argument_list|(
name|mp
argument_list|)
operator|<
name|size
condition|)
name|mem_unsplit
argument_list|(
name|mp
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|Size
argument_list|(
name|mp
argument_list|)
operator|>=
name|size
condition|)
goto|goto
name|got
goto|;
name|debug
argument_list|(
name|D_MEMORY
argument_list|,
literal|"%04x: adjust(%04x) failed -> %d\n"
argument_list|,
operator|(
name|int
operator|)
name|mp
operator|/
literal|16
operator|+
literal|1
argument_list|,
name|size
argument_list|,
name|Size
argument_list|(
name|mp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|availp
condition|)
operator|*
name|availp
operator|=
name|Size
argument_list|(
name|mp
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
name|got
label|:
if|if
condition|(
name|Size
argument_list|(
name|mp
argument_list|)
operator|>
name|size
condition|)
name|mem_split
argument_list|(
name|mp
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|D_MEMORY
argument_list|,
literal|"%04x: adjust(%04x)\n"
argument_list|,
operator|(
name|int
operator|)
name|mp
operator|/
literal|16
operator|+
literal|1
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|availp
condition|)
operator|*
name|availp
operator|=
name|size
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|MEM_TEST
end_ifdef

begin_macro
name|mem_check
argument_list|()
end_macro

begin_block
block|{
name|struct
name|mem_block
modifier|*
name|mp
decl_stmt|;
for|for
control|(
name|mp
operator|=
name|mem_blocks
operator|.
name|next
init|;
name|mp
operator|!=
operator|&
name|mem_blocks
condition|;
name|mp
operator|=
name|mp
operator|->
name|next
control|)
block|{
if|if
condition|(
name|mp
operator|->
name|addr
operator|+
name|mp
operator|->
name|size
operator|!=
name|mp
operator|->
name|next
operator|->
name|addr
condition|)
break|break;
if|if
condition|(
name|mp
operator|->
name|inuse
operator|&&
name|mp
operator|->
name|size
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|mp
operator|->
name|next
operator|!=
operator|&
name|mem_blocks
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_decl_stmt
name|char
modifier|*
name|blocks
index|[
literal|10
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|int
name|n
decl_stmt|;
name|int
name|newsize
decl_stmt|;
name|mem_init
argument_list|(
literal|0
argument_list|,
literal|300
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|100000
condition|;
name|i
operator|++
control|)
block|{
name|n
operator|=
name|random
argument_list|()
operator|%
literal|10
expr_stmt|;
if|if
condition|(
name|blocks
index|[
name|n
index|]
condition|)
block|{
name|newsize
operator|=
name|random
argument_list|()
operator|%
literal|20
expr_stmt|;
if|if
condition|(
operator|(
name|newsize
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
name|newsize
operator|=
literal|0
expr_stmt|;
if|if
condition|(
literal|0
condition|)
name|printf
argument_list|(
literal|"adjust %d %x %d\n"
argument_list|,
name|n
argument_list|,
name|blocks
index|[
name|n
index|]
argument_list|,
name|newsize
argument_list|)
expr_stmt|;
name|mem_adjust
argument_list|(
name|blocks
index|[
name|n
index|]
argument_list|,
name|newsize
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|newsize
operator|==
literal|0
condition|)
name|blocks
index|[
name|n
index|]
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
operator|(
name|newsize
operator|=
name|random
argument_list|()
operator|%
literal|20
operator|)
operator|==
literal|0
condition|)
empty_stmt|;
if|if
condition|(
literal|0
condition|)
name|printf
argument_list|(
literal|"alloc %d %d\n"
argument_list|,
name|n
argument_list|,
name|newsize
argument_list|)
expr_stmt|;
name|blocks
index|[
name|n
index|]
operator|=
name|mem_alloc
argument_list|(
name|newsize
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mem_check
argument_list|()
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"==== %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|mem_print
argument_list|()
expr_stmt|;
block|}
block|}
name|mem_print
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MEM_TEST */
end_comment

end_unit

