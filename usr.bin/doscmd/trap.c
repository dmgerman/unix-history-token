begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1992, 1993, 1996  *	Berkeley Software Design, Inc.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by Berkeley Software  *	Design, Inc.  *  * THIS SOFTWARE IS PROVIDED BY Berkeley Software Design, Inc. ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL Berkeley Software Design, Inc. BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	BSDI trap.c,v 2.3 1996/04/08 19:33:08 bostic Exp  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|"doscmd.h"
end_include

begin_include
include|#
directive|include
file|"trap.h"
end_include

begin_comment
comment|/*  ** When the emulator is very busy, it's often common for ** SIGALRM to be missed, leading to missed screen updates. ** ** We update this counter every time a DOS interrupt is processed and ** if it hits a certain threshold, force an update. ** ** When updates occur, the counter is zeroed. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|update_counter
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|BUSY_UPDATES
value|2000
end_define

begin_comment
comment|/* ** handle interrupts passed to us by the kernel */
end_comment

begin_function
name|void
name|fake_int
parameter_list|(
name|regcontext_t
modifier|*
name|REGS
parameter_list|,
name|int
name|intnum
parameter_list|)
block|{
if|if
condition|(
name|R_CS
operator|==
literal|0xF000
operator|||
operator|(
name|ivec
index|[
name|intnum
index|]
operator|>>
literal|16
operator|)
operator|==
literal|0xF000
condition|)
block|{
if|if
condition|(
name|R_CS
operator|!=
literal|0xF000
condition|)
name|intnum
operator|=
operator|(
operator|(
name|u_char
operator|*
operator|)
name|VECPTR
argument_list|(
name|ivec
index|[
name|intnum
index|]
argument_list|)
operator|)
index|[
literal|1
index|]
expr_stmt|;
name|debug
argument_list|(
name|D_ITRAPS
operator||
name|intnum
argument_list|,
literal|"int %02x:%02x %04x:%04x/%08x\n"
argument_list|,
name|intnum
argument_list|,
name|R_AH
argument_list|,
name|R_CS
argument_list|,
name|R_IP
argument_list|,
name|ivec
index|[
name|intnum
index|]
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|intnum
condition|)
block|{
case|case
literal|0x2f
case|:
comment|/* multiplex interrupt */
name|int2f
argument_list|(
operator|&
name|REGS
operator|->
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0xff
case|:
comment|/* doscmd special */
name|emuint
argument_list|(
name|REGS
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* should not get here */
if|if
condition|(
name|vflag
condition|)
name|dump_regs
argument_list|(
name|REGS
argument_list|)
expr_stmt|;
name|fatal
argument_list|(
literal|"no interrupt set up for 0x%02x\n"
argument_list|,
name|intnum
argument_list|)
expr_stmt|;
block|}
name|debug
argument_list|(
name|D_ITRAPS
operator||
name|intnum
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|user_int
label|:
name|debug
argument_list|(
name|D_TRAPS
operator||
name|intnum
argument_list|,
literal|"INT %02x:%02x [%04x:%04x] %04x %04x %04x %04x from %04x:%04x\n"
argument_list|,
name|intnum
argument_list|,
name|R_AH
argument_list|,
name|ivec
index|[
name|intnum
index|]
operator|>>
literal|16
argument_list|,
name|ivec
index|[
name|intnum
index|]
operator|&
literal|0xffff
argument_list|,
name|R_AX
argument_list|,
name|R_BX
argument_list|,
name|R_CX
argument_list|,
name|R_DX
argument_list|,
name|R_CS
argument_list|,
name|R_IP
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if ((intnum == 0x13)&& (*(u_char *)VECPTR(ivec[intnum]) != 0xf4)) {
if|#
directive|if
literal|1
block|char *addr;
comment|/*= (char *)VECPTR(ivec[intnum]);*/
block|int i, l, j;         char buf[100];          R_CS = 0x2c7;          R_IP = 0x14f9;         addr = (char *)MAKEPTR(R_CS, R_IP);          printf("\n");         for (i = 0; i< 100; i++) {             l = i386dis(R_CS, R_IP, addr, buf, 0);             printf("%04x:%04x  %s\t;",R_CS,R_IP,buf);             for (j = 0; j< l; j++)                 printf(" %02x", (u_char)addr[j]);             printf("\n");             R_IP += l;             addr += l;         }         exit (0);
else|#
directive|else
block|tmode = 1;
endif|#
directive|endif
block|}
endif|#
directive|endif
if|if
condition|(
name|intnum
operator|==
literal|0
condition|)
name|dump_regs
argument_list|(
name|REGS
argument_list|)
expr_stmt|;
if|if
condition|(
name|ivec
index|[
name|intnum
index|]
operator|==
literal|0
condition|)
block|{
comment|/* uninitialised interrupt? */
if|if
condition|(
name|vflag
condition|)
name|dump_regs
argument_list|(
name|REGS
argument_list|)
expr_stmt|;
name|fatal
argument_list|(
literal|"Call to uninitialised interrupt 0x%02x\n"
argument_list|,
name|intnum
argument_list|)
expr_stmt|;
block|}
comment|/*      * This is really ugly, but when DOS boots, it seems to loop      * for a while on INT 16:11 INT 21:3E INT 2A:82      * INT 21:3E is a close(), which seems like something one would      * not sit on for ever, so we will allow it to reset our POLL count.      */
if|if
condition|(
name|intnum
operator|==
literal|0x21
operator|&&
name|R_AX
operator|==
literal|0x3E
condition|)
name|reset_poll
argument_list|()
expr_stmt|;
comment|/* stack for and call the interrupt in vm86 space */
name|PUSH
argument_list|(
operator|(
name|R_FLAGS
operator|&
operator|~
name|PSL_I
operator|)
operator||
operator|(
name|R_EFLAGS
operator|&
name|PSL_VIF
condition|?
name|PSL_I
else|:
literal|0
operator|)
argument_list|,
name|REGS
argument_list|)
expr_stmt|;
name|PUSH
argument_list|(
name|R_CS
argument_list|,
name|REGS
argument_list|)
expr_stmt|;
name|PUSH
argument_list|(
name|R_IP
argument_list|,
name|REGS
argument_list|)
expr_stmt|;
name|R_EFLAGS
operator|&=
operator|~
name|PSL_VIF
expr_stmt|;
comment|/* disable interrupts */
name|PUTVEC
argument_list|(
name|R_CS
argument_list|,
name|R_IP
argument_list|,
name|ivec
index|[
name|intnum
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* make this read a little more intuitively */
end_comment

begin_define
define|#
directive|define
name|ipadvance
parameter_list|(
name|c
parameter_list|,
name|n
parameter_list|)
value|SET16(c->sc_eip, GET16(c->sc_eip) + n)
end_define

begin_comment
comment|/* move %ip along */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USE_VM86
end_ifdef

begin_comment
comment|/* entry from NetBSD-style vm86 */
end_comment

begin_function
name|void
name|sigurg
parameter_list|(
name|struct
name|sigframe
modifier|*
name|sf
parameter_list|)
block|{
define|#
directive|define
name|sc
value|(&sf->sf_sc)
name|int
name|intnum
decl_stmt|;
name|u_char
modifier|*
name|addr
decl_stmt|;
name|int
name|rep
decl_stmt|;
name|int
name|port
decl_stmt|;
name|callback_t
name|func
decl_stmt|;
if|#
directive|if
literal|0
block|printf("ivec08 = %08x\n", ivec[0x08]);
endif|#
directive|endif
if|if
condition|(
name|tmode
condition|)
name|resettrace
argument_list|(
name|sc
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|VM86_TYPE
argument_list|(
name|sf
operator|->
name|sf_code
argument_list|)
condition|)
block|{
case|case
name|VM86_INTx
case|:
name|intnum
operator|=
name|VM86_ARG
argument_list|(
name|sf
operator|->
name|sf_code
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|intnum
condition|)
block|{
case|case
literal|0x2f
case|:
switch|switch
condition|(
name|GET8H
argument_list|(
name|sc
operator|->
name|sc_eax
argument_list|)
condition|)
block|{
case|case
literal|0x11
case|:
name|debug
argument_list|(
name|D_TRAPS
operator||
literal|0x2f
argument_list|,
literal|"INT 2F:%04x\n"
argument_list|,
name|GET16
argument_list|(
name|sc
operator|->
name|sc_eax
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|int2f_11
argument_list|(
name|sc
argument_list|)
condition|)
block|{
comment|/* Skip over int 2f:11 */
goto|goto
name|out
goto|;
block|}
break|break;
case|case
literal|0x43
case|:
name|debug
argument_list|(
name|D_TRAPS
operator||
literal|0x2f
argument_list|,
literal|"INT 2F:%04x\n"
argument_list|,
name|GET16
argument_list|(
name|sc
operator|->
name|sc_eax
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|int2f_43
argument_list|(
name|sc
argument_list|)
condition|)
block|{
comment|/* Skip over int 2f:43 */
goto|goto
name|out
goto|;
block|}
break|break;
block|}
break|break;
block|}
name|fake_int
argument_list|(
name|sc
argument_list|,
name|intnum
argument_list|)
expr_stmt|;
break|break;
case|case
name|VM86_UNKNOWN
case|:
comment|/*XXXXX failed vector also gets here without IP adjust*/
name|addr
operator|=
operator|(
name|u_char
operator|*
operator|)
name|MAKEPTR
argument_list|(
name|sc
operator|->
name|sc_cs
argument_list|,
name|sc
operator|->
name|sc_eip
argument_list|)
expr_stmt|;
name|rep
operator|=
literal|1
expr_stmt|;
name|debug
argument_list|(
name|D_TRAPS2
argument_list|,
literal|"%04x:%04x [%02x]"
argument_list|,
name|GET16
argument_list|(
name|sc
operator|->
name|sc_cs
argument_list|)
argument_list|,
name|GET16
argument_list|(
name|sc
operator|->
name|sc_eip
argument_list|)
argument_list|,
name|addr
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|addr
index|[
literal|0
index|]
condition|)
block|{
case|case
name|TRACETRAP
case|:
name|ipadvance
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fake_int
argument_list|(
name|sc
argument_list|,
literal|3
argument_list|)
expr_stmt|;
break|break;
case|case
name|INd
case|:
name|port
operator|=
name|addr
index|[
literal|1
index|]
expr_stmt|;
name|ipadvance
argument_list|(
name|sc
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|inb
argument_list|(
name|sc
argument_list|,
name|port
argument_list|)
expr_stmt|;
break|break;
case|case
name|OUTd
case|:
name|port
operator|=
name|addr
index|[
literal|1
index|]
expr_stmt|;
name|ipadvance
argument_list|(
name|sc
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
argument_list|,
name|port
argument_list|)
expr_stmt|;
break|break;
case|case
name|INdX
case|:
name|port
operator|=
name|addr
index|[
literal|1
index|]
expr_stmt|;
name|ipadvance
argument_list|(
name|sc
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|inx
argument_list|(
name|sc
argument_list|,
name|port
argument_list|)
expr_stmt|;
break|break;
case|case
name|OUTdX
case|:
name|port
operator|=
name|addr
index|[
literal|1
index|]
expr_stmt|;
name|ipadvance
argument_list|(
name|sc
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|outx
argument_list|(
name|sc
argument_list|,
name|port
argument_list|)
expr_stmt|;
break|break;
case|case
name|IN
case|:
name|ipadvance
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|inb
argument_list|(
name|sc
argument_list|,
name|GET16
argument_list|(
name|sc
operator|->
name|sc_edx
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|INX
case|:
name|ipadvance
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|inx
argument_list|(
name|sc
argument_list|,
name|GET16
argument_list|(
name|sc
operator|->
name|sc_edx
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|OUT
case|:
name|ipadvance
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
argument_list|,
name|GET16
argument_list|(
name|sc
operator|->
name|sc_edx
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|OUTX
case|:
name|ipadvance
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|outx
argument_list|(
name|sc
argument_list|,
name|GET16
argument_list|(
name|sc
operator|->
name|sc_edx
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|OUTSB
case|:
name|ipadvance
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|rep
operator|--
operator|>
literal|0
condition|)
name|outsb
argument_list|(
name|sc
argument_list|,
name|GET16
argument_list|(
name|sc
operator|->
name|sc_edx
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|OUTSW
case|:
name|ipadvance
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|rep
operator|--
operator|>
literal|0
condition|)
name|outsx
argument_list|(
name|sc
argument_list|,
name|GET16
argument_list|(
name|sc
operator|->
name|sc_edx
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|INSB
case|:
name|ipadvance
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|rep
operator|--
operator|>
literal|0
condition|)
name|insb
argument_list|(
name|sc
argument_list|,
name|GET16
argument_list|(
name|sc
operator|->
name|sc_edx
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|INSW
case|:
name|ipadvance
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|rep
operator|--
operator|>
literal|0
condition|)
name|insx
argument_list|(
name|sc
argument_list|,
name|GET16
argument_list|(
name|sc
operator|->
name|sc_edx
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOCK
case|:
name|debug
argument_list|(
name|D_TRAPS2
argument_list|,
literal|"lock\n"
argument_list|)
expr_stmt|;
name|ipadvance
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|HLT
case|:
comment|/* BIOS entry points populated with HLT */
name|func
operator|=
name|find_callback
argument_list|(
name|GETVEC
argument_list|(
name|sc
operator|->
name|sc_cs
argument_list|,
name|sc
operator|->
name|sc_eip
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|func
condition|)
block|{
name|ipadvance
argument_list|(
name|sc
argument_list|,)
expr_stmt|;
name|SET16
argument_list|(
name|sc
operator|->
name|sc_eip
argument_list|,
name|GET16
argument_list|(
name|sc
operator|->
name|sc_eip
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|func
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|dump_regs
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|fatal
argument_list|(
literal|"unsupported instruction\n"
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|dump_regs
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"code = %04x\n"
argument_list|,
name|sf
operator|->
name|sf_code
argument_list|)
expr_stmt|;
name|fatal
argument_list|(
literal|"unrecognized vm86 trap\n"
argument_list|)
expr_stmt|;
block|}
name|out
label|:
if|if
condition|(
name|tmode
condition|)
name|tracetrap
argument_list|(
name|sc
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|sc
undef|#
directive|undef
name|ipadvance
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* USE_VM86 */
end_comment

begin_comment
comment|/* entry from FreeBSD, BSD/OS vm86 */
end_comment

begin_function
name|void
name|sigbus
parameter_list|(
name|struct
name|sigframe
modifier|*
name|sf
parameter_list|)
block|{
name|u_char
modifier|*
name|addr
decl_stmt|;
name|int
name|tempflags
decl_stmt|,
name|okflags
decl_stmt|;
name|int
name|intnum
decl_stmt|;
name|int
name|port
decl_stmt|;
name|callback_t
name|func
decl_stmt|;
name|regcontext_t
modifier|*
name|REGS
init|=
operator|(
name|regcontext_t
operator|*
operator|)
operator|(
operator|&
name|sf
operator|->
name|sf_uc
operator|.
name|uc_mcontext
operator|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|R_EFLAGS
operator|&&
name|PSL_VM
operator|)
condition|)
name|fatal
argument_list|(
literal|"SIGBUS in the emulator\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|sf
operator|->
name|sf_siginfo
operator|!=
literal|0
condition|)
block|{
name|fatal
argument_list|(
literal|"SIGBUS code %d, trapno: %d, err: %d\n"
argument_list|,
operator|(
name|int
operator|)
name|sf
operator|->
name|sf_siginfo
argument_list|,
name|sf
operator|->
name|sf_uc
operator|.
name|uc_mcontext
operator|.
name|mc_trapno
argument_list|,
name|sf
operator|->
name|sf_uc
operator|.
name|uc_mcontext
operator|.
name|mc_err
argument_list|)
expr_stmt|;
block|}
name|addr
operator|=
operator|(
name|u_char
operator|*
operator|)
name|MAKEPTR
argument_list|(
name|R_CS
argument_list|,
name|R_IP
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmode
condition|)
name|resettrace
argument_list|(
name|REGS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|R_EFLAGS
operator|&
operator|(
name|PSL_VIP
operator||
name|PSL_VIF
operator|)
operator|)
operator|==
operator|(
name|PSL_VIP
operator||
name|PSL_VIF
operator|)
condition|)
block|{
if|if
condition|(
name|n_pending
operator|<
literal|1
condition|)
block|{
name|fatal
argument_list|(
literal|"Pending interrupts out of sync\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|resume_interrupt
argument_list|()
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/*    printf("%p\n", addr); fflush(stdout); */
name|debug
argument_list|(
name|D_TRAPS2
argument_list|,
literal|"%04x:%04x [%02x %02x %02x] "
argument_list|,
name|R_CS
argument_list|,
name|R_IP
argument_list|,
operator|(
name|int
operator|)
name|addr
index|[
literal|0
index|]
argument_list|,
operator|(
name|int
operator|)
name|addr
index|[
literal|1
index|]
argument_list|,
operator|(
name|int
operator|)
name|addr
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if ((int)addr[0] == 0x67) {         int i;         printf("HERE\n"); fflush(stdout);         printf("addr: %p\n", REGS); fflush(stdout);         for (i = 0; i< 21 * 4; i++) {             printf("%d: %x\n", i, ((u_char *)REGS)[i]);             fflush(stdout);         }         printf("Trapno, error: %p %p\n", REGS->sc.sc_trapno, REGS->sc.sc_err);         fflush(stdout);         dump_regs(REGS);     }
endif|#
directive|endif
switch|switch
condition|(
name|addr
index|[
literal|0
index|]
condition|)
block|{
comment|/* what was that again dear? */
case|case
name|CLI
case|:
name|debug
argument_list|(
name|D_TRAPS2
argument_list|,
literal|"cli\n"
argument_list|)
expr_stmt|;
name|R_IP
operator|++
expr_stmt|;
name|R_EFLAGS
operator|&=
operator|~
name|PSL_VIP
expr_stmt|;
break|break;
case|case
name|STI
case|:
name|debug
argument_list|(
name|D_TRAPS2
argument_list|,
literal|"sti\n"
argument_list|)
expr_stmt|;
name|R_IP
operator|++
expr_stmt|;
name|R_EFLAGS
operator||=
name|PSL_VIP
expr_stmt|;
if|#
directive|if
literal|0
block|if (update_counter++> BUSY_UPDATES) 		sigalrm(sf);
endif|#
directive|endif
break|break;
case|case
name|PUSHF
case|:
name|debug
argument_list|(
name|D_TRAPS2
argument_list|,
literal|"pushf<- 0x%x\n"
argument_list|,
name|R_EFLAGS
argument_list|)
expr_stmt|;
name|R_IP
operator|++
expr_stmt|;
name|PUSH
argument_list|(
operator|(
name|R_FLAGS
operator|&
operator|~
name|PSL_I
operator|)
operator||
operator|(
name|R_EFLAGS
operator|&
name|PSL_VIF
condition|?
name|PSL_I
else|:
literal|0
operator|)
argument_list|,
name|REGS
argument_list|)
expr_stmt|;
break|break;
case|case
name|IRET
case|:
name|R_IP
operator|=
name|POP
argument_list|(
name|REGS
argument_list|)
expr_stmt|;
comment|/* get new cs:ip off the stack */
name|R_CS
operator|=
name|POP
argument_list|(
name|REGS
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|D_TRAPS2
argument_list|,
literal|"iret to %04x:%04x "
argument_list|,
name|R_CS
argument_list|,
name|R_IP
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
comment|/* 'safe' flag pop operation */
case|case
name|POPF
case|:
comment|/* XXX */
name|fatal
argument_list|(
literal|"popf/iret in emulator"
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
index|[
literal|0
index|]
operator|==
name|POPF
condition|)
name|R_IP
operator|++
expr_stmt|;
comment|/* get flags from stack */
name|tempflags
operator|=
name|POP
argument_list|(
name|REGS
argument_list|)
expr_stmt|;
comment|/* flags we consider OK */
name|okflags
operator|=
operator|(
name|PSL_ALLCC
operator||
name|PSL_T
operator||
name|PSL_D
operator||
name|PSL_V
operator|)
expr_stmt|;
comment|/* keep state of non-OK flags */
name|R_FLAGS
operator|=
operator|(
operator|(
name|R_FLAGS
operator|&
operator|~
name|okflags
operator|)
operator||
comment|/* pop state of OK flags */
operator|(
name|tempflags
operator|&
name|okflags
operator|)
operator|)
expr_stmt|;
comment|/* restore pseudo PSL_I flag */
name|IntState
operator|=
name|tempflags
operator|&
name|PSL_I
expr_stmt|;
name|debug
argument_list|(
name|D_TRAPS2
argument_list|,
literal|"popf -> 0x%x\n"
argument_list|,
name|R_EFLAGS
argument_list|)
expr_stmt|;
break|break;
case|case
name|TRACETRAP
case|:
name|debug
argument_list|(
name|D_TRAPS2
argument_list|,
literal|"ttrap\n"
argument_list|)
expr_stmt|;
name|R_IP
operator|++
expr_stmt|;
name|fake_int
argument_list|(
name|REGS
argument_list|,
literal|3
argument_list|)
expr_stmt|;
break|break;
case|case
name|INTn
case|:
name|intnum
operator|=
name|addr
index|[
literal|1
index|]
expr_stmt|;
name|R_IP
operator|+=
literal|2
expr_stmt|;
comment|/* nobody else will do it for us */
switch|switch
condition|(
name|intnum
condition|)
block|{
case|case
literal|0x2f
case|:
switch|switch
condition|(
name|R_AH
condition|)
block|{
comment|/* function number */
case|case
literal|0x11
case|:
name|debug
argument_list|(
name|D_TRAPS
operator||
literal|0x2f
argument_list|,
literal|"INT 2F:%04x\n"
argument_list|,
name|R_AX
argument_list|)
expr_stmt|;
if|if
condition|(
name|int2f_11
argument_list|(
name|REGS
argument_list|)
condition|)
block|{
comment|/* Skip over int 2f:11 */
goto|goto
name|out
goto|;
block|}
break|break;
case|case
literal|0x43
case|:
name|debug
argument_list|(
name|D_TRAPS
operator||
literal|0x2f
argument_list|,
literal|"INT 2F:%04x\n"
argument_list|,
name|R_AX
argument_list|)
expr_stmt|;
if|if
condition|(
name|int2f_43
argument_list|(
name|REGS
argument_list|)
condition|)
block|{
comment|/* Skip over int 2f:43 */
goto|goto
name|out
goto|;
block|}
break|break;
block|}
break|break;
block|}
name|fake_int
argument_list|(
name|REGS
argument_list|,
name|intnum
argument_list|)
expr_stmt|;
break|break;
case|case
name|INd
case|:
comment|/* XXX implement in/out */
name|R_IP
operator|+=
literal|2
expr_stmt|;
name|port
operator|=
name|addr
index|[
literal|1
index|]
expr_stmt|;
name|inb
argument_list|(
name|REGS
argument_list|,
name|port
argument_list|)
expr_stmt|;
break|break;
case|case
name|IN
case|:
name|R_IP
operator|++
expr_stmt|;
name|inb
argument_list|(
name|REGS
argument_list|,
name|R_DX
argument_list|)
expr_stmt|;
break|break;
case|case
name|INX
case|:
name|R_IP
operator|++
expr_stmt|;
name|inx
argument_list|(
name|REGS
argument_list|,
name|R_DX
argument_list|)
expr_stmt|;
break|break;
case|case
name|INdX
case|:
name|R_IP
operator|+=
literal|2
expr_stmt|;
name|port
operator|=
name|addr
index|[
literal|1
index|]
expr_stmt|;
name|inx
argument_list|(
name|REGS
argument_list|,
name|port
argument_list|)
expr_stmt|;
break|break;
case|case
name|INSB
case|:
name|R_IP
operator|++
expr_stmt|;
name|printf
argument_list|(
literal|"(missed) INSB<- 0x%02x\n"
argument_list|,
name|R_DX
argument_list|)
expr_stmt|;
break|break;
case|case
name|INSW
case|:
name|R_IP
operator|++
expr_stmt|;
name|printf
argument_list|(
literal|"(missed) INSW<- 0x%02x\n"
argument_list|,
name|R_DX
argument_list|)
expr_stmt|;
break|break;
case|case
name|OUTd
case|:
name|R_IP
operator|+=
literal|2
expr_stmt|;
name|port
operator|=
name|addr
index|[
literal|1
index|]
expr_stmt|;
name|outb
argument_list|(
name|REGS
argument_list|,
name|port
argument_list|)
expr_stmt|;
break|break;
case|case
name|OUTdX
case|:
name|R_IP
operator|+=
literal|2
expr_stmt|;
name|port
operator|=
name|addr
index|[
literal|1
index|]
expr_stmt|;
name|outx
argument_list|(
name|REGS
argument_list|,
name|port
argument_list|)
expr_stmt|;
break|break;
case|case
name|OUT
case|:
name|R_IP
operator|++
expr_stmt|;
name|outb
argument_list|(
name|REGS
argument_list|,
name|R_DX
argument_list|)
expr_stmt|;
break|break;
case|case
name|OUTX
case|:
name|R_IP
operator|++
expr_stmt|;
name|outx
argument_list|(
name|REGS
argument_list|,
name|R_DX
argument_list|)
expr_stmt|;
break|break;
case|case
name|OUTSB
case|:
name|R_IP
operator|++
expr_stmt|;
name|printf
argument_list|(
literal|"(missed) OUTSB -> 0x%02x\n"
argument_list|,
name|R_DX
argument_list|)
expr_stmt|;
break|break;
case|case
name|OUTSW
case|:
name|R_IP
operator|++
expr_stmt|;
name|printf
argument_list|(
literal|"(missed) OUTSW -> 0x%02x\n"
argument_list|,
name|R_DX
argument_list|)
expr_stmt|;
comment|/* tmode = 1; */
break|break;
case|case
name|LOCK
case|:
name|debug
argument_list|(
name|D_TRAPS2
argument_list|,
literal|"lock\n"
argument_list|)
expr_stmt|;
name|R_IP
operator|++
expr_stmt|;
break|break;
case|case
name|HLT
case|:
comment|/* BIOS entry points populated with HLT */
name|func
operator|=
name|find_callback
argument_list|(
name|MAKEVEC
argument_list|(
name|R_CS
argument_list|,
name|R_IP
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|func
condition|)
block|{
name|R_IP
operator|++
expr_stmt|;
comment|/* pass HLT opcode */
name|func
argument_list|(
name|REGS
argument_list|)
expr_stmt|;
comment|/*		dump_regs(REGS); */
if|#
directive|if
literal|0
block|update_counter += 5; 		if (update_counter> BUSY_UPDATES) 		    sigalrm(sf);
endif|#
directive|endif
break|break;
block|}
comment|/*            if (R_EFLAGS& PSL_VIF) { */
name|R_IP
operator|++
expr_stmt|;
name|tty_pause
argument_list|()
expr_stmt|;
goto|goto
name|out
goto|;
comment|/*            } */
comment|/* FALLTHRU */
default|default:
name|dump_regs
argument_list|(
name|REGS
argument_list|)
expr_stmt|;
name|fatal
argument_list|(
literal|"unsupported instruction\n"
argument_list|)
expr_stmt|;
block|}
name|out
label|:
if|if
condition|(
name|tmode
condition|)
name|tracetrap
argument_list|(
name|REGS
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_VM86 */
end_comment

begin_function
name|void
name|sigtrace
parameter_list|(
name|struct
name|sigframe
modifier|*
name|sf
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
name|regcontext_t
modifier|*
name|REGS
init|=
operator|(
name|regcontext_t
operator|*
operator|)
operator|(
operator|&
name|sf
operator|->
name|sf_uc
operator|.
name|uc_mcontext
operator|)
decl_stmt|;
if|if
condition|(
name|R_EFLAGS
operator|&
name|PSL_VM
condition|)
block|{
name|debug
argument_list|(
name|D_ALWAYS
argument_list|,
literal|"Currently in DOS\n"
argument_list|)
expr_stmt|;
name|dump_regs
argument_list|(
name|REGS
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
literal|16
condition|;
operator|++
name|x
control|)
name|debug
argument_list|(
name|D_ALWAYS
argument_list|,
literal|" %02x"
argument_list|,
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|)
name|x
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|debugf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|debug
argument_list|(
name|D_ALWAYS
argument_list|,
literal|"Currently in the emulator\n"
argument_list|)
expr_stmt|;
name|sigalrm
argument_list|(
name|sf
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|sigtrap
parameter_list|(
name|struct
name|sigframe
modifier|*
name|sf
parameter_list|)
block|{
name|int
name|intnum
decl_stmt|;
name|int
name|trapno
decl_stmt|;
name|regcontext_t
modifier|*
name|REGS
init|=
operator|(
name|regcontext_t
operator|*
operator|)
operator|(
operator|&
name|sf
operator|->
name|sf_uc
operator|.
name|uc_mcontext
operator|)
decl_stmt|;
if|if
condition|(
operator|(
name|R_EFLAGS
operator|&
name|PSL_VM
operator|)
operator|==
literal|0
condition|)
block|{
name|dump_regs
argument_list|(
name|REGS
argument_list|)
expr_stmt|;
name|fatal
argument_list|(
literal|"%04x:%08x Sigtrap in protected mode\n"
argument_list|,
name|R_CS
argument_list|,
name|R_IP
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tmode
condition|)
if|if
condition|(
name|resettrace
argument_list|(
name|REGS
argument_list|)
condition|)
goto|goto
name|doh
goto|;
ifdef|#
directive|ifdef
name|__FreeBSD__
name|trapno
operator|=
operator|(
name|int
operator|)
name|sf
operator|->
name|sf_siginfo
expr_stmt|;
comment|/* XXX GROSTIC HACK ALERT */
else|#
directive|else
name|trapno
operator|=
name|sc
operator|->
name|sc_trapno
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|trapno
operator|==
name|T_BPTFLT
condition|)
name|intnum
operator|=
literal|3
expr_stmt|;
else|else
name|intnum
operator|=
literal|1
expr_stmt|;
name|PUSH
argument_list|(
operator|(
name|R_FLAGS
operator|&
operator|~
name|PSL_I
operator|)
operator||
operator|(
name|R_EFLAGS
operator|&
name|PSL_VIF
condition|?
name|PSL_I
else|:
literal|0
operator|)
argument_list|,
name|REGS
argument_list|)
expr_stmt|;
name|PUSH
argument_list|(
name|R_CS
argument_list|,
name|REGS
argument_list|)
expr_stmt|;
name|PUSH
argument_list|(
name|R_IP
argument_list|,
name|REGS
argument_list|)
expr_stmt|;
name|R_FLAGS
operator|&=
operator|~
name|PSL_T
expr_stmt|;
name|PUTVEC
argument_list|(
name|R_CS
argument_list|,
name|R_IP
argument_list|,
name|ivec
index|[
name|intnum
index|]
argument_list|)
expr_stmt|;
name|doh
label|:
if|if
condition|(
name|tmode
condition|)
name|tracetrap
argument_list|(
name|REGS
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|breakpoint
parameter_list|(
name|struct
name|sigframe
modifier|*
name|sf
parameter_list|)
block|{
name|regcontext_t
modifier|*
name|REGS
init|=
operator|(
name|regcontext_t
operator|*
operator|)
operator|(
operator|&
name|sf
operator|->
name|sf_uc
operator|.
name|uc_mcontext
operator|)
decl_stmt|;
if|if
condition|(
name|R_EFLAGS
operator|&
name|PSL_VM
condition|)
name|printf
argument_list|(
literal|"doscmd "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"breakpoint: %04x\n"
argument_list|,
operator|*
operator|(
name|u_short
operator|*
operator|)
literal|0x8e64
argument_list|)
expr_stmt|;
asm|__asm__
specifier|volatile
asm|("mov 0, %eax");
asm|__asm__
specifier|volatile
asm|(".byte 0x0f");
comment|/* MOV DR6,EAX */
asm|__asm__
specifier|volatile
asm|(".byte 0x21");
asm|__asm__
specifier|volatile
asm|(".byte 0x1b");
block|}
end_function

begin_comment
comment|/* ** periodic updates */
end_comment

begin_function
name|void
name|sigalrm
parameter_list|(
name|struct
name|sigframe
modifier|*
name|sf
parameter_list|)
block|{
name|regcontext_t
modifier|*
name|REGS
init|=
operator|(
name|regcontext_t
operator|*
operator|)
operator|(
operator|&
name|sf
operator|->
name|sf_uc
operator|.
name|uc_mcontext
operator|)
decl_stmt|;
if|if
condition|(
name|tmode
condition|)
name|resettrace
argument_list|(
name|REGS
argument_list|)
expr_stmt|;
comment|/*     debug(D_ALWAYS,"tick %d", update_counter); */
name|update_counter
operator|=
literal|0
expr_stmt|;
comment|/* remember we've updated */
name|video_update
argument_list|(
operator|&
name|REGS
operator|->
name|sc
argument_list|)
expr_stmt|;
name|hardint
argument_list|(
literal|0x08
argument_list|)
expr_stmt|;
comment|/*    debug(D_ALWAYS,"\n"); */
if|if
condition|(
name|tmode
condition|)
name|tracetrap
argument_list|(
name|REGS
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sigill
parameter_list|(
name|struct
name|sigframe
modifier|*
name|sf
parameter_list|)
block|{
name|regcontext_t
modifier|*
name|REGS
init|=
operator|(
name|regcontext_t
operator|*
operator|)
operator|(
operator|&
name|sf
operator|->
name|sf_uc
operator|.
name|uc_mcontext
operator|)
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Signal %d from DOS program\n"
argument_list|,
name|sf
operator|->
name|sf_signum
argument_list|)
expr_stmt|;
name|dump_regs
argument_list|(
name|REGS
argument_list|)
expr_stmt|;
name|fatal
argument_list|(
literal|"%04x:%04x Illegal instruction\n"
argument_list|,
name|R_CS
argument_list|,
name|R_IP
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sigfpe
parameter_list|(
name|struct
name|sigframe
modifier|*
name|sf
parameter_list|)
block|{
name|regcontext_t
modifier|*
name|REGS
init|=
operator|(
name|regcontext_t
operator|*
operator|)
operator|(
operator|&
name|sf
operator|->
name|sf_uc
operator|.
name|uc_mcontext
operator|)
decl_stmt|;
if|if
condition|(
name|R_EFLAGS
operator|&
name|PSL_VM
condition|)
block|{
name|dump_regs
argument_list|(
name|REGS
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|D_ALWAYS
argument_list|,
literal|"DOS program caused floating point fault\n"
argument_list|)
expr_stmt|;
comment|/*XXX Look into that !! */
name|fake_int
argument_list|(
name|REGS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* call handler XXX rather bogus, eh? */
return|return;
block|}
name|dump_regs
argument_list|(
name|REGS
argument_list|)
expr_stmt|;
name|fatal
argument_list|(
literal|"%04x:%04x Floating point fault in emulator.\n"
argument_list|,
name|R_CS
argument_list|,
name|R_IP
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

