begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1992, 1993, 1996  *	Berkeley Software Design, Inc.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by Berkeley Software  *	Design, Inc.  *  * THIS SOFTWARE IS PROVIDED BY Berkeley Software Design, Inc. ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL Berkeley Software Design, Inc. BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	BSDI doscmd.c,v 2.3 1996/04/08 19:32:30 bostic Exp  *  * $Id: doscmd.c,v 1.2 1997/08/15 23:41:23 jlemon Exp $  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<machine/param.h>
end_include

begin_include
include|#
directive|include
file|<machine/vmparam.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<machine/sysarch.h>
end_include

begin_include
include|#
directive|include
file|<machine/vm86.h>
end_include

begin_include
include|#
directive|include
file|"doscmd.h"
end_include

begin_comment
comment|/* exports */
end_comment

begin_decl_stmt
name|int
name|capture_fd
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dead
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|xmode
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|booting
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|raw_kbd
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|timer_disable
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|timeval
name|boot_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|long
modifier|*
name|ivec
init|=
operator|(
name|unsigned
name|long
operator|*
operator|)
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_long
name|pending
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pending interrupts */
end_comment

begin_decl_stmt
name|int
name|n_pending
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|USE_VM86
end_ifndef

begin_define
define|#
directive|define
name|PRB_V86_FORMAT
value|0x4242
end_define

begin_decl_stmt
name|struct
name|vconnect_area
name|vconnect_area
init|=
block|{
literal|0
block|,
comment|/* Interrupt state */
name|PRB_V86_FORMAT
block|,
comment|/* Magic number */
block|{
literal|0
block|, }
block|,
comment|/* Pass through ints */
block|{
literal|0x00000000
block|,
literal|0x00000000
block|}
comment|/* Magic iret location */
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* local prototypes */
end_comment

begin_function_decl
specifier|static
name|void
name|setup_boot
parameter_list|(
name|regcontext_t
modifier|*
name|REGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|setup_command
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|,
name|regcontext_t
modifier|*
name|REGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|FILE
modifier|*
name|find_doscmdrc
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|do_args
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|open_name
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|char
modifier|*
name|ext
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|init_iomap
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Local option flags&c. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|zflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* DOS environment emulation */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ecnt
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|envs
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Search path and command name */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|dos_path
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|cmdname
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* referenced from dos.c */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|i386_vm86_args
name|vm86
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|vm86_init_args
name|kargs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* lobotomise */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|USE_VM86
name|struct
name|sigcontext
name|sc
decl_stmt|;
else|#
directive|else
name|struct
name|vm86_struct
name|vm86s
decl_stmt|;
define|#
directive|define
name|sc
value|vm86s.substr.regs.vmsc
endif|#
directive|endif
name|regcontext_t
modifier|*
name|REGS
init|=
operator|(
name|regcontext_t
operator|*
operator|)
operator|&
name|sc
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
name|buffer
index|[
literal|4096
index|]
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
comment|/* XXX should only be for tty mode */
name|fd
operator|=
name|open
argument_list|(
literal|"/dev/null"
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|!=
literal|3
condition|)
name|dup2
argument_list|(
name|fd
argument_list|,
literal|3
argument_list|)
expr_stmt|;
comment|/* stdaux */
if|if
condition|(
name|fd
operator|!=
literal|4
condition|)
name|dup2
argument_list|(
name|fd
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* stdprt */
if|if
condition|(
name|fd
operator|!=
literal|3
operator|&&
name|fd
operator|!=
literal|4
condition|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
name|debug_set
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* debug any D_TRAPS without intnum */
comment|/* perform option argument processing */
name|optind
operator|=
name|do_args
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|vflag
operator|&&
name|debugf
operator|==
name|stderr
condition|)
block|{
name|debugf
operator|=
name|stdout
expr_stmt|;
name|setbuf
argument_list|(
name|stdout
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|initHMA
argument_list|()
expr_stmt|;
comment|/* This needs to happen before the executable is loaded */
name|mem_init
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_VM86
name|memset
argument_list|(
operator|&
name|vm86s
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|vm86s
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*      * With no other arguments we will assume we must boot DOS      */
if|if
condition|(
name|argc
operator|<=
literal|0
condition|)
name|booting
operator|=
literal|1
expr_stmt|;
if|#
directive|if
literal|1
comment|/*      * Nominate interrupts to handle here when the kernel is       * performing interrupt handling.      *      * I would like to let INT 2F pass through as well, but I      * need to get my hands on INT 2F:11 to do file redirection.      */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
literal|0xff
condition|;
operator|++
name|i
control|)
block|{
switch|switch
condition|(
name|i
condition|)
block|{
case|case
literal|0x2f
case|:
case|case
literal|0xff
case|:
if|#
directive|if
literal|1
name|kargs
operator|.
name|int_map
index|[
name|i
operator|>>
literal|3
index|]
operator||=
operator|(
literal|1
operator|<<
operator|(
name|i
operator|&
literal|7
operator|)
operator|)
expr_stmt|;
ifndef|#
directive|ifndef
name|USE_VM86
name|vconnect_area
operator|.
name|passthru
index|[
name|i
operator|>>
literal|5
index|]
operator|&=
operator|~
operator|(
literal|1
operator|<<
operator|(
name|i
operator|&
literal|0x1f
operator|)
operator|)
expr_stmt|;
else|#
directive|else
name|vm86s
operator|.
name|int_byuser
index|[
name|i
operator|>>
literal|3
index|]
operator||=
operator|(
literal|1
operator|<<
operator|(
name|i
operator|&
literal|0x07
operator|)
operator|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
break|break;
default|default:
if|#
directive|if
literal|1
name|kargs
operator|.
name|int_map
index|[
name|i
operator|>>
literal|3
index|]
operator|&=
operator|~
operator|(
literal|1
operator|<<
operator|(
name|i
operator|&
literal|7
operator|)
operator|)
expr_stmt|;
ifndef|#
directive|ifndef
name|USE_VM86
name|vconnect_area
operator|.
name|passthru
index|[
name|i
operator|>>
literal|5
index|]
operator||=
operator|(
literal|1
operator|<<
operator|(
name|i
operator|&
literal|0x1f
operator|)
operator|)
expr_stmt|;
else|#
directive|else
name|vm86s
operator|.
name|int_byuser
index|[
name|i
operator|>>
literal|3
index|]
operator||=
operator|(
literal|1
operator|<<
operator|(
name|i
operator|&
literal|0x07
operator|)
operator|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
break|break;
block|}
block|}
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
name|pending
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|n_pending
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|booting
condition|)
block|{
comment|/* are we booting? */
name|setup_boot
argument_list|(
name|REGS
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* no, load a command */
name|setup_command
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|REGS
argument_list|)
expr_stmt|;
block|}
comment|/* install signal handlers */
name|setsignal
argument_list|(
name|SIGFPE
argument_list|,
name|sigfpe
argument_list|)
expr_stmt|;
comment|/* */
name|setsignal
argument_list|(
name|SIGALRM
argument_list|,
name|sigalrm
argument_list|)
expr_stmt|;
comment|/* */
name|setsignal
argument_list|(
name|SIGILL
argument_list|,
name|sigill
argument_list|)
expr_stmt|;
comment|/* */
name|setsignal
argument_list|(
name|SIGTRAP
argument_list|,
name|sigtrap
argument_list|)
expr_stmt|;
comment|/* */
name|setsignal
argument_list|(
name|SIGUSR2
argument_list|,
name|sigtrace
argument_list|)
expr_stmt|;
comment|/* */
name|setsignal
argument_list|(
name|SIGINFO
argument_list|,
name|sigtrace
argument_list|)
expr_stmt|;
comment|/* */
ifdef|#
directive|ifdef
name|USE_VM86
name|setsignal
argument_list|(
name|SIGURG
argument_list|,
name|sigurg
argument_list|)
expr_stmt|;
comment|/* entry from NetBSD vm86 */
else|#
directive|else
name|setsignal
argument_list|(
name|SIGBUS
argument_list|,
name|sigbus
argument_list|)
expr_stmt|;
comment|/* entry from FreeBSD, BSD/OS vm86 */
endif|#
directive|endif
comment|/* Call init functions */
if|if
condition|(
name|raw_kbd
condition|)
name|console_init
argument_list|()
expr_stmt|;
name|init_io_port_handlers
argument_list|()
expr_stmt|;
name|bios_init
argument_list|()
expr_stmt|;
name|cpu_init
argument_list|()
expr_stmt|;
name|video_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|xmode
condition|)
name|mouse_init
argument_list|()
expr_stmt|;
name|video_bios_init
argument_list|()
expr_stmt|;
name|disk_bios_init
argument_list|()
expr_stmt|;
name|cmos_init
argument_list|()
expr_stmt|;
name|xms_init
argument_list|()
expr_stmt|;
name|dos_init
argument_list|()
expr_stmt|;
name|net_init
argument_list|()
expr_stmt|;
name|speaker_init
argument_list|()
expr_stmt|;
name|timer_init
argument_list|()
expr_stmt|;
comment|/* iomap_init(); */
name|gettimeofday
argument_list|(
operator|&
name|boot_time
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|zflag
condition|)
for|for
control|(
init|;
condition|;
control|)
name|pause
argument_list|()
expr_stmt|;
comment|/* spin if requested */
if|if
condition|(
name|raw_kbd
condition|)
block|{
comment|/* 	 * If we have a raw keyboard, and hence, video, 	 * sneak in a call to the video BIOS to reinit the 	 * the video display. 	 */
name|u_long
name|video_vector
decl_stmt|;
specifier|static
name|u_char
name|video_trampoline
index|[]
init|=
block|{
literal|0x60
block|,
comment|/* pusha */
literal|0xB8
block|,
literal|0x03
block|,
literal|0x00
block|,
comment|/* mov ax,00003h */
literal|0xCD
block|,
literal|0x10
block|,
comment|/* int 010h */
literal|0x61
block|,
comment|/* popa */
literal|0xCF
block|,
comment|/* iret */
block|}
decl_stmt|;
name|video_vector
operator|=
name|insert_generic_trampoline
argument_list|(
sizeof|sizeof
argument_list|(
name|video_trampoline
argument_list|)
argument_list|,
name|video_trampoline
argument_list|)
expr_stmt|;
name|N_PUSH
argument_list|(
name|R_FLAGS
argument_list|,
name|REGS
argument_list|)
expr_stmt|;
name|N_PUSH
argument_list|(
name|R_CS
argument_list|,
name|REGS
argument_list|)
expr_stmt|;
name|N_PUSH
argument_list|(
name|R_IP
argument_list|,
name|REGS
argument_list|)
expr_stmt|;
name|N_PUTVEC
argument_list|(
name|R_CS
argument_list|,
name|R_IP
argument_list|,
name|video_vector
argument_list|)
expr_stmt|;
block|}
name|sc
operator|.
name|sc_mask
operator|=
literal|0
expr_stmt|;
name|sc
operator|.
name|sc_onstack
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tmode
condition|)
name|tracetrap
argument_list|(
name|REGS
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|USE_VM86
name|R_EAX
operator|=
operator|(
name|booting
operator|||
name|raw_kbd
operator|)
condition|?
operator|(
name|int
operator|)
operator|&
name|vconnect_area
else|:
operator|-
literal|1
expr_stmt|;
name|R_EFLAGS
operator||=
name|PSL_VM
operator||
name|PSL_VIF
expr_stmt|;
comment|/* request VM86 mode */
name|vm86
operator|.
name|sub_op
operator|=
name|VM86_INIT
expr_stmt|;
name|vm86
operator|.
name|sub_args
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|kargs
expr_stmt|;
name|i
operator|=
name|sysarch
argument_list|(
name|I386_VM86
argument_list|,
operator|&
name|vm86
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Init: %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|sigreturn
argument_list|(
operator|&
name|sc
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|D_ALWAYS
argument_list|,
literal|"sigreturn failed : %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|vm86s
operator|.
name|cpu_type
operator|=
name|VCPU_586
expr_stmt|;
name|i386_vm86
argument_list|(
operator|&
name|vm86s
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* shouldn't get here */
if|if
condition|(
name|vflag
condition|)
name|dump_regs
argument_list|(
operator|(
name|regcontext_t
operator|*
operator|)
operator|&
name|sc
argument_list|)
expr_stmt|;
name|fatal
argument_list|(
literal|"vm86 returned (no kernel support?)\n"
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|sc
block|}
end_function

begin_comment
comment|/* ** setup_boot ** ** Setup to boot DOS */
end_comment

begin_function
specifier|static
name|void
name|setup_boot
parameter_list|(
name|regcontext_t
modifier|*
name|REGS
parameter_list|)
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
comment|/* doscmdrc handle */
name|int
name|fd
decl_stmt|;
comment|/* don't close this! */
name|fp
operator|=
name|find_doscmdrc
argument_list|()
expr_stmt|;
comment|/* get doscmdrc */
if|if
condition|(
operator|!
name|fp
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"You must have a doscmdrc to boot\n"
argument_list|)
expr_stmt|;
name|quit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|booting
operator|=
name|read_config
argument_list|(
name|fp
argument_list|)
expr_stmt|;
comment|/* where to boot from? */
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|booting
operator|<
literal|0
condition|)
block|{
comment|/* not specified */
if|if
condition|(
operator|(
name|fd
operator|=
name|disk_fd
argument_list|(
name|booting
operator|=
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
comment|/* try A: */
name|fd
operator|=
name|disk_fd
argument_list|(
name|booting
operator|=
literal|2
argument_list|)
expr_stmt|;
comment|/* try C: */
block|}
else|else
block|{
name|fd
operator|=
name|disk_fd
argument_list|(
name|booting
argument_list|)
expr_stmt|;
comment|/* do like the man says */
block|}
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
comment|/* can we boot it? */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cannot boot from %c: (can't open)\n"
argument_list|,
name|booting
operator|+
literal|'A'
argument_list|)
expr_stmt|;
name|quit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* read bootblock */
if|if
condition|(
name|read
argument_list|(
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0x7c00
argument_list|,
literal|512
argument_list|)
operator|!=
literal|512
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Short read on boot block from %c:\n"
argument_list|,
name|booting
operator|+
literal|'A'
argument_list|)
expr_stmt|;
name|quit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* initialise registers for entry to bootblock */
name|R_EFLAGS
operator|=
literal|0x20202
expr_stmt|;
name|R_CS
operator|=
literal|0x0000
expr_stmt|;
name|R_IP
operator|=
literal|0x7c00
expr_stmt|;
name|R_SS
operator|=
literal|0x9800
expr_stmt|;
name|R_SP
operator|=
literal|0x8000
operator|-
literal|2
expr_stmt|;
name|R_DS
operator|=
literal|0x0000
expr_stmt|;
name|R_ES
operator|=
literal|0x0000
expr_stmt|;
name|R_AX
operator|=
name|R_BX
operator|=
name|R_CX
operator|=
name|R_DX
operator|=
name|R_SI
operator|=
name|R_DI
operator|=
name|R_BP
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
comment|/*     ** init a few other context registers      */
name|R_FS
operator|=
literal|0x0000
expr_stmt|;
name|R_GS
operator|=
literal|0x0000
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* ** setup_command ** ** Setup to run a single command and emulate DOS */
end_comment

begin_function
specifier|static
name|void
name|setup_command
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|,
name|regcontext_t
modifier|*
name|REGS
parameter_list|)
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|u_short
name|param
index|[
literal|7
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|prog
index|[
literal|1024
index|]
decl_stmt|;
name|char
name|buffer
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|fp
operator|=
name|find_doscmdrc
argument_list|()
expr_stmt|;
comment|/* dig up a doscmdrc */
if|if
condition|(
name|fp
condition|)
block|{
name|read_config
argument_list|(
name|fp
argument_list|)
expr_stmt|;
comment|/* load config for non-boot mode */
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|<=
literal|0
condition|)
comment|/* need some arguments */
name|usage
argument_list|()
expr_stmt|;
comment|/* look for a working directory  XXX ??? */
if|if
condition|(
name|dos_getcwd
argument_list|(
literal|'C'
operator|-
literal|'A'
argument_list|)
operator|==
name|NULL
condition|)
block|{
comment|/* try to get our current directory, use '/' if desperate */
name|p
operator|=
name|getcwd
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
operator|||
operator|!
operator|*
name|p
condition|)
name|p
operator|=
name|getenv
argument_list|(
literal|"PWD"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
operator|||
operator|!
operator|*
name|p
condition|)
name|p
operator|=
literal|"/"
expr_stmt|;
name|init_path
argument_list|(
literal|'C'
operator|-
literal|'A'
argument_list|,
operator|(
name|u_char
operator|*
operator|)
literal|"/"
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|p
argument_list|)
expr_stmt|;
comment|/* look for PATH= already set, learn from it if possible */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ecnt
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|envs
index|[
name|i
index|]
argument_list|,
literal|"PATH="
argument_list|,
literal|5
argument_list|)
condition|)
block|{
name|dos_path
operator|=
name|envs
index|[
name|i
index|]
operator|+
literal|5
expr_stmt|;
break|break;
block|}
block|}
comment|/* no PATH in DOS environment? put current directory there*/
if|if
condition|(
name|i
operator|>=
name|ecnt
condition|)
block|{
specifier|static
name|char
name|path
index|[
literal|256
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|path
argument_list|,
literal|"PATH=C:%s"
argument_list|,
name|dos_getcwd
argument_list|(
literal|'C'
operator|-
literal|'A'
argument_list|)
argument_list|)
expr_stmt|;
name|put_dosenv
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|dos_path
operator|=
name|envs
index|[
name|ecnt
operator|-
literal|1
index|]
operator|+
literal|5
expr_stmt|;
block|}
block|}
comment|/* add a COMSPEC if required */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ecnt
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|envs
index|[
name|i
index|]
argument_list|,
literal|"COMSPEC="
argument_list|,
literal|8
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|>=
name|ecnt
condition|)
name|put_dosenv
argument_list|(
literal|"COMSPEC=C:\\COMMAND.COM"
argument_list|)
expr_stmt|;
comment|/* look for PATH already set, learn from it if possible */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ecnt
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|envs
index|[
name|i
index|]
argument_list|,
literal|"PATH="
argument_list|,
literal|5
argument_list|)
condition|)
block|{
name|dos_path
operator|=
name|envs
index|[
name|i
index|]
operator|+
literal|5
expr_stmt|;
break|break;
block|}
block|}
comment|/* No PATH, default to c:\ */
if|if
condition|(
name|i
operator|>=
name|ecnt
condition|)
block|{
name|dos_path
operator|=
name|envs
index|[
name|ecnt
operator|-
literal|1
index|]
operator|+
literal|5
expr_stmt|;
name|put_dosenv
argument_list|(
literal|"PATH=C:\\"
argument_list|)
expr_stmt|;
block|}
comment|/* if no PROMPT, default to 'DOS>' */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ecnt
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|envs
index|[
name|i
index|]
argument_list|,
literal|"PROMPT="
argument_list|,
literal|7
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|>=
name|ecnt
condition|)
name|put_dosenv
argument_list|(
literal|"PROMPT=DOS> "
argument_list|)
expr_stmt|;
comment|/* terminate environment */
name|envs
index|[
name|ecnt
index|]
operator|=
literal|0
expr_stmt|;
comment|/* XXX ??? */
if|if
condition|(
name|dos_getcwd
argument_list|(
literal|'R'
operator|-
literal|'A'
argument_list|)
operator|==
name|NULL
condition|)
name|init_path
argument_list|(
literal|'R'
operator|-
literal|'A'
argument_list|,
operator|(
name|u_char
operator|*
operator|)
literal|"/"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* get program name */
name|strncpy
argument_list|(
name|prog
argument_list|,
operator|*
name|argv
operator|++
argument_list|,
sizeof|sizeof
argument_list|(
name|prog
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|prog
index|[
sizeof|sizeof
argument_list|(
name|prog
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* try to open program */
if|if
condition|(
operator|(
name|fd
operator|=
name|open_prog
argument_list|(
name|prog
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: command not found\n"
argument_list|,
name|prog
argument_list|)
expr_stmt|;
name|quit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* load program */
name|load_command
argument_list|(
name|REGS
argument_list|,
literal|1
argument_list|,
name|fd
argument_list|,
name|cmdname
argument_list|,
name|param
argument_list|,
name|argv
argument_list|,
name|envs
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** find_doscmdrc ** ** Try to find a doscmdrc file */
end_comment

begin_function
specifier|static
name|FILE
modifier|*
name|find_doscmdrc
parameter_list|(
name|void
parameter_list|)
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
name|buffer
index|[
literal|4096
index|]
decl_stmt|;
name|int
name|fd
decl_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
literal|".doscmdrc"
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|struct
name|passwd
modifier|*
name|pwd
init|=
name|getpwuid
argument_list|(
name|geteuid
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|pwd
condition|)
block|{
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%s/.doscmdrc"
argument_list|,
name|pwd
operator|->
name|pw_dir
argument_list|)
expr_stmt|;
name|fp
operator|=
name|fopen
argument_list|(
name|buffer
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|fp
condition|)
block|{
name|char
modifier|*
name|home
init|=
name|getenv
argument_list|(
literal|"HOME"
argument_list|)
decl_stmt|;
if|if
condition|(
name|home
condition|)
block|{
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%s/.doscmdrc"
argument_list|,
name|home
argument_list|)
expr_stmt|;
name|fp
operator|=
name|fopen
argument_list|(
name|buffer
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|fp
condition|)
name|fp
operator|=
name|fopen
argument_list|(
literal|"/etc/doscmdrc"
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|fp
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** do_args ** ** commandline argument processing */
end_comment

begin_function
specifier|static
name|int
name|do_args
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|c
decl_stmt|,
name|p
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
modifier|*
name|col
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"234Oc:TkCIEMPRLAU:S:HDtzvVxXYfbri:o:d:"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'d'
case|:
if|if
condition|(
name|fp
operator|=
name|fopen
argument_list|(
name|optarg
argument_list|,
literal|"w"
argument_list|)
condition|)
block|{
name|debugf
operator|=
name|fp
expr_stmt|;
name|setbuf
argument_list|(
name|fp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
name|perror
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'2'
case|:
name|debug_flags
operator||=
name|D_TRAPS2
expr_stmt|;
break|break;
case|case
literal|'3'
case|:
name|debug_flags
operator||=
name|D_TRAPS3
expr_stmt|;
break|break;
case|case
literal|'4'
case|:
name|debug_flags
operator||=
name|D_DEBUGIN
expr_stmt|;
break|break;
case|case
literal|'O'
case|:
name|debugf
operator|=
name|stdout
expr_stmt|;
name|setbuf
argument_list|(
name|stdout
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
if|if
condition|(
operator|(
name|capture_fd
operator|=
name|creat
argument_list|(
name|optarg
argument_list|,
literal|0666
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
name|quit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'i'
case|:
name|i
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|col
operator|=
name|strchr
argument_list|(
name|optarg
argument_list|,
literal|':'
argument_list|)
condition|)
block|{
operator|*
name|col
operator|++
operator|=
literal|0
expr_stmt|;
name|i
operator|=
name|strtol
argument_list|(
name|col
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|strtol
argument_list|(
name|optarg
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|--
operator|>
literal|0
condition|)
name|define_input_port_handler
argument_list|(
name|p
operator|++
argument_list|,
name|inb_traceport
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|i
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|col
operator|=
name|strchr
argument_list|(
name|optarg
argument_list|,
literal|':'
argument_list|)
condition|)
block|{
operator|*
name|col
operator|++
operator|=
literal|0
expr_stmt|;
name|i
operator|=
name|strtol
argument_list|(
name|col
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|strtol
argument_list|(
name|optarg
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|--
operator|>
literal|0
condition|)
name|define_output_port_handler
argument_list|(
name|p
operator|++
argument_list|,
name|outb_traceport
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|raw_kbd
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
name|debug_flags
operator||=
name|D_ITRAPS
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
literal|256
condition|;
operator|++
name|c
control|)
name|debug_set
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
name|kargs
operator|.
name|debug
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
name|timer_disable
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
name|debug_flags
operator||=
name|D_EXEC
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
name|debug_flags
operator||=
name|D_DOSCALL
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
name|debug_flags
operator||=
name|D_MEMORY
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
name|debug_flags
operator||=
name|D_PORT
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|debug_flags
operator||=
name|D_REDIR
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
name|debug_flags
operator||=
name|D_XMS
expr_stmt|;
break|break;
case|case
literal|'Y'
case|:
name|debug_flags
operator||=
name|D_EMS
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
name|debug_flags
operator||=
name|D_PRINTER
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
name|debug_flags
operator||=
name|D_TRAPS
operator||
name|D_ITRAPS
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
literal|256
condition|;
operator|++
name|c
control|)
name|debug_set
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'U'
case|:
name|debug_unset
argument_list|(
name|strtol
argument_list|(
name|optarg
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|debug_flags
operator||=
name|D_TRAPS
operator||
name|D_ITRAPS
expr_stmt|;
name|debug_set
argument_list|(
name|strtol
argument_list|(
name|optarg
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
name|debug_flags
operator||=
name|D_HALF
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
ifdef|#
directive|ifdef
name|NO_X
name|fatal
argument_list|(
literal|"X11 support not compiled in.\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|xmode
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|tmode
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'z'
case|:
name|zflag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|debug_flags
operator||=
name|D_DISK
operator||
name|D_FILE_OPS
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|debug_flags
operator||=
name|D_TRAPS
operator||
name|D_ITRAPS
operator||
name|D_HALF
operator||
literal|0xff
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
name|vflag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|booting
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|()
expr_stmt|;
block|}
block|}
return|return
operator|(
name|optind
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** Very helpful 8( */
end_comment

begin_function
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: doscmd cmd args...\n"
argument_list|)
expr_stmt|;
name|quit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** look up a DOS command name ** ** XXX ordering is wrong! */
end_comment

begin_function
specifier|static
name|int
name|open_name
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|char
modifier|*
name|ext
parameter_list|)
block|{
name|int
name|fd
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|name
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|char
modifier|*
name|q
decl_stmt|;
operator|*
name|ext
operator|=
literal|0
expr_stmt|;
name|q
operator|=
name|strrchr
argument_list|(
name|name
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
condition|)
name|q
operator|++
expr_stmt|;
else|else
name|q
operator|=
name|name
expr_stmt|;
if|if
condition|(
operator|!
name|strchr
argument_list|(
name|q
argument_list|,
literal|'.'
argument_list|)
condition|)
block|{
name|strcpy
argument_list|(
name|ext
argument_list|,
literal|".exe"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|p
argument_list|,
literal|".exe"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|name
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|>=
literal|0
condition|)
return|return
operator|(
name|fd
operator|)
return|;
name|strcpy
argument_list|(
name|ext
argument_list|,
literal|".com"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|p
argument_list|,
literal|".com"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|name
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|>=
literal|0
condition|)
return|return
operator|(
name|fd
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|name
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|>=
literal|0
condition|)
return|return
operator|(
name|fd
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** look up a DOS command, search the path as well. */
end_comment

begin_function
name|int
name|open_prog
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|fd
decl_stmt|;
name|char
name|fullname
index|[
literal|1024
index|]
decl_stmt|,
name|tmppath
index|[
literal|1024
index|]
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|e
decl_stmt|;
name|char
name|ext
index|[
literal|5
index|]
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|drive
decl_stmt|;
name|char
modifier|*
name|path
decl_stmt|;
if|if
condition|(
name|strpbrk
argument_list|(
name|name
argument_list|,
literal|":/\\"
argument_list|)
condition|)
block|{
name|error
operator|=
name|translate_filename
argument_list|(
name|name
argument_list|,
name|fullname
argument_list|,
operator|&
name|drive
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|fd
operator|=
name|open_name
argument_list|(
name|fullname
argument_list|,
name|ext
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|cmdname
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ext
condition|)
name|strcat
argument_list|(
name|cmdname
argument_list|,
name|ext
argument_list|)
expr_stmt|;
return|return
operator|(
name|fd
operator|)
return|;
block|}
name|path
operator|=
name|dos_path
expr_stmt|;
while|while
condition|(
operator|*
name|path
condition|)
block|{
name|p
operator|=
name|path
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|';'
condition|)
operator|++
name|p
expr_stmt|;
name|memcpy
argument_list|(
name|tmppath
argument_list|,
name|path
argument_list|,
name|p
operator|-
name|path
argument_list|)
expr_stmt|;
name|e
operator|=
name|tmppath
operator|+
operator|(
name|p
operator|-
name|path
operator|)
expr_stmt|;
operator|*
name|e
operator|++
operator|=
literal|'\\'
expr_stmt|;
name|strcpy
argument_list|(
name|e
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|path
operator|=
operator|*
name|p
condition|?
name|p
operator|+
literal|1
else|:
name|p
expr_stmt|;
name|error
operator|=
name|translate_filename
argument_list|(
name|tmppath
argument_list|,
name|fullname
argument_list|,
operator|&
name|drive
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
continue|continue;
name|fd
operator|=
name|open_name
argument_list|(
name|fullname
argument_list|,
name|ext
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|>=
literal|0
condition|)
block|{
name|strcpy
argument_list|(
name|cmdname
argument_list|,
name|tmppath
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ext
condition|)
name|strcat
argument_list|(
name|cmdname
argument_list|,
name|ext
argument_list|)
expr_stmt|;
return|return
operator|(
name|fd
operator|)
return|;
block|}
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** append a value to the DOS environment */
end_comment

begin_function
name|void
name|put_dosenv
parameter_list|(
name|char
modifier|*
name|value
parameter_list|)
block|{
if|if
condition|(
name|ecnt
operator|<
sizeof|sizeof
argument_list|(
name|envs
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|envs
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|envs
index|[
name|ecnt
operator|++
index|]
operator|=
name|strdup
argument_list|(
name|value
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
literal|"put_dosenv"
argument_list|)
expr_stmt|;
name|quit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Environment full, ignoring %s\n"
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ** replicate a fd up at the top of the range */
end_comment

begin_function
name|int
name|squirrel_fd
parameter_list|(
name|int
name|fd
parameter_list|)
block|{
name|int
name|sfd
init|=
name|sysconf
argument_list|(
name|_SC_OPEN_MAX
argument_list|)
decl_stmt|;
name|struct
name|stat
name|sb
decl_stmt|;
do|do
block|{
name|errno
operator|=
literal|0
expr_stmt|;
name|fstat
argument_list|(
operator|--
name|sfd
argument_list|,
operator|&
name|sb
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|sfd
operator|>
literal|0
operator|&&
name|errno
operator|!=
name|EBADF
condition|)
do|;
if|if
condition|(
name|errno
operator|==
name|EBADF
operator|&&
name|dup2
argument_list|(
name|fd
argument_list|,
name|sfd
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
name|sfd
operator|)
return|;
block|}
return|return
operator|(
name|fd
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** Exit-time stuff */
end_comment

begin_comment
comment|/* ** Going away time ** ** XXX belongs somewhere else perhaps */
end_comment

begin_function
name|void
name|done
parameter_list|(
name|regcontext_t
modifier|*
name|REGS
parameter_list|,
name|int
name|val
parameter_list|)
block|{
if|if
condition|(
name|curpsp
operator|<
literal|2
condition|)
block|{
if|if
condition|(
name|xmode
condition|)
block|{
name|char
modifier|*
name|m
decl_stmt|;
name|tty_move
argument_list|(
literal|24
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|m
operator|=
literal|"END OF PROGRAM"
init|;
operator|*
name|m
condition|;
operator|++
name|m
control|)
name|tty_write
argument_list|(
operator|*
name|m
argument_list|,
literal|0x8400
argument_list|)
expr_stmt|;
for|for
control|(
name|m
operator|=
literal|"(PRESS<CTRL-ALT> ANY MOUSE BUTTON TO exit)"
init|;
operator|*
name|m
condition|;
operator|++
name|m
control|)
name|tty_write
argument_list|(
operator|*
name|m
argument_list|,
literal|0x0900
argument_list|)
expr_stmt|;
name|tty_move
argument_list|(
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
name|tty_pause
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|quit
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
block|}
name|exec_return
argument_list|(
name|REGS
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
name|COQ
block|{
name|void
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|()
function_decl|;
name|void
modifier|*
name|arg
decl_stmt|;
name|struct
name|COQ
modifier|*
name|next
decl_stmt|;
block|}
name|COQ
typedef|;
end_typedef

begin_decl_stmt
name|COQ
modifier|*
name|coq
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|quit
parameter_list|(
name|int
name|status
parameter_list|)
block|{
while|while
condition|(
name|coq
condition|)
block|{
name|COQ
modifier|*
name|c
init|=
name|coq
decl_stmt|;
name|coq
operator|=
name|coq
operator|->
name|next
expr_stmt|;
name|c
operator|->
name|func
argument_list|(
name|c
operator|->
name|arg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|xmode
condition|)
comment|/* XXX not for bootmode */
name|puts
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|call_on_quit
parameter_list|(
name|void
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|COQ
modifier|*
name|c
init|=
operator|(
name|COQ
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|COQ
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|c
condition|)
block|{
name|perror
argument_list|(
literal|"call_on_quit"
argument_list|)
expr_stmt|;
name|quit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|c
operator|->
name|func
operator|=
name|func
expr_stmt|;
name|c
operator|->
name|arg
operator|=
name|arg
expr_stmt|;
name|c
operator|->
name|next
operator|=
name|coq
expr_stmt|;
name|coq
operator|=
name|c
expr_stmt|;
block|}
end_function

begin_struct
struct|struct
name|i386_ioperm_args
block|{
name|u_short
name|start
decl_stmt|;
name|u_short
name|length
decl_stmt|;
name|char
name|disable
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|sysarch_args
block|{
name|int
name|op
decl_stmt|;
name|char
modifier|*
name|parms
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|iomap_init
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|i386_ioperm_args
name|args
index|[]
init|=
block|{
if|#
directive|if
literal|0
block|{ 0x200, 0x200, 1 },
comment|/* 0x200 - 0x400 */
block|{ 0x1c80, 2, 1 },
comment|/* 0x1c80 - 0x1c81 */
block|{ 0x2c80, 2, 1 },
comment|/* 0x2c80 - 0x2c81 */
block|{ 0x3c80, 2, 1 },
comment|/* 0x3c80 - 0x3c81 */
block|{ 0x3c4,  2, 1 },
comment|/* 0x3c4 - 0x3c5 */
block|{ 0x3c5,  2, 1 },
comment|/* 0x3ce - 0x3cf */
else|#
directive|else
block|{
literal|0x0
block|,
literal|0xffff
block|,
literal|1
block|}
block|,
comment|/* entire i/o space */
endif|#
directive|endif
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|args
index|[
name|i
index|]
operator|.
name|length
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sysarch
argument_list|(
name|I386_SET_IOPERM
argument_list|,
operator|&
operator|(
name|args
index|[
name|i
index|]
operator|)
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"sysarch"
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

