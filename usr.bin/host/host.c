begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * ++Copyright++ 1986  * -  * Copyright (c) 1986  *    The Regents of the University of California.  All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  * 	This product includes software developed by the University of  * 	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  * -  * Portions Copyright (c) 1993 by Digital Equipment Corporation.  *   * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies, and that  * the name of Digital Equipment Corporation not be used in advertising or  * publicity pertaining to distribution of the document or software without  * specific, written prior permission.  *   * THE SOFTWARE IS PROVIDED "AS IS" AND DIGITAL EQUIPMENT CORP. DISCLAIMS ALL  * WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS.   IN NO EVENT SHALL DIGITAL EQUIPMENT  * CORPORATION BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL  * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR  * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS  * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS  * SOFTWARE.  * -  * --Copyright--  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
name|char
name|copyright
index|[]
init|=
literal|"@(#) Copyright (c) 1986 Regents of the University of California.\n\  portions Copyright (c) 1993 Digital Equipment Corporation\n\  All rights reserved.\n"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/*  * Actually, this program is from Rutgers University, however it is   * based on nslookup and other pieces of named tools, so it needs  * that copyright notice.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$Id: host.c,v 1.1.1.1 1994/09/22 21:34:21 pst Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<arpa/nameser.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<resolv.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_decl_stmt
specifier|extern
name|int
name|h_errno
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NUMMX
value|50
end_define

begin_define
define|#
directive|define
name|SUCCESS
value|0
end_define

begin_define
define|#
directive|define
name|TIME_OUT
value|-1
end_define

begin_define
define|#
directive|define
name|NO_INFO
value|-2
end_define

begin_define
define|#
directive|define
name|ERROR
value|-3
end_define

begin_define
define|#
directive|define
name|NONAUTH
value|-4
end_define

begin_define
define|#
directive|define
name|NAME_LEN
value|256
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|T_TXT
end_ifndef

begin_define
define|#
directive|define
name|T_TXT
value|16
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|NO_DATA
end_ifndef

begin_define
define|#
directive|define
name|NO_DATA
value|NO_ADDRESS
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|C_HS
end_ifndef

begin_define
define|#
directive|define
name|C_HS
value|4
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|sockFD
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|filePtr
decl_stmt|;
end_decl_stmt

begin_function_decl
name|char
modifier|*
name|DecodeError
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|__res_state
name|orig
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|__res_state
name|_res
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|cname
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|getclass
init|=
name|C_IN
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|gettype
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|verbose
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|list
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|server_specified
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function_decl
name|u_char
modifier|*
name|pr_cdname
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|char
modifier|*
name|pr_class
argument_list|()
decl_stmt|,
modifier|*
name|pr_rr
argument_list|()
decl_stmt|,
modifier|*
name|pr_type
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|char
modifier|*
name|hostalias
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|main
parameter_list|(
name|c
parameter_list|,
name|v
parameter_list|)
name|char
modifier|*
modifier|*
name|v
decl_stmt|;
block|{
name|unsigned
name|addr
decl_stmt|;
specifier|register
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|inverse
operator|=
literal|0
expr_stmt|;
specifier|register
name|waitmode
operator|=
literal|0
expr_stmt|;
name|char
modifier|*
name|oldcname
decl_stmt|;
name|int
name|ncnames
decl_stmt|;
name|res_init
argument_list|()
expr_stmt|;
name|_res
operator|.
name|retrans
operator|=
literal|5
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: host [-w] [-v] [-r] [-d] [-t querytype] [-c class] [-a] host [server]\n  -w to wait forever until reply\n  -v for verbose output\n  -r to disable recursive processing\n  -d to turn on debugging output\n  -t querytype to look for a specific type of information\n  -c class to look for non-Internet data\n  -a is equivalent to '-v -t *'\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|c
operator|>
literal|2
operator|&&
name|v
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|v
index|[
literal|1
index|]
argument_list|,
literal|"-w"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|_res
operator|.
name|retry
operator|=
literal|1
expr_stmt|;
name|_res
operator|.
name|retrans
operator|=
literal|15
expr_stmt|;
name|waitmode
operator|=
literal|1
expr_stmt|;
name|v
operator|++
expr_stmt|;
name|c
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|v
index|[
literal|1
index|]
argument_list|,
literal|"-r"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|_res
operator|.
name|options
operator|&=
operator|~
name|RES_RECURSE
expr_stmt|;
name|v
operator|++
expr_stmt|;
name|c
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|v
index|[
literal|1
index|]
argument_list|,
literal|"-d"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|_res
operator|.
name|options
operator||=
name|RES_DEBUG
expr_stmt|;
name|v
operator|++
expr_stmt|;
name|c
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|v
index|[
literal|1
index|]
argument_list|,
literal|"-v"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|verbose
operator|=
literal|1
expr_stmt|;
name|v
operator|++
expr_stmt|;
name|c
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|v
index|[
literal|1
index|]
argument_list|,
literal|"-l"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|list
operator|=
literal|1
expr_stmt|;
name|v
operator|++
expr_stmt|;
name|c
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|v
index|[
literal|1
index|]
argument_list|,
literal|"-t"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|v
operator|++
expr_stmt|;
name|c
operator|--
expr_stmt|;
name|gettype
operator|=
name|parsetype
argument_list|(
name|v
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|v
operator|++
expr_stmt|;
name|c
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|v
index|[
literal|1
index|]
argument_list|,
literal|"-c"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|v
operator|++
expr_stmt|;
name|c
operator|--
expr_stmt|;
name|getclass
operator|=
name|parseclass
argument_list|(
name|v
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|v
operator|++
expr_stmt|;
name|c
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|v
index|[
literal|1
index|]
argument_list|,
literal|"-a"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|verbose
operator|=
literal|1
expr_stmt|;
name|gettype
operator|=
name|T_ANY
expr_stmt|;
name|v
operator|++
expr_stmt|;
name|c
operator|--
expr_stmt|;
block|}
block|}
if|if
condition|(
name|c
operator|>
literal|2
condition|)
block|{
name|s
operator|=
name|v
index|[
literal|2
index|]
expr_stmt|;
name|server_specified
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|inet_aton
argument_list|(
name|s
argument_list|,
operator|(
expr|struct
name|in_addr
operator|*
operator|)
operator|&
name|addr
argument_list|)
condition|)
block|{
name|hp
operator|=
name|gethostbyname
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error in looking up server name:\n"
argument_list|)
expr_stmt|;
name|hperror
argument_list|(
name|h_errno
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|_res
operator|.
name|nsaddr
operator|.
name|sin_addr
operator|=
operator|*
operator|(
expr|struct
name|in_addr
operator|*
operator|)
name|hp
operator|->
name|h_addr
expr_stmt|;
name|printf
argument_list|(
literal|"Using domain server:\n"
argument_list|)
expr_stmt|;
name|printanswer
argument_list|(
name|hp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|_res
operator|.
name|nsaddr
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|_res
operator|.
name|nsaddr
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|addr
expr_stmt|;
name|_res
operator|.
name|nsaddr
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
name|NAMESERVER_PORT
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Using domain server %s:\n"
argument_list|,
name|inet_ntoa
argument_list|(
name|_res
operator|.
name|nsaddr
operator|.
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|_res
operator|.
name|nscount
operator|=
literal|1
expr_stmt|;
name|_res
operator|.
name|retry
operator|=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|v
index|[
literal|1
index|]
argument_list|,
literal|"."
argument_list|)
operator|==
literal|0
operator|||
operator|!
name|inet_aton
argument_list|(
name|v
index|[
literal|1
index|]
argument_list|,
operator|(
expr|struct
name|in_addr
operator|*
operator|)
operator|&
name|addr
argument_list|)
condition|)
name|addr
operator|=
operator|-
literal|1
expr_stmt|;
name|hp
operator|=
name|NULL
expr_stmt|;
name|h_errno
operator|=
name|TRY_AGAIN
expr_stmt|;
comment|/*  * we handle default domains ourselves, thank you  */
name|_res
operator|.
name|options
operator|&=
operator|~
name|RES_DEFNAMES
expr_stmt|;
if|if
condition|(
name|list
condition|)
name|exit
argument_list|(
name|ListHosts
argument_list|(
name|v
index|[
literal|1
index|]
argument_list|,
name|gettype
condition|?
name|gettype
else|:
name|T_A
argument_list|)
argument_list|)
expr_stmt|;
name|oldcname
operator|=
name|NULL
expr_stmt|;
name|ncnames
operator|=
literal|5
expr_stmt|;
while|while
condition|(
name|hp
operator|==
name|NULL
operator|&&
name|h_errno
operator|==
name|TRY_AGAIN
condition|)
block|{
if|if
condition|(
name|addr
operator|==
operator|-
literal|1
condition|)
block|{
name|cname
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|oldcname
operator|==
name|NULL
condition|)
name|hp
operator|=
operator|(
expr|struct
name|hostent
operator|*
operator|)
name|gethostinfo
argument_list|(
name|v
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
name|hp
operator|=
operator|(
expr|struct
name|hostent
operator|*
operator|)
name|gethostinfo
argument_list|(
name|oldcname
argument_list|)
expr_stmt|;
if|if
condition|(
name|cname
condition|)
block|{
if|if
condition|(
name|ncnames
operator|--
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Too many cnames.  Possible loop.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|oldcname
operator|=
name|cname
expr_stmt|;
name|hp
operator|=
name|NULL
expr_stmt|;
name|h_errno
operator|=
name|TRY_AGAIN
expr_stmt|;
continue|continue;
block|}
block|}
else|else
block|{
name|hp
operator|=
name|gethostbyaddr
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|addr
argument_list|,
literal|4
argument_list|,
name|AF_INET
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
condition|)
name|printanswer
argument_list|(
name|hp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|waitmode
condition|)
break|break;
block|}
if|if
condition|(
name|hp
operator|==
name|NULL
condition|)
block|{
name|hperror
argument_list|(
name|h_errno
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|parsetype
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"a"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|T_A
operator|)
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"ns"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|T_NS
operator|)
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"md"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|T_MD
operator|)
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"mf"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|T_MF
operator|)
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"cname"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|T_CNAME
operator|)
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"soa"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|T_SOA
operator|)
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"mb"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|T_MB
operator|)
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"mg"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|T_MG
operator|)
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"mr"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|T_MR
operator|)
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"null"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|T_NULL
operator|)
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"wks"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|T_WKS
operator|)
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"ptr"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|T_PTR
operator|)
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"hinfo"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|T_HINFO
operator|)
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"minfo"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|T_MINFO
operator|)
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"mx"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|T_MX
operator|)
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"txt"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|T_TXT
operator|)
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"rp"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|T_RP
operator|)
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"afsdb"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|T_AFSDB
operator|)
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"x25"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|T_X25
operator|)
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"isdn"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|T_ISDN
operator|)
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"rt"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|T_RT
operator|)
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"uinfo"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|T_UINFO
operator|)
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"uid"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|T_UID
operator|)
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"gid"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|T_GID
operator|)
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"unspec"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|T_UNSPEC
operator|)
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"any"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|T_ANY
operator|)
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"*"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|T_ANY
operator|)
return|;
if|if
condition|(
name|atoi
argument_list|(
name|s
argument_list|)
condition|)
return|return
operator|(
name|atoi
argument_list|(
name|s
argument_list|)
operator|)
return|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Invalid query type: %s\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|parseclass
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"in"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|C_IN
operator|)
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"hs"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|C_HS
operator|)
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"any"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|C_ANY
operator|)
return|;
if|if
condition|(
name|atoi
argument_list|(
name|s
argument_list|)
condition|)
return|return
operator|(
name|atoi
argument_list|(
name|s
argument_list|)
operator|)
return|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Invalid query class: %s\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|printanswer
argument_list|(
name|hp
argument_list|)
specifier|register
expr|struct
name|hostent
operator|*
name|hp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
modifier|*
name|cp
decl_stmt|;
specifier|register
name|long
modifier|*
modifier|*
name|hptr
decl_stmt|;
name|printf
argument_list|(
literal|"Name: %s\n"
argument_list|,
name|hp
operator|->
name|h_name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Address:"
argument_list|)
expr_stmt|;
for|for
control|(
name|hptr
operator|=
operator|(
name|long
operator|*
operator|*
operator|)
name|hp
operator|->
name|h_addr_list
init|;
operator|*
name|hptr
condition|;
name|hptr
operator|++
control|)
name|printf
argument_list|(
literal|" %s"
argument_list|,
name|inet_ntoa
argument_list|(
operator|*
operator|(
expr|struct
name|in_addr
operator|*
operator|)
operator|*
name|hptr
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\nAliases:"
argument_list|)
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|hp
operator|->
name|h_aliases
init|;
name|cp
operator|&&
operator|*
name|cp
operator|&&
operator|*
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
name|printf
argument_list|(
literal|" %s"
argument_list|,
operator|*
name|cp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|hperror
argument_list|(
argument|errno
argument_list|)
end_macro

begin_decl_stmt
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_block
block|{
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|HOST_NOT_FOUND
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Host not found.\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TRY_AGAIN
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Host not found, try again.\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|NO_RECOVERY
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No recovery, Host not found.\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|NO_ADDRESS
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"There is an entry for this host, but it doesn't have "
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|gettype
condition|)
block|{
case|case
name|T_A
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"an Internet address.\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_NS
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"a Name Server.\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_MD
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"a Mail Destination.\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_MF
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"a Mail Forwarder.\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_CNAME
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"a Canonical Name.\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_SOA
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"a Start of Authority record.\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_MB
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"a Mailbox Domain Name.\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_MG
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"a Mail Group Member.\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_MR
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"a Mail Rename Name.\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_NULL
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"a Null Resource record.\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_WKS
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"any Well Known Service information.\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_PTR
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"a Pointer record.\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_HINFO
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"any Host Information.\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_MINFO
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"any Mailbox Information.\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_MX
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"a Mail Exchanger record.\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_TXT
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"a Text record.\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_RP
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"a Responsible Person.\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_UINFO
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"any User Information.\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_UID
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"a User ID.\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_GID
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"a Group ID.\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_UNSPEC
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"any Unspecified Format data.\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"the information you requested.\n"
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
block|}
block|}
end_block

begin_typedef
typedef|typedef
union|union
block|{
name|HEADER
name|qb1
decl_stmt|;
name|u_char
name|qb2
index|[
name|PACKETSZ
index|]
decl_stmt|;
block|}
name|querybuf
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|u_char
name|hostbuf
index|[
name|BUFSIZ
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_macro
name|gethostinfo
argument_list|(
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
modifier|*
name|domain
decl_stmt|;
name|int
name|n
decl_stmt|;
name|int
name|hp
decl_stmt|;
name|int
name|nDomain
decl_stmt|;
name|int
name|asis
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"."
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|getdomaininfo
argument_list|(
name|name
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
for|for
control|(
name|cp
operator|=
name|name
operator|,
name|n
operator|=
literal|0
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
if|if
condition|(
operator|*
name|cp
operator|==
literal|'.'
condition|)
name|n
operator|++
expr_stmt|;
if|if
condition|(
name|n
operator|&&
name|cp
index|[
operator|-
literal|1
index|]
operator|==
literal|'.'
condition|)
block|{
if|if
condition|(
name|cp
index|[
operator|-
literal|1
index|]
operator|==
literal|'.'
condition|)
name|cp
index|[
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|hp
operator|=
name|getdomaininfo
argument_list|(
name|name
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
index|[
operator|-
literal|1
index|]
operator|==
literal|0
condition|)
name|cp
index|[
operator|-
literal|1
index|]
operator|=
literal|'.'
expr_stmt|;
return|return
operator|(
name|hp
operator|)
return|;
block|}
if|if
condition|(
name|n
operator|==
literal|0
operator|&&
operator|(
name|cp
operator|=
name|hostalias
argument_list|(
name|name
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"Aliased to \"%s\"\n"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|_res
operator|.
name|options
operator||=
name|RES_DEFNAMES
expr_stmt|;
return|return
operator|(
name|getdomaininfo
argument_list|(
name|cp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|n
operator|>=
name|_res
operator|.
name|ndots
condition|)
block|{
name|asis
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"Trying null domain\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|=
name|getdomaininfo
argument_list|(
name|name
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
condition|)
return|return
operator|(
name|hp
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|MAXDS
for|for
control|(
name|nDomain
operator|=
literal|0
init|;
name|_res
operator|.
name|defdname_list
index|[
name|nDomain
index|]
index|[
literal|0
index|]
operator|!=
literal|0
condition|;
name|nDomain
operator|++
control|)
block|{
for|for
control|(
name|domain
operator|=
name|_res
operator|.
name|dnsrch_list
index|[
name|nDomain
index|]
init|;
operator|*
name|domain
condition|;
name|domain
operator|++
control|)
block|{
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"Trying domain \"%s\"\n"
argument_list|,
operator|*
name|domain
argument_list|)
expr_stmt|;
name|hp
operator|=
name|getdomaininfo
argument_list|(
name|name
argument_list|,
operator|*
name|domain
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
condition|)
return|return
operator|(
name|hp
operator|)
return|;
block|}
block|}
else|#
directive|else
for|for
control|(
name|domain
operator|=
name|_res
operator|.
name|dnsrch
init|;
operator|*
name|domain
condition|;
name|domain
operator|++
control|)
block|{
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"Trying domain \"%s\"\n"
argument_list|,
operator|*
name|domain
argument_list|)
expr_stmt|;
name|hp
operator|=
name|getdomaininfo
argument_list|(
name|name
argument_list|,
operator|*
name|domain
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
condition|)
return|return
operator|(
name|hp
operator|)
return|;
block|}
endif|#
directive|endif
if|if
condition|(
name|h_errno
operator|!=
name|HOST_NOT_FOUND
operator|||
operator|(
name|_res
operator|.
name|options
operator|&
name|RES_DNSRCH
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
name|asis
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"Trying null domain\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|getdomaininfo
argument_list|(
name|name
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
operator|)
return|;
block|}
end_block

begin_macro
name|getdomaininfo
argument_list|(
argument|name
argument_list|,
argument|domain
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|domain
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|val1
decl_stmt|,
name|val2
decl_stmt|;
if|if
condition|(
name|gettype
condition|)
return|return
name|getinfo
argument_list|(
name|name
argument_list|,
name|domain
argument_list|,
name|gettype
argument_list|)
return|;
else|else
block|{
name|val1
operator|=
name|getinfo
argument_list|(
name|name
argument_list|,
name|domain
argument_list|,
name|T_A
argument_list|)
expr_stmt|;
if|if
condition|(
name|cname
operator|||
name|verbose
condition|)
return|return
name|val1
return|;
name|val2
operator|=
name|getinfo
argument_list|(
name|name
argument_list|,
name|domain
argument_list|,
name|T_MX
argument_list|)
expr_stmt|;
return|return
name|val1
operator|||
name|val2
return|;
block|}
block|}
end_block

begin_macro
name|getinfo
argument_list|(
argument|name
argument_list|,
argument|domain
argument_list|,
argument|type
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|domain
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|HEADER
modifier|*
name|hp
decl_stmt|;
name|char
modifier|*
name|eom
decl_stmt|,
modifier|*
name|bp
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|querybuf
name|buf
decl_stmt|,
name|answer
decl_stmt|;
name|int
name|n
decl_stmt|,
name|n1
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|,
name|nmx
decl_stmt|,
name|ancount
decl_stmt|,
name|nscount
decl_stmt|,
name|arcount
decl_stmt|,
name|qdcount
decl_stmt|,
name|buflen
decl_stmt|;
name|u_short
name|pref
decl_stmt|,
name|class
decl_stmt|;
name|char
name|host
index|[
literal|2
operator|*
name|MAXDNAME
operator|+
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|domain
operator|==
name|NULL
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|host
argument_list|,
literal|"%.*s"
argument_list|,
name|MAXDNAME
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|host
argument_list|,
literal|"%.*s.%.*s"
argument_list|,
name|MAXDNAME
argument_list|,
name|name
argument_list|,
name|MAXDNAME
argument_list|,
name|domain
argument_list|)
expr_stmt|;
name|n
operator|=
name|res_mkquery
argument_list|(
name|QUERY
argument_list|,
name|host
argument_list|,
name|getclass
argument_list|,
name|type
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|buf
operator|.
name|qb2
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|_res
operator|.
name|options
operator|&
name|RES_DEBUG
condition|)
name|printf
argument_list|(
literal|"res_mkquery failed\n"
argument_list|)
expr_stmt|;
name|h_errno
operator|=
name|NO_RECOVERY
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|n
operator|=
name|res_send
argument_list|(
name|buf
operator|.
name|qb2
argument_list|,
name|n
argument_list|,
name|answer
operator|.
name|qb2
argument_list|,
sizeof|sizeof
name|answer
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|_res
operator|.
name|options
operator|&
name|RES_DEBUG
condition|)
name|printf
argument_list|(
literal|"res_send failed\n"
argument_list|)
expr_stmt|;
name|h_errno
operator|=
name|TRY_AGAIN
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|eom
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|answer
operator|+
name|n
expr_stmt|;
return|return
operator|(
name|printinfo
argument_list|(
operator|&
name|answer
argument_list|,
name|eom
argument_list|,
name|T_ANY
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_block

begin_macro
name|printinfo
argument_list|(
argument|answer
argument_list|,
argument|eom
argument_list|,
argument|filter
argument_list|,
argument|isls
argument_list|)
end_macro

begin_decl_stmt
name|querybuf
modifier|*
name|answer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_char
modifier|*
name|eom
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|filter
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|isls
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|HEADER
modifier|*
name|hp
decl_stmt|;
name|u_char
modifier|*
name|bp
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|int
name|n
decl_stmt|,
name|n1
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|,
name|nmx
decl_stmt|,
name|ancount
decl_stmt|,
name|nscount
decl_stmt|,
name|arcount
decl_stmt|,
name|qdcount
decl_stmt|,
name|buflen
decl_stmt|;
name|u_short
name|pref
decl_stmt|,
name|class
decl_stmt|;
comment|/* 	 * find first satisfactory answer 	 */
name|hp
operator|=
operator|(
name|HEADER
operator|*
operator|)
name|answer
expr_stmt|;
name|ancount
operator|=
name|ntohs
argument_list|(
name|hp
operator|->
name|ancount
argument_list|)
expr_stmt|;
name|qdcount
operator|=
name|ntohs
argument_list|(
name|hp
operator|->
name|qdcount
argument_list|)
expr_stmt|;
name|nscount
operator|=
name|ntohs
argument_list|(
name|hp
operator|->
name|nscount
argument_list|)
expr_stmt|;
name|arcount
operator|=
name|ntohs
argument_list|(
name|hp
operator|->
name|arcount
argument_list|)
expr_stmt|;
if|if
condition|(
name|_res
operator|.
name|options
operator|&
name|RES_DEBUG
operator|||
operator|(
name|verbose
operator|&&
name|isls
operator|==
literal|0
operator|)
condition|)
name|printf
argument_list|(
literal|"rcode = %d (%s), ancount=%d\n"
argument_list|,
name|hp
operator|->
name|rcode
argument_list|,
name|DecodeError
argument_list|(
name|hp
operator|->
name|rcode
argument_list|)
argument_list|,
name|ancount
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|rcode
operator|!=
name|NOERROR
operator|||
operator|(
name|ancount
operator|+
name|nscount
operator|+
name|arcount
operator|)
operator|==
literal|0
condition|)
block|{
switch|switch
condition|(
name|hp
operator|->
name|rcode
condition|)
block|{
case|case
name|NXDOMAIN
case|:
name|h_errno
operator|=
name|HOST_NOT_FOUND
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|SERVFAIL
case|:
name|h_errno
operator|=
name|TRY_AGAIN
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
ifdef|#
directive|ifdef
name|OLDJEEVES
comment|/* 			 * Jeeves (TOPS-20 server) still does not 			 * support MX records.  For the time being, 			 * we must accept FORMERRs as the same as 			 * NOERROR. 			 */
case|case
name|FORMERR
case|:
endif|#
directive|endif
comment|/*OLDJEEVES*/
case|case
name|NOERROR
case|:
comment|/* TpB - set a return error for this case. NO_DATA */
name|h_errno
operator|=
name|NO_DATA
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* was 1,but now indicates exception */
ifndef|#
directive|ifndef
name|OLDJEEVES
case|case
name|FORMERR
case|:
endif|#
directive|endif
comment|/*OLDJEEVES*/
case|case
name|NOTIMP
case|:
case|case
name|REFUSED
case|:
name|h_errno
operator|=
name|NO_RECOVERY
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|bp
operator|=
name|hostbuf
expr_stmt|;
name|nmx
operator|=
literal|0
expr_stmt|;
name|buflen
operator|=
sizeof|sizeof
argument_list|(
name|hostbuf
argument_list|)
expr_stmt|;
name|cp
operator|=
operator|(
name|u_char
operator|*
operator|)
name|answer
operator|+
name|HFIXEDSZ
expr_stmt|;
if|if
condition|(
name|qdcount
condition|)
block|{
name|cp
operator|+=
name|dn_skipname
argument_list|(
name|cp
argument_list|,
name|eom
argument_list|)
operator|+
name|QFIXEDSZ
expr_stmt|;
while|while
condition|(
operator|--
name|qdcount
operator|>
literal|0
condition|)
name|cp
operator|+=
name|dn_skipname
argument_list|(
name|cp
argument_list|,
name|eom
argument_list|)
operator|+
name|QFIXEDSZ
expr_stmt|;
block|}
if|if
condition|(
name|ancount
condition|)
block|{
if|if
condition|(
operator|!
name|hp
operator|->
name|aa
condition|)
if|if
condition|(
name|verbose
operator|&&
name|isls
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"The following answer is not authoritative:\n"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|ancount
operator|>=
literal|0
operator|&&
name|cp
operator|&&
name|cp
operator|<
name|eom
condition|)
block|{
name|cp
operator|=
operator|(
name|u_char
operator|*
operator|)
name|pr_rr
argument_list|(
name|cp
argument_list|,
name|answer
argument_list|,
name|stdout
argument_list|,
name|filter
argument_list|)
expr_stmt|;
comment|/*  * When we ask for address and there is a CNAME, it seems to return  * both the CNAME and the address.  Since we trace down the CNAME  * chain ourselves, we don't really want to print the address at  * this point.  */
if|if
condition|(
name|cname
operator|&&
operator|!
name|verbose
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
operator|!
name|verbose
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|nscount
condition|)
block|{
name|printf
argument_list|(
literal|"For authoritative answers, see:\n"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|nscount
operator|>=
literal|0
operator|&&
name|cp
operator|&&
name|cp
operator|<
name|eom
condition|)
block|{
name|cp
operator|=
operator|(
name|u_char
operator|*
operator|)
name|pr_rr
argument_list|(
name|cp
argument_list|,
name|answer
argument_list|,
name|stdout
argument_list|,
name|filter
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|arcount
condition|)
block|{
name|printf
argument_list|(
literal|"Additional information:\n"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|arcount
operator|>=
literal|0
operator|&&
name|cp
operator|&&
name|cp
operator|<
name|eom
condition|)
block|{
name|cp
operator|=
operator|(
name|u_char
operator|*
operator|)
name|pr_rr
argument_list|(
name|cp
argument_list|,
name|answer
argument_list|,
name|stdout
argument_list|,
name|filter
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_decl_stmt
specifier|static
name|char
name|cnamebuf
index|[
name|MAXDNAME
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Print resource record fields in human readable form.  */
end_comment

begin_function
name|char
modifier|*
name|pr_rr
parameter_list|(
name|cp
parameter_list|,
name|msg
parameter_list|,
name|file
parameter_list|,
name|filter
parameter_list|)
name|u_char
modifier|*
name|cp
decl_stmt|,
decl|*
name|msg
decl_stmt|;
end_function

begin_decl_stmt
name|FILE
modifier|*
name|file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|filter
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|type
decl_stmt|,
name|class
decl_stmt|,
name|dlen
decl_stmt|,
name|n
decl_stmt|,
name|c
decl_stmt|,
name|proto
decl_stmt|,
name|ttl
decl_stmt|;
name|struct
name|in_addr
name|inaddr
decl_stmt|;
name|u_char
modifier|*
name|cp1
decl_stmt|;
name|struct
name|protoent
modifier|*
name|protop
decl_stmt|;
name|struct
name|servent
modifier|*
name|servp
decl_stmt|;
name|char
name|punc
decl_stmt|;
name|int
name|doprint
decl_stmt|;
name|char
name|name
index|[
name|MAXDNAME
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
operator|(
name|u_char
operator|*
operator|)
name|pr_cdname
argument_list|(
name|cp
argument_list|,
name|msg
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* compression error */
name|type
operator|=
name|_getshort
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|INT16SZ
expr_stmt|;
name|class
operator|=
name|_getshort
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|INT16SZ
expr_stmt|;
name|ttl
operator|=
name|_getlong
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|INT32SZ
expr_stmt|;
if|if
condition|(
name|filter
operator|==
name|type
operator|||
name|filter
operator|==
name|T_ANY
operator|||
operator|(
name|filter
operator|==
name|T_A
operator|&&
operator|(
name|type
operator|==
name|T_PTR
operator|||
name|type
operator|==
name|T_NS
operator|)
operator|)
condition|)
name|doprint
operator|=
literal|1
expr_stmt|;
else|else
name|doprint
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|doprint
condition|)
if|if
condition|(
name|verbose
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s\t%d%s\t%s"
argument_list|,
name|name
argument_list|,
name|ttl
argument_list|,
name|pr_class
argument_list|(
name|class
argument_list|)
argument_list|,
name|pr_type
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s%s %s"
argument_list|,
name|name
argument_list|,
name|pr_class
argument_list|(
name|class
argument_list|)
argument_list|,
name|pr_type
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|punc
operator|=
literal|'\t'
expr_stmt|;
else|else
name|punc
operator|=
literal|' '
expr_stmt|;
name|dlen
operator|=
name|_getshort
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|INT16SZ
expr_stmt|;
name|cp1
operator|=
name|cp
expr_stmt|;
comment|/* 	 * Print type specific data, if appropriate 	 */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|T_A
case|:
switch|switch
condition|(
name|class
condition|)
block|{
case|case
name|C_IN
case|:
name|bcopy
argument_list|(
name|cp
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|inaddr
argument_list|,
name|INADDRSZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|dlen
operator|==
literal|4
condition|)
block|{
if|if
condition|(
name|doprint
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%c%s"
argument_list|,
name|punc
argument_list|,
name|inet_ntoa
argument_list|(
name|inaddr
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|dlen
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dlen
operator|==
literal|7
condition|)
block|{
if|if
condition|(
name|doprint
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%c%s"
argument_list|,
name|punc
argument_list|,
name|inet_ntoa
argument_list|(
name|inaddr
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|", protocol = %d"
argument_list|,
name|cp
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|", port = %d"
argument_list|,
operator|(
name|cp
index|[
literal|5
index|]
operator|<<
literal|8
operator|)
operator|+
name|cp
index|[
literal|6
index|]
argument_list|)
expr_stmt|;
block|}
name|cp
operator|+=
name|dlen
expr_stmt|;
block|}
break|break;
block|}
break|break;
case|case
name|T_CNAME
case|:
if|if
condition|(
name|dn_expand
argument_list|(
name|msg
argument_list|,
name|msg
operator|+
literal|512
argument_list|,
name|cp
argument_list|,
name|cnamebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|cnamebuf
argument_list|)
argument_list|)
operator|>=
literal|0
condition|)
name|cname
operator|=
name|cnamebuf
expr_stmt|;
case|case
name|T_MB
case|:
ifdef|#
directive|ifdef
name|OLDRR
case|case
name|T_MD
case|:
case|case
name|T_MF
case|:
endif|#
directive|endif
comment|/* OLDRR */
case|case
name|T_MG
case|:
case|case
name|T_MR
case|:
case|case
name|T_NS
case|:
case|case
name|T_PTR
case|:
name|cp
operator|=
operator|(
name|u_char
operator|*
operator|)
name|pr_cdname
argument_list|(
name|cp
argument_list|,
name|msg
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|doprint
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%c%s"
argument_list|,
name|punc
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_HINFO
case|:
case|case
name|T_ISDN
case|:
if|if
condition|(
name|n
operator|=
operator|*
name|cp
operator|++
condition|)
block|{
if|if
condition|(
name|doprint
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%c%.*s"
argument_list|,
name|punc
argument_list|,
name|n
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|=
operator|*
name|cp
operator|++
condition|)
block|{
if|if
condition|(
name|doprint
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%c%.*s"
argument_list|,
name|punc
argument_list|,
name|n
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
block|}
break|break;
case|case
name|T_SOA
case|:
name|cp
operator|=
operator|(
name|u_char
operator|*
operator|)
name|pr_cdname
argument_list|(
name|cp
argument_list|,
name|msg
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|doprint
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|cp
operator|=
operator|(
name|u_char
operator|*
operator|)
name|pr_cdname
argument_list|(
name|cp
argument_list|,
name|msg
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|doprint
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|doprint
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"(\n\t\t\t%ld\t;serial (version)"
argument_list|,
name|_getlong
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|INT32SZ
expr_stmt|;
if|if
condition|(
name|doprint
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n\t\t\t%ld\t;refresh period"
argument_list|,
name|_getlong
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|INT32SZ
expr_stmt|;
if|if
condition|(
name|doprint
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n\t\t\t%ld\t;retry refresh this often"
argument_list|,
name|_getlong
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|INT32SZ
expr_stmt|;
if|if
condition|(
name|doprint
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n\t\t\t%ld\t;expiration period"
argument_list|,
name|_getlong
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|INT32SZ
expr_stmt|;
if|if
condition|(
name|doprint
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n\t\t\t%ld\t;minimum TTL\n\t\t\t)"
argument_list|,
name|_getlong
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|INT32SZ
expr_stmt|;
break|break;
case|case
name|T_MX
case|:
case|case
name|T_AFSDB
case|:
case|case
name|T_RT
case|:
if|if
condition|(
name|doprint
condition|)
if|if
condition|(
name|verbose
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t%ld "
argument_list|,
name|_getshort
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
expr_stmt|;
name|cp
operator|=
operator|(
name|u_char
operator|*
operator|)
name|pr_cdname
argument_list|(
name|cp
argument_list|,
name|msg
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|doprint
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_MINFO
case|:
case|case
name|T_RP
case|:
name|cp
operator|=
operator|(
name|u_char
operator|*
operator|)
name|pr_cdname
argument_list|(
name|cp
argument_list|,
name|msg
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|doprint
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|T_RP
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|p
operator|=
name|strchr
argument_list|(
name|name
argument_list|,
literal|'.'
argument_list|)
condition|)
operator|*
name|p
operator|=
literal|'@'
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%c%s"
argument_list|,
name|punc
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
name|cp
operator|=
operator|(
name|u_char
operator|*
operator|)
name|pr_cdname
argument_list|(
name|cp
argument_list|,
name|msg
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|doprint
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_TXT
case|:
case|case
name|T_X25
case|:
block|{
name|int
name|n
decl_stmt|,
name|j
decl_stmt|;
name|u_char
modifier|*
name|end
init|=
name|cp
operator|+
name|dlen
decl_stmt|;
if|if
condition|(
name|doprint
condition|)
operator|(
name|void
operator|)
name|fputs
argument_list|(
literal|" \""
argument_list|,
name|file
argument_list|)
expr_stmt|;
while|while
condition|(
name|cp
operator|<
name|end
condition|)
block|{
if|if
condition|(
name|n
operator|=
operator|*
name|cp
operator|++
condition|)
block|{
for|for
control|(
name|j
operator|=
name|n
init|;
name|j
operator|>
literal|0
operator|&&
name|cp
operator|<
name|end
condition|;
name|j
operator|--
control|)
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|doprint
condition|)
block|{
operator|(
name|void
operator|)
name|putc
argument_list|(
literal|'\\'
argument_list|,
name|file
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putc
argument_list|(
operator|*
name|cp
operator|++
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|doprint
condition|)
operator|(
name|void
operator|)
name|putc
argument_list|(
operator|*
name|cp
operator|++
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|doprint
condition|)
operator|(
name|void
operator|)
name|fputs
argument_list|(
literal|"\""
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|T_UINFO
case|:
if|if
condition|(
name|doprint
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%c%s"
argument_list|,
name|punc
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|dlen
expr_stmt|;
break|break;
case|case
name|T_UID
case|:
case|case
name|T_GID
case|:
if|if
condition|(
name|dlen
operator|==
literal|4
condition|)
block|{
if|if
condition|(
name|doprint
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%c%ld"
argument_list|,
name|punc
argument_list|,
name|_getlong
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|INT32SZ
expr_stmt|;
block|}
break|break;
case|case
name|T_WKS
case|:
if|if
condition|(
name|dlen
operator|<
name|INT32SZ
operator|+
literal|1
condition|)
break|break;
name|bcopy
argument_list|(
name|cp
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|inaddr
argument_list|,
name|INADDRSZ
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|INT32SZ
expr_stmt|;
name|proto
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
name|protop
operator|=
name|getprotobynumber
argument_list|(
name|proto
argument_list|)
expr_stmt|;
if|if
condition|(
name|doprint
condition|)
if|if
condition|(
name|protop
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%c%s %s"
argument_list|,
name|punc
argument_list|,
name|inet_ntoa
argument_list|(
name|inaddr
argument_list|)
argument_list|,
name|protop
operator|->
name|p_name
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%c%s %d"
argument_list|,
name|punc
argument_list|,
name|inet_ntoa
argument_list|(
name|inaddr
argument_list|)
argument_list|,
name|proto
argument_list|)
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|cp
operator|<
name|cp1
operator|+
name|dlen
condition|)
block|{
name|c
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
do|do
block|{
if|if
condition|(
name|c
operator|&
literal|0200
condition|)
block|{
name|servp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|protop
condition|)
name|servp
operator|=
name|getservbyport
argument_list|(
name|htons
argument_list|(
name|n
argument_list|)
argument_list|,
name|protop
operator|->
name|p_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|doprint
condition|)
if|if
condition|(
name|servp
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %s"
argument_list|,
name|servp
operator|->
name|s_name
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %d"
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
name|c
operator|<<=
literal|1
expr_stmt|;
block|}
do|while
condition|(
operator|++
name|n
operator|&
literal|07
condition|)
do|;
block|}
break|break;
default|default:
if|if
condition|(
name|doprint
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%c???"
argument_list|,
name|punc
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|dlen
expr_stmt|;
block|}
if|if
condition|(
name|cp
operator|!=
name|cp1
operator|+
name|dlen
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"packet size error (%#x != %#x)\n"
argument_list|,
name|cp
argument_list|,
name|cp1
operator|+
name|dlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|doprint
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|char
operator|*
operator|)
name|cp
return|;
block|}
end_block

begin_decl_stmt
specifier|static
name|char
name|nbuf
index|[
literal|20
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Return a string for the type  */
end_comment

begin_function
name|char
modifier|*
name|pr_type
parameter_list|(
name|type
parameter_list|)
name|int
name|type
decl_stmt|;
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|T_A
case|:
return|return
operator|(
name|verbose
condition|?
literal|"A"
else|:
literal|"has address"
operator|)
return|;
case|case
name|T_NS
case|:
comment|/* authoritative server */
return|return
operator|(
literal|"NS"
operator|)
return|;
ifdef|#
directive|ifdef
name|OLDRR
case|case
name|T_MD
case|:
comment|/* mail destination */
return|return
operator|(
literal|"MD"
operator|)
return|;
case|case
name|T_MF
case|:
comment|/* mail forwarder */
return|return
operator|(
literal|"MF"
operator|)
return|;
endif|#
directive|endif
comment|/* OLDRR */
case|case
name|T_CNAME
case|:
comment|/* connonical name */
return|return
operator|(
name|verbose
condition|?
literal|"CNAME"
else|:
literal|"is a nickname for"
operator|)
return|;
case|case
name|T_SOA
case|:
comment|/* start of authority zone */
return|return
operator|(
literal|"SOA"
operator|)
return|;
case|case
name|T_MB
case|:
comment|/* mailbox domain name */
return|return
operator|(
literal|"MB"
operator|)
return|;
case|case
name|T_MG
case|:
comment|/* mail group member */
return|return
operator|(
literal|"MG"
operator|)
return|;
case|case
name|T_MX
case|:
comment|/* mail routing info */
return|return
operator|(
name|verbose
condition|?
literal|"MX"
else|:
literal|"mail is handled by"
operator|)
return|;
case|case
name|T_TXT
case|:
comment|/* TXT - descriptive info */
return|return
operator|(
name|verbose
condition|?
literal|"TXT"
else|:
literal|"descriptive text"
operator|)
return|;
case|case
name|T_AFSDB
case|:
comment|/* AFS/DCE info */
return|return
operator|(
name|verbose
condition|?
literal|"AFSDB"
else|:
literal|"DCE or AFS service from"
operator|)
return|;
case|case
name|T_X25
case|:
comment|/* X25 */
return|return
operator|(
name|verbose
condition|?
literal|"X25"
else|:
literal|"X25 address"
operator|)
return|;
case|case
name|T_ISDN
case|:
comment|/* ISDN */
return|return
operator|(
name|verbose
condition|?
literal|"ISDN"
else|:
literal|"ISDN address"
operator|)
return|;
case|case
name|T_RT
case|:
comment|/* Router */
return|return
operator|(
name|verbose
condition|?
literal|"RT"
else|:
literal|"router"
operator|)
return|;
case|case
name|T_MR
case|:
comment|/* mail rename name */
return|return
operator|(
literal|"MR"
operator|)
return|;
case|case
name|T_NULL
case|:
comment|/* null resource record */
return|return
operator|(
literal|"NULL"
operator|)
return|;
case|case
name|T_WKS
case|:
comment|/* well known service */
return|return
operator|(
literal|"WKS"
operator|)
return|;
case|case
name|T_PTR
case|:
comment|/* domain name pointer */
return|return
operator|(
literal|"PTR"
operator|)
return|;
case|case
name|T_HINFO
case|:
comment|/* host information */
return|return
operator|(
literal|"HINFO"
operator|)
return|;
case|case
name|T_MINFO
case|:
comment|/* mailbox information */
return|return
operator|(
literal|"MINFO"
operator|)
return|;
case|case
name|T_RP
case|:
comment|/* responsible person */
return|return
operator|(
name|verbose
condition|?
literal|"RP"
else|:
literal|"responsible person"
operator|)
return|;
case|case
name|T_AXFR
case|:
comment|/* zone transfer */
return|return
operator|(
literal|"AXFR"
operator|)
return|;
case|case
name|T_MAILB
case|:
comment|/* mail box */
return|return
operator|(
literal|"MAILB"
operator|)
return|;
case|case
name|T_MAILA
case|:
comment|/* mail address */
return|return
operator|(
literal|"MAILA"
operator|)
return|;
case|case
name|T_ANY
case|:
comment|/* matches any type */
return|return
operator|(
literal|"ANY"
operator|)
return|;
case|case
name|T_UINFO
case|:
return|return
operator|(
literal|"UINFO"
operator|)
return|;
case|case
name|T_UID
case|:
return|return
operator|(
literal|"UID"
operator|)
return|;
case|case
name|T_GID
case|:
return|return
operator|(
literal|"GID"
operator|)
return|;
default|default:
name|sprintf
argument_list|(
name|nbuf
argument_list|,
literal|"%d"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|nbuf
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Return a mnemonic for class  */
end_comment

begin_function
name|char
modifier|*
name|pr_class
parameter_list|(
name|class
parameter_list|)
name|int
name|class
decl_stmt|;
block|{
switch|switch
condition|(
name|class
condition|)
block|{
case|case
name|C_IN
case|:
comment|/* internet class */
return|return
operator|(
name|verbose
condition|?
literal|" IN"
else|:
literal|""
operator|)
return|;
case|case
name|C_HS
case|:
comment|/* internet class */
return|return
operator|(
name|verbose
condition|?
literal|" HS"
else|:
literal|""
operator|)
return|;
case|case
name|C_ANY
case|:
comment|/* matches any class */
return|return
operator|(
literal|" ANY"
operator|)
return|;
default|default:
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|nbuf
argument_list|,
literal|" %d"
argument_list|,
name|class
argument_list|)
expr_stmt|;
return|return
name|nbuf
return|;
block|}
block|}
end_function

begin_function
name|u_char
modifier|*
name|pr_cdname
parameter_list|(
name|cp
parameter_list|,
name|msg
parameter_list|,
name|name
parameter_list|,
name|namelen
parameter_list|)
name|u_char
modifier|*
name|cp
decl_stmt|,
decl|*
name|msg
decl_stmt|;
end_function

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|namelen
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|n
decl_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|dn_expand
argument_list|(
name|msg
argument_list|,
name|msg
operator|+
literal|512
argument_list|,
name|cp
argument_list|,
name|name
argument_list|,
name|namelen
operator|-
literal|2
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|name
index|[
literal|0
index|]
operator|=
literal|'.'
expr_stmt|;
name|name
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
return|return
operator|(
name|cp
operator|+
name|n
operator|)
return|;
block|}
end_block

begin_decl_stmt
name|char
modifier|*
name|resultcodes
index|[]
init|=
block|{
literal|"NOERROR"
block|,
literal|"FORMERR"
block|,
literal|"SERVFAIL"
block|,
literal|"NXDOMAIN"
block|,
literal|"NOTIMP"
block|,
literal|"REFUSED"
block|,
literal|"6"
block|,
literal|"7"
block|,
literal|"8"
block|,
literal|"9"
block|,
literal|"10"
block|,
literal|"11"
block|,
literal|"12"
block|,
literal|"13"
block|,
literal|"14"
block|,
literal|"NOCHANGE"
block|, }
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/*  ******************************************************************************  *  *  ListHosts --  *  *	Requests the name server to do a zone transfer so we  *	find out what hosts it knows about.  *  *  Results:  *	SUCCESS		the listing was successful.  *	ERROR		the server could not be contacted because   *			a socket could not be obtained or an error  *			occured while receiving, or the output file  *			could not be opened.  *  ******************************************************************************  */
end_comment

begin_function
name|int
name|ListHosts
parameter_list|(
name|namePtr
parameter_list|,
name|queryType
parameter_list|)
name|char
modifier|*
name|namePtr
decl_stmt|;
name|int
name|queryType
decl_stmt|;
comment|/* e.g. T_A */
block|{
name|querybuf
name|buf
decl_stmt|,
name|answer
decl_stmt|;
name|struct
name|sockaddr_in
name|sin
decl_stmt|;
name|HEADER
modifier|*
name|headerPtr
decl_stmt|;
name|int
name|msglen
decl_stmt|;
name|int
name|amtToRead
decl_stmt|;
name|int
name|numRead
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|numAnswers
init|=
literal|0
decl_stmt|;
name|int
name|result
decl_stmt|;
name|int
name|soacnt
init|=
literal|0
decl_stmt|;
name|u_short
name|len
decl_stmt|;
name|int
name|dlen
decl_stmt|;
name|int
name|type
decl_stmt|;
name|int
name|nscount
decl_stmt|;
name|u_char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|nmp
decl_stmt|;
name|char
name|name
index|[
name|NAME_LEN
index|]
decl_stmt|;
name|char
name|dname
index|[
literal|2
index|]
index|[
name|NAME_LEN
index|]
decl_stmt|;
name|char
name|domain
index|[
name|NAME_LEN
index|]
decl_stmt|;
comment|/* names and addresses of name servers to try */
define|#
directive|define
name|NUMNS
value|8
name|char
name|nsname
index|[
name|NUMNS
index|]
index|[
name|NAME_LEN
index|]
decl_stmt|;
name|int
name|nshaveaddr
index|[
name|NUMNS
index|]
decl_stmt|;
define|#
directive|define
name|IPADDRSIZE
value|4
define|#
directive|define
name|NUMNSADDR
value|16
name|char
name|nsipaddr
index|[
name|NUMNSADDR
index|]
index|[
name|IPADDRSIZE
index|]
decl_stmt|;
name|int
name|numns
decl_stmt|;
name|int
name|numnsaddr
decl_stmt|;
name|int
name|thisns
decl_stmt|;
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
enum|enum
block|{
name|NO_ERRORS
block|,
name|ERR_READING_LEN
block|,
name|ERR_READING_MSG
block|,
name|ERR_PRINTING
block|}
name|error
init|=
name|NO_ERRORS
enum|;
comment|/*  * normalize to not have trailing dot.  We do string compares below  * of info from name server, and it won't have trailing dots.  */
name|i
operator|=
name|strlen
argument_list|(
name|namePtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|namePtr
index|[
name|i
operator|-
literal|1
index|]
operator|==
literal|'.'
condition|)
name|namePtr
index|[
name|i
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|server_specified
condition|)
block|{
name|bcopy
argument_list|(
operator|&
name|_res
operator|.
name|nsaddr
operator|.
name|sin_addr
argument_list|,
name|nsipaddr
index|[
literal|0
index|]
argument_list|,
name|IPADDRSIZE
argument_list|)
expr_stmt|;
name|numnsaddr
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/*  * First we have to find out where to look.  This needs a NS query,  * possibly followed by looking up addresses for some of the names.  */
name|msglen
operator|=
name|res_mkquery
argument_list|(
name|QUERY
argument_list|,
name|namePtr
argument_list|,
name|C_IN
argument_list|,
name|T_NS
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|buf
operator|.
name|qb2
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|msglen
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"res_mkquery failed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ERROR
operator|)
return|;
block|}
name|msglen
operator|=
name|res_send
argument_list|(
name|buf
operator|.
name|qb2
argument_list|,
name|msglen
argument_list|,
name|answer
operator|.
name|qb2
argument_list|,
sizeof|sizeof
name|answer
argument_list|)
expr_stmt|;
if|if
condition|(
name|msglen
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Unable to get to nameserver -- try again later\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ERROR
operator|)
return|;
block|}
if|if
condition|(
name|_res
operator|.
name|options
operator|&
name|RES_DEBUG
operator|||
name|verbose
condition|)
name|printf
argument_list|(
literal|"rcode = %d (%s), ancount=%d\n"
argument_list|,
name|answer
operator|.
name|qb1
operator|.
name|rcode
argument_list|,
name|DecodeError
argument_list|(
name|answer
operator|.
name|qb1
operator|.
name|rcode
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|answer
operator|.
name|qb1
operator|.
name|ancount
argument_list|)
argument_list|)
expr_stmt|;
comment|/*  * Analyze response to our NS lookup  */
name|nscount
operator|=
name|ntohs
argument_list|(
name|answer
operator|.
name|qb1
operator|.
name|ancount
argument_list|)
operator|+
name|ntohs
argument_list|(
name|answer
operator|.
name|qb1
operator|.
name|nscount
argument_list|)
operator|+
name|ntohs
argument_list|(
name|answer
operator|.
name|qb1
operator|.
name|arcount
argument_list|)
expr_stmt|;
if|if
condition|(
name|answer
operator|.
name|qb1
operator|.
name|rcode
operator|!=
name|NOERROR
operator|||
name|nscount
operator|==
literal|0
condition|)
block|{
switch|switch
condition|(
name|answer
operator|.
name|qb1
operator|.
name|rcode
condition|)
block|{
case|case
name|NXDOMAIN
case|:
comment|/* Check if it's an authoritive answer */
if|if
condition|(
name|answer
operator|.
name|qb1
operator|.
name|aa
condition|)
block|{
name|printf
argument_list|(
literal|"No such domain\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"Unable to get information about domain -- try again later.\n"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SERVFAIL
case|:
name|printf
argument_list|(
literal|"Unable to get information about that domain -- try again later.\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|NOERROR
case|:
name|printf
argument_list|(
literal|"That domain exists, but seems to be a leaf node.\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|FORMERR
case|:
case|case
name|NOTIMP
case|:
case|case
name|REFUSED
case|:
name|printf
argument_list|(
literal|"Unrecoverable error looking up domain name.\n"
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|cp
operator|=
operator|(
name|u_char
operator|*
operator|)
name|answer
operator|.
name|qb2
operator|+
name|HFIXEDSZ
expr_stmt|;
if|if
condition|(
name|ntohs
argument_list|(
name|answer
operator|.
name|qb1
operator|.
name|qdcount
argument_list|)
operator|>
literal|0
condition|)
name|cp
operator|+=
name|dn_skipname
argument_list|(
name|cp
argument_list|,
name|answer
operator|.
name|qb2
operator|+
name|msglen
argument_list|)
operator|+
name|QFIXEDSZ
expr_stmt|;
name|numns
operator|=
literal|0
expr_stmt|;
name|numnsaddr
operator|=
literal|0
expr_stmt|;
comment|/*  * Look at response from NS lookup for NS and A records.  */
for|for
control|(
init|;
name|nscount
condition|;
name|nscount
operator|--
control|)
block|{
name|cp
operator|+=
name|dn_expand
argument_list|(
name|answer
operator|.
name|qb2
argument_list|,
name|answer
operator|.
name|qb2
operator|+
name|msglen
argument_list|,
name|cp
argument_list|,
name|domain
argument_list|,
sizeof|sizeof
argument_list|(
name|domain
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|_getshort
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|INT16SZ
operator|+
name|INT16SZ
operator|+
name|INT32SZ
expr_stmt|;
name|dlen
operator|=
name|_getshort
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|INT16SZ
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|T_NS
condition|)
block|{
if|if
condition|(
name|dn_expand
argument_list|(
name|answer
operator|.
name|qb2
argument_list|,
name|answer
operator|.
name|qb2
operator|+
name|msglen
argument_list|,
name|cp
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|numns
operator|<
name|NUMNS
operator|&&
name|strcasecmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|domain
argument_list|,
name|namePtr
argument_list|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numns
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcasecmp
argument_list|(
name|nsname
index|[
name|i
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
name|name
argument_list|)
operator|==
literal|0
condition|)
break|break;
comment|/* duplicate */
if|if
condition|(
name|i
operator|>=
name|numns
condition|)
block|{
name|strncpy
argument_list|(
name|nsname
index|[
name|numns
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|nshaveaddr
index|[
name|numns
index|]
operator|=
literal|0
expr_stmt|;
name|numns
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|T_A
condition|)
block|{
if|if
condition|(
name|numnsaddr
operator|<
name|NUMNSADDR
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numns
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcasecmp
argument_list|(
name|nsname
index|[
name|i
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
name|domain
argument_list|)
operator|==
literal|0
condition|)
block|{
name|nshaveaddr
index|[
name|i
index|]
operator|++
expr_stmt|;
name|bcopy
argument_list|(
name|cp
argument_list|,
name|nsipaddr
index|[
name|numnsaddr
index|]
argument_list|,
name|IPADDRSIZE
argument_list|)
expr_stmt|;
name|numnsaddr
operator|++
expr_stmt|;
break|break;
block|}
block|}
block|}
name|cp
operator|+=
name|dlen
expr_stmt|;
block|}
comment|/*  * Usually we'll get addresses for all the servers in the additional  * info section.  But in case we don't, look up their addresses.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numns
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|nshaveaddr
index|[
name|i
index|]
condition|)
block|{
specifier|register
name|long
modifier|*
modifier|*
name|hptr
decl_stmt|;
name|int
name|numaddrs
init|=
literal|0
decl_stmt|;
name|hp
operator|=
name|gethostbyname
argument_list|(
name|nsname
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
condition|)
block|{
for|for
control|(
name|hptr
operator|=
operator|(
name|long
operator|*
operator|*
operator|)
name|hp
operator|->
name|h_addr_list
init|;
operator|*
name|hptr
condition|;
name|hptr
operator|++
control|)
if|if
condition|(
name|numnsaddr
operator|<
name|NUMNSADDR
condition|)
block|{
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|*
name|hptr
argument_list|,
name|nsipaddr
index|[
name|numnsaddr
index|]
argument_list|,
name|IPADDRSIZE
argument_list|)
expr_stmt|;
name|numnsaddr
operator|++
expr_stmt|;
name|numaddrs
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|_res
operator|.
name|options
operator|&
name|RES_DEBUG
operator|||
name|verbose
condition|)
name|printf
argument_list|(
literal|"Found %d addresses for %s by extra query\n"
argument_list|,
name|numaddrs
argument_list|,
name|nsname
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|_res
operator|.
name|options
operator|&
name|RES_DEBUG
operator|||
name|verbose
condition|)
name|printf
argument_list|(
literal|"Found %d addresses for %s\n"
argument_list|,
name|nshaveaddr
index|[
name|i
index|]
argument_list|,
name|nsname
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*  * Now nsipaddr has numnsaddr addresses for name servers that  * serve the requested domain.  Now try to find one that will  * accept a zone transfer.  */
name|thisns
operator|=
literal|0
expr_stmt|;
name|again
label|:
name|numAnswers
operator|=
literal|0
expr_stmt|;
name|soacnt
operator|=
literal|0
expr_stmt|;
comment|/* 	 *  Create a query packet for the requested domain name. 	 * 	 */
name|msglen
operator|=
name|res_mkquery
argument_list|(
name|QUERY
argument_list|,
name|namePtr
argument_list|,
name|getclass
argument_list|,
name|T_AXFR
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|buf
operator|.
name|qb2
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|msglen
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|_res
operator|.
name|options
operator|&
name|RES_DEBUG
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ListHosts: Res_mkquery failed\n"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ERROR
operator|)
return|;
block|}
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|sin
argument_list|,
sizeof|sizeof
argument_list|(
name|sin
argument_list|)
argument_list|)
expr_stmt|;
name|sin
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
name|NAMESERVER_PORT
argument_list|)
expr_stmt|;
comment|/* 	 *  Set up a virtual circuit to the server. 	 */
for|for
control|(
init|;
name|thisns
operator|<
name|numnsaddr
condition|;
name|thisns
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|sockFD
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"ListHosts"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ERROR
operator|)
return|;
block|}
name|bcopy
argument_list|(
name|nsipaddr
index|[
name|thisns
index|]
argument_list|,
operator|&
name|sin
operator|.
name|sin_addr
argument_list|,
name|IPADDRSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|_res
operator|.
name|options
operator|&
name|RES_DEBUG
operator|||
name|verbose
condition|)
name|printf
argument_list|(
literal|"Trying %s\n"
argument_list|,
name|inet_ntoa
argument_list|(
name|sin
operator|.
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|connect
argument_list|(
name|sockFD
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin
argument_list|,
sizeof|sizeof
argument_list|(
name|sin
argument_list|)
argument_list|)
operator|>=
literal|0
condition|)
break|break;
if|if
condition|(
name|verbose
condition|)
name|perror
argument_list|(
literal|"Connection failed, trying next server"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|sockFD
argument_list|)
expr_stmt|;
name|sockFD
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|thisns
operator|>=
name|numnsaddr
condition|)
block|{
name|printf
argument_list|(
literal|"No server for that domain responded\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|verbose
condition|)
name|perror
argument_list|(
literal|"Error from the last server was"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ERROR
operator|)
return|;
block|}
comment|/* 	 * Send length& message for zone transfer  	 */
name|__putshort
argument_list|(
name|msglen
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|sockFD
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|len
argument_list|,
name|INT16SZ
argument_list|)
operator|!=
name|INT16SZ
operator|||
name|write
argument_list|(
name|sockFD
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|buf
argument_list|,
name|msglen
argument_list|)
operator|!=
name|msglen
condition|)
block|{
name|perror
argument_list|(
literal|"ListHosts"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|sockFD
argument_list|)
expr_stmt|;
name|sockFD
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
name|ERROR
operator|)
return|;
block|}
name|filePtr
operator|=
name|stdout
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* 	     * Read the length of the response. 	     */
name|cp
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
name|buf
expr_stmt|;
name|amtToRead
operator|=
name|INT16SZ
expr_stmt|;
while|while
condition|(
name|amtToRead
operator|>
literal|0
operator|&&
operator|(
name|numRead
operator|=
name|read
argument_list|(
name|sockFD
argument_list|,
name|cp
argument_list|,
name|amtToRead
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|cp
operator|+=
name|numRead
expr_stmt|;
name|amtToRead
operator|-=
name|numRead
expr_stmt|;
block|}
if|if
condition|(
name|numRead
operator|<=
literal|0
condition|)
block|{
name|error
operator|=
name|ERR_READING_LEN
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|len
operator|=
name|_getshort
argument_list|(
operator|(
name|u_char
operator|*
operator|)
operator|&
name|buf
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
break|break;
comment|/* nothing left to read */
block|}
comment|/* 	     * Read the response. 	     */
name|amtToRead
operator|=
name|len
expr_stmt|;
name|cp
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
name|buf
expr_stmt|;
while|while
condition|(
name|amtToRead
operator|>
literal|0
operator|&&
operator|(
name|numRead
operator|=
name|read
argument_list|(
name|sockFD
argument_list|,
name|cp
argument_list|,
name|amtToRead
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|cp
operator|+=
name|numRead
expr_stmt|;
name|amtToRead
operator|-=
name|numRead
expr_stmt|;
block|}
if|if
condition|(
name|numRead
operator|<=
literal|0
condition|)
block|{
name|error
operator|=
name|ERR_READING_MSG
expr_stmt|;
break|break;
block|}
name|i
operator|=
name|buf
operator|.
name|qb1
operator|.
name|rcode
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|NOERROR
operator|||
name|ntohs
argument_list|(
name|buf
operator|.
name|qb1
operator|.
name|ancount
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|thisns
operator|+
literal|1
operator|)
operator|<
name|numnsaddr
operator|&&
operator|(
name|i
operator|==
name|SERVFAIL
operator|||
name|i
operator|==
name|NOTIMP
operator|||
name|i
operator|==
name|REFUSED
operator|)
condition|)
block|{
if|if
condition|(
name|_res
operator|.
name|options
operator|&
name|RES_DEBUG
operator|||
name|verbose
condition|)
name|printf
argument_list|(
literal|"Server failed, trying next server: %s\n"
argument_list|,
name|i
operator|!=
name|NOERROR
condition|?
name|DecodeError
argument_list|(
name|i
argument_list|)
else|:
literal|"Premature end of data"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|sockFD
argument_list|)
expr_stmt|;
name|sockFD
operator|=
operator|-
literal|1
expr_stmt|;
name|thisns
operator|++
expr_stmt|;
goto|goto
name|again
goto|;
block|}
name|printf
argument_list|(
literal|"Server failed: %s\n"
argument_list|,
name|i
operator|!=
name|NOERROR
condition|?
name|DecodeError
argument_list|(
name|i
argument_list|)
else|:
literal|"Premature end of data"
argument_list|)
expr_stmt|;
break|break;
block|}
name|result
operator|=
name|printinfo
argument_list|(
operator|&
name|buf
argument_list|,
name|cp
argument_list|,
name|queryType
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|result
condition|)
block|{
name|error
operator|=
name|ERR_PRINTING
expr_stmt|;
break|break;
block|}
name|numAnswers
operator|++
expr_stmt|;
name|cp
operator|=
name|buf
operator|.
name|qb2
operator|+
name|HFIXEDSZ
expr_stmt|;
if|if
condition|(
name|ntohs
argument_list|(
name|buf
operator|.
name|qb1
operator|.
name|qdcount
argument_list|)
operator|>
literal|0
condition|)
name|cp
operator|+=
name|dn_skipname
argument_list|(
name|cp
argument_list|,
name|buf
operator|.
name|qb2
operator|+
name|len
argument_list|)
operator|+
name|QFIXEDSZ
expr_stmt|;
name|nmp
operator|=
name|cp
expr_stmt|;
name|cp
operator|+=
name|dn_skipname
argument_list|(
name|cp
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|buf
operator|+
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|_getshort
argument_list|(
name|cp
argument_list|)
operator|==
name|T_SOA
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|dn_expand
argument_list|(
name|buf
operator|.
name|qb2
argument_list|,
name|buf
operator|.
name|qb2
operator|+
name|len
argument_list|,
name|nmp
argument_list|,
name|dname
index|[
name|soacnt
index|]
argument_list|,
sizeof|sizeof
name|dname
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|soacnt
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dname
index|[
literal|0
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
name|dname
index|[
literal|1
index|]
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
else|else
name|soacnt
operator|++
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|close
argument_list|(
name|sockFD
argument_list|)
expr_stmt|;
name|sockFD
operator|=
operator|-
literal|1
expr_stmt|;
switch|switch
condition|(
name|error
condition|)
block|{
case|case
name|NO_ERRORS
case|:
return|return
operator|(
name|SUCCESS
operator|)
return|;
case|case
name|ERR_READING_LEN
case|:
return|return
operator|(
name|ERROR
operator|)
return|;
case|case
name|ERR_PRINTING
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"*** Error during listing of %s: %s\n"
argument_list|,
name|namePtr
argument_list|,
name|DecodeError
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
case|case
name|ERR_READING_MSG
case|:
name|headerPtr
operator|=
operator|(
name|HEADER
operator|*
operator|)
operator|&
name|buf
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ListHosts: error receiving zone transfer:\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  result: %s, answers = %d, authority = %d, additional = %d\n"
argument_list|,
name|resultcodes
index|[
name|headerPtr
operator|->
name|rcode
index|]
argument_list|,
name|ntohs
argument_list|(
name|headerPtr
operator|->
name|ancount
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|headerPtr
operator|->
name|nscount
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|headerPtr
operator|->
name|arcount
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ERROR
operator|)
return|;
default|default:
return|return
operator|(
name|ERROR
operator|)
return|;
block|}
block|}
end_function

begin_function
name|char
modifier|*
name|DecodeError
parameter_list|(
name|result
parameter_list|)
name|int
name|result
decl_stmt|;
block|{
switch|switch
condition|(
name|result
condition|)
block|{
case|case
name|NOERROR
case|:
return|return
operator|(
literal|"Success"
operator|)
return|;
break|break;
case|case
name|FORMERR
case|:
return|return
operator|(
literal|"Format error"
operator|)
return|;
break|break;
case|case
name|SERVFAIL
case|:
return|return
operator|(
literal|"Server failed"
operator|)
return|;
break|break;
case|case
name|NXDOMAIN
case|:
return|return
operator|(
literal|"Non-existent domain"
operator|)
return|;
break|break;
case|case
name|NOTIMP
case|:
return|return
operator|(
literal|"Not implemented"
operator|)
return|;
break|break;
case|case
name|REFUSED
case|:
return|return
operator|(
literal|"Query refused"
operator|)
return|;
break|break;
case|case
name|NOCHANGE
case|:
return|return
operator|(
literal|"No change"
operator|)
return|;
break|break;
case|case
name|NO_INFO
case|:
return|return
operator|(
literal|"No information"
operator|)
return|;
break|break;
case|case
name|ERROR
case|:
return|return
operator|(
literal|"Unspecified error"
operator|)
return|;
break|break;
case|case
name|TIME_OUT
case|:
return|return
operator|(
literal|"Timed out"
operator|)
return|;
break|break;
case|case
name|NONAUTH
case|:
return|return
operator|(
literal|"Non-authoritative answer"
operator|)
return|;
break|break;
default|default:
break|break;
block|}
return|return
operator|(
literal|"BAD ERROR VALUE"
operator|)
return|;
block|}
end_function

end_unit

