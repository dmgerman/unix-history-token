begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: gzip.c,v 1.89 2006/11/13 21:57:59 mrg Exp $	*/
end_comment

begin_comment
comment|/*-  * Copyright (c) 1997, 1998, 2003, 2004, 2006 Matthew R. Green  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,  * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED  * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_expr_stmt
name|__COPYRIGHT
argument_list|(
literal|"@(#) Copyright (c) 1997, 1998, 2003, 2004, 2006 Matthew R. Green\n\      All rights reserved.\n"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|__RCSID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/*  * gzip.c -- GPL free gzip using zlib.  *  * RFC 1950 covers the zlib format  * RFC 1951 covers the deflate format  * RFC 1952 covers the gzip format  *  * TODO:  *	- use mmap where possible  *	- handle some signals better (remove outfile?)  *	- make bzip2/compress -v/-t/-l support work as well as possible  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<inttypes.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<zlib.h>
end_include

begin_include
include|#
directive|include
file|<fts.h>
end_include

begin_include
include|#
directive|include
file|<libgen.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<getopt.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|PRIdOFF
end_ifndef

begin_define
define|#
directive|define
name|PRIdOFF
value|PRId64
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* what type of file are we dealing with */
end_comment

begin_enum
enum|enum
name|filetype
block|{
name|FT_GZIP
block|,
ifndef|#
directive|ifndef
name|NO_BZIP2_SUPPORT
name|FT_BZIP2
block|,
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NO_COMPRESS_SUPPORT
name|FT_Z
block|,
endif|#
directive|endif
name|FT_LAST
block|,
name|FT_UNKNOWN
block|}
enum|;
end_enum

begin_ifndef
ifndef|#
directive|ifndef
name|NO_BZIP2_SUPPORT
end_ifndef

begin_include
include|#
directive|include
file|<bzlib.h>
end_include

begin_define
define|#
directive|define
name|BZ2_SUFFIX
value|".bz2"
end_define

begin_define
define|#
directive|define
name|BZIP2_MAGIC
value|"\102\132\150"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|NO_COMPRESS_SUPPORT
end_ifndef

begin_define
define|#
directive|define
name|Z_SUFFIX
value|".Z"
end_define

begin_define
define|#
directive|define
name|Z_MAGIC
value|"\037\235"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|GZ_SUFFIX
value|".gz"
end_define

begin_define
define|#
directive|define
name|BUFLEN
value|(64 * 1024)
end_define

begin_define
define|#
directive|define
name|GZIP_MAGIC0
value|0x1F
end_define

begin_define
define|#
directive|define
name|GZIP_MAGIC1
value|0x8B
end_define

begin_define
define|#
directive|define
name|GZIP_OMAGIC1
value|0x9E
end_define

begin_define
define|#
directive|define
name|GZIP_TIMESTAMP
value|(off_t)4
end_define

begin_define
define|#
directive|define
name|GZIP_ORIGNAME
value|(off_t)10
end_define

begin_define
define|#
directive|define
name|HEAD_CRC
value|0x02
end_define

begin_define
define|#
directive|define
name|EXTRA_FIELD
value|0x04
end_define

begin_define
define|#
directive|define
name|ORIG_NAME
value|0x08
end_define

begin_define
define|#
directive|define
name|COMMENT
value|0x10
end_define

begin_define
define|#
directive|define
name|OS_CODE
value|3
end_define

begin_comment
comment|/* Unix */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
specifier|const
name|char
modifier|*
name|zipped
decl_stmt|;
name|int
name|ziplen
decl_stmt|;
specifier|const
name|char
modifier|*
name|normal
decl_stmt|;
comment|/* for unzip - must not be longer than zipped */
block|}
name|suffixes_t
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|suffixes_t
name|suffixes
index|[]
init|=
block|{
define|#
directive|define
name|SUFFIX
parameter_list|(
name|Z
parameter_list|,
name|N
parameter_list|)
value|{Z, sizeof Z - 1, N}
name|SUFFIX
argument_list|(
name|GZ_SUFFIX
argument_list|,
literal|""
argument_list|)
block|,
comment|/* Overwritten by -S .xxx */
ifndef|#
directive|ifndef
name|SMALL
name|SUFFIX
argument_list|(
name|GZ_SUFFIX
argument_list|,
literal|""
argument_list|)
block|,
name|SUFFIX
argument_list|(
literal|".z"
argument_list|,
literal|""
argument_list|)
block|,
name|SUFFIX
argument_list|(
literal|"-gz"
argument_list|,
literal|""
argument_list|)
block|,
name|SUFFIX
argument_list|(
literal|"-z"
argument_list|,
literal|""
argument_list|)
block|,
name|SUFFIX
argument_list|(
literal|"_z"
argument_list|,
literal|""
argument_list|)
block|,
name|SUFFIX
argument_list|(
literal|".taz"
argument_list|,
literal|".tar"
argument_list|)
block|,
name|SUFFIX
argument_list|(
literal|".tgz"
argument_list|,
literal|".tar"
argument_list|)
block|,
ifndef|#
directive|ifndef
name|NO_BZIP2_SUPPORT
name|SUFFIX
argument_list|(
name|BZ2_SUFFIX
argument_list|,
literal|""
argument_list|)
block|,
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NO_COMPRESS_SUPPORT
name|SUFFIX
argument_list|(
name|Z_SUFFIX
argument_list|,
literal|""
argument_list|)
block|,
endif|#
directive|endif
name|SUFFIX
argument_list|(
name|GZ_SUFFIX
argument_list|,
literal|""
argument_list|)
block|,
comment|/* Overwritten by -S "" */
endif|#
directive|endif
comment|/* SMALL */
undef|#
directive|undef
name|SUFFIX
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NUM_SUFFIXES
value|(sizeof suffixes / sizeof suffixes[0])
end_define

begin_decl_stmt
specifier|static
specifier|const
name|char
name|gzip_version
index|[]
init|=
literal|"FreeBSD gzip 20070126"
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|SMALL
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|gzip_copyright
index|[]
init|= \
literal|"   Copyright (c) 1997, 1998, 2003, 2004, 2006 Matthew R. Green\n"
literal|"   All rights reserved.\n"
literal|"\n"
literal|"   Redistribution and use in source and binary forms, with or without\n"
literal|"   modification, are permitted provided that the following conditions\n"
literal|"   are met:\n"
literal|"   1. Redistributions of source code must retain the above copyright\n"
literal|"      notice, this list of conditions and the following disclaimer.\n"
literal|"   2. Redistributions in binary form must reproduce the above copyright\n"
literal|"      notice, this list of conditions and the following disclaimer in the\n"
literal|"      documentation and/or other materials provided with the distribution.\n"
literal|"   3. The name of the author may not be used to endorse or promote products\n"
literal|"      derived from this software without specific prior written permission.\n"
literal|"\n"
literal|"   THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n"
literal|"   IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n"
literal|"   OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n"
literal|"   IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\n"
literal|"   INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n"
literal|"   BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n"
literal|"   LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n"
literal|"   AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n"
literal|"   OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n"
literal|"   OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n"
literal|"   SUCH DAMAGE."
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|cflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* stdout mode */
end_comment

begin_decl_stmt
specifier|static
name|int
name|dflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* decompress mode */
end_comment

begin_decl_stmt
specifier|static
name|int
name|lflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list mode */
end_comment

begin_decl_stmt
specifier|static
name|int
name|numflag
init|=
literal|6
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* gzip -1..-9 value */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SMALL
end_ifndef

begin_decl_stmt
specifier|static
name|int
name|fflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* force mode */
end_comment

begin_decl_stmt
specifier|static
name|int
name|nflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* don't save name/timestamp */
end_comment

begin_decl_stmt
specifier|static
name|int
name|Nflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* don't restore name/timestamp */
end_comment

begin_decl_stmt
specifier|static
name|int
name|qflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* quiet mode */
end_comment

begin_decl_stmt
specifier|static
name|int
name|rflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* recursive mode */
end_comment

begin_decl_stmt
specifier|static
name|int
name|tflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* test */
end_comment

begin_decl_stmt
specifier|static
name|int
name|vflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* verbose mode */
end_comment

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|qflag
value|0
end_define

begin_define
define|#
directive|define
name|tflag
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|exit_value
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* exit value */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|infile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* name of file coming in */
end_comment

begin_function_decl
specifier|static
name|void
name|maybe_err
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
function_decl|__attribute__
parameter_list|(
function_decl|(__format__
parameter_list|(
name|__printf__
parameter_list|,
function_decl|1
operator|,
function_decl|2
end_function_decl

begin_empty_stmt
unit|)))
empty_stmt|;
end_empty_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|NO_BZIP2_SUPPORT
end_ifndef

begin_function_decl
specifier|static
name|void
name|maybe_errx
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
function_decl|__attribute__
parameter_list|(
function_decl|(__format__
parameter_list|(
name|__printf__
parameter_list|,
function_decl|1
operator|,
function_decl|2
end_function_decl

begin_empty_stmt
unit|)))
empty_stmt|;
end_empty_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|maybe_warn
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
function_decl|__attribute__
parameter_list|(
function_decl|(__format__
parameter_list|(
name|__printf__
parameter_list|,
function_decl|1
operator|,
function_decl|2
end_function_decl

begin_empty_stmt
unit|)))
empty_stmt|;
end_empty_stmt

begin_function_decl
specifier|static
name|void
name|maybe_warnx
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
function_decl|__attribute__
parameter_list|(
function_decl|(__format__
parameter_list|(
name|__printf__
parameter_list|,
function_decl|1
operator|,
function_decl|2
end_function_decl

begin_empty_stmt
unit|)))
empty_stmt|;
end_empty_stmt

begin_function_decl
specifier|static
name|enum
name|filetype
name|file_gettype
parameter_list|(
name|u_char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|SMALL
end_ifdef

begin_define
define|#
directive|define
name|gz_compress
parameter_list|(
define|if, of, sz, fn, tm) gz_compress(if, of, sz)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|off_t
name|gz_compress
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|off_t
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|off_t
name|gz_uncompress
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|off_t
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|off_t
name|file_compress
parameter_list|(
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|off_t
name|file_uncompress
parameter_list|(
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|handle_pathname
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|handle_file
parameter_list|(
name|char
modifier|*
parameter_list|,
name|struct
name|stat
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|handle_stdin
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|handle_stdout
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_ratio
parameter_list|(
name|off_t
parameter_list|,
name|off_t
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_list
parameter_list|(
name|int
name|fd
parameter_list|,
name|off_t
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|time_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|display_version
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|SMALL
end_ifndef

begin_function_decl
specifier|static
name|void
name|display_license
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
specifier|const
name|suffixes_t
modifier|*
name|check_suffix
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ssize_t
name|read_retry
parameter_list|(
name|int
parameter_list|,
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|SMALL
end_ifdef

begin_define
define|#
directive|define
name|unlink_input
parameter_list|(
name|f
parameter_list|,
name|sb
parameter_list|)
value|unlink(f)
end_define

begin_else
else|#
directive|else
end_else

begin_function_decl
specifier|static
name|off_t
name|cat_fd
parameter_list|(
name|unsigned
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|off_t
modifier|*
parameter_list|,
name|int
name|fd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|prepend_gzip
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|handle_dir
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_verbage
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|off_t
parameter_list|,
name|off_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_test
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|copymodes
parameter_list|(
name|int
name|fd
parameter_list|,
specifier|const
name|struct
name|stat
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|check_outfile
parameter_list|(
specifier|const
name|char
modifier|*
name|outfile
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|NO_BZIP2_SUPPORT
end_ifndef

begin_function_decl
specifier|static
name|off_t
name|unbzip2
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|off_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|NO_COMPRESS_SUPPORT
end_ifndef

begin_function_decl
specifier|static
name|FILE
modifier|*
name|zdopen
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|off_t
name|zuncompress
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|off_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
name|int
name|main
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|SMALL
end_ifdef

begin_define
define|#
directive|define
name|getopt_long
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|,
name|e
parameter_list|)
value|getopt(a,b,c)
end_define

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|option
name|longopts
index|[]
init|=
block|{
block|{
literal|"stdout"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'c'
block|}
block|,
block|{
literal|"to-stdout"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'c'
block|}
block|,
block|{
literal|"decompress"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'d'
block|}
block|,
block|{
literal|"uncompress"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'d'
block|}
block|,
block|{
literal|"force"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'f'
block|}
block|,
block|{
literal|"help"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'h'
block|}
block|,
block|{
literal|"list"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'l'
block|}
block|,
block|{
literal|"no-name"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'n'
block|}
block|,
block|{
literal|"name"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'N'
block|}
block|,
block|{
literal|"quiet"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'q'
block|}
block|,
block|{
literal|"recursive"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'r'
block|}
block|,
block|{
literal|"suffix"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'S'
block|}
block|,
block|{
literal|"test"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'t'
block|}
block|,
block|{
literal|"verbose"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'v'
block|}
block|,
block|{
literal|"version"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'V'
block|}
block|,
block|{
literal|"fast"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'1'
block|}
block|,
block|{
literal|"best"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'9'
block|}
block|,
block|{
literal|"ascii"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'a'
block|}
block|,
block|{
literal|"license"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'L'
block|}
block|,
block|{
name|NULL
block|,
name|no_argument
block|,
literal|0
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|progname
init|=
name|getprogname
argument_list|()
decl_stmt|;
ifndef|#
directive|ifndef
name|SMALL
name|char
modifier|*
name|gzip
decl_stmt|;
name|int
name|len
decl_stmt|;
endif|#
directive|endif
name|int
name|ch
decl_stmt|;
comment|/* XXX set up signals */
ifndef|#
directive|ifndef
name|SMALL
if|if
condition|(
operator|(
name|gzip
operator|=
name|getenv
argument_list|(
literal|"GZIP"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|prepend_gzip
argument_list|(
name|gzip
argument_list|,
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * XXX 	 * handle being called `gunzip', `zcat' and `gzcat' 	 */
if|if
condition|(
name|strcmp
argument_list|(
name|progname
argument_list|,
literal|"gunzip"
argument_list|)
operator|==
literal|0
condition|)
name|dflag
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|progname
argument_list|,
literal|"zcat"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|progname
argument_list|,
literal|"gzcat"
argument_list|)
operator|==
literal|0
condition|)
name|dflag
operator|=
name|cflag
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|SMALL
define|#
directive|define
name|OPT_LIST
value|"123456789cdhltV"
else|#
directive|else
define|#
directive|define
name|OPT_LIST
value|"123456789acdfhlLNnqrS:tVv"
endif|#
directive|endif
while|while
condition|(
operator|(
name|ch
operator|=
name|getopt_long
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|OPT_LIST
argument_list|,
name|longopts
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
name|numflag
operator|=
name|ch
operator|-
literal|'0'
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|cflag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|dflag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|lflag
operator|=
literal|1
expr_stmt|;
name|dflag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
name|display_version
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
ifndef|#
directive|ifndef
name|SMALL
case|case
literal|'a'
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: option --ascii ignored on this system\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|fflag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
name|display_license
argument_list|()
expr_stmt|;
comment|/* NOT REACHED */
case|case
literal|'N'
case|:
name|nflag
operator|=
literal|0
expr_stmt|;
name|Nflag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|nflag
operator|=
literal|1
expr_stmt|;
name|Nflag
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|qflag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|rflag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|len
operator|=
name|strlen
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|!=
literal|0
condition|)
block|{
name|suffixes
index|[
literal|0
index|]
operator|.
name|zipped
operator|=
name|optarg
expr_stmt|;
name|suffixes
index|[
literal|0
index|]
operator|.
name|ziplen
operator|=
name|len
expr_stmt|;
block|}
else|else
block|{
name|suffixes
index|[
name|NUM_SUFFIXES
operator|-
literal|1
index|]
operator|.
name|zipped
operator|=
literal|""
expr_stmt|;
name|suffixes
index|[
name|NUM_SUFFIXES
operator|-
literal|1
index|]
operator|.
name|ziplen
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
literal|'t'
case|:
name|cflag
operator|=
literal|1
expr_stmt|;
name|tflag
operator|=
literal|1
expr_stmt|;
name|dflag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|vflag
operator|=
literal|1
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|usage
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
name|argv
operator|+=
name|optind
expr_stmt|;
name|argc
operator|-=
name|optind
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|dflag
condition|)
comment|/* stdin mode */
name|handle_stdin
argument_list|()
expr_stmt|;
else|else
comment|/* stdout mode */
name|handle_stdout
argument_list|()
expr_stmt|;
block|}
else|else
block|{
do|do
block|{
name|handle_pathname
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|*
operator|++
name|argv
condition|)
do|;
block|}
ifndef|#
directive|ifndef
name|SMALL
if|if
condition|(
name|qflag
operator|==
literal|0
operator|&&
name|lflag
operator|&&
name|argc
operator|>
literal|1
condition|)
name|print_list
argument_list|(
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
literal|"(totals)"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|exit
argument_list|(
name|exit_value
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* maybe print a warning */
end_comment

begin_function
name|void
name|maybe_warn
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
if|if
condition|(
name|qflag
operator|==
literal|0
condition|)
block|{
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vwarn
argument_list|(
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|exit_value
operator|==
literal|0
condition|)
name|exit_value
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ... without an errno. */
end_comment

begin_function
name|void
name|maybe_warnx
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
if|if
condition|(
name|qflag
operator|==
literal|0
condition|)
block|{
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vwarnx
argument_list|(
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|exit_value
operator|==
literal|0
condition|)
name|exit_value
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* maybe print an error */
end_comment

begin_function
name|void
name|maybe_err
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
if|if
condition|(
name|qflag
operator|==
literal|0
condition|)
block|{
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vwarn
argument_list|(
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|NO_BZIP2_SUPPORT
end_ifndef

begin_comment
comment|/* ... without an errno. */
end_comment

begin_function
name|void
name|maybe_errx
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
if|if
condition|(
name|qflag
operator|==
literal|0
condition|)
block|{
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vwarnx
argument_list|(
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SMALL
end_ifndef

begin_comment
comment|/* split up $GZIP and prepend it to the argument list */
end_comment

begin_function
specifier|static
name|void
name|prepend_gzip
parameter_list|(
name|char
modifier|*
name|gzip
parameter_list|,
name|int
modifier|*
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
modifier|*
name|nargv
decl_stmt|,
modifier|*
modifier|*
name|ac
decl_stmt|;
name|int
name|nenvarg
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|;
comment|/* scan how many arguments there are */
for|for
control|(
name|s
operator|=
name|gzip
init|;
condition|;
control|)
block|{
while|while
condition|(
operator|*
name|s
operator|==
literal|' '
operator|||
operator|*
name|s
operator|==
literal|'\t'
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|0
condition|)
goto|goto
name|count_done
goto|;
name|nenvarg
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|!=
literal|' '
operator|&&
operator|*
name|s
operator|!=
literal|'\t'
condition|)
if|if
condition|(
operator|*
name|s
operator|++
operator|==
literal|0
condition|)
goto|goto
name|count_done
goto|;
block|}
name|count_done
label|:
comment|/* punt early */
if|if
condition|(
name|nenvarg
operator|==
literal|0
condition|)
return|return;
operator|*
name|argc
operator|+=
name|nenvarg
expr_stmt|;
name|ac
operator|=
operator|*
name|argv
expr_stmt|;
name|nargv
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|malloc
argument_list|(
operator|(
operator|*
name|argc
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nargv
operator|==
name|NULL
condition|)
name|maybe_err
argument_list|(
literal|"malloc"
argument_list|)
expr_stmt|;
comment|/* stash this away */
operator|*
name|argv
operator|=
name|nargv
expr_stmt|;
comment|/* copy the program name first */
name|i
operator|=
literal|0
expr_stmt|;
name|nargv
index|[
name|i
operator|++
index|]
operator|=
operator|*
operator|(
name|ac
operator|++
operator|)
expr_stmt|;
comment|/* take a copy of $GZIP and add it to the array */
name|s
operator|=
name|strdup
argument_list|(
name|gzip
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
name|maybe_err
argument_list|(
literal|"strdup"
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* Skip whitespaces. */
while|while
condition|(
operator|*
name|s
operator|==
literal|' '
operator|||
operator|*
name|s
operator|==
literal|'\t'
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|0
condition|)
goto|goto
name|copy_done
goto|;
name|nargv
index|[
name|i
operator|++
index|]
operator|=
name|s
expr_stmt|;
comment|/* Find the end of this argument. */
while|while
condition|(
operator|*
name|s
operator|!=
literal|' '
operator|&&
operator|*
name|s
operator|!=
literal|'\t'
condition|)
if|if
condition|(
operator|*
name|s
operator|++
operator|==
literal|0
condition|)
comment|/* Argument followed by NUL. */
goto|goto
name|copy_done
goto|;
comment|/* Terminate by overwriting ' ' or '\t' with NUL. */
operator|*
name|s
operator|++
operator|=
literal|0
expr_stmt|;
block|}
name|copy_done
label|:
comment|/* copy the original arguments and a NULL */
while|while
condition|(
operator|*
name|ac
condition|)
name|nargv
index|[
name|i
operator|++
index|]
operator|=
operator|*
operator|(
name|ac
operator|++
operator|)
expr_stmt|;
name|nargv
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* compress input to output. Return bytes read, -1 on error */
end_comment

begin_function
specifier|static
name|off_t
name|gz_compress
parameter_list|(
name|int
name|in
parameter_list|,
name|int
name|out
parameter_list|,
name|off_t
modifier|*
name|gsizep
parameter_list|,
specifier|const
name|char
modifier|*
name|origname
parameter_list|,
name|uint32_t
name|mtime
parameter_list|)
block|{
name|z_stream
name|z
decl_stmt|;
name|char
modifier|*
name|outbufp
decl_stmt|,
modifier|*
name|inbufp
decl_stmt|;
name|off_t
name|in_tot
init|=
literal|0
decl_stmt|,
name|out_tot
init|=
literal|0
decl_stmt|;
name|ssize_t
name|in_size
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|;
name|uLong
name|crc
decl_stmt|;
ifdef|#
directive|ifdef
name|SMALL
specifier|static
name|char
name|header
index|[]
init|=
block|{
name|GZIP_MAGIC0
block|,
name|GZIP_MAGIC1
block|,
name|Z_DEFLATED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|OS_CODE
block|}
decl_stmt|;
endif|#
directive|endif
name|outbufp
operator|=
name|malloc
argument_list|(
name|BUFLEN
argument_list|)
expr_stmt|;
name|inbufp
operator|=
name|malloc
argument_list|(
name|BUFLEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|outbufp
operator|==
name|NULL
operator|||
name|inbufp
operator|==
name|NULL
condition|)
block|{
name|maybe_err
argument_list|(
literal|"malloc failed"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|memset
argument_list|(
operator|&
name|z
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|z
argument_list|)
expr_stmt|;
name|z
operator|.
name|zalloc
operator|=
name|Z_NULL
expr_stmt|;
name|z
operator|.
name|zfree
operator|=
name|Z_NULL
expr_stmt|;
name|z
operator|.
name|opaque
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|SMALL
name|memcpy
argument_list|(
name|outbufp
argument_list|,
name|header
argument_list|,
sizeof|sizeof
name|header
argument_list|)
expr_stmt|;
name|i
operator|=
sizeof|sizeof
name|header
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|nflag
operator|!=
literal|0
condition|)
block|{
name|mtime
operator|=
literal|0
expr_stmt|;
name|origname
operator|=
literal|""
expr_stmt|;
block|}
name|i
operator|=
name|snprintf
argument_list|(
name|outbufp
argument_list|,
name|BUFLEN
argument_list|,
literal|"%c%c%c%c%c%c%c%c%c%c%s"
argument_list|,
name|GZIP_MAGIC0
argument_list|,
name|GZIP_MAGIC1
argument_list|,
name|Z_DEFLATED
argument_list|,
operator|*
name|origname
condition|?
name|ORIG_NAME
else|:
literal|0
argument_list|,
name|mtime
operator|&
literal|0xff
argument_list|,
operator|(
name|mtime
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|,
operator|(
name|mtime
operator|>>
literal|16
operator|)
operator|&
literal|0xff
argument_list|,
operator|(
name|mtime
operator|>>
literal|24
operator|)
operator|&
literal|0xff
argument_list|,
name|numflag
operator|==
literal|1
condition|?
literal|4
else|:
name|numflag
operator|==
literal|9
condition|?
literal|2
else|:
literal|0
argument_list|,
name|OS_CODE
argument_list|,
name|origname
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|BUFLEN
condition|)
comment|/* this need PATH_MAX> BUFLEN ... */
name|maybe_err
argument_list|(
literal|"snprintf"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|origname
condition|)
name|i
operator|++
expr_stmt|;
endif|#
directive|endif
name|z
operator|.
name|next_out
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|outbufp
operator|+
name|i
expr_stmt|;
name|z
operator|.
name|avail_out
operator|=
name|BUFLEN
operator|-
name|i
expr_stmt|;
name|error
operator|=
name|deflateInit2
argument_list|(
operator|&
name|z
argument_list|,
name|numflag
argument_list|,
name|Z_DEFLATED
argument_list|,
operator|(
operator|-
name|MAX_WBITS
operator|)
argument_list|,
literal|8
argument_list|,
name|Z_DEFAULT_STRATEGY
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|Z_OK
condition|)
block|{
name|maybe_warnx
argument_list|(
literal|"deflateInit2 failed"
argument_list|)
expr_stmt|;
name|in_tot
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|crc
operator|=
name|crc32
argument_list|(
literal|0L
argument_list|,
name|Z_NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|z
operator|.
name|avail_out
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|write
argument_list|(
name|out
argument_list|,
name|outbufp
argument_list|,
name|BUFLEN
argument_list|)
operator|!=
name|BUFLEN
condition|)
block|{
name|maybe_warn
argument_list|(
literal|"write"
argument_list|)
expr_stmt|;
name|out_tot
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|out_tot
operator|+=
name|BUFLEN
expr_stmt|;
name|z
operator|.
name|next_out
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|outbufp
expr_stmt|;
name|z
operator|.
name|avail_out
operator|=
name|BUFLEN
expr_stmt|;
block|}
if|if
condition|(
name|z
operator|.
name|avail_in
operator|==
literal|0
condition|)
block|{
name|in_size
operator|=
name|read
argument_list|(
name|in
argument_list|,
name|inbufp
argument_list|,
name|BUFLEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|in_size
operator|<
literal|0
condition|)
block|{
name|maybe_warn
argument_list|(
literal|"read"
argument_list|)
expr_stmt|;
name|in_tot
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|in_size
operator|==
literal|0
condition|)
break|break;
name|crc
operator|=
name|crc32
argument_list|(
name|crc
argument_list|,
operator|(
specifier|const
name|Bytef
operator|*
operator|)
name|inbufp
argument_list|,
operator|(
name|unsigned
operator|)
name|in_size
argument_list|)
expr_stmt|;
name|in_tot
operator|+=
name|in_size
expr_stmt|;
name|z
operator|.
name|next_in
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|inbufp
expr_stmt|;
name|z
operator|.
name|avail_in
operator|=
name|in_size
expr_stmt|;
block|}
name|error
operator|=
name|deflate
argument_list|(
operator|&
name|z
argument_list|,
name|Z_NO_FLUSH
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|Z_OK
operator|&&
name|error
operator|!=
name|Z_STREAM_END
condition|)
block|{
name|maybe_warnx
argument_list|(
literal|"deflate failed"
argument_list|)
expr_stmt|;
name|in_tot
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
comment|/* clean up */
for|for
control|(
init|;
condition|;
control|)
block|{
name|size_t
name|len
decl_stmt|;
name|ssize_t
name|w
decl_stmt|;
name|error
operator|=
name|deflate
argument_list|(
operator|&
name|z
argument_list|,
name|Z_FINISH
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|Z_OK
operator|&&
name|error
operator|!=
name|Z_STREAM_END
condition|)
block|{
name|maybe_warnx
argument_list|(
literal|"deflate failed"
argument_list|)
expr_stmt|;
name|in_tot
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|len
operator|=
operator|(
name|char
operator|*
operator|)
name|z
operator|.
name|next_out
operator|-
name|outbufp
expr_stmt|;
name|w
operator|=
name|write
argument_list|(
name|out
argument_list|,
name|outbufp
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
operator|-
literal|1
operator|||
operator|(
name|size_t
operator|)
name|w
operator|!=
name|len
condition|)
block|{
name|maybe_warn
argument_list|(
literal|"write"
argument_list|)
expr_stmt|;
name|out_tot
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|out_tot
operator|+=
name|len
expr_stmt|;
name|z
operator|.
name|next_out
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|outbufp
expr_stmt|;
name|z
operator|.
name|avail_out
operator|=
name|BUFLEN
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|Z_STREAM_END
condition|)
break|break;
block|}
if|if
condition|(
name|deflateEnd
argument_list|(
operator|&
name|z
argument_list|)
operator|!=
name|Z_OK
condition|)
block|{
name|maybe_warnx
argument_list|(
literal|"deflateEnd failed"
argument_list|)
expr_stmt|;
name|in_tot
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|i
operator|=
name|snprintf
argument_list|(
name|outbufp
argument_list|,
name|BUFLEN
argument_list|,
literal|"%c%c%c%c%c%c%c%c"
argument_list|,
operator|(
name|int
operator|)
name|crc
operator|&
literal|0xff
argument_list|,
call|(
name|int
call|)
argument_list|(
name|crc
operator|>>
literal|8
argument_list|)
operator|&
literal|0xff
argument_list|,
call|(
name|int
call|)
argument_list|(
name|crc
operator|>>
literal|16
argument_list|)
operator|&
literal|0xff
argument_list|,
call|(
name|int
call|)
argument_list|(
name|crc
operator|>>
literal|24
argument_list|)
operator|&
literal|0xff
argument_list|,
operator|(
name|int
operator|)
name|in_tot
operator|&
literal|0xff
argument_list|,
call|(
name|int
call|)
argument_list|(
name|in_tot
operator|>>
literal|8
argument_list|)
operator|&
literal|0xff
argument_list|,
call|(
name|int
call|)
argument_list|(
name|in_tot
operator|>>
literal|16
argument_list|)
operator|&
literal|0xff
argument_list|,
call|(
name|int
call|)
argument_list|(
name|in_tot
operator|>>
literal|24
argument_list|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|8
condition|)
name|maybe_err
argument_list|(
literal|"snprintf"
argument_list|)
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|out
argument_list|,
name|outbufp
argument_list|,
name|i
argument_list|)
operator|!=
name|i
condition|)
block|{
name|maybe_warn
argument_list|(
literal|"write"
argument_list|)
expr_stmt|;
name|in_tot
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|out_tot
operator|+=
name|i
expr_stmt|;
name|out
label|:
if|if
condition|(
name|inbufp
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|inbufp
argument_list|)
expr_stmt|;
if|if
condition|(
name|outbufp
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|outbufp
argument_list|)
expr_stmt|;
if|if
condition|(
name|gsizep
condition|)
operator|*
name|gsizep
operator|=
name|out_tot
expr_stmt|;
return|return
name|in_tot
return|;
block|}
end_function

begin_comment
comment|/*  * uncompress input to output then close the input.  return the  * uncompressed size written, and put the compressed sized read  * into `*gsizep'.  */
end_comment

begin_function
specifier|static
name|off_t
name|gz_uncompress
parameter_list|(
name|int
name|in
parameter_list|,
name|int
name|out
parameter_list|,
name|char
modifier|*
name|pre
parameter_list|,
name|size_t
name|prelen
parameter_list|,
name|off_t
modifier|*
name|gsizep
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|z_stream
name|z
decl_stmt|;
name|char
modifier|*
name|outbufp
decl_stmt|,
modifier|*
name|inbufp
decl_stmt|;
name|off_t
name|out_tot
init|=
operator|-
literal|1
decl_stmt|,
name|in_tot
init|=
literal|0
decl_stmt|;
name|uint32_t
name|out_sub_tot
init|=
literal|0
decl_stmt|;
enum|enum
block|{
name|GZSTATE_MAGIC0
block|,
name|GZSTATE_MAGIC1
block|,
name|GZSTATE_METHOD
block|,
name|GZSTATE_FLAGS
block|,
name|GZSTATE_SKIPPING
block|,
name|GZSTATE_EXTRA
block|,
name|GZSTATE_EXTRA2
block|,
name|GZSTATE_EXTRA3
block|,
name|GZSTATE_ORIGNAME
block|,
name|GZSTATE_COMMENT
block|,
name|GZSTATE_HEAD_CRC1
block|,
name|GZSTATE_HEAD_CRC2
block|,
name|GZSTATE_INIT
block|,
name|GZSTATE_READ
block|,
name|GZSTATE_CRC
block|,
name|GZSTATE_LEN
block|, 	}
name|state
init|=
name|GZSTATE_MAGIC0
enum|;
name|int
name|flags
init|=
literal|0
decl_stmt|,
name|skip_count
init|=
literal|0
decl_stmt|;
name|int
name|error
init|=
name|Z_STREAM_ERROR
decl_stmt|,
name|done_reading
init|=
literal|0
decl_stmt|;
name|uLong
name|crc
init|=
literal|0
decl_stmt|;
name|ssize_t
name|wr
decl_stmt|;
name|int
name|needmore
init|=
literal|0
decl_stmt|;
define|#
directive|define
name|ADVANCE
parameter_list|()
value|{ z.next_in++; z.avail_in--; }
if|if
condition|(
operator|(
name|outbufp
operator|=
name|malloc
argument_list|(
name|BUFLEN
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|maybe_err
argument_list|(
literal|"malloc failed"
argument_list|)
expr_stmt|;
goto|goto
name|out2
goto|;
block|}
if|if
condition|(
operator|(
name|inbufp
operator|=
name|malloc
argument_list|(
name|BUFLEN
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|maybe_err
argument_list|(
literal|"malloc failed"
argument_list|)
expr_stmt|;
goto|goto
name|out1
goto|;
block|}
name|memset
argument_list|(
operator|&
name|z
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|z
argument_list|)
expr_stmt|;
name|z
operator|.
name|avail_in
operator|=
name|prelen
expr_stmt|;
name|z
operator|.
name|next_in
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|pre
expr_stmt|;
name|z
operator|.
name|avail_out
operator|=
name|BUFLEN
expr_stmt|;
name|z
operator|.
name|next_out
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|outbufp
expr_stmt|;
name|z
operator|.
name|zalloc
operator|=
name|NULL
expr_stmt|;
name|z
operator|.
name|zfree
operator|=
name|NULL
expr_stmt|;
name|z
operator|.
name|opaque
operator|=
literal|0
expr_stmt|;
name|in_tot
operator|=
name|prelen
expr_stmt|;
name|out_tot
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|z
operator|.
name|avail_in
operator|==
literal|0
operator|||
name|needmore
operator|)
operator|&&
name|done_reading
operator|==
literal|0
condition|)
block|{
name|ssize_t
name|in_size
decl_stmt|;
if|if
condition|(
name|z
operator|.
name|avail_in
operator|>
literal|0
condition|)
block|{
name|memmove
argument_list|(
name|inbufp
argument_list|,
name|z
operator|.
name|next_in
argument_list|,
name|z
operator|.
name|avail_in
argument_list|)
expr_stmt|;
block|}
name|z
operator|.
name|next_in
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|inbufp
expr_stmt|;
name|in_size
operator|=
name|read
argument_list|(
name|in
argument_list|,
name|z
operator|.
name|next_in
operator|+
name|z
operator|.
name|avail_in
argument_list|,
name|BUFLEN
operator|-
name|z
operator|.
name|avail_in
argument_list|)
expr_stmt|;
if|if
condition|(
name|in_size
operator|==
operator|-
literal|1
condition|)
block|{
name|maybe_warn
argument_list|(
literal|"failed to read stdin"
argument_list|)
expr_stmt|;
goto|goto
name|stop_and_fail
goto|;
block|}
elseif|else
if|if
condition|(
name|in_size
operator|==
literal|0
condition|)
block|{
name|done_reading
operator|=
literal|1
expr_stmt|;
block|}
name|z
operator|.
name|avail_in
operator|+=
name|in_size
expr_stmt|;
name|needmore
operator|=
literal|0
expr_stmt|;
name|in_tot
operator|+=
name|in_size
expr_stmt|;
block|}
if|if
condition|(
name|z
operator|.
name|avail_in
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|done_reading
operator|&&
name|state
operator|!=
name|GZSTATE_MAGIC0
condition|)
block|{
name|maybe_warnx
argument_list|(
literal|"%s: unexpected end of file"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
goto|goto
name|stop_and_fail
goto|;
block|}
goto|goto
name|stop
goto|;
block|}
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|GZSTATE_MAGIC0
case|:
if|if
condition|(
operator|*
name|z
operator|.
name|next_in
operator|!=
name|GZIP_MAGIC0
condition|)
block|{
if|if
condition|(
name|in_tot
operator|>
literal|0
condition|)
block|{
name|maybe_warnx
argument_list|(
literal|"%s: trailing garbage "
literal|"ignored"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
goto|goto
name|stop
goto|;
block|}
name|maybe_warnx
argument_list|(
literal|"input not gziped (MAGIC0)"
argument_list|)
expr_stmt|;
goto|goto
name|stop_and_fail
goto|;
block|}
name|ADVANCE
argument_list|()
expr_stmt|;
name|state
operator|++
expr_stmt|;
name|out_sub_tot
operator|=
literal|0
expr_stmt|;
name|crc
operator|=
name|crc32
argument_list|(
literal|0L
argument_list|,
name|Z_NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|GZSTATE_MAGIC1
case|:
if|if
condition|(
operator|*
name|z
operator|.
name|next_in
operator|!=
name|GZIP_MAGIC1
operator|&&
operator|*
name|z
operator|.
name|next_in
operator|!=
name|GZIP_OMAGIC1
condition|)
block|{
name|maybe_warnx
argument_list|(
literal|"input not gziped (MAGIC1)"
argument_list|)
expr_stmt|;
goto|goto
name|stop_and_fail
goto|;
block|}
name|ADVANCE
argument_list|()
expr_stmt|;
name|state
operator|++
expr_stmt|;
break|break;
case|case
name|GZSTATE_METHOD
case|:
if|if
condition|(
operator|*
name|z
operator|.
name|next_in
operator|!=
name|Z_DEFLATED
condition|)
block|{
name|maybe_warnx
argument_list|(
literal|"unknown compression method"
argument_list|)
expr_stmt|;
goto|goto
name|stop_and_fail
goto|;
block|}
name|ADVANCE
argument_list|()
expr_stmt|;
name|state
operator|++
expr_stmt|;
break|break;
case|case
name|GZSTATE_FLAGS
case|:
name|flags
operator|=
operator|*
name|z
operator|.
name|next_in
expr_stmt|;
name|ADVANCE
argument_list|()
expr_stmt|;
name|skip_count
operator|=
literal|6
expr_stmt|;
name|state
operator|++
expr_stmt|;
break|break;
case|case
name|GZSTATE_SKIPPING
case|:
if|if
condition|(
name|skip_count
operator|>
literal|0
condition|)
block|{
name|skip_count
operator|--
expr_stmt|;
name|ADVANCE
argument_list|()
expr_stmt|;
block|}
else|else
name|state
operator|++
expr_stmt|;
break|break;
case|case
name|GZSTATE_EXTRA
case|:
if|if
condition|(
operator|(
name|flags
operator|&
name|EXTRA_FIELD
operator|)
operator|==
literal|0
condition|)
block|{
name|state
operator|=
name|GZSTATE_ORIGNAME
expr_stmt|;
break|break;
block|}
name|skip_count
operator|=
operator|*
name|z
operator|.
name|next_in
expr_stmt|;
name|ADVANCE
argument_list|()
expr_stmt|;
name|state
operator|++
expr_stmt|;
break|break;
case|case
name|GZSTATE_EXTRA2
case|:
name|skip_count
operator||=
operator|(
operator|(
operator|*
name|z
operator|.
name|next_in
operator|)
operator|<<
literal|8
operator|)
expr_stmt|;
name|ADVANCE
argument_list|()
expr_stmt|;
name|state
operator|++
expr_stmt|;
break|break;
case|case
name|GZSTATE_EXTRA3
case|:
if|if
condition|(
name|skip_count
operator|>
literal|0
condition|)
block|{
name|skip_count
operator|--
expr_stmt|;
name|ADVANCE
argument_list|()
expr_stmt|;
block|}
else|else
name|state
operator|++
expr_stmt|;
break|break;
case|case
name|GZSTATE_ORIGNAME
case|:
if|if
condition|(
operator|(
name|flags
operator|&
name|ORIG_NAME
operator|)
operator|==
literal|0
condition|)
block|{
name|state
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|*
name|z
operator|.
name|next_in
operator|==
literal|0
condition|)
name|state
operator|++
expr_stmt|;
name|ADVANCE
argument_list|()
expr_stmt|;
break|break;
case|case
name|GZSTATE_COMMENT
case|:
if|if
condition|(
operator|(
name|flags
operator|&
name|COMMENT
operator|)
operator|==
literal|0
condition|)
block|{
name|state
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|*
name|z
operator|.
name|next_in
operator|==
literal|0
condition|)
name|state
operator|++
expr_stmt|;
name|ADVANCE
argument_list|()
expr_stmt|;
break|break;
case|case
name|GZSTATE_HEAD_CRC1
case|:
if|if
condition|(
name|flags
operator|&
name|HEAD_CRC
condition|)
name|skip_count
operator|=
literal|2
expr_stmt|;
else|else
name|skip_count
operator|=
literal|0
expr_stmt|;
name|state
operator|++
expr_stmt|;
break|break;
case|case
name|GZSTATE_HEAD_CRC2
case|:
if|if
condition|(
name|skip_count
operator|>
literal|0
condition|)
block|{
name|skip_count
operator|--
expr_stmt|;
name|ADVANCE
argument_list|()
expr_stmt|;
block|}
else|else
name|state
operator|++
expr_stmt|;
break|break;
case|case
name|GZSTATE_INIT
case|:
if|if
condition|(
name|inflateInit2
argument_list|(
operator|&
name|z
argument_list|,
operator|-
name|MAX_WBITS
argument_list|)
operator|!=
name|Z_OK
condition|)
block|{
name|maybe_warnx
argument_list|(
literal|"failed to inflateInit"
argument_list|)
expr_stmt|;
goto|goto
name|stop_and_fail
goto|;
block|}
name|state
operator|++
expr_stmt|;
break|break;
case|case
name|GZSTATE_READ
case|:
name|error
operator|=
name|inflate
argument_list|(
operator|&
name|z
argument_list|,
name|Z_FINISH
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|error
condition|)
block|{
comment|/* Z_BUF_ERROR goes with Z_FINISH... */
case|case
name|Z_BUF_ERROR
case|:
case|case
name|Z_STREAM_END
case|:
case|case
name|Z_OK
case|:
break|break;
case|case
name|Z_NEED_DICT
case|:
name|maybe_warnx
argument_list|(
literal|"Z_NEED_DICT error"
argument_list|)
expr_stmt|;
goto|goto
name|stop_and_fail
goto|;
case|case
name|Z_DATA_ERROR
case|:
name|maybe_warnx
argument_list|(
literal|"data stream error"
argument_list|)
expr_stmt|;
goto|goto
name|stop_and_fail
goto|;
case|case
name|Z_STREAM_ERROR
case|:
name|maybe_warnx
argument_list|(
literal|"internal stream error"
argument_list|)
expr_stmt|;
goto|goto
name|stop_and_fail
goto|;
case|case
name|Z_MEM_ERROR
case|:
name|maybe_warnx
argument_list|(
literal|"memory allocation error"
argument_list|)
expr_stmt|;
goto|goto
name|stop_and_fail
goto|;
default|default:
name|maybe_warn
argument_list|(
literal|"unknown error from inflate(): %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
name|wr
operator|=
name|BUFLEN
operator|-
name|z
operator|.
name|avail_out
expr_stmt|;
if|if
condition|(
name|wr
operator|!=
literal|0
condition|)
block|{
name|crc
operator|=
name|crc32
argument_list|(
name|crc
argument_list|,
operator|(
specifier|const
name|Bytef
operator|*
operator|)
name|outbufp
argument_list|,
operator|(
name|unsigned
operator|)
name|wr
argument_list|)
expr_stmt|;
if|if
condition|(
ifndef|#
directive|ifndef
name|SMALL
comment|/* don't write anything with -t */
name|tflag
operator|==
literal|0
operator|&&
endif|#
directive|endif
name|write
argument_list|(
name|out
argument_list|,
name|outbufp
argument_list|,
name|wr
argument_list|)
operator|!=
name|wr
condition|)
block|{
name|maybe_warn
argument_list|(
literal|"error writing to output"
argument_list|)
expr_stmt|;
goto|goto
name|stop_and_fail
goto|;
block|}
name|out_tot
operator|+=
name|wr
expr_stmt|;
name|out_sub_tot
operator|+=
name|wr
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
name|Z_STREAM_END
condition|)
block|{
name|inflateEnd
argument_list|(
operator|&
name|z
argument_list|)
expr_stmt|;
name|state
operator|++
expr_stmt|;
block|}
name|z
operator|.
name|next_out
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|outbufp
expr_stmt|;
name|z
operator|.
name|avail_out
operator|=
name|BUFLEN
expr_stmt|;
break|break;
case|case
name|GZSTATE_CRC
case|:
block|{
name|uLong
name|origcrc
decl_stmt|;
if|if
condition|(
name|z
operator|.
name|avail_in
operator|<
literal|4
condition|)
block|{
if|if
condition|(
operator|!
name|done_reading
condition|)
block|{
name|needmore
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
name|maybe_warnx
argument_list|(
literal|"truncated input"
argument_list|)
expr_stmt|;
goto|goto
name|stop_and_fail
goto|;
block|}
name|origcrc
operator|=
operator|(
operator|(
name|unsigned
operator|)
name|z
operator|.
name|next_in
index|[
literal|0
index|]
operator|&
literal|0xff
operator|)
operator||
operator|(
operator|(
name|unsigned
operator|)
name|z
operator|.
name|next_in
index|[
literal|1
index|]
operator|&
literal|0xff
operator|)
operator|<<
literal|8
operator||
operator|(
operator|(
name|unsigned
operator|)
name|z
operator|.
name|next_in
index|[
literal|2
index|]
operator|&
literal|0xff
operator|)
operator|<<
literal|16
operator||
operator|(
operator|(
name|unsigned
operator|)
name|z
operator|.
name|next_in
index|[
literal|3
index|]
operator|&
literal|0xff
operator|)
operator|<<
literal|24
expr_stmt|;
if|if
condition|(
name|origcrc
operator|!=
name|crc
condition|)
block|{
name|maybe_warnx
argument_list|(
literal|"invalid compressed"
literal|" data--crc error"
argument_list|)
expr_stmt|;
goto|goto
name|stop_and_fail
goto|;
block|}
block|}
name|z
operator|.
name|avail_in
operator|-=
literal|4
expr_stmt|;
name|z
operator|.
name|next_in
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
operator|!
name|z
operator|.
name|avail_in
operator|&&
name|done_reading
condition|)
block|{
goto|goto
name|stop
goto|;
block|}
name|state
operator|++
expr_stmt|;
break|break;
case|case
name|GZSTATE_LEN
case|:
block|{
name|uLong
name|origlen
decl_stmt|;
if|if
condition|(
name|z
operator|.
name|avail_in
operator|<
literal|4
condition|)
block|{
if|if
condition|(
operator|!
name|done_reading
condition|)
block|{
name|needmore
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
name|maybe_warnx
argument_list|(
literal|"truncated input"
argument_list|)
expr_stmt|;
goto|goto
name|stop_and_fail
goto|;
block|}
name|origlen
operator|=
operator|(
operator|(
name|unsigned
operator|)
name|z
operator|.
name|next_in
index|[
literal|0
index|]
operator|&
literal|0xff
operator|)
operator||
operator|(
operator|(
name|unsigned
operator|)
name|z
operator|.
name|next_in
index|[
literal|1
index|]
operator|&
literal|0xff
operator|)
operator|<<
literal|8
operator||
operator|(
operator|(
name|unsigned
operator|)
name|z
operator|.
name|next_in
index|[
literal|2
index|]
operator|&
literal|0xff
operator|)
operator|<<
literal|16
operator||
operator|(
operator|(
name|unsigned
operator|)
name|z
operator|.
name|next_in
index|[
literal|3
index|]
operator|&
literal|0xff
operator|)
operator|<<
literal|24
expr_stmt|;
if|if
condition|(
name|origlen
operator|!=
name|out_sub_tot
condition|)
block|{
name|maybe_warnx
argument_list|(
literal|"invalid compressed"
literal|" data--length error"
argument_list|)
expr_stmt|;
goto|goto
name|stop_and_fail
goto|;
block|}
block|}
name|z
operator|.
name|avail_in
operator|-=
literal|4
expr_stmt|;
name|z
operator|.
name|next_in
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|error
operator|<
literal|0
condition|)
block|{
name|maybe_warnx
argument_list|(
literal|"decompression error"
argument_list|)
expr_stmt|;
goto|goto
name|stop_and_fail
goto|;
block|}
name|state
operator|=
name|GZSTATE_MAGIC0
expr_stmt|;
break|break;
block|}
continue|continue;
name|stop_and_fail
label|:
name|out_tot
operator|=
operator|-
literal|1
expr_stmt|;
name|stop
label|:
break|break;
block|}
if|if
condition|(
name|state
operator|>
name|GZSTATE_INIT
condition|)
name|inflateEnd
argument_list|(
operator|&
name|z
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|inbufp
argument_list|)
expr_stmt|;
name|out1
label|:
name|free
argument_list|(
name|outbufp
argument_list|)
expr_stmt|;
name|out2
label|:
if|if
condition|(
name|gsizep
condition|)
operator|*
name|gsizep
operator|=
name|in_tot
expr_stmt|;
return|return
operator|(
name|out_tot
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|SMALL
end_ifndef

begin_comment
comment|/*  * set the owner, mode, flags& utimes using the given file descriptor.  * file is only used in possible warning messages.  */
end_comment

begin_function
specifier|static
name|void
name|copymodes
parameter_list|(
name|int
name|fd
parameter_list|,
specifier|const
name|struct
name|stat
modifier|*
name|sbp
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|)
block|{
name|struct
name|timeval
name|times
index|[
literal|2
index|]
decl_stmt|;
name|struct
name|stat
name|sb
decl_stmt|;
comment|/* 	 * If we have no info on the input, give this file some 	 * default values and return.. 	 */
if|if
condition|(
name|sbp
operator|==
name|NULL
condition|)
block|{
name|mode_t
name|mask
init|=
name|umask
argument_list|(
literal|022
argument_list|)
decl_stmt|;
operator|(
name|void
operator|)
name|fchmod
argument_list|(
name|fd
argument_list|,
name|DEFFILEMODE
operator|&
operator|~
name|mask
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|umask
argument_list|(
name|mask
argument_list|)
expr_stmt|;
return|return;
block|}
name|sb
operator|=
operator|*
name|sbp
expr_stmt|;
comment|/* if the chown fails, remove set-id bits as-per compress(1) */
if|if
condition|(
name|fchown
argument_list|(
name|fd
argument_list|,
name|sb
operator|.
name|st_uid
argument_list|,
name|sb
operator|.
name|st_gid
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EPERM
condition|)
name|maybe_warn
argument_list|(
literal|"couldn't fchown: %s"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|sb
operator|.
name|st_mode
operator|&=
operator|~
operator|(
name|S_ISUID
operator||
name|S_ISGID
operator|)
expr_stmt|;
block|}
comment|/* we only allow set-id and the 9 normal permission bits */
name|sb
operator|.
name|st_mode
operator|&=
name|S_ISUID
operator||
name|S_ISGID
operator||
name|S_IRWXU
operator||
name|S_IRWXG
operator||
name|S_IRWXO
expr_stmt|;
if|if
condition|(
name|fchmod
argument_list|(
name|fd
argument_list|,
name|sb
operator|.
name|st_mode
argument_list|)
operator|<
literal|0
condition|)
name|maybe_warn
argument_list|(
literal|"couldn't fchmod: %s"
argument_list|,
name|file
argument_list|)
expr_stmt|;
comment|/* only try flags if they exist already */
if|if
condition|(
name|sb
operator|.
name|st_flags
operator|!=
literal|0
operator|&&
name|fchflags
argument_list|(
name|fd
argument_list|,
name|sb
operator|.
name|st_flags
argument_list|)
operator|<
literal|0
condition|)
name|maybe_warn
argument_list|(
literal|"couldn't fchflags: %s"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|TIMESPEC_TO_TIMEVAL
argument_list|(
operator|&
name|times
index|[
literal|0
index|]
argument_list|,
operator|&
name|sb
operator|.
name|st_atimespec
argument_list|)
expr_stmt|;
name|TIMESPEC_TO_TIMEVAL
argument_list|(
operator|&
name|times
index|[
literal|1
index|]
argument_list|,
operator|&
name|sb
operator|.
name|st_mtimespec
argument_list|)
expr_stmt|;
if|if
condition|(
name|futimes
argument_list|(
name|fd
argument_list|,
name|times
argument_list|)
operator|<
literal|0
condition|)
name|maybe_warn
argument_list|(
literal|"couldn't utimes: %s"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* what sort of file is this? */
end_comment

begin_function
specifier|static
name|enum
name|filetype
name|file_gettype
parameter_list|(
name|u_char
modifier|*
name|buf
parameter_list|)
block|{
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
name|GZIP_MAGIC0
operator|&&
operator|(
name|buf
index|[
literal|1
index|]
operator|==
name|GZIP_MAGIC1
operator|||
name|buf
index|[
literal|1
index|]
operator|==
name|GZIP_OMAGIC1
operator|)
condition|)
return|return
name|FT_GZIP
return|;
elseif|else
ifndef|#
directive|ifndef
name|NO_BZIP2_SUPPORT
if|if
condition|(
name|memcmp
argument_list|(
name|buf
argument_list|,
name|BZIP2_MAGIC
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
operator|&&
name|buf
index|[
literal|3
index|]
operator|>=
literal|'0'
operator|&&
name|buf
index|[
literal|3
index|]
operator|<=
literal|'9'
condition|)
return|return
name|FT_BZIP2
return|;
elseif|else
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NO_COMPRESS_SUPPORT
if|if
condition|(
name|memcmp
argument_list|(
name|buf
argument_list|,
name|Z_MAGIC
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
return|return
name|FT_Z
return|;
else|else
endif|#
directive|endif
return|return
name|FT_UNKNOWN
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|SMALL
end_ifndef

begin_comment
comment|/* check the outfile is OK. */
end_comment

begin_function
specifier|static
name|int
name|check_outfile
parameter_list|(
specifier|const
name|char
modifier|*
name|outfile
parameter_list|)
block|{
name|struct
name|stat
name|sb
decl_stmt|;
name|int
name|ok
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|lflag
operator|==
literal|0
operator|&&
name|stat
argument_list|(
name|outfile
argument_list|,
operator|&
name|sb
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|fflag
condition|)
name|unlink
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|isatty
argument_list|(
name|STDIN_FILENO
argument_list|)
condition|)
block|{
name|char
name|ans
index|[
literal|10
index|]
init|=
block|{
literal|'n'
block|,
literal|'\0'
block|}
decl_stmt|;
comment|/* default */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s already exists -- do you wish to "
literal|"overwrite (y or n)? "
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fgets
argument_list|(
name|ans
argument_list|,
sizeof|sizeof
argument_list|(
name|ans
argument_list|)
operator|-
literal|1
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
if|if
condition|(
name|ans
index|[
literal|0
index|]
operator|!=
literal|'y'
operator|&&
name|ans
index|[
literal|0
index|]
operator|!=
literal|'Y'
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tnot overwritting\n"
argument_list|)
expr_stmt|;
name|ok
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|unlink
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|maybe_warnx
argument_list|(
literal|"%s already exists -- skipping"
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|ok
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
name|ok
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|unlink_input
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
specifier|const
name|struct
name|stat
modifier|*
name|sb
parameter_list|)
block|{
name|struct
name|stat
name|nsb
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|file
argument_list|,
operator|&
name|nsb
argument_list|)
operator|!=
literal|0
condition|)
comment|/* Must be gone alrady */
return|return;
if|if
condition|(
name|nsb
operator|.
name|st_dev
operator|!=
name|sb
operator|->
name|st_dev
operator|||
name|nsb
operator|.
name|st_ino
operator|!=
name|sb
operator|->
name|st_ino
condition|)
comment|/* Definitely a different file */
return|return;
name|unlink
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
specifier|const
name|suffixes_t
modifier|*
name|check_suffix
parameter_list|(
name|char
modifier|*
name|file
parameter_list|,
name|int
name|xlate
parameter_list|)
block|{
specifier|const
name|suffixes_t
modifier|*
name|s
decl_stmt|;
name|int
name|len
init|=
name|strlen
argument_list|(
name|file
argument_list|)
decl_stmt|;
name|char
modifier|*
name|sp
decl_stmt|;
for|for
control|(
name|s
operator|=
name|suffixes
init|;
name|s
operator|!=
name|suffixes
operator|+
name|NUM_SUFFIXES
condition|;
name|s
operator|++
control|)
block|{
comment|/* if it doesn't fit in "a.suf", don't bother */
if|if
condition|(
name|s
operator|->
name|ziplen
operator|>=
name|len
condition|)
continue|continue;
name|sp
operator|=
name|file
operator|+
name|len
operator|-
name|s
operator|->
name|ziplen
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|s
operator|->
name|zipped
argument_list|,
name|sp
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|xlate
condition|)
name|strcpy
argument_list|(
name|sp
argument_list|,
name|s
operator|->
name|normal
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * compress the given file: create a corresponding .gz file and remove the  * original.  */
end_comment

begin_function
specifier|static
name|off_t
name|file_compress
parameter_list|(
name|char
modifier|*
name|file
parameter_list|,
name|char
modifier|*
name|outfile
parameter_list|,
name|size_t
name|outsize
parameter_list|)
block|{
name|int
name|in
decl_stmt|;
name|int
name|out
decl_stmt|;
name|off_t
name|size
decl_stmt|,
name|insize
decl_stmt|;
ifndef|#
directive|ifndef
name|SMALL
name|struct
name|stat
name|isb
decl_stmt|,
name|osb
decl_stmt|;
specifier|const
name|suffixes_t
modifier|*
name|suff
decl_stmt|;
endif|#
directive|endif
name|in
operator|=
name|open
argument_list|(
name|file
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|in
operator|==
operator|-
literal|1
condition|)
block|{
name|maybe_warn
argument_list|(
literal|"can't open %s"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|cflag
operator|==
literal|0
condition|)
block|{
ifndef|#
directive|ifndef
name|SMALL
if|if
condition|(
name|fstat
argument_list|(
name|in
argument_list|,
operator|&
name|isb
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|isb
operator|.
name|st_nlink
operator|>
literal|1
operator|&&
name|fflag
operator|==
literal|0
condition|)
block|{
name|maybe_warnx
argument_list|(
literal|"%s has %d other link%s -- "
literal|"skipping"
argument_list|,
name|file
argument_list|,
name|isb
operator|.
name|st_nlink
operator|-
literal|1
argument_list|,
name|isb
operator|.
name|st_nlink
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|in
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
if|if
condition|(
name|fflag
operator|==
literal|0
operator|&&
operator|(
name|suff
operator|=
name|check_suffix
argument_list|(
name|file
argument_list|,
literal|0
argument_list|)
operator|)
operator|&&
name|suff
operator|->
name|zipped
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
name|maybe_warnx
argument_list|(
literal|"%s already has %s suffix -- unchanged"
argument_list|,
name|file
argument_list|,
name|suff
operator|->
name|zipped
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|in
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
endif|#
directive|endif
comment|/* Add (usually) .gz to filename */
if|if
condition|(
operator|(
name|size_t
operator|)
name|snprintf
argument_list|(
name|outfile
argument_list|,
name|outsize
argument_list|,
literal|"%s%s"
argument_list|,
name|file
argument_list|,
name|suffixes
index|[
literal|0
index|]
operator|.
name|zipped
argument_list|)
operator|>=
name|outsize
condition|)
name|memcpy
argument_list|(
name|outfile
operator|-
name|suffixes
index|[
literal|0
index|]
operator|.
name|ziplen
operator|-
literal|1
argument_list|,
name|suffixes
index|[
literal|0
index|]
operator|.
name|zipped
argument_list|,
name|suffixes
index|[
literal|0
index|]
operator|.
name|ziplen
operator|+
literal|1
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|SMALL
if|if
condition|(
name|check_outfile
argument_list|(
name|outfile
argument_list|)
operator|==
literal|0
condition|)
block|{
name|close
argument_list|(
name|in
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
endif|#
directive|endif
block|}
if|if
condition|(
name|cflag
operator|==
literal|0
condition|)
block|{
name|out
operator|=
name|open
argument_list|(
name|outfile
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_EXCL
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
if|if
condition|(
name|out
operator|==
operator|-
literal|1
condition|)
block|{
name|maybe_warn
argument_list|(
literal|"could not create output: %s"
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
else|else
name|out
operator|=
name|STDOUT_FILENO
expr_stmt|;
name|insize
operator|=
name|gz_compress
argument_list|(
name|in
argument_list|,
name|out
argument_list|,
operator|&
name|size
argument_list|,
name|basename
argument_list|(
name|file
argument_list|)
argument_list|,
operator|(
name|uint32_t
operator|)
name|isb
operator|.
name|st_mtime
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|in
argument_list|)
expr_stmt|;
comment|/* 	 * If there was an error, insize will be -1. 	 * If we compressed to stdout, just return the size. 	 * Otherwise stat the file and check it is the correct size. 	 * We only blow away the file if we can stat the output and it 	 * has the expected size. 	 */
if|if
condition|(
name|cflag
operator|!=
literal|0
condition|)
return|return
name|insize
operator|==
operator|-
literal|1
condition|?
operator|-
literal|1
else|:
name|size
return|;
ifndef|#
directive|ifndef
name|SMALL
if|if
condition|(
name|fstat
argument_list|(
name|out
argument_list|,
operator|&
name|osb
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|maybe_warn
argument_list|(
literal|"couldn't stat: %s"
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
goto|goto
name|bad_outfile
goto|;
block|}
if|if
condition|(
name|osb
operator|.
name|st_size
operator|!=
name|size
condition|)
block|{
name|maybe_warnx
argument_list|(
literal|"output file: %s wrong size (%"
name|PRIdOFF
literal|" != %"
name|PRIdOFF
literal|"), deleting"
argument_list|,
name|outfile
argument_list|,
name|osb
operator|.
name|st_size
argument_list|,
name|size
argument_list|)
expr_stmt|;
goto|goto
name|bad_outfile
goto|;
block|}
name|copymodes
argument_list|(
name|out
argument_list|,
operator|&
name|isb
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|close
argument_list|(
name|out
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|maybe_warn
argument_list|(
literal|"couldn't close output"
argument_list|)
expr_stmt|;
comment|/* output is good, ok to delete input */
name|unlink_input
argument_list|(
name|file
argument_list|,
operator|&
name|isb
argument_list|)
expr_stmt|;
return|return
name|size
return|;
ifndef|#
directive|ifndef
name|SMALL
name|bad_outfile
label|:
if|if
condition|(
name|close
argument_list|(
name|out
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|maybe_warn
argument_list|(
literal|"couldn't close output"
argument_list|)
expr_stmt|;
name|maybe_warnx
argument_list|(
literal|"leaving original %s"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
return|return
name|size
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* uncompress the given file and remove the original */
end_comment

begin_function
specifier|static
name|off_t
name|file_uncompress
parameter_list|(
name|char
modifier|*
name|file
parameter_list|,
name|char
modifier|*
name|outfile
parameter_list|,
name|size_t
name|outsize
parameter_list|)
block|{
name|struct
name|stat
name|isb
decl_stmt|,
name|osb
decl_stmt|;
name|off_t
name|size
decl_stmt|;
name|ssize_t
name|rbytes
decl_stmt|;
name|unsigned
name|char
name|header1
index|[
literal|4
index|]
decl_stmt|;
name|enum
name|filetype
name|method
decl_stmt|;
name|int
name|rv
decl_stmt|,
name|fd
decl_stmt|,
name|ofd
decl_stmt|,
name|zfd
init|=
operator|-
literal|1
decl_stmt|;
ifndef|#
directive|ifndef
name|SMALL
name|time_t
name|timestamp
init|=
literal|0
decl_stmt|;
name|unsigned
name|char
name|name
index|[
name|PATH_MAX
operator|+
literal|1
index|]
decl_stmt|;
endif|#
directive|endif
comment|/* gather the old name info */
name|fd
operator|=
name|open
argument_list|(
name|file
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|maybe_warn
argument_list|(
literal|"can't open %s"
argument_list|,
name|file
argument_list|)
expr_stmt|;
goto|goto
name|lose
goto|;
block|}
name|strlcpy
argument_list|(
name|outfile
argument_list|,
name|file
argument_list|,
name|outsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|check_suffix
argument_list|(
name|outfile
argument_list|,
literal|1
argument_list|)
operator|==
name|NULL
operator|&&
operator|!
operator|(
name|cflag
operator|||
name|lflag
operator|)
condition|)
block|{
name|maybe_warnx
argument_list|(
literal|"%s: unknown suffix -- ignored"
argument_list|,
name|file
argument_list|)
expr_stmt|;
goto|goto
name|lose
goto|;
block|}
name|rbytes
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|header1
argument_list|,
sizeof|sizeof
name|header1
argument_list|)
expr_stmt|;
if|if
condition|(
name|rbytes
operator|!=
sizeof|sizeof
name|header1
condition|)
block|{
comment|/* we don't want to fail here. */
ifndef|#
directive|ifndef
name|SMALL
if|if
condition|(
name|fflag
condition|)
goto|goto
name|lose
goto|;
endif|#
directive|endif
if|if
condition|(
name|rbytes
operator|==
operator|-
literal|1
condition|)
name|maybe_warn
argument_list|(
literal|"can't read %s"
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
goto|goto
name|unexpected_EOF
goto|;
goto|goto
name|lose
goto|;
block|}
name|method
operator|=
name|file_gettype
argument_list|(
name|header1
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|SMALL
if|if
condition|(
name|fflag
operator|==
literal|0
operator|&&
name|method
operator|==
name|FT_UNKNOWN
condition|)
block|{
name|maybe_warnx
argument_list|(
literal|"%s: not in gzip format"
argument_list|,
name|file
argument_list|)
expr_stmt|;
goto|goto
name|lose
goto|;
block|}
endif|#
directive|endif
ifndef|#
directive|ifndef
name|SMALL
if|if
condition|(
name|method
operator|==
name|FT_GZIP
operator|&&
name|Nflag
condition|)
block|{
name|unsigned
name|char
name|ts
index|[
literal|4
index|]
decl_stmt|;
comment|/* timestamp */
name|rv
operator|=
name|pread
argument_list|(
name|fd
argument_list|,
name|ts
argument_list|,
sizeof|sizeof
name|ts
argument_list|,
name|GZIP_TIMESTAMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|>=
literal|0
operator|&&
operator|(
name|size_t
operator|)
name|rv
operator|<
sizeof|sizeof
name|ts
condition|)
goto|goto
name|unexpected_EOF
goto|;
if|if
condition|(
name|rv
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|fflag
condition|)
name|maybe_warn
argument_list|(
literal|"can't read %s"
argument_list|,
name|file
argument_list|)
expr_stmt|;
goto|goto
name|lose
goto|;
block|}
name|timestamp
operator|=
name|ts
index|[
literal|3
index|]
operator|<<
literal|24
operator||
name|ts
index|[
literal|2
index|]
operator|<<
literal|16
operator||
name|ts
index|[
literal|1
index|]
operator|<<
literal|8
operator||
name|ts
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|header1
index|[
literal|3
index|]
operator|&
name|ORIG_NAME
condition|)
block|{
name|rbytes
operator|=
name|pread
argument_list|(
name|fd
argument_list|,
name|name
argument_list|,
sizeof|sizeof
name|name
argument_list|,
name|GZIP_ORIGNAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|rbytes
operator|<
literal|0
condition|)
block|{
name|maybe_warn
argument_list|(
literal|"can't read %s"
argument_list|,
name|file
argument_list|)
expr_stmt|;
goto|goto
name|lose
goto|;
block|}
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
comment|/* preserve original directory name */
name|char
modifier|*
name|dp
init|=
name|strrchr
argument_list|(
name|file
argument_list|,
literal|'/'
argument_list|)
decl_stmt|;
if|if
condition|(
name|dp
operator|==
name|NULL
condition|)
name|dp
operator|=
name|file
expr_stmt|;
else|else
name|dp
operator|++
expr_stmt|;
name|snprintf
argument_list|(
name|outfile
argument_list|,
name|outsize
argument_list|,
literal|"%.*s%.*s"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|dp
operator|-
name|file
argument_list|)
argument_list|,
name|file
argument_list|,
operator|(
name|int
operator|)
name|rbytes
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
name|lseek
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|cflag
operator|==
literal|0
operator|||
name|lflag
condition|)
block|{
if|if
condition|(
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|isb
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|lose
goto|;
ifndef|#
directive|ifndef
name|SMALL
if|if
condition|(
name|isb
operator|.
name|st_nlink
operator|>
literal|1
operator|&&
name|lflag
operator|==
literal|0
operator|&&
name|fflag
operator|==
literal|0
condition|)
block|{
name|maybe_warnx
argument_list|(
literal|"%s has %d other links -- skipping"
argument_list|,
name|file
argument_list|,
name|isb
operator|.
name|st_nlink
operator|-
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|lose
goto|;
block|}
if|if
condition|(
name|nflag
operator|==
literal|0
operator|&&
name|timestamp
condition|)
name|isb
operator|.
name|st_mtime
operator|=
name|timestamp
expr_stmt|;
if|if
condition|(
name|check_outfile
argument_list|(
name|outfile
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|lose
goto|;
endif|#
directive|endif
block|}
if|if
condition|(
name|cflag
operator|==
literal|0
operator|&&
name|lflag
operator|==
literal|0
condition|)
block|{
name|zfd
operator|=
name|open
argument_list|(
name|outfile
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_EXCL
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
if|if
condition|(
name|zfd
operator|==
name|STDOUT_FILENO
condition|)
block|{
comment|/* We won't close STDOUT_FILENO later... */
name|zfd
operator|=
name|dup
argument_list|(
name|zfd
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|STDOUT_FILENO
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|zfd
operator|==
operator|-
literal|1
condition|)
block|{
name|maybe_warn
argument_list|(
literal|"can't open %s"
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
goto|goto
name|lose
goto|;
block|}
block|}
else|else
name|zfd
operator|=
name|STDOUT_FILENO
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_BZIP2_SUPPORT
if|if
condition|(
name|method
operator|==
name|FT_BZIP2
condition|)
block|{
comment|/* XXX */
if|if
condition|(
name|lflag
condition|)
block|{
name|maybe_warnx
argument_list|(
literal|"no -l with bzip2 files"
argument_list|)
expr_stmt|;
goto|goto
name|lose
goto|;
block|}
name|size
operator|=
name|unbzip2
argument_list|(
name|fd
argument_list|,
name|zfd
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NO_COMPRESS_SUPPORT
if|if
condition|(
name|method
operator|==
name|FT_Z
condition|)
block|{
name|FILE
modifier|*
name|in
decl_stmt|,
modifier|*
name|out
decl_stmt|;
comment|/* XXX */
if|if
condition|(
name|lflag
condition|)
block|{
name|maybe_warnx
argument_list|(
literal|"no -l with Lempel-Ziv files"
argument_list|)
expr_stmt|;
goto|goto
name|lose
goto|;
block|}
if|if
condition|(
operator|(
name|in
operator|=
name|zdopen
argument_list|(
name|fd
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|maybe_warn
argument_list|(
literal|"zdopen for read: %s"
argument_list|,
name|file
argument_list|)
expr_stmt|;
goto|goto
name|lose
goto|;
block|}
name|out
operator|=
name|fdopen
argument_list|(
name|dup
argument_list|(
name|zfd
argument_list|)
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|out
operator|==
name|NULL
condition|)
block|{
name|maybe_warn
argument_list|(
literal|"fdopen for write: %s"
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|in
argument_list|)
expr_stmt|;
goto|goto
name|lose
goto|;
block|}
name|size
operator|=
name|zuncompress
argument_list|(
name|in
argument_list|,
name|out
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* need to fclose() if ferror() is true... */
if|if
condition|(
name|ferror
argument_list|(
name|in
argument_list|)
operator||
name|fclose
argument_list|(
name|in
argument_list|)
condition|)
block|{
name|maybe_warn
argument_list|(
literal|"failed infile fclose"
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fclose
argument_list|(
name|out
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|maybe_warn
argument_list|(
literal|"failed outfile fclose"
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
goto|goto
name|lose
goto|;
block|}
block|}
elseif|else
endif|#
directive|endif
ifndef|#
directive|ifndef
name|SMALL
if|if
condition|(
name|method
operator|==
name|FT_UNKNOWN
condition|)
block|{
if|if
condition|(
name|lflag
condition|)
block|{
name|maybe_warnx
argument_list|(
literal|"no -l for unknown filetypes"
argument_list|)
expr_stmt|;
goto|goto
name|lose
goto|;
block|}
name|size
operator|=
name|cat_fd
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|fd
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
if|if
condition|(
name|lflag
condition|)
block|{
name|print_list
argument_list|(
name|fd
argument_list|,
name|isb
operator|.
name|st_size
argument_list|,
name|outfile
argument_list|,
name|isb
operator|.
name|st_mtime
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
comment|/* XXX */
block|}
name|size
operator|=
name|gz_uncompress
argument_list|(
name|fd
argument_list|,
name|zfd
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|close
argument_list|(
name|fd
argument_list|)
operator|!=
literal|0
condition|)
name|maybe_warn
argument_list|(
literal|"couldn't close input"
argument_list|)
expr_stmt|;
if|if
condition|(
name|zfd
operator|!=
name|STDOUT_FILENO
operator|&&
name|close
argument_list|(
name|zfd
argument_list|)
operator|!=
literal|0
condition|)
name|maybe_warn
argument_list|(
literal|"couldn't close output"
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|cflag
operator|==
literal|0
condition|)
name|unlink
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
name|maybe_warnx
argument_list|(
literal|"%s: uncompress failed"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* if testing, or we uncompressed to stdout, this is all we need */
ifndef|#
directive|ifndef
name|SMALL
if|if
condition|(
name|tflag
condition|)
return|return
name|size
return|;
endif|#
directive|endif
comment|/* if we are uncompressing to stdin, don't remove the file. */
if|if
condition|(
name|cflag
condition|)
return|return
name|size
return|;
comment|/* 	 * if we create a file... 	 */
comment|/* 	 * if we can't stat the file don't remove the file. 	 */
name|ofd
operator|=
name|open
argument_list|(
name|outfile
argument_list|,
name|O_RDWR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ofd
operator|==
operator|-
literal|1
condition|)
block|{
name|maybe_warn
argument_list|(
literal|"couldn't open (leaving original): %s"
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|fstat
argument_list|(
name|ofd
argument_list|,
operator|&
name|osb
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|maybe_warn
argument_list|(
literal|"couldn't stat (leaving original): %s"
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|ofd
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|osb
operator|.
name|st_size
operator|!=
name|size
condition|)
block|{
name|maybe_warnx
argument_list|(
literal|"stat gave different size: %"
name|PRIdOFF
literal|" != %"
name|PRIdOFF
literal|" (leaving original)"
argument_list|,
name|size
argument_list|,
name|osb
operator|.
name|st_size
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|ofd
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|unlink_input
argument_list|(
name|file
argument_list|,
operator|&
name|isb
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|SMALL
name|copymodes
argument_list|(
name|ofd
argument_list|,
operator|&
name|isb
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|close
argument_list|(
name|ofd
argument_list|)
expr_stmt|;
return|return
name|size
return|;
name|unexpected_EOF
label|:
name|maybe_warnx
argument_list|(
literal|"%s: unexpected end of file"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|lose
label|:
if|if
condition|(
name|fd
operator|!=
operator|-
literal|1
condition|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|zfd
operator|!=
operator|-
literal|1
operator|&&
name|zfd
operator|!=
name|STDOUT_FILENO
condition|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|SMALL
end_ifndef

begin_function
specifier|static
name|off_t
name|cat_fd
parameter_list|(
name|unsigned
name|char
modifier|*
name|prepend
parameter_list|,
name|size_t
name|count
parameter_list|,
name|off_t
modifier|*
name|gsizep
parameter_list|,
name|int
name|fd
parameter_list|)
block|{
name|char
name|buf
index|[
name|BUFLEN
index|]
decl_stmt|;
name|off_t
name|in_tot
decl_stmt|;
name|ssize_t
name|w
decl_stmt|;
name|in_tot
operator|=
name|count
expr_stmt|;
name|w
operator|=
name|write
argument_list|(
name|STDOUT_FILENO
argument_list|,
name|prepend
argument_list|,
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
operator|-
literal|1
operator|||
operator|(
name|size_t
operator|)
name|w
operator|!=
name|count
condition|)
block|{
name|maybe_warn
argument_list|(
literal|"write to stdout"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|ssize_t
name|rv
decl_stmt|;
name|rv
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|rv
operator|<
literal|0
condition|)
block|{
name|maybe_warn
argument_list|(
literal|"read from fd %d"
argument_list|,
name|fd
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|write
argument_list|(
name|STDOUT_FILENO
argument_list|,
name|buf
argument_list|,
name|rv
argument_list|)
operator|!=
name|rv
condition|)
block|{
name|maybe_warn
argument_list|(
literal|"write to stdout"
argument_list|)
expr_stmt|;
break|break;
block|}
name|in_tot
operator|+=
name|rv
expr_stmt|;
block|}
if|if
condition|(
name|gsizep
condition|)
operator|*
name|gsizep
operator|=
name|in_tot
expr_stmt|;
return|return
operator|(
name|in_tot
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|handle_stdin
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|char
name|header1
index|[
literal|4
index|]
decl_stmt|;
name|off_t
name|usize
decl_stmt|,
name|gsize
decl_stmt|;
name|enum
name|filetype
name|method
decl_stmt|;
name|ssize_t
name|bytes_read
decl_stmt|;
ifndef|#
directive|ifndef
name|NO_COMPRESS_SUPPORT
name|FILE
modifier|*
name|in
decl_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|SMALL
if|if
condition|(
name|fflag
operator|==
literal|0
operator|&&
name|lflag
operator|==
literal|0
operator|&&
name|isatty
argument_list|(
name|STDIN_FILENO
argument_list|)
condition|)
block|{
name|maybe_warnx
argument_list|(
literal|"standard input is a terminal -- ignoring"
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
if|if
condition|(
name|lflag
condition|)
block|{
name|struct
name|stat
name|isb
decl_stmt|;
comment|/* XXX could read the whole file, etc. */
if|if
condition|(
name|fstat
argument_list|(
name|STDIN_FILENO
argument_list|,
operator|&
name|isb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|maybe_warn
argument_list|(
literal|"fstat"
argument_list|)
expr_stmt|;
return|return;
block|}
name|print_list
argument_list|(
name|STDIN_FILENO
argument_list|,
name|isb
operator|.
name|st_size
argument_list|,
literal|"stdout"
argument_list|,
name|isb
operator|.
name|st_mtime
argument_list|)
expr_stmt|;
return|return;
block|}
name|bytes_read
operator|=
name|read_retry
argument_list|(
name|STDIN_FILENO
argument_list|,
name|header1
argument_list|,
sizeof|sizeof
name|header1
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes_read
operator|==
operator|-
literal|1
condition|)
block|{
name|maybe_warn
argument_list|(
literal|"can't read stdin"
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|bytes_read
operator|!=
sizeof|sizeof
argument_list|(
name|header1
argument_list|)
condition|)
block|{
name|maybe_warnx
argument_list|(
literal|"(stdin): unexpected end of file"
argument_list|)
expr_stmt|;
return|return;
block|}
name|method
operator|=
name|file_gettype
argument_list|(
name|header1
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|method
condition|)
block|{
default|default:
ifndef|#
directive|ifndef
name|SMALL
if|if
condition|(
name|fflag
operator|==
literal|0
condition|)
block|{
name|maybe_warnx
argument_list|(
literal|"unknown compression format"
argument_list|)
expr_stmt|;
return|return;
block|}
name|usize
operator|=
name|cat_fd
argument_list|(
name|header1
argument_list|,
sizeof|sizeof
name|header1
argument_list|,
operator|&
name|gsize
argument_list|,
name|STDIN_FILENO
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|FT_GZIP
case|:
name|usize
operator|=
name|gz_uncompress
argument_list|(
name|STDIN_FILENO
argument_list|,
name|STDOUT_FILENO
argument_list|,
operator|(
name|char
operator|*
operator|)
name|header1
argument_list|,
sizeof|sizeof
name|header1
argument_list|,
operator|&
name|gsize
argument_list|,
literal|"(stdin)"
argument_list|)
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|NO_BZIP2_SUPPORT
case|case
name|FT_BZIP2
case|:
name|usize
operator|=
name|unbzip2
argument_list|(
name|STDIN_FILENO
argument_list|,
name|STDOUT_FILENO
argument_list|,
operator|(
name|char
operator|*
operator|)
name|header1
argument_list|,
sizeof|sizeof
name|header1
argument_list|,
operator|&
name|gsize
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NO_COMPRESS_SUPPORT
case|case
name|FT_Z
case|:
if|if
condition|(
operator|(
name|in
operator|=
name|zdopen
argument_list|(
name|STDIN_FILENO
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|maybe_warnx
argument_list|(
literal|"zopen of stdin"
argument_list|)
expr_stmt|;
return|return;
block|}
name|usize
operator|=
name|zuncompress
argument_list|(
name|in
argument_list|,
name|stdout
argument_list|,
operator|(
name|char
operator|*
operator|)
name|header1
argument_list|,
sizeof|sizeof
name|header1
argument_list|,
operator|&
name|gsize
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|in
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
block|}
ifndef|#
directive|ifndef
name|SMALL
if|if
condition|(
name|vflag
operator|&&
operator|!
name|tflag
operator|&&
name|usize
operator|!=
operator|-
literal|1
operator|&&
name|gsize
operator|!=
operator|-
literal|1
condition|)
name|print_verbage
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|usize
argument_list|,
name|gsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|vflag
operator|&&
name|tflag
condition|)
name|print_test
argument_list|(
literal|"(stdin)"
argument_list|,
name|usize
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|handle_stdout
parameter_list|(
name|void
parameter_list|)
block|{
name|off_t
name|gsize
decl_stmt|,
name|usize
decl_stmt|;
name|struct
name|stat
name|sb
decl_stmt|;
name|time_t
name|systime
decl_stmt|;
name|uint32_t
name|mtime
decl_stmt|;
name|int
name|ret
decl_stmt|;
ifndef|#
directive|ifndef
name|SMALL
if|if
condition|(
name|fflag
operator|==
literal|0
operator|&&
name|isatty
argument_list|(
name|STDOUT_FILENO
argument_list|)
condition|)
block|{
name|maybe_warnx
argument_list|(
literal|"standard output is a terminal -- ignoring"
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* If stdin is a file use it's mtime, otherwise use current time */
name|ret
operator|=
name|fstat
argument_list|(
name|STDIN_FILENO
argument_list|,
operator|&
name|sb
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|SMALL
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
name|maybe_warn
argument_list|(
literal|"Can't stat stdin"
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
if|if
condition|(
name|S_ISREG
argument_list|(
name|sb
operator|.
name|st_mode
argument_list|)
condition|)
name|mtime
operator|=
operator|(
name|uint32_t
operator|)
name|sb
operator|.
name|st_mtime
expr_stmt|;
else|else
block|{
name|systime
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|SMALL
if|if
condition|(
name|systime
operator|==
operator|-
literal|1
condition|)
block|{
name|maybe_warn
argument_list|(
literal|"time"
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|mtime
operator|=
operator|(
name|uint32_t
operator|)
name|systime
expr_stmt|;
block|}
name|usize
operator|=
name|gz_compress
argument_list|(
name|STDIN_FILENO
argument_list|,
name|STDOUT_FILENO
argument_list|,
operator|&
name|gsize
argument_list|,
literal|""
argument_list|,
name|mtime
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|SMALL
if|if
condition|(
name|vflag
operator|&&
operator|!
name|tflag
operator|&&
name|usize
operator|!=
operator|-
literal|1
operator|&&
name|gsize
operator|!=
operator|-
literal|1
condition|)
name|print_verbage
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|usize
argument_list|,
name|gsize
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* do what is asked for, for the path name */
end_comment

begin_function
specifier|static
name|void
name|handle_pathname
parameter_list|(
name|char
modifier|*
name|path
parameter_list|)
block|{
name|char
modifier|*
name|opath
init|=
name|path
decl_stmt|,
modifier|*
name|s
init|=
name|NULL
decl_stmt|;
name|ssize_t
name|len
decl_stmt|;
name|int
name|slen
decl_stmt|;
name|struct
name|stat
name|sb
decl_stmt|;
comment|/* check for stdout/stdin */
if|if
condition|(
name|path
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|path
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|dflag
condition|)
name|handle_stdin
argument_list|()
expr_stmt|;
else|else
name|handle_stdout
argument_list|()
expr_stmt|;
return|return;
block|}
name|retry
label|:
if|if
condition|(
name|stat
argument_list|(
name|path
argument_list|,
operator|&
name|sb
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* lets try<path>.gz if we're decompressing */
if|if
condition|(
name|dflag
operator|&&
name|s
operator|==
name|NULL
operator|&&
name|errno
operator|==
name|ENOENT
condition|)
block|{
name|len
operator|=
name|strlen
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|slen
operator|=
name|suffixes
index|[
literal|0
index|]
operator|.
name|ziplen
expr_stmt|;
name|s
operator|=
name|malloc
argument_list|(
name|len
operator|+
name|slen
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
name|maybe_err
argument_list|(
literal|"malloc"
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|s
argument_list|,
name|path
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|s
operator|+
name|len
argument_list|,
name|suffixes
index|[
literal|0
index|]
operator|.
name|zipped
argument_list|,
name|slen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|path
operator|=
name|s
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
name|maybe_warn
argument_list|(
literal|"can't stat: %s"
argument_list|,
name|opath
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|S_ISDIR
argument_list|(
name|sb
operator|.
name|st_mode
argument_list|)
condition|)
block|{
ifndef|#
directive|ifndef
name|SMALL
if|if
condition|(
name|rflag
condition|)
name|handle_dir
argument_list|(
name|path
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|maybe_warnx
argument_list|(
literal|"%s is a directory"
argument_list|,
name|path
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|S_ISREG
argument_list|(
name|sb
operator|.
name|st_mode
argument_list|)
condition|)
name|handle_file
argument_list|(
name|path
argument_list|,
operator|&
name|sb
argument_list|)
expr_stmt|;
else|else
name|maybe_warnx
argument_list|(
literal|"%s is not a regular file"
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|s
condition|)
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* compress/decompress a file */
end_comment

begin_function
specifier|static
name|void
name|handle_file
parameter_list|(
name|char
modifier|*
name|file
parameter_list|,
name|struct
name|stat
modifier|*
name|sbp
parameter_list|)
block|{
name|off_t
name|usize
decl_stmt|,
name|gsize
decl_stmt|;
name|char
name|outfile
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|infile
operator|=
name|file
expr_stmt|;
if|if
condition|(
name|dflag
condition|)
block|{
name|usize
operator|=
name|file_uncompress
argument_list|(
name|file
argument_list|,
name|outfile
argument_list|,
sizeof|sizeof
argument_list|(
name|outfile
argument_list|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|SMALL
if|if
condition|(
name|vflag
operator|&&
name|tflag
condition|)
name|print_test
argument_list|(
name|file
argument_list|,
name|usize
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|usize
operator|==
operator|-
literal|1
condition|)
return|return;
name|gsize
operator|=
name|sbp
operator|->
name|st_size
expr_stmt|;
block|}
else|else
block|{
name|gsize
operator|=
name|file_compress
argument_list|(
name|file
argument_list|,
name|outfile
argument_list|,
sizeof|sizeof
argument_list|(
name|outfile
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|gsize
operator|==
operator|-
literal|1
condition|)
return|return;
name|usize
operator|=
name|sbp
operator|->
name|st_size
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|SMALL
if|if
condition|(
name|vflag
operator|&&
operator|!
name|tflag
condition|)
name|print_verbage
argument_list|(
name|file
argument_list|,
operator|(
name|cflag
operator|)
condition|?
name|NULL
else|:
name|outfile
argument_list|,
name|usize
argument_list|,
name|gsize
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|SMALL
end_ifndef

begin_comment
comment|/* this is used with -r to recursively descend directories */
end_comment

begin_function
specifier|static
name|void
name|handle_dir
parameter_list|(
name|char
modifier|*
name|dir
parameter_list|)
block|{
name|char
modifier|*
name|path_argv
index|[
literal|2
index|]
decl_stmt|;
name|FTS
modifier|*
name|fts
decl_stmt|;
name|FTSENT
modifier|*
name|entry
decl_stmt|;
name|path_argv
index|[
literal|0
index|]
operator|=
name|dir
expr_stmt|;
name|path_argv
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|fts
operator|=
name|fts_open
argument_list|(
name|path_argv
argument_list|,
name|FTS_PHYSICAL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|fts
operator|==
name|NULL
condition|)
block|{
name|warn
argument_list|(
literal|"couldn't fts_open %s"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
operator|(
name|entry
operator|=
name|fts_read
argument_list|(
name|fts
argument_list|)
operator|)
condition|)
block|{
switch|switch
condition|(
name|entry
operator|->
name|fts_info
condition|)
block|{
case|case
name|FTS_D
case|:
case|case
name|FTS_DP
case|:
continue|continue;
case|case
name|FTS_DNR
case|:
case|case
name|FTS_ERR
case|:
case|case
name|FTS_NS
case|:
name|maybe_warn
argument_list|(
literal|"%s"
argument_list|,
name|entry
operator|->
name|fts_path
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|FTS_F
case|:
name|handle_file
argument_list|(
name|entry
operator|->
name|fts_name
argument_list|,
name|entry
operator|->
name|fts_statp
argument_list|)
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|fts_close
argument_list|(
name|fts
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* print a ratio - size reduction as a fraction of uncompressed size */
end_comment

begin_function
specifier|static
name|void
name|print_ratio
parameter_list|(
name|off_t
name|in
parameter_list|,
name|off_t
name|out
parameter_list|,
name|FILE
modifier|*
name|where
parameter_list|)
block|{
name|int
name|percent10
decl_stmt|;
comment|/* 10 * percent */
name|off_t
name|diff
decl_stmt|;
name|char
name|buff
index|[
literal|8
index|]
decl_stmt|;
name|int
name|len
decl_stmt|;
name|diff
operator|=
name|in
operator|-
name|out
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|diff
operator|<=
literal|0
condition|)
comment|/* 		 * Output is more than double size of input! print -99.9% 		 * Quite possibly we've failed to get the original size. 		 */
name|percent10
operator|=
operator|-
literal|999
expr_stmt|;
else|else
block|{
comment|/* 		 * We only need 12 bits of result from the final division, 		 * so reduce the values until a 32bit division will suffice. 		 */
while|while
condition|(
name|in
operator|>
literal|0x100000
condition|)
block|{
name|diff
operator|>>=
literal|1
expr_stmt|;
name|in
operator|>>=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|in
operator|!=
literal|0
condition|)
name|percent10
operator|=
operator|(
operator|(
name|u_int
operator|)
name|diff
operator|*
literal|2000
operator|)
operator|/
operator|(
name|u_int
operator|)
name|in
operator|-
literal|1000
expr_stmt|;
else|else
name|percent10
operator|=
literal|0
expr_stmt|;
block|}
name|len
operator|=
name|snprintf
argument_list|(
name|buff
argument_list|,
sizeof|sizeof
name|buff
argument_list|,
literal|"%2.2d."
argument_list|,
name|percent10
argument_list|)
expr_stmt|;
comment|/* Move the '.' to before the last digit */
name|buff
index|[
name|len
operator|-
literal|1
index|]
operator|=
name|buff
index|[
name|len
operator|-
literal|2
index|]
expr_stmt|;
name|buff
index|[
name|len
operator|-
literal|2
index|]
operator|=
literal|'.'
expr_stmt|;
name|fprintf
argument_list|(
name|where
argument_list|,
literal|"%5s%%"
argument_list|,
name|buff
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|SMALL
end_ifndef

begin_comment
comment|/* print compression statistics, and the new name (if there is one!) */
end_comment

begin_function
specifier|static
name|void
name|print_verbage
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
specifier|const
name|char
modifier|*
name|nfile
parameter_list|,
name|off_t
name|usize
parameter_list|,
name|off_t
name|gsize
parameter_list|)
block|{
if|if
condition|(
name|file
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%s  "
argument_list|,
name|file
argument_list|,
name|strlen
argument_list|(
name|file
argument_list|)
operator|<
literal|7
condition|?
literal|"\t\t"
else|:
literal|"\t"
argument_list|)
expr_stmt|;
name|print_ratio
argument_list|(
name|usize
argument_list|,
name|gsize
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|nfile
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" -- replaced with %s"
argument_list|,
name|nfile
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* print test results */
end_comment

begin_function
specifier|static
name|void
name|print_test
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|ok
parameter_list|)
block|{
if|if
condition|(
name|exit_value
operator|==
literal|0
operator|&&
name|ok
operator|==
literal|0
condition|)
name|exit_value
operator|=
literal|1
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%s  %s\n"
argument_list|,
name|file
argument_list|,
name|strlen
argument_list|(
name|file
argument_list|)
operator|<
literal|7
condition|?
literal|"\t\t"
else|:
literal|"\t"
argument_list|,
name|ok
condition|?
literal|"OK"
else|:
literal|"NOT OK"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* print a file's info ala --list */
end_comment

begin_comment
comment|/* eg:   compressed uncompressed  ratio uncompressed_name       354841      1679360  78.8% /usr/pkgsrc/distfiles/libglade-2.0.1.tar */
end_comment

begin_function
specifier|static
name|void
name|print_list
parameter_list|(
name|int
name|fd
parameter_list|,
name|off_t
name|out
parameter_list|,
specifier|const
name|char
modifier|*
name|outfile
parameter_list|,
name|time_t
name|ts
parameter_list|)
block|{
specifier|static
name|int
name|first
init|=
literal|1
decl_stmt|;
ifndef|#
directive|ifndef
name|SMALL
specifier|static
name|off_t
name|in_tot
decl_stmt|,
name|out_tot
decl_stmt|;
name|uint32_t
name|crc
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
name|off_t
name|in
init|=
literal|0
decl_stmt|,
name|rv
decl_stmt|;
if|if
condition|(
name|first
condition|)
block|{
ifndef|#
directive|ifndef
name|SMALL
if|if
condition|(
name|vflag
condition|)
name|printf
argument_list|(
literal|"method  crc     date  time  "
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|qflag
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"  compressed uncompressed  "
literal|"ratio uncompressed_name\n"
argument_list|)
expr_stmt|;
block|}
name|first
operator|=
literal|0
expr_stmt|;
comment|/* print totals? */
ifndef|#
directive|ifndef
name|SMALL
if|if
condition|(
name|fd
operator|==
operator|-
literal|1
condition|)
block|{
name|in
operator|=
name|in_tot
expr_stmt|;
name|out
operator|=
name|out_tot
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
comment|/* read the last 4 bytes - this is the uncompressed size */
name|rv
operator|=
name|lseek
argument_list|(
name|fd
argument_list|,
call|(
name|off_t
call|)
argument_list|(
operator|-
literal|8
argument_list|)
argument_list|,
name|SEEK_END
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
operator|-
literal|1
condition|)
block|{
name|unsigned
name|char
name|buf
index|[
literal|8
index|]
decl_stmt|;
name|uint32_t
name|usize
decl_stmt|;
name|rv
operator|=
name|read
argument_list|(
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|==
operator|-
literal|1
condition|)
name|maybe_warn
argument_list|(
literal|"read of uncompressed size"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rv
operator|!=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
condition|)
name|maybe_warnx
argument_list|(
literal|"read of uncompressed size"
argument_list|)
expr_stmt|;
else|else
block|{
name|usize
operator|=
name|buf
index|[
literal|4
index|]
operator||
name|buf
index|[
literal|5
index|]
operator|<<
literal|8
operator||
name|buf
index|[
literal|6
index|]
operator|<<
literal|16
operator||
name|buf
index|[
literal|7
index|]
operator|<<
literal|24
expr_stmt|;
name|in
operator|=
operator|(
name|off_t
operator|)
name|usize
expr_stmt|;
ifndef|#
directive|ifndef
name|SMALL
name|crc
operator|=
name|buf
index|[
literal|0
index|]
operator||
name|buf
index|[
literal|1
index|]
operator|<<
literal|8
operator||
name|buf
index|[
literal|2
index|]
operator|<<
literal|16
operator||
name|buf
index|[
literal|3
index|]
operator|<<
literal|24
expr_stmt|;
endif|#
directive|endif
block|}
block|}
block|}
ifndef|#
directive|ifndef
name|SMALL
if|if
condition|(
name|vflag
operator|&&
name|fd
operator|==
operator|-
literal|1
condition|)
name|printf
argument_list|(
literal|"                            "
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|vflag
condition|)
block|{
name|char
modifier|*
name|date
init|=
name|ctime
argument_list|(
operator|&
name|ts
argument_list|)
decl_stmt|;
comment|/* skip the day, 1/100th second, and year */
name|date
operator|+=
literal|4
expr_stmt|;
name|date
index|[
literal|12
index|]
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"%5s %08x %11s "
argument_list|,
literal|"defla"
comment|/*XXX*/
argument_list|,
name|crc
argument_list|,
name|date
argument_list|)
expr_stmt|;
block|}
name|in_tot
operator|+=
name|in
expr_stmt|;
name|out_tot
operator|+=
name|out
expr_stmt|;
endif|#
directive|endif
name|printf
argument_list|(
literal|"%12llu %12llu "
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|out
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|in
argument_list|)
expr_stmt|;
name|print_ratio
argument_list|(
name|in
argument_list|,
name|out
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %s\n"
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* display the usage of NetBSD gzip */
end_comment

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|gzip_version
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: %s [-"
name|OPT_LIST
literal|"] [<file> [<file> ...]]\n"
ifndef|#
directive|ifndef
name|SMALL
literal|" -1 --fast            fastest (worst) compression\n"
literal|" -2 .. -8             set compression level\n"
literal|" -9 --best            best (slowest) compression\n"
literal|" -c --stdout          write to stdout, keep original files\n"
literal|"    --to-stdout\n"
literal|" -d --decompress      uncompress files\n"
literal|"    --uncompress\n"
literal|" -f --force           force overwriting& compress links\n"
literal|" -h --help            display this help\n"
literal|" -l --list            list compressed file contents\n"
literal|" -N --name            save or restore original file name and time stamp\n"
literal|" -n --no-name         don't save original file name or time stamp\n"
literal|" -q --quiet           output no warnings\n"
literal|" -r --recursive       recursively compress files in directories\n"
literal|" -S .suf              use suffix .suf instead of .gz\n"
literal|"    --suffix .suf\n"
literal|" -t --test            test compressed file\n"
literal|" -V --version         display program version\n"
literal|" -v --verbose         print extra statistics\n"
argument_list|,
else|#
directive|else
argument_list|,
endif|#
directive|endif
name|getprogname
argument_list|()
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|SMALL
end_ifndef

begin_comment
comment|/* display the license information of FreeBSD gzip */
end_comment

begin_function
specifier|static
name|void
name|display_license
parameter_list|(
name|void
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s (based on NetBSD gzip 20060927)\n"
argument_list|,
name|gzip_version
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|gzip_copyright
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* display the version of NetBSD gzip */
end_comment

begin_function
specifier|static
name|void
name|display_version
parameter_list|(
name|void
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|gzip_version
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|NO_BZIP2_SUPPORT
end_ifndef

begin_include
include|#
directive|include
file|"unbzip2.c"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|NO_COMPRESS_SUPPORT
end_ifndef

begin_include
include|#
directive|include
file|"zuncompress.c"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|ssize_t
name|read_retry
parameter_list|(
name|int
name|fd
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|sz
parameter_list|)
block|{
name|char
modifier|*
name|cp
init|=
name|buf
decl_stmt|;
name|size_t
name|left
init|=
name|MIN
argument_list|(
name|sz
argument_list|,
operator|(
name|size_t
operator|)
name|SSIZE_MAX
argument_list|)
decl_stmt|;
while|while
condition|(
name|left
operator|>
literal|0
condition|)
block|{
name|ssize_t
name|ret
decl_stmt|;
name|ret
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|cp
argument_list|,
name|left
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
condition|)
block|{
return|return
name|ret
return|;
block|}
elseif|else
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
break|break;
comment|/* EOF */
block|}
name|cp
operator|+=
name|ret
expr_stmt|;
name|left
operator|-=
name|ret
expr_stmt|;
block|}
return|return
name|sz
operator|-
name|left
return|;
block|}
end_function

end_unit

