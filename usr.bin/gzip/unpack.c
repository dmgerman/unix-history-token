begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$FreeBSD$	*/
end_comment

begin_comment
comment|/*	$NetBSD: unpack.c,v 1.3 2017/08/04 07:27:08 mrg Exp $	*/
end_comment

begin_comment
comment|/*-  * Copyright (c) 2009 Xin LI<delphij@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_comment
comment|/* This file is #included by gzip.c */
end_comment

begin_comment
comment|/*  * pack(1) file format:  *  * The first 7 bytes is the header:  *	00, 01 - Signature (US, RS), we already validated it earlier.  *	02..05 - Uncompressed size  *	    06 - Level for the huffman tree (<=24)  *  * pack(1) will then store symbols (leaf) nodes count in each huffman  * tree levels, each level would consume 1 byte (See [1]).  *  * After the symbol count table, there is the symbol table, storing  * symbols represented by corresponding leaf node.  EOB is not being  * explicitly transmitted (not necessary anyway) in the symbol table.  *  * Compressed data goes after the symbol table.  *  * NOTES  *  * [1] If we count EOB into the symbols, that would mean that we will  * have at most 256 symbols in the huffman tree.  pack(1) rejects empty  * file and files that just repeats one character, which means that we  * will have at least 2 symbols.  Therefore, pack(1) would reduce the  * last level symbol count by 2 which makes it a number in  * range [0..254], so all levels' symbol count would fit into 1 byte.  */
end_comment

begin_define
define|#
directive|define
name|PACK_HEADER_LENGTH
value|7
end_define

begin_define
define|#
directive|define
name|HTREE_MAXLEVEL
value|24
end_define

begin_comment
comment|/*  * unpack descriptor  *  * Represent the huffman tree in a similar way that pack(1) would  * store in a packed file.  We store all symbols in a linear table,  * and store pointers to each level's first symbol.  In addition to  * that, maintain two counts for each level: inner nodes count and  * leaf nodes count.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|int
name|symbol_size
decl_stmt|;
comment|/* Size of the symbol table */
name|int
name|treelevels
decl_stmt|;
comment|/* Levels for the huffman tree */
name|int
modifier|*
name|symbolsin
decl_stmt|;
comment|/* Table of leaf symbols count in each 					 * level */
name|int
modifier|*
name|inodesin
decl_stmt|;
comment|/* Table of internal nodes count in 					 * each level */
name|char
modifier|*
name|symbol
decl_stmt|;
comment|/* The symbol table */
name|char
modifier|*
name|symbol_eob
decl_stmt|;
comment|/* Pointer to the EOB symbol */
name|char
modifier|*
modifier|*
name|tree
decl_stmt|;
comment|/* Decoding huffman tree (pointers to 					 * first symbol of each tree level */
name|off_t
name|uncompressed_size
decl_stmt|;
comment|/* Uncompressed size */
name|FILE
modifier|*
name|fpIn
decl_stmt|;
comment|/* Input stream */
name|FILE
modifier|*
name|fpOut
decl_stmt|;
comment|/* Output stream */
block|}
name|unpack_descriptor_t
typedef|;
end_typedef

begin_comment
comment|/*  * Release resource allocated to an unpack descriptor.  *  * Caller is responsible to make sure that all of these pointers are  * initialized (in our case, they all point to valid memory block).  * We don't zero out pointers here because nobody else would ever  * reference the memory block without scrubbing them.  */
end_comment

begin_function
specifier|static
name|void
name|unpack_descriptor_fini
parameter_list|(
name|unpack_descriptor_t
modifier|*
name|unpackd
parameter_list|)
block|{
name|free
argument_list|(
name|unpackd
operator|->
name|symbolsin
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|unpackd
operator|->
name|inodesin
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|unpackd
operator|->
name|symbol
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|unpackd
operator|->
name|tree
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|unpackd
operator|->
name|fpIn
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|unpackd
operator|->
name|fpOut
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Recursively fill the internal node count table  */
end_comment

begin_function
specifier|static
name|void
name|unpackd_fill_inodesin
parameter_list|(
specifier|const
name|unpack_descriptor_t
modifier|*
name|unpackd
parameter_list|,
name|int
name|level
parameter_list|)
block|{
comment|/* 	 * The internal nodes would be 1/2 of total internal nodes and 	 * leaf nodes in the next level.  For the last level there 	 * would be no internal node by definition. 	 */
if|if
condition|(
name|level
operator|<
name|unpackd
operator|->
name|treelevels
condition|)
block|{
name|unpackd_fill_inodesin
argument_list|(
name|unpackd
argument_list|,
name|level
operator|+
literal|1
argument_list|)
expr_stmt|;
name|unpackd
operator|->
name|inodesin
index|[
name|level
index|]
operator|=
operator|(
name|unpackd
operator|->
name|inodesin
index|[
name|level
operator|+
literal|1
index|]
operator|+
name|unpackd
operator|->
name|symbolsin
index|[
name|level
operator|+
literal|1
index|]
operator|)
operator|/
literal|2
expr_stmt|;
block|}
else|else
name|unpackd
operator|->
name|inodesin
index|[
name|level
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Update counter for accepted bytes  */
end_comment

begin_function
specifier|static
name|void
name|accepted_bytes
parameter_list|(
name|off_t
modifier|*
name|bytes_in
parameter_list|,
name|off_t
name|newbytes
parameter_list|)
block|{
if|if
condition|(
name|bytes_in
operator|!=
name|NULL
condition|)
operator|(
operator|*
name|bytes_in
operator|)
operator|+=
name|newbytes
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Read file header and construct the tree.  Also, prepare the buffered I/O  * for decode routine.  *  * Return value is uncompressed size.  */
end_comment

begin_function
specifier|static
name|void
name|unpack_parse_header
parameter_list|(
name|int
name|in
parameter_list|,
name|int
name|out
parameter_list|,
name|char
modifier|*
name|pre
parameter_list|,
name|size_t
name|prelen
parameter_list|,
name|off_t
modifier|*
name|bytes_in
parameter_list|,
name|unpack_descriptor_t
modifier|*
name|unpackd
parameter_list|)
block|{
name|unsigned
name|char
name|hdr
index|[
name|PACK_HEADER_LENGTH
index|]
decl_stmt|;
comment|/* buffer for header */
name|ssize_t
name|bytesread
decl_stmt|;
comment|/* Bytes read from the file */
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|thisbyte
decl_stmt|;
if|if
condition|(
name|prelen
operator|>
sizeof|sizeof
name|hdr
condition|)
name|maybe_err
argument_list|(
literal|"prelen too long"
argument_list|)
expr_stmt|;
comment|/* Prepend the header buffer if we already read some data */
if|if
condition|(
name|prelen
operator|!=
literal|0
condition|)
name|memcpy
argument_list|(
name|hdr
argument_list|,
name|pre
argument_list|,
name|prelen
argument_list|)
expr_stmt|;
comment|/* Read in and fill the rest bytes of header */
name|bytesread
operator|=
name|read
argument_list|(
name|in
argument_list|,
name|hdr
operator|+
name|prelen
argument_list|,
name|PACK_HEADER_LENGTH
operator|-
name|prelen
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytesread
operator|<
literal|0
condition|)
name|maybe_err
argument_list|(
literal|"Error reading pack header"
argument_list|)
expr_stmt|;
name|infile_newdata
argument_list|(
name|bytesread
argument_list|)
expr_stmt|;
name|accepted_bytes
argument_list|(
name|bytes_in
argument_list|,
name|PACK_HEADER_LENGTH
argument_list|)
expr_stmt|;
comment|/* Obtain uncompressed length (bytes 2,3,4,5) */
name|unpackd
operator|->
name|uncompressed_size
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<=
literal|5
condition|;
name|i
operator|++
control|)
block|{
name|unpackd
operator|->
name|uncompressed_size
operator|<<=
literal|8
expr_stmt|;
name|unpackd
operator|->
name|uncompressed_size
operator||=
name|hdr
index|[
name|i
index|]
expr_stmt|;
block|}
comment|/* Get the levels of the tree */
name|unpackd
operator|->
name|treelevels
operator|=
name|hdr
index|[
literal|6
index|]
expr_stmt|;
if|if
condition|(
name|unpackd
operator|->
name|treelevels
operator|>
name|HTREE_MAXLEVEL
operator|||
name|unpackd
operator|->
name|treelevels
operator|<
literal|1
condition|)
name|maybe_errx
argument_list|(
literal|"Huffman tree has insane levels"
argument_list|)
expr_stmt|;
comment|/* Let libc take care for buffering from now on */
if|if
condition|(
operator|(
name|unpackd
operator|->
name|fpIn
operator|=
name|fdopen
argument_list|(
name|in
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|maybe_err
argument_list|(
literal|"Can not fdopen() input stream"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|unpackd
operator|->
name|fpOut
operator|=
name|fdopen
argument_list|(
name|out
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|maybe_err
argument_list|(
literal|"Can not fdopen() output stream"
argument_list|)
expr_stmt|;
comment|/* Allocate for the tables of bounds and the tree itself */
name|unpackd
operator|->
name|inodesin
operator|=
name|calloc
argument_list|(
name|unpackd
operator|->
name|treelevels
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
operator|(
name|unpackd
operator|->
name|inodesin
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|unpackd
operator|->
name|symbolsin
operator|=
name|calloc
argument_list|(
name|unpackd
operator|->
name|treelevels
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
operator|(
name|unpackd
operator|->
name|symbolsin
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|unpackd
operator|->
name|tree
operator|=
name|calloc
argument_list|(
name|unpackd
operator|->
name|treelevels
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
operator|*
operator|(
name|unpackd
operator|->
name|tree
operator|)
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|unpackd
operator|->
name|inodesin
operator|==
name|NULL
operator|||
name|unpackd
operator|->
name|symbolsin
operator|==
name|NULL
operator|||
name|unpackd
operator|->
name|tree
operator|==
name|NULL
condition|)
name|maybe_err
argument_list|(
literal|"calloc"
argument_list|)
expr_stmt|;
comment|/* We count from 0 so adjust to match array upper bound */
name|unpackd
operator|->
name|treelevels
operator|--
expr_stmt|;
comment|/* Read the levels symbol count table and calculate total */
name|unpackd
operator|->
name|symbol_size
operator|=
literal|1
expr_stmt|;
comment|/* EOB */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|unpackd
operator|->
name|treelevels
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|thisbyte
operator|=
name|fgetc
argument_list|(
name|unpackd
operator|->
name|fpIn
argument_list|)
operator|)
operator|==
name|EOF
condition|)
name|maybe_err
argument_list|(
literal|"File appears to be truncated"
argument_list|)
expr_stmt|;
name|unpackd
operator|->
name|symbolsin
index|[
name|i
index|]
operator|=
operator|(
name|unsigned
name|char
operator|)
name|thisbyte
expr_stmt|;
name|unpackd
operator|->
name|symbol_size
operator|+=
name|unpackd
operator|->
name|symbolsin
index|[
name|i
index|]
expr_stmt|;
block|}
name|accepted_bytes
argument_list|(
name|bytes_in
argument_list|,
name|unpackd
operator|->
name|treelevels
argument_list|)
expr_stmt|;
if|if
condition|(
name|unpackd
operator|->
name|symbol_size
operator|>
literal|256
condition|)
name|maybe_errx
argument_list|(
literal|"Bad symbol table"
argument_list|)
expr_stmt|;
name|infile_newdata
argument_list|(
name|unpackd
operator|->
name|treelevels
argument_list|)
expr_stmt|;
comment|/* Allocate for the symbol table, point symbol_eob at the beginning */
name|unpackd
operator|->
name|symbol_eob
operator|=
name|unpackd
operator|->
name|symbol
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
name|unpackd
operator|->
name|symbol_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|unpackd
operator|->
name|symbol
operator|==
name|NULL
condition|)
name|maybe_err
argument_list|(
literal|"calloc"
argument_list|)
expr_stmt|;
comment|/* 	 * Read in the symbol table, which contain [2, 256] symbols. 	 * In order to fit the count in one byte, pack(1) would offset 	 * it by reducing 2 from the actual number from the last level. 	 * 	 * We adjust the last level's symbol count by 1 here, because 	 * the EOB symbol is not being transmitted explicitly.  Another 	 * adjustment would be done later afterward. 	 */
name|unpackd
operator|->
name|symbolsin
index|[
name|unpackd
operator|->
name|treelevels
index|]
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|unpackd
operator|->
name|treelevels
condition|;
name|i
operator|++
control|)
block|{
name|unpackd
operator|->
name|tree
index|[
name|i
index|]
operator|=
name|unpackd
operator|->
name|symbol_eob
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|unpackd
operator|->
name|symbolsin
index|[
name|i
index|]
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|thisbyte
operator|=
name|fgetc
argument_list|(
name|unpackd
operator|->
name|fpIn
argument_list|)
operator|)
operator|==
name|EOF
condition|)
name|maybe_errx
argument_list|(
literal|"Symbol table truncated"
argument_list|)
expr_stmt|;
operator|*
name|unpackd
operator|->
name|symbol_eob
operator|++
operator|=
operator|(
name|char
operator|)
name|thisbyte
expr_stmt|;
block|}
name|infile_newdata
argument_list|(
name|unpackd
operator|->
name|symbolsin
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|accepted_bytes
argument_list|(
name|bytes_in
argument_list|,
name|unpackd
operator|->
name|symbolsin
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Now, take account for the EOB symbol as well */
name|unpackd
operator|->
name|symbolsin
index|[
name|unpackd
operator|->
name|treelevels
index|]
operator|++
expr_stmt|;
comment|/* 	 * The symbolsin table has been constructed now. 	 * Calculate the internal nodes count table based on it. 	 */
name|unpackd_fill_inodesin
argument_list|(
name|unpackd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Decode huffman stream, based on the huffman tree.  */
end_comment

begin_function
specifier|static
name|void
name|unpack_decode
parameter_list|(
specifier|const
name|unpack_descriptor_t
modifier|*
name|unpackd
parameter_list|,
name|off_t
modifier|*
name|bytes_in
parameter_list|)
block|{
name|int
name|thislevel
decl_stmt|,
name|thiscode
decl_stmt|,
name|thisbyte
decl_stmt|,
name|inlevelindex
decl_stmt|;
name|int
name|i
decl_stmt|;
name|off_t
name|bytes_out
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|thissymbol
decl_stmt|;
comment|/* The symbol pointer decoded from stream */
comment|/* 	 * Decode huffman.  Fetch every bytes from the file, get it 	 * into 'thiscode' bit-by-bit, then output the symbol we got 	 * when one has been found. 	 * 	 * Assumption: sizeof(int)> ((max tree levels + 1) / 8). 	 * bad things could happen if not. 	 */
name|thislevel
operator|=
literal|0
expr_stmt|;
name|thiscode
operator|=
name|thisbyte
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|thisbyte
operator|=
name|fgetc
argument_list|(
name|unpackd
operator|->
name|fpIn
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
name|accepted_bytes
argument_list|(
name|bytes_in
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|infile_newdata
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|check_siginfo
argument_list|()
expr_stmt|;
comment|/* 		 * Split one bit from thisbyte, from highest to lowest, 		 * feed the bit into thiscode, until we got a symbol from 		 * the tree. 		 */
for|for
control|(
name|i
operator|=
literal|7
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|thiscode
operator|=
operator|(
name|thiscode
operator|<<
literal|1
operator|)
operator||
operator|(
operator|(
name|thisbyte
operator|>>
name|i
operator|)
operator|&
literal|1
operator|)
expr_stmt|;
comment|/* Did we got a symbol? (referencing leaf node) */
if|if
condition|(
name|thiscode
operator|>=
name|unpackd
operator|->
name|inodesin
index|[
name|thislevel
index|]
condition|)
block|{
name|inlevelindex
operator|=
name|thiscode
operator|-
name|unpackd
operator|->
name|inodesin
index|[
name|thislevel
index|]
expr_stmt|;
if|if
condition|(
name|inlevelindex
operator|>
name|unpackd
operator|->
name|symbolsin
index|[
name|thislevel
index|]
condition|)
name|maybe_errx
argument_list|(
literal|"File corrupt"
argument_list|)
expr_stmt|;
name|thissymbol
operator|=
operator|&
operator|(
name|unpackd
operator|->
name|tree
index|[
name|thislevel
index|]
index|[
name|inlevelindex
index|]
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|thissymbol
operator|==
name|unpackd
operator|->
name|symbol_eob
operator|)
operator|&&
operator|(
name|bytes_out
operator|==
name|unpackd
operator|->
name|uncompressed_size
operator|)
condition|)
goto|goto
name|finished
goto|;
name|fputc
argument_list|(
operator|(
operator|*
name|thissymbol
operator|)
argument_list|,
name|unpackd
operator|->
name|fpOut
argument_list|)
expr_stmt|;
name|bytes_out
operator|++
expr_stmt|;
comment|/* Prepare for next input */
name|thislevel
operator|=
literal|0
expr_stmt|;
name|thiscode
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|thislevel
operator|++
expr_stmt|;
if|if
condition|(
name|thislevel
operator|>
name|unpackd
operator|->
name|treelevels
condition|)
name|maybe_errx
argument_list|(
literal|"File corrupt"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|finished
label|:
if|if
condition|(
name|bytes_out
operator|!=
name|unpackd
operator|->
name|uncompressed_size
condition|)
name|maybe_errx
argument_list|(
literal|"Premature EOF"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handler for pack(1)'ed file */
end_comment

begin_function
specifier|static
name|off_t
name|unpack
parameter_list|(
name|int
name|in
parameter_list|,
name|int
name|out
parameter_list|,
name|char
modifier|*
name|pre
parameter_list|,
name|size_t
name|prelen
parameter_list|,
name|off_t
modifier|*
name|bytes_in
parameter_list|)
block|{
name|unpack_descriptor_t
name|unpackd
decl_stmt|;
name|in
operator|=
name|dup
argument_list|(
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|in
operator|==
operator|-
literal|1
condition|)
name|maybe_err
argument_list|(
literal|"dup"
argument_list|)
expr_stmt|;
name|out
operator|=
name|dup
argument_list|(
name|out
argument_list|)
expr_stmt|;
if|if
condition|(
name|out
operator|==
operator|-
literal|1
condition|)
name|maybe_err
argument_list|(
literal|"dup"
argument_list|)
expr_stmt|;
name|unpack_parse_header
argument_list|(
name|in
argument_list|,
name|out
argument_list|,
name|pre
argument_list|,
name|prelen
argument_list|,
name|bytes_in
argument_list|,
operator|&
name|unpackd
argument_list|)
expr_stmt|;
name|unpack_decode
argument_list|(
operator|&
name|unpackd
argument_list|,
name|bytes_in
argument_list|)
expr_stmt|;
name|unpack_descriptor_fini
argument_list|(
operator|&
name|unpackd
argument_list|)
expr_stmt|;
comment|/* If we reached here, the unpack was successful */
return|return
operator|(
name|unpackd
operator|.
name|uncompressed_size
operator|)
return|;
block|}
end_function

end_unit

