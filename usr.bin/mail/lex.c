begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1980, 1993  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static char sccsid[] = "@(#)lex.c	8.2 (Berkeley) 4/20/95";
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"rcv.h"
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|"extern.h"
end_include

begin_comment
comment|/*  * Mail -- a mail program  *  * Lexical processing of commands.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|prompt
init|=
literal|"& "
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
specifier|const
name|struct
name|cmd
name|cmdtab
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
specifier|const
name|char
modifier|*
name|version
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Set up editing on the given file name.  * If the first character of name is %, we are considered to be  * editing the file, otherwise we are reading our mail which has  * signficance for mbox and so forth.  *  * If the -e option is being passed to mail, this function has a  * tri-state return code: -1 on error, 0 on no mail, 1 if there is  * mail.  */
end_comment

begin_function
name|int
name|setfile
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|FILE
modifier|*
name|ibuf
decl_stmt|;
name|int
name|checkmode
decl_stmt|,
name|i
decl_stmt|,
name|fd
decl_stmt|;
name|struct
name|stat
name|stb
decl_stmt|;
name|char
name|isedit
init|=
operator|*
name|name
operator|!=
literal|'%'
operator|||
name|getuserid
argument_list|(
name|myname
argument_list|)
operator|!=
name|getuid
argument_list|()
decl_stmt|;
name|char
modifier|*
name|who
init|=
name|name
index|[
literal|1
index|]
condition|?
name|name
operator|+
literal|1
else|:
name|myname
decl_stmt|;
name|char
name|tempname
index|[
name|PATHSIZE
index|]
decl_stmt|;
specifier|static
name|int
name|shudclob
decl_stmt|;
name|checkmode
operator|=
name|value
argument_list|(
literal|"checkmode"
argument_list|)
operator|!=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|name
operator|=
name|expand
argument_list|(
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|(
name|ibuf
operator|=
name|Fopen
argument_list|(
name|name
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|isedit
operator|&&
name|errno
operator|==
name|ENOENT
condition|)
goto|goto
name|nomail
goto|;
name|warn
argument_list|(
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|fstat
argument_list|(
name|fileno
argument_list|(
name|ibuf
argument_list|)
argument_list|,
operator|&
name|stb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"fstat"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Fclose
argument_list|(
name|ibuf
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|S_ISDIR
argument_list|(
name|stb
operator|.
name|st_mode
argument_list|)
operator|||
operator|!
name|S_ISREG
argument_list|(
name|stb
operator|.
name|st_mode
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|Fclose
argument_list|(
name|ibuf
argument_list|)
expr_stmt|;
name|errno
operator|=
name|S_ISDIR
argument_list|(
name|stb
operator|.
name|st_mode
argument_list|)
condition|?
name|EISDIR
else|:
name|EINVAL
expr_stmt|;
name|warn
argument_list|(
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * Looks like all will be well.  We must now relinquish our 	 * hold on the current set of stuff.  Must hold signals 	 * while we are reading the new file, else we will ruin 	 * the message[] data structure. 	 */
name|holdsigs
argument_list|()
expr_stmt|;
if|if
condition|(
name|shudclob
condition|)
name|quit
argument_list|()
expr_stmt|;
comment|/* 	 * Copy the messages into /tmp 	 * and set pointers. 	 */
name|readonly
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|open
argument_list|(
name|name
argument_list|,
literal|1
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|readonly
operator|++
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|close
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|shudclob
condition|)
block|{
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|itf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|otf
argument_list|)
expr_stmt|;
block|}
name|shudclob
operator|=
literal|1
expr_stmt|;
name|edit
operator|=
name|isedit
expr_stmt|;
name|strlcpy
argument_list|(
name|prevfile
argument_list|,
name|mailname
argument_list|,
sizeof|sizeof
argument_list|(
name|prevfile
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|!=
name|mailname
condition|)
name|strlcpy
argument_list|(
name|mailname
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|mailname
argument_list|)
argument_list|)
expr_stmt|;
name|mailsize
operator|=
name|fsize
argument_list|(
name|ibuf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|tempname
argument_list|,
sizeof|sizeof
argument_list|(
name|tempname
argument_list|)
argument_list|,
literal|"%s/mail.RxXXXXXXXXXX"
argument_list|,
name|tmpdir
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|mkstemp
argument_list|(
name|tempname
argument_list|)
operator|)
operator|==
operator|-
literal|1
operator|||
operator|(
name|otf
operator|=
name|fdopen
argument_list|(
name|fd
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"%s"
argument_list|,
name|tempname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fcntl
argument_list|(
name|fileno
argument_list|(
name|otf
argument_list|)
argument_list|,
name|F_SETFD
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|itf
operator|=
name|fopen
argument_list|(
name|tempname
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"%s"
argument_list|,
name|tempname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fcntl
argument_list|(
name|fileno
argument_list|(
name|itf
argument_list|)
argument_list|,
name|F_SETFD
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|rm
argument_list|(
name|tempname
argument_list|)
expr_stmt|;
name|setptr
argument_list|(
name|ibuf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|setmsize
argument_list|(
name|msgCount
argument_list|)
expr_stmt|;
comment|/* 	 * New mail may have arrived while we were reading 	 * the mail file, so reset mailsize to be where 	 * we really are in the file... 	 */
name|mailsize
operator|=
name|ftello
argument_list|(
name|ibuf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Fclose
argument_list|(
name|ibuf
argument_list|)
expr_stmt|;
name|relsesigs
argument_list|()
expr_stmt|;
name|sawcom
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|checkmode
operator|||
operator|!
name|edit
operator|)
operator|&&
name|msgCount
operator|==
literal|0
condition|)
block|{
name|nomail
label|:
if|if
condition|(
operator|!
name|checkmode
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No mail for %s\n"
argument_list|,
name|who
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|checkmode
condition|?
literal|1
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Incorporate any new mail that has arrived since we first  * started reading mail.  */
end_comment

begin_function
name|int
name|incfile
parameter_list|()
block|{
name|off_t
name|newsize
decl_stmt|;
name|int
name|omsgCount
init|=
name|msgCount
decl_stmt|;
name|FILE
modifier|*
name|ibuf
decl_stmt|;
name|ibuf
operator|=
name|Fopen
argument_list|(
name|mailname
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ibuf
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|holdsigs
argument_list|()
expr_stmt|;
name|newsize
operator|=
name|fsize
argument_list|(
name|ibuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|newsize
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* mail box is now empty??? */
if|if
condition|(
name|newsize
operator|<
name|mailsize
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* mail box has shrunk??? */
if|if
condition|(
name|newsize
operator|==
name|mailsize
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* no new mail */
name|setptr
argument_list|(
name|ibuf
argument_list|,
name|mailsize
argument_list|)
expr_stmt|;
name|setmsize
argument_list|(
name|msgCount
argument_list|)
expr_stmt|;
name|mailsize
operator|=
name|ftello
argument_list|(
name|ibuf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Fclose
argument_list|(
name|ibuf
argument_list|)
expr_stmt|;
name|relsesigs
argument_list|()
expr_stmt|;
return|return
operator|(
name|msgCount
operator|-
name|omsgCount
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
modifier|*
name|msgvec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|reset_on_stop
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* do a reset() if stopped */
end_comment

begin_comment
comment|/*  * Interpret user commands one by one.  If standard input is not a tty,  * print no prompt.  */
end_comment

begin_function
name|void
name|commands
parameter_list|()
block|{
name|int
name|n
decl_stmt|,
name|eofloop
init|=
literal|0
decl_stmt|;
name|char
name|linebuf
index|[
name|LINESIZE
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|sourcing
condition|)
block|{
if|if
condition|(
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|intr
argument_list|)
expr_stmt|;
if|if
condition|(
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|hangup
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|stop
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGTTOU
argument_list|,
name|stop
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGTTIN
argument_list|,
name|stop
argument_list|)
expr_stmt|;
block|}
name|setexit
argument_list|()
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 		 * Print the prompt, if needed.  Clear out 		 * string space, and flush the output. 		 */
if|if
condition|(
operator|!
name|sourcing
operator|&&
name|value
argument_list|(
literal|"interactive"
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|value
argument_list|(
literal|"autoinc"
argument_list|)
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|incfile
argument_list|()
operator|>
literal|0
operator|)
condition|)
name|printf
argument_list|(
literal|"New mail has arrived.\n"
argument_list|)
expr_stmt|;
name|reset_on_stop
operator|=
literal|1
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|prompt
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|sreset
argument_list|()
expr_stmt|;
comment|/* 		 * Read a line of commands from the current input 		 * and handle end of file specially. 		 */
name|n
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|readline
argument_list|(
name|input
argument_list|,
operator|&
name|linebuf
index|[
name|n
index|]
argument_list|,
name|LINESIZE
operator|-
name|n
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|n
operator|==
literal|0
condition|)
name|n
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|n
operator|=
name|strlen
argument_list|(
name|linebuf
argument_list|)
operator|)
operator|==
literal|0
condition|)
break|break;
name|n
operator|--
expr_stmt|;
if|if
condition|(
name|linebuf
index|[
name|n
index|]
operator|!=
literal|'\\'
condition|)
break|break;
name|linebuf
index|[
name|n
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
block|}
name|reset_on_stop
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
comment|/* eof */
if|if
condition|(
name|loading
condition|)
break|break;
if|if
condition|(
name|sourcing
condition|)
block|{
name|unstack
argument_list|()
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|value
argument_list|(
literal|"interactive"
argument_list|)
operator|!=
name|NULL
operator|&&
name|value
argument_list|(
literal|"ignoreeof"
argument_list|)
operator|!=
name|NULL
operator|&&
operator|++
name|eofloop
operator|<
literal|25
condition|)
block|{
name|printf
argument_list|(
literal|"Use \"quit\" to quit.\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
name|eofloop
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|execute
argument_list|(
name|linebuf
argument_list|,
literal|0
argument_list|)
condition|)
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Execute a single command.  * Command functions return 0 for success, 1 for error, and -1  * for abort.  A 1 or -1 aborts a load or source.  A -1 aborts  * the interactive command loop.  * Contxt is non-zero if called while composing mail.  */
end_comment

begin_function
name|int
name|execute
parameter_list|(
name|linebuf
parameter_list|,
name|contxt
parameter_list|)
name|char
name|linebuf
index|[]
decl_stmt|;
name|int
name|contxt
decl_stmt|;
block|{
name|char
name|word
index|[
name|LINESIZE
index|]
decl_stmt|;
name|char
modifier|*
name|arglist
index|[
name|MAXARGC
index|]
decl_stmt|;
specifier|const
name|struct
name|cmd
modifier|*
name|com
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|cp2
decl_stmt|;
name|int
name|c
decl_stmt|,
name|muvec
index|[
literal|2
index|]
decl_stmt|;
name|int
name|e
init|=
literal|1
decl_stmt|;
comment|/* 	 * Strip the white space away from the beginning 	 * of the command, then scan out a word, which 	 * consists of anything except digits and white space. 	 * 	 * Handle ! escapes differently to get the correct 	 * lexical conventions. 	 */
for|for
control|(
name|cp
operator|=
name|linebuf
init|;
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cp
argument_list|)
condition|;
name|cp
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'!'
condition|)
block|{
if|if
condition|(
name|sourcing
condition|)
block|{
name|printf
argument_list|(
literal|"Can't \"!\" while sourcing\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|shell
argument_list|(
name|cp
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|cp2
operator|=
name|word
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|!=
literal|'\0'
operator|&&
name|strchr
argument_list|(
literal|" \t0123456789$^.:/-+*'\""
argument_list|,
operator|*
name|cp
argument_list|)
operator|==
name|NULL
condition|)
operator|*
name|cp2
operator|++
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
operator|*
name|cp2
operator|=
literal|'\0'
expr_stmt|;
comment|/* 	 * Look up the command; if not found, bitch. 	 * Normally, a blank command would map to the 	 * first command in the table; while sourcing, 	 * however, we ignore blank lines to eliminate 	 * confusion. 	 */
if|if
condition|(
name|sourcing
operator|&&
operator|*
name|word
operator|==
literal|'\0'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|com
operator|=
name|lex
argument_list|(
name|word
argument_list|)
expr_stmt|;
if|if
condition|(
name|com
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"Unknown command: \"%s\"\n"
argument_list|,
name|word
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * See if we should execute the command -- if a conditional 	 * we always execute it, otherwise, check the state of cond. 	 */
if|if
condition|(
operator|(
name|com
operator|->
name|c_argtype
operator|&
name|F
operator|)
operator|==
literal|0
condition|)
if|if
condition|(
operator|(
name|cond
operator|==
name|CRCV
operator|&&
operator|!
name|rcvmode
operator|)
operator|||
operator|(
name|cond
operator|==
name|CSEND
operator|&&
name|rcvmode
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Process the arguments to the command, depending 	 * on the type he expects.  Default to an error. 	 * If we are sourcing an interactive command, it's 	 * an error. 	 */
if|if
condition|(
operator|!
name|rcvmode
operator|&&
operator|(
name|com
operator|->
name|c_argtype
operator|&
name|M
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"May not execute \"%s\" while sending\n"
argument_list|,
name|com
operator|->
name|c_name
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|sourcing
operator|&&
name|com
operator|->
name|c_argtype
operator|&
name|I
condition|)
block|{
name|printf
argument_list|(
literal|"May not execute \"%s\" while sourcing\n"
argument_list|,
name|com
operator|->
name|c_name
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|readonly
operator|&&
name|com
operator|->
name|c_argtype
operator|&
name|W
condition|)
block|{
name|printf
argument_list|(
literal|"May not execute \"%s\" -- message file is read only\n"
argument_list|,
name|com
operator|->
name|c_name
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|contxt
operator|&&
name|com
operator|->
name|c_argtype
operator|&
name|R
condition|)
block|{
name|printf
argument_list|(
literal|"Cannot recursively invoke \"%s\"\n"
argument_list|,
name|com
operator|->
name|c_name
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
switch|switch
condition|(
name|com
operator|->
name|c_argtype
operator|&
operator|~
operator|(
name|F
operator||
name|P
operator||
name|I
operator||
name|M
operator||
name|T
operator||
name|W
operator||
name|R
operator|)
condition|)
block|{
case|case
name|MSGLIST
case|:
comment|/* 		 * A message list defaulting to nearest forward 		 * legal message. 		 */
if|if
condition|(
name|msgvec
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Illegal use of \"message list\"\n"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|c
operator|=
name|getmsglist
argument_list|(
name|cp
argument_list|,
name|msgvec
argument_list|,
name|com
operator|->
name|c_msgflag
argument_list|)
operator|)
operator|<
literal|0
condition|)
break|break;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
block|{
operator|*
name|msgvec
operator|=
name|first
argument_list|(
name|com
operator|->
name|c_msgflag
argument_list|,
name|com
operator|->
name|c_msgmask
argument_list|)
expr_stmt|;
name|msgvec
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|msgvec
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"No applicable messages\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|e
operator|=
call|(
modifier|*
name|com
operator|->
name|c_func
call|)
argument_list|(
name|msgvec
argument_list|)
expr_stmt|;
break|break;
case|case
name|NDMLIST
case|:
comment|/* 		 * A message list with no defaults, but no error 		 * if none exist. 		 */
if|if
condition|(
name|msgvec
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Illegal use of \"message list\"\n"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|getmsglist
argument_list|(
name|cp
argument_list|,
name|msgvec
argument_list|,
name|com
operator|->
name|c_msgflag
argument_list|)
operator|<
literal|0
condition|)
break|break;
name|e
operator|=
call|(
modifier|*
name|com
operator|->
name|c_func
call|)
argument_list|(
name|msgvec
argument_list|)
expr_stmt|;
break|break;
case|case
name|STRLIST
case|:
comment|/* 		 * Just the straight string, with 		 * leading blanks removed. 		 */
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cp
argument_list|)
condition|)
name|cp
operator|++
expr_stmt|;
name|e
operator|=
call|(
modifier|*
name|com
operator|->
name|c_func
call|)
argument_list|(
name|cp
argument_list|)
expr_stmt|;
break|break;
case|case
name|RAWLIST
case|:
comment|/* 		 * A vector of strings, in shell style. 		 */
if|if
condition|(
operator|(
name|c
operator|=
name|getrawlist
argument_list|(
name|cp
argument_list|,
name|arglist
argument_list|,
sizeof|sizeof
argument_list|(
name|arglist
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|arglist
argument_list|)
argument_list|)
operator|)
operator|<
literal|0
condition|)
break|break;
if|if
condition|(
name|c
operator|<
name|com
operator|->
name|c_minargs
condition|)
block|{
name|printf
argument_list|(
literal|"%s requires at least %d arg(s)\n"
argument_list|,
name|com
operator|->
name|c_name
argument_list|,
name|com
operator|->
name|c_minargs
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|c
operator|>
name|com
operator|->
name|c_maxargs
condition|)
block|{
name|printf
argument_list|(
literal|"%s takes no more than %d arg(s)\n"
argument_list|,
name|com
operator|->
name|c_name
argument_list|,
name|com
operator|->
name|c_maxargs
argument_list|)
expr_stmt|;
break|break;
block|}
name|e
operator|=
call|(
modifier|*
name|com
operator|->
name|c_func
call|)
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
break|break;
case|case
name|NOLIST
case|:
comment|/* 		 * Just the constant zero, for exiting, 		 * eg. 		 */
name|e
operator|=
call|(
modifier|*
name|com
operator|->
name|c_func
call|)
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Unknown argtype"
argument_list|)
expr_stmt|;
block|}
name|out
label|:
comment|/* 	 * Exit the current source file on 	 * error. 	 */
if|if
condition|(
name|e
condition|)
block|{
if|if
condition|(
name|e
operator|<
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|loading
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|sourcing
condition|)
name|unstack
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|com
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|value
argument_list|(
literal|"autoprint"
argument_list|)
operator|!=
name|NULL
operator|&&
name|com
operator|->
name|c_argtype
operator|&
name|P
condition|)
if|if
condition|(
operator|(
name|dot
operator|->
name|m_flag
operator|&
name|MDELETED
operator|)
operator|==
literal|0
condition|)
block|{
name|muvec
index|[
literal|0
index|]
operator|=
name|dot
operator|-
operator|&
name|message
index|[
literal|0
index|]
operator|+
literal|1
expr_stmt|;
name|muvec
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|type
argument_list|(
name|muvec
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|sourcing
operator|&&
operator|(
name|com
operator|->
name|c_argtype
operator|&
name|T
operator|)
operator|==
literal|0
condition|)
name|sawcom
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set the size of the message vector used to construct argument  * lists to message list functions.  */
end_comment

begin_function
name|void
name|setmsize
parameter_list|(
name|sz
parameter_list|)
name|int
name|sz
decl_stmt|;
block|{
if|if
condition|(
name|msgvec
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|free
argument_list|(
name|msgvec
argument_list|)
expr_stmt|;
name|msgvec
operator|=
name|calloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|sz
operator|+
literal|1
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|msgvec
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Find the correct command in the command table corresponding  * to the passed command "word"  */
end_comment

begin_function
name|__const
name|struct
name|cmd
modifier|*
name|lex
parameter_list|(
name|word
parameter_list|)
name|char
name|word
index|[]
decl_stmt|;
block|{
specifier|const
name|struct
name|cmd
modifier|*
name|cp
decl_stmt|;
comment|/* 	 * ignore trailing chars after `#' 	 * 	 * lines with beginning `#' are comments 	 * spaces before `#' are ignored in execute() 	 */
if|if
condition|(
operator|*
name|word
operator|==
literal|'#'
condition|)
operator|*
operator|(
name|word
operator|+
literal|1
operator|)
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|cp
operator|=
operator|&
name|cmdtab
index|[
literal|0
index|]
init|;
name|cp
operator|->
name|c_name
operator|!=
name|NULL
condition|;
name|cp
operator|++
control|)
if|if
condition|(
name|isprefix
argument_list|(
name|word
argument_list|,
name|cp
operator|->
name|c_name
argument_list|)
condition|)
return|return
operator|(
name|cp
operator|)
return|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Determine if as1 is a valid prefix of as2.  * Return true if yep.  */
end_comment

begin_function
name|int
name|isprefix
parameter_list|(
name|as1
parameter_list|,
name|as2
parameter_list|)
specifier|const
name|char
modifier|*
name|as1
decl_stmt|,
decl|*
name|as2
decl_stmt|;
end_function

begin_block
block|{
specifier|const
name|char
modifier|*
name|s1
decl_stmt|,
modifier|*
name|s2
decl_stmt|;
name|s1
operator|=
name|as1
expr_stmt|;
name|s2
operator|=
name|as2
expr_stmt|;
while|while
condition|(
operator|*
name|s1
operator|++
operator|==
operator|*
name|s2
condition|)
if|if
condition|(
operator|*
name|s2
operator|++
operator|==
literal|'\0'
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
operator|*
operator|--
name|s1
operator|==
literal|'\0'
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * The following gets called on receipt of an interrupt.  This is  * to abort printout of a command, mainly.  * Dispatching here when command() is inactive crashes rcv.  * Close all open files except 0, 1, 2, and the temporary.  * Also, unstack all source files.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|inithdr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* am printing startup headers */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
name|intr
parameter_list|(
name|s
parameter_list|)
name|int
name|s
decl_stmt|;
block|{
name|noreset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|inithdr
condition|)
name|sawcom
operator|++
expr_stmt|;
name|inithdr
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|sourcing
condition|)
name|unstack
argument_list|()
expr_stmt|;
name|close_all_files
argument_list|()
expr_stmt|;
if|if
condition|(
name|image
operator|>=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|image
argument_list|)
expr_stmt|;
name|image
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Interrupt\n"
argument_list|)
expr_stmt|;
name|reset
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * When we wake up after ^Z, reprint the prompt.  */
end_comment

begin_function
name|void
name|stop
parameter_list|(
name|s
parameter_list|)
name|int
name|s
decl_stmt|;
block|{
name|sig_t
name|old_action
init|=
name|signal
argument_list|(
name|s
argument_list|,
name|SIG_DFL
argument_list|)
decl_stmt|;
name|sigset_t
name|nset
decl_stmt|;
operator|(
name|void
operator|)
name|sigemptyset
argument_list|(
operator|&
name|nset
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigaddset
argument_list|(
operator|&
name|nset
argument_list|,
name|s
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigprocmask
argument_list|(
name|SIG_UNBLOCK
argument_list|,
operator|&
name|nset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|kill
argument_list|(
literal|0
argument_list|,
name|s
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigprocmask
argument_list|(
name|SIG_BLOCK
argument_list|,
operator|&
name|nset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|s
argument_list|,
name|old_action
argument_list|)
expr_stmt|;
if|if
condition|(
name|reset_on_stop
condition|)
block|{
name|reset_on_stop
operator|=
literal|0
expr_stmt|;
name|reset
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Branch here on hangup signal and simulate "exit".  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
name|hangup
parameter_list|(
name|s
parameter_list|)
name|int
name|s
decl_stmt|;
block|{
comment|/* nothing to do? */
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Announce the presence of the current Mail version,  * give the message count, and print a header listing.  */
end_comment

begin_function
name|void
name|announce
parameter_list|()
block|{
name|int
name|vec
index|[
literal|2
index|]
decl_stmt|,
name|mdot
decl_stmt|;
name|mdot
operator|=
name|newfileinfo
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|vec
index|[
literal|0
index|]
operator|=
name|mdot
expr_stmt|;
name|vec
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|dot
operator|=
operator|&
name|message
index|[
name|mdot
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|msgCount
operator|>
literal|0
operator|&&
name|value
argument_list|(
literal|"noheader"
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|inithdr
operator|++
expr_stmt|;
name|headers
argument_list|(
name|vec
argument_list|)
expr_stmt|;
name|inithdr
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Announce information about the file we are editing.  * Return a likely place to set dot.  */
end_comment

begin_function
name|int
name|newfileinfo
parameter_list|(
name|omsgCount
parameter_list|)
name|int
name|omsgCount
decl_stmt|;
block|{
name|struct
name|message
modifier|*
name|mp
decl_stmt|;
name|int
name|u
decl_stmt|,
name|n
decl_stmt|,
name|mdot
decl_stmt|,
name|d
decl_stmt|,
name|s
decl_stmt|;
name|char
name|fname
index|[
name|PATHSIZE
operator|+
literal|1
index|]
decl_stmt|,
name|zname
index|[
name|PATHSIZE
operator|+
literal|1
index|]
decl_stmt|,
modifier|*
name|ename
decl_stmt|;
for|for
control|(
name|mp
operator|=
operator|&
name|message
index|[
name|omsgCount
index|]
init|;
name|mp
operator|<
operator|&
name|message
index|[
name|msgCount
index|]
condition|;
name|mp
operator|++
control|)
if|if
condition|(
name|mp
operator|->
name|m_flag
operator|&
name|MNEW
condition|)
break|break;
if|if
condition|(
name|mp
operator|>=
operator|&
name|message
index|[
name|msgCount
index|]
condition|)
for|for
control|(
name|mp
operator|=
operator|&
name|message
index|[
name|omsgCount
index|]
init|;
name|mp
operator|<
operator|&
name|message
index|[
name|msgCount
index|]
condition|;
name|mp
operator|++
control|)
if|if
condition|(
operator|(
name|mp
operator|->
name|m_flag
operator|&
name|MREAD
operator|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|mp
operator|<
operator|&
name|message
index|[
name|msgCount
index|]
condition|)
name|mdot
operator|=
name|mp
operator|-
operator|&
name|message
index|[
literal|0
index|]
operator|+
literal|1
expr_stmt|;
else|else
name|mdot
operator|=
name|omsgCount
operator|+
literal|1
expr_stmt|;
name|s
operator|=
name|d
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|mp
operator|=
operator|&
name|message
index|[
literal|0
index|]
operator|,
name|n
operator|=
literal|0
operator|,
name|u
operator|=
literal|0
init|;
name|mp
operator|<
operator|&
name|message
index|[
name|msgCount
index|]
condition|;
name|mp
operator|++
control|)
block|{
if|if
condition|(
name|mp
operator|->
name|m_flag
operator|&
name|MNEW
condition|)
name|n
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|mp
operator|->
name|m_flag
operator|&
name|MREAD
operator|)
operator|==
literal|0
condition|)
name|u
operator|++
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|m_flag
operator|&
name|MDELETED
condition|)
name|d
operator|++
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|m_flag
operator|&
name|MSAVED
condition|)
name|s
operator|++
expr_stmt|;
block|}
name|ename
operator|=
name|mailname
expr_stmt|;
if|if
condition|(
name|getfold
argument_list|(
name|fname
argument_list|,
sizeof|sizeof
argument_list|(
name|fname
argument_list|)
operator|-
literal|1
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|strcat
argument_list|(
name|fname
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|fname
argument_list|,
name|mailname
argument_list|,
name|strlen
argument_list|(
name|fname
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|zname
argument_list|,
sizeof|sizeof
argument_list|(
name|zname
argument_list|)
argument_list|,
literal|"+%s"
argument_list|,
name|mailname
operator|+
name|strlen
argument_list|(
name|fname
argument_list|)
argument_list|)
expr_stmt|;
name|ename
operator|=
name|zname
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"\"%s\": "
argument_list|,
name|ename
argument_list|)
expr_stmt|;
if|if
condition|(
name|msgCount
operator|==
literal|1
condition|)
name|printf
argument_list|(
literal|"1 message"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%d messages"
argument_list|,
name|msgCount
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|" %d new"
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|u
operator|-
name|n
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|" %d unread"
argument_list|,
name|u
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|" %d deleted"
argument_list|,
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|" %d saved"
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|readonly
condition|)
name|printf
argument_list|(
literal|" [Read only]"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|mdot
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Print the current version number.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|int
name|pversion
parameter_list|(
name|e
parameter_list|)
name|int
name|e
decl_stmt|;
block|{
name|printf
argument_list|(
literal|"Version %s\n"
argument_list|,
name|version
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Load a file of user definitions.  */
end_comment

begin_function
name|void
name|load
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|FILE
modifier|*
name|in
decl_stmt|,
modifier|*
name|oldin
decl_stmt|;
if|if
condition|(
operator|(
name|in
operator|=
name|Fopen
argument_list|(
name|name
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
name|oldin
operator|=
name|input
expr_stmt|;
name|input
operator|=
name|in
expr_stmt|;
name|loading
operator|=
literal|1
expr_stmt|;
name|sourcing
operator|=
literal|1
expr_stmt|;
name|commands
argument_list|()
expr_stmt|;
name|loading
operator|=
literal|0
expr_stmt|;
name|sourcing
operator|=
literal|0
expr_stmt|;
name|input
operator|=
name|oldin
expr_stmt|;
operator|(
name|void
operator|)
name|Fclose
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

