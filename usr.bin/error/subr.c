begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1980, 1993  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static char sccsid[] = "@(#)subr.c	8.1 (Berkeley) 6/6/93";
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"error.h"
end_include

begin_comment
comment|/*  *	Arrayify a list of rules  */
end_comment

begin_function
name|void
name|arrayify
parameter_list|(
name|e_length
parameter_list|,
name|e_array
parameter_list|,
name|header
parameter_list|)
name|int
modifier|*
name|e_length
decl_stmt|;
name|Eptr
modifier|*
modifier|*
name|e_array
decl_stmt|;
name|Eptr
name|header
decl_stmt|;
block|{
name|reg
name|Eptr
name|errorp
decl_stmt|;
name|reg
name|Eptr
modifier|*
name|array
decl_stmt|;
name|reg
name|int
name|listlength
decl_stmt|;
name|reg
name|int
name|listindex
decl_stmt|;
for|for
control|(
name|errorp
operator|=
name|header
operator|,
name|listlength
operator|=
literal|0
init|;
name|errorp
condition|;
name|errorp
operator|=
name|errorp
operator|->
name|error_next
operator|,
name|listlength
operator|++
control|)
continue|continue;
name|array
operator|=
operator|(
name|Eptr
operator|*
operator|)
name|Calloc
argument_list|(
name|listlength
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|Eptr
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|listindex
operator|=
literal|0
operator|,
name|errorp
operator|=
name|header
init|;
name|listindex
operator|<
name|listlength
condition|;
name|listindex
operator|++
operator|,
name|errorp
operator|=
name|errorp
operator|->
name|error_next
control|)
block|{
name|array
index|[
name|listindex
index|]
operator|=
name|errorp
expr_stmt|;
name|errorp
operator|->
name|error_position
operator|=
name|listindex
expr_stmt|;
block|}
name|array
index|[
name|listindex
index|]
operator|=
operator|(
name|Eptr
operator|)
literal|0
expr_stmt|;
operator|*
name|e_length
operator|=
name|listlength
expr_stmt|;
operator|*
name|e_array
operator|=
name|array
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|char
modifier|*
name|Calloc
parameter_list|(
name|nelements
parameter_list|,
name|size
parameter_list|)
name|int
name|nelements
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|char
modifier|*
name|back
decl_stmt|;
if|if
condition|(
operator|(
name|back
operator|=
operator|(
name|char
operator|*
operator|)
name|calloc
argument_list|(
name|nelements
argument_list|,
name|size
argument_list|)
operator|)
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
name|errx
argument_list|(
literal|6
argument_list|,
literal|"ran out of memory"
argument_list|)
expr_stmt|;
return|return
operator|(
name|back
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|strsave
parameter_list|(
name|instring
parameter_list|)
name|char
modifier|*
name|instring
decl_stmt|;
block|{
name|char
modifier|*
name|outstring
decl_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|outstring
operator|=
operator|(
name|char
operator|*
operator|)
name|Calloc
argument_list|(
literal|1
argument_list|,
name|strlen
argument_list|(
name|instring
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|,
name|instring
argument_list|)
expr_stmt|;
return|return
operator|(
name|outstring
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	find the position of a given character in a string  *		(one based)  */
end_comment

begin_function
name|int
name|position
parameter_list|(
name|string
parameter_list|,
name|ch
parameter_list|)
name|reg
name|char
modifier|*
name|string
decl_stmt|;
name|reg
name|char
name|ch
decl_stmt|;
block|{
name|reg
name|int
name|i
decl_stmt|;
if|if
condition|(
name|string
condition|)
for|for
control|(
name|i
operator|=
literal|1
init|;
operator|*
name|string
condition|;
name|string
operator|++
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|string
operator|==
name|ch
condition|)
return|return
operator|(
name|i
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	clobber the first occurance of ch in string by the new character  */
end_comment

begin_function
name|char
modifier|*
name|substitute
parameter_list|(
name|string
parameter_list|,
name|chold
parameter_list|,
name|chnew
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|char
name|chold
decl_stmt|,
name|chnew
decl_stmt|;
block|{
name|reg
name|char
modifier|*
name|cp
init|=
name|string
decl_stmt|;
if|if
condition|(
name|cp
condition|)
while|while
condition|(
operator|*
name|cp
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
name|chold
condition|)
block|{
operator|*
name|cp
operator|=
name|chnew
expr_stmt|;
break|break;
block|}
name|cp
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|string
operator|)
return|;
block|}
end_function

begin_function
name|char
name|lastchar
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|int
name|length
decl_stmt|;
if|if
condition|(
name|string
operator|==
literal|0
condition|)
return|return
operator|(
literal|'\0'
operator|)
return|;
name|length
operator|=
name|strlen
argument_list|(
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|>=
literal|1
condition|)
return|return
operator|(
name|string
index|[
name|length
operator|-
literal|1
index|]
operator|)
return|;
else|else
return|return
operator|(
literal|'\0'
operator|)
return|;
block|}
end_function

begin_function
name|char
name|firstchar
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
if|if
condition|(
name|string
condition|)
return|return
operator|(
name|string
index|[
literal|0
index|]
operator|)
return|;
else|else
return|return
operator|(
literal|'\0'
operator|)
return|;
block|}
end_function

begin_function
name|char
name|next_lastchar
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|int
name|length
decl_stmt|;
if|if
condition|(
name|string
operator|==
literal|0
condition|)
return|return
operator|(
literal|'\0'
operator|)
return|;
name|length
operator|=
name|strlen
argument_list|(
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|>=
literal|2
condition|)
return|return
operator|(
name|string
index|[
name|length
operator|-
literal|2
index|]
operator|)
return|;
else|else
return|return
operator|(
literal|'\0'
operator|)
return|;
block|}
end_function

begin_function
name|void
name|clob_last
parameter_list|(
name|string
parameter_list|,
name|newstuff
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|,
name|newstuff
decl_stmt|;
block|{
name|int
name|length
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|string
condition|)
name|length
operator|=
name|strlen
argument_list|(
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|>=
literal|1
condition|)
name|string
index|[
name|length
operator|-
literal|1
index|]
operator|=
name|newstuff
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	parse a string that is the result of a format %s(%d)  *	return TRUE if this is of the proper format  */
end_comment

begin_function
name|boolean
name|persperdexplode
parameter_list|(
name|string
parameter_list|,
name|r_perd
parameter_list|,
name|r_pers
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|char
modifier|*
modifier|*
name|r_perd
decl_stmt|,
decl|*
modifier|*
name|r_pers
decl_stmt|;
end_function

begin_block
block|{
name|reg
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|length
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|string
condition|)
name|length
operator|=
name|strlen
argument_list|(
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|length
operator|>=
literal|4
operator|)
operator|&&
operator|(
name|string
index|[
name|length
operator|-
literal|1
index|]
operator|==
literal|')'
operator|)
condition|)
block|{
for|for
control|(
name|cp
operator|=
operator|&
name|string
index|[
name|length
operator|-
literal|2
index|]
init|;
operator|(
name|isdigit
argument_list|(
operator|*
name|cp
argument_list|)
operator|)
operator|&&
operator|(
operator|*
name|cp
operator|!=
literal|'('
operator|)
condition|;
operator|--
name|cp
control|)
continue|continue;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'('
condition|)
block|{
name|string
index|[
name|length
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* clobber the ) */
operator|*
name|r_perd
operator|=
name|strsave
argument_list|(
name|cp
operator|+
literal|1
argument_list|)
expr_stmt|;
name|string
index|[
name|length
operator|-
literal|1
index|]
operator|=
literal|')'
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
comment|/* clobber the ( */
operator|*
name|r_pers
operator|=
name|strsave
argument_list|(
name|string
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|=
literal|'('
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
block|}
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  *	parse a quoted string that is the result of a format \"%s\"(%d)  *	return TRUE if this is of the proper format  */
end_comment

begin_function
name|boolean
name|qpersperdexplode
parameter_list|(
name|string
parameter_list|,
name|r_perd
parameter_list|,
name|r_pers
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|char
modifier|*
modifier|*
name|r_perd
decl_stmt|,
decl|*
modifier|*
name|r_pers
decl_stmt|;
end_function

begin_block
block|{
name|reg
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|length
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|string
condition|)
name|length
operator|=
name|strlen
argument_list|(
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|length
operator|>=
literal|4
operator|)
operator|&&
operator|(
name|string
index|[
name|length
operator|-
literal|1
index|]
operator|==
literal|')'
operator|)
condition|)
block|{
for|for
control|(
name|cp
operator|=
operator|&
name|string
index|[
name|length
operator|-
literal|2
index|]
init|;
operator|(
name|isdigit
argument_list|(
operator|*
name|cp
argument_list|)
operator|)
operator|&&
operator|(
operator|*
name|cp
operator|!=
literal|'('
operator|)
condition|;
operator|--
name|cp
control|)
continue|continue;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'('
operator|&&
operator|*
operator|(
name|cp
operator|-
literal|1
operator|)
operator|==
literal|'"'
condition|)
block|{
name|string
index|[
name|length
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|r_perd
operator|=
name|strsave
argument_list|(
name|cp
operator|+
literal|1
argument_list|)
expr_stmt|;
name|string
index|[
name|length
operator|-
literal|1
index|]
operator|=
literal|')'
expr_stmt|;
operator|*
operator|(
name|cp
operator|-
literal|1
operator|)
operator|=
literal|'\0'
expr_stmt|;
comment|/* clobber the " */
operator|*
name|r_pers
operator|=
name|strsave
argument_list|(
name|string
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|*
operator|(
name|cp
operator|-
literal|1
operator|)
operator|=
literal|'"'
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
block|}
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_block

begin_decl_stmt
specifier|static
name|char
name|cincomment
index|[]
init|=
name|CINCOMMENT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|coutcomment
index|[]
init|=
name|COUTCOMMENT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|fincomment
index|[]
init|=
name|FINCOMMENT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|foutcomment
index|[]
init|=
name|FOUTCOMMENT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|newline
index|[]
init|=
name|NEWLINE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|piincomment
index|[]
init|=
name|PIINCOMMENT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|pioutcomment
index|[]
init|=
name|PIOUTCOMMENT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|lispincomment
index|[]
init|=
name|LISPINCOMMENT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|riincomment
index|[]
init|=
name|RIINCOMMENT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|rioutcomment
index|[]
init|=
name|RIOUTCOMMENT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|troffincomment
index|[]
init|=
name|TROFFINCOMMENT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|troffoutcomment
index|[]
init|=
name|TROFFOUTCOMMENT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|mod2incomment
index|[]
init|=
name|MOD2INCOMMENT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|mod2outcomment
index|[]
init|=
name|MOD2OUTCOMMENT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|lang_desc
name|lang_table
index|[]
init|=
block|{
comment|/*INUNKNOWN	0*/
block|{
literal|"unknown"
block|,
name|cincomment
block|,
name|coutcomment
block|}
block|,
comment|/*INCPP		1*/
block|{
literal|"cpp"
block|,
name|cincomment
block|,
name|coutcomment
block|}
block|,
comment|/*INCC		2*/
block|{
literal|"cc"
block|,
name|cincomment
block|,
name|coutcomment
block|}
block|,
comment|/*INAS		3*/
block|{
literal|"as"
block|,
name|ASINCOMMENT
block|,
name|newline
block|}
block|,
comment|/*INLD		4*/
block|{
literal|"ld"
block|,
name|cincomment
block|,
name|coutcomment
block|}
block|,
comment|/*INLINT	5*/
block|{
literal|"lint"
block|,
name|cincomment
block|,
name|coutcomment
block|}
block|,
comment|/*INF77		6*/
block|{
literal|"f77"
block|,
name|fincomment
block|,
name|foutcomment
block|}
block|,
comment|/*INPI		7*/
block|{
literal|"pi"
block|,
name|piincomment
block|,
name|pioutcomment
block|}
block|,
comment|/*INPC		8*/
block|{
literal|"pc"
block|,
name|piincomment
block|,
name|pioutcomment
block|}
block|,
comment|/*INFRANZ	9*/
block|{
literal|"franz"
block|,
name|lispincomment
block|,
name|newline
block|}
block|,
comment|/*INLISP	10*/
block|{
literal|"lisp"
block|,
name|lispincomment
block|,
name|newline
block|}
block|,
comment|/*INVAXIMA	11*/
block|{
literal|"vaxima"
block|,
name|lispincomment
block|,
name|newline
block|}
block|,
comment|/*INRATFOR	12*/
block|{
literal|"ratfor"
block|,
name|fincomment
block|,
name|foutcomment
block|}
block|,
comment|/*INLEX		13*/
block|{
literal|"lex"
block|,
name|cincomment
block|,
name|coutcomment
block|}
block|,
comment|/*INYACC	14*/
block|{
literal|"yacc"
block|,
name|cincomment
block|,
name|coutcomment
block|}
block|,
comment|/*INAPL		15*/
block|{
literal|"apl"
block|,
literal|".lm"
block|,
name|newline
block|}
block|,
comment|/*INMAKE	16*/
block|{
literal|"make"
block|,
name|ASINCOMMENT
block|,
name|newline
block|}
block|,
comment|/*INRI		17*/
block|{
literal|"ri"
block|,
name|riincomment
block|,
name|rioutcomment
block|}
block|,
comment|/*INTROFF	18*/
block|{
literal|"troff"
block|,
name|troffincomment
block|,
name|troffoutcomment
block|}
block|,
comment|/*INMOD2	19*/
block|{
literal|"mod2"
block|,
name|mod2incomment
block|,
name|mod2outcomment
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|printerrors
parameter_list|(
name|look_at_subclass
parameter_list|,
name|errorc
parameter_list|,
name|errorv
parameter_list|)
name|boolean
name|look_at_subclass
decl_stmt|;
name|int
name|errorc
decl_stmt|;
name|Eptr
name|errorv
index|[]
decl_stmt|;
block|{
name|reg
name|int
name|i
decl_stmt|;
name|reg
name|Eptr
name|errorp
decl_stmt|;
for|for
control|(
name|errorp
operator|=
name|errorv
index|[
name|i
operator|=
literal|0
index|]
init|;
name|i
operator|<
name|errorc
condition|;
name|errorp
operator|=
name|errorv
index|[
operator|++
name|i
index|]
control|)
block|{
if|if
condition|(
name|errorp
operator|->
name|error_e_class
operator|==
name|C_IGNORE
condition|)
continue|continue;
if|if
condition|(
name|look_at_subclass
operator|&&
name|errorp
operator|->
name|error_s_class
operator|==
name|C_DUPL
condition|)
continue|continue;
name|printf
argument_list|(
literal|"Error %d, (%s error) [%s], text = \""
argument_list|,
name|i
argument_list|,
name|class_table
index|[
name|errorp
operator|->
name|error_e_class
index|]
argument_list|,
name|lang_table
index|[
name|errorp
operator|->
name|error_language
index|]
operator|.
name|lang_name
argument_list|)
expr_stmt|;
name|wordvprint
argument_list|(
name|stdout
argument_list|,
name|errorp
operator|->
name|error_lgtext
argument_list|,
name|errorp
operator|->
name|error_text
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|wordvprint
parameter_list|(
name|fyle
parameter_list|,
name|wordc
parameter_list|,
name|wordv
parameter_list|)
name|FILE
modifier|*
name|fyle
decl_stmt|;
name|int
name|wordc
decl_stmt|;
name|char
modifier|*
name|wordv
index|[]
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|sep
init|=
literal|""
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|wordc
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|wordv
index|[
name|i
index|]
condition|)
block|{
name|fprintf
argument_list|(
name|fyle
argument_list|,
literal|"%s%s"
argument_list|,
name|sep
argument_list|,
name|wordv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|sep
operator|=
literal|" "
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  *	Given a string, parse it into a number of words, and build  *	a wordc wordv combination pointing into it.  */
end_comment

begin_function
name|void
name|wordvbuild
parameter_list|(
name|string
parameter_list|,
name|r_wordc
parameter_list|,
name|r_wordv
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|int
modifier|*
name|r_wordc
decl_stmt|;
name|char
modifier|*
modifier|*
modifier|*
name|r_wordv
decl_stmt|;
block|{
name|reg
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|saltedbuffer
decl_stmt|;
name|char
modifier|*
modifier|*
name|wordv
decl_stmt|;
name|int
name|wordcount
decl_stmt|;
name|int
name|wordindex
decl_stmt|;
name|saltedbuffer
operator|=
name|strsave
argument_list|(
name|string
argument_list|)
expr_stmt|;
for|for
control|(
name|wordcount
operator|=
literal|0
operator|,
name|cp
operator|=
name|saltedbuffer
init|;
operator|*
name|cp
condition|;
name|wordcount
operator|++
control|)
block|{
while|while
condition|(
operator|*
name|cp
operator|&&
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|cp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|0
condition|)
break|break;
while|while
condition|(
operator|!
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|cp
operator|++
expr_stmt|;
block|}
name|wordv
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|Calloc
argument_list|(
name|wordcount
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|saltedbuffer
operator|,
name|wordindex
operator|=
literal|0
init|;
name|wordcount
condition|;
name|wordindex
operator|++
operator|,
operator|--
name|wordcount
control|)
block|{
while|while
condition|(
operator|*
name|cp
operator|&&
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|cp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|0
condition|)
break|break;
name|wordv
index|[
name|wordindex
index|]
operator|=
name|cp
expr_stmt|;
while|while
condition|(
operator|!
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|cp
operator|++
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|wordcount
operator|!=
literal|0
condition|)
name|errx
argument_list|(
literal|6
argument_list|,
literal|"initial miscount of the number of words in a line"
argument_list|)
expr_stmt|;
name|wordv
index|[
name|wordindex
index|]
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|FULLDEBUG
for|for
control|(
name|wordcount
operator|=
literal|0
init|;
name|wordcount
operator|<
name|wordindex
condition|;
name|wordcount
operator|++
control|)
name|printf
argument_list|(
literal|"Word %d = \"%s\"\n"
argument_list|,
name|wordcount
argument_list|,
name|wordv
index|[
name|wordcount
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|r_wordc
operator|=
name|wordindex
expr_stmt|;
operator|*
name|r_wordv
operator|=
name|wordv
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	Compare two 0 based wordvectors  */
end_comment

begin_function
name|int
name|wordvcmp
parameter_list|(
name|wordv1
parameter_list|,
name|wordc
parameter_list|,
name|wordv2
parameter_list|)
name|char
modifier|*
modifier|*
name|wordv1
decl_stmt|;
name|int
name|wordc
decl_stmt|;
name|char
modifier|*
modifier|*
name|wordv2
decl_stmt|;
block|{
name|reg
name|int
name|i
decl_stmt|;
name|int
name|back
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|wordc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|wordv1
index|[
name|i
index|]
operator|==
literal|0
operator|||
name|wordv2
index|[
name|i
index|]
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|(
name|back
operator|=
name|strcmp
argument_list|(
name|wordv1
index|[
name|i
index|]
argument_list|,
name|wordv2
index|[
name|i
index|]
argument_list|)
operator|)
condition|)
block|{
return|return
operator|(
name|back
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
comment|/* they are equal */
block|}
end_function

begin_comment
comment|/*  *	splice a 0 basedword vector onto the tail of a  *	new wordv, allowing the first emptyhead slots to be empty  */
end_comment

begin_function
name|char
modifier|*
modifier|*
name|wordvsplice
parameter_list|(
name|emptyhead
parameter_list|,
name|wordc
parameter_list|,
name|wordv
parameter_list|)
name|int
name|emptyhead
decl_stmt|;
name|int
name|wordc
decl_stmt|;
name|char
modifier|*
modifier|*
name|wordv
decl_stmt|;
block|{
name|reg
name|char
modifier|*
modifier|*
name|nwordv
decl_stmt|;
name|int
name|nwordc
init|=
name|emptyhead
operator|+
name|wordc
decl_stmt|;
name|reg
name|int
name|i
decl_stmt|;
name|nwordv
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|Calloc
argument_list|(
name|nwordc
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|emptyhead
condition|;
name|i
operator|++
control|)
name|nwordv
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|emptyhead
init|;
name|i
operator|<
name|nwordc
condition|;
name|i
operator|++
control|)
block|{
name|nwordv
index|[
name|i
index|]
operator|=
name|wordv
index|[
name|i
operator|-
name|emptyhead
index|]
expr_stmt|;
block|}
return|return
operator|(
name|nwordv
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	plural'ize and verb forms  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|S
init|=
literal|"s"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|N
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_function
name|char
modifier|*
name|plural
parameter_list|(
name|n
parameter_list|)
name|int
name|n
decl_stmt|;
block|{
return|return
operator|(
name|n
operator|>
literal|1
condition|?
name|S
else|:
name|N
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|verbform
parameter_list|(
name|n
parameter_list|)
name|int
name|n
decl_stmt|;
block|{
return|return
operator|(
name|n
operator|>
literal|1
condition|?
name|N
else|:
name|S
operator|)
return|;
block|}
end_function

end_unit

