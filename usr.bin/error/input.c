begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1980, 1993  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static char sccsid[] = "@(#)input.c	8.1 (Berkeley) 6/6/93";
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$Id$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"error.h"
end_include

begin_decl_stmt
name|int
name|wordc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* how long the current error message is */
end_comment

begin_decl_stmt
name|char
modifier|*
modifier|*
name|wordv
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the actual error message */
end_comment

begin_decl_stmt
name|int
name|nerrors
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|language
decl_stmt|;
end_decl_stmt

begin_function_decl
name|Errorclass
name|onelong
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|Errorclass
name|cpp
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|Errorclass
name|pccccom
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Portable C Compiler C Compiler */
end_comment

begin_function_decl
name|Errorclass
name|richieccom
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Richie Compiler for 11 */
end_comment

begin_function_decl
name|Errorclass
name|lint0
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|Errorclass
name|lint1
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|Errorclass
name|lint2
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|Errorclass
name|lint3
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|Errorclass
name|make
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|Errorclass
name|f77
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|Errorclass
name|pi
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|Errorclass
name|ri
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|Errorclass
name|troff
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|Errorclass
name|mod2
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|Errorclass
name|catchall
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *	Eat all of the lines in the input file, attempting to categorize  *	them by their various flavors  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|inbuffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|eaterrors
parameter_list|(
name|r_errorc
parameter_list|,
name|r_errorv
parameter_list|)
name|int
modifier|*
name|r_errorc
decl_stmt|;
name|Eptr
modifier|*
modifier|*
name|r_errorv
decl_stmt|;
block|{
name|Errorclass
name|errorclass
init|=
name|C_SYNC
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|fgets
argument_list|(
name|inbuffer
argument_list|,
name|BUFSIZ
argument_list|,
name|errorfile
argument_list|)
operator|==
name|NULL
condition|)
break|break;
name|wordvbuild
argument_list|(
name|inbuffer
argument_list|,
operator|&
name|wordc
argument_list|,
operator|&
name|wordv
argument_list|)
expr_stmt|;
comment|/* 	 *	for convience, convert wordv to be 1 based, instead 	 *	of 0 based. 	 */
name|wordv
operator|-=
literal|1
expr_stmt|;
if|if
condition|(
name|wordc
operator|>
literal|0
operator|&&
operator|(
operator|(
operator|(
name|errorclass
operator|=
name|onelong
argument_list|()
operator|)
operator|!=
name|C_UNKNOWN
operator|)
operator|||
operator|(
operator|(
name|errorclass
operator|=
name|cpp
argument_list|()
operator|)
operator|!=
name|C_UNKNOWN
operator|)
operator|||
operator|(
operator|(
name|errorclass
operator|=
name|pccccom
argument_list|()
operator|)
operator|!=
name|C_UNKNOWN
operator|)
operator|||
operator|(
operator|(
name|errorclass
operator|=
name|richieccom
argument_list|()
operator|)
operator|!=
name|C_UNKNOWN
operator|)
operator|||
operator|(
operator|(
name|errorclass
operator|=
name|lint0
argument_list|()
operator|)
operator|!=
name|C_UNKNOWN
operator|)
operator|||
operator|(
operator|(
name|errorclass
operator|=
name|lint1
argument_list|()
operator|)
operator|!=
name|C_UNKNOWN
operator|)
operator|||
operator|(
operator|(
name|errorclass
operator|=
name|lint2
argument_list|()
operator|)
operator|!=
name|C_UNKNOWN
operator|)
operator|||
operator|(
operator|(
name|errorclass
operator|=
name|lint3
argument_list|()
operator|)
operator|!=
name|C_UNKNOWN
operator|)
operator|||
operator|(
operator|(
name|errorclass
operator|=
name|make
argument_list|()
operator|)
operator|!=
name|C_UNKNOWN
operator|)
operator|||
operator|(
operator|(
name|errorclass
operator|=
name|f77
argument_list|()
operator|)
operator|!=
name|C_UNKNOWN
operator|)
operator|||
operator|(
operator|(
name|errorclass
operator|=
name|pi
argument_list|()
operator|)
operator|!=
name|C_UNKNOWN
operator|)
operator|||
operator|(
operator|(
name|errorclass
operator|=
name|ri
argument_list|()
operator|)
operator|!=
name|C_UNKNOWN
operator|)
operator|||
operator|(
operator|(
name|errorclass
operator|=
name|mod2
argument_list|()
operator|)
operator|!=
name|C_UNKNOWN
operator|)
operator|||
operator|(
operator|(
name|errorclass
operator|=
name|troff
argument_list|()
operator|)
operator|!=
name|C_UNKNOWN
operator|)
operator|)
condition|)
empty_stmt|;
else|else
name|errorclass
operator|=
name|catchall
argument_list|()
expr_stmt|;
if|if
condition|(
name|wordc
condition|)
name|erroradd
argument_list|(
name|wordc
argument_list|,
name|wordv
operator|+
literal|1
argument_list|,
name|errorclass
argument_list|,
name|C_UNKNOWN
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|FULLDEBUG
name|printf
argument_list|(
literal|"%d errorentrys\n"
argument_list|,
name|nerrors
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|arrayify
argument_list|(
name|r_errorc
argument_list|,
name|r_errorv
argument_list|,
name|er_head
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	create a new error entry, given a zero based array and count  */
end_comment

begin_function
name|void
name|erroradd
parameter_list|(
name|errorlength
parameter_list|,
name|errorv
parameter_list|,
name|errorclass
parameter_list|,
name|errorsubclass
parameter_list|)
name|int
name|errorlength
decl_stmt|;
name|char
modifier|*
modifier|*
name|errorv
decl_stmt|;
name|Errorclass
name|errorclass
decl_stmt|;
name|Errorclass
name|errorsubclass
decl_stmt|;
block|{
name|reg
name|Eptr
name|newerror
decl_stmt|;
name|reg
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|errorclass
operator|==
name|C_TRUE
condition|)
block|{
comment|/* check canonicalization of the second argument*/
for|for
control|(
name|cp
operator|=
name|errorv
index|[
literal|1
index|]
init|;
operator|*
name|cp
operator|&&
name|isdigit
argument_list|(
operator|*
name|cp
argument_list|)
condition|;
name|cp
operator|++
control|)
continue|continue;
name|errorclass
operator|=
operator|(
operator|*
name|cp
operator|==
literal|'\0'
operator|)
condition|?
name|C_TRUE
else|:
name|C_NONSPEC
expr_stmt|;
ifdef|#
directive|ifdef
name|FULLDEBUG
if|if
condition|(
name|errorclass
operator|!=
name|C_TRUE
condition|)
name|printf
argument_list|(
literal|"The 2nd word, \"%s\" is not a number.\n"
argument_list|,
name|errorv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|errorlength
operator|>
literal|0
condition|)
block|{
name|newerror
operator|=
operator|(
name|Eptr
operator|)
name|Calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|Edesc
argument_list|)
argument_list|)
expr_stmt|;
name|newerror
operator|->
name|error_language
operator|=
name|language
expr_stmt|;
comment|/* language is global */
name|newerror
operator|->
name|error_text
operator|=
name|errorv
expr_stmt|;
name|newerror
operator|->
name|error_lgtext
operator|=
name|errorlength
expr_stmt|;
if|if
condition|(
name|errorclass
operator|==
name|C_TRUE
condition|)
name|newerror
operator|->
name|error_line
operator|=
name|atoi
argument_list|(
name|errorv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|newerror
operator|->
name|error_e_class
operator|=
name|errorclass
expr_stmt|;
name|newerror
operator|->
name|error_s_class
operator|=
name|errorsubclass
expr_stmt|;
switch|switch
condition|(
name|newerror
operator|->
name|error_e_class
operator|=
name|discardit
argument_list|(
name|newerror
argument_list|)
condition|)
block|{
case|case
name|C_SYNC
case|:
name|nsyncerrors
operator|++
expr_stmt|;
break|break;
case|case
name|C_DISCARD
case|:
name|ndiscard
operator|++
expr_stmt|;
break|break;
case|case
name|C_NULLED
case|:
name|nnulled
operator|++
expr_stmt|;
break|break;
case|case
name|C_NONSPEC
case|:
name|nnonspec
operator|++
expr_stmt|;
break|break;
case|case
name|C_THISFILE
case|:
name|nthisfile
operator|++
expr_stmt|;
break|break;
case|case
name|C_TRUE
case|:
name|ntrue
operator|++
expr_stmt|;
break|break;
case|case
name|C_UNKNOWN
case|:
name|nunknown
operator|++
expr_stmt|;
break|break;
case|case
name|C_IGNORE
case|:
name|nignore
operator|++
expr_stmt|;
break|break;
block|}
name|newerror
operator|->
name|error_next
operator|=
name|er_head
expr_stmt|;
name|er_head
operator|=
name|newerror
expr_stmt|;
name|newerror
operator|->
name|error_no
operator|=
name|nerrors
operator|++
expr_stmt|;
block|}
comment|/* length> 0 */
block|}
end_function

begin_function
name|Errorclass
name|onelong
parameter_list|()
block|{
name|char
modifier|*
modifier|*
name|nwordv
decl_stmt|;
if|if
condition|(
operator|(
name|wordc
operator|==
literal|1
operator|)
operator|&&
operator|(
name|language
operator|!=
name|INLD
operator|)
condition|)
block|{
comment|/* 		 *	We have either: 		 *	a)	file name from cc 		 *	b)	Assembler telling world that it is complaining 		 *	c)	Noise from make ("Stop.") 		 *	c)	Random noise 		 */
name|wordc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|wordv
index|[
literal|1
index|]
argument_list|,
literal|"Stop."
argument_list|)
operator|==
literal|0
condition|)
block|{
name|language
operator|=
name|INMAKE
expr_stmt|;
return|return
operator|(
name|C_SYNC
operator|)
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|wordv
index|[
literal|1
index|]
argument_list|,
literal|"Assembler:"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* assembler always alerts us to what happened*/
name|language
operator|=
name|INAS
expr_stmt|;
return|return
operator|(
name|C_SYNC
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|wordv
index|[
literal|1
index|]
argument_list|,
literal|"Undefined:"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* loader complains about unknown symbols*/
name|language
operator|=
name|INLD
expr_stmt|;
return|return
operator|(
name|C_SYNC
operator|)
return|;
block|}
if|if
condition|(
name|lastchar
argument_list|(
name|wordv
index|[
literal|1
index|]
argument_list|)
operator|==
literal|':'
condition|)
block|{
comment|/* cc tells us what file we are in */
name|currentfilename
operator|=
name|wordv
index|[
literal|1
index|]
expr_stmt|;
operator|(
name|void
operator|)
name|substitute
argument_list|(
name|currentfilename
argument_list|,
literal|':'
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
name|language
operator|=
name|INCC
expr_stmt|;
return|return
operator|(
name|C_SYNC
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|wordc
operator|==
literal|1
operator|)
operator|&&
operator|(
name|language
operator|==
name|INLD
operator|)
condition|)
block|{
name|nwordv
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|Calloc
argument_list|(
literal|4
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|nwordv
index|[
literal|0
index|]
operator|=
literal|"ld:"
expr_stmt|;
name|nwordv
index|[
literal|1
index|]
operator|=
name|wordv
index|[
literal|1
index|]
expr_stmt|;
name|nwordv
index|[
literal|2
index|]
operator|=
literal|"is"
expr_stmt|;
name|nwordv
index|[
literal|3
index|]
operator|=
literal|"undefined."
expr_stmt|;
name|wordc
operator|=
literal|4
expr_stmt|;
name|wordv
operator|=
name|nwordv
operator|-
literal|1
expr_stmt|;
return|return
operator|(
name|C_NONSPEC
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|wordc
operator|==
literal|1
condition|)
block|{
return|return
operator|(
name|C_SYNC
operator|)
return|;
block|}
return|return
operator|(
name|C_UNKNOWN
operator|)
return|;
block|}
end_function

begin_comment
comment|/* end of one long */
end_comment

begin_function
name|Errorclass
name|cpp
parameter_list|()
block|{
comment|/* 	 *	Now attempt a cpp error message match 	 *	Examples: 	 *		./morse.h: 23: undefined control 	 *		morsesend.c: 229: MAGNIBBL: argument mismatch 	 *		morsesend.c: 237: MAGNIBBL: argument mismatch 	 *		test1.c: 6: undefined control 	 */
if|if
condition|(
operator|(
name|language
operator|!=
name|INLD
operator|)
comment|/* loader errors have almost same fmt*/
operator|&&
operator|(
name|lastchar
argument_list|(
name|wordv
index|[
literal|1
index|]
argument_list|)
operator|==
literal|':'
operator|)
operator|&&
operator|(
name|isdigit
argument_list|(
name|firstchar
argument_list|(
name|wordv
index|[
literal|2
index|]
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|lastchar
argument_list|(
name|wordv
index|[
literal|2
index|]
argument_list|)
operator|==
literal|':'
operator|)
condition|)
block|{
name|language
operator|=
name|INCPP
expr_stmt|;
name|clob_last
argument_list|(
name|wordv
index|[
literal|1
index|]
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
name|clob_last
argument_list|(
name|wordv
index|[
literal|2
index|]
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
return|return
operator|(
name|C_TRUE
operator|)
return|;
block|}
return|return
operator|(
name|C_UNKNOWN
operator|)
return|;
block|}
end_function

begin_comment
comment|/*end of cpp*/
end_comment

begin_function
name|Errorclass
name|pccccom
parameter_list|()
block|{
comment|/* 	 *	Now attempt a ccom error message match: 	 *	Examples: 	 *	  "morsesend.c", line 237: operands of& have incompatible types 	 *	  "test.c", line 7: warning: old-fashioned initialization: use = 	 *	  "subdir.d/foo2.h", line 1: illegal initialization 	 */
if|if
condition|(
operator|(
name|firstchar
argument_list|(
name|wordv
index|[
literal|1
index|]
argument_list|)
operator|==
literal|'"'
operator|)
operator|&&
operator|(
name|lastchar
argument_list|(
name|wordv
index|[
literal|1
index|]
argument_list|)
operator|==
literal|','
operator|)
operator|&&
operator|(
name|next_lastchar
argument_list|(
name|wordv
index|[
literal|1
index|]
argument_list|)
operator|==
literal|'"'
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|wordv
index|[
literal|2
index|]
argument_list|,
literal|"line"
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|isdigit
argument_list|(
name|firstchar
argument_list|(
name|wordv
index|[
literal|3
index|]
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|lastchar
argument_list|(
name|wordv
index|[
literal|3
index|]
argument_list|)
operator|==
literal|':'
operator|)
condition|)
block|{
name|clob_last
argument_list|(
name|wordv
index|[
literal|1
index|]
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
comment|/* drop last , */
name|clob_last
argument_list|(
name|wordv
index|[
literal|1
index|]
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
comment|/* drop last " */
name|wordv
index|[
literal|1
index|]
operator|++
expr_stmt|;
comment|/* drop first " */
name|clob_last
argument_list|(
name|wordv
index|[
literal|3
index|]
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
comment|/* drop : on line number */
name|wordv
index|[
literal|2
index|]
operator|=
name|wordv
index|[
literal|1
index|]
expr_stmt|;
comment|/* overwrite "line" */
name|wordv
operator|++
expr_stmt|;
comment|/*compensate*/
name|wordc
operator|--
expr_stmt|;
name|currentfilename
operator|=
name|wordv
index|[
literal|1
index|]
expr_stmt|;
name|language
operator|=
name|INCC
expr_stmt|;
return|return
operator|(
name|C_TRUE
operator|)
return|;
block|}
return|return
operator|(
name|C_UNKNOWN
operator|)
return|;
block|}
end_function

begin_comment
comment|/* end of ccom */
end_comment

begin_comment
comment|/*  *	Do the error message from the Richie C Compiler for the PDP11,  *	which has this source:  *  *	if (filename[0])  *		fprintf(stderr, "%s:", filename);  *	fprintf(stderr, "%d: ", line);  *  */
end_comment

begin_function
name|Errorclass
name|richieccom
parameter_list|()
block|{
name|reg
name|char
modifier|*
name|cp
decl_stmt|;
name|reg
name|char
modifier|*
modifier|*
name|nwordv
decl_stmt|;
name|char
modifier|*
name|file
decl_stmt|;
if|if
condition|(
name|lastchar
argument_list|(
name|wordv
index|[
literal|1
index|]
argument_list|)
operator|==
literal|':'
condition|)
block|{
name|cp
operator|=
name|wordv
index|[
literal|1
index|]
operator|+
name|strlen
argument_list|(
name|wordv
index|[
literal|1
index|]
argument_list|)
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|*
operator|--
name|cp
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|*
name|cp
operator|==
literal|':'
condition|)
block|{
name|clob_last
argument_list|(
name|wordv
index|[
literal|1
index|]
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
comment|/* last : */
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
comment|/* first : */
name|file
operator|=
name|wordv
index|[
literal|1
index|]
expr_stmt|;
name|nwordv
operator|=
name|wordvsplice
argument_list|(
literal|1
argument_list|,
name|wordc
argument_list|,
name|wordv
operator|+
literal|1
argument_list|)
expr_stmt|;
name|nwordv
index|[
literal|0
index|]
operator|=
name|file
expr_stmt|;
name|nwordv
index|[
literal|1
index|]
operator|=
name|cp
operator|+
literal|1
expr_stmt|;
name|wordc
operator|+=
literal|1
expr_stmt|;
name|wordv
operator|=
name|nwordv
operator|-
literal|1
expr_stmt|;
name|language
operator|=
name|INCC
expr_stmt|;
name|currentfilename
operator|=
name|wordv
index|[
literal|1
index|]
expr_stmt|;
return|return
operator|(
name|C_TRUE
operator|)
return|;
block|}
block|}
return|return
operator|(
name|C_UNKNOWN
operator|)
return|;
block|}
end_function

begin_function
name|Errorclass
name|lint0
parameter_list|()
block|{
name|reg
name|char
modifier|*
modifier|*
name|nwordv
decl_stmt|;
name|char
modifier|*
name|line
decl_stmt|,
modifier|*
name|file
decl_stmt|;
comment|/* 	 *	Attempt a match for the new lint style normal compiler 	 *	error messages, of the form 	 * 	 *	printf("%s(%d): %s\n", filename, linenumber, message); 	 */
if|if
condition|(
name|wordc
operator|>=
literal|2
condition|)
block|{
if|if
condition|(
operator|(
name|lastchar
argument_list|(
name|wordv
index|[
literal|1
index|]
argument_list|)
operator|==
literal|':'
operator|)
operator|&&
operator|(
name|next_lastchar
argument_list|(
name|wordv
index|[
literal|1
index|]
argument_list|)
operator|==
literal|')'
operator|)
condition|)
block|{
name|clob_last
argument_list|(
name|wordv
index|[
literal|1
index|]
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
comment|/* colon */
if|if
condition|(
name|persperdexplode
argument_list|(
name|wordv
index|[
literal|1
index|]
argument_list|,
operator|&
name|line
argument_list|,
operator|&
name|file
argument_list|)
condition|)
block|{
name|nwordv
operator|=
name|wordvsplice
argument_list|(
literal|1
argument_list|,
name|wordc
argument_list|,
name|wordv
operator|+
literal|1
argument_list|)
expr_stmt|;
name|nwordv
index|[
literal|0
index|]
operator|=
name|file
expr_stmt|;
comment|/* file name */
name|nwordv
index|[
literal|1
index|]
operator|=
name|line
expr_stmt|;
comment|/* line number */
name|wordc
operator|+=
literal|1
expr_stmt|;
name|wordv
operator|=
name|nwordv
operator|-
literal|1
expr_stmt|;
name|language
operator|=
name|INLINT
expr_stmt|;
return|return
operator|(
name|C_TRUE
operator|)
return|;
block|}
name|wordv
index|[
literal|1
index|]
index|[
name|strlen
argument_list|(
name|wordv
index|[
literal|1
index|]
argument_list|)
index|]
operator|=
literal|':'
expr_stmt|;
block|}
block|}
return|return
operator|(
name|C_UNKNOWN
operator|)
return|;
block|}
end_function

begin_function
name|Errorclass
name|lint1
parameter_list|()
block|{
name|char
modifier|*
name|line1
decl_stmt|,
modifier|*
name|line2
decl_stmt|;
name|char
modifier|*
name|file1
decl_stmt|,
modifier|*
name|file2
decl_stmt|;
name|char
modifier|*
modifier|*
name|nwordv1
decl_stmt|,
modifier|*
modifier|*
name|nwordv2
decl_stmt|;
comment|/* 	 *	Now, attempt a match for the various errors that lint 	 *	can complain about. 	 * 	 *	Look first for type 1 lint errors 	 */
if|if
condition|(
name|wordc
operator|>
literal|1
operator|&&
name|strcmp
argument_list|(
name|wordv
index|[
name|wordc
operator|-
literal|1
index|]
argument_list|,
literal|"::"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/*   	  * %.7s, arg. %d used inconsistently %s(%d) :: %s(%d)   	  * %.7s value used inconsistently %s(%d) :: %s(%d)   	  * %.7s multiply declared %s(%d) :: %s(%d)   	  * %.7s value declared inconsistently %s(%d) :: %s(%d)   	  * %.7s function value type must be declared before use %s(%d) :: %s(%d) 	  */
name|language
operator|=
name|INLINT
expr_stmt|;
if|if
condition|(
name|wordc
operator|>
literal|2
operator|&&
operator|(
name|persperdexplode
argument_list|(
name|wordv
index|[
name|wordc
index|]
argument_list|,
operator|&
name|line2
argument_list|,
operator|&
name|file2
argument_list|)
operator|)
operator|&&
operator|(
name|persperdexplode
argument_list|(
name|wordv
index|[
name|wordc
operator|-
literal|2
index|]
argument_list|,
operator|&
name|line1
argument_list|,
operator|&
name|file1
argument_list|)
operator|)
condition|)
block|{
name|nwordv1
operator|=
name|wordvsplice
argument_list|(
literal|2
argument_list|,
name|wordc
argument_list|,
name|wordv
operator|+
literal|1
argument_list|)
expr_stmt|;
name|nwordv2
operator|=
name|wordvsplice
argument_list|(
literal|2
argument_list|,
name|wordc
argument_list|,
name|wordv
operator|+
literal|1
argument_list|)
expr_stmt|;
name|nwordv1
index|[
literal|0
index|]
operator|=
name|file1
expr_stmt|;
name|nwordv1
index|[
literal|1
index|]
operator|=
name|line1
expr_stmt|;
name|erroradd
argument_list|(
name|wordc
operator|+
literal|2
argument_list|,
name|nwordv1
argument_list|,
name|C_TRUE
argument_list|,
name|C_DUPL
argument_list|)
expr_stmt|;
comment|/* takes 0 based*/
name|nwordv2
index|[
literal|0
index|]
operator|=
name|file2
expr_stmt|;
name|nwordv2
index|[
literal|1
index|]
operator|=
name|line2
expr_stmt|;
name|wordc
operator|=
name|wordc
operator|+
literal|2
expr_stmt|;
name|wordv
operator|=
name|nwordv2
operator|-
literal|1
expr_stmt|;
comment|/* 1 based */
return|return
operator|(
name|C_TRUE
operator|)
return|;
block|}
block|}
return|return
operator|(
name|C_UNKNOWN
operator|)
return|;
block|}
end_function

begin_comment
comment|/* end of lint 1*/
end_comment

begin_function
name|Errorclass
name|lint2
parameter_list|()
block|{
name|char
modifier|*
name|file
decl_stmt|;
name|char
modifier|*
name|line
decl_stmt|;
name|char
modifier|*
modifier|*
name|nwordv
decl_stmt|;
comment|/* 	 *	Look for type 2 lint errors 	 * 	 *	%.7s used( %s(%d) ), but not defined 	 *	%.7s defined( %s(%d) ), but never used 	 *	%.7s declared( %s(%d) ), but never used or defined 	 * 	 *	bufp defined( "./metric.h"(10) ), but never used 	 */
if|if
condition|(
operator|(
name|lastchar
argument_list|(
name|wordv
index|[
literal|2
index|]
argument_list|)
operator|==
literal|'('
comment|/* ')' */
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|wordv
index|[
literal|4
index|]
argument_list|,
literal|"),"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|language
operator|=
name|INLINT
expr_stmt|;
if|if
condition|(
name|persperdexplode
argument_list|(
name|wordv
index|[
literal|3
index|]
argument_list|,
operator|&
name|line
argument_list|,
operator|&
name|file
argument_list|)
condition|)
block|{
name|nwordv
operator|=
name|wordvsplice
argument_list|(
literal|2
argument_list|,
name|wordc
argument_list|,
name|wordv
operator|+
literal|1
argument_list|)
expr_stmt|;
name|nwordv
index|[
literal|0
index|]
operator|=
name|file
expr_stmt|;
name|nwordv
index|[
literal|1
index|]
operator|=
name|line
expr_stmt|;
name|wordc
operator|=
name|wordc
operator|+
literal|2
expr_stmt|;
name|wordv
operator|=
name|nwordv
operator|-
literal|1
expr_stmt|;
comment|/* 1 based */
return|return
operator|(
name|C_TRUE
operator|)
return|;
block|}
block|}
return|return
operator|(
name|C_UNKNOWN
operator|)
return|;
block|}
end_function

begin_comment
comment|/* end of lint 2*/
end_comment

begin_decl_stmt
name|char
modifier|*
name|Lint31
index|[
literal|4
index|]
init|=
block|{
literal|"returns"
block|,
literal|"value"
block|,
literal|"which"
block|,
literal|"is"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|Lint32
index|[
literal|6
index|]
init|=
block|{
literal|"value"
block|,
literal|"is"
block|,
literal|"used,"
block|,
literal|"but"
block|,
literal|"none"
block|,
literal|"returned"
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|Errorclass
name|lint3
parameter_list|()
block|{
if|if
condition|(
operator|(
name|wordvcmp
argument_list|(
name|wordv
operator|+
literal|2
argument_list|,
literal|4
argument_list|,
name|Lint31
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|wordvcmp
argument_list|(
name|wordv
operator|+
literal|2
argument_list|,
literal|6
argument_list|,
name|Lint32
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|language
operator|=
name|INLINT
expr_stmt|;
return|return
operator|(
name|C_NONSPEC
operator|)
return|;
block|}
return|return
operator|(
name|C_UNKNOWN
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	Special word vectors for use by F77 recognition  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|F77_fatal
index|[
literal|3
index|]
init|=
block|{
literal|"Compiler"
block|,
literal|"error"
block|,
literal|"line"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|F77_error
index|[
literal|3
index|]
init|=
block|{
literal|"Error"
block|,
literal|"on"
block|,
literal|"line"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|F77_warning
index|[
literal|3
index|]
init|=
block|{
literal|"Warning"
block|,
literal|"on"
block|,
literal|"line"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|F77_no_ass
index|[
literal|3
index|]
init|=
block|{
literal|"Error."
block|,
literal|"No"
block|,
literal|"assembly."
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|Errorclass
name|f77
parameter_list|()
block|{
name|char
modifier|*
modifier|*
name|nwordv
decl_stmt|;
comment|/* 	 *	look for f77 errors: 	 *	Error messages from /usr/src/cmd/f77/error.c, with 	 *	these printf formats: 	 * 	 *		Compiler error line %d of %s: %s 	 *		Error on line %d of %s: %s 	 *		Warning on line %d of %s: %s 	 *		Error.  No assembly. 	 */
if|if
condition|(
name|wordc
operator|==
literal|3
operator|&&
name|wordvcmp
argument_list|(
name|wordv
operator|+
literal|1
argument_list|,
literal|3
argument_list|,
name|F77_no_ass
argument_list|)
operator|==
literal|0
condition|)
block|{
name|wordc
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|C_SYNC
operator|)
return|;
block|}
if|if
condition|(
name|wordc
operator|<
literal|6
condition|)
return|return
operator|(
name|C_UNKNOWN
operator|)
return|;
if|if
condition|(
operator|(
name|lastchar
argument_list|(
name|wordv
index|[
literal|6
index|]
argument_list|)
operator|==
literal|':'
operator|)
operator|&&
operator|(
operator|(
name|wordvcmp
argument_list|(
name|wordv
operator|+
literal|1
argument_list|,
literal|3
argument_list|,
name|F77_fatal
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|wordvcmp
argument_list|(
name|wordv
operator|+
literal|1
argument_list|,
literal|3
argument_list|,
name|F77_error
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|wordvcmp
argument_list|(
name|wordv
operator|+
literal|1
argument_list|,
literal|3
argument_list|,
name|F77_warning
argument_list|)
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
name|language
operator|=
name|INF77
expr_stmt|;
name|nwordv
operator|=
name|wordvsplice
argument_list|(
literal|2
argument_list|,
name|wordc
argument_list|,
name|wordv
operator|+
literal|1
argument_list|)
expr_stmt|;
name|nwordv
index|[
literal|0
index|]
operator|=
name|wordv
index|[
literal|6
index|]
expr_stmt|;
name|clob_last
argument_list|(
name|nwordv
index|[
literal|0
index|]
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
name|nwordv
index|[
literal|1
index|]
operator|=
name|wordv
index|[
literal|4
index|]
expr_stmt|;
name|wordc
operator|+=
literal|2
expr_stmt|;
name|wordv
operator|=
name|nwordv
operator|-
literal|1
expr_stmt|;
comment|/* 1 based */
return|return
operator|(
name|C_TRUE
operator|)
return|;
block|}
return|return
operator|(
name|C_UNKNOWN
operator|)
return|;
block|}
end_function

begin_comment
comment|/* end of f77 */
end_comment

begin_decl_stmt
name|char
modifier|*
name|Make_Croak
index|[
literal|3
index|]
init|=
block|{
literal|"***"
block|,
literal|"Error"
block|,
literal|"code"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|Make_NotRemade
index|[
literal|5
index|]
init|=
block|{
literal|"not"
block|,
literal|"remade"
block|,
literal|"because"
block|,
literal|"of"
block|,
literal|"errors"
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|Errorclass
name|make
parameter_list|()
block|{
if|if
condition|(
name|wordvcmp
argument_list|(
name|wordv
operator|+
literal|1
argument_list|,
literal|3
argument_list|,
name|Make_Croak
argument_list|)
operator|==
literal|0
condition|)
block|{
name|language
operator|=
name|INMAKE
expr_stmt|;
return|return
operator|(
name|C_SYNC
operator|)
return|;
block|}
if|if
condition|(
name|wordvcmp
argument_list|(
name|wordv
operator|+
literal|2
argument_list|,
literal|5
argument_list|,
name|Make_NotRemade
argument_list|)
operator|==
literal|0
condition|)
block|{
name|language
operator|=
name|INMAKE
expr_stmt|;
return|return
operator|(
name|C_SYNC
operator|)
return|;
block|}
return|return
operator|(
name|C_UNKNOWN
operator|)
return|;
block|}
end_function

begin_function
name|Errorclass
name|ri
parameter_list|()
block|{
comment|/*  *	Match an error message produced by ri; here is the  *	procedure yanked from the distributed version of ri  *	April 24, 1980.  *  *	serror(str, x1, x2, x3)  *		char str[];  *		char *x1, *x2, *x3;  *	{  *		extern int yylineno;  *  *		putc('"', stdout);  *		fputs(srcfile, stdout);  *		putc('"', stdout);  *		fprintf(stdout, " %d: ", yylineno);  *		fprintf(stdout, str, x1, x2, x3);  *		fprintf(stdout, "\n");  *		synerrs++;  *	}  */
if|if
condition|(
operator|(
name|firstchar
argument_list|(
name|wordv
index|[
literal|1
index|]
argument_list|)
operator|==
literal|'"'
operator|)
operator|&&
operator|(
name|lastchar
argument_list|(
name|wordv
index|[
literal|1
index|]
argument_list|)
operator|==
literal|'"'
operator|)
operator|&&
operator|(
name|lastchar
argument_list|(
name|wordv
index|[
literal|2
index|]
argument_list|)
operator|==
literal|':'
operator|)
operator|&&
operator|(
name|isdigit
argument_list|(
name|firstchar
argument_list|(
name|wordv
index|[
literal|2
index|]
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|clob_last
argument_list|(
name|wordv
index|[
literal|1
index|]
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
comment|/* drop the last " */
name|wordv
index|[
literal|1
index|]
operator|++
expr_stmt|;
comment|/* skip over the first " */
name|clob_last
argument_list|(
name|wordv
index|[
literal|2
index|]
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
name|language
operator|=
name|INRI
expr_stmt|;
return|return
operator|(
name|C_TRUE
operator|)
return|;
block|}
return|return
operator|(
name|C_UNKNOWN
operator|)
return|;
block|}
end_function

begin_function
name|Errorclass
name|catchall
parameter_list|()
block|{
comment|/* 	 *	Catches random things. 	 */
name|language
operator|=
name|INUNKNOWN
expr_stmt|;
return|return
operator|(
name|C_NONSPEC
operator|)
return|;
block|}
end_function

begin_comment
comment|/* end of catch all*/
end_comment

begin_function
name|Errorclass
name|troff
parameter_list|()
block|{
comment|/* 	 *	troff source error message, from eqn, bib, tbl... 	 *	Just like pcc ccom, except uses `' 	 */
if|if
condition|(
operator|(
name|firstchar
argument_list|(
name|wordv
index|[
literal|1
index|]
argument_list|)
operator|==
literal|'`'
operator|)
operator|&&
operator|(
name|lastchar
argument_list|(
name|wordv
index|[
literal|1
index|]
argument_list|)
operator|==
literal|','
operator|)
operator|&&
operator|(
name|next_lastchar
argument_list|(
name|wordv
index|[
literal|1
index|]
argument_list|)
operator|==
literal|'\''
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|wordv
index|[
literal|2
index|]
argument_list|,
literal|"line"
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|isdigit
argument_list|(
name|firstchar
argument_list|(
name|wordv
index|[
literal|3
index|]
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|lastchar
argument_list|(
name|wordv
index|[
literal|3
index|]
argument_list|)
operator|==
literal|':'
operator|)
condition|)
block|{
name|clob_last
argument_list|(
name|wordv
index|[
literal|1
index|]
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
comment|/* drop last , */
name|clob_last
argument_list|(
name|wordv
index|[
literal|1
index|]
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
comment|/* drop last " */
name|wordv
index|[
literal|1
index|]
operator|++
expr_stmt|;
comment|/* drop first " */
name|clob_last
argument_list|(
name|wordv
index|[
literal|3
index|]
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
comment|/* drop : on line number */
name|wordv
index|[
literal|2
index|]
operator|=
name|wordv
index|[
literal|1
index|]
expr_stmt|;
comment|/* overwrite "line" */
name|wordv
operator|++
expr_stmt|;
comment|/*compensate*/
name|currentfilename
operator|=
name|wordv
index|[
literal|1
index|]
expr_stmt|;
name|language
operator|=
name|INTROFF
expr_stmt|;
return|return
operator|(
name|C_TRUE
operator|)
return|;
block|}
return|return
operator|(
name|C_UNKNOWN
operator|)
return|;
block|}
end_function

begin_function
name|Errorclass
name|mod2
parameter_list|()
block|{
comment|/* 	 *	for decwrl modula2 compiler (powell) 	 */
if|if
condition|(
operator|(
operator|(
name|strcmp
argument_list|(
name|wordv
index|[
literal|1
index|]
argument_list|,
literal|"!!!"
argument_list|)
operator|==
literal|0
operator|)
comment|/* early version */
operator|||
operator|(
name|strcmp
argument_list|(
name|wordv
index|[
literal|1
index|]
argument_list|,
literal|"File"
argument_list|)
operator|==
literal|0
operator|)
operator|)
comment|/* later version */
operator|&&
operator|(
name|lastchar
argument_list|(
name|wordv
index|[
literal|2
index|]
argument_list|)
operator|==
literal|','
operator|)
comment|/* file name */
operator|&&
operator|(
name|strcmp
argument_list|(
name|wordv
index|[
literal|3
index|]
argument_list|,
literal|"line"
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|isdigit
argument_list|(
name|firstchar
argument_list|(
name|wordv
index|[
literal|4
index|]
argument_list|)
argument_list|)
operator|)
comment|/* line number */
operator|&&
operator|(
name|lastchar
argument_list|(
name|wordv
index|[
literal|4
index|]
argument_list|)
operator|==
literal|':'
operator|)
comment|/* line number */
condition|)
block|{
name|clob_last
argument_list|(
name|wordv
index|[
literal|2
index|]
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
comment|/* drop last , on file name */
name|clob_last
argument_list|(
name|wordv
index|[
literal|4
index|]
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
comment|/* drop last : on line number */
name|wordv
index|[
literal|3
index|]
operator|=
name|wordv
index|[
literal|2
index|]
expr_stmt|;
comment|/* file name on top of "line" */
name|wordv
operator|+=
literal|2
expr_stmt|;
name|wordc
operator|-=
literal|2
expr_stmt|;
name|currentfilename
operator|=
name|wordv
index|[
literal|1
index|]
expr_stmt|;
name|language
operator|=
name|INMOD2
expr_stmt|;
return|return
operator|(
name|C_TRUE
operator|)
return|;
block|}
return|return
operator|(
name|C_UNKNOWN
operator|)
return|;
block|}
end_function

end_unit

