begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: init.c,v 1.5 2001/02/19 20:50:17 jdolecek Exp $	*/
end_comment

begin_comment
comment|/*-  * Copyright (c) 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Peter McIlroy.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"sort.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|__RCSID("$NetBSD: init.c,v 1.5 2001/02/19 20:50:17 jdolecek Exp $"); __SCCSID("@(#)init.c	8.1 (Berkeley) 6/6/93");
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_function_decl
specifier|static
name|void
name|insertcol
parameter_list|(
name|struct
name|field
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|setcolumn
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|struct
name|field
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|setfield
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|struct
name|field
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|findgap
parameter_list|(
name|u_char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|shift_at_REC_D
parameter_list|(
name|u_char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|collcmp
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|struct
name|coldesc
name|clist
index|[
operator|(
name|ND
operator|+
literal|1
operator|)
operator|*
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|ncols
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_char
name|gweights
index|[
name|NBINS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * masks of ignored characters.  Alltable is 256 ones.  */
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|alltable
index|[
name|NBINS
index|]
decl_stmt|,
name|dtable
index|[
name|NBINS
index|]
decl_stmt|,
name|itable
index|[
name|NBINS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * clist (list of columns which correspond to one or more icol or tcol)  * is in increasing order of columns.  * Fields are kept in increasing order of fields.  */
end_comment

begin_comment
comment|/*   * keep clist in order--inserts a column in a sorted array  */
end_comment

begin_function
specifier|static
name|void
name|insertcol
parameter_list|(
name|field
parameter_list|)
name|struct
name|field
modifier|*
name|field
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ncols
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|field
operator|->
name|icol
operator|.
name|num
operator|<=
name|clist
index|[
name|i
index|]
operator|.
name|num
condition|)
break|break;
if|if
condition|(
name|field
operator|->
name|icol
operator|.
name|num
operator|!=
name|clist
index|[
name|i
index|]
operator|.
name|num
condition|)
block|{
name|memmove
argument_list|(
name|clist
operator|+
name|i
operator|+
literal|1
argument_list|,
name|clist
operator|+
name|i
argument_list|,
sizeof|sizeof
argument_list|(
name|COLDESC
argument_list|)
operator|*
operator|(
name|ncols
operator|-
name|i
operator|)
argument_list|)
expr_stmt|;
name|clist
index|[
name|i
index|]
operator|.
name|num
operator|=
name|field
operator|->
name|icol
operator|.
name|num
expr_stmt|;
name|ncols
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|field
operator|->
name|tcol
operator|.
name|num
operator|&&
name|field
operator|->
name|tcol
operator|.
name|num
operator|!=
name|field
operator|->
name|icol
operator|.
name|num
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ncols
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|field
operator|->
name|tcol
operator|.
name|num
operator|<=
name|clist
index|[
name|i
index|]
operator|.
name|num
condition|)
break|break;
if|if
condition|(
name|field
operator|->
name|tcol
operator|.
name|num
operator|!=
name|clist
index|[
name|i
index|]
operator|.
name|num
condition|)
block|{
name|memmove
argument_list|(
name|clist
operator|+
name|i
operator|+
literal|1
argument_list|,
name|clist
operator|+
name|i
argument_list|,
sizeof|sizeof
argument_list|(
name|COLDESC
argument_list|)
operator|*
operator|(
name|ncols
operator|-
name|i
operator|)
argument_list|)
expr_stmt|;
name|clist
index|[
name|i
index|]
operator|.
name|num
operator|=
name|field
operator|->
name|tcol
operator|.
name|num
expr_stmt|;
name|ncols
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * matches fields with the appropriate columns--n^2 but who cares?  */
end_comment

begin_function
name|void
name|fldreset
parameter_list|(
name|fldtab
parameter_list|)
name|struct
name|field
modifier|*
name|fldtab
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|fldtab
index|[
literal|0
index|]
operator|.
name|tcol
operator|.
name|p
operator|=
name|clist
operator|+
name|ncols
operator|-
literal|1
expr_stmt|;
for|for
control|(
operator|++
name|fldtab
init|;
name|fldtab
operator|->
name|icol
operator|.
name|num
condition|;
operator|++
name|fldtab
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|fldtab
operator|->
name|icol
operator|.
name|num
operator|!=
name|clist
index|[
name|i
index|]
operator|.
name|num
condition|;
name|i
operator|++
control|)
empty_stmt|;
name|fldtab
operator|->
name|icol
operator|.
name|p
operator|=
name|clist
operator|+
name|i
expr_stmt|;
if|if
condition|(
operator|!
name|fldtab
operator|->
name|tcol
operator|.
name|num
condition|)
continue|continue;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|fldtab
operator|->
name|tcol
operator|.
name|num
operator|!=
name|clist
index|[
name|i
index|]
operator|.
name|num
condition|;
name|i
operator|++
control|)
empty_stmt|;
name|fldtab
operator|->
name|tcol
operator|.
name|p
operator|=
name|clist
operator|+
name|i
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * interprets a column in a -k field  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|setcolumn
parameter_list|(
name|pos
parameter_list|,
name|cur_fld
parameter_list|,
name|gflag
parameter_list|)
specifier|const
name|char
modifier|*
name|pos
decl_stmt|;
name|struct
name|field
modifier|*
name|cur_fld
decl_stmt|;
name|int
name|gflag
name|__unused
decl_stmt|;
block|{
name|struct
name|column
modifier|*
name|col
decl_stmt|;
name|int
name|tmp
decl_stmt|;
name|col
operator|=
name|cur_fld
operator|->
name|icol
operator|.
name|num
condition|?
operator|(
operator|&
operator|(
operator|*
name|cur_fld
operator|)
operator|.
name|tcol
operator|)
else|:
operator|(
operator|&
operator|(
operator|*
name|cur_fld
operator|)
operator|.
name|icol
operator|)
expr_stmt|;
name|pos
operator|+=
name|sscanf
argument_list|(
name|pos
argument_list|,
literal|"%d"
argument_list|,
operator|&
operator|(
name|col
operator|->
name|num
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|(
name|u_char
operator|)
operator|*
name|pos
argument_list|)
condition|)
name|pos
operator|++
expr_stmt|;
if|if
condition|(
name|col
operator|->
name|num
operator|<=
literal|0
operator|&&
operator|!
operator|(
name|col
operator|->
name|num
operator|==
literal|0
operator|&&
name|col
operator|==
operator|&
operator|(
name|cur_fld
operator|->
name|tcol
operator|)
operator|)
condition|)
name|errx
argument_list|(
literal|2
argument_list|,
literal|"field numbers must be positive"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|pos
operator|==
literal|'.'
condition|)
block|{
if|if
condition|(
operator|!
name|col
operator|->
name|num
condition|)
name|errx
argument_list|(
literal|2
argument_list|,
literal|"cannot indent end of line"
argument_list|)
expr_stmt|;
operator|++
name|pos
expr_stmt|;
name|pos
operator|+=
name|sscanf
argument_list|(
name|pos
argument_list|,
literal|"%d"
argument_list|,
operator|&
operator|(
name|col
operator|->
name|indent
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|(
name|u_char
operator|)
operator|*
name|pos
argument_list|)
condition|)
name|pos
operator|++
expr_stmt|;
if|if
condition|(
operator|&
name|cur_fld
operator|->
name|icol
operator|==
name|col
condition|)
name|col
operator|->
name|indent
operator|--
expr_stmt|;
if|if
condition|(
name|col
operator|->
name|indent
operator|<
literal|0
condition|)
name|errx
argument_list|(
literal|2
argument_list|,
literal|"illegal offset"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|optval
argument_list|(
operator|*
name|pos
argument_list|,
name|cur_fld
operator|->
name|tcol
operator|.
name|num
argument_list|)
condition|)
while|while
condition|(
operator|(
name|tmp
operator|=
name|optval
argument_list|(
operator|*
name|pos
argument_list|,
name|cur_fld
operator|->
name|tcol
operator|.
name|num
argument_list|)
operator|)
condition|)
block|{
name|cur_fld
operator|->
name|flags
operator||=
name|tmp
expr_stmt|;
name|pos
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|cur_fld
operator|->
name|icol
operator|.
name|num
operator|==
literal|0
condition|)
name|cur_fld
operator|->
name|icol
operator|.
name|num
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|pos
operator|)
return|;
block|}
end_function

begin_function
name|int
name|setfield
parameter_list|(
name|pos
parameter_list|,
name|cur_fld
parameter_list|,
name|gflag
parameter_list|)
specifier|const
name|char
modifier|*
name|pos
decl_stmt|;
name|struct
name|field
modifier|*
name|cur_fld
decl_stmt|;
name|int
name|gflag
decl_stmt|;
block|{
specifier|static
name|int
name|nfields
init|=
literal|0
decl_stmt|;
name|int
name|tmp
decl_stmt|;
if|if
condition|(
operator|++
name|nfields
operator|==
name|ND
condition|)
name|errx
argument_list|(
literal|2
argument_list|,
literal|"too many sort keys. (Limit is %d)"
argument_list|,
name|ND
operator|-
literal|1
argument_list|)
expr_stmt|;
name|cur_fld
operator|->
name|weights
operator|=
name|ascii
expr_stmt|;
name|cur_fld
operator|->
name|mask
operator|=
name|alltable
expr_stmt|;
name|pos
operator|=
name|setcolumn
argument_list|(
name|pos
argument_list|,
name|cur_fld
argument_list|,
name|gflag
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|pos
operator|==
literal|'\0'
condition|)
comment|/* key extends to EOL. */
name|cur_fld
operator|->
name|tcol
operator|.
name|num
operator|=
literal|0
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|*
name|pos
operator|!=
literal|','
condition|)
name|errx
argument_list|(
literal|2
argument_list|,
literal|"illegal field descriptor"
argument_list|)
expr_stmt|;
name|setcolumn
argument_list|(
operator|(
operator|++
name|pos
operator|)
argument_list|,
name|cur_fld
argument_list|,
name|gflag
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|cur_fld
operator|->
name|flags
condition|)
name|cur_fld
operator|->
name|flags
operator|=
name|gflag
expr_stmt|;
name|tmp
operator|=
name|cur_fld
operator|->
name|flags
expr_stmt|;
comment|/* 	 * Assign appropriate mask table and weight table. 	 * If the global weights are reversed, the local field 	 * must be "re-reversed". 	 */
if|if
condition|(
operator|(
operator|(
name|tmp
operator|&
name|R
operator|)
operator|^
operator|(
name|gflag
operator|&
name|R
operator|)
operator|)
operator|&&
operator|(
name|tmp
operator|&
name|F
operator|)
condition|)
name|cur_fld
operator|->
name|weights
operator|=
name|RFtable
expr_stmt|;
elseif|else
if|if
condition|(
name|tmp
operator|&
name|F
condition|)
name|cur_fld
operator|->
name|weights
operator|=
name|Ftable
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|tmp
operator|&
name|R
operator|)
operator|^
operator|(
name|gflag
operator|&
name|R
operator|)
condition|)
name|cur_fld
operator|->
name|weights
operator|=
name|Rascii
expr_stmt|;
if|if
condition|(
name|tmp
operator|&
name|I
condition|)
name|cur_fld
operator|->
name|mask
operator|=
name|itable
expr_stmt|;
elseif|else
if|if
condition|(
name|tmp
operator|&
name|D
condition|)
name|cur_fld
operator|->
name|mask
operator|=
name|dtable
expr_stmt|;
name|cur_fld
operator|->
name|flags
operator||=
operator|(
name|gflag
operator|&
operator|(
name|BI
operator||
name|BT
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|cur_fld
operator|->
name|tcol
operator|.
name|indent
condition|)
comment|/* BT has no meaning at end of field */
name|cur_fld
operator|->
name|flags
operator|&=
operator|~
name|BT
expr_stmt|;
if|if
condition|(
name|cur_fld
operator|->
name|tcol
operator|.
name|num
operator|&&
operator|!
operator|(
operator|!
operator|(
name|cur_fld
operator|->
name|flags
operator|&
name|BI
operator|)
operator|&&
name|cur_fld
operator|->
name|flags
operator|&
name|BT
operator|)
operator|&&
operator|(
name|cur_fld
operator|->
name|tcol
operator|.
name|num
operator|<=
name|cur_fld
operator|->
name|icol
operator|.
name|num
operator|&&
name|cur_fld
operator|->
name|tcol
operator|.
name|indent
operator|<
name|cur_fld
operator|->
name|icol
operator|.
name|indent
operator|)
condition|)
name|errx
argument_list|(
literal|2
argument_list|,
literal|"fields out of order"
argument_list|)
expr_stmt|;
name|insertcol
argument_list|(
name|cur_fld
argument_list|)
expr_stmt|;
return|return
operator|(
name|cur_fld
operator|->
name|tcol
operator|.
name|num
operator|)
return|;
block|}
end_function

begin_function
name|int
name|optval
parameter_list|(
name|desc
parameter_list|,
name|tcolflag
parameter_list|)
name|int
name|desc
decl_stmt|,
name|tcolflag
decl_stmt|;
block|{
switch|switch
condition|(
name|desc
condition|)
block|{
case|case
literal|'b'
case|:
if|if
condition|(
operator|!
name|tcolflag
condition|)
return|return
operator|(
name|BI
operator|)
return|;
else|else
return|return
operator|(
name|BT
operator|)
return|;
case|case
literal|'d'
case|:
return|return
operator|(
name|D
operator|)
return|;
case|case
literal|'f'
case|:
return|return
operator|(
name|F
operator|)
return|;
case|case
literal|'i'
case|:
return|return
operator|(
name|I
operator|)
return|;
case|case
literal|'n'
case|:
return|return
operator|(
name|N
operator|)
return|;
case|case
literal|'r'
case|:
return|return
operator|(
name|R
operator|)
return|;
default|default:
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_function
name|void
name|fixit
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
modifier|*
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|v
decl_stmt|,
name|w
decl_stmt|,
name|x
decl_stmt|;
specifier|static
name|char
name|vbuf
index|[
name|ND
operator|*
literal|20
index|]
decl_stmt|,
modifier|*
name|vpos
decl_stmt|,
modifier|*
name|tpos
decl_stmt|;
name|vpos
operator|=
name|vbuf
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
operator|*
name|argc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'+'
condition|)
block|{
name|tpos
operator|=
name|argv
index|[
name|i
index|]
operator|+
literal|1
expr_stmt|;
name|argv
index|[
name|i
index|]
operator|=
name|vpos
expr_stmt|;
name|vpos
operator|+=
name|sprintf
argument_list|(
name|vpos
argument_list|,
literal|"-k"
argument_list|)
expr_stmt|;
name|tpos
operator|+=
name|sscanf
argument_list|(
name|tpos
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|v
argument_list|)
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|(
name|u_char
operator|)
operator|*
name|tpos
argument_list|)
condition|)
name|tpos
operator|++
expr_stmt|;
name|vpos
operator|+=
name|sprintf
argument_list|(
name|vpos
argument_list|,
literal|"%d"
argument_list|,
name|v
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|tpos
operator|==
literal|'.'
condition|)
block|{
operator|++
name|tpos
expr_stmt|;
name|tpos
operator|+=
name|sscanf
argument_list|(
name|tpos
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|x
argument_list|)
expr_stmt|;
name|vpos
operator|+=
name|sprintf
argument_list|(
name|vpos
argument_list|,
literal|".%d"
argument_list|,
name|x
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|*
name|tpos
condition|)
operator|*
name|vpos
operator|++
operator|=
operator|*
name|tpos
operator|++
expr_stmt|;
name|vpos
operator|+=
name|sprintf
argument_list|(
name|vpos
argument_list|,
literal|","
argument_list|)
expr_stmt|;
if|if
condition|(
name|argv
index|[
name|i
operator|+
literal|1
index|]
operator|&&
name|argv
index|[
name|i
operator|+
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|isdigit
argument_list|(
operator|(
name|u_char
operator|)
name|argv
index|[
name|i
operator|+
literal|1
index|]
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|tpos
operator|=
name|argv
index|[
name|i
operator|+
literal|1
index|]
operator|+
literal|1
expr_stmt|;
name|tpos
operator|+=
name|sscanf
argument_list|(
name|tpos
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|w
argument_list|)
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|(
name|u_char
operator|)
operator|*
name|tpos
argument_list|)
condition|)
name|tpos
operator|++
expr_stmt|;
name|x
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|tpos
operator|==
literal|'.'
condition|)
block|{
operator|++
name|tpos
expr_stmt|;
name|tpos
operator|+=
name|sscanf
argument_list|(
name|tpos
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|x
argument_list|)
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|(
name|u_char
operator|)
operator|*
name|tpos
argument_list|)
condition|)
name|tpos
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|x
condition|)
block|{
name|vpos
operator|+=
name|sprintf
argument_list|(
name|vpos
argument_list|,
literal|"%d"
argument_list|,
name|w
operator|+
literal|1
argument_list|)
expr_stmt|;
name|vpos
operator|+=
name|sprintf
argument_list|(
name|vpos
argument_list|,
literal|".%d"
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
else|else
name|vpos
operator|+=
name|sprintf
argument_list|(
name|vpos
argument_list|,
literal|"%d"
argument_list|,
name|w
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|tpos
condition|)
operator|*
name|vpos
operator|++
operator|=
operator|*
name|tpos
operator|++
expr_stmt|;
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
operator|*
name|argc
condition|;
name|j
operator|++
control|)
name|argv
index|[
name|j
index|]
operator|=
name|argv
index|[
name|j
operator|+
literal|1
index|]
expr_stmt|;
operator|*
name|argc
operator|-=
literal|1
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|findgap
parameter_list|(
name|u_char
modifier|*
name|table
parameter_list|,
name|int
name|old
parameter_list|,
name|int
name|new
parameter_list|)
block|{
name|u_char
name|gap
index|[
name|NBINS
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|fto
decl_stmt|,
name|rto
decl_stmt|,
name|ret
decl_stmt|,
name|lim
decl_stmt|;
operator|(
name|void
operator|)
name|memset
argument_list|(
name|gap
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|gap
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NBINS
condition|;
name|i
operator|++
control|)
name|gap
index|[
name|table
index|[
name|i
index|]
index|]
operator|++
expr_stmt|;
name|fto
operator|=
operator|-
literal|1
expr_stmt|;
name|lim
operator|=
name|NBINS
expr_stmt|;
if|if
condition|(
name|new
operator|>
name|old
condition|)
name|lim
operator|=
name|new
expr_stmt|;
for|for
control|(
name|i
operator|=
name|old
operator|+
literal|1
init|;
name|i
operator|<
name|lim
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|gap
index|[
name|i
index|]
operator|==
literal|0
condition|)
block|{
name|fto
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
name|rto
operator|=
operator|-
literal|1
expr_stmt|;
name|lim
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|new
operator|<
name|old
condition|)
name|lim
operator|=
name|new
expr_stmt|;
for|for
control|(
name|i
operator|=
name|old
operator|-
literal|1
init|;
name|i
operator|>
name|lim
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|gap
index|[
name|i
index|]
operator|==
literal|0
condition|)
block|{
name|rto
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
name|ret
operator|=
name|old
expr_stmt|;
if|if
condition|(
name|fto
operator|>=
literal|0
operator|&&
name|rto
operator|>=
literal|0
condition|)
block|{
name|ret
operator|=
name|fto
expr_stmt|;
if|if
condition|(
name|fto
operator|-
name|old
operator|>
name|old
operator|-
name|rto
condition|)
name|ret
operator|=
name|rto
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fto
operator|>=
literal|0
condition|)
name|ret
operator|=
name|fto
expr_stmt|;
elseif|else
if|if
condition|(
name|rto
operator|>=
literal|0
condition|)
name|ret
operator|=
name|rto
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|shift_at_REC_D
parameter_list|(
name|u_char
modifier|*
name|table
parameter_list|,
name|int
name|new
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|old
decl_stmt|,
name|conflict
decl_stmt|,
name|to
decl_stmt|,
name|oldn
decl_stmt|;
name|old
operator|=
name|table
index|[
name|REC_D
index|]
expr_stmt|;
name|conflict
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|old
operator|>
name|new
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NBINS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|table
index|[
name|i
index|]
operator|==
name|old
condition|)
block|{
if|if
condition|(
name|i
operator|!=
name|REC_D
condition|)
name|conflict
operator|=
literal|1
expr_stmt|;
name|table
index|[
name|i
index|]
operator|=
name|new
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|table
index|[
name|i
index|]
operator|>=
name|new
operator|&&
name|table
index|[
name|i
index|]
operator|<
name|old
condition|)
name|table
index|[
name|i
index|]
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|old
operator|<
name|new
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NBINS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|table
index|[
name|i
index|]
operator|==
name|old
condition|)
block|{
if|if
condition|(
name|i
operator|!=
name|REC_D
condition|)
name|conflict
operator|=
literal|1
expr_stmt|;
name|table
index|[
name|i
index|]
operator|=
name|new
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|table
index|[
name|i
index|]
operator|>
name|old
operator|&&
name|table
index|[
name|i
index|]
operator|<=
name|new
condition|)
name|table
index|[
name|i
index|]
operator|--
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NBINS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|table
index|[
name|i
index|]
operator|==
name|old
condition|)
block|{
if|if
condition|(
name|i
operator|!=
name|REC_D
condition|)
block|{
name|conflict
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
if|if
condition|(
name|conflict
condition|)
block|{
name|to
operator|=
name|findgap
argument_list|(
name|table
argument_list|,
name|old
argument_list|,
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
name|to
operator|>
name|old
condition|)
block|{
name|oldn
operator|=
name|old
operator|+
operator|(
name|old
operator|>=
name|new
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NBINS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|table
index|[
name|i
index|]
operator|==
name|new
operator|&&
name|i
operator|!=
name|REC_D
condition|)
name|table
index|[
name|i
index|]
operator|=
name|oldn
expr_stmt|;
elseif|else
if|if
condition|(
name|table
index|[
name|i
index|]
operator|>=
name|oldn
operator|&&
name|table
index|[
name|i
index|]
operator|<
name|to
condition|)
name|table
index|[
name|i
index|]
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|to
operator|<
name|old
condition|)
block|{
name|oldn
operator|=
name|old
operator|-
operator|(
name|old
operator|<=
name|new
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NBINS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|table
index|[
name|i
index|]
operator|==
name|new
operator|&&
name|i
operator|!=
name|REC_D
condition|)
name|table
index|[
name|i
index|]
operator|=
name|oldn
expr_stmt|;
elseif|else
if|if
condition|(
name|table
index|[
name|i
index|]
operator|<=
name|oldn
operator|&&
name|table
index|[
name|i
index|]
operator|>
name|to
condition|)
name|table
index|[
name|i
index|]
operator|--
expr_stmt|;
block|}
block|}
else|else
name|warnx
argument_list|(
literal|"can't resolve conflict in the sorting table"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|collcmp
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
block|{
specifier|static
name|char
name|sa
index|[
literal|2
index|]
decl_stmt|,
name|sb
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
operator|*
operator|(
operator|(
name|char
operator|*
operator|)
name|a
operator|)
operator|==
operator|*
operator|(
operator|(
name|char
operator|*
operator|)
name|b
operator|)
condition|)
return|return
literal|0
return|;
name|sa
index|[
literal|0
index|]
operator|=
operator|*
operator|(
operator|(
name|char
operator|*
operator|)
name|a
operator|)
expr_stmt|;
name|sb
index|[
literal|0
index|]
operator|=
operator|*
operator|(
operator|(
name|char
operator|*
operator|)
name|b
operator|)
expr_stmt|;
return|return
name|strcoll
argument_list|(
name|sa
argument_list|,
name|sb
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * ascii, Rascii, Ftable, and RFtable map  * REC_D -> REC_D;  {not REC_D} -> {not REC_D}.  * gweights maps REC_D -> (0 or 255); {not REC_D} -> {not gweights[REC_D]}.  * Note: when sorting in forward order, to encode character zero in a key,  * use \001\001; character 1 becomes \001\002.  In this case, character 0  * is reserved for the field delimiter.  Analagously for -r (fld_d = 255).  * See also num_init() in fields.c  */
end_comment

begin_function
name|void
name|settables
parameter_list|(
name|gflags
parameter_list|)
name|int
name|gflags
decl_stmt|;
block|{
name|u_char
name|idx2asc
index|[
name|NBINS
index|]
decl_stmt|;
name|u_char
modifier|*
name|wts
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NBINS
condition|;
name|i
operator|++
control|)
name|idx2asc
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
name|qsort
argument_list|(
name|idx2asc
argument_list|,
name|NBINS
argument_list|,
sizeof|sizeof
argument_list|(
name|u_char
argument_list|)
argument_list|,
name|collcmp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NBINS
condition|;
name|i
operator|++
control|)
block|{
name|n
operator|=
name|idx2asc
index|[
name|i
index|]
expr_stmt|;
name|Ftable
index|[
name|n
index|]
operator|=
name|ascii
index|[
name|n
index|]
operator|=
name|i
expr_stmt|;
name|RFtable
index|[
name|n
index|]
operator|=
name|Rascii
index|[
name|n
index|]
operator|=
name|NBINS
operator|-
literal|1
operator|-
name|i
expr_stmt|;
name|alltable
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|'\n'
operator|||
name|isprint
argument_list|(
name|i
argument_list|)
condition|)
name|itable
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
else|else
name|itable
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|isalnum
argument_list|(
name|i
argument_list|)
operator|||
operator|(
name|isspace
argument_list|(
name|i
argument_list|)
operator|&&
operator|(
name|i
operator|==
literal|'\n'
operator|||
name|i
operator|==
literal|'\t'
operator|||
name|isprint
argument_list|(
name|i
argument_list|)
operator|)
operator|)
condition|)
name|dtable
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
else|else
name|dtable
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NBINS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|n
operator|=
name|toupper
argument_list|(
name|i
argument_list|)
operator|)
operator|!=
name|i
condition|)
block|{
name|Ftable
index|[
name|i
index|]
operator|=
name|Ftable
index|[
name|n
index|]
expr_stmt|;
name|RFtable
index|[
name|i
index|]
operator|=
name|RFtable
index|[
name|n
index|]
expr_stmt|;
block|}
block|}
name|shift_at_REC_D
argument_list|(
name|ascii
argument_list|,
name|REC_D
argument_list|)
expr_stmt|;
name|shift_at_REC_D
argument_list|(
name|Rascii
argument_list|,
name|REC_D
argument_list|)
expr_stmt|;
name|shift_at_REC_D
argument_list|(
name|Ftable
argument_list|,
name|REC_D
argument_list|)
expr_stmt|;
name|shift_at_REC_D
argument_list|(
name|RFtable
argument_list|,
name|REC_D
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|gflags
operator|&
name|R
operator|)
operator|&&
operator|!
operator|(
operator|(
name|gflags
operator|&
name|F
operator|)
operator|&&
name|SINGL_FLD
operator|)
condition|)
name|wts
operator|=
name|Rascii
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
operator|(
name|gflags
operator|&
name|F
operator|)
operator|&&
name|SINGL_FLD
operator|)
condition|)
name|wts
operator|=
name|ascii
expr_stmt|;
elseif|else
if|if
condition|(
name|gflags
operator|&
name|R
condition|)
name|wts
operator|=
name|RFtable
expr_stmt|;
else|else
name|wts
operator|=
name|Ftable
expr_stmt|;
operator|(
name|void
operator|)
name|memcpy
argument_list|(
name|gweights
argument_list|,
name|wts
argument_list|,
sizeof|sizeof
argument_list|(
name|gweights
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|gflags
operator|&
name|R
operator|)
condition|)
name|shift_at_REC_D
argument_list|(
name|gweights
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|shift_at_REC_D
argument_list|(
name|gweights
argument_list|,
name|NBINS
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|SINGL_FLD
operator|&&
operator|(
name|gflags
operator|&
name|F
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|gflags
operator|&
name|R
operator|)
condition|)
block|{
name|shift_at_REC_D
argument_list|(
name|ascii
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|shift_at_REC_D
argument_list|(
name|Rascii
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|shift_at_REC_D
argument_list|(
name|ascii
argument_list|,
name|NBINS
operator|-
literal|1
argument_list|)
expr_stmt|;
name|shift_at_REC_D
argument_list|(
name|Rascii
argument_list|,
name|NBINS
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

end_unit

