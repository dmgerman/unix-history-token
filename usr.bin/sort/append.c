begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: append.c,v 1.9 2001/01/18 20:59:43 jdolecek Exp $	*/
end_comment

begin_comment
comment|/*-  * Copyright (c) 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Peter McIlroy.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"sort.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_expr_stmt
name|__RCSID
argument_list|(
literal|"$NetBSD: append.c,v 1.9 2001/01/18 20:59:43 jdolecek Exp $"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|__SCCSID
argument_list|(
literal|"@(#)append.c	8.1 (Berkeley) 6/6/93"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_define
define|#
directive|define
name|OUTPUT
value|{							\ 	if ((n = cpos - ppos)> 1) {					\ 		for (; ppos< cpos; ++ppos)				\ 			*ppos -= odepth;				\ 		ppos -= n;						\ 		if (stable_sort)					\ 			sradixsort(ppos, n, wts1, REC_D);		\ 		else							\ 			radixsort(ppos, n, wts1, REC_D);		\ 		for (; ppos< cpos; ppos++) {				\ 			prec = (const RECHEADER *) (*ppos - sizeof(TRECHEADER));\ 			put(prec, fp);					\ 		}							\ 	} else put(prec, fp);						\ }
end_define

begin_comment
comment|/*  * copy sorted lines to output; check for uniqueness  */
end_comment

begin_function
name|void
name|append
parameter_list|(
name|keylist
parameter_list|,
name|nelem
parameter_list|,
name|depth
parameter_list|,
name|fp
parameter_list|,
name|put
parameter_list|,
name|ftbl
parameter_list|)
specifier|const
name|u_char
modifier|*
modifier|*
name|keylist
decl_stmt|;
name|int
name|nelem
decl_stmt|;
name|int
name|depth
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|put_func_t
name|put
decl_stmt|;
name|struct
name|field
modifier|*
name|ftbl
decl_stmt|;
block|{
name|u_char
modifier|*
name|wts
decl_stmt|,
modifier|*
name|wts1
decl_stmt|;
name|int
name|n
decl_stmt|,
name|odepth
decl_stmt|;
specifier|const
name|u_char
modifier|*
modifier|*
name|cpos
decl_stmt|,
modifier|*
modifier|*
name|ppos
decl_stmt|,
modifier|*
modifier|*
name|lastkey
decl_stmt|;
specifier|const
name|u_char
modifier|*
name|cend
decl_stmt|,
modifier|*
name|pend
decl_stmt|,
modifier|*
name|start
decl_stmt|;
specifier|const
name|struct
name|recheader
modifier|*
name|crec
decl_stmt|,
modifier|*
name|prec
decl_stmt|;
if|if
condition|(
operator|*
name|keylist
operator|==
literal|'\0'
operator|&&
name|UNIQUE
condition|)
return|return;
name|wts1
operator|=
name|wts
operator|=
name|ftbl
index|[
literal|0
index|]
operator|.
name|weights
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|UNIQUE
operator|)
operator|&&
name|SINGL_FLD
condition|)
block|{
if|if
condition|(
operator|(
name|ftbl
index|[
literal|0
index|]
operator|.
name|flags
operator|&
name|F
operator|)
operator|&&
operator|(
name|ftbl
index|[
literal|0
index|]
operator|.
name|flags
operator|&
name|R
operator|)
condition|)
name|wts1
operator|=
name|Rascii
expr_stmt|;
elseif|else
if|if
condition|(
name|ftbl
index|[
literal|0
index|]
operator|.
name|flags
operator|&
name|F
condition|)
name|wts1
operator|=
name|ascii
expr_stmt|;
name|odepth
operator|=
name|depth
expr_stmt|;
block|}
name|lastkey
operator|=
name|keylist
operator|+
name|nelem
expr_stmt|;
name|depth
operator|+=
sizeof|sizeof
argument_list|(
name|TRECHEADER
argument_list|)
expr_stmt|;
if|if
condition|(
name|SINGL_FLD
operator|&&
operator|(
name|UNIQUE
operator|||
name|wts1
operator|!=
name|wts
operator|)
condition|)
block|{
name|ppos
operator|=
name|keylist
expr_stmt|;
name|prec
operator|=
operator|(
specifier|const
name|RECHEADER
operator|*
operator|)
operator|(
operator|*
name|ppos
operator|-
name|depth
operator|)
expr_stmt|;
if|if
condition|(
name|UNIQUE
condition|)
name|put
argument_list|(
name|prec
argument_list|,
name|fp
argument_list|)
expr_stmt|;
for|for
control|(
name|cpos
operator|=
operator|&
name|keylist
index|[
literal|1
index|]
init|;
name|cpos
operator|<
name|lastkey
condition|;
name|cpos
operator|++
control|)
block|{
name|crec
operator|=
operator|(
specifier|const
name|RECHEADER
operator|*
operator|)
operator|(
operator|*
name|cpos
operator|-
name|depth
operator|)
expr_stmt|;
if|if
condition|(
name|crec
operator|->
name|length
operator|==
name|prec
operator|->
name|length
condition|)
block|{
comment|/* 				 * Set pend and cend so that trailing NUL and 				 * record separator is ignored. 				 */
name|pend
operator|=
operator|(
specifier|const
name|u_char
operator|*
operator|)
operator|&
name|prec
operator|->
name|data
operator|+
name|prec
operator|->
name|length
operator|-
literal|2
expr_stmt|;
name|cend
operator|=
operator|(
specifier|const
name|u_char
operator|*
operator|)
operator|&
name|crec
operator|->
name|data
operator|+
name|crec
operator|->
name|length
operator|-
literal|2
expr_stmt|;
for|for
control|(
name|start
operator|=
operator|*
name|cpos
init|;
name|cend
operator|>=
name|start
condition|;
name|cend
operator|--
control|)
block|{
if|if
condition|(
name|wts
index|[
operator|*
name|cend
index|]
operator|!=
name|wts
index|[
operator|*
name|pend
index|]
condition|)
break|break;
name|pend
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|pend
operator|+
literal|1
operator|!=
operator|*
name|ppos
condition|)
block|{
if|if
condition|(
operator|!
name|UNIQUE
condition|)
block|{
name|OUTPUT
expr_stmt|;
block|}
else|else
name|put
argument_list|(
name|crec
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|ppos
operator|=
name|cpos
expr_stmt|;
name|prec
operator|=
name|crec
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|UNIQUE
condition|)
block|{
name|OUTPUT
expr_stmt|;
block|}
else|else
name|put
argument_list|(
name|crec
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|ppos
operator|=
name|cpos
expr_stmt|;
name|prec
operator|=
name|crec
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|UNIQUE
condition|)
block|{
name|OUTPUT
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|UNIQUE
condition|)
block|{
name|ppos
operator|=
name|keylist
expr_stmt|;
name|prec
operator|=
operator|(
specifier|const
name|RECHEADER
operator|*
operator|)
operator|(
operator|*
name|ppos
operator|-
name|depth
operator|)
expr_stmt|;
name|put
argument_list|(
name|prec
argument_list|,
name|fp
argument_list|)
expr_stmt|;
for|for
control|(
name|cpos
operator|=
operator|&
name|keylist
index|[
literal|1
index|]
init|;
name|cpos
operator|<
name|lastkey
condition|;
name|cpos
operator|++
control|)
block|{
name|crec
operator|=
operator|(
specifier|const
name|RECHEADER
operator|*
operator|)
operator|(
operator|*
name|cpos
operator|-
name|depth
operator|)
expr_stmt|;
if|if
condition|(
name|crec
operator|->
name|offset
operator|==
name|prec
operator|->
name|offset
condition|)
block|{
comment|/* 				 * Set pend and cend so that trailing NUL and 				 * record separator is ignored. 				 */
name|pend
operator|=
operator|(
specifier|const
name|u_char
operator|*
operator|)
operator|&
name|prec
operator|->
name|data
operator|+
name|prec
operator|->
name|offset
operator|-
literal|2
expr_stmt|;
name|cend
operator|=
operator|(
specifier|const
name|u_char
operator|*
operator|)
operator|&
name|crec
operator|->
name|data
operator|+
name|crec
operator|->
name|offset
operator|-
literal|2
expr_stmt|;
for|for
control|(
name|start
operator|=
operator|*
name|cpos
init|;
name|cend
operator|>=
name|start
condition|;
name|cend
operator|--
control|)
block|{
if|if
condition|(
name|wts
index|[
operator|*
name|cend
index|]
operator|!=
name|wts
index|[
operator|*
name|pend
index|]
condition|)
break|break;
name|pend
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|pend
operator|+
literal|1
operator|!=
operator|*
name|ppos
condition|)
block|{
name|ppos
operator|=
name|cpos
expr_stmt|;
name|prec
operator|=
name|crec
expr_stmt|;
name|put
argument_list|(
name|prec
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|ppos
operator|=
name|cpos
expr_stmt|;
name|prec
operator|=
name|crec
expr_stmt|;
name|put
argument_list|(
name|prec
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
for|for
control|(
name|cpos
operator|=
name|keylist
init|;
name|cpos
operator|<
name|lastkey
condition|;
name|cpos
operator|++
control|)
block|{
name|crec
operator|=
operator|(
specifier|const
name|RECHEADER
operator|*
operator|)
operator|(
operator|*
name|cpos
operator|-
name|depth
operator|)
expr_stmt|;
name|put
argument_list|(
name|crec
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * output the already sorted eol bin.  */
end_comment

begin_function
name|void
name|rd_append
parameter_list|(
name|binno
parameter_list|,
name|infl0
parameter_list|,
name|nfiles
parameter_list|,
name|outfp
parameter_list|,
name|buffer
parameter_list|,
name|bufend
parameter_list|)
name|u_char
modifier|*
name|buffer
decl_stmt|;
name|int
name|infl0
decl_stmt|;
name|int
name|binno
decl_stmt|,
name|nfiles
decl_stmt|;
name|FILE
modifier|*
name|outfp
decl_stmt|;
name|u_char
modifier|*
name|bufend
decl_stmt|;
block|{
name|RECHEADER
modifier|*
name|rec
decl_stmt|;
name|rec
operator|=
operator|(
name|RECHEADER
operator|*
operator|)
name|buffer
expr_stmt|;
if|if
condition|(
operator|!
name|getnext
argument_list|(
name|binno
argument_list|,
name|infl0
argument_list|,
name|NULL
argument_list|,
name|nfiles
argument_list|,
operator|(
name|RECHEADER
operator|*
operator|)
name|buffer
argument_list|,
name|bufend
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|putline
argument_list|(
name|rec
argument_list|,
name|outfp
argument_list|)
expr_stmt|;
while|while
condition|(
name|getnext
argument_list|(
name|binno
argument_list|,
name|infl0
argument_list|,
name|NULL
argument_list|,
name|nfiles
argument_list|,
operator|(
name|RECHEADER
operator|*
operator|)
name|buffer
argument_list|,
name|bufend
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|UNIQUE
condition|)
name|putline
argument_list|(
name|rec
argument_list|,
name|outfp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * append plain text--used after sorting the biggest bin.  */
end_comment

begin_function
name|void
name|concat
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
name|FILE
modifier|*
name|a
decl_stmt|,
decl|*
name|b
decl_stmt|;
end_function

begin_block
block|{
name|int
name|nread
decl_stmt|;
name|char
name|buffer
index|[
literal|4096
index|]
decl_stmt|;
name|rewind
argument_list|(
name|b
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|nread
operator|=
name|fread
argument_list|(
name|buffer
argument_list|,
literal|1
argument_list|,
literal|4096
argument_list|,
name|b
argument_list|)
operator|)
operator|>
literal|0
condition|)
name|EWRITE
argument_list|(
name|buffer
argument_list|,
literal|1
argument_list|,
name|nread
argument_list|,
name|a
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

