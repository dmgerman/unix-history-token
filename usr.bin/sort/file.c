begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (C) 2009 Gabor Kovesdan<gabor@FreeBSD.org>  * Copyright (C) 2012 Oleg Moskalenko<mom040267@gmail.com>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SORT_THREADS
argument_list|)
end_if

begin_include
include|#
directive|include
file|<pthread.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<semaphore.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<wchar.h>
end_include

begin_include
include|#
directive|include
file|<wctype.h>
end_include

begin_include
include|#
directive|include
file|"coll.h"
end_include

begin_include
include|#
directive|include
file|"file.h"
end_include

begin_include
include|#
directive|include
file|"radixsort.h"
end_include

begin_decl_stmt
name|unsigned
name|long
name|long
name|free_memory
init|=
literal|1000000
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|long
name|long
name|available_free_memory
init|=
literal|1000000
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|use_mmap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|tmpdir
init|=
literal|"/var/tmp"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|compress_program
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|max_open_files
init|=
literal|16
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * How much space we read from file at once  */
end_comment

begin_define
define|#
directive|define
name|READ_CHUNK
value|(4096)
end_define

begin_comment
comment|/*  * File reader structure  */
end_comment

begin_struct
struct|struct
name|file_reader
block|{
name|struct
name|reader_buffer
name|rb
decl_stmt|;
name|FILE
modifier|*
name|file
decl_stmt|;
name|char
modifier|*
name|fname
decl_stmt|;
name|unsigned
name|char
modifier|*
name|buffer
decl_stmt|;
name|unsigned
name|char
modifier|*
name|mmapaddr
decl_stmt|;
name|unsigned
name|char
modifier|*
name|mmapptr
decl_stmt|;
name|size_t
name|bsz
decl_stmt|;
name|size_t
name|cbsz
decl_stmt|;
name|size_t
name|mmapsize
decl_stmt|;
name|size_t
name|strbeg
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|char
name|elsymb
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Structure to be used in file merge process.  */
end_comment

begin_struct
struct|struct
name|file_header
block|{
name|struct
name|file_reader
modifier|*
name|fr
decl_stmt|;
name|struct
name|sort_list_item
modifier|*
name|si
decl_stmt|;
comment|/* current top line */
name|size_t
name|file_pos
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * List elements of "cleanable" files list.  */
end_comment

begin_struct
struct|struct
name|CLEANABLE_FILE
block|{
name|char
modifier|*
name|fn
decl_stmt|;
name|LIST_ENTRY
argument_list|(
argument|CLEANABLE_FILE
argument_list|)
name|files
expr_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * List header of "cleanable" files list.  */
end_comment

begin_expr_stmt
specifier|static
name|LIST_HEAD
argument_list|(
argument|CLEANABLE_FILES
argument_list|,
argument|CLEANABLE_FILE
argument_list|)
name|tmp_files
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Semaphore to protect the tmp file list.  * We use semaphore here because it is signal-safe, according to POSIX.  * And semaphore does not require pthread library.  */
end_comment

begin_decl_stmt
specifier|static
name|sem_t
name|tmp_files_sem
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|mt_sort
parameter_list|(
name|struct
name|sort_list
modifier|*
name|list
parameter_list|,
name|int
function_decl|(
modifier|*
name|sort_func
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|size_t
parameter_list|,
name|int
function_decl|(
modifier|*
function_decl|)
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
parameter_list|)
parameter_list|,
specifier|const
name|char
modifier|*
name|fn
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Init tmp files list  */
end_comment

begin_function
name|void
name|init_tmp_files
parameter_list|(
name|void
parameter_list|)
block|{
name|LIST_INIT
argument_list|(
operator|&
name|tmp_files
argument_list|)
expr_stmt|;
name|sem_init
argument_list|(
operator|&
name|tmp_files_sem
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Save name of a tmp file for signal cleanup  */
end_comment

begin_function
name|void
name|tmp_file_atexit
parameter_list|(
specifier|const
name|char
modifier|*
name|tmp_file
parameter_list|)
block|{
if|if
condition|(
name|tmp_file
condition|)
block|{
name|sem_wait
argument_list|(
operator|&
name|tmp_files_sem
argument_list|)
expr_stmt|;
name|struct
name|CLEANABLE_FILE
modifier|*
name|item
init|=
name|sort_malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|CLEANABLE_FILE
argument_list|)
argument_list|)
decl_stmt|;
name|item
operator|->
name|fn
operator|=
name|sort_strdup
argument_list|(
name|tmp_file
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|tmp_files
argument_list|,
name|item
argument_list|,
name|files
argument_list|)
expr_stmt|;
name|sem_post
argument_list|(
operator|&
name|tmp_files_sem
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Clear tmp files  */
end_comment

begin_function
name|void
name|clear_tmp_files
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|CLEANABLE_FILE
modifier|*
name|item
decl_stmt|;
name|sem_wait
argument_list|(
operator|&
name|tmp_files_sem
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|item
argument_list|,
argument|&tmp_files
argument_list|,
argument|files
argument_list|)
block|{
if|if
condition|(
operator|(
name|item
operator|)
operator|&&
operator|(
name|item
operator|->
name|fn
operator|)
condition|)
name|unlink
argument_list|(
name|item
operator|->
name|fn
argument_list|)
expr_stmt|;
block|}
name|sem_post
argument_list|(
operator|&
name|tmp_files_sem
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Check whether a file is a temporary file  */
end_comment

begin_function
specifier|static
name|bool
name|file_is_tmp
parameter_list|(
specifier|const
name|char
modifier|*
name|fn
parameter_list|)
block|{
name|struct
name|CLEANABLE_FILE
modifier|*
name|item
decl_stmt|;
name|bool
name|ret
init|=
name|false
decl_stmt|;
if|if
condition|(
name|fn
condition|)
block|{
name|sem_wait
argument_list|(
operator|&
name|tmp_files_sem
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|item
argument_list|,
argument|&tmp_files
argument_list|,
argument|files
argument_list|)
block|{
if|if
condition|(
operator|(
name|item
operator|)
operator|&&
operator|(
name|item
operator|->
name|fn
operator|)
condition|)
if|if
condition|(
name|strcmp
argument_list|(
name|item
operator|->
name|fn
argument_list|,
name|fn
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ret
operator|=
name|true
expr_stmt|;
break|break;
block|}
block|}
name|sem_post
argument_list|(
operator|&
name|tmp_files_sem
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Generate new temporary file name  */
end_comment

begin_function
name|char
modifier|*
name|new_tmp_file_name
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|size_t
name|tfcounter
init|=
literal|0
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
name|fn
init|=
literal|".bsdsort."
decl_stmt|;
name|char
modifier|*
name|ret
decl_stmt|;
name|size_t
name|sz
decl_stmt|;
name|sz
operator|=
name|strlen
argument_list|(
name|tmpdir
argument_list|)
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|fn
argument_list|)
operator|+
literal|32
operator|+
literal|1
expr_stmt|;
name|ret
operator|=
name|sort_malloc
argument_list|(
name|sz
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|ret
argument_list|,
literal|"%s/%s%d.%lu"
argument_list|,
name|tmpdir
argument_list|,
name|fn
argument_list|,
operator|(
name|int
operator|)
name|getpid
argument_list|()
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|tfcounter
operator|++
argument_list|)
argument_list|)
expr_stmt|;
name|tmp_file_atexit
argument_list|(
name|ret
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize file list  */
end_comment

begin_function
name|void
name|file_list_init
parameter_list|(
name|struct
name|file_list
modifier|*
name|fl
parameter_list|,
name|bool
name|tmp
parameter_list|)
block|{
if|if
condition|(
name|fl
condition|)
block|{
name|fl
operator|->
name|count
operator|=
literal|0
expr_stmt|;
name|fl
operator|->
name|sz
operator|=
literal|0
expr_stmt|;
name|fl
operator|->
name|fns
operator|=
name|NULL
expr_stmt|;
name|fl
operator|->
name|tmp
operator|=
name|tmp
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Add a file name to the list  */
end_comment

begin_function
name|void
name|file_list_add
parameter_list|(
name|struct
name|file_list
modifier|*
name|fl
parameter_list|,
name|char
modifier|*
name|fn
parameter_list|,
name|bool
name|allocate
parameter_list|)
block|{
if|if
condition|(
name|fl
operator|&&
name|fn
condition|)
block|{
if|if
condition|(
name|fl
operator|->
name|count
operator|>=
name|fl
operator|->
name|sz
operator|||
operator|(
name|fl
operator|->
name|fns
operator|==
name|NULL
operator|)
condition|)
block|{
name|fl
operator|->
name|sz
operator|=
operator|(
name|fl
operator|->
name|sz
operator|)
operator|*
literal|2
operator|+
literal|1
expr_stmt|;
name|fl
operator|->
name|fns
operator|=
name|sort_realloc
argument_list|(
name|fl
operator|->
name|fns
argument_list|,
name|fl
operator|->
name|sz
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fl
operator|->
name|fns
index|[
name|fl
operator|->
name|count
index|]
operator|=
name|allocate
condition|?
name|sort_strdup
argument_list|(
name|fn
argument_list|)
else|:
name|fn
expr_stmt|;
name|fl
operator|->
name|count
operator|+=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Populate file list from array of file names  */
end_comment

begin_function
name|void
name|file_list_populate
parameter_list|(
name|struct
name|file_list
modifier|*
name|fl
parameter_list|,
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|bool
name|allocate
parameter_list|)
block|{
if|if
condition|(
name|fl
operator|&&
name|argv
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
name|file_list_add
argument_list|(
name|fl
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|,
name|allocate
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Clean file list data and delete the files,  * if this is a list of temporary files  */
end_comment

begin_function
name|void
name|file_list_clean
parameter_list|(
name|struct
name|file_list
modifier|*
name|fl
parameter_list|)
block|{
if|if
condition|(
name|fl
condition|)
block|{
if|if
condition|(
name|fl
operator|->
name|fns
condition|)
block|{
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fl
operator|->
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fl
operator|->
name|fns
index|[
name|i
index|]
condition|)
block|{
if|if
condition|(
name|fl
operator|->
name|tmp
condition|)
name|unlink
argument_list|(
name|fl
operator|->
name|fns
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|sort_free
argument_list|(
name|fl
operator|->
name|fns
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|fl
operator|->
name|fns
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|sort_free
argument_list|(
name|fl
operator|->
name|fns
argument_list|)
expr_stmt|;
name|fl
operator|->
name|fns
operator|=
name|NULL
expr_stmt|;
block|}
name|fl
operator|->
name|sz
operator|=
literal|0
expr_stmt|;
name|fl
operator|->
name|count
operator|=
literal|0
expr_stmt|;
name|fl
operator|->
name|tmp
operator|=
name|false
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Init sort list  */
end_comment

begin_function
name|void
name|sort_list_init
parameter_list|(
name|struct
name|sort_list
modifier|*
name|l
parameter_list|)
block|{
if|if
condition|(
name|l
condition|)
block|{
name|l
operator|->
name|count
operator|=
literal|0
expr_stmt|;
name|l
operator|->
name|size
operator|=
literal|0
expr_stmt|;
name|l
operator|->
name|memsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sort_list
argument_list|)
expr_stmt|;
name|l
operator|->
name|list
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Add string to sort list  */
end_comment

begin_function
name|void
name|sort_list_add
parameter_list|(
name|struct
name|sort_list
modifier|*
name|l
parameter_list|,
name|struct
name|bwstring
modifier|*
name|str
parameter_list|)
block|{
if|if
condition|(
name|l
operator|&&
name|str
condition|)
block|{
name|size_t
name|indx
init|=
name|l
operator|->
name|count
decl_stmt|;
if|if
condition|(
operator|(
name|l
operator|->
name|list
operator|==
name|NULL
operator|)
operator|||
operator|(
name|indx
operator|>=
name|l
operator|->
name|size
operator|)
condition|)
block|{
name|size_t
name|newsize
init|=
operator|(
name|l
operator|->
name|size
operator|+
literal|1
operator|)
operator|+
literal|1024
decl_stmt|;
name|l
operator|->
name|list
operator|=
name|sort_realloc
argument_list|(
name|l
operator|->
name|list
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sort_list_item
operator|*
argument_list|)
operator|*
name|newsize
argument_list|)
expr_stmt|;
name|l
operator|->
name|memsize
operator|+=
operator|(
name|newsize
operator|-
name|l
operator|->
name|size
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sort_list_item
operator|*
argument_list|)
expr_stmt|;
name|l
operator|->
name|size
operator|=
name|newsize
expr_stmt|;
block|}
name|l
operator|->
name|list
index|[
name|indx
index|]
operator|=
name|sort_list_item_alloc
argument_list|()
expr_stmt|;
name|sort_list_item_set
argument_list|(
name|l
operator|->
name|list
index|[
name|indx
index|]
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|l
operator|->
name|memsize
operator|+=
name|sort_list_item_size
argument_list|(
name|l
operator|->
name|list
index|[
name|indx
index|]
argument_list|)
expr_stmt|;
name|l
operator|->
name|count
operator|+=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Clean sort list data  */
end_comment

begin_function
name|void
name|sort_list_clean
parameter_list|(
name|struct
name|sort_list
modifier|*
name|l
parameter_list|)
block|{
if|if
condition|(
name|l
condition|)
block|{
if|if
condition|(
name|l
operator|->
name|list
condition|)
block|{
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|l
operator|->
name|count
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|sort_list_item
modifier|*
name|item
decl_stmt|;
name|item
operator|=
name|l
operator|->
name|list
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|item
condition|)
block|{
name|sort_list_item_clean
argument_list|(
name|item
argument_list|)
expr_stmt|;
name|sort_free
argument_list|(
name|item
argument_list|)
expr_stmt|;
name|l
operator|->
name|list
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|sort_free
argument_list|(
name|l
operator|->
name|list
argument_list|)
expr_stmt|;
name|l
operator|->
name|list
operator|=
name|NULL
expr_stmt|;
block|}
name|l
operator|->
name|count
operator|=
literal|0
expr_stmt|;
name|l
operator|->
name|size
operator|=
literal|0
expr_stmt|;
name|l
operator|->
name|memsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sort_list
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Write sort list to file  */
end_comment

begin_function
name|void
name|sort_list_dump
parameter_list|(
name|struct
name|sort_list
modifier|*
name|l
parameter_list|,
specifier|const
name|char
modifier|*
name|fn
parameter_list|)
block|{
if|if
condition|(
name|l
operator|&&
name|fn
condition|)
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
name|f
operator|=
name|openfile
argument_list|(
name|fn
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|2
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|->
name|list
condition|)
block|{
name|size_t
name|i
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|sort_opts_vals
operator|.
name|uflag
operator|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|l
operator|->
name|count
condition|;
operator|++
name|i
control|)
name|bwsfwrite
argument_list|(
name|l
operator|->
name|list
index|[
name|i
index|]
operator|->
name|str
argument_list|,
name|f
argument_list|,
name|sort_opts_vals
operator|.
name|zflag
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|sort_list_item
modifier|*
name|last_printed_item
init|=
name|NULL
decl_stmt|;
name|struct
name|sort_list_item
modifier|*
name|item
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|l
operator|->
name|count
condition|;
operator|++
name|i
control|)
block|{
name|item
operator|=
name|l
operator|->
name|list
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|last_printed_item
operator|==
name|NULL
operator|)
operator|||
name|list_coll
argument_list|(
operator|&
name|last_printed_item
argument_list|,
operator|&
name|item
argument_list|)
condition|)
block|{
name|bwsfwrite
argument_list|(
name|item
operator|->
name|str
argument_list|,
name|f
argument_list|,
name|sort_opts_vals
operator|.
name|zflag
argument_list|)
expr_stmt|;
name|last_printed_item
operator|=
name|item
expr_stmt|;
block|}
block|}
block|}
block|}
name|closefile
argument_list|(
name|f
argument_list|,
name|fn
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Checks if the given file is sorted.  Stops at the first disorder,  * prints the disordered line and returns 1.  */
end_comment

begin_function
name|int
name|check
parameter_list|(
specifier|const
name|char
modifier|*
name|fn
parameter_list|)
block|{
name|struct
name|bwstring
modifier|*
name|s1
decl_stmt|,
modifier|*
name|s2
decl_stmt|,
modifier|*
name|s1disorder
decl_stmt|,
modifier|*
name|s2disorder
decl_stmt|;
name|struct
name|file_reader
modifier|*
name|fr
decl_stmt|;
name|struct
name|keys_array
modifier|*
name|ka1
decl_stmt|,
modifier|*
name|ka2
decl_stmt|;
name|int
name|res
decl_stmt|;
name|size_t
name|pos
decl_stmt|,
name|posdisorder
decl_stmt|;
name|s1
operator|=
name|s2
operator|=
name|s1disorder
operator|=
name|s2disorder
operator|=
name|NULL
expr_stmt|;
name|ka1
operator|=
name|ka2
operator|=
name|NULL
expr_stmt|;
name|fr
operator|=
name|file_reader_init
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|res
operator|=
literal|0
expr_stmt|;
name|pos
operator|=
literal|1
expr_stmt|;
name|posdisorder
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|fr
operator|==
name|NULL
condition|)
block|{
name|err
argument_list|(
literal|2
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
goto|goto
name|end
goto|;
block|}
name|s1
operator|=
name|file_reader_readline
argument_list|(
name|fr
argument_list|)
expr_stmt|;
if|if
condition|(
name|s1
operator|==
name|NULL
condition|)
goto|goto
name|end
goto|;
name|ka1
operator|=
name|keys_array_alloc
argument_list|()
expr_stmt|;
name|preproc
argument_list|(
name|s1
argument_list|,
name|ka1
argument_list|)
expr_stmt|;
name|s2
operator|=
name|file_reader_readline
argument_list|(
name|fr
argument_list|)
expr_stmt|;
if|if
condition|(
name|s2
operator|==
name|NULL
condition|)
goto|goto
name|end
goto|;
name|ka2
operator|=
name|keys_array_alloc
argument_list|()
expr_stmt|;
name|preproc
argument_list|(
name|s2
argument_list|,
name|ka2
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|debug_sort
condition|)
block|{
name|bwsprintf
argument_list|(
name|stdout
argument_list|,
name|s2
argument_list|,
literal|"s1=<"
argument_list|,
literal|">"
argument_list|)
expr_stmt|;
name|bwsprintf
argument_list|(
name|stdout
argument_list|,
name|s1
argument_list|,
literal|"s2=<"
argument_list|,
literal|">"
argument_list|)
expr_stmt|;
block|}
name|int
name|cmp
init|=
name|key_coll
argument_list|(
name|ka2
argument_list|,
name|ka1
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|debug_sort
condition|)
name|printf
argument_list|(
literal|"; cmp1=%d"
argument_list|,
name|cmp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cmp
operator|&&
name|sort_opts_vals
operator|.
name|complex_sort
operator|&&
operator|!
operator|(
name|sort_opts_vals
operator|.
name|uflag
operator|)
operator|&&
operator|!
operator|(
name|sort_opts_vals
operator|.
name|sflag
operator|)
condition|)
block|{
name|cmp
operator|=
name|top_level_str_coll
argument_list|(
name|s2
argument_list|,
name|s1
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_sort
condition|)
name|printf
argument_list|(
literal|"; cmp2=%d"
argument_list|,
name|cmp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|debug_sort
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sort_opts_vals
operator|.
name|uflag
operator|&&
operator|(
name|cmp
operator|<=
literal|0
operator|)
operator|)
operator|||
operator|(
name|cmp
operator|<
literal|0
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|sort_opts_vals
operator|.
name|csilentflag
operator|)
condition|)
block|{
name|s2disorder
operator|=
name|bwsdup
argument_list|(
name|s2
argument_list|)
expr_stmt|;
name|posdisorder
operator|=
name|pos
expr_stmt|;
if|if
condition|(
name|debug_sort
condition|)
name|s1disorder
operator|=
name|bwsdup
argument_list|(
name|s1
argument_list|)
expr_stmt|;
block|}
name|res
operator|=
literal|1
expr_stmt|;
goto|goto
name|end
goto|;
block|}
name|pos
operator|++
expr_stmt|;
name|clean_keys_array
argument_list|(
name|s1
argument_list|,
name|ka1
argument_list|)
expr_stmt|;
name|sort_free
argument_list|(
name|ka1
argument_list|)
expr_stmt|;
name|ka1
operator|=
name|ka2
expr_stmt|;
name|ka2
operator|=
name|NULL
expr_stmt|;
name|bwsfree
argument_list|(
name|s1
argument_list|)
expr_stmt|;
name|s1
operator|=
name|s2
expr_stmt|;
name|s2
operator|=
name|file_reader_readline
argument_list|(
name|fr
argument_list|)
expr_stmt|;
if|if
condition|(
name|s2
operator|==
name|NULL
condition|)
goto|goto
name|end
goto|;
name|ka2
operator|=
name|keys_array_alloc
argument_list|()
expr_stmt|;
name|preproc
argument_list|(
name|s2
argument_list|,
name|ka2
argument_list|)
expr_stmt|;
block|}
name|end
label|:
if|if
condition|(
name|ka1
condition|)
block|{
name|clean_keys_array
argument_list|(
name|s1
argument_list|,
name|ka1
argument_list|)
expr_stmt|;
name|sort_free
argument_list|(
name|ka1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|s1
condition|)
name|bwsfree
argument_list|(
name|s1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ka2
condition|)
block|{
name|clean_keys_array
argument_list|(
name|s2
argument_list|,
name|ka2
argument_list|)
expr_stmt|;
name|sort_free
argument_list|(
name|ka2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|s2
condition|)
name|bwsfree
argument_list|(
name|s2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fn
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|*
name|fn
operator|==
literal|0
operator|)
operator|||
operator|(
name|strcmp
argument_list|(
name|fn
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|s2
operator|=
name|file_reader_readline
argument_list|(
name|fr
argument_list|)
expr_stmt|;
if|if
condition|(
name|s2
operator|==
name|NULL
condition|)
break|break;
name|bwsfree
argument_list|(
name|s2
argument_list|)
expr_stmt|;
block|}
block|}
name|file_reader_free
argument_list|(
name|fr
argument_list|)
expr_stmt|;
if|if
condition|(
name|s2disorder
condition|)
block|{
name|bws_disorder_warnx
argument_list|(
name|s2disorder
argument_list|,
name|fn
argument_list|,
name|posdisorder
argument_list|)
expr_stmt|;
if|if
condition|(
name|s1disorder
condition|)
block|{
name|bws_disorder_warnx
argument_list|(
name|s1disorder
argument_list|,
name|fn
argument_list|,
name|posdisorder
argument_list|)
expr_stmt|;
if|if
condition|(
name|s1disorder
operator|!=
name|s2disorder
condition|)
name|bwsfree
argument_list|(
name|s1disorder
argument_list|)
expr_stmt|;
block|}
name|bwsfree
argument_list|(
name|s2disorder
argument_list|)
expr_stmt|;
name|s1disorder
operator|=
name|NULL
expr_stmt|;
name|s2disorder
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|res
condition|)
name|exit
argument_list|(
name|res
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Opens a file.  If the given filename is "-", stdout will be  * opened.  */
end_comment

begin_function
name|FILE
modifier|*
name|openfile
parameter_list|(
specifier|const
name|char
modifier|*
name|fn
parameter_list|,
specifier|const
name|char
modifier|*
name|mode
parameter_list|)
block|{
name|FILE
modifier|*
name|file
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|fn
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
operator|(
operator|(
name|mode
operator|&&
name|mode
index|[
literal|0
index|]
operator|==
literal|'r'
operator|)
condition|?
name|stdin
else|:
name|stdout
operator|)
return|;
block|}
else|else
block|{
name|mode_t
name|orig_file_mask
init|=
literal|0
decl_stmt|;
name|int
name|is_tmp
init|=
name|file_is_tmp
argument_list|(
name|fn
argument_list|)
decl_stmt|;
if|if
condition|(
name|is_tmp
operator|&&
operator|(
name|mode
index|[
literal|0
index|]
operator|==
literal|'w'
operator|)
condition|)
name|orig_file_mask
operator|=
name|umask
argument_list|(
name|S_IWGRP
operator||
name|S_IWOTH
operator||
name|S_IRGRP
operator||
name|S_IROTH
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_tmp
operator|&&
operator|(
name|compress_program
operator|!=
name|NULL
operator|)
condition|)
block|{
name|char
modifier|*
name|cmd
decl_stmt|;
name|size_t
name|cmdsz
decl_stmt|;
name|cmdsz
operator|=
name|strlen
argument_list|(
name|fn
argument_list|)
operator|+
literal|128
expr_stmt|;
name|cmd
operator|=
name|sort_malloc
argument_list|(
name|cmdsz
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
index|[
literal|0
index|]
operator|==
literal|'r'
condition|)
name|snprintf
argument_list|(
name|cmd
argument_list|,
name|cmdsz
operator|-
literal|1
argument_list|,
literal|"cat %s | %s -d"
argument_list|,
name|fn
argument_list|,
name|compress_program
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|mode
index|[
literal|0
index|]
operator|==
literal|'w'
condition|)
name|snprintf
argument_list|(
name|cmd
argument_list|,
name|cmdsz
operator|-
literal|1
argument_list|,
literal|"%s> %s"
argument_list|,
name|compress_program
argument_list|,
name|fn
argument_list|)
expr_stmt|;
else|else
name|err
argument_list|(
literal|2
argument_list|,
literal|"%s"
argument_list|,
name|getstr
argument_list|(
literal|7
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|file
operator|=
name|popen
argument_list|(
name|cmd
argument_list|,
name|mode
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|2
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|sort_free
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|file
operator|=
name|fopen
argument_list|(
name|fn
argument_list|,
name|mode
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|2
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_tmp
operator|&&
operator|(
name|mode
index|[
literal|0
index|]
operator|==
literal|'w'
operator|)
condition|)
name|umask
argument_list|(
name|orig_file_mask
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|file
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Close file  */
end_comment

begin_function
name|void
name|closefile
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|,
specifier|const
name|char
modifier|*
name|fn
parameter_list|)
block|{
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
empty_stmt|;
block|}
elseif|else
if|if
condition|(
name|f
operator|==
name|stdin
condition|)
block|{
empty_stmt|;
block|}
elseif|else
if|if
condition|(
name|f
operator|==
name|stdout
condition|)
block|{
name|fflush
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|file_is_tmp
argument_list|(
name|fn
argument_list|)
operator|&&
name|compress_program
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|pclose
argument_list|(
name|f
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|2
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Reads a file into the internal buffer.  */
end_comment

begin_function
name|struct
name|file_reader
modifier|*
name|file_reader_init
parameter_list|(
specifier|const
name|char
modifier|*
name|fsrc
parameter_list|)
block|{
name|struct
name|file_reader
modifier|*
name|ret
decl_stmt|;
if|if
condition|(
name|fsrc
operator|==
name|NULL
condition|)
name|fsrc
operator|=
literal|"-"
expr_stmt|;
name|ret
operator|=
name|sort_malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|file_reader
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|ret
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|file_reader
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|->
name|elsymb
operator|=
literal|'\n'
expr_stmt|;
if|if
condition|(
name|sort_opts_vals
operator|.
name|zflag
condition|)
name|ret
operator|->
name|elsymb
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|fname
operator|=
name|sort_strdup
argument_list|(
name|fsrc
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|fsrc
argument_list|,
literal|"-"
argument_list|)
operator|&&
operator|(
name|compress_program
operator|==
name|NULL
operator|)
operator|&&
name|use_mmap
condition|)
block|{
do|do
block|{
name|struct
name|stat
name|stat_buf
decl_stmt|;
name|void
modifier|*
name|addr
decl_stmt|;
name|size_t
name|sz
init|=
literal|0
decl_stmt|;
name|int
name|fd
decl_stmt|,
name|flags
decl_stmt|;
name|flags
operator|=
name|MAP_NOCORE
operator||
name|MAP_NOSYNC
expr_stmt|;
name|addr
operator|=
name|MAP_FAILED
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|fsrc
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|2
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|stat_buf
argument_list|)
operator|<
literal|0
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
break|break;
block|}
name|sz
operator|=
name|stat_buf
operator|.
name|st_size
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|MAP_PREFAULT_READ
argument_list|)
name|flags
operator||=
name|MAP_PREFAULT_READ
expr_stmt|;
endif|#
directive|endif
name|addr
operator|=
name|mmap
argument_list|(
name|NULL
argument_list|,
name|sz
argument_list|,
name|PROT_READ
argument_list|,
name|flags
argument_list|,
name|fd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|==
name|MAP_FAILED
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
break|break;
block|}
name|ret
operator|->
name|fd
operator|=
name|fd
expr_stmt|;
name|ret
operator|->
name|mmapaddr
operator|=
name|addr
expr_stmt|;
name|ret
operator|->
name|mmapsize
operator|=
name|sz
expr_stmt|;
name|ret
operator|->
name|mmapptr
operator|=
name|ret
operator|->
name|mmapaddr
expr_stmt|;
block|}
do|while
condition|(
literal|0
condition|)
do|;
block|}
if|if
condition|(
name|ret
operator|->
name|mmapaddr
operator|==
name|NULL
condition|)
block|{
name|ret
operator|->
name|file
operator|=
name|openfile
argument_list|(
name|fsrc
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|->
name|file
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|2
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|fsrc
argument_list|,
literal|"-"
argument_list|)
condition|)
block|{
name|ret
operator|->
name|cbsz
operator|=
name|READ_CHUNK
expr_stmt|;
name|ret
operator|->
name|buffer
operator|=
name|sort_malloc
argument_list|(
name|ret
operator|->
name|cbsz
argument_list|)
expr_stmt|;
name|ret
operator|->
name|bsz
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|strbeg
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|bsz
operator|=
name|fread
argument_list|(
name|ret
operator|->
name|buffer
argument_list|,
literal|1
argument_list|,
name|ret
operator|->
name|cbsz
argument_list|,
name|ret
operator|->
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|->
name|bsz
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ferror
argument_list|(
name|ret
operator|->
name|file
argument_list|)
condition|)
name|err
argument_list|(
literal|2
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|bwstring
modifier|*
name|file_reader_readline
parameter_list|(
name|struct
name|file_reader
modifier|*
name|fr
parameter_list|)
block|{
name|struct
name|bwstring
modifier|*
name|ret
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|fr
operator|->
name|mmapaddr
condition|)
block|{
name|unsigned
name|char
modifier|*
name|mmapend
decl_stmt|;
name|mmapend
operator|=
name|fr
operator|->
name|mmapaddr
operator|+
name|fr
operator|->
name|mmapsize
expr_stmt|;
if|if
condition|(
name|fr
operator|->
name|mmapptr
operator|>=
name|mmapend
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
else|else
block|{
name|unsigned
name|char
modifier|*
name|strend
decl_stmt|;
name|size_t
name|sz
decl_stmt|;
name|sz
operator|=
name|mmapend
operator|-
name|fr
operator|->
name|mmapptr
expr_stmt|;
name|strend
operator|=
name|memchr
argument_list|(
name|fr
operator|->
name|mmapptr
argument_list|,
name|fr
operator|->
name|elsymb
argument_list|,
name|sz
argument_list|)
expr_stmt|;
if|if
condition|(
name|strend
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|bwscsbdup
argument_list|(
name|fr
operator|->
name|mmapptr
argument_list|,
name|sz
argument_list|)
expr_stmt|;
name|fr
operator|->
name|mmapptr
operator|=
name|mmapend
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|bwscsbdup
argument_list|(
name|fr
operator|->
name|mmapptr
argument_list|,
name|strend
operator|-
name|fr
operator|->
name|mmapptr
argument_list|)
expr_stmt|;
name|fr
operator|->
name|mmapptr
operator|=
name|strend
operator|+
literal|1
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|fr
operator|->
name|file
operator|!=
name|stdin
condition|)
block|{
name|unsigned
name|char
modifier|*
name|strend
decl_stmt|;
name|size_t
name|bsz1
decl_stmt|,
name|remsz
decl_stmt|,
name|search_start
decl_stmt|;
name|search_start
operator|=
literal|0
expr_stmt|;
name|remsz
operator|=
literal|0
expr_stmt|;
name|strend
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|fr
operator|->
name|bsz
operator|>
name|fr
operator|->
name|strbeg
condition|)
name|remsz
operator|=
name|fr
operator|->
name|bsz
operator|-
name|fr
operator|->
name|strbeg
expr_stmt|;
comment|/* line read cycle */
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|remsz
operator|>
name|search_start
condition|)
name|strend
operator|=
name|memchr
argument_list|(
name|fr
operator|->
name|buffer
operator|+
name|fr
operator|->
name|strbeg
operator|+
name|search_start
argument_list|,
name|fr
operator|->
name|elsymb
argument_list|,
name|remsz
operator|-
name|search_start
argument_list|)
expr_stmt|;
else|else
name|strend
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|strend
condition|)
break|break;
if|if
condition|(
name|feof
argument_list|(
name|fr
operator|->
name|file
argument_list|)
condition|)
break|break;
if|if
condition|(
name|fr
operator|->
name|bsz
operator|!=
name|fr
operator|->
name|cbsz
condition|)
comment|/* NOTREACHED */
name|err
argument_list|(
literal|2
argument_list|,
literal|"File read software error 1"
argument_list|)
expr_stmt|;
if|if
condition|(
name|remsz
operator|>
operator|(
name|READ_CHUNK
operator|>>
literal|1
operator|)
condition|)
block|{
name|search_start
operator|=
name|fr
operator|->
name|cbsz
operator|-
name|fr
operator|->
name|strbeg
expr_stmt|;
name|fr
operator|->
name|cbsz
operator|+=
name|READ_CHUNK
expr_stmt|;
name|fr
operator|->
name|buffer
operator|=
name|sort_realloc
argument_list|(
name|fr
operator|->
name|buffer
argument_list|,
name|fr
operator|->
name|cbsz
argument_list|)
expr_stmt|;
name|bsz1
operator|=
name|fread
argument_list|(
name|fr
operator|->
name|buffer
operator|+
name|fr
operator|->
name|bsz
argument_list|,
literal|1
argument_list|,
name|READ_CHUNK
argument_list|,
name|fr
operator|->
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|bsz1
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ferror
argument_list|(
name|fr
operator|->
name|file
argument_list|)
condition|)
name|err
argument_list|(
literal|2
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
name|fr
operator|->
name|bsz
operator|+=
name|bsz1
expr_stmt|;
name|remsz
operator|+=
name|bsz1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|remsz
operator|>
literal|0
operator|&&
name|fr
operator|->
name|strbeg
operator|>
literal|0
condition|)
name|bcopy
argument_list|(
name|fr
operator|->
name|buffer
operator|+
name|fr
operator|->
name|strbeg
argument_list|,
name|fr
operator|->
name|buffer
argument_list|,
name|remsz
argument_list|)
expr_stmt|;
name|fr
operator|->
name|strbeg
operator|=
literal|0
expr_stmt|;
name|search_start
operator|=
name|remsz
expr_stmt|;
name|bsz1
operator|=
name|fread
argument_list|(
name|fr
operator|->
name|buffer
operator|+
name|remsz
argument_list|,
literal|1
argument_list|,
name|fr
operator|->
name|cbsz
operator|-
name|remsz
argument_list|,
name|fr
operator|->
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|bsz1
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ferror
argument_list|(
name|fr
operator|->
name|file
argument_list|)
condition|)
name|err
argument_list|(
literal|2
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
name|fr
operator|->
name|bsz
operator|=
name|remsz
operator|+
name|bsz1
expr_stmt|;
name|remsz
operator|=
name|fr
operator|->
name|bsz
expr_stmt|;
block|}
block|}
if|if
condition|(
name|strend
operator|==
name|NULL
condition|)
name|strend
operator|=
name|fr
operator|->
name|buffer
operator|+
name|fr
operator|->
name|bsz
expr_stmt|;
if|if
condition|(
operator|(
name|fr
operator|->
name|buffer
operator|+
name|fr
operator|->
name|strbeg
operator|<=
name|strend
operator|)
operator|&&
operator|(
name|fr
operator|->
name|strbeg
operator|<
name|fr
operator|->
name|bsz
operator|)
operator|&&
operator|(
name|remsz
operator|>
literal|0
operator|)
condition|)
name|ret
operator|=
name|bwscsbdup
argument_list|(
name|fr
operator|->
name|buffer
operator|+
name|fr
operator|->
name|strbeg
argument_list|,
name|strend
operator|-
name|fr
operator|->
name|buffer
operator|-
name|fr
operator|->
name|strbeg
argument_list|)
expr_stmt|;
name|fr
operator|->
name|strbeg
operator|=
operator|(
name|strend
operator|-
name|fr
operator|->
name|buffer
operator|)
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|size_t
name|len
init|=
literal|0
decl_stmt|;
name|ret
operator|=
name|bwsfgetln
argument_list|(
name|fr
operator|->
name|file
argument_list|,
operator|&
name|len
argument_list|,
name|sort_opts_vals
operator|.
name|zflag
argument_list|,
operator|&
operator|(
name|fr
operator|->
name|rb
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|file_reader_clean
parameter_list|(
name|struct
name|file_reader
modifier|*
name|fr
parameter_list|)
block|{
if|if
condition|(
name|fr
condition|)
block|{
if|if
condition|(
name|fr
operator|->
name|mmapaddr
condition|)
name|munmap
argument_list|(
name|fr
operator|->
name|mmapaddr
argument_list|,
name|fr
operator|->
name|mmapsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|fr
operator|->
name|fd
condition|)
name|close
argument_list|(
name|fr
operator|->
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|fr
operator|->
name|buffer
condition|)
name|sort_free
argument_list|(
name|fr
operator|->
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|fr
operator|->
name|file
condition|)
if|if
condition|(
name|fr
operator|->
name|file
operator|!=
name|stdin
condition|)
name|closefile
argument_list|(
name|fr
operator|->
name|file
argument_list|,
name|fr
operator|->
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|fr
operator|->
name|fname
condition|)
name|sort_free
argument_list|(
name|fr
operator|->
name|fname
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|fr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|file_reader
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|file_reader_free
parameter_list|(
name|struct
name|file_reader
modifier|*
name|fr
parameter_list|)
block|{
if|if
condition|(
name|fr
condition|)
block|{
name|file_reader_clean
argument_list|(
name|fr
argument_list|)
expr_stmt|;
name|sort_free
argument_list|(
name|fr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|procfile
parameter_list|(
specifier|const
name|char
modifier|*
name|fsrc
parameter_list|,
name|struct
name|sort_list
modifier|*
name|list
parameter_list|,
name|struct
name|file_list
modifier|*
name|fl
parameter_list|)
block|{
name|struct
name|file_reader
modifier|*
name|fr
decl_stmt|;
name|fr
operator|=
name|file_reader_init
argument_list|(
name|fsrc
argument_list|)
expr_stmt|;
if|if
condition|(
name|fr
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|2
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* file browse cycle */
for|for
control|(
init|;
condition|;
control|)
block|{
name|struct
name|bwstring
modifier|*
name|bws
decl_stmt|;
name|bws
operator|=
name|file_reader_readline
argument_list|(
name|fr
argument_list|)
expr_stmt|;
if|if
condition|(
name|bws
operator|==
name|NULL
condition|)
break|break;
name|sort_list_add
argument_list|(
name|list
argument_list|,
name|bws
argument_list|)
expr_stmt|;
if|if
condition|(
name|list
operator|->
name|memsize
operator|>=
name|available_free_memory
condition|)
block|{
name|char
modifier|*
name|fn
decl_stmt|;
name|fn
operator|=
name|new_tmp_file_name
argument_list|()
expr_stmt|;
name|sort_list_to_file
argument_list|(
name|list
argument_list|,
name|fn
argument_list|)
expr_stmt|;
name|file_list_add
argument_list|(
name|fl
argument_list|,
name|fn
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|sort_list_clean
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
block|}
name|file_reader_free
argument_list|(
name|fr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Compare file headers. Files with EOF always go to the end of the list.  */
end_comment

begin_function
specifier|static
name|int
name|file_header_cmp
parameter_list|(
name|struct
name|file_header
modifier|*
name|f1
parameter_list|,
name|struct
name|file_header
modifier|*
name|f2
parameter_list|)
block|{
if|if
condition|(
name|f1
operator|==
name|f2
condition|)
return|return
operator|(
literal|0
operator|)
return|;
else|else
block|{
if|if
condition|(
name|f1
operator|->
name|fr
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
operator|(
name|f2
operator|->
name|fr
operator|==
name|NULL
operator|)
condition|?
literal|0
else|:
operator|+
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|f2
operator|->
name|fr
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
else|else
block|{
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|list_coll
argument_list|(
operator|&
operator|(
name|f1
operator|->
name|si
operator|)
argument_list|,
operator|&
operator|(
name|f2
operator|->
name|si
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
return|return
operator|(
operator|(
name|f1
operator|->
name|file_pos
operator|<
name|f2
operator|->
name|file_pos
operator|)
condition|?
operator|-
literal|1
else|:
operator|+
literal|1
operator|)
return|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Allocate and init file header structure  */
end_comment

begin_function
specifier|static
name|void
name|file_header_init
parameter_list|(
name|struct
name|file_header
modifier|*
modifier|*
name|fh
parameter_list|,
specifier|const
name|char
modifier|*
name|fn
parameter_list|,
name|size_t
name|file_pos
parameter_list|)
block|{
if|if
condition|(
name|fh
operator|&&
name|fn
condition|)
block|{
name|struct
name|bwstring
modifier|*
name|line
decl_stmt|;
operator|*
name|fh
operator|=
name|sort_malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|file_header
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|fh
operator|)
operator|->
name|file_pos
operator|=
name|file_pos
expr_stmt|;
operator|(
operator|*
name|fh
operator|)
operator|->
name|fr
operator|=
name|file_reader_init
argument_list|(
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|fh
operator|)
operator|->
name|fr
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|err
argument_list|(
literal|2
argument_list|,
literal|"%s"
argument_list|,
name|getstr
argument_list|(
literal|8
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|line
operator|=
name|file_reader_readline
argument_list|(
operator|(
operator|*
name|fh
operator|)
operator|->
name|fr
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|==
name|NULL
condition|)
block|{
name|file_reader_free
argument_list|(
operator|(
operator|*
name|fh
operator|)
operator|->
name|fr
argument_list|)
expr_stmt|;
operator|(
operator|*
name|fh
operator|)
operator|->
name|fr
operator|=
name|NULL
expr_stmt|;
operator|(
operator|*
name|fh
operator|)
operator|->
name|si
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
operator|(
operator|*
name|fh
operator|)
operator|->
name|si
operator|=
name|sort_list_item_alloc
argument_list|()
expr_stmt|;
name|sort_list_item_set
argument_list|(
operator|(
operator|*
name|fh
operator|)
operator|->
name|si
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Close file  */
end_comment

begin_function
specifier|static
name|void
name|file_header_close
parameter_list|(
name|struct
name|file_header
modifier|*
modifier|*
name|fh
parameter_list|)
block|{
if|if
condition|(
name|fh
operator|&&
operator|*
name|fh
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|fh
operator|)
operator|->
name|fr
condition|)
block|{
name|file_reader_free
argument_list|(
operator|(
operator|*
name|fh
operator|)
operator|->
name|fr
argument_list|)
expr_stmt|;
operator|(
operator|*
name|fh
operator|)
operator|->
name|fr
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|*
name|fh
operator|)
operator|->
name|si
condition|)
block|{
name|sort_list_item_clean
argument_list|(
operator|(
operator|*
name|fh
operator|)
operator|->
name|si
argument_list|)
expr_stmt|;
name|sort_free
argument_list|(
operator|(
operator|*
name|fh
operator|)
operator|->
name|si
argument_list|)
expr_stmt|;
operator|(
operator|*
name|fh
operator|)
operator|->
name|si
operator|=
name|NULL
expr_stmt|;
block|}
name|sort_free
argument_list|(
operator|*
name|fh
argument_list|)
expr_stmt|;
operator|*
name|fh
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Swap two array elements  */
end_comment

begin_function
specifier|static
name|void
name|file_header_swap
parameter_list|(
name|struct
name|file_header
modifier|*
modifier|*
name|fh
parameter_list|,
name|size_t
name|i1
parameter_list|,
name|size_t
name|i2
parameter_list|)
block|{
name|struct
name|file_header
modifier|*
name|tmp
decl_stmt|;
name|tmp
operator|=
name|fh
index|[
name|i1
index|]
expr_stmt|;
name|fh
index|[
name|i1
index|]
operator|=
name|fh
index|[
name|i2
index|]
expr_stmt|;
name|fh
index|[
name|i2
index|]
operator|=
name|tmp
expr_stmt|;
block|}
end_function

begin_comment
comment|/* heap algorithm ==>> */
end_comment

begin_comment
comment|/*  * See heap sort algorithm  * "Raises" last element to its right place  */
end_comment

begin_function
specifier|static
name|void
name|file_header_heap_swim
parameter_list|(
name|struct
name|file_header
modifier|*
modifier|*
name|fh
parameter_list|,
name|size_t
name|indx
parameter_list|)
block|{
if|if
condition|(
name|indx
operator|>
literal|0
condition|)
block|{
name|size_t
name|parent_index
decl_stmt|;
name|parent_index
operator|=
operator|(
name|indx
operator|-
literal|1
operator|)
operator|>>
literal|1
expr_stmt|;
if|if
condition|(
name|file_header_cmp
argument_list|(
name|fh
index|[
name|indx
index|]
argument_list|,
name|fh
index|[
name|parent_index
index|]
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* swap child and parent and continue */
name|file_header_swap
argument_list|(
name|fh
argument_list|,
name|indx
argument_list|,
name|parent_index
argument_list|)
expr_stmt|;
name|file_header_heap_swim
argument_list|(
name|fh
argument_list|,
name|parent_index
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Sink the top element to its correct position  */
end_comment

begin_function
specifier|static
name|void
name|file_header_heap_sink
parameter_list|(
name|struct
name|file_header
modifier|*
modifier|*
name|fh
parameter_list|,
name|size_t
name|indx
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|size_t
name|left_child_index
decl_stmt|;
name|size_t
name|right_child_index
decl_stmt|;
name|left_child_index
operator|=
name|indx
operator|+
name|indx
operator|+
literal|1
expr_stmt|;
name|right_child_index
operator|=
name|left_child_index
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|left_child_index
operator|<
name|size
condition|)
block|{
name|size_t
name|min_child_index
decl_stmt|;
name|min_child_index
operator|=
name|left_child_index
expr_stmt|;
if|if
condition|(
operator|(
name|right_child_index
operator|<
name|size
operator|)
operator|&&
operator|(
name|file_header_cmp
argument_list|(
name|fh
index|[
name|left_child_index
index|]
argument_list|,
name|fh
index|[
name|right_child_index
index|]
argument_list|)
operator|>
literal|0
operator|)
condition|)
name|min_child_index
operator|=
name|right_child_index
expr_stmt|;
if|if
condition|(
name|file_header_cmp
argument_list|(
name|fh
index|[
name|indx
index|]
argument_list|,
name|fh
index|[
name|min_child_index
index|]
argument_list|)
operator|>
literal|0
condition|)
block|{
name|file_header_swap
argument_list|(
name|fh
argument_list|,
name|indx
argument_list|,
name|min_child_index
argument_list|)
expr_stmt|;
name|file_header_heap_sink
argument_list|(
name|fh
argument_list|,
name|min_child_index
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*<<== heap algorithm */
end_comment

begin_comment
comment|/*  * Adds element to the "left" end  */
end_comment

begin_function
specifier|static
name|void
name|file_header_list_rearrange_from_header
parameter_list|(
name|struct
name|file_header
modifier|*
modifier|*
name|fh
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|file_header_heap_sink
argument_list|(
name|fh
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Adds element to the "right" end  */
end_comment

begin_function
specifier|static
name|void
name|file_header_list_push
parameter_list|(
name|struct
name|file_header
modifier|*
name|f
parameter_list|,
name|struct
name|file_header
modifier|*
modifier|*
name|fh
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|fh
index|[
name|size
operator|++
index|]
operator|=
name|f
expr_stmt|;
name|file_header_heap_swim
argument_list|(
name|fh
argument_list|,
name|size
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_struct
struct|struct
name|last_printed
block|{
name|struct
name|bwstring
modifier|*
name|str
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Prints the current line of the file  */
end_comment

begin_function
specifier|static
name|void
name|file_header_print
parameter_list|(
name|struct
name|file_header
modifier|*
name|fh
parameter_list|,
name|FILE
modifier|*
name|f_out
parameter_list|,
name|struct
name|last_printed
modifier|*
name|lp
parameter_list|)
block|{
if|if
condition|(
name|fh
operator|&&
name|fh
operator|->
name|fr
operator|&&
name|f_out
operator|&&
name|fh
operator|->
name|si
operator|&&
name|fh
operator|->
name|si
operator|->
name|str
condition|)
block|{
if|if
condition|(
name|sort_opts_vals
operator|.
name|uflag
condition|)
block|{
if|if
condition|(
operator|(
name|lp
operator|->
name|str
operator|==
name|NULL
operator|)
operator|||
operator|(
name|str_list_coll
argument_list|(
name|lp
operator|->
name|str
argument_list|,
operator|&
operator|(
name|fh
operator|->
name|si
operator|)
argument_list|)
operator|)
condition|)
block|{
name|bwsfwrite
argument_list|(
name|fh
operator|->
name|si
operator|->
name|str
argument_list|,
name|f_out
argument_list|,
name|sort_opts_vals
operator|.
name|zflag
argument_list|)
expr_stmt|;
if|if
condition|(
name|lp
operator|->
name|str
condition|)
name|bwsfree
argument_list|(
name|lp
operator|->
name|str
argument_list|)
expr_stmt|;
name|lp
operator|->
name|str
operator|=
name|bwsdup
argument_list|(
name|fh
operator|->
name|si
operator|->
name|str
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|bwsfwrite
argument_list|(
name|fh
operator|->
name|si
operator|->
name|str
argument_list|,
name|f_out
argument_list|,
name|sort_opts_vals
operator|.
name|zflag
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Read next line  */
end_comment

begin_function
specifier|static
name|void
name|file_header_read_next
parameter_list|(
name|struct
name|file_header
modifier|*
name|fh
parameter_list|)
block|{
if|if
condition|(
name|fh
operator|&&
name|fh
operator|->
name|fr
condition|)
block|{
name|struct
name|bwstring
modifier|*
name|tmp
decl_stmt|;
name|tmp
operator|=
name|file_reader_readline
argument_list|(
name|fh
operator|->
name|fr
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
name|NULL
condition|)
block|{
name|file_reader_free
argument_list|(
name|fh
operator|->
name|fr
argument_list|)
expr_stmt|;
name|fh
operator|->
name|fr
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|fh
operator|->
name|si
condition|)
block|{
name|sort_list_item_clean
argument_list|(
name|fh
operator|->
name|si
argument_list|)
expr_stmt|;
name|sort_free
argument_list|(
name|fh
operator|->
name|si
argument_list|)
expr_stmt|;
name|fh
operator|->
name|si
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|fh
operator|->
name|si
operator|==
name|NULL
condition|)
name|fh
operator|->
name|si
operator|=
name|sort_list_item_alloc
argument_list|()
expr_stmt|;
name|sort_list_item_set
argument_list|(
name|fh
operator|->
name|si
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Merge array of "files headers"  */
end_comment

begin_function
specifier|static
name|void
name|file_headers_merge
parameter_list|(
name|size_t
name|fnum
parameter_list|,
name|struct
name|file_header
modifier|*
modifier|*
name|fh
parameter_list|,
name|FILE
modifier|*
name|f_out
parameter_list|)
block|{
name|struct
name|last_printed
name|lp
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|memset
argument_list|(
operator|&
name|lp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|lp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * construct the initial sort structure 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fnum
condition|;
name|i
operator|++
control|)
name|file_header_list_push
argument_list|(
name|fh
index|[
name|i
index|]
argument_list|,
name|fh
argument_list|,
name|i
argument_list|)
expr_stmt|;
while|while
condition|(
name|fh
index|[
literal|0
index|]
operator|->
name|fr
condition|)
block|{
comment|/* unfinished files are always in front */
comment|/* output the smallest line: */
name|file_header_print
argument_list|(
name|fh
index|[
literal|0
index|]
argument_list|,
name|f_out
argument_list|,
operator|&
name|lp
argument_list|)
expr_stmt|;
comment|/* read a new line, if possible: */
name|file_header_read_next
argument_list|(
name|fh
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* re-arrange the list: */
name|file_header_list_rearrange_from_header
argument_list|(
name|fh
argument_list|,
name|fnum
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lp
operator|.
name|str
condition|)
name|bwsfree
argument_list|(
name|lp
operator|.
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Merges the given files into the output file, which can be  * stdout.  */
end_comment

begin_function
specifier|static
name|void
name|merge_files_array
parameter_list|(
name|size_t
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
specifier|const
name|char
modifier|*
name|fn_out
parameter_list|)
block|{
if|if
condition|(
name|argv
operator|&&
name|fn_out
condition|)
block|{
name|struct
name|file_header
modifier|*
modifier|*
name|fh
decl_stmt|;
name|FILE
modifier|*
name|f_out
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|f_out
operator|=
name|openfile
argument_list|(
name|fn_out
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f_out
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|2
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|fh
operator|=
name|sort_malloc
argument_list|(
operator|(
name|argc
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|file_header
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
name|file_header_init
argument_list|(
name|fh
operator|+
name|i
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|,
operator|(
name|size_t
operator|)
name|i
argument_list|)
expr_stmt|;
name|file_headers_merge
argument_list|(
name|argc
argument_list|,
name|fh
argument_list|,
name|f_out
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
name|file_header_close
argument_list|(
name|fh
operator|+
name|i
argument_list|)
expr_stmt|;
name|sort_free
argument_list|(
name|fh
argument_list|)
expr_stmt|;
name|closefile
argument_list|(
name|f_out
argument_list|,
name|fn_out
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Shrinks the file list until its size smaller than max number of opened files  */
end_comment

begin_function
specifier|static
name|int
name|shrink_file_list
parameter_list|(
name|struct
name|file_list
modifier|*
name|fl
parameter_list|)
block|{
if|if
condition|(
operator|(
name|fl
operator|==
name|NULL
operator|)
operator|||
call|(
name|size_t
call|)
argument_list|(
name|fl
operator|->
name|count
argument_list|)
operator|<
name|max_open_files
condition|)
return|return
operator|(
literal|0
operator|)
return|;
else|else
block|{
name|struct
name|file_list
name|new_fl
decl_stmt|;
name|size_t
name|indx
init|=
literal|0
decl_stmt|;
name|file_list_init
argument_list|(
operator|&
name|new_fl
argument_list|,
name|true
argument_list|)
expr_stmt|;
while|while
condition|(
name|indx
operator|<
name|fl
operator|->
name|count
condition|)
block|{
name|char
modifier|*
name|fnew
decl_stmt|;
name|size_t
name|num
decl_stmt|;
name|num
operator|=
name|fl
operator|->
name|count
operator|-
name|indx
expr_stmt|;
name|fnew
operator|=
name|new_tmp_file_name
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|size_t
operator|)
name|num
operator|>=
name|max_open_files
condition|)
name|num
operator|=
name|max_open_files
operator|-
literal|1
expr_stmt|;
name|merge_files_array
argument_list|(
name|num
argument_list|,
name|fl
operator|->
name|fns
operator|+
name|indx
argument_list|,
name|fnew
argument_list|)
expr_stmt|;
if|if
condition|(
name|fl
operator|->
name|tmp
condition|)
block|{
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
name|unlink
argument_list|(
name|fl
operator|->
name|fns
index|[
name|indx
operator|+
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|file_list_add
argument_list|(
operator|&
name|new_fl
argument_list|,
name|fnew
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|indx
operator|+=
name|num
expr_stmt|;
block|}
name|fl
operator|->
name|tmp
operator|=
name|false
expr_stmt|;
comment|/* already taken care of */
name|file_list_clean
argument_list|(
name|fl
argument_list|)
expr_stmt|;
name|fl
operator|->
name|count
operator|=
name|new_fl
operator|.
name|count
expr_stmt|;
name|fl
operator|->
name|fns
operator|=
name|new_fl
operator|.
name|fns
expr_stmt|;
name|fl
operator|->
name|sz
operator|=
name|new_fl
operator|.
name|sz
expr_stmt|;
name|fl
operator|->
name|tmp
operator|=
name|new_fl
operator|.
name|tmp
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Merge list of files  */
end_comment

begin_function
name|void
name|merge_files
parameter_list|(
name|struct
name|file_list
modifier|*
name|fl
parameter_list|,
specifier|const
name|char
modifier|*
name|fn_out
parameter_list|)
block|{
if|if
condition|(
name|fl
operator|&&
name|fn_out
condition|)
block|{
while|while
condition|(
name|shrink_file_list
argument_list|(
name|fl
argument_list|)
condition|)
empty_stmt|;
name|merge_files_array
argument_list|(
name|fl
operator|->
name|count
argument_list|,
name|fl
operator|->
name|fns
argument_list|,
name|fn_out
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_sort_method_name
parameter_list|(
name|int
name|sm
parameter_list|)
block|{
if|if
condition|(
name|sm
operator|==
name|SORT_MERGESORT
condition|)
return|return
literal|"mergesort"
return|;
elseif|else
if|if
condition|(
name|sort_opts_vals
operator|.
name|sort_method
operator|==
name|SORT_RADIXSORT
condition|)
return|return
literal|"radixsort"
return|;
elseif|else
if|if
condition|(
name|sort_opts_vals
operator|.
name|sort_method
operator|==
name|SORT_HEAPSORT
condition|)
return|return
literal|"heapsort"
return|;
else|else
return|return
literal|"quicksort"
return|;
block|}
end_function

begin_comment
comment|/*  * Wrapper for qsort  */
end_comment

begin_function
specifier|static
name|int
name|sort_qsort
parameter_list|(
name|void
modifier|*
name|list
parameter_list|,
name|size_t
name|count
parameter_list|,
name|size_t
name|elem_size
parameter_list|,
name|int
function_decl|(
modifier|*
name|cmp_func
function_decl|)
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
parameter_list|)
block|{
name|qsort
argument_list|(
name|list
argument_list|,
name|count
argument_list|,
name|elem_size
argument_list|,
name|cmp_func
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Sort list of lines and writes it to the file  */
end_comment

begin_function
name|void
name|sort_list_to_file
parameter_list|(
name|struct
name|sort_list
modifier|*
name|list
parameter_list|,
specifier|const
name|char
modifier|*
name|outfile
parameter_list|)
block|{
name|struct
name|sort_mods
modifier|*
name|sm
init|=
operator|&
operator|(
name|keys
index|[
literal|0
index|]
operator|.
name|sm
operator|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|sm
operator|->
name|Mflag
operator|)
operator|&&
operator|!
operator|(
name|sm
operator|->
name|Rflag
operator|)
operator|&&
operator|!
operator|(
name|sm
operator|->
name|Vflag
operator|)
operator|&&
operator|!
operator|(
name|sm
operator|->
name|Vflag
operator|)
operator|&&
operator|!
operator|(
name|sm
operator|->
name|gflag
operator|)
operator|&&
operator|!
operator|(
name|sm
operator|->
name|hflag
operator|)
operator|&&
operator|!
operator|(
name|sm
operator|->
name|nflag
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|sort_opts_vals
operator|.
name|sort_method
operator|==
name|SORT_DEFAULT
operator|)
operator|&&
name|byte_sort
condition|)
name|sort_opts_vals
operator|.
name|sort_method
operator|=
name|SORT_RADIXSORT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sort_opts_vals
operator|.
name|sort_method
operator|==
name|SORT_RADIXSORT
condition|)
name|err
argument_list|(
literal|2
argument_list|,
literal|"%s"
argument_list|,
name|getstr
argument_list|(
literal|9
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * to handle stable sort and the unique cases in the 	 * right order, we need stable basic algorithm 	 */
if|if
condition|(
name|sort_opts_vals
operator|.
name|sflag
condition|)
block|{
switch|switch
condition|(
name|sort_opts_vals
operator|.
name|sort_method
condition|)
block|{
case|case
name|SORT_MERGESORT
case|:
break|break;
case|case
name|SORT_RADIXSORT
case|:
break|break;
case|case
name|SORT_DEFAULT
case|:
name|sort_opts_vals
operator|.
name|sort_method
operator|=
name|SORT_MERGESORT
expr_stmt|;
break|break;
default|default:
name|errx
argument_list|(
literal|2
argument_list|,
literal|"%s"
argument_list|,
name|getstr
argument_list|(
literal|10
argument_list|)
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
block|}
if|if
condition|(
name|sort_opts_vals
operator|.
name|sort_method
operator|==
name|SORT_DEFAULT
condition|)
name|sort_opts_vals
operator|.
name|sort_method
operator|=
name|DEFAULT_SORT_ALGORITHM
expr_stmt|;
if|if
condition|(
name|debug_sort
condition|)
name|printf
argument_list|(
literal|"sort_method=%s\n"
argument_list|,
name|get_sort_method_name
argument_list|(
name|sort_opts_vals
operator|.
name|sort_method
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sort_opts_vals
operator|.
name|sort_method
condition|)
block|{
case|case
name|SORT_RADIXSORT
case|:
name|rxsort
argument_list|(
name|list
operator|->
name|list
argument_list|,
name|list
operator|->
name|count
argument_list|)
expr_stmt|;
name|sort_list_dump
argument_list|(
name|list
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|SORT_MERGESORT
case|:
name|mt_sort
argument_list|(
name|list
argument_list|,
name|mergesort
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|SORT_HEAPSORT
case|:
name|mt_sort
argument_list|(
name|list
argument_list|,
name|heapsort
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|SORT_QSORT
case|:
name|mt_sort
argument_list|(
name|list
argument_list|,
name|sort_qsort
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
break|break;
default|default:
name|mt_sort
argument_list|(
name|list
argument_list|,
name|DEFAULT_SORT_FUNC
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/******************* MT SORT ************************/
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SORT_THREADS
argument_list|)
end_if

begin_comment
comment|/* semaphore to count threads */
end_comment

begin_decl_stmt
specifier|static
name|sem_t
name|mtsem
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current system sort function */
end_comment

begin_function_decl
specifier|static
name|int
function_decl|(
modifier|*
name|g_sort_func
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|size_t
parameter_list|,
name|int
function_decl|(
modifier|*
function_decl|)
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Sort cycle thread (in multi-threaded mode)  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|mt_sort_thread
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|sort_list
modifier|*
name|list
init|=
name|arg
decl_stmt|;
name|g_sort_func
argument_list|(
name|list
operator|->
name|list
argument_list|,
name|list
operator|->
name|count
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sort_list_item
operator|*
argument_list|)
argument_list|,
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
specifier|const
name|void
operator|*
argument_list|,
specifier|const
name|void
operator|*
argument_list|)
operator|)
name|list_coll
argument_list|)
expr_stmt|;
name|sem_post
argument_list|(
operator|&
name|mtsem
argument_list|)
expr_stmt|;
return|return
operator|(
name|arg
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Compare sub-lists. Empty sub-lists always go to the end of the list.  */
end_comment

begin_function
specifier|static
name|int
name|sub_list_cmp
parameter_list|(
name|struct
name|sort_list
modifier|*
name|l1
parameter_list|,
name|struct
name|sort_list
modifier|*
name|l2
parameter_list|)
block|{
if|if
condition|(
name|l1
operator|==
name|l2
condition|)
return|return
operator|(
literal|0
operator|)
return|;
else|else
block|{
if|if
condition|(
name|l1
operator|->
name|count
operator|==
literal|0
condition|)
block|{
return|return
operator|(
operator|(
name|l2
operator|->
name|count
operator|==
literal|0
operator|)
condition|?
literal|0
else|:
operator|+
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|l2
operator|->
name|count
operator|==
literal|0
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
else|else
block|{
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|list_coll
argument_list|(
operator|&
operator|(
name|l1
operator|->
name|list
index|[
literal|0
index|]
operator|)
argument_list|,
operator|&
operator|(
name|l2
operator|->
name|list
index|[
literal|0
index|]
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
return|return
operator|(
operator|(
name|l1
operator|->
name|sub_list_pos
operator|<
name|l2
operator|->
name|sub_list_pos
operator|)
condition|?
operator|-
literal|1
else|:
operator|+
literal|1
operator|)
return|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Swap two array elements  */
end_comment

begin_function
specifier|static
name|void
name|sub_list_swap
parameter_list|(
name|struct
name|sort_list
modifier|*
modifier|*
name|sl
parameter_list|,
name|size_t
name|i1
parameter_list|,
name|size_t
name|i2
parameter_list|)
block|{
name|struct
name|sort_list
modifier|*
name|tmp
decl_stmt|;
name|tmp
operator|=
name|sl
index|[
name|i1
index|]
expr_stmt|;
name|sl
index|[
name|i1
index|]
operator|=
name|sl
index|[
name|i2
index|]
expr_stmt|;
name|sl
index|[
name|i2
index|]
operator|=
name|tmp
expr_stmt|;
block|}
end_function

begin_comment
comment|/* heap algorithm ==>> */
end_comment

begin_comment
comment|/*  * See heap sort algorithm  * "Raises" last element to its right place  */
end_comment

begin_function
specifier|static
name|void
name|sub_list_swim
parameter_list|(
name|struct
name|sort_list
modifier|*
modifier|*
name|sl
parameter_list|,
name|size_t
name|indx
parameter_list|)
block|{
if|if
condition|(
name|indx
operator|>
literal|0
condition|)
block|{
name|size_t
name|parent_index
decl_stmt|;
name|parent_index
operator|=
operator|(
name|indx
operator|-
literal|1
operator|)
operator|>>
literal|1
expr_stmt|;
if|if
condition|(
name|sub_list_cmp
argument_list|(
name|sl
index|[
name|indx
index|]
argument_list|,
name|sl
index|[
name|parent_index
index|]
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* swap child and parent and continue */
name|sub_list_swap
argument_list|(
name|sl
argument_list|,
name|indx
argument_list|,
name|parent_index
argument_list|)
expr_stmt|;
name|sub_list_swim
argument_list|(
name|sl
argument_list|,
name|parent_index
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Sink the top element to its correct position  */
end_comment

begin_function
specifier|static
name|void
name|sub_list_sink
parameter_list|(
name|struct
name|sort_list
modifier|*
modifier|*
name|sl
parameter_list|,
name|size_t
name|indx
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|size_t
name|left_child_index
decl_stmt|;
name|size_t
name|right_child_index
decl_stmt|;
name|left_child_index
operator|=
name|indx
operator|+
name|indx
operator|+
literal|1
expr_stmt|;
name|right_child_index
operator|=
name|left_child_index
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|left_child_index
operator|<
name|size
condition|)
block|{
name|size_t
name|min_child_index
decl_stmt|;
name|min_child_index
operator|=
name|left_child_index
expr_stmt|;
if|if
condition|(
operator|(
name|right_child_index
operator|<
name|size
operator|)
operator|&&
operator|(
name|sub_list_cmp
argument_list|(
name|sl
index|[
name|left_child_index
index|]
argument_list|,
name|sl
index|[
name|right_child_index
index|]
argument_list|)
operator|>
literal|0
operator|)
condition|)
name|min_child_index
operator|=
name|right_child_index
expr_stmt|;
if|if
condition|(
name|sub_list_cmp
argument_list|(
name|sl
index|[
name|indx
index|]
argument_list|,
name|sl
index|[
name|min_child_index
index|]
argument_list|)
operator|>
literal|0
condition|)
block|{
name|sub_list_swap
argument_list|(
name|sl
argument_list|,
name|indx
argument_list|,
name|min_child_index
argument_list|)
expr_stmt|;
name|sub_list_sink
argument_list|(
name|sl
argument_list|,
name|min_child_index
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*<<== heap algorithm */
end_comment

begin_comment
comment|/*  * Adds element to the "right" end  */
end_comment

begin_function
specifier|static
name|void
name|sub_list_push
parameter_list|(
name|struct
name|sort_list
modifier|*
name|s
parameter_list|,
name|struct
name|sort_list
modifier|*
modifier|*
name|sl
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|sl
index|[
name|size
operator|++
index|]
operator|=
name|s
expr_stmt|;
name|sub_list_swim
argument_list|(
name|sl
argument_list|,
name|size
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_struct
struct|struct
name|last_printed_item
block|{
name|struct
name|sort_list_item
modifier|*
name|item
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Prints the current line of the file  */
end_comment

begin_function
specifier|static
name|void
name|sub_list_header_print
parameter_list|(
name|struct
name|sort_list
modifier|*
name|sl
parameter_list|,
name|FILE
modifier|*
name|f_out
parameter_list|,
name|struct
name|last_printed_item
modifier|*
name|lp
parameter_list|)
block|{
if|if
condition|(
name|sl
operator|&&
name|sl
operator|->
name|count
operator|&&
name|f_out
operator|&&
name|sl
operator|->
name|list
index|[
literal|0
index|]
operator|->
name|str
condition|)
block|{
if|if
condition|(
name|sort_opts_vals
operator|.
name|uflag
condition|)
block|{
if|if
condition|(
operator|(
name|lp
operator|->
name|item
operator|==
name|NULL
operator|)
operator|||
operator|(
name|list_coll
argument_list|(
operator|&
operator|(
name|lp
operator|->
name|item
operator|)
argument_list|,
operator|&
operator|(
name|sl
operator|->
name|list
index|[
literal|0
index|]
operator|)
argument_list|)
operator|)
condition|)
block|{
name|bwsfwrite
argument_list|(
name|sl
operator|->
name|list
index|[
literal|0
index|]
operator|->
name|str
argument_list|,
name|f_out
argument_list|,
name|sort_opts_vals
operator|.
name|zflag
argument_list|)
expr_stmt|;
name|lp
operator|->
name|item
operator|=
name|sl
operator|->
name|list
index|[
literal|0
index|]
expr_stmt|;
block|}
block|}
else|else
name|bwsfwrite
argument_list|(
name|sl
operator|->
name|list
index|[
literal|0
index|]
operator|->
name|str
argument_list|,
name|f_out
argument_list|,
name|sort_opts_vals
operator|.
name|zflag
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Read next line  */
end_comment

begin_function
specifier|static
name|void
name|sub_list_next
parameter_list|(
name|struct
name|sort_list
modifier|*
name|sl
parameter_list|)
block|{
if|if
condition|(
name|sl
operator|&&
name|sl
operator|->
name|count
condition|)
block|{
name|sl
operator|->
name|list
operator|+=
literal|1
expr_stmt|;
name|sl
operator|->
name|count
operator|-=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Merge sub-lists to a file  */
end_comment

begin_function
specifier|static
name|void
name|merge_sub_lists
parameter_list|(
name|struct
name|sort_list
modifier|*
modifier|*
name|sl
parameter_list|,
name|size_t
name|n
parameter_list|,
name|FILE
modifier|*
name|f_out
parameter_list|)
block|{
name|struct
name|last_printed_item
name|lp
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|memset
argument_list|(
operator|&
name|lp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|lp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* construct the initial list: */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
name|sub_list_push
argument_list|(
name|sl
index|[
name|i
index|]
argument_list|,
name|sl
argument_list|,
name|i
argument_list|)
expr_stmt|;
while|while
condition|(
name|sl
index|[
literal|0
index|]
operator|->
name|count
condition|)
block|{
comment|/* unfinished lists are always in front */
comment|/* output the smallest line: */
name|sub_list_header_print
argument_list|(
name|sl
index|[
literal|0
index|]
argument_list|,
name|f_out
argument_list|,
operator|&
name|lp
argument_list|)
expr_stmt|;
comment|/* move to a new line, if possible: */
name|sub_list_next
argument_list|(
name|sl
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* re-arrange the list: */
name|sub_list_sink
argument_list|(
name|sl
argument_list|,
literal|0
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Merge sub-lists to a file  */
end_comment

begin_function
specifier|static
name|void
name|merge_list_parts
parameter_list|(
name|struct
name|sort_list
modifier|*
modifier|*
name|parts
parameter_list|,
name|size_t
name|n
parameter_list|,
specifier|const
name|char
modifier|*
name|fn
parameter_list|)
block|{
name|FILE
modifier|*
name|f_out
decl_stmt|;
name|f_out
operator|=
name|openfile
argument_list|(
name|fn
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
name|merge_sub_lists
argument_list|(
name|parts
argument_list|,
name|n
argument_list|,
name|f_out
argument_list|)
expr_stmt|;
name|closefile
argument_list|(
name|f_out
argument_list|,
name|fn
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(SORT_THREADS) */
end_comment

begin_comment
comment|/*  * Multi-threaded sort algorithm "driver"  */
end_comment

begin_function
specifier|static
name|void
name|mt_sort
parameter_list|(
name|struct
name|sort_list
modifier|*
name|list
parameter_list|,
name|int
function_decl|(
modifier|*
name|sort_func
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|size_t
parameter_list|,
name|int
function_decl|(
modifier|*
function_decl|)
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
parameter_list|)
parameter_list|,
specifier|const
name|char
modifier|*
name|fn
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|SORT_THREADS
argument_list|)
if|if
condition|(
name|nthreads
operator|<
literal|2
operator|||
name|list
operator|->
name|count
operator|<
name|MT_SORT_THRESHOLD
condition|)
block|{
name|size_t
name|nthreads_save
init|=
name|nthreads
decl_stmt|;
name|nthreads
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* if single thread or small data, do simple sort */
name|sort_func
argument_list|(
name|list
operator|->
name|list
argument_list|,
name|list
operator|->
name|count
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sort_list_item
operator|*
argument_list|)
argument_list|,
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
specifier|const
name|void
operator|*
argument_list|,
specifier|const
name|void
operator|*
argument_list|)
operator|)
name|list_coll
argument_list|)
expr_stmt|;
name|sort_list_dump
argument_list|(
name|list
argument_list|,
name|fn
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SORT_THREADS
argument_list|)
name|nthreads
operator|=
name|nthreads_save
expr_stmt|;
block|}
else|else
block|{
comment|/* multi-threaded sort */
name|struct
name|sort_list
modifier|*
modifier|*
name|parts
decl_stmt|;
name|size_t
name|avgsize
decl_stmt|,
name|cstart
decl_stmt|,
name|i
decl_stmt|;
comment|/* array of sub-lists */
name|parts
operator|=
name|sort_malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sort_list
operator|*
argument_list|)
operator|*
name|nthreads
argument_list|)
expr_stmt|;
name|cstart
operator|=
literal|0
expr_stmt|;
name|avgsize
operator|=
name|list
operator|->
name|count
operator|/
name|nthreads
expr_stmt|;
comment|/* set global system sort function */
name|g_sort_func
operator|=
name|sort_func
expr_stmt|;
comment|/* set sublists */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nthreads
condition|;
operator|++
name|i
control|)
block|{
name|size_t
name|sz
init|=
literal|0
decl_stmt|;
name|parts
index|[
name|i
index|]
operator|=
name|sort_malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sort_list
argument_list|)
argument_list|)
expr_stmt|;
name|parts
index|[
name|i
index|]
operator|->
name|list
operator|=
name|list
operator|->
name|list
operator|+
name|cstart
expr_stmt|;
name|parts
index|[
name|i
index|]
operator|->
name|memsize
operator|=
literal|0
expr_stmt|;
name|parts
index|[
name|i
index|]
operator|->
name|sub_list_pos
operator|=
name|i
expr_stmt|;
name|sz
operator|=
operator|(
name|i
operator|==
name|nthreads
operator|-
literal|1
operator|)
condition|?
name|list
operator|->
name|count
operator|-
name|cstart
else|:
name|avgsize
expr_stmt|;
name|parts
index|[
name|i
index|]
operator|->
name|count
operator|=
name|sz
expr_stmt|;
name|parts
index|[
name|i
index|]
operator|->
name|size
operator|=
name|parts
index|[
name|i
index|]
operator|->
name|count
expr_stmt|;
name|cstart
operator|+=
name|sz
expr_stmt|;
block|}
comment|/* init threads counting semaphore */
name|sem_init
argument_list|(
operator|&
name|mtsem
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* start threads */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nthreads
condition|;
operator|++
name|i
control|)
block|{
name|pthread_t
name|pth
decl_stmt|;
name|pthread_attr_t
name|attr
decl_stmt|;
name|pthread_attr_init
argument_list|(
operator|&
name|attr
argument_list|)
expr_stmt|;
name|pthread_attr_setdetachstate
argument_list|(
operator|&
name|attr
argument_list|,
name|PTHREAD_DETACHED
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|res
init|=
name|pthread_create
argument_list|(
operator|&
name|pth
argument_list|,
operator|&
name|attr
argument_list|,
name|mt_sort_thread
argument_list|,
name|parts
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|res
operator|>=
literal|0
condition|)
break|break;
if|if
condition|(
name|errno
operator|==
name|EAGAIN
condition|)
block|{
name|pthread_yield
argument_list|()
expr_stmt|;
continue|continue;
block|}
name|err
argument_list|(
literal|2
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|pthread_attr_destroy
argument_list|(
operator|&
name|attr
argument_list|)
expr_stmt|;
block|}
comment|/* wait for threads completion */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nthreads
condition|;
operator|++
name|i
control|)
block|{
name|sem_wait
argument_list|(
operator|&
name|mtsem
argument_list|)
expr_stmt|;
block|}
comment|/* destroy the semaphore - we do not need it anymore */
name|sem_destroy
argument_list|(
operator|&
name|mtsem
argument_list|)
expr_stmt|;
comment|/* merge sorted sub-lists to the file */
name|merge_list_parts
argument_list|(
name|parts
argument_list|,
name|nthreads
argument_list|,
name|fn
argument_list|)
expr_stmt|;
comment|/* free sub-lists data */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nthreads
condition|;
operator|++
name|i
control|)
block|{
name|sort_free
argument_list|(
name|parts
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|sort_free
argument_list|(
name|parts
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* defined(SORT_THREADS) */
block|}
end_function

end_unit

