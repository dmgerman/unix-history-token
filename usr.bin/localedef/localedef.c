begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright 2010 Nexenta Systems, Inc.  All rights reserved.  * Copyright 2015 John Marino<draco@marino.st>  *  * This source code is derived from the illumos localedef command, and  * provided under BSD-style license terms by Nexenta Systems, Inc.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE  * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * POSIX localedef.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<libgen.h>
end_include

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<locale.h>
end_include

begin_include
include|#
directive|include
file|<dirent.h>
end_include

begin_include
include|#
directive|include
file|"localedef.h"
end_include

begin_include
include|#
directive|include
file|"parser.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|TEXT_DOMAIN
end_ifndef

begin_define
define|#
directive|define
name|TEXT_DOMAIN
value|"SYS_TEST"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|bsd
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|verbose
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|undefok
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|warnok
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|locname
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|locpath
index|[
name|PATH_MAX
index|]
decl_stmt|;
end_decl_stmt

begin_function
specifier|const
name|char
modifier|*
name|category_name
parameter_list|(
name|void
parameter_list|)
block|{
switch|switch
condition|(
name|get_category
argument_list|()
condition|)
block|{
case|case
name|T_CHARMAP
case|:
return|return
operator|(
literal|"CHARMAP"
operator|)
return|;
case|case
name|T_WIDTH
case|:
return|return
operator|(
literal|"WIDTH"
operator|)
return|;
case|case
name|T_COLLATE
case|:
return|return
operator|(
literal|"LC_COLLATE"
operator|)
return|;
case|case
name|T_CTYPE
case|:
return|return
operator|(
literal|"LC_CTYPE"
operator|)
return|;
case|case
name|T_MESSAGES
case|:
return|return
operator|(
literal|"LC_MESSAGES"
operator|)
return|;
case|case
name|T_MONETARY
case|:
return|return
operator|(
literal|"LC_MONETARY"
operator|)
return|;
case|case
name|T_NUMERIC
case|:
return|return
operator|(
literal|"LC_NUMERIC"
operator|)
return|;
case|case
name|T_TIME
case|:
return|return
operator|(
literal|"LC_TIME"
operator|)
return|;
default|default:
name|INTERR
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|category_file
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|bsd
condition|)
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|locpath
argument_list|,
sizeof|sizeof
argument_list|(
name|locpath
argument_list|)
argument_list|,
literal|"%s.%s"
argument_list|,
name|locname
argument_list|,
name|category_name
argument_list|()
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|locpath
argument_list|,
sizeof|sizeof
argument_list|(
name|locpath
argument_list|)
argument_list|,
literal|"%s/%s"
argument_list|,
name|locname
argument_list|,
name|category_name
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|(
name|locpath
operator|)
return|;
block|}
end_function

begin_function
name|FILE
modifier|*
name|open_category
parameter_list|(
name|void
parameter_list|)
block|{
name|FILE
modifier|*
name|file
decl_stmt|;
if|if
condition|(
name|verbose
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"Writing category %s: "
argument_list|,
name|category_name
argument_list|()
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
comment|/* make the parent directory */
if|if
condition|(
operator|!
name|bsd
condition|)
operator|(
name|void
operator|)
name|mkdir
argument_list|(
name|dirname
argument_list|(
name|category_file
argument_list|()
argument_list|)
argument_list|,
literal|0755
argument_list|)
expr_stmt|;
comment|/* 	 * note that we have to regenerate the file name, as dirname 	 * clobbered it. 	 */
name|file
operator|=
name|fopen
argument_list|(
name|category_file
argument_list|()
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|==
name|NULL
condition|)
block|{
name|errf
argument_list|(
literal|"%s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|file
operator|)
return|;
block|}
end_function

begin_function
name|void
name|close_category
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|)
block|{
if|if
condition|(
name|fchmod
argument_list|(
name|fileno
argument_list|(
name|f
argument_list|)
argument_list|,
literal|0644
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|category_file
argument_list|()
argument_list|)
expr_stmt|;
name|errf
argument_list|(
literal|"%s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fclose
argument_list|(
name|f
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|category_file
argument_list|()
argument_list|)
expr_stmt|;
name|errf
argument_list|(
literal|"%s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|verbose
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"done.\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * This function is used when copying the category from another  * locale.  Note that the copy is actually performed using a hard  * link for efficiency.  */
end_comment

begin_function
name|void
name|copy_category
parameter_list|(
name|char
modifier|*
name|src
parameter_list|)
block|{
name|char
name|srcpath
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|int
name|rv
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|srcpath
argument_list|,
sizeof|sizeof
argument_list|(
name|srcpath
argument_list|)
argument_list|,
literal|"%s/%s"
argument_list|,
name|src
argument_list|,
name|category_name
argument_list|()
argument_list|)
expr_stmt|;
name|rv
operator|=
name|access
argument_list|(
name|srcpath
argument_list|,
name|R_OK
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rv
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|strchr
argument_list|(
name|srcpath
argument_list|,
literal|'/'
argument_list|)
operator|==
name|NULL
operator|)
condition|)
block|{
comment|/* Maybe we should try the system locale */
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|srcpath
argument_list|,
sizeof|sizeof
argument_list|(
name|srcpath
argument_list|)
argument_list|,
literal|"/usr/lib/locale/%s/%s"
argument_list|,
name|src
argument_list|,
name|category_name
argument_list|()
argument_list|)
expr_stmt|;
name|rv
operator|=
name|access
argument_list|(
name|srcpath
argument_list|,
name|R_OK
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"source locale data unavailable: %s"
argument_list|,
name|src
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|verbose
operator|>
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"Copying category %s from %s: "
argument_list|,
name|category_name
argument_list|()
argument_list|,
name|src
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
comment|/* make the parent directory */
if|if
condition|(
operator|!
name|bsd
condition|)
operator|(
name|void
operator|)
name|mkdir
argument_list|(
name|dirname
argument_list|(
name|category_file
argument_list|()
argument_list|)
argument_list|,
literal|0755
argument_list|)
expr_stmt|;
if|if
condition|(
name|link
argument_list|(
name|srcpath
argument_list|,
name|category_file
argument_list|()
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"unable to copy locale data: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|verbose
operator|>
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"done.\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|putl_category
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|FILE
modifier|*
name|f
parameter_list|)
block|{
if|if
condition|(
name|s
operator|&&
name|fputs
argument_list|(
name|s
argument_list|,
name|f
argument_list|)
operator|==
name|EOF
condition|)
block|{
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|category_file
argument_list|()
argument_list|)
expr_stmt|;
name|errf
argument_list|(
literal|"%s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EOF
operator|)
return|;
block|}
if|if
condition|(
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|f
argument_list|)
operator|==
name|EOF
condition|)
block|{
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|category_file
argument_list|()
argument_list|)
expr_stmt|;
name|errf
argument_list|(
literal|"%s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EOF
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|wr_category
parameter_list|(
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|sz
parameter_list|,
name|FILE
modifier|*
name|f
parameter_list|)
block|{
if|if
condition|(
operator|!
name|sz
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|fwrite
argument_list|(
name|buf
argument_list|,
name|sz
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|<
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|category_file
argument_list|()
argument_list|)
expr_stmt|;
name|errf
argument_list|(
literal|"%s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EOF
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function_decl
name|int
name|yyparse
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: localedef [options] localename\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"[options] are:\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  -D          : BSD-style output\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  -c          : ignore warnings\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  -v          : verbose output\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  -U          : ignore undefined symbols\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  -f charmap  : use given charmap file\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  -u encoding : assume encoding\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  -w widths   : use screen widths file\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  -i locsrc   : source file for locale\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|4
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|lfname
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|cfname
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|wfname
init|=
name|NULL
decl_stmt|;
name|DIR
modifier|*
name|dir
decl_stmt|;
name|init_charmap
argument_list|()
expr_stmt|;
name|init_collate
argument_list|()
expr_stmt|;
name|init_ctype
argument_list|()
expr_stmt|;
name|init_messages
argument_list|()
expr_stmt|;
name|init_monetary
argument_list|()
expr_stmt|;
name|init_numeric
argument_list|()
expr_stmt|;
name|init_time
argument_list|()
expr_stmt|;
name|yydebug
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|setlocale
argument_list|(
name|LC_ALL
argument_list|,
literal|""
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"w:i:cf:u:vUD"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'D'
case|:
name|bsd
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|verbose
operator|++
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|lfname
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|set_wide_encoding
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|cfname
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'U'
case|:
name|undefok
operator|++
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|warnok
operator|++
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|wfname
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
name|usage
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|(
name|argc
operator|-
literal|1
operator|)
operator|!=
operator|(
name|optind
operator|)
condition|)
block|{
name|usage
argument_list|()
expr_stmt|;
block|}
name|locname
operator|=
name|argv
index|[
name|argc
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"Processing locale %s.\n"
argument_list|,
name|locname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cfname
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"Loading charmap %s.\n"
argument_list|,
name|cfname
argument_list|)
expr_stmt|;
name|reset_scanner
argument_list|(
name|cfname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|yyparse
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|wfname
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"Loading widths %s.\n"
argument_list|,
name|wfname
argument_list|)
expr_stmt|;
name|reset_scanner
argument_list|(
name|wfname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|yyparse
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|verbose
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"Loading POSIX portable characters.\n"
argument_list|)
expr_stmt|;
block|}
name|add_charmap_posix
argument_list|()
expr_stmt|;
if|if
condition|(
name|lfname
condition|)
block|{
name|reset_scanner
argument_list|(
name|lfname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|reset_scanner
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* make the directory for the locale if not already present */
if|if
condition|(
operator|!
name|bsd
condition|)
block|{
while|while
condition|(
operator|(
name|dir
operator|=
name|opendir
argument_list|(
name|locname
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|errno
operator|!=
name|ENOENT
operator|)
operator|||
operator|(
name|mkdir
argument_list|(
name|locname
argument_list|,
literal|0755
argument_list|)
operator|<
literal|0
operator|)
condition|)
block|{
name|errf
argument_list|(
literal|"%s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|closedir
argument_list|(
name|dir
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|mkdir
argument_list|(
name|dirname
argument_list|(
name|category_file
argument_list|()
argument_list|)
argument_list|,
literal|0755
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|yyparse
argument_list|()
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"All done.\n"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|warnings
condition|?
literal|1
else|:
literal|0
operator|)
return|;
block|}
end_function

end_unit

