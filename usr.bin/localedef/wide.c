begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright 2011 Nexenta Systems, Inc.  All rights reserved.  * Copyright 2012 Garrett D'Amore<garrett@damore.org>  All rights reserved.  * Copyright 2015 John Marino<draco@marino.st>  *  * This source code is derived from the illumos localedef command, and  * provided under BSD-style license terms by Nexenta Systems, Inc.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE  * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * The functions in this file convert from the standard multibyte forms  * to the wide character forms used internally by libc.  Unfortunately,  * this approach means that we need a method for each and every encoding.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<wchar.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|"localedef.h"
end_include

begin_function_decl
specifier|static
name|int
name|towide_none
parameter_list|(
name|wchar_t
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|unsigned
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|towide_utf8
parameter_list|(
name|wchar_t
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|unsigned
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|towide_big5
parameter_list|(
name|wchar_t
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|unsigned
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|towide_gbk
parameter_list|(
name|wchar_t
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|unsigned
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|towide_gb2312
parameter_list|(
name|wchar_t
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|unsigned
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|towide_gb18030
parameter_list|(
name|wchar_t
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|unsigned
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|towide_mskanji
parameter_list|(
name|wchar_t
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|unsigned
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|towide_euccn
parameter_list|(
name|wchar_t
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|unsigned
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|towide_eucjp
parameter_list|(
name|wchar_t
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|unsigned
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|towide_euckr
parameter_list|(
name|wchar_t
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|unsigned
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|towide_euctw
parameter_list|(
name|wchar_t
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|unsigned
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|tomb_none
parameter_list|(
name|char
modifier|*
parameter_list|,
name|wchar_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|tomb_utf8
parameter_list|(
name|char
modifier|*
parameter_list|,
name|wchar_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|tomb_mbs
parameter_list|(
name|char
modifier|*
parameter_list|,
name|wchar_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
function_decl|(
modifier|*
name|_towide
function_decl|)
parameter_list|(
name|wchar_t
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|unsigned
parameter_list|)
init|=
name|towide_none
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
function_decl|(
modifier|*
name|_tomb
function_decl|)
parameter_list|(
name|char
modifier|*
parameter_list|,
name|wchar_t
parameter_list|)
init|=
name|tomb_none
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|char
name|_encoding_buffer
index|[
literal|20
index|]
init|=
block|{
literal|'N'
block|,
literal|'O'
block|,
literal|'N'
block|,
literal|'E'
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|_encoding
init|=
name|_encoding_buffer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|_nbits
init|=
literal|7
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Table of supported encodings.  We only bother to list the multibyte  * encodings here, because single byte locales are handed by "NONE".  */
end_comment

begin_struct
specifier|static
struct|struct
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* the name that the underlying libc implemenation uses */
specifier|const
name|char
modifier|*
name|cname
decl_stmt|;
comment|/* the maximum number of bits required for priorities */
name|int
name|nbits
decl_stmt|;
name|int
function_decl|(
modifier|*
name|towide
function_decl|)
parameter_list|(
name|wchar_t
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|unsigned
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|tomb
function_decl|)
parameter_list|(
name|char
modifier|*
parameter_list|,
name|wchar_t
parameter_list|)
function_decl|;
block|}
name|mb_encodings
index|[]
init|=
block|{
comment|/* 	 * UTF8 values max out at 0x1fffff (although in theory there could 	 * be later extensions, but it won't happen.)  This means we only need 	 * 21 bits to be able to encode the entire range of priorities. 	 */
block|{
literal|"UTF-8"
block|,
literal|"UTF-8"
block|,
literal|21
block|,
name|towide_utf8
block|,
name|tomb_utf8
block|}
block|,
block|{
literal|"UTF8"
block|,
literal|"UTF-8"
block|,
literal|21
block|,
name|towide_utf8
block|,
name|tomb_utf8
block|}
block|,
block|{
literal|"utf8"
block|,
literal|"UTF-8"
block|,
literal|21
block|,
name|towide_utf8
block|,
name|tomb_utf8
block|}
block|,
block|{
literal|"utf-8"
block|,
literal|"UTF-8"
block|,
literal|21
block|,
name|towide_utf8
block|,
name|tomb_utf8
block|}
block|,
block|{
literal|"EUC-CN"
block|,
literal|"EUC-CN"
block|,
literal|16
block|,
name|towide_euccn
block|,
name|tomb_mbs
block|}
block|,
block|{
literal|"eucCN"
block|,
literal|"EUC-CN"
block|,
literal|16
block|,
name|towide_euccn
block|,
name|tomb_mbs
block|}
block|,
comment|/* 	 * Becuase the 3-byte form of EUC-JP use the same leading byte, 	 * only 17 bits required to provide unique priorities.  (The low 	 * bit of that first byte is set.)  By setting this value low, 	 * we can get by with only 3 bytes in the strxfrm expansion. 	 */
block|{
literal|"EUC-JP"
block|,
literal|"EUC-JP"
block|,
literal|17
block|,
name|towide_eucjp
block|,
name|tomb_mbs
block|}
block|,
block|{
literal|"eucJP"
block|,
literal|"EUC-JP"
block|,
literal|17
block|,
name|towide_eucjp
block|,
name|tomb_mbs
block|}
block|,
block|{
literal|"EUC-KR"
block|,
literal|"EUC-KR"
block|,
literal|16
block|,
name|towide_euckr
block|,
name|tomb_mbs
block|}
block|,
block|{
literal|"eucKR"
block|,
literal|"EUC-KR"
block|,
literal|16
block|,
name|towide_euckr
block|,
name|tomb_mbs
block|}
block|,
comment|/* 	 * EUC-TW uses 2 bytes most of the time, but 4 bytes if the 	 * high order byte is 0x8E.  However, with 4 byte encodings, 	 * the third byte will be A0-B0.  So we only need to consider 	 * the lower order 24 bits for collation. 	 */
block|{
literal|"EUC-TW"
block|,
literal|"EUC-TW"
block|,
literal|24
block|,
name|towide_euctw
block|,
name|tomb_mbs
block|}
block|,
block|{
literal|"eucTW"
block|,
literal|"EUC-TW"
block|,
literal|24
block|,
name|towide_euctw
block|,
name|tomb_mbs
block|}
block|,
block|{
literal|"MS_Kanji"
block|,
literal|"MSKanji"
block|,
literal|16
block|,
name|towide_mskanji
block|,
name|tomb_mbs
block|}
block|,
block|{
literal|"MSKanji"
block|,
literal|"MSKanji"
block|,
literal|16
block|,
name|towide_mskanji
block|,
name|tomb_mbs
block|}
block|,
block|{
literal|"PCK"
block|,
literal|"MSKanji"
block|,
literal|16
block|,
name|towide_mskanji
block|,
name|tomb_mbs
block|}
block|,
block|{
literal|"SJIS"
block|,
literal|"MSKanji"
block|,
literal|16
block|,
name|towide_mskanji
block|,
name|tomb_mbs
block|}
block|,
block|{
literal|"Shift_JIS"
block|,
literal|"MSKanji"
block|,
literal|16
block|,
name|towide_mskanji
block|,
name|tomb_mbs
block|}
block|,
block|{
literal|"BIG5"
block|,
literal|"BIG5"
block|,
literal|16
block|,
name|towide_big5
block|,
name|tomb_mbs
block|}
block|,
block|{
literal|"big5"
block|,
literal|"BIG5"
block|,
literal|16
block|,
name|towide_big5
block|,
name|tomb_mbs
block|}
block|,
block|{
literal|"Big5"
block|,
literal|"BIG5"
block|,
literal|16
block|,
name|towide_big5
block|,
name|tomb_mbs
block|}
block|,
block|{
literal|"GBK"
block|,
literal|"GBK"
block|,
literal|16
block|,
name|towide_gbk
block|,
name|tomb_mbs
block|}
block|,
comment|/* 	 * GB18030 can get away with just 31 bits.  This is because the 	 * high order bit is always set for 4 byte values, and the 	 * at least one of the other bits in that 4 byte value will 	 * be non-zero. 	 */
block|{
literal|"GB18030"
block|,
literal|"GB18030"
block|,
literal|31
block|,
name|towide_gb18030
block|,
name|tomb_mbs
block|}
block|,
comment|/* 	 * This should probably be an aliase for euc-cn, or vice versa. 	 */
block|{
literal|"GB2312"
block|,
literal|"GB2312"
block|,
literal|16
block|,
name|towide_gb2312
block|,
name|tomb_mbs
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|, }
struct|;
end_struct

begin_function
specifier|static
name|char
modifier|*
name|show_mb
parameter_list|(
specifier|const
name|char
modifier|*
name|mb
parameter_list|)
block|{
specifier|static
name|char
name|buf
index|[
literal|64
index|]
decl_stmt|;
comment|/* ASCII stuff we just print */
if|if
condition|(
name|isascii
argument_list|(
operator|*
name|mb
argument_list|)
operator|&&
name|isgraph
argument_list|(
operator|*
name|mb
argument_list|)
condition|)
block|{
name|buf
index|[
literal|0
index|]
operator|=
operator|*
name|mb
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
name|buf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|mb
operator|!=
literal|0
condition|)
block|{
name|char
name|scr
index|[
literal|8
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|scr
argument_list|,
sizeof|sizeof
argument_list|(
name|scr
argument_list|)
argument_list|,
literal|"\\x%02x"
argument_list|,
operator|*
name|mb
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcat
argument_list|(
name|buf
argument_list|,
name|scr
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|mb
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
modifier|*
name|widemsg
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|werr
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|char
modifier|*
name|msg
decl_stmt|;
name|va_list
name|va
decl_stmt|;
name|va_start
argument_list|(
name|va
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|vasprintf
argument_list|(
operator|&
name|msg
argument_list|,
name|fmt
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|widemsg
argument_list|)
expr_stmt|;
name|widemsg
operator|=
name|msg
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This is used for 8-bit encodings.  */
end_comment

begin_function
name|int
name|towide_none
parameter_list|(
name|wchar_t
modifier|*
name|c
parameter_list|,
specifier|const
name|char
modifier|*
name|mb
parameter_list|,
name|unsigned
name|n
name|__unused
parameter_list|)
block|{
if|if
condition|(
name|mb_cur_max
operator|!=
literal|1
condition|)
block|{
name|werr
argument_list|(
literal|"invalid or unsupported multibyte locale"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
operator|*
name|c
operator|=
operator|(
name|uint8_t
operator|)
operator|*
name|mb
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|tomb_none
parameter_list|(
name|char
modifier|*
name|mb
parameter_list|,
name|wchar_t
name|wc
parameter_list|)
block|{
if|if
condition|(
name|mb_cur_max
operator|!=
literal|1
condition|)
block|{
name|werr
argument_list|(
literal|"invalid or unsupported multibyte locale"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
operator|*
operator|(
name|uint8_t
operator|*
operator|)
name|mb
operator|=
operator|(
name|wc
operator|&
literal|0xff
operator|)
expr_stmt|;
name|mb
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * UTF-8 stores wide characters in UTF-32 form.  */
end_comment

begin_function
name|int
name|towide_utf8
parameter_list|(
name|wchar_t
modifier|*
name|wc
parameter_list|,
specifier|const
name|char
modifier|*
name|mb
parameter_list|,
name|unsigned
name|n
parameter_list|)
block|{
name|wchar_t
name|c
decl_stmt|;
name|int
name|nb
decl_stmt|;
name|int
name|lv
decl_stmt|;
comment|/* lowest legal value */
name|int
name|i
decl_stmt|;
specifier|const
name|uint8_t
modifier|*
name|s
init|=
operator|(
specifier|const
name|uint8_t
operator|*
operator|)
name|mb
decl_stmt|;
name|c
operator|=
operator|*
name|s
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|&
literal|0x80
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 7-bit ASCII */
operator|*
name|wc
operator|=
name|c
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|&
literal|0xe0
operator|)
operator|==
literal|0xc0
condition|)
block|{
comment|/* u80-u7ff - two bytes encoded */
name|nb
operator|=
literal|2
expr_stmt|;
name|lv
operator|=
literal|0x80
expr_stmt|;
name|c
operator|&=
operator|~
literal|0xe0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|&
literal|0xf0
operator|)
operator|==
literal|0xe0
condition|)
block|{
comment|/* u800-uffff - three bytes encoded */
name|nb
operator|=
literal|3
expr_stmt|;
name|lv
operator|=
literal|0x800
expr_stmt|;
name|c
operator|&=
operator|~
literal|0xf0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|&
literal|0xf8
operator|)
operator|==
literal|0xf0
condition|)
block|{
comment|/* u1000-u1fffff - four bytes encoded */
name|nb
operator|=
literal|4
expr_stmt|;
name|lv
operator|=
literal|0x1000
expr_stmt|;
name|c
operator|&=
operator|~
literal|0xf8
expr_stmt|;
block|}
else|else
block|{
comment|/* 5 and 6 byte encodings are not legal unicode */
name|werr
argument_list|(
literal|"utf8 encoding too large (%s)"
argument_list|,
name|show_mb
argument_list|(
name|mb
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|nb
operator|>
operator|(
name|int
operator|)
name|n
condition|)
block|{
name|werr
argument_list|(
literal|"incomplete utf8 sequence (%s)"
argument_list|,
name|show_mb
argument_list|(
name|mb
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nb
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|s
index|[
name|i
index|]
operator|)
operator|&
literal|0xc0
operator|)
operator|!=
literal|0x80
condition|)
block|{
name|werr
argument_list|(
literal|"illegal utf8 byte (%x)"
argument_list|,
name|s
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|c
operator|<<=
literal|6
expr_stmt|;
name|c
operator||=
operator|(
name|s
index|[
name|i
index|]
operator|&
literal|0x3f
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|<
name|lv
condition|)
block|{
name|werr
argument_list|(
literal|"illegal redundant utf8 encoding (%s)"
argument_list|,
name|show_mb
argument_list|(
name|mb
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
operator|*
name|wc
operator|=
name|c
expr_stmt|;
return|return
operator|(
name|nb
operator|)
return|;
block|}
end_function

begin_function
name|int
name|tomb_utf8
parameter_list|(
name|char
modifier|*
name|mb
parameter_list|,
name|wchar_t
name|wc
parameter_list|)
block|{
name|uint8_t
modifier|*
name|s
init|=
operator|(
name|uint8_t
operator|*
operator|)
name|mb
decl_stmt|;
name|uint8_t
name|msk
decl_stmt|;
name|int
name|cnt
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|wc
operator|<=
literal|0x7f
condition|)
block|{
name|s
index|[
literal|0
index|]
operator|=
name|wc
operator|&
literal|0x7f
expr_stmt|;
name|s
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|wc
operator|<=
literal|0x7ff
condition|)
block|{
name|cnt
operator|=
literal|2
expr_stmt|;
name|msk
operator|=
literal|0xc0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|wc
operator|<=
literal|0xffff
condition|)
block|{
name|cnt
operator|=
literal|3
expr_stmt|;
name|msk
operator|=
literal|0xe0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|wc
operator|<=
literal|0x1fffff
condition|)
block|{
name|cnt
operator|=
literal|4
expr_stmt|;
name|msk
operator|=
literal|0xf0
expr_stmt|;
block|}
else|else
block|{
name|werr
argument_list|(
literal|"illegal uf8 char (%x)"
argument_list|,
name|wc
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
name|cnt
operator|-
literal|1
init|;
name|i
condition|;
name|i
operator|--
control|)
block|{
name|s
index|[
name|i
index|]
operator|=
operator|(
name|wc
operator|&
literal|0x3f
operator|)
operator||
literal|0x80
expr_stmt|;
name|wc
operator|>>=
literal|6
expr_stmt|;
block|}
name|s
index|[
literal|0
index|]
operator|=
operator|(
name|msk
operator|)
operator||
name|wc
expr_stmt|;
name|s
index|[
name|cnt
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|cnt
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Several encodings share a simplistic dual byte encoding.  In these  * forms, they all indicate that a two byte sequence is to be used if  * the first byte has its high bit set.  They all store this simple  * encoding as a 16-bit value, although a great many of the possible  * code points are not used in most character sets.  This gives a possible  * set of just over 32,000 valid code points.  *  * 0x00 - 0x7f		- 1 byte encoding  * 0x80 - 0x7fff	- illegal  * 0x8000 - 0xffff	- 2 byte encoding  */
end_comment

begin_pragma
pragma|#
directive|pragma
name|GCC
name|diagnostic
name|push
end_pragma

begin_pragma
pragma|#
directive|pragma
name|GCC
name|diagnostic
name|ignored
literal|"-Wcast-qual"
end_pragma

begin_function
specifier|static
name|int
name|towide_dbcs
parameter_list|(
name|wchar_t
modifier|*
name|wc
parameter_list|,
specifier|const
name|char
modifier|*
name|mb
parameter_list|,
name|unsigned
name|n
parameter_list|)
block|{
name|wchar_t
name|c
decl_stmt|;
name|c
operator|=
operator|*
operator|(
name|uint8_t
operator|*
operator|)
name|mb
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|&
literal|0x80
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 7-bit */
operator|*
name|wc
operator|=
name|c
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|n
operator|<
literal|2
condition|)
block|{
name|werr
argument_list|(
literal|"incomplete character sequence (%s)"
argument_list|,
name|show_mb
argument_list|(
name|mb
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* Store both bytes as a single 16-bit wide. */
name|c
operator|<<=
literal|8
expr_stmt|;
name|c
operator||=
call|(
name|uint8_t
call|)
argument_list|(
name|mb
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
operator|*
name|wc
operator|=
name|c
expr_stmt|;
return|return
operator|(
literal|2
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Most multibyte locales just convert the wide character to the multibyte  * form by stripping leading null bytes, and writing the 32-bit quantity  * in big-endian order.  */
end_comment

begin_function
name|int
name|tomb_mbs
parameter_list|(
name|char
modifier|*
name|mb
parameter_list|,
name|wchar_t
name|wc
parameter_list|)
block|{
name|uint8_t
modifier|*
name|s
init|=
operator|(
name|uint8_t
operator|*
operator|)
name|mb
decl_stmt|;
name|int
name|n
init|=
literal|0
decl_stmt|,
name|c
decl_stmt|;
if|if
condition|(
operator|(
name|wc
operator|&
literal|0xff000000U
operator|)
operator|!=
literal|0
condition|)
block|{
name|n
operator|=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|wc
operator|&
literal|0x00ff0000U
operator|)
operator|!=
literal|0
condition|)
block|{
name|n
operator|=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|wc
operator|&
literal|0x0000ff00U
operator|)
operator|!=
literal|0
condition|)
block|{
name|n
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|n
operator|=
literal|1
expr_stmt|;
block|}
name|c
operator|=
name|n
expr_stmt|;
while|while
condition|(
name|n
condition|)
block|{
name|n
operator|--
expr_stmt|;
name|s
index|[
name|n
index|]
operator|=
name|wc
operator|&
literal|0xff
expr_stmt|;
name|wc
operator|>>=
literal|8
expr_stmt|;
block|}
comment|/* ensure null termination */
name|s
index|[
name|c
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * big5 is a simple dual byte character set.  */
end_comment

begin_function
name|int
name|towide_big5
parameter_list|(
name|wchar_t
modifier|*
name|wc
parameter_list|,
specifier|const
name|char
modifier|*
name|mb
parameter_list|,
name|unsigned
name|n
parameter_list|)
block|{
return|return
operator|(
name|towide_dbcs
argument_list|(
name|wc
argument_list|,
name|mb
argument_list|,
name|n
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * GBK encodes wides in the same way that big5 does, the high order  * bit of the first byte indicates a double byte character.  */
end_comment

begin_function
name|int
name|towide_gbk
parameter_list|(
name|wchar_t
modifier|*
name|wc
parameter_list|,
specifier|const
name|char
modifier|*
name|mb
parameter_list|,
name|unsigned
name|n
parameter_list|)
block|{
return|return
operator|(
name|towide_dbcs
argument_list|(
name|wc
argument_list|,
name|mb
argument_list|,
name|n
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * GB2312 is another DBCS.  Its cleaner than others in that the second  * byte does not encode ASCII, but it supports characters.  */
end_comment

begin_function
name|int
name|towide_gb2312
parameter_list|(
name|wchar_t
modifier|*
name|wc
parameter_list|,
specifier|const
name|char
modifier|*
name|mb
parameter_list|,
name|unsigned
name|n
parameter_list|)
block|{
return|return
operator|(
name|towide_dbcs
argument_list|(
name|wc
argument_list|,
name|mb
argument_list|,
name|n
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * GB18030.  This encodes as 8, 16, or 32-bits.  * 7-bit values are in 1 byte,  4 byte sequences are used when  * the second byte encodes 0x30-39 and all other sequences are 2 bytes.  */
end_comment

begin_function
name|int
name|towide_gb18030
parameter_list|(
name|wchar_t
modifier|*
name|wc
parameter_list|,
specifier|const
name|char
modifier|*
name|mb
parameter_list|,
name|unsigned
name|n
parameter_list|)
block|{
name|wchar_t
name|c
decl_stmt|;
name|c
operator|=
operator|*
operator|(
name|uint8_t
operator|*
operator|)
name|mb
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|&
literal|0x80
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 7-bit */
operator|*
name|wc
operator|=
name|c
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|n
operator|<
literal|2
condition|)
block|{
name|werr
argument_list|(
literal|"incomplete character sequence (%s)"
argument_list|,
name|show_mb
argument_list|(
name|mb
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* pull in the second byte */
name|c
operator|<<=
literal|8
expr_stmt|;
name|c
operator||=
call|(
name|uint8_t
call|)
argument_list|(
name|mb
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|c
operator|&
literal|0xff
operator|)
operator|>=
literal|0x30
operator|)
operator|&&
operator|(
operator|(
name|c
operator|&
literal|0xff
operator|)
operator|<=
literal|0x39
operator|)
condition|)
block|{
if|if
condition|(
name|n
operator|<
literal|4
condition|)
block|{
name|werr
argument_list|(
literal|"incomplete 4-byte character sequence (%s)"
argument_list|,
name|show_mb
argument_list|(
name|mb
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|c
operator|<<=
literal|8
expr_stmt|;
name|c
operator||=
call|(
name|uint8_t
call|)
argument_list|(
name|mb
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|c
operator|<<=
literal|8
expr_stmt|;
name|c
operator||=
call|(
name|uint8_t
call|)
argument_list|(
name|mb
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
operator|*
name|wc
operator|=
name|c
expr_stmt|;
return|return
operator|(
literal|4
operator|)
return|;
block|}
operator|*
name|wc
operator|=
name|c
expr_stmt|;
return|return
operator|(
literal|2
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * MS-Kanji (aka SJIS) is almost a clean DBCS like the others, but it  * also has a range of single byte characters above 0x80.  (0xa1-0xdf).  */
end_comment

begin_function
name|int
name|towide_mskanji
parameter_list|(
name|wchar_t
modifier|*
name|wc
parameter_list|,
specifier|const
name|char
modifier|*
name|mb
parameter_list|,
name|unsigned
name|n
parameter_list|)
block|{
name|wchar_t
name|c
decl_stmt|;
name|c
operator|=
operator|*
operator|(
name|uint8_t
operator|*
operator|)
name|mb
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|<
literal|0x80
operator|)
operator|||
operator|(
operator|(
name|c
operator|>
literal|0xa0
operator|)
operator|&&
operator|(
name|c
operator|<
literal|0xe0
operator|)
operator|)
condition|)
block|{
comment|/* 7-bit */
operator|*
name|wc
operator|=
name|c
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|n
operator|<
literal|2
condition|)
block|{
name|werr
argument_list|(
literal|"incomplete character sequence (%s)"
argument_list|,
name|show_mb
argument_list|(
name|mb
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* Store both bytes as a single 16-bit wide. */
name|c
operator|<<=
literal|8
expr_stmt|;
name|c
operator||=
call|(
name|uint8_t
call|)
argument_list|(
name|mb
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
operator|*
name|wc
operator|=
name|c
expr_stmt|;
return|return
operator|(
literal|2
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * EUC forms.  EUC encodings are "variable".  FreeBSD carries some additional  * variable data to encode these, but we're going to treat each as independent  * instead.  Its the only way we can sensibly move forward.  *  * Note that the way in which the different EUC forms vary is how wide  * CS2 and CS3 are and what the first byte of them is.  */
end_comment

begin_function
specifier|static
name|int
name|towide_euc_impl
parameter_list|(
name|wchar_t
modifier|*
name|wc
parameter_list|,
specifier|const
name|char
modifier|*
name|mb
parameter_list|,
name|unsigned
name|n
parameter_list|,
name|uint8_t
name|cs2
parameter_list|,
name|uint8_t
name|cs2width
parameter_list|,
name|uint8_t
name|cs3
parameter_list|,
name|uint8_t
name|cs3width
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|width
init|=
literal|2
decl_stmt|;
name|wchar_t
name|c
decl_stmt|;
name|c
operator|=
operator|*
operator|(
name|uint8_t
operator|*
operator|)
name|mb
expr_stmt|;
comment|/* 	 * All variations of EUC encode 7-bit ASCII as one byte, and use 	 * additional bytes for more than that. 	 */
if|if
condition|(
operator|(
name|c
operator|&
literal|0x80
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 7-bit */
operator|*
name|wc
operator|=
name|c
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * All EUC variants reserve 0xa1-0xff to identify CS1, which 	 * is always two bytes wide.  Note that unused CS will be zero, 	 * and that cannot be true because we know that the high order 	 * bit must be set. 	 */
if|if
condition|(
name|c
operator|>=
literal|0xa1
condition|)
block|{
name|width
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|cs2
condition|)
block|{
name|width
operator|=
name|cs2width
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|cs3
condition|)
block|{
name|width
operator|=
name|cs3width
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|int
operator|)
name|n
operator|<
name|width
condition|)
block|{
name|werr
argument_list|(
literal|"incomplete character sequence (%s)"
argument_list|,
name|show_mb
argument_list|(
name|mb
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|width
condition|;
name|i
operator|++
control|)
block|{
comment|/* pull in the next byte */
name|c
operator|<<=
literal|8
expr_stmt|;
name|c
operator||=
call|(
name|uint8_t
call|)
argument_list|(
name|mb
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
operator|*
name|wc
operator|=
name|c
expr_stmt|;
return|return
operator|(
name|width
operator|)
return|;
block|}
end_function

begin_pragma
pragma|#
directive|pragma
name|GCC
name|diagnostic
name|pop
end_pragma

begin_comment
comment|/*  * EUC-CN encodes as follows:  *  * Code set 0 (ASCII):				0x21-0x7E  * Code set 1 (CNS 11643-1992 Plane 1):		0xA1A1-0xFEFE  * Code set 2:					unused  * Code set 3:					unused  */
end_comment

begin_function
name|int
name|towide_euccn
parameter_list|(
name|wchar_t
modifier|*
name|wc
parameter_list|,
specifier|const
name|char
modifier|*
name|mb
parameter_list|,
name|unsigned
name|n
parameter_list|)
block|{
return|return
operator|(
name|towide_euc_impl
argument_list|(
name|wc
argument_list|,
name|mb
argument_list|,
name|n
argument_list|,
literal|0x8e
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * EUC-JP encodes as follows:  *  * Code set 0 (ASCII or JIS X 0201-1976 Roman):	0x21-0x7E  * Code set 1 (JIS X 0208):			0xA1A1-0xFEFE  * Code set 2 (half-width katakana):		0x8EA1-0x8EDF  * Code set 3 (JIS X 0212-1990):		0x8FA1A1-0x8FFEFE  */
end_comment

begin_function
name|int
name|towide_eucjp
parameter_list|(
name|wchar_t
modifier|*
name|wc
parameter_list|,
specifier|const
name|char
modifier|*
name|mb
parameter_list|,
name|unsigned
name|n
parameter_list|)
block|{
return|return
operator|(
name|towide_euc_impl
argument_list|(
name|wc
argument_list|,
name|mb
argument_list|,
name|n
argument_list|,
literal|0x8e
argument_list|,
literal|2
argument_list|,
literal|0x8f
argument_list|,
literal|3
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * EUC-KR encodes as follows:  *  * Code set 0 (ASCII or KS C 5636-1993):	0x21-0x7E  * Code set 1 (KS C 5601-1992):			0xA1A1-0xFEFE  * Code set 2:					unused  * Code set 3:					unused  */
end_comment

begin_function
name|int
name|towide_euckr
parameter_list|(
name|wchar_t
modifier|*
name|wc
parameter_list|,
specifier|const
name|char
modifier|*
name|mb
parameter_list|,
name|unsigned
name|n
parameter_list|)
block|{
return|return
operator|(
name|towide_euc_impl
argument_list|(
name|wc
argument_list|,
name|mb
argument_list|,
name|n
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * EUC-TW encodes as follows:  *  * Code set 0 (ASCII):				0x21-0x7E  * Code set 1 (CNS 11643-1992 Plane 1):		0xA1A1-0xFEFE  * Code set 2 (CNS 11643-1992 Planes 1-16):	0x8EA1A1A1-0x8EB0FEFE  * Code set 3:					unused  */
end_comment

begin_function
name|int
name|towide_euctw
parameter_list|(
name|wchar_t
modifier|*
name|wc
parameter_list|,
specifier|const
name|char
modifier|*
name|mb
parameter_list|,
name|unsigned
name|n
parameter_list|)
block|{
return|return
operator|(
name|towide_euc_impl
argument_list|(
name|wc
argument_list|,
name|mb
argument_list|,
name|n
argument_list|,
literal|0x8e
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Public entry points.  */
end_comment

begin_function
name|int
name|to_wide
parameter_list|(
name|wchar_t
modifier|*
name|wc
parameter_list|,
specifier|const
name|char
modifier|*
name|mb
parameter_list|)
block|{
comment|/* this won't fail hard */
return|return
operator|(
name|_towide
argument_list|(
name|wc
argument_list|,
name|mb
argument_list|,
name|strlen
argument_list|(
name|mb
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|to_mb
parameter_list|(
name|char
modifier|*
name|mb
parameter_list|,
name|wchar_t
name|wc
parameter_list|)
block|{
name|int
name|rv
decl_stmt|;
if|if
condition|(
operator|(
name|rv
operator|=
name|_tomb
argument_list|(
name|mb
argument_list|,
name|wc
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|errf
argument_list|(
name|widemsg
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|widemsg
argument_list|)
expr_stmt|;
name|widemsg
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|to_mb_string
parameter_list|(
specifier|const
name|wchar_t
modifier|*
name|wcs
parameter_list|)
block|{
name|char
modifier|*
name|mbs
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
name|int
name|len
decl_stmt|;
name|mbs
operator|=
name|malloc
argument_list|(
operator|(
name|wcslen
argument_list|(
name|wcs
argument_list|)
operator|*
name|mb_cur_max
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs
operator|==
name|NULL
condition|)
block|{
name|errf
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|ptr
operator|=
name|mbs
expr_stmt|;
while|while
condition|(
operator|*
name|wcs
condition|)
block|{
if|if
condition|(
operator|(
name|len
operator|=
name|to_mb
argument_list|(
name|ptr
argument_list|,
operator|*
name|wcs
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|INTERR
expr_stmt|;
name|free
argument_list|(
name|mbs
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|wcs
operator|++
expr_stmt|;
name|ptr
operator|+=
name|len
expr_stmt|;
block|}
operator|*
name|ptr
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|mbs
operator|)
return|;
block|}
end_function

begin_function
name|void
name|set_wide_encoding
parameter_list|(
specifier|const
name|char
modifier|*
name|encoding
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|_towide
operator|=
name|towide_none
expr_stmt|;
name|_tomb
operator|=
name|tomb_none
expr_stmt|;
name|_nbits
operator|=
literal|8
expr_stmt|;
name|snprintf
argument_list|(
name|_encoding_buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|_encoding_buffer
argument_list|)
argument_list|,
literal|"NONE:%s"
argument_list|,
name|encoding
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|mb_encodings
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcasecmp
argument_list|(
name|encoding
argument_list|,
name|mb_encodings
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|_towide
operator|=
name|mb_encodings
index|[
name|i
index|]
operator|.
name|towide
expr_stmt|;
name|_tomb
operator|=
name|mb_encodings
index|[
name|i
index|]
operator|.
name|tomb
expr_stmt|;
name|_encoding
operator|=
name|mb_encodings
index|[
name|i
index|]
operator|.
name|cname
expr_stmt|;
name|_nbits
operator|=
name|mb_encodings
index|[
name|i
index|]
operator|.
name|nbits
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|get_wide_encoding
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|_encoding
operator|)
return|;
block|}
end_function

begin_function
name|int
name|max_wide
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
call|(
name|int
call|)
argument_list|(
operator|(
literal|1U
operator|<<
name|_nbits
operator|)
operator|-
literal|1
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

