begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright 2011 Nexenta Systems, Inc.  All rights reserved.  * Copyright 2012 Garrett D'Amore<garrett@damore.org>  All rights reserved.  * Copyright 2015 John Marino<draco@marino.st>  *  * This source code is derived from the illumos localedef command, and  * provided under BSD-style license terms by Nexenta Systems, Inc.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE  * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * LC_CTYPE database generation routines for localedef.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/tree.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<wchar.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<wctype.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"localedef.h"
end_include

begin_include
include|#
directive|include
file|"parser.h"
end_include

begin_include
include|#
directive|include
file|"runefile.h"
end_include

begin_comment
comment|/* Needed for bootstrapping, _CTYPE_N */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_CTYPE_N
end_ifndef

begin_define
define|#
directive|define
name|_CTYPE_N
value|0x00400000L
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|_ISUPPER
value|_CTYPE_U
end_define

begin_define
define|#
directive|define
name|_ISLOWER
value|_CTYPE_L
end_define

begin_define
define|#
directive|define
name|_ISDIGIT
value|_CTYPE_D
end_define

begin_define
define|#
directive|define
name|_ISXDIGIT
value|_CTYPE_X
end_define

begin_define
define|#
directive|define
name|_ISSPACE
value|_CTYPE_S
end_define

begin_define
define|#
directive|define
name|_ISBLANK
value|_CTYPE_B
end_define

begin_define
define|#
directive|define
name|_ISALPHA
value|_CTYPE_A
end_define

begin_define
define|#
directive|define
name|_ISPUNCT
value|_CTYPE_P
end_define

begin_define
define|#
directive|define
name|_ISGRAPH
value|_CTYPE_G
end_define

begin_define
define|#
directive|define
name|_ISPRINT
value|_CTYPE_R
end_define

begin_define
define|#
directive|define
name|_ISCNTRL
value|_CTYPE_C
end_define

begin_define
define|#
directive|define
name|_E1
value|_CTYPE_Q
end_define

begin_define
define|#
directive|define
name|_E2
value|_CTYPE_I
end_define

begin_define
define|#
directive|define
name|_E3
value|0
end_define

begin_define
define|#
directive|define
name|_E4
value|_CTYPE_N
end_define

begin_define
define|#
directive|define
name|_E5
value|_CTYPE_T
end_define

begin_decl_stmt
specifier|static
name|wchar_t
name|last_ctype
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|ctype_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|n1
parameter_list|,
specifier|const
name|void
modifier|*
name|n2
parameter_list|)
function_decl|;
end_function_decl

begin_typedef
typedef|typedef
struct|struct
name|ctype_node
block|{
name|wchar_t
name|wc
decl_stmt|;
name|int32_t
name|ctype
decl_stmt|;
name|int32_t
name|toupper
decl_stmt|;
name|int32_t
name|tolower
decl_stmt|;
name|RB_ENTRY
argument_list|(
argument|ctype_node
argument_list|)
name|entry
expr_stmt|;
block|}
name|ctype_node_t
typedef|;
end_typedef

begin_expr_stmt
specifier|static
name|RB_HEAD
argument_list|(
argument|ctypes
argument_list|,
argument|ctype_node
argument_list|)
name|ctypes
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|RB_GENERATE_STATIC
argument_list|(
name|ctypes
argument_list|,
name|ctype_node
argument_list|,
name|entry
argument_list|,
name|ctype_compare
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|ctype_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|n1
parameter_list|,
specifier|const
name|void
modifier|*
name|n2
parameter_list|)
block|{
specifier|const
name|ctype_node_t
modifier|*
name|c1
init|=
name|n1
decl_stmt|;
specifier|const
name|ctype_node_t
modifier|*
name|c2
init|=
name|n2
decl_stmt|;
return|return
operator|(
name|c1
operator|->
name|wc
operator|<
name|c2
operator|->
name|wc
condition|?
operator|-
literal|1
else|:
name|c1
operator|->
name|wc
operator|>
name|c2
operator|->
name|wc
condition|?
literal|1
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|init_ctype
parameter_list|(
name|void
parameter_list|)
block|{
name|RB_INIT
argument_list|(
operator|&
name|ctypes
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|add_ctype_impl
parameter_list|(
name|ctype_node_t
modifier|*
name|ctn
parameter_list|)
block|{
switch|switch
condition|(
name|last_kw
condition|)
block|{
case|case
name|T_ISUPPER
case|:
name|ctn
operator|->
name|ctype
operator||=
operator|(
name|_ISUPPER
operator||
name|_ISALPHA
operator||
name|_ISGRAPH
operator||
name|_ISPRINT
operator|)
expr_stmt|;
break|break;
case|case
name|T_ISLOWER
case|:
name|ctn
operator|->
name|ctype
operator||=
operator|(
name|_ISLOWER
operator||
name|_ISALPHA
operator||
name|_ISGRAPH
operator||
name|_ISPRINT
operator|)
expr_stmt|;
break|break;
case|case
name|T_ISALPHA
case|:
name|ctn
operator|->
name|ctype
operator||=
operator|(
name|_ISALPHA
operator||
name|_ISGRAPH
operator||
name|_ISPRINT
operator|)
expr_stmt|;
break|break;
case|case
name|T_ISDIGIT
case|:
name|ctn
operator|->
name|ctype
operator||=
operator|(
name|_ISDIGIT
operator||
name|_ISGRAPH
operator||
name|_ISPRINT
operator||
name|_ISXDIGIT
operator||
name|_E4
operator|)
expr_stmt|;
break|break;
case|case
name|T_ISSPACE
case|:
name|ctn
operator|->
name|ctype
operator||=
name|_ISSPACE
expr_stmt|;
break|break;
case|case
name|T_ISCNTRL
case|:
name|ctn
operator|->
name|ctype
operator||=
name|_ISCNTRL
expr_stmt|;
break|break;
case|case
name|T_ISGRAPH
case|:
name|ctn
operator|->
name|ctype
operator||=
operator|(
name|_ISGRAPH
operator||
name|_ISPRINT
operator|)
expr_stmt|;
break|break;
case|case
name|T_ISPRINT
case|:
name|ctn
operator|->
name|ctype
operator||=
name|_ISPRINT
expr_stmt|;
break|break;
case|case
name|T_ISPUNCT
case|:
name|ctn
operator|->
name|ctype
operator||=
operator|(
name|_ISPUNCT
operator||
name|_ISGRAPH
operator||
name|_ISPRINT
operator|)
expr_stmt|;
break|break;
case|case
name|T_ISXDIGIT
case|:
name|ctn
operator|->
name|ctype
operator||=
operator|(
name|_ISXDIGIT
operator||
name|_ISPRINT
operator|)
expr_stmt|;
break|break;
case|case
name|T_ISBLANK
case|:
name|ctn
operator|->
name|ctype
operator||=
operator|(
name|_ISBLANK
operator||
name|_ISSPACE
operator|)
expr_stmt|;
break|break;
case|case
name|T_ISPHONOGRAM
case|:
name|ctn
operator|->
name|ctype
operator||=
operator|(
name|_E1
operator||
name|_ISPRINT
operator||
name|_ISGRAPH
operator|)
expr_stmt|;
break|break;
case|case
name|T_ISIDEOGRAM
case|:
name|ctn
operator|->
name|ctype
operator||=
operator|(
name|_E2
operator||
name|_ISPRINT
operator||
name|_ISGRAPH
operator|)
expr_stmt|;
break|break;
case|case
name|T_ISENGLISH
case|:
name|ctn
operator|->
name|ctype
operator||=
operator|(
name|_E3
operator||
name|_ISPRINT
operator||
name|_ISGRAPH
operator|)
expr_stmt|;
break|break;
case|case
name|T_ISNUMBER
case|:
name|ctn
operator|->
name|ctype
operator||=
operator|(
name|_E4
operator||
name|_ISPRINT
operator||
name|_ISGRAPH
operator|)
expr_stmt|;
break|break;
case|case
name|T_ISSPECIAL
case|:
name|ctn
operator|->
name|ctype
operator||=
operator|(
name|_E5
operator||
name|_ISPRINT
operator||
name|_ISGRAPH
operator|)
expr_stmt|;
break|break;
case|case
name|T_ISALNUM
case|:
comment|/* 		 * We can't do anything with this.  The character 		 * should already be specified as a digit or alpha. 		 */
break|break;
default|default:
name|errf
argument_list|(
literal|"not a valid character class"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|ctype_node_t
modifier|*
name|get_ctype
parameter_list|(
name|wchar_t
name|wc
parameter_list|)
block|{
name|ctype_node_t
name|srch
decl_stmt|;
name|ctype_node_t
modifier|*
name|ctn
decl_stmt|;
name|srch
operator|.
name|wc
operator|=
name|wc
expr_stmt|;
if|if
condition|(
operator|(
name|ctn
operator|=
name|RB_FIND
argument_list|(
name|ctypes
argument_list|,
operator|&
name|ctypes
argument_list|,
operator|&
name|srch
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|ctn
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ctn
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|errf
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|ctn
operator|->
name|wc
operator|=
name|wc
expr_stmt|;
name|RB_INSERT
argument_list|(
name|ctypes
argument_list|,
operator|&
name|ctypes
argument_list|,
name|ctn
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ctn
operator|)
return|;
block|}
end_function

begin_function
name|void
name|add_ctype
parameter_list|(
name|int
name|val
parameter_list|)
block|{
name|ctype_node_t
modifier|*
name|ctn
decl_stmt|;
if|if
condition|(
operator|(
name|ctn
operator|=
name|get_ctype
argument_list|(
name|val
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|INTERR
expr_stmt|;
return|return;
block|}
name|add_ctype_impl
argument_list|(
name|ctn
argument_list|)
expr_stmt|;
name|last_ctype
operator|=
name|ctn
operator|->
name|wc
expr_stmt|;
block|}
end_function

begin_function
name|void
name|add_ctype_range
parameter_list|(
name|wchar_t
name|end
parameter_list|)
block|{
name|ctype_node_t
modifier|*
name|ctn
decl_stmt|;
name|wchar_t
name|cur
decl_stmt|;
if|if
condition|(
name|end
operator|<
name|last_ctype
condition|)
block|{
name|errf
argument_list|(
literal|"malformed character range (%u ... %u))"
argument_list|,
name|last_ctype
argument_list|,
name|end
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|cur
operator|=
name|last_ctype
operator|+
literal|1
init|;
name|cur
operator|<=
name|end
condition|;
name|cur
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|ctn
operator|=
name|get_ctype
argument_list|(
name|cur
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|INTERR
expr_stmt|;
return|return;
block|}
name|add_ctype_impl
argument_list|(
name|ctn
argument_list|)
expr_stmt|;
block|}
name|last_ctype
operator|=
name|end
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * A word about widths: if the width mask is specified, then libc  * unconditionally honors it.  Otherwise, it assumes printable  * characters have width 1, and non-printable characters have width  * -1 (except for NULL which is special with with 0).  Hence, we have  * no need to inject defaults here -- the "default" unset value of 0  * indicates that libc should use its own logic in wcwidth as described.  */
end_comment

begin_function
name|void
name|add_width
parameter_list|(
name|int
name|wc
parameter_list|,
name|int
name|width
parameter_list|)
block|{
name|ctype_node_t
modifier|*
name|ctn
decl_stmt|;
if|if
condition|(
operator|(
name|ctn
operator|=
name|get_ctype
argument_list|(
name|wc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|INTERR
expr_stmt|;
return|return;
block|}
name|ctn
operator|->
name|ctype
operator|&=
operator|~
operator|(
name|_CTYPE_SWM
operator|)
expr_stmt|;
switch|switch
condition|(
name|width
condition|)
block|{
case|case
literal|0
case|:
name|ctn
operator|->
name|ctype
operator||=
name|_CTYPE_SW0
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|ctn
operator|->
name|ctype
operator||=
name|_CTYPE_SW1
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|ctn
operator|->
name|ctype
operator||=
name|_CTYPE_SW2
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|ctn
operator|->
name|ctype
operator||=
name|_CTYPE_SW3
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
name|void
name|add_width_range
parameter_list|(
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|,
name|int
name|width
parameter_list|)
block|{
for|for
control|(
init|;
name|start
operator|<=
name|end
condition|;
name|start
operator|++
control|)
block|{
name|add_width
argument_list|(
name|start
argument_list|,
name|width
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|add_caseconv
parameter_list|(
name|int
name|val
parameter_list|,
name|int
name|wc
parameter_list|)
block|{
name|ctype_node_t
modifier|*
name|ctn
decl_stmt|;
name|ctn
operator|=
name|get_ctype
argument_list|(
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctn
operator|==
name|NULL
condition|)
block|{
name|INTERR
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|last_kw
condition|)
block|{
case|case
name|T_TOUPPER
case|:
name|ctn
operator|->
name|toupper
operator|=
name|wc
expr_stmt|;
break|break;
case|case
name|T_TOLOWER
case|:
name|ctn
operator|->
name|tolower
operator|=
name|wc
expr_stmt|;
break|break;
default|default:
name|INTERR
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
name|void
name|dump_ctype
parameter_list|(
name|void
parameter_list|)
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
name|_FileRuneLocale
name|rl
decl_stmt|;
name|ctype_node_t
modifier|*
name|ctn
decl_stmt|,
modifier|*
name|last_ct
decl_stmt|,
modifier|*
name|last_lo
decl_stmt|,
modifier|*
name|last_up
decl_stmt|;
name|_FileRuneEntry
modifier|*
name|ct
init|=
name|NULL
decl_stmt|;
name|_FileRuneEntry
modifier|*
name|lo
init|=
name|NULL
decl_stmt|;
name|_FileRuneEntry
modifier|*
name|up
init|=
name|NULL
decl_stmt|;
name|wchar_t
name|wc
decl_stmt|;
operator|(
name|void
operator|)
name|memset
argument_list|(
operator|&
name|rl
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|rl
argument_list|)
argument_list|)
expr_stmt|;
name|last_ct
operator|=
name|NULL
expr_stmt|;
name|last_lo
operator|=
name|NULL
expr_stmt|;
name|last_up
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|f
operator|=
name|open_category
argument_list|()
operator|)
operator|==
name|NULL
condition|)
return|return;
operator|(
name|void
operator|)
name|memcpy
argument_list|(
name|rl
operator|.
name|magic
argument_list|,
name|_FILE_RUNE_MAGIC_1
argument_list|,
literal|8
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|rl
operator|.
name|encoding
argument_list|,
name|get_wide_encoding
argument_list|()
argument_list|,
sizeof|sizeof
argument_list|(
name|rl
operator|.
name|encoding
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize the identity map. 	 */
for|for
control|(
name|wc
operator|=
literal|0
init|;
operator|(
name|unsigned
operator|)
name|wc
operator|<
name|_CACHED_RUNES
condition|;
name|wc
operator|++
control|)
block|{
name|rl
operator|.
name|maplower
index|[
name|wc
index|]
operator|=
name|wc
expr_stmt|;
name|rl
operator|.
name|mapupper
index|[
name|wc
index|]
operator|=
name|wc
expr_stmt|;
block|}
name|RB_FOREACH
argument_list|(
argument|ctn
argument_list|,
argument|ctypes
argument_list|,
argument|&ctypes
argument_list|)
block|{
name|int
name|conflict
init|=
literal|0
decl_stmt|;
name|wc
operator|=
name|ctn
operator|->
name|wc
expr_stmt|;
comment|/* 		 * POSIX requires certain portable characters have 		 * certain types.  Add them if they are missing. 		 */
if|if
condition|(
operator|(
name|wc
operator|>=
literal|1
operator|)
operator|&&
operator|(
name|wc
operator|<=
literal|127
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|wc
operator|>=
literal|'A'
operator|)
operator|&&
operator|(
name|wc
operator|<=
literal|'Z'
operator|)
condition|)
name|ctn
operator|->
name|ctype
operator||=
name|_ISUPPER
expr_stmt|;
if|if
condition|(
operator|(
name|wc
operator|>=
literal|'a'
operator|)
operator|&&
operator|(
name|wc
operator|<=
literal|'z'
operator|)
condition|)
name|ctn
operator|->
name|ctype
operator||=
name|_ISLOWER
expr_stmt|;
if|if
condition|(
operator|(
name|wc
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
name|wc
operator|<=
literal|'9'
operator|)
condition|)
name|ctn
operator|->
name|ctype
operator||=
name|_ISDIGIT
expr_stmt|;
if|if
condition|(
name|wc
operator|==
literal|' '
condition|)
name|ctn
operator|->
name|ctype
operator||=
name|_ISPRINT
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
literal|" \f\n\r\t\v"
argument_list|,
operator|(
name|char
operator|)
name|wc
argument_list|)
operator|!=
name|NULL
condition|)
name|ctn
operator|->
name|ctype
operator||=
name|_ISSPACE
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
literal|"0123456789ABCDEFabcdef"
argument_list|,
operator|(
name|char
operator|)
name|wc
argument_list|)
operator|!=
name|NULL
condition|)
name|ctn
operator|->
name|ctype
operator||=
name|_ISXDIGIT
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
literal|" \t"
argument_list|,
operator|(
name|char
operator|)
name|wc
argument_list|)
condition|)
name|ctn
operator|->
name|ctype
operator||=
name|_ISBLANK
expr_stmt|;
comment|/* 			 * Technically these settings are only 			 * required for the C locale.  However, it 			 * turns out that because of the historical 			 * version of isprint(), we need them for all 			 * locales as well.  Note that these are not 			 * necessarily valid punctation characters in 			 * the current language, but ispunct() needs 			 * to return TRUE for them. 			 */
if|if
condition|(
name|strchr
argument_list|(
literal|"!\"'#$%&()*+,-./:;<=>?@[\\]^_`{|}~"
argument_list|,
operator|(
name|char
operator|)
name|wc
argument_list|)
condition|)
name|ctn
operator|->
name|ctype
operator||=
name|_ISPUNCT
expr_stmt|;
block|}
comment|/* 		 * POSIX also requires that certain types imply 		 * others.  Add any inferred types here. 		 */
if|if
condition|(
name|ctn
operator|->
name|ctype
operator|&
operator|(
name|_ISUPPER
operator||
name|_ISLOWER
operator|)
condition|)
name|ctn
operator|->
name|ctype
operator||=
name|_ISALPHA
expr_stmt|;
if|if
condition|(
name|ctn
operator|->
name|ctype
operator|&
name|_ISDIGIT
condition|)
name|ctn
operator|->
name|ctype
operator||=
name|_ISXDIGIT
expr_stmt|;
if|if
condition|(
name|ctn
operator|->
name|ctype
operator|&
name|_ISBLANK
condition|)
name|ctn
operator|->
name|ctype
operator||=
name|_ISSPACE
expr_stmt|;
if|if
condition|(
name|ctn
operator|->
name|ctype
operator|&
operator|(
name|_ISALPHA
operator||
name|_ISDIGIT
operator||
name|_ISXDIGIT
operator|)
condition|)
name|ctn
operator|->
name|ctype
operator||=
name|_ISGRAPH
expr_stmt|;
if|if
condition|(
name|ctn
operator|->
name|ctype
operator|&
name|_ISGRAPH
condition|)
name|ctn
operator|->
name|ctype
operator||=
name|_ISPRINT
expr_stmt|;
comment|/* 		 * Finally, POSIX requires that certain combinations 		 * are invalid.  We don't flag this as a fatal error, 		 * but we will warn about. 		 */
if|if
condition|(
operator|(
name|ctn
operator|->
name|ctype
operator|&
name|_ISALPHA
operator|)
operator|&&
operator|(
name|ctn
operator|->
name|ctype
operator|&
operator|(
name|_ISPUNCT
operator||
name|_ISDIGIT
operator|)
operator|)
condition|)
name|conflict
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|ctn
operator|->
name|ctype
operator|&
name|_ISPUNCT
operator|)
operator|&
operator|(
name|ctn
operator|->
name|ctype
operator|&
operator|(
name|_ISDIGIT
operator||
name|_ISALPHA
operator||
name|_ISXDIGIT
operator|)
operator|)
condition|)
name|conflict
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|ctn
operator|->
name|ctype
operator|&
name|_ISSPACE
operator|)
operator|&&
operator|(
name|ctn
operator|->
name|ctype
operator|&
name|_ISGRAPH
operator|)
condition|)
name|conflict
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|ctn
operator|->
name|ctype
operator|&
name|_ISCNTRL
operator|)
operator|&
name|_ISPRINT
condition|)
name|conflict
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|wc
operator|==
literal|' '
operator|)
operator|&&
operator|(
name|ctn
operator|->
name|ctype
operator|&
operator|(
name|_ISPUNCT
operator||
name|_ISGRAPH
operator|)
operator|)
condition|)
name|conflict
operator|++
expr_stmt|;
if|if
condition|(
name|conflict
condition|)
block|{
name|warn
argument_list|(
literal|"conflicting classes for character 0x%x (%x)"
argument_list|,
name|wc
argument_list|,
name|ctn
operator|->
name|ctype
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Handle the lower 256 characters using the simple 		 * optimization.  Note that if we have not defined the 		 * upper/lower case, then we identity map it. 		 */
if|if
condition|(
operator|(
name|unsigned
operator|)
name|wc
operator|<
name|_CACHED_RUNES
condition|)
block|{
name|rl
operator|.
name|runetype
index|[
name|wc
index|]
operator|=
name|ctn
operator|->
name|ctype
expr_stmt|;
if|if
condition|(
name|ctn
operator|->
name|tolower
condition|)
name|rl
operator|.
name|maplower
index|[
name|wc
index|]
operator|=
name|ctn
operator|->
name|tolower
expr_stmt|;
if|if
condition|(
name|ctn
operator|->
name|toupper
condition|)
name|rl
operator|.
name|mapupper
index|[
name|wc
index|]
operator|=
name|ctn
operator|->
name|toupper
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|last_ct
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|last_ct
operator|->
name|ctype
operator|==
name|ctn
operator|->
name|ctype
operator|)
condition|)
block|{
name|ct
index|[
name|rl
operator|.
name|runetype_ext_nranges
operator|-
literal|1
index|]
operator|.
name|max
operator|=
name|wc
expr_stmt|;
name|last_ct
operator|=
name|ctn
expr_stmt|;
block|}
else|else
block|{
name|rl
operator|.
name|runetype_ext_nranges
operator|++
expr_stmt|;
name|ct
operator|=
name|realloc
argument_list|(
name|ct
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ct
argument_list|)
operator|*
name|rl
operator|.
name|runetype_ext_nranges
argument_list|)
expr_stmt|;
name|ct
index|[
name|rl
operator|.
name|runetype_ext_nranges
operator|-
literal|1
index|]
operator|.
name|min
operator|=
name|wc
expr_stmt|;
name|ct
index|[
name|rl
operator|.
name|runetype_ext_nranges
operator|-
literal|1
index|]
operator|.
name|max
operator|=
name|wc
expr_stmt|;
name|ct
index|[
name|rl
operator|.
name|runetype_ext_nranges
operator|-
literal|1
index|]
operator|.
name|map
operator|=
name|ctn
operator|->
name|ctype
expr_stmt|;
name|last_ct
operator|=
name|ctn
expr_stmt|;
block|}
if|if
condition|(
name|ctn
operator|->
name|tolower
operator|==
literal|0
condition|)
block|{
name|last_lo
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|last_lo
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|last_lo
operator|->
name|tolower
operator|+
literal|1
operator|==
name|ctn
operator|->
name|tolower
operator|)
condition|)
block|{
name|lo
index|[
name|rl
operator|.
name|maplower_ext_nranges
operator|-
literal|1
index|]
operator|.
name|max
operator|=
name|wc
expr_stmt|;
name|last_lo
operator|=
name|ctn
expr_stmt|;
block|}
else|else
block|{
name|rl
operator|.
name|maplower_ext_nranges
operator|++
expr_stmt|;
name|lo
operator|=
name|realloc
argument_list|(
name|lo
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lo
argument_list|)
operator|*
name|rl
operator|.
name|maplower_ext_nranges
argument_list|)
expr_stmt|;
name|lo
index|[
name|rl
operator|.
name|maplower_ext_nranges
operator|-
literal|1
index|]
operator|.
name|min
operator|=
name|wc
expr_stmt|;
name|lo
index|[
name|rl
operator|.
name|maplower_ext_nranges
operator|-
literal|1
index|]
operator|.
name|max
operator|=
name|wc
expr_stmt|;
name|lo
index|[
name|rl
operator|.
name|maplower_ext_nranges
operator|-
literal|1
index|]
operator|.
name|map
operator|=
name|ctn
operator|->
name|tolower
expr_stmt|;
name|last_lo
operator|=
name|ctn
expr_stmt|;
block|}
if|if
condition|(
name|ctn
operator|->
name|toupper
operator|==
literal|0
condition|)
block|{
name|last_up
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|last_up
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|last_up
operator|->
name|toupper
operator|+
literal|1
operator|==
name|ctn
operator|->
name|toupper
operator|)
condition|)
block|{
name|up
index|[
name|rl
operator|.
name|mapupper_ext_nranges
operator|-
literal|1
index|]
operator|.
name|max
operator|=
name|wc
expr_stmt|;
name|last_up
operator|=
name|ctn
expr_stmt|;
block|}
else|else
block|{
name|rl
operator|.
name|mapupper_ext_nranges
operator|++
expr_stmt|;
name|up
operator|=
name|realloc
argument_list|(
name|up
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|up
argument_list|)
operator|*
name|rl
operator|.
name|mapupper_ext_nranges
argument_list|)
expr_stmt|;
name|up
index|[
name|rl
operator|.
name|mapupper_ext_nranges
operator|-
literal|1
index|]
operator|.
name|min
operator|=
name|wc
expr_stmt|;
name|up
index|[
name|rl
operator|.
name|mapupper_ext_nranges
operator|-
literal|1
index|]
operator|.
name|max
operator|=
name|wc
expr_stmt|;
name|up
index|[
name|rl
operator|.
name|mapupper_ext_nranges
operator|-
literal|1
index|]
operator|.
name|map
operator|=
name|ctn
operator|->
name|toupper
expr_stmt|;
name|last_up
operator|=
name|ctn
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|wr_category
argument_list|(
operator|&
name|rl
argument_list|,
sizeof|sizeof
argument_list|(
name|rl
argument_list|)
argument_list|,
name|f
argument_list|)
operator|<
literal|0
operator|)
operator|||
operator|(
name|wr_category
argument_list|(
name|ct
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ct
argument_list|)
operator|*
name|rl
operator|.
name|runetype_ext_nranges
argument_list|,
name|f
argument_list|)
operator|<
literal|0
operator|)
operator|||
operator|(
name|wr_category
argument_list|(
name|lo
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lo
argument_list|)
operator|*
name|rl
operator|.
name|maplower_ext_nranges
argument_list|,
name|f
argument_list|)
operator|<
literal|0
operator|)
operator|||
operator|(
name|wr_category
argument_list|(
name|up
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|up
argument_list|)
operator|*
name|rl
operator|.
name|mapupper_ext_nranges
argument_list|,
name|f
argument_list|)
operator|<
literal|0
operator|)
condition|)
block|{
return|return;
block|}
name|close_category
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

