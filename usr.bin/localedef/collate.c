begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright 2017 Nexenta Systems, Inc.  * Copyright 2015 John Marino<draco@marino.st>  *  * This source code is derived from the illumos localedef command, and  * provided under BSD-style license terms by Nexenta Systems, Inc.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE  * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * LC_COLLATE database generation routines for localedef.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/tree.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<wchar.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|"localedef.h"
end_include

begin_include
include|#
directive|include
file|"parser.h"
end_include

begin_include
include|#
directive|include
file|"collate.h"
end_include

begin_comment
comment|/*  * Design notes.  *  * It will be extremely helpful to the reader if they have access to  * the localedef and locale file format specifications available.  * Latest versions of these are available from www.opengroup.org.  *  * The design for the collation code is a bit complex.  The goal is a  * single collation database as described in collate.h (in  * libc/port/locale).  However, there are some other tidbits:  *  * a) The substitution entries are now a directly indexable array.  A  * priority elsewhere in the table is taken as an index into the  * substitution table if it has a high bit (COLLATE_SUBST_PRIORITY)  * set.  (The bit is cleared and the result is the index into the  * table.  *  * b) We eliminate duplicate entries into the substitution table.  * This saves a lot of space.  *  * c) The priorities for each level are "compressed", so that each  * sorting level has consecutively numbered priorities starting at 1.  * (O is reserved for the ignore priority.)  This means sort levels  * which only have a few distinct priorities can represent the  * priority level in fewer bits, which makes the strxfrm output  * smaller.  *  * d) We record the total number of priorities so that strxfrm can  * figure out how many bytes to expand a numeric priority into.  *  * e) For the UNDEFINED pass (the last pass), we record the maximum  * number of bits needed to uniquely prioritize these entries, so that  * the last pass can also use smaller strxfrm output when possible.  *  * f) Priorities with the sign bit set are verboten.  This works out  * because no active character set needs that bit to carry significant  * information once the character is in wide form.  *  * To process the entire data to make the database, we actually run  * multiple passes over the data.  *  * The first pass, which is done at parse time, identifies elements,  * substitutions, and such, and records them in priority order.  As  * some priorities can refer to other priorities, using forward  * references, we use a table of references indicating whether the  * priority's value has been resolved, or whether it is still a  * reference.  *  * The second pass walks over all the items in priority order, noting  * that they are used directly, and not just an indirect reference.  * This is done by creating a "weight" structure for the item.  The  * weights are stashed in an RB tree sorted by relative "priority".  *  * The third pass walks over all the weight structures, in priority  * order, and assigns a new monotonically increasing (per sort level)  * weight value to them.  These are the values that will actually be  * written to the file.  *  * The fourth pass just writes the data out.  */
end_comment

begin_comment
comment|/*  * In order to resolve the priorities, we create a table of priorities.  * Entries in the table can be in one of three states.  *  * UNKNOWN is for newly allocated entries, and indicates that nothing  * is known about the priority.  (For example, when new entries are created  * for collating-symbols, this is the value assigned for them until the  * collating symbol's order has been determined.  *  * RESOLVED is used for an entry where the priority indicates the final  * numeric weight.  *  * REFER is used for entries that reference other entries.  Typically  * this is used for forward references.  A collating-symbol can never  * have this value.  *  * The "pass" field is used during final resolution to aid in detection  * of referencing loops.  (For example<A> depends on<B>, but<B> has its  * priority dependent on<A>.)  */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|UNKNOWN
block|,
comment|/* priority is totally unknown */
name|RESOLVED
block|,
comment|/* priority value fully resolved */
name|REFER
comment|/* priority is a reference (index) */
block|}
name|res_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|weight
block|{
name|int32_t
name|pri
decl_stmt|;
name|int
name|opt
decl_stmt|;
name|RB_ENTRY
argument_list|(
argument|weight
argument_list|)
name|entry
expr_stmt|;
block|}
name|weight_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|priority
block|{
name|res_t
name|res
decl_stmt|;
name|int32_t
name|pri
decl_stmt|;
name|int
name|pass
decl_stmt|;
name|int
name|lineno
decl_stmt|;
block|}
name|collpri_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|NUM_WT
value|collinfo.directive_count
end_define

begin_comment
comment|/*  * These are the abstract collating symbols, which are just a symbolic  * way to reference a priority.  */
end_comment

begin_struct
struct|struct
name|collsym
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int32_t
name|ref
decl_stmt|;
name|RB_ENTRY
argument_list|(
argument|collsym
argument_list|)
name|entry
expr_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * These are also abstract collating symbols, but we allow them to have  * different priorities at different levels.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|collundef
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int32_t
name|ref
index|[
name|COLL_WEIGHTS_MAX
index|]
decl_stmt|;
name|RB_ENTRY
argument_list|(
argument|collundef
argument_list|)
name|entry
expr_stmt|;
block|}
name|collundef_t
typedef|;
end_typedef

begin_comment
comment|/*  * These are called "chains" in libc.  This records the fact that two  * more characters should be treated as a single collating entity when  * they appear together.  For example, in Spanish<C><h> gets collated  * as a character between<C> and<D>.  */
end_comment

begin_struct
struct|struct
name|collelem
block|{
name|char
modifier|*
name|symbol
decl_stmt|;
name|wchar_t
modifier|*
name|expand
decl_stmt|;
name|int32_t
name|ref
index|[
name|COLL_WEIGHTS_MAX
index|]
decl_stmt|;
name|RB_ENTRY
argument_list|(
argument|collelem
argument_list|)
name|rb_bysymbol
expr_stmt|;
name|RB_ENTRY
argument_list|(
argument|collelem
argument_list|)
name|rb_byexpand
expr_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Individual characters have a sequence of weights as well.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|collchar
block|{
name|wchar_t
name|wc
decl_stmt|;
name|int32_t
name|ref
index|[
name|COLL_WEIGHTS_MAX
index|]
decl_stmt|;
name|RB_ENTRY
argument_list|(
argument|collchar
argument_list|)
name|entry
expr_stmt|;
block|}
name|collchar_t
typedef|;
end_typedef

begin_comment
comment|/*  * Substitution entries.  The key is itself a priority.  Note that  * when we create one of these, we *automatically* wind up with a  * fully resolved priority for the key, because creation of  * substitutions creates a resolved priority at the same time.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|subst
block|{
name|int32_t
name|key
decl_stmt|;
name|int32_t
name|ref
index|[
name|COLLATE_STR_LEN
index|]
decl_stmt|;
name|RB_ENTRY
argument_list|(
argument|subst
argument_list|)
name|entry
expr_stmt|;
name|RB_ENTRY
argument_list|(
argument|subst
argument_list|)
name|entry_ref
expr_stmt|;
block|}
name|subst_t
typedef|;
end_typedef

begin_expr_stmt
specifier|static
name|RB_HEAD
argument_list|(
argument|collsyms
argument_list|,
argument|collsym
argument_list|)
name|collsyms
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|RB_HEAD
argument_list|(
argument|collundefs
argument_list|,
argument|collundef
argument_list|)
name|collundefs
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|RB_HEAD
argument_list|(
argument|elem_by_symbol
argument_list|,
argument|collelem
argument_list|)
name|elem_by_symbol
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|RB_HEAD
argument_list|(
argument|elem_by_expand
argument_list|,
argument|collelem
argument_list|)
name|elem_by_expand
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|RB_HEAD
argument_list|(
argument|collchars
argument_list|,
argument|collchar
argument_list|)
name|collchars
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|RB_HEAD
argument_list|(
argument|substs
argument_list|,
argument|subst
argument_list|)
name|substs
index|[
name|COLL_WEIGHTS_MAX
index|]
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|RB_HEAD
argument_list|(
argument|substs_ref
argument_list|,
argument|subst
argument_list|)
name|substs_ref
index|[
name|COLL_WEIGHTS_MAX
index|]
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|RB_HEAD
argument_list|(
argument|weights
argument_list|,
argument|weight
argument_list|)
name|weights
index|[
name|COLL_WEIGHTS_MAX
index|]
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int32_t
name|nweight
index|[
name|COLL_WEIGHTS_MAX
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This is state tracking for the ellipsis token.  Note that we start  * the initial values so that the ellipsis logic will think we got a  * magic starting value of NUL.  It starts at minus one because the  * starting point is exclusive -- i.e. the starting point is not  * itself handled by the ellipsis code.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|currorder
init|=
name|EOF
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|lastorder
init|=
name|EOF
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|collelem_t
modifier|*
name|currelem
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|collchar_t
modifier|*
name|currchar
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|collundef_t
modifier|*
name|currundef
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|wchar_t
name|ellipsis_start
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int32_t
name|ellipsis_weights
index|[
name|COLL_WEIGHTS_MAX
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * We keep a running tally of weights.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|nextpri
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nextsubst
index|[
name|COLL_WEIGHTS_MAX
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This array collects up the weights for each level.  */
end_comment

begin_decl_stmt
specifier|static
name|int32_t
name|order_weights
index|[
name|COLL_WEIGHTS_MAX
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|curr_weight
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int32_t
name|subst_weights
index|[
name|COLLATE_STR_LEN
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|curr_subst
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Some initial priority values.  */
end_comment

begin_decl_stmt
specifier|static
name|int32_t
name|pri_undefined
index|[
name|COLL_WEIGHTS_MAX
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int32_t
name|pri_ignore
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|collate_info_t
name|collinfo
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|collpri_t
modifier|*
name|prilist
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|numpri
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|maxpri
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|start_order
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int32_t
name|new_pri
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|numpri
operator|>=
name|maxpri
condition|)
block|{
name|maxpri
operator|=
name|maxpri
condition|?
name|maxpri
operator|*
literal|2
else|:
literal|1024
expr_stmt|;
name|prilist
operator|=
name|realloc
argument_list|(
name|prilist
argument_list|,
sizeof|sizeof
argument_list|(
name|collpri_t
argument_list|)
operator|*
name|maxpri
argument_list|)
expr_stmt|;
if|if
condition|(
name|prilist
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
name|numpri
init|;
name|i
operator|<
name|maxpri
condition|;
name|i
operator|++
control|)
block|{
name|prilist
index|[
name|i
index|]
operator|.
name|res
operator|=
name|UNKNOWN
expr_stmt|;
name|prilist
index|[
name|i
index|]
operator|.
name|pri
operator|=
literal|0
expr_stmt|;
name|prilist
index|[
name|i
index|]
operator|.
name|pass
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
operator|(
name|numpri
operator|++
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|collpri_t
modifier|*
name|get_pri
parameter_list|(
name|int32_t
name|ref
parameter_list|)
block|{
if|if
condition|(
operator|(
name|ref
operator|<
literal|0
operator|)
operator|||
operator|(
name|ref
operator|>
name|numpri
operator|)
condition|)
block|{
name|INTERR
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
operator|&
name|prilist
index|[
name|ref
index|]
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_pri
parameter_list|(
name|int32_t
name|ref
parameter_list|,
name|int32_t
name|v
parameter_list|,
name|res_t
name|res
parameter_list|)
block|{
name|collpri_t
modifier|*
name|pri
decl_stmt|;
name|pri
operator|=
name|get_pri
argument_list|(
name|ref
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|res
operator|==
name|REFER
operator|)
operator|&&
operator|(
operator|(
name|v
operator|<
literal|0
operator|)
operator|||
operator|(
name|v
operator|>=
name|numpri
operator|)
operator|)
condition|)
block|{
name|INTERR
expr_stmt|;
block|}
comment|/* Resolve self references */
if|if
condition|(
operator|(
name|res
operator|==
name|REFER
operator|)
operator|&&
operator|(
name|ref
operator|==
name|v
operator|)
condition|)
block|{
name|v
operator|=
name|nextpri
expr_stmt|;
name|res
operator|=
name|RESOLVED
expr_stmt|;
block|}
if|if
condition|(
name|pri
operator|->
name|res
operator|!=
name|UNKNOWN
condition|)
block|{
name|warn
argument_list|(
literal|"repeated item in order list (first on %d)"
argument_list|,
name|pri
operator|->
name|lineno
argument_list|)
expr_stmt|;
return|return;
block|}
name|pri
operator|->
name|lineno
operator|=
name|lineno
expr_stmt|;
name|pri
operator|->
name|pri
operator|=
name|v
expr_stmt|;
name|pri
operator|->
name|res
operator|=
name|res
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int32_t
name|resolve_pri
parameter_list|(
name|int32_t
name|ref
parameter_list|)
block|{
name|collpri_t
modifier|*
name|pri
decl_stmt|;
specifier|static
name|int32_t
name|pass
init|=
literal|0
decl_stmt|;
name|pri
operator|=
name|get_pri
argument_list|(
name|ref
argument_list|)
expr_stmt|;
name|pass
operator|++
expr_stmt|;
while|while
condition|(
name|pri
operator|->
name|res
operator|==
name|REFER
condition|)
block|{
if|if
condition|(
name|pri
operator|->
name|pass
operator|==
name|pass
condition|)
block|{
comment|/* report a line with the circular symbol */
name|lineno
operator|=
name|pri
operator|->
name|lineno
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"circular reference in order list"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|pri
operator|->
name|pri
operator|<
literal|0
operator|)
operator|||
operator|(
name|pri
operator|->
name|pri
operator|>=
name|numpri
operator|)
condition|)
block|{
name|INTERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|pri
operator|->
name|pass
operator|=
name|pass
expr_stmt|;
name|pri
operator|=
operator|&
name|prilist
index|[
name|pri
operator|->
name|pri
index|]
expr_stmt|;
block|}
if|if
condition|(
name|pri
operator|->
name|res
operator|==
name|UNKNOWN
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|pri
operator|->
name|res
operator|!=
name|RESOLVED
condition|)
name|INTERR
expr_stmt|;
return|return
operator|(
name|pri
operator|->
name|pri
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|weight_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|n1
parameter_list|,
specifier|const
name|void
modifier|*
name|n2
parameter_list|)
block|{
name|int32_t
name|k1
init|=
operator|(
operator|(
specifier|const
name|weight_t
operator|*
operator|)
name|n1
operator|)
operator|->
name|pri
decl_stmt|;
name|int32_t
name|k2
init|=
operator|(
operator|(
specifier|const
name|weight_t
operator|*
operator|)
name|n2
operator|)
operator|->
name|pri
decl_stmt|;
return|return
operator|(
name|k1
operator|<
name|k2
condition|?
operator|-
literal|1
else|:
name|k1
operator|>
name|k2
condition|?
literal|1
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|RB_GENERATE_STATIC
argument_list|(
name|weights
argument_list|,
name|weight
argument_list|,
name|entry
argument_list|,
name|weight_compare
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|collsym_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|n1
parameter_list|,
specifier|const
name|void
modifier|*
name|n2
parameter_list|)
block|{
specifier|const
name|collsym_t
modifier|*
name|c1
init|=
name|n1
decl_stmt|;
specifier|const
name|collsym_t
modifier|*
name|c2
init|=
name|n2
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|rv
operator|=
name|strcmp
argument_list|(
name|c1
operator|->
name|name
argument_list|,
name|c2
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|rv
operator|<
literal|0
operator|)
condition|?
operator|-
literal|1
else|:
operator|(
name|rv
operator|>
literal|0
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|RB_GENERATE_STATIC
argument_list|(
name|collsyms
argument_list|,
name|collsym
argument_list|,
name|entry
argument_list|,
name|collsym_compare
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|collundef_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|n1
parameter_list|,
specifier|const
name|void
modifier|*
name|n2
parameter_list|)
block|{
specifier|const
name|collundef_t
modifier|*
name|c1
init|=
name|n1
decl_stmt|;
specifier|const
name|collundef_t
modifier|*
name|c2
init|=
name|n2
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|rv
operator|=
name|strcmp
argument_list|(
name|c1
operator|->
name|name
argument_list|,
name|c2
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|rv
operator|<
literal|0
operator|)
condition|?
operator|-
literal|1
else|:
operator|(
name|rv
operator|>
literal|0
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|RB_GENERATE_STATIC
argument_list|(
name|collundefs
argument_list|,
name|collundef
argument_list|,
name|entry
argument_list|,
name|collundef_compare
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|element_compare_symbol
parameter_list|(
specifier|const
name|void
modifier|*
name|n1
parameter_list|,
specifier|const
name|void
modifier|*
name|n2
parameter_list|)
block|{
specifier|const
name|collelem_t
modifier|*
name|c1
init|=
name|n1
decl_stmt|;
specifier|const
name|collelem_t
modifier|*
name|c2
init|=
name|n2
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|rv
operator|=
name|strcmp
argument_list|(
name|c1
operator|->
name|symbol
argument_list|,
name|c2
operator|->
name|symbol
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|rv
operator|<
literal|0
operator|)
condition|?
operator|-
literal|1
else|:
operator|(
name|rv
operator|>
literal|0
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|RB_GENERATE_STATIC
argument_list|(
name|elem_by_symbol
argument_list|,
name|collelem
argument_list|,
name|rb_bysymbol
argument_list|,
name|element_compare_symbol
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|element_compare_expand
parameter_list|(
specifier|const
name|void
modifier|*
name|n1
parameter_list|,
specifier|const
name|void
modifier|*
name|n2
parameter_list|)
block|{
specifier|const
name|collelem_t
modifier|*
name|c1
init|=
name|n1
decl_stmt|;
specifier|const
name|collelem_t
modifier|*
name|c2
init|=
name|n2
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|rv
operator|=
name|wcscmp
argument_list|(
name|c1
operator|->
name|expand
argument_list|,
name|c2
operator|->
name|expand
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|rv
operator|<
literal|0
operator|)
condition|?
operator|-
literal|1
else|:
operator|(
name|rv
operator|>
literal|0
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|RB_GENERATE_STATIC
argument_list|(
name|elem_by_expand
argument_list|,
name|collelem
argument_list|,
name|rb_byexpand
argument_list|,
name|element_compare_expand
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|collchar_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|n1
parameter_list|,
specifier|const
name|void
modifier|*
name|n2
parameter_list|)
block|{
name|wchar_t
name|k1
init|=
operator|(
operator|(
specifier|const
name|collchar_t
operator|*
operator|)
name|n1
operator|)
operator|->
name|wc
decl_stmt|;
name|wchar_t
name|k2
init|=
operator|(
operator|(
specifier|const
name|collchar_t
operator|*
operator|)
name|n2
operator|)
operator|->
name|wc
decl_stmt|;
return|return
operator|(
name|k1
operator|<
name|k2
condition|?
operator|-
literal|1
else|:
name|k1
operator|>
name|k2
condition|?
literal|1
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|RB_GENERATE_STATIC
argument_list|(
name|collchars
argument_list|,
name|collchar
argument_list|,
name|entry
argument_list|,
name|collchar_compare
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|subst_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|n1
parameter_list|,
specifier|const
name|void
modifier|*
name|n2
parameter_list|)
block|{
name|int32_t
name|k1
init|=
operator|(
operator|(
specifier|const
name|subst_t
operator|*
operator|)
name|n1
operator|)
operator|->
name|key
decl_stmt|;
name|int32_t
name|k2
init|=
operator|(
operator|(
specifier|const
name|subst_t
operator|*
operator|)
name|n2
operator|)
operator|->
name|key
decl_stmt|;
return|return
operator|(
name|k1
operator|<
name|k2
condition|?
operator|-
literal|1
else|:
name|k1
operator|>
name|k2
condition|?
literal|1
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|RB_GENERATE_STATIC
argument_list|(
name|substs
argument_list|,
name|subst
argument_list|,
name|entry
argument_list|,
name|subst_compare
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|subst_compare_ref
parameter_list|(
specifier|const
name|void
modifier|*
name|n1
parameter_list|,
specifier|const
name|void
modifier|*
name|n2
parameter_list|)
block|{
specifier|const
name|wchar_t
modifier|*
name|c1
init|=
operator|(
operator|(
specifier|const
name|subst_t
operator|*
operator|)
name|n1
operator|)
operator|->
name|ref
decl_stmt|;
specifier|const
name|wchar_t
modifier|*
name|c2
init|=
operator|(
operator|(
specifier|const
name|subst_t
operator|*
operator|)
name|n2
operator|)
operator|->
name|ref
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|rv
operator|=
name|wcscmp
argument_list|(
name|c1
argument_list|,
name|c2
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|rv
operator|<
literal|0
operator|)
condition|?
operator|-
literal|1
else|:
operator|(
name|rv
operator|>
literal|0
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|RB_GENERATE_STATIC
argument_list|(
name|substs_ref
argument_list|,
name|subst
argument_list|,
name|entry_ref
argument_list|,
name|subst_compare_ref
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|void
name|init_collate
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|RB_INIT
argument_list|(
operator|&
name|collsyms
argument_list|)
expr_stmt|;
name|RB_INIT
argument_list|(
operator|&
name|collundefs
argument_list|)
expr_stmt|;
name|RB_INIT
argument_list|(
operator|&
name|elem_by_symbol
argument_list|)
expr_stmt|;
name|RB_INIT
argument_list|(
operator|&
name|elem_by_expand
argument_list|)
expr_stmt|;
name|RB_INIT
argument_list|(
operator|&
name|collchars
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|COLL_WEIGHTS_MAX
condition|;
name|i
operator|++
control|)
block|{
name|RB_INIT
argument_list|(
operator|&
name|substs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|RB_INIT
argument_list|(
operator|&
name|substs_ref
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|RB_INIT
argument_list|(
operator|&
name|weights
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|nweight
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|memset
argument_list|(
operator|&
name|collinfo
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|collinfo
argument_list|)
argument_list|)
expr_stmt|;
comment|/* allocate some initial priorities */
name|pri_ignore
operator|=
name|new_pri
argument_list|()
expr_stmt|;
name|set_pri
argument_list|(
name|pri_ignore
argument_list|,
literal|0
argument_list|,
name|RESOLVED
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|COLL_WEIGHTS_MAX
condition|;
name|i
operator|++
control|)
block|{
name|pri_undefined
index|[
name|i
index|]
operator|=
name|new_pri
argument_list|()
expr_stmt|;
comment|/* we will override this later */
name|set_pri
argument_list|(
name|pri_undefined
index|[
name|i
index|]
argument_list|,
name|COLLATE_MAX_PRIORITY
argument_list|,
name|UNKNOWN
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|define_collsym
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|collsym_t
modifier|*
name|sym
decl_stmt|;
if|if
condition|(
operator|(
name|sym
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sym
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
return|return;
block|}
name|sym
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|sym
operator|->
name|ref
operator|=
name|new_pri
argument_list|()
expr_stmt|;
if|if
condition|(
name|RB_FIND
argument_list|(
name|collsyms
argument_list|,
operator|&
name|collsyms
argument_list|,
name|sym
argument_list|)
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * This should never happen because we are only called 		 * for undefined symbols. 		 */
name|free
argument_list|(
name|sym
argument_list|)
expr_stmt|;
name|INTERR
expr_stmt|;
return|return;
block|}
name|RB_INSERT
argument_list|(
name|collsyms
argument_list|,
operator|&
name|collsyms
argument_list|,
name|sym
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|collsym_t
modifier|*
name|lookup_collsym
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|collsym_t
name|srch
decl_stmt|;
name|srch
operator|.
name|name
operator|=
name|name
expr_stmt|;
return|return
operator|(
name|RB_FIND
argument_list|(
name|collsyms
argument_list|,
operator|&
name|collsyms
argument_list|,
operator|&
name|srch
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|collelem_t
modifier|*
name|lookup_collelem
parameter_list|(
name|char
modifier|*
name|symbol
parameter_list|)
block|{
name|collelem_t
name|srch
decl_stmt|;
name|srch
operator|.
name|symbol
operator|=
name|symbol
expr_stmt|;
return|return
operator|(
name|RB_FIND
argument_list|(
name|elem_by_symbol
argument_list|,
operator|&
name|elem_by_symbol
argument_list|,
operator|&
name|srch
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|collundef_t
modifier|*
name|get_collundef
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|collundef_t
name|srch
decl_stmt|;
name|collundef_t
modifier|*
name|ud
decl_stmt|;
name|int
name|i
decl_stmt|;
name|srch
operator|.
name|name
operator|=
name|name
expr_stmt|;
if|if
condition|(
operator|(
name|ud
operator|=
name|RB_FIND
argument_list|(
name|collundefs
argument_list|,
operator|&
name|collundefs
argument_list|,
operator|&
name|srch
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|ud
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ud
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|(
name|ud
operator|->
name|name
operator|=
name|strdup
argument_list|(
name|name
argument_list|)
operator|)
operator|==
name|NULL
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ud
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_WT
condition|;
name|i
operator|++
control|)
block|{
name|ud
operator|->
name|ref
index|[
name|i
index|]
operator|=
name|new_pri
argument_list|()
expr_stmt|;
block|}
name|RB_INSERT
argument_list|(
name|collundefs
argument_list|,
operator|&
name|collundefs
argument_list|,
name|ud
argument_list|)
expr_stmt|;
block|}
name|add_charmap_undefined
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|ud
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|collchar_t
modifier|*
name|get_collchar
parameter_list|(
name|wchar_t
name|wc
parameter_list|,
name|int
name|create
parameter_list|)
block|{
name|collchar_t
name|srch
decl_stmt|;
name|collchar_t
modifier|*
name|cc
decl_stmt|;
name|int
name|i
decl_stmt|;
name|srch
operator|.
name|wc
operator|=
name|wc
expr_stmt|;
name|cc
operator|=
name|RB_FIND
argument_list|(
name|collchars
argument_list|,
operator|&
name|collchars
argument_list|,
operator|&
name|srch
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cc
operator|==
name|NULL
operator|)
operator|&&
name|create
condition|)
block|{
if|if
condition|(
operator|(
name|cc
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cc
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_WT
condition|;
name|i
operator|++
control|)
block|{
name|cc
operator|->
name|ref
index|[
name|i
index|]
operator|=
name|new_pri
argument_list|()
expr_stmt|;
block|}
name|cc
operator|->
name|wc
operator|=
name|wc
expr_stmt|;
name|RB_INSERT
argument_list|(
name|collchars
argument_list|,
operator|&
name|collchars
argument_list|,
name|cc
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|cc
operator|)
return|;
block|}
end_function

begin_function
name|void
name|end_order_collsym
parameter_list|(
name|collsym_t
modifier|*
name|sym
parameter_list|)
block|{
name|start_order
argument_list|(
name|T_COLLSYM
argument_list|)
expr_stmt|;
comment|/* update the weight */
name|set_pri
argument_list|(
name|sym
operator|->
name|ref
argument_list|,
name|nextpri
argument_list|,
name|RESOLVED
argument_list|)
expr_stmt|;
name|nextpri
operator|++
expr_stmt|;
block|}
end_function

begin_function
name|void
name|end_order
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int32_t
name|pri
decl_stmt|;
name|int32_t
name|ref
decl_stmt|;
name|collpri_t
modifier|*
name|p
decl_stmt|;
comment|/* advance the priority/weight */
name|pri
operator|=
name|nextpri
expr_stmt|;
switch|switch
condition|(
name|currorder
condition|)
block|{
case|case
name|T_CHAR
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_WT
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|ref
operator|=
name|order_weights
index|[
name|i
index|]
operator|)
operator|<
literal|0
operator|)
operator|||
operator|(
operator|(
name|p
operator|=
name|get_pri
argument_list|(
name|ref
argument_list|)
operator|)
operator|==
name|NULL
operator|)
operator|||
operator|(
name|p
operator|->
name|pri
operator|==
operator|-
literal|1
operator|)
condition|)
block|{
comment|/* unspecified weight is a self reference */
name|set_pri
argument_list|(
name|currchar
operator|->
name|ref
index|[
name|i
index|]
argument_list|,
name|pri
argument_list|,
name|RESOLVED
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|set_pri
argument_list|(
name|currchar
operator|->
name|ref
index|[
name|i
index|]
argument_list|,
name|ref
argument_list|,
name|REFER
argument_list|)
expr_stmt|;
block|}
name|order_weights
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* leave a cookie trail in case next symbol is ellipsis */
name|ellipsis_start
operator|=
name|currchar
operator|->
name|wc
operator|+
literal|1
expr_stmt|;
name|currchar
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|T_ELLIPSIS
case|:
comment|/* save off the weights were we can find them */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_WT
condition|;
name|i
operator|++
control|)
block|{
name|ellipsis_weights
index|[
name|i
index|]
operator|=
name|order_weights
index|[
name|i
index|]
expr_stmt|;
name|order_weights
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|T_COLLELEM
case|:
if|if
condition|(
name|currelem
operator|==
name|NULL
condition|)
block|{
name|INTERR
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_WT
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|ref
operator|=
name|order_weights
index|[
name|i
index|]
operator|)
operator|<
literal|0
operator|)
operator|||
operator|(
operator|(
name|p
operator|=
name|get_pri
argument_list|(
name|ref
argument_list|)
operator|)
operator|==
name|NULL
operator|)
operator|||
operator|(
name|p
operator|->
name|pri
operator|==
operator|-
literal|1
operator|)
condition|)
block|{
name|set_pri
argument_list|(
name|currelem
operator|->
name|ref
index|[
name|i
index|]
argument_list|,
name|pri
argument_list|,
name|RESOLVED
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|set_pri
argument_list|(
name|currelem
operator|->
name|ref
index|[
name|i
index|]
argument_list|,
name|ref
argument_list|,
name|REFER
argument_list|)
expr_stmt|;
block|}
name|order_weights
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
break|break;
case|case
name|T_UNDEFINED
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_WT
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|ref
operator|=
name|order_weights
index|[
name|i
index|]
operator|)
operator|<
literal|0
operator|)
operator|||
operator|(
operator|(
name|p
operator|=
name|get_pri
argument_list|(
name|ref
argument_list|)
operator|)
operator|==
name|NULL
operator|)
operator|||
operator|(
name|p
operator|->
name|pri
operator|==
operator|-
literal|1
operator|)
condition|)
block|{
name|set_pri
argument_list|(
name|pri_undefined
index|[
name|i
index|]
argument_list|,
operator|-
literal|1
argument_list|,
name|RESOLVED
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|set_pri
argument_list|(
name|pri_undefined
index|[
name|i
index|]
argument_list|,
name|ref
argument_list|,
name|REFER
argument_list|)
expr_stmt|;
block|}
name|order_weights
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|T_SYMBOL
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_WT
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|ref
operator|=
name|order_weights
index|[
name|i
index|]
operator|)
operator|<
literal|0
operator|)
operator|||
operator|(
operator|(
name|p
operator|=
name|get_pri
argument_list|(
name|ref
argument_list|)
operator|)
operator|==
name|NULL
operator|)
operator|||
operator|(
name|p
operator|->
name|pri
operator|==
operator|-
literal|1
operator|)
condition|)
block|{
name|set_pri
argument_list|(
name|currundef
operator|->
name|ref
index|[
name|i
index|]
argument_list|,
name|pri
argument_list|,
name|RESOLVED
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|set_pri
argument_list|(
name|currundef
operator|->
name|ref
index|[
name|i
index|]
argument_list|,
name|ref
argument_list|,
name|REFER
argument_list|)
expr_stmt|;
block|}
name|order_weights
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
break|break;
default|default:
name|INTERR
expr_stmt|;
block|}
name|nextpri
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|start_order
parameter_list|(
name|int
name|type
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|lastorder
operator|=
name|currorder
expr_stmt|;
name|currorder
operator|=
name|type
expr_stmt|;
comment|/* this is used to protect ELLIPSIS processing */
if|if
condition|(
operator|(
name|lastorder
operator|==
name|T_ELLIPSIS
operator|)
operator|&&
operator|(
name|type
operator|!=
name|T_CHAR
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"character value expected"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|COLL_WEIGHTS_MAX
condition|;
name|i
operator|++
control|)
block|{
name|order_weights
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|curr_weight
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|start_order_undefined
parameter_list|(
name|void
parameter_list|)
block|{
name|start_order
argument_list|(
name|T_UNDEFINED
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|start_order_symbol
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|currundef
operator|=
name|get_collundef
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|start_order
argument_list|(
name|T_SYMBOL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|start_order_char
parameter_list|(
name|wchar_t
name|wc
parameter_list|)
block|{
name|collchar_t
modifier|*
name|cc
decl_stmt|;
name|int32_t
name|ref
decl_stmt|;
name|start_order
argument_list|(
name|T_CHAR
argument_list|)
expr_stmt|;
comment|/* 	 * If we last saw an ellipsis, then we need to close the range. 	 * Handle that here.  Note that we have to be careful because the 	 * items *inside* the range are treated exclusiveley to the items 	 * outside of the range.  The ends of the range can have quite 	 * different weights than the range members. 	 */
if|if
condition|(
name|lastorder
operator|==
name|T_ELLIPSIS
condition|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|wc
operator|<
name|ellipsis_start
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"malformed range!"
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|ellipsis_start
operator|<
name|wc
condition|)
block|{
comment|/* 			 * pick all of the saved weights for the 			 * ellipsis.  note that -1 encodes for the 			 * ellipsis itself, which means to take the 			 * current relative priority. 			 */
if|if
condition|(
operator|(
name|cc
operator|=
name|get_collchar
argument_list|(
name|ellipsis_start
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|INTERR
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_WT
condition|;
name|i
operator|++
control|)
block|{
name|collpri_t
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|ref
operator|=
name|ellipsis_weights
index|[
name|i
index|]
operator|)
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
operator|(
name|p
operator|=
name|get_pri
argument_list|(
name|ref
argument_list|)
operator|)
operator|==
name|NULL
operator|)
operator|||
operator|(
name|p
operator|->
name|pri
operator|==
operator|-
literal|1
operator|)
condition|)
block|{
name|set_pri
argument_list|(
name|cc
operator|->
name|ref
index|[
name|i
index|]
argument_list|,
name|nextpri
argument_list|,
name|RESOLVED
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|set_pri
argument_list|(
name|cc
operator|->
name|ref
index|[
name|i
index|]
argument_list|,
name|ref
argument_list|,
name|REFER
argument_list|)
expr_stmt|;
block|}
name|ellipsis_weights
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|ellipsis_start
operator|++
expr_stmt|;
name|nextpri
operator|++
expr_stmt|;
block|}
block|}
name|currchar
operator|=
name|get_collchar
argument_list|(
name|wc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|start_order_collelem
parameter_list|(
name|collelem_t
modifier|*
name|e
parameter_list|)
block|{
name|start_order
argument_list|(
name|T_COLLELEM
argument_list|)
expr_stmt|;
name|currelem
operator|=
name|e
expr_stmt|;
block|}
end_function

begin_function
name|void
name|start_order_ellipsis
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|start_order
argument_list|(
name|T_ELLIPSIS
argument_list|)
expr_stmt|;
if|if
condition|(
name|lastorder
operator|!=
name|T_CHAR
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"illegal starting point for range"
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_WT
condition|;
name|i
operator|++
control|)
block|{
name|ellipsis_weights
index|[
name|i
index|]
operator|=
name|order_weights
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|define_collelem
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|wchar_t
modifier|*
name|wcs
parameter_list|)
block|{
name|collelem_t
modifier|*
name|e
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|wcslen
argument_list|(
name|wcs
argument_list|)
operator|>=
name|COLLATE_STR_LEN
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"expanded collation element too long"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|e
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|e
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
return|return;
block|}
name|e
operator|->
name|expand
operator|=
name|wcs
expr_stmt|;
name|e
operator|->
name|symbol
operator|=
name|name
expr_stmt|;
comment|/* 	 * This is executed before the order statement, so we don't 	 * know how many priorities we *really* need.  We allocate one 	 * for each possible weight.  Not a big deal, as collating-elements 	 * prove to be quite rare. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|COLL_WEIGHTS_MAX
condition|;
name|i
operator|++
control|)
block|{
name|e
operator|->
name|ref
index|[
name|i
index|]
operator|=
name|new_pri
argument_list|()
expr_stmt|;
block|}
comment|/* A character sequence can only reduce to one element. */
if|if
condition|(
operator|(
name|RB_FIND
argument_list|(
name|elem_by_symbol
argument_list|,
operator|&
name|elem_by_symbol
argument_list|,
name|e
argument_list|)
operator|!=
name|NULL
operator|)
operator|||
operator|(
name|RB_FIND
argument_list|(
name|elem_by_expand
argument_list|,
operator|&
name|elem_by_expand
argument_list|,
name|e
argument_list|)
operator|!=
name|NULL
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"duplicate collating element definition"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return;
block|}
name|RB_INSERT
argument_list|(
name|elem_by_symbol
argument_list|,
operator|&
name|elem_by_symbol
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|RB_INSERT
argument_list|(
name|elem_by_expand
argument_list|,
operator|&
name|elem_by_expand
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|add_order_bit
parameter_list|(
name|int
name|kw
parameter_list|)
block|{
name|uint8_t
name|bit
init|=
name|DIRECTIVE_UNDEF
decl_stmt|;
switch|switch
condition|(
name|kw
condition|)
block|{
case|case
name|T_FORWARD
case|:
name|bit
operator|=
name|DIRECTIVE_FORWARD
expr_stmt|;
break|break;
case|case
name|T_BACKWARD
case|:
name|bit
operator|=
name|DIRECTIVE_BACKWARD
expr_stmt|;
break|break;
case|case
name|T_POSITION
case|:
name|bit
operator|=
name|DIRECTIVE_POSITION
expr_stmt|;
break|break;
default|default:
name|INTERR
expr_stmt|;
break|break;
block|}
name|collinfo
operator|.
name|directive
index|[
name|collinfo
operator|.
name|directive_count
index|]
operator||=
name|bit
expr_stmt|;
block|}
end_function

begin_function
name|void
name|add_order_directive
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|collinfo
operator|.
name|directive_count
operator|>=
name|COLL_WEIGHTS_MAX
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"too many directives (max %d)"
argument_list|,
name|COLL_WEIGHTS_MAX
argument_list|)
expr_stmt|;
block|}
name|collinfo
operator|.
name|directive_count
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|add_order_pri
parameter_list|(
name|int32_t
name|ref
parameter_list|)
block|{
if|if
condition|(
name|curr_weight
operator|>=
name|NUM_WT
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"too many weights (max %d)"
argument_list|,
name|NUM_WT
argument_list|)
expr_stmt|;
return|return;
block|}
name|order_weights
index|[
name|curr_weight
index|]
operator|=
name|ref
expr_stmt|;
name|curr_weight
operator|++
expr_stmt|;
block|}
end_function

begin_function
name|void
name|add_order_collsym
parameter_list|(
name|collsym_t
modifier|*
name|s
parameter_list|)
block|{
name|add_order_pri
argument_list|(
name|s
operator|->
name|ref
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|add_order_char
parameter_list|(
name|wchar_t
name|wc
parameter_list|)
block|{
name|collchar_t
modifier|*
name|cc
decl_stmt|;
if|if
condition|(
operator|(
name|cc
operator|=
name|get_collchar
argument_list|(
name|wc
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|INTERR
expr_stmt|;
return|return;
block|}
name|add_order_pri
argument_list|(
name|cc
operator|->
name|ref
index|[
name|curr_weight
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|add_order_collelem
parameter_list|(
name|collelem_t
modifier|*
name|e
parameter_list|)
block|{
name|add_order_pri
argument_list|(
name|e
operator|->
name|ref
index|[
name|curr_weight
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|add_order_ignore
parameter_list|(
name|void
parameter_list|)
block|{
name|add_order_pri
argument_list|(
name|pri_ignore
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|add_order_symbol
parameter_list|(
name|char
modifier|*
name|sym
parameter_list|)
block|{
name|collundef_t
modifier|*
name|c
decl_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|get_collundef
argument_list|(
name|sym
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|INTERR
expr_stmt|;
return|return;
block|}
name|add_order_pri
argument_list|(
name|c
operator|->
name|ref
index|[
name|curr_weight
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|add_order_ellipsis
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* special NULL value indicates self reference */
name|add_order_pri
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|add_order_subst
parameter_list|(
name|void
parameter_list|)
block|{
name|subst_t
name|srch
decl_stmt|;
name|subst_t
modifier|*
name|s
decl_stmt|;
name|int
name|i
decl_stmt|;
operator|(
name|void
operator|)
name|memset
argument_list|(
operator|&
name|srch
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|srch
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|curr_subst
condition|;
name|i
operator|++
control|)
block|{
name|srch
operator|.
name|ref
index|[
name|i
index|]
operator|=
name|subst_weights
index|[
name|i
index|]
expr_stmt|;
name|subst_weights
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|s
operator|=
name|RB_FIND
argument_list|(
name|substs_ref
argument_list|,
operator|&
name|substs_ref
index|[
name|curr_weight
index|]
argument_list|,
operator|&
name|srch
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|s
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|s
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
return|return;
block|}
name|s
operator|->
name|key
operator|=
name|new_pri
argument_list|()
expr_stmt|;
comment|/* 		 * We use a self reference for our key, but we set a 		 * high bit to indicate that this is a substitution 		 * reference.  This will expedite table lookups later, 		 * and prevent table lookups for situations that don't 		 * require it.  (In short, its a big win, because we 		 * can skip a lot of binary searching.) 		 */
name|set_pri
argument_list|(
name|s
operator|->
name|key
argument_list|,
operator|(
name|nextsubst
index|[
name|curr_weight
index|]
operator||
name|COLLATE_SUBST_PRIORITY
operator|)
argument_list|,
name|RESOLVED
argument_list|)
expr_stmt|;
name|nextsubst
index|[
name|curr_weight
index|]
operator|+=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|curr_subst
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|->
name|ref
index|[
name|i
index|]
operator|=
name|srch
operator|.
name|ref
index|[
name|i
index|]
expr_stmt|;
block|}
name|RB_INSERT
argument_list|(
name|substs_ref
argument_list|,
operator|&
name|substs_ref
index|[
name|curr_weight
index|]
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|RB_FIND
argument_list|(
name|substs
argument_list|,
operator|&
name|substs
index|[
name|curr_weight
index|]
argument_list|,
name|s
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|INTERR
expr_stmt|;
return|return;
block|}
name|RB_INSERT
argument_list|(
name|substs
argument_list|,
operator|&
name|substs
index|[
name|curr_weight
index|]
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
name|curr_subst
operator|=
literal|0
expr_stmt|;
comment|/* 	 * We are using the current (unique) priority as a search key 	 * in the substitution table. 	 */
name|add_order_pri
argument_list|(
name|s
operator|->
name|key
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|add_subst_pri
parameter_list|(
name|int32_t
name|ref
parameter_list|)
block|{
if|if
condition|(
name|curr_subst
operator|>=
name|COLLATE_STR_LEN
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"substitution string is too long"
argument_list|)
expr_stmt|;
return|return;
block|}
name|subst_weights
index|[
name|curr_subst
index|]
operator|=
name|ref
expr_stmt|;
name|curr_subst
operator|++
expr_stmt|;
block|}
end_function

begin_function
name|void
name|add_subst_char
parameter_list|(
name|wchar_t
name|wc
parameter_list|)
block|{
name|collchar_t
modifier|*
name|cc
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|cc
operator|=
name|get_collchar
argument_list|(
name|wc
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|NULL
operator|)
operator|||
operator|(
name|cc
operator|->
name|wc
operator|!=
name|wc
operator|)
condition|)
block|{
name|INTERR
expr_stmt|;
return|return;
block|}
comment|/* we take the weight for the character at that position */
name|add_subst_pri
argument_list|(
name|cc
operator|->
name|ref
index|[
name|curr_weight
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|add_subst_collelem
parameter_list|(
name|collelem_t
modifier|*
name|e
parameter_list|)
block|{
name|add_subst_pri
argument_list|(
name|e
operator|->
name|ref
index|[
name|curr_weight
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|add_subst_collsym
parameter_list|(
name|collsym_t
modifier|*
name|s
parameter_list|)
block|{
name|add_subst_pri
argument_list|(
name|s
operator|->
name|ref
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|add_subst_symbol
parameter_list|(
name|char
modifier|*
name|ptr
parameter_list|)
block|{
name|collundef_t
modifier|*
name|cu
decl_stmt|;
if|if
condition|(
operator|(
name|cu
operator|=
name|get_collundef
argument_list|(
name|ptr
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|add_subst_pri
argument_list|(
name|cu
operator|->
name|ref
index|[
name|curr_weight
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|add_weight
parameter_list|(
name|int32_t
name|ref
parameter_list|,
name|int
name|pass
parameter_list|)
block|{
name|weight_t
name|srch
decl_stmt|;
name|weight_t
modifier|*
name|w
decl_stmt|;
name|srch
operator|.
name|pri
operator|=
name|resolve_pri
argument_list|(
name|ref
argument_list|)
expr_stmt|;
comment|/* No translation of ignores */
if|if
condition|(
name|srch
operator|.
name|pri
operator|==
literal|0
condition|)
return|return;
comment|/* Substitution priorities are not weights */
if|if
condition|(
name|srch
operator|.
name|pri
operator|&
name|COLLATE_SUBST_PRIORITY
condition|)
return|return;
if|if
condition|(
name|RB_FIND
argument_list|(
name|weights
argument_list|,
operator|&
name|weights
index|[
name|pass
index|]
argument_list|,
operator|&
name|srch
argument_list|)
operator|!=
name|NULL
condition|)
return|return;
if|if
condition|(
operator|(
name|w
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|w
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
return|return;
block|}
name|w
operator|->
name|pri
operator|=
name|srch
operator|.
name|pri
expr_stmt|;
name|RB_INSERT
argument_list|(
name|weights
argument_list|,
operator|&
name|weights
index|[
name|pass
index|]
argument_list|,
name|w
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|add_weights
parameter_list|(
name|int32_t
modifier|*
name|refs
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_WT
condition|;
name|i
operator|++
control|)
block|{
name|add_weight
argument_list|(
name|refs
index|[
name|i
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int32_t
name|get_weight
parameter_list|(
name|int32_t
name|ref
parameter_list|,
name|int
name|pass
parameter_list|)
block|{
name|weight_t
name|srch
decl_stmt|;
name|weight_t
modifier|*
name|w
decl_stmt|;
name|int32_t
name|pri
decl_stmt|;
name|pri
operator|=
name|resolve_pri
argument_list|(
name|ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|pri
operator|&
name|COLLATE_SUBST_PRIORITY
condition|)
block|{
return|return
operator|(
name|pri
operator|)
return|;
block|}
if|if
condition|(
name|pri
operator|<=
literal|0
condition|)
block|{
return|return
operator|(
name|pri
operator|)
return|;
block|}
name|srch
operator|.
name|pri
operator|=
name|pri
expr_stmt|;
if|if
condition|(
operator|(
name|w
operator|=
name|RB_FIND
argument_list|(
name|weights
argument_list|,
operator|&
name|weights
index|[
name|pass
index|]
argument_list|,
operator|&
name|srch
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|INTERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
name|w
operator|->
name|opt
operator|)
return|;
block|}
end_function

begin_function
name|wchar_t
modifier|*
name|wsncpy
parameter_list|(
name|wchar_t
modifier|*
name|s1
parameter_list|,
specifier|const
name|wchar_t
modifier|*
name|s2
parameter_list|,
name|size_t
name|n
parameter_list|)
block|{
name|wchar_t
modifier|*
name|os1
init|=
name|s1
decl_stmt|;
name|n
operator|++
expr_stmt|;
while|while
condition|(
operator|--
name|n
operator|>
literal|0
operator|&&
operator|(
operator|*
name|s1
operator|++
operator|=
operator|*
name|s2
operator|++
operator|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|n
operator|>
literal|0
condition|)
while|while
condition|(
operator|--
name|n
operator|>
literal|0
condition|)
operator|*
name|s1
operator|++
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|os1
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|RB_COUNT
parameter_list|(
name|x
parameter_list|,
name|name
parameter_list|,
name|head
parameter_list|,
name|cnt
parameter_list|)
value|do { \ 	(cnt) = 0; \ 	RB_FOREACH(x, name, (head)) { \ 		(cnt)++; \ 	} \ } while (0)
end_define

begin_define
define|#
directive|define
name|RB_NUMNODES
parameter_list|(
name|type
parameter_list|,
name|name
parameter_list|,
name|head
parameter_list|,
name|cnt
parameter_list|)
value|do { \ 	type *t; \ 	cnt = 0; \ 	RB_FOREACH(t, name, head) { \ 		cnt++; \ 	} \ } while (0)
end_define

begin_function
name|void
name|dump_collate
parameter_list|(
name|void
parameter_list|)
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|n
decl_stmt|;
name|size_t
name|sz
decl_stmt|;
name|int32_t
name|pri
decl_stmt|;
name|collelem_t
modifier|*
name|ce
decl_stmt|;
name|collchar_t
modifier|*
name|cc
decl_stmt|;
name|subst_t
modifier|*
name|sb
decl_stmt|;
name|char
name|vers
index|[
name|COLLATE_STR_LEN
index|]
decl_stmt|;
name|collate_char_t
name|chars
index|[
name|UCHAR_MAX
operator|+
literal|1
index|]
decl_stmt|;
name|collate_large_t
modifier|*
name|large
decl_stmt|;
name|collate_subst_t
modifier|*
name|subst
index|[
name|COLL_WEIGHTS_MAX
index|]
decl_stmt|;
name|collate_chain_t
modifier|*
name|chain
decl_stmt|;
comment|/* 	 * We have to run through a preliminary pass to identify all the 	 * weights that we use for each sorting level. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_WT
condition|;
name|i
operator|++
control|)
block|{
name|add_weight
argument_list|(
name|pri_ignore
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_WT
condition|;
name|i
operator|++
control|)
block|{
name|RB_FOREACH
argument_list|(
argument|sb
argument_list|,
argument|substs
argument_list|,
argument|&substs[i]
argument_list|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|sb
operator|->
name|ref
index|[
name|j
index|]
condition|;
name|j
operator|++
control|)
block|{
name|add_weight
argument_list|(
name|sb
operator|->
name|ref
index|[
name|j
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|RB_FOREACH
argument_list|(
argument|ce
argument_list|,
argument|elem_by_expand
argument_list|,
argument|&elem_by_expand
argument_list|)
block|{
name|add_weights
argument_list|(
name|ce
operator|->
name|ref
argument_list|)
expr_stmt|;
block|}
name|RB_FOREACH
argument_list|(
argument|cc
argument_list|,
argument|collchars
argument_list|,
argument|&collchars
argument_list|)
block|{
name|add_weights
argument_list|(
name|cc
operator|->
name|ref
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Now we walk the entire set of weights, removing the gaps 	 * in the weights.  This gives us optimum usage.  The walk 	 * occurs in priority. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_WT
condition|;
name|i
operator|++
control|)
block|{
name|weight_t
modifier|*
name|w
decl_stmt|;
name|RB_FOREACH
argument_list|(
argument|w
argument_list|,
argument|weights
argument_list|,
argument|&weights[i]
argument_list|)
block|{
name|w
operator|->
name|opt
operator|=
name|nweight
index|[
name|i
index|]
expr_stmt|;
name|nweight
index|[
name|i
index|]
operator|+=
literal|1
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|memset
argument_list|(
operator|&
name|chars
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|chars
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|memset
argument_list|(
name|vers
argument_list|,
literal|0
argument_list|,
name|COLLATE_STR_LEN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|vers
argument_list|,
name|COLLATE_VERSION
argument_list|,
sizeof|sizeof
argument_list|(
name|vers
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * We need to make sure we arrange for the UNDEFINED field 	 * to show up.  Also, set the total weight counts. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_WT
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|resolve_pri
argument_list|(
name|pri_undefined
index|[
name|i
index|]
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|set_pri
argument_list|(
name|pri_undefined
index|[
name|i
index|]
argument_list|,
operator|-
literal|1
argument_list|,
name|RESOLVED
argument_list|)
expr_stmt|;
comment|/* they collate at the end of everything else */
name|collinfo
operator|.
name|undef_pri
index|[
name|i
index|]
operator|=
name|COLLATE_MAX_PRIORITY
expr_stmt|;
block|}
name|collinfo
operator|.
name|pri_count
index|[
name|i
index|]
operator|=
name|nweight
index|[
name|i
index|]
expr_stmt|;
block|}
name|collinfo
operator|.
name|pri_count
index|[
name|NUM_WT
index|]
operator|=
name|max_wide
argument_list|()
expr_stmt|;
name|collinfo
operator|.
name|undef_pri
index|[
name|NUM_WT
index|]
operator|=
name|COLLATE_MAX_PRIORITY
expr_stmt|;
name|collinfo
operator|.
name|directive
index|[
name|NUM_WT
index|]
operator|=
name|DIRECTIVE_UNDEFINED
expr_stmt|;
comment|/* 	 * Ordinary character priorities 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|UCHAR_MAX
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|cc
operator|=
name|get_collchar
argument_list|(
name|i
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|NUM_WT
condition|;
name|j
operator|++
control|)
block|{
name|chars
index|[
name|i
index|]
operator|.
name|pri
index|[
name|j
index|]
operator|=
name|get_weight
argument_list|(
name|cc
operator|->
name|ref
index|[
name|j
index|]
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|NUM_WT
condition|;
name|j
operator|++
control|)
block|{
name|chars
index|[
name|i
index|]
operator|.
name|pri
index|[
name|j
index|]
operator|=
name|get_weight
argument_list|(
name|pri_undefined
index|[
name|j
index|]
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * Per POSIX, for undefined characters, we 			 * also have to add a last item, which is the 			 * character code. 			 */
name|chars
index|[
name|i
index|]
operator|.
name|pri
index|[
name|NUM_WT
index|]
operator|=
name|i
expr_stmt|;
block|}
block|}
comment|/* 	 * Substitution tables 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_WT
condition|;
name|i
operator|++
control|)
block|{
name|collate_subst_t
modifier|*
name|st
init|=
name|NULL
decl_stmt|;
name|subst_t
modifier|*
name|temp
decl_stmt|;
name|RB_COUNT
argument_list|(
name|temp
argument_list|,
name|substs
argument_list|,
operator|&
name|substs
index|[
name|i
index|]
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|collinfo
operator|.
name|subst_count
index|[
name|i
index|]
operator|=
name|n
expr_stmt|;
if|if
condition|(
operator|(
name|st
operator|=
name|calloc
argument_list|(
name|n
argument_list|,
sizeof|sizeof
argument_list|(
name|collate_subst_t
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
return|return;
block|}
name|n
operator|=
literal|0
expr_stmt|;
name|RB_FOREACH
argument_list|(
argument|sb
argument_list|,
argument|substs
argument_list|,
argument|&substs[i]
argument_list|)
block|{
if|if
condition|(
operator|(
name|st
index|[
name|n
index|]
operator|.
name|key
operator|=
name|resolve_pri
argument_list|(
name|sb
operator|->
name|key
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
comment|/* by definition these resolve! */
name|INTERR
expr_stmt|;
block|}
if|if
condition|(
name|st
index|[
name|n
index|]
operator|.
name|key
operator|!=
operator|(
name|n
operator||
name|COLLATE_SUBST_PRIORITY
operator|)
condition|)
block|{
name|INTERR
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|sb
operator|->
name|ref
index|[
name|j
index|]
condition|;
name|j
operator|++
control|)
block|{
name|st
index|[
name|n
index|]
operator|.
name|pri
index|[
name|j
index|]
operator|=
name|get_weight
argument_list|(
name|sb
operator|->
name|ref
index|[
name|j
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|n
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|!=
name|collinfo
operator|.
name|subst_count
index|[
name|i
index|]
condition|)
name|INTERR
expr_stmt|;
name|subst
index|[
name|i
index|]
operator|=
name|st
expr_stmt|;
block|}
comment|/* 	 * Chains, i.e. collating elements 	 */
name|RB_NUMNODES
argument_list|(
name|collelem_t
argument_list|,
name|elem_by_expand
argument_list|,
operator|&
name|elem_by_expand
argument_list|,
name|collinfo
operator|.
name|chain_count
argument_list|)
expr_stmt|;
name|chain
operator|=
name|calloc
argument_list|(
name|collinfo
operator|.
name|chain_count
argument_list|,
sizeof|sizeof
argument_list|(
name|collate_chain_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|chain
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
return|return;
block|}
name|n
operator|=
literal|0
expr_stmt|;
name|RB_FOREACH
argument_list|(
argument|ce
argument_list|,
argument|elem_by_expand
argument_list|,
argument|&elem_by_expand
argument_list|)
block|{
operator|(
name|void
operator|)
name|wsncpy
argument_list|(
name|chain
index|[
name|n
index|]
operator|.
name|str
argument_list|,
name|ce
operator|->
name|expand
argument_list|,
name|COLLATE_STR_LEN
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_WT
condition|;
name|i
operator|++
control|)
block|{
name|chain
index|[
name|n
index|]
operator|.
name|pri
index|[
name|i
index|]
operator|=
name|get_weight
argument_list|(
name|ce
operator|->
name|ref
index|[
name|i
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|n
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|!=
name|collinfo
operator|.
name|chain_count
condition|)
name|INTERR
expr_stmt|;
comment|/* 	 * Large (> UCHAR_MAX) character priorities 	 */
name|RB_NUMNODES
argument_list|(
name|collchar_t
argument_list|,
name|collchars
argument_list|,
operator|&
name|collchars
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|large
operator|=
name|calloc
argument_list|(
name|n
argument_list|,
sizeof|sizeof
argument_list|(
name|collate_large_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|large
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
return|return;
block|}
name|i
operator|=
literal|0
expr_stmt|;
name|RB_FOREACH
argument_list|(
argument|cc
argument_list|,
argument|collchars
argument_list|,
argument|&collchars
argument_list|)
block|{
name|int
name|undef
init|=
literal|0
decl_stmt|;
comment|/* we already gathered those */
if|if
condition|(
name|cc
operator|->
name|wc
operator|<=
name|UCHAR_MAX
condition|)
continue|continue;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|NUM_WT
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|pri
operator|=
name|get_weight
argument_list|(
name|cc
operator|->
name|ref
index|[
name|j
index|]
argument_list|,
name|j
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|undef
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|undef
operator|&&
operator|(
name|pri
operator|>=
literal|0
operator|)
condition|)
block|{
comment|/* if undefined, then all priorities are */
name|INTERR
expr_stmt|;
block|}
else|else
block|{
name|large
index|[
name|i
index|]
operator|.
name|pri
operator|.
name|pri
index|[
name|j
index|]
operator|=
name|pri
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|undef
condition|)
block|{
name|large
index|[
name|i
index|]
operator|.
name|val
operator|=
name|cc
operator|->
name|wc
expr_stmt|;
name|collinfo
operator|.
name|large_count
operator|=
name|i
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|f
operator|=
name|open_category
argument_list|()
operator|)
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
comment|/* Time to write the entire data set out */
if|if
condition|(
operator|(
name|wr_category
argument_list|(
name|vers
argument_list|,
name|COLLATE_STR_LEN
argument_list|,
name|f
argument_list|)
operator|<
literal|0
operator|)
operator|||
operator|(
name|wr_category
argument_list|(
operator|&
name|collinfo
argument_list|,
sizeof|sizeof
argument_list|(
name|collinfo
argument_list|)
argument_list|,
name|f
argument_list|)
operator|<
literal|0
operator|)
operator|||
operator|(
name|wr_category
argument_list|(
operator|&
name|chars
argument_list|,
sizeof|sizeof
argument_list|(
name|chars
argument_list|)
argument_list|,
name|f
argument_list|)
operator|<
literal|0
operator|)
condition|)
block|{
name|delete_category
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_WT
condition|;
name|i
operator|++
control|)
block|{
name|sz
operator|=
sizeof|sizeof
argument_list|(
name|collate_subst_t
argument_list|)
operator|*
name|collinfo
operator|.
name|subst_count
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|wr_category
argument_list|(
name|subst
index|[
name|i
index|]
argument_list|,
name|sz
argument_list|,
name|f
argument_list|)
operator|<
literal|0
condition|)
block|{
name|delete_category
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|sz
operator|=
sizeof|sizeof
argument_list|(
name|collate_chain_t
argument_list|)
operator|*
name|collinfo
operator|.
name|chain_count
expr_stmt|;
if|if
condition|(
name|wr_category
argument_list|(
name|chain
argument_list|,
name|sz
argument_list|,
name|f
argument_list|)
operator|<
literal|0
condition|)
block|{
name|delete_category
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return;
block|}
name|sz
operator|=
sizeof|sizeof
argument_list|(
name|collate_large_t
argument_list|)
operator|*
name|collinfo
operator|.
name|large_count
expr_stmt|;
if|if
condition|(
name|wr_category
argument_list|(
name|large
argument_list|,
name|sz
argument_list|,
name|f
argument_list|)
operator|<
literal|0
condition|)
block|{
name|delete_category
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return;
block|}
name|close_category
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

