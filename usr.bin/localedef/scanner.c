begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright 2010 Nexenta Systems, Inc.  All rights reserved.  * Copyright 2015 John Marino<draco@marino.st>  *  * This source code is derived from the illumos localedef command, and  * provided under BSD-style license terms by Nexenta Systems, Inc.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE  * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * This file contains the "scanner", which tokenizes the input files  * for localedef for processing by the higher level grammar processor.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<wchar.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|"localedef.h"
end_include

begin_include
include|#
directive|include
file|"parser.h"
end_include

begin_decl_stmt
name|int
name|com_char
init|=
literal|'#'
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|esc_char
init|=
literal|'\\'
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|mb_cur_min
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|mb_cur_max
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|lineno
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|warnings
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|is_stdin
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|input
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nextline
decl_stmt|;
end_decl_stmt

begin_comment
comment|//static FILE		*input = stdin;
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|filename
init|=
literal|"<stdin>"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|instring
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|escaped
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Token space ... grows on demand.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|token
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|tokidx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|toksz
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|hadtok
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Wide string space ... grows on demand.  */
end_comment

begin_decl_stmt
specifier|static
name|wchar_t
modifier|*
name|widestr
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|wideidx
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|widesz
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The last keyword seen.  This is useful to trigger the special lexer rules  * for "copy" and also collating symbols and elements.  */
end_comment

begin_decl_stmt
name|int
name|last_kw
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|category
init|=
name|T_END
decl_stmt|;
end_decl_stmt

begin_struct
specifier|static
struct|struct
name|token
block|{
name|int
name|id
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|}
name|keywords
index|[]
init|=
block|{
block|{
name|T_COM_CHAR
block|,
literal|"comment_char"
block|}
block|,
block|{
name|T_ESC_CHAR
block|,
literal|"escape_char"
block|}
block|,
block|{
name|T_END
block|,
literal|"END"
block|}
block|,
block|{
name|T_COPY
block|,
literal|"copy"
block|}
block|,
block|{
name|T_MESSAGES
block|,
literal|"LC_MESSAGES"
block|}
block|,
block|{
name|T_YESSTR
block|,
literal|"yesstr"
block|}
block|,
block|{
name|T_YESEXPR
block|,
literal|"yesexpr"
block|}
block|,
block|{
name|T_NOSTR
block|,
literal|"nostr"
block|}
block|,
block|{
name|T_NOEXPR
block|,
literal|"noexpr"
block|}
block|,
block|{
name|T_MONETARY
block|,
literal|"LC_MONETARY"
block|}
block|,
block|{
name|T_INT_CURR_SYMBOL
block|,
literal|"int_curr_symbol"
block|}
block|,
block|{
name|T_CURRENCY_SYMBOL
block|,
literal|"currency_symbol"
block|}
block|,
block|{
name|T_MON_DECIMAL_POINT
block|,
literal|"mon_decimal_point"
block|}
block|,
block|{
name|T_MON_THOUSANDS_SEP
block|,
literal|"mon_thousands_sep"
block|}
block|,
block|{
name|T_POSITIVE_SIGN
block|,
literal|"positive_sign"
block|}
block|,
block|{
name|T_NEGATIVE_SIGN
block|,
literal|"negative_sign"
block|}
block|,
block|{
name|T_MON_GROUPING
block|,
literal|"mon_grouping"
block|}
block|,
block|{
name|T_INT_FRAC_DIGITS
block|,
literal|"int_frac_digits"
block|}
block|,
block|{
name|T_FRAC_DIGITS
block|,
literal|"frac_digits"
block|}
block|,
block|{
name|T_P_CS_PRECEDES
block|,
literal|"p_cs_precedes"
block|}
block|,
block|{
name|T_P_SEP_BY_SPACE
block|,
literal|"p_sep_by_space"
block|}
block|,
block|{
name|T_N_CS_PRECEDES
block|,
literal|"n_cs_precedes"
block|}
block|,
block|{
name|T_N_SEP_BY_SPACE
block|,
literal|"n_sep_by_space"
block|}
block|,
block|{
name|T_P_SIGN_POSN
block|,
literal|"p_sign_posn"
block|}
block|,
block|{
name|T_N_SIGN_POSN
block|,
literal|"n_sign_posn"
block|}
block|,
block|{
name|T_INT_P_CS_PRECEDES
block|,
literal|"int_p_cs_precedes"
block|}
block|,
block|{
name|T_INT_N_CS_PRECEDES
block|,
literal|"int_n_cs_precedes"
block|}
block|,
block|{
name|T_INT_P_SEP_BY_SPACE
block|,
literal|"int_p_sep_by_space"
block|}
block|,
block|{
name|T_INT_N_SEP_BY_SPACE
block|,
literal|"int_n_sep_by_space"
block|}
block|,
block|{
name|T_INT_P_SIGN_POSN
block|,
literal|"int_p_sign_posn"
block|}
block|,
block|{
name|T_INT_N_SIGN_POSN
block|,
literal|"int_n_sign_posn"
block|}
block|,
block|{
name|T_COLLATE
block|,
literal|"LC_COLLATE"
block|}
block|,
block|{
name|T_COLLATING_SYMBOL
block|,
literal|"collating-symbol"
block|}
block|,
block|{
name|T_COLLATING_ELEMENT
block|,
literal|"collating-element"
block|}
block|,
block|{
name|T_FROM
block|,
literal|"from"
block|}
block|,
block|{
name|T_ORDER_START
block|,
literal|"order_start"
block|}
block|,
block|{
name|T_ORDER_END
block|,
literal|"order_end"
block|}
block|,
block|{
name|T_FORWARD
block|,
literal|"forward"
block|}
block|,
block|{
name|T_BACKWARD
block|,
literal|"backward"
block|}
block|,
block|{
name|T_POSITION
block|,
literal|"position"
block|}
block|,
block|{
name|T_IGNORE
block|,
literal|"IGNORE"
block|}
block|,
block|{
name|T_UNDEFINED
block|,
literal|"UNDEFINED"
block|}
block|,
block|{
name|T_NUMERIC
block|,
literal|"LC_NUMERIC"
block|}
block|,
block|{
name|T_DECIMAL_POINT
block|,
literal|"decimal_point"
block|}
block|,
block|{
name|T_THOUSANDS_SEP
block|,
literal|"thousands_sep"
block|}
block|,
block|{
name|T_GROUPING
block|,
literal|"grouping"
block|}
block|,
block|{
name|T_TIME
block|,
literal|"LC_TIME"
block|}
block|,
block|{
name|T_ABDAY
block|,
literal|"abday"
block|}
block|,
block|{
name|T_DAY
block|,
literal|"day"
block|}
block|,
block|{
name|T_ABMON
block|,
literal|"abmon"
block|}
block|,
block|{
name|T_MON
block|,
literal|"mon"
block|}
block|,
block|{
name|T_D_T_FMT
block|,
literal|"d_t_fmt"
block|}
block|,
block|{
name|T_D_FMT
block|,
literal|"d_fmt"
block|}
block|,
block|{
name|T_T_FMT
block|,
literal|"t_fmt"
block|}
block|,
block|{
name|T_AM_PM
block|,
literal|"am_pm"
block|}
block|,
block|{
name|T_T_FMT_AMPM
block|,
literal|"t_fmt_ampm"
block|}
block|,
block|{
name|T_ERA
block|,
literal|"era"
block|}
block|,
block|{
name|T_ERA_D_FMT
block|,
literal|"era_d_fmt"
block|}
block|,
block|{
name|T_ERA_T_FMT
block|,
literal|"era_t_fmt"
block|}
block|,
block|{
name|T_ERA_D_T_FMT
block|,
literal|"era_d_t_fmt"
block|}
block|,
block|{
name|T_ALT_DIGITS
block|,
literal|"alt_digits"
block|}
block|,
block|{
name|T_CTYPE
block|,
literal|"LC_CTYPE"
block|}
block|,
block|{
name|T_ISUPPER
block|,
literal|"upper"
block|}
block|,
block|{
name|T_ISLOWER
block|,
literal|"lower"
block|}
block|,
block|{
name|T_ISALPHA
block|,
literal|"alpha"
block|}
block|,
block|{
name|T_ISDIGIT
block|,
literal|"digit"
block|}
block|,
block|{
name|T_ISPUNCT
block|,
literal|"punct"
block|}
block|,
block|{
name|T_ISXDIGIT
block|,
literal|"xdigit"
block|}
block|,
block|{
name|T_ISSPACE
block|,
literal|"space"
block|}
block|,
block|{
name|T_ISPRINT
block|,
literal|"print"
block|}
block|,
block|{
name|T_ISGRAPH
block|,
literal|"graph"
block|}
block|,
block|{
name|T_ISBLANK
block|,
literal|"blank"
block|}
block|,
block|{
name|T_ISCNTRL
block|,
literal|"cntrl"
block|}
block|,
comment|/* 	 * These entries are local additions, and not specified by 	 * TOG.  Note that they are not guaranteed to be accurate for 	 * all locales, and so applications should not depend on them. 	 */
block|{
name|T_ISSPECIAL
block|,
literal|"special"
block|}
block|,
block|{
name|T_ISENGLISH
block|,
literal|"english"
block|}
block|,
block|{
name|T_ISPHONOGRAM
block|,
literal|"phonogram"
block|}
block|,
block|{
name|T_ISIDEOGRAM
block|,
literal|"ideogram"
block|}
block|,
block|{
name|T_ISNUMBER
block|,
literal|"number"
block|}
block|,
comment|/* 	 * We have to support this in the grammar, but it would be a 	 * syntax error to define a character as one of these without 	 * also defining it as an alpha or digit.  We ignore it in our 	 * parsing. 	 */
block|{
name|T_ISALNUM
block|,
literal|"alnum"
block|}
block|,
block|{
name|T_TOUPPER
block|,
literal|"toupper"
block|}
block|,
block|{
name|T_TOLOWER
block|,
literal|"tolower"
block|}
block|,
comment|/* 	 * These are keywords used in the charmap file.  Note that 	 * Solaris originally used angle brackets to wrap some of them, 	 * but we removed that to simplify our parser.  The first of these 	 * items are "global items." 	 */
block|{
name|T_CHARMAP
block|,
literal|"CHARMAP"
block|}
block|,
block|{
name|T_WIDTH
block|,
literal|"WIDTH"
block|}
block|,
block|{
operator|-
literal|1
block|,
name|NULL
block|}
block|, }
struct|;
end_struct

begin_comment
comment|/*  * These special words are only used in a charmap file, enclosed in<>.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|token
name|symwords
index|[]
init|=
block|{
block|{
name|T_COM_CHAR
block|,
literal|"comment_char"
block|}
block|,
block|{
name|T_ESC_CHAR
block|,
literal|"escape_char"
block|}
block|,
block|{
name|T_CODE_SET
block|,
literal|"code_set_name"
block|}
block|,
block|{
name|T_MB_CUR_MAX
block|,
literal|"mb_cur_max"
block|}
block|,
block|{
name|T_MB_CUR_MIN
block|,
literal|"mb_cur_min"
block|}
block|,
block|{
operator|-
literal|1
block|,
name|NULL
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|categories
index|[]
init|=
block|{
name|T_CHARMAP
block|,
name|T_CTYPE
block|,
name|T_COLLATE
block|,
name|T_MESSAGES
block|,
name|T_MONETARY
block|,
name|T_NUMERIC
block|,
name|T_TIME
block|,
name|T_WIDTH
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|reset_scanner
parameter_list|(
specifier|const
name|char
modifier|*
name|fname
parameter_list|)
block|{
if|if
condition|(
name|fname
operator|==
name|NULL
condition|)
block|{
name|filename
operator|=
literal|"<stdin>"
expr_stmt|;
name|is_stdin
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|is_stdin
condition|)
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|input
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|input
operator|=
name|fopen
argument_list|(
name|fname
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
literal|"fopen"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|4
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|is_stdin
operator|=
literal|0
expr_stmt|;
block|}
name|filename
operator|=
name|fname
expr_stmt|;
block|}
name|com_char
operator|=
literal|'#'
expr_stmt|;
name|esc_char
operator|=
literal|'\\'
expr_stmt|;
name|instring
operator|=
literal|0
expr_stmt|;
name|escaped
operator|=
literal|0
expr_stmt|;
name|lineno
operator|=
literal|1
expr_stmt|;
name|nextline
operator|=
literal|1
expr_stmt|;
name|tokidx
operator|=
literal|0
expr_stmt|;
name|wideidx
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|hex
parameter_list|(
name|x
parameter_list|)
define|\
value|(isdigit(x) ? (x - '0') : ((islower(x) ? (x - 'a') : (x - 'A')) + 10))
end_define

begin_define
define|#
directive|define
name|isodigit
parameter_list|(
name|x
parameter_list|)
value|((x>= '0')&& (x<= '7'))
end_define

begin_function
specifier|static
name|int
name|scanc
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
if|if
condition|(
name|is_stdin
condition|)
name|c
operator|=
name|getc
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
else|else
name|c
operator|=
name|getc
argument_list|(
name|input
argument_list|)
expr_stmt|;
name|lineno
operator|=
name|nextline
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
name|nextline
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|c
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|unscanc
parameter_list|(
name|int
name|c
parameter_list|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
name|nextline
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|ungetc
argument_list|(
name|c
argument_list|,
name|is_stdin
condition|?
name|stdin
else|:
name|input
argument_list|)
operator|<
literal|0
condition|)
block|{
name|yyerror
argument_list|(
literal|"ungetc failed"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|scan_hex_byte
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|c1
decl_stmt|,
name|c2
decl_stmt|;
name|int
name|v
decl_stmt|;
name|c1
operator|=
name|scanc
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|isxdigit
argument_list|(
name|c1
argument_list|)
condition|)
block|{
name|yyerror
argument_list|(
literal|"malformed hex digit"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|c2
operator|=
name|scanc
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|isxdigit
argument_list|(
name|c2
argument_list|)
condition|)
block|{
name|yyerror
argument_list|(
literal|"malformed hex digit"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|v
operator|=
operator|(
operator|(
name|hex
argument_list|(
name|c1
argument_list|)
operator|<<
literal|4
operator|)
operator||
name|hex
argument_list|(
name|c2
argument_list|)
operator|)
expr_stmt|;
return|return
operator|(
name|v
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|scan_dec_byte
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|c1
decl_stmt|,
name|c2
decl_stmt|,
name|c3
decl_stmt|;
name|int
name|b
decl_stmt|;
name|c1
operator|=
name|scanc
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
name|c1
argument_list|)
condition|)
block|{
name|yyerror
argument_list|(
literal|"malformed decimal digit"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|b
operator|=
name|c1
operator|-
literal|'0'
expr_stmt|;
name|c2
operator|=
name|scanc
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
name|c2
argument_list|)
condition|)
block|{
name|yyerror
argument_list|(
literal|"malformed decimal digit"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|b
operator|*=
literal|10
expr_stmt|;
name|b
operator|+=
operator|(
name|c2
operator|-
literal|'0'
operator|)
expr_stmt|;
name|c3
operator|=
name|scanc
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
name|c3
argument_list|)
condition|)
block|{
name|unscanc
argument_list|(
name|c3
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|b
operator|*=
literal|10
expr_stmt|;
name|b
operator|+=
operator|(
name|c3
operator|-
literal|'0'
operator|)
expr_stmt|;
block|}
return|return
operator|(
name|b
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|scan_oct_byte
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|c1
decl_stmt|,
name|c2
decl_stmt|,
name|c3
decl_stmt|;
name|int
name|b
decl_stmt|;
name|b
operator|=
literal|0
expr_stmt|;
name|c1
operator|=
name|scanc
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|isodigit
argument_list|(
name|c1
argument_list|)
condition|)
block|{
name|yyerror
argument_list|(
literal|"malformed octal digit"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|b
operator|=
name|c1
operator|-
literal|'0'
expr_stmt|;
name|c2
operator|=
name|scanc
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|isodigit
argument_list|(
name|c2
argument_list|)
condition|)
block|{
name|yyerror
argument_list|(
literal|"malformed octal digit"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|b
operator|*=
literal|8
expr_stmt|;
name|b
operator|+=
operator|(
name|c2
operator|-
literal|'0'
operator|)
expr_stmt|;
name|c3
operator|=
name|scanc
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|isodigit
argument_list|(
name|c3
argument_list|)
condition|)
block|{
name|unscanc
argument_list|(
name|c3
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|b
operator|*=
literal|8
expr_stmt|;
name|b
operator|+=
operator|(
name|c3
operator|-
literal|'0'
operator|)
expr_stmt|;
block|}
return|return
operator|(
name|b
operator|)
return|;
block|}
end_function

begin_function
name|void
name|add_tok
parameter_list|(
name|int
name|c
parameter_list|)
block|{
if|if
condition|(
operator|(
name|tokidx
operator|+
literal|1
operator|)
operator|>=
name|toksz
condition|)
block|{
name|toksz
operator|+=
literal|64
expr_stmt|;
if|if
condition|(
operator|(
name|token
operator|=
name|realloc
argument_list|(
name|token
argument_list|,
name|toksz
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|yyerror
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
name|tokidx
operator|=
literal|0
expr_stmt|;
name|toksz
operator|=
literal|0
expr_stmt|;
return|return;
block|}
block|}
name|token
index|[
name|tokidx
operator|++
index|]
operator|=
operator|(
name|char
operator|)
name|c
expr_stmt|;
name|token
index|[
name|tokidx
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|add_wcs
parameter_list|(
name|wchar_t
name|c
parameter_list|)
block|{
if|if
condition|(
operator|(
name|wideidx
operator|+
literal|1
operator|)
operator|>=
name|widesz
condition|)
block|{
name|widesz
operator|+=
literal|64
expr_stmt|;
name|widestr
operator|=
name|realloc
argument_list|(
name|widestr
argument_list|,
operator|(
name|widesz
operator|*
sizeof|sizeof
argument_list|(
name|wchar_t
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|widestr
operator|==
name|NULL
condition|)
block|{
name|yyerror
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
name|wideidx
operator|=
literal|0
expr_stmt|;
name|widesz
operator|=
literal|0
expr_stmt|;
return|return;
block|}
block|}
name|widestr
index|[
name|wideidx
operator|++
index|]
operator|=
name|c
expr_stmt|;
name|widestr
index|[
name|wideidx
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|wchar_t
modifier|*
name|get_wcs
parameter_list|(
name|void
parameter_list|)
block|{
name|wchar_t
modifier|*
name|ws
init|=
name|widestr
decl_stmt|;
name|wideidx
operator|=
literal|0
expr_stmt|;
name|widestr
operator|=
name|NULL
expr_stmt|;
name|widesz
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ws
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|ws
operator|=
name|wcsdup
argument_list|(
literal|L""
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|yyerror
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|ws
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_byte
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|scanc
argument_list|()
operator|)
operator|!=
name|esc_char
condition|)
block|{
name|unscanc
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
operator|(
name|EOF
operator|)
return|;
block|}
name|c
operator|=
name|scanc
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'d'
case|:
case|case
literal|'D'
case|:
return|return
operator|(
name|scan_dec_byte
argument_list|()
operator|)
return|;
case|case
literal|'x'
case|:
case|case
literal|'X'
case|:
return|return
operator|(
name|scan_hex_byte
argument_list|()
operator|)
return|;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
comment|/* put the character back so we can get it */
name|unscanc
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
operator|(
name|scan_oct_byte
argument_list|()
operator|)
return|;
default|default:
name|unscanc
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|unscanc
argument_list|(
name|esc_char
argument_list|)
expr_stmt|;
return|return
operator|(
name|EOF
operator|)
return|;
block|}
block|}
end_function

begin_function
name|int
name|get_escaped
parameter_list|(
name|int
name|c
parameter_list|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'n'
case|:
return|return
operator|(
literal|'\n'
operator|)
return|;
case|case
literal|'r'
case|:
return|return
operator|(
literal|'\r'
operator|)
return|;
case|case
literal|'t'
case|:
return|return
operator|(
literal|'\t'
operator|)
return|;
case|case
literal|'f'
case|:
return|return
operator|(
literal|'\f'
operator|)
return|;
case|case
literal|'v'
case|:
return|return
operator|(
literal|'\v'
operator|)
return|;
case|case
literal|'b'
case|:
return|return
operator|(
literal|'\b'
operator|)
return|;
case|case
literal|'a'
case|:
return|return
operator|(
literal|'\a'
operator|)
return|;
default|default:
return|return
operator|(
name|c
operator|)
return|;
block|}
block|}
end_function

begin_function
name|int
name|get_wide
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|char
name|mbs
index|[
name|MB_LEN_MAX
operator|+
literal|1
index|]
init|=
literal|""
decl_stmt|;
specifier|static
name|int
name|mbi
init|=
literal|0
decl_stmt|;
name|int
name|c
decl_stmt|;
name|wchar_t
name|wc
decl_stmt|;
if|if
condition|(
name|mb_cur_max
operator|>=
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|mbs
argument_list|)
condition|)
block|{
name|yyerror
argument_list|(
literal|"max multibyte character size too big"
argument_list|)
expr_stmt|;
name|mbi
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|T_NULL
operator|)
return|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|mbi
operator|==
name|mb_cur_max
operator|)
operator|||
operator|(
operator|(
name|c
operator|=
name|get_byte
argument_list|()
operator|)
operator|==
name|EOF
operator|)
condition|)
block|{
comment|/* 			 * end of the byte sequence reached, but no 			 * valid wide decoding.  fatal error. 			 */
name|mbi
operator|=
literal|0
expr_stmt|;
name|yyerror
argument_list|(
literal|"not a valid character encoding"
argument_list|)
expr_stmt|;
return|return
operator|(
name|T_NULL
operator|)
return|;
block|}
name|mbs
index|[
name|mbi
operator|++
index|]
operator|=
name|c
expr_stmt|;
name|mbs
index|[
name|mbi
index|]
operator|=
literal|0
expr_stmt|;
comment|/* does it decode? */
if|if
condition|(
name|to_wide
argument_list|(
operator|&
name|wc
argument_list|,
name|mbs
argument_list|)
operator|>=
literal|0
condition|)
block|{
break|break;
block|}
block|}
name|mbi
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|category
operator|!=
name|T_CHARMAP
operator|)
operator|&&
operator|(
name|category
operator|!=
name|T_WIDTH
operator|)
condition|)
block|{
if|if
condition|(
name|check_charmap
argument_list|(
name|wc
argument_list|)
operator|<
literal|0
condition|)
block|{
name|yyerror
argument_list|(
literal|"no symbolic name for character"
argument_list|)
expr_stmt|;
return|return
operator|(
name|T_NULL
operator|)
return|;
block|}
block|}
name|yylval
operator|.
name|wc
operator|=
name|wc
expr_stmt|;
return|return
operator|(
name|T_CHAR
operator|)
return|;
block|}
end_function

begin_function
name|int
name|get_symbol
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|scanc
argument_list|()
operator|)
operator|!=
name|EOF
condition|)
block|{
if|if
condition|(
name|escaped
condition|)
block|{
name|escaped
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
continue|continue;
name|add_tok
argument_list|(
name|get_escaped
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|c
operator|==
name|esc_char
condition|)
block|{
name|escaped
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
comment|/* well that's strange! */
name|yyerror
argument_list|(
literal|"unterminated symbolic name"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|c
operator|==
literal|'>'
condition|)
block|{
comment|/* end of symbol */
comment|/* 			 * This restarts the token from the beginning 			 * the next time we scan a character.  (This 			 * token is complete.) 			 */
if|if
condition|(
name|token
operator|==
name|NULL
condition|)
block|{
name|yyerror
argument_list|(
literal|"missing symbolic name"
argument_list|)
expr_stmt|;
return|return
operator|(
name|T_NULL
operator|)
return|;
block|}
name|tokidx
operator|=
literal|0
expr_stmt|;
comment|/* 			 * A few symbols are handled as keywords outside 			 * of the normal categories. 			 */
if|if
condition|(
name|category
operator|==
name|T_END
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|symwords
index|[
name|i
index|]
operator|.
name|name
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|token
argument_list|,
name|symwords
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|last_kw
operator|=
name|symwords
index|[
name|i
index|]
operator|.
name|id
expr_stmt|;
return|return
operator|(
name|last_kw
operator|)
return|;
block|}
block|}
block|}
comment|/* 			 * Contextual rule: Only literal characters are 			 * permitted in CHARMAP.  Anywhere else the symbolic 			 * forms are fine. 			 */
if|if
condition|(
operator|(
name|category
operator|!=
name|T_CHARMAP
operator|)
operator|&&
operator|(
name|lookup_charmap
argument_list|(
name|token
argument_list|,
operator|&
name|yylval
operator|.
name|wc
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
return|return
operator|(
name|T_CHAR
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|yylval
operator|.
name|collsym
operator|=
name|lookup_collsym
argument_list|(
name|token
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
return|return
operator|(
name|T_COLLSYM
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|yylval
operator|.
name|collelem
operator|=
name|lookup_collelem
argument_list|(
name|token
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
return|return
operator|(
name|T_COLLELEM
operator|)
return|;
block|}
comment|/* its an undefined symbol */
name|yylval
operator|.
name|token
operator|=
name|strdup
argument_list|(
name|token
argument_list|)
expr_stmt|;
name|token
operator|=
name|NULL
expr_stmt|;
name|toksz
operator|=
literal|0
expr_stmt|;
name|tokidx
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|T_SYMBOL
operator|)
return|;
block|}
name|add_tok
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
name|yyerror
argument_list|(
literal|"unterminated symbolic name"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EOF
operator|)
return|;
block|}
end_function

begin_function
name|int
name|get_category
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|category
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|consume_token
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|len
init|=
name|tokidx
decl_stmt|;
name|int
name|i
decl_stmt|;
name|tokidx
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|token
operator|==
name|NULL
condition|)
return|return
operator|(
name|T_NULL
operator|)
return|;
comment|/* 	 * this one is special, because we don't want it to alter the 	 * last_kw field. 	 */
if|if
condition|(
name|strcmp
argument_list|(
name|token
argument_list|,
literal|"..."
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|T_ELLIPSIS
operator|)
return|;
block|}
comment|/* search for reserved words first */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|keywords
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
block|{
name|int
name|j
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|keywords
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|token
argument_list|)
operator|!=
literal|0
condition|)
block|{
continue|continue;
block|}
name|last_kw
operator|=
name|keywords
index|[
name|i
index|]
operator|.
name|id
expr_stmt|;
comment|/* clear the top level category if we're done with it */
if|if
condition|(
name|last_kw
operator|==
name|T_END
condition|)
block|{
name|category
operator|=
name|T_END
expr_stmt|;
block|}
comment|/* set the top level category if we're changing */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|categories
index|[
name|j
index|]
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|categories
index|[
name|j
index|]
operator|!=
name|last_kw
condition|)
continue|continue;
name|category
operator|=
name|last_kw
expr_stmt|;
block|}
return|return
operator|(
name|keywords
index|[
name|i
index|]
operator|.
name|id
operator|)
return|;
block|}
comment|/* maybe its a numeric constant? */
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|token
argument_list|)
operator|||
operator|(
operator|*
name|token
operator|==
literal|'-'
operator|&&
name|isdigit
argument_list|(
name|token
index|[
literal|1
index|]
argument_list|)
operator|)
condition|)
block|{
name|char
modifier|*
name|eptr
decl_stmt|;
name|yylval
operator|.
name|num
operator|=
name|strtol
argument_list|(
name|token
argument_list|,
operator|&
name|eptr
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|eptr
operator|!=
literal|0
condition|)
name|yyerror
argument_list|(
literal|"malformed number"
argument_list|)
expr_stmt|;
return|return
operator|(
name|T_NUMBER
operator|)
return|;
block|}
comment|/* 	 * A single lone character is treated as a character literal. 	 * To avoid duplication of effort, we stick in the charmap. 	 */
if|if
condition|(
name|len
operator|==
literal|1
condition|)
block|{
name|yylval
operator|.
name|wc
operator|=
name|token
index|[
literal|0
index|]
expr_stmt|;
return|return
operator|(
name|T_CHAR
operator|)
return|;
block|}
comment|/* anything else is treated as a symbolic name */
name|yylval
operator|.
name|token
operator|=
name|strdup
argument_list|(
name|token
argument_list|)
expr_stmt|;
name|token
operator|=
name|NULL
expr_stmt|;
name|toksz
operator|=
literal|0
expr_stmt|;
name|tokidx
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|T_NAME
operator|)
return|;
block|}
end_function

begin_function
name|void
name|scan_to_eol
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|scanc
argument_list|()
operator|)
operator|!=
literal|'\n'
condition|)
block|{
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
comment|/* end of file without newline! */
name|errf
argument_list|(
literal|"missing newline"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|assert
argument_list|(
name|c
operator|==
literal|'\n'
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|yylex
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|scanc
argument_list|()
operator|)
operator|!=
name|EOF
condition|)
block|{
comment|/* special handling for quoted string */
if|if
condition|(
name|instring
condition|)
block|{
if|if
condition|(
name|escaped
condition|)
block|{
name|escaped
operator|=
literal|0
expr_stmt|;
comment|/* if newline, just eat and forget it */
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
continue|continue;
if|if
condition|(
name|strchr
argument_list|(
literal|"xXd01234567"
argument_list|,
name|c
argument_list|)
condition|)
block|{
name|unscanc
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|unscanc
argument_list|(
name|esc_char
argument_list|)
expr_stmt|;
return|return
operator|(
name|get_wide
argument_list|()
operator|)
return|;
block|}
name|yylval
operator|.
name|wc
operator|=
name|get_escaped
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
operator|(
name|T_CHAR
operator|)
return|;
block|}
if|if
condition|(
name|c
operator|==
name|esc_char
condition|)
block|{
name|escaped
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'<'
case|:
return|return
operator|(
name|get_symbol
argument_list|()
operator|)
return|;
case|case
literal|'>'
case|:
comment|/* oops! should generate syntax error  */
return|return
operator|(
name|T_GT
operator|)
return|;
case|case
literal|'"'
case|:
name|instring
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|T_QUOTE
operator|)
return|;
default|default:
name|yylval
operator|.
name|wc
operator|=
name|c
expr_stmt|;
return|return
operator|(
name|T_CHAR
operator|)
return|;
block|}
block|}
comment|/* escaped characters first */
if|if
condition|(
name|escaped
condition|)
block|{
name|escaped
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
comment|/* eat the newline */
continue|continue;
block|}
name|hadtok
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|tokidx
condition|)
block|{
comment|/* an escape mid-token is nonsense */
return|return
operator|(
name|T_NULL
operator|)
return|;
block|}
comment|/* numeric escapes are treated as wide characters */
if|if
condition|(
name|strchr
argument_list|(
literal|"xXd01234567"
argument_list|,
name|c
argument_list|)
condition|)
block|{
name|unscanc
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|unscanc
argument_list|(
name|esc_char
argument_list|)
expr_stmt|;
return|return
operator|(
name|get_wide
argument_list|()
operator|)
return|;
block|}
name|add_tok
argument_list|(
name|get_escaped
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* if it is the escape charter itself note it */
if|if
condition|(
name|c
operator|==
name|esc_char
condition|)
block|{
name|escaped
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
comment|/* remove from the comment char to end of line */
if|if
condition|(
name|c
operator|==
name|com_char
condition|)
block|{
while|while
condition|(
name|c
operator|!=
literal|'\n'
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
name|scanc
argument_list|()
operator|)
operator|==
name|EOF
condition|)
block|{
comment|/* end of file without newline! */
return|return
operator|(
name|EOF
operator|)
return|;
block|}
block|}
name|assert
argument_list|(
name|c
operator|==
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hadtok
condition|)
block|{
comment|/* 				 * If there were no tokens on this line, 				 * then just pretend it didn't exist at all. 				 */
continue|continue;
block|}
name|hadtok
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|T_NL
operator|)
return|;
block|}
if|if
condition|(
name|strchr
argument_list|(
literal|" \t\n;()<>,\""
argument_list|,
name|c
argument_list|)
operator|&&
operator|(
name|tokidx
operator|!=
literal|0
operator|)
condition|)
block|{
comment|/* 			 * These are all token delimiters.  If there 			 * is a token already in progress, we need to 			 * process it. 			 */
name|unscanc
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
operator|(
name|consume_token
argument_list|()
operator|)
return|;
block|}
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\n'
case|:
if|if
condition|(
operator|!
name|hadtok
condition|)
block|{
comment|/* 				 * If the line was completely devoid of tokens, 				 * then just ignore it. 				 */
continue|continue;
block|}
comment|/* we're starting a new line, reset the token state */
name|hadtok
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|T_NL
operator|)
return|;
case|case
literal|','
case|:
name|hadtok
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|T_COMMA
operator|)
return|;
case|case
literal|';'
case|:
name|hadtok
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|T_SEMI
operator|)
return|;
case|case
literal|'('
case|:
name|hadtok
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|T_LPAREN
operator|)
return|;
case|case
literal|')'
case|:
name|hadtok
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|T_RPAREN
operator|)
return|;
case|case
literal|'>'
case|:
name|hadtok
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|T_GT
operator|)
return|;
case|case
literal|'<'
case|:
comment|/* symbol start! */
name|hadtok
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|get_symbol
argument_list|()
operator|)
return|;
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
comment|/* whitespace, just ignore it */
continue|continue;
case|case
literal|'"'
case|:
name|hadtok
operator|=
literal|1
expr_stmt|;
name|instring
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|T_QUOTE
operator|)
return|;
default|default:
name|hadtok
operator|=
literal|1
expr_stmt|;
name|add_tok
argument_list|(
name|c
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
return|return
operator|(
name|EOF
operator|)
return|;
block|}
end_function

begin_function
name|void
name|yyerror
parameter_list|(
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %d: error: %s\n"
argument_list|,
name|filename
argument_list|,
name|lineno
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|4
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|errf
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|char
modifier|*
name|msg
decl_stmt|;
name|va_list
name|va
decl_stmt|;
name|va_start
argument_list|(
name|va
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|vasprintf
argument_list|(
operator|&
name|msg
argument_list|,
name|fmt
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|va
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %d: error: %s\n"
argument_list|,
name|filename
argument_list|,
name|lineno
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|4
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|warn
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|char
modifier|*
name|msg
decl_stmt|;
name|va_list
name|va
decl_stmt|;
name|va_start
argument_list|(
name|va
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|vasprintf
argument_list|(
operator|&
name|msg
argument_list|,
name|fmt
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|va
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %d: warning: %s\n"
argument_list|,
name|filename
argument_list|,
name|lineno
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|warnings
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|warnok
condition|)
name|exit
argument_list|(
literal|4
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

