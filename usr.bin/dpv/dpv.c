begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2013-2014 Devin Teske<dteske@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *   * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_define
define|#
directive|define
name|_BSD_SOURCE
end_define

begin_comment
comment|/* to get dprintf() prototype in stdio.h below */
end_comment

begin_include
include|#
directive|include
file|<dialog.h>
end_include

begin_include
include|#
directive|include
file|<dpv.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<string_m.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"dpv_util.h"
end_include

begin_comment
comment|/* Debugging */
end_comment

begin_decl_stmt
specifier|static
name|uint8_t
name|debug
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Data to process */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|dpv_file_node
modifier|*
name|file_list
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|nfiles
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Data processing */
end_comment

begin_decl_stmt
specifier|static
name|uint8_t
name|line_mode
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint8_t
name|no_overrun
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fd
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|output_type
init|=
name|DPV_OUTPUT_NONE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|bsize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|rpath
index|[
name|PATH_MAX
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Extra display information */
end_comment

begin_decl_stmt
specifier|static
name|uint8_t
name|multiple
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* `-m' */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|pgm
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* set to argv[0] by main() */
end_comment

begin_comment
comment|/* Function prototypes */
end_comment

begin_function_decl
specifier|static
name|void
name|sig_int
parameter_list|(
name|int
name|sig
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|operate_common
parameter_list|(
name|struct
name|dpv_file_node
modifier|*
name|file
parameter_list|,
name|int
name|out
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|operate_on_bytes
parameter_list|(
name|struct
name|dpv_file_node
modifier|*
name|file
parameter_list|,
name|int
name|out
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|operate_on_lines
parameter_list|(
name|struct
name|dpv_file_node
modifier|*
name|file
parameter_list|,
name|int
name|out
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|operate_common
parameter_list|(
name|struct
name|dpv_file_node
modifier|*
name|file
parameter_list|,
name|int
name|out
parameter_list|)
block|{
name|struct
name|stat
name|sb
decl_stmt|;
comment|/* Open the file if necessary */
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|multiple
condition|)
block|{
comment|/* Resolve the file path and attempt to open it */
if|if
condition|(
name|realpath
argument_list|(
name|file
operator|->
name|path
argument_list|,
name|rpath
argument_list|)
operator|==
literal|0
operator|||
operator|(
name|fd
operator|=
name|open
argument_list|(
name|rpath
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"%s"
argument_list|,
name|file
operator|->
name|path
argument_list|)
expr_stmt|;
name|file
operator|->
name|status
operator|=
name|DPV_STATUS_FAILED
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/* Assume stdin, but if that's a TTY instead use the 			 * highest numbered file descriptor (obtained by 			 * generating new fd and then decrementing). 			 * 			 * NB: /dev/stdin should always be open(2)'able 			 */
name|fd
operator|=
name|STDIN_FILENO
expr_stmt|;
if|if
condition|(
name|isatty
argument_list|(
name|fd
argument_list|)
condition|)
block|{
name|fd
operator|=
name|open
argument_list|(
literal|"/dev/stdin"
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
operator|--
argument_list|)
expr_stmt|;
block|}
comment|/* This answer might be wrong, if dpv(3) has (by 			 * request) opened an output file or pipe. If we 			 * told dpv(3) to open a file, subtract one from 			 * previous answer. If instead we told dpv(3) to 			 * prepare a pipe output, subtract two. 			 */
switch|switch
condition|(
name|output_type
condition|)
block|{
case|case
name|DPV_OUTPUT_FILE
case|:
name|fd
operator|-=
literal|1
expr_stmt|;
break|break;
case|case
name|DPV_OUTPUT_SHELL
case|:
name|fd
operator|-=
literal|2
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* Allocate buffer if necessary */
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
comment|/* Use output block size as buffer size if available */
if|if
condition|(
name|out
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|fstat
argument_list|(
name|out
argument_list|,
operator|&
name|sb
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"%i"
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|file
operator|->
name|status
operator|=
name|DPV_STATUS_FAILED
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|S_ISREG
argument_list|(
name|sb
operator|.
name|st_mode
argument_list|)
condition|)
block|{
if|if
condition|(
name|sysconf
argument_list|(
name|_SC_PHYS_PAGES
argument_list|)
operator|>
name|PHYSPAGES_THRESHOLD
condition|)
name|bsize
operator|=
name|MIN
argument_list|(
name|BUFSIZE_MAX
argument_list|,
name|MAXPHYS
operator|*
literal|8
argument_list|)
expr_stmt|;
else|else
name|bsize
operator|=
name|BUFSIZE_SMALL
expr_stmt|;
block|}
else|else
name|bsize
operator|=
name|MAX
argument_list|(
name|sb
operator|.
name|st_blksize
argument_list|,
operator|(
name|blksize_t
operator|)
name|sysconf
argument_list|(
name|_SC_PAGESIZE
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|bsize
operator|=
name|MIN
argument_list|(
name|BUFSIZE_MAX
argument_list|,
name|MAXPHYS
operator|*
literal|8
argument_list|)
expr_stmt|;
comment|/* Attempt to allocate */
if|if
condition|(
operator|(
name|buf
operator|=
name|malloc
argument_list|(
name|bsize
operator|+
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|end_dialog
argument_list|()
expr_stmt|;
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"Out of memory?!"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|operate_on_bytes
parameter_list|(
name|struct
name|dpv_file_node
modifier|*
name|file
parameter_list|,
name|int
name|out
parameter_list|)
block|{
name|int
name|progress
decl_stmt|;
name|ssize_t
name|r
decl_stmt|,
name|w
decl_stmt|;
if|if
condition|(
name|operate_common
argument_list|(
name|file
argument_list|,
name|out
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* [Re-]Fill the buffer */
if|if
condition|(
operator|(
name|r
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
name|bsize
argument_list|)
operator|)
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|fd
operator|!=
name|STDIN_FILENO
condition|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
name|file
operator|->
name|status
operator|=
name|DPV_STATUS_DONE
expr_stmt|;
return|return
operator|(
literal|100
operator|)
return|;
block|}
comment|/* [Re-]Dump the buffer */
if|if
condition|(
name|out
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|w
operator|=
name|write
argument_list|(
name|out
argument_list|,
name|buf
argument_list|,
name|r
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|end_dialog
argument_list|()
expr_stmt|;
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"output"
argument_list|)
expr_stmt|;
block|}
name|fsync
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
name|overall_read
operator|+=
name|r
expr_stmt|;
name|file
operator|->
name|read
operator|+=
name|r
expr_stmt|;
comment|/* Calculate percentage of completion (if possible) */
if|if
condition|(
name|file
operator|->
name|length
operator|>=
literal|0
condition|)
block|{
name|progress
operator|=
operator|(
name|file
operator|->
name|read
operator|*
literal|100
operator|/
operator|(
name|file
operator|->
name|length
operator|>
literal|0
condition|?
name|file
operator|->
name|length
else|:
literal|1
operator|)
operator|)
expr_stmt|;
comment|/* If no_overrun, do not return 100% until read>= length */
if|if
condition|(
name|no_overrun
operator|&&
name|progress
operator|==
literal|100
operator|&&
name|file
operator|->
name|read
operator|<
name|file
operator|->
name|length
condition|)
name|progress
operator|--
expr_stmt|;
return|return
operator|(
name|progress
operator|)
return|;
block|}
else|else
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|operate_on_lines
parameter_list|(
name|struct
name|dpv_file_node
modifier|*
name|file
parameter_list|,
name|int
name|out
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|progress
decl_stmt|;
name|ssize_t
name|r
decl_stmt|,
name|w
decl_stmt|;
if|if
condition|(
name|operate_common
argument_list|(
name|file
argument_list|,
name|out
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* [Re-]Fill the buffer */
if|if
condition|(
operator|(
name|r
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
name|bsize
argument_list|)
operator|)
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|fd
operator|!=
name|STDIN_FILENO
condition|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
name|file
operator|->
name|status
operator|=
name|DPV_STATUS_DONE
expr_stmt|;
return|return
operator|(
literal|100
operator|)
return|;
block|}
name|buf
index|[
name|r
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* [Re-]Dump the buffer */
if|if
condition|(
name|out
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|w
operator|=
name|write
argument_list|(
name|out
argument_list|,
name|buf
argument_list|,
name|r
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|end_dialog
argument_list|()
expr_stmt|;
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"output"
argument_list|)
expr_stmt|;
block|}
name|fsync
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
comment|/* Process the buffer for number of lines */
for|for
control|(
name|p
operator|=
name|buf
init|;
name|p
operator|!=
name|NULL
operator|&&
operator|*
name|p
operator|!=
literal|'\0'
condition|;
control|)
if|if
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|overall_read
operator|++
operator|,
name|p
operator|++
operator|,
name|file
operator|->
name|read
operator|++
expr_stmt|;
comment|/* Calculate percentage of completion (if possible) */
if|if
condition|(
name|file
operator|->
name|length
operator|>=
literal|0
condition|)
block|{
name|progress
operator|=
operator|(
name|file
operator|->
name|read
operator|*
literal|100
operator|/
name|file
operator|->
name|length
operator|)
expr_stmt|;
comment|/* If no_overrun, do not return 100% until read>= length */
if|if
condition|(
name|no_overrun
operator|&&
name|progress
operator|==
literal|100
operator|&&
name|file
operator|->
name|read
operator|<
name|file
operator|->
name|length
condition|)
name|progress
operator|--
expr_stmt|;
return|return
operator|(
name|progress
operator|)
return|;
block|}
else|else
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Takes a list of names that are to correspond to input streams coming from  * stdin or fifos and produces necessary config to drive dpv(3) `--gauge'  * widget. If the `-d' flag is used, output is instead send to terminal  * standard output (and the output can then be saved to a file, piped into  * custom [X]dialog(1) invocation, or whatever.  */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|char
name|dummy
decl_stmt|;
name|int
name|ch
decl_stmt|;
name|int
name|n
init|=
literal|0
decl_stmt|;
name|size_t
name|config_size
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|dpv_config
argument_list|)
decl_stmt|;
name|size_t
name|file_node_size
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|dpv_file_node
argument_list|)
decl_stmt|;
name|struct
name|dpv_config
modifier|*
name|config
decl_stmt|;
name|struct
name|dpv_file_node
modifier|*
name|curfile
decl_stmt|;
name|struct
name|sigaction
name|act
decl_stmt|;
name|pgm
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
comment|/* store a copy of invocation name */
comment|/* Allocate config structure */
if|if
condition|(
operator|(
name|config
operator|=
name|malloc
argument_list|(
name|config_size
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"Out of memory?!"
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|config
operator|)
argument_list|,
literal|'\0'
argument_list|,
name|config_size
argument_list|)
expr_stmt|;
comment|/* 	 * Process command-line options 	 */
while|while
condition|(
operator|(
name|ch
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"a:b:dDhi:I:lL:mn:No:p:P:t:TU:wx:X"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'a'
case|:
comment|/* additional message text to append */
if|if
condition|(
name|config
operator|->
name|aprompt
operator|==
name|NULL
condition|)
block|{
name|config
operator|->
name|aprompt
operator|=
name|malloc
argument_list|(
name|DPV_APROMPT_MAX
argument_list|)
expr_stmt|;
if|if
condition|(
name|config
operator|->
name|aprompt
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"Out of memory?!"
argument_list|)
expr_stmt|;
block|}
name|snprintf
argument_list|(
name|config
operator|->
name|aprompt
argument_list|,
name|DPV_APROMPT_MAX
argument_list|,
literal|"%s"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
comment|/* [X]dialog(1) backtitle */
if|if
condition|(
name|config
operator|->
name|backtitle
operator|!=
name|NULL
condition|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|config
operator|->
name|backtitle
argument_list|)
expr_stmt|;
name|config
operator|->
name|backtitle
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|optarg
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|config
operator|->
name|backtitle
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"Out of memory?!"
argument_list|)
expr_stmt|;
operator|*
operator|(
name|config
operator|->
name|backtitle
operator|)
operator|=
literal|'\0'
expr_stmt|;
name|strcat
argument_list|(
name|config
operator|->
name|backtitle
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
comment|/* debugging */
name|debug
operator|=
name|TRUE
expr_stmt|;
name|config
operator|->
name|debug
operator|=
name|debug
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
comment|/* use dialog(1) instead of libdialog */
name|config
operator|->
name|display_type
operator|=
name|DPV_DISPLAY_DIALOG
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
comment|/* help/usage */
name|usage
argument_list|()
expr_stmt|;
break|break;
comment|/* NOTREACHED */
case|case
literal|'i'
case|:
comment|/* status line format string for single-file */
name|config
operator|->
name|status_solo
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
comment|/* status line format string for many-files */
name|config
operator|->
name|status_many
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
comment|/* Line mode */
name|line_mode
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
comment|/* custom label size */
name|config
operator|->
name|label_size
operator|=
operator|(
name|int
operator|)
name|strtol
argument_list|(
name|optarg
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|config
operator|->
name|label_size
operator|==
literal|0
operator|&&
name|errno
operator|==
name|EINVAL
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"`-L' argument must be numeric"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|config
operator|->
name|label_size
operator|<
operator|-
literal|1
condition|)
name|config
operator|->
name|label_size
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
comment|/* enable multiple file arguments */
name|multiple
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
comment|/* `-o path' for sending data-read to file */
name|output_type
operator|=
name|DPV_OUTPUT_FILE
expr_stmt|;
name|config
operator|->
name|output_type
operator|=
name|DPV_OUTPUT_FILE
expr_stmt|;
name|config
operator|->
name|output
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
comment|/* custom number of files per `page' */
name|config
operator|->
name|display_limit
operator|=
operator|(
name|int
operator|)
name|strtol
argument_list|(
name|optarg
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|config
operator|->
name|display_limit
operator|==
literal|0
operator|&&
name|errno
operator|==
name|EINVAL
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"`-n' argument must be numeric"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|config
operator|->
name|display_limit
operator|<
literal|0
condition|)
name|config
operator|->
name|display_limit
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
comment|/* No overrun (truncate reads of known-length) */
name|no_overrun
operator|=
name|TRUE
expr_stmt|;
name|config
operator|->
name|options
operator||=
name|DPV_NO_OVERRUN
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
comment|/* additional message text to use as prefix */
if|if
condition|(
name|config
operator|->
name|pprompt
operator|==
name|NULL
condition|)
block|{
name|config
operator|->
name|pprompt
operator|=
name|malloc
argument_list|(
name|DPV_PPROMPT_MAX
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|config
operator|->
name|pprompt
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"Out of memory?!"
argument_list|)
expr_stmt|;
comment|/* +2 is for implicit "\n" appended later */
block|}
name|snprintf
argument_list|(
name|config
operator|->
name|pprompt
argument_list|,
name|DPV_PPROMPT_MAX
argument_list|,
literal|"%s"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
comment|/* custom size for mini-progressbar */
name|config
operator|->
name|pbar_size
operator|=
operator|(
name|int
operator|)
name|strtol
argument_list|(
name|optarg
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|config
operator|->
name|pbar_size
operator|==
literal|0
operator|&&
name|errno
operator|==
name|EINVAL
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"`-P' argument must be numeric"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|config
operator|->
name|pbar_size
operator|<
operator|-
literal|1
condition|)
name|config
operator|->
name|pbar_size
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
comment|/* [X]dialog(1) title */
if|if
condition|(
name|config
operator|->
name|title
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|config
operator|->
name|title
argument_list|)
expr_stmt|;
name|config
operator|->
name|title
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|optarg
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|config
operator|->
name|title
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"Out of memory?!"
argument_list|)
expr_stmt|;
operator|*
operator|(
name|config
operator|->
name|title
operator|)
operator|=
literal|'\0'
expr_stmt|;
name|strcat
argument_list|(
name|config
operator|->
name|title
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
comment|/* test mode (don't read data, fake it) */
name|config
operator|->
name|options
operator||=
name|DPV_TEST_MODE
expr_stmt|;
break|break;
case|case
literal|'U'
case|:
comment|/* updates per second */
name|config
operator|->
name|status_updates_per_second
operator|=
operator|(
name|int
operator|)
name|strtol
argument_list|(
name|optarg
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|config
operator|->
name|status_updates_per_second
operator|==
literal|0
operator|&&
name|errno
operator|==
name|EINVAL
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"`-U' argument must be numeric"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
comment|/* `-p' and `-a' widths bump [X]dialog(1) width */
name|config
operator|->
name|options
operator||=
name|DPV_WIDE_MODE
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
comment|/* `-x cmd' for sending data-read to sh(1) code */
name|output_type
operator|=
name|DPV_OUTPUT_SHELL
expr_stmt|;
name|config
operator|->
name|output_type
operator|=
name|DPV_OUTPUT_SHELL
expr_stmt|;
name|config
operator|->
name|output
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
comment|/* X11 support through x11/xdialog */
name|config
operator|->
name|display_type
operator|=
name|DPV_DISPLAY_XDIALOG
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
comment|/* unknown argument (based on optstring) */
comment|/* FALLTHROUGH */
default|default:
comment|/* unhandled argument (based on switch) */
name|usage
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
comment|/* Process remaining arguments as list of names to display */
for|for
control|(
name|curfile
operator|=
name|file_list
init|;
name|n
operator|<
name|argc
condition|;
name|n
operator|++
control|)
block|{
name|nfiles
operator|++
expr_stmt|;
comment|/* Allocate a new struct for the file argument */
if|if
condition|(
name|curfile
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|curfile
operator|=
name|malloc
argument_list|(
name|file_node_size
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"Out of memory?!"
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|curfile
operator|)
argument_list|,
literal|'\0'
argument_list|,
name|file_node_size
argument_list|)
expr_stmt|;
name|file_list
operator|=
name|curfile
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|curfile
operator|->
name|next
operator|=
name|malloc
argument_list|(
name|file_node_size
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"Out of memory?!"
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|curfile
operator|->
name|next
operator|)
argument_list|,
literal|'\0'
argument_list|,
name|file_node_size
argument_list|)
expr_stmt|;
name|curfile
operator|=
name|curfile
operator|->
name|next
expr_stmt|;
block|}
name|curfile
operator|->
name|name
operator|=
name|argv
index|[
name|n
index|]
expr_stmt|;
comment|/* Read possible `lines:' prefix from label syntax */
if|if
condition|(
name|sscanf
argument_list|(
name|curfile
operator|->
name|name
argument_list|,
literal|"%lli:%c"
argument_list|,
operator|&
operator|(
name|curfile
operator|->
name|length
operator|)
argument_list|,
operator|&
name|dummy
argument_list|)
operator|==
literal|2
condition|)
name|curfile
operator|->
name|name
operator|=
name|strchr
argument_list|(
name|curfile
operator|->
name|name
argument_list|,
literal|':'
argument_list|)
operator|+
literal|1
expr_stmt|;
else|else
name|curfile
operator|->
name|length
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Read path argument if enabled */
if|if
condition|(
name|multiple
condition|)
block|{
if|if
condition|(
operator|++
name|n
operator|>=
name|argc
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"Missing path argument "
literal|"for label number %i"
argument_list|,
name|nfiles
argument_list|)
expr_stmt|;
name|curfile
operator|->
name|path
operator|=
name|argv
index|[
name|n
index|]
expr_stmt|;
block|}
else|else
break|break;
block|}
comment|/* Display usage and exit if not given at least one name */
if|if
condition|(
name|nfiles
operator|==
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"no labels provided"
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
block|}
comment|/* 	 * Set cleanup routine for Ctrl-C action 	 */
if|if
condition|(
name|config
operator|->
name|display_type
operator|==
name|DPV_DISPLAY_LIBDIALOG
condition|)
block|{
name|act
operator|.
name|sa_handler
operator|=
name|sig_int
expr_stmt|;
name|sigaction
argument_list|(
name|SIGINT
argument_list|,
operator|&
name|act
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Set status formats and action */
if|if
condition|(
name|line_mode
condition|)
block|{
name|config
operator|->
name|status_solo
operator|=
name|LINE_STATUS_SOLO
expr_stmt|;
name|config
operator|->
name|status_many
operator|=
name|LINE_STATUS_SOLO
expr_stmt|;
name|config
operator|->
name|action
operator|=
name|operate_on_lines
expr_stmt|;
block|}
else|else
block|{
name|config
operator|->
name|status_solo
operator|=
name|BYTE_STATUS_SOLO
expr_stmt|;
name|config
operator|->
name|status_many
operator|=
name|BYTE_STATUS_SOLO
expr_stmt|;
name|config
operator|->
name|action
operator|=
name|operate_on_bytes
expr_stmt|;
block|}
comment|/* 	 * Hand off to dpv(3)... 	 */
if|if
condition|(
name|dpv
argument_list|(
name|config
argument_list|,
name|file_list
argument_list|)
operator|!=
literal|0
operator|&&
name|debug
condition|)
name|warnx
argument_list|(
literal|"dpv(3) returned error!?"
argument_list|)
expr_stmt|;
name|end_dialog
argument_list|()
expr_stmt|;
name|dpv_free
argument_list|()
expr_stmt|;
name|exit
argument_list|(
name|EXIT_SUCCESS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Interrupt handler to indicate we received a Ctrl-C interrupt.  */
end_comment

begin_function
specifier|static
name|void
name|sig_int
parameter_list|(
name|int
name|sig
name|__unused
parameter_list|)
block|{
name|dpv_interrupt
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Print short usage statement to stderr and exit with error status.  */
end_comment

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|debug
condition|)
comment|/* No need for usage */
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: %s [options] bytes:label\n"
argument_list|,
name|pgm
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"       %s [options] -m bytes1:label1 path1 "
literal|"[bytes2:label2 path2 ...]\n"
argument_list|,
name|pgm
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"OPTIONS:\n"
argument_list|)
expr_stmt|;
define|#
directive|define
name|OPTFMT
value|"\t%-14s %s\n"
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|OPTFMT
argument_list|,
literal|"-a text"
argument_list|,
literal|"Append text. Displayed below file progress indicators."
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|OPTFMT
argument_list|,
literal|"-b backtitle"
argument_list|,
literal|"String to be displayed on the backdrop, at top-left."
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|OPTFMT
argument_list|,
literal|"-d"
argument_list|,
literal|"Debug. Write to standard output instead of dialog."
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|OPTFMT
argument_list|,
literal|"-D"
argument_list|,
literal|"Use dialog(1) instead of dialog(3) [default]."
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|OPTFMT
argument_list|,
literal|"-h"
argument_list|,
literal|"Produce this output on standard error and exit."
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|OPTFMT
argument_list|,
literal|"-i format"
argument_list|,
literal|"Customize status line format. See fdpv(1) for details."
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|OPTFMT
argument_list|,
literal|"-I format"
argument_list|,
literal|"Customize status line format. See fdpv(1) for details."
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|OPTFMT
argument_list|,
literal|"-L size"
argument_list|,
literal|"Label size. Must be a number greater than 0, or -1."
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|OPTFMT
argument_list|,
literal|"-m"
argument_list|,
literal|"Enable processing of multiple file argiments."
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|OPTFMT
argument_list|,
literal|"-n num"
argument_list|,
literal|"Display at-most num files per screen. Default is -1."
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|OPTFMT
argument_list|,
literal|"-N"
argument_list|,
literal|"No overrun. Stop reading input at stated length, if any."
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|OPTFMT
argument_list|,
literal|"-o file"
argument_list|,
literal|"Output data to file. First %s replaced with label text."
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|OPTFMT
argument_list|,
literal|"-p text"
argument_list|,
literal|"Prefix text. Displayed above file progress indicators."
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|OPTFMT
argument_list|,
literal|"-P size"
argument_list|,
literal|"Mini-progressbar size. Must be a number greater than 3."
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|OPTFMT
argument_list|,
literal|"-t title"
argument_list|,
literal|"Title string to be displayed at top of dialog(1) box."
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|OPTFMT
argument_list|,
literal|"-T"
argument_list|,
literal|"Test mode. Don't actually read any data, but fake it."
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|OPTFMT
argument_list|,
literal|"-U num"
argument_list|,
literal|"Update status line num times per-second. Default is 2."
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|OPTFMT
argument_list|,
literal|"-w"
argument_list|,
literal|"Wide. Width of `-p' and `-a' text bump dialog(1) width."
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|OPTFMT
argument_list|,
literal|"-x cmd"
argument_list|,
literal|"Send data to executed cmd. First %s replaced with label."
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|OPTFMT
argument_list|,
literal|"-X"
argument_list|,
literal|"X11. Use Xdialog(1) instead of dialog(1)."
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

