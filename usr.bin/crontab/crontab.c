begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|LINT
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$Header: /home/local/site/cron2.1/orig/RCS/crontab.c,v 2.3 1992/05/13 05:56:35 rich Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Revision 1.5  87/05/02  17:33:22  paul  * pokecron?  (RCS file has the rest of the log)  *   * Revision 1.5  87/05/02  17:33:22  paul  * baseline for mod.sources release  *   * Revision 1.4  87/03/31  13:11:48  paul  * I won't say that rs@mirror gave me this idea but crontab uses getopt() now  *   * Revision 1.3  87/03/30  23:43:48  paul  * another suggestion from rs@mirror:  *   use getpwuid(getuid)->pw_name instead of getenv("USER")  *   this is a boost to security...  *   * Revision 1.2  87/02/11  17:40:12  paul  * changed command syntax to allow append and replace instead of append as  * default and no replace at all.  *   * Revision 1.1  87/01/26  23:49:06  paul  * Initial revision  *  * PATCHES MAGIC                LEVEL   PATCH THAT GOT US HERE  * --------------------         -----   ----------------------  * CURRENT PATCH LEVEL:         1       00131  * --------------------         -----   ----------------------  *  * 06 Apr 93	Adam Glass	Fixes so it compiles quitely  *  */
end_comment

begin_comment
comment|/* Copyright 1988,1990 by Paul Vixie  * All rights reserved  *  * Distribute freely, except: don't remove my name from the source or  * documentation (don't take credit for my work), mark your changes (don't  * get me blamed for your possible bugs), don't alter or remove this  * notice.  May be sold if buildable source is provided to buyer.  No  * warrantee of any kind, express or implied, is included with this  * software; use at your own risk, responsibility for damages (if any) to  * anyone resulting from the use of this software rests entirely with the  * user.  *  * Send bug reports, bug fixes, enhancements, requests, flames, etc., and  * I'll try to keep a version up to date.  I can be reached as follows:  * Paul Vixie, 329 Noe Street, San Francisco, CA, 94114, (415) 864-7013,  * paul@vixie.sf.ca.us || {hoptoad,pacbell,decwrl,crash}!vixie!paul  */
end_comment

begin_define
define|#
directive|define
name|MAIN_PROGRAM
end_define

begin_include
include|#
directive|include
file|"cron.h"
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|BSD
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*BSD*/
end_comment

begin_comment
comment|/* extern	char	*sprintf(); */
end_comment

begin_decl_stmt
specifier|static
name|int
name|Pid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|User
index|[
name|MAX_UNAME
index|]
decl_stmt|,
name|RealUser
index|[
name|MAX_UNAME
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|Filename
index|[
name|MAX_FNAME
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|NewCrontab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|CheckErrorCount
decl_stmt|;
end_decl_stmt

begin_enum
specifier|static
enum|enum
block|{
name|opt_unknown
block|,
name|opt_list
block|,
name|opt_delete
block|,
name|opt_replace
block|}
name|Option
enum|;
end_enum

begin_function_decl
specifier|extern
name|void
name|log_it
parameter_list|()
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|DEBUGGING
end_if

begin_decl_stmt
specifier|static
name|char
modifier|*
name|Options
index|[]
init|=
block|{
literal|"???"
block|,
literal|"list"
block|,
literal|"delete"
block|,
literal|"replace"
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|usage
parameter_list|()
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage:  %s [-u user] ...\n"
argument_list|,
name|ProgramName
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" ... -l         (list user's crontab)\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" ... -d         (delete user's crontab)\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" ... -r file    (replace user's crontab)\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|ERROR_EXIT
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|void
name|parse_args
argument_list|()
decl_stmt|,
name|set_cron_uid
argument_list|()
decl_stmt|,
name|set_cron_cwd
argument_list|()
decl_stmt|,
name|list_cmd
argument_list|()
decl_stmt|,
name|delete_cmd
argument_list|()
decl_stmt|,
name|replace_cmd
argument_list|()
decl_stmt|;
name|Pid
operator|=
name|getpid
argument_list|()
expr_stmt|;
name|ProgramName
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|BSD
argument_list|)
name|setlinebuf
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|parse_args
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
comment|/* sets many globals, opens a file */
name|set_cron_uid
argument_list|()
expr_stmt|;
name|set_cron_cwd
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|allowed
argument_list|(
name|User
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"You (%s) are not allowed to use this program (%s)\n"
argument_list|,
name|User
argument_list|,
name|ProgramName
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"See crontab(1) for more information\n"
argument_list|)
expr_stmt|;
name|log_it
argument_list|(
name|RealUser
argument_list|,
name|Pid
argument_list|,
literal|"AUTH"
argument_list|,
literal|"crontab command not allowed"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|ERROR_EXIT
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|Option
condition|)
block|{
case|case
name|opt_list
case|:
name|list_cmd
argument_list|()
expr_stmt|;
break|break;
case|case
name|opt_delete
case|:
name|delete_cmd
argument_list|()
expr_stmt|;
break|break;
case|case
name|opt_replace
case|:
name|replace_cmd
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
name|void
name|parse_args
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|void
name|usage
parameter_list|()
function_decl|;
name|char
modifier|*
name|getenv
argument_list|()
decl_stmt|,
modifier|*
name|strcpy
argument_list|()
decl_stmt|;
name|int
name|getuid
parameter_list|()
function_decl|;
name|struct
name|passwd
modifier|*
name|getpwnam
parameter_list|()
function_decl|;
specifier|extern
name|int
name|getopt
argument_list|()
decl_stmt|,
name|optind
decl_stmt|;
specifier|extern
name|char
modifier|*
name|optarg
decl_stmt|;
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
name|int
name|argch
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|pw
operator|=
name|getpwuid
argument_list|(
name|getuid
argument_list|()
argument_list|)
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: your UID isn't in the passwd file.\n"
argument_list|,
name|ProgramName
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"bailing out.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|ERROR_EXIT
argument_list|)
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|User
argument_list|,
name|pw
operator|->
name|pw_name
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|RealUser
argument_list|,
name|User
argument_list|)
expr_stmt|;
name|Filename
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|Option
operator|=
name|opt_unknown
expr_stmt|;
while|while
condition|(
name|EOF
operator|!=
operator|(
name|argch
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"u:ldr:x:"
argument_list|)
operator|)
condition|)
block|{
switch|switch
condition|(
name|argch
condition|)
block|{
case|case
literal|'x'
case|:
if|if
condition|(
operator|!
name|set_debug_flags
argument_list|(
name|optarg
argument_list|)
condition|)
name|usage
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
if|if
condition|(
name|getuid
argument_list|()
operator|!=
name|ROOT_UID
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"must be privileged to use -u\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|ERROR_EXIT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
expr|struct
name|passwd
operator|*
operator|)
name|NULL
operator|==
name|getpwnam
argument_list|(
name|optarg
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:  user `%s' unknown\n"
argument_list|,
name|ProgramName
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|ERROR_EXIT
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|User
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
if|if
condition|(
name|Option
operator|!=
name|opt_unknown
condition|)
name|usage
argument_list|()
expr_stmt|;
name|Option
operator|=
name|opt_list
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
if|if
condition|(
name|Option
operator|!=
name|opt_unknown
condition|)
name|usage
argument_list|()
expr_stmt|;
name|Option
operator|=
name|opt_delete
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
if|if
condition|(
name|Option
operator|!=
name|opt_unknown
condition|)
name|usage
argument_list|()
expr_stmt|;
name|Option
operator|=
name|opt_replace
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|Filename
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|()
expr_stmt|;
block|}
block|}
name|endpwent
argument_list|()
expr_stmt|;
if|if
condition|(
name|Option
operator|==
name|opt_unknown
operator|||
name|argv
index|[
name|optind
index|]
operator|!=
name|NULL
condition|)
name|usage
argument_list|()
expr_stmt|;
if|if
condition|(
name|Option
operator|==
name|opt_replace
condition|)
block|{
if|if
condition|(
operator|!
name|Filename
index|[
literal|0
index|]
condition|)
block|{
comment|/* getopt(3) says this can't be true 			 * but I'm paranoid today. 			 */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"filename must be given for -a or -r\n"
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
comment|/* we have to open the file here because we're going to 		 * chdir(2) into /var/cron before we get around to 		 * reading the file. 		 */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|Filename
argument_list|,
literal|"-"
argument_list|)
condition|)
block|{
name|NewCrontab
operator|=
name|stdin
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|NewCrontab
operator|=
name|fopen
argument_list|(
name|Filename
argument_list|,
literal|"r"
argument_list|)
operator|)
condition|)
block|{
name|perror
argument_list|(
name|Filename
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|ERROR_EXIT
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|Debug
argument_list|(
argument|DMISC
argument_list|,
argument|(
literal|"user=%s, file=%s, option=%s\n"
argument|, 					User, Filename, Options[(int)Option])
argument_list|)
block|}
end_function

begin_function
name|void
name|list_cmd
parameter_list|()
block|{
extern|extern	errno;
name|char
name|n
index|[
name|MAX_FNAME
index|]
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
name|int
name|ch
decl_stmt|;
name|log_it
argument_list|(
name|RealUser
argument_list|,
name|Pid
argument_list|,
literal|"LIST"
argument_list|,
name|User
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|n
argument_list|,
name|CRON_TAB
argument_list|(
name|User
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|f
operator|=
name|fopen
argument_list|(
name|n
argument_list|,
literal|"r"
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOENT
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"no crontab for %s\n"
argument_list|,
name|User
argument_list|)
expr_stmt|;
else|else
name|perror
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|ERROR_EXIT
argument_list|)
expr_stmt|;
block|}
comment|/* file is open. copy to stdout, close. 	 */
name|Set_LineNum
argument_list|(
literal|1
argument_list|)
while|while
condition|(
name|EOF
operator|!=
operator|(
name|ch
operator|=
name|get_char
argument_list|(
name|f
argument_list|)
operator|)
condition|)
name|putchar
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|delete_cmd
parameter_list|()
block|{
extern|extern	errno;
name|int
name|unlink
parameter_list|()
function_decl|;
name|void
name|poke_daemon
parameter_list|()
function_decl|;
name|char
name|n
index|[
name|MAX_FNAME
index|]
decl_stmt|;
name|log_it
argument_list|(
name|RealUser
argument_list|,
name|Pid
argument_list|,
literal|"DELETE"
argument_list|,
name|User
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|n
argument_list|,
name|CRON_TAB
argument_list|(
name|User
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlink
argument_list|(
name|n
argument_list|)
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOENT
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"no crontab for %s\n"
argument_list|,
name|User
argument_list|)
expr_stmt|;
else|else
name|perror
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|ERROR_EXIT
argument_list|)
expr_stmt|;
block|}
name|poke_daemon
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|check_error
parameter_list|(
name|msg
parameter_list|)
name|char
modifier|*
name|msg
decl_stmt|;
block|{
name|CheckErrorCount
operator|+=
literal|1
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\"%s\", line %d: %s\n"
argument_list|,
name|Filename
argument_list|,
name|LineNumber
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|replace_cmd
parameter_list|()
block|{
name|entry
modifier|*
name|load_entry
parameter_list|()
function_decl|;
name|int
name|load_env
parameter_list|()
function_decl|;
name|int
name|unlink
parameter_list|()
function_decl|;
name|void
name|free_entry
parameter_list|()
function_decl|;
name|void
name|check_error
parameter_list|()
function_decl|;
name|void
name|poke_daemon
parameter_list|()
function_decl|;
extern|extern	errno;
name|char
name|n
index|[
name|MAX_FNAME
index|]
decl_stmt|,
name|envstr
index|[
name|MAX_ENVSTR
index|]
decl_stmt|,
name|tn
index|[
name|MAX_FNAME
index|]
decl_stmt|;
name|FILE
modifier|*
name|tmp
decl_stmt|;
name|int
name|ch
decl_stmt|;
name|entry
modifier|*
name|e
decl_stmt|;
name|int
name|status
decl_stmt|;
name|time_t
name|now
init|=
name|time
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|n
argument_list|,
literal|"tmp.%d"
argument_list|,
name|Pid
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|tn
argument_list|,
name|CRON_TAB
argument_list|(
name|n
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tmp
operator|=
name|fopen
argument_list|(
name|tn
argument_list|,
literal|"w"
argument_list|)
operator|)
condition|)
block|{
name|perror
argument_list|(
name|tn
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|ERROR_EXIT
argument_list|)
expr_stmt|;
block|}
comment|/* write a signature at the top of the file.  for brian. 	 */
name|fprintf
argument_list|(
name|tmp
argument_list|,
literal|"# (%s installed on %-24.24s)\n"
argument_list|,
name|Filename
argument_list|,
name|ctime
argument_list|(
operator|&
name|now
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|tmp
argument_list|,
literal|"# (Cron version -- %s)\n"
argument_list|,
name|rcsid
argument_list|)
expr_stmt|;
comment|/* copy the crontab to the tmp 	 */
name|Set_LineNum
argument_list|(
literal|1
argument_list|)
while|while
condition|(
name|EOF
operator|!=
operator|(
name|ch
operator|=
name|get_char
argument_list|(
name|NewCrontab
argument_list|)
operator|)
condition|)
name|putc
argument_list|(
name|ch
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|NewCrontab
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|rewind
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|tmp
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: error while writing new crontab to %s\n"
argument_list|,
name|ProgramName
argument_list|,
name|tn
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|tn
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|ERROR_EXIT
argument_list|)
expr_stmt|;
block|}
comment|/* check the syntax of the file being installed. 	 */
comment|/* BUG: was reporting errors after the EOF if there were any errors 	 * in the file proper -- kludged it by stopping after first error. 	 *		vix 31mar87 	 */
name|CheckErrorCount
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|CheckErrorCount
operator|&&
operator|(
name|status
operator|=
name|load_env
argument_list|(
name|envstr
argument_list|,
name|tmp
argument_list|)
operator|)
operator|>=
name|OK
condition|)
block|{
if|if
condition|(
name|status
operator|==
name|FALSE
condition|)
block|{
if|if
condition|(
name|NULL
operator|!=
operator|(
name|e
operator|=
name|load_entry
argument_list|(
name|NewCrontab
argument_list|,
name|check_error
argument_list|)
operator|)
condition|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|e
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|CheckErrorCount
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"errors in crontab file, can't install.\n"
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|tn
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|ERROR_EXIT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fchown
argument_list|(
name|fileno
argument_list|(
name|tmp
argument_list|)
argument_list|,
name|ROOT_UID
argument_list|,
operator|-
literal|1
argument_list|)
operator|<
name|OK
condition|)
block|{
name|perror
argument_list|(
literal|"chown"
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|tn
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|ERROR_EXIT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fchmod
argument_list|(
name|fileno
argument_list|(
name|tmp
argument_list|)
argument_list|,
literal|0600
argument_list|)
operator|<
name|OK
condition|)
block|{
name|perror
argument_list|(
literal|"chown"
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|tn
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|ERROR_EXIT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fclose
argument_list|(
name|tmp
argument_list|)
operator|==
name|EOF
condition|)
block|{
name|perror
argument_list|(
literal|"fclose"
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|tn
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|ERROR_EXIT
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|n
argument_list|,
name|CRON_TAB
argument_list|(
name|User
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rename
argument_list|(
name|tn
argument_list|,
name|n
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: error renaming %s to %s\n"
argument_list|,
name|ProgramName
argument_list|,
name|tn
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|perror
argument_list|(
literal|"rename"
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|tn
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|ERROR_EXIT
argument_list|)
expr_stmt|;
block|}
name|log_it
argument_list|(
name|RealUser
argument_list|,
name|Pid
argument_list|,
literal|"REPLACE"
argument_list|,
name|User
argument_list|)
expr_stmt|;
name|poke_daemon
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|poke_daemon
parameter_list|()
block|{
if|#
directive|if
name|defined
argument_list|(
name|BSD
argument_list|)
name|struct
name|timeval
name|tvs
index|[
literal|2
index|]
decl_stmt|;
name|struct
name|timezone
name|tz
decl_stmt|;
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|tvs
index|[
literal|0
index|]
argument_list|,
operator|&
name|tz
argument_list|)
expr_stmt|;
name|tvs
index|[
literal|1
index|]
operator|=
name|tvs
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|utimes
argument_list|(
name|SPOOL_DIR
argument_list|,
name|tvs
argument_list|)
operator|<
name|OK
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"crontab: can't update mtime on spooldir\n"
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|SPOOL_DIR
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/*BSD*/
if|#
directive|if
name|defined
argument_list|(
name|ATT
argument_list|)
if|if
condition|(
name|utime
argument_list|(
name|SPOOL_DIR
argument_list|,
name|NULL
argument_list|)
operator|<
name|OK
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"crontab: can't update mtime on spooldir\n"
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|SPOOL_DIR
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/*ATT*/
block|}
end_function

end_unit

