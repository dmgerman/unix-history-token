begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: read.c,v 1.2 1995/07/03 21:24:59 cgd Exp $	*/
end_comment

begin_comment
comment|/*  * Copyright (c) 1994, 1995 Jochen Pohl  * All Rights Reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *      This product includes software developed by Jochen Pohl for  *	The NetBSD Project.  * 4. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$NetBSD: read.c,v 1.2 1995/07/03 21:24:59 cgd Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|"lint2.h"
end_include

begin_comment
comment|/* index of current (included) source file */
end_comment

begin_decl_stmt
specifier|static
name|int
name|srcfile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The array pointed to by inpfns maps the file name indices of input files  * to the file name indices used in lint2  */
end_comment

begin_decl_stmt
specifier|static
name|short
modifier|*
name|inpfns
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|ninpfns
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The array pointed to by *fnames maps file name indizes to file names.  * Indices of type short are used instead of pointers to save memory.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
modifier|*
name|fnames
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|nfnames
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Types are shared (to save memory for the types itself) and accessed  * via indices (to save memory for references to types (indices are short)).  * To share types, a equal type must be located fast. This is done by a  * hash table. Access by indices is done via an array of pointers to the  * types.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|thtab
block|{
specifier|const
name|char
modifier|*
name|th_name
decl_stmt|;
name|u_short
name|th_idx
decl_stmt|;
name|struct
name|thtab
modifier|*
name|th_nxt
decl_stmt|;
block|}
name|thtab_t
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|thtab_t
modifier|*
modifier|*
name|thtab
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* hash table */
end_comment

begin_decl_stmt
name|type_t
modifier|*
modifier|*
name|tlst
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* array for indexed access */
end_comment

begin_decl_stmt
specifier|static
name|size_t
name|tlstlen
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* length of tlst */
end_comment

begin_comment
comment|/* index of current C source file (as spezified at the command line) */
end_comment

begin_decl_stmt
specifier|static
name|int
name|csrcfile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|inperr
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|setsrc
name|__P
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|setfnid
name|__P
argument_list|(
operator|(
name|int
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|funccall
name|__P
argument_list|(
operator|(
name|pos_t
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|decldef
name|__P
argument_list|(
operator|(
name|pos_t
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|usedsym
name|__P
argument_list|(
operator|(
name|pos_t
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_short
name|inptype
name|__P
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|gettlen
name|__P
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_short
name|findtype
name|__P
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|size_t
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_short
name|storetyp
name|__P
argument_list|(
operator|(
name|type_t
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|size_t
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|thash
name|__P
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|inpqstrg
name|__P
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|inpname
name|__P
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|getfnidx
name|__P
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|readfile
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|FILE
modifier|*
name|inp
decl_stmt|;
name|size_t
name|len
decl_stmt|;
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|line
decl_stmt|,
modifier|*
name|eptr
decl_stmt|,
name|rt
decl_stmt|;
name|int
name|cline
decl_stmt|,
name|isrc
decl_stmt|,
name|iline
decl_stmt|;
name|pos_t
name|pos
decl_stmt|;
if|if
condition|(
name|inpfns
operator|==
name|NULL
condition|)
name|inpfns
operator|=
name|xcalloc
argument_list|(
name|ninpfns
operator|=
literal|128
argument_list|,
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fnames
operator|==
name|NULL
condition|)
name|fnames
operator|=
name|xcalloc
argument_list|(
name|nfnames
operator|=
literal|256
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tlstlen
operator|==
literal|0
condition|)
name|tlst
operator|=
name|xcalloc
argument_list|(
name|tlstlen
operator|=
literal|256
argument_list|,
sizeof|sizeof
argument_list|(
name|type_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|thtab
operator|==
name|NULL
condition|)
name|thtab
operator|=
name|xcalloc
argument_list|(
name|THSHSIZ2
argument_list|,
sizeof|sizeof
argument_list|(
name|thtab_t
argument_list|)
argument_list|)
expr_stmt|;
name|srcfile
operator|=
name|getfnidx
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|inp
operator|=
name|fopen
argument_list|(
name|name
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"cannot open %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|line
operator|=
name|fgetln
argument_list|(
name|inp
argument_list|,
operator|&
name|len
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|len
operator|==
literal|0
operator|||
name|line
index|[
name|len
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
name|inperr
argument_list|()
expr_stmt|;
name|line
index|[
name|len
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|cp
operator|=
name|line
expr_stmt|;
comment|/* line number in csrcfile */
name|cline
operator|=
operator|(
name|int
operator|)
name|strtol
argument_list|(
name|cp
argument_list|,
operator|&
name|eptr
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|eptr
condition|)
block|{
name|cline
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|cp
operator|=
name|eptr
expr_stmt|;
block|}
comment|/* record type */
if|if
condition|(
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
block|{
name|rt
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
block|}
else|else
block|{
name|inperr
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|rt
operator|==
literal|'S'
condition|)
block|{
name|setsrc
argument_list|(
name|cp
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|rt
operator|==
literal|'s'
condition|)
block|{
name|setfnid
argument_list|(
name|cline
argument_list|,
name|cp
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Index of (included) source file. If this index is 		 * different from csrcfile, it refers to an included 		 * file. 		 */
name|isrc
operator|=
operator|(
name|int
operator|)
name|strtol
argument_list|(
name|cp
argument_list|,
operator|&
name|eptr
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|eptr
condition|)
name|inperr
argument_list|()
expr_stmt|;
name|cp
operator|=
name|eptr
expr_stmt|;
name|isrc
operator|=
name|inpfns
index|[
name|isrc
index|]
expr_stmt|;
comment|/* line number in isrc */
if|if
condition|(
operator|*
name|cp
operator|++
operator|!=
literal|'.'
condition|)
name|inperr
argument_list|()
expr_stmt|;
name|iline
operator|=
operator|(
name|int
operator|)
name|strtol
argument_list|(
name|cp
argument_list|,
operator|&
name|eptr
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|eptr
condition|)
name|inperr
argument_list|()
expr_stmt|;
name|cp
operator|=
name|eptr
expr_stmt|;
name|pos
operator|.
name|p_src
operator|=
operator|(
name|u_short
operator|)
name|csrcfile
expr_stmt|;
name|pos
operator|.
name|p_line
operator|=
operator|(
name|u_short
operator|)
name|cline
expr_stmt|;
name|pos
operator|.
name|p_isrc
operator|=
operator|(
name|u_short
operator|)
name|isrc
expr_stmt|;
name|pos
operator|.
name|p_iline
operator|=
operator|(
name|u_short
operator|)
name|iline
expr_stmt|;
comment|/* process rest of this record */
switch|switch
condition|(
name|rt
condition|)
block|{
case|case
literal|'c'
case|:
name|funccall
argument_list|(
operator|&
name|pos
argument_list|,
name|cp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|decldef
argument_list|(
operator|&
name|pos
argument_list|,
name|cp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|usedsym
argument_list|(
operator|&
name|pos
argument_list|,
name|cp
argument_list|)
expr_stmt|;
break|break;
default|default:
name|inperr
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ferror
argument_list|(
name|inp
argument_list|)
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"read error on %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|inperr
parameter_list|()
block|{
name|errx
argument_list|(
literal|1
argument_list|,
literal|"input file error: %s"
argument_list|,
name|fnames
index|[
name|srcfile
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set the name of the C source file of the .ln file which is  * currently read.  */
end_comment

begin_function
specifier|static
name|void
name|setsrc
parameter_list|(
name|cp
parameter_list|)
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
block|{
name|csrcfile
operator|=
name|getfnidx
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * setfnid() gets as input an index as used in an input file and the  * associated file name. If neccessary, it creates a new lint2 file  * name index for this file name and creates the mapping of the index  * as used in the input file to the index used in lint2.  */
end_comment

begin_function
specifier|static
name|void
name|setfnid
parameter_list|(
name|fid
parameter_list|,
name|cp
parameter_list|)
name|int
name|fid
decl_stmt|;
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
block|{
if|if
condition|(
name|fid
operator|==
operator|-
literal|1
condition|)
name|inperr
argument_list|()
expr_stmt|;
if|if
condition|(
name|fid
operator|>=
name|ninpfns
condition|)
block|{
name|inpfns
operator|=
name|xrealloc
argument_list|(
name|inpfns
argument_list|,
operator|(
name|ninpfns
operator|*
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|memset
argument_list|(
name|inpfns
operator|+
name|ninpfns
argument_list|,
literal|0
argument_list|,
name|ninpfns
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
name|ninpfns
operator|*=
literal|2
expr_stmt|;
block|}
comment|/* 	 * Should always be true because indices written in the output 	 * file by lint1 are always the previous index + 1. 	 */
if|if
condition|(
name|fid
operator|>=
name|ninpfns
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"internal error: setfnid()"
argument_list|)
expr_stmt|;
name|inpfns
index|[
name|fid
index|]
operator|=
operator|(
name|u_short
operator|)
name|getfnidx
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process a function call record (c-record).  */
end_comment

begin_function
specifier|static
name|void
name|funccall
parameter_list|(
name|posp
parameter_list|,
name|cp
parameter_list|)
name|pos_t
modifier|*
name|posp
decl_stmt|;
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
block|{
name|arginf_t
modifier|*
name|ai
decl_stmt|,
modifier|*
modifier|*
name|lai
decl_stmt|;
name|char
name|c
decl_stmt|,
modifier|*
name|eptr
decl_stmt|;
name|int
name|rused
decl_stmt|,
name|rdisc
decl_stmt|;
name|hte_t
modifier|*
name|hte
decl_stmt|;
name|fcall_t
modifier|*
name|fcall
decl_stmt|;
name|fcall
operator|=
name|xalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|fcall_t
argument_list|)
argument_list|)
expr_stmt|;
name|STRUCT_ASSIGN
argument_list|(
name|fcall
operator|->
name|f_pos
argument_list|,
operator|*
name|posp
argument_list|)
expr_stmt|;
comment|/* read flags */
name|rused
operator|=
name|rdisc
operator|=
literal|0
expr_stmt|;
name|lai
operator|=
operator|&
name|fcall
operator|->
name|f_args
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|cp
operator|)
operator|==
literal|'u'
operator|||
name|c
operator|==
literal|'i'
operator|||
name|c
operator|==
literal|'d'
operator|||
name|c
operator|==
literal|'z'
operator|||
name|c
operator|==
literal|'p'
operator|||
name|c
operator|==
literal|'n'
operator|||
name|c
operator|==
literal|'s'
condition|)
block|{
name|cp
operator|++
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'u'
case|:
if|if
condition|(
name|rused
operator|||
name|rdisc
condition|)
name|inperr
argument_list|()
expr_stmt|;
name|rused
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
if|if
condition|(
name|rused
operator|||
name|rdisc
condition|)
name|inperr
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
if|if
condition|(
name|rused
operator|||
name|rdisc
condition|)
name|inperr
argument_list|()
expr_stmt|;
name|rdisc
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'z'
case|:
case|case
literal|'p'
case|:
case|case
literal|'n'
case|:
case|case
literal|'s'
case|:
name|ai
operator|=
name|xalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|arginf_t
argument_list|)
argument_list|)
expr_stmt|;
name|ai
operator|->
name|a_num
operator|=
operator|(
name|int
operator|)
name|strtol
argument_list|(
name|cp
argument_list|,
operator|&
name|eptr
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|eptr
condition|)
name|inperr
argument_list|()
expr_stmt|;
name|cp
operator|=
name|eptr
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'z'
condition|)
block|{
name|ai
operator|->
name|a_pcon
operator|=
name|ai
operator|->
name|a_zero
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'p'
condition|)
block|{
name|ai
operator|->
name|a_pcon
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'n'
condition|)
block|{
name|ai
operator|->
name|a_ncon
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|ai
operator|->
name|a_fmt
operator|=
literal|1
expr_stmt|;
name|ai
operator|->
name|a_fstrg
operator|=
name|inpqstrg
argument_list|(
name|cp
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
block|}
operator|*
name|lai
operator|=
name|ai
expr_stmt|;
name|lai
operator|=
operator|&
name|ai
operator|->
name|a_nxt
expr_stmt|;
break|break;
block|}
block|}
name|fcall
operator|->
name|f_rused
operator|=
name|rused
expr_stmt|;
name|fcall
operator|->
name|f_rdisc
operator|=
name|rdisc
expr_stmt|;
comment|/* read name of function */
name|hte
operator|=
name|hsearch
argument_list|(
name|inpname
argument_list|(
name|cp
argument_list|,
operator|&
name|cp
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|hte
operator|->
name|h_used
operator|=
literal|1
expr_stmt|;
name|fcall
operator|->
name|f_type
operator|=
name|inptype
argument_list|(
name|cp
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
operator|*
name|hte
operator|->
name|h_lcall
operator|=
name|fcall
expr_stmt|;
name|hte
operator|->
name|h_lcall
operator|=
operator|&
name|fcall
operator|->
name|f_nxt
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
name|inperr
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process a declaration or definition (d-record).  */
end_comment

begin_function
specifier|static
name|void
name|decldef
parameter_list|(
name|posp
parameter_list|,
name|cp
parameter_list|)
name|pos_t
modifier|*
name|posp
decl_stmt|;
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
block|{
name|sym_t
modifier|*
name|symp
decl_stmt|,
name|sym
decl_stmt|;
name|char
name|c
decl_stmt|,
modifier|*
name|ep
decl_stmt|;
name|int
name|used
decl_stmt|;
name|hte_t
modifier|*
name|hte
decl_stmt|;
operator|(
name|void
operator|)
name|memset
argument_list|(
operator|&
name|sym
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
name|STRUCT_ASSIGN
argument_list|(
name|sym
operator|.
name|s_pos
argument_list|,
operator|*
name|posp
argument_list|)
expr_stmt|;
name|sym
operator|.
name|s_def
operator|=
name|NODECL
expr_stmt|;
name|used
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|cp
operator|)
operator|==
literal|'t'
operator|||
name|c
operator|==
literal|'d'
operator|||
name|c
operator|==
literal|'e'
operator|||
name|c
operator|==
literal|'u'
operator|||
name|c
operator|==
literal|'r'
operator|||
name|c
operator|==
literal|'o'
operator|||
name|c
operator|==
literal|'s'
operator|||
name|c
operator|==
literal|'v'
operator|||
name|c
operator|==
literal|'P'
operator|||
name|c
operator|==
literal|'S'
condition|)
block|{
name|cp
operator|++
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'t'
case|:
if|if
condition|(
name|sym
operator|.
name|s_def
operator|!=
name|NODECL
condition|)
name|inperr
argument_list|()
expr_stmt|;
name|sym
operator|.
name|s_def
operator|=
name|TDEF
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
if|if
condition|(
name|sym
operator|.
name|s_def
operator|!=
name|NODECL
condition|)
name|inperr
argument_list|()
expr_stmt|;
name|sym
operator|.
name|s_def
operator|=
name|DEF
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
if|if
condition|(
name|sym
operator|.
name|s_def
operator|!=
name|NODECL
condition|)
name|inperr
argument_list|()
expr_stmt|;
name|sym
operator|.
name|s_def
operator|=
name|DECL
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
if|if
condition|(
name|used
condition|)
name|inperr
argument_list|()
expr_stmt|;
name|used
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
if|if
condition|(
name|sym
operator|.
name|s_rval
condition|)
name|inperr
argument_list|()
expr_stmt|;
name|sym
operator|.
name|s_rval
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
if|if
condition|(
name|sym
operator|.
name|s_osdef
condition|)
name|inperr
argument_list|()
expr_stmt|;
name|sym
operator|.
name|s_osdef
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
if|if
condition|(
name|sym
operator|.
name|s_static
condition|)
name|inperr
argument_list|()
expr_stmt|;
name|sym
operator|.
name|s_static
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
if|if
condition|(
name|sym
operator|.
name|s_va
condition|)
name|inperr
argument_list|()
expr_stmt|;
name|sym
operator|.
name|s_va
operator|=
literal|1
expr_stmt|;
name|sym
operator|.
name|s_nva
operator|=
operator|(
name|short
operator|)
name|strtol
argument_list|(
name|cp
argument_list|,
operator|&
name|ep
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|ep
condition|)
name|inperr
argument_list|()
expr_stmt|;
name|cp
operator|=
name|ep
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
if|if
condition|(
name|sym
operator|.
name|s_prfl
condition|)
name|inperr
argument_list|()
expr_stmt|;
name|sym
operator|.
name|s_prfl
operator|=
literal|1
expr_stmt|;
name|sym
operator|.
name|s_nprfl
operator|=
operator|(
name|short
operator|)
name|strtol
argument_list|(
name|cp
argument_list|,
operator|&
name|ep
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|ep
condition|)
name|inperr
argument_list|()
expr_stmt|;
name|cp
operator|=
name|ep
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
if|if
condition|(
name|sym
operator|.
name|s_scfl
condition|)
name|inperr
argument_list|()
expr_stmt|;
name|sym
operator|.
name|s_scfl
operator|=
literal|1
expr_stmt|;
name|sym
operator|.
name|s_nscfl
operator|=
operator|(
name|short
operator|)
name|strtol
argument_list|(
name|cp
argument_list|,
operator|&
name|ep
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|ep
condition|)
name|inperr
argument_list|()
expr_stmt|;
name|cp
operator|=
name|ep
expr_stmt|;
break|break;
block|}
block|}
comment|/* read symbol name */
name|hte
operator|=
name|hsearch
argument_list|(
name|inpname
argument_list|(
name|cp
argument_list|,
operator|&
name|cp
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|hte
operator|->
name|h_used
operator||=
name|used
expr_stmt|;
if|if
condition|(
name|sym
operator|.
name|s_def
operator|==
name|DEF
operator|||
name|sym
operator|.
name|s_def
operator|==
name|TDEF
condition|)
name|hte
operator|->
name|h_def
operator|=
literal|1
expr_stmt|;
name|sym
operator|.
name|s_type
operator|=
name|inptype
argument_list|(
name|cp
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate memory for this symbol only if it was not already 	 * declared or tentatively defined at the same location with 	 * the same type. Works only for symbols with external linkage, 	 * because static symbols, tentatively defined at the same location 	 * but in different translation units are really different symbols. 	 */
for|for
control|(
name|symp
operator|=
name|hte
operator|->
name|h_syms
init|;
name|symp
operator|!=
name|NULL
condition|;
name|symp
operator|=
name|symp
operator|->
name|s_nxt
control|)
block|{
if|if
condition|(
name|symp
operator|->
name|s_pos
operator|.
name|p_isrc
operator|==
name|sym
operator|.
name|s_pos
operator|.
name|p_isrc
operator|&&
name|symp
operator|->
name|s_pos
operator|.
name|p_iline
operator|==
name|sym
operator|.
name|s_pos
operator|.
name|p_iline
operator|&&
name|symp
operator|->
name|s_type
operator|==
name|sym
operator|.
name|s_type
operator|&&
operator|(
operator|(
name|symp
operator|->
name|s_def
operator|==
name|DECL
operator|&&
name|sym
operator|.
name|s_def
operator|==
name|DECL
operator|)
operator|||
operator|(
operator|!
name|sflag
operator|&&
name|symp
operator|->
name|s_def
operator|==
name|TDEF
operator|&&
name|sym
operator|.
name|s_def
operator|==
name|TDEF
operator|)
operator|)
operator|&&
operator|!
name|symp
operator|->
name|s_static
operator|&&
operator|!
name|sym
operator|.
name|s_static
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|symp
operator|==
name|NULL
condition|)
block|{
comment|/* allocsym reserviert keinen Platz fuer s_nva */
if|if
condition|(
name|sym
operator|.
name|s_va
operator|||
name|sym
operator|.
name|s_prfl
operator|||
name|sym
operator|.
name|s_scfl
condition|)
block|{
name|symp
operator|=
name|xalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|sym_t
argument_list|)
argument_list|)
expr_stmt|;
name|STRUCT_ASSIGN
argument_list|(
operator|*
name|symp
argument_list|,
name|sym
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|symp
operator|=
name|xalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|symp
operator|->
name|s_s
argument_list|)
argument_list|)
expr_stmt|;
name|STRUCT_ASSIGN
argument_list|(
name|symp
operator|->
name|s_s
argument_list|,
name|sym
operator|.
name|s_s
argument_list|)
expr_stmt|;
block|}
operator|*
name|hte
operator|->
name|h_lsym
operator|=
name|symp
expr_stmt|;
name|hte
operator|->
name|h_lsym
operator|=
operator|&
name|symp
operator|->
name|s_nxt
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
name|inperr
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Read an u-record (emited by lint1 if a symbol was used).  */
end_comment

begin_function
specifier|static
name|void
name|usedsym
parameter_list|(
name|posp
parameter_list|,
name|cp
parameter_list|)
name|pos_t
modifier|*
name|posp
decl_stmt|;
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
block|{
name|usym_t
modifier|*
name|usym
decl_stmt|;
name|hte_t
modifier|*
name|hte
decl_stmt|;
name|usym
operator|=
name|xalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|usym_t
argument_list|)
argument_list|)
expr_stmt|;
name|STRUCT_ASSIGN
argument_list|(
name|usym
operator|->
name|u_pos
argument_list|,
operator|*
name|posp
argument_list|)
expr_stmt|;
comment|/* needed as delimiter between two numbers */
if|if
condition|(
operator|*
name|cp
operator|++
operator|!=
literal|'x'
condition|)
name|inperr
argument_list|()
expr_stmt|;
name|hte
operator|=
name|hsearch
argument_list|(
name|inpname
argument_list|(
name|cp
argument_list|,
operator|&
name|cp
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|hte
operator|->
name|h_used
operator|=
literal|1
expr_stmt|;
operator|*
name|hte
operator|->
name|h_lusym
operator|=
name|usym
expr_stmt|;
name|hte
operator|->
name|h_lusym
operator|=
operator|&
name|usym
operator|->
name|u_nxt
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Read a type and return the index of this type.  */
end_comment

begin_function
specifier|static
name|u_short
name|inptype
parameter_list|(
name|cp
parameter_list|,
name|epp
parameter_list|)
specifier|const
name|char
modifier|*
name|cp
decl_stmt|,
decl|*
modifier|*
name|epp
decl_stmt|;
end_function

begin_block
block|{
name|char
name|c
decl_stmt|,
name|s
decl_stmt|,
modifier|*
name|eptr
decl_stmt|;
specifier|const
name|char
modifier|*
name|ep
decl_stmt|;
name|type_t
modifier|*
name|tp
decl_stmt|;
name|int
name|narg
decl_stmt|,
name|i
decl_stmt|,
name|osdef
decl_stmt|;
name|size_t
name|tlen
decl_stmt|;
name|u_short
name|tidx
decl_stmt|;
name|int
name|h
decl_stmt|;
comment|/* If we have this type already, return it's index. */
name|tlen
operator|=
name|gettlen
argument_list|(
name|cp
argument_list|,
operator|&
name|ep
argument_list|)
expr_stmt|;
name|h
operator|=
name|thash
argument_list|(
name|cp
argument_list|,
name|tlen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tidx
operator|=
name|findtype
argument_list|(
name|cp
argument_list|,
name|tlen
argument_list|,
name|h
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
operator|*
name|epp
operator|=
name|ep
expr_stmt|;
return|return
operator|(
name|tidx
operator|)
return|;
block|}
comment|/* No, we must create a new type. */
name|tp
operator|=
name|xalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|type_t
argument_list|)
argument_list|)
expr_stmt|;
name|tidx
operator|=
name|storetyp
argument_list|(
name|tp
argument_list|,
name|cp
argument_list|,
name|tlen
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|c
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
while|while
condition|(
name|c
operator|==
literal|'c'
operator|||
name|c
operator|==
literal|'v'
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'c'
condition|)
block|{
name|tp
operator|->
name|t_const
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|tp
operator|->
name|t_volatile
operator|=
literal|1
expr_stmt|;
block|}
name|c
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|'s'
operator|||
name|c
operator|==
literal|'u'
operator|||
name|c
operator|==
literal|'l'
operator|||
name|c
operator|==
literal|'e'
condition|)
block|{
name|s
operator|=
name|c
expr_stmt|;
name|c
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
block|}
else|else
block|{
name|s
operator|=
literal|'\0'
expr_stmt|;
block|}
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'C'
case|:
name|tp
operator|->
name|t_tspec
operator|=
name|s
operator|==
literal|'s'
condition|?
name|SCHAR
else|:
operator|(
name|s
operator|==
literal|'u'
condition|?
name|UCHAR
else|:
name|CHAR
operator|)
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|tp
operator|->
name|t_tspec
operator|=
name|s
operator|==
literal|'u'
condition|?
name|USHORT
else|:
name|SHORT
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
name|tp
operator|->
name|t_tspec
operator|=
name|s
operator|==
literal|'u'
condition|?
name|UINT
else|:
name|INT
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
name|tp
operator|->
name|t_tspec
operator|=
name|s
operator|==
literal|'u'
condition|?
name|ULONG
else|:
name|LONG
expr_stmt|;
break|break;
case|case
literal|'Q'
case|:
name|tp
operator|->
name|t_tspec
operator|=
name|s
operator|==
literal|'u'
condition|?
name|UQUAD
else|:
name|QUAD
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|tp
operator|->
name|t_tspec
operator|=
name|s
operator|==
literal|'s'
condition|?
name|FLOAT
else|:
operator|(
name|s
operator|==
literal|'l'
condition|?
name|LDOUBLE
else|:
name|DOUBLE
operator|)
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
name|tp
operator|->
name|t_tspec
operator|=
name|VOID
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
name|tp
operator|->
name|t_tspec
operator|=
name|PTR
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
name|tp
operator|->
name|t_tspec
operator|=
name|ARRAY
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
case|case
literal|'f'
case|:
name|osdef
operator|=
name|c
operator|==
literal|'f'
expr_stmt|;
name|tp
operator|->
name|t_tspec
operator|=
name|FUNC
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
name|tp
operator|->
name|t_tspec
operator|=
name|s
operator|==
literal|'e'
condition|?
name|ENUM
else|:
operator|(
name|s
operator|==
literal|'s'
condition|?
name|STRUCT
else|:
name|UNION
operator|)
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|tp
operator|->
name|t_tspec
condition|)
block|{
case|case
name|ARRAY
case|:
name|tp
operator|->
name|t_dim
operator|=
operator|(
name|int
operator|)
name|strtol
argument_list|(
name|cp
argument_list|,
operator|&
name|eptr
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|cp
operator|=
name|eptr
expr_stmt|;
name|tp
operator|->
name|t_subt
operator|=
name|TP
argument_list|(
name|inptype
argument_list|(
name|cp
argument_list|,
operator|&
name|cp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|PTR
case|:
name|tp
operator|->
name|t_subt
operator|=
name|TP
argument_list|(
name|inptype
argument_list|(
name|cp
argument_list|,
operator|&
name|cp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FUNC
case|:
name|c
operator|=
operator|*
name|cp
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
operator|(
name|u_char
operator|)
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|osdef
condition|)
name|tp
operator|->
name|t_proto
operator|=
literal|1
expr_stmt|;
name|narg
operator|=
operator|(
name|int
operator|)
name|strtol
argument_list|(
name|cp
argument_list|,
operator|&
name|eptr
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|cp
operator|=
name|eptr
expr_stmt|;
name|tp
operator|->
name|t_args
operator|=
name|xcalloc
argument_list|(
call|(
name|size_t
call|)
argument_list|(
name|narg
operator|+
literal|1
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|type_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|narg
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
name|narg
operator|-
literal|1
operator|&&
operator|*
name|cp
operator|==
literal|'E'
condition|)
block|{
name|tp
operator|->
name|t_vararg
operator|=
literal|1
expr_stmt|;
name|cp
operator|++
expr_stmt|;
block|}
else|else
block|{
name|tp
operator|->
name|t_args
index|[
name|i
index|]
operator|=
name|TP
argument_list|(
name|inptype
argument_list|(
name|cp
argument_list|,
operator|&
name|cp
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|tp
operator|->
name|t_subt
operator|=
name|TP
argument_list|(
name|inptype
argument_list|(
name|cp
argument_list|,
operator|&
name|cp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENUM
case|:
name|tp
operator|->
name|t_tspec
operator|=
name|INT
expr_stmt|;
name|tp
operator|->
name|t_isenum
operator|=
literal|1
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|STRUCT
case|:
case|case
name|UNION
case|:
switch|switch
condition|(
operator|*
name|cp
operator|++
condition|)
block|{
case|case
literal|'0'
case|:
break|break;
case|case
literal|'1'
case|:
name|tp
operator|->
name|t_istag
operator|=
literal|1
expr_stmt|;
name|tp
operator|->
name|t_tag
operator|=
name|hsearch
argument_list|(
name|inpname
argument_list|(
name|cp
argument_list|,
operator|&
name|cp
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'2'
case|:
name|tp
operator|->
name|t_istynam
operator|=
literal|1
expr_stmt|;
name|tp
operator|->
name|t_tynam
operator|=
name|hsearch
argument_list|(
name|inpname
argument_list|(
name|cp
argument_list|,
operator|&
name|cp
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
comment|/* LINTED (enumeration value(s) not handled in switch) */
block|}
operator|*
name|epp
operator|=
name|cp
expr_stmt|;
return|return
operator|(
name|tidx
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Get the length of a type string.  */
end_comment

begin_function
specifier|static
name|int
name|gettlen
parameter_list|(
name|cp
parameter_list|,
name|epp
parameter_list|)
specifier|const
name|char
modifier|*
name|cp
decl_stmt|,
decl|*
modifier|*
name|epp
decl_stmt|;
end_function

begin_block
block|{
specifier|const
name|char
modifier|*
name|cp1
decl_stmt|;
name|char
name|c
decl_stmt|,
name|s
decl_stmt|,
modifier|*
name|eptr
decl_stmt|;
name|tspec_t
name|t
decl_stmt|;
name|int
name|narg
decl_stmt|,
name|i
decl_stmt|,
name|cm
decl_stmt|,
name|vm
decl_stmt|;
name|cp1
operator|=
name|cp
expr_stmt|;
name|c
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
name|cm
operator|=
name|vm
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|c
operator|==
literal|'c'
operator|||
name|c
operator|==
literal|'v'
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'c'
condition|)
block|{
if|if
condition|(
name|cm
condition|)
name|inperr
argument_list|()
expr_stmt|;
name|cm
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|vm
condition|)
name|inperr
argument_list|()
expr_stmt|;
name|vm
operator|=
literal|1
expr_stmt|;
block|}
name|c
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|'s'
operator|||
name|c
operator|==
literal|'u'
operator|||
name|c
operator|==
literal|'l'
operator|||
name|c
operator|==
literal|'e'
condition|)
block|{
name|s
operator|=
name|c
expr_stmt|;
name|c
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
block|}
else|else
block|{
name|s
operator|=
literal|'\0'
expr_stmt|;
block|}
name|t
operator|=
name|NOTSPEC
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'C'
case|:
if|if
condition|(
name|s
operator|==
literal|'s'
condition|)
block|{
name|t
operator|=
name|SCHAR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
operator|==
literal|'u'
condition|)
block|{
name|t
operator|=
name|UCHAR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
operator|==
literal|'\0'
condition|)
block|{
name|t
operator|=
name|CHAR
expr_stmt|;
block|}
break|break;
case|case
literal|'S'
case|:
if|if
condition|(
name|s
operator|==
literal|'u'
condition|)
block|{
name|t
operator|=
name|USHORT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
operator|==
literal|'\0'
condition|)
block|{
name|t
operator|=
name|SHORT
expr_stmt|;
block|}
break|break;
case|case
literal|'I'
case|:
if|if
condition|(
name|s
operator|==
literal|'u'
condition|)
block|{
name|t
operator|=
name|UINT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
operator|==
literal|'\0'
condition|)
block|{
name|t
operator|=
name|INT
expr_stmt|;
block|}
break|break;
case|case
literal|'L'
case|:
if|if
condition|(
name|s
operator|==
literal|'u'
condition|)
block|{
name|t
operator|=
name|ULONG
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
operator|==
literal|'\0'
condition|)
block|{
name|t
operator|=
name|LONG
expr_stmt|;
block|}
break|break;
case|case
literal|'Q'
case|:
if|if
condition|(
name|s
operator|==
literal|'u'
condition|)
block|{
name|t
operator|=
name|UQUAD
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
operator|==
literal|'\0'
condition|)
block|{
name|t
operator|=
name|QUAD
expr_stmt|;
block|}
break|break;
case|case
literal|'D'
case|:
if|if
condition|(
name|s
operator|==
literal|'s'
condition|)
block|{
name|t
operator|=
name|FLOAT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
operator|==
literal|'l'
condition|)
block|{
name|t
operator|=
name|LDOUBLE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
operator|==
literal|'\0'
condition|)
block|{
name|t
operator|=
name|DOUBLE
expr_stmt|;
block|}
break|break;
case|case
literal|'V'
case|:
if|if
condition|(
name|s
operator|==
literal|'\0'
condition|)
name|t
operator|=
name|VOID
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
if|if
condition|(
name|s
operator|==
literal|'\0'
condition|)
name|t
operator|=
name|PTR
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
if|if
condition|(
name|s
operator|==
literal|'\0'
condition|)
name|t
operator|=
name|ARRAY
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
case|case
literal|'f'
case|:
if|if
condition|(
name|s
operator|==
literal|'\0'
condition|)
name|t
operator|=
name|FUNC
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
if|if
condition|(
name|s
operator|==
literal|'e'
condition|)
block|{
name|t
operator|=
name|ENUM
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
operator|==
literal|'s'
condition|)
block|{
name|t
operator|=
name|STRUCT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
operator|==
literal|'u'
condition|)
block|{
name|t
operator|=
name|UNION
expr_stmt|;
block|}
break|break;
default|default:
name|inperr
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|==
name|NOTSPEC
condition|)
name|inperr
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|t
condition|)
block|{
case|case
name|ARRAY
case|:
operator|(
name|void
operator|)
name|strtol
argument_list|(
name|cp
argument_list|,
operator|&
name|eptr
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|eptr
condition|)
name|inperr
argument_list|()
expr_stmt|;
name|cp
operator|=
name|eptr
expr_stmt|;
operator|(
name|void
operator|)
name|gettlen
argument_list|(
name|cp
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
break|break;
case|case
name|PTR
case|:
operator|(
name|void
operator|)
name|gettlen
argument_list|(
name|cp
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
break|break;
case|case
name|FUNC
case|:
name|c
operator|=
operator|*
name|cp
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
operator|(
name|u_char
operator|)
name|c
argument_list|)
condition|)
block|{
name|narg
operator|=
operator|(
name|int
operator|)
name|strtol
argument_list|(
name|cp
argument_list|,
operator|&
name|eptr
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|cp
operator|=
name|eptr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|narg
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
name|narg
operator|-
literal|1
operator|&&
operator|*
name|cp
operator|==
literal|'E'
condition|)
block|{
name|cp
operator|++
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|gettlen
argument_list|(
name|cp
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
operator|(
name|void
operator|)
name|gettlen
argument_list|(
name|cp
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENUM
case|:
case|case
name|STRUCT
case|:
case|case
name|UNION
case|:
switch|switch
condition|(
operator|*
name|cp
operator|++
condition|)
block|{
case|case
literal|'0'
case|:
break|break;
case|case
literal|'1'
case|:
operator|(
name|void
operator|)
name|inpname
argument_list|(
name|cp
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'2'
case|:
operator|(
name|void
operator|)
name|inpname
argument_list|(
name|cp
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
break|break;
default|default:
name|inperr
argument_list|()
expr_stmt|;
block|}
break|break;
comment|/* LINTED (enumeration value(s) not handled in switch) */
block|}
operator|*
name|epp
operator|=
name|cp
expr_stmt|;
return|return
operator|(
name|cp
operator|-
name|cp1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Search a type by it's type string.  */
end_comment

begin_function
specifier|static
name|u_short
name|findtype
parameter_list|(
name|cp
parameter_list|,
name|len
parameter_list|,
name|h
parameter_list|)
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|int
name|h
decl_stmt|;
block|{
name|thtab_t
modifier|*
name|thte
decl_stmt|;
for|for
control|(
name|thte
operator|=
name|thtab
index|[
name|h
index|]
init|;
name|thte
operator|!=
name|NULL
condition|;
name|thte
operator|=
name|thte
operator|->
name|th_nxt
control|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|thte
operator|->
name|th_name
argument_list|,
name|cp
argument_list|,
name|len
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|thte
operator|->
name|th_name
index|[
name|len
index|]
operator|==
literal|'\0'
condition|)
return|return
operator|(
name|thte
operator|->
name|th_idx
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Store a type and it's type string so we can later share this type  * if we read the same type string from the input file.  */
end_comment

begin_function
specifier|static
name|u_short
name|storetyp
parameter_list|(
name|tp
parameter_list|,
name|cp
parameter_list|,
name|len
parameter_list|,
name|h
parameter_list|)
name|type_t
modifier|*
name|tp
decl_stmt|;
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|int
name|h
decl_stmt|;
block|{
comment|/* 0 ist reserved */
specifier|static
name|u_int
name|tidx
init|=
literal|1
decl_stmt|;
name|thtab_t
modifier|*
name|thte
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|tidx
operator|>=
name|USHRT_MAX
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"sorry, too many types"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tidx
operator|==
name|tlstlen
operator|-
literal|1
condition|)
block|{
name|tlst
operator|=
name|xrealloc
argument_list|(
name|tlst
argument_list|,
operator|(
name|tlstlen
operator|*
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|type_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|memset
argument_list|(
name|tlst
operator|+
name|tlstlen
argument_list|,
literal|0
argument_list|,
name|tlstlen
operator|*
sizeof|sizeof
argument_list|(
name|type_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|tlstlen
operator|*=
literal|2
expr_stmt|;
block|}
name|tlst
index|[
name|tidx
index|]
operator|=
name|tp
expr_stmt|;
comment|/* create a hash table entry */
name|name
operator|=
name|xalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|memcpy
argument_list|(
name|name
argument_list|,
name|cp
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|name
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|thte
operator|=
name|xalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|thtab_t
argument_list|)
argument_list|)
expr_stmt|;
name|thte
operator|->
name|th_name
operator|=
name|name
expr_stmt|;
name|thte
operator|->
name|th_idx
operator|=
name|tidx
expr_stmt|;
name|thte
operator|->
name|th_nxt
operator|=
name|thtab
index|[
name|h
index|]
expr_stmt|;
name|thtab
index|[
name|h
index|]
operator|=
name|thte
expr_stmt|;
return|return
operator|(
operator|(
name|u_short
operator|)
name|tidx
operator|++
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Hash function for types  */
end_comment

begin_function
specifier|static
name|int
name|thash
parameter_list|(
name|s
parameter_list|,
name|len
parameter_list|)
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|size_t
name|len
decl_stmt|;
block|{
name|u_int
name|v
decl_stmt|;
name|v
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|len
operator|--
operator|!=
literal|0
condition|)
block|{
name|v
operator|=
operator|(
name|v
operator|<<
sizeof|sizeof
argument_list|(
name|v
argument_list|)
operator|)
operator|+
operator|(
name|u_char
operator|)
operator|*
name|s
operator|++
expr_stmt|;
name|v
operator|^=
name|v
operator|>>
operator|(
sizeof|sizeof
argument_list|(
name|v
argument_list|)
operator|*
name|CHAR_BIT
operator|-
sizeof|sizeof
argument_list|(
name|v
argument_list|)
operator|)
expr_stmt|;
block|}
return|return
operator|(
name|v
operator|%
name|THSHSIZ2
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read a string enclosed by "". This string may contain quoted chars.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|inpqstrg
parameter_list|(
name|src
parameter_list|,
name|epp
parameter_list|)
specifier|const
name|char
modifier|*
name|src
decl_stmt|,
decl|*
modifier|*
name|epp
decl_stmt|;
end_function

begin_block
block|{
name|char
modifier|*
name|strg
decl_stmt|,
modifier|*
name|dst
decl_stmt|;
name|size_t
name|slen
decl_stmt|;
name|int
name|c
decl_stmt|;
name|int
name|v
decl_stmt|;
name|dst
operator|=
name|strg
operator|=
name|xmalloc
argument_list|(
name|slen
operator|=
literal|32
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
operator|*
name|src
operator|++
operator|)
operator|!=
literal|'"'
condition|)
name|inperr
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
operator|*
name|src
operator|++
operator|)
operator|==
literal|'\0'
condition|)
name|inperr
argument_list|()
expr_stmt|;
while|while
condition|(
name|c
operator|!=
literal|'"'
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
operator|*
name|src
operator|++
operator|)
operator|==
literal|'\0'
condition|)
name|inperr
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'n'
case|:
name|c
operator|=
literal|'\n'
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|c
operator|=
literal|'\t'
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
ifdef|#
directive|ifdef
name|__STDC__
name|c
operator|=
literal|'\v'
expr_stmt|;
else|#
directive|else
name|c
operator|=
literal|'\013'
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|'b'
case|:
name|c
operator|=
literal|'\b'
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|c
operator|=
literal|'\r'
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|c
operator|=
literal|'\f'
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
ifdef|#
directive|ifdef
name|__STDC__
name|c
operator|=
literal|'\a'
expr_stmt|;
else|#
directive|else
name|c
operator|=
literal|'\007'
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|'\\'
case|:
name|c
operator|=
literal|'\\'
expr_stmt|;
break|break;
case|case
literal|'"'
case|:
name|c
operator|=
literal|'"'
expr_stmt|;
break|break;
case|case
literal|'\''
case|:
name|c
operator|=
literal|'\''
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
name|v
operator|=
operator|(
name|c
operator|-
literal|'0'
operator|)
operator|<<
literal|6
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
operator|*
name|src
operator|++
operator|)
operator|<
literal|'0'
operator|||
name|c
operator|>
literal|'7'
condition|)
name|inperr
argument_list|()
expr_stmt|;
name|v
operator||=
operator|(
name|c
operator|-
literal|'0'
operator|)
operator|<<
literal|3
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
operator|*
name|src
operator|++
operator|)
operator|<
literal|'0'
operator|||
name|c
operator|>
literal|'7'
condition|)
name|inperr
argument_list|()
expr_stmt|;
name|v
operator||=
name|c
operator|-
literal|'0'
expr_stmt|;
name|c
operator|=
operator|(
name|u_char
operator|)
name|v
expr_stmt|;
break|break;
default|default:
name|inperr
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* keep space for trailing '\0' */
if|if
condition|(
name|dst
operator|-
name|strg
operator|==
name|slen
operator|-
literal|1
condition|)
block|{
name|strg
operator|=
name|xrealloc
argument_list|(
name|strg
argument_list|,
name|slen
operator|*
literal|2
argument_list|)
expr_stmt|;
name|dst
operator|=
name|strg
operator|+
operator|(
name|slen
operator|-
literal|1
operator|)
expr_stmt|;
name|slen
operator|*=
literal|2
expr_stmt|;
block|}
operator|*
name|dst
operator|++
operator|=
operator|(
name|char
operator|)
name|c
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
operator|*
name|src
operator|++
operator|)
operator|==
literal|'\0'
condition|)
name|inperr
argument_list|()
expr_stmt|;
block|}
operator|*
name|dst
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|epp
operator|=
name|src
expr_stmt|;
return|return
operator|(
name|strg
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Read the name of a symbol in static memory.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|inpname
parameter_list|(
name|cp
parameter_list|,
name|epp
parameter_list|)
specifier|const
name|char
modifier|*
name|cp
decl_stmt|,
decl|*
modifier|*
name|epp
decl_stmt|;
end_function

begin_block
block|{
specifier|static
name|char
modifier|*
name|buf
decl_stmt|;
specifier|static
name|size_t
name|blen
init|=
literal|0
decl_stmt|;
name|size_t
name|len
decl_stmt|,
name|i
decl_stmt|;
name|char
modifier|*
name|eptr
decl_stmt|,
name|c
decl_stmt|;
name|len
operator|=
operator|(
name|int
operator|)
name|strtol
argument_list|(
name|cp
argument_list|,
operator|&
name|eptr
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|eptr
condition|)
name|inperr
argument_list|()
expr_stmt|;
name|cp
operator|=
name|eptr
expr_stmt|;
if|if
condition|(
name|len
operator|+
literal|1
operator|>
name|blen
condition|)
name|buf
operator|=
name|xrealloc
argument_list|(
name|buf
argument_list|,
name|blen
operator|=
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|isalnum
argument_list|(
name|c
argument_list|)
operator|&&
name|c
operator|!=
literal|'_'
condition|)
name|inperr
argument_list|()
expr_stmt|;
name|buf
index|[
name|i
index|]
operator|=
name|c
expr_stmt|;
block|}
name|buf
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|epp
operator|=
name|cp
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Return the index of a file name. If the name cannot be found, create  * a new entry and return the index of the newly created entry.  */
end_comment

begin_function
specifier|static
name|int
name|getfnidx
parameter_list|(
name|fn
parameter_list|)
specifier|const
name|char
modifier|*
name|fn
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
comment|/* 0 ist reserved */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|fnames
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|fnames
index|[
name|i
index|]
argument_list|,
name|fn
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|fnames
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
return|return
operator|(
name|i
operator|)
return|;
if|if
condition|(
name|i
operator|==
name|nfnames
operator|-
literal|1
condition|)
block|{
name|fnames
operator|=
name|xrealloc
argument_list|(
name|fnames
argument_list|,
operator|(
name|nfnames
operator|*
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|memset
argument_list|(
name|fnames
operator|+
name|nfnames
argument_list|,
literal|0
argument_list|,
name|nfnames
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|nfnames
operator|*=
literal|2
expr_stmt|;
block|}
name|fnames
index|[
name|i
index|]
operator|=
name|xstrdup
argument_list|(
name|fn
argument_list|)
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Separate symbols with static and external linkage.  */
end_comment

begin_function
name|void
name|mkstatic
parameter_list|(
name|hte
parameter_list|)
name|hte_t
modifier|*
name|hte
decl_stmt|;
block|{
name|sym_t
modifier|*
name|sym1
decl_stmt|,
modifier|*
modifier|*
name|symp
decl_stmt|,
modifier|*
name|sym
decl_stmt|;
name|fcall_t
modifier|*
modifier|*
name|callp
decl_stmt|,
modifier|*
name|call
decl_stmt|;
name|usym_t
modifier|*
modifier|*
name|usymp
decl_stmt|,
modifier|*
name|usym
decl_stmt|;
name|hte_t
modifier|*
name|nhte
decl_stmt|;
name|int
name|ofnd
decl_stmt|;
comment|/* Look for first static definition */
for|for
control|(
name|sym1
operator|=
name|hte
operator|->
name|h_syms
init|;
name|sym1
operator|!=
name|NULL
condition|;
name|sym1
operator|=
name|sym1
operator|->
name|s_nxt
control|)
block|{
if|if
condition|(
name|sym1
operator|->
name|s_static
condition|)
break|break;
block|}
if|if
condition|(
name|sym1
operator|==
name|NULL
condition|)
return|return;
comment|/* Do nothing if this name is used only in one translation unit. */
name|ofnd
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|sym
operator|=
name|hte
operator|->
name|h_syms
init|;
name|sym
operator|!=
name|NULL
operator|&&
operator|!
name|ofnd
condition|;
name|sym
operator|=
name|sym
operator|->
name|s_nxt
control|)
block|{
if|if
condition|(
name|sym
operator|->
name|s_pos
operator|.
name|p_src
operator|!=
name|sym1
operator|->
name|s_pos
operator|.
name|p_src
condition|)
name|ofnd
operator|=
literal|1
expr_stmt|;
block|}
for|for
control|(
name|call
operator|=
name|hte
operator|->
name|h_calls
init|;
name|call
operator|!=
name|NULL
operator|&&
operator|!
name|ofnd
condition|;
name|call
operator|=
name|call
operator|->
name|f_nxt
control|)
block|{
if|if
condition|(
name|call
operator|->
name|f_pos
operator|.
name|p_src
operator|!=
name|sym1
operator|->
name|s_pos
operator|.
name|p_src
condition|)
name|ofnd
operator|=
literal|1
expr_stmt|;
block|}
for|for
control|(
name|usym
operator|=
name|hte
operator|->
name|h_usyms
init|;
name|usym
operator|!=
name|NULL
operator|&&
operator|!
name|ofnd
condition|;
name|usym
operator|=
name|usym
operator|->
name|u_nxt
control|)
block|{
if|if
condition|(
name|usym
operator|->
name|u_pos
operator|.
name|p_src
operator|!=
name|sym1
operator|->
name|s_pos
operator|.
name|p_src
condition|)
name|ofnd
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ofnd
condition|)
block|{
name|hte
operator|->
name|h_used
operator|=
literal|1
expr_stmt|;
comment|/* errors about undef. static symbols are printed in lint1 */
name|hte
operator|->
name|h_def
operator|=
literal|1
expr_stmt|;
name|hte
operator|->
name|h_static
operator|=
literal|1
expr_stmt|;
return|return;
block|}
comment|/* 	 * Create a new hash table entry 	 * 	 * XXX this entry should be put at the beginning of the list to 	 * avoid to process the same symbol twice. 	 */
for|for
control|(
name|nhte
operator|=
name|hte
init|;
name|nhte
operator|->
name|h_link
operator|!=
name|NULL
condition|;
name|nhte
operator|=
name|nhte
operator|->
name|h_link
control|)
empty_stmt|;
name|nhte
operator|->
name|h_link
operator|=
name|xalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|hte_t
argument_list|)
argument_list|)
expr_stmt|;
name|nhte
operator|=
name|nhte
operator|->
name|h_link
expr_stmt|;
name|nhte
operator|->
name|h_name
operator|=
name|hte
operator|->
name|h_name
expr_stmt|;
name|nhte
operator|->
name|h_static
operator|=
literal|1
expr_stmt|;
name|nhte
operator|->
name|h_used
operator|=
literal|1
expr_stmt|;
name|nhte
operator|->
name|h_def
operator|=
literal|1
expr_stmt|;
comment|/* error in lint1 */
name|nhte
operator|->
name|h_lsym
operator|=
operator|&
name|nhte
operator|->
name|h_syms
expr_stmt|;
name|nhte
operator|->
name|h_lcall
operator|=
operator|&
name|nhte
operator|->
name|h_calls
expr_stmt|;
name|nhte
operator|->
name|h_lusym
operator|=
operator|&
name|nhte
operator|->
name|h_usyms
expr_stmt|;
comment|/* 	 * move all symbols used in this translation unit into the new 	 * hash table entry. 	 */
for|for
control|(
name|symp
operator|=
operator|&
name|hte
operator|->
name|h_syms
init|;
operator|(
name|sym
operator|=
operator|*
name|symp
operator|)
operator|!=
name|NULL
condition|;
control|)
block|{
if|if
condition|(
name|sym
operator|->
name|s_pos
operator|.
name|p_src
operator|==
name|sym1
operator|->
name|s_pos
operator|.
name|p_src
condition|)
block|{
name|sym
operator|->
name|s_static
operator|=
literal|1
expr_stmt|;
operator|(
operator|*
name|symp
operator|)
operator|=
name|sym
operator|->
name|s_nxt
expr_stmt|;
if|if
condition|(
name|hte
operator|->
name|h_lsym
operator|==
operator|&
name|sym
operator|->
name|s_nxt
condition|)
name|hte
operator|->
name|h_lsym
operator|=
name|symp
expr_stmt|;
name|sym
operator|->
name|s_nxt
operator|=
name|NULL
expr_stmt|;
operator|*
name|nhte
operator|->
name|h_lsym
operator|=
name|sym
expr_stmt|;
name|nhte
operator|->
name|h_lsym
operator|=
operator|&
name|sym
operator|->
name|s_nxt
expr_stmt|;
block|}
else|else
block|{
name|symp
operator|=
operator|&
name|sym
operator|->
name|s_nxt
expr_stmt|;
block|}
block|}
for|for
control|(
name|callp
operator|=
operator|&
name|hte
operator|->
name|h_calls
init|;
operator|(
name|call
operator|=
operator|*
name|callp
operator|)
operator|!=
name|NULL
condition|;
control|)
block|{
if|if
condition|(
name|call
operator|->
name|f_pos
operator|.
name|p_src
operator|==
name|sym1
operator|->
name|s_pos
operator|.
name|p_src
condition|)
block|{
operator|(
operator|*
name|callp
operator|)
operator|=
name|call
operator|->
name|f_nxt
expr_stmt|;
if|if
condition|(
name|hte
operator|->
name|h_lcall
operator|==
operator|&
name|call
operator|->
name|f_nxt
condition|)
name|hte
operator|->
name|h_lcall
operator|=
name|callp
expr_stmt|;
name|call
operator|->
name|f_nxt
operator|=
name|NULL
expr_stmt|;
operator|*
name|nhte
operator|->
name|h_lcall
operator|=
name|call
expr_stmt|;
name|nhte
operator|->
name|h_lcall
operator|=
operator|&
name|call
operator|->
name|f_nxt
expr_stmt|;
block|}
else|else
block|{
name|callp
operator|=
operator|&
name|call
operator|->
name|f_nxt
expr_stmt|;
block|}
block|}
for|for
control|(
name|usymp
operator|=
operator|&
name|hte
operator|->
name|h_usyms
init|;
operator|(
name|usym
operator|=
operator|*
name|usymp
operator|)
operator|!=
name|NULL
condition|;
control|)
block|{
if|if
condition|(
name|usym
operator|->
name|u_pos
operator|.
name|p_src
operator|==
name|sym1
operator|->
name|s_pos
operator|.
name|p_src
condition|)
block|{
operator|(
operator|*
name|usymp
operator|)
operator|=
name|usym
operator|->
name|u_nxt
expr_stmt|;
if|if
condition|(
name|hte
operator|->
name|h_lusym
operator|==
operator|&
name|usym
operator|->
name|u_nxt
condition|)
name|hte
operator|->
name|h_lusym
operator|=
name|usymp
expr_stmt|;
name|usym
operator|->
name|u_nxt
operator|=
name|NULL
expr_stmt|;
operator|*
name|nhte
operator|->
name|h_lusym
operator|=
name|usym
expr_stmt|;
name|nhte
operator|->
name|h_lusym
operator|=
operator|&
name|usym
operator|->
name|u_nxt
expr_stmt|;
block|}
else|else
block|{
name|usymp
operator|=
operator|&
name|usym
operator|->
name|u_nxt
expr_stmt|;
block|}
block|}
comment|/* h_def must be recalculated for old hte */
name|hte
operator|->
name|h_def
operator|=
name|nhte
operator|->
name|h_def
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|sym
operator|=
name|hte
operator|->
name|h_syms
init|;
name|sym
operator|!=
name|NULL
condition|;
name|sym
operator|=
name|sym
operator|->
name|s_nxt
control|)
block|{
if|if
condition|(
name|sym
operator|->
name|s_def
operator|==
name|DEF
operator|||
name|sym
operator|->
name|s_def
operator|==
name|TDEF
condition|)
block|{
name|hte
operator|->
name|h_def
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
name|mkstatic
argument_list|(
name|hte
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

