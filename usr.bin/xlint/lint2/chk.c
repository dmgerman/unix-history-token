begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $NetBSD: chk.c,v 1.15 2002/01/21 19:49:52 tv Exp $ */
end_comment

begin_comment
comment|/*  * Copyright (c) 1996 Christopher G. Demetriou.  All Rights Reserved.  * Copyright (c) 1994, 1995 Jochen Pohl  * All Rights Reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *      This product includes software developed by Jochen Pohl for  *	The NetBSD Project.  * 4. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__RCSID
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
end_if

begin_expr_stmt
name|__RCSID
argument_list|(
literal|"$NetBSD: chk.c,v 1.15 2002/01/21 19:49:52 tv Exp $"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|"lint2.h"
end_include

begin_function_decl
specifier|static
name|void
name|chkund
parameter_list|(
name|hte_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|chkdnu
parameter_list|(
name|hte_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|chkdnud
parameter_list|(
name|hte_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|chkmd
parameter_list|(
name|hte_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|chkvtui
parameter_list|(
name|hte_t
modifier|*
parameter_list|,
name|sym_t
modifier|*
parameter_list|,
name|sym_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|chkvtdi
parameter_list|(
name|hte_t
modifier|*
parameter_list|,
name|sym_t
modifier|*
parameter_list|,
name|sym_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|chkfaui
parameter_list|(
name|hte_t
modifier|*
parameter_list|,
name|sym_t
modifier|*
parameter_list|,
name|sym_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|chkau
parameter_list|(
name|hte_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|sym_t
modifier|*
parameter_list|,
name|sym_t
modifier|*
parameter_list|,
name|pos_t
modifier|*
parameter_list|,
name|fcall_t
modifier|*
parameter_list|,
name|fcall_t
modifier|*
parameter_list|,
name|type_t
modifier|*
parameter_list|,
name|type_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|chkrvu
parameter_list|(
name|hte_t
modifier|*
parameter_list|,
name|sym_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|chkadecl
parameter_list|(
name|hte_t
modifier|*
parameter_list|,
name|sym_t
modifier|*
parameter_list|,
name|sym_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|printflike
parameter_list|(
name|hte_t
modifier|*
parameter_list|,
name|fcall_t
modifier|*
parameter_list|,
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|type_t
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|scanflike
parameter_list|(
name|hte_t
modifier|*
parameter_list|,
name|fcall_t
modifier|*
parameter_list|,
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|type_t
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|badfmt
parameter_list|(
name|hte_t
modifier|*
parameter_list|,
name|fcall_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|inconarg
parameter_list|(
name|hte_t
modifier|*
parameter_list|,
name|fcall_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|tofewarg
parameter_list|(
name|hte_t
modifier|*
parameter_list|,
name|fcall_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|tomanyarg
parameter_list|(
name|hte_t
modifier|*
parameter_list|,
name|fcall_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|eqtype
parameter_list|(
name|type_t
modifier|*
parameter_list|,
name|type_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|eqargs
parameter_list|(
name|type_t
modifier|*
parameter_list|,
name|type_t
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mnoarg
parameter_list|(
name|type_t
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * If there is a symbol named "main", mark it as used.  */
end_comment

begin_function
name|void
name|mainused
parameter_list|(
name|void
parameter_list|)
block|{
name|hte_t
modifier|*
name|hte
decl_stmt|;
if|if
condition|(
operator|(
name|hte
operator|=
name|hsearch
argument_list|(
literal|"main"
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|hte
operator|->
name|h_used
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Performs all tests for a single name  */
end_comment

begin_function
name|void
name|chkname
parameter_list|(
name|hte_t
modifier|*
name|hte
parameter_list|)
block|{
name|sym_t
modifier|*
name|sym
decl_stmt|,
modifier|*
name|def
decl_stmt|,
modifier|*
name|pdecl
decl_stmt|,
modifier|*
name|decl
decl_stmt|;
if|if
condition|(
name|uflag
condition|)
block|{
name|chkund
argument_list|(
name|hte
argument_list|)
expr_stmt|;
name|chkdnu
argument_list|(
name|hte
argument_list|)
expr_stmt|;
if|if
condition|(
name|xflag
condition|)
name|chkdnud
argument_list|(
name|hte
argument_list|)
expr_stmt|;
block|}
name|chkmd
argument_list|(
name|hte
argument_list|)
expr_stmt|;
comment|/* Get definition, prototype declaration and declaration */
name|def
operator|=
name|pdecl
operator|=
name|decl
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|sym
operator|=
name|hte
operator|->
name|h_syms
init|;
name|sym
operator|!=
name|NULL
condition|;
name|sym
operator|=
name|sym
operator|->
name|s_nxt
control|)
block|{
if|if
condition|(
name|def
operator|==
name|NULL
operator|&&
operator|(
name|sym
operator|->
name|s_def
operator|==
name|DEF
operator|||
name|sym
operator|->
name|s_def
operator|==
name|TDEF
operator|)
condition|)
name|def
operator|=
name|sym
expr_stmt|;
if|if
condition|(
name|pdecl
operator|==
name|NULL
operator|&&
name|sym
operator|->
name|s_def
operator|==
name|DECL
operator|&&
name|TP
argument_list|(
name|sym
operator|->
name|s_type
argument_list|)
operator|->
name|t_tspec
operator|==
name|FUNC
operator|&&
name|TP
argument_list|(
name|sym
operator|->
name|s_type
argument_list|)
operator|->
name|t_proto
condition|)
block|{
name|pdecl
operator|=
name|sym
expr_stmt|;
block|}
if|if
condition|(
name|decl
operator|==
name|NULL
operator|&&
name|sym
operator|->
name|s_def
operator|==
name|DECL
condition|)
name|decl
operator|=
name|sym
expr_stmt|;
block|}
comment|/* A prototype is better than an old style declaration. */
if|if
condition|(
name|pdecl
operator|!=
name|NULL
condition|)
name|decl
operator|=
name|pdecl
expr_stmt|;
name|chkvtui
argument_list|(
name|hte
argument_list|,
name|def
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|chkvtdi
argument_list|(
name|hte
argument_list|,
name|def
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|chkfaui
argument_list|(
name|hte
argument_list|,
name|def
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|chkrvu
argument_list|(
name|hte
argument_list|,
name|def
argument_list|)
expr_stmt|;
name|chkadecl
argument_list|(
name|hte
argument_list|,
name|def
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Print a warning if the name has been used, but not defined.  */
end_comment

begin_function
specifier|static
name|void
name|chkund
parameter_list|(
name|hte_t
modifier|*
name|hte
parameter_list|)
block|{
name|fcall_t
modifier|*
name|fcall
decl_stmt|;
name|usym_t
modifier|*
name|usym
decl_stmt|;
if|if
condition|(
operator|!
name|hte
operator|->
name|h_used
operator|||
name|hte
operator|->
name|h_def
condition|)
return|return;
if|if
condition|(
operator|(
name|fcall
operator|=
name|hte
operator|->
name|h_calls
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* %s used( %s ), but not defined */
name|msg
argument_list|(
literal|0
argument_list|,
name|hte
operator|->
name|h_name
argument_list|,
name|mkpos
argument_list|(
operator|&
name|fcall
operator|->
name|f_pos
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|usym
operator|=
name|hte
operator|->
name|h_usyms
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* %s used( %s ), but not defined */
name|msg
argument_list|(
literal|0
argument_list|,
name|hte
operator|->
name|h_name
argument_list|,
name|mkpos
argument_list|(
operator|&
name|usym
operator|->
name|u_pos
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Print a warning if the name has been defined, but never used.  */
end_comment

begin_function
specifier|static
name|void
name|chkdnu
parameter_list|(
name|hte_t
modifier|*
name|hte
parameter_list|)
block|{
name|sym_t
modifier|*
name|sym
decl_stmt|;
if|if
condition|(
operator|!
name|hte
operator|->
name|h_def
operator|||
name|hte
operator|->
name|h_used
condition|)
return|return;
for|for
control|(
name|sym
operator|=
name|hte
operator|->
name|h_syms
init|;
name|sym
operator|!=
name|NULL
condition|;
name|sym
operator|=
name|sym
operator|->
name|s_nxt
control|)
block|{
if|if
condition|(
name|sym
operator|->
name|s_def
operator|==
name|DEF
operator|||
name|sym
operator|->
name|s_def
operator|==
name|TDEF
condition|)
block|{
comment|/* %s defined( %s ), but never used */
name|msg
argument_list|(
literal|1
argument_list|,
name|hte
operator|->
name|h_name
argument_list|,
name|mkpos
argument_list|(
operator|&
name|sym
operator|->
name|s_pos
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Print a warning if the variable has been declared, but is not used  * or defined.  */
end_comment

begin_function
specifier|static
name|void
name|chkdnud
parameter_list|(
name|hte_t
modifier|*
name|hte
parameter_list|)
block|{
name|sym_t
modifier|*
name|sym
decl_stmt|;
if|if
condition|(
name|hte
operator|->
name|h_syms
operator|==
name|NULL
operator|||
name|hte
operator|->
name|h_used
operator|||
name|hte
operator|->
name|h_def
condition|)
return|return;
name|sym
operator|=
name|hte
operator|->
name|h_syms
expr_stmt|;
if|if
condition|(
name|TP
argument_list|(
name|sym
operator|->
name|s_type
argument_list|)
operator|->
name|t_tspec
operator|==
name|FUNC
condition|)
return|return;
if|if
condition|(
name|sym
operator|->
name|s_def
operator|!=
name|DECL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"internal error: chkdnud() 1"
argument_list|)
expr_stmt|;
comment|/* %s declared( %s ), but never used or defined */
name|msg
argument_list|(
literal|2
argument_list|,
name|hte
operator|->
name|h_name
argument_list|,
name|mkpos
argument_list|(
operator|&
name|sym
operator|->
name|s_pos
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Print a warning if there is more than one definition for  * this name.  */
end_comment

begin_function
specifier|static
name|void
name|chkmd
parameter_list|(
name|hte_t
modifier|*
name|hte
parameter_list|)
block|{
name|sym_t
modifier|*
name|sym
decl_stmt|,
modifier|*
name|def1
decl_stmt|;
name|char
modifier|*
name|pos1
decl_stmt|;
if|if
condition|(
operator|!
name|hte
operator|->
name|h_def
condition|)
return|return;
name|def1
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|sym
operator|=
name|hte
operator|->
name|h_syms
init|;
name|sym
operator|!=
name|NULL
condition|;
name|sym
operator|=
name|sym
operator|->
name|s_nxt
control|)
block|{
comment|/* 		 * ANSI C allows tentative definitions of the same name in 		 * only one compilation unit. 		 */
if|if
condition|(
name|sym
operator|->
name|s_def
operator|!=
name|DEF
operator|&&
operator|(
operator|!
name|sflag
operator|||
name|sym
operator|->
name|s_def
operator|!=
name|TDEF
operator|)
condition|)
continue|continue;
if|if
condition|(
name|def1
operator|==
name|NULL
condition|)
block|{
name|def1
operator|=
name|sym
expr_stmt|;
continue|continue;
block|}
name|pos1
operator|=
name|xstrdup
argument_list|(
name|mkpos
argument_list|(
operator|&
name|def1
operator|->
name|s_pos
argument_list|)
argument_list|)
expr_stmt|;
comment|/* %s multiply defined\t%s  ::  %s */
name|msg
argument_list|(
literal|3
argument_list|,
name|hte
operator|->
name|h_name
argument_list|,
name|pos1
argument_list|,
name|mkpos
argument_list|(
operator|&
name|sym
operator|->
name|s_pos
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pos1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Print a warning if the return value assumed for a function call  * differs from the return value of the function definition or  * function declaration.  *  * If no definition/declaration can be found, the assumed return values  * are always int. So there is no need to compare with another function  * call as it's done for function arguments.  */
end_comment

begin_function
specifier|static
name|void
name|chkvtui
parameter_list|(
name|hte_t
modifier|*
name|hte
parameter_list|,
name|sym_t
modifier|*
name|def
parameter_list|,
name|sym_t
modifier|*
name|decl
parameter_list|)
block|{
name|fcall_t
modifier|*
name|call
decl_stmt|;
name|char
modifier|*
name|pos1
decl_stmt|;
name|type_t
modifier|*
name|tp1
decl_stmt|,
modifier|*
name|tp2
decl_stmt|;
comment|/* LINTED (automatic hides external declaration: warn) */
name|int
name|warn
decl_stmt|,
name|eq
decl_stmt|;
name|tspec_t
name|t1
decl_stmt|;
if|if
condition|(
name|hte
operator|->
name|h_calls
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|def
operator|==
name|NULL
condition|)
name|def
operator|=
name|decl
expr_stmt|;
if|if
condition|(
name|def
operator|==
name|NULL
condition|)
return|return;
name|t1
operator|=
operator|(
name|tp1
operator|=
name|TP
argument_list|(
name|def
operator|->
name|s_type
argument_list|)
operator|->
name|t_subt
operator|)
operator|->
name|t_tspec
expr_stmt|;
for|for
control|(
name|call
operator|=
name|hte
operator|->
name|h_calls
init|;
name|call
operator|!=
name|NULL
condition|;
name|call
operator|=
name|call
operator|->
name|f_nxt
control|)
block|{
name|tp2
operator|=
name|TP
argument_list|(
name|call
operator|->
name|f_type
argument_list|)
operator|->
name|t_subt
expr_stmt|;
name|eq
operator|=
name|eqtype
argument_list|(
name|tp1
argument_list|,
name|tp2
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
name|warn
operator|=
literal|0
operator|,
operator|&
name|warn
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|call
operator|->
name|f_rused
condition|)
block|{
comment|/* no return value used */
if|if
condition|(
operator|(
name|t1
operator|==
name|STRUCT
operator|||
name|t1
operator|==
name|UNION
operator|)
operator|&&
operator|!
name|eq
condition|)
block|{
comment|/* 				 * If a function returns a struct or union it 				 * must be declared to return a struct or 				 * union, also if the return value is ignored. 				 * This is necessary because the caller must 				 * allocate stack space for the return value. 				 * If it does not, the return value would over- 				 * write other data. 				 * XXX Following massage may be confusing 				 * because it appears also if the return value 				 * was declared inconsistently. But this 				 * behaviour matches pcc based lint, so it is 				 * accepted for now. 				 */
name|pos1
operator|=
name|xstrdup
argument_list|(
name|mkpos
argument_list|(
operator|&
name|def
operator|->
name|s_pos
argument_list|)
argument_list|)
expr_stmt|;
comment|/* %s value must be decl. before use %s :: %s */
name|msg
argument_list|(
literal|17
argument_list|,
name|hte
operator|->
name|h_name
argument_list|,
name|pos1
argument_list|,
name|mkpos
argument_list|(
operator|&
name|call
operator|->
name|f_pos
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pos1
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
operator|!
name|eq
operator|||
operator|(
name|sflag
operator|&&
name|warn
operator|)
condition|)
block|{
name|pos1
operator|=
name|xstrdup
argument_list|(
name|mkpos
argument_list|(
operator|&
name|def
operator|->
name|s_pos
argument_list|)
argument_list|)
expr_stmt|;
comment|/* %s value used inconsistenty\t%s  ::  %s */
name|msg
argument_list|(
literal|4
argument_list|,
name|hte
operator|->
name|h_name
argument_list|,
name|pos1
argument_list|,
name|mkpos
argument_list|(
operator|&
name|call
operator|->
name|f_pos
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pos1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Print a warning if a definition/declaration does not match another  * definition/declaration of the same name. For functions, only the  * types of return values are tested.  */
end_comment

begin_function
specifier|static
name|void
name|chkvtdi
parameter_list|(
name|hte_t
modifier|*
name|hte
parameter_list|,
name|sym_t
modifier|*
name|def
parameter_list|,
name|sym_t
modifier|*
name|decl
parameter_list|)
block|{
name|sym_t
modifier|*
name|sym
decl_stmt|;
name|type_t
modifier|*
name|tp1
decl_stmt|,
modifier|*
name|tp2
decl_stmt|;
comment|/* LINTED (automatic hides external declaration: warn) */
name|int
name|eq
decl_stmt|,
name|warn
decl_stmt|;
name|char
modifier|*
name|pos1
decl_stmt|;
if|if
condition|(
name|def
operator|==
name|NULL
condition|)
name|def
operator|=
name|decl
expr_stmt|;
if|if
condition|(
name|def
operator|==
name|NULL
condition|)
return|return;
name|tp1
operator|=
name|TP
argument_list|(
name|def
operator|->
name|s_type
argument_list|)
expr_stmt|;
for|for
control|(
name|sym
operator|=
name|hte
operator|->
name|h_syms
init|;
name|sym
operator|!=
name|NULL
condition|;
name|sym
operator|=
name|sym
operator|->
name|s_nxt
control|)
block|{
if|if
condition|(
name|sym
operator|==
name|def
condition|)
continue|continue;
name|tp2
operator|=
name|TP
argument_list|(
name|sym
operator|->
name|s_type
argument_list|)
expr_stmt|;
name|warn
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tp1
operator|->
name|t_tspec
operator|==
name|FUNC
operator|&&
name|tp2
operator|->
name|t_tspec
operator|==
name|FUNC
condition|)
block|{
name|eq
operator|=
name|eqtype
argument_list|(
name|tp1
operator|->
name|t_subt
argument_list|,
name|tp2
operator|->
name|t_subt
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|warn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|eq
operator|=
name|eqtype
argument_list|(
name|tp1
argument_list|,
name|tp2
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|warn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|eq
operator|||
operator|(
name|sflag
operator|&&
name|warn
operator|)
condition|)
block|{
name|pos1
operator|=
name|xstrdup
argument_list|(
name|mkpos
argument_list|(
operator|&
name|def
operator|->
name|s_pos
argument_list|)
argument_list|)
expr_stmt|;
comment|/* %s value declared inconsistently\t%s  ::  %s */
name|msg
argument_list|(
literal|5
argument_list|,
name|hte
operator|->
name|h_name
argument_list|,
name|pos1
argument_list|,
name|mkpos
argument_list|(
operator|&
name|sym
operator|->
name|s_pos
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pos1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Print a warning if a function is called with arguments which does  * not match the function definition, declaration or another call  * of the same function.  */
end_comment

begin_function
specifier|static
name|void
name|chkfaui
parameter_list|(
name|hte_t
modifier|*
name|hte
parameter_list|,
name|sym_t
modifier|*
name|def
parameter_list|,
name|sym_t
modifier|*
name|decl
parameter_list|)
block|{
name|type_t
modifier|*
name|tp1
decl_stmt|,
modifier|*
name|tp2
decl_stmt|,
modifier|*
modifier|*
name|ap1
decl_stmt|,
modifier|*
modifier|*
name|ap2
decl_stmt|;
name|pos_t
modifier|*
name|pos1p
init|=
name|NULL
decl_stmt|;
name|fcall_t
modifier|*
name|calls
decl_stmt|,
modifier|*
name|call
decl_stmt|,
modifier|*
name|call1
decl_stmt|;
name|int
name|n
decl_stmt|,
name|as
decl_stmt|;
name|char
modifier|*
name|pos1
decl_stmt|;
name|arginf_t
modifier|*
name|ai
decl_stmt|;
if|if
condition|(
operator|(
name|calls
operator|=
name|hte
operator|->
name|h_calls
operator|)
operator|==
name|NULL
condition|)
return|return;
comment|/* 	 * If we find a function definition, we use this for comparison, 	 * otherwise the first prototype we can find. If there is no 	 * definition or prototype declaration, the first function call 	 * is used. 	 */
name|tp1
operator|=
name|NULL
expr_stmt|;
name|call1
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|def
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|tp1
operator|=
name|TP
argument_list|(
name|def
operator|->
name|s_type
argument_list|)
operator|)
operator|->
name|t_tspec
operator|!=
name|FUNC
condition|)
return|return;
name|pos1p
operator|=
operator|&
name|def
operator|->
name|s_pos
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|decl
operator|!=
name|NULL
operator|&&
name|TP
argument_list|(
name|decl
operator|->
name|s_type
argument_list|)
operator|->
name|t_proto
condition|)
block|{
if|if
condition|(
operator|(
name|tp1
operator|=
name|TP
argument_list|(
name|decl
operator|->
name|s_type
argument_list|)
operator|)
operator|->
name|t_tspec
operator|!=
name|FUNC
condition|)
return|return;
name|pos1p
operator|=
operator|&
name|decl
operator|->
name|s_pos
expr_stmt|;
block|}
if|if
condition|(
name|tp1
operator|==
name|NULL
condition|)
block|{
name|call1
operator|=
name|calls
expr_stmt|;
name|calls
operator|=
name|calls
operator|->
name|f_nxt
expr_stmt|;
if|if
condition|(
operator|(
name|tp1
operator|=
name|TP
argument_list|(
name|call1
operator|->
name|f_type
argument_list|)
operator|)
operator|->
name|t_tspec
operator|!=
name|FUNC
condition|)
return|return;
name|pos1p
operator|=
operator|&
name|call1
operator|->
name|f_pos
expr_stmt|;
block|}
name|n
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|call
operator|=
name|calls
init|;
name|call
operator|!=
name|NULL
condition|;
name|call
operator|=
name|call
operator|->
name|f_nxt
control|)
block|{
if|if
condition|(
operator|(
name|tp2
operator|=
name|TP
argument_list|(
name|call
operator|->
name|f_type
argument_list|)
operator|)
operator|->
name|t_tspec
operator|!=
name|FUNC
condition|)
continue|continue;
name|ap1
operator|=
name|tp1
operator|->
name|t_args
expr_stmt|;
name|ap2
operator|=
name|tp2
operator|->
name|t_args
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|ap1
operator|!=
name|NULL
operator|&&
operator|*
name|ap2
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|def
operator|!=
name|NULL
operator|&&
name|def
operator|->
name|s_va
operator|&&
name|n
operator|>=
name|def
operator|->
name|s_nva
condition|)
break|break;
name|n
operator|++
expr_stmt|;
name|chkau
argument_list|(
name|hte
argument_list|,
name|n
argument_list|,
name|def
argument_list|,
name|decl
argument_list|,
name|pos1p
argument_list|,
name|call1
argument_list|,
name|call
argument_list|,
operator|*
name|ap1
argument_list|,
operator|*
name|ap2
argument_list|)
expr_stmt|;
name|ap1
operator|++
expr_stmt|;
name|ap2
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|ap1
operator|==
operator|*
name|ap2
condition|)
block|{
comment|/* equal # of arguments */
block|}
elseif|else
if|if
condition|(
name|def
operator|!=
name|NULL
operator|&&
name|def
operator|->
name|s_va
operator|&&
name|n
operator|>=
name|def
operator|->
name|s_nva
condition|)
block|{
comment|/* 			 * function definition with VARARGS; The # of 			 * arguments of the call must be at least as large 			 * as the parameter of VARARGS. 			 */
block|}
elseif|else
if|if
condition|(
operator|*
name|ap2
operator|!=
name|NULL
operator|&&
name|tp1
operator|->
name|t_proto
operator|&&
name|tp1
operator|->
name|t_vararg
condition|)
block|{
comment|/* 			 * prototype with ... and function call with 			 * at least the same # of arguments as declared 			 * in the prototype. 			 */
block|}
else|else
block|{
name|pos1
operator|=
name|xstrdup
argument_list|(
name|mkpos
argument_list|(
name|pos1p
argument_list|)
argument_list|)
expr_stmt|;
comment|/* %s: variable # of args\t%s  ::  %s */
name|msg
argument_list|(
literal|7
argument_list|,
name|hte
operator|->
name|h_name
argument_list|,
name|pos1
argument_list|,
name|mkpos
argument_list|(
operator|&
name|call
operator|->
name|f_pos
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pos1
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* perform SCANFLIKE/PRINTFLIKE tests */
if|if
condition|(
name|def
operator|==
name|NULL
operator|||
operator|(
operator|!
name|def
operator|->
name|s_prfl
operator|&&
operator|!
name|def
operator|->
name|s_scfl
operator|)
condition|)
continue|continue;
name|as
operator|=
name|def
operator|->
name|s_prfl
condition|?
name|def
operator|->
name|s_nprfl
else|:
name|def
operator|->
name|s_nscfl
expr_stmt|;
for|for
control|(
name|ai
operator|=
name|call
operator|->
name|f_args
init|;
name|ai
operator|!=
name|NULL
condition|;
name|ai
operator|=
name|ai
operator|->
name|a_nxt
control|)
block|{
if|if
condition|(
name|ai
operator|->
name|a_num
operator|==
name|as
condition|)
break|break;
block|}
if|if
condition|(
name|ai
operator|==
name|NULL
operator|||
operator|!
name|ai
operator|->
name|a_fmt
condition|)
continue|continue;
if|if
condition|(
name|def
operator|->
name|s_prfl
condition|)
block|{
name|printflike
argument_list|(
name|hte
argument_list|,
name|call
argument_list|,
name|n
argument_list|,
name|ai
operator|->
name|a_fstrg
argument_list|,
name|ap2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|scanflike
argument_list|(
name|hte
argument_list|,
name|call
argument_list|,
name|n
argument_list|,
name|ai
operator|->
name|a_fstrg
argument_list|,
name|ap2
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Check a single argument in a function call.  *  *  hte		a pointer to the hash table entry of the function  *  n		the number of the argument (1..)  *  def		the function definition or NULL  *  decl	prototype declaration, old style declaration or NULL  *  pos1p	position of definition, declaration of first call  *  call1	first call, if both def and decl are old style def/decl  *  call	checked call  *  arg1	currently checked argument of def/decl/call1  *  arg2	currently checked argument of call  *  */
end_comment

begin_function
specifier|static
name|void
name|chkau
parameter_list|(
name|hte_t
modifier|*
name|hte
parameter_list|,
name|int
name|n
parameter_list|,
name|sym_t
modifier|*
name|def
parameter_list|,
name|sym_t
modifier|*
name|decl
parameter_list|,
name|pos_t
modifier|*
name|pos1p
parameter_list|,
name|fcall_t
modifier|*
name|call1
parameter_list|,
name|fcall_t
modifier|*
name|call
parameter_list|,
name|type_t
modifier|*
name|arg1
parameter_list|,
name|type_t
modifier|*
name|arg2
parameter_list|)
block|{
comment|/* LINTED (automatic hides external declaration: warn) */
name|int
name|promote
decl_stmt|,
name|asgn
decl_stmt|,
name|warn
decl_stmt|;
name|tspec_t
name|t1
decl_stmt|,
name|t2
decl_stmt|;
name|arginf_t
modifier|*
name|ai
decl_stmt|,
modifier|*
name|ai1
decl_stmt|;
name|char
modifier|*
name|pos1
decl_stmt|;
comment|/* 	 * If a function definition is available (def != NULL), we compair the 	 * function call (call) with the definition. Otherwise, if a function 	 * definition is available and it is not an old style definition 	 * (decl != NULL&& TP(decl->s_type)->t_proto), we compair the call 	 * with this declaration. Otherwise we compair it with the first 	 * call we have found (call1). 	 */
comment|/* arg1 must be promoted if it stems from an old style definition */
name|promote
operator|=
name|def
operator|!=
name|NULL
operator|&&
name|def
operator|->
name|s_osdef
expr_stmt|;
comment|/* 	 * If we compair with a definition or declaration, we must perform 	 * the same checks for qualifiers in indirected types as in 	 * assignments. 	 */
name|asgn
operator|=
name|def
operator|!=
name|NULL
operator|||
operator|(
name|decl
operator|!=
name|NULL
operator|&&
name|TP
argument_list|(
name|decl
operator|->
name|s_type
argument_list|)
operator|->
name|t_proto
operator|)
expr_stmt|;
name|warn
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|eqtype
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|,
literal|1
argument_list|,
name|promote
argument_list|,
name|asgn
argument_list|,
operator|&
name|warn
argument_list|)
operator|&&
operator|(
operator|!
name|sflag
operator|||
operator|!
name|warn
operator|)
condition|)
return|return;
comment|/* 	 * Other lint implementations print warnings as soon as the type 	 * of an argument does not match exactly the expected type. The 	 * result are lots of warnings which are really not necessary. 	 * We print a warning only if 	 *   (0) at least one type is not an interger type and types differ 	 *   (1) hflag is set and types differ 	 *   (2) types differ, except in signedness 	 * If the argument is an integer constant whose msb is not set, 	 * signedness is ignored (e.g. 0 matches both signed and unsigned 	 * int). This is with and without hflag. 	 * If the argument is an integer constant with value 0 and the 	 * expected argument is of type pointer and the width of the 	 * interger constant is the same as the width of the pointer, 	 * no warning is printed. 	 */
name|t1
operator|=
name|arg1
operator|->
name|t_tspec
expr_stmt|;
name|t2
operator|=
name|arg2
operator|->
name|t_tspec
expr_stmt|;
if|if
condition|(
name|isityp
argument_list|(
name|t1
argument_list|)
operator|&&
name|isityp
argument_list|(
name|t2
argument_list|)
operator|&&
operator|!
name|arg1
operator|->
name|t_isenum
operator|&&
operator|!
name|arg2
operator|->
name|t_isenum
condition|)
block|{
if|if
condition|(
name|promote
condition|)
block|{
comment|/* 			 * XXX Here is a problem: Althrough it is possible to 			 * pass an int where a char/short it expected, there 			 * may be loss in significant digits. We should first 			 * check for const arguments if they can be converted 			 * into the original parameter type. 			 */
if|if
condition|(
name|t1
operator|==
name|FLOAT
condition|)
block|{
name|t1
operator|=
name|DOUBLE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t1
operator|==
name|CHAR
operator|||
name|t1
operator|==
name|SCHAR
condition|)
block|{
name|t1
operator|=
name|INT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t1
operator|==
name|UCHAR
condition|)
block|{
name|t1
operator|=
name|tflag
condition|?
name|UINT
else|:
name|INT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t1
operator|==
name|SHORT
condition|)
block|{
name|t1
operator|=
name|INT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t1
operator|==
name|USHORT
condition|)
block|{
comment|/* CONSTCOND */
name|t1
operator|=
name|INT_MAX
operator|<
name|USHRT_MAX
operator|||
name|tflag
condition|?
name|UINT
else|:
name|INT
expr_stmt|;
block|}
block|}
if|if
condition|(
name|styp
argument_list|(
name|t1
argument_list|)
operator|==
name|styp
argument_list|(
name|t2
argument_list|)
condition|)
block|{
comment|/* 			 * types differ only in signedness; get information 			 * about arguments 			 */
comment|/* 			 * treat a definition like a call with variable 			 * arguments 			 */
name|ai1
operator|=
name|call1
operator|!=
name|NULL
condition|?
name|call1
operator|->
name|f_args
else|:
name|NULL
expr_stmt|;
comment|/* 			 * if two calls are compared, ai1 is set to the 			 * information for the n-th argument, if this was 			 * a constant, otherwise to NULL 			 */
for|for
control|(
init|;
name|ai1
operator|!=
name|NULL
condition|;
name|ai1
operator|=
name|ai1
operator|->
name|a_nxt
control|)
block|{
if|if
condition|(
name|ai1
operator|->
name|a_num
operator|==
name|n
condition|)
break|break;
block|}
comment|/* 			 * ai is set to the information of the n-th arg 			 * of the (second) call, if this was a constant, 			 * otherwise to NULL 			 */
for|for
control|(
name|ai
operator|=
name|call
operator|->
name|f_args
init|;
name|ai
operator|!=
name|NULL
condition|;
name|ai
operator|=
name|ai
operator|->
name|a_nxt
control|)
block|{
if|if
condition|(
name|ai
operator|->
name|a_num
operator|==
name|n
condition|)
break|break;
block|}
if|if
condition|(
name|ai1
operator|==
name|NULL
operator|&&
name|ai
operator|==
name|NULL
condition|)
block|{
comment|/* no constant at all */
if|if
condition|(
operator|!
name|hflag
condition|)
return|return;
block|}
elseif|else
if|if
condition|(
name|ai1
operator|==
name|NULL
operator|||
name|ai
operator|==
name|NULL
condition|)
block|{
comment|/* one constant */
if|if
condition|(
name|ai
operator|==
name|NULL
condition|)
name|ai
operator|=
name|ai1
expr_stmt|;
if|if
condition|(
name|ai
operator|->
name|a_zero
operator|||
name|ai
operator|->
name|a_pcon
condition|)
comment|/* same value in signed and unsigned */
return|return;
comment|/* value (not representation) differently */
block|}
else|else
block|{
comment|/* 				 * two constants, one signed, one unsigned; 				 * if the msb of one of the constants is set, 				 * the argument is used inconsistently. 				 */
if|if
condition|(
operator|!
name|ai1
operator|->
name|a_ncon
operator|&&
operator|!
name|ai
operator|->
name|a_ncon
condition|)
return|return;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|t1
operator|==
name|PTR
operator|&&
name|isityp
argument_list|(
name|t2
argument_list|)
condition|)
block|{
for|for
control|(
name|ai
operator|=
name|call
operator|->
name|f_args
init|;
name|ai
operator|!=
name|NULL
condition|;
name|ai
operator|=
name|ai
operator|->
name|a_nxt
control|)
block|{
if|if
condition|(
name|ai
operator|->
name|a_num
operator|==
name|n
condition|)
break|break;
block|}
comment|/* 		 * Vendor implementations of lint (e.g. HP-UX, Digital UNIX) 		 * don't care about the size of the integer argument, 		 * only whether or not it is zero.  We do the same. 		 */
if|if
condition|(
name|ai
operator|!=
name|NULL
operator|&&
name|ai
operator|->
name|a_zero
condition|)
return|return;
block|}
name|pos1
operator|=
name|xstrdup
argument_list|(
name|mkpos
argument_list|(
name|pos1p
argument_list|)
argument_list|)
expr_stmt|;
comment|/* %s, arg %d used inconsistently\t%s  ::  %s */
name|msg
argument_list|(
literal|6
argument_list|,
name|hte
operator|->
name|h_name
argument_list|,
name|n
argument_list|,
name|pos1
argument_list|,
name|mkpos
argument_list|(
operator|&
name|call
operator|->
name|f_pos
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pos1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Compare the types in the NULL-terminated array ap with the format  * string fmt.  */
end_comment

begin_function
specifier|static
name|void
name|printflike
parameter_list|(
name|hte_t
modifier|*
name|hte
parameter_list|,
name|fcall_t
modifier|*
name|call
parameter_list|,
name|int
name|n
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
name|type_t
modifier|*
modifier|*
name|ap
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|fp
decl_stmt|;
name|int
name|fc
decl_stmt|;
name|int
name|fwidth
decl_stmt|,
name|prec
decl_stmt|,
name|left
decl_stmt|,
name|sign
decl_stmt|,
name|space
decl_stmt|,
name|alt
decl_stmt|,
name|zero
decl_stmt|;
name|tspec_t
name|sz
decl_stmt|,
name|t1
decl_stmt|,
name|t2
init|=
name|NOTSPEC
decl_stmt|;
name|type_t
modifier|*
name|tp
decl_stmt|;
name|fp
operator|=
name|fmt
expr_stmt|;
name|fc
operator|=
operator|*
name|fp
operator|++
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|fc
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|*
name|ap
operator|!=
name|NULL
condition|)
name|tomanyarg
argument_list|(
name|hte
argument_list|,
name|call
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|fc
operator|!=
literal|'%'
condition|)
block|{
name|badfmt
argument_list|(
name|hte
argument_list|,
name|call
argument_list|)
expr_stmt|;
break|break;
block|}
name|fc
operator|=
operator|*
name|fp
operator|++
expr_stmt|;
name|fwidth
operator|=
name|prec
operator|=
name|left
operator|=
name|sign
operator|=
name|space
operator|=
name|alt
operator|=
name|zero
operator|=
literal|0
expr_stmt|;
name|sz
operator|=
name|NOTSPEC
expr_stmt|;
comment|/* Flags */
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|fc
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
name|left
condition|)
break|break;
name|left
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fc
operator|==
literal|'+'
condition|)
block|{
if|if
condition|(
name|sign
condition|)
break|break;
name|sign
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fc
operator|==
literal|' '
condition|)
block|{
if|if
condition|(
name|space
condition|)
break|break;
name|space
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fc
operator|==
literal|'#'
condition|)
block|{
if|if
condition|(
name|alt
condition|)
break|break;
name|alt
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fc
operator|==
literal|'0'
condition|)
block|{
if|if
condition|(
name|zero
condition|)
break|break;
name|zero
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
name|fc
operator|=
operator|*
name|fp
operator|++
expr_stmt|;
block|}
comment|/* field width */
if|if
condition|(
name|isdigit
argument_list|(
name|fc
argument_list|)
condition|)
block|{
name|fwidth
operator|=
literal|1
expr_stmt|;
do|do
block|{
name|fc
operator|=
operator|*
name|fp
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|isdigit
argument_list|(
name|fc
argument_list|)
condition|)
do|;
block|}
elseif|else
if|if
condition|(
name|fc
operator|==
literal|'*'
condition|)
block|{
name|fwidth
operator|=
literal|1
expr_stmt|;
name|fc
operator|=
operator|*
name|fp
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|tp
operator|=
operator|*
name|ap
operator|++
operator|)
operator|==
name|NULL
condition|)
block|{
name|tofewarg
argument_list|(
name|hte
argument_list|,
name|call
argument_list|)
expr_stmt|;
break|break;
block|}
name|n
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|t1
operator|=
name|tp
operator|->
name|t_tspec
operator|)
operator|!=
name|INT
operator|&&
operator|(
name|hflag
operator|||
name|t1
operator|!=
name|UINT
operator|)
condition|)
name|inconarg
argument_list|(
name|hte
argument_list|,
name|call
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
comment|/* precision */
if|if
condition|(
name|fc
operator|==
literal|'.'
condition|)
block|{
name|fc
operator|=
operator|*
name|fp
operator|++
expr_stmt|;
name|prec
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
name|fc
argument_list|)
condition|)
block|{
do|do
block|{
name|fc
operator|=
operator|*
name|fp
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|isdigit
argument_list|(
name|fc
argument_list|)
condition|)
do|;
block|}
elseif|else
if|if
condition|(
name|fc
operator|==
literal|'*'
condition|)
block|{
name|fc
operator|=
operator|*
name|fp
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|tp
operator|=
operator|*
name|ap
operator|++
operator|)
operator|==
name|NULL
condition|)
block|{
name|tofewarg
argument_list|(
name|hte
argument_list|,
name|call
argument_list|)
expr_stmt|;
break|break;
block|}
name|n
operator|++
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_tspec
operator|!=
name|INT
condition|)
name|inconarg
argument_list|(
name|hte
argument_list|,
name|call
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|badfmt
argument_list|(
name|hte
argument_list|,
name|call
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|fc
operator|==
literal|'h'
condition|)
block|{
name|sz
operator|=
name|SHORT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fc
operator|==
literal|'l'
condition|)
block|{
name|sz
operator|=
name|LONG
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fc
operator|==
literal|'q'
condition|)
block|{
name|sz
operator|=
name|QUAD
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fc
operator|==
literal|'L'
condition|)
block|{
name|sz
operator|=
name|LDOUBLE
expr_stmt|;
block|}
if|if
condition|(
name|sz
operator|!=
name|NOTSPEC
condition|)
name|fc
operator|=
operator|*
name|fp
operator|++
expr_stmt|;
if|if
condition|(
name|fc
operator|==
literal|'%'
condition|)
block|{
if|if
condition|(
name|sz
operator|!=
name|NOTSPEC
operator|||
name|left
operator|||
name|sign
operator|||
name|space
operator|||
name|alt
operator|||
name|zero
operator|||
name|prec
operator|||
name|fwidth
condition|)
block|{
name|badfmt
argument_list|(
name|hte
argument_list|,
name|call
argument_list|)
expr_stmt|;
block|}
name|fc
operator|=
operator|*
name|fp
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|fc
operator|==
literal|'\0'
condition|)
block|{
name|badfmt
argument_list|(
name|hte
argument_list|,
name|call
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|tp
operator|=
operator|*
name|ap
operator|++
operator|)
operator|==
name|NULL
condition|)
block|{
name|tofewarg
argument_list|(
name|hte
argument_list|,
name|call
argument_list|)
expr_stmt|;
break|break;
block|}
name|n
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|t1
operator|=
name|tp
operator|->
name|t_tspec
operator|)
operator|==
name|PTR
condition|)
name|t2
operator|=
name|tp
operator|->
name|t_subt
operator|->
name|t_tspec
expr_stmt|;
if|if
condition|(
name|fc
operator|==
literal|'d'
operator|||
name|fc
operator|==
literal|'i'
condition|)
block|{
if|if
condition|(
name|alt
operator|||
name|sz
operator|==
name|LDOUBLE
condition|)
block|{
name|badfmt
argument_list|(
name|hte
argument_list|,
name|call
argument_list|)
expr_stmt|;
break|break;
block|}
name|int_conv
label|:
if|if
condition|(
name|sz
operator|==
name|LONG
condition|)
block|{
if|if
condition|(
name|t1
operator|!=
name|LONG
operator|&&
operator|(
name|hflag
operator|||
name|t1
operator|!=
name|ULONG
operator|)
condition|)
name|inconarg
argument_list|(
name|hte
argument_list|,
name|call
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sz
operator|==
name|QUAD
condition|)
block|{
if|if
condition|(
name|t1
operator|!=
name|QUAD
operator|&&
operator|(
name|hflag
operator|||
name|t1
operator|!=
name|UQUAD
operator|)
condition|)
name|inconarg
argument_list|(
name|hte
argument_list|,
name|call
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * SHORT is always promoted to INT, USHORT 				 * to INT or UINT. 				 */
if|if
condition|(
name|t1
operator|!=
name|INT
operator|&&
operator|(
name|hflag
operator|||
name|t1
operator|!=
name|UINT
operator|)
condition|)
name|inconarg
argument_list|(
name|hte
argument_list|,
name|call
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|fc
operator|==
literal|'o'
operator|||
name|fc
operator|==
literal|'u'
operator|||
name|fc
operator|==
literal|'x'
operator|||
name|fc
operator|==
literal|'X'
condition|)
block|{
if|if
condition|(
operator|(
name|alt
operator|&&
name|fc
operator|==
literal|'u'
operator|)
operator|||
name|sz
operator|==
name|LDOUBLE
condition|)
name|badfmt
argument_list|(
name|hte
argument_list|,
name|call
argument_list|)
expr_stmt|;
name|uint_conv
label|:
if|if
condition|(
name|sz
operator|==
name|LONG
condition|)
block|{
if|if
condition|(
name|t1
operator|!=
name|ULONG
operator|&&
operator|(
name|hflag
operator|||
name|t1
operator|!=
name|LONG
operator|)
condition|)
name|inconarg
argument_list|(
name|hte
argument_list|,
name|call
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sz
operator|==
name|QUAD
condition|)
block|{
if|if
condition|(
name|t1
operator|!=
name|UQUAD
operator|&&
operator|(
name|hflag
operator|||
name|t1
operator|!=
name|QUAD
operator|)
condition|)
name|inconarg
argument_list|(
name|hte
argument_list|,
name|call
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sz
operator|==
name|SHORT
condition|)
block|{
comment|/* USHORT was promoted to INT or UINT */
if|if
condition|(
name|t1
operator|!=
name|UINT
operator|&&
name|t1
operator|!=
name|INT
condition|)
name|inconarg
argument_list|(
name|hte
argument_list|,
name|call
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|t1
operator|!=
name|UINT
operator|&&
operator|(
name|hflag
operator|||
name|t1
operator|!=
name|INT
operator|)
condition|)
name|inconarg
argument_list|(
name|hte
argument_list|,
name|call
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|fc
operator|==
literal|'D'
operator|||
name|fc
operator|==
literal|'O'
operator|||
name|fc
operator|==
literal|'U'
condition|)
block|{
if|if
condition|(
operator|(
name|alt
operator|&&
name|fc
operator|!=
literal|'O'
operator|)
operator|||
name|sz
operator|!=
name|NOTSPEC
operator|||
operator|!
name|tflag
condition|)
name|badfmt
argument_list|(
name|hte
argument_list|,
name|call
argument_list|)
expr_stmt|;
name|sz
operator|=
name|LONG
expr_stmt|;
if|if
condition|(
name|fc
operator|==
literal|'D'
condition|)
block|{
goto|goto
name|int_conv
goto|;
block|}
else|else
block|{
goto|goto
name|uint_conv
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|fc
operator|==
literal|'f'
operator|||
name|fc
operator|==
literal|'e'
operator|||
name|fc
operator|==
literal|'E'
operator|||
name|fc
operator|==
literal|'g'
operator|||
name|fc
operator|==
literal|'G'
condition|)
block|{
if|if
condition|(
name|sz
operator|==
name|NOTSPEC
condition|)
name|sz
operator|=
name|DOUBLE
expr_stmt|;
if|if
condition|(
name|sz
operator|!=
name|DOUBLE
operator|&&
name|sz
operator|!=
name|LDOUBLE
condition|)
name|badfmt
argument_list|(
name|hte
argument_list|,
name|call
argument_list|)
expr_stmt|;
if|if
condition|(
name|t1
operator|!=
name|sz
condition|)
name|inconarg
argument_list|(
name|hte
argument_list|,
name|call
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fc
operator|==
literal|'c'
condition|)
block|{
if|if
condition|(
name|sz
operator|!=
name|NOTSPEC
operator|||
name|alt
operator|||
name|zero
condition|)
name|badfmt
argument_list|(
name|hte
argument_list|,
name|call
argument_list|)
expr_stmt|;
if|if
condition|(
name|t1
operator|!=
name|INT
condition|)
name|inconarg
argument_list|(
name|hte
argument_list|,
name|call
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fc
operator|==
literal|'s'
condition|)
block|{
if|if
condition|(
name|sz
operator|!=
name|NOTSPEC
operator|||
name|alt
operator|||
name|zero
condition|)
name|badfmt
argument_list|(
name|hte
argument_list|,
name|call
argument_list|)
expr_stmt|;
if|if
condition|(
name|t1
operator|!=
name|PTR
operator|||
operator|(
name|t2
operator|!=
name|CHAR
operator|&&
name|t2
operator|!=
name|UCHAR
operator|&&
name|t2
operator|!=
name|SCHAR
operator|)
condition|)
block|{
name|inconarg
argument_list|(
name|hte
argument_list|,
name|call
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|fc
operator|==
literal|'p'
condition|)
block|{
if|if
condition|(
name|fwidth
operator|||
name|prec
operator|||
name|sz
operator|!=
name|NOTSPEC
operator|||
name|alt
operator|||
name|zero
condition|)
name|badfmt
argument_list|(
name|hte
argument_list|,
name|call
argument_list|)
expr_stmt|;
if|if
condition|(
name|t1
operator|!=
name|PTR
operator|||
operator|(
name|hflag
operator|&&
name|t2
operator|!=
name|VOID
operator|)
condition|)
name|inconarg
argument_list|(
name|hte
argument_list|,
name|call
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fc
operator|==
literal|'n'
condition|)
block|{
if|if
condition|(
name|fwidth
operator|||
name|prec
operator|||
name|alt
operator|||
name|zero
operator|||
name|sz
operator|==
name|LDOUBLE
condition|)
name|badfmt
argument_list|(
name|hte
argument_list|,
name|call
argument_list|)
expr_stmt|;
if|if
condition|(
name|t1
operator|!=
name|PTR
condition|)
block|{
name|inconarg
argument_list|(
name|hte
argument_list|,
name|call
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sz
operator|==
name|LONG
condition|)
block|{
if|if
condition|(
name|t2
operator|!=
name|LONG
operator|&&
name|t2
operator|!=
name|ULONG
condition|)
name|inconarg
argument_list|(
name|hte
argument_list|,
name|call
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sz
operator|==
name|SHORT
condition|)
block|{
if|if
condition|(
name|t2
operator|!=
name|SHORT
operator|&&
name|t2
operator|!=
name|USHORT
condition|)
name|inconarg
argument_list|(
name|hte
argument_list|,
name|call
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|t2
operator|!=
name|INT
operator|&&
name|t2
operator|!=
name|UINT
condition|)
name|inconarg
argument_list|(
name|hte
argument_list|,
name|call
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|badfmt
argument_list|(
name|hte
argument_list|,
name|call
argument_list|)
expr_stmt|;
break|break;
block|}
name|fc
operator|=
operator|*
name|fp
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Compare the types in the NULL-terminated array ap with the format  * string fmt.  */
end_comment

begin_function
specifier|static
name|void
name|scanflike
parameter_list|(
name|hte_t
modifier|*
name|hte
parameter_list|,
name|fcall_t
modifier|*
name|call
parameter_list|,
name|int
name|n
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
name|type_t
modifier|*
modifier|*
name|ap
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|fp
decl_stmt|;
name|int
name|fc
decl_stmt|;
name|int
name|noasgn
decl_stmt|,
name|fwidth
decl_stmt|;
name|tspec_t
name|sz
decl_stmt|,
name|t1
init|=
name|NOTSPEC
decl_stmt|,
name|t2
init|=
name|NOTSPEC
decl_stmt|;
name|type_t
modifier|*
name|tp
init|=
name|NULL
decl_stmt|;
name|fp
operator|=
name|fmt
expr_stmt|;
name|fc
operator|=
operator|*
name|fp
operator|++
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|fc
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|*
name|ap
operator|!=
name|NULL
condition|)
name|tomanyarg
argument_list|(
name|hte
argument_list|,
name|call
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|fc
operator|!=
literal|'%'
condition|)
block|{
name|badfmt
argument_list|(
name|hte
argument_list|,
name|call
argument_list|)
expr_stmt|;
break|break;
block|}
name|fc
operator|=
operator|*
name|fp
operator|++
expr_stmt|;
name|noasgn
operator|=
name|fwidth
operator|=
literal|0
expr_stmt|;
name|sz
operator|=
name|NOTSPEC
expr_stmt|;
if|if
condition|(
name|fc
operator|==
literal|'*'
condition|)
block|{
name|noasgn
operator|=
literal|1
expr_stmt|;
name|fc
operator|=
operator|*
name|fp
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|isdigit
argument_list|(
name|fc
argument_list|)
condition|)
block|{
name|fwidth
operator|=
literal|1
expr_stmt|;
do|do
block|{
name|fc
operator|=
operator|*
name|fp
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|isdigit
argument_list|(
name|fc
argument_list|)
condition|)
do|;
block|}
if|if
condition|(
name|fc
operator|==
literal|'h'
condition|)
block|{
name|sz
operator|=
name|SHORT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fc
operator|==
literal|'l'
condition|)
block|{
name|sz
operator|=
name|LONG
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fc
operator|==
literal|'q'
condition|)
block|{
name|sz
operator|=
name|QUAD
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fc
operator|==
literal|'L'
condition|)
block|{
name|sz
operator|=
name|LDOUBLE
expr_stmt|;
block|}
if|if
condition|(
name|sz
operator|!=
name|NOTSPEC
condition|)
name|fc
operator|=
operator|*
name|fp
operator|++
expr_stmt|;
if|if
condition|(
name|fc
operator|==
literal|'%'
condition|)
block|{
if|if
condition|(
name|sz
operator|!=
name|NOTSPEC
operator|||
name|noasgn
operator|||
name|fwidth
condition|)
name|badfmt
argument_list|(
name|hte
argument_list|,
name|call
argument_list|)
expr_stmt|;
name|fc
operator|=
operator|*
name|fp
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|noasgn
condition|)
block|{
if|if
condition|(
operator|(
name|tp
operator|=
operator|*
name|ap
operator|++
operator|)
operator|==
name|NULL
condition|)
block|{
name|tofewarg
argument_list|(
name|hte
argument_list|,
name|call
argument_list|)
expr_stmt|;
break|break;
block|}
name|n
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|t1
operator|=
name|tp
operator|->
name|t_tspec
operator|)
operator|==
name|PTR
condition|)
name|t2
operator|=
name|tp
operator|->
name|t_subt
operator|->
name|t_tspec
expr_stmt|;
block|}
if|if
condition|(
name|fc
operator|==
literal|'d'
operator|||
name|fc
operator|==
literal|'i'
operator|||
name|fc
operator|==
literal|'n'
condition|)
block|{
if|if
condition|(
name|sz
operator|==
name|LDOUBLE
condition|)
name|badfmt
argument_list|(
name|hte
argument_list|,
name|call
argument_list|)
expr_stmt|;
if|if
condition|(
name|sz
operator|!=
name|SHORT
operator|&&
name|sz
operator|!=
name|LONG
operator|&&
name|sz
operator|!=
name|QUAD
condition|)
name|sz
operator|=
name|INT
expr_stmt|;
name|conv
label|:
if|if
condition|(
operator|!
name|noasgn
condition|)
block|{
if|if
condition|(
name|t1
operator|!=
name|PTR
condition|)
block|{
name|inconarg
argument_list|(
name|hte
argument_list|,
name|call
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t2
operator|!=
name|styp
argument_list|(
name|sz
argument_list|)
condition|)
block|{
name|inconarg
argument_list|(
name|hte
argument_list|,
name|call
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hflag
operator|&&
name|t2
operator|!=
name|sz
condition|)
block|{
name|inconarg
argument_list|(
name|hte
argument_list|,
name|call
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tp
operator|->
name|t_subt
operator|->
name|t_const
condition|)
block|{
name|inconarg
argument_list|(
name|hte
argument_list|,
name|call
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|fc
operator|==
literal|'o'
operator|||
name|fc
operator|==
literal|'u'
operator|||
name|fc
operator|==
literal|'x'
condition|)
block|{
if|if
condition|(
name|sz
operator|==
name|LDOUBLE
condition|)
name|badfmt
argument_list|(
name|hte
argument_list|,
name|call
argument_list|)
expr_stmt|;
if|if
condition|(
name|sz
operator|==
name|SHORT
condition|)
block|{
name|sz
operator|=
name|USHORT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sz
operator|==
name|LONG
condition|)
block|{
name|sz
operator|=
name|ULONG
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sz
operator|==
name|QUAD
condition|)
block|{
name|sz
operator|=
name|UQUAD
expr_stmt|;
block|}
else|else
block|{
name|sz
operator|=
name|UINT
expr_stmt|;
block|}
goto|goto
name|conv
goto|;
block|}
elseif|else
if|if
condition|(
name|fc
operator|==
literal|'D'
condition|)
block|{
if|if
condition|(
name|sz
operator|!=
name|NOTSPEC
operator|||
operator|!
name|tflag
condition|)
name|badfmt
argument_list|(
name|hte
argument_list|,
name|call
argument_list|)
expr_stmt|;
name|sz
operator|=
name|LONG
expr_stmt|;
goto|goto
name|conv
goto|;
block|}
elseif|else
if|if
condition|(
name|fc
operator|==
literal|'O'
condition|)
block|{
if|if
condition|(
name|sz
operator|!=
name|NOTSPEC
operator|||
operator|!
name|tflag
condition|)
name|badfmt
argument_list|(
name|hte
argument_list|,
name|call
argument_list|)
expr_stmt|;
name|sz
operator|=
name|ULONG
expr_stmt|;
goto|goto
name|conv
goto|;
block|}
elseif|else
if|if
condition|(
name|fc
operator|==
literal|'X'
condition|)
block|{
comment|/* 			 * XXX valid in ANSI C, but in NetBSD's libc imple- 			 * mented as "lx". Thats why it should be avoided. 			 */
if|if
condition|(
name|sz
operator|!=
name|NOTSPEC
operator|||
operator|!
name|tflag
condition|)
name|badfmt
argument_list|(
name|hte
argument_list|,
name|call
argument_list|)
expr_stmt|;
name|sz
operator|=
name|ULONG
expr_stmt|;
goto|goto
name|conv
goto|;
block|}
elseif|else
if|if
condition|(
name|fc
operator|==
literal|'E'
condition|)
block|{
comment|/* 			 * XXX valid in ANSI C, but in NetBSD's libc imple- 			 * mented as "lf". Thats why it should be avoided. 			 */
if|if
condition|(
name|sz
operator|!=
name|NOTSPEC
operator|||
operator|!
name|tflag
condition|)
name|badfmt
argument_list|(
name|hte
argument_list|,
name|call
argument_list|)
expr_stmt|;
name|sz
operator|=
name|DOUBLE
expr_stmt|;
goto|goto
name|conv
goto|;
block|}
elseif|else
if|if
condition|(
name|fc
operator|==
literal|'F'
condition|)
block|{
comment|/* XXX only for backward compatibility */
if|if
condition|(
name|sz
operator|!=
name|NOTSPEC
operator|||
operator|!
name|tflag
condition|)
name|badfmt
argument_list|(
name|hte
argument_list|,
name|call
argument_list|)
expr_stmt|;
name|sz
operator|=
name|DOUBLE
expr_stmt|;
goto|goto
name|conv
goto|;
block|}
elseif|else
if|if
condition|(
name|fc
operator|==
literal|'G'
condition|)
block|{
comment|/* 			 * XXX valid in ANSI C, but in NetBSD's libc not 			 * implemented 			 */
if|if
condition|(
name|sz
operator|!=
name|NOTSPEC
operator|&&
name|sz
operator|!=
name|LONG
operator|&&
name|sz
operator|!=
name|LDOUBLE
condition|)
name|badfmt
argument_list|(
name|hte
argument_list|,
name|call
argument_list|)
expr_stmt|;
goto|goto
name|fconv
goto|;
block|}
elseif|else
if|if
condition|(
name|fc
operator|==
literal|'e'
operator|||
name|fc
operator|==
literal|'f'
operator|||
name|fc
operator|==
literal|'g'
condition|)
block|{
name|fconv
label|:
if|if
condition|(
name|sz
operator|==
name|NOTSPEC
condition|)
block|{
name|sz
operator|=
name|FLOAT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sz
operator|==
name|LONG
condition|)
block|{
name|sz
operator|=
name|DOUBLE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sz
operator|!=
name|LDOUBLE
condition|)
block|{
name|badfmt
argument_list|(
name|hte
argument_list|,
name|call
argument_list|)
expr_stmt|;
name|sz
operator|=
name|FLOAT
expr_stmt|;
block|}
goto|goto
name|conv
goto|;
block|}
elseif|else
if|if
condition|(
name|fc
operator|==
literal|'s'
operator|||
name|fc
operator|==
literal|'['
operator|||
name|fc
operator|==
literal|'c'
condition|)
block|{
if|if
condition|(
name|sz
operator|!=
name|NOTSPEC
condition|)
name|badfmt
argument_list|(
name|hte
argument_list|,
name|call
argument_list|)
expr_stmt|;
if|if
condition|(
name|fc
operator|==
literal|'['
condition|)
block|{
if|if
condition|(
operator|(
name|fc
operator|=
operator|*
name|fp
operator|++
operator|)
operator|==
literal|'-'
condition|)
block|{
name|badfmt
argument_list|(
name|hte
argument_list|,
name|call
argument_list|)
expr_stmt|;
name|fc
operator|=
operator|*
name|fp
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|fc
operator|!=
literal|']'
condition|)
block|{
name|badfmt
argument_list|(
name|hte
argument_list|,
name|call
argument_list|)
expr_stmt|;
if|if
condition|(
name|fc
operator|==
literal|'\0'
condition|)
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|noasgn
condition|)
block|{
if|if
condition|(
name|t1
operator|!=
name|PTR
condition|)
block|{
name|inconarg
argument_list|(
name|hte
argument_list|,
name|call
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t2
operator|!=
name|CHAR
operator|&&
name|t2
operator|!=
name|UCHAR
operator|&&
name|t2
operator|!=
name|SCHAR
condition|)
block|{
name|inconarg
argument_list|(
name|hte
argument_list|,
name|call
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|fc
operator|==
literal|'p'
condition|)
block|{
if|if
condition|(
name|sz
operator|!=
name|NOTSPEC
condition|)
name|badfmt
argument_list|(
name|hte
argument_list|,
name|call
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|noasgn
condition|)
block|{
if|if
condition|(
name|t1
operator|!=
name|PTR
operator|||
name|t2
operator|!=
name|PTR
condition|)
block|{
name|inconarg
argument_list|(
name|hte
argument_list|,
name|call
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tp
operator|->
name|t_subt
operator|->
name|t_subt
operator|->
name|t_tspec
operator|!=
name|VOID
condition|)
block|{
if|if
condition|(
name|hflag
condition|)
name|inconarg
argument_list|(
name|hte
argument_list|,
name|call
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|badfmt
argument_list|(
name|hte
argument_list|,
name|call
argument_list|)
expr_stmt|;
break|break;
block|}
name|fc
operator|=
operator|*
name|fp
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|badfmt
parameter_list|(
name|hte_t
modifier|*
name|hte
parameter_list|,
name|fcall_t
modifier|*
name|call
parameter_list|)
block|{
comment|/* %s: malformed format string\t%s */
name|msg
argument_list|(
literal|13
argument_list|,
name|hte
operator|->
name|h_name
argument_list|,
name|mkpos
argument_list|(
operator|&
name|call
operator|->
name|f_pos
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|inconarg
parameter_list|(
name|hte_t
modifier|*
name|hte
parameter_list|,
name|fcall_t
modifier|*
name|call
parameter_list|,
name|int
name|n
parameter_list|)
block|{
comment|/* %s, arg %d inconsistent with format\t%s(%d) */
name|msg
argument_list|(
literal|14
argument_list|,
name|hte
operator|->
name|h_name
argument_list|,
name|n
argument_list|,
name|mkpos
argument_list|(
operator|&
name|call
operator|->
name|f_pos
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|tofewarg
parameter_list|(
name|hte_t
modifier|*
name|hte
parameter_list|,
name|fcall_t
modifier|*
name|call
parameter_list|)
block|{
comment|/* %s: too few args for format  \t%s */
name|msg
argument_list|(
literal|15
argument_list|,
name|hte
operator|->
name|h_name
argument_list|,
name|mkpos
argument_list|(
operator|&
name|call
operator|->
name|f_pos
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|tomanyarg
parameter_list|(
name|hte_t
modifier|*
name|hte
parameter_list|,
name|fcall_t
modifier|*
name|call
parameter_list|)
block|{
comment|/* %s: too many args for format  \t%s */
name|msg
argument_list|(
literal|16
argument_list|,
name|hte
operator|->
name|h_name
argument_list|,
name|mkpos
argument_list|(
operator|&
name|call
operator|->
name|f_pos
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Print warnings for return values which are used, but not returned,  * or return values which are always or sometimes ignored.  */
end_comment

begin_function
specifier|static
name|void
name|chkrvu
parameter_list|(
name|hte_t
modifier|*
name|hte
parameter_list|,
name|sym_t
modifier|*
name|def
parameter_list|)
block|{
name|fcall_t
modifier|*
name|call
decl_stmt|;
name|int
name|used
decl_stmt|,
name|ignored
decl_stmt|;
if|if
condition|(
name|def
operator|==
name|NULL
condition|)
comment|/* don't know wheter or not the functions returns a value */
return|return;
if|if
condition|(
name|hte
operator|->
name|h_calls
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|def
operator|->
name|s_rval
condition|)
block|{
comment|/* function has return value */
name|used
operator|=
name|ignored
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|call
operator|=
name|hte
operator|->
name|h_calls
init|;
name|call
operator|!=
name|NULL
condition|;
name|call
operator|=
name|call
operator|->
name|f_nxt
control|)
block|{
name|used
operator||=
name|call
operator|->
name|f_rused
operator|||
name|call
operator|->
name|f_rdisc
expr_stmt|;
name|ignored
operator||=
operator|!
name|call
operator|->
name|f_rused
operator|&&
operator|!
name|call
operator|->
name|f_rdisc
expr_stmt|;
block|}
comment|/* 		 * XXX as soon as we are able to disable single warnings 		 * the following dependencies from hflag should be removed. 		 * but for now I do'nt want to be botherd by this warnings 		 * which are almost always useless. 		 */
if|if
condition|(
operator|!
name|used
operator|&&
name|ignored
condition|)
block|{
if|if
condition|(
name|hflag
condition|)
comment|/* %s returns value which is always ignored */
name|msg
argument_list|(
literal|8
argument_list|,
name|hte
operator|->
name|h_name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|used
operator|&&
name|ignored
condition|)
block|{
if|if
condition|(
name|hflag
condition|)
comment|/* %s returns value which is sometimes ign. */
name|msg
argument_list|(
literal|9
argument_list|,
name|hte
operator|->
name|h_name
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* function has no return value */
for|for
control|(
name|call
operator|=
name|hte
operator|->
name|h_calls
init|;
name|call
operator|!=
name|NULL
condition|;
name|call
operator|=
name|call
operator|->
name|f_nxt
control|)
block|{
if|if
condition|(
name|call
operator|->
name|f_rused
condition|)
comment|/* %s value is used( %s ), but none ret. */
name|msg
argument_list|(
literal|10
argument_list|,
name|hte
operator|->
name|h_name
argument_list|,
name|mkpos
argument_list|(
operator|&
name|call
operator|->
name|f_pos
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Print warnings for inconsistent argument declarations.  */
end_comment

begin_function
specifier|static
name|void
name|chkadecl
parameter_list|(
name|hte_t
modifier|*
name|hte
parameter_list|,
name|sym_t
modifier|*
name|def
parameter_list|,
name|sym_t
modifier|*
name|decl
parameter_list|)
block|{
comment|/* LINTED (automatic hides external declaration: warn) */
name|int
name|osdef
decl_stmt|,
name|eq
decl_stmt|,
name|warn
decl_stmt|,
name|n
decl_stmt|;
name|sym_t
modifier|*
name|sym1
decl_stmt|,
modifier|*
name|sym
decl_stmt|;
name|type_t
modifier|*
modifier|*
name|ap1
decl_stmt|,
modifier|*
modifier|*
name|ap2
decl_stmt|,
modifier|*
name|tp1
decl_stmt|,
modifier|*
name|tp2
decl_stmt|;
name|char
modifier|*
name|pos1
decl_stmt|;
specifier|const
name|char
modifier|*
name|pos2
decl_stmt|;
name|osdef
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|def
operator|!=
name|NULL
condition|)
block|{
name|osdef
operator|=
name|def
operator|->
name|s_osdef
expr_stmt|;
name|sym1
operator|=
name|def
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|decl
operator|!=
name|NULL
operator|&&
name|TP
argument_list|(
name|decl
operator|->
name|s_type
argument_list|)
operator|->
name|t_proto
condition|)
block|{
name|sym1
operator|=
name|decl
expr_stmt|;
block|}
else|else
block|{
return|return;
block|}
if|if
condition|(
name|TP
argument_list|(
name|sym1
operator|->
name|s_type
argument_list|)
operator|->
name|t_tspec
operator|!=
name|FUNC
condition|)
return|return;
comment|/* 	 * XXX Prototypes should also be compared with old style function 	 * declarations. 	 */
for|for
control|(
name|sym
operator|=
name|hte
operator|->
name|h_syms
init|;
name|sym
operator|!=
name|NULL
condition|;
name|sym
operator|=
name|sym
operator|->
name|s_nxt
control|)
block|{
if|if
condition|(
name|sym
operator|==
name|sym1
operator|||
operator|!
name|TP
argument_list|(
name|sym
operator|->
name|s_type
argument_list|)
operator|->
name|t_proto
condition|)
continue|continue;
name|ap1
operator|=
name|TP
argument_list|(
name|sym1
operator|->
name|s_type
argument_list|)
operator|->
name|t_args
expr_stmt|;
name|ap2
operator|=
name|TP
argument_list|(
name|sym
operator|->
name|s_type
argument_list|)
operator|->
name|t_args
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|ap1
operator|!=
name|NULL
operator|&&
operator|*
name|ap2
operator|!=
name|NULL
condition|)
block|{
name|warn
operator|=
literal|0
expr_stmt|;
name|eq
operator|=
name|eqtype
argument_list|(
operator|*
name|ap1
argument_list|,
operator|*
name|ap2
argument_list|,
literal|1
argument_list|,
name|osdef
argument_list|,
literal|0
argument_list|,
operator|&
name|warn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|eq
operator|||
name|warn
condition|)
block|{
name|pos1
operator|=
name|xstrdup
argument_list|(
name|mkpos
argument_list|(
operator|&
name|sym1
operator|->
name|s_pos
argument_list|)
argument_list|)
expr_stmt|;
name|pos2
operator|=
name|mkpos
argument_list|(
operator|&
name|sym
operator|->
name|s_pos
argument_list|)
expr_stmt|;
comment|/* %s, arg %d declared inconsistently ... */
name|msg
argument_list|(
literal|11
argument_list|,
name|hte
operator|->
name|h_name
argument_list|,
name|n
operator|+
literal|1
argument_list|,
name|pos1
argument_list|,
name|pos2
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pos1
argument_list|)
expr_stmt|;
block|}
name|n
operator|++
expr_stmt|;
name|ap1
operator|++
expr_stmt|;
name|ap2
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|ap1
operator|==
operator|*
name|ap2
condition|)
block|{
name|tp1
operator|=
name|TP
argument_list|(
name|sym1
operator|->
name|s_type
argument_list|)
expr_stmt|;
name|tp2
operator|=
name|TP
argument_list|(
name|sym
operator|->
name|s_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp1
operator|->
name|t_vararg
operator|==
name|tp2
operator|->
name|t_vararg
condition|)
continue|continue;
if|if
condition|(
name|tp2
operator|->
name|t_vararg
operator|&&
name|sym1
operator|->
name|s_va
operator|&&
name|sym1
operator|->
name|s_nva
operator|==
name|n
operator|&&
operator|!
name|sflag
condition|)
block|{
continue|continue;
block|}
block|}
comment|/* %s: variable # of args declared\t%s  ::  %s */
name|pos1
operator|=
name|xstrdup
argument_list|(
name|mkpos
argument_list|(
operator|&
name|sym1
operator|->
name|s_pos
argument_list|)
argument_list|)
expr_stmt|;
name|msg
argument_list|(
literal|12
argument_list|,
name|hte
operator|->
name|h_name
argument_list|,
name|pos1
argument_list|,
name|mkpos
argument_list|(
operator|&
name|sym
operator|->
name|s_pos
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pos1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Check compatibility of two types. Returns 1 if types are compatible,  * otherwise 0.  *  * ignqual	if set, ignore qualifiers of outhermost type; used for  *		function arguments  * promote	if set, promote left type before comparison; used for  *		comparisons of arguments with parameters of old style  *		definitions  * asgn		left indirected type must have at least the same qualifiers  *		like right indirected type (for assignments and function  *		arguments)  * *warn	set to 1 if an old style declaration was compared with  *		an incompatible prototype declaration  */
end_comment

begin_function
specifier|static
name|int
name|eqtype
parameter_list|(
name|type_t
modifier|*
name|tp1
parameter_list|,
name|type_t
modifier|*
name|tp2
parameter_list|,
name|int
name|ignqual
parameter_list|,
name|int
name|promot
parameter_list|,
name|int
name|asgn
parameter_list|,
name|int
modifier|*
name|warn
parameter_list|)
block|{
name|tspec_t
name|t
decl_stmt|,
name|to
decl_stmt|;
name|int
name|indir
decl_stmt|;
name|to
operator|=
name|NOTSPEC
expr_stmt|;
name|indir
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|tp1
operator|!=
name|NULL
operator|&&
name|tp2
operator|!=
name|NULL
condition|)
block|{
name|t
operator|=
name|tp1
operator|->
name|t_tspec
expr_stmt|;
if|if
condition|(
name|promot
condition|)
block|{
if|if
condition|(
name|t
operator|==
name|FLOAT
condition|)
block|{
name|t
operator|=
name|DOUBLE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t
operator|==
name|CHAR
operator|||
name|t
operator|==
name|SCHAR
condition|)
block|{
name|t
operator|=
name|INT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t
operator|==
name|UCHAR
condition|)
block|{
name|t
operator|=
name|tflag
condition|?
name|UINT
else|:
name|INT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t
operator|==
name|SHORT
condition|)
block|{
name|t
operator|=
name|INT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t
operator|==
name|USHORT
condition|)
block|{
comment|/* CONSTCOND */
name|t
operator|=
name|INT_MAX
operator|<
name|USHRT_MAX
operator|||
name|tflag
condition|?
name|UINT
else|:
name|INT
expr_stmt|;
block|}
block|}
if|if
condition|(
name|asgn
operator|&&
name|to
operator|==
name|PTR
condition|)
block|{
if|if
condition|(
name|indir
operator|==
literal|1
operator|&&
operator|(
name|t
operator|==
name|VOID
operator|||
name|tp2
operator|->
name|t_tspec
operator|==
name|VOID
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|t
operator|!=
name|tp2
operator|->
name|t_tspec
condition|)
block|{
comment|/* 			 * Give pointer to types which differ only in 			 * signedness a chance if not sflag and not hflag. 			 */
if|if
condition|(
name|sflag
operator|||
name|hflag
operator|||
name|to
operator|!=
name|PTR
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|styp
argument_list|(
name|t
argument_list|)
operator|!=
name|styp
argument_list|(
name|tp2
operator|->
name|t_tspec
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|tp1
operator|->
name|t_isenum
operator|&&
name|tp2
operator|->
name|t_isenum
condition|)
block|{
if|if
condition|(
name|tp1
operator|->
name|t_istag
operator|&&
name|tp2
operator|->
name|t_istag
condition|)
block|{
return|return
operator|(
name|tp1
operator|->
name|t_tag
operator|==
name|tp2
operator|->
name|t_tag
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|tp1
operator|->
name|t_istynam
operator|&&
name|tp2
operator|->
name|t_istynam
condition|)
block|{
return|return
operator|(
name|tp1
operator|->
name|t_tynam
operator|==
name|tp2
operator|->
name|t_tynam
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|tp1
operator|->
name|t_isuniqpos
operator|&&
name|tp2
operator|->
name|t_isuniqpos
condition|)
block|{
return|return
operator|(
name|tp1
operator|->
name|t_uniqpos
operator|.
name|p_line
operator|==
name|tp2
operator|->
name|t_uniqpos
operator|.
name|p_line
operator|&&
name|tp1
operator|->
name|t_uniqpos
operator|.
name|p_file
operator|==
name|tp2
operator|->
name|t_uniqpos
operator|.
name|p_file
operator|&&
name|tp1
operator|->
name|t_uniqpos
operator|.
name|p_uniq
operator|==
name|tp2
operator|->
name|t_uniqpos
operator|.
name|p_uniq
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
comment|/* 		 * XXX Handle combinations of enum and int if eflag is set. 		 * But note: enum and 0 should be allowed. 		 */
if|if
condition|(
name|asgn
operator|&&
name|indir
operator|==
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|tp1
operator|->
name|t_const
operator|&&
name|tp2
operator|->
name|t_const
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
name|tp1
operator|->
name|t_volatile
operator|&&
name|tp2
operator|->
name|t_volatile
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|ignqual
operator|&&
operator|!
name|tflag
condition|)
block|{
if|if
condition|(
name|tp1
operator|->
name|t_const
operator|!=
name|tp2
operator|->
name|t_const
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|tp1
operator|->
name|t_const
operator|!=
name|tp2
operator|->
name|t_const
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|t
operator|==
name|STRUCT
operator|||
name|t
operator|==
name|UNION
condition|)
block|{
if|if
condition|(
name|tp1
operator|->
name|t_istag
operator|&&
name|tp2
operator|->
name|t_istag
condition|)
block|{
return|return
operator|(
name|tp1
operator|->
name|t_tag
operator|==
name|tp2
operator|->
name|t_tag
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|tp1
operator|->
name|t_istynam
operator|&&
name|tp2
operator|->
name|t_istynam
condition|)
block|{
return|return
operator|(
name|tp1
operator|->
name|t_tynam
operator|==
name|tp2
operator|->
name|t_tynam
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|tp1
operator|->
name|t_isuniqpos
operator|&&
name|tp2
operator|->
name|t_isuniqpos
condition|)
block|{
return|return
operator|(
name|tp1
operator|->
name|t_uniqpos
operator|.
name|p_line
operator|==
name|tp2
operator|->
name|t_uniqpos
operator|.
name|p_line
operator|&&
name|tp1
operator|->
name|t_uniqpos
operator|.
name|p_file
operator|==
name|tp2
operator|->
name|t_uniqpos
operator|.
name|p_file
operator|&&
name|tp1
operator|->
name|t_uniqpos
operator|.
name|p_uniq
operator|==
name|tp2
operator|->
name|t_uniqpos
operator|.
name|p_uniq
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
if|if
condition|(
name|t
operator|==
name|ARRAY
operator|&&
name|tp1
operator|->
name|t_dim
operator|!=
name|tp2
operator|->
name|t_dim
condition|)
block|{
if|if
condition|(
name|tp1
operator|->
name|t_dim
operator|!=
literal|0
operator|&&
name|tp2
operator|->
name|t_dim
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|t
operator|==
name|FUNC
condition|)
block|{
if|if
condition|(
name|tp1
operator|->
name|t_proto
operator|&&
name|tp2
operator|->
name|t_proto
condition|)
block|{
if|if
condition|(
operator|!
name|eqargs
argument_list|(
name|tp1
argument_list|,
name|tp2
argument_list|,
name|warn
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|tp1
operator|->
name|t_proto
condition|)
block|{
if|if
condition|(
operator|!
name|mnoarg
argument_list|(
name|tp1
argument_list|,
name|warn
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|tp2
operator|->
name|t_proto
condition|)
block|{
if|if
condition|(
operator|!
name|mnoarg
argument_list|(
name|tp2
argument_list|,
name|warn
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
name|tp1
operator|=
name|tp1
operator|->
name|t_subt
expr_stmt|;
name|tp2
operator|=
name|tp2
operator|->
name|t_subt
expr_stmt|;
name|ignqual
operator|=
name|promot
operator|=
literal|0
expr_stmt|;
name|to
operator|=
name|t
expr_stmt|;
name|indir
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|tp1
operator|==
name|tp2
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Compares arguments of two prototypes  */
end_comment

begin_function
specifier|static
name|int
name|eqargs
parameter_list|(
name|type_t
modifier|*
name|tp1
parameter_list|,
name|type_t
modifier|*
name|tp2
parameter_list|,
name|int
modifier|*
name|warn
parameter_list|)
block|{
name|type_t
modifier|*
modifier|*
name|a1
decl_stmt|,
modifier|*
modifier|*
name|a2
decl_stmt|;
if|if
condition|(
name|tp1
operator|->
name|t_vararg
operator|!=
name|tp2
operator|->
name|t_vararg
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|a1
operator|=
name|tp1
operator|->
name|t_args
expr_stmt|;
name|a2
operator|=
name|tp2
operator|->
name|t_args
expr_stmt|;
while|while
condition|(
operator|*
name|a1
operator|!=
name|NULL
operator|&&
operator|*
name|a2
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|eqtype
argument_list|(
operator|*
name|a1
argument_list|,
operator|*
name|a2
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|warn
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|a1
operator|++
expr_stmt|;
name|a2
operator|++
expr_stmt|;
block|}
return|return
operator|(
operator|*
name|a1
operator|==
operator|*
name|a2
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * mnoarg() (matches functions with no argument type information)  * returns 1 if all parameters of a prototype are compatible with  * and old style function declaration.  * This is the case if following conditions are met:  *	1. the prototype must have a fixed number of parameters  *	2. no parameter is of type float  *	3. no parameter is converted to another type if integer promotion  *	   is applied on it  */
end_comment

begin_function
specifier|static
name|int
name|mnoarg
parameter_list|(
name|type_t
modifier|*
name|tp
parameter_list|,
name|int
modifier|*
name|warn
parameter_list|)
block|{
name|type_t
modifier|*
modifier|*
name|arg
decl_stmt|;
name|tspec_t
name|t
decl_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_vararg
operator|&&
name|warn
operator|!=
name|NULL
condition|)
operator|*
name|warn
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|arg
operator|=
name|tp
operator|->
name|t_args
init|;
operator|*
name|arg
operator|!=
name|NULL
condition|;
name|arg
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|t
operator|=
operator|(
operator|*
name|arg
operator|)
operator|->
name|t_tspec
operator|)
operator|==
name|FLOAT
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|t
operator|==
name|CHAR
operator|||
name|t
operator|==
name|SCHAR
operator|||
name|t
operator|==
name|UCHAR
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|t
operator|==
name|SHORT
operator|||
name|t
operator|==
name|USHORT
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

end_unit

