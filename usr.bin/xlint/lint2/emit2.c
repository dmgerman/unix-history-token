begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: emit2.c,v 1.2 1995/07/03 21:24:44 cgd Exp $	*/
end_comment

begin_comment
comment|/*  * Copyright (c) 1994, 1995 Jochen Pohl  * All Rights Reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *      This product includes software developed by Jochen Pohl for  *	The NetBSD Project.  * 4. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$NetBSD: emit2.c,v 1.2 1995/07/03 21:24:44 cgd Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|"lint2.h"
end_include

begin_decl_stmt
specifier|static
name|void
name|outtype
name|__P
argument_list|(
operator|(
name|type_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|outdef
name|__P
argument_list|(
operator|(
name|hte_t
operator|*
operator|,
name|sym_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dumpname
name|__P
argument_list|(
operator|(
name|hte_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Write type into the output buffer.  */
end_comment

begin_function
specifier|static
name|void
name|outtype
parameter_list|(
name|tp
parameter_list|)
name|type_t
modifier|*
name|tp
decl_stmt|;
block|{
name|int
name|t
decl_stmt|,
name|s
decl_stmt|,
name|na
decl_stmt|;
name|tspec_t
name|ts
decl_stmt|;
name|type_t
modifier|*
modifier|*
name|ap
decl_stmt|;
while|while
condition|(
name|tp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|ts
operator|=
name|tp
operator|->
name|t_tspec
operator|)
operator|==
name|INT
operator|&&
name|tp
operator|->
name|t_isenum
condition|)
name|ts
operator|=
name|ENUM
expr_stmt|;
switch|switch
condition|(
name|ts
condition|)
block|{
case|case
name|CHAR
case|:
name|t
operator|=
literal|'C'
expr_stmt|;
name|s
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
name|SCHAR
case|:
name|t
operator|=
literal|'C'
expr_stmt|;
name|s
operator|=
literal|'s'
expr_stmt|;
break|break;
case|case
name|UCHAR
case|:
name|t
operator|=
literal|'C'
expr_stmt|;
name|s
operator|=
literal|'u'
expr_stmt|;
break|break;
case|case
name|SHORT
case|:
name|t
operator|=
literal|'S'
expr_stmt|;
name|s
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
name|USHORT
case|:
name|t
operator|=
literal|'S'
expr_stmt|;
name|s
operator|=
literal|'u'
expr_stmt|;
break|break;
case|case
name|INT
case|:
name|t
operator|=
literal|'I'
expr_stmt|;
name|s
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
name|UINT
case|:
name|t
operator|=
literal|'I'
expr_stmt|;
name|s
operator|=
literal|'u'
expr_stmt|;
break|break;
case|case
name|LONG
case|:
name|t
operator|=
literal|'L'
expr_stmt|;
name|s
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
name|ULONG
case|:
name|t
operator|=
literal|'L'
expr_stmt|;
name|s
operator|=
literal|'u'
expr_stmt|;
break|break;
case|case
name|QUAD
case|:
name|t
operator|=
literal|'Q'
expr_stmt|;
name|s
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
name|UQUAD
case|:
name|t
operator|=
literal|'Q'
expr_stmt|;
name|s
operator|=
literal|'u'
expr_stmt|;
break|break;
case|case
name|FLOAT
case|:
name|t
operator|=
literal|'D'
expr_stmt|;
name|s
operator|=
literal|'s'
expr_stmt|;
break|break;
case|case
name|DOUBLE
case|:
name|t
operator|=
literal|'D'
expr_stmt|;
name|s
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
name|LDOUBLE
case|:
name|t
operator|=
literal|'D'
expr_stmt|;
name|s
operator|=
literal|'l'
expr_stmt|;
break|break;
case|case
name|VOID
case|:
name|t
operator|=
literal|'V'
expr_stmt|;
name|s
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
name|PTR
case|:
name|t
operator|=
literal|'P'
expr_stmt|;
name|s
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
name|ARRAY
case|:
name|t
operator|=
literal|'A'
expr_stmt|;
name|s
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
name|ENUM
case|:
name|t
operator|=
literal|'T'
expr_stmt|;
name|s
operator|=
literal|'e'
expr_stmt|;
break|break;
case|case
name|STRUCT
case|:
name|t
operator|=
literal|'T'
expr_stmt|;
name|s
operator|=
literal|'s'
expr_stmt|;
break|break;
case|case
name|UNION
case|:
name|t
operator|=
literal|'T'
expr_stmt|;
name|s
operator|=
literal|'u'
expr_stmt|;
break|break;
case|case
name|FUNC
case|:
if|if
condition|(
name|tp
operator|->
name|t_args
operator|!=
name|NULL
operator|&&
operator|!
name|tp
operator|->
name|t_proto
condition|)
block|{
name|t
operator|=
literal|'f'
expr_stmt|;
block|}
else|else
block|{
name|t
operator|=
literal|'F'
expr_stmt|;
block|}
name|s
operator|=
literal|'\0'
expr_stmt|;
break|break;
default|default:
name|errx
argument_list|(
literal|1
argument_list|,
literal|"internal error: outtype() 1"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tp
operator|->
name|t_const
condition|)
name|outchar
argument_list|(
literal|'c'
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_volatile
condition|)
name|outchar
argument_list|(
literal|'v'
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
literal|'\0'
condition|)
name|outchar
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|outchar
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|ts
operator|==
name|ARRAY
condition|)
block|{
name|outint
argument_list|(
name|tp
operator|->
name|t_dim
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ts
operator|==
name|ENUM
operator|||
name|ts
operator|==
name|STRUCT
operator|||
name|ts
operator|==
name|UNION
condition|)
block|{
if|if
condition|(
name|tp
operator|->
name|t_istag
condition|)
block|{
name|outint
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|outname
argument_list|(
name|tp
operator|->
name|t_tag
operator|->
name|h_name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tp
operator|->
name|t_istynam
condition|)
block|{
name|outint
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|outname
argument_list|(
name|tp
operator|->
name|t_tynam
operator|->
name|h_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|outint
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ts
operator|==
name|FUNC
operator|&&
name|tp
operator|->
name|t_args
operator|!=
name|NULL
condition|)
block|{
name|na
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ap
operator|=
name|tp
operator|->
name|t_args
init|;
operator|*
name|ap
operator|!=
name|NULL
condition|;
name|ap
operator|++
control|)
name|na
operator|++
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_vararg
condition|)
name|na
operator|++
expr_stmt|;
name|outint
argument_list|(
name|na
argument_list|)
expr_stmt|;
for|for
control|(
name|ap
operator|=
name|tp
operator|->
name|t_args
init|;
operator|*
name|ap
operator|!=
name|NULL
condition|;
name|ap
operator|++
control|)
name|outtype
argument_list|(
operator|*
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_vararg
condition|)
name|outchar
argument_list|(
literal|'E'
argument_list|)
expr_stmt|;
block|}
name|tp
operator|=
name|tp
operator|->
name|t_subt
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Write a definition.  */
end_comment

begin_function
specifier|static
name|void
name|outdef
parameter_list|(
name|hte
parameter_list|,
name|sym
parameter_list|)
name|hte_t
modifier|*
name|hte
decl_stmt|;
name|sym_t
modifier|*
name|sym
decl_stmt|;
block|{
comment|/* reset output buffer */
name|outclr
argument_list|()
expr_stmt|;
comment|/* line number in C source file */
name|outint
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* this is a definition */
name|outchar
argument_list|(
literal|'d'
argument_list|)
expr_stmt|;
comment|/* index of file where symbol was defined and line number of def. */
name|outint
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|outchar
argument_list|(
literal|'.'
argument_list|)
expr_stmt|;
name|outint
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* flags */
if|if
condition|(
name|sym
operator|->
name|s_va
condition|)
block|{
name|outchar
argument_list|(
literal|'v'
argument_list|)
expr_stmt|;
comment|/* varargs */
name|outint
argument_list|(
name|sym
operator|->
name|s_nva
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sym
operator|->
name|s_scfl
condition|)
block|{
name|outchar
argument_list|(
literal|'S'
argument_list|)
expr_stmt|;
comment|/* scanflike */
name|outint
argument_list|(
name|sym
operator|->
name|s_nscfl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sym
operator|->
name|s_prfl
condition|)
block|{
name|outchar
argument_list|(
literal|'P'
argument_list|)
expr_stmt|;
comment|/* printflike */
name|outint
argument_list|(
name|sym
operator|->
name|s_nprfl
argument_list|)
expr_stmt|;
block|}
comment|/* definition or tentative definition */
name|outchar
argument_list|(
name|sym
operator|->
name|s_def
operator|==
name|DEF
condition|?
literal|'d'
else|:
literal|'t'
argument_list|)
expr_stmt|;
if|if
condition|(
name|TP
argument_list|(
name|sym
operator|->
name|s_type
argument_list|)
operator|->
name|t_tspec
operator|==
name|FUNC
condition|)
block|{
if|if
condition|(
name|sym
operator|->
name|s_rval
condition|)
name|outchar
argument_list|(
literal|'r'
argument_list|)
expr_stmt|;
comment|/* fkt. has return value */
if|if
condition|(
name|sym
operator|->
name|s_osdef
condition|)
name|outchar
argument_list|(
literal|'o'
argument_list|)
expr_stmt|;
comment|/* old style definition */
block|}
name|outchar
argument_list|(
literal|'u'
argument_list|)
expr_stmt|;
comment|/* used (no warning if not used) */
comment|/* name */
name|outname
argument_list|(
name|hte
operator|->
name|h_name
argument_list|)
expr_stmt|;
comment|/* type */
name|outtype
argument_list|(
name|TP
argument_list|(
name|sym
operator|->
name|s_type
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Write the first definition of a name into the lint library.  */
end_comment

begin_function
specifier|static
name|void
name|dumpname
parameter_list|(
name|hte
parameter_list|)
name|hte_t
modifier|*
name|hte
decl_stmt|;
block|{
name|sym_t
modifier|*
name|sym
decl_stmt|,
modifier|*
name|def
decl_stmt|;
comment|/* static and undefined symbols are not written */
if|if
condition|(
name|hte
operator|->
name|h_static
operator|||
operator|!
name|hte
operator|->
name|h_def
condition|)
return|return;
comment|/* 	 * If there is a definition, write it. Otherwise write a tentative 	 * definition. This is neccessary because more than one tentative 	 * definition is allowed (except with sflag). 	 */
name|def
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|sym
operator|=
name|hte
operator|->
name|h_syms
init|;
name|sym
operator|!=
name|NULL
condition|;
name|sym
operator|=
name|sym
operator|->
name|s_nxt
control|)
block|{
if|if
condition|(
name|sym
operator|->
name|s_def
operator|==
name|DEF
condition|)
block|{
name|def
operator|=
name|sym
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|sym
operator|->
name|s_def
operator|==
name|TDEF
operator|&&
name|def
operator|==
name|NULL
condition|)
name|def
operator|=
name|sym
expr_stmt|;
block|}
if|if
condition|(
name|def
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"internal error: dumpname() %s"
argument_list|,
name|hte
operator|->
name|h_name
argument_list|)
expr_stmt|;
name|outdef
argument_list|(
name|hte
argument_list|,
name|def
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Write a new lint library.  */
end_comment

begin_function
name|void
name|outlib
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
comment|/* Open of output file and initialisation of the output buffer */
name|outopen
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* write name of lint library */
name|outsrc
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* name of lint lib has index 0 */
name|outclr
argument_list|()
expr_stmt|;
name|outint
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|outchar
argument_list|(
literal|'s'
argument_list|)
expr_stmt|;
name|outstrg
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* write all definitions with external linkage */
name|forall
argument_list|(
name|dumpname
argument_list|)
expr_stmt|;
comment|/* close the output */
name|outclose
argument_list|()
expr_stmt|;
block|}
end_function

end_unit

