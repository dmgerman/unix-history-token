begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: tree.c,v 1.12 1995/10/02 17:37:57 jpo Exp $	*/
end_comment

begin_comment
comment|/*  * Copyright (c) 1994, 1995 Jochen Pohl  * All Rights Reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *      This product includes software developed by Jochen Pohl for  *	The NetBSD Project.  * 4. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$NetBSD: tree.c,v 1.12 1995/10/02 17:37:57 jpo Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<float.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_include
include|#
directive|include
file|"lint1.h"
end_include

begin_include
include|#
directive|include
file|"y.tab.h"
end_include

begin_comment
comment|/* Various flags for each operator. */
end_comment

begin_decl_stmt
specifier|static
name|mod_t
name|modtab
index|[
name|NOPS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tnode_t
modifier|*
name|getinode
name|__P
argument_list|(
operator|(
name|tspec_t
operator|,
name|quad_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ptrcmpok
name|__P
argument_list|(
operator|(
name|op_t
operator|,
name|tnode_t
operator|*
operator|,
name|tnode_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|asgntypok
name|__P
argument_list|(
operator|(
name|op_t
operator|,
name|int
operator|,
name|tnode_t
operator|*
operator|,
name|tnode_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|chkbeop
name|__P
argument_list|(
operator|(
name|op_t
operator|,
name|tnode_t
operator|*
operator|,
name|tnode_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|chkeop2
name|__P
argument_list|(
operator|(
name|op_t
operator|,
name|int
operator|,
name|tnode_t
operator|*
operator|,
name|tnode_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|chkeop1
name|__P
argument_list|(
operator|(
name|op_t
operator|,
name|int
operator|,
name|tnode_t
operator|*
operator|,
name|tnode_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tnode_t
modifier|*
name|mktnode
name|__P
argument_list|(
operator|(
name|op_t
operator|,
name|type_t
operator|*
operator|,
name|tnode_t
operator|*
operator|,
name|tnode_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|balance
name|__P
argument_list|(
operator|(
name|op_t
operator|,
name|tnode_t
operator|*
operator|*
operator|,
name|tnode_t
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|incompat
name|__P
argument_list|(
operator|(
name|op_t
operator|,
name|tspec_t
operator|,
name|tspec_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|illptrc
name|__P
argument_list|(
operator|(
name|mod_t
operator|*
operator|,
name|type_t
operator|*
operator|,
name|type_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mrgqual
name|__P
argument_list|(
operator|(
name|type_t
operator|*
operator|*
operator|,
name|type_t
operator|*
operator|,
name|type_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|conmemb
name|__P
argument_list|(
operator|(
name|type_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ptconv
name|__P
argument_list|(
operator|(
name|int
operator|,
name|tspec_t
operator|,
name|tspec_t
operator|,
name|type_t
operator|*
operator|,
name|tnode_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|iiconv
name|__P
argument_list|(
operator|(
name|op_t
operator|,
name|int
operator|,
name|tspec_t
operator|,
name|tspec_t
operator|,
name|type_t
operator|*
operator|,
name|tnode_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|piconv
name|__P
argument_list|(
operator|(
name|op_t
operator|,
name|tspec_t
operator|,
name|type_t
operator|*
operator|,
name|tnode_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ppconv
name|__P
argument_list|(
operator|(
name|op_t
operator|,
name|tnode_t
operator|*
operator|,
name|type_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tnode_t
modifier|*
name|bldstr
name|__P
argument_list|(
operator|(
name|op_t
operator|,
name|tnode_t
operator|*
operator|,
name|tnode_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tnode_t
modifier|*
name|bldincdec
name|__P
argument_list|(
operator|(
name|op_t
operator|,
name|tnode_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tnode_t
modifier|*
name|bldamper
name|__P
argument_list|(
operator|(
name|tnode_t
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tnode_t
modifier|*
name|bldplmi
name|__P
argument_list|(
operator|(
name|op_t
operator|,
name|tnode_t
operator|*
operator|,
name|tnode_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tnode_t
modifier|*
name|bldshft
name|__P
argument_list|(
operator|(
name|op_t
operator|,
name|tnode_t
operator|*
operator|,
name|tnode_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tnode_t
modifier|*
name|bldcol
name|__P
argument_list|(
operator|(
name|tnode_t
operator|*
operator|,
name|tnode_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tnode_t
modifier|*
name|bldasgn
name|__P
argument_list|(
operator|(
name|op_t
operator|,
name|tnode_t
operator|*
operator|,
name|tnode_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tnode_t
modifier|*
name|plength
name|__P
argument_list|(
operator|(
name|type_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tnode_t
modifier|*
name|fold
name|__P
argument_list|(
operator|(
name|tnode_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tnode_t
modifier|*
name|foldtst
name|__P
argument_list|(
operator|(
name|tnode_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tnode_t
modifier|*
name|foldflt
name|__P
argument_list|(
operator|(
name|tnode_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tnode_t
modifier|*
name|chkfarg
name|__P
argument_list|(
operator|(
name|type_t
operator|*
operator|,
name|tnode_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tnode_t
modifier|*
name|parg
name|__P
argument_list|(
operator|(
name|int
operator|,
name|type_t
operator|*
operator|,
name|tnode_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|nulleff
name|__P
argument_list|(
operator|(
name|tnode_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|displexpr
name|__P
argument_list|(
operator|(
name|tnode_t
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|chkaidx
name|__P
argument_list|(
operator|(
name|tnode_t
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|chkcomp
name|__P
argument_list|(
operator|(
name|op_t
operator|,
name|tnode_t
operator|*
operator|,
name|tnode_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|precconf
name|__P
argument_list|(
operator|(
name|tnode_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Initialize mods of operators.  */
end_comment

begin_function
name|void
name|initmtab
parameter_list|()
block|{
specifier|static
struct|struct
block|{
name|op_t
name|op
decl_stmt|;
name|mod_t
name|m
decl_stmt|;
block|}
name|imods
index|[]
init|=
block|{
block|{
name|ARROW
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|"->"
block|}
block|}
block|,
block|{
name|POINT
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|"."
block|}
block|}
block|,
block|{
name|NOT
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|"!"
block|}
block|}
block|,
block|{
name|COMPL
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|"~"
block|}
block|}
block|,
block|{
name|INCBEF
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|"prefix++"
block|}
block|}
block|,
block|{
name|DECBEF
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|"prefix--"
block|}
block|}
block|,
block|{
name|INCAFT
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|"postfix++"
block|}
block|}
block|,
block|{
name|DECAFT
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|"postfix--"
block|}
block|}
block|,
block|{
name|UPLUS
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|"unary +"
block|}
block|}
block|,
block|{
name|UMINUS
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|"unary -"
block|}
block|}
block|,
block|{
name|STAR
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|"unary *"
block|}
block|}
block|,
block|{
name|AMPER
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|"unary&"
block|}
block|}
block|,
block|{
name|MULT
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|"*"
block|}
block|}
block|,
block|{
name|DIV
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|"/"
block|}
block|}
block|,
block|{
name|MOD
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|"%"
block|}
block|}
block|,
block|{
name|PLUS
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|"+"
block|}
block|}
block|,
block|{
name|MINUS
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|"-"
block|}
block|}
block|,
block|{
name|SHL
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|"<<"
block|}
block|}
block|,
block|{
name|SHR
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|">>"
block|}
block|}
block|,
block|{
name|LT
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|"<"
block|}
block|}
block|,
block|{
name|LE
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|"<="
block|}
block|}
block|,
block|{
name|GT
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|">"
block|}
block|}
block|,
block|{
name|GE
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|">="
block|}
block|}
block|,
block|{
name|EQ
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|"=="
block|}
block|}
block|,
block|{
name|NE
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|"!="
block|}
block|}
block|,
block|{
name|AND
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|"&"
block|}
block|}
block|,
block|{
name|XOR
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|"^"
block|}
block|}
block|,
block|{
name|OR
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|"|"
block|}
block|}
block|,
block|{
name|LOGAND
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|"&&"
block|}
block|}
block|,
block|{
name|LOGOR
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|"||"
block|}
block|}
block|,
block|{
name|QUEST
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|"?"
block|}
block|}
block|,
block|{
name|COLON
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|":"
block|}
block|}
block|,
block|{
name|ASSIGN
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|"="
block|}
block|}
block|,
block|{
name|MULASS
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|"*="
block|}
block|}
block|,
block|{
name|DIVASS
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|"/="
block|}
block|}
block|,
block|{
name|MODASS
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|"%="
block|}
block|}
block|,
block|{
name|ADDASS
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|"+="
block|}
block|}
block|,
block|{
name|SUBASS
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|"-="
block|}
block|}
block|,
block|{
name|SHLASS
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|"<<="
block|}
block|}
block|,
block|{
name|SHRASS
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|">>="
block|}
block|}
block|,
block|{
name|ANDASS
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|"&="
block|}
block|}
block|,
block|{
name|XORASS
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|"^="
block|}
block|}
block|,
block|{
name|ORASS
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|"|="
block|}
block|}
block|,
block|{
name|NAME
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|"NAME"
block|}
block|}
block|,
block|{
name|CON
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|"CON"
block|}
block|}
block|,
block|{
name|STRING
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|"STRING"
block|}
block|}
block|,
block|{
name|FSEL
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|"FSEL"
block|}
block|}
block|,
block|{
name|CALL
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|"CALL"
block|}
block|}
block|,
block|{
name|COMMA
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|","
block|}
block|}
block|,
block|{
name|CVT
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|"CVT"
block|}
block|}
block|,
block|{
name|ICALL
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|"ICALL"
block|}
block|}
block|,
block|{
name|LOAD
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|"LOAD"
block|}
block|}
block|,
block|{
name|PUSH
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|"PUSH"
block|}
block|}
block|,
block|{
name|RETURN
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|"RETURN"
block|}
block|}
block|,
block|{
name|INIT
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|"INIT"
block|}
block|}
block|,
block|{
name|FARG
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|"FARG"
block|}
block|}
block|,
block|{
name|NOOP
block|}
block|}
struct|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|imods
index|[
name|i
index|]
operator|.
name|op
operator|!=
name|NOOP
condition|;
name|i
operator|++
control|)
name|STRUCT_ASSIGN
argument_list|(
name|modtab
index|[
name|imods
index|[
name|i
index|]
operator|.
name|op
index|]
argument_list|,
name|imods
index|[
name|i
index|]
operator|.
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Increase degree of reference.  * This is most often used to change type "T" in type "pointer to T".  */
end_comment

begin_function
name|type_t
modifier|*
name|incref
parameter_list|(
name|tp
parameter_list|,
name|t
parameter_list|)
name|type_t
modifier|*
name|tp
decl_stmt|;
name|tspec_t
name|t
decl_stmt|;
block|{
name|type_t
modifier|*
name|tp2
decl_stmt|;
name|tp2
operator|=
name|getblk
argument_list|(
sizeof|sizeof
argument_list|(
name|type_t
argument_list|)
argument_list|)
expr_stmt|;
name|tp2
operator|->
name|t_tspec
operator|=
name|t
expr_stmt|;
name|tp2
operator|->
name|t_subt
operator|=
name|tp
expr_stmt|;
return|return
operator|(
name|tp2
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * same for use in expressions  */
end_comment

begin_function
name|type_t
modifier|*
name|tincref
parameter_list|(
name|tp
parameter_list|,
name|t
parameter_list|)
name|type_t
modifier|*
name|tp
decl_stmt|;
name|tspec_t
name|t
decl_stmt|;
block|{
name|type_t
modifier|*
name|tp2
decl_stmt|;
name|tp2
operator|=
name|tgetblk
argument_list|(
sizeof|sizeof
argument_list|(
name|type_t
argument_list|)
argument_list|)
expr_stmt|;
name|tp2
operator|->
name|t_tspec
operator|=
name|t
expr_stmt|;
name|tp2
operator|->
name|t_subt
operator|=
name|tp
expr_stmt|;
return|return
operator|(
name|tp2
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create a node for a constant.  */
end_comment

begin_function
name|tnode_t
modifier|*
name|getcnode
parameter_list|(
name|tp
parameter_list|,
name|v
parameter_list|)
name|type_t
modifier|*
name|tp
decl_stmt|;
name|val_t
modifier|*
name|v
decl_stmt|;
block|{
name|tnode_t
modifier|*
name|n
decl_stmt|;
name|n
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|n
operator|->
name|tn_op
operator|=
name|CON
expr_stmt|;
name|n
operator|->
name|tn_type
operator|=
name|tp
expr_stmt|;
name|n
operator|->
name|tn_val
operator|=
name|tgetblk
argument_list|(
sizeof|sizeof
argument_list|(
name|val_t
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|->
name|tn_val
operator|->
name|v_tspec
operator|=
name|tp
operator|->
name|t_tspec
expr_stmt|;
name|n
operator|->
name|tn_val
operator|->
name|v_ansiu
operator|=
name|v
operator|->
name|v_ansiu
expr_stmt|;
name|n
operator|->
name|tn_val
operator|->
name|v_u
operator|=
name|v
operator|->
name|v_u
expr_stmt|;
name|free
argument_list|(
name|v
argument_list|)
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create a node for a integer constant.  */
end_comment

begin_function
specifier|static
name|tnode_t
modifier|*
name|getinode
parameter_list|(
name|t
parameter_list|,
name|q
parameter_list|)
name|tspec_t
name|t
decl_stmt|;
name|quad_t
name|q
decl_stmt|;
block|{
name|tnode_t
modifier|*
name|n
decl_stmt|;
name|n
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|n
operator|->
name|tn_op
operator|=
name|CON
expr_stmt|;
name|n
operator|->
name|tn_type
operator|=
name|gettyp
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|n
operator|->
name|tn_val
operator|=
name|tgetblk
argument_list|(
sizeof|sizeof
argument_list|(
name|val_t
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|->
name|tn_val
operator|->
name|v_tspec
operator|=
name|t
expr_stmt|;
name|n
operator|->
name|tn_val
operator|->
name|v_quad
operator|=
name|q
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create a node for a name (symbol table entry).  * ntok is the token which follows the name.  */
end_comment

begin_function
name|tnode_t
modifier|*
name|getnnode
parameter_list|(
name|sym
parameter_list|,
name|ntok
parameter_list|)
name|sym_t
modifier|*
name|sym
decl_stmt|;
name|int
name|ntok
decl_stmt|;
block|{
name|tnode_t
modifier|*
name|n
decl_stmt|;
if|if
condition|(
name|sym
operator|->
name|s_scl
operator|==
name|NOSCL
condition|)
block|{
name|sym
operator|->
name|s_scl
operator|=
name|EXTERN
expr_stmt|;
name|sym
operator|->
name|s_def
operator|=
name|DECL
expr_stmt|;
if|if
condition|(
name|ntok
operator|==
name|T_LPARN
condition|)
block|{
if|if
condition|(
name|sflag
condition|)
block|{
comment|/* function implicitly declared to ... */
name|warning
argument_list|(
literal|215
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * XXX if tflag is set the symbol should be 			 * exported to level 0 			 */
name|sym
operator|->
name|s_type
operator|=
name|incref
argument_list|(
name|sym
operator|->
name|s_type
argument_list|,
name|FUNC
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* %s undefined */
name|error
argument_list|(
literal|99
argument_list|,
name|sym
operator|->
name|s_name
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sym
operator|->
name|s_kind
operator|!=
name|FVFT
operator|&&
name|sym
operator|->
name|s_kind
operator|!=
name|FMOS
condition|)
name|lerror
argument_list|(
literal|"getnnode() 1"
argument_list|)
expr_stmt|;
name|n
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|n
operator|->
name|tn_type
operator|=
name|sym
operator|->
name|s_type
expr_stmt|;
if|if
condition|(
name|sym
operator|->
name|s_scl
operator|!=
name|ENUMCON
condition|)
block|{
name|n
operator|->
name|tn_op
operator|=
name|NAME
expr_stmt|;
name|n
operator|->
name|tn_sym
operator|=
name|sym
expr_stmt|;
if|if
condition|(
name|sym
operator|->
name|s_kind
operator|==
name|FVFT
operator|&&
name|sym
operator|->
name|s_type
operator|->
name|t_tspec
operator|!=
name|FUNC
condition|)
name|n
operator|->
name|tn_lvalue
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|n
operator|->
name|tn_op
operator|=
name|CON
expr_stmt|;
name|n
operator|->
name|tn_val
operator|=
name|tgetblk
argument_list|(
sizeof|sizeof
argument_list|(
name|val_t
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|n
operator|->
name|tn_val
operator|=
name|sym
operator|->
name|s_value
expr_stmt|;
block|}
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create a node for a string.  */
end_comment

begin_function
name|tnode_t
modifier|*
name|getsnode
parameter_list|(
name|strg
parameter_list|)
name|strg_t
modifier|*
name|strg
decl_stmt|;
block|{
name|size_t
name|len
decl_stmt|;
name|tnode_t
modifier|*
name|n
decl_stmt|;
name|len
operator|=
name|strg
operator|->
name|st_len
expr_stmt|;
name|n
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|n
operator|->
name|tn_op
operator|=
name|STRING
expr_stmt|;
name|n
operator|->
name|tn_type
operator|=
name|tincref
argument_list|(
name|gettyp
argument_list|(
name|strg
operator|->
name|st_tspec
argument_list|)
argument_list|,
name|ARRAY
argument_list|)
expr_stmt|;
name|n
operator|->
name|tn_type
operator|->
name|t_dim
operator|=
name|len
operator|+
literal|1
expr_stmt|;
name|n
operator|->
name|tn_lvalue
operator|=
literal|1
expr_stmt|;
name|n
operator|->
name|tn_strg
operator|=
name|tgetblk
argument_list|(
sizeof|sizeof
argument_list|(
name|strg_t
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|->
name|tn_strg
operator|->
name|st_tspec
operator|=
name|strg
operator|->
name|st_tspec
expr_stmt|;
name|n
operator|->
name|tn_strg
operator|->
name|st_len
operator|=
name|len
expr_stmt|;
if|if
condition|(
name|strg
operator|->
name|st_tspec
operator|==
name|CHAR
condition|)
block|{
name|n
operator|->
name|tn_strg
operator|->
name|st_cp
operator|=
name|tgetblk
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|memcpy
argument_list|(
name|n
operator|->
name|tn_strg
operator|->
name|st_cp
argument_list|,
name|strg
operator|->
name|st_cp
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|strg
operator|->
name|st_cp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|n
operator|->
name|tn_strg
operator|->
name|st_wcp
operator|=
name|tgetblk
argument_list|(
operator|(
name|len
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|wchar_t
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|memcpy
argument_list|(
name|n
operator|->
name|tn_strg
operator|->
name|st_wcp
argument_list|,
name|strg
operator|->
name|st_wcp
argument_list|,
operator|(
name|len
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|wchar_t
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|strg
operator|->
name|st_wcp
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|strg
argument_list|)
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns a symbol which has the same name as the msym argument and is a  * member of the struct or union specified by the tn argument.  */
end_comment

begin_function
name|sym_t
modifier|*
name|strmemb
parameter_list|(
name|tn
parameter_list|,
name|op
parameter_list|,
name|msym
parameter_list|)
name|tnode_t
modifier|*
name|tn
decl_stmt|;
name|op_t
name|op
decl_stmt|;
name|sym_t
modifier|*
name|msym
decl_stmt|;
block|{
name|str_t
modifier|*
name|str
decl_stmt|;
name|type_t
modifier|*
name|tp
decl_stmt|;
name|sym_t
modifier|*
name|sym
decl_stmt|,
modifier|*
name|csym
decl_stmt|;
name|int
name|eq
decl_stmt|;
name|tspec_t
name|t
decl_stmt|;
comment|/* 	 * Remove the member if it was unknown until now (Which means 	 * that no defined struct or union has a member with the same name). 	 */
if|if
condition|(
name|msym
operator|->
name|s_scl
operator|==
name|NOSCL
condition|)
block|{
comment|/* undefined struct/union member: %s */
name|error
argument_list|(
literal|101
argument_list|,
name|msym
operator|->
name|s_name
argument_list|)
expr_stmt|;
name|rmsym
argument_list|(
name|msym
argument_list|)
expr_stmt|;
name|msym
operator|->
name|s_kind
operator|=
name|FMOS
expr_stmt|;
name|msym
operator|->
name|s_scl
operator|=
name|MOS
expr_stmt|;
name|msym
operator|->
name|s_styp
operator|=
name|tgetblk
argument_list|(
sizeof|sizeof
argument_list|(
name|str_t
argument_list|)
argument_list|)
expr_stmt|;
name|msym
operator|->
name|s_styp
operator|->
name|stag
operator|=
name|tgetblk
argument_list|(
sizeof|sizeof
argument_list|(
name|sym_t
argument_list|)
argument_list|)
expr_stmt|;
name|msym
operator|->
name|s_styp
operator|->
name|stag
operator|->
name|s_name
operator|=
name|unnamed
expr_stmt|;
name|msym
operator|->
name|s_value
operator|.
name|v_tspec
operator|=
name|INT
expr_stmt|;
return|return
operator|(
name|msym
operator|)
return|;
block|}
comment|/* Set str to the tag of which msym is expected to be a member. */
name|str
operator|=
name|NULL
expr_stmt|;
name|t
operator|=
operator|(
name|tp
operator|=
name|tn
operator|->
name|tn_type
operator|)
operator|->
name|t_tspec
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|POINT
condition|)
block|{
if|if
condition|(
name|t
operator|==
name|STRUCT
operator|||
name|t
operator|==
name|UNION
condition|)
name|str
operator|=
name|tp
operator|->
name|t_str
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|op
operator|==
name|ARROW
operator|&&
name|t
operator|==
name|PTR
condition|)
block|{
name|t
operator|=
operator|(
name|tp
operator|=
name|tp
operator|->
name|t_subt
operator|)
operator|->
name|t_tspec
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|STRUCT
operator|||
name|t
operator|==
name|UNION
condition|)
name|str
operator|=
name|tp
operator|->
name|t_str
expr_stmt|;
block|}
comment|/* 	 * If this struct/union has a member with the name of msym, return 	 * return this it. 	 */
if|if
condition|(
name|str
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|sym
operator|=
name|msym
init|;
name|sym
operator|!=
name|NULL
condition|;
name|sym
operator|=
name|sym
operator|->
name|s_link
control|)
block|{
if|if
condition|(
name|sym
operator|->
name|s_scl
operator|!=
name|MOS
operator|&&
name|sym
operator|->
name|s_scl
operator|!=
name|MOU
condition|)
continue|continue;
if|if
condition|(
name|sym
operator|->
name|s_styp
operator|!=
name|str
condition|)
continue|continue;
if|if
condition|(
name|strcmp
argument_list|(
name|sym
operator|->
name|s_name
argument_list|,
name|msym
operator|->
name|s_name
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
return|return
operator|(
name|sym
operator|)
return|;
block|}
block|}
comment|/* 	 * Set eq to 0 if there are struct/union members with the same name 	 * and different types and/or offsets. 	 */
name|eq
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|csym
operator|=
name|msym
init|;
name|csym
operator|!=
name|NULL
condition|;
name|csym
operator|=
name|csym
operator|->
name|s_link
control|)
block|{
if|if
condition|(
name|csym
operator|->
name|s_scl
operator|!=
name|MOS
operator|&&
name|csym
operator|->
name|s_scl
operator|!=
name|MOU
condition|)
continue|continue;
if|if
condition|(
name|strcmp
argument_list|(
name|msym
operator|->
name|s_name
argument_list|,
name|csym
operator|->
name|s_name
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
for|for
control|(
name|sym
operator|=
name|csym
operator|->
name|s_link
init|;
name|sym
operator|!=
name|NULL
condition|;
name|sym
operator|=
name|sym
operator|->
name|s_link
control|)
block|{
name|int
name|w
decl_stmt|;
if|if
condition|(
name|sym
operator|->
name|s_scl
operator|!=
name|MOS
operator|&&
name|sym
operator|->
name|s_scl
operator|!=
name|MOU
condition|)
continue|continue;
if|if
condition|(
name|strcmp
argument_list|(
name|csym
operator|->
name|s_name
argument_list|,
name|sym
operator|->
name|s_name
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|csym
operator|->
name|s_value
operator|.
name|v_quad
operator|!=
name|sym
operator|->
name|s_value
operator|.
name|v_quad
condition|)
block|{
name|eq
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|w
operator|=
literal|0
expr_stmt|;
name|eq
operator|=
name|eqtype
argument_list|(
name|csym
operator|->
name|s_type
argument_list|,
name|sym
operator|->
name|s_type
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|w
argument_list|)
operator|&&
operator|!
name|w
expr_stmt|;
if|if
condition|(
operator|!
name|eq
condition|)
break|break;
if|if
condition|(
name|csym
operator|->
name|s_field
operator|!=
name|sym
operator|->
name|s_field
condition|)
block|{
name|eq
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|csym
operator|->
name|s_field
condition|)
block|{
name|type_t
modifier|*
name|tp1
decl_stmt|,
modifier|*
name|tp2
decl_stmt|;
name|tp1
operator|=
name|csym
operator|->
name|s_type
expr_stmt|;
name|tp2
operator|=
name|sym
operator|->
name|s_type
expr_stmt|;
if|if
condition|(
name|tp1
operator|->
name|t_flen
operator|!=
name|tp2
operator|->
name|t_flen
condition|)
block|{
name|eq
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|tp1
operator|->
name|t_foffs
operator|!=
name|tp2
operator|->
name|t_foffs
condition|)
block|{
name|eq
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|eq
condition|)
break|break;
block|}
comment|/* 	 * Now handle the case in which the left operand refers really 	 * to a struct/union, but the right operand is not member of it. 	 */
if|if
condition|(
name|str
operator|!=
name|NULL
condition|)
block|{
comment|/* illegal member use: %s */
if|if
condition|(
name|eq
operator|&&
name|tflag
condition|)
block|{
name|warning
argument_list|(
literal|102
argument_list|,
name|msym
operator|->
name|s_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
literal|102
argument_list|,
name|msym
operator|->
name|s_name
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|msym
operator|)
return|;
block|}
comment|/* 	 * Now the left operand of ARROW does not point to a struct/union 	 * or the left operand of POINT is no struct/union. 	 */
if|if
condition|(
name|eq
condition|)
block|{
if|if
condition|(
name|op
operator|==
name|POINT
condition|)
block|{
comment|/* left operand of "." must be struct/union object */
if|if
condition|(
name|tflag
condition|)
block|{
name|warning
argument_list|(
literal|103
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
literal|103
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* left operand of "->" must be pointer to ... */
if|if
condition|(
name|tflag
operator|&&
name|tn
operator|->
name|tn_type
operator|->
name|t_tspec
operator|==
name|PTR
condition|)
block|{
name|warning
argument_list|(
literal|104
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
literal|104
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|tflag
condition|)
block|{
comment|/* non-unique member requires struct/union %s */
name|error
argument_list|(
literal|105
argument_list|,
name|op
operator|==
name|POINT
condition|?
literal|"object"
else|:
literal|"pointer"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* unacceptable operand of %s */
name|error
argument_list|(
literal|111
argument_list|,
name|modtab
index|[
name|op
index|]
operator|.
name|m_name
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|msym
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create a tree node. Called for most operands except function calls,  * sizeof and casts.  *  * op	operator  * ln	left operand  * rn	if not NULL, right operand  */
end_comment

begin_function
name|tnode_t
modifier|*
name|build
parameter_list|(
name|op
parameter_list|,
name|ln
parameter_list|,
name|rn
parameter_list|)
name|op_t
name|op
decl_stmt|;
name|tnode_t
modifier|*
name|ln
decl_stmt|,
decl|*
name|rn
decl_stmt|;
end_function

begin_block
block|{
name|mod_t
modifier|*
name|mp
decl_stmt|;
name|tnode_t
modifier|*
name|ntn
decl_stmt|;
name|type_t
modifier|*
name|rtp
decl_stmt|;
name|mp
operator|=
operator|&
name|modtab
index|[
name|op
index|]
expr_stmt|;
comment|/* If there was an error in one of the operands, return. */
if|if
condition|(
name|ln
operator|==
name|NULL
operator|||
operator|(
name|mp
operator|->
name|m_binary
operator|&&
name|rn
operator|==
name|NULL
operator|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* 	 * Apply class conversions to the left operand, but only if its 	 * value is needed or it is compaired with null. 	 */
if|if
condition|(
name|mp
operator|->
name|m_vctx
operator|||
name|mp
operator|->
name|m_tctx
condition|)
name|ln
operator|=
name|cconv
argument_list|(
name|ln
argument_list|)
expr_stmt|;
comment|/* 	 * The right operand is almost always in a test or value context, 	 * except if it is a struct or union member. 	 */
if|if
condition|(
name|mp
operator|->
name|m_binary
operator|&&
name|op
operator|!=
name|ARROW
operator|&&
name|op
operator|!=
name|POINT
condition|)
name|rn
operator|=
name|cconv
argument_list|(
name|rn
argument_list|)
expr_stmt|;
comment|/* 	 * Print some warnings for comparisions of unsigned values with 	 * constants lower than or equal to null. This must be done 	 * before promote() because otherwise unsigned char and unsigned 	 * short would be promoted to int. Also types are tested to be 	 * CHAR, which would also become int. 	 */
if|if
condition|(
name|mp
operator|->
name|m_comp
condition|)
name|chkcomp
argument_list|(
name|op
argument_list|,
name|ln
argument_list|,
name|rn
argument_list|)
expr_stmt|;
comment|/* 	 * Promote the left operand if it is in a test or value context 	 */
if|if
condition|(
name|mp
operator|->
name|m_vctx
operator|||
name|mp
operator|->
name|m_tctx
condition|)
name|ln
operator|=
name|promote
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
name|ln
argument_list|)
expr_stmt|;
comment|/* 	 * Promote the right operand, but only if it is no struct or 	 * union member, or if it is not to be assigned to the left operand 	 */
if|if
condition|(
name|mp
operator|->
name|m_binary
operator|&&
name|op
operator|!=
name|ARROW
operator|&&
name|op
operator|!=
name|POINT
operator|&&
name|op
operator|!=
name|ASSIGN
operator|&&
name|op
operator|!=
name|RETURN
condition|)
block|{
name|rn
operator|=
name|promote
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
name|rn
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If the result of the operation is different for signed or 	 * unsigned operands and one of the operands is signed only in 	 * ANSI C, print a warning. 	 */
if|if
condition|(
name|mp
operator|->
name|m_tlansiu
operator|&&
name|ln
operator|->
name|tn_op
operator|==
name|CON
operator|&&
name|ln
operator|->
name|tn_val
operator|->
name|v_ansiu
condition|)
block|{
comment|/* ANSI C treats constant as unsigned, op %s */
name|warning
argument_list|(
literal|218
argument_list|,
name|mp
operator|->
name|m_name
argument_list|)
expr_stmt|;
name|ln
operator|->
name|tn_val
operator|->
name|v_ansiu
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|mp
operator|->
name|m_transiu
operator|&&
name|rn
operator|->
name|tn_op
operator|==
name|CON
operator|&&
name|rn
operator|->
name|tn_val
operator|->
name|v_ansiu
condition|)
block|{
comment|/* ANSI C treats constant as unsigned, op %s */
name|warning
argument_list|(
literal|218
argument_list|,
name|mp
operator|->
name|m_name
argument_list|)
expr_stmt|;
name|rn
operator|->
name|tn_val
operator|->
name|v_ansiu
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Make sure both operands are of the same type */
if|if
condition|(
name|mp
operator|->
name|m_balance
operator|||
operator|(
name|tflag
operator|&&
operator|(
name|op
operator|==
name|SHL
operator|||
name|op
operator|==
name|SHR
operator|)
operator|)
condition|)
name|balance
argument_list|(
name|op
argument_list|,
operator|&
name|ln
argument_list|,
operator|&
name|rn
argument_list|)
expr_stmt|;
comment|/* 	 * Check types for compatibility with the operation and mutual 	 * compatibility. Return if there are serios problems. 	 */
if|if
condition|(
operator|!
name|typeok
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
name|ln
argument_list|,
name|rn
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* And now create the node. */
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|POINT
case|:
case|case
name|ARROW
case|:
name|ntn
operator|=
name|bldstr
argument_list|(
name|op
argument_list|,
name|ln
argument_list|,
name|rn
argument_list|)
expr_stmt|;
break|break;
case|case
name|INCAFT
case|:
case|case
name|DECAFT
case|:
case|case
name|INCBEF
case|:
case|case
name|DECBEF
case|:
name|ntn
operator|=
name|bldincdec
argument_list|(
name|op
argument_list|,
name|ln
argument_list|)
expr_stmt|;
break|break;
case|case
name|AMPER
case|:
name|ntn
operator|=
name|bldamper
argument_list|(
name|ln
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|STAR
case|:
name|ntn
operator|=
name|mktnode
argument_list|(
name|STAR
argument_list|,
name|ln
operator|->
name|tn_type
operator|->
name|t_subt
argument_list|,
name|ln
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|PLUS
case|:
case|case
name|MINUS
case|:
name|ntn
operator|=
name|bldplmi
argument_list|(
name|op
argument_list|,
name|ln
argument_list|,
name|rn
argument_list|)
expr_stmt|;
break|break;
case|case
name|SHL
case|:
case|case
name|SHR
case|:
name|ntn
operator|=
name|bldshft
argument_list|(
name|op
argument_list|,
name|ln
argument_list|,
name|rn
argument_list|)
expr_stmt|;
break|break;
case|case
name|COLON
case|:
name|ntn
operator|=
name|bldcol
argument_list|(
name|ln
argument_list|,
name|rn
argument_list|)
expr_stmt|;
break|break;
case|case
name|ASSIGN
case|:
case|case
name|MULASS
case|:
case|case
name|DIVASS
case|:
case|case
name|MODASS
case|:
case|case
name|ADDASS
case|:
case|case
name|SUBASS
case|:
case|case
name|SHLASS
case|:
case|case
name|SHRASS
case|:
case|case
name|ANDASS
case|:
case|case
name|XORASS
case|:
case|case
name|ORASS
case|:
case|case
name|RETURN
case|:
name|ntn
operator|=
name|bldasgn
argument_list|(
name|op
argument_list|,
name|ln
argument_list|,
name|rn
argument_list|)
expr_stmt|;
break|break;
case|case
name|COMMA
case|:
case|case
name|QUEST
case|:
name|ntn
operator|=
name|mktnode
argument_list|(
name|op
argument_list|,
name|rn
operator|->
name|tn_type
argument_list|,
name|ln
argument_list|,
name|rn
argument_list|)
expr_stmt|;
break|break;
default|default:
name|rtp
operator|=
name|mp
operator|->
name|m_logop
condition|?
name|gettyp
argument_list|(
name|INT
argument_list|)
else|:
name|ln
operator|->
name|tn_type
expr_stmt|;
if|if
condition|(
operator|!
name|mp
operator|->
name|m_binary
operator|&&
name|rn
operator|!=
name|NULL
condition|)
name|lerror
argument_list|(
literal|"build() 1"
argument_list|)
expr_stmt|;
name|ntn
operator|=
name|mktnode
argument_list|(
name|op
argument_list|,
name|rtp
argument_list|,
name|ln
argument_list|,
name|rn
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Return if an error occured. */
if|if
condition|(
name|ntn
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* Print a warning if precedence confusion is possible */
if|if
condition|(
name|mp
operator|->
name|m_tpconf
condition|)
name|precconf
argument_list|(
name|ntn
argument_list|)
expr_stmt|;
comment|/* 	 * Print a warning if one of the operands is in a context where 	 * it is compared with null and if this operand is a constant. 	 */
if|if
condition|(
name|mp
operator|->
name|m_tctx
condition|)
block|{
if|if
condition|(
name|ln
operator|->
name|tn_op
operator|==
name|CON
operator|||
operator|(
operator|(
name|mp
operator|->
name|m_binary
operator|&&
name|op
operator|!=
name|QUEST
operator|)
operator|&&
name|rn
operator|->
name|tn_op
operator|==
name|CON
operator|)
condition|)
block|{
if|if
condition|(
name|hflag
operator|&&
operator|!
name|ccflg
condition|)
comment|/* constant in conditional context */
name|warning
argument_list|(
literal|161
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Fold if the operator requires it */
if|if
condition|(
name|mp
operator|->
name|m_fold
condition|)
block|{
if|if
condition|(
name|ln
operator|->
name|tn_op
operator|==
name|CON
operator|&&
operator|(
operator|!
name|mp
operator|->
name|m_binary
operator|||
name|rn
operator|->
name|tn_op
operator|==
name|CON
operator|)
condition|)
block|{
if|if
condition|(
name|mp
operator|->
name|m_tctx
condition|)
block|{
name|ntn
operator|=
name|foldtst
argument_list|(
name|ntn
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isftyp
argument_list|(
name|ntn
operator|->
name|tn_type
operator|->
name|t_tspec
argument_list|)
condition|)
block|{
name|ntn
operator|=
name|foldflt
argument_list|(
name|ntn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ntn
operator|=
name|fold
argument_list|(
name|ntn
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|op
operator|==
name|QUEST
operator|&&
name|ln
operator|->
name|tn_op
operator|==
name|CON
condition|)
block|{
name|ntn
operator|=
name|ln
operator|->
name|tn_val
operator|->
name|v_quad
condition|?
name|rn
operator|->
name|tn_left
else|:
name|rn
operator|->
name|tn_right
expr_stmt|;
block|}
block|}
return|return
operator|(
name|ntn
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Perform class conversions.  *  * Arrays of type T are converted into pointers to type T.  * Functions are converted to pointers to functions.  * Lvalues are converted to rvalues.  */
end_comment

begin_function
name|tnode_t
modifier|*
name|cconv
parameter_list|(
name|tn
parameter_list|)
name|tnode_t
modifier|*
name|tn
decl_stmt|;
block|{
name|type_t
modifier|*
name|tp
decl_stmt|;
comment|/* 	 * Array-lvalue (array of type T) is converted into rvalue 	 * (pointer to type T) 	 */
if|if
condition|(
name|tn
operator|->
name|tn_type
operator|->
name|t_tspec
operator|==
name|ARRAY
condition|)
block|{
if|if
condition|(
operator|!
name|tn
operator|->
name|tn_lvalue
condition|)
block|{
comment|/* %soperand of '%s' must be lvalue */
comment|/* XXX print correct operator */
operator|(
name|void
operator|)
name|gnuism
argument_list|(
literal|114
argument_list|,
literal|""
argument_list|,
name|modtab
index|[
name|AMPER
index|]
operator|.
name|m_name
argument_list|)
expr_stmt|;
block|}
name|tn
operator|=
name|mktnode
argument_list|(
name|AMPER
argument_list|,
name|tincref
argument_list|(
name|tn
operator|->
name|tn_type
operator|->
name|t_subt
argument_list|,
name|PTR
argument_list|)
argument_list|,
name|tn
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Expression of type function (function with return value of type T) 	 * in rvalue-expression (pointer to function with return value 	 * of type T) 	 */
if|if
condition|(
name|tn
operator|->
name|tn_type
operator|->
name|t_tspec
operator|==
name|FUNC
condition|)
name|tn
operator|=
name|bldamper
argument_list|(
name|tn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* lvalue to rvalue */
if|if
condition|(
name|tn
operator|->
name|tn_lvalue
condition|)
block|{
name|tp
operator|=
name|tduptyp
argument_list|(
name|tn
operator|->
name|tn_type
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_const
operator|=
name|tp
operator|->
name|t_volatile
operator|=
literal|0
expr_stmt|;
name|tn
operator|=
name|mktnode
argument_list|(
name|LOAD
argument_list|,
name|tp
argument_list|,
name|tn
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|tn
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Perform most type checks. First the types are checked using  * informations from modtab[]. After that it is done by hand for  * more complicated operators and type combinations.  *  * If the types are ok, typeok() returns 1, otherwise 0.  */
end_comment

begin_function
name|int
name|typeok
parameter_list|(
name|op
parameter_list|,
name|arg
parameter_list|,
name|ln
parameter_list|,
name|rn
parameter_list|)
name|op_t
name|op
decl_stmt|;
name|int
name|arg
decl_stmt|;
name|tnode_t
modifier|*
name|ln
decl_stmt|,
decl|*
name|rn
decl_stmt|;
end_function

begin_block
block|{
name|mod_t
modifier|*
name|mp
decl_stmt|;
name|tspec_t
name|lt
decl_stmt|,
name|rt
decl_stmt|,
name|lst
decl_stmt|,
name|rst
decl_stmt|,
name|olt
decl_stmt|,
name|ort
decl_stmt|;
name|type_t
modifier|*
name|ltp
decl_stmt|,
modifier|*
name|rtp
decl_stmt|,
modifier|*
name|lstp
decl_stmt|,
modifier|*
name|rstp
decl_stmt|;
name|tnode_t
modifier|*
name|tn
decl_stmt|;
name|mp
operator|=
operator|&
name|modtab
index|[
name|op
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|lt
operator|=
operator|(
name|ltp
operator|=
name|ln
operator|->
name|tn_type
operator|)
operator|->
name|t_tspec
operator|)
operator|==
name|PTR
condition|)
name|lst
operator|=
operator|(
name|lstp
operator|=
name|ltp
operator|->
name|t_subt
operator|)
operator|->
name|t_tspec
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|m_binary
condition|)
block|{
if|if
condition|(
operator|(
name|rt
operator|=
operator|(
name|rtp
operator|=
name|rn
operator|->
name|tn_type
operator|)
operator|->
name|t_tspec
operator|)
operator|==
name|PTR
condition|)
name|rst
operator|=
operator|(
name|rstp
operator|=
name|rtp
operator|->
name|t_subt
operator|)
operator|->
name|t_tspec
expr_stmt|;
block|}
if|if
condition|(
name|mp
operator|->
name|m_rqint
condition|)
block|{
comment|/* integertypes required */
if|if
condition|(
operator|!
name|isityp
argument_list|(
name|lt
argument_list|)
operator|||
operator|(
name|mp
operator|->
name|m_binary
operator|&&
operator|!
name|isityp
argument_list|(
name|rt
argument_list|)
operator|)
condition|)
block|{
name|incompat
argument_list|(
name|op
argument_list|,
name|lt
argument_list|,
name|rt
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|mp
operator|->
name|m_rqsclt
condition|)
block|{
comment|/* scalar types required */
if|if
condition|(
operator|!
name|issclt
argument_list|(
name|lt
argument_list|)
operator|||
operator|(
name|mp
operator|->
name|m_binary
operator|&&
operator|!
name|issclt
argument_list|(
name|rt
argument_list|)
operator|)
condition|)
block|{
name|incompat
argument_list|(
name|op
argument_list|,
name|lt
argument_list|,
name|rt
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|mp
operator|->
name|m_rqatyp
condition|)
block|{
comment|/* arithmetic types required */
if|if
condition|(
operator|!
name|isatyp
argument_list|(
name|lt
argument_list|)
operator|||
operator|(
name|mp
operator|->
name|m_binary
operator|&&
operator|!
name|isatyp
argument_list|(
name|rt
argument_list|)
operator|)
condition|)
block|{
name|incompat
argument_list|(
name|op
argument_list|,
name|lt
argument_list|,
name|rt
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
if|if
condition|(
name|op
operator|==
name|SHL
operator|||
name|op
operator|==
name|SHR
operator|||
name|op
operator|==
name|SHLASS
operator|||
name|op
operator|==
name|SHRASS
condition|)
block|{
comment|/* 		 * For these operations we need the types before promotion 		 * and balancing. 		 */
for|for
control|(
name|tn
operator|=
name|ln
init|;
name|tn
operator|->
name|tn_op
operator|==
name|CVT
operator|&&
operator|!
name|tn
operator|->
name|tn_cast
condition|;
name|tn
operator|=
name|tn
operator|->
name|tn_left
control|)
empty_stmt|;
name|olt
operator|=
name|tn
operator|->
name|tn_type
operator|->
name|t_tspec
expr_stmt|;
for|for
control|(
name|tn
operator|=
name|rn
init|;
name|tn
operator|->
name|tn_op
operator|==
name|CVT
operator|&&
operator|!
name|tn
operator|->
name|tn_cast
condition|;
name|tn
operator|=
name|tn
operator|->
name|tn_left
control|)
empty_stmt|;
name|ort
operator|=
name|tn
operator|->
name|tn_type
operator|->
name|t_tspec
expr_stmt|;
block|}
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|POINT
case|:
comment|/* 		 * Most errors required by ANSI C are reported in strmemb(). 		 * Here we only must check for totaly wrong things. 		 */
if|if
condition|(
name|lt
operator|==
name|FUNC
operator|||
name|lt
operator|==
name|VOID
operator|||
name|ltp
operator|->
name|t_isfield
operator|||
operator|(
operator|(
name|lt
operator|!=
name|STRUCT
operator|&&
name|lt
operator|!=
name|UNION
operator|)
operator|&&
operator|!
name|ln
operator|->
name|tn_lvalue
operator|)
condition|)
block|{
comment|/* Without tflag we got already an error */
if|if
condition|(
name|tflag
condition|)
comment|/* unacceptable operand of %s */
name|error
argument_list|(
literal|111
argument_list|,
name|mp
operator|->
name|m_name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Now we have an object we can create a pointer to */
break|break;
case|case
name|ARROW
case|:
if|if
condition|(
name|lt
operator|!=
name|PTR
operator|&&
operator|!
operator|(
name|tflag
operator|&&
name|isityp
argument_list|(
name|lt
argument_list|)
operator|)
condition|)
block|{
comment|/* Without tflag we got already an error */
if|if
condition|(
name|tflag
condition|)
comment|/* unacceptabel operand of %s */
name|error
argument_list|(
literal|111
argument_list|,
name|mp
operator|->
name|m_name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
break|break;
case|case
name|INCAFT
case|:
case|case
name|DECAFT
case|:
case|case
name|INCBEF
case|:
case|case
name|DECBEF
case|:
comment|/* operands have scalar types (checked above) */
if|if
condition|(
operator|!
name|ln
operator|->
name|tn_lvalue
condition|)
block|{
if|if
condition|(
name|ln
operator|->
name|tn_op
operator|==
name|CVT
operator|&&
name|ln
operator|->
name|tn_cast
operator|&&
name|ln
operator|->
name|tn_left
operator|->
name|tn_op
operator|==
name|LOAD
condition|)
block|{
comment|/* a cast does not yield an lvalue */
name|error
argument_list|(
literal|163
argument_list|)
expr_stmt|;
block|}
comment|/* %soperand of %s must be lvalue */
name|error
argument_list|(
literal|114
argument_list|,
literal|""
argument_list|,
name|mp
operator|->
name|m_name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|ltp
operator|->
name|t_const
condition|)
block|{
comment|/* %soperand of %s must be modifiable lvalue */
if|if
condition|(
operator|!
name|tflag
condition|)
name|warning
argument_list|(
literal|115
argument_list|,
literal|""
argument_list|,
name|mp
operator|->
name|m_name
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|AMPER
case|:
if|if
condition|(
name|lt
operator|==
name|ARRAY
operator|||
name|lt
operator|==
name|FUNC
condition|)
block|{
comment|/* ok, a warning comes later (in bldamper()) */
block|}
elseif|else
if|if
condition|(
operator|!
name|ln
operator|->
name|tn_lvalue
condition|)
block|{
if|if
condition|(
name|ln
operator|->
name|tn_op
operator|==
name|CVT
operator|&&
name|ln
operator|->
name|tn_cast
operator|&&
name|ln
operator|->
name|tn_left
operator|->
name|tn_op
operator|==
name|LOAD
condition|)
block|{
comment|/* a cast does not yield an lvalue */
name|error
argument_list|(
literal|163
argument_list|)
expr_stmt|;
block|}
comment|/* %soperand of %s must be lvalue */
name|error
argument_list|(
literal|114
argument_list|,
literal|""
argument_list|,
name|mp
operator|->
name|m_name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|issclt
argument_list|(
name|lt
argument_list|)
condition|)
block|{
if|if
condition|(
name|ltp
operator|->
name|t_isfield
condition|)
block|{
comment|/* cannot take address of bit-field */
name|error
argument_list|(
literal|112
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|lt
operator|!=
name|STRUCT
operator|&&
name|lt
operator|!=
name|UNION
condition|)
block|{
comment|/* unacceptable operand of %s */
name|error
argument_list|(
literal|111
argument_list|,
name|mp
operator|->
name|m_name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|ln
operator|->
name|tn_op
operator|==
name|NAME
operator|&&
name|ln
operator|->
name|tn_sym
operator|->
name|s_reg
condition|)
block|{
comment|/* cannot take address of register %s */
name|error
argument_list|(
literal|113
argument_list|,
name|ln
operator|->
name|tn_sym
operator|->
name|s_name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
break|break;
case|case
name|STAR
case|:
comment|/* until now there were no type checks for this operator */
if|if
condition|(
name|lt
operator|!=
name|PTR
condition|)
block|{
comment|/* cannot dereference non-pointer type */
name|error
argument_list|(
literal|96
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
break|break;
case|case
name|PLUS
case|:
comment|/* operands have scalar types (checked above) */
if|if
condition|(
operator|(
name|lt
operator|==
name|PTR
operator|&&
operator|!
name|isityp
argument_list|(
name|rt
argument_list|)
operator|)
operator|||
operator|(
name|rt
operator|==
name|PTR
operator|&&
operator|!
name|isityp
argument_list|(
name|lt
argument_list|)
operator|)
condition|)
block|{
name|incompat
argument_list|(
name|op
argument_list|,
name|lt
argument_list|,
name|rt
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
break|break;
case|case
name|MINUS
case|:
comment|/* operands have scalar types (checked above) */
if|if
condition|(
name|lt
operator|==
name|PTR
operator|&&
operator|(
operator|!
name|isityp
argument_list|(
name|rt
argument_list|)
operator|&&
name|rt
operator|!=
name|PTR
operator|)
condition|)
block|{
name|incompat
argument_list|(
name|op
argument_list|,
name|lt
argument_list|,
name|rt
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|rt
operator|==
name|PTR
operator|&&
name|lt
operator|!=
name|PTR
condition|)
block|{
name|incompat
argument_list|(
name|op
argument_list|,
name|lt
argument_list|,
name|rt
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|lt
operator|==
name|PTR
operator|&&
name|rt
operator|==
name|PTR
condition|)
block|{
if|if
condition|(
operator|!
name|eqtype
argument_list|(
name|lstp
argument_list|,
name|rstp
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
comment|/* illegal pointer subtraction */
name|error
argument_list|(
literal|116
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|SHR
case|:
comment|/* operands have integer types (checked above) */
if|if
condition|(
name|pflag
operator|&&
operator|!
name|isutyp
argument_list|(
name|lt
argument_list|)
condition|)
block|{
comment|/* 			 * The left operand is signed. This means that 			 * the operation is (possibly) nonportable. 			 */
comment|/* bitwise operation on signed value nonportable */
if|if
condition|(
name|ln
operator|->
name|tn_op
operator|!=
name|CON
condition|)
block|{
comment|/* possibly nonportable */
name|warning
argument_list|(
literal|117
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ln
operator|->
name|tn_val
operator|->
name|v_quad
operator|<
literal|0
condition|)
block|{
name|warning
argument_list|(
literal|120
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|tflag
operator|&&
operator|!
name|sflag
operator|&&
operator|!
name|isutyp
argument_list|(
name|olt
argument_list|)
operator|&&
name|isutyp
argument_list|(
name|ort
argument_list|)
condition|)
block|{
comment|/* 			 * The left operand would become unsigned in 			 * traditional C. 			 */
if|if
condition|(
name|hflag
operator|&&
operator|(
name|ln
operator|->
name|tn_op
operator|!=
name|CON
operator|||
name|ln
operator|->
name|tn_val
operator|->
name|v_quad
operator|<
literal|0
operator|)
condition|)
block|{
comment|/* semantics of %s change in ANSI C; use ... */
name|warning
argument_list|(
literal|118
argument_list|,
name|mp
operator|->
name|m_name
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|tflag
operator|&&
operator|!
name|sflag
operator|&&
operator|!
name|isutyp
argument_list|(
name|olt
argument_list|)
operator|&&
operator|!
name|isutyp
argument_list|(
name|ort
argument_list|)
operator|&&
name|psize
argument_list|(
name|lt
argument_list|)
operator|<
name|psize
argument_list|(
name|rt
argument_list|)
condition|)
block|{
comment|/* 			 * In traditional C the left operand would be extended, 			 * possibly with 1, and then shifted. 			 */
if|if
condition|(
name|hflag
operator|&&
operator|(
name|ln
operator|->
name|tn_op
operator|!=
name|CON
operator|||
name|ln
operator|->
name|tn_val
operator|->
name|v_quad
operator|<
literal|0
operator|)
condition|)
block|{
comment|/* semantics of %s change in ANSI C; use ... */
name|warning
argument_list|(
literal|118
argument_list|,
name|mp
operator|->
name|m_name
argument_list|)
expr_stmt|;
block|}
block|}
goto|goto
name|shift
goto|;
case|case
name|SHL
case|:
comment|/* 		 * ANSI C does not perform balancing for shift operations, 		 * but traditional C does. If the width of the right operand 		 * is greather than the width of the left operand, than in 		 * traditional C the left operand would be extendet to the 		 * width of the right operand. For SHL this may result in 		 * different results. 		 */
if|if
condition|(
name|psize
argument_list|(
name|lt
argument_list|)
operator|<
name|psize
argument_list|(
name|rt
argument_list|)
condition|)
block|{
comment|/* 			 * XXX If both operands are constant make sure 			 * that there is really a differencs between 			 * ANSI C and traditional C. 			 */
if|if
condition|(
name|hflag
condition|)
comment|/* semantics of %s change in ANSI C; use ... */
name|warning
argument_list|(
literal|118
argument_list|,
name|mp
operator|->
name|m_name
argument_list|)
expr_stmt|;
block|}
name|shift
label|:
if|if
condition|(
name|rn
operator|->
name|tn_op
operator|==
name|CON
condition|)
block|{
if|if
condition|(
operator|!
name|isutyp
argument_list|(
name|rt
argument_list|)
operator|&&
name|rn
operator|->
name|tn_val
operator|->
name|v_quad
operator|<
literal|0
condition|)
block|{
comment|/* negative shift */
name|warning
argument_list|(
literal|121
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|u_quad_t
operator|)
name|rn
operator|->
name|tn_val
operator|->
name|v_quad
operator|==
name|size
argument_list|(
name|lt
argument_list|)
condition|)
block|{
comment|/* shift equal to size fo object */
name|warning
argument_list|(
literal|267
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|u_quad_t
operator|)
name|rn
operator|->
name|tn_val
operator|->
name|v_quad
operator|>
name|size
argument_list|(
name|lt
argument_list|)
condition|)
block|{
comment|/* shift greater than size of object */
name|warning
argument_list|(
literal|122
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|EQ
case|:
case|case
name|NE
case|:
comment|/* 		 * Accept some things which are allowed with EQ and NE, 		 * but not with ordered comparisions. 		 */
if|if
condition|(
name|lt
operator|==
name|PTR
operator|&&
operator|(
operator|(
name|rt
operator|==
name|PTR
operator|&&
name|rst
operator|==
name|VOID
operator|)
operator|||
name|isityp
argument_list|(
name|rt
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|rn
operator|->
name|tn_op
operator|==
name|CON
operator|&&
name|rn
operator|->
name|tn_val
operator|->
name|v_quad
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|rt
operator|==
name|PTR
operator|&&
operator|(
operator|(
name|lt
operator|==
name|PTR
operator|&&
name|lst
operator|==
name|VOID
operator|)
operator|||
name|isityp
argument_list|(
name|lt
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|ln
operator|->
name|tn_op
operator|==
name|CON
operator|&&
name|ln
operator|->
name|tn_val
operator|->
name|v_quad
operator|==
literal|0
condition|)
break|break;
block|}
comment|/* FALLTHROUGH */
case|case
name|LT
case|:
case|case
name|GT
case|:
case|case
name|LE
case|:
case|case
name|GE
case|:
if|if
condition|(
operator|(
name|lt
operator|==
name|PTR
operator|||
name|rt
operator|==
name|PTR
operator|)
operator|&&
name|lt
operator|!=
name|rt
condition|)
block|{
if|if
condition|(
name|isityp
argument_list|(
name|lt
argument_list|)
operator|||
name|isityp
argument_list|(
name|rt
argument_list|)
condition|)
block|{
comment|/* illegal comb. of pointer and int., op %s */
name|warning
argument_list|(
literal|123
argument_list|,
name|mp
operator|->
name|m_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|incompat
argument_list|(
name|op
argument_list|,
name|lt
argument_list|,
name|rt
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|lt
operator|==
name|PTR
operator|&&
name|rt
operator|==
name|PTR
condition|)
block|{
name|ptrcmpok
argument_list|(
name|op
argument_list|,
name|ln
argument_list|,
name|rn
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|QUEST
case|:
if|if
condition|(
operator|!
name|issclt
argument_list|(
name|lt
argument_list|)
condition|)
block|{
comment|/* first operand must have scalar type, op ? : */
name|error
argument_list|(
literal|170
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|rn
operator|->
name|tn_op
operator|!=
name|COLON
condition|)
name|lerror
argument_list|(
literal|"typeok() 2"
argument_list|)
expr_stmt|;
break|break;
case|case
name|COLON
case|:
if|if
condition|(
name|isatyp
argument_list|(
name|lt
argument_list|)
operator|&&
name|isatyp
argument_list|(
name|rt
argument_list|)
condition|)
break|break;
if|if
condition|(
name|lt
operator|==
name|STRUCT
operator|&&
name|rt
operator|==
name|STRUCT
operator|&&
name|ltp
operator|->
name|t_str
operator|==
name|rtp
operator|->
name|t_str
condition|)
break|break;
if|if
condition|(
name|lt
operator|==
name|UNION
operator|&&
name|rt
operator|==
name|UNION
operator|&&
name|ltp
operator|->
name|t_str
operator|==
name|rtp
operator|->
name|t_str
condition|)
break|break;
comment|/* combination of any pointer and 0, 0L or (void *)0 is ok */
if|if
condition|(
name|lt
operator|==
name|PTR
operator|&&
operator|(
operator|(
name|rt
operator|==
name|PTR
operator|&&
name|rst
operator|==
name|VOID
operator|)
operator|||
name|isityp
argument_list|(
name|rt
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|rn
operator|->
name|tn_op
operator|==
name|CON
operator|&&
name|rn
operator|->
name|tn_val
operator|->
name|v_quad
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|rt
operator|==
name|PTR
operator|&&
operator|(
operator|(
name|lt
operator|==
name|PTR
operator|&&
name|lst
operator|==
name|VOID
operator|)
operator|||
name|isityp
argument_list|(
name|lt
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|ln
operator|->
name|tn_op
operator|==
name|CON
operator|&&
name|ln
operator|->
name|tn_val
operator|->
name|v_quad
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
operator|(
name|lt
operator|==
name|PTR
operator|&&
name|isityp
argument_list|(
name|rt
argument_list|)
operator|)
operator|||
operator|(
name|isityp
argument_list|(
name|lt
argument_list|)
operator|&&
name|rt
operator|==
name|PTR
operator|)
condition|)
block|{
comment|/* illegal comb. of ptr. and int., op %s */
name|warning
argument_list|(
literal|123
argument_list|,
name|mp
operator|->
name|m_name
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|lt
operator|==
name|VOID
operator|||
name|rt
operator|==
name|VOID
condition|)
block|{
if|if
condition|(
name|lt
operator|!=
name|VOID
operator|||
name|rt
operator|!=
name|VOID
condition|)
comment|/* incompatible types in conditional */
name|warning
argument_list|(
literal|126
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|lt
operator|==
name|PTR
operator|&&
name|rt
operator|==
name|PTR
operator|&&
operator|(
operator|(
name|lst
operator|==
name|VOID
operator|&&
name|rst
operator|==
name|FUNC
operator|)
operator|||
operator|(
name|lst
operator|==
name|FUNC
operator|&&
name|rst
operator|==
name|VOID
operator|)
operator|)
condition|)
block|{
comment|/* (void *)0 handled above */
if|if
condition|(
name|sflag
condition|)
comment|/* ANSI C forbids conv. of %s to %s, op %s */
name|warning
argument_list|(
literal|305
argument_list|,
literal|"function pointer"
argument_list|,
literal|"'void *'"
argument_list|,
name|mp
operator|->
name|m_name
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|rt
operator|==
name|PTR
operator|&&
name|lt
operator|==
name|PTR
condition|)
block|{
if|if
condition|(
operator|!
name|eqtype
argument_list|(
name|lstp
argument_list|,
name|rstp
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
condition|)
name|illptrc
argument_list|(
name|mp
argument_list|,
name|ltp
argument_list|,
name|rtp
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* incompatible types in conditional */
name|error
argument_list|(
literal|126
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|ASSIGN
case|:
case|case
name|INIT
case|:
case|case
name|FARG
case|:
case|case
name|RETURN
case|:
if|if
condition|(
operator|!
name|asgntypok
argument_list|(
name|op
argument_list|,
name|arg
argument_list|,
name|ln
argument_list|,
name|rn
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
goto|goto
name|assign
goto|;
case|case
name|MULASS
case|:
case|case
name|DIVASS
case|:
case|case
name|MODASS
case|:
goto|goto
name|assign
goto|;
case|case
name|ADDASS
case|:
case|case
name|SUBASS
case|:
comment|/* operands have scalar types (checked above) */
if|if
condition|(
operator|(
name|lt
operator|==
name|PTR
operator|&&
operator|!
name|isityp
argument_list|(
name|rt
argument_list|)
operator|)
operator|||
name|rt
operator|==
name|PTR
condition|)
block|{
name|incompat
argument_list|(
name|op
argument_list|,
name|lt
argument_list|,
name|rt
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
goto|goto
name|assign
goto|;
case|case
name|SHLASS
case|:
goto|goto
name|assign
goto|;
case|case
name|SHRASS
case|:
if|if
condition|(
name|pflag
operator|&&
operator|!
name|isutyp
argument_list|(
name|lt
argument_list|)
operator|&&
operator|!
operator|(
name|tflag
operator|&&
name|isutyp
argument_list|(
name|rt
argument_list|)
operator|)
condition|)
block|{
comment|/* bitwise operation on s.v. possibly nonportabel */
name|warning
argument_list|(
literal|117
argument_list|)
expr_stmt|;
block|}
goto|goto
name|assign
goto|;
case|case
name|ANDASS
case|:
case|case
name|XORASS
case|:
case|case
name|ORASS
case|:
goto|goto
name|assign
goto|;
name|assign
label|:
if|if
condition|(
operator|!
name|ln
operator|->
name|tn_lvalue
condition|)
block|{
if|if
condition|(
name|ln
operator|->
name|tn_op
operator|==
name|CVT
operator|&&
name|ln
operator|->
name|tn_cast
operator|&&
name|ln
operator|->
name|tn_left
operator|->
name|tn_op
operator|==
name|LOAD
condition|)
block|{
comment|/* a cast does not yield an lvalue */
name|error
argument_list|(
literal|163
argument_list|)
expr_stmt|;
block|}
comment|/* %soperand of %s must be lvalue */
name|error
argument_list|(
literal|114
argument_list|,
literal|"left "
argument_list|,
name|mp
operator|->
name|m_name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|ltp
operator|->
name|t_const
operator|||
operator|(
operator|(
name|lt
operator|==
name|STRUCT
operator|||
name|lt
operator|==
name|UNION
operator|)
operator|&&
name|conmemb
argument_list|(
name|ltp
argument_list|)
operator|)
condition|)
block|{
comment|/* %soperand of %s must be modifiable lvalue */
if|if
condition|(
operator|!
name|tflag
condition|)
name|warning
argument_list|(
literal|115
argument_list|,
literal|"left "
argument_list|,
name|mp
operator|->
name|m_name
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|COMMA
case|:
if|if
condition|(
operator|!
name|modtab
index|[
name|ln
operator|->
name|tn_op
index|]
operator|.
name|m_sideeff
condition|)
name|nulleff
argument_list|(
name|ln
argument_list|)
expr_stmt|;
break|break;
comment|/* LINTED (enumeration values not handled in switch) */
default|default:
block|}
if|if
condition|(
name|mp
operator|->
name|m_badeop
operator|&&
operator|(
name|ltp
operator|->
name|t_isenum
operator|||
operator|(
name|mp
operator|->
name|m_binary
operator|&&
name|rtp
operator|->
name|t_isenum
operator|)
operator|)
condition|)
block|{
name|chkbeop
argument_list|(
name|op
argument_list|,
name|ln
argument_list|,
name|rn
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mp
operator|->
name|m_enumop
operator|&&
operator|(
name|ltp
operator|->
name|t_isenum
operator|&&
name|rtp
operator|->
name|t_isenum
operator|)
condition|)
block|{
name|chkeop2
argument_list|(
name|op
argument_list|,
name|arg
argument_list|,
name|ln
argument_list|,
name|rn
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mp
operator|->
name|m_enumop
operator|&&
operator|(
name|ltp
operator|->
name|t_isenum
operator|||
name|rtp
operator|->
name|t_isenum
operator|)
condition|)
block|{
name|chkeop1
argument_list|(
name|op
argument_list|,
name|arg
argument_list|,
name|ln
argument_list|,
name|rn
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_function
specifier|static
name|void
name|ptrcmpok
parameter_list|(
name|op
parameter_list|,
name|ln
parameter_list|,
name|rn
parameter_list|)
name|op_t
name|op
decl_stmt|;
name|tnode_t
modifier|*
name|ln
decl_stmt|,
decl|*
name|rn
decl_stmt|;
end_function

begin_block
block|{
name|type_t
modifier|*
name|ltp
decl_stmt|,
modifier|*
name|rtp
decl_stmt|;
name|tspec_t
name|lt
decl_stmt|,
name|rt
decl_stmt|;
specifier|const
name|char
modifier|*
name|lts
decl_stmt|,
modifier|*
name|rts
decl_stmt|;
name|lt
operator|=
operator|(
name|ltp
operator|=
name|ln
operator|->
name|tn_type
operator|)
operator|->
name|t_subt
operator|->
name|t_tspec
expr_stmt|;
name|rt
operator|=
operator|(
name|rtp
operator|=
name|rn
operator|->
name|tn_type
operator|)
operator|->
name|t_subt
operator|->
name|t_tspec
expr_stmt|;
if|if
condition|(
name|lt
operator|==
name|VOID
operator|||
name|rt
operator|==
name|VOID
condition|)
block|{
if|if
condition|(
name|sflag
operator|&&
operator|(
name|lt
operator|==
name|FUNC
operator|||
name|rt
operator|==
name|FUNC
operator|)
condition|)
block|{
comment|/* (void *)0 already handled in typeok() */
operator|*
operator|(
name|lt
operator|==
name|FUNC
condition|?
operator|&
name|lts
else|:
operator|&
name|rts
operator|)
operator|=
literal|"function pointer"
expr_stmt|;
operator|*
operator|(
name|lt
operator|==
name|VOID
condition|?
operator|&
name|lts
else|:
operator|&
name|rts
operator|)
operator|=
literal|"'void *'"
expr_stmt|;
comment|/* ANSI C forbids comparision of %s with %s */
name|warning
argument_list|(
literal|274
argument_list|,
name|lts
argument_list|,
name|rts
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
operator|!
name|eqtype
argument_list|(
name|ltp
operator|->
name|t_subt
argument_list|,
name|rtp
operator|->
name|t_subt
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|illptrc
argument_list|(
operator|&
name|modtab
index|[
name|op
index|]
argument_list|,
name|ltp
argument_list|,
name|rtp
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|lt
operator|==
name|FUNC
operator|&&
name|rt
operator|==
name|FUNC
condition|)
block|{
if|if
condition|(
name|sflag
operator|&&
name|op
operator|!=
name|EQ
operator|&&
name|op
operator|!=
name|NE
condition|)
comment|/* ANSI C forbids ordered comp. of func ptr */
name|warning
argument_list|(
literal|125
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Checks type compatibility for ASSIGN, INIT, FARG and RETURN  * and prints warnings/errors if necessary.  * If the types are (almost) compatible, 1 is returned, otherwise 0.  */
end_comment

begin_function
specifier|static
name|int
name|asgntypok
parameter_list|(
name|op
parameter_list|,
name|arg
parameter_list|,
name|ln
parameter_list|,
name|rn
parameter_list|)
name|op_t
name|op
decl_stmt|;
name|int
name|arg
decl_stmt|;
name|tnode_t
modifier|*
name|ln
decl_stmt|,
decl|*
name|rn
decl_stmt|;
end_function

begin_block
block|{
name|tspec_t
name|lt
decl_stmt|,
name|rt
decl_stmt|,
name|lst
decl_stmt|,
name|rst
decl_stmt|;
name|type_t
modifier|*
name|ltp
decl_stmt|,
modifier|*
name|rtp
decl_stmt|,
modifier|*
name|lstp
decl_stmt|,
modifier|*
name|rstp
decl_stmt|;
name|mod_t
modifier|*
name|mp
decl_stmt|;
specifier|const
name|char
modifier|*
name|lts
decl_stmt|,
modifier|*
name|rts
decl_stmt|;
if|if
condition|(
operator|(
name|lt
operator|=
operator|(
name|ltp
operator|=
name|ln
operator|->
name|tn_type
operator|)
operator|->
name|t_tspec
operator|)
operator|==
name|PTR
condition|)
name|lst
operator|=
operator|(
name|lstp
operator|=
name|ltp
operator|->
name|t_subt
operator|)
operator|->
name|t_tspec
expr_stmt|;
if|if
condition|(
operator|(
name|rt
operator|=
operator|(
name|rtp
operator|=
name|rn
operator|->
name|tn_type
operator|)
operator|->
name|t_tspec
operator|)
operator|==
name|PTR
condition|)
name|rst
operator|=
operator|(
name|rstp
operator|=
name|rtp
operator|->
name|t_subt
operator|)
operator|->
name|t_tspec
expr_stmt|;
name|mp
operator|=
operator|&
name|modtab
index|[
name|op
index|]
expr_stmt|;
if|if
condition|(
name|isatyp
argument_list|(
name|lt
argument_list|)
operator|&&
name|isatyp
argument_list|(
name|rt
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
operator|(
name|lt
operator|==
name|STRUCT
operator|||
name|lt
operator|==
name|UNION
operator|)
operator|&&
operator|(
name|rt
operator|==
name|STRUCT
operator|||
name|rt
operator|==
name|UNION
operator|)
condition|)
comment|/* both are struct or union */
return|return
operator|(
name|ltp
operator|->
name|t_str
operator|==
name|rtp
operator|->
name|t_str
operator|)
return|;
comment|/* 0, 0L and (void *)0 may be assigned to any pointer */
if|if
condition|(
name|lt
operator|==
name|PTR
operator|&&
operator|(
operator|(
name|rt
operator|==
name|PTR
operator|&&
name|rst
operator|==
name|VOID
operator|)
operator|||
name|isityp
argument_list|(
name|rt
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|rn
operator|->
name|tn_op
operator|==
name|CON
operator|&&
name|rn
operator|->
name|tn_val
operator|->
name|v_quad
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|lt
operator|==
name|PTR
operator|&&
name|rt
operator|==
name|PTR
operator|&&
operator|(
name|lst
operator|==
name|VOID
operator|||
name|rst
operator|==
name|VOID
operator|)
condition|)
block|{
comment|/* two pointers, at least one pointer to void */
if|if
condition|(
name|sflag
operator|&&
operator|(
name|lst
operator|==
name|FUNC
operator|||
name|rst
operator|==
name|FUNC
operator|)
condition|)
block|{
comment|/* comb. of ptr to func and ptr to void */
operator|*
operator|(
name|lst
operator|==
name|FUNC
condition|?
operator|&
name|lts
else|:
operator|&
name|rts
operator|)
operator|=
literal|"function pointer"
expr_stmt|;
operator|*
operator|(
name|lst
operator|==
name|VOID
condition|?
operator|&
name|lts
else|:
operator|&
name|rts
operator|)
operator|=
literal|"'void *'"
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|INIT
case|:
case|case
name|RETURN
case|:
comment|/* ANSI C forbids conversion of %s to %s */
name|warning
argument_list|(
literal|303
argument_list|,
name|rts
argument_list|,
name|lts
argument_list|)
expr_stmt|;
break|break;
case|case
name|FARG
case|:
comment|/* ANSI C forbids conv. of %s to %s, arg #%d */
name|warning
argument_list|(
literal|304
argument_list|,
name|rts
argument_list|,
name|lts
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* ANSI C forbids conv. of %s to %s, op %s */
name|warning
argument_list|(
literal|305
argument_list|,
name|rts
argument_list|,
name|lts
argument_list|,
name|mp
operator|->
name|m_name
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|lt
operator|==
name|PTR
operator|&&
name|rt
operator|==
name|PTR
operator|&&
operator|(
name|lst
operator|==
name|VOID
operator|||
name|rst
operator|==
name|VOID
operator|||
name|eqtype
argument_list|(
name|lstp
argument_list|,
name|rstp
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
operator|)
condition|)
block|{
comment|/* compatible pointer types (qualifiers ignored) */
if|if
condition|(
operator|!
name|tflag
operator|&&
operator|(
operator|(
operator|!
name|lstp
operator|->
name|t_const
operator|&&
name|rstp
operator|->
name|t_const
operator|)
operator|||
operator|(
operator|!
name|lstp
operator|->
name|t_volatile
operator|&&
name|rstp
operator|->
name|t_volatile
operator|)
operator|)
condition|)
block|{
comment|/* left side has not all qualifiers of right */
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|INIT
case|:
case|case
name|RETURN
case|:
comment|/* incompatible pointer types */
name|warning
argument_list|(
literal|182
argument_list|)
expr_stmt|;
break|break;
case|case
name|FARG
case|:
comment|/* argument has incompat. ptr. type, arg #%d */
name|warning
argument_list|(
literal|153
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* operands have incompat. ptr. types, op %s */
name|warning
argument_list|(
literal|128
argument_list|,
name|mp
operator|->
name|m_name
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|lt
operator|==
name|PTR
operator|&&
name|isityp
argument_list|(
name|rt
argument_list|)
operator|)
operator|||
operator|(
name|isityp
argument_list|(
name|lt
argument_list|)
operator|&&
name|rt
operator|==
name|PTR
operator|)
condition|)
block|{
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|INIT
case|:
case|case
name|RETURN
case|:
comment|/* illegal combination of pointer and integer */
name|warning
argument_list|(
literal|183
argument_list|)
expr_stmt|;
break|break;
case|case
name|FARG
case|:
comment|/* illegal comb. of ptr. and int., arg #%d */
name|warning
argument_list|(
literal|154
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* illegal comb. of ptr. and int., op %s */
name|warning
argument_list|(
literal|123
argument_list|,
name|mp
operator|->
name|m_name
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|lt
operator|==
name|PTR
operator|&&
name|rt
operator|==
name|PTR
condition|)
block|{
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|INIT
case|:
case|case
name|RETURN
case|:
name|illptrc
argument_list|(
name|NULL
argument_list|,
name|ltp
argument_list|,
name|rtp
argument_list|)
expr_stmt|;
break|break;
case|case
name|FARG
case|:
comment|/* argument has incompatible pointer type, arg #%d */
name|warning
argument_list|(
literal|153
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
default|default:
name|illptrc
argument_list|(
name|mp
argument_list|,
name|ltp
argument_list|,
name|rtp
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|INIT
case|:
comment|/* initialisation type mismatch */
name|error
argument_list|(
literal|185
argument_list|)
expr_stmt|;
break|break;
case|case
name|RETURN
case|:
comment|/* return value type mismatch */
name|error
argument_list|(
literal|211
argument_list|)
expr_stmt|;
break|break;
case|case
name|FARG
case|:
comment|/* argument is incompatible with prototype, arg #%d */
name|warning
argument_list|(
literal|155
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
default|default:
name|incompat
argument_list|(
name|op
argument_list|,
name|lt
argument_list|,
name|rt
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Prints a warning if an operator, which should be senseless for an  * enum type, is applied to an enum type.  */
end_comment

begin_function
specifier|static
name|void
name|chkbeop
parameter_list|(
name|op
parameter_list|,
name|ln
parameter_list|,
name|rn
parameter_list|)
name|op_t
name|op
decl_stmt|;
name|tnode_t
modifier|*
name|ln
decl_stmt|,
decl|*
name|rn
decl_stmt|;
end_function

begin_block
block|{
name|mod_t
modifier|*
name|mp
decl_stmt|;
if|if
condition|(
operator|!
name|eflag
condition|)
return|return;
name|mp
operator|=
operator|&
name|modtab
index|[
name|op
index|]
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ln
operator|->
name|tn_type
operator|->
name|t_isenum
operator|||
operator|(
name|mp
operator|->
name|m_binary
operator|&&
name|rn
operator|->
name|tn_type
operator|->
name|t_isenum
operator|)
operator|)
condition|)
block|{
return|return;
block|}
comment|/* 	 * Enum as offset to a pointer is an exception (otherwise enums 	 * could not be used as array indizes). 	 */
if|if
condition|(
name|op
operator|==
name|PLUS
operator|&&
operator|(
operator|(
name|ln
operator|->
name|tn_type
operator|->
name|t_isenum
operator|&&
name|rn
operator|->
name|tn_type
operator|->
name|t_tspec
operator|==
name|PTR
operator|)
operator|||
operator|(
name|rn
operator|->
name|tn_type
operator|->
name|t_isenum
operator|&&
name|ln
operator|->
name|tn_type
operator|->
name|t_tspec
operator|==
name|PTR
operator|)
operator|)
condition|)
block|{
return|return;
block|}
comment|/* dubious operation on enum, op %s */
name|warning
argument_list|(
literal|241
argument_list|,
name|mp
operator|->
name|m_name
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Prints a warning if an operator is applied to two different enum types.  */
end_comment

begin_function
specifier|static
name|void
name|chkeop2
parameter_list|(
name|op
parameter_list|,
name|arg
parameter_list|,
name|ln
parameter_list|,
name|rn
parameter_list|)
name|op_t
name|op
decl_stmt|;
name|int
name|arg
decl_stmt|;
name|tnode_t
modifier|*
name|ln
decl_stmt|,
decl|*
name|rn
decl_stmt|;
end_function

begin_block
block|{
name|mod_t
modifier|*
name|mp
decl_stmt|;
name|mp
operator|=
operator|&
name|modtab
index|[
name|op
index|]
expr_stmt|;
if|if
condition|(
name|ln
operator|->
name|tn_type
operator|->
name|t_enum
operator|!=
name|rn
operator|->
name|tn_type
operator|->
name|t_enum
condition|)
block|{
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|INIT
case|:
comment|/* enum type mismatch in initialisation */
name|warning
argument_list|(
literal|210
argument_list|)
expr_stmt|;
break|break;
case|case
name|FARG
case|:
comment|/* enum type mismatch, arg #%d */
name|warning
argument_list|(
literal|156
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|RETURN
case|:
comment|/* return value type mismatch */
name|warning
argument_list|(
literal|211
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* enum type mismatch, op %s */
name|warning
argument_list|(
literal|130
argument_list|,
name|mp
operator|->
name|m_name
argument_list|)
expr_stmt|;
break|break;
block|}
if|#
directive|if
literal|0
block|} else if (mp->m_comp&& op != EQ&& op != NE) { 		if (eflag)
comment|/* dubious comparisions of enums */
block|warning(243, mp->m_name);
endif|#
directive|endif
block|}
block|}
end_block

begin_comment
comment|/*  * Prints a warning if an operator has both enum end other integer  * types.  */
end_comment

begin_function
specifier|static
name|void
name|chkeop1
parameter_list|(
name|op
parameter_list|,
name|arg
parameter_list|,
name|ln
parameter_list|,
name|rn
parameter_list|)
name|op_t
name|op
decl_stmt|;
name|int
name|arg
decl_stmt|;
name|tnode_t
modifier|*
name|ln
decl_stmt|,
decl|*
name|rn
decl_stmt|;
end_function

begin_block
block|{
if|if
condition|(
operator|!
name|eflag
condition|)
return|return;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|INIT
case|:
comment|/* 		 * Initializations with 0 should be allowed. Otherwise, 		 * we should complain about all uninitialized enums, 		 * consequently. 		 */
if|if
condition|(
operator|!
name|rn
operator|->
name|tn_type
operator|->
name|t_isenum
operator|&&
name|rn
operator|->
name|tn_op
operator|==
name|CON
operator|&&
name|isityp
argument_list|(
name|rn
operator|->
name|tn_type
operator|->
name|t_tspec
argument_list|)
operator|&&
name|rn
operator|->
name|tn_val
operator|->
name|v_quad
operator|==
literal|0
condition|)
block|{
return|return;
block|}
comment|/* initialisation of '%s' with '%s' */
name|warning
argument_list|(
literal|277
argument_list|,
name|tyname
argument_list|(
name|ln
operator|->
name|tn_type
argument_list|)
argument_list|,
name|tyname
argument_list|(
name|rn
operator|->
name|tn_type
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FARG
case|:
comment|/* combination of '%s' and '%s', arg #%d */
name|warning
argument_list|(
literal|278
argument_list|,
name|tyname
argument_list|(
name|ln
operator|->
name|tn_type
argument_list|)
argument_list|,
name|tyname
argument_list|(
name|rn
operator|->
name|tn_type
argument_list|)
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|RETURN
case|:
comment|/* combination of '%s' and '%s' in return */
name|warning
argument_list|(
literal|279
argument_list|,
name|tyname
argument_list|(
name|ln
operator|->
name|tn_type
argument_list|)
argument_list|,
name|tyname
argument_list|(
name|rn
operator|->
name|tn_type
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* combination of '%s' and %s, op %s */
name|warning
argument_list|(
literal|242
argument_list|,
name|tyname
argument_list|(
name|ln
operator|->
name|tn_type
argument_list|)
argument_list|,
name|tyname
argument_list|(
name|rn
operator|->
name|tn_type
argument_list|)
argument_list|,
name|modtab
index|[
name|op
index|]
operator|.
name|m_name
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_block

begin_comment
comment|/*  * Build and initialize a new node.  */
end_comment

begin_function
specifier|static
name|tnode_t
modifier|*
name|mktnode
parameter_list|(
name|op
parameter_list|,
name|type
parameter_list|,
name|ln
parameter_list|,
name|rn
parameter_list|)
name|op_t
name|op
decl_stmt|;
name|type_t
modifier|*
name|type
decl_stmt|;
name|tnode_t
modifier|*
name|ln
decl_stmt|,
decl|*
name|rn
decl_stmt|;
end_function

begin_block
block|{
name|tnode_t
modifier|*
name|ntn
decl_stmt|;
name|tspec_t
name|t
decl_stmt|;
name|ntn
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|ntn
operator|->
name|tn_op
operator|=
name|op
expr_stmt|;
name|ntn
operator|->
name|tn_type
operator|=
name|type
expr_stmt|;
name|ntn
operator|->
name|tn_left
operator|=
name|ln
expr_stmt|;
name|ntn
operator|->
name|tn_right
operator|=
name|rn
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|STAR
operator|||
name|op
operator|==
name|FSEL
condition|)
block|{
if|if
condition|(
name|ln
operator|->
name|tn_type
operator|->
name|t_tspec
operator|==
name|PTR
condition|)
block|{
name|t
operator|=
name|ln
operator|->
name|tn_type
operator|->
name|t_subt
operator|->
name|t_tspec
expr_stmt|;
if|if
condition|(
name|t
operator|!=
name|FUNC
operator|&&
name|t
operator|!=
name|VOID
condition|)
name|ntn
operator|->
name|tn_lvalue
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|lerror
argument_list|(
literal|"mktnode() 2"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|ntn
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Performs usual conversion of operands to (unsigned) int.  *  * If tflag is set or the operand is a function argument with no  * type information (no prototype or variable # of args), convert  * float to double.  */
end_comment

begin_function
name|tnode_t
modifier|*
name|promote
parameter_list|(
name|op
parameter_list|,
name|farg
parameter_list|,
name|tn
parameter_list|)
name|op_t
name|op
decl_stmt|;
name|int
name|farg
decl_stmt|;
name|tnode_t
modifier|*
name|tn
decl_stmt|;
block|{
name|tspec_t
name|t
decl_stmt|;
name|type_t
modifier|*
name|ntp
decl_stmt|;
name|int
name|len
decl_stmt|;
name|t
operator|=
name|tn
operator|->
name|tn_type
operator|->
name|t_tspec
expr_stmt|;
if|if
condition|(
operator|!
name|isatyp
argument_list|(
name|t
argument_list|)
condition|)
return|return
operator|(
name|tn
operator|)
return|;
if|if
condition|(
operator|!
name|tflag
condition|)
block|{
comment|/* 		 * ANSI C requires that the result is always of type INT 		 * if INT can represent all possible values of the previous 		 * type. 		 */
if|if
condition|(
name|tn
operator|->
name|tn_type
operator|->
name|t_isfield
condition|)
block|{
name|len
operator|=
name|tn
operator|->
name|tn_type
operator|->
name|t_flen
expr_stmt|;
if|if
condition|(
name|size
argument_list|(
name|INT
argument_list|)
operator|>
name|len
condition|)
block|{
name|t
operator|=
name|INT
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|size
argument_list|(
name|INT
argument_list|)
operator|!=
name|len
condition|)
name|lerror
argument_list|(
literal|"promote() 1"
argument_list|)
expr_stmt|;
if|if
condition|(
name|isutyp
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|t
operator|=
name|UINT
expr_stmt|;
block|}
else|else
block|{
name|t
operator|=
name|INT
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|t
operator|==
name|CHAR
operator|||
name|t
operator|==
name|UCHAR
operator|||
name|t
operator|==
name|SCHAR
condition|)
block|{
name|t
operator|=
operator|(
name|size
argument_list|(
name|CHAR
argument_list|)
operator|<
name|size
argument_list|(
name|INT
argument_list|)
operator|||
name|t
operator|!=
name|UCHAR
operator|)
condition|?
name|INT
else|:
name|UINT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t
operator|==
name|SHORT
operator|||
name|t
operator|==
name|USHORT
condition|)
block|{
name|t
operator|=
operator|(
name|size
argument_list|(
name|SHORT
argument_list|)
operator|<
name|size
argument_list|(
name|INT
argument_list|)
operator|||
name|t
operator|==
name|SHORT
operator|)
condition|?
name|INT
else|:
name|UINT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t
operator|==
name|ENUM
condition|)
block|{
name|t
operator|=
name|INT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|farg
operator|&&
name|t
operator|==
name|FLOAT
condition|)
block|{
name|t
operator|=
name|DOUBLE
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * In traditional C, keep unsigned and promote FLOAT 		 * to DOUBLE. 		 */
if|if
condition|(
name|t
operator|==
name|UCHAR
operator|||
name|t
operator|==
name|USHORT
condition|)
block|{
name|t
operator|=
name|UINT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t
operator|==
name|CHAR
operator|||
name|t
operator|==
name|SCHAR
operator|||
name|t
operator|==
name|SHORT
condition|)
block|{
name|t
operator|=
name|INT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t
operator|==
name|FLOAT
condition|)
block|{
name|t
operator|=
name|DOUBLE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t
operator|==
name|ENUM
condition|)
block|{
name|t
operator|=
name|INT
expr_stmt|;
block|}
block|}
if|if
condition|(
name|t
operator|!=
name|tn
operator|->
name|tn_type
operator|->
name|t_tspec
condition|)
block|{
name|ntp
operator|=
name|tduptyp
argument_list|(
name|tn
operator|->
name|tn_type
argument_list|)
expr_stmt|;
name|ntp
operator|->
name|t_tspec
operator|=
name|t
expr_stmt|;
comment|/* 		 * Keep t_isenum so we are later able to check compatibility 		 * of enum types. 		 */
name|tn
operator|=
name|convert
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
name|ntp
argument_list|,
name|tn
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|tn
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Insert conversions which are necessary to give both operands the same  * type. This is done in different ways for traditional C and ANIS C.  */
end_comment

begin_function
specifier|static
name|void
name|balance
parameter_list|(
name|op
parameter_list|,
name|lnp
parameter_list|,
name|rnp
parameter_list|)
name|op_t
name|op
decl_stmt|;
name|tnode_t
modifier|*
modifier|*
name|lnp
decl_stmt|,
decl|*
modifier|*
name|rnp
decl_stmt|;
end_function

begin_block
block|{
name|tspec_t
name|lt
decl_stmt|,
name|rt
decl_stmt|,
name|t
decl_stmt|;
name|int
name|i
decl_stmt|,
name|u
decl_stmt|;
name|type_t
modifier|*
name|ntp
decl_stmt|;
specifier|static
name|tspec_t
name|tl
index|[]
init|=
block|{
name|LDOUBLE
block|,
name|DOUBLE
block|,
name|FLOAT
block|,
name|UQUAD
block|,
name|QUAD
block|,
name|ULONG
block|,
name|LONG
block|,
name|UINT
block|,
name|INT
block|, 	}
decl_stmt|;
name|lt
operator|=
operator|(
operator|*
name|lnp
operator|)
operator|->
name|tn_type
operator|->
name|t_tspec
expr_stmt|;
name|rt
operator|=
operator|(
operator|*
name|rnp
operator|)
operator|->
name|tn_type
operator|->
name|t_tspec
expr_stmt|;
if|if
condition|(
operator|!
name|isatyp
argument_list|(
name|lt
argument_list|)
operator|||
operator|!
name|isatyp
argument_list|(
name|rt
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|tflag
condition|)
block|{
if|if
condition|(
name|lt
operator|==
name|rt
condition|)
block|{
name|t
operator|=
name|lt
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lt
operator|==
name|LDOUBLE
operator|||
name|rt
operator|==
name|LDOUBLE
condition|)
block|{
name|t
operator|=
name|LDOUBLE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lt
operator|==
name|DOUBLE
operator|||
name|rt
operator|==
name|DOUBLE
condition|)
block|{
name|t
operator|=
name|DOUBLE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lt
operator|==
name|FLOAT
operator|||
name|rt
operator|==
name|FLOAT
condition|)
block|{
name|t
operator|=
name|FLOAT
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * If type A has more bits than type B it should 			 * be able to hold all possible values of type B. 			 */
if|if
condition|(
name|size
argument_list|(
name|lt
argument_list|)
operator|>
name|size
argument_list|(
name|rt
argument_list|)
condition|)
block|{
name|t
operator|=
name|lt
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|size
argument_list|(
name|lt
argument_list|)
operator|<
name|size
argument_list|(
name|rt
argument_list|)
condition|)
block|{
name|t
operator|=
name|rt
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|3
init|;
name|tl
index|[
name|i
index|]
operator|!=
name|INT
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|tl
index|[
name|i
index|]
operator|==
name|lt
operator|||
name|tl
index|[
name|i
index|]
operator|==
name|rt
condition|)
break|break;
block|}
if|if
condition|(
operator|(
name|isutyp
argument_list|(
name|lt
argument_list|)
operator|||
name|isutyp
argument_list|(
name|rt
argument_list|)
operator|)
operator|&&
operator|!
name|isutyp
argument_list|(
name|tl
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|i
operator|--
expr_stmt|;
block|}
name|t
operator|=
name|tl
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* Keep unsigned in traditional C */
name|u
operator|=
name|isutyp
argument_list|(
name|lt
argument_list|)
operator|||
name|isutyp
argument_list|(
name|rt
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|tl
index|[
name|i
index|]
operator|!=
name|INT
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|lt
operator|==
name|tl
index|[
name|i
index|]
operator|||
name|rt
operator|==
name|tl
index|[
name|i
index|]
condition|)
break|break;
block|}
name|t
operator|=
name|tl
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|u
operator|&&
name|isityp
argument_list|(
name|t
argument_list|)
operator|&&
operator|!
name|isutyp
argument_list|(
name|t
argument_list|)
condition|)
name|t
operator|=
name|utyp
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|!=
name|lt
condition|)
block|{
name|ntp
operator|=
name|tduptyp
argument_list|(
operator|(
operator|*
name|lnp
operator|)
operator|->
name|tn_type
argument_list|)
expr_stmt|;
name|ntp
operator|->
name|t_tspec
operator|=
name|t
expr_stmt|;
operator|*
name|lnp
operator|=
name|convert
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
name|ntp
argument_list|,
operator|*
name|lnp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|!=
name|rt
condition|)
block|{
name|ntp
operator|=
name|tduptyp
argument_list|(
operator|(
operator|*
name|rnp
operator|)
operator|->
name|tn_type
argument_list|)
expr_stmt|;
name|ntp
operator|->
name|t_tspec
operator|=
name|t
expr_stmt|;
operator|*
name|rnp
operator|=
name|convert
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
name|ntp
argument_list|,
operator|*
name|rnp
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Insert a conversion operator, which converts the type of the node  * to another given type.  * If op is FARG, arg is the number of the argument (used for warnings).  */
end_comment

begin_function
name|tnode_t
modifier|*
name|convert
parameter_list|(
name|op
parameter_list|,
name|arg
parameter_list|,
name|tp
parameter_list|,
name|tn
parameter_list|)
name|op_t
name|op
decl_stmt|;
name|int
name|arg
decl_stmt|;
name|type_t
modifier|*
name|tp
decl_stmt|;
name|tnode_t
modifier|*
name|tn
decl_stmt|;
block|{
name|tnode_t
modifier|*
name|ntn
decl_stmt|;
name|tspec_t
name|nt
decl_stmt|,
name|ot
decl_stmt|,
name|ost
decl_stmt|;
if|if
condition|(
name|tn
operator|->
name|tn_lvalue
condition|)
name|lerror
argument_list|(
literal|"convert() 1"
argument_list|)
expr_stmt|;
name|nt
operator|=
name|tp
operator|->
name|t_tspec
expr_stmt|;
if|if
condition|(
operator|(
name|ot
operator|=
name|tn
operator|->
name|tn_type
operator|->
name|t_tspec
operator|)
operator|==
name|PTR
condition|)
name|ost
operator|=
name|tn
operator|->
name|tn_type
operator|->
name|t_subt
operator|->
name|t_tspec
expr_stmt|;
if|if
condition|(
operator|!
name|tflag
operator|&&
operator|!
name|sflag
operator|&&
name|op
operator|==
name|FARG
condition|)
name|ptconv
argument_list|(
name|arg
argument_list|,
name|nt
argument_list|,
name|ot
argument_list|,
name|tp
argument_list|,
name|tn
argument_list|)
expr_stmt|;
if|if
condition|(
name|isityp
argument_list|(
name|nt
argument_list|)
operator|&&
name|isityp
argument_list|(
name|ot
argument_list|)
condition|)
block|{
name|iiconv
argument_list|(
name|op
argument_list|,
name|arg
argument_list|,
name|nt
argument_list|,
name|ot
argument_list|,
name|tp
argument_list|,
name|tn
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nt
operator|==
name|PTR
operator|&&
operator|(
operator|(
name|ot
operator|==
name|PTR
operator|&&
name|ost
operator|==
name|VOID
operator|)
operator|||
name|isityp
argument_list|(
name|ot
argument_list|)
operator|)
operator|&&
name|tn
operator|->
name|tn_op
operator|==
name|CON
operator|&&
name|tn
operator|->
name|tn_val
operator|->
name|v_quad
operator|==
literal|0
condition|)
block|{
comment|/* 0, 0L and (void *)0 may be assigned to any pointer. */
block|}
elseif|else
if|if
condition|(
name|isityp
argument_list|(
name|nt
argument_list|)
operator|&&
name|ot
operator|==
name|PTR
condition|)
block|{
name|piconv
argument_list|(
name|op
argument_list|,
name|nt
argument_list|,
name|tp
argument_list|,
name|tn
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nt
operator|==
name|PTR
operator|&&
name|ot
operator|==
name|PTR
condition|)
block|{
name|ppconv
argument_list|(
name|op
argument_list|,
name|tn
argument_list|,
name|tp
argument_list|)
expr_stmt|;
block|}
name|ntn
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|ntn
operator|->
name|tn_op
operator|=
name|CVT
expr_stmt|;
name|ntn
operator|->
name|tn_type
operator|=
name|tp
expr_stmt|;
name|ntn
operator|->
name|tn_cast
operator|=
name|op
operator|==
name|CVT
expr_stmt|;
if|if
condition|(
name|tn
operator|->
name|tn_op
operator|!=
name|CON
operator|||
name|nt
operator|==
name|VOID
condition|)
block|{
name|ntn
operator|->
name|tn_left
operator|=
name|tn
expr_stmt|;
block|}
else|else
block|{
name|ntn
operator|->
name|tn_op
operator|=
name|CON
expr_stmt|;
name|ntn
operator|->
name|tn_val
operator|=
name|tgetblk
argument_list|(
sizeof|sizeof
argument_list|(
name|val_t
argument_list|)
argument_list|)
expr_stmt|;
name|cvtcon
argument_list|(
name|op
argument_list|,
name|arg
argument_list|,
name|ntn
operator|->
name|tn_type
argument_list|,
name|ntn
operator|->
name|tn_val
argument_list|,
name|tn
operator|->
name|tn_val
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ntn
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Print a warning if a prototype causes a type conversion that is  * different from what would happen to the same argument in the  * absence of a prototype.  *  * Errors/Warnings about illegal type combinations are already printed  * in asgntypok().  */
end_comment

begin_function
specifier|static
name|void
name|ptconv
parameter_list|(
name|arg
parameter_list|,
name|nt
parameter_list|,
name|ot
parameter_list|,
name|tp
parameter_list|,
name|tn
parameter_list|)
name|int
name|arg
decl_stmt|;
name|tspec_t
name|nt
decl_stmt|,
name|ot
decl_stmt|;
name|type_t
modifier|*
name|tp
decl_stmt|;
name|tnode_t
modifier|*
name|tn
decl_stmt|;
block|{
name|tnode_t
modifier|*
name|ptn
decl_stmt|;
if|if
condition|(
operator|!
name|isatyp
argument_list|(
name|nt
argument_list|)
operator|||
operator|!
name|isatyp
argument_list|(
name|ot
argument_list|)
condition|)
return|return;
comment|/* 	 * If the type of the formal parameter is char/short, a warning 	 * would be useless, because functions declared the old style 	 * can't expect char/short arguments. 	 */
if|if
condition|(
name|nt
operator|==
name|CHAR
operator|||
name|nt
operator|==
name|UCHAR
operator|||
name|nt
operator|==
name|SHORT
operator|||
name|nt
operator|==
name|USHORT
condition|)
return|return;
comment|/* get default promotion */
name|ptn
operator|=
name|promote
argument_list|(
name|NOOP
argument_list|,
literal|1
argument_list|,
name|tn
argument_list|)
expr_stmt|;
name|ot
operator|=
name|ptn
operator|->
name|tn_type
operator|->
name|t_tspec
expr_stmt|;
comment|/* return if types are the same with and without prototype */
if|if
condition|(
name|nt
operator|==
name|ot
operator|||
operator|(
name|nt
operator|==
name|ENUM
operator|&&
name|ot
operator|==
name|INT
operator|)
condition|)
return|return;
if|if
condition|(
name|isftyp
argument_list|(
name|nt
argument_list|)
operator|!=
name|isftyp
argument_list|(
name|ot
argument_list|)
operator|||
name|psize
argument_list|(
name|nt
argument_list|)
operator|!=
name|psize
argument_list|(
name|ot
argument_list|)
condition|)
block|{
comment|/* representation and/or width change */
if|if
condition|(
name|styp
argument_list|(
name|nt
argument_list|)
operator|!=
name|SHORT
operator|||
operator|!
name|isityp
argument_list|(
name|ot
argument_list|)
operator|||
name|psize
argument_list|(
name|ot
argument_list|)
operator|>
name|psize
argument_list|(
name|INT
argument_list|)
condition|)
comment|/* conversion to '%s' due to prototype, arg #%d */
name|warning
argument_list|(
literal|259
argument_list|,
name|tyname
argument_list|(
name|tp
argument_list|)
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hflag
condition|)
block|{
comment|/* 		 * they differ in sign or base type (char, short, int, 		 * long, long long, float, double, long double) 		 * 		 * if they differ only in sign and the argument is a constant 		 * and the msb of the argument is not set, print no warning 		 */
if|if
condition|(
name|ptn
operator|->
name|tn_op
operator|==
name|CON
operator|&&
name|isityp
argument_list|(
name|nt
argument_list|)
operator|&&
name|styp
argument_list|(
name|nt
argument_list|)
operator|==
name|styp
argument_list|(
name|ot
argument_list|)
operator|&&
name|msb
argument_list|(
name|ptn
operator|->
name|tn_val
operator|->
name|v_quad
argument_list|,
name|ot
argument_list|,
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* ok */
block|}
else|else
block|{
comment|/* conversion to '%s' due to prototype, arg #%d */
name|warning
argument_list|(
literal|259
argument_list|,
name|tyname
argument_list|(
name|tp
argument_list|)
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Print warnings for conversions of integer types which my cause  * problems.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|iiconv
parameter_list|(
name|op
parameter_list|,
name|arg
parameter_list|,
name|nt
parameter_list|,
name|ot
parameter_list|,
name|tp
parameter_list|,
name|tn
parameter_list|)
name|op_t
name|op
decl_stmt|;
name|int
name|arg
decl_stmt|;
name|tspec_t
name|nt
decl_stmt|,
name|ot
decl_stmt|;
name|type_t
modifier|*
name|tp
decl_stmt|;
name|tnode_t
modifier|*
name|tn
decl_stmt|;
block|{
if|if
condition|(
name|tn
operator|->
name|tn_op
operator|==
name|CON
condition|)
return|return;
if|if
condition|(
name|op
operator|==
name|CVT
condition|)
return|return;
if|#
directive|if
literal|0
block|if (psize(nt)> psize(ot)&& isutyp(nt) != isutyp(ot)) {
comment|/* conversion to %s may sign-extend incorrectly (, arg #%d) */
block|if (aflag&& pflag) { 			if (op == FARG) { 				warning(297, tyname(tp), arg); 			} else { 				warning(131, tyname(tp)); 			} 		} 	}
endif|#
directive|endif
if|if
condition|(
name|psize
argument_list|(
name|nt
argument_list|)
operator|<
name|psize
argument_list|(
name|ot
argument_list|)
operator|&&
operator|(
name|ot
operator|==
name|LONG
operator|||
name|ot
operator|==
name|ULONG
operator|||
name|ot
operator|==
name|QUAD
operator|||
name|ot
operator|==
name|UQUAD
operator|||
name|aflag
operator|>
literal|1
operator|)
condition|)
block|{
comment|/* conversion from '%s' may lose accuracy */
if|if
condition|(
name|aflag
condition|)
block|{
if|if
condition|(
name|op
operator|==
name|FARG
condition|)
block|{
name|warning
argument_list|(
literal|298
argument_list|,
name|tyname
argument_list|(
name|tn
operator|->
name|tn_type
argument_list|)
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|warning
argument_list|(
literal|132
argument_list|,
name|tyname
argument_list|(
name|tn
operator|->
name|tn_type
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Print warnings for dubious conversions of pointer to integer.  */
end_comment

begin_function
specifier|static
name|void
name|piconv
parameter_list|(
name|op
parameter_list|,
name|nt
parameter_list|,
name|tp
parameter_list|,
name|tn
parameter_list|)
name|op_t
name|op
decl_stmt|;
name|tspec_t
name|nt
decl_stmt|;
name|type_t
modifier|*
name|tp
decl_stmt|;
name|tnode_t
modifier|*
name|tn
decl_stmt|;
block|{
if|if
condition|(
name|tn
operator|->
name|tn_op
operator|==
name|CON
condition|)
return|return;
if|if
condition|(
name|op
operator|!=
name|CVT
condition|)
block|{
comment|/* We got already an error. */
return|return;
block|}
if|if
condition|(
name|psize
argument_list|(
name|nt
argument_list|)
operator|<
name|psize
argument_list|(
name|PTR
argument_list|)
condition|)
block|{
if|if
condition|(
name|pflag
operator|&&
name|size
argument_list|(
name|nt
argument_list|)
operator|>=
name|size
argument_list|(
name|PTR
argument_list|)
condition|)
block|{
comment|/* conv. of pointer to %s may lose bits */
name|warning
argument_list|(
literal|134
argument_list|,
name|tyname
argument_list|(
name|tp
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* conv. of pointer to %s loses bits */
name|warning
argument_list|(
literal|133
argument_list|,
name|tyname
argument_list|(
name|tp
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Print warnings for questionable pointer conversions.  */
end_comment

begin_function
specifier|static
name|void
name|ppconv
parameter_list|(
name|op
parameter_list|,
name|tn
parameter_list|,
name|tp
parameter_list|)
name|op_t
name|op
decl_stmt|;
name|tnode_t
modifier|*
name|tn
decl_stmt|;
name|type_t
modifier|*
name|tp
decl_stmt|;
block|{
name|tspec_t
name|nt
decl_stmt|,
name|ot
decl_stmt|;
specifier|const
name|char
modifier|*
name|nts
decl_stmt|,
modifier|*
name|ots
decl_stmt|;
comment|/* 	 * We got already an error (pointers of different types 	 * without a cast) or we will not get a warning. 	 */
if|if
condition|(
name|op
operator|!=
name|CVT
condition|)
return|return;
name|nt
operator|=
name|tp
operator|->
name|t_subt
operator|->
name|t_tspec
expr_stmt|;
name|ot
operator|=
name|tn
operator|->
name|tn_type
operator|->
name|t_subt
operator|->
name|t_tspec
expr_stmt|;
if|if
condition|(
name|nt
operator|==
name|VOID
operator|||
name|ot
operator|==
name|VOID
condition|)
block|{
if|if
condition|(
name|sflag
operator|&&
operator|(
name|nt
operator|==
name|FUNC
operator|||
name|ot
operator|==
name|FUNC
operator|)
condition|)
block|{
comment|/* (void *)0 already handled in convert() */
operator|*
operator|(
name|nt
operator|==
name|FUNC
condition|?
operator|&
name|nts
else|:
operator|&
name|ots
operator|)
operator|=
literal|"function pointer"
expr_stmt|;
operator|*
operator|(
name|nt
operator|==
name|VOID
condition|?
operator|&
name|nts
else|:
operator|&
name|ots
operator|)
operator|=
literal|"'void *'"
expr_stmt|;
comment|/* ANSI C forbids conversion of %s to %s */
name|warning
argument_list|(
literal|303
argument_list|,
name|ots
argument_list|,
name|nts
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
elseif|else
if|if
condition|(
name|nt
operator|==
name|FUNC
operator|&&
name|ot
operator|==
name|FUNC
condition|)
block|{
return|return;
block|}
elseif|else
if|if
condition|(
name|nt
operator|==
name|FUNC
operator|||
name|ot
operator|==
name|FUNC
condition|)
block|{
comment|/* questionable conversion of function pointer */
name|warning
argument_list|(
literal|229
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|getbound
argument_list|(
name|tp
operator|->
name|t_subt
argument_list|)
operator|>
name|getbound
argument_list|(
name|tn
operator|->
name|tn_type
operator|->
name|t_subt
argument_list|)
condition|)
block|{
if|if
condition|(
name|hflag
condition|)
comment|/* possible pointer alignment problem */
name|warning
argument_list|(
literal|135
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|(
name|nt
operator|==
name|STRUCT
operator|||
name|nt
operator|==
name|UNION
operator|)
operator|&&
name|tp
operator|->
name|t_subt
operator|->
name|t_str
operator|!=
name|tn
operator|->
name|tn_type
operator|->
name|t_subt
operator|->
name|t_str
operator|)
operator|||
name|psize
argument_list|(
name|nt
argument_list|)
operator|!=
name|psize
argument_list|(
name|ot
argument_list|)
condition|)
block|{
if|if
condition|(
name|cflag
condition|)
block|{
comment|/* pointer casts may be troublesome */
name|warning
argument_list|(
literal|247
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Converts a typed constant in a constant of another type.  *  * op		operator which requires conversion  * arg		if op is FARG, # of argument  * tp		type in which to convert the constant  * nv		new constant  * v		old constant  */
end_comment

begin_function
name|void
name|cvtcon
parameter_list|(
name|op
parameter_list|,
name|arg
parameter_list|,
name|tp
parameter_list|,
name|nv
parameter_list|,
name|v
parameter_list|)
name|op_t
name|op
decl_stmt|;
name|int
name|arg
decl_stmt|;
name|type_t
modifier|*
name|tp
decl_stmt|;
name|val_t
modifier|*
name|nv
decl_stmt|,
decl|*
name|v
decl_stmt|;
end_function

begin_block
block|{
name|tspec_t
name|ot
decl_stmt|,
name|nt
decl_stmt|;
name|ldbl_t
name|max
decl_stmt|,
name|min
decl_stmt|;
name|int
name|sz
decl_stmt|,
name|rchk
decl_stmt|;
name|quad_t
name|xmask
decl_stmt|,
name|xmsk1
decl_stmt|;
name|int
name|osz
decl_stmt|,
name|nsz
decl_stmt|;
name|ot
operator|=
name|v
operator|->
name|v_tspec
expr_stmt|;
name|nt
operator|=
name|nv
operator|->
name|v_tspec
operator|=
name|tp
operator|->
name|t_tspec
expr_stmt|;
name|rchk
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ot
operator|==
name|FLOAT
operator|||
name|ot
operator|==
name|DOUBLE
operator|||
name|ot
operator|==
name|LDOUBLE
condition|)
block|{
switch|switch
condition|(
name|nt
condition|)
block|{
case|case
name|CHAR
case|:
name|max
operator|=
name|CHAR_MAX
expr_stmt|;
name|min
operator|=
name|CHAR_MIN
expr_stmt|;
break|break;
case|case
name|UCHAR
case|:
name|max
operator|=
name|UCHAR_MAX
expr_stmt|;
name|min
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SCHAR
case|:
name|max
operator|=
name|SCHAR_MAX
expr_stmt|;
name|min
operator|=
name|SCHAR_MIN
expr_stmt|;
break|break;
case|case
name|SHORT
case|:
name|max
operator|=
name|SHRT_MAX
expr_stmt|;
name|min
operator|=
name|SHRT_MIN
expr_stmt|;
break|break;
case|case
name|USHORT
case|:
name|max
operator|=
name|USHRT_MAX
expr_stmt|;
name|min
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|ENUM
case|:
case|case
name|INT
case|:
name|max
operator|=
name|INT_MAX
expr_stmt|;
name|min
operator|=
name|INT_MIN
expr_stmt|;
break|break;
case|case
name|UINT
case|:
name|max
operator|=
operator|(
name|u_int
operator|)
name|UINT_MAX
expr_stmt|;
name|min
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|LONG
case|:
name|max
operator|=
name|LONG_MAX
expr_stmt|;
name|min
operator|=
name|LONG_MIN
expr_stmt|;
break|break;
case|case
name|ULONG
case|:
name|max
operator|=
operator|(
name|u_long
operator|)
name|ULONG_MAX
expr_stmt|;
name|min
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|QUAD
case|:
name|max
operator|=
name|QUAD_MAX
expr_stmt|;
name|min
operator|=
name|QUAD_MIN
expr_stmt|;
break|break;
case|case
name|UQUAD
case|:
name|max
operator|=
operator|(
name|u_quad_t
operator|)
name|UQUAD_MAX
expr_stmt|;
name|min
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|FLOAT
case|:
name|max
operator|=
name|FLT_MAX
expr_stmt|;
name|min
operator|=
operator|-
name|FLT_MAX
expr_stmt|;
break|break;
case|case
name|DOUBLE
case|:
name|max
operator|=
name|DBL_MAX
expr_stmt|;
name|min
operator|=
operator|-
name|DBL_MAX
expr_stmt|;
break|break;
case|case
name|PTR
case|:
comment|/* Got already an error because of float --> ptr */
case|case
name|LDOUBLE
case|:
name|max
operator|=
name|LDBL_MAX
expr_stmt|;
name|min
operator|=
operator|-
name|LDBL_MAX
expr_stmt|;
break|break;
default|default:
name|lerror
argument_list|(
literal|"cvtcon() 1"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|v
operator|->
name|v_ldbl
operator|>
name|max
operator|||
name|v
operator|->
name|v_ldbl
operator|<
name|min
condition|)
block|{
if|if
condition|(
name|nt
operator|==
name|LDOUBLE
condition|)
name|lerror
argument_list|(
literal|"cvtcon() 2"
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|FARG
condition|)
block|{
comment|/* conv. of %s to %s is out of rng., arg #%d */
name|warning
argument_list|(
literal|295
argument_list|,
name|tyname
argument_list|(
name|gettyp
argument_list|(
name|ot
argument_list|)
argument_list|)
argument_list|,
name|tyname
argument_list|(
name|tp
argument_list|)
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* conversion of %s to %s is out of range */
name|warning
argument_list|(
literal|119
argument_list|,
name|tyname
argument_list|(
name|gettyp
argument_list|(
name|ot
argument_list|)
argument_list|)
argument_list|,
name|tyname
argument_list|(
name|tp
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|v
operator|->
name|v_ldbl
operator|=
name|v
operator|->
name|v_ldbl
operator|>
literal|0
condition|?
name|max
else|:
name|min
expr_stmt|;
block|}
if|if
condition|(
name|nt
operator|==
name|FLOAT
condition|)
block|{
name|nv
operator|->
name|v_ldbl
operator|=
operator|(
name|float
operator|)
name|v
operator|->
name|v_ldbl
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nt
operator|==
name|DOUBLE
condition|)
block|{
name|nv
operator|->
name|v_ldbl
operator|=
operator|(
name|double
operator|)
name|v
operator|->
name|v_ldbl
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nt
operator|==
name|LDOUBLE
condition|)
block|{
name|nv
operator|->
name|v_ldbl
operator|=
name|v
operator|->
name|v_ldbl
expr_stmt|;
block|}
else|else
block|{
name|nv
operator|->
name|v_quad
operator|=
operator|(
name|nt
operator|==
name|PTR
operator|||
name|isutyp
argument_list|(
name|nt
argument_list|)
operator|)
condition|?
operator|(
name|u_quad_t
operator|)
name|v
operator|->
name|v_ldbl
else|:
operator|(
name|quad_t
operator|)
name|v
operator|->
name|v_ldbl
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|nt
operator|==
name|FLOAT
condition|)
block|{
name|nv
operator|->
name|v_ldbl
operator|=
operator|(
name|ot
operator|==
name|PTR
operator|||
name|isutyp
argument_list|(
name|ot
argument_list|)
operator|)
condition|?
operator|(
name|float
operator|)
operator|(
name|u_quad_t
operator|)
name|v
operator|->
name|v_quad
else|:
operator|(
name|float
operator|)
name|v
operator|->
name|v_quad
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nt
operator|==
name|DOUBLE
condition|)
block|{
name|nv
operator|->
name|v_ldbl
operator|=
operator|(
name|ot
operator|==
name|PTR
operator|||
name|isutyp
argument_list|(
name|ot
argument_list|)
operator|)
condition|?
operator|(
name|double
operator|)
operator|(
name|u_quad_t
operator|)
name|v
operator|->
name|v_quad
else|:
operator|(
name|double
operator|)
name|v
operator|->
name|v_quad
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nt
operator|==
name|LDOUBLE
condition|)
block|{
name|nv
operator|->
name|v_ldbl
operator|=
operator|(
name|ot
operator|==
name|PTR
operator|||
name|isutyp
argument_list|(
name|ot
argument_list|)
operator|)
condition|?
operator|(
name|ldbl_t
operator|)
operator|(
name|u_quad_t
operator|)
name|v
operator|->
name|v_quad
else|:
operator|(
name|ldbl_t
operator|)
name|v
operator|->
name|v_quad
expr_stmt|;
block|}
else|else
block|{
name|rchk
operator|=
literal|1
expr_stmt|;
comment|/* Check for lost precision. */
name|nv
operator|->
name|v_quad
operator|=
name|v
operator|->
name|v_quad
expr_stmt|;
block|}
block|}
if|if
condition|(
name|v
operator|->
name|v_ansiu
operator|&&
name|isftyp
argument_list|(
name|nt
argument_list|)
condition|)
block|{
comment|/* ANSI C treats constant as unsigned */
name|warning
argument_list|(
literal|157
argument_list|)
expr_stmt|;
name|v
operator|->
name|v_ansiu
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|v
operator|->
name|v_ansiu
operator|&&
operator|(
name|isityp
argument_list|(
name|nt
argument_list|)
operator|&&
operator|!
name|isutyp
argument_list|(
name|nt
argument_list|)
operator|&&
name|psize
argument_list|(
name|nt
argument_list|)
operator|>
name|psize
argument_list|(
name|ot
argument_list|)
operator|)
condition|)
block|{
comment|/* ANSI C treats constant as unsigned */
name|warning
argument_list|(
literal|157
argument_list|)
expr_stmt|;
name|v
operator|->
name|v_ansiu
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|nt
operator|!=
name|FLOAT
operator|&&
name|nt
operator|!=
name|DOUBLE
operator|&&
name|nt
operator|!=
name|LDOUBLE
condition|)
block|{
name|sz
operator|=
name|tp
operator|->
name|t_isfield
condition|?
name|tp
operator|->
name|t_flen
else|:
name|size
argument_list|(
name|nt
argument_list|)
expr_stmt|;
name|nv
operator|->
name|v_quad
operator|=
name|xsign
argument_list|(
name|nv
operator|->
name|v_quad
argument_list|,
name|nt
argument_list|,
name|sz
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rchk
operator|&&
name|op
operator|!=
name|CVT
condition|)
block|{
name|osz
operator|=
name|size
argument_list|(
name|ot
argument_list|)
expr_stmt|;
name|nsz
operator|=
name|tp
operator|->
name|t_isfield
condition|?
name|tp
operator|->
name|t_flen
else|:
name|size
argument_list|(
name|nt
argument_list|)
expr_stmt|;
name|xmask
operator|=
name|qlmasks
index|[
name|nsz
index|]
operator|^
name|qlmasks
index|[
name|osz
index|]
expr_stmt|;
name|xmsk1
operator|=
name|qlmasks
index|[
name|nsz
index|]
operator|^
name|qlmasks
index|[
name|osz
operator|-
literal|1
index|]
expr_stmt|;
comment|/* 		 * For bitwise operations we are not interested in the 		 * value, but in the bits itself. 		 */
if|if
condition|(
name|op
operator|==
name|ORASS
operator|||
name|op
operator|==
name|OR
operator|||
name|op
operator|==
name|XOR
condition|)
block|{
comment|/* 			 * Print a warning if bits which were set are 			 * lost due to the conversion. 			 * This can happen with operator ORASS only. 			 */
if|if
condition|(
name|nsz
operator|<
name|osz
operator|&&
operator|(
name|v
operator|->
name|v_quad
operator|&
name|xmask
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* constant truncated by conv., op %s */
name|warning
argument_list|(
literal|306
argument_list|,
name|modtab
index|[
name|op
index|]
operator|.
name|m_name
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|op
operator|==
name|ANDASS
operator|||
name|op
operator|==
name|AND
condition|)
block|{
comment|/* 			 * Print a warning if additional bits are not all 1 			 * and the most significant bit of the old value is 1, 			 * or if at least one (but not all) removed bit was 0. 			 */
if|if
condition|(
name|nsz
operator|>
name|osz
operator|&&
operator|(
name|nv
operator|->
name|v_quad
operator|&
name|qbmasks
index|[
name|osz
operator|-
literal|1
index|]
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|nv
operator|->
name|v_quad
operator|&
name|xmask
operator|)
operator|!=
name|xmask
condition|)
block|{
comment|/* 				 * extra bits set to 0 in conversion 				 * of '%s' to '%s', op %s 				 */
name|warning
argument_list|(
literal|309
argument_list|,
name|tyname
argument_list|(
name|gettyp
argument_list|(
name|ot
argument_list|)
argument_list|)
argument_list|,
name|tyname
argument_list|(
name|tp
argument_list|)
argument_list|,
name|modtab
index|[
name|op
index|]
operator|.
name|m_name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nsz
operator|<
name|osz
operator|&&
operator|(
name|v
operator|->
name|v_quad
operator|&
name|xmask
operator|)
operator|!=
name|xmask
operator|&&
operator|(
name|v
operator|->
name|v_quad
operator|&
name|xmask
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* const. truncated by conv., op %s */
name|warning
argument_list|(
literal|306
argument_list|,
name|modtab
index|[
name|op
index|]
operator|.
name|m_name
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|nt
operator|!=
name|PTR
operator|&&
name|isutyp
argument_list|(
name|nt
argument_list|)
operator|)
operator|&&
operator|(
name|ot
operator|!=
name|PTR
operator|&&
operator|!
name|isutyp
argument_list|(
name|ot
argument_list|)
operator|)
operator|&&
name|v
operator|->
name|v_quad
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|op
operator|==
name|ASSIGN
condition|)
block|{
comment|/* assignment of negative constant to ... */
name|warning
argument_list|(
literal|164
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|op
operator|==
name|INIT
condition|)
block|{
comment|/* initialisation of unsigned with neg. ... */
name|warning
argument_list|(
literal|221
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|op
operator|==
name|FARG
condition|)
block|{
comment|/* conversion of neg. const. to ..., arg #%d */
name|warning
argument_list|(
literal|296
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|modtab
index|[
name|op
index|]
operator|.
name|m_comp
condition|)
block|{
comment|/* we get this warning already in chkcomp() */
block|}
else|else
block|{
comment|/* conversion of negative constant to ... */
name|warning
argument_list|(
literal|222
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|nv
operator|->
name|v_quad
operator|!=
name|v
operator|->
name|v_quad
operator|&&
name|nsz
operator|<=
name|osz
operator|&&
operator|(
name|v
operator|->
name|v_quad
operator|&
name|xmask
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|isutyp
argument_list|(
name|ot
argument_list|)
operator|||
operator|(
name|v
operator|->
name|v_quad
operator|&
name|xmsk1
operator|)
operator|!=
name|xmsk1
operator|)
condition|)
block|{
comment|/* 			 * Loss of significant bit(s). All truncated bits 			 * of unsigned types or all truncated bits plus the 			 * msb of the target for signed types are considered 			 * to be significant bits. Loss of significant bits 			 * means that at least on of the bits was set in an 			 * unsigned type or that at least one, but not all of 			 * the bits was set in an signed type. 			 * Loss of significant bits means that it is not 			 * possible, also not with necessary casts, to convert 			 * back to the original type. A example for a 			 * necessary cast is: 			 *	char c;	int	i; c = 128; 			 *	i = c;			** yields -128 ** 			 *	i = (unsigned char)c;	** yields 128 ** 			 */
if|if
condition|(
name|op
operator|==
name|ASSIGN
operator|&&
name|tp
operator|->
name|t_isfield
condition|)
block|{
comment|/* precision lost in bit-field assignment */
name|warning
argument_list|(
literal|166
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|op
operator|==
name|ASSIGN
condition|)
block|{
comment|/* constant truncated by assignment */
name|warning
argument_list|(
literal|165
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|op
operator|==
name|INIT
operator|&&
name|tp
operator|->
name|t_isfield
condition|)
block|{
comment|/* bit-field initializer does not fit */
name|warning
argument_list|(
literal|180
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|op
operator|==
name|INIT
condition|)
block|{
comment|/* initializer does not fit */
name|warning
argument_list|(
literal|178
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|op
operator|==
name|CASE
condition|)
block|{
comment|/* case label affected by conversion */
name|warning
argument_list|(
literal|196
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|op
operator|==
name|FARG
condition|)
block|{
comment|/* conv. of %s to %s is out of rng., arg #%d */
name|warning
argument_list|(
literal|295
argument_list|,
name|tyname
argument_list|(
name|gettyp
argument_list|(
name|ot
argument_list|)
argument_list|)
argument_list|,
name|tyname
argument_list|(
name|tp
argument_list|)
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* conversion of %s to %s is out of range */
name|warning
argument_list|(
literal|119
argument_list|,
name|tyname
argument_list|(
name|gettyp
argument_list|(
name|ot
argument_list|)
argument_list|)
argument_list|,
name|tyname
argument_list|(
name|tp
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|nv
operator|->
name|v_quad
operator|!=
name|v
operator|->
name|v_quad
condition|)
block|{
if|if
condition|(
name|op
operator|==
name|ASSIGN
operator|&&
name|tp
operator|->
name|t_isfield
condition|)
block|{
comment|/* precision lost in bit-field assignment */
name|warning
argument_list|(
literal|166
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|op
operator|==
name|INIT
operator|&&
name|tp
operator|->
name|t_isfield
condition|)
block|{
comment|/* bit-field initializer out of range */
name|warning
argument_list|(
literal|11
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|op
operator|==
name|CASE
condition|)
block|{
comment|/* case label affected by conversion */
name|warning
argument_list|(
literal|196
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|op
operator|==
name|FARG
condition|)
block|{
comment|/* conv. of %s to %s is out of rng., arg #%d */
name|warning
argument_list|(
literal|295
argument_list|,
name|tyname
argument_list|(
name|gettyp
argument_list|(
name|ot
argument_list|)
argument_list|)
argument_list|,
name|tyname
argument_list|(
name|tp
argument_list|)
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* conversion of %s to %s is out of range */
name|warning
argument_list|(
literal|119
argument_list|,
name|tyname
argument_list|(
name|gettyp
argument_list|(
name|ot
argument_list|)
argument_list|)
argument_list|,
name|tyname
argument_list|(
name|tp
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * Called if incompatible types were detected.  * Prints a appropriate warning.  */
end_comment

begin_function
specifier|static
name|void
name|incompat
parameter_list|(
name|op
parameter_list|,
name|lt
parameter_list|,
name|rt
parameter_list|)
name|op_t
name|op
decl_stmt|;
name|tspec_t
name|lt
decl_stmt|,
name|rt
decl_stmt|;
block|{
name|mod_t
modifier|*
name|mp
decl_stmt|;
name|mp
operator|=
operator|&
name|modtab
index|[
name|op
index|]
expr_stmt|;
if|if
condition|(
name|lt
operator|==
name|VOID
operator|||
operator|(
name|mp
operator|->
name|m_binary
operator|&&
name|rt
operator|==
name|VOID
operator|)
condition|)
block|{
comment|/* void type illegal in expression */
name|error
argument_list|(
literal|109
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|op
operator|==
name|ASSIGN
condition|)
block|{
if|if
condition|(
operator|(
name|lt
operator|==
name|STRUCT
operator|||
name|lt
operator|==
name|UNION
operator|)
operator|&&
operator|(
name|rt
operator|==
name|STRUCT
operator|||
name|rt
operator|==
name|UNION
operator|)
condition|)
block|{
comment|/* assignment of different structures */
name|error
argument_list|(
literal|240
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* assignment type mismatch */
name|error
argument_list|(
literal|171
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|mp
operator|->
name|m_binary
condition|)
block|{
comment|/* operands of %s have incompatible types */
name|error
argument_list|(
literal|107
argument_list|,
name|mp
operator|->
name|m_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* operand of %s has incompatible type */
name|error
argument_list|(
literal|108
argument_list|,
name|mp
operator|->
name|m_name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Called if incompatible pointer types are detected.  * Print an appropriate warning.  */
end_comment

begin_function
specifier|static
name|void
name|illptrc
parameter_list|(
name|mp
parameter_list|,
name|ltp
parameter_list|,
name|rtp
parameter_list|)
name|mod_t
modifier|*
name|mp
decl_stmt|;
name|type_t
modifier|*
name|ltp
decl_stmt|,
decl|*
name|rtp
decl_stmt|;
end_function

begin_block
block|{
name|tspec_t
name|lt
decl_stmt|,
name|rt
decl_stmt|;
if|if
condition|(
name|ltp
operator|->
name|t_tspec
operator|!=
name|PTR
operator|||
name|rtp
operator|->
name|t_tspec
operator|!=
name|PTR
condition|)
name|lerror
argument_list|(
literal|"illptrc() 1"
argument_list|)
expr_stmt|;
name|lt
operator|=
name|ltp
operator|->
name|t_subt
operator|->
name|t_tspec
expr_stmt|;
name|rt
operator|=
name|rtp
operator|->
name|t_subt
operator|->
name|t_tspec
expr_stmt|;
if|if
condition|(
operator|(
name|lt
operator|==
name|STRUCT
operator|||
name|lt
operator|==
name|UNION
operator|)
operator|&&
operator|(
name|rt
operator|==
name|STRUCT
operator|||
name|rt
operator|==
name|UNION
operator|)
condition|)
block|{
if|if
condition|(
name|mp
operator|==
name|NULL
condition|)
block|{
comment|/* illegal structure pointer combination */
name|warning
argument_list|(
literal|244
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* illegal structure pointer combination, op %s */
name|warning
argument_list|(
literal|245
argument_list|,
name|mp
operator|->
name|m_name
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|mp
operator|==
name|NULL
condition|)
block|{
comment|/* illegal pointer combination */
name|warning
argument_list|(
literal|184
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* illegal pointer combination, op %s */
name|warning
argument_list|(
literal|124
argument_list|,
name|mp
operator|->
name|m_name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * Make sure type (*tpp)->t_subt has at least the qualifiers  * of tp1->t_subt and tp2->t_subt.  */
end_comment

begin_function
specifier|static
name|void
name|mrgqual
parameter_list|(
name|tpp
parameter_list|,
name|tp1
parameter_list|,
name|tp2
parameter_list|)
name|type_t
modifier|*
modifier|*
name|tpp
decl_stmt|,
decl|*
name|tp1
decl_stmt|,
modifier|*
name|tp2
decl_stmt|;
end_function

begin_block
block|{
if|if
condition|(
operator|(
operator|*
name|tpp
operator|)
operator|->
name|t_tspec
operator|!=
name|PTR
operator|||
name|tp1
operator|->
name|t_tspec
operator|!=
name|PTR
operator|||
name|tp2
operator|->
name|t_tspec
operator|!=
name|PTR
condition|)
block|{
name|lerror
argument_list|(
literal|"mrgqual()"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|*
name|tpp
operator|)
operator|->
name|t_subt
operator|->
name|t_const
operator|==
operator|(
name|tp1
operator|->
name|t_subt
operator|->
name|t_const
operator||
name|tp2
operator|->
name|t_subt
operator|->
name|t_const
operator|)
operator|&&
operator|(
operator|*
name|tpp
operator|)
operator|->
name|t_subt
operator|->
name|t_volatile
operator|==
operator|(
name|tp1
operator|->
name|t_subt
operator|->
name|t_volatile
operator||
name|tp2
operator|->
name|t_subt
operator|->
name|t_volatile
operator|)
condition|)
block|{
return|return;
block|}
operator|*
name|tpp
operator|=
name|tduptyp
argument_list|(
operator|*
name|tpp
argument_list|)
expr_stmt|;
operator|(
operator|*
name|tpp
operator|)
operator|->
name|t_subt
operator|=
name|tduptyp
argument_list|(
operator|(
operator|*
name|tpp
operator|)
operator|->
name|t_subt
argument_list|)
expr_stmt|;
operator|(
operator|*
name|tpp
operator|)
operator|->
name|t_subt
operator|->
name|t_const
operator|=
name|tp1
operator|->
name|t_subt
operator|->
name|t_const
operator||
name|tp2
operator|->
name|t_subt
operator|->
name|t_const
expr_stmt|;
operator|(
operator|*
name|tpp
operator|)
operator|->
name|t_subt
operator|->
name|t_volatile
operator|=
name|tp1
operator|->
name|t_subt
operator|->
name|t_volatile
operator||
name|tp2
operator|->
name|t_subt
operator|->
name|t_volatile
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Returns 1 if the given structure or union has a constant member  * (maybe recursively).  */
end_comment

begin_function
specifier|static
name|int
name|conmemb
parameter_list|(
name|tp
parameter_list|)
name|type_t
modifier|*
name|tp
decl_stmt|;
block|{
name|sym_t
modifier|*
name|m
decl_stmt|;
name|tspec_t
name|t
decl_stmt|;
if|if
condition|(
operator|(
name|t
operator|=
name|tp
operator|->
name|t_tspec
operator|)
operator|!=
name|STRUCT
operator|&&
name|t
operator|!=
name|UNION
condition|)
name|lerror
argument_list|(
literal|"conmemb()"
argument_list|)
expr_stmt|;
for|for
control|(
name|m
operator|=
name|tp
operator|->
name|t_str
operator|->
name|memb
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|s_nxt
control|)
block|{
name|tp
operator|=
name|m
operator|->
name|s_type
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_const
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
operator|(
name|t
operator|=
name|tp
operator|->
name|t_tspec
operator|)
operator|==
name|STRUCT
operator|||
name|t
operator|==
name|UNION
condition|)
block|{
if|if
condition|(
name|conmemb
argument_list|(
name|m
operator|->
name|s_type
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|tyname
parameter_list|(
name|tp
parameter_list|)
name|type_t
modifier|*
name|tp
decl_stmt|;
block|{
name|tspec_t
name|t
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
operator|(
name|t
operator|=
name|tp
operator|->
name|t_tspec
operator|)
operator|==
name|INT
operator|&&
name|tp
operator|->
name|t_isenum
condition|)
name|t
operator|=
name|ENUM
expr_stmt|;
switch|switch
condition|(
name|t
condition|)
block|{
case|case
name|CHAR
case|:
name|s
operator|=
literal|"char"
expr_stmt|;
break|break;
case|case
name|UCHAR
case|:
name|s
operator|=
literal|"unsigned char"
expr_stmt|;
break|break;
case|case
name|SCHAR
case|:
name|s
operator|=
literal|"signed char"
expr_stmt|;
break|break;
case|case
name|SHORT
case|:
name|s
operator|=
literal|"short"
expr_stmt|;
break|break;
case|case
name|USHORT
case|:
name|s
operator|=
literal|"unsigned short"
expr_stmt|;
break|break;
case|case
name|INT
case|:
name|s
operator|=
literal|"int"
expr_stmt|;
break|break;
case|case
name|UINT
case|:
name|s
operator|=
literal|"unsigned int"
expr_stmt|;
break|break;
case|case
name|LONG
case|:
name|s
operator|=
literal|"long"
expr_stmt|;
break|break;
case|case
name|ULONG
case|:
name|s
operator|=
literal|"unsigned long"
expr_stmt|;
break|break;
case|case
name|QUAD
case|:
name|s
operator|=
literal|"long long"
expr_stmt|;
break|break;
case|case
name|UQUAD
case|:
name|s
operator|=
literal|"unsigned long long"
expr_stmt|;
break|break;
case|case
name|FLOAT
case|:
name|s
operator|=
literal|"float"
expr_stmt|;
break|break;
case|case
name|DOUBLE
case|:
name|s
operator|=
literal|"double"
expr_stmt|;
break|break;
case|case
name|LDOUBLE
case|:
name|s
operator|=
literal|"long double"
expr_stmt|;
break|break;
case|case
name|PTR
case|:
name|s
operator|=
literal|"pointer"
expr_stmt|;
break|break;
case|case
name|ENUM
case|:
name|s
operator|=
literal|"enum"
expr_stmt|;
break|break;
case|case
name|STRUCT
case|:
name|s
operator|=
literal|"struct"
expr_stmt|;
break|break;
case|case
name|UNION
case|:
name|s
operator|=
literal|"union"
expr_stmt|;
break|break;
case|case
name|FUNC
case|:
name|s
operator|=
literal|"function"
expr_stmt|;
break|break;
case|case
name|ARRAY
case|:
name|s
operator|=
literal|"array"
expr_stmt|;
break|break;
default|default:
name|lerror
argument_list|(
literal|"tyname()"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|s
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create a new node for one of the operators POINT and ARROW.  */
end_comment

begin_function
specifier|static
name|tnode_t
modifier|*
name|bldstr
parameter_list|(
name|op
parameter_list|,
name|ln
parameter_list|,
name|rn
parameter_list|)
name|op_t
name|op
decl_stmt|;
name|tnode_t
modifier|*
name|ln
decl_stmt|,
decl|*
name|rn
decl_stmt|;
end_function

begin_block
block|{
name|tnode_t
modifier|*
name|ntn
decl_stmt|,
modifier|*
name|ctn
decl_stmt|;
name|int
name|nolval
decl_stmt|;
if|if
condition|(
name|rn
operator|->
name|tn_op
operator|!=
name|NAME
condition|)
name|lerror
argument_list|(
literal|"bldstr() 1"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rn
operator|->
name|tn_sym
operator|->
name|s_value
operator|.
name|v_tspec
operator|!=
name|INT
condition|)
name|lerror
argument_list|(
literal|"bldstr() 2"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rn
operator|->
name|tn_sym
operator|->
name|s_scl
operator|!=
name|MOS
operator|&&
name|rn
operator|->
name|tn_sym
operator|->
name|s_scl
operator|!=
name|MOU
condition|)
name|lerror
argument_list|(
literal|"bldstr() 3"
argument_list|)
expr_stmt|;
comment|/* 	 * Remember if the left operand is an lvalue (structure members 	 * are lvalues if and only if the structure itself is an lvalue). 	 */
name|nolval
operator|=
name|op
operator|==
name|POINT
operator|&&
operator|!
name|ln
operator|->
name|tn_lvalue
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|POINT
condition|)
block|{
name|ln
operator|=
name|bldamper
argument_list|(
name|ln
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ln
operator|->
name|tn_type
operator|->
name|t_tspec
operator|!=
name|PTR
condition|)
block|{
if|if
condition|(
operator|!
name|tflag
operator|||
operator|!
name|isityp
argument_list|(
name|ln
operator|->
name|tn_type
operator|->
name|t_tspec
argument_list|)
condition|)
name|lerror
argument_list|(
literal|"bldstr() 4"
argument_list|)
expr_stmt|;
name|ln
operator|=
name|convert
argument_list|(
name|NOOP
argument_list|,
literal|0
argument_list|,
name|tincref
argument_list|(
name|gettyp
argument_list|(
name|VOID
argument_list|)
argument_list|,
name|PTR
argument_list|)
argument_list|,
name|ln
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|PTRDIFF_IS_LONG
name|ctn
operator|=
name|getinode
argument_list|(
name|LONG
argument_list|,
name|rn
operator|->
name|tn_sym
operator|->
name|s_value
operator|.
name|v_quad
operator|/
name|CHAR_BIT
argument_list|)
expr_stmt|;
else|#
directive|else
name|ctn
operator|=
name|getinode
argument_list|(
name|INT
argument_list|,
name|rn
operator|->
name|tn_sym
operator|->
name|s_value
operator|.
name|v_quad
operator|/
name|CHAR_BIT
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ntn
operator|=
name|mktnode
argument_list|(
name|PLUS
argument_list|,
name|tincref
argument_list|(
name|rn
operator|->
name|tn_type
argument_list|,
name|PTR
argument_list|)
argument_list|,
name|ln
argument_list|,
name|ctn
argument_list|)
expr_stmt|;
if|if
condition|(
name|ln
operator|->
name|tn_op
operator|==
name|CON
condition|)
name|ntn
operator|=
name|fold
argument_list|(
name|ntn
argument_list|)
expr_stmt|;
if|if
condition|(
name|rn
operator|->
name|tn_type
operator|->
name|t_isfield
condition|)
block|{
name|ntn
operator|=
name|mktnode
argument_list|(
name|FSEL
argument_list|,
name|ntn
operator|->
name|tn_type
operator|->
name|t_subt
argument_list|,
name|ntn
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ntn
operator|=
name|mktnode
argument_list|(
name|STAR
argument_list|,
name|ntn
operator|->
name|tn_type
operator|->
name|t_subt
argument_list|,
name|ntn
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nolval
condition|)
name|ntn
operator|->
name|tn_lvalue
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|ntn
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Create a node for INCAFT, INCBEF, DECAFT and DECBEF.  */
end_comment

begin_function
specifier|static
name|tnode_t
modifier|*
name|bldincdec
parameter_list|(
name|op
parameter_list|,
name|ln
parameter_list|)
name|op_t
name|op
decl_stmt|;
name|tnode_t
modifier|*
name|ln
decl_stmt|;
block|{
name|tnode_t
modifier|*
name|cn
decl_stmt|,
modifier|*
name|ntn
decl_stmt|;
if|if
condition|(
name|ln
operator|==
name|NULL
condition|)
name|lerror
argument_list|(
literal|"bldincdec() 1"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ln
operator|->
name|tn_type
operator|->
name|t_tspec
operator|==
name|PTR
condition|)
block|{
name|cn
operator|=
name|plength
argument_list|(
name|ln
operator|->
name|tn_type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cn
operator|=
name|getinode
argument_list|(
name|INT
argument_list|,
operator|(
name|quad_t
operator|)
literal|1
argument_list|)
expr_stmt|;
block|}
name|ntn
operator|=
name|mktnode
argument_list|(
name|op
argument_list|,
name|ln
operator|->
name|tn_type
argument_list|,
name|ln
argument_list|,
name|cn
argument_list|)
expr_stmt|;
return|return
operator|(
name|ntn
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create a tree node for the& operator  */
end_comment

begin_function
specifier|static
name|tnode_t
modifier|*
name|bldamper
parameter_list|(
name|tn
parameter_list|,
name|noign
parameter_list|)
name|tnode_t
modifier|*
name|tn
decl_stmt|;
name|int
name|noign
decl_stmt|;
block|{
name|tnode_t
modifier|*
name|ntn
decl_stmt|;
name|tspec_t
name|t
decl_stmt|;
if|if
condition|(
operator|!
name|noign
operator|&&
operator|(
operator|(
name|t
operator|=
name|tn
operator|->
name|tn_type
operator|->
name|t_tspec
operator|)
operator|==
name|ARRAY
operator|||
name|t
operator|==
name|FUNC
operator|)
condition|)
block|{
comment|/*& before array or function: ignored */
if|if
condition|(
name|tflag
condition|)
name|warning
argument_list|(
literal|127
argument_list|)
expr_stmt|;
return|return
operator|(
name|tn
operator|)
return|;
block|}
comment|/* eliminate&* */
if|if
condition|(
name|tn
operator|->
name|tn_op
operator|==
name|STAR
operator|&&
name|tn
operator|->
name|tn_left
operator|->
name|tn_type
operator|->
name|t_tspec
operator|==
name|PTR
operator|&&
name|tn
operator|->
name|tn_left
operator|->
name|tn_type
operator|->
name|t_subt
operator|==
name|tn
operator|->
name|tn_type
condition|)
block|{
return|return
operator|(
name|tn
operator|->
name|tn_left
operator|)
return|;
block|}
name|ntn
operator|=
name|mktnode
argument_list|(
name|AMPER
argument_list|,
name|tincref
argument_list|(
name|tn
operator|->
name|tn_type
argument_list|,
name|PTR
argument_list|)
argument_list|,
name|tn
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|ntn
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create a node for operators PLUS and MINUS.  */
end_comment

begin_function
specifier|static
name|tnode_t
modifier|*
name|bldplmi
parameter_list|(
name|op
parameter_list|,
name|ln
parameter_list|,
name|rn
parameter_list|)
name|op_t
name|op
decl_stmt|;
name|tnode_t
modifier|*
name|ln
decl_stmt|,
decl|*
name|rn
decl_stmt|;
end_function

begin_block
block|{
name|tnode_t
modifier|*
name|ntn
decl_stmt|,
modifier|*
name|ctn
decl_stmt|;
name|type_t
modifier|*
name|tp
decl_stmt|;
comment|/* If pointer and integer, then pointer to the lhs. */
if|if
condition|(
name|rn
operator|->
name|tn_type
operator|->
name|t_tspec
operator|==
name|PTR
operator|&&
name|isityp
argument_list|(
name|ln
operator|->
name|tn_type
operator|->
name|t_tspec
argument_list|)
condition|)
block|{
name|ntn
operator|=
name|ln
expr_stmt|;
name|ln
operator|=
name|rn
expr_stmt|;
name|rn
operator|=
name|ntn
expr_stmt|;
block|}
if|if
condition|(
name|ln
operator|->
name|tn_type
operator|->
name|t_tspec
operator|==
name|PTR
operator|&&
name|rn
operator|->
name|tn_type
operator|->
name|t_tspec
operator|!=
name|PTR
condition|)
block|{
if|if
condition|(
operator|!
name|isityp
argument_list|(
name|rn
operator|->
name|tn_type
operator|->
name|t_tspec
argument_list|)
condition|)
name|lerror
argument_list|(
literal|"bldplmi() 1"
argument_list|)
expr_stmt|;
name|ctn
operator|=
name|plength
argument_list|(
name|ln
operator|->
name|tn_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|rn
operator|->
name|tn_type
operator|->
name|t_tspec
operator|!=
name|ctn
operator|->
name|tn_type
operator|->
name|t_tspec
condition|)
name|rn
operator|=
name|convert
argument_list|(
name|NOOP
argument_list|,
literal|0
argument_list|,
name|ctn
operator|->
name|tn_type
argument_list|,
name|rn
argument_list|)
expr_stmt|;
name|rn
operator|=
name|mktnode
argument_list|(
name|MULT
argument_list|,
name|rn
operator|->
name|tn_type
argument_list|,
name|rn
argument_list|,
name|ctn
argument_list|)
expr_stmt|;
if|if
condition|(
name|rn
operator|->
name|tn_left
operator|->
name|tn_op
operator|==
name|CON
condition|)
name|rn
operator|=
name|fold
argument_list|(
name|rn
argument_list|)
expr_stmt|;
name|ntn
operator|=
name|mktnode
argument_list|(
name|op
argument_list|,
name|ln
operator|->
name|tn_type
argument_list|,
name|ln
argument_list|,
name|rn
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rn
operator|->
name|tn_type
operator|->
name|t_tspec
operator|==
name|PTR
condition|)
block|{
if|if
condition|(
name|ln
operator|->
name|tn_type
operator|->
name|t_tspec
operator|!=
name|PTR
operator|||
name|op
operator|!=
name|MINUS
condition|)
name|lerror
argument_list|(
literal|"bldplmi() 2"
argument_list|)
expr_stmt|;
if|#
directive|if
name|PTRDIFF_IS_LONG
name|tp
operator|=
name|gettyp
argument_list|(
name|LONG
argument_list|)
expr_stmt|;
else|#
directive|else
name|tp
operator|=
name|gettyp
argument_list|(
name|INT
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ntn
operator|=
name|mktnode
argument_list|(
name|op
argument_list|,
name|tp
argument_list|,
name|ln
argument_list|,
name|rn
argument_list|)
expr_stmt|;
if|if
condition|(
name|ln
operator|->
name|tn_op
operator|==
name|CON
operator|&&
name|rn
operator|->
name|tn_op
operator|==
name|CON
condition|)
name|ntn
operator|=
name|fold
argument_list|(
name|ntn
argument_list|)
expr_stmt|;
name|ctn
operator|=
name|plength
argument_list|(
name|ln
operator|->
name|tn_type
argument_list|)
expr_stmt|;
name|balance
argument_list|(
name|NOOP
argument_list|,
operator|&
name|ntn
argument_list|,
operator|&
name|ctn
argument_list|)
expr_stmt|;
name|ntn
operator|=
name|mktnode
argument_list|(
name|DIV
argument_list|,
name|tp
argument_list|,
name|ntn
argument_list|,
name|ctn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ntn
operator|=
name|mktnode
argument_list|(
name|op
argument_list|,
name|ln
operator|->
name|tn_type
argument_list|,
name|ln
argument_list|,
name|rn
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ntn
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Create a node for operators SHL and SHR.  */
end_comment

begin_function
specifier|static
name|tnode_t
modifier|*
name|bldshft
parameter_list|(
name|op
parameter_list|,
name|ln
parameter_list|,
name|rn
parameter_list|)
name|op_t
name|op
decl_stmt|;
name|tnode_t
modifier|*
name|ln
decl_stmt|,
decl|*
name|rn
decl_stmt|;
end_function

begin_block
block|{
name|tspec_t
name|t
decl_stmt|;
name|tnode_t
modifier|*
name|ntn
decl_stmt|;
if|if
condition|(
operator|(
name|t
operator|=
name|rn
operator|->
name|tn_type
operator|->
name|t_tspec
operator|)
operator|!=
name|INT
operator|&&
name|t
operator|!=
name|UINT
condition|)
name|rn
operator|=
name|convert
argument_list|(
name|CVT
argument_list|,
literal|0
argument_list|,
name|gettyp
argument_list|(
name|INT
argument_list|)
argument_list|,
name|rn
argument_list|)
expr_stmt|;
name|ntn
operator|=
name|mktnode
argument_list|(
name|op
argument_list|,
name|ln
operator|->
name|tn_type
argument_list|,
name|ln
argument_list|,
name|rn
argument_list|)
expr_stmt|;
return|return
operator|(
name|ntn
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Create a node for COLON.  */
end_comment

begin_function
specifier|static
name|tnode_t
modifier|*
name|bldcol
parameter_list|(
name|ln
parameter_list|,
name|rn
parameter_list|)
name|tnode_t
modifier|*
name|ln
decl_stmt|,
decl|*
name|rn
decl_stmt|;
end_function

begin_block
block|{
name|tspec_t
name|lt
decl_stmt|,
name|rt
decl_stmt|,
name|pdt
decl_stmt|;
name|type_t
modifier|*
name|rtp
decl_stmt|;
name|tnode_t
modifier|*
name|ntn
decl_stmt|;
name|lt
operator|=
name|ln
operator|->
name|tn_type
operator|->
name|t_tspec
expr_stmt|;
name|rt
operator|=
name|rn
operator|->
name|tn_type
operator|->
name|t_tspec
expr_stmt|;
if|#
directive|if
name|PTRDIFF_IS_LONG
name|pdt
operator|=
name|LONG
expr_stmt|;
else|#
directive|else
name|pdt
operator|=
name|INT
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Arithmetic types are balanced, all other type combinations 	 * still need to be handled. 	 */
if|if
condition|(
name|isatyp
argument_list|(
name|lt
argument_list|)
operator|&&
name|isatyp
argument_list|(
name|rt
argument_list|)
condition|)
block|{
name|rtp
operator|=
name|ln
operator|->
name|tn_type
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lt
operator|==
name|VOID
operator|||
name|rt
operator|==
name|VOID
condition|)
block|{
name|rtp
operator|=
name|gettyp
argument_list|(
name|VOID
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lt
operator|==
name|STRUCT
operator|||
name|lt
operator|==
name|UNION
condition|)
block|{
comment|/* Both types must be identical. */
if|if
condition|(
name|rt
operator|!=
name|STRUCT
operator|&&
name|rt
operator|!=
name|UNION
condition|)
name|lerror
argument_list|(
literal|"bldcol() 1"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ln
operator|->
name|tn_type
operator|->
name|t_str
operator|!=
name|rn
operator|->
name|tn_type
operator|->
name|t_str
condition|)
name|lerror
argument_list|(
literal|"bldcol() 2"
argument_list|)
expr_stmt|;
if|if
condition|(
name|incompl
argument_list|(
name|ln
operator|->
name|tn_type
argument_list|)
condition|)
block|{
comment|/* unknown operand size, op %s */
name|error
argument_list|(
literal|138
argument_list|,
name|modtab
index|[
name|COLON
index|]
operator|.
name|m_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|rtp
operator|=
name|ln
operator|->
name|tn_type
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lt
operator|==
name|PTR
operator|&&
name|isityp
argument_list|(
name|rt
argument_list|)
condition|)
block|{
if|if
condition|(
name|rt
operator|!=
name|pdt
condition|)
block|{
name|rn
operator|=
name|convert
argument_list|(
name|NOOP
argument_list|,
literal|0
argument_list|,
name|gettyp
argument_list|(
name|pdt
argument_list|)
argument_list|,
name|rn
argument_list|)
expr_stmt|;
name|rt
operator|=
name|pdt
expr_stmt|;
block|}
name|rtp
operator|=
name|ln
operator|->
name|tn_type
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rt
operator|==
name|PTR
operator|&&
name|isityp
argument_list|(
name|lt
argument_list|)
condition|)
block|{
if|if
condition|(
name|lt
operator|!=
name|pdt
condition|)
block|{
name|ln
operator|=
name|convert
argument_list|(
name|NOOP
argument_list|,
literal|0
argument_list|,
name|gettyp
argument_list|(
name|pdt
argument_list|)
argument_list|,
name|ln
argument_list|)
expr_stmt|;
name|lt
operator|=
name|pdt
expr_stmt|;
block|}
name|rtp
operator|=
name|rn
operator|->
name|tn_type
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lt
operator|==
name|PTR
operator|&&
name|ln
operator|->
name|tn_type
operator|->
name|t_subt
operator|->
name|t_tspec
operator|==
name|VOID
condition|)
block|{
if|if
condition|(
name|rt
operator|!=
name|PTR
condition|)
name|lerror
argument_list|(
literal|"bldcol() 4"
argument_list|)
expr_stmt|;
name|rtp
operator|=
name|ln
operator|->
name|tn_type
expr_stmt|;
name|mrgqual
argument_list|(
operator|&
name|rtp
argument_list|,
name|ln
operator|->
name|tn_type
argument_list|,
name|rn
operator|->
name|tn_type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rt
operator|==
name|PTR
operator|&&
name|rn
operator|->
name|tn_type
operator|->
name|t_subt
operator|->
name|t_tspec
operator|==
name|VOID
condition|)
block|{
if|if
condition|(
name|lt
operator|!=
name|PTR
condition|)
name|lerror
argument_list|(
literal|"bldcol() 5"
argument_list|)
expr_stmt|;
name|rtp
operator|=
name|rn
operator|->
name|tn_type
expr_stmt|;
name|mrgqual
argument_list|(
operator|&
name|rtp
argument_list|,
name|ln
operator|->
name|tn_type
argument_list|,
name|rn
operator|->
name|tn_type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|lt
operator|!=
name|PTR
operator|||
name|rt
operator|!=
name|PTR
condition|)
name|lerror
argument_list|(
literal|"bldcol() 6"
argument_list|)
expr_stmt|;
comment|/* 		 * XXX For now we simply take the left type. This is 		 * probably wrong, if one type contains a functionprototype 		 * and the other one, at the same place, only an old style 		 * declaration. 		 */
name|rtp
operator|=
name|ln
operator|->
name|tn_type
expr_stmt|;
name|mrgqual
argument_list|(
operator|&
name|rtp
argument_list|,
name|ln
operator|->
name|tn_type
argument_list|,
name|rn
operator|->
name|tn_type
argument_list|)
expr_stmt|;
block|}
name|ntn
operator|=
name|mktnode
argument_list|(
name|COLON
argument_list|,
name|rtp
argument_list|,
name|ln
argument_list|,
name|rn
argument_list|)
expr_stmt|;
return|return
operator|(
name|ntn
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Create a node for an assignment operator (both = and op= ).  */
end_comment

begin_function
specifier|static
name|tnode_t
modifier|*
name|bldasgn
parameter_list|(
name|op
parameter_list|,
name|ln
parameter_list|,
name|rn
parameter_list|)
name|op_t
name|op
decl_stmt|;
name|tnode_t
modifier|*
name|ln
decl_stmt|,
decl|*
name|rn
decl_stmt|;
end_function

begin_block
block|{
name|tspec_t
name|lt
decl_stmt|,
name|rt
decl_stmt|;
name|tnode_t
modifier|*
name|ntn
decl_stmt|,
modifier|*
name|ctn
decl_stmt|;
if|if
condition|(
name|ln
operator|==
name|NULL
operator|||
name|rn
operator|==
name|NULL
condition|)
name|lerror
argument_list|(
literal|"bldasgn() 1"
argument_list|)
expr_stmt|;
name|lt
operator|=
name|ln
operator|->
name|tn_type
operator|->
name|t_tspec
expr_stmt|;
name|rt
operator|=
name|rn
operator|->
name|tn_type
operator|->
name|t_tspec
expr_stmt|;
if|if
condition|(
operator|(
name|op
operator|==
name|ADDASS
operator|||
name|op
operator|==
name|SUBASS
operator|)
operator|&&
name|lt
operator|==
name|PTR
condition|)
block|{
if|if
condition|(
operator|!
name|isityp
argument_list|(
name|rt
argument_list|)
condition|)
name|lerror
argument_list|(
literal|"bldasgn() 2"
argument_list|)
expr_stmt|;
name|ctn
operator|=
name|plength
argument_list|(
name|ln
operator|->
name|tn_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|rn
operator|->
name|tn_type
operator|->
name|t_tspec
operator|!=
name|ctn
operator|->
name|tn_type
operator|->
name|t_tspec
condition|)
name|rn
operator|=
name|convert
argument_list|(
name|NOOP
argument_list|,
literal|0
argument_list|,
name|ctn
operator|->
name|tn_type
argument_list|,
name|rn
argument_list|)
expr_stmt|;
name|rn
operator|=
name|mktnode
argument_list|(
name|MULT
argument_list|,
name|rn
operator|->
name|tn_type
argument_list|,
name|rn
argument_list|,
name|ctn
argument_list|)
expr_stmt|;
if|if
condition|(
name|rn
operator|->
name|tn_left
operator|->
name|tn_op
operator|==
name|CON
condition|)
name|rn
operator|=
name|fold
argument_list|(
name|rn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|op
operator|==
name|ASSIGN
operator|||
name|op
operator|==
name|RETURN
operator|)
operator|&&
operator|(
name|lt
operator|==
name|STRUCT
operator|||
name|rt
operator|==
name|STRUCT
operator|)
condition|)
block|{
if|if
condition|(
name|rt
operator|!=
name|lt
operator|||
name|ln
operator|->
name|tn_type
operator|->
name|t_str
operator|!=
name|rn
operator|->
name|tn_type
operator|->
name|t_str
condition|)
name|lerror
argument_list|(
literal|"bldasgn() 3"
argument_list|)
expr_stmt|;
if|if
condition|(
name|incompl
argument_list|(
name|ln
operator|->
name|tn_type
argument_list|)
condition|)
block|{
if|if
condition|(
name|op
operator|==
name|RETURN
condition|)
block|{
comment|/* cannot return incomplete type */
name|error
argument_list|(
literal|212
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* unknown operand size, op %s */
name|error
argument_list|(
literal|138
argument_list|,
name|modtab
index|[
name|op
index|]
operator|.
name|m_name
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
if|if
condition|(
name|op
operator|==
name|SHLASS
operator|||
name|op
operator|==
name|SHRASS
condition|)
block|{
if|if
condition|(
name|rt
operator|!=
name|INT
condition|)
block|{
name|rn
operator|=
name|convert
argument_list|(
name|NOOP
argument_list|,
literal|0
argument_list|,
name|gettyp
argument_list|(
name|INT
argument_list|)
argument_list|,
name|rn
argument_list|)
expr_stmt|;
name|rt
operator|=
name|INT
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|op
operator|==
name|ASSIGN
operator|||
name|lt
operator|!=
name|PTR
condition|)
block|{
if|if
condition|(
name|lt
operator|!=
name|rt
operator|||
operator|(
name|ln
operator|->
name|tn_type
operator|->
name|t_isfield
operator|&&
name|rn
operator|->
name|tn_op
operator|==
name|CON
operator|)
condition|)
block|{
name|rn
operator|=
name|convert
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
name|ln
operator|->
name|tn_type
argument_list|,
name|rn
argument_list|)
expr_stmt|;
name|rt
operator|=
name|lt
expr_stmt|;
block|}
block|}
block|}
name|ntn
operator|=
name|mktnode
argument_list|(
name|op
argument_list|,
name|ln
operator|->
name|tn_type
argument_list|,
name|ln
argument_list|,
name|rn
argument_list|)
expr_stmt|;
return|return
operator|(
name|ntn
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Get length of type tp->t_subt.  */
end_comment

begin_function
specifier|static
name|tnode_t
modifier|*
name|plength
parameter_list|(
name|tp
parameter_list|)
name|type_t
modifier|*
name|tp
decl_stmt|;
block|{
name|int
name|elem
decl_stmt|,
name|elsz
decl_stmt|;
name|tspec_t
name|st
decl_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_tspec
operator|!=
name|PTR
condition|)
name|lerror
argument_list|(
literal|"plength() 1"
argument_list|)
expr_stmt|;
name|tp
operator|=
name|tp
operator|->
name|t_subt
expr_stmt|;
name|elem
operator|=
literal|1
expr_stmt|;
name|elsz
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|tp
operator|->
name|t_tspec
operator|==
name|ARRAY
condition|)
block|{
name|elem
operator|*=
name|tp
operator|->
name|t_dim
expr_stmt|;
name|tp
operator|=
name|tp
operator|->
name|t_subt
expr_stmt|;
block|}
switch|switch
condition|(
name|tp
operator|->
name|t_tspec
condition|)
block|{
case|case
name|FUNC
case|:
comment|/* pointer to function is not allowed here */
name|error
argument_list|(
literal|110
argument_list|)
expr_stmt|;
break|break;
case|case
name|VOID
case|:
comment|/* cannot do pointer arithmetic on operand of ... */
operator|(
name|void
operator|)
name|gnuism
argument_list|(
literal|136
argument_list|)
expr_stmt|;
break|break;
case|case
name|STRUCT
case|:
case|case
name|UNION
case|:
if|if
condition|(
operator|(
name|elsz
operator|=
name|tp
operator|->
name|t_str
operator|->
name|size
operator|)
operator|==
literal|0
condition|)
comment|/* cannot do pointer arithmetic on operand of ... */
name|error
argument_list|(
literal|136
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENUM
case|:
if|if
condition|(
name|incompl
argument_list|(
name|tp
argument_list|)
condition|)
block|{
comment|/* cannot do pointer arithmetic on operand of ... */
name|warning
argument_list|(
literal|136
argument_list|)
expr_stmt|;
block|}
comment|/* FALLTHROUGH */
default|default:
if|if
condition|(
operator|(
name|elsz
operator|=
name|size
argument_list|(
name|tp
operator|->
name|t_tspec
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* cannot do pointer arithmetic on operand of ... */
name|error
argument_list|(
literal|136
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|elsz
operator|==
operator|-
literal|1
condition|)
block|{
name|lerror
argument_list|(
literal|"plength() 2"
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|elem
operator|==
literal|0
operator|&&
name|elsz
operator|!=
literal|0
condition|)
block|{
comment|/* cannot do pointer arithmetic on operand of ... */
name|error
argument_list|(
literal|136
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|elsz
operator|==
literal|0
condition|)
name|elsz
operator|=
name|CHAR_BIT
expr_stmt|;
if|#
directive|if
name|PTRDIFF_IS_LONG
name|st
operator|=
name|LONG
expr_stmt|;
else|#
directive|else
name|st
operator|=
name|INT
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|getinode
argument_list|(
name|st
argument_list|,
call|(
name|quad_t
call|)
argument_list|(
name|elem
operator|*
name|elsz
operator|/
name|CHAR_BIT
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|XXX_BROKEN_GCC
end_ifdef

begin_function
specifier|static
name|int
name|quad_t_eq
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
name|quad_t
name|x
decl_stmt|,
name|y
decl_stmt|;
block|{
return|return
operator|(
name|x
operator|==
name|y
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|u_quad_t_eq
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
name|u_quad_t
name|x
decl_stmt|,
name|y
decl_stmt|;
block|{
return|return
operator|(
name|x
operator|==
name|y
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Do only as much as necessary to compute constant expressions.  * Called only if the operator allows folding and (both) operands  * are constants.  */
end_comment

begin_function
specifier|static
name|tnode_t
modifier|*
name|fold
parameter_list|(
name|tn
parameter_list|)
name|tnode_t
modifier|*
name|tn
decl_stmt|;
block|{
name|val_t
modifier|*
name|v
decl_stmt|;
name|tspec_t
name|t
decl_stmt|;
name|int
name|utyp
decl_stmt|,
name|ovfl
decl_stmt|;
name|quad_t
name|sl
decl_stmt|,
name|sr
decl_stmt|,
name|q
decl_stmt|,
name|mask
decl_stmt|;
name|u_quad_t
name|ul
decl_stmt|,
name|ur
decl_stmt|;
name|tnode_t
modifier|*
name|cn
decl_stmt|;
name|v
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|val_t
argument_list|)
argument_list|)
expr_stmt|;
name|v
operator|->
name|v_tspec
operator|=
name|t
operator|=
name|tn
operator|->
name|tn_type
operator|->
name|t_tspec
expr_stmt|;
name|utyp
operator|=
name|t
operator|==
name|PTR
operator|||
name|isutyp
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|ul
operator|=
name|sl
operator|=
name|tn
operator|->
name|tn_left
operator|->
name|tn_val
operator|->
name|v_quad
expr_stmt|;
if|if
condition|(
name|modtab
index|[
name|tn
operator|->
name|tn_op
index|]
operator|.
name|m_binary
condition|)
name|ur
operator|=
name|sr
operator|=
name|tn
operator|->
name|tn_right
operator|->
name|tn_val
operator|->
name|v_quad
expr_stmt|;
name|ovfl
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|tn
operator|->
name|tn_op
condition|)
block|{
case|case
name|UPLUS
case|:
name|q
operator|=
name|sl
expr_stmt|;
break|break;
case|case
name|UMINUS
case|:
name|q
operator|=
operator|-
name|sl
expr_stmt|;
if|if
condition|(
name|msb
argument_list|(
name|q
argument_list|,
name|t
argument_list|,
operator|-
literal|1
argument_list|)
operator|==
name|msb
argument_list|(
name|sl
argument_list|,
name|t
argument_list|,
operator|-
literal|1
argument_list|)
condition|)
name|ovfl
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|COMPL
case|:
name|q
operator|=
operator|~
name|sl
expr_stmt|;
break|break;
case|case
name|MULT
case|:
name|q
operator|=
name|utyp
condition|?
name|ul
operator|*
name|ur
else|:
name|sl
operator|*
name|sr
expr_stmt|;
if|if
condition|(
name|msb
argument_list|(
name|q
argument_list|,
name|t
argument_list|,
operator|-
literal|1
argument_list|)
operator|!=
operator|(
name|msb
argument_list|(
name|sl
argument_list|,
name|t
argument_list|,
operator|-
literal|1
argument_list|)
operator|^
name|msb
argument_list|(
name|sr
argument_list|,
name|t
argument_list|,
operator|-
literal|1
argument_list|)
operator|)
condition|)
name|ovfl
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|DIV
case|:
if|if
condition|(
name|sr
operator|==
literal|0
condition|)
block|{
comment|/* division by 0 */
name|error
argument_list|(
literal|139
argument_list|)
expr_stmt|;
name|q
operator|=
name|utyp
condition|?
name|UQUAD_MAX
else|:
name|QUAD_MAX
expr_stmt|;
block|}
else|else
block|{
name|q
operator|=
name|utyp
condition|?
name|ul
operator|/
name|ur
else|:
name|sl
operator|/
name|sr
expr_stmt|;
block|}
break|break;
case|case
name|MOD
case|:
if|if
condition|(
name|sr
operator|==
literal|0
condition|)
block|{
comment|/* modulus by 0 */
name|error
argument_list|(
literal|140
argument_list|)
expr_stmt|;
name|q
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|q
operator|=
name|utyp
condition|?
name|ul
operator|%
name|ur
else|:
name|sl
operator|%
name|sr
expr_stmt|;
block|}
break|break;
case|case
name|PLUS
case|:
name|q
operator|=
name|utyp
condition|?
name|ul
operator|+
name|ur
else|:
name|sl
operator|+
name|sr
expr_stmt|;
if|if
condition|(
name|msb
argument_list|(
name|sl
argument_list|,
name|t
argument_list|,
operator|-
literal|1
argument_list|)
operator|!=
literal|0
operator|&&
name|msb
argument_list|(
name|sr
argument_list|,
name|t
argument_list|,
operator|-
literal|1
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|msb
argument_list|(
name|q
argument_list|,
name|t
argument_list|,
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
name|ovfl
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|msb
argument_list|(
name|sl
argument_list|,
name|t
argument_list|,
operator|-
literal|1
argument_list|)
operator|==
literal|0
operator|&&
name|msb
argument_list|(
name|sr
argument_list|,
name|t
argument_list|,
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|msb
argument_list|(
name|q
argument_list|,
name|t
argument_list|,
operator|-
literal|1
argument_list|)
operator|!=
literal|0
condition|)
name|ovfl
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|MINUS
case|:
name|q
operator|=
name|utyp
condition|?
name|ul
operator|-
name|ur
else|:
name|sl
operator|-
name|sr
expr_stmt|;
if|if
condition|(
name|msb
argument_list|(
name|sl
argument_list|,
name|t
argument_list|,
operator|-
literal|1
argument_list|)
operator|!=
literal|0
operator|&&
name|msb
argument_list|(
name|sr
argument_list|,
name|t
argument_list|,
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|msb
argument_list|(
name|q
argument_list|,
name|t
argument_list|,
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
name|ovfl
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|msb
argument_list|(
name|sl
argument_list|,
name|t
argument_list|,
operator|-
literal|1
argument_list|)
operator|==
literal|0
operator|&&
name|msb
argument_list|(
name|sr
argument_list|,
name|t
argument_list|,
operator|-
literal|1
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|msb
argument_list|(
name|q
argument_list|,
name|t
argument_list|,
operator|-
literal|1
argument_list|)
operator|!=
literal|0
condition|)
name|ovfl
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|SHL
case|:
name|q
operator|=
name|utyp
condition|?
name|ul
operator|<<
name|sr
else|:
name|sl
operator|<<
name|sr
expr_stmt|;
break|break;
case|case
name|SHR
case|:
comment|/* 		 * The sign must be explizitly extended because 		 * shifts of signed values are implementation dependent. 		 */
name|q
operator|=
name|ul
operator|>>
name|sr
expr_stmt|;
name|q
operator|=
name|xsign
argument_list|(
name|q
argument_list|,
name|t
argument_list|,
name|size
argument_list|(
name|t
argument_list|)
operator|-
operator|(
name|int
operator|)
name|sr
argument_list|)
expr_stmt|;
break|break;
case|case
name|LT
case|:
name|q
operator|=
name|utyp
condition|?
name|ul
operator|<
name|ur
else|:
name|sl
operator|<
name|sr
expr_stmt|;
break|break;
case|case
name|LE
case|:
name|q
operator|=
name|utyp
condition|?
name|ul
operator|<=
name|ur
else|:
name|sl
operator|<=
name|sr
expr_stmt|;
break|break;
case|case
name|GE
case|:
name|q
operator|=
name|utyp
condition|?
name|ul
operator|>=
name|ur
else|:
name|sl
operator|>=
name|sr
expr_stmt|;
break|break;
case|case
name|GT
case|:
name|q
operator|=
name|utyp
condition|?
name|ul
operator|>
name|ur
else|:
name|sl
operator|>
name|sr
expr_stmt|;
break|break;
case|case
name|EQ
case|:
ifdef|#
directive|ifdef
name|XXX_BROKEN_GCC
name|q
operator|=
name|utyp
condition|?
name|u_quad_t_eq
argument_list|(
name|ul
argument_list|,
name|ur
argument_list|)
else|:
name|quad_t_eq
argument_list|(
name|sl
argument_list|,
name|sr
argument_list|)
expr_stmt|;
else|#
directive|else
name|q
operator|=
name|utyp
condition|?
name|ul
operator|==
name|ur
else|:
name|sl
operator|==
name|sr
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|NE
case|:
name|q
operator|=
name|utyp
condition|?
name|ul
operator|!=
name|ur
else|:
name|sl
operator|!=
name|sr
expr_stmt|;
break|break;
case|case
name|AND
case|:
name|q
operator|=
name|utyp
condition|?
name|ul
operator|&
name|ur
else|:
name|sl
operator|&
name|sr
expr_stmt|;
break|break;
case|case
name|XOR
case|:
name|q
operator|=
name|utyp
condition|?
name|ul
operator|^
name|ur
else|:
name|sl
operator|^
name|sr
expr_stmt|;
break|break;
case|case
name|OR
case|:
name|q
operator|=
name|utyp
condition|?
name|ul
operator||
name|ur
else|:
name|sl
operator||
name|sr
expr_stmt|;
break|break;
default|default:
name|lerror
argument_list|(
literal|"fold() 5"
argument_list|)
expr_stmt|;
block|}
name|mask
operator|=
name|qlmasks
index|[
name|size
argument_list|(
name|t
argument_list|)
index|]
expr_stmt|;
comment|/* XXX does not work for quads. */
if|if
condition|(
name|ovfl
operator|||
operator|(
operator|(
name|q
operator||
name|mask
operator|)
operator|!=
operator|~
operator|(
name|u_quad_t
operator|)
literal|0
operator|&&
operator|(
name|q
operator|&
operator|~
name|mask
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|hflag
condition|)
comment|/* integer overflow detected, op %s */
name|warning
argument_list|(
literal|141
argument_list|,
name|modtab
index|[
name|tn
operator|->
name|tn_op
index|]
operator|.
name|m_name
argument_list|)
expr_stmt|;
block|}
name|v
operator|->
name|v_quad
operator|=
name|xsign
argument_list|(
name|q
argument_list|,
name|t
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|cn
operator|=
name|getcnode
argument_list|(
name|tn
operator|->
name|tn_type
argument_list|,
name|v
argument_list|)
expr_stmt|;
return|return
operator|(
name|cn
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|XXX_BROKEN_GCC
end_ifdef

begin_function
name|int
name|ldbl_t_neq
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
name|ldbl_t
name|x
decl_stmt|,
name|y
decl_stmt|;
block|{
return|return
operator|(
name|x
operator|!=
name|y
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Same for operators whose operands are compared with 0 (test context).  */
end_comment

begin_function
specifier|static
name|tnode_t
modifier|*
name|foldtst
parameter_list|(
name|tn
parameter_list|)
name|tnode_t
modifier|*
name|tn
decl_stmt|;
block|{
name|int
name|l
decl_stmt|,
name|r
decl_stmt|;
name|val_t
modifier|*
name|v
decl_stmt|;
name|v
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|val_t
argument_list|)
argument_list|)
expr_stmt|;
name|v
operator|->
name|v_tspec
operator|=
name|tn
operator|->
name|tn_type
operator|->
name|t_tspec
expr_stmt|;
if|if
condition|(
name|tn
operator|->
name|tn_type
operator|->
name|t_tspec
operator|!=
name|INT
condition|)
name|lerror
argument_list|(
literal|"foldtst() 1"
argument_list|)
expr_stmt|;
if|if
condition|(
name|isftyp
argument_list|(
name|tn
operator|->
name|tn_left
operator|->
name|tn_type
operator|->
name|t_tspec
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|XXX_BROKEN_GCC
name|l
operator|=
name|ldbl_t_neq
argument_list|(
name|tn
operator|->
name|tn_left
operator|->
name|tn_val
operator|->
name|v_ldbl
argument_list|,
literal|0.0
argument_list|)
expr_stmt|;
else|#
directive|else
name|l
operator|=
name|tn
operator|->
name|tn_left
operator|->
name|tn_val
operator|->
name|v_ldbl
operator|!=
literal|0.0
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|l
operator|=
name|tn
operator|->
name|tn_left
operator|->
name|tn_val
operator|->
name|v_quad
operator|!=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|modtab
index|[
name|tn
operator|->
name|tn_op
index|]
operator|.
name|m_binary
condition|)
block|{
if|if
condition|(
name|isftyp
argument_list|(
name|tn
operator|->
name|tn_right
operator|->
name|tn_type
operator|->
name|t_tspec
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|XXX_BROKEN_GCC
name|r
operator|=
name|ldbl_t_neq
argument_list|(
name|tn
operator|->
name|tn_right
operator|->
name|tn_val
operator|->
name|v_ldbl
argument_list|,
literal|0.0
argument_list|)
expr_stmt|;
else|#
directive|else
name|r
operator|=
name|tn
operator|->
name|tn_right
operator|->
name|tn_val
operator|->
name|v_ldbl
operator|!=
literal|0.0
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|r
operator|=
name|tn
operator|->
name|tn_right
operator|->
name|tn_val
operator|->
name|v_quad
operator|!=
literal|0
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|tn
operator|->
name|tn_op
condition|)
block|{
case|case
name|NOT
case|:
if|if
condition|(
name|hflag
condition|)
comment|/* constant argument to NOT */
name|warning
argument_list|(
literal|239
argument_list|)
expr_stmt|;
name|v
operator|->
name|v_quad
operator|=
operator|!
name|l
expr_stmt|;
break|break;
case|case
name|LOGAND
case|:
name|v
operator|->
name|v_quad
operator|=
name|l
operator|&&
name|r
expr_stmt|;
break|break;
case|case
name|LOGOR
case|:
name|v
operator|->
name|v_quad
operator|=
name|l
operator|||
name|r
expr_stmt|;
break|break;
default|default:
name|lerror
argument_list|(
literal|"foldtst() 1"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|getcnode
argument_list|(
name|tn
operator|->
name|tn_type
argument_list|,
name|v
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Same for operands with floating point type.  */
end_comment

begin_function
specifier|static
name|tnode_t
modifier|*
name|foldflt
parameter_list|(
name|tn
parameter_list|)
name|tnode_t
modifier|*
name|tn
decl_stmt|;
block|{
name|val_t
modifier|*
name|v
decl_stmt|;
name|tspec_t
name|t
decl_stmt|;
name|ldbl_t
name|l
decl_stmt|,
name|r
decl_stmt|;
name|v
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|val_t
argument_list|)
argument_list|)
expr_stmt|;
name|v
operator|->
name|v_tspec
operator|=
name|t
operator|=
name|tn
operator|->
name|tn_type
operator|->
name|t_tspec
expr_stmt|;
if|if
condition|(
operator|!
name|isftyp
argument_list|(
name|t
argument_list|)
condition|)
name|lerror
argument_list|(
literal|"foldflt() 1"
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|!=
name|tn
operator|->
name|tn_left
operator|->
name|tn_type
operator|->
name|t_tspec
condition|)
name|lerror
argument_list|(
literal|"foldflt() 2"
argument_list|)
expr_stmt|;
if|if
condition|(
name|modtab
index|[
name|tn
operator|->
name|tn_op
index|]
operator|.
name|m_binary
operator|&&
name|t
operator|!=
name|tn
operator|->
name|tn_right
operator|->
name|tn_type
operator|->
name|t_tspec
condition|)
name|lerror
argument_list|(
literal|"foldflt() 3"
argument_list|)
expr_stmt|;
name|l
operator|=
name|tn
operator|->
name|tn_left
operator|->
name|tn_val
operator|->
name|v_ldbl
expr_stmt|;
if|if
condition|(
name|modtab
index|[
name|tn
operator|->
name|tn_op
index|]
operator|.
name|m_binary
condition|)
name|r
operator|=
name|tn
operator|->
name|tn_right
operator|->
name|tn_val
operator|->
name|v_ldbl
expr_stmt|;
switch|switch
condition|(
name|tn
operator|->
name|tn_op
condition|)
block|{
case|case
name|UPLUS
case|:
name|v
operator|->
name|v_ldbl
operator|=
name|l
expr_stmt|;
break|break;
case|case
name|UMINUS
case|:
name|v
operator|->
name|v_ldbl
operator|=
operator|-
name|l
expr_stmt|;
break|break;
case|case
name|MULT
case|:
name|v
operator|->
name|v_ldbl
operator|=
name|l
operator|*
name|r
expr_stmt|;
break|break;
case|case
name|DIV
case|:
if|if
condition|(
name|r
operator|==
literal|0.0
condition|)
block|{
comment|/* division by 0 */
name|error
argument_list|(
literal|139
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|FLOAT
condition|)
block|{
name|v
operator|->
name|v_ldbl
operator|=
name|l
operator|<
literal|0
condition|?
operator|-
name|FLT_MAX
else|:
name|FLT_MAX
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t
operator|==
name|DOUBLE
condition|)
block|{
name|v
operator|->
name|v_ldbl
operator|=
name|l
operator|<
literal|0
condition|?
operator|-
name|DBL_MAX
else|:
name|DBL_MAX
expr_stmt|;
block|}
else|else
block|{
name|v
operator|->
name|v_ldbl
operator|=
name|l
operator|<
literal|0
condition|?
operator|-
name|LDBL_MAX
else|:
name|LDBL_MAX
expr_stmt|;
block|}
block|}
else|else
block|{
name|v
operator|->
name|v_ldbl
operator|=
name|l
operator|/
name|r
expr_stmt|;
block|}
break|break;
case|case
name|PLUS
case|:
name|v
operator|->
name|v_ldbl
operator|=
name|l
operator|+
name|r
expr_stmt|;
break|break;
case|case
name|MINUS
case|:
name|v
operator|->
name|v_ldbl
operator|=
name|l
operator|-
name|r
expr_stmt|;
break|break;
case|case
name|LT
case|:
name|v
operator|->
name|v_quad
operator|=
name|l
operator|<
name|r
expr_stmt|;
break|break;
case|case
name|LE
case|:
name|v
operator|->
name|v_quad
operator|=
name|l
operator|<=
name|r
expr_stmt|;
break|break;
case|case
name|GE
case|:
name|v
operator|->
name|v_quad
operator|=
name|l
operator|>=
name|r
expr_stmt|;
break|break;
case|case
name|GT
case|:
name|v
operator|->
name|v_quad
operator|=
name|l
operator|>
name|r
expr_stmt|;
break|break;
case|case
name|EQ
case|:
name|v
operator|->
name|v_quad
operator|=
name|l
operator|==
name|r
expr_stmt|;
break|break;
case|case
name|NE
case|:
name|v
operator|->
name|v_quad
operator|=
name|l
operator|!=
name|r
expr_stmt|;
break|break;
default|default:
name|lerror
argument_list|(
literal|"foldflt() 4"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isnan
argument_list|(
operator|(
name|double
operator|)
name|v
operator|->
name|v_ldbl
argument_list|)
condition|)
name|lerror
argument_list|(
literal|"foldflt() 5"
argument_list|)
expr_stmt|;
if|if
condition|(
name|isinf
argument_list|(
operator|(
name|double
operator|)
name|v
operator|->
name|v_ldbl
argument_list|)
operator|||
operator|(
name|t
operator|==
name|FLOAT
operator|&&
operator|(
name|v
operator|->
name|v_ldbl
operator|>
name|FLT_MAX
operator|||
name|v
operator|->
name|v_ldbl
operator|<
operator|-
name|FLT_MAX
operator|)
operator|)
operator|||
operator|(
name|t
operator|==
name|DOUBLE
operator|&&
operator|(
name|v
operator|->
name|v_ldbl
operator|>
name|DBL_MAX
operator|||
name|v
operator|->
name|v_ldbl
operator|<
operator|-
name|DBL_MAX
operator|)
operator|)
condition|)
block|{
comment|/* floating point overflow detected, op %s */
name|warning
argument_list|(
literal|142
argument_list|,
name|modtab
index|[
name|tn
operator|->
name|tn_op
index|]
operator|.
name|m_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|FLOAT
condition|)
block|{
name|v
operator|->
name|v_ldbl
operator|=
name|v
operator|->
name|v_ldbl
operator|<
literal|0
condition|?
operator|-
name|FLT_MAX
else|:
name|FLT_MAX
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t
operator|==
name|DOUBLE
condition|)
block|{
name|v
operator|->
name|v_ldbl
operator|=
name|v
operator|->
name|v_ldbl
operator|<
literal|0
condition|?
operator|-
name|DBL_MAX
else|:
name|DBL_MAX
expr_stmt|;
block|}
else|else
block|{
name|v
operator|->
name|v_ldbl
operator|=
name|v
operator|->
name|v_ldbl
operator|<
literal|0
condition|?
operator|-
name|LDBL_MAX
else|:
name|LDBL_MAX
expr_stmt|;
block|}
block|}
return|return
operator|(
name|getcnode
argument_list|(
name|tn
operator|->
name|tn_type
argument_list|,
name|v
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create a constant node for sizeof.  */
end_comment

begin_function
name|tnode_t
modifier|*
name|bldszof
parameter_list|(
name|tp
parameter_list|)
name|type_t
modifier|*
name|tp
decl_stmt|;
block|{
name|int
name|elem
decl_stmt|,
name|elsz
decl_stmt|;
name|tspec_t
name|st
decl_stmt|;
name|elem
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|tp
operator|->
name|t_tspec
operator|==
name|ARRAY
condition|)
block|{
name|elem
operator|*=
name|tp
operator|->
name|t_dim
expr_stmt|;
name|tp
operator|=
name|tp
operator|->
name|t_subt
expr_stmt|;
block|}
if|if
condition|(
name|elem
operator|==
literal|0
condition|)
block|{
comment|/* cannot take size of incomplete type */
name|error
argument_list|(
literal|143
argument_list|)
expr_stmt|;
name|elem
operator|=
literal|1
expr_stmt|;
block|}
switch|switch
condition|(
name|tp
operator|->
name|t_tspec
condition|)
block|{
case|case
name|FUNC
case|:
comment|/* cannot take size of function */
name|error
argument_list|(
literal|144
argument_list|)
expr_stmt|;
name|elsz
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|STRUCT
case|:
case|case
name|UNION
case|:
if|if
condition|(
name|incompl
argument_list|(
name|tp
argument_list|)
condition|)
block|{
comment|/* cannot take size of incomplete type */
name|error
argument_list|(
literal|143
argument_list|)
expr_stmt|;
name|elsz
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|elsz
operator|=
name|tp
operator|->
name|t_str
operator|->
name|size
expr_stmt|;
block|}
break|break;
case|case
name|ENUM
case|:
if|if
condition|(
name|incompl
argument_list|(
name|tp
argument_list|)
condition|)
block|{
comment|/* cannot take size of incomplete type */
name|warning
argument_list|(
literal|143
argument_list|)
expr_stmt|;
block|}
comment|/* FALLTHROUGH */
default|default:
if|if
condition|(
name|tp
operator|->
name|t_isfield
condition|)
block|{
comment|/* cannot take size of bit-field */
name|error
argument_list|(
literal|145
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tp
operator|->
name|t_tspec
operator|==
name|VOID
condition|)
block|{
comment|/* cannot take size of void */
name|error
argument_list|(
literal|146
argument_list|)
expr_stmt|;
name|elsz
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|elsz
operator|=
name|size
argument_list|(
name|tp
operator|->
name|t_tspec
argument_list|)
expr_stmt|;
if|if
condition|(
name|elsz
operator|<=
literal|0
condition|)
name|lerror
argument_list|(
literal|"bldszof() 1"
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|#
directive|if
name|SIZEOF_IS_ULONG
name|st
operator|=
name|ULONG
expr_stmt|;
else|#
directive|else
name|st
operator|=
name|UINT
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|getinode
argument_list|(
name|st
argument_list|,
call|(
name|quad_t
call|)
argument_list|(
name|elem
operator|*
name|elsz
operator|/
name|CHAR_BIT
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Type casts.  */
end_comment

begin_function
name|tnode_t
modifier|*
name|cast
parameter_list|(
name|tn
parameter_list|,
name|tp
parameter_list|)
name|tnode_t
modifier|*
name|tn
decl_stmt|;
name|type_t
modifier|*
name|tp
decl_stmt|;
block|{
name|tspec_t
name|nt
decl_stmt|,
name|ot
decl_stmt|;
if|if
condition|(
name|tn
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|tn
operator|=
name|cconv
argument_list|(
name|tn
argument_list|)
expr_stmt|;
name|nt
operator|=
name|tp
operator|->
name|t_tspec
expr_stmt|;
name|ot
operator|=
name|tn
operator|->
name|tn_type
operator|->
name|t_tspec
expr_stmt|;
if|if
condition|(
name|nt
operator|==
name|VOID
condition|)
block|{
comment|/* 		 * XXX ANSI C requires scalar types or void (Plauger&Brodie). 		 * But this seams really questionable. 		 */
block|}
elseif|else
if|if
condition|(
name|nt
operator|==
name|STRUCT
operator|||
name|nt
operator|==
name|UNION
operator|||
name|nt
operator|==
name|ARRAY
operator|||
name|nt
operator|==
name|FUNC
condition|)
block|{
comment|/* invalid cast expression */
name|error
argument_list|(
literal|147
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|ot
operator|==
name|STRUCT
operator|||
name|ot
operator|==
name|UNION
condition|)
block|{
comment|/* invalid cast expression */
name|error
argument_list|(
literal|147
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|ot
operator|==
name|VOID
condition|)
block|{
comment|/* improper cast of void expression */
name|error
argument_list|(
literal|148
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|isityp
argument_list|(
name|nt
argument_list|)
operator|&&
name|issclt
argument_list|(
name|ot
argument_list|)
condition|)
block|{
comment|/* ok */
block|}
elseif|else
if|if
condition|(
name|isftyp
argument_list|(
name|nt
argument_list|)
operator|&&
name|isatyp
argument_list|(
name|ot
argument_list|)
condition|)
block|{
comment|/* ok */
block|}
elseif|else
if|if
condition|(
name|nt
operator|==
name|PTR
operator|&&
name|isityp
argument_list|(
name|ot
argument_list|)
condition|)
block|{
comment|/* ok */
block|}
elseif|else
if|if
condition|(
name|nt
operator|==
name|PTR
operator|&&
name|ot
operator|==
name|PTR
condition|)
block|{
if|if
condition|(
operator|!
name|tp
operator|->
name|t_subt
operator|->
name|t_const
operator|&&
name|tn
operator|->
name|tn_type
operator|->
name|t_subt
operator|->
name|t_const
condition|)
block|{
if|if
condition|(
name|hflag
condition|)
comment|/* cast discards 'const' from ... */
name|warning
argument_list|(
literal|275
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* invalid cast expression */
name|error
argument_list|(
literal|147
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|tn
operator|=
name|convert
argument_list|(
name|CVT
argument_list|,
literal|0
argument_list|,
name|tp
argument_list|,
name|tn
argument_list|)
expr_stmt|;
name|tn
operator|->
name|tn_cast
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|tn
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create the node for a function argument.  * All necessary conversions and type checks are done in funccall(), because  * in funcarg() we have no information about expected argument types.  */
end_comment

begin_function
name|tnode_t
modifier|*
name|funcarg
parameter_list|(
name|args
parameter_list|,
name|arg
parameter_list|)
name|tnode_t
modifier|*
name|args
decl_stmt|,
decl|*
name|arg
decl_stmt|;
end_function

begin_block
block|{
name|tnode_t
modifier|*
name|ntn
decl_stmt|;
comment|/* 	 * If there was a serious error in the expression for the argument, 	 * create a dummy argument so the positions of the remaining arguments 	 * will not change. 	 */
if|if
condition|(
name|arg
operator|==
name|NULL
condition|)
name|arg
operator|=
name|getinode
argument_list|(
name|INT
argument_list|,
operator|(
name|quad_t
operator|)
literal|0
argument_list|)
expr_stmt|;
name|ntn
operator|=
name|mktnode
argument_list|(
name|PUSH
argument_list|,
name|arg
operator|->
name|tn_type
argument_list|,
name|arg
argument_list|,
name|args
argument_list|)
expr_stmt|;
return|return
operator|(
name|ntn
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Create the node for a function call. Also check types of  * function arguments and insert conversions, if necessary.  */
end_comment

begin_function
name|tnode_t
modifier|*
name|funccall
parameter_list|(
name|func
parameter_list|,
name|args
parameter_list|)
name|tnode_t
modifier|*
name|func
decl_stmt|,
decl|*
name|args
decl_stmt|;
end_function

begin_block
block|{
name|tnode_t
modifier|*
name|ntn
decl_stmt|;
name|op_t
name|fcop
decl_stmt|;
if|if
condition|(
name|func
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|func
operator|->
name|tn_op
operator|==
name|NAME
operator|&&
name|func
operator|->
name|tn_type
operator|->
name|t_tspec
operator|==
name|FUNC
condition|)
block|{
name|fcop
operator|=
name|CALL
expr_stmt|;
block|}
else|else
block|{
name|fcop
operator|=
name|ICALL
expr_stmt|;
block|}
comment|/* 	 * after cconv() func will always be a pointer to a function 	 * if it is a valid function designator. 	 */
name|func
operator|=
name|cconv
argument_list|(
name|func
argument_list|)
expr_stmt|;
if|if
condition|(
name|func
operator|->
name|tn_type
operator|->
name|t_tspec
operator|!=
name|PTR
operator|||
name|func
operator|->
name|tn_type
operator|->
name|t_subt
operator|->
name|t_tspec
operator|!=
name|FUNC
condition|)
block|{
comment|/* illegal function */
name|error
argument_list|(
literal|149
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|args
operator|=
name|chkfarg
argument_list|(
name|func
operator|->
name|tn_type
operator|->
name|t_subt
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|ntn
operator|=
name|mktnode
argument_list|(
name|fcop
argument_list|,
name|func
operator|->
name|tn_type
operator|->
name|t_subt
operator|->
name|t_subt
argument_list|,
name|func
argument_list|,
name|args
argument_list|)
expr_stmt|;
return|return
operator|(
name|ntn
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Check types of all function arguments and insert conversions,  * if necessary.  */
end_comment

begin_function
specifier|static
name|tnode_t
modifier|*
name|chkfarg
parameter_list|(
name|ftp
parameter_list|,
name|args
parameter_list|)
name|type_t
modifier|*
name|ftp
decl_stmt|;
comment|/* type of called function */
name|tnode_t
modifier|*
name|args
decl_stmt|;
comment|/* arguments */
block|{
name|tnode_t
modifier|*
name|arg
decl_stmt|;
name|sym_t
modifier|*
name|asym
decl_stmt|;
name|tspec_t
name|at
decl_stmt|;
name|int
name|narg
decl_stmt|,
name|npar
decl_stmt|,
name|n
decl_stmt|,
name|i
decl_stmt|;
comment|/* get # of args in the prototype */
name|npar
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|asym
operator|=
name|ftp
operator|->
name|t_args
init|;
name|asym
operator|!=
name|NULL
condition|;
name|asym
operator|=
name|asym
operator|->
name|s_nxt
control|)
name|npar
operator|++
expr_stmt|;
comment|/* get # of args in function call */
name|narg
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|arg
operator|=
name|args
init|;
name|arg
operator|!=
name|NULL
condition|;
name|arg
operator|=
name|arg
operator|->
name|tn_right
control|)
name|narg
operator|++
expr_stmt|;
name|asym
operator|=
name|ftp
operator|->
name|t_args
expr_stmt|;
if|if
condition|(
name|ftp
operator|->
name|t_proto
operator|&&
name|npar
operator|!=
name|narg
operator|&&
operator|!
operator|(
name|ftp
operator|->
name|t_vararg
operator|&&
name|npar
operator|<
name|narg
operator|)
condition|)
block|{
comment|/* argument mismatch: %d arg%s passed, %d expected */
name|error
argument_list|(
literal|150
argument_list|,
name|narg
argument_list|,
name|narg
operator|>
literal|1
condition|?
literal|"s"
else|:
literal|""
argument_list|,
name|npar
argument_list|)
expr_stmt|;
name|asym
operator|=
name|NULL
expr_stmt|;
block|}
for|for
control|(
name|n
operator|=
literal|1
init|;
name|n
operator|<=
name|narg
condition|;
name|n
operator|++
control|)
block|{
comment|/* 		 * The rightmost argument is at the top of the argument 		 * subtree. 		 */
for|for
control|(
name|i
operator|=
name|narg
operator|,
name|arg
operator|=
name|args
init|;
name|i
operator|>
name|n
condition|;
name|i
operator|--
operator|,
name|arg
operator|=
name|arg
operator|->
name|tn_right
control|)
empty_stmt|;
comment|/* some things which are always not allowd */
if|if
condition|(
operator|(
name|at
operator|=
name|arg
operator|->
name|tn_left
operator|->
name|tn_type
operator|->
name|t_tspec
operator|)
operator|==
name|VOID
condition|)
block|{
comment|/* void expressions may not be arguments, arg #%d */
name|error
argument_list|(
literal|151
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|at
operator|==
name|STRUCT
operator|||
name|at
operator|==
name|UNION
operator|)
operator|&&
name|incompl
argument_list|(
name|arg
operator|->
name|tn_left
operator|->
name|tn_type
argument_list|)
condition|)
block|{
comment|/* argument cannot have unknown size, arg #%d */
name|error
argument_list|(
literal|152
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|isityp
argument_list|(
name|at
argument_list|)
operator|&&
name|arg
operator|->
name|tn_left
operator|->
name|tn_type
operator|->
name|t_isenum
operator|&&
name|incompl
argument_list|(
name|arg
operator|->
name|tn_left
operator|->
name|tn_type
argument_list|)
condition|)
block|{
comment|/* argument cannot have unknown size, arg #%d */
name|warning
argument_list|(
literal|152
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
comment|/* class conversions (arg in value context) */
name|arg
operator|->
name|tn_left
operator|=
name|cconv
argument_list|(
name|arg
operator|->
name|tn_left
argument_list|)
expr_stmt|;
if|if
condition|(
name|asym
operator|!=
name|NULL
condition|)
block|{
name|arg
operator|->
name|tn_left
operator|=
name|parg
argument_list|(
name|n
argument_list|,
name|asym
operator|->
name|s_type
argument_list|,
name|arg
operator|->
name|tn_left
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|arg
operator|->
name|tn_left
operator|=
name|promote
argument_list|(
name|NOOP
argument_list|,
literal|1
argument_list|,
name|arg
operator|->
name|tn_left
argument_list|)
expr_stmt|;
block|}
name|arg
operator|->
name|tn_type
operator|=
name|arg
operator|->
name|tn_left
operator|->
name|tn_type
expr_stmt|;
if|if
condition|(
name|asym
operator|!=
name|NULL
condition|)
name|asym
operator|=
name|asym
operator|->
name|s_nxt
expr_stmt|;
block|}
return|return
operator|(
name|args
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Compare the type of an argument with the corresponding type of a  * prototype parameter. If it is a valid combination, but both types  * are not the same, insert a conversion to convert the argument into  * the type of the parameter.  */
end_comment

begin_function
specifier|static
name|tnode_t
modifier|*
name|parg
parameter_list|(
name|n
parameter_list|,
name|tp
parameter_list|,
name|tn
parameter_list|)
name|int
name|n
decl_stmt|;
comment|/* pos of arg */
name|type_t
modifier|*
name|tp
decl_stmt|;
comment|/* expected type (from prototype) */
name|tnode_t
modifier|*
name|tn
decl_stmt|;
comment|/* argument */
block|{
name|tnode_t
modifier|*
name|ln
decl_stmt|;
name|int
name|warn
decl_stmt|;
name|ln
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|tnode_t
argument_list|)
argument_list|)
expr_stmt|;
name|ln
operator|->
name|tn_type
operator|=
name|tduptyp
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|ln
operator|->
name|tn_type
operator|->
name|t_const
operator|=
literal|0
expr_stmt|;
name|ln
operator|->
name|tn_lvalue
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|typeok
argument_list|(
name|FARG
argument_list|,
name|n
argument_list|,
name|ln
argument_list|,
name|tn
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|eqtype
argument_list|(
name|tp
argument_list|,
name|tn
operator|->
name|tn_type
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
operator|(
name|warn
operator|=
literal|0
operator|,
operator|&
name|warn
operator|)
argument_list|)
operator|||
name|warn
condition|)
name|tn
operator|=
name|convert
argument_list|(
name|FARG
argument_list|,
name|n
argument_list|,
name|tp
argument_list|,
name|tn
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|ln
argument_list|)
expr_stmt|;
return|return
operator|(
name|tn
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the value of an integral constant expression.  * If the expression is not constant or its type is not an integer  * type, an error message is printed.  */
end_comment

begin_function
name|val_t
modifier|*
name|constant
parameter_list|(
name|tn
parameter_list|)
name|tnode_t
modifier|*
name|tn
decl_stmt|;
block|{
name|val_t
modifier|*
name|v
decl_stmt|;
if|if
condition|(
name|tn
operator|!=
name|NULL
condition|)
name|tn
operator|=
name|cconv
argument_list|(
name|tn
argument_list|)
expr_stmt|;
if|if
condition|(
name|tn
operator|!=
name|NULL
condition|)
name|tn
operator|=
name|promote
argument_list|(
name|NOOP
argument_list|,
literal|0
argument_list|,
name|tn
argument_list|)
expr_stmt|;
name|v
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|val_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tn
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|nerr
operator|==
literal|0
condition|)
name|lerror
argument_list|(
literal|"constant() 1"
argument_list|)
expr_stmt|;
name|v
operator|->
name|v_tspec
operator|=
name|INT
expr_stmt|;
name|v
operator|->
name|v_quad
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|v
operator|)
return|;
block|}
name|v
operator|->
name|v_tspec
operator|=
name|tn
operator|->
name|tn_type
operator|->
name|t_tspec
expr_stmt|;
if|if
condition|(
name|tn
operator|->
name|tn_op
operator|==
name|CON
condition|)
block|{
if|if
condition|(
name|tn
operator|->
name|tn_type
operator|->
name|t_tspec
operator|!=
name|tn
operator|->
name|tn_val
operator|->
name|v_tspec
condition|)
name|lerror
argument_list|(
literal|"constant() 2"
argument_list|)
expr_stmt|;
if|if
condition|(
name|isityp
argument_list|(
name|tn
operator|->
name|tn_val
operator|->
name|v_tspec
argument_list|)
condition|)
block|{
name|v
operator|->
name|v_ansiu
operator|=
name|tn
operator|->
name|tn_val
operator|->
name|v_ansiu
expr_stmt|;
name|v
operator|->
name|v_quad
operator|=
name|tn
operator|->
name|tn_val
operator|->
name|v_quad
expr_stmt|;
return|return
operator|(
name|v
operator|)
return|;
block|}
name|v
operator|->
name|v_quad
operator|=
name|tn
operator|->
name|tn_val
operator|->
name|v_ldbl
expr_stmt|;
block|}
else|else
block|{
name|v
operator|->
name|v_quad
operator|=
literal|1
expr_stmt|;
block|}
comment|/* integral constant expression expected */
name|error
argument_list|(
literal|55
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isityp
argument_list|(
name|v
operator|->
name|v_tspec
argument_list|)
condition|)
name|v
operator|->
name|v_tspec
operator|=
name|INT
expr_stmt|;
return|return
operator|(
name|v
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Perform some tests on expressions which can't be done in build() and  * functions called by build(). These tests must be done here because  * we need some information about the context in which the operations  * are performed.  * After all tests are performed, expr() frees the memory which is used  * for the expression.  */
end_comment

begin_function
name|void
name|expr
parameter_list|(
name|tn
parameter_list|,
name|vctx
parameter_list|,
name|tctx
parameter_list|)
name|tnode_t
modifier|*
name|tn
decl_stmt|;
name|int
name|vctx
decl_stmt|,
name|tctx
decl_stmt|;
block|{
if|if
condition|(
name|tn
operator|==
name|NULL
operator|&&
name|nerr
operator|==
literal|0
condition|)
name|lerror
argument_list|(
literal|"expr() 1"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tn
operator|==
name|NULL
condition|)
block|{
name|tfreeblk
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* expr() is also called in global initialisations */
if|if
condition|(
name|dcs
operator|->
name|d_ctx
operator|!=
name|EXTERN
condition|)
name|chkreach
argument_list|()
expr_stmt|;
name|chkmisc
argument_list|(
name|tn
argument_list|,
name|vctx
argument_list|,
name|tctx
argument_list|,
operator|!
name|tctx
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|tn
operator|->
name|tn_op
operator|==
name|ASSIGN
condition|)
block|{
if|if
condition|(
name|hflag
operator|&&
name|tctx
condition|)
comment|/* assignment in conditional context */
name|warning
argument_list|(
literal|159
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tn
operator|->
name|tn_op
operator|==
name|CON
condition|)
block|{
if|if
condition|(
name|hflag
operator|&&
name|tctx
operator|&&
operator|!
name|ccflg
condition|)
comment|/* constant in conditional context */
name|warning
argument_list|(
literal|161
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|modtab
index|[
name|tn
operator|->
name|tn_op
index|]
operator|.
name|m_sideeff
condition|)
block|{
comment|/* 		 * for left operands of COMMA this warning is already 		 * printed 		 */
if|if
condition|(
name|tn
operator|->
name|tn_op
operator|!=
name|COMMA
operator|&&
operator|!
name|vctx
operator|&&
operator|!
name|tctx
condition|)
name|nulleff
argument_list|(
name|tn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dflag
condition|)
name|displexpr
argument_list|(
name|tn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* free the tree memory */
name|tfreeblk
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|nulleff
parameter_list|(
name|tn
parameter_list|)
name|tnode_t
modifier|*
name|tn
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|hflag
condition|)
return|return;
while|while
condition|(
operator|!
name|modtab
index|[
name|tn
operator|->
name|tn_op
index|]
operator|.
name|m_sideeff
condition|)
block|{
if|if
condition|(
name|tn
operator|->
name|tn_op
operator|==
name|CVT
operator|&&
name|tn
operator|->
name|tn_type
operator|->
name|t_tspec
operator|==
name|VOID
condition|)
block|{
name|tn
operator|=
name|tn
operator|->
name|tn_left
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tn
operator|->
name|tn_op
operator|==
name|LOGAND
operator|||
name|tn
operator|->
name|tn_op
operator|==
name|LOGOR
condition|)
block|{
comment|/* 			 *&& and || have a side effect if the right operand 			 * has a side effect. 			 */
name|tn
operator|=
name|tn
operator|->
name|tn_right
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tn
operator|->
name|tn_op
operator|==
name|QUEST
condition|)
block|{
comment|/* 			 * ? has a side effect if at least one of its right 			 * operands has a side effect 			 */
name|tn
operator|=
name|tn
operator|->
name|tn_right
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tn
operator|->
name|tn_op
operator|==
name|COLON
condition|)
block|{
comment|/* 			 * : has a side effect if at least one of its operands 			 * has a side effect 			 */
if|if
condition|(
name|modtab
index|[
name|tn
operator|->
name|tn_left
operator|->
name|tn_op
index|]
operator|.
name|m_sideeff
condition|)
block|{
name|tn
operator|=
name|tn
operator|->
name|tn_left
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|modtab
index|[
name|tn
operator|->
name|tn_right
operator|->
name|tn_op
index|]
operator|.
name|m_sideeff
condition|)
block|{
name|tn
operator|=
name|tn
operator|->
name|tn_right
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
else|else
block|{
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|modtab
index|[
name|tn
operator|->
name|tn_op
index|]
operator|.
name|m_sideeff
condition|)
comment|/* expression has null effect */
name|warning
argument_list|(
literal|129
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Dump an expression to stdout  * only used for debugging  */
end_comment

begin_function
specifier|static
name|void
name|displexpr
parameter_list|(
name|tn
parameter_list|,
name|offs
parameter_list|)
name|tnode_t
modifier|*
name|tn
decl_stmt|;
name|int
name|offs
decl_stmt|;
block|{
name|u_quad_t
name|uq
decl_stmt|;
if|if
condition|(
name|tn
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%*s%s\n"
argument_list|,
name|offs
argument_list|,
literal|""
argument_list|,
literal|"NULL"
argument_list|)
expr_stmt|;
return|return;
block|}
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%*sop %s  "
argument_list|,
name|offs
argument_list|,
literal|""
argument_list|,
name|modtab
index|[
name|tn
operator|->
name|tn_op
index|]
operator|.
name|m_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|tn
operator|->
name|tn_op
operator|==
name|NAME
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: %s "
argument_list|,
name|tn
operator|->
name|tn_sym
operator|->
name|s_name
argument_list|,
name|scltoa
argument_list|(
name|tn
operator|->
name|tn_sym
operator|->
name|s_scl
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tn
operator|->
name|tn_op
operator|==
name|CON
operator|&&
name|isftyp
argument_list|(
name|tn
operator|->
name|tn_type
operator|->
name|t_tspec
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%#g "
argument_list|,
operator|(
name|double
operator|)
name|tn
operator|->
name|tn_val
operator|->
name|v_ldbl
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tn
operator|->
name|tn_op
operator|==
name|CON
operator|&&
name|isityp
argument_list|(
name|tn
operator|->
name|tn_type
operator|->
name|t_tspec
argument_list|)
condition|)
block|{
name|uq
operator|=
name|tn
operator|->
name|tn_val
operator|->
name|v_quad
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"0x %08lx %08lx "
argument_list|,
call|(
name|long
call|)
argument_list|(
name|uq
operator|>>
literal|32
argument_list|)
operator|&
literal|0xffffffffl
argument_list|,
operator|(
name|long
operator|)
name|uq
operator|&
literal|0xffffffffl
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tn
operator|->
name|tn_op
operator|==
name|CON
condition|)
block|{
if|if
condition|(
name|tn
operator|->
name|tn_type
operator|->
name|t_tspec
operator|!=
name|PTR
condition|)
name|lerror
argument_list|(
literal|"displexpr() 1"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"0x%0*lx "
argument_list|,
call|(
name|int
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
operator|*
name|CHAR_BIT
operator|/
literal|4
argument_list|)
argument_list|,
operator|(
name|u_long
operator|)
name|tn
operator|->
name|tn_val
operator|->
name|v_quad
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tn
operator|->
name|tn_op
operator|==
name|STRING
condition|)
block|{
if|if
condition|(
name|tn
operator|->
name|tn_strg
operator|->
name|st_tspec
operator|==
name|CHAR
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\"%s\""
argument_list|,
name|tn
operator|->
name|tn_strg
operator|->
name|st_cp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|size_t
name|n
decl_stmt|;
name|n
operator|=
name|MB_CUR_MAX
operator|*
operator|(
name|tn
operator|->
name|tn_strg
operator|->
name|st_len
operator|+
literal|1
operator|)
expr_stmt|;
name|s
operator|=
name|xmalloc
argument_list|(
name|n
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|wcstombs
argument_list|(
name|s
argument_list|,
name|tn
operator|->
name|tn_strg
operator|->
name|st_wcp
argument_list|,
name|n
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"L\"%s\""
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tn
operator|->
name|tn_op
operator|==
name|FSEL
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"o=%d, l=%d "
argument_list|,
name|tn
operator|->
name|tn_type
operator|->
name|t_foffs
argument_list|,
name|tn
operator|->
name|tn_type
operator|->
name|t_flen
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|ttos
argument_list|(
name|tn
operator|->
name|tn_type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tn
operator|->
name|tn_op
operator|==
name|NAME
operator|||
name|tn
operator|->
name|tn_op
operator|==
name|CON
operator|||
name|tn
operator|->
name|tn_op
operator|==
name|STRING
condition|)
return|return;
name|displexpr
argument_list|(
name|tn
operator|->
name|tn_left
argument_list|,
name|offs
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|modtab
index|[
name|tn
operator|->
name|tn_op
index|]
operator|.
name|m_binary
operator|||
operator|(
name|tn
operator|->
name|tn_op
operator|==
name|PUSH
operator|&&
name|tn
operator|->
name|tn_right
operator|!=
name|NULL
operator|)
condition|)
block|{
name|displexpr
argument_list|(
name|tn
operator|->
name|tn_right
argument_list|,
name|offs
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Called by expr() to recursively perform some tests.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|void
name|chkmisc
parameter_list|(
name|tn
parameter_list|,
name|vctx
parameter_list|,
name|tctx
parameter_list|,
name|eqwarn
parameter_list|,
name|fcall
parameter_list|,
name|rvdisc
parameter_list|,
name|szof
parameter_list|)
name|tnode_t
modifier|*
name|tn
decl_stmt|;
name|int
name|vctx
decl_stmt|,
name|tctx
decl_stmt|,
name|eqwarn
decl_stmt|,
name|fcall
decl_stmt|,
name|rvdisc
decl_stmt|,
name|szof
decl_stmt|;
block|{
name|tnode_t
modifier|*
name|ln
decl_stmt|,
modifier|*
name|rn
decl_stmt|;
name|mod_t
modifier|*
name|mp
decl_stmt|;
name|int
name|nrvdisc
decl_stmt|,
name|cvctx
decl_stmt|,
name|ctctx
decl_stmt|;
name|op_t
name|op
decl_stmt|;
name|scl_t
name|sc
decl_stmt|;
name|dinfo_t
modifier|*
name|di
decl_stmt|;
if|if
condition|(
name|tn
operator|==
name|NULL
condition|)
return|return;
name|ln
operator|=
name|tn
operator|->
name|tn_left
expr_stmt|;
name|rn
operator|=
name|tn
operator|->
name|tn_right
expr_stmt|;
name|mp
operator|=
operator|&
name|modtab
index|[
name|op
operator|=
name|tn
operator|->
name|tn_op
index|]
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|AMPER
case|:
if|if
condition|(
name|ln
operator|->
name|tn_op
operator|==
name|NAME
operator|&&
operator|(
name|reached
operator|||
name|rchflg
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|szof
condition|)
name|setsflg
argument_list|(
name|ln
operator|->
name|tn_sym
argument_list|)
expr_stmt|;
name|setuflg
argument_list|(
name|ln
operator|->
name|tn_sym
argument_list|,
name|fcall
argument_list|,
name|szof
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ln
operator|->
name|tn_op
operator|==
name|STAR
operator|&&
name|ln
operator|->
name|tn_left
operator|->
name|tn_op
operator|==
name|PLUS
condition|)
comment|/* check the range of array indices */
name|chkaidx
argument_list|(
name|ln
operator|->
name|tn_left
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOAD
case|:
if|if
condition|(
name|ln
operator|->
name|tn_op
operator|==
name|STAR
operator|&&
name|ln
operator|->
name|tn_left
operator|->
name|tn_op
operator|==
name|PLUS
condition|)
comment|/* check the range of array indices */
name|chkaidx
argument_list|(
name|ln
operator|->
name|tn_left
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|PUSH
case|:
case|case
name|INCBEF
case|:
case|case
name|DECBEF
case|:
case|case
name|INCAFT
case|:
case|case
name|DECAFT
case|:
case|case
name|ADDASS
case|:
case|case
name|SUBASS
case|:
case|case
name|MULASS
case|:
case|case
name|DIVASS
case|:
case|case
name|MODASS
case|:
case|case
name|ANDASS
case|:
case|case
name|ORASS
case|:
case|case
name|XORASS
case|:
case|case
name|SHLASS
case|:
case|case
name|SHRASS
case|:
if|if
condition|(
name|ln
operator|->
name|tn_op
operator|==
name|NAME
operator|&&
operator|(
name|reached
operator|||
name|rchflg
operator|)
condition|)
block|{
name|sc
operator|=
name|ln
operator|->
name|tn_sym
operator|->
name|s_scl
expr_stmt|;
comment|/* 			 * Look if there was a asm statement in one of the 			 * compound statements we are in. If not, we don't 			 * print a warning. 			 */
for|for
control|(
name|di
operator|=
name|dcs
init|;
name|di
operator|!=
name|NULL
condition|;
name|di
operator|=
name|di
operator|->
name|d_nxt
control|)
block|{
if|if
condition|(
name|di
operator|->
name|d_asm
condition|)
break|break;
block|}
if|if
condition|(
name|sc
operator|!=
name|EXTERN
operator|&&
name|sc
operator|!=
name|STATIC
operator|&&
operator|!
name|ln
operator|->
name|tn_sym
operator|->
name|s_set
operator|&&
operator|!
name|szof
operator|&&
name|di
operator|==
name|NULL
condition|)
block|{
comment|/* %s may be used before set */
name|warning
argument_list|(
literal|158
argument_list|,
name|ln
operator|->
name|tn_sym
operator|->
name|s_name
argument_list|)
expr_stmt|;
name|setsflg
argument_list|(
name|ln
operator|->
name|tn_sym
argument_list|)
expr_stmt|;
block|}
name|setuflg
argument_list|(
name|ln
operator|->
name|tn_sym
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ASSIGN
case|:
if|if
condition|(
name|ln
operator|->
name|tn_op
operator|==
name|NAME
operator|&&
operator|!
name|szof
operator|&&
operator|(
name|reached
operator|||
name|rchflg
operator|)
condition|)
block|{
name|setsflg
argument_list|(
name|ln
operator|->
name|tn_sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|ln
operator|->
name|tn_sym
operator|->
name|s_scl
operator|==
name|EXTERN
condition|)
name|outusg
argument_list|(
name|ln
operator|->
name|tn_sym
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ln
operator|->
name|tn_op
operator|==
name|STAR
operator|&&
name|ln
operator|->
name|tn_left
operator|->
name|tn_op
operator|==
name|PLUS
condition|)
comment|/* check the range of array indices */
name|chkaidx
argument_list|(
name|ln
operator|->
name|tn_left
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|CALL
case|:
if|if
condition|(
name|ln
operator|->
name|tn_op
operator|!=
name|AMPER
operator|||
name|ln
operator|->
name|tn_left
operator|->
name|tn_op
operator|!=
name|NAME
condition|)
name|lerror
argument_list|(
literal|"chkmisc() 1"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|szof
condition|)
name|outcall
argument_list|(
name|tn
argument_list|,
name|vctx
operator|||
name|tctx
argument_list|,
name|rvdisc
argument_list|)
expr_stmt|;
break|break;
case|case
name|EQ
case|:
comment|/* equality operator "==" found where "=" was exp. */
if|if
condition|(
name|hflag
operator|&&
name|eqwarn
condition|)
name|warning
argument_list|(
literal|160
argument_list|)
expr_stmt|;
break|break;
case|case
name|CON
case|:
case|case
name|NAME
case|:
case|case
name|STRING
case|:
return|return;
comment|/* LINTED (enumeration values not handled in switch) */
default|default:
block|}
name|cvctx
operator|=
name|mp
operator|->
name|m_vctx
expr_stmt|;
name|ctctx
operator|=
name|mp
operator|->
name|m_tctx
expr_stmt|;
comment|/* 	 * values of operands of ':' are not used if the type of at least 	 * one of the operands (for gcc compatibility) is void 	 * XXX test/value context of QUEST should probably be used as 	 * context for both operands of COLON 	 */
if|if
condition|(
name|op
operator|==
name|COLON
operator|&&
name|tn
operator|->
name|tn_type
operator|->
name|t_tspec
operator|==
name|VOID
condition|)
name|cvctx
operator|=
name|ctctx
operator|=
literal|0
expr_stmt|;
name|nrvdisc
operator|=
name|op
operator|==
name|CVT
operator|&&
name|tn
operator|->
name|tn_type
operator|->
name|t_tspec
operator|==
name|VOID
expr_stmt|;
name|chkmisc
argument_list|(
name|ln
argument_list|,
name|cvctx
argument_list|,
name|ctctx
argument_list|,
name|mp
operator|->
name|m_eqwarn
argument_list|,
name|op
operator|==
name|CALL
argument_list|,
name|nrvdisc
argument_list|,
name|szof
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|PUSH
case|:
if|if
condition|(
name|rn
operator|!=
name|NULL
condition|)
name|chkmisc
argument_list|(
name|rn
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|mp
operator|->
name|m_eqwarn
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|szof
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOGAND
case|:
case|case
name|LOGOR
case|:
name|chkmisc
argument_list|(
name|rn
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|mp
operator|->
name|m_eqwarn
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|szof
argument_list|)
expr_stmt|;
break|break;
case|case
name|COLON
case|:
name|chkmisc
argument_list|(
name|rn
argument_list|,
name|cvctx
argument_list|,
name|ctctx
argument_list|,
name|mp
operator|->
name|m_eqwarn
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|szof
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|mp
operator|->
name|m_binary
condition|)
name|chkmisc
argument_list|(
name|rn
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|mp
operator|->
name|m_eqwarn
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|szof
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Checks the range of array indices, if possible.  * amper is set if only the address of the element is used. This  * means that the index is allowd to refere to the first element  * after the array.  */
end_comment

begin_function
specifier|static
name|void
name|chkaidx
parameter_list|(
name|tn
parameter_list|,
name|amper
parameter_list|)
name|tnode_t
modifier|*
name|tn
decl_stmt|;
name|int
name|amper
decl_stmt|;
block|{
name|int
name|dim
decl_stmt|;
name|tnode_t
modifier|*
name|ln
decl_stmt|,
modifier|*
name|rn
decl_stmt|;
name|int
name|elsz
decl_stmt|;
name|quad_t
name|con
decl_stmt|;
name|ln
operator|=
name|tn
operator|->
name|tn_left
expr_stmt|;
name|rn
operator|=
name|tn
operator|->
name|tn_right
expr_stmt|;
comment|/* We can only check constant indices. */
if|if
condition|(
name|rn
operator|->
name|tn_op
operator|!=
name|CON
condition|)
return|return;
comment|/* Return if the left node does not stem from an array. */
if|if
condition|(
name|ln
operator|->
name|tn_op
operator|!=
name|AMPER
condition|)
return|return;
if|if
condition|(
name|ln
operator|->
name|tn_left
operator|->
name|tn_op
operator|!=
name|STRING
operator|&&
name|ln
operator|->
name|tn_left
operator|->
name|tn_op
operator|!=
name|NAME
condition|)
return|return;
if|if
condition|(
name|ln
operator|->
name|tn_left
operator|->
name|tn_type
operator|->
name|t_tspec
operator|!=
name|ARRAY
condition|)
return|return;
comment|/* 	 * For incomplete array types, we can print a warning only if 	 * the index is negative. 	 */
if|if
condition|(
name|incompl
argument_list|(
name|ln
operator|->
name|tn_left
operator|->
name|tn_type
argument_list|)
operator|&&
name|rn
operator|->
name|tn_val
operator|->
name|v_quad
operator|>=
literal|0
condition|)
return|return;
comment|/* Get the size of one array element */
if|if
condition|(
operator|(
name|elsz
operator|=
name|length
argument_list|(
name|ln
operator|->
name|tn_type
operator|->
name|t_subt
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return;
name|elsz
operator|/=
name|CHAR_BIT
expr_stmt|;
comment|/* Change the unit of the index from bytes to element size. */
if|if
condition|(
name|isutyp
argument_list|(
name|rn
operator|->
name|tn_type
operator|->
name|t_tspec
argument_list|)
condition|)
block|{
name|con
operator|=
operator|(
name|u_quad_t
operator|)
name|rn
operator|->
name|tn_val
operator|->
name|v_quad
operator|/
name|elsz
expr_stmt|;
block|}
else|else
block|{
name|con
operator|=
name|rn
operator|->
name|tn_val
operator|->
name|v_quad
operator|/
name|elsz
expr_stmt|;
block|}
name|dim
operator|=
name|ln
operator|->
name|tn_left
operator|->
name|tn_type
operator|->
name|t_dim
operator|+
operator|(
name|amper
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|isutyp
argument_list|(
name|rn
operator|->
name|tn_type
operator|->
name|t_tspec
argument_list|)
operator|&&
name|con
operator|<
literal|0
condition|)
block|{
comment|/* array subscript cannot be negative: %ld */
name|warning
argument_list|(
literal|167
argument_list|,
operator|(
name|long
operator|)
name|con
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dim
operator|>
literal|0
operator|&&
operator|(
name|u_quad_t
operator|)
name|con
operator|>=
name|dim
condition|)
block|{
comment|/* array subscript cannot be> %d: %ld */
name|warning
argument_list|(
literal|168
argument_list|,
name|dim
operator|-
literal|1
argument_list|,
operator|(
name|long
operator|)
name|con
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Check for ordered comparisions of unsigned values with 0.  */
end_comment

begin_function
specifier|static
name|void
name|chkcomp
parameter_list|(
name|op
parameter_list|,
name|ln
parameter_list|,
name|rn
parameter_list|)
name|op_t
name|op
decl_stmt|;
name|tnode_t
modifier|*
name|ln
decl_stmt|,
decl|*
name|rn
decl_stmt|;
end_function

begin_block
block|{
name|tspec_t
name|lt
decl_stmt|,
name|rt
decl_stmt|;
name|mod_t
modifier|*
name|mp
decl_stmt|;
name|lt
operator|=
name|ln
operator|->
name|tn_type
operator|->
name|t_tspec
expr_stmt|;
name|rt
operator|=
name|rn
operator|->
name|tn_type
operator|->
name|t_tspec
expr_stmt|;
name|mp
operator|=
operator|&
name|modtab
index|[
name|op
index|]
expr_stmt|;
if|if
condition|(
name|ln
operator|->
name|tn_op
operator|!=
name|CON
operator|&&
name|rn
operator|->
name|tn_op
operator|!=
name|CON
condition|)
return|return;
if|if
condition|(
operator|!
name|isityp
argument_list|(
name|lt
argument_list|)
operator|||
operator|!
name|isityp
argument_list|(
name|rt
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|(
name|hflag
operator|||
name|pflag
operator|)
operator|&&
name|lt
operator|==
name|CHAR
operator|&&
name|rn
operator|->
name|tn_op
operator|==
name|CON
operator|&&
operator|(
name|rn
operator|->
name|tn_val
operator|->
name|v_quad
operator|<
literal|0
operator|||
name|rn
operator|->
name|tn_val
operator|->
name|v_quad
operator|>
operator|~
operator|(
operator|~
literal|0
operator|<<
operator|(
name|CHAR_BIT
operator|-
literal|1
operator|)
operator|)
operator|)
condition|)
block|{
comment|/* nonportable character comparision, op %s */
name|warning
argument_list|(
literal|230
argument_list|,
name|mp
operator|->
name|m_name
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|hflag
operator|||
name|pflag
operator|)
operator|&&
name|rt
operator|==
name|CHAR
operator|&&
name|ln
operator|->
name|tn_op
operator|==
name|CON
operator|&&
operator|(
name|ln
operator|->
name|tn_val
operator|->
name|v_quad
operator|<
literal|0
operator|||
name|ln
operator|->
name|tn_val
operator|->
name|v_quad
operator|>
operator|~
operator|(
operator|~
literal|0
operator|<<
operator|(
name|CHAR_BIT
operator|-
literal|1
operator|)
operator|)
operator|)
condition|)
block|{
comment|/* nonportable character comparision, op %s */
name|warning
argument_list|(
literal|230
argument_list|,
name|mp
operator|->
name|m_name
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|isutyp
argument_list|(
name|lt
argument_list|)
operator|&&
operator|!
name|isutyp
argument_list|(
name|rt
argument_list|)
operator|&&
name|rn
operator|->
name|tn_op
operator|==
name|CON
operator|&&
name|rn
operator|->
name|tn_val
operator|->
name|v_quad
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|rn
operator|->
name|tn_val
operator|->
name|v_quad
operator|<
literal|0
condition|)
block|{
comment|/* comparision of %s with %s, op %s */
name|warning
argument_list|(
literal|162
argument_list|,
name|tyname
argument_list|(
name|ln
operator|->
name|tn_type
argument_list|)
argument_list|,
literal|"negative constant"
argument_list|,
name|mp
operator|->
name|m_name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|op
operator|==
name|LT
operator|||
name|op
operator|==
name|GE
operator|||
operator|(
name|hflag
operator|&&
name|op
operator|==
name|LE
operator|)
condition|)
block|{
comment|/* comparision of %s with %s, op %s */
name|warning
argument_list|(
literal|162
argument_list|,
name|tyname
argument_list|(
name|ln
operator|->
name|tn_type
argument_list|)
argument_list|,
literal|"0"
argument_list|,
name|mp
operator|->
name|m_name
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|isutyp
argument_list|(
name|rt
argument_list|)
operator|&&
operator|!
name|isutyp
argument_list|(
name|lt
argument_list|)
operator|&&
name|ln
operator|->
name|tn_op
operator|==
name|CON
operator|&&
name|ln
operator|->
name|tn_val
operator|->
name|v_quad
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|ln
operator|->
name|tn_val
operator|->
name|v_quad
operator|<
literal|0
condition|)
block|{
comment|/* comparision of %s with %s, op %s */
name|warning
argument_list|(
literal|162
argument_list|,
literal|"negative constant"
argument_list|,
name|tyname
argument_list|(
name|rn
operator|->
name|tn_type
argument_list|)
argument_list|,
name|mp
operator|->
name|m_name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|op
operator|==
name|GT
operator|||
name|op
operator|==
name|LE
operator|||
operator|(
name|hflag
operator|&&
name|op
operator|==
name|GE
operator|)
condition|)
block|{
comment|/* comparision of %s with %s, op %s */
name|warning
argument_list|(
literal|162
argument_list|,
literal|"0"
argument_list|,
name|tyname
argument_list|(
name|rn
operator|->
name|tn_type
argument_list|)
argument_list|,
name|mp
operator|->
name|m_name
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
block|}
end_block

begin_comment
comment|/*  * Takes an expression an returns 0 if this expression can be used  * for static initialisation, otherwise -1.  *  * Constant initialisation expressions must be costant or an address  * of a static object with an optional offset. In the first case,  * the result is returned in *offsp. In the second case, the static  * object is returned in *symp and the offset in *offsp.  *  * The expression can consist of PLUS, MINUS, AMPER, NAME, STRING and  * CON. Type conversions are allowed if they do not change binary  * representation (including width).  */
end_comment

begin_function
name|int
name|conaddr
parameter_list|(
name|tn
parameter_list|,
name|symp
parameter_list|,
name|offsp
parameter_list|)
name|tnode_t
modifier|*
name|tn
decl_stmt|;
name|sym_t
modifier|*
modifier|*
name|symp
decl_stmt|;
name|ptrdiff_t
modifier|*
name|offsp
decl_stmt|;
block|{
name|sym_t
modifier|*
name|sym
decl_stmt|;
name|ptrdiff_t
name|offs1
decl_stmt|,
name|offs2
decl_stmt|;
name|tspec_t
name|t
decl_stmt|,
name|ot
decl_stmt|;
switch|switch
condition|(
name|tn
operator|->
name|tn_op
condition|)
block|{
case|case
name|MINUS
case|:
if|if
condition|(
name|tn
operator|->
name|tn_right
operator|->
name|tn_op
operator|!=
name|CON
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* FALLTHROUGH */
case|case
name|PLUS
case|:
name|offs1
operator|=
name|offs2
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tn
operator|->
name|tn_left
operator|->
name|tn_op
operator|==
name|CON
condition|)
block|{
name|offs1
operator|=
operator|(
name|ptrdiff_t
operator|)
name|tn
operator|->
name|tn_left
operator|->
name|tn_val
operator|->
name|v_quad
expr_stmt|;
if|if
condition|(
name|conaddr
argument_list|(
name|tn
operator|->
name|tn_right
argument_list|,
operator|&
name|sym
argument_list|,
operator|&
name|offs2
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|tn
operator|->
name|tn_right
operator|->
name|tn_op
operator|==
name|CON
condition|)
block|{
name|offs2
operator|=
operator|(
name|ptrdiff_t
operator|)
name|tn
operator|->
name|tn_right
operator|->
name|tn_val
operator|->
name|v_quad
expr_stmt|;
if|if
condition|(
name|tn
operator|->
name|tn_op
operator|==
name|MINUS
condition|)
name|offs2
operator|=
operator|-
name|offs2
expr_stmt|;
if|if
condition|(
name|conaddr
argument_list|(
name|tn
operator|->
name|tn_left
argument_list|,
operator|&
name|sym
argument_list|,
operator|&
name|offs1
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
operator|*
name|symp
operator|=
name|sym
expr_stmt|;
operator|*
name|offsp
operator|=
name|offs1
operator|+
name|offs2
expr_stmt|;
break|break;
case|case
name|AMPER
case|:
if|if
condition|(
name|tn
operator|->
name|tn_left
operator|->
name|tn_op
operator|==
name|NAME
condition|)
block|{
operator|*
name|symp
operator|=
name|tn
operator|->
name|tn_left
operator|->
name|tn_sym
expr_stmt|;
operator|*
name|offsp
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tn
operator|->
name|tn_left
operator|->
name|tn_op
operator|==
name|STRING
condition|)
block|{
comment|/* 			 * If this would be the front end of a compiler we 			 * would return a label instead of 0. 			 */
operator|*
name|offsp
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|CVT
case|:
name|t
operator|=
name|tn
operator|->
name|tn_type
operator|->
name|t_tspec
expr_stmt|;
name|ot
operator|=
name|tn
operator|->
name|tn_left
operator|->
name|tn_type
operator|->
name|t_tspec
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|isityp
argument_list|(
name|t
argument_list|)
operator|&&
name|t
operator|!=
name|PTR
operator|)
operator|||
operator|(
operator|!
name|isityp
argument_list|(
name|ot
argument_list|)
operator|&&
name|ot
operator|!=
name|PTR
operator|)
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|psize
argument_list|(
name|t
argument_list|)
operator|!=
name|psize
argument_list|(
name|ot
argument_list|)
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|conaddr
argument_list|(
name|tn
operator|->
name|tn_left
argument_list|,
name|symp
argument_list|,
name|offsp
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
break|break;
default|default:
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Concatenate two string constants.  */
end_comment

begin_function
name|strg_t
modifier|*
name|catstrg
parameter_list|(
name|strg1
parameter_list|,
name|strg2
parameter_list|)
name|strg_t
modifier|*
name|strg1
decl_stmt|,
decl|*
name|strg2
decl_stmt|;
end_function

begin_block
block|{
name|size_t
name|len1
decl_stmt|,
name|len2
decl_stmt|,
name|len
decl_stmt|;
if|if
condition|(
name|strg1
operator|->
name|st_tspec
operator|!=
name|strg2
operator|->
name|st_tspec
condition|)
block|{
comment|/* cannot concatenate wide and regular string literals */
name|error
argument_list|(
literal|292
argument_list|)
expr_stmt|;
return|return
operator|(
name|strg1
operator|)
return|;
block|}
name|len
operator|=
operator|(
name|len1
operator|=
name|strg1
operator|->
name|st_len
operator|)
operator|+
operator|(
name|len2
operator|=
name|strg2
operator|->
name|st_len
operator|)
expr_stmt|;
if|if
condition|(
name|strg1
operator|->
name|st_tspec
operator|==
name|CHAR
condition|)
block|{
name|strg1
operator|->
name|st_cp
operator|=
name|xrealloc
argument_list|(
name|strg1
operator|->
name|st_cp
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|memcpy
argument_list|(
name|strg1
operator|->
name|st_cp
operator|+
name|len1
argument_list|,
name|strg2
operator|->
name|st_cp
argument_list|,
name|len2
operator|+
literal|1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|strg2
operator|->
name|st_cp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strg1
operator|->
name|st_wcp
operator|=
name|xrealloc
argument_list|(
name|strg1
operator|->
name|st_wcp
argument_list|,
operator|(
name|len
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|wchar_t
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|memcpy
argument_list|(
name|strg1
operator|->
name|st_wcp
operator|+
name|len1
argument_list|,
name|strg2
operator|->
name|st_wcp
argument_list|,
operator|(
name|len2
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|wchar_t
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|strg2
operator|->
name|st_wcp
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|strg2
argument_list|)
expr_stmt|;
return|return
operator|(
name|strg1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Print a warning if the given node has operands which should be  * parenthesized.  *  * XXX Does not work if an operand is a constant expression. Constant  * expressions are already folded.  */
end_comment

begin_function
specifier|static
name|void
name|precconf
parameter_list|(
name|tn
parameter_list|)
name|tnode_t
modifier|*
name|tn
decl_stmt|;
block|{
name|tnode_t
modifier|*
name|ln
decl_stmt|,
modifier|*
name|rn
decl_stmt|;
name|op_t
name|lop
decl_stmt|,
name|rop
decl_stmt|;
name|int
name|lparn
decl_stmt|,
name|rparn
decl_stmt|;
name|mod_t
modifier|*
name|mp
decl_stmt|;
name|int
name|warn
decl_stmt|;
if|if
condition|(
operator|!
name|hflag
condition|)
return|return;
name|mp
operator|=
operator|&
name|modtab
index|[
name|tn
operator|->
name|tn_op
index|]
expr_stmt|;
name|lparn
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ln
operator|=
name|tn
operator|->
name|tn_left
init|;
name|ln
operator|->
name|tn_op
operator|==
name|CVT
condition|;
name|ln
operator|=
name|ln
operator|->
name|tn_left
control|)
name|lparn
operator||=
name|ln
operator|->
name|tn_parn
expr_stmt|;
name|lparn
operator||=
name|ln
operator|->
name|tn_parn
expr_stmt|;
name|lop
operator|=
name|ln
operator|->
name|tn_op
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|m_binary
condition|)
block|{
name|rparn
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|rn
operator|=
name|tn
operator|->
name|tn_right
init|;
name|tn
operator|->
name|tn_op
operator|==
name|CVT
condition|;
name|rn
operator|=
name|rn
operator|->
name|tn_left
control|)
name|rparn
operator||=
name|rn
operator|->
name|tn_parn
expr_stmt|;
name|rparn
operator||=
name|rn
operator|->
name|tn_parn
expr_stmt|;
name|rop
operator|=
name|rn
operator|->
name|tn_op
expr_stmt|;
block|}
name|warn
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|tn
operator|->
name|tn_op
condition|)
block|{
case|case
name|SHL
case|:
case|case
name|SHR
case|:
if|if
condition|(
operator|!
name|lparn
operator|&&
operator|(
name|lop
operator|==
name|PLUS
operator|||
name|lop
operator|==
name|MINUS
operator|)
condition|)
block|{
name|warn
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|rparn
operator|&&
operator|(
name|rop
operator|==
name|PLUS
operator|||
name|rop
operator|==
name|MINUS
operator|)
condition|)
block|{
name|warn
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|LOGOR
case|:
if|if
condition|(
operator|!
name|lparn
operator|&&
name|lop
operator|==
name|LOGAND
condition|)
block|{
name|warn
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|rparn
operator|&&
name|rop
operator|==
name|LOGAND
condition|)
block|{
name|warn
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|AND
case|:
case|case
name|XOR
case|:
case|case
name|OR
case|:
if|if
condition|(
operator|!
name|lparn
operator|&&
name|lop
operator|!=
name|tn
operator|->
name|tn_op
condition|)
block|{
if|if
condition|(
name|lop
operator|==
name|PLUS
operator|||
name|lop
operator|==
name|MINUS
condition|)
block|{
name|warn
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lop
operator|==
name|AND
operator|||
name|lop
operator|==
name|XOR
condition|)
block|{
name|warn
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|warn
operator|&&
operator|!
name|rparn
operator|&&
name|rop
operator|!=
name|tn
operator|->
name|tn_op
condition|)
block|{
if|if
condition|(
name|rop
operator|==
name|PLUS
operator|||
name|rop
operator|==
name|MINUS
condition|)
block|{
name|warn
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rop
operator|==
name|AND
operator|||
name|rop
operator|==
name|XOR
condition|)
block|{
name|warn
operator|=
literal|1
expr_stmt|;
block|}
block|}
break|break;
comment|/* LINTED (enumeration values not handled in switch) */
default|default:
block|}
if|if
condition|(
name|warn
condition|)
block|{
comment|/* precedence confusion possible: parenthesize! */
name|warning
argument_list|(
literal|169
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

