begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $NetBSD: emit1.c,v 1.11 2002/01/31 19:36:54 tv Exp $ */
end_comment

begin_comment
comment|/*  * Copyright (c) 1996 Christopher G. Demetriou.  All Rights Reserved.  * Copyright (c) 1994, 1995 Jochen Pohl  * All Rights Reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *      This product includes software developed by Jochen Pohl for  *	The NetBSD Project.  * 4. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__RCSID
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
end_if

begin_expr_stmt
name|__RCSID
argument_list|(
literal|"$NetBSD: emit1.c,v 1.11 2002/01/31 19:36:54 tv Exp $"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"lint1.h"
end_include

begin_function_decl
specifier|static
name|void
name|outtt
parameter_list|(
name|sym_t
modifier|*
parameter_list|,
name|sym_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|outfstrg
parameter_list|(
name|strg_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Write type into the output buffer.  * The type is written as a sequence of substrings, each of which describes a  * node of type type_t  * a node is coded as follows:  *	char			C  *	signed char		s C  *	unsigned char		u C  *	short			S  *	unsigned short		u S  *	int			I  *	unsigned int		u I  *	long			L  *	unsigned long		u L  *	long long		Q  *	unsigned long long	u Q  *	float			s D  *	double			D  *	long double		l D  *	void			V  *	*			P  *	[n]			A n  *	()			F  *	(void)			F 0  *	(n arguments)		F n arg1 arg2 ... argn  *	(n arguments, ...)	F n arg1 arg2 ... argn-1 E  *	(a, b, c, ...)		f n arg1 arg2 ...  *	enum tag		e T tag_or_typename  *	struct tag		s T tag_or_typename  *	union tag		u T tag_or_typename  *  *	tag_or_typename		0			no tag or type name  *				1 n tag			Tag  *				2 n typename		only type name  *  * spaces are only for better readability  * additionaly it is possible to prepend the characters 'c' (for const)  * and 'v' (for volatile)  */
end_comment

begin_function
name|void
name|outtype
parameter_list|(
name|type_t
modifier|*
name|tp
parameter_list|)
block|{
name|int
name|t
decl_stmt|,
name|s
decl_stmt|,
name|na
decl_stmt|;
name|sym_t
modifier|*
name|arg
decl_stmt|;
name|tspec_t
name|ts
decl_stmt|;
while|while
condition|(
name|tp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|ts
operator|=
name|tp
operator|->
name|t_tspec
operator|)
operator|==
name|INT
operator|&&
name|tp
operator|->
name|t_isenum
condition|)
name|ts
operator|=
name|ENUM
expr_stmt|;
switch|switch
condition|(
name|ts
condition|)
block|{
case|case
name|CHAR
case|:
name|t
operator|=
literal|'C'
expr_stmt|;
name|s
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
name|SCHAR
case|:
name|t
operator|=
literal|'C'
expr_stmt|;
name|s
operator|=
literal|'s'
expr_stmt|;
break|break;
case|case
name|UCHAR
case|:
name|t
operator|=
literal|'C'
expr_stmt|;
name|s
operator|=
literal|'u'
expr_stmt|;
break|break;
case|case
name|SHORT
case|:
name|t
operator|=
literal|'S'
expr_stmt|;
name|s
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
name|USHORT
case|:
name|t
operator|=
literal|'S'
expr_stmt|;
name|s
operator|=
literal|'u'
expr_stmt|;
break|break;
case|case
name|INT
case|:
name|t
operator|=
literal|'I'
expr_stmt|;
name|s
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
name|UINT
case|:
name|t
operator|=
literal|'I'
expr_stmt|;
name|s
operator|=
literal|'u'
expr_stmt|;
break|break;
case|case
name|LONG
case|:
name|t
operator|=
literal|'L'
expr_stmt|;
name|s
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
name|ULONG
case|:
name|t
operator|=
literal|'L'
expr_stmt|;
name|s
operator|=
literal|'u'
expr_stmt|;
break|break;
case|case
name|QUAD
case|:
name|t
operator|=
literal|'Q'
expr_stmt|;
name|s
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
name|UQUAD
case|:
name|t
operator|=
literal|'Q'
expr_stmt|;
name|s
operator|=
literal|'u'
expr_stmt|;
break|break;
case|case
name|FLOAT
case|:
name|t
operator|=
literal|'D'
expr_stmt|;
name|s
operator|=
literal|'s'
expr_stmt|;
break|break;
case|case
name|DOUBLE
case|:
name|t
operator|=
literal|'D'
expr_stmt|;
name|s
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
name|LDOUBLE
case|:
name|t
operator|=
literal|'D'
expr_stmt|;
name|s
operator|=
literal|'l'
expr_stmt|;
break|break;
case|case
name|VOID
case|:
name|t
operator|=
literal|'V'
expr_stmt|;
name|s
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
name|PTR
case|:
name|t
operator|=
literal|'P'
expr_stmt|;
name|s
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
name|ARRAY
case|:
name|t
operator|=
literal|'A'
expr_stmt|;
name|s
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
name|FUNC
case|:
name|t
operator|=
literal|'F'
expr_stmt|;
name|s
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
name|ENUM
case|:
name|t
operator|=
literal|'T'
expr_stmt|;
name|s
operator|=
literal|'e'
expr_stmt|;
break|break;
case|case
name|STRUCT
case|:
name|t
operator|=
literal|'T'
expr_stmt|;
name|s
operator|=
literal|'s'
expr_stmt|;
break|break;
case|case
name|UNION
case|:
name|t
operator|=
literal|'T'
expr_stmt|;
name|s
operator|=
literal|'u'
expr_stmt|;
break|break;
default|default:
name|lerror
argument_list|(
literal|"outtyp() 1"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tp
operator|->
name|t_const
condition|)
name|outchar
argument_list|(
literal|'c'
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_volatile
condition|)
name|outchar
argument_list|(
literal|'v'
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
literal|'\0'
condition|)
name|outchar
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|outchar
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|ts
operator|==
name|ARRAY
condition|)
block|{
name|outint
argument_list|(
name|tp
operator|->
name|t_dim
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ts
operator|==
name|ENUM
condition|)
block|{
name|outtt
argument_list|(
name|tp
operator|->
name|t_enum
operator|->
name|etag
argument_list|,
name|tp
operator|->
name|t_enum
operator|->
name|etdef
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ts
operator|==
name|STRUCT
operator|||
name|ts
operator|==
name|UNION
condition|)
block|{
name|outtt
argument_list|(
name|tp
operator|->
name|t_str
operator|->
name|stag
argument_list|,
name|tp
operator|->
name|t_str
operator|->
name|stdef
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ts
operator|==
name|FUNC
operator|&&
name|tp
operator|->
name|t_proto
condition|)
block|{
name|na
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|arg
operator|=
name|tp
operator|->
name|t_args
init|;
name|arg
operator|!=
name|NULL
condition|;
name|arg
operator|=
name|arg
operator|->
name|s_nxt
control|)
name|na
operator|++
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_vararg
condition|)
name|na
operator|++
expr_stmt|;
name|outint
argument_list|(
name|na
argument_list|)
expr_stmt|;
for|for
control|(
name|arg
operator|=
name|tp
operator|->
name|t_args
init|;
name|arg
operator|!=
name|NULL
condition|;
name|arg
operator|=
name|arg
operator|->
name|s_nxt
control|)
name|outtype
argument_list|(
name|arg
operator|->
name|s_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_vararg
condition|)
name|outchar
argument_list|(
literal|'E'
argument_list|)
expr_stmt|;
block|}
name|tp
operator|=
name|tp
operator|->
name|t_subt
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * type to string  * used for debugging output  *  * it uses its own output buffer for conversion  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|ttos
parameter_list|(
name|type_t
modifier|*
name|tp
parameter_list|)
block|{
specifier|static
name|ob_t
name|tob
decl_stmt|;
name|ob_t
name|tmp
decl_stmt|;
if|if
condition|(
name|tob
operator|.
name|o_buf
operator|==
name|NULL
condition|)
block|{
name|tob
operator|.
name|o_len
operator|=
literal|64
expr_stmt|;
name|tob
operator|.
name|o_buf
operator|=
name|tob
operator|.
name|o_nxt
operator|=
name|xmalloc
argument_list|(
name|tob
operator|.
name|o_len
argument_list|)
expr_stmt|;
name|tob
operator|.
name|o_end
operator|=
name|tob
operator|.
name|o_buf
operator|+
name|tob
operator|.
name|o_len
expr_stmt|;
block|}
name|tmp
operator|=
name|ob
expr_stmt|;
name|ob
operator|=
name|tob
expr_stmt|;
name|ob
operator|.
name|o_nxt
operator|=
name|ob
operator|.
name|o_buf
expr_stmt|;
name|outtype
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|outchar
argument_list|(
literal|'\0'
argument_list|)
expr_stmt|;
name|tob
operator|=
name|ob
expr_stmt|;
name|ob
operator|=
name|tmp
expr_stmt|;
return|return
operator|(
name|tob
operator|.
name|o_buf
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * write the name of a tag or typename  *  * if the tag is named, the name of the  * tag is written, otherwise, if a typename exists which  * refers to this tag, this typename is written  */
end_comment

begin_function
specifier|static
name|void
name|outtt
parameter_list|(
name|sym_t
modifier|*
name|tag
parameter_list|,
name|sym_t
modifier|*
name|tdef
parameter_list|)
block|{
comment|/* 	 * 0 is no longer used. 	 */
if|if
condition|(
name|tag
operator|->
name|s_name
operator|!=
name|unnamed
condition|)
block|{
name|outint
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|outname
argument_list|(
name|tag
operator|->
name|s_name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tdef
operator|!=
name|NULL
condition|)
block|{
name|outint
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|outname
argument_list|(
name|tdef
operator|->
name|s_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|outint
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|outint
argument_list|(
name|tag
operator|->
name|s_dpos
operator|.
name|p_line
argument_list|)
expr_stmt|;
name|outchar
argument_list|(
literal|'.'
argument_list|)
expr_stmt|;
name|outint
argument_list|(
name|getfnid
argument_list|(
name|tag
operator|->
name|s_dpos
operator|.
name|p_file
argument_list|)
argument_list|)
expr_stmt|;
name|outchar
argument_list|(
literal|'.'
argument_list|)
expr_stmt|;
name|outint
argument_list|(
name|tag
operator|->
name|s_dpos
operator|.
name|p_uniq
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * write information about an global declared/defined symbol  * with storage class extern  *  * informations about function definitions are written in outfdef(),  * not here  */
end_comment

begin_function
name|void
name|outsym
parameter_list|(
name|sym_t
modifier|*
name|sym
parameter_list|,
name|scl_t
name|sc
parameter_list|,
name|def_t
name|def
parameter_list|)
block|{
comment|/* 	 * Static function declarations must also be written to the output 	 * file. Compatibility of function declarations (for both static 	 * and extern functions) must be checked in lint2. Lint1 can't do 	 * this, especially not, if functions are declared at block level 	 * before their first declaration at level 0. 	 */
if|if
condition|(
name|sc
operator|!=
name|EXTERN
operator|&&
operator|!
operator|(
name|sc
operator|==
name|STATIC
operator|&&
name|sym
operator|->
name|s_type
operator|->
name|t_tspec
operator|==
name|FUNC
operator|)
condition|)
return|return;
comment|/* reset buffer */
name|outclr
argument_list|()
expr_stmt|;
comment|/* 	 * line number of .c source, 'd' for declaration, Id of current 	 * source (.c or .h), and line in current source. 	 */
name|outint
argument_list|(
name|csrc_pos
operator|.
name|p_line
argument_list|)
expr_stmt|;
name|outchar
argument_list|(
literal|'d'
argument_list|)
expr_stmt|;
name|outint
argument_list|(
name|getfnid
argument_list|(
name|sym
operator|->
name|s_dpos
operator|.
name|p_file
argument_list|)
argument_list|)
expr_stmt|;
name|outchar
argument_list|(
literal|'.'
argument_list|)
expr_stmt|;
name|outint
argument_list|(
name|sym
operator|->
name|s_dpos
operator|.
name|p_line
argument_list|)
expr_stmt|;
comment|/* flags */
switch|switch
condition|(
name|def
condition|)
block|{
case|case
name|DEF
case|:
comment|/* defined */
name|outchar
argument_list|(
literal|'d'
argument_list|)
expr_stmt|;
break|break;
case|case
name|TDEF
case|:
comment|/* tentative defined */
name|outchar
argument_list|(
literal|'t'
argument_list|)
expr_stmt|;
break|break;
case|case
name|DECL
case|:
comment|/* declared */
name|outchar
argument_list|(
literal|'e'
argument_list|)
expr_stmt|;
break|break;
default|default:
name|lerror
argument_list|(
literal|"outsym() 2"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|llibflg
operator|&&
name|def
operator|!=
name|DECL
condition|)
block|{
comment|/* 		 * mark it as used so we get no warnings from lint2 about 		 * unused symbols in libraries. 		 */
name|outchar
argument_list|(
literal|'u'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|==
name|STATIC
condition|)
name|outchar
argument_list|(
literal|'s'
argument_list|)
expr_stmt|;
comment|/* name of the symbol */
name|outname
argument_list|(
name|sym
operator|->
name|s_name
argument_list|)
expr_stmt|;
comment|/* renamed name of symbol, if necessary */
if|if
condition|(
name|sym
operator|->
name|s_rename
condition|)
block|{
name|outchar
argument_list|(
literal|'r'
argument_list|)
expr_stmt|;
name|outname
argument_list|(
name|sym
operator|->
name|s_rename
argument_list|)
expr_stmt|;
block|}
comment|/* type of the symbol */
name|outtype
argument_list|(
name|sym
operator|->
name|s_type
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * write information about function definition  *  * this is also done for static functions so we are able to check if  * they are called with proper argument types  */
end_comment

begin_function
name|void
name|outfdef
parameter_list|(
name|sym_t
modifier|*
name|fsym
parameter_list|,
name|pos_t
modifier|*
name|posp
parameter_list|,
name|int
name|rval
parameter_list|,
name|int
name|osdef
parameter_list|,
name|sym_t
modifier|*
name|args
parameter_list|)
block|{
name|int
name|narg
decl_stmt|;
name|sym_t
modifier|*
name|arg
decl_stmt|;
comment|/* reset the buffer */
name|outclr
argument_list|()
expr_stmt|;
comment|/* 	 * line number of .c source, 'd' for declaration, Id of current 	 * source (.c or .h), and line in current source 	 * 	 * we are already at the end of the function. If we are in the 	 * .c source, posp->p_line is correct, otherwise csrc_pos.p_line 	 * (for functions defined in header files). 	 */
if|if
condition|(
name|posp
operator|->
name|p_file
operator|==
name|csrc_pos
operator|.
name|p_file
condition|)
block|{
name|outint
argument_list|(
name|posp
operator|->
name|p_line
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|outint
argument_list|(
name|csrc_pos
operator|.
name|p_line
argument_list|)
expr_stmt|;
block|}
name|outchar
argument_list|(
literal|'d'
argument_list|)
expr_stmt|;
name|outint
argument_list|(
name|getfnid
argument_list|(
name|posp
operator|->
name|p_file
argument_list|)
argument_list|)
expr_stmt|;
name|outchar
argument_list|(
literal|'.'
argument_list|)
expr_stmt|;
name|outint
argument_list|(
name|posp
operator|->
name|p_line
argument_list|)
expr_stmt|;
comment|/* flags */
comment|/* both SCANFLIKE and PRINTFLIKE imply VARARGS */
if|if
condition|(
name|prflstrg
operator|!=
operator|-
literal|1
condition|)
block|{
name|nvararg
operator|=
name|prflstrg
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scflstrg
operator|!=
operator|-
literal|1
condition|)
block|{
name|nvararg
operator|=
name|scflstrg
expr_stmt|;
block|}
if|if
condition|(
name|nvararg
operator|!=
operator|-
literal|1
condition|)
block|{
name|outchar
argument_list|(
literal|'v'
argument_list|)
expr_stmt|;
name|outint
argument_list|(
name|nvararg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|scflstrg
operator|!=
operator|-
literal|1
condition|)
block|{
name|outchar
argument_list|(
literal|'S'
argument_list|)
expr_stmt|;
name|outint
argument_list|(
name|scflstrg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|prflstrg
operator|!=
operator|-
literal|1
condition|)
block|{
name|outchar
argument_list|(
literal|'P'
argument_list|)
expr_stmt|;
name|outint
argument_list|(
name|prflstrg
argument_list|)
expr_stmt|;
block|}
name|nvararg
operator|=
name|prflstrg
operator|=
name|scflstrg
operator|=
operator|-
literal|1
expr_stmt|;
name|outchar
argument_list|(
literal|'d'
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
condition|)
comment|/* has return value */
name|outchar
argument_list|(
literal|'r'
argument_list|)
expr_stmt|;
if|if
condition|(
name|llibflg
condition|)
comment|/* 		 * mark it as used so lint2 does not complain about 		 * unused symbols in libraries 		 */
name|outchar
argument_list|(
literal|'u'
argument_list|)
expr_stmt|;
if|if
condition|(
name|osdef
condition|)
comment|/* old style function definition */
name|outchar
argument_list|(
literal|'o'
argument_list|)
expr_stmt|;
if|if
condition|(
name|fsym
operator|->
name|s_scl
operator|==
name|STATIC
condition|)
name|outchar
argument_list|(
literal|'s'
argument_list|)
expr_stmt|;
comment|/* name of function */
name|outname
argument_list|(
name|fsym
operator|->
name|s_name
argument_list|)
expr_stmt|;
comment|/* renamed name of function, if necessary */
if|if
condition|(
name|fsym
operator|->
name|s_rename
condition|)
block|{
name|outchar
argument_list|(
literal|'r'
argument_list|)
expr_stmt|;
name|outname
argument_list|(
name|fsym
operator|->
name|s_rename
argument_list|)
expr_stmt|;
block|}
comment|/* argument types and return value */
if|if
condition|(
name|osdef
condition|)
block|{
name|narg
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|arg
operator|=
name|args
init|;
name|arg
operator|!=
name|NULL
condition|;
name|arg
operator|=
name|arg
operator|->
name|s_nxt
control|)
name|narg
operator|++
expr_stmt|;
name|outchar
argument_list|(
literal|'f'
argument_list|)
expr_stmt|;
name|outint
argument_list|(
name|narg
argument_list|)
expr_stmt|;
for|for
control|(
name|arg
operator|=
name|args
init|;
name|arg
operator|!=
name|NULL
condition|;
name|arg
operator|=
name|arg
operator|->
name|s_nxt
control|)
name|outtype
argument_list|(
name|arg
operator|->
name|s_type
argument_list|)
expr_stmt|;
name|outtype
argument_list|(
name|fsym
operator|->
name|s_type
operator|->
name|t_subt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|outtype
argument_list|(
name|fsym
operator|->
name|s_type
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * write out all information necessary for lint2 to check function  * calls  *  * rvused is set if the return value is used (asigned to a variable)  * rvdisc is set if the return value is not used and not ignored  * (casted to void)  */
end_comment

begin_function
name|void
name|outcall
parameter_list|(
name|tnode_t
modifier|*
name|tn
parameter_list|,
name|int
name|rvused
parameter_list|,
name|int
name|rvdisc
parameter_list|)
block|{
name|tnode_t
modifier|*
name|args
decl_stmt|,
modifier|*
name|arg
decl_stmt|;
name|int
name|narg
decl_stmt|,
name|n
decl_stmt|,
name|i
decl_stmt|;
name|int64_t
name|q
decl_stmt|;
name|tspec_t
name|t
decl_stmt|;
comment|/* reset buffer */
name|outclr
argument_list|()
expr_stmt|;
comment|/* 	 * line number of .c source, 'c' for function call, Id of current 	 * source (.c or .h), and line in current source 	 */
name|outint
argument_list|(
name|csrc_pos
operator|.
name|p_line
argument_list|)
expr_stmt|;
name|outchar
argument_list|(
literal|'c'
argument_list|)
expr_stmt|;
name|outint
argument_list|(
name|getfnid
argument_list|(
name|curr_pos
operator|.
name|p_file
argument_list|)
argument_list|)
expr_stmt|;
name|outchar
argument_list|(
literal|'.'
argument_list|)
expr_stmt|;
name|outint
argument_list|(
name|curr_pos
operator|.
name|p_line
argument_list|)
expr_stmt|;
comment|/* 	 * flags; 'u' and 'i' must be last to make sure a letter 	 * is between the numeric argument of a flag and the name of 	 * the function 	 */
name|narg
operator|=
literal|0
expr_stmt|;
name|args
operator|=
name|tn
operator|->
name|tn_right
expr_stmt|;
for|for
control|(
name|arg
operator|=
name|args
init|;
name|arg
operator|!=
name|NULL
condition|;
name|arg
operator|=
name|arg
operator|->
name|tn_right
control|)
name|narg
operator|++
expr_stmt|;
comment|/* informations about arguments */
for|for
control|(
name|n
operator|=
literal|1
init|;
name|n
operator|<=
name|narg
condition|;
name|n
operator|++
control|)
block|{
comment|/* the last argument is the top one in the tree */
for|for
control|(
name|i
operator|=
name|narg
operator|,
name|arg
operator|=
name|args
init|;
name|i
operator|>
name|n
condition|;
name|i
operator|--
operator|,
name|arg
operator|=
name|arg
operator|->
name|tn_right
control|)
continue|continue;
name|arg
operator|=
name|arg
operator|->
name|tn_left
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|tn_op
operator|==
name|CON
condition|)
block|{
if|if
condition|(
name|isityp
argument_list|(
name|t
operator|=
name|arg
operator|->
name|tn_type
operator|->
name|t_tspec
argument_list|)
condition|)
block|{
comment|/* 				 * XXX it would probably be better to 				 * explizitly test the sign 				 */
if|if
condition|(
operator|(
name|q
operator|=
name|arg
operator|->
name|tn_val
operator|->
name|v_quad
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* zero constant */
name|outchar
argument_list|(
literal|'z'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|msb
argument_list|(
name|q
argument_list|,
name|t
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* positive if casted to signed */
name|outchar
argument_list|(
literal|'p'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* negative if casted to signed */
name|outchar
argument_list|(
literal|'n'
argument_list|)
expr_stmt|;
block|}
name|outint
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|arg
operator|->
name|tn_op
operator|==
name|AMPER
operator|&&
name|arg
operator|->
name|tn_left
operator|->
name|tn_op
operator|==
name|STRING
operator|&&
name|arg
operator|->
name|tn_left
operator|->
name|tn_strg
operator|->
name|st_tspec
operator|==
name|CHAR
condition|)
block|{
comment|/* constant string, write all format specifiers */
name|outchar
argument_list|(
literal|'s'
argument_list|)
expr_stmt|;
name|outint
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|outfstrg
argument_list|(
name|arg
operator|->
name|tn_left
operator|->
name|tn_strg
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* return value discarded/used/ignored */
name|outchar
argument_list|(
name|rvdisc
condition|?
literal|'d'
else|:
operator|(
name|rvused
condition|?
literal|'u'
else|:
literal|'i'
operator|)
argument_list|)
expr_stmt|;
comment|/* name of the called function */
name|outname
argument_list|(
name|tn
operator|->
name|tn_left
operator|->
name|tn_left
operator|->
name|tn_sym
operator|->
name|s_name
argument_list|)
expr_stmt|;
comment|/* types of arguments */
name|outchar
argument_list|(
literal|'f'
argument_list|)
expr_stmt|;
name|outint
argument_list|(
name|narg
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|1
init|;
name|n
operator|<=
name|narg
condition|;
name|n
operator|++
control|)
block|{
comment|/* the last argument is the top one in the tree */
for|for
control|(
name|i
operator|=
name|narg
operator|,
name|arg
operator|=
name|args
init|;
name|i
operator|>
name|n
condition|;
name|i
operator|--
operator|,
name|arg
operator|=
name|arg
operator|->
name|tn_right
control|)
continue|continue;
name|outtype
argument_list|(
name|arg
operator|->
name|tn_left
operator|->
name|tn_type
argument_list|)
expr_stmt|;
block|}
comment|/* expected type of return value */
name|outtype
argument_list|(
name|tn
operator|->
name|tn_type
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * extracts potential format specifiers for printf() and scanf() and  * writes them, enclosed in "" and qouted if necessary, to the output buffer  */
end_comment

begin_function
specifier|static
name|void
name|outfstrg
parameter_list|(
name|strg_t
modifier|*
name|strg
parameter_list|)
block|{
name|int
name|c
decl_stmt|,
name|oc
decl_stmt|,
name|first
decl_stmt|;
name|u_char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|strg
operator|->
name|st_tspec
operator|!=
name|CHAR
condition|)
name|lerror
argument_list|(
literal|"outfstrg() 1"
argument_list|)
expr_stmt|;
name|cp
operator|=
name|strg
operator|->
name|st_cp
expr_stmt|;
name|outchar
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
name|c
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
while|while
condition|(
name|c
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|c
operator|!=
literal|'%'
condition|)
block|{
name|c
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
continue|continue;
block|}
name|outqchar
argument_list|(
literal|'%'
argument_list|)
expr_stmt|;
name|c
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
comment|/* flags for printf and scanf and *-fieldwidth for printf */
while|while
condition|(
name|c
operator|!=
literal|'\0'
operator|&&
operator|(
name|c
operator|==
literal|'-'
operator|||
name|c
operator|==
literal|'+'
operator|||
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'#'
operator|||
name|c
operator|==
literal|'0'
operator|||
name|c
operator|==
literal|'*'
operator|)
condition|)
block|{
name|outqchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|c
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
block|}
comment|/* numeric field width */
while|while
condition|(
name|c
operator|!=
literal|'\0'
operator|&&
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|outqchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|c
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
block|}
comment|/* precision for printf */
if|if
condition|(
name|c
operator|==
literal|'.'
condition|)
block|{
name|outqchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
operator|*
name|cp
operator|++
operator|)
operator|==
literal|'*'
condition|)
block|{
name|outqchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|c
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|c
operator|!=
literal|'\0'
operator|&&
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|outqchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|c
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
block|}
block|}
block|}
comment|/* h, l, L and q flags fpr printf and scanf */
if|if
condition|(
name|c
operator|==
literal|'h'
operator|||
name|c
operator|==
literal|'l'
operator|||
name|c
operator|==
literal|'L'
operator|||
name|c
operator|==
literal|'q'
condition|)
block|{
name|outqchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|c
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
block|}
comment|/* 		 * The last character. It is always written so we can detect 		 * invalid format specifiers. 		 */
if|if
condition|(
name|c
operator|!=
literal|'\0'
condition|)
block|{
name|outqchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|oc
operator|=
name|c
expr_stmt|;
name|c
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
comment|/* 			 * handle [ for scanf. [-] means that a minus sign 			 * was found at an undefined position. 			 */
if|if
condition|(
name|oc
operator|==
literal|'['
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'^'
condition|)
name|c
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|']'
condition|)
name|c
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
name|first
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|c
operator|!=
literal|'\0'
operator|&&
name|c
operator|!=
literal|']'
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
operator|!
name|first
operator|&&
operator|*
name|cp
operator|!=
literal|']'
condition|)
name|outqchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
name|first
operator|=
literal|0
expr_stmt|;
name|c
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|']'
condition|)
block|{
name|outqchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|c
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
name|outchar
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * writes a record if sym was used  */
end_comment

begin_function
name|void
name|outusg
parameter_list|(
name|sym_t
modifier|*
name|sym
parameter_list|)
block|{
comment|/* reset buffer */
name|outclr
argument_list|()
expr_stmt|;
comment|/* 	 * line number of .c source, 'u' for used, Id of current 	 * source (.c or .h), and line in current source 	 */
name|outint
argument_list|(
name|csrc_pos
operator|.
name|p_line
argument_list|)
expr_stmt|;
name|outchar
argument_list|(
literal|'u'
argument_list|)
expr_stmt|;
name|outint
argument_list|(
name|getfnid
argument_list|(
name|curr_pos
operator|.
name|p_file
argument_list|)
argument_list|)
expr_stmt|;
name|outchar
argument_list|(
literal|'.'
argument_list|)
expr_stmt|;
name|outint
argument_list|(
name|curr_pos
operator|.
name|p_line
argument_list|)
expr_stmt|;
comment|/* necessary to delimit both numbers */
name|outchar
argument_list|(
literal|'x'
argument_list|)
expr_stmt|;
comment|/* Den Namen des Symbols ausgeben */
name|outname
argument_list|(
name|sym
operator|->
name|s_name
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

