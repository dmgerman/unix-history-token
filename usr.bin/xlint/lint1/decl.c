begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $NetBSD: decl.c,v 1.29 2002/01/18 21:01:39 thorpej Exp $ */
end_comment

begin_comment
comment|/*  * Copyright (c) 1996 Christopher G. Demetriou.  All Rights Reserved.  * Copyright (c) 1994, 1995 Jochen Pohl  * All Rights Reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *      This product includes software developed by Jochen Pohl for  *	The NetBSD Project.  * 4. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__RCSID
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
end_if

begin_expr_stmt
name|__RCSID
argument_list|(
literal|"$NetBSD: decl.c,v 1.29 2002/01/18 21:01:39 thorpej Exp $"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"lint1.h"
end_include

begin_decl_stmt
specifier|const
name|char
modifier|*
name|unnamed
init|=
literal|"<unnamed>"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* shared type structures for arithmtic types and void */
end_comment

begin_decl_stmt
specifier|static
name|type_t
modifier|*
name|typetab
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* value of next enumerator during declaration of enum types */
end_comment

begin_decl_stmt
name|int
name|enumval
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * pointer to top element of a stack which contains informations local  * to nested declarations  */
end_comment

begin_decl_stmt
name|dinfo_t
modifier|*
name|dcs
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|type_t
modifier|*
name|tdeferr
parameter_list|(
name|type_t
modifier|*
parameter_list|,
name|tspec_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|settdsym
parameter_list|(
name|type_t
modifier|*
parameter_list|,
name|sym_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tspec_t
name|mrgtspec
parameter_list|(
name|tspec_t
parameter_list|,
name|tspec_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|align
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|sym_t
modifier|*
name|newtag
parameter_list|(
name|sym_t
modifier|*
parameter_list|,
name|scl_t
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|eqargs
parameter_list|(
name|type_t
modifier|*
parameter_list|,
name|type_t
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mnoarg
parameter_list|(
name|type_t
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|chkosdef
parameter_list|(
name|sym_t
modifier|*
parameter_list|,
name|sym_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|chkptdecl
parameter_list|(
name|sym_t
modifier|*
parameter_list|,
name|sym_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|sym_t
modifier|*
name|nsfunc
parameter_list|(
name|sym_t
modifier|*
parameter_list|,
name|sym_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|osfunc
parameter_list|(
name|sym_t
modifier|*
parameter_list|,
name|sym_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ledecl
parameter_list|(
name|sym_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|chkinit
parameter_list|(
name|sym_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|chkausg
parameter_list|(
name|int
parameter_list|,
name|sym_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|chkvusg
parameter_list|(
name|int
parameter_list|,
name|sym_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|chklusg
parameter_list|(
name|sym_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|chktusg
parameter_list|(
name|sym_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|chkglvar
parameter_list|(
name|sym_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|glchksz
parameter_list|(
name|sym_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * initializes all global vars used in declarations  */
end_comment

begin_function
name|void
name|initdecl
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* declaration stack */
if|if
condition|(
operator|(
name|dcs
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|dinfo_t
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|nomem
argument_list|()
expr_stmt|;
name|dcs
operator|->
name|d_ctx
operator|=
name|EXTERN
expr_stmt|;
name|dcs
operator|->
name|d_ldlsym
operator|=
operator|&
name|dcs
operator|->
name|d_dlsyms
expr_stmt|;
comment|/* type information and classification */
name|inittyp
argument_list|()
expr_stmt|;
comment|/* shared type structures */
if|if
condition|(
operator|(
name|typetab
operator|=
name|calloc
argument_list|(
name|NTSPEC
argument_list|,
sizeof|sizeof
argument_list|(
name|type_t
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|nomem
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NTSPEC
condition|;
name|i
operator|++
control|)
name|typetab
index|[
name|i
index|]
operator|.
name|t_tspec
operator|=
name|NOTSPEC
expr_stmt|;
name|typetab
index|[
name|CHAR
index|]
operator|.
name|t_tspec
operator|=
name|CHAR
expr_stmt|;
name|typetab
index|[
name|SCHAR
index|]
operator|.
name|t_tspec
operator|=
name|SCHAR
expr_stmt|;
name|typetab
index|[
name|UCHAR
index|]
operator|.
name|t_tspec
operator|=
name|UCHAR
expr_stmt|;
name|typetab
index|[
name|SHORT
index|]
operator|.
name|t_tspec
operator|=
name|SHORT
expr_stmt|;
name|typetab
index|[
name|USHORT
index|]
operator|.
name|t_tspec
operator|=
name|USHORT
expr_stmt|;
name|typetab
index|[
name|INT
index|]
operator|.
name|t_tspec
operator|=
name|INT
expr_stmt|;
name|typetab
index|[
name|UINT
index|]
operator|.
name|t_tspec
operator|=
name|UINT
expr_stmt|;
name|typetab
index|[
name|LONG
index|]
operator|.
name|t_tspec
operator|=
name|LONG
expr_stmt|;
name|typetab
index|[
name|ULONG
index|]
operator|.
name|t_tspec
operator|=
name|ULONG
expr_stmt|;
name|typetab
index|[
name|QUAD
index|]
operator|.
name|t_tspec
operator|=
name|QUAD
expr_stmt|;
name|typetab
index|[
name|UQUAD
index|]
operator|.
name|t_tspec
operator|=
name|UQUAD
expr_stmt|;
name|typetab
index|[
name|FLOAT
index|]
operator|.
name|t_tspec
operator|=
name|FLOAT
expr_stmt|;
name|typetab
index|[
name|DOUBLE
index|]
operator|.
name|t_tspec
operator|=
name|DOUBLE
expr_stmt|;
name|typetab
index|[
name|LDOUBLE
index|]
operator|.
name|t_tspec
operator|=
name|LDOUBLE
expr_stmt|;
name|typetab
index|[
name|VOID
index|]
operator|.
name|t_tspec
operator|=
name|VOID
expr_stmt|;
comment|/* 	 * Next two are not real types. They are only used by the parser 	 * to return keywords "signed" and "unsigned" 	 */
name|typetab
index|[
name|SIGNED
index|]
operator|.
name|t_tspec
operator|=
name|SIGNED
expr_stmt|;
name|typetab
index|[
name|UNSIGN
index|]
operator|.
name|t_tspec
operator|=
name|UNSIGN
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Returns a shared type structure vor arithmetic types and void.  *  * It's important do duplicate this structure (using duptyp() or tdupdyp())  * if it is to be modified (adding qualifiers or anything else).  */
end_comment

begin_function
name|type_t
modifier|*
name|gettyp
parameter_list|(
name|tspec_t
name|t
parameter_list|)
block|{
return|return
operator|(
operator|&
name|typetab
index|[
name|t
index|]
operator|)
return|;
block|}
end_function

begin_function
name|type_t
modifier|*
name|duptyp
parameter_list|(
specifier|const
name|type_t
modifier|*
name|tp
parameter_list|)
block|{
name|type_t
modifier|*
name|ntp
decl_stmt|;
name|ntp
operator|=
name|getblk
argument_list|(
sizeof|sizeof
argument_list|(
name|type_t
argument_list|)
argument_list|)
expr_stmt|;
name|STRUCT_ASSIGN
argument_list|(
operator|*
name|ntp
argument_list|,
operator|*
name|tp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ntp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Use tduptyp() instead of duptyp() inside expressions (if the  * allocated memory should be freed after the expr).  */
end_comment

begin_function
name|type_t
modifier|*
name|tduptyp
parameter_list|(
specifier|const
name|type_t
modifier|*
name|tp
parameter_list|)
block|{
name|type_t
modifier|*
name|ntp
decl_stmt|;
name|ntp
operator|=
name|tgetblk
argument_list|(
sizeof|sizeof
argument_list|(
name|type_t
argument_list|)
argument_list|)
expr_stmt|;
name|STRUCT_ASSIGN
argument_list|(
operator|*
name|ntp
argument_list|,
operator|*
name|tp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ntp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns 1 if the argument is void or an incomplete array,  * struct, union or enum type.  */
end_comment

begin_function
name|int
name|incompl
parameter_list|(
name|type_t
modifier|*
name|tp
parameter_list|)
block|{
name|tspec_t
name|t
decl_stmt|;
if|if
condition|(
operator|(
name|t
operator|=
name|tp
operator|->
name|t_tspec
operator|)
operator|==
name|VOID
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|t
operator|==
name|ARRAY
condition|)
block|{
return|return
operator|(
name|tp
operator|->
name|t_aincompl
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|t
operator|==
name|STRUCT
operator|||
name|t
operator|==
name|UNION
condition|)
block|{
return|return
operator|(
name|tp
operator|->
name|t_str
operator|->
name|sincompl
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|t
operator|==
name|ENUM
condition|)
block|{
return|return
operator|(
name|tp
operator|->
name|t_enum
operator|->
name|eincompl
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set the flag for (in)complete array, struct, union or enum  * types.  */
end_comment

begin_function
name|void
name|setcompl
parameter_list|(
name|type_t
modifier|*
name|tp
parameter_list|,
name|int
name|ic
parameter_list|)
block|{
name|tspec_t
name|t
decl_stmt|;
if|if
condition|(
operator|(
name|t
operator|=
name|tp
operator|->
name|t_tspec
operator|)
operator|==
name|ARRAY
condition|)
block|{
name|tp
operator|->
name|t_aincompl
operator|=
name|ic
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t
operator|==
name|STRUCT
operator|||
name|t
operator|==
name|UNION
condition|)
block|{
name|tp
operator|->
name|t_str
operator|->
name|sincompl
operator|=
name|ic
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|t
operator|!=
name|ENUM
condition|)
name|lerror
argument_list|(
literal|"setcompl() 1"
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_enum
operator|->
name|eincompl
operator|=
name|ic
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Remember the storage class of the current declaration in dcs->d_scl  * (the top element of the declaration stack) and detect multiple  * storage classes.  */
end_comment

begin_function
name|void
name|addscl
parameter_list|(
name|scl_t
name|sc
parameter_list|)
block|{
if|if
condition|(
name|sc
operator|==
name|INLINE
condition|)
block|{
if|if
condition|(
name|dcs
operator|->
name|d_inline
condition|)
comment|/* duplicate '%s' */
name|warning
argument_list|(
literal|10
argument_list|,
literal|"inline"
argument_list|)
expr_stmt|;
name|dcs
operator|->
name|d_inline
operator|=
literal|1
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|dcs
operator|->
name|d_type
operator|!=
name|NULL
operator|||
name|dcs
operator|->
name|d_atyp
operator|!=
name|NOTSPEC
operator|||
name|dcs
operator|->
name|d_smod
operator|!=
name|NOTSPEC
operator|||
name|dcs
operator|->
name|d_lmod
operator|!=
name|NOTSPEC
condition|)
block|{
comment|/* storage class after type is obsolescent */
name|warning
argument_list|(
literal|83
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dcs
operator|->
name|d_scl
operator|==
name|NOSCL
condition|)
block|{
name|dcs
operator|->
name|d_scl
operator|=
name|sc
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * multiple storage classes. An error will be reported in 		 * deftyp(). 		 */
name|dcs
operator|->
name|d_mscl
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Remember the type, modifier or typedef name returned by the parser  * in *dcs (top element of decl stack). This information is used in  * deftyp() to build the type used for all declarators in this  * declaration.  *  * Is tp->t_typedef 1, the type comes from a previously defined typename.  * Otherwise it comes from a type specifier (int, long, ...) or a  * struct/union/enum tag.  */
end_comment

begin_function
name|void
name|addtype
parameter_list|(
name|type_t
modifier|*
name|tp
parameter_list|)
block|{
name|tspec_t
name|t
decl_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_typedef
condition|)
block|{
if|if
condition|(
name|dcs
operator|->
name|d_type
operator|!=
name|NULL
operator|||
name|dcs
operator|->
name|d_atyp
operator|!=
name|NOTSPEC
operator|||
name|dcs
operator|->
name|d_lmod
operator|!=
name|NOTSPEC
operator|||
name|dcs
operator|->
name|d_smod
operator|!=
name|NOTSPEC
condition|)
block|{
comment|/* 			 * something like "typedef int a; int a b;" 			 * This should not happen with current grammar. 			 */
name|lerror
argument_list|(
literal|"addtype()"
argument_list|)
expr_stmt|;
block|}
name|dcs
operator|->
name|d_type
operator|=
name|tp
expr_stmt|;
return|return;
block|}
name|t
operator|=
name|tp
operator|->
name|t_tspec
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|STRUCT
operator|||
name|t
operator|==
name|UNION
operator|||
name|t
operator|==
name|ENUM
condition|)
block|{
comment|/* 		 * something like "int struct a ..." 		 * struct/union/enum with anything else is not allowed 		 */
if|if
condition|(
name|dcs
operator|->
name|d_type
operator|!=
name|NULL
operator|||
name|dcs
operator|->
name|d_atyp
operator|!=
name|NOTSPEC
operator|||
name|dcs
operator|->
name|d_lmod
operator|!=
name|NOTSPEC
operator|||
name|dcs
operator|->
name|d_smod
operator|!=
name|NOTSPEC
condition|)
block|{
comment|/* 			 * remember that an error must be reported in 			 * deftyp(). 			 */
name|dcs
operator|->
name|d_terr
operator|=
literal|1
expr_stmt|;
name|dcs
operator|->
name|d_atyp
operator|=
name|dcs
operator|->
name|d_lmod
operator|=
name|dcs
operator|->
name|d_smod
operator|=
name|NOTSPEC
expr_stmt|;
block|}
name|dcs
operator|->
name|d_type
operator|=
name|tp
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|dcs
operator|->
name|d_type
operator|!=
name|NULL
operator|&&
operator|!
name|dcs
operator|->
name|d_type
operator|->
name|t_typedef
condition|)
block|{
comment|/* 		 * something like "struct a int" 		 * struct/union/enum with anything else is not allowed 		 */
name|dcs
operator|->
name|d_terr
operator|=
literal|1
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|t
operator|==
name|LONG
operator|&&
name|dcs
operator|->
name|d_lmod
operator|==
name|LONG
condition|)
block|{
comment|/* "long long" or "long ... long" */
name|t
operator|=
name|QUAD
expr_stmt|;
name|dcs
operator|->
name|d_lmod
operator|=
name|NOTSPEC
expr_stmt|;
if|if
condition|(
operator|!
name|quadflg
condition|)
comment|/* %s C does not support 'long long' */
operator|(
name|void
operator|)
name|gnuism
argument_list|(
literal|265
argument_list|,
name|tflag
condition|?
literal|"traditional"
else|:
literal|"ANSI"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dcs
operator|->
name|d_type
operator|!=
name|NULL
operator|&&
name|dcs
operator|->
name|d_type
operator|->
name|t_typedef
condition|)
block|{
comment|/* something like "typedef int a; a long ..." */
name|dcs
operator|->
name|d_type
operator|=
name|tdeferr
argument_list|(
name|dcs
operator|->
name|d_type
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* now it can be only a combination of arithmetic types and void */
if|if
condition|(
name|t
operator|==
name|SIGNED
operator|||
name|t
operator|==
name|UNSIGN
condition|)
block|{
comment|/* remeber specifiers "signed" and "unsigned" in dcs->d_smod */
if|if
condition|(
name|dcs
operator|->
name|d_smod
operator|!=
name|NOTSPEC
condition|)
comment|/* 			 * more than one "signed" and/or "unsigned"; print 			 * an error in deftyp() 			 */
name|dcs
operator|->
name|d_terr
operator|=
literal|1
expr_stmt|;
name|dcs
operator|->
name|d_smod
operator|=
name|t
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t
operator|==
name|SHORT
operator|||
name|t
operator|==
name|LONG
operator|||
name|t
operator|==
name|QUAD
condition|)
block|{
comment|/* 		 * remember specifiers "short", "long" and "long long" in 		 * dcs->d_lmod 		 */
if|if
condition|(
name|dcs
operator|->
name|d_lmod
operator|!=
name|NOTSPEC
condition|)
comment|/* more than one, print error in deftyp() */
name|dcs
operator|->
name|d_terr
operator|=
literal|1
expr_stmt|;
name|dcs
operator|->
name|d_lmod
operator|=
name|t
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * remember specifiers "void", "char", "int", "float" or 		 * "double" int dcs->d_atyp 		 */
if|if
condition|(
name|dcs
operator|->
name|d_atyp
operator|!=
name|NOTSPEC
condition|)
comment|/* more than one, print error in deftyp() */
name|dcs
operator|->
name|d_terr
operator|=
literal|1
expr_stmt|;
name|dcs
operator|->
name|d_atyp
operator|=
name|t
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * called if a list of declaration specifiers contains a typedef name  * and other specifiers (except struct, union, enum, typedef name)  */
end_comment

begin_function
specifier|static
name|type_t
modifier|*
name|tdeferr
parameter_list|(
name|type_t
modifier|*
name|td
parameter_list|,
name|tspec_t
name|t
parameter_list|)
block|{
name|tspec_t
name|t2
decl_stmt|;
name|t2
operator|=
name|td
operator|->
name|t_tspec
expr_stmt|;
switch|switch
condition|(
name|t
condition|)
block|{
case|case
name|SIGNED
case|:
case|case
name|UNSIGN
case|:
if|if
condition|(
name|t2
operator|==
name|CHAR
operator|||
name|t2
operator|==
name|SHORT
operator|||
name|t2
operator|==
name|INT
operator|||
name|t2
operator|==
name|LONG
operator|||
name|t2
operator|==
name|QUAD
condition|)
block|{
if|if
condition|(
operator|!
name|tflag
condition|)
comment|/* modifying typedef with ... */
name|warning
argument_list|(
literal|5
argument_list|,
name|ttab
index|[
name|t
index|]
operator|.
name|tt_name
argument_list|)
expr_stmt|;
name|td
operator|=
name|duptyp
argument_list|(
name|gettyp
argument_list|(
name|mrgtspec
argument_list|(
name|t2
argument_list|,
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|td
operator|->
name|t_typedef
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|td
operator|)
return|;
block|}
break|break;
case|case
name|SHORT
case|:
if|if
condition|(
name|t2
operator|==
name|INT
operator|||
name|t2
operator|==
name|UINT
condition|)
block|{
comment|/* modifying typedef with ... */
name|warning
argument_list|(
literal|5
argument_list|,
literal|"short"
argument_list|)
expr_stmt|;
name|td
operator|=
name|duptyp
argument_list|(
name|gettyp
argument_list|(
name|t2
operator|==
name|INT
condition|?
name|SHORT
else|:
name|USHORT
argument_list|)
argument_list|)
expr_stmt|;
name|td
operator|->
name|t_typedef
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|td
operator|)
return|;
block|}
break|break;
case|case
name|LONG
case|:
if|if
condition|(
name|t2
operator|==
name|INT
operator|||
name|t2
operator|==
name|UINT
operator|||
name|t2
operator|==
name|LONG
operator|||
name|t2
operator|==
name|ULONG
operator|||
name|t2
operator|==
name|FLOAT
operator|||
name|t2
operator|==
name|DOUBLE
condition|)
block|{
comment|/* modifying typedef with ... */
name|warning
argument_list|(
literal|5
argument_list|,
literal|"long"
argument_list|)
expr_stmt|;
if|if
condition|(
name|t2
operator|==
name|INT
condition|)
block|{
name|td
operator|=
name|gettyp
argument_list|(
name|LONG
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t2
operator|==
name|UINT
condition|)
block|{
name|td
operator|=
name|gettyp
argument_list|(
name|ULONG
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t2
operator|==
name|LONG
condition|)
block|{
name|td
operator|=
name|gettyp
argument_list|(
name|QUAD
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t2
operator|==
name|ULONG
condition|)
block|{
name|td
operator|=
name|gettyp
argument_list|(
name|UQUAD
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t2
operator|==
name|FLOAT
condition|)
block|{
name|td
operator|=
name|gettyp
argument_list|(
name|DOUBLE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t2
operator|==
name|DOUBLE
condition|)
block|{
name|td
operator|=
name|gettyp
argument_list|(
name|LDOUBLE
argument_list|)
expr_stmt|;
block|}
name|td
operator|=
name|duptyp
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|td
operator|->
name|t_typedef
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|td
operator|)
return|;
block|}
break|break;
comment|/* LINTED (enumeration values not handled in switch) */
case|case
name|NOTSPEC
case|:
case|case
name|USHORT
case|:
case|case
name|UCHAR
case|:
case|case
name|SCHAR
case|:
case|case
name|CHAR
case|:
case|case
name|FUNC
case|:
case|case
name|ARRAY
case|:
case|case
name|PTR
case|:
case|case
name|ENUM
case|:
case|case
name|UNION
case|:
case|case
name|STRUCT
case|:
case|case
name|VOID
case|:
case|case
name|LDOUBLE
case|:
case|case
name|DOUBLE
case|:
case|case
name|FLOAT
case|:
case|case
name|UQUAD
case|:
case|case
name|QUAD
case|:
case|case
name|ULONG
case|:
case|case
name|UINT
case|:
case|case
name|INT
case|:
break|break;
case|case
name|NTSPEC
case|:
comment|/* this value unused */
break|break;
block|}
comment|/* Anything other is not accepted. */
name|dcs
operator|->
name|d_terr
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|td
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Remember the symbol of a typedef name (2nd arg) in a struct, union  * or enum tag if the typedef name is the first defined for this tag.  *  * If the tag is unnamed, the typdef name is used for identification  * of this tag in lint2. Although its possible that more than one typedef  * name is defined for one tag, the first name defined should be unique  * if the tag is unnamed.  */
end_comment

begin_function
specifier|static
name|void
name|settdsym
parameter_list|(
name|type_t
modifier|*
name|tp
parameter_list|,
name|sym_t
modifier|*
name|sym
parameter_list|)
block|{
name|tspec_t
name|t
decl_stmt|;
if|if
condition|(
operator|(
name|t
operator|=
name|tp
operator|->
name|t_tspec
operator|)
operator|==
name|STRUCT
operator|||
name|t
operator|==
name|UNION
condition|)
block|{
if|if
condition|(
name|tp
operator|->
name|t_str
operator|->
name|stdef
operator|==
name|NULL
condition|)
name|tp
operator|->
name|t_str
operator|->
name|stdef
operator|=
name|sym
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t
operator|==
name|ENUM
condition|)
block|{
if|if
condition|(
name|tp
operator|->
name|t_enum
operator|->
name|etdef
operator|==
name|NULL
condition|)
name|tp
operator|->
name|t_enum
operator|->
name|etdef
operator|=
name|sym
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Remember a qualifier which is part of the declaration specifiers  * (and not the declarator) in the top element of the declaration stack.  * Also detect multiple qualifiers of the same kind.   * The remembered qualifier is used by deftyp() to construct the type  * for all declarators.  */
end_comment

begin_function
name|void
name|addqual
parameter_list|(
name|tqual_t
name|q
parameter_list|)
block|{
if|if
condition|(
name|q
operator|==
name|CONST
condition|)
block|{
if|if
condition|(
name|dcs
operator|->
name|d_const
condition|)
block|{
comment|/* duplicate "%s" */
name|warning
argument_list|(
literal|10
argument_list|,
literal|"const"
argument_list|)
expr_stmt|;
block|}
name|dcs
operator|->
name|d_const
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|q
operator|!=
name|VOLATILE
condition|)
name|lerror
argument_list|(
literal|"addqual() 1"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dcs
operator|->
name|d_volatile
condition|)
block|{
comment|/* duplicate "%s" */
name|warning
argument_list|(
literal|10
argument_list|,
literal|"volatile"
argument_list|)
expr_stmt|;
block|}
name|dcs
operator|->
name|d_volatile
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Go to the next declaration level (structs, nested structs, blocks,  * argument declaration lists ...)  */
end_comment

begin_function
name|void
name|pushdecl
parameter_list|(
name|scl_t
name|sc
parameter_list|)
block|{
name|dinfo_t
modifier|*
name|di
decl_stmt|;
if|if
condition|(
name|dflag
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"pushdecl(%d)\n"
argument_list|,
operator|(
name|int
operator|)
name|sc
argument_list|)
expr_stmt|;
comment|/* put a new element on the declaration stack */
if|if
condition|(
operator|(
name|di
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|dinfo_t
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|nomem
argument_list|()
expr_stmt|;
name|di
operator|->
name|d_nxt
operator|=
name|dcs
expr_stmt|;
name|dcs
operator|=
name|di
expr_stmt|;
name|di
operator|->
name|d_ctx
operator|=
name|sc
expr_stmt|;
name|di
operator|->
name|d_ldlsym
operator|=
operator|&
name|di
operator|->
name|d_dlsyms
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Go back to previous declaration level  */
end_comment

begin_function
name|void
name|popdecl
parameter_list|(
name|void
parameter_list|)
block|{
name|dinfo_t
modifier|*
name|di
decl_stmt|;
if|if
condition|(
name|dflag
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"popdecl(%d)\n"
argument_list|,
operator|(
name|int
operator|)
name|dcs
operator|->
name|d_ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|dcs
operator|->
name|d_nxt
operator|==
name|NULL
condition|)
name|lerror
argument_list|(
literal|"popdecl() 1"
argument_list|)
expr_stmt|;
name|di
operator|=
name|dcs
expr_stmt|;
name|dcs
operator|=
name|di
operator|->
name|d_nxt
expr_stmt|;
switch|switch
condition|(
name|di
operator|->
name|d_ctx
condition|)
block|{
case|case
name|EXTERN
case|:
comment|/* there is nothing after external declarations */
name|lerror
argument_list|(
literal|"popdecl() 2"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
case|case
name|MOS
case|:
case|case
name|MOU
case|:
case|case
name|ENUMCON
case|:
comment|/* 		 * Symbols declared in (nested) structs or enums are 		 * part of the next level (they are removed from the 		 * symbol table if the symbols of the outher level are 		 * removed) 		 */
if|if
condition|(
operator|(
operator|*
name|dcs
operator|->
name|d_ldlsym
operator|=
name|di
operator|->
name|d_dlsyms
operator|)
operator|!=
name|NULL
condition|)
name|dcs
operator|->
name|d_ldlsym
operator|=
name|di
operator|->
name|d_ldlsym
expr_stmt|;
break|break;
case|case
name|ARG
case|:
comment|/* 		 * All symbols in dcs->d_dlsyms are introduced in old style 		 * argument declarations (it's not clean, but possible). 		 * They are appended to the list of symbols declared in 		 * an old style argument identifier list or a new style 		 * parameter type list. 		 */
if|if
condition|(
name|di
operator|->
name|d_dlsyms
operator|!=
name|NULL
condition|)
block|{
operator|*
name|di
operator|->
name|d_ldlsym
operator|=
name|dcs
operator|->
name|d_fpsyms
expr_stmt|;
name|dcs
operator|->
name|d_fpsyms
operator|=
name|di
operator|->
name|d_dlsyms
expr_stmt|;
block|}
break|break;
case|case
name|ABSTRACT
case|:
comment|/* 		 * casts and sizeof 		 * Append all symbols declared in the abstract declaration 		 * to the list of symbols declared in the surounding decl. 		 * or block. 		 * XXX I'm not sure whether they should be removed from the 		 * symbol table now or later. 		 */
if|if
condition|(
operator|(
operator|*
name|dcs
operator|->
name|d_ldlsym
operator|=
name|di
operator|->
name|d_dlsyms
operator|)
operator|!=
name|NULL
condition|)
name|dcs
operator|->
name|d_ldlsym
operator|=
name|di
operator|->
name|d_ldlsym
expr_stmt|;
break|break;
case|case
name|AUTO
case|:
comment|/* check usage of local vars */
name|chkusage
argument_list|(
name|di
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|PARG
case|:
comment|/* usage of arguments will be checked by funcend() */
name|rmsyms
argument_list|(
name|di
operator|->
name|d_dlsyms
argument_list|)
expr_stmt|;
break|break;
default|default:
name|lerror
argument_list|(
literal|"popdecl() 3"
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|di
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set flag d_asm in all declaration stack elements up to the  * outermost one.  *  * This is used to mark compound statements which have, possibly in  * nested compound statements, asm statements. For these compound  * statements no warnings about unused or unitialized variables are  * printed.  *  * There is no need to clear d_asm in dinfo structs with context AUTO,  * because these structs are freed at the end of the compound statement.  * But it must be cleard in the outermost dinfo struct, which has  * context EXTERN. This could be done in clrtyp() and would work for  * C, but not for C++ (due to mixed statements and declarations). Thus  * we clear it in glclup(), which is used to do some cleanup after  * global declarations/definitions.  */
end_comment

begin_function
name|void
name|setasm
parameter_list|(
name|void
parameter_list|)
block|{
name|dinfo_t
modifier|*
name|di
decl_stmt|;
for|for
control|(
name|di
operator|=
name|dcs
init|;
name|di
operator|!=
name|NULL
condition|;
name|di
operator|=
name|di
operator|->
name|d_nxt
control|)
name|di
operator|->
name|d_asm
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Clean all elements of the top element of declaration stack which  * will be used by the next declaration  */
end_comment

begin_function
name|void
name|clrtyp
parameter_list|(
name|void
parameter_list|)
block|{
name|dcs
operator|->
name|d_atyp
operator|=
name|dcs
operator|->
name|d_smod
operator|=
name|dcs
operator|->
name|d_lmod
operator|=
name|NOTSPEC
expr_stmt|;
name|dcs
operator|->
name|d_scl
operator|=
name|NOSCL
expr_stmt|;
name|dcs
operator|->
name|d_type
operator|=
name|NULL
expr_stmt|;
name|dcs
operator|->
name|d_const
operator|=
name|dcs
operator|->
name|d_volatile
operator|=
literal|0
expr_stmt|;
name|dcs
operator|->
name|d_inline
operator|=
literal|0
expr_stmt|;
name|dcs
operator|->
name|d_mscl
operator|=
name|dcs
operator|->
name|d_terr
operator|=
literal|0
expr_stmt|;
name|dcs
operator|->
name|d_nedecl
operator|=
literal|0
expr_stmt|;
name|dcs
operator|->
name|d_notyp
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Create a type structure from the informations gathered in  * the declaration stack.  * Complain about storage classes which are not possible in current  * context.  */
end_comment

begin_function
name|void
name|deftyp
parameter_list|(
name|void
parameter_list|)
block|{
name|tspec_t
name|t
decl_stmt|,
name|s
decl_stmt|,
name|l
decl_stmt|;
name|type_t
modifier|*
name|tp
decl_stmt|;
name|scl_t
name|scl
decl_stmt|;
name|t
operator|=
name|dcs
operator|->
name|d_atyp
expr_stmt|;
comment|/* CHAR, INT, FLOAT, DOUBLE, VOID */
name|s
operator|=
name|dcs
operator|->
name|d_smod
expr_stmt|;
comment|/* SIGNED, UNSIGNED */
name|l
operator|=
name|dcs
operator|->
name|d_lmod
expr_stmt|;
comment|/* SHORT, LONG, QUAD */
name|tp
operator|=
name|dcs
operator|->
name|d_type
expr_stmt|;
name|scl
operator|=
name|dcs
operator|->
name|d_scl
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|NOTSPEC
operator|&&
name|s
operator|==
name|NOTSPEC
operator|&&
name|l
operator|==
name|NOTSPEC
operator|&&
name|tp
operator|==
name|NULL
condition|)
name|dcs
operator|->
name|d_notyp
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|tp
operator|!=
name|NULL
operator|&&
operator|(
name|t
operator|!=
name|NOTSPEC
operator|||
name|s
operator|!=
name|NOTSPEC
operator|||
name|l
operator|!=
name|NOTSPEC
operator|)
condition|)
block|{
comment|/* should never happen */
name|lerror
argument_list|(
literal|"deftyp() 1"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tp
operator|==
name|NULL
condition|)
block|{
switch|switch
condition|(
name|t
condition|)
block|{
case|case
name|NOTSPEC
case|:
name|t
operator|=
name|INT
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|INT
case|:
if|if
condition|(
name|s
operator|==
name|NOTSPEC
condition|)
name|s
operator|=
name|SIGNED
expr_stmt|;
break|break;
case|case
name|CHAR
case|:
if|if
condition|(
name|l
operator|!=
name|NOTSPEC
condition|)
block|{
name|dcs
operator|->
name|d_terr
operator|=
literal|1
expr_stmt|;
name|l
operator|=
name|NOTSPEC
expr_stmt|;
block|}
break|break;
case|case
name|FLOAT
case|:
if|if
condition|(
name|l
operator|==
name|LONG
condition|)
block|{
name|l
operator|=
name|NOTSPEC
expr_stmt|;
name|t
operator|=
name|DOUBLE
expr_stmt|;
if|if
condition|(
operator|!
name|tflag
condition|)
comment|/* use 'double' instead of ...  */
name|warning
argument_list|(
literal|6
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DOUBLE
case|:
if|if
condition|(
name|l
operator|==
name|LONG
condition|)
block|{
name|l
operator|=
name|NOTSPEC
expr_stmt|;
name|t
operator|=
name|LDOUBLE
expr_stmt|;
if|if
condition|(
name|tflag
condition|)
comment|/* 'long double' is illegal in ... */
name|warning
argument_list|(
literal|266
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|VOID
case|:
break|break;
default|default:
name|lerror
argument_list|(
literal|"deftyp() 2"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|!=
name|INT
operator|&&
name|t
operator|!=
name|CHAR
operator|&&
operator|(
name|s
operator|!=
name|NOTSPEC
operator|||
name|l
operator|!=
name|NOTSPEC
operator|)
condition|)
block|{
name|dcs
operator|->
name|d_terr
operator|=
literal|1
expr_stmt|;
name|l
operator|=
name|s
operator|=
name|NOTSPEC
expr_stmt|;
block|}
if|if
condition|(
name|l
operator|!=
name|NOTSPEC
condition|)
name|t
operator|=
name|l
expr_stmt|;
name|dcs
operator|->
name|d_type
operator|=
name|gettyp
argument_list|(
name|mrgtspec
argument_list|(
name|t
argument_list|,
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dcs
operator|->
name|d_mscl
condition|)
block|{
comment|/* only one storage class allowed */
name|error
argument_list|(
literal|7
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dcs
operator|->
name|d_terr
condition|)
block|{
comment|/* illegal type combination */
name|error
argument_list|(
literal|4
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dcs
operator|->
name|d_ctx
operator|==
name|EXTERN
condition|)
block|{
if|if
condition|(
name|scl
operator|==
name|REG
operator|||
name|scl
operator|==
name|AUTO
condition|)
block|{
comment|/* illegal storage class */
name|error
argument_list|(
literal|8
argument_list|)
expr_stmt|;
name|scl
operator|=
name|NOSCL
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|dcs
operator|->
name|d_ctx
operator|==
name|ARG
operator|||
name|dcs
operator|->
name|d_ctx
operator|==
name|PARG
condition|)
block|{
if|if
condition|(
name|scl
operator|!=
name|NOSCL
operator|&&
name|scl
operator|!=
name|REG
condition|)
block|{
comment|/* only "register" valid ... */
name|error
argument_list|(
literal|9
argument_list|)
expr_stmt|;
name|scl
operator|=
name|NOSCL
expr_stmt|;
block|}
block|}
name|dcs
operator|->
name|d_scl
operator|=
name|scl
expr_stmt|;
if|if
condition|(
name|dcs
operator|->
name|d_const
operator|&&
name|dcs
operator|->
name|d_type
operator|->
name|t_const
condition|)
block|{
if|if
condition|(
operator|!
name|dcs
operator|->
name|d_type
operator|->
name|t_typedef
condition|)
name|lerror
argument_list|(
literal|"deftyp() 3"
argument_list|)
expr_stmt|;
comment|/* typedef already qualified with "%s" */
name|warning
argument_list|(
literal|68
argument_list|,
literal|"const"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dcs
operator|->
name|d_volatile
operator|&&
name|dcs
operator|->
name|d_type
operator|->
name|t_volatile
condition|)
block|{
if|if
condition|(
operator|!
name|dcs
operator|->
name|d_type
operator|->
name|t_typedef
condition|)
name|lerror
argument_list|(
literal|"deftyp() 4"
argument_list|)
expr_stmt|;
comment|/* typedef already qualified with "%s" */
name|warning
argument_list|(
literal|68
argument_list|,
literal|"volatile"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dcs
operator|->
name|d_const
operator|||
name|dcs
operator|->
name|d_volatile
condition|)
block|{
name|dcs
operator|->
name|d_type
operator|=
name|duptyp
argument_list|(
name|dcs
operator|->
name|d_type
argument_list|)
expr_stmt|;
name|dcs
operator|->
name|d_type
operator|->
name|t_const
operator||=
name|dcs
operator|->
name|d_const
expr_stmt|;
name|dcs
operator|->
name|d_type
operator|->
name|t_volatile
operator||=
name|dcs
operator|->
name|d_volatile
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Merge type specifiers (char, ..., long long, signed, unsigned).  */
end_comment

begin_function
specifier|static
name|tspec_t
name|mrgtspec
parameter_list|(
name|tspec_t
name|t
parameter_list|,
name|tspec_t
name|s
parameter_list|)
block|{
if|if
condition|(
name|s
operator|==
name|SIGNED
operator|||
name|s
operator|==
name|UNSIGN
condition|)
block|{
if|if
condition|(
name|t
operator|==
name|CHAR
condition|)
block|{
name|t
operator|=
name|s
operator|==
name|SIGNED
condition|?
name|SCHAR
else|:
name|UCHAR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t
operator|==
name|SHORT
condition|)
block|{
name|t
operator|=
name|s
operator|==
name|SIGNED
condition|?
name|SHORT
else|:
name|USHORT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t
operator|==
name|INT
condition|)
block|{
name|t
operator|=
name|s
operator|==
name|SIGNED
condition|?
name|INT
else|:
name|UINT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t
operator|==
name|LONG
condition|)
block|{
name|t
operator|=
name|s
operator|==
name|SIGNED
condition|?
name|LONG
else|:
name|ULONG
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t
operator|==
name|QUAD
condition|)
block|{
name|t
operator|=
name|s
operator|==
name|SIGNED
condition|?
name|QUAD
else|:
name|UQUAD
expr_stmt|;
block|}
block|}
return|return
operator|(
name|t
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the length of a type in bit.  *  * Printing a message if the outhermost dimension of an array is 0 must  * be done by the caller. All other problems are reported by length()  * if name is not NULL.  */
end_comment

begin_function
name|int
name|length
parameter_list|(
name|type_t
modifier|*
name|tp
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|elem
decl_stmt|,
name|elsz
decl_stmt|;
name|elem
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|tp
operator|&&
name|tp
operator|->
name|t_tspec
operator|==
name|ARRAY
condition|)
block|{
name|elem
operator|*=
name|tp
operator|->
name|t_dim
expr_stmt|;
name|tp
operator|=
name|tp
operator|->
name|t_subt
expr_stmt|;
block|}
if|if
condition|(
name|tp
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
switch|switch
condition|(
name|tp
operator|->
name|t_tspec
condition|)
block|{
case|case
name|FUNC
case|:
comment|/* compiler takes size of function */
name|lerror
argument_list|(
literal|"%s"
argument_list|,
name|msgs
index|[
literal|12
index|]
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
case|case
name|STRUCT
case|:
case|case
name|UNION
case|:
if|if
condition|(
name|incompl
argument_list|(
name|tp
argument_list|)
operator|&&
name|name
operator|!=
name|NULL
condition|)
block|{
comment|/* incomplete structure or union %s: %s */
name|error
argument_list|(
literal|31
argument_list|,
name|tp
operator|->
name|t_str
operator|->
name|stag
operator|->
name|s_name
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
name|elsz
operator|=
name|tp
operator|->
name|t_str
operator|->
name|size
expr_stmt|;
break|break;
case|case
name|ENUM
case|:
if|if
condition|(
name|incompl
argument_list|(
name|tp
argument_list|)
operator|&&
name|name
operator|!=
name|NULL
condition|)
block|{
comment|/* incomplete enum type: %s */
name|warning
argument_list|(
literal|13
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
comment|/* FALLTHROUGH */
default|default:
name|elsz
operator|=
name|size
argument_list|(
name|tp
operator|->
name|t_tspec
argument_list|)
expr_stmt|;
if|if
condition|(
name|elsz
operator|<=
literal|0
condition|)
name|lerror
argument_list|(
literal|"length()"
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|elem
operator|*
name|elsz
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get the alignment of the given Type in bits.  */
end_comment

begin_function
name|int
name|getbound
parameter_list|(
name|type_t
modifier|*
name|tp
parameter_list|)
block|{
name|int
name|a
decl_stmt|;
name|tspec_t
name|t
decl_stmt|;
while|while
condition|(
name|tp
operator|&&
name|tp
operator|->
name|t_tspec
operator|==
name|ARRAY
condition|)
name|tp
operator|=
name|tp
operator|->
name|t_subt
expr_stmt|;
if|if
condition|(
name|tp
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|(
name|t
operator|=
name|tp
operator|->
name|t_tspec
operator|)
operator|==
name|STRUCT
operator|||
name|t
operator|==
name|UNION
condition|)
block|{
name|a
operator|=
name|tp
operator|->
name|t_str
operator|->
name|align
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t
operator|==
name|FUNC
condition|)
block|{
comment|/* compiler takes alignment of function */
name|error
argument_list|(
literal|14
argument_list|)
expr_stmt|;
name|a
operator|=
name|ALIGN
argument_list|(
literal|1
argument_list|)
operator|*
name|CHAR_BIT
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|a
operator|=
name|size
argument_list|(
name|t
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|a
operator|=
name|CHAR_BIT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|a
operator|>
name|ALIGN
argument_list|(
literal|1
argument_list|)
operator|*
name|CHAR_BIT
condition|)
block|{
name|a
operator|=
name|ALIGN
argument_list|(
literal|1
argument_list|)
operator|*
name|CHAR_BIT
expr_stmt|;
block|}
block|}
if|if
condition|(
name|a
operator|<
name|CHAR_BIT
operator|||
name|a
operator|>
name|ALIGN
argument_list|(
literal|1
argument_list|)
operator|*
name|CHAR_BIT
condition|)
name|lerror
argument_list|(
literal|"getbound() 1"
argument_list|)
expr_stmt|;
return|return
operator|(
name|a
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Concatenate two lists of symbols by s_nxt. Used by declarations of  * struct/union/enum elements and parameters.  */
end_comment

begin_function
name|sym_t
modifier|*
name|lnklst
parameter_list|(
name|sym_t
modifier|*
name|l1
parameter_list|,
name|sym_t
modifier|*
name|l2
parameter_list|)
block|{
name|sym_t
modifier|*
name|l
decl_stmt|;
if|if
condition|(
operator|(
name|l
operator|=
name|l1
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|l2
operator|)
return|;
while|while
condition|(
name|l1
operator|->
name|s_nxt
operator|!=
name|NULL
condition|)
name|l1
operator|=
name|l1
operator|->
name|s_nxt
expr_stmt|;
name|l1
operator|->
name|s_nxt
operator|=
name|l2
expr_stmt|;
return|return
operator|(
name|l
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check if the type of the given symbol is valid and print an error  * message if it is not.  *  * Invalid types are:  * - arrays of incomlete types or functions  * - functions returning arrays or functions  * - void types other than type of function or pointer  */
end_comment

begin_function
name|void
name|chktyp
parameter_list|(
name|sym_t
modifier|*
name|sym
parameter_list|)
block|{
name|tspec_t
name|to
decl_stmt|,
name|t
decl_stmt|;
name|type_t
modifier|*
modifier|*
name|tpp
decl_stmt|,
modifier|*
name|tp
decl_stmt|;
name|tpp
operator|=
operator|&
name|sym
operator|->
name|s_type
expr_stmt|;
name|to
operator|=
name|NOTSPEC
expr_stmt|;
while|while
condition|(
operator|(
name|tp
operator|=
operator|*
name|tpp
operator|)
operator|!=
name|NULL
condition|)
block|{
name|t
operator|=
name|tp
operator|->
name|t_tspec
expr_stmt|;
comment|/* 		 * If this is the type of an old style function definition, 		 * a better warning is printed in funcdef(). 		 */
if|if
condition|(
name|t
operator|==
name|FUNC
operator|&&
operator|!
name|tp
operator|->
name|t_proto
operator|&&
operator|!
operator|(
name|to
operator|==
name|NOTSPEC
operator|&&
name|sym
operator|->
name|s_osdef
operator|)
condition|)
block|{
if|if
condition|(
name|sflag
operator|&&
name|hflag
condition|)
comment|/* function declaration is not a prototype */
name|warning
argument_list|(
literal|287
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|to
operator|==
name|FUNC
condition|)
block|{
if|if
condition|(
name|t
operator|==
name|FUNC
operator|||
name|t
operator|==
name|ARRAY
condition|)
block|{
comment|/* function returns illegal type */
name|error
argument_list|(
literal|15
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|FUNC
condition|)
block|{
operator|*
name|tpp
operator|=
name|incref
argument_list|(
operator|*
name|tpp
argument_list|,
name|PTR
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|tpp
operator|=
name|incref
argument_list|(
operator|(
operator|*
name|tpp
operator|)
operator|->
name|t_subt
argument_list|,
name|PTR
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
elseif|else
if|if
condition|(
name|tp
operator|->
name|t_const
operator|||
name|tp
operator|->
name|t_volatile
condition|)
block|{
if|if
condition|(
name|sflag
condition|)
block|{
comment|/* XXX oder better !tflag ? */
comment|/* function cannot return const... */
name|warning
argument_list|(
literal|228
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|to
operator|==
name|ARRAY
condition|)
block|{
if|if
condition|(
name|t
operator|==
name|FUNC
condition|)
block|{
comment|/* array of function is illegal */
name|error
argument_list|(
literal|16
argument_list|)
expr_stmt|;
operator|*
name|tpp
operator|=
name|gettyp
argument_list|(
name|INT
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|t
operator|==
name|ARRAY
operator|&&
name|tp
operator|->
name|t_dim
operator|==
literal|0
condition|)
block|{
comment|/* null dimension */
name|error
argument_list|(
literal|17
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|t
operator|==
name|VOID
condition|)
block|{
comment|/* illegal use of void */
name|error
argument_list|(
literal|18
argument_list|)
expr_stmt|;
operator|*
name|tpp
operator|=
name|gettyp
argument_list|(
name|INT
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* errors are produced by length() */
block|} else if (incompl(tp)) {
comment|/* array of incomplete type */
block|if (sflag) { 					error(301); 				} else { 					warning(301); 				}
endif|#
directive|endif
block|}
block|}
elseif|else
if|if
condition|(
name|to
operator|==
name|NOTSPEC
operator|&&
name|t
operator|==
name|VOID
condition|)
block|{
if|if
condition|(
name|dcs
operator|->
name|d_ctx
operator|==
name|PARG
condition|)
block|{
if|if
condition|(
name|sym
operator|->
name|s_scl
operator|!=
name|ABSTRACT
condition|)
block|{
if|if
condition|(
name|sym
operator|->
name|s_name
operator|==
name|unnamed
condition|)
name|lerror
argument_list|(
literal|"chktyp()"
argument_list|)
expr_stmt|;
comment|/* void param cannot have name: %s */
name|error
argument_list|(
literal|61
argument_list|,
name|sym
operator|->
name|s_name
argument_list|)
expr_stmt|;
operator|*
name|tpp
operator|=
name|gettyp
argument_list|(
name|INT
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|dcs
operator|->
name|d_ctx
operator|==
name|ABSTRACT
condition|)
block|{
comment|/* ok */
block|}
elseif|else
if|if
condition|(
name|sym
operator|->
name|s_scl
operator|!=
name|TYPEDEF
condition|)
block|{
comment|/* void type for %s */
name|error
argument_list|(
literal|19
argument_list|,
name|sym
operator|->
name|s_name
argument_list|)
expr_stmt|;
operator|*
name|tpp
operator|=
name|gettyp
argument_list|(
name|INT
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|t
operator|==
name|VOID
operator|&&
name|to
operator|!=
name|PTR
condition|)
block|{
if|if
condition|(
name|tp
operator|->
name|t_const
operator|||
name|tp
operator|->
name|t_volatile
condition|)
block|{
comment|/* inappropriate qualifiers with "void" */
name|warning
argument_list|(
literal|69
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_const
operator|=
name|tp
operator|->
name|t_volatile
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|tpp
operator|=
operator|&
name|tp
operator|->
name|t_subt
expr_stmt|;
name|to
operator|=
name|t
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Process the declarator of a struct/union element.  */
end_comment

begin_function
name|sym_t
modifier|*
name|decl1str
parameter_list|(
name|sym_t
modifier|*
name|dsym
parameter_list|)
block|{
name|type_t
modifier|*
name|tp
decl_stmt|;
name|tspec_t
name|t
decl_stmt|;
name|int
name|sz
decl_stmt|,
name|len
decl_stmt|;
name|int
name|o
init|=
literal|0
decl_stmt|;
comment|/* Appease gcc */
name|scl_t
name|sc
decl_stmt|;
if|if
condition|(
operator|(
name|sc
operator|=
name|dsym
operator|->
name|s_scl
operator|)
operator|!=
name|MOS
operator|&&
name|sc
operator|!=
name|MOU
condition|)
name|lerror
argument_list|(
literal|"decl1str() 1"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dcs
operator|->
name|d_rdcsym
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|sc
operator|=
name|dcs
operator|->
name|d_rdcsym
operator|->
name|s_scl
operator|)
operator|!=
name|MOS
operator|&&
name|sc
operator|!=
name|MOU
condition|)
comment|/* should be ensured by storesym() */
name|lerror
argument_list|(
literal|"decl1str() 2"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dsym
operator|->
name|s_styp
operator|==
name|dcs
operator|->
name|d_rdcsym
operator|->
name|s_styp
condition|)
block|{
comment|/* duplicate member name: %s */
name|error
argument_list|(
literal|33
argument_list|,
name|dsym
operator|->
name|s_name
argument_list|)
expr_stmt|;
name|rmsym
argument_list|(
name|dcs
operator|->
name|d_rdcsym
argument_list|)
expr_stmt|;
block|}
block|}
name|chktyp
argument_list|(
name|dsym
argument_list|)
expr_stmt|;
name|t
operator|=
operator|(
name|tp
operator|=
name|dsym
operator|->
name|s_type
operator|)
operator|->
name|t_tspec
expr_stmt|;
if|if
condition|(
name|dsym
operator|->
name|s_field
condition|)
block|{
comment|/* 		 * bit field 		 * 		 * only unsigned und signed int are protable bit-field types 		 *(at least in ANSI C, in traditional C only unsigned int) 		 */
if|if
condition|(
name|t
operator|==
name|CHAR
operator|||
name|t
operator|==
name|UCHAR
operator|||
name|t
operator|==
name|SCHAR
operator|||
name|t
operator|==
name|SHORT
operator|||
name|t
operator|==
name|USHORT
operator|||
name|t
operator|==
name|ENUM
condition|)
block|{
if|if
condition|(
name|bitfieldtype_ok
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|sflag
condition|)
block|{
comment|/* 					 * bit-field type '%s' invalid in 					 * ANSI C 					 */
name|warning
argument_list|(
literal|273
argument_list|,
name|tyname
argument_list|(
name|tp
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pflag
condition|)
block|{
comment|/* nonportable bit-field type */
name|warning
argument_list|(
literal|34
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|t
operator|==
name|INT
operator|&&
name|dcs
operator|->
name|d_smod
operator|==
name|NOTSPEC
condition|)
block|{
if|if
condition|(
name|pflag
operator|&&
name|bitfieldtype_ok
operator|==
literal|0
condition|)
block|{
comment|/* nonportable bit-field type */
name|warning
argument_list|(
literal|34
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|t
operator|!=
name|INT
operator|&&
name|t
operator|!=
name|UINT
condition|)
block|{
comment|/* 			 * Non-integer types are always illegal for 			 * bitfields, regardless of BITFIELDTYPE. 			 * Integer types not dealt with above are 			 * okay only if BITFIELDTYPE is in effect. 			 */
if|if
condition|(
name|bitfieldtype_ok
operator|==
literal|0
operator|||
name|isityp
argument_list|(
name|t
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* illegal bit-field type */
name|error
argument_list|(
literal|35
argument_list|)
expr_stmt|;
name|sz
operator|=
name|tp
operator|->
name|t_flen
expr_stmt|;
name|dsym
operator|->
name|s_type
operator|=
name|tp
operator|=
name|duptyp
argument_list|(
name|gettyp
argument_list|(
name|t
operator|=
name|INT
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tp
operator|->
name|t_flen
operator|=
name|sz
operator|)
operator|>
name|size
argument_list|(
name|t
argument_list|)
condition|)
name|tp
operator|->
name|t_flen
operator|=
name|size
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|len
operator|=
name|tp
operator|->
name|t_flen
operator|)
operator|<
literal|0
operator|||
name|len
operator|>
name|size
argument_list|(
name|t
argument_list|)
condition|)
block|{
comment|/* illegal bit-field size */
name|error
argument_list|(
literal|36
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_flen
operator|=
name|size
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|len
operator|==
literal|0
operator|&&
name|dsym
operator|->
name|s_name
operator|!=
name|unnamed
condition|)
block|{
comment|/* zero size bit-field */
name|error
argument_list|(
literal|37
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_flen
operator|=
name|size
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dsym
operator|->
name|s_scl
operator|==
name|MOU
condition|)
block|{
comment|/* illegal use of bit-field */
name|error
argument_list|(
literal|41
argument_list|)
expr_stmt|;
name|dsym
operator|->
name|s_type
operator|->
name|t_isfield
operator|=
literal|0
expr_stmt|;
name|dsym
operator|->
name|s_field
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|t
operator|==
name|FUNC
condition|)
block|{
comment|/* function illegal in structure or union */
name|error
argument_list|(
literal|38
argument_list|)
expr_stmt|;
name|dsym
operator|->
name|s_type
operator|=
name|tp
operator|=
name|incref
argument_list|(
name|tp
argument_list|,
name|t
operator|=
name|PTR
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * bit-fields of length 0 are not warned about because length() 	 * does not return the length of the bit-field but the length 	 * of the type the bit-field is packed in (its ok) 	 */
if|if
condition|(
operator|(
name|sz
operator|=
name|length
argument_list|(
name|dsym
operator|->
name|s_type
argument_list|,
name|dsym
operator|->
name|s_name
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|t
operator|==
name|ARRAY
operator|&&
name|dsym
operator|->
name|s_type
operator|->
name|t_dim
operator|==
literal|0
condition|)
block|{
comment|/* illegal zero sized structure member: %s */
name|warning
argument_list|(
literal|39
argument_list|,
name|dsym
operator|->
name|s_name
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dcs
operator|->
name|d_ctx
operator|==
name|MOU
condition|)
block|{
name|o
operator|=
name|dcs
operator|->
name|d_offset
expr_stmt|;
name|dcs
operator|->
name|d_offset
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|dsym
operator|->
name|s_field
condition|)
block|{
name|align
argument_list|(
name|getbound
argument_list|(
name|tp
argument_list|)
argument_list|,
name|tp
operator|->
name|t_flen
argument_list|)
expr_stmt|;
name|dsym
operator|->
name|s_value
operator|.
name|v_quad
operator|=
operator|(
name|dcs
operator|->
name|d_offset
operator|/
name|size
argument_list|(
name|t
argument_list|)
operator|)
operator|*
name|size
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_foffs
operator|=
name|dcs
operator|->
name|d_offset
operator|-
operator|(
name|int
operator|)
name|dsym
operator|->
name|s_value
operator|.
name|v_quad
expr_stmt|;
name|dcs
operator|->
name|d_offset
operator|+=
name|tp
operator|->
name|t_flen
expr_stmt|;
block|}
else|else
block|{
name|align
argument_list|(
name|getbound
argument_list|(
name|tp
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dsym
operator|->
name|s_value
operator|.
name|v_quad
operator|=
name|dcs
operator|->
name|d_offset
expr_stmt|;
name|dcs
operator|->
name|d_offset
operator|+=
name|sz
expr_stmt|;
block|}
if|if
condition|(
name|dcs
operator|->
name|d_ctx
operator|==
name|MOU
condition|)
block|{
if|if
condition|(
name|o
operator|>
name|dcs
operator|->
name|d_offset
condition|)
name|dcs
operator|->
name|d_offset
operator|=
name|o
expr_stmt|;
block|}
name|chkfdef
argument_list|(
name|dsym
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Clear the BITFIELDTYPE indicator after processing each 	 * structure element. 	 */
name|bitfieldtype_ok
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|dsym
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Aligns next structure element as required.  *  * al contains the required alignment, len the length of a bit-field.  */
end_comment

begin_function
specifier|static
name|void
name|align
parameter_list|(
name|int
name|al
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|no
decl_stmt|;
comment|/* 	 * The alignment of the current element becomes the alignment of 	 * the struct/union if it is larger than the current alignment 	 * of the struct/union. 	 */
if|if
condition|(
name|al
operator|>
name|dcs
operator|->
name|d_stralign
condition|)
name|dcs
operator|->
name|d_stralign
operator|=
name|al
expr_stmt|;
name|no
operator|=
operator|(
name|dcs
operator|->
name|d_offset
operator|+
operator|(
name|al
operator|-
literal|1
operator|)
operator|)
operator|&
operator|~
operator|(
name|al
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
operator|||
name|dcs
operator|->
name|d_offset
operator|+
name|len
operator|>
name|no
condition|)
name|dcs
operator|->
name|d_offset
operator|=
name|no
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Remember the width of the field in its type structure.  */
end_comment

begin_function
name|sym_t
modifier|*
name|bitfield
parameter_list|(
name|sym_t
modifier|*
name|dsym
parameter_list|,
name|int
name|len
parameter_list|)
block|{
if|if
condition|(
name|dsym
operator|==
name|NULL
condition|)
block|{
name|dsym
operator|=
name|getblk
argument_list|(
sizeof|sizeof
argument_list|(
name|sym_t
argument_list|)
argument_list|)
expr_stmt|;
name|dsym
operator|->
name|s_name
operator|=
name|unnamed
expr_stmt|;
name|dsym
operator|->
name|s_kind
operator|=
name|FMOS
expr_stmt|;
name|dsym
operator|->
name|s_scl
operator|=
name|MOS
expr_stmt|;
name|dsym
operator|->
name|s_type
operator|=
name|gettyp
argument_list|(
name|UINT
argument_list|)
expr_stmt|;
name|dsym
operator|->
name|s_blklev
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|dsym
operator|->
name|s_type
operator|=
name|duptyp
argument_list|(
name|dsym
operator|->
name|s_type
argument_list|)
expr_stmt|;
name|dsym
operator|->
name|s_type
operator|->
name|t_isfield
operator|=
literal|1
expr_stmt|;
name|dsym
operator|->
name|s_type
operator|->
name|t_flen
operator|=
name|len
expr_stmt|;
name|dsym
operator|->
name|s_field
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|dsym
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Collect informations about a sequence of asterisks and qualifiers  * in a list of type pqinf_t.  * Qualifiers refer always to the left asterisk. The rightmost asterisk  * will be at the top of the list.  */
end_comment

begin_function
name|pqinf_t
modifier|*
name|mergepq
parameter_list|(
name|pqinf_t
modifier|*
name|p1
parameter_list|,
name|pqinf_t
modifier|*
name|p2
parameter_list|)
block|{
name|pqinf_t
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|p2
operator|->
name|p_pcnt
operator|!=
literal|0
condition|)
block|{
comment|/* left '*' at the end of the list */
for|for
control|(
name|p
operator|=
name|p2
init|;
name|p
operator|->
name|p_nxt
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|p_nxt
control|)
continue|continue;
name|p
operator|->
name|p_nxt
operator|=
name|p1
expr_stmt|;
return|return
operator|(
name|p2
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|p2
operator|->
name|p_const
condition|)
block|{
if|if
condition|(
name|p1
operator|->
name|p_const
condition|)
block|{
comment|/* duplicate %s */
name|warning
argument_list|(
literal|10
argument_list|,
literal|"const"
argument_list|)
expr_stmt|;
block|}
name|p1
operator|->
name|p_const
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|p2
operator|->
name|p_volatile
condition|)
block|{
if|if
condition|(
name|p1
operator|->
name|p_volatile
condition|)
block|{
comment|/* duplicate %s */
name|warning
argument_list|(
literal|10
argument_list|,
literal|"volatile"
argument_list|)
expr_stmt|;
block|}
name|p1
operator|->
name|p_volatile
operator|=
literal|1
expr_stmt|;
block|}
name|free
argument_list|(
name|p2
argument_list|)
expr_stmt|;
return|return
operator|(
name|p1
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Followint 3 functions extend the type of a declarator with  * pointer, function and array types.  *  * The current type is the Type built by deftyp() (dcs->d_type) and  * pointer, function and array types already added for this  * declarator. The new type extension is inserted between both.  */
end_comment

begin_function
name|sym_t
modifier|*
name|addptr
parameter_list|(
name|sym_t
modifier|*
name|decl
parameter_list|,
name|pqinf_t
modifier|*
name|pi
parameter_list|)
block|{
name|type_t
modifier|*
modifier|*
name|tpp
decl_stmt|,
modifier|*
name|tp
decl_stmt|;
name|pqinf_t
modifier|*
name|npi
decl_stmt|;
name|tpp
operator|=
operator|&
name|decl
operator|->
name|s_type
expr_stmt|;
while|while
condition|(
operator|*
name|tpp
operator|&&
operator|*
name|tpp
operator|!=
name|dcs
operator|->
name|d_type
condition|)
name|tpp
operator|=
operator|&
operator|(
operator|*
name|tpp
operator|)
operator|->
name|t_subt
expr_stmt|;
if|if
condition|(
operator|*
name|tpp
operator|==
name|NULL
condition|)
return|return
name|decl
return|;
while|while
condition|(
name|pi
operator|!=
name|NULL
condition|)
block|{
operator|*
name|tpp
operator|=
name|tp
operator|=
name|getblk
argument_list|(
sizeof|sizeof
argument_list|(
name|type_t
argument_list|)
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_tspec
operator|=
name|PTR
expr_stmt|;
name|tp
operator|->
name|t_const
operator|=
name|pi
operator|->
name|p_const
expr_stmt|;
name|tp
operator|->
name|t_volatile
operator|=
name|pi
operator|->
name|p_volatile
expr_stmt|;
operator|*
operator|(
name|tpp
operator|=
operator|&
name|tp
operator|->
name|t_subt
operator|)
operator|=
name|dcs
operator|->
name|d_type
expr_stmt|;
name|npi
operator|=
name|pi
operator|->
name|p_nxt
expr_stmt|;
name|free
argument_list|(
name|pi
argument_list|)
expr_stmt|;
name|pi
operator|=
name|npi
expr_stmt|;
block|}
return|return
operator|(
name|decl
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * If a dimension was specified, dim is 1, otherwise 0  * n is the specified dimension  */
end_comment

begin_function
name|sym_t
modifier|*
name|addarray
parameter_list|(
name|sym_t
modifier|*
name|decl
parameter_list|,
name|int
name|dim
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|type_t
modifier|*
modifier|*
name|tpp
decl_stmt|,
modifier|*
name|tp
decl_stmt|;
name|tpp
operator|=
operator|&
name|decl
operator|->
name|s_type
expr_stmt|;
while|while
condition|(
operator|*
name|tpp
operator|&&
operator|*
name|tpp
operator|!=
name|dcs
operator|->
name|d_type
condition|)
name|tpp
operator|=
operator|&
operator|(
operator|*
name|tpp
operator|)
operator|->
name|t_subt
expr_stmt|;
if|if
condition|(
operator|*
name|tpp
operator|==
name|NULL
condition|)
return|return
name|decl
return|;
operator|*
name|tpp
operator|=
name|tp
operator|=
name|getblk
argument_list|(
sizeof|sizeof
argument_list|(
name|type_t
argument_list|)
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_tspec
operator|=
name|ARRAY
expr_stmt|;
name|tp
operator|->
name|t_subt
operator|=
name|dcs
operator|->
name|d_type
expr_stmt|;
name|tp
operator|->
name|t_dim
operator|=
name|n
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
comment|/* zero or negative array dimension */
name|error
argument_list|(
literal|20
argument_list|)
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|n
operator|==
literal|0
operator|&&
name|dim
condition|)
block|{
comment|/* zero or negative array dimension */
name|warning
argument_list|(
literal|20
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|n
operator|==
literal|0
operator|&&
operator|!
name|dim
condition|)
block|{
comment|/* is incomplete type */
name|setcompl
argument_list|(
name|tp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|decl
operator|)
return|;
block|}
end_function

begin_function
name|sym_t
modifier|*
name|addfunc
parameter_list|(
name|sym_t
modifier|*
name|decl
parameter_list|,
name|sym_t
modifier|*
name|args
parameter_list|)
block|{
name|type_t
modifier|*
modifier|*
name|tpp
decl_stmt|,
modifier|*
name|tp
decl_stmt|;
if|if
condition|(
name|dcs
operator|->
name|d_proto
condition|)
block|{
if|if
condition|(
name|tflag
condition|)
comment|/* function prototypes are illegal in traditional C */
name|warning
argument_list|(
literal|270
argument_list|)
expr_stmt|;
name|args
operator|=
name|nsfunc
argument_list|(
name|decl
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|osfunc
argument_list|(
name|decl
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * The symbols are removed from the symbol table by popdecl() after 	 * addfunc(). To be able to restore them if this is a function 	 * definition, a pointer to the list of all symbols is stored in 	 * dcs->d_nxt->d_fpsyms. Also a list of the arguments (concatenated 	 * by s_nxt) is stored in dcs->d_nxt->d_fargs. 	 * (dcs->d_nxt must be used because *dcs is the declaration stack 	 * element created for the list of params and is removed after 	 * addfunc()) 	 */
if|if
condition|(
name|dcs
operator|->
name|d_nxt
operator|->
name|d_ctx
operator|==
name|EXTERN
operator|&&
name|decl
operator|->
name|s_type
operator|==
name|dcs
operator|->
name|d_nxt
operator|->
name|d_type
condition|)
block|{
name|dcs
operator|->
name|d_nxt
operator|->
name|d_fpsyms
operator|=
name|dcs
operator|->
name|d_dlsyms
expr_stmt|;
name|dcs
operator|->
name|d_nxt
operator|->
name|d_fargs
operator|=
name|args
expr_stmt|;
block|}
name|tpp
operator|=
operator|&
name|decl
operator|->
name|s_type
expr_stmt|;
while|while
condition|(
operator|*
name|tpp
operator|&&
operator|*
name|tpp
operator|!=
name|dcs
operator|->
name|d_nxt
operator|->
name|d_type
condition|)
name|tpp
operator|=
operator|&
operator|(
operator|*
name|tpp
operator|)
operator|->
name|t_subt
expr_stmt|;
if|if
condition|(
operator|*
name|tpp
operator|==
name|NULL
condition|)
return|return
name|decl
return|;
operator|*
name|tpp
operator|=
name|tp
operator|=
name|getblk
argument_list|(
sizeof|sizeof
argument_list|(
name|type_t
argument_list|)
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_tspec
operator|=
name|FUNC
expr_stmt|;
name|tp
operator|->
name|t_subt
operator|=
name|dcs
operator|->
name|d_nxt
operator|->
name|d_type
expr_stmt|;
if|if
condition|(
operator|(
name|tp
operator|->
name|t_proto
operator|=
name|dcs
operator|->
name|d_proto
operator|)
operator|!=
literal|0
condition|)
name|tp
operator|->
name|t_args
operator|=
name|args
expr_stmt|;
name|tp
operator|->
name|t_vararg
operator|=
name|dcs
operator|->
name|d_vararg
expr_stmt|;
return|return
operator|(
name|decl
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Called for new style function declarations.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|sym_t
modifier|*
name|nsfunc
parameter_list|(
name|sym_t
modifier|*
name|decl
parameter_list|,
name|sym_t
modifier|*
name|args
parameter_list|)
block|{
name|sym_t
modifier|*
name|arg
decl_stmt|,
modifier|*
name|sym
decl_stmt|;
name|scl_t
name|sc
decl_stmt|;
name|int
name|n
decl_stmt|;
comment|/* 	 * Declarations of structs/unions/enums in param lists are legal, 	 * but senseless. 	 */
for|for
control|(
name|sym
operator|=
name|dcs
operator|->
name|d_dlsyms
init|;
name|sym
operator|!=
name|NULL
condition|;
name|sym
operator|=
name|sym
operator|->
name|s_dlnxt
control|)
block|{
name|sc
operator|=
name|sym
operator|->
name|s_scl
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|STRTAG
operator|||
name|sc
operator|==
name|UNIONTAG
operator|||
name|sc
operator|==
name|ENUMTAG
condition|)
block|{
comment|/* dubious tag declaration: %s %s */
name|warning
argument_list|(
literal|85
argument_list|,
name|scltoa
argument_list|(
name|sc
argument_list|)
argument_list|,
name|sym
operator|->
name|s_name
argument_list|)
expr_stmt|;
block|}
block|}
name|n
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|arg
operator|=
name|args
init|;
name|arg
operator|!=
name|NULL
condition|;
name|arg
operator|=
name|arg
operator|->
name|s_nxt
control|)
block|{
if|if
condition|(
name|arg
operator|->
name|s_type
operator|->
name|t_tspec
operator|==
name|VOID
condition|)
block|{
if|if
condition|(
name|n
operator|>
literal|1
operator|||
name|arg
operator|->
name|s_nxt
operator|!=
name|NULL
condition|)
block|{
comment|/* "void" must be sole parameter */
name|error
argument_list|(
literal|60
argument_list|)
expr_stmt|;
name|arg
operator|->
name|s_type
operator|=
name|gettyp
argument_list|(
name|INT
argument_list|)
expr_stmt|;
block|}
block|}
name|n
operator|++
expr_stmt|;
block|}
comment|/* return NULL if first param is VOID */
return|return
operator|(
name|args
operator|!=
name|NULL
operator|&&
name|args
operator|->
name|s_type
operator|->
name|t_tspec
operator|!=
name|VOID
condition|?
name|args
else|:
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Called for old style function declarations.  */
end_comment

begin_function
specifier|static
name|void
name|osfunc
parameter_list|(
name|sym_t
modifier|*
name|decl
parameter_list|,
name|sym_t
modifier|*
name|args
parameter_list|)
block|{
comment|/* 	 * Remember list of params only if this is really seams to be 	 * a function definition. 	 */
if|if
condition|(
name|dcs
operator|->
name|d_nxt
operator|->
name|d_ctx
operator|==
name|EXTERN
operator|&&
name|decl
operator|->
name|s_type
operator|==
name|dcs
operator|->
name|d_nxt
operator|->
name|d_type
condition|)
block|{
comment|/* 		 * We assume that this becomes a function definition. If 		 * we are wrong, its corrected in chkfdef(). 		 */
if|if
condition|(
name|args
operator|!=
name|NULL
condition|)
block|{
name|decl
operator|->
name|s_osdef
operator|=
literal|1
expr_stmt|;
name|decl
operator|->
name|s_args
operator|=
name|args
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|args
operator|!=
name|NULL
condition|)
comment|/* function prototype parameters must have types */
name|warning
argument_list|(
literal|62
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Lists of Identifiers in functions declarations are allowed only if  * its also a function definition. If this is not the case, print a  * error message.  */
end_comment

begin_function
name|void
name|chkfdef
parameter_list|(
name|sym_t
modifier|*
name|sym
parameter_list|,
name|int
name|msg
parameter_list|)
block|{
if|if
condition|(
name|sym
operator|->
name|s_osdef
condition|)
block|{
if|if
condition|(
name|msg
condition|)
block|{
comment|/* incomplete or misplaced function definition */
name|error
argument_list|(
literal|22
argument_list|)
expr_stmt|;
block|}
name|sym
operator|->
name|s_osdef
operator|=
literal|0
expr_stmt|;
name|sym
operator|->
name|s_args
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Process the name in a declarator.  * If the symbol does already exists, a new one is created.  * The symbol becomes one of the storage classes EXTERN, STATIC, AUTO or  * TYPEDEF.  * s_def and s_reg are valid after dname().  */
end_comment

begin_function
name|sym_t
modifier|*
name|dname
parameter_list|(
name|sym_t
modifier|*
name|sym
parameter_list|)
block|{
name|scl_t
name|sc
init|=
name|NOSCL
decl_stmt|;
if|if
condition|(
name|sym
operator|->
name|s_scl
operator|==
name|NOSCL
condition|)
block|{
name|dcs
operator|->
name|d_rdcsym
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sym
operator|->
name|s_defarg
condition|)
block|{
name|sym
operator|->
name|s_defarg
operator|=
literal|0
expr_stmt|;
name|dcs
operator|->
name|d_rdcsym
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|dcs
operator|->
name|d_rdcsym
operator|=
name|sym
expr_stmt|;
name|sym
operator|=
name|pushdown
argument_list|(
name|sym
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|dcs
operator|->
name|d_ctx
condition|)
block|{
case|case
name|MOS
case|:
case|case
name|MOU
case|:
comment|/* Parent setzen */
name|sym
operator|->
name|s_styp
operator|=
name|dcs
operator|->
name|d_tagtyp
operator|->
name|t_str
expr_stmt|;
name|sym
operator|->
name|s_def
operator|=
name|DEF
expr_stmt|;
name|sym
operator|->
name|s_value
operator|.
name|v_tspec
operator|=
name|INT
expr_stmt|;
name|sc
operator|=
name|dcs
operator|->
name|d_ctx
expr_stmt|;
break|break;
case|case
name|EXTERN
case|:
comment|/* 		 * static and external symbols without "extern" are 		 * considered to be tentative defined, external 		 * symbols with "extern" are declared, and typedef names 		 * are defined. Tentative defined and declared symbols 		 * may become defined if an initializer is present or 		 * this is a function definition. 		 */
if|if
condition|(
operator|(
name|sc
operator|=
name|dcs
operator|->
name|d_scl
operator|)
operator|==
name|NOSCL
condition|)
block|{
name|sc
operator|=
name|EXTERN
expr_stmt|;
name|sym
operator|->
name|s_def
operator|=
name|TDEF
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|==
name|STATIC
condition|)
block|{
name|sym
operator|->
name|s_def
operator|=
name|TDEF
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|==
name|TYPEDEF
condition|)
block|{
name|sym
operator|->
name|s_def
operator|=
name|DEF
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|==
name|EXTERN
condition|)
block|{
name|sym
operator|->
name|s_def
operator|=
name|DECL
expr_stmt|;
block|}
else|else
block|{
name|lerror
argument_list|(
literal|"dname() 1"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PARG
case|:
name|sym
operator|->
name|s_arg
operator|=
literal|1
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|ARG
case|:
if|if
condition|(
operator|(
name|sc
operator|=
name|dcs
operator|->
name|d_scl
operator|)
operator|==
name|NOSCL
condition|)
block|{
name|sc
operator|=
name|AUTO
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|==
name|REG
condition|)
block|{
name|sym
operator|->
name|s_reg
operator|=
literal|1
expr_stmt|;
name|sc
operator|=
name|AUTO
expr_stmt|;
block|}
else|else
block|{
name|lerror
argument_list|(
literal|"dname() 2"
argument_list|)
expr_stmt|;
block|}
name|sym
operator|->
name|s_def
operator|=
name|DEF
expr_stmt|;
break|break;
case|case
name|AUTO
case|:
if|if
condition|(
operator|(
name|sc
operator|=
name|dcs
operator|->
name|d_scl
operator|)
operator|==
name|NOSCL
condition|)
block|{
comment|/* 			 * XXX somewhat ugly because we dont know whether 			 * this is AUTO or EXTERN (functions). If we are 			 * wrong it must be corrected in decl1loc(), where 			 * we have the necessary type information. 			 */
name|sc
operator|=
name|AUTO
expr_stmt|;
name|sym
operator|->
name|s_def
operator|=
name|DEF
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|==
name|AUTO
operator|||
name|sc
operator|==
name|STATIC
operator|||
name|sc
operator|==
name|TYPEDEF
condition|)
block|{
name|sym
operator|->
name|s_def
operator|=
name|DEF
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|==
name|REG
condition|)
block|{
name|sym
operator|->
name|s_reg
operator|=
literal|1
expr_stmt|;
name|sc
operator|=
name|AUTO
expr_stmt|;
name|sym
operator|->
name|s_def
operator|=
name|DEF
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|==
name|EXTERN
condition|)
block|{
name|sym
operator|->
name|s_def
operator|=
name|DECL
expr_stmt|;
block|}
else|else
block|{
name|lerror
argument_list|(
literal|"dname() 3"
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|lerror
argument_list|(
literal|"dname() 4"
argument_list|)
expr_stmt|;
block|}
name|sym
operator|->
name|s_scl
operator|=
name|sc
expr_stmt|;
name|sym
operator|->
name|s_type
operator|=
name|dcs
operator|->
name|d_type
expr_stmt|;
name|dcs
operator|->
name|d_fpsyms
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|sym
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Process a name in the list of formal params in an old style function  * definition.  */
end_comment

begin_function
name|sym_t
modifier|*
name|iname
parameter_list|(
name|sym_t
modifier|*
name|sym
parameter_list|)
block|{
if|if
condition|(
name|sym
operator|->
name|s_scl
operator|!=
name|NOSCL
condition|)
block|{
if|if
condition|(
name|blklev
operator|==
name|sym
operator|->
name|s_blklev
condition|)
block|{
comment|/* redeclaration of formal parameter %s */
name|error
argument_list|(
literal|21
argument_list|,
name|sym
operator|->
name|s_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sym
operator|->
name|s_defarg
condition|)
name|lerror
argument_list|(
literal|"iname()"
argument_list|)
expr_stmt|;
block|}
name|sym
operator|=
name|pushdown
argument_list|(
name|sym
argument_list|)
expr_stmt|;
block|}
name|sym
operator|->
name|s_type
operator|=
name|gettyp
argument_list|(
name|INT
argument_list|)
expr_stmt|;
name|sym
operator|->
name|s_scl
operator|=
name|AUTO
expr_stmt|;
name|sym
operator|->
name|s_def
operator|=
name|DEF
expr_stmt|;
name|sym
operator|->
name|s_defarg
operator|=
name|sym
operator|->
name|s_arg
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|sym
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create the type of a tag.  *  * tag points to the symbol table entry of the tag  * kind is the kind of the tag (STRUCT/UNION/ENUM)  * decl is 1 if the type of the tag will be completed in this declaration  * (the following token is T_LBRACE)  * semi is 1 if the following token is T_SEMI  */
end_comment

begin_function
name|type_t
modifier|*
name|mktag
parameter_list|(
name|sym_t
modifier|*
name|tag
parameter_list|,
name|tspec_t
name|kind
parameter_list|,
name|int
name|decl
parameter_list|,
name|int
name|semi
parameter_list|)
block|{
name|scl_t
name|scl
init|=
name|NOSCL
decl_stmt|;
name|type_t
modifier|*
name|tp
decl_stmt|;
if|if
condition|(
name|kind
operator|==
name|STRUCT
condition|)
block|{
name|scl
operator|=
name|STRTAG
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|kind
operator|==
name|UNION
condition|)
block|{
name|scl
operator|=
name|UNIONTAG
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|kind
operator|==
name|ENUM
condition|)
block|{
name|scl
operator|=
name|ENUMTAG
expr_stmt|;
block|}
else|else
block|{
name|lerror
argument_list|(
literal|"mktag()"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tag
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|tag
operator|->
name|s_scl
operator|!=
name|NOSCL
condition|)
block|{
name|tag
operator|=
name|newtag
argument_list|(
name|tag
argument_list|,
name|scl
argument_list|,
name|decl
argument_list|,
name|semi
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* a new tag, no empty declaration */
name|dcs
operator|->
name|d_nxt
operator|->
name|d_nedecl
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|scl
operator|==
name|ENUMTAG
operator|&&
operator|!
name|decl
condition|)
block|{
if|if
condition|(
operator|!
name|tflag
operator|&&
operator|(
name|sflag
operator|||
name|pflag
operator|)
condition|)
comment|/* forward reference to enum type */
name|warning
argument_list|(
literal|42
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tag
operator|->
name|s_scl
operator|==
name|NOSCL
condition|)
block|{
name|tag
operator|->
name|s_scl
operator|=
name|scl
expr_stmt|;
name|tag
operator|->
name|s_type
operator|=
name|tp
operator|=
name|getblk
argument_list|(
sizeof|sizeof
argument_list|(
name|type_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tp
operator|=
name|tag
operator|->
name|s_type
expr_stmt|;
block|}
block|}
else|else
block|{
name|tag
operator|=
name|getblk
argument_list|(
sizeof|sizeof
argument_list|(
name|sym_t
argument_list|)
argument_list|)
expr_stmt|;
name|tag
operator|->
name|s_name
operator|=
name|unnamed
expr_stmt|;
name|UNIQUE_CURR_POS
argument_list|(
name|tag
operator|->
name|s_dpos
argument_list|)
expr_stmt|;
name|tag
operator|->
name|s_kind
operator|=
name|FTAG
expr_stmt|;
name|tag
operator|->
name|s_scl
operator|=
name|scl
expr_stmt|;
name|tag
operator|->
name|s_blklev
operator|=
operator|-
literal|1
expr_stmt|;
name|tag
operator|->
name|s_type
operator|=
name|tp
operator|=
name|getblk
argument_list|(
sizeof|sizeof
argument_list|(
name|type_t
argument_list|)
argument_list|)
expr_stmt|;
name|dcs
operator|->
name|d_nxt
operator|->
name|d_nedecl
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|tp
operator|->
name|t_tspec
operator|==
name|NOTSPEC
condition|)
block|{
name|tp
operator|->
name|t_tspec
operator|=
name|kind
expr_stmt|;
if|if
condition|(
name|kind
operator|!=
name|ENUM
condition|)
block|{
name|tp
operator|->
name|t_str
operator|=
name|getblk
argument_list|(
sizeof|sizeof
argument_list|(
name|str_t
argument_list|)
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_str
operator|->
name|align
operator|=
name|CHAR_BIT
expr_stmt|;
name|tp
operator|->
name|t_str
operator|->
name|stag
operator|=
name|tag
expr_stmt|;
block|}
else|else
block|{
name|tp
operator|->
name|t_isenum
operator|=
literal|1
expr_stmt|;
name|tp
operator|->
name|t_enum
operator|=
name|getblk
argument_list|(
sizeof|sizeof
argument_list|(
name|enum_t
argument_list|)
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_enum
operator|->
name|etag
operator|=
name|tag
expr_stmt|;
block|}
comment|/* ist unvollstaendiger Typ */
name|setcompl
argument_list|(
name|tp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|tp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Checks all possible cases of tag redeclarations.  * decl is 1 if T_LBRACE follows  * semi is 1 if T_SEMI follows  */
end_comment

begin_function
specifier|static
name|sym_t
modifier|*
name|newtag
parameter_list|(
name|sym_t
modifier|*
name|tag
parameter_list|,
name|scl_t
name|scl
parameter_list|,
name|int
name|decl
parameter_list|,
name|int
name|semi
parameter_list|)
block|{
if|if
condition|(
name|tag
operator|->
name|s_blklev
operator|<
name|blklev
condition|)
block|{
if|if
condition|(
name|semi
condition|)
block|{
comment|/* "struct a;" */
if|if
condition|(
operator|!
name|tflag
condition|)
block|{
if|if
condition|(
operator|!
name|sflag
condition|)
comment|/* decl. introduces new type ... */
name|warning
argument_list|(
literal|44
argument_list|,
name|scltoa
argument_list|(
name|scl
argument_list|)
argument_list|,
name|tag
operator|->
name|s_name
argument_list|)
expr_stmt|;
name|tag
operator|=
name|pushdown
argument_list|(
name|tag
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tag
operator|->
name|s_scl
operator|!=
name|scl
condition|)
block|{
comment|/* base type is really "%s %s" */
name|warning
argument_list|(
literal|45
argument_list|,
name|scltoa
argument_list|(
name|tag
operator|->
name|s_scl
argument_list|)
argument_list|,
name|tag
operator|->
name|s_name
argument_list|)
expr_stmt|;
block|}
name|dcs
operator|->
name|d_nxt
operator|->
name|d_nedecl
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|decl
condition|)
block|{
comment|/* "struct a { ... } " */
if|if
condition|(
name|hflag
condition|)
comment|/* redefinition hides earlier one: %s */
name|warning
argument_list|(
literal|43
argument_list|,
name|tag
operator|->
name|s_name
argument_list|)
expr_stmt|;
name|tag
operator|=
name|pushdown
argument_list|(
name|tag
argument_list|)
expr_stmt|;
name|dcs
operator|->
name|d_nxt
operator|->
name|d_nedecl
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tag
operator|->
name|s_scl
operator|!=
name|scl
condition|)
block|{
comment|/* base type is really "%s %s" */
name|warning
argument_list|(
literal|45
argument_list|,
name|scltoa
argument_list|(
name|tag
operator|->
name|s_scl
argument_list|)
argument_list|,
name|tag
operator|->
name|s_name
argument_list|)
expr_stmt|;
comment|/* declaration introduces new type in ANSI C: %s %s */
if|if
condition|(
operator|!
name|sflag
condition|)
name|warning
argument_list|(
literal|44
argument_list|,
name|scltoa
argument_list|(
name|scl
argument_list|)
argument_list|,
name|tag
operator|->
name|s_name
argument_list|)
expr_stmt|;
name|tag
operator|=
name|pushdown
argument_list|(
name|tag
argument_list|)
expr_stmt|;
name|dcs
operator|->
name|d_nxt
operator|->
name|d_nedecl
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|tag
operator|->
name|s_scl
operator|!=
name|scl
condition|)
block|{
comment|/* (%s) tag redeclared */
name|error
argument_list|(
literal|46
argument_list|,
name|scltoa
argument_list|(
name|tag
operator|->
name|s_scl
argument_list|)
argument_list|)
expr_stmt|;
name|prevdecl
argument_list|(
operator|-
literal|1
argument_list|,
name|tag
argument_list|)
expr_stmt|;
name|tag
operator|=
name|pushdown
argument_list|(
name|tag
argument_list|)
expr_stmt|;
name|dcs
operator|->
name|d_nxt
operator|->
name|d_nedecl
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|decl
operator|&&
operator|!
name|incompl
argument_list|(
name|tag
operator|->
name|s_type
argument_list|)
condition|)
block|{
comment|/* (%s) tag redeclared */
name|error
argument_list|(
literal|46
argument_list|,
name|scltoa
argument_list|(
name|tag
operator|->
name|s_scl
argument_list|)
argument_list|)
expr_stmt|;
name|prevdecl
argument_list|(
operator|-
literal|1
argument_list|,
name|tag
argument_list|)
expr_stmt|;
name|tag
operator|=
name|pushdown
argument_list|(
name|tag
argument_list|)
expr_stmt|;
name|dcs
operator|->
name|d_nxt
operator|->
name|d_nedecl
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|semi
operator|||
name|decl
condition|)
block|{
name|dcs
operator|->
name|d_nxt
operator|->
name|d_nedecl
operator|=
literal|1
expr_stmt|;
block|}
block|}
return|return
operator|(
name|tag
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|scltoa
parameter_list|(
name|scl_t
name|sc
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
switch|switch
condition|(
name|sc
condition|)
block|{
case|case
name|EXTERN
case|:
name|s
operator|=
literal|"extern"
expr_stmt|;
break|break;
case|case
name|STATIC
case|:
name|s
operator|=
literal|"static"
expr_stmt|;
break|break;
case|case
name|AUTO
case|:
name|s
operator|=
literal|"auto"
expr_stmt|;
break|break;
case|case
name|REG
case|:
name|s
operator|=
literal|"register"
expr_stmt|;
break|break;
case|case
name|TYPEDEF
case|:
name|s
operator|=
literal|"typedef"
expr_stmt|;
break|break;
case|case
name|STRTAG
case|:
name|s
operator|=
literal|"struct"
expr_stmt|;
break|break;
case|case
name|UNIONTAG
case|:
name|s
operator|=
literal|"union"
expr_stmt|;
break|break;
case|case
name|ENUMTAG
case|:
name|s
operator|=
literal|"enum"
expr_stmt|;
break|break;
default|default:
name|lerror
argument_list|(
literal|"tagttoa()"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|s
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Completes the type of a tag in a struct/union/enum declaration.  * tp points to the type of the, tag, fmem to the list of members/enums.  */
end_comment

begin_function
name|type_t
modifier|*
name|compltag
parameter_list|(
name|type_t
modifier|*
name|tp
parameter_list|,
name|sym_t
modifier|*
name|fmem
parameter_list|)
block|{
name|tspec_t
name|t
decl_stmt|;
name|str_t
modifier|*
name|sp
decl_stmt|;
name|int
name|n
decl_stmt|;
name|sym_t
modifier|*
name|mem
decl_stmt|;
comment|/* from now a complete type */
name|setcompl
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|t
operator|=
name|tp
operator|->
name|t_tspec
operator|)
operator|!=
name|ENUM
condition|)
block|{
name|align
argument_list|(
name|dcs
operator|->
name|d_stralign
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sp
operator|=
name|tp
operator|->
name|t_str
expr_stmt|;
name|sp
operator|->
name|align
operator|=
name|dcs
operator|->
name|d_stralign
expr_stmt|;
name|sp
operator|->
name|size
operator|=
name|dcs
operator|->
name|d_offset
expr_stmt|;
name|sp
operator|->
name|memb
operator|=
name|fmem
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|size
operator|==
literal|0
condition|)
block|{
comment|/* zero sized %s */
operator|(
name|void
operator|)
name|gnuism
argument_list|(
literal|47
argument_list|,
name|ttab
index|[
name|t
index|]
operator|.
name|tt_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|n
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|mem
operator|=
name|fmem
init|;
name|mem
operator|!=
name|NULL
condition|;
name|mem
operator|=
name|mem
operator|->
name|s_nxt
control|)
block|{
if|if
condition|(
name|mem
operator|->
name|s_name
operator|!=
name|unnamed
condition|)
name|n
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
comment|/* %s has no named members */
name|warning
argument_list|(
literal|65
argument_list|,
name|t
operator|==
name|STRUCT
condition|?
literal|"structure"
else|:
literal|"union"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|tp
operator|->
name|t_enum
operator|->
name|elem
operator|=
name|fmem
expr_stmt|;
block|}
return|return
operator|(
name|tp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Processes the name of an enumerator in en enum declaration.  *  * sym points to the enumerator  * val is the value of the enumerator  * impl is 1 if the value of the enumerator was not explicit specified.  */
end_comment

begin_function
name|sym_t
modifier|*
name|ename
parameter_list|(
name|sym_t
modifier|*
name|sym
parameter_list|,
name|int
name|val
parameter_list|,
name|int
name|impl
parameter_list|)
block|{
if|if
condition|(
name|sym
operator|->
name|s_scl
condition|)
block|{
if|if
condition|(
name|sym
operator|->
name|s_blklev
operator|==
name|blklev
condition|)
block|{
comment|/* no hflag, because this is illegal!!! */
if|if
condition|(
name|sym
operator|->
name|s_arg
condition|)
block|{
comment|/* enumeration constant hides parameter: %s */
name|warning
argument_list|(
literal|57
argument_list|,
name|sym
operator|->
name|s_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* redeclaration of %s */
name|error
argument_list|(
literal|27
argument_list|,
name|sym
operator|->
name|s_name
argument_list|)
expr_stmt|;
comment|/* 				 * inside blocks it should not too complicated 				 * to find the position of the previous 				 * declaration 				 */
if|if
condition|(
name|blklev
operator|==
literal|0
condition|)
name|prevdecl
argument_list|(
operator|-
literal|1
argument_list|,
name|sym
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|hflag
condition|)
comment|/* redefinition hides earlier one: %s */
name|warning
argument_list|(
literal|43
argument_list|,
name|sym
operator|->
name|s_name
argument_list|)
expr_stmt|;
block|}
name|sym
operator|=
name|pushdown
argument_list|(
name|sym
argument_list|)
expr_stmt|;
block|}
name|sym
operator|->
name|s_scl
operator|=
name|ENUMCON
expr_stmt|;
name|sym
operator|->
name|s_type
operator|=
name|dcs
operator|->
name|d_tagtyp
expr_stmt|;
name|sym
operator|->
name|s_value
operator|.
name|v_tspec
operator|=
name|INT
expr_stmt|;
name|sym
operator|->
name|s_value
operator|.
name|v_quad
operator|=
name|val
expr_stmt|;
if|if
condition|(
name|impl
operator|&&
name|val
operator|-
literal|1
operator|==
name|INT_MAX
condition|)
block|{
comment|/* overflow in enumeration values: %s */
name|warning
argument_list|(
literal|48
argument_list|,
name|sym
operator|->
name|s_name
argument_list|)
expr_stmt|;
block|}
name|enumval
operator|=
name|val
operator|+
literal|1
expr_stmt|;
return|return
operator|(
name|sym
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Process a single external declarator.  */
end_comment

begin_function
name|void
name|decl1ext
parameter_list|(
name|sym_t
modifier|*
name|dsym
parameter_list|,
name|int
name|initflg
parameter_list|)
block|{
name|int
name|warn
decl_stmt|,
name|rval
decl_stmt|,
name|redec
decl_stmt|;
name|sym_t
modifier|*
name|rdsym
decl_stmt|;
name|chkfdef
argument_list|(
name|dsym
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|chktyp
argument_list|(
name|dsym
argument_list|)
expr_stmt|;
if|if
condition|(
name|initflg
operator|&&
operator|!
operator|(
name|initerr
operator|=
name|chkinit
argument_list|(
name|dsym
argument_list|)
operator|)
condition|)
name|dsym
operator|->
name|s_def
operator|=
name|DEF
expr_stmt|;
comment|/* 	 * Declarations of functions are marked as "tentative" in dname(). 	 * This is wrong because there are no tentative function 	 * definitions. 	 */
if|if
condition|(
name|dsym
operator|->
name|s_type
operator|->
name|t_tspec
operator|==
name|FUNC
operator|&&
name|dsym
operator|->
name|s_def
operator|==
name|TDEF
condition|)
name|dsym
operator|->
name|s_def
operator|=
name|DECL
expr_stmt|;
if|if
condition|(
name|dcs
operator|->
name|d_inline
condition|)
block|{
if|if
condition|(
name|dsym
operator|->
name|s_type
operator|->
name|t_tspec
operator|==
name|FUNC
condition|)
block|{
name|dsym
operator|->
name|s_inline
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* variable declared inline: %s */
name|warning
argument_list|(
literal|268
argument_list|,
name|dsym
operator|->
name|s_name
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Write the declaration into the output file */
if|if
condition|(
name|plibflg
operator|&&
name|llibflg
operator|&&
name|dsym
operator|->
name|s_type
operator|->
name|t_tspec
operator|==
name|FUNC
operator|&&
name|dsym
operator|->
name|s_type
operator|->
name|t_proto
condition|)
block|{
comment|/* 		 * With both LINTLIBRARY and PROTOLIB the prototyp is 		 * written as a function definition to the output file. 		 */
name|rval
operator|=
name|dsym
operator|->
name|s_type
operator|->
name|t_subt
operator|->
name|t_tspec
operator|!=
name|VOID
expr_stmt|;
name|outfdef
argument_list|(
name|dsym
argument_list|,
operator|&
name|dsym
operator|->
name|s_dpos
argument_list|,
name|rval
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|outsym
argument_list|(
name|dsym
argument_list|,
name|dsym
operator|->
name|s_scl
argument_list|,
name|dsym
operator|->
name|s_def
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|rdsym
operator|=
name|dcs
operator|->
name|d_rdcsym
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * If the old symbol stems from a old style function definition 		 * we have remembered the params in rdsmy->s_args and compare 		 * them with the params of the prototype. 		 */
if|if
condition|(
name|rdsym
operator|->
name|s_osdef
operator|&&
name|dsym
operator|->
name|s_type
operator|->
name|t_proto
condition|)
block|{
name|redec
operator|=
name|chkosdef
argument_list|(
name|rdsym
argument_list|,
name|dsym
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|redec
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|redec
operator|&&
operator|!
name|isredec
argument_list|(
name|dsym
argument_list|,
operator|(
name|warn
operator|=
literal|0
operator|,
operator|&
name|warn
operator|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|warn
condition|)
block|{
comment|/* redeclaration of %s */
operator|(
operator|*
operator|(
name|sflag
condition|?
name|error
else|:
name|warning
operator|)
operator|)
operator|(
literal|27
operator|,
name|dsym
operator|->
name|s_name
operator|)
expr_stmt|;
name|prevdecl
argument_list|(
operator|-
literal|1
argument_list|,
name|rdsym
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * Overtake the rememberd params if the new symbol 			 * is not a prototype. 			 */
if|if
condition|(
name|rdsym
operator|->
name|s_osdef
operator|&&
operator|!
name|dsym
operator|->
name|s_type
operator|->
name|t_proto
condition|)
block|{
name|dsym
operator|->
name|s_osdef
operator|=
name|rdsym
operator|->
name|s_osdef
expr_stmt|;
name|dsym
operator|->
name|s_args
operator|=
name|rdsym
operator|->
name|s_args
expr_stmt|;
name|STRUCT_ASSIGN
argument_list|(
name|dsym
operator|->
name|s_dpos
argument_list|,
name|rdsym
operator|->
name|s_dpos
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * Remember the position of the declaration if the 			 * old symbol was a prototype and the new is not. 			 * Also remember the position if the old symbol 			 * was defined and the new is not. 			 */
if|if
condition|(
name|rdsym
operator|->
name|s_type
operator|->
name|t_proto
operator|&&
operator|!
name|dsym
operator|->
name|s_type
operator|->
name|t_proto
condition|)
block|{
name|STRUCT_ASSIGN
argument_list|(
name|dsym
operator|->
name|s_dpos
argument_list|,
name|rdsym
operator|->
name|s_dpos
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rdsym
operator|->
name|s_def
operator|==
name|DEF
operator|&&
name|dsym
operator|->
name|s_def
operator|!=
name|DEF
condition|)
block|{
name|STRUCT_ASSIGN
argument_list|(
name|dsym
operator|->
name|s_dpos
argument_list|,
name|rdsym
operator|->
name|s_dpos
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * Copy informations about usage of the name into 			 * the new symbol. 			 */
name|cpuinfo
argument_list|(
name|dsym
argument_list|,
name|rdsym
argument_list|)
expr_stmt|;
comment|/* Once a name is defined, it remains defined. */
if|if
condition|(
name|rdsym
operator|->
name|s_def
operator|==
name|DEF
condition|)
name|dsym
operator|->
name|s_def
operator|=
name|DEF
expr_stmt|;
comment|/* once a function is inline, it remains inline */
if|if
condition|(
name|rdsym
operator|->
name|s_inline
condition|)
name|dsym
operator|->
name|s_inline
operator|=
literal|1
expr_stmt|;
name|compltyp
argument_list|(
name|dsym
argument_list|,
name|rdsym
argument_list|)
expr_stmt|;
block|}
name|rmsym
argument_list|(
name|rdsym
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dsym
operator|->
name|s_scl
operator|==
name|TYPEDEF
condition|)
block|{
name|dsym
operator|->
name|s_type
operator|=
name|duptyp
argument_list|(
name|dsym
operator|->
name|s_type
argument_list|)
expr_stmt|;
name|dsym
operator|->
name|s_type
operator|->
name|t_typedef
operator|=
literal|1
expr_stmt|;
name|settdsym
argument_list|(
name|dsym
operator|->
name|s_type
argument_list|,
name|dsym
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Copies informations about usage into a new symbol table entry of  * the same symbol.  */
end_comment

begin_function
name|void
name|cpuinfo
parameter_list|(
name|sym_t
modifier|*
name|sym
parameter_list|,
name|sym_t
modifier|*
name|rdsym
parameter_list|)
block|{
name|sym
operator|->
name|s_spos
operator|=
name|rdsym
operator|->
name|s_spos
expr_stmt|;
name|sym
operator|->
name|s_upos
operator|=
name|rdsym
operator|->
name|s_upos
expr_stmt|;
name|sym
operator|->
name|s_set
operator|=
name|rdsym
operator|->
name|s_set
expr_stmt|;
name|sym
operator|->
name|s_used
operator|=
name|rdsym
operator|->
name|s_used
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Prints an error and returns 1 if a symbol is redeclared/redefined.  * Otherwise returns 0 and, in some cases of minor problems, prints  * a warning.  */
end_comment

begin_function
name|int
name|isredec
parameter_list|(
name|sym_t
modifier|*
name|dsym
parameter_list|,
name|int
modifier|*
name|warn
parameter_list|)
block|{
name|sym_t
modifier|*
name|rsym
decl_stmt|;
if|if
condition|(
operator|(
name|rsym
operator|=
name|dcs
operator|->
name|d_rdcsym
operator|)
operator|->
name|s_scl
operator|==
name|ENUMCON
condition|)
block|{
comment|/* redeclaration of %s */
name|error
argument_list|(
literal|27
argument_list|,
name|dsym
operator|->
name|s_name
argument_list|)
expr_stmt|;
name|prevdecl
argument_list|(
operator|-
literal|1
argument_list|,
name|rsym
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|rsym
operator|->
name|s_scl
operator|==
name|TYPEDEF
condition|)
block|{
comment|/* typedef redeclared: %s */
name|error
argument_list|(
literal|89
argument_list|,
name|dsym
operator|->
name|s_name
argument_list|)
expr_stmt|;
name|prevdecl
argument_list|(
operator|-
literal|1
argument_list|,
name|rsym
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|dsym
operator|->
name|s_scl
operator|==
name|TYPEDEF
condition|)
block|{
comment|/* redeclaration of %s */
name|error
argument_list|(
literal|27
argument_list|,
name|dsym
operator|->
name|s_name
argument_list|)
expr_stmt|;
name|prevdecl
argument_list|(
operator|-
literal|1
argument_list|,
name|rsym
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|rsym
operator|->
name|s_def
operator|==
name|DEF
operator|&&
name|dsym
operator|->
name|s_def
operator|==
name|DEF
condition|)
block|{
comment|/* redefinition of %s */
name|error
argument_list|(
literal|28
argument_list|,
name|dsym
operator|->
name|s_name
argument_list|)
expr_stmt|;
name|prevdecl
argument_list|(
operator|-
literal|1
argument_list|,
name|rsym
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|eqtype
argument_list|(
name|rsym
operator|->
name|s_type
argument_list|,
name|dsym
operator|->
name|s_type
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|warn
argument_list|)
condition|)
block|{
comment|/* redeclaration of %s */
name|error
argument_list|(
literal|27
argument_list|,
name|dsym
operator|->
name|s_name
argument_list|)
expr_stmt|;
name|prevdecl
argument_list|(
operator|-
literal|1
argument_list|,
name|rsym
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|rsym
operator|->
name|s_scl
operator|==
name|EXTERN
operator|&&
name|dsym
operator|->
name|s_scl
operator|==
name|EXTERN
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|rsym
operator|->
name|s_scl
operator|==
name|STATIC
operator|&&
name|dsym
operator|->
name|s_scl
operator|==
name|STATIC
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|rsym
operator|->
name|s_scl
operator|==
name|STATIC
operator|&&
name|dsym
operator|->
name|s_def
operator|==
name|DECL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|rsym
operator|->
name|s_scl
operator|==
name|EXTERN
operator|&&
name|rsym
operator|->
name|s_def
operator|==
name|DEF
condition|)
block|{
comment|/* 		 * All cases except "int a = 1; static int a;" are catched 		 * above with or without a warning 		 */
comment|/* redeclaration of %s */
name|error
argument_list|(
literal|27
argument_list|,
name|dsym
operator|->
name|s_name
argument_list|)
expr_stmt|;
name|prevdecl
argument_list|(
operator|-
literal|1
argument_list|,
name|rsym
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|rsym
operator|->
name|s_scl
operator|==
name|EXTERN
condition|)
block|{
comment|/* previously declared extern, becomes static: %s */
name|warning
argument_list|(
literal|29
argument_list|,
name|dsym
operator|->
name|s_name
argument_list|)
expr_stmt|;
name|prevdecl
argument_list|(
operator|-
literal|1
argument_list|,
name|rsym
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Now its on of: 	 * "static a; int a;", "static a; int a = 1;", "static a = 1; int a;" 	 */
comment|/* redeclaration of %s; ANSI C requires "static" */
if|if
condition|(
name|sflag
condition|)
block|{
name|warning
argument_list|(
literal|30
argument_list|,
name|dsym
operator|->
name|s_name
argument_list|)
expr_stmt|;
name|prevdecl
argument_list|(
operator|-
literal|1
argument_list|,
name|rsym
argument_list|)
expr_stmt|;
block|}
name|dsym
operator|->
name|s_scl
operator|=
name|STATIC
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Checks if two types are compatible. Returns 0 if not, otherwise 1.  *  * ignqual	ignore qualifiers of type; used for function params  * promot	promote left type; used for comparison of params of  *		old style function definitions with params of prototypes.  * *warn	set to 1 if an old style function declaration is not  *		compatible with a prototype  */
end_comment

begin_function
name|int
name|eqtype
parameter_list|(
name|type_t
modifier|*
name|tp1
parameter_list|,
name|type_t
modifier|*
name|tp2
parameter_list|,
name|int
name|ignqual
parameter_list|,
name|int
name|promot
parameter_list|,
name|int
modifier|*
name|warn
parameter_list|)
block|{
name|tspec_t
name|t
decl_stmt|;
while|while
condition|(
name|tp1
operator|!=
name|NULL
operator|&&
name|tp2
operator|!=
name|NULL
condition|)
block|{
name|t
operator|=
name|tp1
operator|->
name|t_tspec
expr_stmt|;
if|if
condition|(
name|promot
condition|)
block|{
if|if
condition|(
name|t
operator|==
name|FLOAT
condition|)
block|{
name|t
operator|=
name|DOUBLE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t
operator|==
name|CHAR
operator|||
name|t
operator|==
name|SCHAR
condition|)
block|{
name|t
operator|=
name|INT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t
operator|==
name|UCHAR
condition|)
block|{
name|t
operator|=
name|tflag
condition|?
name|UINT
else|:
name|INT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t
operator|==
name|SHORT
condition|)
block|{
name|t
operator|=
name|INT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t
operator|==
name|USHORT
condition|)
block|{
comment|/* CONSTCOND */
name|t
operator|=
name|INT_MAX
operator|<
name|USHRT_MAX
operator|||
name|tflag
condition|?
name|UINT
else|:
name|INT
expr_stmt|;
block|}
block|}
if|if
condition|(
name|t
operator|!=
name|tp2
operator|->
name|t_tspec
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|tp1
operator|->
name|t_const
operator|!=
name|tp2
operator|->
name|t_const
operator|&&
operator|!
name|ignqual
operator|&&
operator|!
name|tflag
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|tp1
operator|->
name|t_volatile
operator|!=
name|tp2
operator|->
name|t_volatile
operator|&&
operator|!
name|ignqual
operator|&&
operator|!
name|tflag
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|t
operator|==
name|STRUCT
operator|||
name|t
operator|==
name|UNION
condition|)
return|return
operator|(
name|tp1
operator|->
name|t_str
operator|==
name|tp2
operator|->
name|t_str
operator|)
return|;
if|if
condition|(
name|t
operator|==
name|ARRAY
operator|&&
name|tp1
operator|->
name|t_dim
operator|!=
name|tp2
operator|->
name|t_dim
condition|)
block|{
if|if
condition|(
name|tp1
operator|->
name|t_dim
operator|!=
literal|0
operator|&&
name|tp2
operator|->
name|t_dim
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* dont check prototypes for traditional */
if|if
condition|(
name|t
operator|==
name|FUNC
operator|&&
operator|!
name|tflag
condition|)
block|{
if|if
condition|(
name|tp1
operator|->
name|t_proto
operator|&&
name|tp2
operator|->
name|t_proto
condition|)
block|{
if|if
condition|(
operator|!
name|eqargs
argument_list|(
name|tp1
argument_list|,
name|tp2
argument_list|,
name|warn
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|tp1
operator|->
name|t_proto
condition|)
block|{
if|if
condition|(
operator|!
name|mnoarg
argument_list|(
name|tp1
argument_list|,
name|warn
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|tp2
operator|->
name|t_proto
condition|)
block|{
if|if
condition|(
operator|!
name|mnoarg
argument_list|(
name|tp2
argument_list|,
name|warn
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
name|tp1
operator|=
name|tp1
operator|->
name|t_subt
expr_stmt|;
name|tp2
operator|=
name|tp2
operator|->
name|t_subt
expr_stmt|;
name|ignqual
operator|=
name|promot
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|tp1
operator|==
name|tp2
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Compares the parameter types of two prototypes.  */
end_comment

begin_function
specifier|static
name|int
name|eqargs
parameter_list|(
name|type_t
modifier|*
name|tp1
parameter_list|,
name|type_t
modifier|*
name|tp2
parameter_list|,
name|int
modifier|*
name|warn
parameter_list|)
block|{
name|sym_t
modifier|*
name|a1
decl_stmt|,
modifier|*
name|a2
decl_stmt|;
if|if
condition|(
name|tp1
operator|->
name|t_vararg
operator|!=
name|tp2
operator|->
name|t_vararg
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|a1
operator|=
name|tp1
operator|->
name|t_args
expr_stmt|;
name|a2
operator|=
name|tp2
operator|->
name|t_args
expr_stmt|;
while|while
condition|(
name|a1
operator|!=
name|NULL
operator|&&
name|a2
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|eqtype
argument_list|(
name|a1
operator|->
name|s_type
argument_list|,
name|a2
operator|->
name|s_type
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|warn
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|a1
operator|=
name|a1
operator|->
name|s_nxt
expr_stmt|;
name|a2
operator|=
name|a2
operator|->
name|s_nxt
expr_stmt|;
block|}
return|return
operator|(
name|a1
operator|==
name|a2
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * mnoarg() (matches functions with no argument type information)  * returns 1 if all parameters of a prototype are compatible with  * and old style function declaration.  * This is the case if following conditions are met:  *	1. the prototype must have a fixed number of parameters  *	2. no parameter is of type float  *	3. no parameter is converted to another type if integer promotion  *	   is applied on it  */
end_comment

begin_function
specifier|static
name|int
name|mnoarg
parameter_list|(
name|type_t
modifier|*
name|tp
parameter_list|,
name|int
modifier|*
name|warn
parameter_list|)
block|{
name|sym_t
modifier|*
name|arg
decl_stmt|;
name|tspec_t
name|t
decl_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_vararg
condition|)
block|{
if|if
condition|(
name|warn
operator|!=
name|NULL
condition|)
operator|*
name|warn
operator|=
literal|1
expr_stmt|;
block|}
for|for
control|(
name|arg
operator|=
name|tp
operator|->
name|t_args
init|;
name|arg
operator|!=
name|NULL
condition|;
name|arg
operator|=
name|arg
operator|->
name|s_nxt
control|)
block|{
if|if
condition|(
operator|(
name|t
operator|=
name|arg
operator|->
name|s_type
operator|->
name|t_tspec
operator|)
operator|==
name|FLOAT
operator|||
name|t
operator|==
name|CHAR
operator|||
name|t
operator|==
name|SCHAR
operator|||
name|t
operator|==
name|UCHAR
operator|||
name|t
operator|==
name|SHORT
operator|||
name|t
operator|==
name|USHORT
condition|)
block|{
if|if
condition|(
name|warn
operator|!=
name|NULL
condition|)
operator|*
name|warn
operator|=
literal|1
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Compares a prototype declaration with the remembered arguments of  * a previous old style function definition.  */
end_comment

begin_function
specifier|static
name|int
name|chkosdef
parameter_list|(
name|sym_t
modifier|*
name|rdsym
parameter_list|,
name|sym_t
modifier|*
name|dsym
parameter_list|)
block|{
name|sym_t
modifier|*
name|args
decl_stmt|,
modifier|*
name|pargs
decl_stmt|,
modifier|*
name|arg
decl_stmt|,
modifier|*
name|parg
decl_stmt|;
name|int
name|narg
decl_stmt|,
name|nparg
decl_stmt|,
name|n
decl_stmt|;
name|int
name|warn
decl_stmt|,
name|msg
decl_stmt|;
name|args
operator|=
name|rdsym
operator|->
name|s_args
expr_stmt|;
name|pargs
operator|=
name|dsym
operator|->
name|s_type
operator|->
name|t_args
expr_stmt|;
name|msg
operator|=
literal|0
expr_stmt|;
name|narg
operator|=
name|nparg
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|arg
operator|=
name|args
init|;
name|arg
operator|!=
name|NULL
condition|;
name|arg
operator|=
name|arg
operator|->
name|s_nxt
control|)
name|narg
operator|++
expr_stmt|;
for|for
control|(
name|parg
operator|=
name|pargs
init|;
name|parg
operator|!=
name|NULL
condition|;
name|parg
operator|=
name|parg
operator|->
name|s_nxt
control|)
name|nparg
operator|++
expr_stmt|;
if|if
condition|(
name|narg
operator|!=
name|nparg
condition|)
block|{
comment|/* prototype does not match old-style definition */
name|error
argument_list|(
literal|63
argument_list|)
expr_stmt|;
name|msg
operator|=
literal|1
expr_stmt|;
goto|goto
name|end
goto|;
block|}
name|arg
operator|=
name|args
expr_stmt|;
name|parg
operator|=
name|pargs
expr_stmt|;
name|n
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|narg
operator|--
condition|)
block|{
name|warn
operator|=
literal|0
expr_stmt|;
comment|/* 		 * If it does not match due to promotion and sflag is 		 * not set we print only a warning. 		 */
if|if
condition|(
operator|!
name|eqtype
argument_list|(
name|arg
operator|->
name|s_type
argument_list|,
name|parg
operator|->
name|s_type
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
operator|&
name|warn
argument_list|)
operator|||
name|warn
condition|)
block|{
comment|/* prototype does not match old-style def., arg #%d */
name|error
argument_list|(
literal|299
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|msg
operator|=
literal|1
expr_stmt|;
block|}
name|arg
operator|=
name|arg
operator|->
name|s_nxt
expr_stmt|;
name|parg
operator|=
name|parg
operator|->
name|s_nxt
expr_stmt|;
name|n
operator|++
expr_stmt|;
block|}
name|end
label|:
if|if
condition|(
name|msg
condition|)
comment|/* old style definition */
name|prevdecl
argument_list|(
literal|300
argument_list|,
name|rdsym
argument_list|)
expr_stmt|;
return|return
operator|(
name|msg
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Complets a type by copying the dimension and prototype information  * from a second compatible type.  *  * Following lines are legal:  *  "typedef a[]; a b; a b[10]; a c; a c[20];"  *  "typedef ft(); ft f; f(int); ft g; g(long);"  * This means that, if a type is completed, the type structure must  * be duplicated.  */
end_comment

begin_function
name|void
name|compltyp
parameter_list|(
name|sym_t
modifier|*
name|dsym
parameter_list|,
name|sym_t
modifier|*
name|ssym
parameter_list|)
block|{
name|type_t
modifier|*
modifier|*
name|dstp
decl_stmt|,
modifier|*
name|src
decl_stmt|;
name|type_t
modifier|*
name|dst
decl_stmt|;
name|dstp
operator|=
operator|&
name|dsym
operator|->
name|s_type
expr_stmt|;
name|src
operator|=
name|ssym
operator|->
name|s_type
expr_stmt|;
while|while
condition|(
operator|(
name|dst
operator|=
operator|*
name|dstp
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|src
operator|==
name|NULL
operator|||
name|dst
operator|->
name|t_tspec
operator|!=
name|src
operator|->
name|t_tspec
condition|)
name|lerror
argument_list|(
literal|"compltyp() 1"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst
operator|->
name|t_tspec
operator|==
name|ARRAY
condition|)
block|{
if|if
condition|(
name|dst
operator|->
name|t_dim
operator|==
literal|0
operator|&&
name|src
operator|->
name|t_dim
operator|!=
literal|0
condition|)
block|{
operator|*
name|dstp
operator|=
name|dst
operator|=
name|duptyp
argument_list|(
name|dst
argument_list|)
expr_stmt|;
name|dst
operator|->
name|t_dim
operator|=
name|src
operator|->
name|t_dim
expr_stmt|;
comment|/* now a complete Typ */
name|setcompl
argument_list|(
name|dst
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|dst
operator|->
name|t_tspec
operator|==
name|FUNC
condition|)
block|{
if|if
condition|(
operator|!
name|dst
operator|->
name|t_proto
operator|&&
name|src
operator|->
name|t_proto
condition|)
block|{
operator|*
name|dstp
operator|=
name|dst
operator|=
name|duptyp
argument_list|(
name|dst
argument_list|)
expr_stmt|;
name|dst
operator|->
name|t_proto
operator|=
literal|1
expr_stmt|;
name|dst
operator|->
name|t_args
operator|=
name|src
operator|->
name|t_args
expr_stmt|;
block|}
block|}
name|dstp
operator|=
operator|&
name|dst
operator|->
name|t_subt
expr_stmt|;
name|src
operator|=
name|src
operator|->
name|t_subt
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Completes the declaration of a single argument.  */
end_comment

begin_function
name|sym_t
modifier|*
name|decl1arg
parameter_list|(
name|sym_t
modifier|*
name|sym
parameter_list|,
name|int
name|initflg
parameter_list|)
block|{
name|tspec_t
name|t
decl_stmt|;
name|chkfdef
argument_list|(
name|sym
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|chktyp
argument_list|(
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|dcs
operator|->
name|d_rdcsym
operator|!=
name|NULL
operator|&&
name|dcs
operator|->
name|d_rdcsym
operator|->
name|s_blklev
operator|==
name|blklev
condition|)
block|{
comment|/* redeclaration of formal parameter %s */
name|error
argument_list|(
literal|237
argument_list|,
name|sym
operator|->
name|s_name
argument_list|)
expr_stmt|;
name|rmsym
argument_list|(
name|dcs
operator|->
name|d_rdcsym
argument_list|)
expr_stmt|;
name|sym
operator|->
name|s_arg
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|sym
operator|->
name|s_arg
condition|)
block|{
comment|/* declared argument %s is missing */
name|error
argument_list|(
literal|53
argument_list|,
name|sym
operator|->
name|s_name
argument_list|)
expr_stmt|;
name|sym
operator|->
name|s_arg
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|initflg
condition|)
block|{
comment|/* cannot initialize parameter: %s */
name|error
argument_list|(
literal|52
argument_list|,
name|sym
operator|->
name|s_name
argument_list|)
expr_stmt|;
name|initerr
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|t
operator|=
name|sym
operator|->
name|s_type
operator|->
name|t_tspec
operator|)
operator|==
name|ARRAY
condition|)
block|{
name|sym
operator|->
name|s_type
operator|=
name|incref
argument_list|(
name|sym
operator|->
name|s_type
operator|->
name|t_subt
argument_list|,
name|PTR
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t
operator|==
name|FUNC
condition|)
block|{
if|if
condition|(
name|tflag
condition|)
comment|/* a function is declared as an argument: %s */
name|warning
argument_list|(
literal|50
argument_list|,
name|sym
operator|->
name|s_name
argument_list|)
expr_stmt|;
name|sym
operator|->
name|s_type
operator|=
name|incref
argument_list|(
name|sym
operator|->
name|s_type
argument_list|,
name|PTR
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t
operator|==
name|FLOAT
condition|)
block|{
if|if
condition|(
name|tflag
condition|)
name|sym
operator|->
name|s_type
operator|=
name|gettyp
argument_list|(
name|DOUBLE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dcs
operator|->
name|d_inline
condition|)
comment|/* argument declared inline: %s */
name|warning
argument_list|(
literal|269
argument_list|,
name|sym
operator|->
name|s_name
argument_list|)
expr_stmt|;
comment|/* 	 * Arguments must have complete types. lengths() prints the needed 	 * error messages (null dimension is impossible because arrays are 	 * converted to pointers). 	 */
if|if
condition|(
name|sym
operator|->
name|s_type
operator|->
name|t_tspec
operator|!=
name|VOID
condition|)
operator|(
name|void
operator|)
name|length
argument_list|(
name|sym
operator|->
name|s_type
argument_list|,
name|sym
operator|->
name|s_name
argument_list|)
expr_stmt|;
name|setsflg
argument_list|(
name|sym
argument_list|)
expr_stmt|;
return|return
operator|(
name|sym
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Does some checks for lint directives which apply to functions.  * Processes arguments in old style function definitions which default  * to int.  * Checks compatiblility of old style function definition with previous  * prototype.  */
end_comment

begin_function
name|void
name|cluparg
parameter_list|(
name|void
parameter_list|)
block|{
name|sym_t
modifier|*
name|args
decl_stmt|,
modifier|*
name|arg
decl_stmt|,
modifier|*
name|pargs
decl_stmt|,
modifier|*
name|parg
decl_stmt|;
name|int
name|narg
decl_stmt|,
name|nparg
decl_stmt|,
name|n
decl_stmt|,
name|msg
decl_stmt|;
name|tspec_t
name|t
decl_stmt|;
name|args
operator|=
name|funcsym
operator|->
name|s_args
expr_stmt|;
name|pargs
operator|=
name|funcsym
operator|->
name|s_type
operator|->
name|t_args
expr_stmt|;
comment|/* check for illegal combinations of lint directives */
if|if
condition|(
name|prflstrg
operator|!=
operator|-
literal|1
operator|&&
name|scflstrg
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* can't be used together: ** PRINTFLIKE ** ** SCANFLIKE ** */
name|warning
argument_list|(
literal|289
argument_list|)
expr_stmt|;
name|prflstrg
operator|=
name|scflstrg
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|nvararg
operator|!=
operator|-
literal|1
operator|&&
operator|(
name|prflstrg
operator|!=
operator|-
literal|1
operator|||
name|scflstrg
operator|!=
operator|-
literal|1
operator|)
condition|)
block|{
comment|/* dubious use of ** VARARGS ** with ** %s ** */
name|warning
argument_list|(
literal|288
argument_list|,
name|prflstrg
operator|!=
operator|-
literal|1
condition|?
literal|"PRINTFLIKE"
else|:
literal|"SCANFLIKE"
argument_list|)
expr_stmt|;
name|nvararg
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* 	 * check if the argument of a lint directive is compatible with the 	 * number of arguments. 	 */
name|narg
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|arg
operator|=
name|dcs
operator|->
name|d_fargs
init|;
name|arg
operator|!=
name|NULL
condition|;
name|arg
operator|=
name|arg
operator|->
name|s_nxt
control|)
name|narg
operator|++
expr_stmt|;
if|if
condition|(
name|nargusg
operator|>
name|narg
condition|)
block|{
comment|/* argument number mismatch with directive: ** %s ** */
name|warning
argument_list|(
literal|283
argument_list|,
literal|"ARGSUSED"
argument_list|)
expr_stmt|;
name|nargusg
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|nvararg
operator|>
name|narg
condition|)
block|{
comment|/* argument number mismatch with directive: ** %s ** */
name|warning
argument_list|(
literal|283
argument_list|,
literal|"VARARGS"
argument_list|)
expr_stmt|;
name|nvararg
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|prflstrg
operator|>
name|narg
condition|)
block|{
comment|/* argument number mismatch with directive: ** %s ** */
name|warning
argument_list|(
literal|283
argument_list|,
literal|"PRINTFLIKE"
argument_list|)
expr_stmt|;
name|prflstrg
operator|=
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|prflstrg
operator|==
literal|0
condition|)
block|{
name|prflstrg
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|scflstrg
operator|>
name|narg
condition|)
block|{
comment|/* argument number mismatch with directive: ** %s ** */
name|warning
argument_list|(
literal|283
argument_list|,
literal|"SCANFLIKE"
argument_list|)
expr_stmt|;
name|scflstrg
operator|=
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scflstrg
operator|==
literal|0
condition|)
block|{
name|scflstrg
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|prflstrg
operator|!=
operator|-
literal|1
operator|||
name|scflstrg
operator|!=
operator|-
literal|1
condition|)
block|{
name|narg
operator|=
name|prflstrg
operator|!=
operator|-
literal|1
condition|?
name|prflstrg
else|:
name|scflstrg
expr_stmt|;
name|arg
operator|=
name|dcs
operator|->
name|d_fargs
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|1
init|;
name|n
operator|<
name|narg
condition|;
name|n
operator|++
control|)
name|arg
operator|=
name|arg
operator|->
name|s_nxt
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|s_type
operator|->
name|t_tspec
operator|!=
name|PTR
operator|||
operator|(
operator|(
name|t
operator|=
name|arg
operator|->
name|s_type
operator|->
name|t_subt
operator|->
name|t_tspec
operator|)
operator|!=
name|CHAR
operator|&&
name|t
operator|!=
name|UCHAR
operator|&&
name|t
operator|!=
name|SCHAR
operator|)
condition|)
block|{
comment|/* arg. %d must be 'char *' for PRINTFLIKE/SCANFLIKE */
name|warning
argument_list|(
literal|293
argument_list|,
name|narg
argument_list|)
expr_stmt|;
name|prflstrg
operator|=
name|scflstrg
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
comment|/* 	 * print a warning for each argument off an old style function 	 * definition which defaults to int 	 */
for|for
control|(
name|arg
operator|=
name|args
init|;
name|arg
operator|!=
name|NULL
condition|;
name|arg
operator|=
name|arg
operator|->
name|s_nxt
control|)
block|{
if|if
condition|(
name|arg
operator|->
name|s_defarg
condition|)
block|{
comment|/* argument type defaults to int: %s */
name|warning
argument_list|(
literal|32
argument_list|,
name|arg
operator|->
name|s_name
argument_list|)
expr_stmt|;
name|arg
operator|->
name|s_defarg
operator|=
literal|0
expr_stmt|;
name|setsflg
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * If this is an old style function definition and a prototyp 	 * exists, compare the types of arguments. 	 */
if|if
condition|(
name|funcsym
operator|->
name|s_osdef
operator|&&
name|funcsym
operator|->
name|s_type
operator|->
name|t_proto
condition|)
block|{
comment|/* 		 * If the number of arguments does not macht, we need not 		 * continue. 		 */
name|narg
operator|=
name|nparg
operator|=
literal|0
expr_stmt|;
name|msg
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|parg
operator|=
name|pargs
init|;
name|parg
operator|!=
name|NULL
condition|;
name|parg
operator|=
name|parg
operator|->
name|s_nxt
control|)
name|nparg
operator|++
expr_stmt|;
for|for
control|(
name|arg
operator|=
name|args
init|;
name|arg
operator|!=
name|NULL
condition|;
name|arg
operator|=
name|arg
operator|->
name|s_nxt
control|)
name|narg
operator|++
expr_stmt|;
if|if
condition|(
name|narg
operator|!=
name|nparg
condition|)
block|{
comment|/* parameter mismatch: %d declared, %d defined */
name|error
argument_list|(
literal|51
argument_list|,
name|nparg
argument_list|,
name|narg
argument_list|)
expr_stmt|;
name|msg
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|parg
operator|=
name|pargs
expr_stmt|;
name|arg
operator|=
name|args
expr_stmt|;
while|while
condition|(
name|narg
operator|--
condition|)
block|{
name|msg
operator||=
name|chkptdecl
argument_list|(
name|arg
argument_list|,
name|parg
argument_list|)
expr_stmt|;
name|parg
operator|=
name|parg
operator|->
name|s_nxt
expr_stmt|;
name|arg
operator|=
name|arg
operator|->
name|s_nxt
expr_stmt|;
block|}
block|}
if|if
condition|(
name|msg
condition|)
comment|/* prototype declaration */
name|prevdecl
argument_list|(
literal|285
argument_list|,
name|dcs
operator|->
name|d_rdcsym
argument_list|)
expr_stmt|;
comment|/* from now the prototype is valid */
name|funcsym
operator|->
name|s_osdef
operator|=
literal|0
expr_stmt|;
name|funcsym
operator|->
name|s_args
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Checks compatibility of an old style function definition with a previous  * prototype declaration.  * Returns 1 if the position of the previous declaration should be reported.  */
end_comment

begin_function
specifier|static
name|int
name|chkptdecl
parameter_list|(
name|sym_t
modifier|*
name|arg
parameter_list|,
name|sym_t
modifier|*
name|parg
parameter_list|)
block|{
name|type_t
modifier|*
name|tp
decl_stmt|,
modifier|*
name|ptp
decl_stmt|;
name|int
name|warn
decl_stmt|,
name|msg
decl_stmt|;
name|tp
operator|=
name|arg
operator|->
name|s_type
expr_stmt|;
name|ptp
operator|=
name|parg
operator|->
name|s_type
expr_stmt|;
name|msg
operator|=
literal|0
expr_stmt|;
name|warn
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|eqtype
argument_list|(
name|tp
argument_list|,
name|ptp
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
operator|&
name|warn
argument_list|)
condition|)
block|{
if|if
condition|(
name|eqtype
argument_list|(
name|tp
argument_list|,
name|ptp
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
operator|&
name|warn
argument_list|)
condition|)
block|{
comment|/* type does not match prototype: %s */
name|msg
operator|=
name|gnuism
argument_list|(
literal|58
argument_list|,
name|arg
operator|->
name|s_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* type does not match prototype: %s */
name|error
argument_list|(
literal|58
argument_list|,
name|arg
operator|->
name|s_name
argument_list|)
expr_stmt|;
name|msg
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|warn
condition|)
block|{
comment|/* type does not match prototype: %s */
operator|(
operator|*
operator|(
name|sflag
condition|?
name|error
else|:
name|warning
operator|)
operator|)
operator|(
literal|58
operator|,
name|arg
operator|->
name|s_name
operator|)
expr_stmt|;
name|msg
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|msg
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Completes a single local declaration/definition.  */
end_comment

begin_function
name|void
name|decl1loc
parameter_list|(
name|sym_t
modifier|*
name|dsym
parameter_list|,
name|int
name|initflg
parameter_list|)
block|{
comment|/* Correct a mistake done in dname(). */
if|if
condition|(
name|dsym
operator|->
name|s_type
operator|->
name|t_tspec
operator|==
name|FUNC
condition|)
block|{
name|dsym
operator|->
name|s_def
operator|=
name|DECL
expr_stmt|;
if|if
condition|(
name|dcs
operator|->
name|d_scl
operator|==
name|NOSCL
condition|)
name|dsym
operator|->
name|s_scl
operator|=
name|EXTERN
expr_stmt|;
block|}
if|if
condition|(
name|dsym
operator|->
name|s_type
operator|->
name|t_tspec
operator|==
name|FUNC
condition|)
block|{
if|if
condition|(
name|dsym
operator|->
name|s_scl
operator|==
name|STATIC
condition|)
block|{
comment|/* dubious static function at block level: %s */
name|warning
argument_list|(
literal|93
argument_list|,
name|dsym
operator|->
name|s_name
argument_list|)
expr_stmt|;
name|dsym
operator|->
name|s_scl
operator|=
name|EXTERN
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dsym
operator|->
name|s_scl
operator|!=
name|EXTERN
operator|&&
name|dsym
operator|->
name|s_scl
operator|!=
name|TYPEDEF
condition|)
block|{
comment|/* function has illegal storage class: %s */
name|error
argument_list|(
literal|94
argument_list|,
name|dsym
operator|->
name|s_name
argument_list|)
expr_stmt|;
name|dsym
operator|->
name|s_scl
operator|=
name|EXTERN
expr_stmt|;
block|}
block|}
comment|/* 	 * functions may be declared inline at local scope, although 	 * this has no effect for a later definition of the same 	 * function. 	 * XXX it should have an effect if tflag is set. this would 	 * also be the way gcc behaves. 	 */
if|if
condition|(
name|dcs
operator|->
name|d_inline
condition|)
block|{
if|if
condition|(
name|dsym
operator|->
name|s_type
operator|->
name|t_tspec
operator|==
name|FUNC
condition|)
block|{
name|dsym
operator|->
name|s_inline
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* variable declared inline: %s */
name|warning
argument_list|(
literal|268
argument_list|,
name|dsym
operator|->
name|s_name
argument_list|)
expr_stmt|;
block|}
block|}
name|chkfdef
argument_list|(
name|dsym
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|chktyp
argument_list|(
name|dsym
argument_list|)
expr_stmt|;
if|if
condition|(
name|dcs
operator|->
name|d_rdcsym
operator|!=
name|NULL
operator|&&
name|dsym
operator|->
name|s_scl
operator|==
name|EXTERN
condition|)
name|ledecl
argument_list|(
name|dsym
argument_list|)
expr_stmt|;
if|if
condition|(
name|dsym
operator|->
name|s_scl
operator|==
name|EXTERN
condition|)
block|{
comment|/* 		 * XXX wenn die statische Variable auf Ebene 0 erst 		 * spaeter definiert wird, haben wir die Brille auf. 		 */
if|if
condition|(
name|dsym
operator|->
name|s_xsym
operator|==
name|NULL
condition|)
block|{
name|outsym
argument_list|(
name|dsym
argument_list|,
name|EXTERN
argument_list|,
name|dsym
operator|->
name|s_def
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|outsym
argument_list|(
name|dsym
argument_list|,
name|dsym
operator|->
name|s_xsym
operator|->
name|s_scl
argument_list|,
name|dsym
operator|->
name|s_def
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dcs
operator|->
name|d_rdcsym
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|dcs
operator|->
name|d_rdcsym
operator|->
name|s_blklev
operator|==
literal|0
condition|)
block|{
switch|switch
condition|(
name|dsym
operator|->
name|s_scl
condition|)
block|{
case|case
name|AUTO
case|:
comment|/* automatic hides external declaration: %s */
if|if
condition|(
name|hflag
condition|)
name|warning
argument_list|(
literal|86
argument_list|,
name|dsym
operator|->
name|s_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|STATIC
case|:
comment|/* static hides external declaration: %s */
if|if
condition|(
name|hflag
condition|)
name|warning
argument_list|(
literal|87
argument_list|,
name|dsym
operator|->
name|s_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPEDEF
case|:
comment|/* typedef hides  external declaration: %s */
if|if
condition|(
name|hflag
condition|)
name|warning
argument_list|(
literal|88
argument_list|,
name|dsym
operator|->
name|s_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|EXTERN
case|:
comment|/* 				 * Warnings and errors are printed in ledecl() 				 */
break|break;
default|default:
name|lerror
argument_list|(
literal|"decl1loc() 1"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|dcs
operator|->
name|d_rdcsym
operator|->
name|s_blklev
operator|==
name|blklev
condition|)
block|{
comment|/* no hflag, because its illegal! */
if|if
condition|(
name|dcs
operator|->
name|d_rdcsym
operator|->
name|s_arg
condition|)
block|{
comment|/* 				 * if !tflag, a "redeclaration of %s" error 				 * is produced below 				 */
if|if
condition|(
name|tflag
condition|)
block|{
if|if
condition|(
name|hflag
condition|)
comment|/* decl. hides parameter: %s */
name|warning
argument_list|(
literal|91
argument_list|,
name|dsym
operator|->
name|s_name
argument_list|)
expr_stmt|;
name|rmsym
argument_list|(
name|dcs
operator|->
name|d_rdcsym
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|dcs
operator|->
name|d_rdcsym
operator|->
name|s_blklev
operator|<
name|blklev
condition|)
block|{
if|if
condition|(
name|hflag
condition|)
comment|/* declaration hides earlier one: %s */
name|warning
argument_list|(
literal|95
argument_list|,
name|dsym
operator|->
name|s_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dcs
operator|->
name|d_rdcsym
operator|->
name|s_blklev
operator|==
name|blklev
condition|)
block|{
comment|/* redeclaration of %s */
name|error
argument_list|(
literal|27
argument_list|,
name|dsym
operator|->
name|s_name
argument_list|)
expr_stmt|;
name|rmsym
argument_list|(
name|dcs
operator|->
name|d_rdcsym
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|initflg
operator|&&
operator|!
operator|(
name|initerr
operator|=
name|chkinit
argument_list|(
name|dsym
argument_list|)
operator|)
condition|)
block|{
name|dsym
operator|->
name|s_def
operator|=
name|DEF
expr_stmt|;
name|setsflg
argument_list|(
name|dsym
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dsym
operator|->
name|s_scl
operator|==
name|TYPEDEF
condition|)
block|{
name|dsym
operator|->
name|s_type
operator|=
name|duptyp
argument_list|(
name|dsym
operator|->
name|s_type
argument_list|)
expr_stmt|;
name|dsym
operator|->
name|s_type
operator|->
name|t_typedef
operator|=
literal|1
expr_stmt|;
name|settdsym
argument_list|(
name|dsym
operator|->
name|s_type
argument_list|,
name|dsym
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Before we can check the size we must wait for a initialisation 	 * which may follow. 	 */
block|}
end_function

begin_comment
comment|/*  * Processes (re)declarations of external Symbols inside blocks.  */
end_comment

begin_function
specifier|static
name|void
name|ledecl
parameter_list|(
name|sym_t
modifier|*
name|dsym
parameter_list|)
block|{
name|int
name|eqt
decl_stmt|,
name|warn
decl_stmt|;
name|sym_t
modifier|*
name|esym
decl_stmt|;
comment|/* look for a symbol with the same name */
name|esym
operator|=
name|dcs
operator|->
name|d_rdcsym
expr_stmt|;
while|while
condition|(
name|esym
operator|!=
name|NULL
operator|&&
name|esym
operator|->
name|s_blklev
operator|!=
literal|0
condition|)
block|{
while|while
condition|(
operator|(
name|esym
operator|=
name|esym
operator|->
name|s_link
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|esym
operator|->
name|s_kind
operator|!=
name|FVFT
condition|)
continue|continue;
if|if
condition|(
name|strcmp
argument_list|(
name|dsym
operator|->
name|s_name
argument_list|,
name|esym
operator|->
name|s_name
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|esym
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|esym
operator|->
name|s_scl
operator|!=
name|EXTERN
operator|&&
name|esym
operator|->
name|s_scl
operator|!=
name|STATIC
condition|)
block|{
comment|/* gcc accepts this without a warning, pcc prints an error. */
comment|/* redeclaration of %s */
name|warning
argument_list|(
literal|27
argument_list|,
name|dsym
operator|->
name|s_name
argument_list|)
expr_stmt|;
name|prevdecl
argument_list|(
operator|-
literal|1
argument_list|,
name|esym
argument_list|)
expr_stmt|;
return|return;
block|}
name|warn
operator|=
literal|0
expr_stmt|;
name|eqt
operator|=
name|eqtype
argument_list|(
name|esym
operator|->
name|s_type
argument_list|,
name|dsym
operator|->
name|s_type
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|warn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|eqt
operator|||
name|warn
condition|)
block|{
if|if
condition|(
name|esym
operator|->
name|s_scl
operator|==
name|EXTERN
condition|)
block|{
comment|/* inconsistent redeclaration of extern: %s */
name|warning
argument_list|(
literal|90
argument_list|,
name|dsym
operator|->
name|s_name
argument_list|)
expr_stmt|;
name|prevdecl
argument_list|(
operator|-
literal|1
argument_list|,
name|esym
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* inconsistent redeclaration of static: %s */
name|warning
argument_list|(
literal|92
argument_list|,
name|dsym
operator|->
name|s_name
argument_list|)
expr_stmt|;
name|prevdecl
argument_list|(
operator|-
literal|1
argument_list|,
name|esym
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|eqt
condition|)
block|{
comment|/* 		 * Remember the external symbol so we can update usage 		 * information at the end of the block. 		 */
name|dsym
operator|->
name|s_xsym
operator|=
name|esym
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Print an error or a warning if the symbol cant be initialized due  * to type/storage class. Returnvalue is 1 if an error has been  * detected.  */
end_comment

begin_function
specifier|static
name|int
name|chkinit
parameter_list|(
name|sym_t
modifier|*
name|sym
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|err
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sym
operator|->
name|s_type
operator|->
name|t_tspec
operator|==
name|FUNC
condition|)
block|{
comment|/* cannot initialize function: %s */
name|error
argument_list|(
literal|24
argument_list|,
name|sym
operator|->
name|s_name
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sym
operator|->
name|s_scl
operator|==
name|TYPEDEF
condition|)
block|{
comment|/* cannot initialize typedef: %s */
name|error
argument_list|(
literal|25
argument_list|,
name|sym
operator|->
name|s_name
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sym
operator|->
name|s_scl
operator|==
name|EXTERN
operator|&&
name|sym
operator|->
name|s_def
operator|==
name|DECL
condition|)
block|{
comment|/* cannot initialize "extern" declaration: %s */
if|if
condition|(
name|dcs
operator|->
name|d_ctx
operator|==
name|EXTERN
condition|)
block|{
name|warning
argument_list|(
literal|26
argument_list|,
name|sym
operator|->
name|s_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
literal|26
argument_list|,
name|sym
operator|->
name|s_name
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create a symbole for an abstract declaration.  */
end_comment

begin_function
name|sym_t
modifier|*
name|aname
parameter_list|(
name|void
parameter_list|)
block|{
name|sym_t
modifier|*
name|sym
decl_stmt|;
if|if
condition|(
name|dcs
operator|->
name|d_ctx
operator|!=
name|ABSTRACT
operator|&&
name|dcs
operator|->
name|d_ctx
operator|!=
name|PARG
condition|)
name|lerror
argument_list|(
literal|"aname()"
argument_list|)
expr_stmt|;
name|sym
operator|=
name|getblk
argument_list|(
sizeof|sizeof
argument_list|(
name|sym_t
argument_list|)
argument_list|)
expr_stmt|;
name|sym
operator|->
name|s_name
operator|=
name|unnamed
expr_stmt|;
name|sym
operator|->
name|s_def
operator|=
name|DEF
expr_stmt|;
name|sym
operator|->
name|s_scl
operator|=
name|ABSTRACT
expr_stmt|;
name|sym
operator|->
name|s_blklev
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|dcs
operator|->
name|d_ctx
operator|==
name|PARG
condition|)
name|sym
operator|->
name|s_arg
operator|=
literal|1
expr_stmt|;
name|sym
operator|->
name|s_type
operator|=
name|dcs
operator|->
name|d_type
expr_stmt|;
name|dcs
operator|->
name|d_rdcsym
operator|=
name|NULL
expr_stmt|;
name|dcs
operator|->
name|d_vararg
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|sym
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Removes anything which has nothing to do on global level.  */
end_comment

begin_function
name|void
name|globclup
parameter_list|(
name|void
parameter_list|)
block|{
while|while
condition|(
name|dcs
operator|->
name|d_nxt
operator|!=
name|NULL
condition|)
name|popdecl
argument_list|()
expr_stmt|;
name|cleanup
argument_list|()
expr_stmt|;
name|blklev
operator|=
literal|0
expr_stmt|;
name|mblklev
operator|=
literal|0
expr_stmt|;
comment|/* 	 * remove all informations about pending lint directives without 	 * warnings. 	 */
name|glclup
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process an abstract type declaration  */
end_comment

begin_function
name|sym_t
modifier|*
name|decl1abs
parameter_list|(
name|sym_t
modifier|*
name|sym
parameter_list|)
block|{
name|chkfdef
argument_list|(
name|sym
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|chktyp
argument_list|(
name|sym
argument_list|)
expr_stmt|;
return|return
operator|(
name|sym
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Checks size after declarations of variables and their initialisation.  */
end_comment

begin_function
name|void
name|chksz
parameter_list|(
name|sym_t
modifier|*
name|dsym
parameter_list|)
block|{
comment|/* 	 * check size only for symbols which are defined and no function and 	 * not typedef name 	 */
if|if
condition|(
name|dsym
operator|->
name|s_def
operator|!=
name|DEF
condition|)
return|return;
if|if
condition|(
name|dsym
operator|->
name|s_scl
operator|==
name|TYPEDEF
condition|)
return|return;
if|if
condition|(
name|dsym
operator|->
name|s_type
operator|->
name|t_tspec
operator|==
name|FUNC
condition|)
return|return;
if|if
condition|(
name|length
argument_list|(
name|dsym
operator|->
name|s_type
argument_list|,
name|dsym
operator|->
name|s_name
argument_list|)
operator|==
literal|0
operator|&&
name|dsym
operator|->
name|s_type
operator|->
name|t_tspec
operator|==
name|ARRAY
operator|&&
name|dsym
operator|->
name|s_type
operator|->
name|t_dim
operator|==
literal|0
condition|)
block|{
comment|/* empty array declaration: %s */
if|if
condition|(
name|tflag
condition|)
block|{
name|warning
argument_list|(
literal|190
argument_list|,
name|dsym
operator|->
name|s_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
literal|190
argument_list|,
name|dsym
operator|->
name|s_name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Mark an object as set if it is not already  */
end_comment

begin_function
name|void
name|setsflg
parameter_list|(
name|sym_t
modifier|*
name|sym
parameter_list|)
block|{
if|if
condition|(
operator|!
name|sym
operator|->
name|s_set
condition|)
block|{
name|sym
operator|->
name|s_set
operator|=
literal|1
expr_stmt|;
name|UNIQUE_CURR_POS
argument_list|(
name|sym
operator|->
name|s_spos
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Mark an object as used if it is not already  */
end_comment

begin_function
name|void
name|setuflg
parameter_list|(
name|sym_t
modifier|*
name|sym
parameter_list|,
name|int
name|fcall
parameter_list|,
name|int
name|szof
parameter_list|)
block|{
if|if
condition|(
operator|!
name|sym
operator|->
name|s_used
condition|)
block|{
name|sym
operator|->
name|s_used
operator|=
literal|1
expr_stmt|;
name|UNIQUE_CURR_POS
argument_list|(
name|sym
operator|->
name|s_upos
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * for function calls another record is written 	 * 	 * XXX Should symbols used in sizeof() treated as used or not? 	 * Probably not, because there is no sense to declare an 	 * external variable only to get their size. 	 */
if|if
condition|(
operator|!
name|fcall
operator|&&
operator|!
name|szof
operator|&&
name|sym
operator|->
name|s_kind
operator|==
name|FVFT
operator|&&
name|sym
operator|->
name|s_scl
operator|==
name|EXTERN
condition|)
name|outusg
argument_list|(
name|sym
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Prints warnings for a list of variables and labels (concatenated  * with s_dlnxt) if these are not used or only set.  */
end_comment

begin_function
name|void
name|chkusage
parameter_list|(
name|dinfo_t
modifier|*
name|di
parameter_list|)
block|{
name|sym_t
modifier|*
name|sym
decl_stmt|;
name|int
name|mknowarn
decl_stmt|;
comment|/* for this warnings LINTED has no effect */
name|mknowarn
operator|=
name|nowarn
expr_stmt|;
name|nowarn
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|sym
operator|=
name|di
operator|->
name|d_dlsyms
init|;
name|sym
operator|!=
name|NULL
condition|;
name|sym
operator|=
name|sym
operator|->
name|s_dlnxt
control|)
name|chkusg1
argument_list|(
name|di
operator|->
name|d_asm
argument_list|,
name|sym
argument_list|)
expr_stmt|;
name|nowarn
operator|=
name|mknowarn
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Prints a warning for a single variable or label if it is not used or  * only set.  */
end_comment

begin_function
name|void
name|chkusg1
parameter_list|(
name|int
name|novar
parameter_list|,
name|sym_t
modifier|*
name|sym
parameter_list|)
block|{
name|pos_t
name|cpos
decl_stmt|;
if|if
condition|(
name|sym
operator|->
name|s_blklev
operator|==
operator|-
literal|1
condition|)
return|return;
name|STRUCT_ASSIGN
argument_list|(
name|cpos
argument_list|,
name|curr_pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|->
name|s_kind
operator|==
name|FVFT
condition|)
block|{
if|if
condition|(
name|sym
operator|->
name|s_arg
condition|)
block|{
name|chkausg
argument_list|(
name|novar
argument_list|,
name|sym
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|chkvusg
argument_list|(
name|novar
argument_list|,
name|sym
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|sym
operator|->
name|s_kind
operator|==
name|FLAB
condition|)
block|{
name|chklusg
argument_list|(
name|sym
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sym
operator|->
name|s_kind
operator|==
name|FTAG
condition|)
block|{
name|chktusg
argument_list|(
name|sym
argument_list|)
expr_stmt|;
block|}
name|STRUCT_ASSIGN
argument_list|(
name|curr_pos
argument_list|,
name|cpos
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|chkausg
parameter_list|(
name|int
name|novar
parameter_list|,
name|sym_t
modifier|*
name|arg
parameter_list|)
block|{
if|if
condition|(
operator|!
name|arg
operator|->
name|s_set
condition|)
name|lerror
argument_list|(
literal|"chkausg() 1"
argument_list|)
expr_stmt|;
if|if
condition|(
name|novar
condition|)
return|return;
if|if
condition|(
operator|!
name|arg
operator|->
name|s_used
operator|&&
name|vflag
condition|)
block|{
name|STRUCT_ASSIGN
argument_list|(
name|curr_pos
argument_list|,
name|arg
operator|->
name|s_dpos
argument_list|)
expr_stmt|;
comment|/* argument %s unused in function %s */
name|warning
argument_list|(
literal|231
argument_list|,
name|arg
operator|->
name|s_name
argument_list|,
name|funcsym
operator|->
name|s_name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|chkvusg
parameter_list|(
name|int
name|novar
parameter_list|,
name|sym_t
modifier|*
name|sym
parameter_list|)
block|{
name|scl_t
name|sc
decl_stmt|;
name|sym_t
modifier|*
name|xsym
decl_stmt|;
if|if
condition|(
name|blklev
operator|==
literal|0
operator|||
name|sym
operator|->
name|s_blklev
operator|==
literal|0
condition|)
name|lerror
argument_list|(
literal|"chkvusg() 1"
argument_list|)
expr_stmt|;
comment|/* errors in expressions easily cause lots of these warnings */
if|if
condition|(
name|nerr
operator|!=
literal|0
condition|)
return|return;
comment|/* 	 * XXX Only variables are checkd, although types should 	 * probably also be checked 	 */
if|if
condition|(
operator|(
name|sc
operator|=
name|sym
operator|->
name|s_scl
operator|)
operator|!=
name|EXTERN
operator|&&
name|sc
operator|!=
name|STATIC
operator|&&
name|sc
operator|!=
name|AUTO
operator|&&
name|sc
operator|!=
name|REG
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|novar
condition|)
return|return;
if|if
condition|(
name|sc
operator|==
name|EXTERN
condition|)
block|{
if|if
condition|(
operator|!
name|sym
operator|->
name|s_used
operator|&&
operator|!
name|sym
operator|->
name|s_set
condition|)
block|{
name|STRUCT_ASSIGN
argument_list|(
name|curr_pos
argument_list|,
name|sym
operator|->
name|s_dpos
argument_list|)
expr_stmt|;
comment|/* %s unused in function %s */
name|warning
argument_list|(
literal|192
argument_list|,
name|sym
operator|->
name|s_name
argument_list|,
name|funcsym
operator|->
name|s_name
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|sym
operator|->
name|s_set
operator|&&
operator|!
name|sym
operator|->
name|s_used
condition|)
block|{
name|STRUCT_ASSIGN
argument_list|(
name|curr_pos
argument_list|,
name|sym
operator|->
name|s_spos
argument_list|)
expr_stmt|;
comment|/* %s set but not used in function %s */
name|warning
argument_list|(
literal|191
argument_list|,
name|sym
operator|->
name|s_name
argument_list|,
name|funcsym
operator|->
name|s_name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|sym
operator|->
name|s_used
condition|)
block|{
name|STRUCT_ASSIGN
argument_list|(
name|curr_pos
argument_list|,
name|sym
operator|->
name|s_dpos
argument_list|)
expr_stmt|;
comment|/* %s unused in function %s */
name|warning
argument_list|(
literal|192
argument_list|,
name|sym
operator|->
name|s_name
argument_list|,
name|funcsym
operator|->
name|s_name
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sc
operator|==
name|EXTERN
condition|)
block|{
comment|/* 		 * information about usage is taken over into the symbol 		 * tabel entry at level 0 if the symbol was locally declared 		 * as an external symbol. 		 * 		 * XXX This is wrong for symbols declared static at level 0 		 * if the usage information stems from sizeof(). This is 		 * because symbols at level 0 only used in sizeof() are 		 * considered to not be used. 		 */
if|if
condition|(
operator|(
name|xsym
operator|=
name|sym
operator|->
name|s_xsym
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|sym
operator|->
name|s_used
operator|&&
operator|!
name|xsym
operator|->
name|s_used
condition|)
block|{
name|xsym
operator|->
name|s_used
operator|=
literal|1
expr_stmt|;
name|STRUCT_ASSIGN
argument_list|(
name|xsym
operator|->
name|s_upos
argument_list|,
name|sym
operator|->
name|s_upos
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sym
operator|->
name|s_set
operator|&&
operator|!
name|xsym
operator|->
name|s_set
condition|)
block|{
name|xsym
operator|->
name|s_set
operator|=
literal|1
expr_stmt|;
name|STRUCT_ASSIGN
argument_list|(
name|xsym
operator|->
name|s_spos
argument_list|,
name|sym
operator|->
name|s_spos
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|chklusg
parameter_list|(
name|sym_t
modifier|*
name|lab
parameter_list|)
block|{
if|if
condition|(
name|blklev
operator|!=
literal|1
operator|||
name|lab
operator|->
name|s_blklev
operator|!=
literal|1
condition|)
name|lerror
argument_list|(
literal|"chklusg() 1"
argument_list|)
expr_stmt|;
if|if
condition|(
name|lab
operator|->
name|s_set
operator|&&
operator|!
name|lab
operator|->
name|s_used
condition|)
block|{
name|STRUCT_ASSIGN
argument_list|(
name|curr_pos
argument_list|,
name|lab
operator|->
name|s_spos
argument_list|)
expr_stmt|;
comment|/* label %s unused in function %s */
name|warning
argument_list|(
literal|192
argument_list|,
name|lab
operator|->
name|s_name
argument_list|,
name|funcsym
operator|->
name|s_name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|lab
operator|->
name|s_set
condition|)
block|{
name|STRUCT_ASSIGN
argument_list|(
name|curr_pos
argument_list|,
name|lab
operator|->
name|s_upos
argument_list|)
expr_stmt|;
comment|/* undefined label %s */
name|warning
argument_list|(
literal|23
argument_list|,
name|lab
operator|->
name|s_name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|chktusg
parameter_list|(
name|sym_t
modifier|*
name|sym
parameter_list|)
block|{
if|if
condition|(
operator|!
name|incompl
argument_list|(
name|sym
operator|->
name|s_type
argument_list|)
condition|)
return|return;
comment|/* complain alwasy about incomplet tags declared inside blocks */
if|if
condition|(
operator|!
name|zflag
operator|||
name|dcs
operator|->
name|d_ctx
operator|!=
name|EXTERN
condition|)
return|return;
name|STRUCT_ASSIGN
argument_list|(
name|curr_pos
argument_list|,
name|sym
operator|->
name|s_dpos
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sym
operator|->
name|s_type
operator|->
name|t_tspec
condition|)
block|{
case|case
name|STRUCT
case|:
comment|/* struct %s never defined */
name|warning
argument_list|(
literal|233
argument_list|,
name|sym
operator|->
name|s_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNION
case|:
comment|/* union %s never defined */
name|warning
argument_list|(
literal|234
argument_list|,
name|sym
operator|->
name|s_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENUM
case|:
comment|/* enum %s never defined */
name|warning
argument_list|(
literal|235
argument_list|,
name|sym
operator|->
name|s_name
argument_list|)
expr_stmt|;
break|break;
default|default:
name|lerror
argument_list|(
literal|"chktusg() 1"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Called after the entire translation unit has been parsed.  * Changes tentative definitions in definitions.  * Performs some tests on global Symbols. Detected Problems are:  * - defined variables of incomplete type  * - constant variables which are not initialized  * - static symbols which are never used  */
end_comment

begin_function
name|void
name|chkglsyms
parameter_list|(
name|void
parameter_list|)
block|{
name|sym_t
modifier|*
name|sym
decl_stmt|;
name|pos_t
name|cpos
decl_stmt|;
if|if
condition|(
name|blklev
operator|!=
literal|0
operator|||
name|dcs
operator|->
name|d_nxt
operator|!=
name|NULL
condition|)
name|norecover
argument_list|()
expr_stmt|;
name|STRUCT_ASSIGN
argument_list|(
name|cpos
argument_list|,
name|curr_pos
argument_list|)
expr_stmt|;
for|for
control|(
name|sym
operator|=
name|dcs
operator|->
name|d_dlsyms
init|;
name|sym
operator|!=
name|NULL
condition|;
name|sym
operator|=
name|sym
operator|->
name|s_dlnxt
control|)
block|{
if|if
condition|(
name|sym
operator|->
name|s_blklev
operator|==
operator|-
literal|1
condition|)
continue|continue;
if|if
condition|(
name|sym
operator|->
name|s_kind
operator|==
name|FVFT
condition|)
block|{
name|chkglvar
argument_list|(
name|sym
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sym
operator|->
name|s_kind
operator|==
name|FTAG
condition|)
block|{
name|chktusg
argument_list|(
name|sym
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|sym
operator|->
name|s_kind
operator|!=
name|FMOS
condition|)
name|lerror
argument_list|(
literal|"chkglsyms() 1"
argument_list|)
expr_stmt|;
block|}
block|}
name|STRUCT_ASSIGN
argument_list|(
name|curr_pos
argument_list|,
name|cpos
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|chkglvar
parameter_list|(
name|sym_t
modifier|*
name|sym
parameter_list|)
block|{
if|if
condition|(
name|sym
operator|->
name|s_scl
operator|==
name|TYPEDEF
operator|||
name|sym
operator|->
name|s_scl
operator|==
name|ENUMCON
condition|)
return|return;
if|if
condition|(
name|sym
operator|->
name|s_scl
operator|!=
name|EXTERN
operator|&&
name|sym
operator|->
name|s_scl
operator|!=
name|STATIC
condition|)
name|lerror
argument_list|(
literal|"chkglvar() 1"
argument_list|)
expr_stmt|;
name|glchksz
argument_list|(
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|->
name|s_scl
operator|==
name|STATIC
condition|)
block|{
if|if
condition|(
name|sym
operator|->
name|s_type
operator|->
name|t_tspec
operator|==
name|FUNC
condition|)
block|{
if|if
condition|(
name|sym
operator|->
name|s_used
operator|&&
name|sym
operator|->
name|s_def
operator|!=
name|DEF
condition|)
block|{
name|STRUCT_ASSIGN
argument_list|(
name|curr_pos
argument_list|,
name|sym
operator|->
name|s_upos
argument_list|)
expr_stmt|;
comment|/* static func. called but not def.. */
name|error
argument_list|(
literal|225
argument_list|,
name|sym
operator|->
name|s_name
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|sym
operator|->
name|s_used
condition|)
block|{
name|STRUCT_ASSIGN
argument_list|(
name|curr_pos
argument_list|,
name|sym
operator|->
name|s_dpos
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|->
name|s_type
operator|->
name|t_tspec
operator|==
name|FUNC
condition|)
block|{
if|if
condition|(
name|sym
operator|->
name|s_def
operator|==
name|DEF
condition|)
block|{
if|if
condition|(
operator|!
name|sym
operator|->
name|s_inline
condition|)
comment|/* static function %s unused */
name|warning
argument_list|(
literal|236
argument_list|,
name|sym
operator|->
name|s_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* static function %s decl. but ... */
name|warning
argument_list|(
literal|290
argument_list|,
name|sym
operator|->
name|s_name
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|sym
operator|->
name|s_set
condition|)
block|{
comment|/* static variable %s unused */
name|warning
argument_list|(
literal|226
argument_list|,
name|sym
operator|->
name|s_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* static variable %s set but not used */
name|warning
argument_list|(
literal|307
argument_list|,
name|sym
operator|->
name|s_name
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|tflag
operator|&&
name|sym
operator|->
name|s_def
operator|==
name|TDEF
operator|&&
name|sym
operator|->
name|s_type
operator|->
name|t_const
condition|)
block|{
name|STRUCT_ASSIGN
argument_list|(
name|curr_pos
argument_list|,
name|sym
operator|->
name|s_dpos
argument_list|)
expr_stmt|;
comment|/* const object %s should have initializer */
name|warning
argument_list|(
literal|227
argument_list|,
name|sym
operator|->
name|s_name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|glchksz
parameter_list|(
name|sym_t
modifier|*
name|sym
parameter_list|)
block|{
if|if
condition|(
name|sym
operator|->
name|s_def
operator|==
name|TDEF
condition|)
block|{
if|if
condition|(
name|sym
operator|->
name|s_type
operator|->
name|t_tspec
operator|==
name|FUNC
condition|)
comment|/* 			 * this can happen if an syntax error occurred 			 * after a function declaration 			 */
return|return;
name|STRUCT_ASSIGN
argument_list|(
name|curr_pos
argument_list|,
name|sym
operator|->
name|s_dpos
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
argument_list|(
name|sym
operator|->
name|s_type
argument_list|,
name|sym
operator|->
name|s_name
argument_list|)
operator|==
literal|0
operator|&&
name|sym
operator|->
name|s_type
operator|->
name|t_tspec
operator|==
name|ARRAY
operator|&&
name|sym
operator|->
name|s_type
operator|->
name|t_dim
operator|==
literal|0
condition|)
block|{
comment|/* empty array declaration: %s */
if|if
condition|(
name|tflag
operator|||
operator|(
name|sym
operator|->
name|s_scl
operator|==
name|EXTERN
operator|&&
operator|!
name|sflag
operator|)
condition|)
block|{
name|warning
argument_list|(
literal|190
argument_list|,
name|sym
operator|->
name|s_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
literal|190
argument_list|,
name|sym
operator|->
name|s_name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Prints information about location of previous definition/declaration.  */
end_comment

begin_function
name|void
name|prevdecl
parameter_list|(
name|int
name|msg
parameter_list|,
name|sym_t
modifier|*
name|psym
parameter_list|)
block|{
name|pos_t
name|cpos
decl_stmt|;
if|if
condition|(
operator|!
name|rflag
condition|)
return|return;
name|STRUCT_ASSIGN
argument_list|(
name|cpos
argument_list|,
name|curr_pos
argument_list|)
expr_stmt|;
name|STRUCT_ASSIGN
argument_list|(
name|curr_pos
argument_list|,
name|psym
operator|->
name|s_dpos
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|!=
operator|-
literal|1
condition|)
block|{
name|message
argument_list|(
name|msg
argument_list|,
name|psym
operator|->
name|s_name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|psym
operator|->
name|s_def
operator|==
name|DEF
operator|||
name|psym
operator|->
name|s_def
operator|==
name|TDEF
condition|)
block|{
comment|/* previous definition of %s */
name|message
argument_list|(
literal|261
argument_list|,
name|psym
operator|->
name|s_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* previous declaration of %s */
name|message
argument_list|(
literal|260
argument_list|,
name|psym
operator|->
name|s_name
argument_list|)
expr_stmt|;
block|}
name|STRUCT_ASSIGN
argument_list|(
name|curr_pos
argument_list|,
name|cpos
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

