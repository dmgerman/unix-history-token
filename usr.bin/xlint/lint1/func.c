begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $NetBSD: func.c,v 1.7 1995/10/02 17:31:40 jpo Exp $	*/
end_comment

begin_comment
comment|/*  * Copyright (c) 1994, 1995 Jochen Pohl  * All Rights Reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *      This product includes software developed by Jochen Pohl for  *	The NetBSD Project.  * 4. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"lint1.h"
end_include

begin_include
include|#
directive|include
file|"y.tab.h"
end_include

begin_comment
comment|/*  * Contains a pointer to the symbol table entry of the current function  * definition.  */
end_comment

begin_decl_stmt
name|sym_t
modifier|*
name|funcsym
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Is set as long as a statement can be reached. Must be set at level 0. */
end_comment

begin_decl_stmt
name|int
name|reached
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Is set as long as NOTREACHED is in effect.  * Is reset everywhere where reached can become 0.  */
end_comment

begin_decl_stmt
name|int
name|rchflg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * In conjunction with reached ontrols printing of "fallthrough on ..."  * warnings.  * Reset by each statement and set by FALLTHROUGH, switch (switch1())  * and case (label()).  *  * Control statements if, for, while and switch do not reset ftflg because  * this must be done by the controled statement. At least for if this is  * important because ** FALLTHROUGH ** after "if (expr) stmnt" is evaluated  * befor the following token, wich causes reduction of above, is read.  * This means that ** FALLTHROUGH ** after "if ..." would always be ignored.  */
end_comment

begin_decl_stmt
name|int
name|ftflg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Top element of stack for control statements */
end_comment

begin_decl_stmt
name|cstk_t
modifier|*
name|cstk
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Number of arguments which will be checked for usage in following  * function definition. -1 stands for all arguments.  *  * The position of the last ARGSUSED comment is stored in aupos.  */
end_comment

begin_decl_stmt
name|int
name|nargusg
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|pos_t
name|aupos
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Number of arguments of the following function definition whose types  * shall be checked by lint2. -1 stands for all arguments.  *  * The position of the last VARARGS comment is stored in vapos.  */
end_comment

begin_decl_stmt
name|int
name|nvararg
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|pos_t
name|vapos
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Both prflstr and scflstrg contain the number of the argument which  * shall be used to check the types of remaining arguments (for PRINTFLIKE  * and SCANFLIKE).  *  * prflpos and scflpos are the positions of the last PRINTFLIKE or  * SCANFLIKE comment.  */
end_comment

begin_decl_stmt
name|int
name|prflstrg
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|scflstrg
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|pos_t
name|prflpos
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|pos_t
name|scflpos
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Are both plibflg and llibflg set, prototypes are writen as function  * definitions to the output file.  */
end_comment

begin_decl_stmt
name|int
name|plibflg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Nonzero means that no warnings about constands in conditional  * context are printed.  */
end_comment

begin_decl_stmt
name|int
name|ccflg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * llibflg is set if a lint library shall be created. The effect of  * llibflg is that all defined symbols are treated as used.  * (The LINTLIBRARY comment also resets vflag.)  */
end_comment

begin_decl_stmt
name|int
name|llibflg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Nonzero if warnings are suppressed by a LINTED directive  */
end_comment

begin_decl_stmt
name|int
name|nowarn
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Nonzero if complaints about use of "long long" are suppressed in  * the next statement or declaration.  */
end_comment

begin_decl_stmt
name|int
name|quadflg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Puts a new element at the top of the stack used for control statements.  */
end_comment

begin_function
name|void
name|pushctrl
parameter_list|(
name|env
parameter_list|)
name|int
name|env
decl_stmt|;
block|{
name|cstk_t
modifier|*
name|ci
decl_stmt|;
name|ci
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|cstk_t
argument_list|)
argument_list|)
expr_stmt|;
name|ci
operator|->
name|c_env
operator|=
name|env
expr_stmt|;
name|ci
operator|->
name|c_nxt
operator|=
name|cstk
expr_stmt|;
name|cstk
operator|=
name|ci
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Removes the top element of the stack used for control statements.  */
end_comment

begin_function
name|void
name|popctrl
parameter_list|(
name|env
parameter_list|)
name|int
name|env
decl_stmt|;
block|{
name|cstk_t
modifier|*
name|ci
decl_stmt|;
name|clst_t
modifier|*
name|cl
decl_stmt|;
if|if
condition|(
name|cstk
operator|==
name|NULL
operator|||
name|cstk
operator|->
name|c_env
operator|!=
name|env
condition|)
name|lerror
argument_list|(
literal|"popctrl() 1"
argument_list|)
expr_stmt|;
name|cstk
operator|=
operator|(
name|ci
operator|=
name|cstk
operator|)
operator|->
name|c_nxt
expr_stmt|;
while|while
condition|(
operator|(
name|cl
operator|=
name|ci
operator|->
name|c_clst
operator|)
operator|!=
name|NULL
condition|)
block|{
name|ci
operator|->
name|c_clst
operator|=
name|cl
operator|->
name|cl_nxt
expr_stmt|;
name|free
argument_list|(
name|cl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ci
operator|->
name|c_swtype
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|ci
operator|->
name|c_swtype
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ci
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Prints a warning if a statement cannot be reached.  */
end_comment

begin_function
name|void
name|chkreach
parameter_list|()
block|{
if|if
condition|(
operator|!
name|reached
operator|&&
operator|!
name|rchflg
condition|)
block|{
comment|/* statement not reached */
name|warning
argument_list|(
literal|193
argument_list|)
expr_stmt|;
name|reached
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Called after a function declaration which introduces a function definition  * and before an (optional) old style argument declaration list.  *  * Puts all symbols declared in the Prototype or in an old style argument  * list back to the symbol table.  *  * Does the usual checking of storage class, type (return value),  * redeclaration etc..  */
end_comment

begin_function
name|void
name|funcdef
parameter_list|(
name|fsym
parameter_list|)
name|sym_t
modifier|*
name|fsym
decl_stmt|;
block|{
name|int
name|n
decl_stmt|,
name|warn
decl_stmt|;
name|sym_t
modifier|*
name|arg
decl_stmt|,
modifier|*
name|sym
decl_stmt|,
modifier|*
name|rdsym
decl_stmt|;
name|funcsym
operator|=
name|fsym
expr_stmt|;
comment|/* 	 * Put all symbols declared in the argument list back to the 	 * symbol table. 	 */
for|for
control|(
name|sym
operator|=
name|dcs
operator|->
name|d_fpsyms
init|;
name|sym
operator|!=
name|NULL
condition|;
name|sym
operator|=
name|sym
operator|->
name|s_dlnxt
control|)
block|{
if|if
condition|(
name|sym
operator|->
name|s_blklev
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|sym
operator|->
name|s_blklev
operator|!=
literal|1
condition|)
name|lerror
argument_list|(
literal|"funcdef() 1"
argument_list|)
expr_stmt|;
name|inssym
argument_list|(
literal|1
argument_list|,
name|sym
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * In osfunc() we did not know whether it is an old style function 	 * definition or only an old style declaration, if there are no 	 * arguments inside the argument list ("f()"). 	 */
if|if
condition|(
operator|!
name|fsym
operator|->
name|s_type
operator|->
name|t_proto
operator|&&
name|fsym
operator|->
name|s_args
operator|==
name|NULL
condition|)
name|fsym
operator|->
name|s_osdef
operator|=
literal|1
expr_stmt|;
name|chktyp
argument_list|(
name|fsym
argument_list|)
expr_stmt|;
comment|/* 	 * chktyp() checks for almost all possible errors, but not for 	 * incomplete return values (these are allowed in declarations) 	 */
if|if
condition|(
name|fsym
operator|->
name|s_type
operator|->
name|t_subt
operator|->
name|t_tspec
operator|!=
name|VOID
operator|&&
name|incompl
argument_list|(
name|fsym
operator|->
name|s_type
operator|->
name|t_subt
argument_list|)
condition|)
block|{
comment|/* cannot return incomplete type */
name|error
argument_list|(
literal|67
argument_list|)
expr_stmt|;
block|}
name|fsym
operator|->
name|s_def
operator|=
name|DEF
expr_stmt|;
if|if
condition|(
name|fsym
operator|->
name|s_scl
operator|==
name|TYPEDEF
condition|)
block|{
name|fsym
operator|->
name|s_scl
operator|=
name|EXTERN
expr_stmt|;
comment|/* illegal storage class */
name|error
argument_list|(
literal|8
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dcs
operator|->
name|d_inline
condition|)
name|fsym
operator|->
name|s_inline
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Arguments in new style function declarations need a name. 	 * (void is already removed from the list of arguments) 	 */
name|n
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|arg
operator|=
name|fsym
operator|->
name|s_type
operator|->
name|t_args
init|;
name|arg
operator|!=
name|NULL
condition|;
name|arg
operator|=
name|arg
operator|->
name|s_nxt
control|)
block|{
if|if
condition|(
name|arg
operator|->
name|s_scl
operator|==
name|ABSTRACT
condition|)
block|{
if|if
condition|(
name|arg
operator|->
name|s_name
operator|!=
name|unnamed
condition|)
name|lerror
argument_list|(
literal|"funcdef() 2"
argument_list|)
expr_stmt|;
comment|/* formal parameter lacks name: param #%d */
name|error
argument_list|(
literal|59
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|arg
operator|->
name|s_name
operator|==
name|unnamed
condition|)
name|lerror
argument_list|(
literal|"funcdef() 3"
argument_list|)
expr_stmt|;
block|}
name|n
operator|++
expr_stmt|;
block|}
comment|/* 	 * We must also remember the position. s_dpos is overwritten 	 * if this is an old style definition and we had already a 	 * prototype. 	 */
name|STRUCT_ASSIGN
argument_list|(
name|dcs
operator|->
name|d_fdpos
argument_list|,
name|fsym
operator|->
name|s_dpos
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rdsym
operator|=
name|dcs
operator|->
name|d_rdcsym
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|isredec
argument_list|(
name|fsym
argument_list|,
operator|(
name|warn
operator|=
literal|0
operator|,
operator|&
name|warn
operator|)
argument_list|)
condition|)
block|{
comment|/* 			 * Print nothing if the newly defined function 			 * is defined in old style. A better warning will 			 * be printed in cluparg(). 			 */
if|if
condition|(
name|warn
operator|&&
operator|!
name|fsym
operator|->
name|s_osdef
condition|)
block|{
comment|/* redeclaration of %s */
operator|(
operator|*
operator|(
name|sflag
condition|?
name|error
else|:
name|warning
operator|)
operator|)
operator|(
literal|27
operator|,
name|fsym
operator|->
name|s_name
operator|)
expr_stmt|;
name|prevdecl
argument_list|(
operator|-
literal|1
argument_list|,
name|rdsym
argument_list|)
expr_stmt|;
block|}
comment|/* copy usage information */
name|cpuinfo
argument_list|(
name|fsym
argument_list|,
name|rdsym
argument_list|)
expr_stmt|;
comment|/* 			 * If the old symbol was a prototype and the new 			 * one is none, overtake the position of the 			 * declaration of the prototype. 			 */
if|if
condition|(
name|fsym
operator|->
name|s_osdef
operator|&&
name|rdsym
operator|->
name|s_type
operator|->
name|t_proto
condition|)
name|STRUCT_ASSIGN
argument_list|(
name|fsym
operator|->
name|s_dpos
argument_list|,
name|rdsym
operator|->
name|s_dpos
argument_list|)
expr_stmt|;
comment|/* complete the type */
name|compltyp
argument_list|(
name|fsym
argument_list|,
name|rdsym
argument_list|)
expr_stmt|;
comment|/* once a function is inline it remains inline */
if|if
condition|(
name|rdsym
operator|->
name|s_inline
condition|)
name|fsym
operator|->
name|s_inline
operator|=
literal|1
expr_stmt|;
block|}
comment|/* remove the old symbol from the symbol table */
name|rmsym
argument_list|(
name|rdsym
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fsym
operator|->
name|s_osdef
operator|&&
operator|!
name|fsym
operator|->
name|s_type
operator|->
name|t_proto
condition|)
block|{
if|if
condition|(
name|sflag
operator|&&
name|hflag
operator|&&
name|strcmp
argument_list|(
name|fsym
operator|->
name|s_name
argument_list|,
literal|"main"
argument_list|)
operator|!=
literal|0
condition|)
comment|/* function definition is not a prototyp */
name|warning
argument_list|(
literal|286
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dcs
operator|->
name|d_notyp
condition|)
comment|/* return value is implizitly declared to be int */
name|fsym
operator|->
name|s_rimpl
operator|=
literal|1
expr_stmt|;
name|reached
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Called at the end of a function definition.  */
end_comment

begin_function
name|void
name|funcend
parameter_list|()
block|{
name|sym_t
modifier|*
name|arg
decl_stmt|;
name|int
name|n
decl_stmt|;
if|if
condition|(
name|reached
condition|)
block|{
name|cstk
operator|->
name|c_noretval
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|funcsym
operator|->
name|s_type
operator|->
name|t_subt
operator|->
name|t_tspec
operator|!=
name|VOID
operator|&&
operator|!
name|funcsym
operator|->
name|s_rimpl
condition|)
block|{
comment|/* func. %s falls off bottom without returning value */
name|warning
argument_list|(
literal|217
argument_list|,
name|funcsym
operator|->
name|s_name
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * This warning is printed only if the return value was implizitly 	 * declared to be int. Otherwise the wrong return statement 	 * has already printed a warning. 	 */
if|if
condition|(
name|cstk
operator|->
name|c_noretval
operator|&&
name|cstk
operator|->
name|c_retval
operator|&&
name|funcsym
operator|->
name|s_rimpl
condition|)
comment|/* function %s has return (e); and return; */
name|warning
argument_list|(
literal|216
argument_list|,
name|funcsym
operator|->
name|s_name
argument_list|)
expr_stmt|;
comment|/* Print warnings for unused arguments */
name|arg
operator|=
name|dcs
operator|->
name|d_fargs
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|arg
operator|!=
name|NULL
operator|&&
operator|(
name|nargusg
operator|==
operator|-
literal|1
operator|||
name|n
operator|<
name|nargusg
operator|)
condition|)
block|{
name|chkusg1
argument_list|(
name|dcs
operator|->
name|d_asm
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|arg
operator|=
name|arg
operator|->
name|s_nxt
expr_stmt|;
name|n
operator|++
expr_stmt|;
block|}
name|nargusg
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* 	 * write the information about the function definition to the 	 * output file 	 * inline functions explicitely declared extern are written as 	 * declarations only. 	 */
if|if
condition|(
name|dcs
operator|->
name|d_scl
operator|==
name|EXTERN
operator|&&
name|funcsym
operator|->
name|s_inline
condition|)
block|{
name|outsym
argument_list|(
name|funcsym
argument_list|,
name|funcsym
operator|->
name|s_scl
argument_list|,
name|DECL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|outfdef
argument_list|(
name|funcsym
argument_list|,
operator|&
name|dcs
operator|->
name|d_fdpos
argument_list|,
name|cstk
operator|->
name|c_retval
argument_list|,
name|funcsym
operator|->
name|s_osdef
argument_list|,
name|dcs
operator|->
name|d_fargs
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * remove all symbols declared during argument declaration from 	 * the symbol table 	 */
if|if
condition|(
name|dcs
operator|->
name|d_nxt
operator|!=
name|NULL
operator|||
name|dcs
operator|->
name|d_ctx
operator|!=
name|EXTERN
condition|)
name|lerror
argument_list|(
literal|"funcend() 1"
argument_list|)
expr_stmt|;
name|rmsyms
argument_list|(
name|dcs
operator|->
name|d_fpsyms
argument_list|)
expr_stmt|;
comment|/* must be set on level 0 */
name|reached
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process a label.  *  * typ		type of the label (T_NAME, T_DEFAULT or T_CASE).  * sym		symbol table entry of label if typ == T_NAME  * tn		expression if typ == T_CASE  */
end_comment

begin_function
name|void
name|label
parameter_list|(
name|typ
parameter_list|,
name|sym
parameter_list|,
name|tn
parameter_list|)
name|int
name|typ
decl_stmt|;
name|sym_t
modifier|*
name|sym
decl_stmt|;
name|tnode_t
modifier|*
name|tn
decl_stmt|;
block|{
name|cstk_t
modifier|*
name|ci
decl_stmt|;
name|clst_t
modifier|*
name|cl
decl_stmt|;
name|val_t
modifier|*
name|v
decl_stmt|,
modifier|*
name|nv
decl_stmt|;
name|tspec_t
name|t
decl_stmt|;
switch|switch
condition|(
name|typ
condition|)
block|{
case|case
name|T_NAME
case|:
if|if
condition|(
name|sym
operator|->
name|s_set
condition|)
block|{
comment|/* label %s redefined */
name|error
argument_list|(
literal|194
argument_list|,
name|sym
operator|->
name|s_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|setsflg
argument_list|(
name|sym
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|T_CASE
case|:
comment|/* find the stack entry for the innermost switch statement */
for|for
control|(
name|ci
operator|=
name|cstk
init|;
name|ci
operator|!=
name|NULL
operator|&&
operator|!
name|ci
operator|->
name|c_switch
condition|;
name|ci
operator|=
name|ci
operator|->
name|c_nxt
control|)
empty_stmt|;
if|if
condition|(
name|ci
operator|==
name|NULL
condition|)
block|{
comment|/* case not in switch */
name|error
argument_list|(
literal|195
argument_list|)
expr_stmt|;
name|tn
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tn
operator|!=
name|NULL
operator|&&
name|tn
operator|->
name|tn_op
operator|!=
name|CON
condition|)
block|{
comment|/* non-constant case expression */
name|error
argument_list|(
literal|197
argument_list|)
expr_stmt|;
name|tn
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tn
operator|!=
name|NULL
operator|&&
operator|!
name|isityp
argument_list|(
name|tn
operator|->
name|tn_type
operator|->
name|t_tspec
argument_list|)
condition|)
block|{
comment|/* non-integral case expression */
name|error
argument_list|(
literal|198
argument_list|)
expr_stmt|;
name|tn
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|tn
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ci
operator|->
name|c_swtype
operator|==
name|NULL
condition|)
name|lerror
argument_list|(
literal|"label() 1"
argument_list|)
expr_stmt|;
if|if
condition|(
name|reached
operator|&&
operator|!
name|ftflg
condition|)
block|{
if|if
condition|(
name|hflag
condition|)
comment|/* fallthrough on case statement */
name|warning
argument_list|(
literal|220
argument_list|)
expr_stmt|;
block|}
name|t
operator|=
name|tn
operator|->
name|tn_type
operator|->
name|t_tspec
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|LONG
operator|||
name|t
operator|==
name|ULONG
operator|||
name|t
operator|==
name|QUAD
operator|||
name|t
operator|==
name|UQUAD
condition|)
block|{
if|if
condition|(
name|tflag
condition|)
comment|/* case label must be of type ... */
name|warning
argument_list|(
literal|203
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * get the value of the expression and convert it 			 * to the type of the switch expression 			 */
name|v
operator|=
name|constant
argument_list|(
name|tn
argument_list|)
expr_stmt|;
name|nv
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|val_t
argument_list|)
argument_list|)
expr_stmt|;
name|cvtcon
argument_list|(
name|CASE
argument_list|,
literal|0
argument_list|,
name|ci
operator|->
name|c_swtype
argument_list|,
name|nv
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|v
argument_list|)
expr_stmt|;
comment|/* look if we had this value already */
for|for
control|(
name|cl
operator|=
name|ci
operator|->
name|c_clst
init|;
name|cl
operator|!=
name|NULL
condition|;
name|cl
operator|=
name|cl
operator|->
name|cl_nxt
control|)
block|{
if|if
condition|(
name|cl
operator|->
name|cl_val
operator|.
name|v_quad
operator|==
name|nv
operator|->
name|v_quad
condition|)
break|break;
block|}
if|if
condition|(
name|cl
operator|!=
name|NULL
operator|&&
name|isutyp
argument_list|(
name|nv
operator|->
name|v_tspec
argument_list|)
condition|)
block|{
comment|/* duplicate case in switch, %lu */
name|error
argument_list|(
literal|200
argument_list|,
operator|(
name|u_long
operator|)
name|nv
operator|->
name|v_quad
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cl
operator|!=
name|NULL
condition|)
block|{
comment|/* duplicate case in switch, %ld */
name|error
argument_list|(
literal|199
argument_list|,
operator|(
name|long
operator|)
name|nv
operator|->
name|v_quad
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * append the value to the list of 				 * case values 				 */
name|cl
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|clst_t
argument_list|)
argument_list|)
expr_stmt|;
name|STRUCT_ASSIGN
argument_list|(
name|cl
operator|->
name|cl_val
argument_list|,
operator|*
name|nv
argument_list|)
expr_stmt|;
name|cl
operator|->
name|cl_nxt
operator|=
name|ci
operator|->
name|c_clst
expr_stmt|;
name|ci
operator|->
name|c_clst
operator|=
name|cl
expr_stmt|;
block|}
block|}
name|tfreeblk
argument_list|()
expr_stmt|;
break|break;
case|case
name|T_DEFAULT
case|:
comment|/* find the stack entry for the innermost switch statement */
for|for
control|(
name|ci
operator|=
name|cstk
init|;
name|ci
operator|!=
name|NULL
operator|&&
operator|!
name|ci
operator|->
name|c_switch
condition|;
name|ci
operator|=
name|ci
operator|->
name|c_nxt
control|)
empty_stmt|;
if|if
condition|(
name|ci
operator|==
name|NULL
condition|)
block|{
comment|/* default outside switch */
name|error
argument_list|(
literal|201
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ci
operator|->
name|c_default
condition|)
block|{
comment|/* duplicate default in switch */
name|error
argument_list|(
literal|202
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|reached
operator|&&
operator|!
name|ftflg
condition|)
block|{
if|if
condition|(
name|hflag
condition|)
comment|/* fallthrough on default statement */
name|warning
argument_list|(
literal|284
argument_list|)
expr_stmt|;
block|}
name|ci
operator|->
name|c_default
operator|=
literal|1
expr_stmt|;
block|}
break|break;
block|}
empty_stmt|;
name|reached
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * T_IF T_LPARN expr T_RPARN  */
end_comment

begin_function
name|void
name|if1
parameter_list|(
name|tn
parameter_list|)
name|tnode_t
modifier|*
name|tn
decl_stmt|;
block|{
if|if
condition|(
name|tn
operator|!=
name|NULL
condition|)
name|tn
operator|=
name|cconv
argument_list|(
name|tn
argument_list|)
expr_stmt|;
if|if
condition|(
name|tn
operator|!=
name|NULL
condition|)
name|tn
operator|=
name|promote
argument_list|(
name|NOOP
argument_list|,
literal|0
argument_list|,
name|tn
argument_list|)
expr_stmt|;
name|expr
argument_list|(
name|tn
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pushctrl
argument_list|(
name|T_IF
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * if_without_else  * if_without_else T_ELSE  */
end_comment

begin_function
name|void
name|if2
parameter_list|()
block|{
name|cstk
operator|->
name|c_rchif
operator|=
name|reached
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|reached
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * if_without_else  * if_without_else T_ELSE stmnt  */
end_comment

begin_function
name|void
name|if3
parameter_list|(
name|els
parameter_list|)
name|int
name|els
decl_stmt|;
block|{
if|if
condition|(
name|els
condition|)
block|{
name|reached
operator||=
name|cstk
operator|->
name|c_rchif
expr_stmt|;
block|}
else|else
block|{
name|reached
operator|=
literal|1
expr_stmt|;
block|}
name|popctrl
argument_list|(
name|T_IF
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * T_SWITCH T_LPARN expr T_RPARN  */
end_comment

begin_function
name|void
name|switch1
parameter_list|(
name|tn
parameter_list|)
name|tnode_t
modifier|*
name|tn
decl_stmt|;
block|{
name|tspec_t
name|t
decl_stmt|;
name|type_t
modifier|*
name|tp
decl_stmt|;
if|if
condition|(
name|tn
operator|!=
name|NULL
condition|)
name|tn
operator|=
name|cconv
argument_list|(
name|tn
argument_list|)
expr_stmt|;
if|if
condition|(
name|tn
operator|!=
name|NULL
condition|)
name|tn
operator|=
name|promote
argument_list|(
name|NOOP
argument_list|,
literal|0
argument_list|,
name|tn
argument_list|)
expr_stmt|;
if|if
condition|(
name|tn
operator|!=
name|NULL
operator|&&
operator|!
name|isityp
argument_list|(
name|tn
operator|->
name|tn_type
operator|->
name|t_tspec
argument_list|)
condition|)
block|{
comment|/* switch expression must have integral type */
name|error
argument_list|(
literal|205
argument_list|)
expr_stmt|;
name|tn
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|tn
operator|!=
name|NULL
operator|&&
name|tflag
condition|)
block|{
name|t
operator|=
name|tn
operator|->
name|tn_type
operator|->
name|t_tspec
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|LONG
operator|||
name|t
operator|==
name|ULONG
operator|||
name|t
operator|==
name|QUAD
operator|||
name|t
operator|==
name|UQUAD
condition|)
block|{
comment|/* switch expr. must be of type `int' in trad. C */
name|warning
argument_list|(
literal|271
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Remember the type of the expression. Because its possible 	 * that (*tp) is allocated on tree memory the type must be 	 * duplicated. This is not too complicated because it is 	 * only an integer type. 	 */
name|tp
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|type_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tn
operator|!=
name|NULL
condition|)
block|{
name|tp
operator|->
name|t_tspec
operator|=
name|tn
operator|->
name|tn_type
operator|->
name|t_tspec
expr_stmt|;
if|if
condition|(
operator|(
name|tp
operator|->
name|t_isenum
operator|=
name|tn
operator|->
name|tn_type
operator|->
name|t_isenum
operator|)
operator|!=
literal|0
condition|)
name|tp
operator|->
name|t_enum
operator|=
name|tn
operator|->
name|tn_type
operator|->
name|t_enum
expr_stmt|;
block|}
else|else
block|{
name|tp
operator|->
name|t_tspec
operator|=
name|INT
expr_stmt|;
block|}
name|expr
argument_list|(
name|tn
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pushctrl
argument_list|(
name|T_SWITCH
argument_list|)
expr_stmt|;
name|cstk
operator|->
name|c_switch
operator|=
literal|1
expr_stmt|;
name|cstk
operator|->
name|c_swtype
operator|=
name|tp
expr_stmt|;
name|reached
operator|=
name|rchflg
operator|=
literal|0
expr_stmt|;
name|ftflg
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * switch_expr stmnt  */
end_comment

begin_function
name|void
name|switch2
parameter_list|()
block|{
name|int
name|nenum
decl_stmt|,
name|nclab
decl_stmt|;
name|sym_t
modifier|*
name|esym
decl_stmt|;
name|clst_t
modifier|*
name|cl
decl_stmt|;
if|if
condition|(
name|cstk
operator|->
name|c_swtype
operator|==
name|NULL
condition|)
name|lerror
argument_list|(
literal|"switch2() 1"
argument_list|)
expr_stmt|;
comment|/* 	 * If the switch expression was of type enumeration, count the case 	 * labels and the number of enumerators. If both counts are not 	 * equal print a warning. 	 */
if|if
condition|(
name|cstk
operator|->
name|c_swtype
operator|->
name|t_isenum
condition|)
block|{
name|nenum
operator|=
name|nclab
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cstk
operator|->
name|c_swtype
operator|->
name|t_enum
operator|==
name|NULL
condition|)
name|lerror
argument_list|(
literal|"switch2() 2"
argument_list|)
expr_stmt|;
for|for
control|(
name|esym
operator|=
name|cstk
operator|->
name|c_swtype
operator|->
name|t_enum
operator|->
name|elem
init|;
name|esym
operator|!=
name|NULL
condition|;
name|esym
operator|=
name|esym
operator|->
name|s_nxt
control|)
block|{
name|nenum
operator|++
expr_stmt|;
block|}
for|for
control|(
name|cl
operator|=
name|cstk
operator|->
name|c_clst
init|;
name|cl
operator|!=
name|NULL
condition|;
name|cl
operator|=
name|cl
operator|->
name|cl_nxt
control|)
name|nclab
operator|++
expr_stmt|;
if|if
condition|(
name|hflag
operator|&&
name|eflag
operator|&&
name|nenum
operator|!=
name|nclab
operator|&&
operator|!
name|cstk
operator|->
name|c_default
condition|)
block|{
comment|/* enumeration value(s) not handled in switch */
name|warning
argument_list|(
literal|206
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cstk
operator|->
name|c_break
condition|)
block|{
comment|/* 		 * end of switch alway reached (c_break is only set if the 		 * break statement can be reached). 		 */
name|reached
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|cstk
operator|->
name|c_default
operator|&&
operator|(
operator|!
name|hflag
operator|||
operator|!
name|cstk
operator|->
name|c_swtype
operator|->
name|t_isenum
operator|||
name|nenum
operator|!=
name|nclab
operator|)
condition|)
block|{
comment|/* 		 * there are possible values which are not handled in 		 * switch 		 */
name|reached
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 		 * otherwise the end of the switch expression is reached 		 * if the end of the last statement inside it is reached. 		 */
name|popctrl
argument_list|(
name|T_SWITCH
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * T_WHILE T_LPARN expr T_RPARN  */
end_comment

begin_function
name|void
name|while1
parameter_list|(
name|tn
parameter_list|)
name|tnode_t
modifier|*
name|tn
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|reached
condition|)
block|{
comment|/* loop not entered at top */
name|warning
argument_list|(
literal|207
argument_list|)
expr_stmt|;
name|reached
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|tn
operator|!=
name|NULL
condition|)
name|tn
operator|=
name|cconv
argument_list|(
name|tn
argument_list|)
expr_stmt|;
if|if
condition|(
name|tn
operator|!=
name|NULL
condition|)
name|tn
operator|=
name|promote
argument_list|(
name|NOOP
argument_list|,
literal|0
argument_list|,
name|tn
argument_list|)
expr_stmt|;
if|if
condition|(
name|tn
operator|!=
name|NULL
operator|&&
operator|!
name|issclt
argument_list|(
name|tn
operator|->
name|tn_type
operator|->
name|t_tspec
argument_list|)
condition|)
block|{
comment|/* controlling expressions must have scalar type */
name|error
argument_list|(
literal|204
argument_list|)
expr_stmt|;
name|tn
operator|=
name|NULL
expr_stmt|;
block|}
name|pushctrl
argument_list|(
name|T_WHILE
argument_list|)
expr_stmt|;
name|cstk
operator|->
name|c_loop
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|tn
operator|!=
name|NULL
operator|&&
name|tn
operator|->
name|tn_op
operator|==
name|CON
condition|)
block|{
if|if
condition|(
name|isityp
argument_list|(
name|tn
operator|->
name|tn_type
operator|->
name|t_tspec
argument_list|)
condition|)
block|{
name|cstk
operator|->
name|c_infinite
operator|=
name|tn
operator|->
name|tn_val
operator|->
name|v_quad
operator|!=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|cstk
operator|->
name|c_infinite
operator|=
name|tn
operator|->
name|tn_val
operator|->
name|v_ldbl
operator|!=
literal|0.0
expr_stmt|;
block|}
block|}
name|expr
argument_list|(
name|tn
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * while_expr stmnt  * while_expr error  */
end_comment

begin_function
name|void
name|while2
parameter_list|()
block|{
comment|/* 	 * The end of the loop can be reached if it is no endless loop 	 * or there was a break statement which was reached. 	 */
name|reached
operator|=
operator|!
name|cstk
operator|->
name|c_infinite
operator|||
name|cstk
operator|->
name|c_break
expr_stmt|;
name|rchflg
operator|=
literal|0
expr_stmt|;
name|popctrl
argument_list|(
name|T_WHILE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * T_DO  */
end_comment

begin_function
name|void
name|do1
parameter_list|()
block|{
if|if
condition|(
operator|!
name|reached
condition|)
block|{
comment|/* loop not entered at top */
name|warning
argument_list|(
literal|207
argument_list|)
expr_stmt|;
name|reached
operator|=
literal|1
expr_stmt|;
block|}
name|pushctrl
argument_list|(
name|T_DO
argument_list|)
expr_stmt|;
name|cstk
operator|->
name|c_loop
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * do stmnt do_while_expr  * do error  */
end_comment

begin_function
name|void
name|do2
parameter_list|(
name|tn
parameter_list|)
name|tnode_t
modifier|*
name|tn
decl_stmt|;
block|{
comment|/* 	 * If there was a continue statement the expression controlling the 	 * loop is reached. 	 */
if|if
condition|(
name|cstk
operator|->
name|c_cont
condition|)
name|reached
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|tn
operator|!=
name|NULL
condition|)
name|tn
operator|=
name|cconv
argument_list|(
name|tn
argument_list|)
expr_stmt|;
if|if
condition|(
name|tn
operator|!=
name|NULL
condition|)
name|tn
operator|=
name|promote
argument_list|(
name|NOOP
argument_list|,
literal|0
argument_list|,
name|tn
argument_list|)
expr_stmt|;
if|if
condition|(
name|tn
operator|!=
name|NULL
operator|&&
operator|!
name|issclt
argument_list|(
name|tn
operator|->
name|tn_type
operator|->
name|t_tspec
argument_list|)
condition|)
block|{
comment|/* controlling expressions must have scalar type */
name|error
argument_list|(
literal|204
argument_list|)
expr_stmt|;
name|tn
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|tn
operator|!=
name|NULL
operator|&&
name|tn
operator|->
name|tn_op
operator|==
name|CON
condition|)
block|{
if|if
condition|(
name|isityp
argument_list|(
name|tn
operator|->
name|tn_type
operator|->
name|t_tspec
argument_list|)
condition|)
block|{
name|cstk
operator|->
name|c_infinite
operator|=
name|tn
operator|->
name|tn_val
operator|->
name|v_quad
operator|!=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|cstk
operator|->
name|c_infinite
operator|=
name|tn
operator|->
name|tn_val
operator|->
name|v_ldbl
operator|!=
literal|0.0
expr_stmt|;
block|}
block|}
name|expr
argument_list|(
name|tn
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * The end of the loop is only reached if it is no endless loop 	 * or there was a break statement which could be reached. 	 */
name|reached
operator|=
operator|!
name|cstk
operator|->
name|c_infinite
operator|||
name|cstk
operator|->
name|c_break
expr_stmt|;
name|rchflg
operator|=
literal|0
expr_stmt|;
name|popctrl
argument_list|(
name|T_DO
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * T_FOR T_LPARN opt_expr T_SEMI opt_expr T_SEMI opt_expr T_RPARN  */
end_comment

begin_function
name|void
name|for1
parameter_list|(
name|tn1
parameter_list|,
name|tn2
parameter_list|,
name|tn3
parameter_list|)
name|tnode_t
modifier|*
name|tn1
decl_stmt|,
decl|*
name|tn2
decl_stmt|,
modifier|*
name|tn3
decl_stmt|;
end_function

begin_block
block|{
comment|/* 	 * If there is no initialisation expression it is possible that 	 * it is intended not to enter the loop at top. 	 */
if|if
condition|(
name|tn1
operator|!=
name|NULL
operator|&&
operator|!
name|reached
condition|)
block|{
comment|/* loop not entered at top */
name|warning
argument_list|(
literal|207
argument_list|)
expr_stmt|;
name|reached
operator|=
literal|1
expr_stmt|;
block|}
name|pushctrl
argument_list|(
name|T_FOR
argument_list|)
expr_stmt|;
name|cstk
operator|->
name|c_loop
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Store the tree memory for the reinitialisation expression. 	 * Also remember this expression itself. We must check it at 	 * the end of the loop to get "used but not set" warnings correct. 	 */
name|cstk
operator|->
name|c_fexprm
operator|=
name|tsave
argument_list|()
expr_stmt|;
name|cstk
operator|->
name|c_f3expr
operator|=
name|tn3
expr_stmt|;
name|STRUCT_ASSIGN
argument_list|(
name|cstk
operator|->
name|c_fpos
argument_list|,
name|curr_pos
argument_list|)
expr_stmt|;
name|STRUCT_ASSIGN
argument_list|(
name|cstk
operator|->
name|c_cfpos
argument_list|,
name|csrc_pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|tn1
operator|!=
name|NULL
condition|)
name|expr
argument_list|(
name|tn1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|tn2
operator|!=
name|NULL
condition|)
name|tn2
operator|=
name|cconv
argument_list|(
name|tn2
argument_list|)
expr_stmt|;
if|if
condition|(
name|tn2
operator|!=
name|NULL
condition|)
name|tn2
operator|=
name|promote
argument_list|(
name|NOOP
argument_list|,
literal|0
argument_list|,
name|tn2
argument_list|)
expr_stmt|;
if|if
condition|(
name|tn2
operator|!=
name|NULL
operator|&&
operator|!
name|issclt
argument_list|(
name|tn2
operator|->
name|tn_type
operator|->
name|t_tspec
argument_list|)
condition|)
block|{
comment|/* controlling expressions must have scalar type */
name|error
argument_list|(
literal|204
argument_list|)
expr_stmt|;
name|tn2
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|tn2
operator|!=
name|NULL
condition|)
name|expr
argument_list|(
name|tn2
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tn2
operator|==
name|NULL
condition|)
block|{
name|cstk
operator|->
name|c_infinite
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tn2
operator|->
name|tn_op
operator|==
name|CON
condition|)
block|{
if|if
condition|(
name|isityp
argument_list|(
name|tn2
operator|->
name|tn_type
operator|->
name|t_tspec
argument_list|)
condition|)
block|{
name|cstk
operator|->
name|c_infinite
operator|=
name|tn2
operator|->
name|tn_val
operator|->
name|v_quad
operator|!=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|cstk
operator|->
name|c_infinite
operator|=
name|tn2
operator|->
name|tn_val
operator|->
name|v_ldbl
operator|!=
literal|0.0
expr_stmt|;
block|}
block|}
comment|/* Checking the reinitialisation expression is done in for2() */
name|reached
operator|=
literal|1
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * for_exprs stmnt  * for_exprs error  */
end_comment

begin_function
name|void
name|for2
parameter_list|()
block|{
name|pos_t
name|cpos
decl_stmt|,
name|cspos
decl_stmt|;
name|tnode_t
modifier|*
name|tn3
decl_stmt|;
if|if
condition|(
name|cstk
operator|->
name|c_cont
condition|)
name|reached
operator|=
literal|1
expr_stmt|;
name|STRUCT_ASSIGN
argument_list|(
name|cpos
argument_list|,
name|curr_pos
argument_list|)
expr_stmt|;
name|STRUCT_ASSIGN
argument_list|(
name|cspos
argument_list|,
name|csrc_pos
argument_list|)
expr_stmt|;
comment|/* Restore the tree memory for the reinitialisation expression */
name|trestor
argument_list|(
name|cstk
operator|->
name|c_fexprm
argument_list|)
expr_stmt|;
name|tn3
operator|=
name|cstk
operator|->
name|c_f3expr
expr_stmt|;
name|STRUCT_ASSIGN
argument_list|(
name|curr_pos
argument_list|,
name|cstk
operator|->
name|c_fpos
argument_list|)
expr_stmt|;
name|STRUCT_ASSIGN
argument_list|(
name|csrc_pos
argument_list|,
name|cstk
operator|->
name|c_cfpos
argument_list|)
expr_stmt|;
comment|/* simply "statement not reached" would be confusing */
if|if
condition|(
operator|!
name|reached
operator|&&
operator|!
name|rchflg
condition|)
block|{
comment|/* end-of-loop code not reached */
name|warning
argument_list|(
literal|223
argument_list|)
expr_stmt|;
name|reached
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|tn3
operator|!=
name|NULL
condition|)
block|{
name|expr
argument_list|(
name|tn3
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tfreeblk
argument_list|()
expr_stmt|;
block|}
name|STRUCT_ASSIGN
argument_list|(
name|curr_pos
argument_list|,
name|cpos
argument_list|)
expr_stmt|;
name|STRUCT_ASSIGN
argument_list|(
name|csrc_pos
argument_list|,
name|cspos
argument_list|)
expr_stmt|;
comment|/* An endless loop without break will never terminate */
name|reached
operator|=
name|cstk
operator|->
name|c_break
operator|||
operator|!
name|cstk
operator|->
name|c_infinite
expr_stmt|;
name|rchflg
operator|=
literal|0
expr_stmt|;
name|popctrl
argument_list|(
name|T_FOR
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * T_GOTO identifier T_SEMI  * T_GOTO error T_SEMI  */
end_comment

begin_function
name|void
name|dogoto
parameter_list|(
name|lab
parameter_list|)
name|sym_t
modifier|*
name|lab
decl_stmt|;
block|{
name|setuflg
argument_list|(
name|lab
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|chkreach
argument_list|()
expr_stmt|;
name|reached
operator|=
name|rchflg
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * T_BREAK T_SEMI  */
end_comment

begin_function
name|void
name|dobreak
parameter_list|()
block|{
name|cstk_t
modifier|*
name|ci
decl_stmt|;
name|ci
operator|=
name|cstk
expr_stmt|;
while|while
condition|(
name|ci
operator|!=
name|NULL
operator|&&
operator|!
name|ci
operator|->
name|c_loop
operator|&&
operator|!
name|ci
operator|->
name|c_switch
condition|)
name|ci
operator|=
name|ci
operator|->
name|c_nxt
expr_stmt|;
if|if
condition|(
name|ci
operator|==
name|NULL
condition|)
block|{
comment|/* break outside loop or switch */
name|error
argument_list|(
literal|208
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|reached
condition|)
name|ci
operator|->
name|c_break
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|bflag
condition|)
name|chkreach
argument_list|()
expr_stmt|;
name|reached
operator|=
name|rchflg
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * T_CONTINUE T_SEMI  */
end_comment

begin_function
name|void
name|docont
parameter_list|()
block|{
name|cstk_t
modifier|*
name|ci
decl_stmt|;
for|for
control|(
name|ci
operator|=
name|cstk
init|;
name|ci
operator|!=
name|NULL
operator|&&
operator|!
name|ci
operator|->
name|c_loop
condition|;
name|ci
operator|=
name|ci
operator|->
name|c_nxt
control|)
empty_stmt|;
if|if
condition|(
name|ci
operator|==
name|NULL
condition|)
block|{
comment|/* continue outside loop */
name|error
argument_list|(
literal|209
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ci
operator|->
name|c_cont
operator|=
literal|1
expr_stmt|;
block|}
name|chkreach
argument_list|()
expr_stmt|;
name|reached
operator|=
name|rchflg
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * T_RETURN T_SEMI  * T_RETURN expr T_SEMI  */
end_comment

begin_function
name|void
name|doreturn
parameter_list|(
name|tn
parameter_list|)
name|tnode_t
modifier|*
name|tn
decl_stmt|;
block|{
name|tnode_t
modifier|*
name|ln
decl_stmt|,
modifier|*
name|rn
decl_stmt|;
name|cstk_t
modifier|*
name|ci
decl_stmt|;
name|op_t
name|op
decl_stmt|;
for|for
control|(
name|ci
operator|=
name|cstk
init|;
name|ci
operator|->
name|c_nxt
operator|!=
name|NULL
condition|;
name|ci
operator|=
name|ci
operator|->
name|c_nxt
control|)
empty_stmt|;
if|if
condition|(
name|tn
operator|!=
name|NULL
condition|)
block|{
name|ci
operator|->
name|c_retval
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|ci
operator|->
name|c_noretval
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|tn
operator|!=
name|NULL
operator|&&
name|funcsym
operator|->
name|s_type
operator|->
name|t_subt
operator|->
name|t_tspec
operator|==
name|VOID
condition|)
block|{
comment|/* void function %s cannot return value */
name|error
argument_list|(
literal|213
argument_list|,
name|funcsym
operator|->
name|s_name
argument_list|)
expr_stmt|;
name|tfreeblk
argument_list|()
expr_stmt|;
name|tn
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tn
operator|==
name|NULL
operator|&&
name|funcsym
operator|->
name|s_type
operator|->
name|t_subt
operator|->
name|t_tspec
operator|!=
name|VOID
condition|)
block|{
comment|/* 		 * Assume that the function has a return value only if it 		 * is explicitly declared. 		 */
if|if
condition|(
operator|!
name|funcsym
operator|->
name|s_rimpl
condition|)
comment|/* function %s expects to return value */
name|warning
argument_list|(
literal|214
argument_list|,
name|funcsym
operator|->
name|s_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tn
operator|!=
name|NULL
condition|)
block|{
comment|/* Create a temporary node for the left side */
name|ln
operator|=
name|tgetblk
argument_list|(
sizeof|sizeof
argument_list|(
name|tnode_t
argument_list|)
argument_list|)
expr_stmt|;
name|ln
operator|->
name|tn_op
operator|=
name|NAME
expr_stmt|;
name|ln
operator|->
name|tn_type
operator|=
name|tduptyp
argument_list|(
name|funcsym
operator|->
name|s_type
operator|->
name|t_subt
argument_list|)
expr_stmt|;
name|ln
operator|->
name|tn_type
operator|->
name|t_const
operator|=
literal|0
expr_stmt|;
name|ln
operator|->
name|tn_lvalue
operator|=
literal|1
expr_stmt|;
name|ln
operator|->
name|tn_sym
operator|=
name|funcsym
expr_stmt|;
comment|/* better than nothing */
name|tn
operator|=
name|build
argument_list|(
name|RETURN
argument_list|,
name|ln
argument_list|,
name|tn
argument_list|)
expr_stmt|;
if|if
condition|(
name|tn
operator|!=
name|NULL
condition|)
block|{
name|rn
operator|=
name|tn
operator|->
name|tn_right
expr_stmt|;
while|while
condition|(
operator|(
name|op
operator|=
name|rn
operator|->
name|tn_op
operator|)
operator|==
name|CVT
operator|||
name|op
operator|==
name|PLUS
condition|)
name|rn
operator|=
name|rn
operator|->
name|tn_left
expr_stmt|;
if|if
condition|(
name|rn
operator|->
name|tn_op
operator|==
name|AMPER
operator|&&
name|rn
operator|->
name|tn_left
operator|->
name|tn_op
operator|==
name|NAME
operator|&&
name|rn
operator|->
name|tn_left
operator|->
name|tn_sym
operator|->
name|s_scl
operator|==
name|AUTO
condition|)
block|{
comment|/* %s returns pointer to automatic object */
name|warning
argument_list|(
literal|302
argument_list|,
name|funcsym
operator|->
name|s_name
argument_list|)
expr_stmt|;
block|}
block|}
name|expr
argument_list|(
name|tn
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|chkreach
argument_list|()
expr_stmt|;
block|}
name|reached
operator|=
name|rchflg
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Do some cleanup after a global declaration or definition.  * Especially remove informations about unused lint comments.  */
end_comment

begin_function
name|void
name|glclup
parameter_list|(
name|silent
parameter_list|)
name|int
name|silent
decl_stmt|;
block|{
name|pos_t
name|cpos
decl_stmt|;
name|STRUCT_ASSIGN
argument_list|(
name|cpos
argument_list|,
name|curr_pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|nargusg
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|silent
condition|)
block|{
name|STRUCT_ASSIGN
argument_list|(
name|curr_pos
argument_list|,
name|aupos
argument_list|)
expr_stmt|;
comment|/* must precede function definition: %s */
name|warning
argument_list|(
literal|282
argument_list|,
literal|"ARGSUSED"
argument_list|)
expr_stmt|;
block|}
name|nargusg
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|nvararg
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|silent
condition|)
block|{
name|STRUCT_ASSIGN
argument_list|(
name|curr_pos
argument_list|,
name|vapos
argument_list|)
expr_stmt|;
comment|/* must precede function definition: %s */
name|warning
argument_list|(
literal|282
argument_list|,
literal|"VARARGS"
argument_list|)
expr_stmt|;
block|}
name|nvararg
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|prflstrg
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|silent
condition|)
block|{
name|STRUCT_ASSIGN
argument_list|(
name|curr_pos
argument_list|,
name|prflpos
argument_list|)
expr_stmt|;
comment|/* must precede function definition: %s */
name|warning
argument_list|(
literal|282
argument_list|,
literal|"PRINTFLIKE"
argument_list|)
expr_stmt|;
block|}
name|prflstrg
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|scflstrg
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|silent
condition|)
block|{
name|STRUCT_ASSIGN
argument_list|(
name|curr_pos
argument_list|,
name|scflpos
argument_list|)
expr_stmt|;
comment|/* must precede function definition: %s */
name|warning
argument_list|(
literal|282
argument_list|,
literal|"SCANFLIKE"
argument_list|)
expr_stmt|;
block|}
name|scflstrg
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|STRUCT_ASSIGN
argument_list|(
name|curr_pos
argument_list|,
name|cpos
argument_list|)
expr_stmt|;
name|dcs
operator|->
name|d_asm
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ARGSUSED comment  *  * Only the first n arguments of the following function are checked  * for usage. A missing argument is taken to be 0.  */
end_comment

begin_function
name|void
name|argsused
parameter_list|(
name|n
parameter_list|)
name|int
name|n
decl_stmt|;
block|{
if|if
condition|(
name|n
operator|==
operator|-
literal|1
condition|)
name|n
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dcs
operator|->
name|d_ctx
operator|!=
name|EXTERN
condition|)
block|{
comment|/* must be outside function: ** %s ** */
name|warning
argument_list|(
literal|280
argument_list|,
literal|"ARGSUSED"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|nargusg
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* duplicate use of ** %s ** */
name|warning
argument_list|(
literal|281
argument_list|,
literal|"ARGSUSED"
argument_list|)
expr_stmt|;
block|}
name|nargusg
operator|=
name|n
expr_stmt|;
name|STRUCT_ASSIGN
argument_list|(
name|aupos
argument_list|,
name|curr_pos
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * VARARGS comment  *  * Makes that lint2 checks only the first n arguments for compatibility  * to the function definition. A missing argument is taken to be 0.  */
end_comment

begin_function
name|void
name|varargs
parameter_list|(
name|n
parameter_list|)
name|int
name|n
decl_stmt|;
block|{
if|if
condition|(
name|n
operator|==
operator|-
literal|1
condition|)
name|n
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dcs
operator|->
name|d_ctx
operator|!=
name|EXTERN
condition|)
block|{
comment|/* must be outside function: ** %s ** */
name|warning
argument_list|(
literal|280
argument_list|,
literal|"VARARGS"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|nvararg
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* duplicate use of  ** %s ** */
name|warning
argument_list|(
literal|281
argument_list|,
literal|"VARARGS"
argument_list|)
expr_stmt|;
block|}
name|nvararg
operator|=
name|n
expr_stmt|;
name|STRUCT_ASSIGN
argument_list|(
name|vapos
argument_list|,
name|curr_pos
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * PRINTFLIKE comment  *  * Check all arguments until the (n-1)-th as usual. The n-th argument is  * used the check the types of remaining arguments.  */
end_comment

begin_function
name|void
name|printflike
parameter_list|(
name|n
parameter_list|)
name|int
name|n
decl_stmt|;
block|{
if|if
condition|(
name|n
operator|==
operator|-
literal|1
condition|)
name|n
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dcs
operator|->
name|d_ctx
operator|!=
name|EXTERN
condition|)
block|{
comment|/* must be outside function: ** %s ** */
name|warning
argument_list|(
literal|280
argument_list|,
literal|"PRINTFLIKE"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|prflstrg
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* duplicate use of ** %s ** */
name|warning
argument_list|(
literal|281
argument_list|,
literal|"PRINTFLIKE"
argument_list|)
expr_stmt|;
block|}
name|prflstrg
operator|=
name|n
expr_stmt|;
name|STRUCT_ASSIGN
argument_list|(
name|prflpos
argument_list|,
name|curr_pos
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * SCANFLIKE comment  *  * Check all arguments until the (n-1)-th as usual. The n-th argument is  * used the check the types of remaining arguments.  */
end_comment

begin_function
name|void
name|scanflike
parameter_list|(
name|n
parameter_list|)
name|int
name|n
decl_stmt|;
block|{
if|if
condition|(
name|n
operator|==
operator|-
literal|1
condition|)
name|n
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dcs
operator|->
name|d_ctx
operator|!=
name|EXTERN
condition|)
block|{
comment|/* must be outside function: ** %s ** */
name|warning
argument_list|(
literal|280
argument_list|,
literal|"SCANFLIKE"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|scflstrg
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* duplicate use of ** %s ** */
name|warning
argument_list|(
literal|281
argument_list|,
literal|"SCANFLIKE"
argument_list|)
expr_stmt|;
block|}
name|scflstrg
operator|=
name|n
expr_stmt|;
name|STRUCT_ASSIGN
argument_list|(
name|scflpos
argument_list|,
name|curr_pos
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set the linenumber for a CONSTCOND comment. At this and the following  * line no warnings about constants in conditional contexts are printed.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|void
name|constcond
parameter_list|(
name|n
parameter_list|)
name|int
name|n
decl_stmt|;
block|{
name|ccflg
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Suppress printing of "fallthrough on ..." warnings until next  * statement.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|void
name|fallthru
parameter_list|(
name|n
parameter_list|)
name|int
name|n
decl_stmt|;
block|{
name|ftflg
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Stop warnings about statements which cannot be reached. Also tells lint  * that the following statements cannot be reached (e.g. after exit()).  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|void
name|notreach
parameter_list|(
name|n
parameter_list|)
name|int
name|n
decl_stmt|;
block|{
name|reached
operator|=
literal|0
expr_stmt|;
name|rchflg
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|void
name|lintlib
parameter_list|(
name|n
parameter_list|)
name|int
name|n
decl_stmt|;
block|{
if|if
condition|(
name|dcs
operator|->
name|d_ctx
operator|!=
name|EXTERN
condition|)
block|{
comment|/* must be outside function: ** %s ** */
name|warning
argument_list|(
literal|280
argument_list|,
literal|"LINTLIBRARY"
argument_list|)
expr_stmt|;
return|return;
block|}
name|llibflg
operator|=
literal|1
expr_stmt|;
name|vflag
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Suppress most warnings at the current and the following line.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|void
name|linted
parameter_list|(
name|n
parameter_list|)
name|int
name|n
decl_stmt|;
block|{
name|nowarn
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * PROTOTLIB in conjunction with LINTLIBRARY can be used to handle  * prototypes like function definitions. This is done if the argument  * to PROTOLIB is nonzero. Otherwise prototypes are handled normaly.  */
end_comment

begin_function
name|void
name|protolib
parameter_list|(
name|n
parameter_list|)
name|int
name|n
decl_stmt|;
block|{
if|if
condition|(
name|dcs
operator|->
name|d_ctx
operator|!=
name|EXTERN
condition|)
block|{
comment|/* must be outside function: ** %s ** */
name|warning
argument_list|(
literal|280
argument_list|,
literal|"PROTOLIB"
argument_list|)
expr_stmt|;
return|return;
block|}
name|plibflg
operator|=
name|n
operator|==
literal|0
condition|?
literal|0
else|:
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set quadflg to nonzero which means that the next statement/declaration  * may use "long long" without an error or warning.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|void
name|longlong
parameter_list|(
name|n
parameter_list|)
name|int
name|n
decl_stmt|;
block|{
name|quadflg
operator|=
literal|1
expr_stmt|;
block|}
end_function

end_unit

