begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: fetch.c,v 1.16.2.1 1997/11/18 01:00:22 mellon Exp $	*/
end_comment

begin_comment
comment|/*-  * Copyright (c) 1997 The NetBSD Foundation, Inc.  * All rights reserved.  *  * This code is derived from software contributed to The NetBSD Foundation  * by Jason Thorpe and Luke Mewburn.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *        This product includes software developed by the NetBSD  *        Foundation, Inc. and its contributors.  * 4. Neither the name of The NetBSD Foundation nor the names of its  *    contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED  * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_expr_stmt
name|__RCSID
argument_list|(
literal|"$Id: fetch.c,v 1.5 1997/12/16 08:58:15 ache Exp $"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|__RCSID_SOURCE
argument_list|(
literal|"$NetBSD: fetch.c,v 1.16.2.1 1997/11/18 01:00:22 mellon Exp $"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/*  * FTP User Program -- Command line file retrieval  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<arpa/ftp.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"ftp_var.h"
end_include

begin_decl_stmt
specifier|static
name|int
name|url_get
name|__P
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|aborthttp
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|FTP_URL
value|"ftp://"
end_define

begin_comment
comment|/* ftp URL prefix */
end_comment

begin_define
define|#
directive|define
name|HTTP_URL
value|"http://"
end_define

begin_comment
comment|/* http URL prefix */
end_comment

begin_define
define|#
directive|define
name|FTP_PROXY
value|"ftp_proxy"
end_define

begin_comment
comment|/* env var with ftp proxy location */
end_comment

begin_define
define|#
directive|define
name|HTTP_PROXY
value|"http_proxy"
end_define

begin_comment
comment|/* env var with http proxy location */
end_comment

begin_define
define|#
directive|define
name|EMPTYSTRING
parameter_list|(
name|x
parameter_list|)
value|((x) == NULL || (*(x) == '\0'))
end_define

begin_decl_stmt
name|jmp_buf
name|httpabort
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Retrieve URL, via the proxy in $proxyvar if necessary.  * Modifies the string argument given.  * Returns -1 on failure, 0 on success  */
end_comment

begin_function
specifier|static
name|int
name|url_get
parameter_list|(
name|origline
parameter_list|,
name|proxyenv
parameter_list|)
specifier|const
name|char
modifier|*
name|origline
decl_stmt|;
specifier|const
name|char
modifier|*
name|proxyenv
decl_stmt|;
block|{
name|struct
name|sockaddr_in
name|sin
decl_stmt|;
name|int
name|i
decl_stmt|,
name|out
decl_stmt|,
name|isftpurl
decl_stmt|;
name|u_int16_t
name|port
decl_stmt|;
specifier|volatile
name|int
name|s
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|char
name|c
decl_stmt|,
modifier|*
name|cp
decl_stmt|,
modifier|*
name|ep
decl_stmt|,
modifier|*
name|portnum
decl_stmt|,
modifier|*
name|path
decl_stmt|,
name|buf
index|[
literal|4096
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|savefile
decl_stmt|;
name|char
modifier|*
name|line
decl_stmt|,
modifier|*
name|proxy
decl_stmt|,
modifier|*
name|host
decl_stmt|;
specifier|volatile
name|sig_t
name|oldintr
decl_stmt|;
name|off_t
name|hashbytes
decl_stmt|;
name|s
operator|=
operator|-
literal|1
expr_stmt|;
name|proxy
operator|=
name|NULL
expr_stmt|;
name|isftpurl
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|__GNUC__
comment|/* XXX: to shut up gcc warnings */
operator|(
name|void
operator|)
operator|&
name|savefile
expr_stmt|;
operator|(
name|void
operator|)
operator|&
name|proxy
expr_stmt|;
endif|#
directive|endif
name|line
operator|=
name|strdup
argument_list|(
name|origline
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Can't allocate memory to parse URL"
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncasecmp
argument_list|(
name|line
argument_list|,
name|HTTP_URL
argument_list|,
sizeof|sizeof
argument_list|(
name|HTTP_URL
argument_list|)
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
name|host
operator|=
name|line
operator|+
sizeof|sizeof
argument_list|(
name|HTTP_URL
argument_list|)
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strncasecmp
argument_list|(
name|line
argument_list|,
name|FTP_URL
argument_list|,
sizeof|sizeof
argument_list|(
name|FTP_URL
argument_list|)
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|host
operator|=
name|line
operator|+
sizeof|sizeof
argument_list|(
name|FTP_URL
argument_list|)
operator|-
literal|1
expr_stmt|;
name|isftpurl
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|errx
argument_list|(
literal|1
argument_list|,
literal|"url_get: Invalid URL '%s'"
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|path
operator|=
name|strchr
argument_list|(
name|host
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
comment|/* find path */
if|if
condition|(
name|EMPTYSTRING
argument_list|(
name|path
argument_list|)
condition|)
block|{
if|if
condition|(
name|isftpurl
condition|)
goto|goto
name|noftpautologin
goto|;
name|warnx
argument_list|(
literal|"Invalid URL (no `/' after host): %s"
argument_list|,
name|origline
argument_list|)
expr_stmt|;
goto|goto
name|cleanup_url_get
goto|;
block|}
operator|*
name|path
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|EMPTYSTRING
argument_list|(
name|path
argument_list|)
condition|)
block|{
if|if
condition|(
name|isftpurl
condition|)
goto|goto
name|noftpautologin
goto|;
name|warnx
argument_list|(
literal|"Invalid URL (no file after host): %s"
argument_list|,
name|origline
argument_list|)
expr_stmt|;
goto|goto
name|cleanup_url_get
goto|;
block|}
name|savefile
operator|=
name|strrchr
argument_list|(
name|path
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
comment|/* find savefile */
if|if
condition|(
name|savefile
operator|!=
name|NULL
condition|)
name|savefile
operator|++
expr_stmt|;
else|else
name|savefile
operator|=
name|path
expr_stmt|;
if|if
condition|(
name|EMPTYSTRING
argument_list|(
name|savefile
argument_list|)
condition|)
block|{
if|if
condition|(
name|isftpurl
condition|)
goto|goto
name|noftpautologin
goto|;
name|warnx
argument_list|(
literal|"Invalid URL (no file after directory): %s"
argument_list|,
name|origline
argument_list|)
expr_stmt|;
goto|goto
name|cleanup_url_get
goto|;
block|}
if|if
condition|(
name|proxyenv
operator|!=
name|NULL
condition|)
block|{
comment|/* use proxy */
name|proxy
operator|=
name|strdup
argument_list|(
name|proxyenv
argument_list|)
expr_stmt|;
if|if
condition|(
name|proxy
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Can't allocate memory for proxy URL."
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncasecmp
argument_list|(
name|proxy
argument_list|,
name|HTTP_URL
argument_list|,
sizeof|sizeof
argument_list|(
name|HTTP_URL
argument_list|)
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
name|host
operator|=
name|proxy
operator|+
sizeof|sizeof
argument_list|(
name|HTTP_URL
argument_list|)
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strncasecmp
argument_list|(
name|proxy
argument_list|,
name|FTP_URL
argument_list|,
sizeof|sizeof
argument_list|(
name|FTP_URL
argument_list|)
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
name|host
operator|=
name|proxy
operator|+
sizeof|sizeof
argument_list|(
name|FTP_URL
argument_list|)
operator|-
literal|1
expr_stmt|;
else|else
block|{
name|warnx
argument_list|(
literal|"Malformed proxy URL: %s"
argument_list|,
name|proxyenv
argument_list|)
expr_stmt|;
goto|goto
name|cleanup_url_get
goto|;
block|}
if|if
condition|(
name|EMPTYSTRING
argument_list|(
name|host
argument_list|)
condition|)
block|{
name|warnx
argument_list|(
literal|"Malformed proxy URL: %s"
argument_list|,
name|proxyenv
argument_list|)
expr_stmt|;
goto|goto
name|cleanup_url_get
goto|;
block|}
operator|*
operator|--
name|path
operator|=
literal|'/'
expr_stmt|;
comment|/* add / back to real path */
name|path
operator|=
name|strchr
argument_list|(
name|host
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
comment|/* remove trailing / on host */
if|if
condition|(
operator|!
name|EMPTYSTRING
argument_list|(
name|path
argument_list|)
condition|)
operator|*
name|path
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|path
operator|=
name|line
expr_stmt|;
block|}
name|portnum
operator|=
name|strchr
argument_list|(
name|host
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
comment|/* find portnum */
if|if
condition|(
name|portnum
operator|!=
name|NULL
condition|)
operator|*
name|portnum
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"host %s, port %s, path %s, save as %s.\n"
argument_list|,
name|host
argument_list|,
name|portnum
argument_list|,
name|path
argument_list|,
name|savefile
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|sin
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sin
argument_list|)
argument_list|)
expr_stmt|;
name|sin
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|host
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|inet_aton
argument_list|(
name|host
argument_list|,
operator|&
name|sin
operator|.
name|sin_addr
argument_list|)
operator|==
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"Invalid IP address: %s"
argument_list|,
name|host
argument_list|)
expr_stmt|;
goto|goto
name|cleanup_url_get
goto|;
block|}
block|}
else|else
block|{
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
name|hp
operator|=
name|gethostbyname
argument_list|(
name|host
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: %s"
argument_list|,
name|host
argument_list|,
name|hstrerror
argument_list|(
name|h_errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|cleanup_url_get
goto|;
block|}
if|if
condition|(
name|hp
operator|->
name|h_addrtype
operator|!=
name|AF_INET
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: not an Internet address?"
argument_list|,
name|host
argument_list|)
expr_stmt|;
goto|goto
name|cleanup_url_get
goto|;
block|}
name|memcpy
argument_list|(
operator|&
name|sin
operator|.
name|sin_addr
argument_list|,
name|hp
operator|->
name|h_addr
argument_list|,
name|hp
operator|->
name|h_length
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|EMPTYSTRING
argument_list|(
name|portnum
argument_list|)
condition|)
block|{
name|char
modifier|*
name|ep
decl_stmt|;
name|long
name|nport
decl_stmt|;
name|nport
operator|=
name|strtol
argument_list|(
name|portnum
argument_list|,
operator|&
name|ep
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|nport
operator|<
literal|1
operator|||
name|nport
operator|>
literal|0xffff
operator|||
operator|*
name|ep
operator|!=
literal|'\0'
condition|)
block|{
name|warnx
argument_list|(
literal|"Invalid port: %s"
argument_list|,
name|portnum
argument_list|)
expr_stmt|;
goto|goto
name|cleanup_url_get
goto|;
block|}
name|port
operator|=
name|htons
argument_list|(
name|nport
argument_list|)
expr_stmt|;
block|}
else|else
name|port
operator|=
name|httpport
expr_stmt|;
name|sin
operator|.
name|sin_port
operator|=
name|port
expr_stmt|;
name|s
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
operator|-
literal|1
condition|)
block|{
name|warn
argument_list|(
literal|"Can't create socket"
argument_list|)
expr_stmt|;
goto|goto
name|cleanup_url_get
goto|;
block|}
if|if
condition|(
name|dobind
operator|&&
name|bind
argument_list|(
name|s
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|bindto
argument_list|,
sizeof|sizeof
argument_list|(
name|bindto
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|warn
argument_list|(
literal|"Can't bind to %s"
argument_list|,
name|inet_ntoa
argument_list|(
name|bindto
operator|.
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|cleanup_url_get
goto|;
block|}
if|if
condition|(
name|connect
argument_list|(
name|s
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin
argument_list|,
sizeof|sizeof
argument_list|(
name|sin
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|warn
argument_list|(
literal|"Can't connect to %s"
argument_list|,
name|host
argument_list|)
expr_stmt|;
goto|goto
name|cleanup_url_get
goto|;
block|}
comment|/* 	 * Construct and send the request.  We're expecting a return 	 * status of "200". Proxy requests don't want leading /. 	 */
if|if
condition|(
operator|!
name|proxy
condition|)
name|printf
argument_list|(
literal|"Requesting %s\n"
argument_list|,
name|origline
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"Requesting %s (via %s)\n"
argument_list|,
name|origline
argument_list|,
name|proxyenv
argument_list|)
expr_stmt|;
name|len
operator|=
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"GET %s%s HTTP/1.0\r\n\r\n"
argument_list|,
name|proxy
condition|?
literal|""
else|:
literal|"/"
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|s
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
operator|<
name|len
condition|)
block|{
name|warn
argument_list|(
literal|"Writing HTTP request"
argument_list|)
expr_stmt|;
goto|goto
name|cleanup_url_get
goto|;
block|}
name|memset
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|buf
init|;
name|cp
operator|<
name|buf
operator|+
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
condition|;
control|)
block|{
if|if
condition|(
name|read
argument_list|(
name|s
argument_list|,
name|cp
argument_list|,
literal|1
argument_list|)
operator|!=
literal|1
condition|)
goto|goto
name|improper
goto|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\r'
condition|)
continue|continue;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\n'
condition|)
break|break;
name|cp
operator|++
expr_stmt|;
block|}
name|buf
index|[
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* sanity */
name|cp
operator|=
name|strchr
argument_list|(
name|buf
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
goto|goto
name|improper
goto|;
else|else
name|cp
operator|++
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|cp
argument_list|,
literal|"200"
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|warnx
argument_list|(
literal|"Error retrieving file: %s"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
goto|goto
name|cleanup_url_get
goto|;
block|}
comment|/* 	 * Read the rest of the header. 	 */
name|memset
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|buf
init|;
name|cp
operator|<
name|buf
operator|+
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
condition|;
control|)
block|{
if|if
condition|(
name|read
argument_list|(
name|s
argument_list|,
name|cp
argument_list|,
literal|1
argument_list|)
operator|!=
literal|1
condition|)
goto|goto
name|improper
goto|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\r'
condition|)
continue|continue;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\n'
operator|&&
name|c
operator|==
literal|'\n'
condition|)
break|break;
name|c
operator|=
operator|*
name|cp
expr_stmt|;
name|cp
operator|++
expr_stmt|;
block|}
name|buf
index|[
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* sanity */
comment|/* 	 * Look for the "Content-length: " header. 	 */
define|#
directive|define
name|CONTENTLEN
value|"Content-Length: "
for|for
control|(
name|cp
operator|=
name|buf
init|;
operator|*
name|cp
operator|!=
literal|'\0'
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
name|tolower
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cp
argument_list|)
operator|==
literal|'c'
operator|&&
name|strncasecmp
argument_list|(
name|cp
argument_list|,
name|CONTENTLEN
argument_list|,
sizeof|sizeof
argument_list|(
name|CONTENTLEN
argument_list|)
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
block|{
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|CONTENTLEN
argument_list|)
operator|-
literal|1
expr_stmt|;
name|ep
operator|=
name|strchr
argument_list|(
name|cp
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|==
name|NULL
condition|)
goto|goto
name|improper
goto|;
else|else
operator|*
name|ep
operator|=
literal|'\0'
expr_stmt|;
name|filesize
operator|=
name|strtol
argument_list|(
name|cp
argument_list|,
operator|&
name|ep
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|filesize
operator|<
literal|1
operator|||
operator|*
name|ep
operator|!=
literal|'\0'
condition|)
goto|goto
name|improper
goto|;
block|}
else|else
name|filesize
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Open the output file. */
name|out
operator|=
name|open
argument_list|(
name|savefile
argument_list|,
name|O_CREAT
operator||
name|O_WRONLY
operator||
name|O_TRUNC
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
if|if
condition|(
name|out
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"Can't open %s"
argument_list|,
name|savefile
argument_list|)
expr_stmt|;
goto|goto
name|cleanup_url_get
goto|;
block|}
comment|/* Trap signals */
name|oldintr
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|httpabort
argument_list|)
condition|)
block|{
if|if
condition|(
name|oldintr
condition|)
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|oldintr
argument_list|)
expr_stmt|;
goto|goto
name|cleanup_url_get
goto|;
block|}
name|oldintr
operator|=
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|aborthttp
argument_list|)
expr_stmt|;
name|bytes
operator|=
literal|0
expr_stmt|;
name|hashbytes
operator|=
name|mark
expr_stmt|;
name|progressmeter
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Finally, suck down the file. */
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|len
operator|=
name|read
argument_list|(
name|s
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|bytes
operator|+=
name|len
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|buf
init|;
name|len
operator|>
literal|0
condition|;
name|len
operator|-=
name|i
operator|,
name|cp
operator|+=
name|i
control|)
block|{
if|if
condition|(
operator|(
name|i
operator|=
name|write
argument_list|(
name|out
argument_list|,
name|cp
argument_list|,
name|len
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|warn
argument_list|(
literal|"Writing %s"
argument_list|,
name|savefile
argument_list|)
expr_stmt|;
goto|goto
name|cleanup_url_get
goto|;
block|}
elseif|else
if|if
condition|(
name|i
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|hash
operator|&&
operator|!
name|progress
condition|)
block|{
while|while
condition|(
name|bytes
operator|>=
name|hashbytes
condition|)
block|{
operator|(
name|void
operator|)
name|putchar
argument_list|(
literal|'#'
argument_list|)
expr_stmt|;
name|hashbytes
operator|+=
name|mark
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|hash
operator|&&
operator|!
name|progress
operator|&&
name|bytes
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|bytes
operator|<
name|mark
condition|)
operator|(
name|void
operator|)
name|putchar
argument_list|(
literal|'#'
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|!=
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"Reading from socket"
argument_list|)
expr_stmt|;
goto|goto
name|cleanup_url_get
goto|;
block|}
name|progressmeter
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|puts
argument_list|(
literal|"Successfully retrieved file."
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|oldintr
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|out
argument_list|)
expr_stmt|;
if|if
condition|(
name|proxy
condition|)
name|free
argument_list|(
name|proxy
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|noftpautologin
label|:
name|warnx
argument_list|(
literal|"Auto-login using ftp URLs isn't supported when using $ftp_proxy"
argument_list|)
expr_stmt|;
goto|goto
name|cleanup_url_get
goto|;
name|improper
label|:
name|warnx
argument_list|(
literal|"Improper response from %s"
argument_list|,
name|host
argument_list|)
expr_stmt|;
name|cleanup_url_get
label|:
if|if
condition|(
name|s
operator|!=
operator|-
literal|1
condition|)
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|proxy
condition|)
name|free
argument_list|(
name|proxy
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Abort a http retrieval  */
end_comment

begin_function
name|void
name|aborthttp
parameter_list|(
name|notused
parameter_list|)
name|int
name|notused
decl_stmt|;
block|{
name|alarmtimer
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"\nhttp fetch aborted."
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|httpabort
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Retrieve multiple files from the command line, transferring  * files of the form "host:path", "ftp://host/path" using the  * ftp protocol, and files of the form "http://host/path" using  * the http protocol.  * If path has a trailing "/", then return (-1);  * the path will be cd-ed into and the connection remains open,  * and the function will return -1 (to indicate the connection  * is alive).  * If an error occurs the return value will be the offset+1 in  * argv[] of the file that caused a problem (i.e, argv[x]  * returns x+1)  * Otherwise, 0 is returned if all files retrieved successfully.  */
end_comment

begin_function
name|int
name|auto_fetch
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
specifier|static
name|char
name|lasthost
index|[
name|MAXHOSTNAMELEN
index|]
decl_stmt|;
name|char
modifier|*
name|xargv
index|[
literal|5
index|]
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|line
decl_stmt|,
modifier|*
name|host
decl_stmt|,
modifier|*
name|dir
decl_stmt|,
modifier|*
name|file
decl_stmt|,
modifier|*
name|portnum
decl_stmt|;
name|char
modifier|*
name|user
decl_stmt|,
modifier|*
name|pass
decl_stmt|;
name|char
modifier|*
name|ftpproxy
decl_stmt|,
modifier|*
name|httpproxy
decl_stmt|;
name|int
name|rval
decl_stmt|,
name|xargc
decl_stmt|;
specifier|volatile
name|int
name|argpos
decl_stmt|;
name|int
name|dirhasglob
decl_stmt|,
name|filehasglob
decl_stmt|;
name|char
name|rempath
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|argpos
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|toplevel
argument_list|)
condition|)
block|{
if|if
condition|(
name|connected
condition|)
name|disconnect
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|argpos
operator|+
literal|1
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
operator|(
name|sig_t
operator|)
name|intr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
operator|(
name|sig_t
operator|)
name|lostpeer
argument_list|)
expr_stmt|;
name|ftpproxy
operator|=
name|getenv
argument_list|(
name|FTP_PROXY
argument_list|)
expr_stmt|;
name|httpproxy
operator|=
name|getenv
argument_list|(
name|HTTP_PROXY
argument_list|)
expr_stmt|;
comment|/* 	 * Loop through as long as there's files to fetch. 	 */
for|for
control|(
name|rval
operator|=
literal|0
init|;
operator|(
name|rval
operator|==
literal|0
operator|)
operator|&&
operator|(
name|argpos
operator|<
name|argc
operator|)
condition|;
name|free
argument_list|(
name|line
argument_list|)
operator|,
name|argpos
operator|++
control|)
block|{
if|if
condition|(
name|strchr
argument_list|(
name|argv
index|[
name|argpos
index|]
argument_list|,
literal|':'
argument_list|)
operator|==
name|NULL
condition|)
break|break;
name|host
operator|=
name|dir
operator|=
name|file
operator|=
name|portnum
operator|=
name|user
operator|=
name|pass
operator|=
name|NULL
expr_stmt|;
comment|/* 		 * We muck with the string, so we make a copy. 		 */
name|line
operator|=
name|strdup
argument_list|(
name|argv
index|[
name|argpos
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Can't allocate memory for auto-fetch."
argument_list|)
expr_stmt|;
comment|/* 		 * Try HTTP URL-style arguments first. 		 */
if|if
condition|(
name|strncasecmp
argument_list|(
name|line
argument_list|,
name|HTTP_URL
argument_list|,
sizeof|sizeof
argument_list|(
name|HTTP_URL
argument_list|)
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|url_get
argument_list|(
name|line
argument_list|,
name|httpproxy
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|rval
operator|=
name|argpos
operator|+
literal|1
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Try FTP URL-style arguments next. If ftpproxy is 		 * set, use url_get() instead of standard ftp. 		 * Finally, try host:file. 		 */
name|host
operator|=
name|line
expr_stmt|;
if|if
condition|(
name|strncasecmp
argument_list|(
name|line
argument_list|,
name|FTP_URL
argument_list|,
sizeof|sizeof
argument_list|(
name|FTP_URL
argument_list|)
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ftpproxy
condition|)
block|{
if|if
condition|(
name|url_get
argument_list|(
name|line
argument_list|,
name|ftpproxy
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|rval
operator|=
name|argpos
operator|+
literal|1
expr_stmt|;
continue|continue;
block|}
name|host
operator|+=
sizeof|sizeof
argument_list|(
name|FTP_URL
argument_list|)
operator|-
literal|1
expr_stmt|;
name|dir
operator|=
name|strchr
argument_list|(
name|host
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
comment|/* look for [user:pass@]host[:port] */
name|pass
operator|=
name|strpbrk
argument_list|(
name|host
argument_list|,
literal|":@/"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pass
operator|==
name|NULL
operator|||
operator|*
name|pass
operator|==
literal|'/'
condition|)
block|{
name|pass
operator|=
name|NULL
expr_stmt|;
goto|goto
name|parsed_url
goto|;
block|}
if|if
condition|(
name|pass
operator|==
name|host
operator|||
operator|*
name|pass
operator|==
literal|'@'
condition|)
block|{
name|bad_ftp_url
label|:
name|warnx
argument_list|(
literal|"Invalid URL: %s"
argument_list|,
name|argv
index|[
name|argpos
index|]
argument_list|)
expr_stmt|;
name|rval
operator|=
name|argpos
operator|+
literal|1
expr_stmt|;
continue|continue;
block|}
operator|*
name|pass
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|cp
operator|=
name|strpbrk
argument_list|(
name|pass
argument_list|,
literal|":@/"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
operator|||
operator|*
name|cp
operator|==
literal|'/'
condition|)
block|{
name|portnum
operator|=
name|pass
expr_stmt|;
name|pass
operator|=
name|NULL
expr_stmt|;
goto|goto
name|parsed_url
goto|;
block|}
if|if
condition|(
name|EMPTYSTRING
argument_list|(
name|cp
argument_list|)
operator|||
operator|*
name|cp
operator|==
literal|':'
condition|)
goto|goto
name|bad_ftp_url
goto|;
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|user
operator|=
name|host
expr_stmt|;
if|if
condition|(
name|EMPTYSTRING
argument_list|(
name|user
argument_list|)
condition|)
goto|goto
name|bad_ftp_url
goto|;
name|host
operator|=
name|cp
expr_stmt|;
name|portnum
operator|=
name|strchr
argument_list|(
name|host
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|portnum
operator|!=
name|NULL
condition|)
operator|*
name|portnum
operator|++
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
comment|/* classic style `host:file' */
name|dir
operator|=
name|strchr
argument_list|(
name|host
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
block|}
name|parsed_url
label|:
if|if
condition|(
name|EMPTYSTRING
argument_list|(
name|host
argument_list|)
condition|)
block|{
name|rval
operator|=
name|argpos
operator|+
literal|1
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * If dir is NULL, the file wasn't specified 		 * (URL looked something like ftp://host) 		 */
if|if
condition|(
name|dir
operator|!=
name|NULL
condition|)
operator|*
name|dir
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* 		 * Extract the file and (if present) directory name. 		 */
if|if
condition|(
operator|!
name|EMPTYSTRING
argument_list|(
name|dir
argument_list|)
condition|)
block|{
name|cp
operator|=
name|strrchr
argument_list|(
name|dir
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
block|{
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|file
operator|=
name|cp
expr_stmt|;
block|}
else|else
block|{
name|file
operator|=
name|dir
expr_stmt|;
name|dir
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"user %s:%s host %s port %s dir %s file %s\n"
argument_list|,
name|user
argument_list|,
name|pass
argument_list|,
name|host
argument_list|,
name|portnum
argument_list|,
name|dir
argument_list|,
name|file
argument_list|)
expr_stmt|;
comment|/* 		 * Set up the connection if we don't have one. 		 */
if|if
condition|(
name|strcmp
argument_list|(
name|host
argument_list|,
name|lasthost
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|int
name|oautologin
decl_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|lasthost
argument_list|,
name|host
argument_list|)
expr_stmt|;
if|if
condition|(
name|connected
condition|)
name|disconnect
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|xargv
index|[
literal|0
index|]
operator|=
name|__progname
expr_stmt|;
name|xargv
index|[
literal|1
index|]
operator|=
name|host
expr_stmt|;
name|xargv
index|[
literal|2
index|]
operator|=
name|NULL
expr_stmt|;
name|xargc
operator|=
literal|2
expr_stmt|;
if|if
condition|(
operator|!
name|EMPTYSTRING
argument_list|(
name|portnum
argument_list|)
condition|)
block|{
name|xargv
index|[
literal|2
index|]
operator|=
name|portnum
expr_stmt|;
name|xargv
index|[
literal|3
index|]
operator|=
name|NULL
expr_stmt|;
name|xargc
operator|=
literal|3
expr_stmt|;
block|}
name|oautologin
operator|=
name|autologin
expr_stmt|;
if|if
condition|(
name|user
operator|!=
name|NULL
condition|)
name|autologin
operator|=
literal|0
expr_stmt|;
name|setpeer
argument_list|(
name|xargc
argument_list|,
name|xargv
argument_list|)
expr_stmt|;
name|autologin
operator|=
name|oautologin
expr_stmt|;
if|if
condition|(
operator|(
name|connected
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|connected
operator|==
literal|1
operator|)
operator|&&
operator|!
name|login
argument_list|(
name|host
argument_list|,
name|user
argument_list|,
name|pass
argument_list|)
operator|)
condition|)
block|{
name|warnx
argument_list|(
literal|"Can't connect or login to host `%s'"
argument_list|,
name|host
argument_list|)
expr_stmt|;
name|rval
operator|=
name|argpos
operator|+
literal|1
expr_stmt|;
continue|continue;
block|}
comment|/* Always use binary transfers. */
name|setbinary
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* cd back to '/' */
name|xargv
index|[
literal|0
index|]
operator|=
literal|"cd"
expr_stmt|;
name|xargv
index|[
literal|1
index|]
operator|=
literal|"/"
expr_stmt|;
name|xargv
index|[
literal|2
index|]
operator|=
name|NULL
expr_stmt|;
name|cd
argument_list|(
literal|2
argument_list|,
name|xargv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dirchange
condition|)
block|{
name|rval
operator|=
name|argpos
operator|+
literal|1
expr_stmt|;
continue|continue;
block|}
name|dirhasglob
operator|=
name|filehasglob
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|doglob
condition|)
block|{
if|if
condition|(
operator|!
name|EMPTYSTRING
argument_list|(
name|dir
argument_list|)
operator|&&
name|strpbrk
argument_list|(
name|dir
argument_list|,
literal|"*?[]{}"
argument_list|)
operator|!=
name|NULL
condition|)
name|dirhasglob
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|EMPTYSTRING
argument_list|(
name|file
argument_list|)
operator|&&
name|strpbrk
argument_list|(
name|file
argument_list|,
literal|"*?[]{}"
argument_list|)
operator|!=
name|NULL
condition|)
name|filehasglob
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Change directories, if necessary. */
if|if
condition|(
operator|!
name|EMPTYSTRING
argument_list|(
name|dir
argument_list|)
operator|&&
operator|!
name|dirhasglob
condition|)
block|{
name|xargv
index|[
literal|0
index|]
operator|=
literal|"cd"
expr_stmt|;
name|xargv
index|[
literal|1
index|]
operator|=
name|dir
expr_stmt|;
name|xargv
index|[
literal|2
index|]
operator|=
name|NULL
expr_stmt|;
name|cd
argument_list|(
literal|2
argument_list|,
name|xargv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dirchange
condition|)
block|{
name|rval
operator|=
name|argpos
operator|+
literal|1
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|EMPTYSTRING
argument_list|(
name|file
argument_list|)
condition|)
block|{
name|rval
operator|=
operator|-
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|verbose
condition|)
name|printf
argument_list|(
literal|"Retrieving %s/%s\n"
argument_list|,
name|dir
condition|?
name|dir
else|:
literal|""
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|dirhasglob
condition|)
block|{
name|snprintf
argument_list|(
name|rempath
argument_list|,
sizeof|sizeof
argument_list|(
name|rempath
argument_list|)
argument_list|,
literal|"%s/%s"
argument_list|,
name|dir
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|file
operator|=
name|rempath
expr_stmt|;
block|}
comment|/* Fetch the file(s). */
name|xargv
index|[
literal|0
index|]
operator|=
literal|"get"
expr_stmt|;
name|xargv
index|[
literal|1
index|]
operator|=
name|file
expr_stmt|;
name|xargv
index|[
literal|2
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|dirhasglob
operator|||
name|filehasglob
condition|)
block|{
name|int
name|ointeractive
decl_stmt|;
name|ointeractive
operator|=
name|interactive
expr_stmt|;
name|interactive
operator|=
literal|0
expr_stmt|;
name|xargv
index|[
literal|0
index|]
operator|=
literal|"mget"
expr_stmt|;
name|mget
argument_list|(
literal|2
argument_list|,
name|xargv
argument_list|)
expr_stmt|;
name|interactive
operator|=
name|ointeractive
expr_stmt|;
block|}
else|else
name|get
argument_list|(
literal|2
argument_list|,
name|xargv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|code
operator|/
literal|100
operator|)
operator|!=
name|COMPLETE
condition|)
name|rval
operator|=
name|argpos
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|connected
operator|&&
name|rval
operator|!=
operator|-
literal|1
condition|)
name|disconnect
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|rval
operator|)
return|;
block|}
end_function

end_unit

