begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $FreeBSD$	*/
end_comment

begin_comment
comment|/*	$NetBSD: util.c,v 1.16.2.1 1997/11/18 01:02:33 mellon Exp $	*/
end_comment

begin_comment
comment|/*  * Copyright (c) 1985, 1989, 1993, 1994  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_expr_stmt
name|__RCSID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|__RCSID_SOURCE
argument_list|(
literal|"$NetBSD: util.c,v 1.16.2.1 1997/11/18 01:02:33 mellon Exp $"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/*  * FTP User Program -- Misc support routines  */
end_comment

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<arpa/ftp.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<glob.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"ftp_var.h"
end_include

begin_include
include|#
directive|include
file|"pathnames.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|SECSPERHOUR
end_ifndef

begin_define
define|#
directive|define
name|SECSPERHOUR
value|(60*60)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Connect to peer server and  * auto-login, if possible.  */
end_comment

begin_function
name|void
name|setpeer
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|char
modifier|*
name|host
decl_stmt|;
name|char
modifier|*
name|port
decl_stmt|;
if|if
condition|(
name|connected
condition|)
block|{
name|printf
argument_list|(
literal|"Already connected to %s, use close first.\n"
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
name|code
operator|=
operator|-
literal|1
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
operator|(
name|void
operator|)
name|another
argument_list|(
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|,
literal|"to"
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|<
literal|2
operator|||
name|argc
operator|>
literal|3
condition|)
block|{
name|printf
argument_list|(
literal|"usage: %s host-name [port]\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|code
operator|=
operator|-
literal|1
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|gatemode
condition|)
name|port
operator|=
name|gateport
expr_stmt|;
else|else
name|port
operator|=
name|ftpport
expr_stmt|;
if|if
condition|(
name|argc
operator|>
literal|2
condition|)
name|port
operator|=
name|strdup
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|gatemode
condition|)
block|{
if|if
condition|(
name|gateserver
operator|==
name|NULL
operator|||
operator|*
name|gateserver
operator|==
literal|'\0'
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"gateserver not defined (shouldn't happen)"
argument_list|)
expr_stmt|;
name|host
operator|=
name|hookup
argument_list|(
name|gateserver
argument_list|,
name|port
argument_list|)
expr_stmt|;
block|}
else|else
name|host
operator|=
name|hookup
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|host
condition|)
block|{
name|int
name|overbose
decl_stmt|;
if|if
condition|(
name|gatemode
condition|)
block|{
if|if
condition|(
name|command
argument_list|(
literal|"PASSERVE %s"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
operator|!=
name|COMPLETE
condition|)
return|return;
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"Connected via pass-through server %s\n"
argument_list|,
name|gateserver
argument_list|)
expr_stmt|;
block|}
name|connected
operator|=
literal|1
expr_stmt|;
name|try_epsv
operator|=
literal|1
expr_stmt|;
comment|/* 		 * Set up defaults for FTP. 		 */
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|typename
argument_list|,
literal|"ascii"
argument_list|)
operator|,
name|type
operator|=
name|TYPE_A
expr_stmt|;
name|curtype
operator|=
name|TYPE_A
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|formname
argument_list|,
literal|"non-print"
argument_list|)
operator|,
name|form
operator|=
name|FORM_N
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|modename
argument_list|,
literal|"stream"
argument_list|)
operator|,
name|mode
operator|=
name|MODE_S
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|structname
argument_list|,
literal|"file"
argument_list|)
operator|,
name|stru
operator|=
name|STRU_F
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|bytename
argument_list|,
literal|"8"
argument_list|)
operator|,
name|bytesize
operator|=
literal|8
expr_stmt|;
if|if
condition|(
name|autologin
condition|)
operator|(
name|void
operator|)
name|login
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|overbose
operator|=
name|verbose
expr_stmt|;
if|if
condition|(
name|debug
operator|==
literal|0
condition|)
name|verbose
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|command
argument_list|(
literal|"SYST"
argument_list|)
operator|==
name|COMPLETE
operator|&&
name|overbose
condition|)
block|{
name|char
modifier|*
name|cp
decl_stmt|,
name|c
decl_stmt|;
name|c
operator|=
literal|0
expr_stmt|;
name|cp
operator|=
name|strchr
argument_list|(
name|reply_string
operator|+
literal|4
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
name|cp
operator|=
name|strchr
argument_list|(
name|reply_string
operator|+
literal|4
argument_list|,
literal|'\r'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
condition|)
block|{
if|if
condition|(
name|cp
index|[
operator|-
literal|1
index|]
operator|==
literal|'.'
condition|)
name|cp
operator|--
expr_stmt|;
name|c
operator|=
operator|*
name|cp
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"Remote system type is %s.\n"
argument_list|,
name|reply_string
operator|+
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
condition|)
operator|*
name|cp
operator|=
name|c
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|reply_string
argument_list|,
literal|"215 UNIX Type: L8"
argument_list|,
literal|17
argument_list|)
condition|)
block|{
if|if
condition|(
name|proxy
condition|)
name|unix_proxy
operator|=
literal|1
expr_stmt|;
else|else
name|unix_server
operator|=
literal|1
expr_stmt|;
comment|/* 			 * Set type to 0 (not specified by user), 			 * meaning binary by default, but don't bother 			 * telling server.  We can use binary 			 * for text files unless changed by the user. 			 */
name|type
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|typename
argument_list|,
literal|"binary"
argument_list|)
expr_stmt|;
if|if
condition|(
name|overbose
condition|)
name|printf
argument_list|(
literal|"Using %s mode to transfer files.\n"
argument_list|,
name|typename
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|proxy
condition|)
name|unix_proxy
operator|=
literal|0
expr_stmt|;
else|else
name|unix_server
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|overbose
operator|&&
operator|!
name|strncmp
argument_list|(
name|reply_string
argument_list|,
literal|"215 TOPS20"
argument_list|,
literal|10
argument_list|)
condition|)
name|puts
argument_list|(
literal|"Remember to set tenex mode when transferring binary files from this machine."
argument_list|)
expr_stmt|;
block|}
name|verbose
operator|=
name|overbose
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * login to remote host, using given username& password if supplied  */
end_comment

begin_function
name|int
name|login
parameter_list|(
name|host
parameter_list|,
name|user
parameter_list|,
name|pass
parameter_list|)
specifier|const
name|char
modifier|*
name|host
decl_stmt|;
name|char
modifier|*
name|user
decl_stmt|,
decl|*
name|pass
decl_stmt|;
end_function

begin_block
block|{
name|char
name|tmp
index|[
literal|80
index|]
decl_stmt|;
name|char
modifier|*
name|acct
decl_stmt|;
name|char
name|anonpass
index|[
name|MAXLOGNAME
operator|+
literal|1
operator|+
name|MAXHOSTNAMELEN
index|]
decl_stmt|;
comment|/* "user@hostname" */
name|char
name|hostname
index|[
name|MAXHOSTNAMELEN
index|]
decl_stmt|;
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
name|int
name|n
decl_stmt|,
name|aflag
init|=
literal|0
decl_stmt|;
name|acct
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|user
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|ruserpass
argument_list|(
name|host
argument_list|,
operator|&
name|user
argument_list|,
operator|&
name|pass
argument_list|,
operator|&
name|acct
argument_list|)
operator|<
literal|0
condition|)
block|{
name|code
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
comment|/* 	 * Set up arguments for an anonymous FTP session, if necessary. 	 */
if|if
condition|(
operator|(
name|user
operator|==
name|NULL
operator|||
name|pass
operator|==
name|NULL
operator|)
operator|&&
name|anonftp
condition|)
block|{
name|memset
argument_list|(
name|anonpass
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|anonpass
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|hostname
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hostname
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * Set up anonymous login password. 		 */
if|if
condition|(
operator|(
name|user
operator|=
name|getlogin
argument_list|()
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|pw
operator|=
name|getpwuid
argument_list|(
name|getuid
argument_list|()
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|user
operator|=
literal|"anonymous"
expr_stmt|;
else|else
name|user
operator|=
name|pw
operator|->
name|pw_name
expr_stmt|;
block|}
name|gethostname
argument_list|(
name|hostname
argument_list|,
name|MAXHOSTNAMELEN
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|DONT_CHEAT_ANONPASS
comment|/* 		 * Every anonymous FTP server I've encountered 		 * will accept the string "username@", and will 		 * append the hostname itself.  We do this by default 		 * since many servers are picky about not having 		 * a FQDN in the anonymous password. - thorpej@netbsd.org 		 */
name|snprintf
argument_list|(
name|anonpass
argument_list|,
sizeof|sizeof
argument_list|(
name|anonpass
argument_list|)
operator|-
literal|1
argument_list|,
literal|"%s@"
argument_list|,
name|user
argument_list|)
expr_stmt|;
else|#
directive|else
name|snprintf
argument_list|(
name|anonpass
argument_list|,
sizeof|sizeof
argument_list|(
name|anonpass
argument_list|)
operator|-
literal|1
argument_list|,
literal|"%s@%s"
argument_list|,
name|user
argument_list|,
name|hp
operator|->
name|h_name
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pass
operator|=
name|anonpass
expr_stmt|;
name|user
operator|=
literal|"anonymous"
expr_stmt|;
comment|/* as per RFC 1635 */
block|}
while|while
condition|(
name|user
operator|==
name|NULL
condition|)
block|{
name|char
modifier|*
name|myname
init|=
name|getlogin
argument_list|()
decl_stmt|;
if|if
condition|(
name|myname
operator|==
name|NULL
operator|&&
operator|(
name|pw
operator|=
name|getpwuid
argument_list|(
name|getuid
argument_list|()
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|myname
operator|=
name|pw
operator|->
name|pw_name
expr_stmt|;
if|if
condition|(
name|myname
condition|)
name|printf
argument_list|(
literal|"Name (%s:%s): "
argument_list|,
name|host
argument_list|,
name|myname
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"Name (%s): "
argument_list|,
name|host
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|fgets
argument_list|(
name|tmp
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
operator|-
literal|1
argument_list|,
name|stdin
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|tmp
index|[
name|strlen
argument_list|(
name|tmp
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|*
name|tmp
operator|==
literal|'\0'
condition|)
name|user
operator|=
name|myname
expr_stmt|;
else|else
name|user
operator|=
name|tmp
expr_stmt|;
block|}
name|n
operator|=
name|command
argument_list|(
literal|"USER %s"
argument_list|,
name|user
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|CONTINUE
condition|)
block|{
if|if
condition|(
name|pass
operator|==
name|NULL
condition|)
name|pass
operator|=
name|getpass
argument_list|(
literal|"Password:"
argument_list|)
expr_stmt|;
name|n
operator|=
name|command
argument_list|(
literal|"PASS %s"
argument_list|,
name|pass
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|==
name|CONTINUE
condition|)
block|{
name|aflag
operator|++
expr_stmt|;
if|if
condition|(
name|acct
operator|==
name|NULL
condition|)
name|acct
operator|=
name|getpass
argument_list|(
literal|"Account:"
argument_list|)
expr_stmt|;
name|n
operator|=
name|command
argument_list|(
literal|"ACCT %s"
argument_list|,
name|acct
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|n
operator|!=
name|COMPLETE
operator|)
operator|||
operator|(
operator|!
name|aflag
operator|&&
name|acct
operator|!=
name|NULL
operator|&&
name|command
argument_list|(
literal|"ACCT %s"
argument_list|,
name|acct
argument_list|)
operator|!=
name|COMPLETE
operator|)
condition|)
block|{
name|warnx
argument_list|(
literal|"Login failed."
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|proxy
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|connected
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|macnum
condition|;
operator|++
name|n
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"init"
argument_list|,
name|macros
index|[
name|n
index|]
operator|.
name|mac_name
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|line
argument_list|,
literal|"$init"
argument_list|)
expr_stmt|;
name|makeargv
argument_list|()
expr_stmt|;
name|domacro
argument_list|(
name|margc
argument_list|,
name|margv
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * `another' gets another argument, and stores the new argc and argv.  * It reverts to the top level (via main.c's intr()) on EOF/error.  *  * Returns false if no new arguments have been added.  */
end_comment

begin_function
name|int
name|another
parameter_list|(
name|pargc
parameter_list|,
name|pargv
parameter_list|,
name|prompt
parameter_list|)
name|int
modifier|*
name|pargc
decl_stmt|;
name|char
modifier|*
modifier|*
modifier|*
name|pargv
decl_stmt|;
specifier|const
name|char
modifier|*
name|prompt
decl_stmt|;
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|line
argument_list|)
decl_stmt|,
name|ret
decl_stmt|;
if|if
condition|(
name|len
operator|>=
sizeof|sizeof
argument_list|(
name|line
argument_list|)
operator|-
literal|3
condition|)
block|{
name|puts
argument_list|(
literal|"sorry, arguments too long."
argument_list|)
expr_stmt|;
name|intr
argument_list|()
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"(%s) "
argument_list|,
name|prompt
argument_list|)
expr_stmt|;
name|line
index|[
name|len
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
name|fgets
argument_list|(
operator|&
name|line
index|[
name|len
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
operator|-
name|len
argument_list|,
name|stdin
argument_list|)
operator|==
name|NULL
condition|)
name|intr
argument_list|()
expr_stmt|;
name|len
operator|+=
name|strlen
argument_list|(
operator|&
name|line
index|[
name|len
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
operator|&&
name|line
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|line
index|[
name|len
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|makeargv
argument_list|()
expr_stmt|;
name|ret
operator|=
name|margc
operator|>
operator|*
name|pargc
expr_stmt|;
operator|*
name|pargc
operator|=
name|margc
expr_stmt|;
operator|*
name|pargv
operator|=
name|margv
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * glob files given in argv[] from the remote server.  * if errbuf isn't NULL, store error messages there instead  * of writing to the screen.  */
end_comment

begin_function
name|char
modifier|*
name|remglob
parameter_list|(
name|argv
parameter_list|,
name|doswitch
parameter_list|,
name|errbuf
parameter_list|)
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
name|int
name|doswitch
decl_stmt|;
name|char
modifier|*
modifier|*
name|errbuf
decl_stmt|;
block|{
name|char
name|temp
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
specifier|static
name|char
name|buf
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
specifier|static
name|FILE
modifier|*
name|ftemp
init|=
name|NULL
decl_stmt|;
specifier|static
name|char
modifier|*
modifier|*
name|args
decl_stmt|;
name|int
name|oldverbose
decl_stmt|,
name|oldhash
decl_stmt|,
name|fd
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|mode
decl_stmt|;
if|if
condition|(
operator|!
name|mflag
condition|)
block|{
if|if
condition|(
operator|!
name|doglob
condition|)
name|args
operator|=
name|NULL
expr_stmt|;
else|else
block|{
if|if
condition|(
name|ftemp
condition|)
block|{
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|ftemp
argument_list|)
expr_stmt|;
name|ftemp
operator|=
name|NULL
expr_stmt|;
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|doglob
condition|)
block|{
if|if
condition|(
name|args
operator|==
name|NULL
condition|)
name|args
operator|=
name|argv
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
operator|*
operator|++
name|args
operator|)
operator|==
name|NULL
condition|)
name|args
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|cp
operator|)
return|;
block|}
if|if
condition|(
name|ftemp
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|temp
argument_list|,
sizeof|sizeof
argument_list|(
name|temp
argument_list|)
argument_list|,
literal|"%s/%s"
argument_list|,
name|tmpdir
argument_list|,
name|TMPFILE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|mkstemp
argument_list|(
name|temp
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"unable to create temporary file %s"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|oldverbose
operator|=
name|verbose
expr_stmt|;
name|verbose
operator|=
operator|(
name|errbuf
operator|!=
name|NULL
operator|)
condition|?
operator|-
literal|1
else|:
literal|0
expr_stmt|;
name|oldhash
operator|=
name|hash
expr_stmt|;
name|hash
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|doswitch
condition|)
name|pswitch
argument_list|(
operator|!
name|proxy
argument_list|)
expr_stmt|;
for|for
control|(
name|mode
operator|=
literal|"w"
init|;
operator|*
operator|++
name|argv
operator|!=
name|NULL
condition|;
name|mode
operator|=
literal|"a"
control|)
name|recvrequest
argument_list|(
literal|"NLST"
argument_list|,
name|temp
argument_list|,
operator|*
name|argv
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|code
operator|/
literal|100
operator|)
operator|!=
name|COMPLETE
condition|)
block|{
if|if
condition|(
name|errbuf
operator|!=
name|NULL
condition|)
operator|*
name|errbuf
operator|=
name|reply_string
expr_stmt|;
block|}
if|if
condition|(
name|doswitch
condition|)
name|pswitch
argument_list|(
operator|!
name|proxy
argument_list|)
expr_stmt|;
name|verbose
operator|=
name|oldverbose
expr_stmt|;
name|hash
operator|=
name|oldhash
expr_stmt|;
name|ftemp
operator|=
name|fopen
argument_list|(
name|temp
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ftemp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|errbuf
operator|==
name|NULL
condition|)
name|puts
argument_list|(
literal|"can't find list of remote files, oops."
argument_list|)
expr_stmt|;
else|else
operator|*
name|errbuf
operator|=
literal|"can't find list of remote files, oops."
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
if|if
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|ftemp
argument_list|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|ftemp
argument_list|)
expr_stmt|;
name|ftemp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|cp
operator|=
name|strchr
argument_list|(
name|buf
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_function
name|int
name|confirm
parameter_list|(
name|cmd
parameter_list|,
name|file
parameter_list|)
specifier|const
name|char
modifier|*
name|cmd
decl_stmt|,
decl|*
name|file
decl_stmt|;
end_function

begin_block
block|{
name|char
name|line
index|[
name|BUFSIZ
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|interactive
operator|||
name|confirmrest
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|printf
argument_list|(
literal|"%s %s? "
argument_list|,
name|cmd
argument_list|,
name|file
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|,
name|stdin
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
switch|switch
condition|(
name|tolower
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|line
argument_list|)
condition|)
block|{
case|case
literal|'n'
case|:
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|'p'
case|:
name|interactive
operator|=
literal|0
expr_stmt|;
name|puts
argument_list|(
literal|"Interactive mode: off."
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|confirmrest
operator|=
literal|1
expr_stmt|;
name|printf
argument_list|(
literal|"Prompting off for duration of %s.\n"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Glob a local file name specification with  * the expectation of a single return value.  * Can't control multiple values being expanded  * from the expression, we return only the first.  */
end_comment

begin_function
name|int
name|globulize
parameter_list|(
name|cpp
parameter_list|)
name|char
modifier|*
modifier|*
name|cpp
decl_stmt|;
block|{
name|glob_t
name|gl
decl_stmt|;
name|int
name|flags
decl_stmt|;
if|if
condition|(
operator|!
name|doglob
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|flags
operator|=
name|GLOB_BRACE
operator||
name|GLOB_NOCHECK
operator||
name|GLOB_QUOTE
operator||
name|GLOB_TILDE
expr_stmt|;
name|memset
argument_list|(
operator|&
name|gl
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|gl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|glob
argument_list|(
operator|*
name|cpp
argument_list|,
name|flags
argument_list|,
name|NULL
argument_list|,
operator|&
name|gl
argument_list|)
operator|||
name|gl
operator|.
name|gl_pathc
operator|==
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: not found"
argument_list|,
operator|*
name|cpp
argument_list|)
expr_stmt|;
name|globfree
argument_list|(
operator|&
name|gl
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* XXX: caller should check if *cpp changed, and 		 *	free(*cpp) if that is the case 		 */
operator|*
name|cpp
operator|=
name|strdup
argument_list|(
name|gl
operator|.
name|gl_pathv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|globfree
argument_list|(
operator|&
name|gl
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * determine size of remote file  */
end_comment

begin_function
name|off_t
name|remotesize
parameter_list|(
name|file
parameter_list|,
name|noisy
parameter_list|)
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|noisy
decl_stmt|;
block|{
name|int
name|overbose
decl_stmt|;
name|off_t
name|size
decl_stmt|;
name|overbose
operator|=
name|verbose
expr_stmt|;
name|size
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|debug
operator|==
literal|0
condition|)
name|verbose
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|command
argument_list|(
literal|"SIZE %s"
argument_list|,
name|file
argument_list|)
operator|==
name|COMPLETE
condition|)
block|{
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|ep
decl_stmt|;
name|cp
operator|=
name|strchr
argument_list|(
name|reply_string
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
block|{
name|cp
operator|++
expr_stmt|;
name|size
operator|=
name|strtoq
argument_list|(
name|cp
argument_list|,
operator|&
name|ep
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ep
operator|!=
literal|'\0'
operator|&&
operator|!
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|ep
argument_list|)
condition|)
name|size
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|noisy
operator|&&
name|debug
operator|==
literal|0
condition|)
name|puts
argument_list|(
name|reply_string
argument_list|)
expr_stmt|;
name|verbose
operator|=
name|overbose
expr_stmt|;
return|return
operator|(
name|size
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * determine last modification time (in GMT) of remote file  */
end_comment

begin_function
name|time_t
name|remotemodtime
parameter_list|(
name|file
parameter_list|,
name|noisy
parameter_list|)
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|noisy
decl_stmt|;
block|{
name|struct
name|tm
name|timebuf
decl_stmt|;
name|time_t
name|rtime
decl_stmt|;
name|int
name|len
decl_stmt|,
name|month
decl_stmt|,
name|ocode
decl_stmt|,
name|overbose
decl_stmt|,
name|y2kbug
decl_stmt|,
name|year
decl_stmt|;
name|char
modifier|*
name|fmt
decl_stmt|;
name|char
name|mtbuf
index|[
literal|17
index|]
decl_stmt|;
name|overbose
operator|=
name|verbose
expr_stmt|;
name|ocode
operator|=
name|code
expr_stmt|;
name|rtime
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|debug
operator|==
literal|0
condition|)
name|verbose
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|command
argument_list|(
literal|"MDTM %s"
argument_list|,
name|file
argument_list|)
operator|==
name|COMPLETE
condition|)
block|{
name|memset
argument_list|(
operator|&
name|timebuf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|timebuf
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * Parse the time string, which is expected to be 14 		 * characters long.  Some broken servers send tm_year 		 * formatted with "19%02d", which produces an incorrect 		 * (but parsable) 15 characters for years>= 2000. 		 * Scan for invalid trailing junk by accepting up to 16 		 * characters. 		 */
if|if
condition|(
name|sscanf
argument_list|(
name|reply_string
argument_list|,
literal|"%*s %16s"
argument_list|,
name|mtbuf
argument_list|)
operator|==
literal|1
condition|)
block|{
name|fmt
operator|=
name|NULL
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|mtbuf
argument_list|)
expr_stmt|;
name|y2kbug
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|15
operator|&&
name|strncmp
argument_list|(
name|mtbuf
argument_list|,
literal|"19"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fmt
operator|=
literal|"19%03d%02d%02d%02d%02d%02d"
expr_stmt|;
name|y2kbug
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|len
operator|==
literal|14
condition|)
name|fmt
operator|=
literal|"%04d%02d%02d%02d%02d%02d"
expr_stmt|;
if|if
condition|(
name|fmt
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|sscanf
argument_list|(
name|mtbuf
argument_list|,
name|fmt
argument_list|,
operator|&
name|year
argument_list|,
operator|&
name|month
argument_list|,
operator|&
name|timebuf
operator|.
name|tm_mday
argument_list|,
operator|&
name|timebuf
operator|.
name|tm_hour
argument_list|,
operator|&
name|timebuf
operator|.
name|tm_min
argument_list|,
operator|&
name|timebuf
operator|.
name|tm_sec
argument_list|)
operator|==
literal|6
condition|)
block|{
name|timebuf
operator|.
name|tm_isdst
operator|=
operator|-
literal|1
expr_stmt|;
name|timebuf
operator|.
name|tm_mon
operator|=
name|month
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|y2kbug
condition|)
name|timebuf
operator|.
name|tm_year
operator|=
name|year
expr_stmt|;
else|else
name|timebuf
operator|.
name|tm_year
operator|=
name|year
operator|-
literal|1900
expr_stmt|;
name|rtime
operator|=
name|mktime
argument_list|(
operator|&
name|timebuf
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|rtime
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|noisy
operator|||
name|debug
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"Can't convert %s to a time.\n"
argument_list|,
name|mtbuf
argument_list|)
expr_stmt|;
block|}
else|else
name|rtime
operator|+=
name|timebuf
operator|.
name|tm_gmtoff
expr_stmt|;
comment|/* conv. local -> GMT */
block|}
elseif|else
if|if
condition|(
name|noisy
operator|&&
name|debug
operator|==
literal|0
condition|)
name|puts
argument_list|(
name|reply_string
argument_list|)
expr_stmt|;
name|verbose
operator|=
name|overbose
expr_stmt|;
if|if
condition|(
name|rtime
operator|==
operator|-
literal|1
condition|)
name|code
operator|=
name|ocode
expr_stmt|;
return|return
operator|(
name|rtime
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|void
name|updateprogressmeter
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|updateprogressmeter
parameter_list|(
name|dummy
parameter_list|)
name|int
name|dummy
decl_stmt|;
block|{
specifier|static
name|pid_t
name|pgrp
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|ctty_pgrp
decl_stmt|;
if|if
condition|(
name|pgrp
operator|==
operator|-
literal|1
condition|)
name|pgrp
operator|=
name|getpgrp
argument_list|()
expr_stmt|;
comment|/* 	 * print progress bar only if we are foreground process. 	 */
if|if
condition|(
name|ioctl
argument_list|(
name|STDOUT_FILENO
argument_list|,
name|TIOCGPGRP
argument_list|,
operator|&
name|ctty_pgrp
argument_list|)
operator|!=
operator|-
literal|1
operator|&&
name|ctty_pgrp
operator|==
operator|(
name|int
operator|)
name|pgrp
condition|)
name|progressmeter
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Display a transfer progress bar if progress is non-zero.  * SIGALRM is hijacked for use by this function.  * - Before the transfer, set filesize to size of file (or -1 if unknown),  *   and call with flag = -1. This starts the once per second timer,  *   and a call to updateprogressmeter() upon SIGALRM.  * - During the transfer, updateprogressmeter will call progressmeter  *   with flag = 0  * - After the transfer, call with flag = 1  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|timeval
name|start
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|progressmeter
parameter_list|(
name|flag
parameter_list|)
name|int
name|flag
decl_stmt|;
block|{
comment|/* 	 * List of order of magnitude prefixes. 	 * The last is `P', as 2^64 = 16384 Petabytes 	 */
specifier|static
specifier|const
name|char
name|prefixes
index|[]
init|=
literal|" KMGTP"
decl_stmt|;
specifier|static
name|struct
name|timeval
name|lastupdate
decl_stmt|;
specifier|static
name|off_t
name|lastsize
decl_stmt|;
name|struct
name|timeval
name|now
decl_stmt|,
name|td
decl_stmt|,
name|wait
decl_stmt|;
name|off_t
name|cursize
decl_stmt|,
name|abbrevsize
decl_stmt|;
name|double
name|elapsed
decl_stmt|;
name|int
name|ratio
decl_stmt|,
name|barlength
decl_stmt|,
name|i
decl_stmt|,
name|len
decl_stmt|;
name|off_t
name|remaining
decl_stmt|;
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|flag
operator|==
operator|-
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|start
argument_list|,
operator|(
expr|struct
name|timezone
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|lastupdate
operator|=
name|start
expr_stmt|;
name|lastsize
operator|=
name|restart_point
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|now
argument_list|,
operator|(
expr|struct
name|timezone
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|progress
operator|||
name|filesize
operator|<=
literal|0
condition|)
return|return;
name|cursize
operator|=
name|bytes
operator|+
name|restart_point
expr_stmt|;
name|ratio
operator|=
name|cursize
operator|*
literal|100
operator|/
name|filesize
expr_stmt|;
name|ratio
operator|=
name|MAX
argument_list|(
name|ratio
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ratio
operator|=
name|MIN
argument_list|(
name|ratio
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|len
operator|+=
name|snprintf
argument_list|(
name|buf
operator|+
name|len
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
name|len
argument_list|,
literal|"\r%3d%% "
argument_list|,
name|ratio
argument_list|)
expr_stmt|;
name|barlength
operator|=
name|ttywidth
operator|-
literal|30
expr_stmt|;
if|if
condition|(
name|barlength
operator|>
literal|0
condition|)
block|{
name|i
operator|=
name|barlength
operator|*
name|ratio
operator|/
literal|100
expr_stmt|;
name|len
operator|+=
name|snprintf
argument_list|(
name|buf
operator|+
name|len
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
name|len
argument_list|,
literal|"|%.*s%*s|"
argument_list|,
name|i
argument_list|,
literal|"*****************************************************************************"
literal|"*****************************************************************************"
argument_list|,
name|barlength
operator|-
name|i
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
literal|0
expr_stmt|;
name|abbrevsize
operator|=
name|cursize
expr_stmt|;
while|while
condition|(
name|abbrevsize
operator|>=
literal|100000
operator|&&
name|i
operator|<
sizeof|sizeof
argument_list|(
name|prefixes
argument_list|)
condition|)
block|{
name|i
operator|++
expr_stmt|;
name|abbrevsize
operator|>>=
literal|10
expr_stmt|;
block|}
name|len
operator|+=
name|snprintf
argument_list|(
name|buf
operator|+
name|len
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
name|len
argument_list|,
literal|" %5qd %c%c "
argument_list|,
operator|(
name|long
name|long
operator|)
name|abbrevsize
argument_list|,
name|prefixes
index|[
name|i
index|]
argument_list|,
name|prefixes
index|[
name|i
index|]
operator|==
literal|' '
condition|?
literal|' '
else|:
literal|'B'
argument_list|)
expr_stmt|;
name|timersub
argument_list|(
operator|&
name|now
argument_list|,
operator|&
name|lastupdate
argument_list|,
operator|&
name|wait
argument_list|)
expr_stmt|;
if|if
condition|(
name|cursize
operator|>
name|lastsize
condition|)
block|{
name|lastupdate
operator|=
name|now
expr_stmt|;
name|lastsize
operator|=
name|cursize
expr_stmt|;
if|if
condition|(
name|wait
operator|.
name|tv_sec
operator|>=
name|STALLTIME
condition|)
block|{
comment|/* fudge out stalled time */
name|start
operator|.
name|tv_sec
operator|+=
name|wait
operator|.
name|tv_sec
expr_stmt|;
name|start
operator|.
name|tv_usec
operator|+=
name|wait
operator|.
name|tv_usec
expr_stmt|;
block|}
name|wait
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
block|}
name|timersub
argument_list|(
operator|&
name|now
argument_list|,
operator|&
name|start
argument_list|,
operator|&
name|td
argument_list|)
expr_stmt|;
name|elapsed
operator|=
name|td
operator|.
name|tv_sec
operator|+
operator|(
name|td
operator|.
name|tv_usec
operator|/
literal|1000000.0
operator|)
expr_stmt|;
if|if
condition|(
name|bytes
operator|<=
literal|0
operator|||
name|elapsed
operator|<=
literal|0.0
operator|||
name|cursize
operator|>
name|filesize
condition|)
block|{
name|len
operator|+=
name|snprintf
argument_list|(
name|buf
operator|+
name|len
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
name|len
argument_list|,
literal|"   --:-- ETA"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|wait
operator|.
name|tv_sec
operator|>=
name|STALLTIME
condition|)
block|{
name|len
operator|+=
name|snprintf
argument_list|(
name|buf
operator|+
name|len
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
name|len
argument_list|,
literal|" - stalled -"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|remaining
operator|=
operator|(
operator|(
name|filesize
operator|-
name|restart_point
operator|)
operator|/
operator|(
name|bytes
operator|/
name|elapsed
operator|)
operator|-
name|elapsed
operator|)
expr_stmt|;
if|if
condition|(
name|remaining
operator|>=
literal|100
operator|*
name|SECSPERHOUR
condition|)
name|len
operator|+=
name|snprintf
argument_list|(
name|buf
operator|+
name|len
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
name|len
argument_list|,
literal|"   --:-- ETA"
argument_list|)
expr_stmt|;
else|else
block|{
name|i
operator|=
name|remaining
operator|/
name|SECSPERHOUR
expr_stmt|;
if|if
condition|(
name|i
condition|)
name|len
operator|+=
name|snprintf
argument_list|(
name|buf
operator|+
name|len
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
name|len
argument_list|,
literal|"%2d:"
argument_list|,
name|i
argument_list|)
expr_stmt|;
else|else
name|len
operator|+=
name|snprintf
argument_list|(
name|buf
operator|+
name|len
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
name|len
argument_list|,
literal|"   "
argument_list|)
expr_stmt|;
name|i
operator|=
name|remaining
operator|%
name|SECSPERHOUR
expr_stmt|;
name|len
operator|+=
name|snprintf
argument_list|(
name|buf
operator|+
name|len
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
name|len
argument_list|,
literal|"%02d:%02d ETA"
argument_list|,
name|i
operator|/
literal|60
argument_list|,
name|i
operator|%
literal|60
argument_list|)
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|write
argument_list|(
name|STDOUT_FILENO
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag
operator|==
operator|-
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|updateprogressmeter
argument_list|)
expr_stmt|;
name|alarmtimer
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* set alarm timer for 1 Hz */
block|}
elseif|else
if|if
condition|(
name|flag
operator|==
literal|1
condition|)
block|{
name|alarmtimer
argument_list|(
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Display transfer statistics.  * Requires start to be initialised by progressmeter(-1),  * direction to be defined by xfer routines, and filesize and bytes  * to be updated by xfer routines  * If siginfo is nonzero, an ETA is displayed, and the output goes to STDERR  * instead of STDOUT.  */
end_comment

begin_function
name|void
name|ptransfer
parameter_list|(
name|siginfo
parameter_list|)
name|int
name|siginfo
decl_stmt|;
block|{
name|struct
name|timeval
name|now
decl_stmt|,
name|td
decl_stmt|;
name|double
name|elapsed
decl_stmt|;
name|off_t
name|bs
decl_stmt|;
name|int
name|meg
decl_stmt|,
name|remaining
decl_stmt|,
name|hh
decl_stmt|,
name|len
decl_stmt|;
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|verbose
operator|&&
operator|!
name|siginfo
condition|)
return|return;
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|now
argument_list|,
operator|(
expr|struct
name|timezone
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|timersub
argument_list|(
operator|&
name|now
argument_list|,
operator|&
name|start
argument_list|,
operator|&
name|td
argument_list|)
expr_stmt|;
name|elapsed
operator|=
name|td
operator|.
name|tv_sec
operator|+
operator|(
name|td
operator|.
name|tv_usec
operator|/
literal|1000000.0
operator|)
expr_stmt|;
name|bs
operator|=
name|bytes
operator|/
operator|(
name|elapsed
operator|==
literal|0.0
condition|?
literal|1
else|:
name|elapsed
operator|)
expr_stmt|;
name|meg
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bs
operator|>
operator|(
literal|1024
operator|*
literal|1024
operator|)
condition|)
name|meg
operator|=
literal|1
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
name|len
operator|+=
name|snprintf
argument_list|(
name|buf
operator|+
name|len
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
name|len
argument_list|,
literal|"%qd byte%s %s in %.2f seconds (%.2f %sB/s)\n"
argument_list|,
operator|(
name|long
name|long
operator|)
name|bytes
argument_list|,
name|bytes
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|,
name|direction
argument_list|,
name|elapsed
argument_list|,
name|bs
operator|/
operator|(
literal|1024.0
operator|*
operator|(
name|meg
condition|?
literal|1024.0
else|:
literal|1.0
operator|)
operator|)
argument_list|,
name|meg
condition|?
literal|"M"
else|:
literal|"K"
argument_list|)
expr_stmt|;
if|if
condition|(
name|siginfo
operator|&&
name|bytes
operator|>
literal|0
operator|&&
name|elapsed
operator|>
literal|0.0
operator|&&
name|filesize
operator|>=
literal|0
operator|&&
name|bytes
operator|+
name|restart_point
operator|<=
name|filesize
condition|)
block|{
name|remaining
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|filesize
operator|-
name|restart_point
operator|)
operator|/
operator|(
name|bytes
operator|/
name|elapsed
operator|)
operator|-
name|elapsed
argument_list|)
expr_stmt|;
name|hh
operator|=
name|remaining
operator|/
name|SECSPERHOUR
expr_stmt|;
name|remaining
operator|%=
name|SECSPERHOUR
expr_stmt|;
name|len
operator|--
expr_stmt|;
comment|/* decrement len to overwrite \n */
name|len
operator|+=
name|snprintf
argument_list|(
name|buf
operator|+
name|len
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
name|len
argument_list|,
literal|"  ETA: %02d:%02d:%02d\n"
argument_list|,
name|hh
argument_list|,
name|remaining
operator|/
literal|60
argument_list|,
name|remaining
operator|%
literal|60
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|write
argument_list|(
name|siginfo
condition|?
name|STDERR_FILENO
else|:
name|STDOUT_FILENO
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * List words in stringlist, vertically arranged  */
end_comment

begin_function
name|void
name|list_vertical
parameter_list|(
name|sl
parameter_list|)
name|StringList
modifier|*
name|sl
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|w
decl_stmt|;
name|int
name|columns
decl_stmt|,
name|width
decl_stmt|,
name|lines
decl_stmt|,
name|items
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|width
operator|=
name|items
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sl
operator|->
name|sl_cur
condition|;
name|i
operator|++
control|)
block|{
name|w
operator|=
name|strlen
argument_list|(
name|sl
operator|->
name|sl_str
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|>
name|width
condition|)
name|width
operator|=
name|w
expr_stmt|;
block|}
name|width
operator|=
operator|(
name|width
operator|+
literal|8
operator|)
operator|&
operator|~
literal|7
expr_stmt|;
name|columns
operator|=
name|ttywidth
operator|/
name|width
expr_stmt|;
if|if
condition|(
name|columns
operator|==
literal|0
condition|)
name|columns
operator|=
literal|1
expr_stmt|;
name|lines
operator|=
operator|(
name|sl
operator|->
name|sl_cur
operator|+
name|columns
operator|-
literal|1
operator|)
operator|/
name|columns
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lines
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|columns
condition|;
name|j
operator|++
control|)
block|{
name|p
operator|=
name|sl
operator|->
name|sl_str
index|[
name|j
operator|*
name|lines
operator|+
name|i
index|]
expr_stmt|;
if|if
condition|(
name|p
condition|)
name|fputs
argument_list|(
name|p
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|*
name|lines
operator|+
name|i
operator|+
name|lines
operator|>=
name|sl
operator|->
name|sl_cur
condition|)
block|{
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
break|break;
block|}
name|w
operator|=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
while|while
condition|(
name|w
operator|<
name|width
condition|)
block|{
name|w
operator|=
operator|(
name|w
operator|+
literal|8
operator|)
operator|&
operator|~
literal|7
expr_stmt|;
operator|(
name|void
operator|)
name|putchar
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Update the global ttywidth value, using TIOCGWINSZ.  */
end_comment

begin_function
name|void
name|setttywidth
parameter_list|(
name|a
parameter_list|)
name|int
name|a
decl_stmt|;
block|{
name|struct
name|winsize
name|winsize
decl_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|,
name|TIOCGWINSZ
argument_list|,
operator|&
name|winsize
argument_list|)
operator|!=
operator|-
literal|1
condition|)
name|ttywidth
operator|=
name|winsize
operator|.
name|ws_col
expr_stmt|;
else|else
name|ttywidth
operator|=
literal|80
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set the SIGALRM interval timer for wait seconds, 0 to disable.  */
end_comment

begin_function
name|void
name|alarmtimer
parameter_list|(
name|wait
parameter_list|)
name|int
name|wait
decl_stmt|;
block|{
name|struct
name|itimerval
name|itv
decl_stmt|;
name|itv
operator|.
name|it_value
operator|.
name|tv_sec
operator|=
name|wait
expr_stmt|;
name|itv
operator|.
name|it_value
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|itv
operator|.
name|it_interval
operator|=
name|itv
operator|.
name|it_value
expr_stmt|;
name|setitimer
argument_list|(
name|ITIMER_REAL
argument_list|,
operator|&
name|itv
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Setup or cleanup EditLine structures  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SMALL
end_ifndef

begin_function
name|void
name|controlediting
parameter_list|()
block|{
if|if
condition|(
name|editing
operator|&&
name|el
operator|==
name|NULL
operator|&&
name|hist
operator|==
name|NULL
condition|)
block|{
name|el
operator|=
name|el_init
argument_list|(
name|__progname
argument_list|,
name|stdin
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
comment|/* init editline */
name|hist
operator|=
name|history_init
argument_list|()
expr_stmt|;
comment|/* init the builtin history */
name|history
argument_list|(
name|hist
argument_list|,
name|H_EVENT
argument_list|,
literal|100
argument_list|)
expr_stmt|;
comment|/* remember 100 events */
name|el_set
argument_list|(
name|el
argument_list|,
name|EL_HIST
argument_list|,
name|history
argument_list|,
name|hist
argument_list|)
expr_stmt|;
comment|/* use history */
name|el_set
argument_list|(
name|el
argument_list|,
name|EL_EDITOR
argument_list|,
literal|"emacs"
argument_list|)
expr_stmt|;
comment|/* default editor is emacs */
name|el_set
argument_list|(
name|el
argument_list|,
name|EL_PROMPT
argument_list|,
name|prompt
argument_list|)
expr_stmt|;
comment|/* set the prompt function */
comment|/* add local file completion, bind to TAB */
name|el_set
argument_list|(
name|el
argument_list|,
name|EL_ADDFN
argument_list|,
literal|"ftp-complete"
argument_list|,
literal|"Context sensitive argument completion"
argument_list|,
name|complete
argument_list|)
expr_stmt|;
name|el_set
argument_list|(
name|el
argument_list|,
name|EL_BIND
argument_list|,
literal|"^I"
argument_list|,
literal|"ftp-complete"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|el_source
argument_list|(
name|el
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* read ~/.editrc */
name|el_set
argument_list|(
name|el
argument_list|,
name|EL_SIGNAL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|editing
condition|)
block|{
if|if
condition|(
name|hist
condition|)
block|{
name|history_end
argument_list|(
name|hist
argument_list|)
expr_stmt|;
name|hist
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|el
condition|)
block|{
name|el_end
argument_list|(
name|el
argument_list|)
expr_stmt|;
name|el
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !SMALL */
end_comment

begin_comment
comment|/*  * Determine if given string is an IPv6 address or not.  * Return 1 for yes, 0 for no  */
end_comment

begin_function
name|int
name|isipv6addr
parameter_list|(
specifier|const
name|char
modifier|*
name|addr
parameter_list|)
block|{
name|int
name|rv
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|INET6
name|struct
name|addrinfo
name|hints
decl_stmt|,
modifier|*
name|res
decl_stmt|;
name|memset
argument_list|(
operator|&
name|hints
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hints
argument_list|)
argument_list|)
expr_stmt|;
name|hints
operator|.
name|ai_family
operator|=
name|PF_INET6
expr_stmt|;
name|hints
operator|.
name|ai_socktype
operator|=
name|SOCK_DGRAM
expr_stmt|;
comment|/*dummy*/
name|hints
operator|.
name|ai_flags
operator|=
name|AI_NUMERICHOST
expr_stmt|;
if|if
condition|(
name|getaddrinfo
argument_list|(
name|addr
argument_list|,
literal|"0"
argument_list|,
operator|&
name|hints
argument_list|,
operator|&
name|res
argument_list|)
operator|!=
literal|0
condition|)
name|rv
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|rv
operator|=
literal|1
expr_stmt|;
name|freeaddrinfo
argument_list|(
name|res
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"isipv6addr: got %d for %s\n"
argument_list|,
name|rv
argument_list|,
name|addr
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|rv
operator|==
literal|1
operator|)
condition|?
literal|1
else|:
literal|0
return|;
block|}
end_function

end_unit

