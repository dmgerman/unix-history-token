begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$OpenBSD: diff3prog.c,v 1.11 2009/10/27 23:59:37 deraadt Exp $	*/
end_comment

begin_comment
comment|/*  * Copyright (C) Caldera International Inc.  2001-2002.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code and documentation must retain the above  *    copyright notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed or owned by Caldera  *	International, Inc.  * 4. Neither the name of Caldera International, Inc. nor the names of other  *    contributors may be used to endorse or promote products derived from  *    this software without specific prior written permission.  *  * USE OF THE SOFTWARE PROVIDED FOR UNDER THIS LICENSE BY CALDERA  * INTERNATIONAL, INC. AND CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL CALDERA INTERNATIONAL, INC. BE LIABLE FOR ANY DIRECT,  * INDIRECT INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*-  * Copyright (c) 1991, 1993  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	@(#)diff3.c	8.1 (Berkeley) 6/6/93  */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_endif
unit|static char sccsid[] = "@(#)diff3.c	8.1 (Berkeley) 6/6/93";
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/capsicum.h>
end_include

begin_include
include|#
directive|include
file|<sys/procdesc.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/event.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<capsicum_helpers.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<getopt.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_comment
comment|/*  * "from" is first in range of changed lines; "to" is last+1  * from=to=line after point of insertion for added lines.  */
end_comment

begin_struct
struct|struct
name|range
block|{
name|int
name|from
decl_stmt|;
name|int
name|to
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|diff
block|{
name|struct
name|range
name|old
decl_stmt|;
name|struct
name|range
name|new
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|size_t
name|szchanges
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|diff
modifier|*
name|d13
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|diff
modifier|*
name|d23
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * "de" is used to gather editing scripts.  These are later spewed out in  * reverse order.  Its first element must be all zero, the "new" component  * of "de" contains line positions or byte positions depending on when you  * look (!?).  Array overlap indicates which sections in "de" correspond to  * lines that are different in all three files.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|diff
modifier|*
name|de
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|overlap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|overlapcnt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|fp
index|[
literal|3
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cline
index|[
literal|3
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # of the last-read line in each file (0-2) */
end_comment

begin_comment
comment|/*  * The latest known correspondence between line numbers of the 3 files  * is stored in last[1-3];  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|last
index|[
literal|4
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|Aflag
decl_stmt|,
name|eflag
decl_stmt|,
name|iflag
decl_stmt|,
name|mflag
decl_stmt|,
name|Tflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|oflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* indicates whether to mark overlaps (-E or -X)*/
end_comment

begin_decl_stmt
specifier|static
name|int
name|strip_cr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|f1mark
decl_stmt|,
modifier|*
name|f2mark
decl_stmt|,
modifier|*
name|f3mark
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|bool
name|duplicate
parameter_list|(
name|struct
name|range
modifier|*
parameter_list|,
name|struct
name|range
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|edit
parameter_list|(
name|struct
name|diff
modifier|*
parameter_list|,
name|bool
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|getchange
parameter_list|(
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|get_line
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|number
parameter_list|(
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|readin
parameter_list|(
name|int
name|fd
parameter_list|,
name|struct
name|diff
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|skip
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|change
parameter_list|(
name|int
parameter_list|,
name|struct
name|range
modifier|*
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|keep
parameter_list|(
name|int
parameter_list|,
name|struct
name|range
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|merge
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|prange
parameter_list|(
name|struct
name|range
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|repos
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|void
name|edscript
argument_list|(
name|int
argument_list|)
name|__dead2
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|increase
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|void
name|usage
argument_list|(
name|void
argument_list|)
name|__dead2
decl_stmt|;
end_decl_stmt

begin_enum
enum|enum
block|{
name|DIFFPROG_OPT
block|,
name|STRIPCR_OPT
block|, }
enum|;
end_enum

begin_define
define|#
directive|define
name|MAX_CHECK
value|768
end_define

begin_comment
comment|/* 3 kb of chars */
end_comment

begin_define
define|#
directive|define
name|DIFF_PATH
value|"/usr/bin/diff"
end_define

begin_define
define|#
directive|define
name|OPTIONS
value|"3aAeEiL:mTxX"
end_define

begin_decl_stmt
specifier|static
name|struct
name|option
name|longopts
index|[]
init|=
block|{
block|{
literal|"ed"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'e'
block|}
block|,
block|{
literal|"show-overlap"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'E'
block|}
block|,
block|{
literal|"overlap-only"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'x'
block|}
block|,
block|{
literal|"initial-tab"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'T'
block|}
block|,
block|{
literal|"text"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'a'
block|}
block|,
block|{
literal|"strip-trailing-cr"
block|,
name|no_argument
block|,
name|NULL
block|,
name|STRIPCR_OPT
block|}
block|,
block|{
literal|"show-all"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'A'
block|}
block|,
block|{
literal|"easy-only"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'3'
block|}
block|,
block|{
literal|"merge"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'m'
block|}
block|,
block|{
literal|"label"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'L'
block|}
block|,
block|{
literal|"diff-program"
block|,
name|required_argument
block|,
name|NULL
block|,
name|DIFFPROG_OPT
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: diff3 [-3aAeEimTxX] [-L lable1] [-L label2] "
literal|"[ -L label3] file1 file2 file3\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|readin
parameter_list|(
name|int
name|fd
parameter_list|,
name|struct
name|diff
modifier|*
modifier|*
name|dd
parameter_list|)
block|{
name|int
name|a
decl_stmt|,
name|b
decl_stmt|,
name|c
decl_stmt|,
name|d
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|char
name|kind
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
name|f
operator|=
name|fdopen
argument_list|(
name|fd
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|2
argument_list|,
literal|"fdopen"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|p
operator|=
name|getchange
argument_list|(
name|f
argument_list|)
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>=
name|szchanges
operator|-
literal|1
condition|)
name|increase
argument_list|()
expr_stmt|;
name|a
operator|=
name|b
operator|=
name|number
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|','
condition|)
block|{
name|p
operator|++
expr_stmt|;
name|b
operator|=
name|number
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
block|}
name|kind
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|c
operator|=
name|d
operator|=
name|number
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|','
condition|)
block|{
name|p
operator|++
expr_stmt|;
name|d
operator|=
name|number
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|kind
operator|==
literal|'a'
condition|)
name|a
operator|++
expr_stmt|;
if|if
condition|(
name|kind
operator|==
literal|'d'
condition|)
name|c
operator|++
expr_stmt|;
name|b
operator|++
expr_stmt|;
name|d
operator|++
expr_stmt|;
operator|(
operator|*
name|dd
operator|)
index|[
name|i
index|]
operator|.
name|old
operator|.
name|from
operator|=
name|a
expr_stmt|;
operator|(
operator|*
name|dd
operator|)
index|[
name|i
index|]
operator|.
name|old
operator|.
name|to
operator|=
name|b
expr_stmt|;
operator|(
operator|*
name|dd
operator|)
index|[
name|i
index|]
operator|.
name|new
operator|.
name|from
operator|=
name|c
expr_stmt|;
operator|(
operator|*
name|dd
operator|)
index|[
name|i
index|]
operator|.
name|new
operator|.
name|to
operator|=
name|d
expr_stmt|;
block|}
if|if
condition|(
name|i
condition|)
block|{
operator|(
operator|*
name|dd
operator|)
index|[
name|i
index|]
operator|.
name|old
operator|.
name|from
operator|=
operator|(
operator|*
name|dd
operator|)
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|old
operator|.
name|to
expr_stmt|;
operator|(
operator|*
name|dd
operator|)
index|[
name|i
index|]
operator|.
name|new
operator|.
name|from
operator|=
operator|(
operator|*
name|dd
operator|)
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|new
operator|.
name|to
expr_stmt|;
block|}
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|diffexec
parameter_list|(
specifier|const
name|char
modifier|*
name|diffprog
parameter_list|,
name|char
modifier|*
modifier|*
name|diffargv
parameter_list|,
name|int
name|fd
index|[]
parameter_list|)
block|{
name|int
name|pid
decl_stmt|,
name|pd
decl_stmt|;
switch|switch
condition|(
name|pid
operator|=
name|pdfork
argument_list|(
operator|&
name|pd
argument_list|,
name|PD_CLOEXEC
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
name|close
argument_list|(
name|fd
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|dup2
argument_list|(
name|fd
index|[
literal|1
index|]
argument_list|,
name|STDOUT_FILENO
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|2
argument_list|,
literal|"child could not duplicate descriptor"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|execvp
argument_list|(
name|diffprog
argument_list|,
name|diffargv
argument_list|)
expr_stmt|;
name|err
argument_list|(
literal|2
argument_list|,
literal|"could not execute diff: %s"
argument_list|,
name|diffprog
argument_list|)
expr_stmt|;
break|break;
case|case
operator|-
literal|1
case|:
name|err
argument_list|(
literal|2
argument_list|,
literal|"could not fork"
argument_list|)
expr_stmt|;
break|break;
block|}
name|close
argument_list|(
name|fd
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|pd
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|number
parameter_list|(
name|char
modifier|*
modifier|*
name|lc
parameter_list|)
block|{
name|int
name|nn
decl_stmt|;
name|nn
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
call|(
name|unsigned
name|char
call|)
argument_list|(
operator|*
operator|*
name|lc
argument_list|)
argument_list|)
condition|)
name|nn
operator|=
name|nn
operator|*
literal|10
operator|+
operator|*
operator|(
operator|*
name|lc
operator|)
operator|++
operator|-
literal|'0'
expr_stmt|;
return|return
operator|(
name|nn
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|getchange
parameter_list|(
name|FILE
modifier|*
name|b
parameter_list|)
block|{
name|char
modifier|*
name|line
decl_stmt|;
while|while
condition|(
operator|(
name|line
operator|=
name|get_line
argument_list|(
name|b
argument_list|,
name|NULL
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|line
index|[
literal|0
index|]
argument_list|)
condition|)
return|return
operator|(
name|line
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|get_line
parameter_list|(
name|FILE
modifier|*
name|b
parameter_list|,
name|size_t
modifier|*
name|n
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|size_t
name|len
decl_stmt|;
specifier|static
name|char
modifier|*
name|buf
decl_stmt|;
specifier|static
name|size_t
name|bufsize
decl_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|fgetln
argument_list|(
name|b
argument_list|,
operator|&
name|len
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|cp
index|[
name|len
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
name|len
operator|++
expr_stmt|;
if|if
condition|(
name|len
operator|+
literal|1
operator|>
name|bufsize
condition|)
block|{
do|do
block|{
name|bufsize
operator|+=
literal|1024
expr_stmt|;
block|}
do|while
condition|(
name|len
operator|+
literal|1
operator|>
name|bufsize
condition|)
do|;
if|if
condition|(
operator|(
name|buf
operator|=
name|realloc
argument_list|(
name|buf
argument_list|,
name|bufsize
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|buf
argument_list|,
name|cp
argument_list|,
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
name|buf
index|[
name|len
operator|-
literal|1
index|]
operator|=
literal|'\n'
expr_stmt|;
name|buf
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|n
operator|!=
name|NULL
condition|)
operator|*
name|n
operator|=
name|len
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|merge
parameter_list|(
name|int
name|m1
parameter_list|,
name|int
name|m2
parameter_list|)
block|{
name|struct
name|diff
modifier|*
name|d1
decl_stmt|,
modifier|*
name|d2
decl_stmt|,
modifier|*
name|d3
decl_stmt|;
name|int
name|j
decl_stmt|,
name|t1
decl_stmt|,
name|t2
decl_stmt|;
name|bool
name|dup
init|=
name|false
decl_stmt|;
name|d1
operator|=
name|d13
expr_stmt|;
name|d2
operator|=
name|d23
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|t1
operator|=
name|d1
operator|<
name|d13
operator|+
name|m1
operator|)
operator||
operator|(
name|t2
operator|=
name|d2
operator|<
name|d23
operator|+
name|m2
operator|)
condition|)
block|{
comment|/* first file is different from the others */
if|if
condition|(
operator|!
name|t2
operator|||
operator|(
name|t1
operator|&&
name|d1
operator|->
name|new
operator|.
name|to
operator|<
name|d2
operator|->
name|new
operator|.
name|from
operator|)
condition|)
block|{
comment|/* stuff peculiar to 1st file */
if|if
condition|(
name|eflag
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"====1\n"
argument_list|)
expr_stmt|;
name|change
argument_list|(
literal|1
argument_list|,
operator|&
name|d1
operator|->
name|old
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|keep
argument_list|(
literal|2
argument_list|,
operator|&
name|d1
operator|->
name|new
argument_list|)
expr_stmt|;
name|change
argument_list|(
literal|3
argument_list|,
operator|&
name|d1
operator|->
name|new
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
name|d1
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* second file is different from others */
if|if
condition|(
operator|!
name|t1
operator|||
operator|(
name|t2
operator|&&
name|d2
operator|->
name|new
operator|.
name|to
operator|<
name|d1
operator|->
name|new
operator|.
name|from
operator|)
condition|)
block|{
if|if
condition|(
name|eflag
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"====2\n"
argument_list|)
expr_stmt|;
name|keep
argument_list|(
literal|1
argument_list|,
operator|&
name|d2
operator|->
name|new
argument_list|)
expr_stmt|;
name|change
argument_list|(
literal|3
argument_list|,
operator|&
name|d2
operator|->
name|new
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|change
argument_list|(
literal|2
argument_list|,
operator|&
name|d2
operator|->
name|old
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
name|d2
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Merge overlapping changes in first file 		 * this happens after extension (see below). 		 */
if|if
condition|(
name|d1
operator|+
literal|1
operator|<
name|d13
operator|+
name|m1
operator|&&
name|d1
operator|->
name|new
operator|.
name|to
operator|>=
name|d1
index|[
literal|1
index|]
operator|.
name|new
operator|.
name|from
condition|)
block|{
name|d1
index|[
literal|1
index|]
operator|.
name|old
operator|.
name|from
operator|=
name|d1
operator|->
name|old
operator|.
name|from
expr_stmt|;
name|d1
index|[
literal|1
index|]
operator|.
name|new
operator|.
name|from
operator|=
name|d1
operator|->
name|new
operator|.
name|from
expr_stmt|;
name|d1
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* merge overlapping changes in second */
if|if
condition|(
name|d2
operator|+
literal|1
operator|<
name|d23
operator|+
name|m2
operator|&&
name|d2
operator|->
name|new
operator|.
name|to
operator|>=
name|d2
index|[
literal|1
index|]
operator|.
name|new
operator|.
name|from
condition|)
block|{
name|d2
index|[
literal|1
index|]
operator|.
name|old
operator|.
name|from
operator|=
name|d2
operator|->
name|old
operator|.
name|from
expr_stmt|;
name|d2
index|[
literal|1
index|]
operator|.
name|new
operator|.
name|from
operator|=
name|d2
operator|->
name|new
operator|.
name|from
expr_stmt|;
name|d2
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* stuff peculiar to third file or different in all */
if|if
condition|(
name|d1
operator|->
name|new
operator|.
name|from
operator|==
name|d2
operator|->
name|new
operator|.
name|from
operator|&&
name|d1
operator|->
name|new
operator|.
name|to
operator|==
name|d2
operator|->
name|new
operator|.
name|to
condition|)
block|{
name|dup
operator|=
name|duplicate
argument_list|(
operator|&
name|d1
operator|->
name|old
argument_list|,
operator|&
name|d2
operator|->
name|old
argument_list|)
expr_stmt|;
comment|/* 			 * dup = 0 means all files differ 			 * dup = 1 means files 1 and 2 identical 			 */
if|if
condition|(
name|eflag
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"====%s\n"
argument_list|,
name|dup
condition|?
literal|"3"
else|:
literal|""
argument_list|)
expr_stmt|;
name|change
argument_list|(
literal|1
argument_list|,
operator|&
name|d1
operator|->
name|old
argument_list|,
name|dup
argument_list|)
expr_stmt|;
name|change
argument_list|(
literal|2
argument_list|,
operator|&
name|d2
operator|->
name|old
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|d3
operator|=
name|d1
operator|->
name|old
operator|.
name|to
operator|>
name|d1
operator|->
name|old
operator|.
name|from
condition|?
name|d1
else|:
name|d2
expr_stmt|;
name|change
argument_list|(
literal|3
argument_list|,
operator|&
name|d3
operator|->
name|new
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
else|else
name|j
operator|=
name|edit
argument_list|(
name|d1
argument_list|,
name|dup
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|d1
operator|++
expr_stmt|;
name|d2
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Overlapping changes from file 1 and 2; extend changes 		 * appropriately to make them coincide. 		 */
if|if
condition|(
name|d1
operator|->
name|new
operator|.
name|from
operator|<
name|d2
operator|->
name|new
operator|.
name|from
condition|)
block|{
name|d2
operator|->
name|old
operator|.
name|from
operator|-=
name|d2
operator|->
name|new
operator|.
name|from
operator|-
name|d1
operator|->
name|new
operator|.
name|from
expr_stmt|;
name|d2
operator|->
name|new
operator|.
name|from
operator|=
name|d1
operator|->
name|new
operator|.
name|from
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|d2
operator|->
name|new
operator|.
name|from
operator|<
name|d1
operator|->
name|new
operator|.
name|from
condition|)
block|{
name|d1
operator|->
name|old
operator|.
name|from
operator|-=
name|d1
operator|->
name|new
operator|.
name|from
operator|-
name|d2
operator|->
name|new
operator|.
name|from
expr_stmt|;
name|d1
operator|->
name|new
operator|.
name|from
operator|=
name|d2
operator|->
name|new
operator|.
name|from
expr_stmt|;
block|}
if|if
condition|(
name|d1
operator|->
name|new
operator|.
name|to
operator|>
name|d2
operator|->
name|new
operator|.
name|to
condition|)
block|{
name|d2
operator|->
name|old
operator|.
name|to
operator|+=
name|d1
operator|->
name|new
operator|.
name|to
operator|-
name|d2
operator|->
name|new
operator|.
name|to
expr_stmt|;
name|d2
operator|->
name|new
operator|.
name|to
operator|=
name|d1
operator|->
name|new
operator|.
name|to
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|d2
operator|->
name|new
operator|.
name|to
operator|>
name|d1
operator|->
name|new
operator|.
name|to
condition|)
block|{
name|d1
operator|->
name|old
operator|.
name|to
operator|+=
name|d2
operator|->
name|new
operator|.
name|to
operator|-
name|d1
operator|->
name|new
operator|.
name|to
expr_stmt|;
name|d1
operator|->
name|new
operator|.
name|to
operator|=
name|d2
operator|->
name|new
operator|.
name|to
expr_stmt|;
block|}
block|}
if|if
condition|(
name|eflag
condition|)
name|edscript
argument_list|(
name|j
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * The range of lines rold.from thru rold.to in file i is to be changed.  * It is to be printed only if it does not duplicate something to be  * printed later.  */
end_comment

begin_function
specifier|static
name|void
name|change
parameter_list|(
name|int
name|i
parameter_list|,
name|struct
name|range
modifier|*
name|rold
parameter_list|,
name|bool
name|dup
parameter_list|)
block|{
name|printf
argument_list|(
literal|"%d:"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|last
index|[
name|i
index|]
operator|=
name|rold
operator|->
name|to
expr_stmt|;
name|prange
argument_list|(
name|rold
argument_list|)
expr_stmt|;
if|if
condition|(
name|dup
condition|)
return|return;
name|i
operator|--
expr_stmt|;
name|skip
argument_list|(
name|i
argument_list|,
name|rold
operator|->
name|from
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|skip
argument_list|(
name|i
argument_list|,
name|rold
operator|->
name|to
argument_list|,
literal|"  "
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Print the range of line numbers, rold.from thru rold.to, as n1,n2 or   * n1.  */
end_comment

begin_function
specifier|static
name|void
name|prange
parameter_list|(
name|struct
name|range
modifier|*
name|rold
parameter_list|)
block|{
if|if
condition|(
name|rold
operator|->
name|to
operator|<=
name|rold
operator|->
name|from
condition|)
name|printf
argument_list|(
literal|"%da\n"
argument_list|,
name|rold
operator|->
name|from
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
literal|"%d"
argument_list|,
name|rold
operator|->
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|rold
operator|->
name|to
operator|>
name|rold
operator|->
name|from
operator|+
literal|1
condition|)
name|printf
argument_list|(
literal|",%d"
argument_list|,
name|rold
operator|->
name|to
operator|-
literal|1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"c\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * No difference was reported by diff between file 1 (or 2) and file 3,  * and an artificial dummy difference (trange) must be ginned up to  * correspond to the change reported in the other file.  */
end_comment

begin_function
specifier|static
name|void
name|keep
parameter_list|(
name|int
name|i
parameter_list|,
name|struct
name|range
modifier|*
name|rnew
parameter_list|)
block|{
name|int
name|delta
decl_stmt|;
name|struct
name|range
name|trange
decl_stmt|;
name|delta
operator|=
name|last
index|[
literal|3
index|]
operator|-
name|last
index|[
name|i
index|]
expr_stmt|;
name|trange
operator|.
name|from
operator|=
name|rnew
operator|->
name|from
operator|-
name|delta
expr_stmt|;
name|trange
operator|.
name|to
operator|=
name|rnew
operator|->
name|to
operator|-
name|delta
expr_stmt|;
name|change
argument_list|(
name|i
argument_list|,
operator|&
name|trange
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * skip to just before line number from in file "i".  If "pr" is non-NULL,  * print all skipped stuff with string pr as a prefix.  */
end_comment

begin_function
specifier|static
name|int
name|skip
parameter_list|(
name|int
name|i
parameter_list|,
name|int
name|from
parameter_list|,
specifier|const
name|char
modifier|*
name|pr
parameter_list|)
block|{
name|size_t
name|j
decl_stmt|,
name|n
decl_stmt|;
name|char
modifier|*
name|line
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|cline
index|[
name|i
index|]
operator|<
name|from
operator|-
literal|1
condition|;
name|n
operator|+=
name|j
control|)
block|{
if|if
condition|(
operator|(
name|line
operator|=
name|get_line
argument_list|(
name|fp
index|[
name|i
index|]
argument_list|,
operator|&
name|j
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"logic error"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pr
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|"%s%s"
argument_list|,
name|Tflag
operator|==
literal|1
condition|?
literal|"\t"
else|:
name|pr
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|cline
index|[
name|i
index|]
operator|++
expr_stmt|;
block|}
return|return
operator|(
operator|(
name|int
operator|)
name|n
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return 1 or 0 according as the old range (in file 1) contains exactly  * the same data as the new range (in file 2).  */
end_comment

begin_function
specifier|static
name|bool
name|duplicate
parameter_list|(
name|struct
name|range
modifier|*
name|r1
parameter_list|,
name|struct
name|range
modifier|*
name|r2
parameter_list|)
block|{
name|int
name|c
decl_stmt|,
name|d
decl_stmt|;
name|int
name|nchar
decl_stmt|;
name|int
name|nline
decl_stmt|;
if|if
condition|(
name|r1
operator|->
name|to
operator|-
name|r1
operator|->
name|from
operator|!=
name|r2
operator|->
name|to
operator|-
name|r2
operator|->
name|from
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|skip
argument_list|(
literal|0
argument_list|,
name|r1
operator|->
name|from
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|skip
argument_list|(
literal|1
argument_list|,
name|r2
operator|->
name|from
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|nchar
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|nline
operator|=
literal|0
init|;
name|nline
operator|<
name|r1
operator|->
name|to
operator|-
name|r1
operator|->
name|from
condition|;
name|nline
operator|++
control|)
block|{
do|do
block|{
name|c
operator|=
name|getc
argument_list|(
name|fp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|d
operator|=
name|getc
argument_list|(
name|fp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
operator|-
literal|1
operator|||
name|d
operator|==
operator|-
literal|1
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"logic error"
argument_list|)
expr_stmt|;
name|nchar
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|d
condition|)
block|{
name|repos
argument_list|(
name|nchar
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
do|while
condition|(
name|c
operator|!=
literal|'\n'
condition|)
do|;
block|}
name|repos
argument_list|(
name|nchar
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|repos
parameter_list|(
name|int
name|nchar
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
operator|(
name|void
operator|)
name|fseek
argument_list|(
name|fp
index|[
name|i
index|]
argument_list|,
operator|(
name|long
operator|)
operator|-
name|nchar
argument_list|,
name|SEEK_CUR
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * collect an editing script for later regurgitation  */
end_comment

begin_function
specifier|static
name|int
name|edit
parameter_list|(
name|struct
name|diff
modifier|*
name|diff
parameter_list|,
name|bool
name|dup
parameter_list|,
name|int
name|j
parameter_list|)
block|{
if|if
condition|(
operator|(
operator|(
name|dup
operator|+
literal|1
operator|)
operator|&
name|eflag
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|j
operator|)
return|;
name|j
operator|++
expr_stmt|;
name|overlap
index|[
name|j
index|]
operator|=
operator|!
name|dup
expr_stmt|;
if|if
condition|(
operator|!
name|dup
condition|)
name|overlapcnt
operator|++
expr_stmt|;
name|de
index|[
name|j
index|]
operator|.
name|old
operator|.
name|from
operator|=
name|diff
operator|->
name|old
operator|.
name|from
expr_stmt|;
name|de
index|[
name|j
index|]
operator|.
name|old
operator|.
name|to
operator|=
name|diff
operator|->
name|old
operator|.
name|to
expr_stmt|;
name|de
index|[
name|j
index|]
operator|.
name|new
operator|.
name|from
operator|=
name|de
index|[
name|j
operator|-
literal|1
index|]
operator|.
name|new
operator|.
name|to
operator|+
name|skip
argument_list|(
literal|2
argument_list|,
name|diff
operator|->
name|new
operator|.
name|from
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|de
index|[
name|j
index|]
operator|.
name|new
operator|.
name|to
operator|=
name|de
index|[
name|j
index|]
operator|.
name|new
operator|.
name|from
operator|+
name|skip
argument_list|(
literal|2
argument_list|,
name|diff
operator|->
name|new
operator|.
name|to
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|j
operator|)
return|;
block|}
end_function

begin_comment
comment|/* regurgitate */
end_comment

begin_function
specifier|static
name|void
name|edscript
parameter_list|(
name|int
name|n
parameter_list|)
block|{
name|int
name|k
decl_stmt|;
name|size_t
name|j
decl_stmt|;
name|char
name|block
index|[
name|BUFSIZ
index|]
decl_stmt|;
for|for
control|(
init|;
name|n
operator|>
literal|0
condition|;
name|n
operator|--
control|)
block|{
if|if
condition|(
operator|!
name|oflag
operator|||
operator|!
name|overlap
index|[
name|n
index|]
condition|)
block|{
name|prange
argument_list|(
operator|&
name|de
index|[
name|n
index|]
operator|.
name|old
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"%da\n"
argument_list|,
name|de
index|[
name|n
index|]
operator|.
name|old
operator|.
name|to
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|Aflag
condition|)
block|{
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|f2mark
argument_list|)
expr_stmt|;
name|fseek
argument_list|(
name|fp
index|[
literal|1
index|]
argument_list|,
name|de
index|[
name|n
index|]
operator|.
name|old
operator|.
name|from
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
name|de
index|[
name|n
index|]
operator|.
name|old
operator|.
name|to
operator|-
name|de
index|[
name|n
index|]
operator|.
name|old
operator|.
name|from
init|;
name|k
operator|>
literal|0
condition|;
name|k
operator|-=
name|j
control|)
block|{
name|j
operator|=
name|k
operator|>
name|BUFSIZ
condition|?
name|BUFSIZ
else|:
name|k
expr_stmt|;
if|if
condition|(
name|fread
argument_list|(
name|block
argument_list|,
literal|1
argument_list|,
name|j
argument_list|,
name|fp
index|[
literal|1
index|]
argument_list|)
operator|!=
name|j
condition|)
name|errx
argument_list|(
literal|2
argument_list|,
literal|"logic error"
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
name|block
argument_list|,
literal|1
argument_list|,
name|j
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"=======\n"
argument_list|)
expr_stmt|;
block|}
name|fseek
argument_list|(
name|fp
index|[
literal|2
index|]
argument_list|,
operator|(
name|long
operator|)
name|de
index|[
name|n
index|]
operator|.
name|new
operator|.
name|from
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
name|de
index|[
name|n
index|]
operator|.
name|new
operator|.
name|to
operator|-
name|de
index|[
name|n
index|]
operator|.
name|new
operator|.
name|from
init|;
name|k
operator|>
literal|0
condition|;
name|k
operator|-=
name|j
control|)
block|{
name|j
operator|=
name|k
operator|>
name|BUFSIZ
condition|?
name|BUFSIZ
else|:
name|k
expr_stmt|;
if|if
condition|(
name|fread
argument_list|(
name|block
argument_list|,
literal|1
argument_list|,
name|j
argument_list|,
name|fp
index|[
literal|2
index|]
argument_list|)
operator|!=
name|j
condition|)
name|errx
argument_list|(
literal|2
argument_list|,
literal|"logic error"
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
name|block
argument_list|,
literal|1
argument_list|,
name|j
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|oflag
operator|||
operator|!
name|overlap
index|[
name|n
index|]
condition|)
name|printf
argument_list|(
literal|".\n"
argument_list|)
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
literal|"%s\n.\n"
argument_list|,
name|f3mark
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%da\n%s\n.\n"
argument_list|,
name|de
index|[
name|n
index|]
operator|.
name|old
operator|.
name|from
operator|-
literal|1
argument_list|,
name|f1mark
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|iflag
condition|)
name|printf
argument_list|(
literal|"w\nq\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|eflag
operator|==
literal|0
condition|?
name|overlapcnt
else|:
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|increase
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|diff
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|q
decl_stmt|;
name|size_t
name|newsz
decl_stmt|,
name|incr
decl_stmt|;
comment|/* are the memset(3) calls needed? */
name|newsz
operator|=
name|szchanges
operator|==
literal|0
condition|?
literal|64
else|:
literal|2
operator|*
name|szchanges
expr_stmt|;
name|incr
operator|=
name|newsz
operator|-
name|szchanges
expr_stmt|;
name|p
operator|=
name|realloc
argument_list|(
name|d13
argument_list|,
name|newsz
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|diff
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|p
operator|+
name|szchanges
argument_list|,
literal|0
argument_list|,
name|incr
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|diff
argument_list|)
argument_list|)
expr_stmt|;
name|d13
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|realloc
argument_list|(
name|d23
argument_list|,
name|newsz
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|diff
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|p
operator|+
name|szchanges
argument_list|,
literal|0
argument_list|,
name|incr
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|diff
argument_list|)
argument_list|)
expr_stmt|;
name|d23
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|realloc
argument_list|(
name|de
argument_list|,
name|newsz
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|diff
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|p
operator|+
name|szchanges
argument_list|,
literal|0
argument_list|,
name|incr
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|diff
argument_list|)
argument_list|)
expr_stmt|;
name|de
operator|=
name|p
expr_stmt|;
name|q
operator|=
name|realloc
argument_list|(
name|overlap
argument_list|,
name|newsz
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|q
operator|+
name|szchanges
argument_list|,
literal|0
argument_list|,
name|incr
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|overlap
operator|=
name|q
expr_stmt|;
name|szchanges
operator|=
name|newsz
expr_stmt|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|ch
decl_stmt|,
name|nblabels
decl_stmt|,
name|status
decl_stmt|,
name|m
decl_stmt|,
name|n
decl_stmt|,
name|kq
decl_stmt|,
name|nke
decl_stmt|,
name|nleft
decl_stmt|,
name|i
decl_stmt|;
name|char
modifier|*
name|labels
index|[]
init|=
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
specifier|const
name|char
modifier|*
name|diffprog
init|=
name|DIFF_PATH
decl_stmt|;
name|char
modifier|*
name|file1
decl_stmt|,
modifier|*
name|file2
decl_stmt|,
modifier|*
name|file3
decl_stmt|;
name|char
modifier|*
name|diffargv
index|[
literal|6
index|]
decl_stmt|;
name|int
name|diffargc
init|=
literal|0
decl_stmt|;
name|int
name|fd13
index|[
literal|2
index|]
decl_stmt|,
name|fd23
index|[
literal|2
index|]
decl_stmt|;
name|int
name|pd13
decl_stmt|,
name|pd23
decl_stmt|;
name|cap_rights_t
name|rights_ro
decl_stmt|;
name|struct
name|kevent
modifier|*
name|e
decl_stmt|;
name|nblabels
operator|=
literal|0
expr_stmt|;
name|eflag
operator|=
literal|0
expr_stmt|;
name|oflag
operator|=
literal|0
expr_stmt|;
name|diffargv
index|[
name|diffargc
operator|++
index|]
operator|=
name|__DECONST
argument_list|(
name|char
operator|*
argument_list|,
name|diffprog
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|getopt_long
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|OPTIONS
argument_list|,
name|longopts
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'3'
case|:
name|eflag
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|diffargv
index|[
name|diffargc
operator|++
index|]
operator|=
name|__DECONST
argument_list|(
name|char
operator|*
argument_list|,
literal|"-a"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
name|Aflag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|eflag
operator|=
literal|3
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
name|eflag
operator|=
literal|3
expr_stmt|;
name|oflag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|iflag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
name|oflag
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|nblabels
operator|>=
literal|3
condition|)
name|errx
argument_list|(
literal|2
argument_list|,
literal|"too many file label options"
argument_list|)
expr_stmt|;
name|labels
index|[
name|nblabels
operator|++
index|]
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|Aflag
operator|=
literal|1
expr_stmt|;
name|oflag
operator|=
literal|1
expr_stmt|;
name|mflag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
name|Tflag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|eflag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
name|oflag
operator|=
literal|1
expr_stmt|;
name|eflag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|DIFFPROG_OPT
case|:
name|diffprog
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
name|STRIPCR_OPT
case|:
name|strip_cr
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|Aflag
condition|)
block|{
name|eflag
operator|=
literal|3
expr_stmt|;
name|oflag
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|!=
literal|3
condition|)
name|usage
argument_list|()
expr_stmt|;
if|if
condition|(
name|caph_limit_stdio
argument_list|()
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|2
argument_list|,
literal|"unable to limit stdio"
argument_list|)
expr_stmt|;
name|cap_rights_init
argument_list|(
operator|&
name|rights_ro
argument_list|,
name|CAP_READ
argument_list|,
name|CAP_FSTAT
argument_list|,
name|CAP_SEEK
argument_list|)
expr_stmt|;
name|kq
operator|=
name|kqueue
argument_list|()
expr_stmt|;
if|if
condition|(
name|kq
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|2
argument_list|,
literal|"kqueue"
argument_list|)
expr_stmt|;
name|e
operator|=
name|malloc
argument_list|(
literal|2
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|kevent
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|2
argument_list|,
literal|"malloc"
argument_list|)
expr_stmt|;
comment|/* TODO stdio */
name|file1
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|file2
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
name|file3
operator|=
name|argv
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|oflag
condition|)
block|{
name|asprintf
argument_list|(
operator|&
name|f1mark
argument_list|,
literal|"<<<<<<< %s"
argument_list|,
name|labels
index|[
literal|0
index|]
operator|!=
name|NULL
condition|?
name|labels
index|[
literal|0
index|]
else|:
name|file1
argument_list|)
expr_stmt|;
if|if
condition|(
name|f1mark
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|2
argument_list|,
literal|"asprintf"
argument_list|)
expr_stmt|;
name|asprintf
argument_list|(
operator|&
name|f2mark
argument_list|,
literal|"||||||| %s"
argument_list|,
name|labels
index|[
literal|1
index|]
operator|!=
name|NULL
condition|?
name|labels
index|[
literal|1
index|]
else|:
name|file2
argument_list|)
expr_stmt|;
if|if
condition|(
name|f2mark
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|2
argument_list|,
literal|"asprintf"
argument_list|)
expr_stmt|;
name|asprintf
argument_list|(
operator|&
name|f3mark
argument_list|,
literal|">>>>>>> %s"
argument_list|,
name|labels
index|[
literal|2
index|]
operator|!=
name|NULL
condition|?
name|labels
index|[
literal|2
index|]
else|:
name|file3
argument_list|)
expr_stmt|;
if|if
condition|(
name|f3mark
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|2
argument_list|,
literal|"asprintf"
argument_list|)
expr_stmt|;
block|}
name|fp
index|[
literal|0
index|]
operator|=
name|fopen
argument_list|(
name|file1
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
index|[
literal|0
index|]
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|2
argument_list|,
literal|"Can't open %s"
argument_list|,
name|file1
argument_list|)
expr_stmt|;
if|if
condition|(
name|cap_rights_limit
argument_list|(
name|fileno
argument_list|(
name|fp
index|[
literal|0
index|]
argument_list|)
argument_list|,
operator|&
name|rights_ro
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|2
argument_list|,
literal|"unable to limit rights on: %s"
argument_list|,
name|file1
argument_list|)
expr_stmt|;
name|fp
index|[
literal|1
index|]
operator|=
name|fopen
argument_list|(
name|file2
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
index|[
literal|1
index|]
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|2
argument_list|,
literal|"Can't open %s"
argument_list|,
name|file2
argument_list|)
expr_stmt|;
if|if
condition|(
name|cap_rights_limit
argument_list|(
name|fileno
argument_list|(
name|fp
index|[
literal|1
index|]
argument_list|)
argument_list|,
operator|&
name|rights_ro
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|2
argument_list|,
literal|"unable to limit rights on: %s"
argument_list|,
name|file2
argument_list|)
expr_stmt|;
name|fp
index|[
literal|2
index|]
operator|=
name|fopen
argument_list|(
name|file3
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
index|[
literal|2
index|]
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|2
argument_list|,
literal|"Can't open %s"
argument_list|,
name|file3
argument_list|)
expr_stmt|;
if|if
condition|(
name|cap_rights_limit
argument_list|(
name|fileno
argument_list|(
name|fp
index|[
literal|2
index|]
argument_list|)
argument_list|,
operator|&
name|rights_ro
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|2
argument_list|,
literal|"unable to limit rights on: %s"
argument_list|,
name|file3
argument_list|)
expr_stmt|;
if|if
condition|(
name|pipe
argument_list|(
name|fd13
argument_list|)
condition|)
name|err
argument_list|(
literal|2
argument_list|,
literal|"pipe"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pipe
argument_list|(
name|fd23
argument_list|)
condition|)
name|err
argument_list|(
literal|2
argument_list|,
literal|"pipe"
argument_list|)
expr_stmt|;
name|diffargv
index|[
name|diffargc
index|]
operator|=
name|file1
expr_stmt|;
name|diffargv
index|[
name|diffargc
operator|+
literal|1
index|]
operator|=
name|file3
expr_stmt|;
name|diffargv
index|[
name|diffargc
operator|+
literal|2
index|]
operator|=
name|NULL
expr_stmt|;
name|nleft
operator|=
literal|0
expr_stmt|;
name|pd13
operator|=
name|diffexec
argument_list|(
name|diffprog
argument_list|,
name|diffargv
argument_list|,
name|fd13
argument_list|)
expr_stmt|;
name|EV_SET
argument_list|(
name|e
operator|+
name|nleft
argument_list|,
name|pd13
argument_list|,
name|EVFILT_PROCDESC
argument_list|,
name|EV_ADD
argument_list|,
name|NOTE_EXIT
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|kevent
argument_list|(
name|kq
argument_list|,
name|e
operator|+
name|nleft
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|2
argument_list|,
literal|"kevent1"
argument_list|)
expr_stmt|;
name|nleft
operator|++
expr_stmt|;
name|diffargv
index|[
name|diffargc
index|]
operator|=
name|file2
expr_stmt|;
name|pd23
operator|=
name|diffexec
argument_list|(
name|diffprog
argument_list|,
name|diffargv
argument_list|,
name|fd23
argument_list|)
expr_stmt|;
name|EV_SET
argument_list|(
name|e
operator|+
name|nleft
argument_list|,
name|pd23
argument_list|,
name|EVFILT_PROCDESC
argument_list|,
name|EV_ADD
argument_list|,
name|NOTE_EXIT
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|kevent
argument_list|(
name|kq
argument_list|,
name|e
operator|+
name|nleft
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|2
argument_list|,
literal|"kevent2"
argument_list|)
expr_stmt|;
name|nleft
operator|++
expr_stmt|;
name|caph_cache_catpages
argument_list|()
expr_stmt|;
if|if
condition|(
name|cap_enter
argument_list|()
operator|<
literal|0
operator|&&
name|errno
operator|!=
name|ENOSYS
condition|)
name|err
argument_list|(
literal|2
argument_list|,
literal|"unable to enter capability mode"
argument_list|)
expr_stmt|;
comment|/* parse diffs */
name|increase
argument_list|()
expr_stmt|;
name|m
operator|=
name|readin
argument_list|(
name|fd13
index|[
literal|0
index|]
argument_list|,
operator|&
name|d13
argument_list|)
expr_stmt|;
name|n
operator|=
name|readin
argument_list|(
name|fd23
index|[
literal|0
index|]
argument_list|,
operator|&
name|d23
argument_list|)
expr_stmt|;
comment|/* waitpid cooked over pdforks */
while|while
condition|(
name|nleft
operator|>
literal|0
condition|)
block|{
name|nke
operator|=
name|kevent
argument_list|(
name|kq
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|e
argument_list|,
name|nleft
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|nke
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|2
argument_list|,
literal|"kevent"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nke
condition|;
name|i
operator|++
control|)
block|{
name|status
operator|=
name|e
index|[
name|i
index|]
operator|.
name|data
expr_stmt|;
if|if
condition|(
name|WIFEXITED
argument_list|(
name|status
argument_list|)
operator|&&
name|WEXITSTATUS
argument_list|(
name|status
argument_list|)
operator|>=
literal|2
condition|)
name|errx
argument_list|(
literal|2
argument_list|,
literal|"diff exited abormally"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|WIFSIGNALED
argument_list|(
name|status
argument_list|)
condition|)
name|errx
argument_list|(
literal|2
argument_list|,
literal|"diff killed by signal %d"
argument_list|,
name|WTERMSIG
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|nleft
operator|-=
name|nke
expr_stmt|;
block|}
name|merge
argument_list|(
name|m
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
operator|(
name|EXIT_SUCCESS
operator|)
return|;
block|}
end_function

end_unit

