begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* elvrec.c */
end_comment

begin_comment
comment|/* This file contains the file recovery program */
end_comment

begin_comment
comment|/* Author:  *	Steve Kirkendall  *	14407 SW Teal Blvd. #C  *	Beaverton, OR 97005  *	kirkenda@cs.pdx.edu  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"vi.h"
end_include

begin_decl_stmt
name|void
name|recover
name|P_
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
decl|main
name|P_
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|recover
parameter_list|(
name|basename
parameter_list|,
name|outname
parameter_list|)
name|char
modifier|*
name|basename
decl_stmt|;
comment|/* the name of the file to recover */
name|char
modifier|*
name|outname
decl_stmt|;
comment|/* the name of the file to write to */
block|{
name|char
name|pathname
index|[
literal|500
index|]
decl_stmt|;
comment|/* full pathname of the file to recover */
name|char
name|line
index|[
literal|600
index|]
decl_stmt|;
comment|/* a line from the /usr/preserve/Index file */
name|int
name|ch
decl_stmt|;
comment|/* a character from the text being recovered */
name|FILE
modifier|*
name|from
decl_stmt|;
comment|/* the /usr/preserve file, or /usr/preserve/Index */
name|FILE
modifier|*
name|to
decl_stmt|;
comment|/* the user's text file */
name|char
modifier|*
name|ptr
decl_stmt|;
if|#
directive|if
name|OSK
name|int
name|uid
decl_stmt|;
endif|#
directive|endif
comment|/* convert basename to a full pathname */
if|if
condition|(
name|basename
condition|)
block|{
ifndef|#
directive|ifndef
name|CRUNCH
if|#
directive|if
name|MSDOS
operator|||
name|TOS
if|if
condition|(
operator|!
name|basename
index|[
literal|0
index|]
operator|||
name|basename
index|[
literal|1
index|]
operator|!=
literal|':'
condition|)
else|#
directive|else
if|if
condition|(
name|basename
index|[
literal|0
index|]
operator|!=
name|SLASH
condition|)
endif|#
directive|endif
block|{
name|ptr
operator|=
name|getcwd
argument_list|(
name|pathname
argument_list|,
sizeof|sizeof
name|pathname
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|!=
name|pathname
condition|)
block|{
name|strcpy
argument_list|(
name|pathname
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
block|}
name|ptr
operator|=
name|pathname
operator|+
name|strlen
argument_list|(
name|pathname
argument_list|)
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
name|SLASH
expr_stmt|;
name|strcpy
argument_list|(
name|ptr
argument_list|,
name|basename
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|strcpy
argument_list|(
name|pathname
argument_list|,
name|basename
argument_list|)
expr_stmt|;
block|}
block|}
if|#
directive|if
name|OSK
name|uid
operator|=
name|getuid
argument_list|()
expr_stmt|;
if|if
condition|(
name|setuid
argument_list|(
literal|0
argument_list|)
condition|)
name|exit
argument_list|(
name|_errmsg
argument_list|(
name|errno
argument_list|,
literal|"Can't set uid\n"
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* scan the /usr/preserve/Index file, for the *oldest* unrecovered 	 * version of this file. 	 */
name|from
operator|=
name|fopen
argument_list|(
name|PRSVINDEX
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
while|while
condition|(
name|from
operator|&&
name|fgets
argument_list|(
name|line
argument_list|,
sizeof|sizeof
name|line
argument_list|,
name|from
argument_list|)
condition|)
block|{
comment|/* strip off the newline from the end of the string */
name|line
index|[
name|strlen
argument_list|(
name|line
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* parse the line into a "preserve" name and a "text" name */
for|for
control|(
name|ptr
operator|=
name|line
init|;
operator|*
name|ptr
operator|!=
literal|' '
condition|;
name|ptr
operator|++
control|)
block|{ 		}
operator|*
name|ptr
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* If the "preserve" file is missing, then ignore this line 		 * because it describes a file that has already been recovered. 		 */
if|if
condition|(
name|access
argument_list|(
name|line
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
continue|continue;
block|}
comment|/* are we looking for a specific file? */
if|if
condition|(
name|basename
condition|)
block|{
comment|/* quit if we found it */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ptr
argument_list|,
name|pathname
argument_list|)
condition|)
block|{
break|break;
block|}
block|}
else|else
block|{
comment|/* list this file as "available for recovery" */
name|puts
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* file not found? */
if|if
condition|(
operator|!
name|basename
operator|||
operator|!
name|from
operator|||
name|feof
argument_list|(
name|from
argument_list|)
condition|)
block|{
if|if
condition|(
name|from
operator|!=
name|NULL
condition|)
name|fclose
argument_list|(
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|basename
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: no recovered file has that exact name\n"
argument_list|,
name|pathname
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|from
operator|!=
name|NULL
condition|)
name|fclose
argument_list|(
name|from
argument_list|)
expr_stmt|;
comment|/* copy the recovered text back into the user's file... */
comment|/* open the /usr/preserve file for reading */
name|from
operator|=
name|fopen
argument_list|(
name|line
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|from
condition|)
block|{
name|perror
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|ANY_UNIX
comment|/* Be careful about user-id.  We want to be running under the user's 	 * real id when we open/create the user's text file... but we want 	 * to be superuser when we delete the /usr/preserve file.  For UNIX, 	 * we accomplish this by deleting the /usr/preserve file *now*, 	 * when it is open but before we've read it.  Then we revert to the 	 * user's real id. 	 */
name|unlink
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|setuid
argument_list|(
name|getuid
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|OSK
name|setuid
argument_list|(
name|uid
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|outname
operator|==
name|NULL
condition|)
return|return;
comment|/* open the user's file for writing */
name|to
operator|=
name|fopen
argument_list|(
name|outname
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|to
condition|)
block|{
name|perror
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
comment|/* copy the text */
while|while
condition|(
operator|(
name|ch
operator|=
name|getc
argument_list|(
name|from
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
name|putc
argument_list|(
name|ch
argument_list|,
name|to
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
operator|!
name|ANY_UNIX
if|#
directive|if
name|OSK
name|fclose
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|setuid
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* delete the /usr/preserve file */
name|unlink
argument_list|(
name|line
argument_list|)
expr_stmt|;
if|#
directive|if
name|OSK
name|setuid
argument_list|(
name|uid
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
comment|/* check arguments */
if|if
condition|(
name|argc
operator|>
literal|3
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: %s [preserved_file [recovery_file]]\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
comment|/* recover the requested file, or list recoverable files */
if|if
condition|(
name|argc
operator|==
literal|3
condition|)
block|{
comment|/* recover the file, but write it to a different filename */
name|recover
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argc
operator|==
literal|2
condition|)
block|{
comment|/* recover the file */
name|recover
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* list the recoverable files */
name|recover
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* success! */
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

