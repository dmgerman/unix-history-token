begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2003-2007 Tim Kientzle  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer  *    in this position and unchanged.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"cpio_platform.h"
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<archive.h>
end_include

begin_include
include|#
directive|include
file|<archive_entry.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_STAT_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_ERRNO_H
end_ifdef

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_FCNTL_H
end_ifdef

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STDARG_H
end_ifdef

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STDLIB_H
end_ifdef

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STRING_H
end_ifdef

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_UNISTD_H
end_ifdef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"cpio.h"
end_include

begin_include
include|#
directive|include
file|"matching.h"
end_include

begin_function_decl
specifier|static
name|int
name|copy_data
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|cpio_rename
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|entry_to_archive
parameter_list|(
name|struct
name|cpio
modifier|*
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|file_to_archive
parameter_list|(
name|struct
name|cpio
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|long_help
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mode_in
parameter_list|(
name|struct
name|cpio
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mode_list
parameter_list|(
name|struct
name|cpio
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mode_out
parameter_list|(
name|struct
name|cpio
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mode_pass
parameter_list|(
name|struct
name|cpio
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|restore_time
parameter_list|(
name|struct
name|cpio
modifier|*
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
name|fd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|version
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
specifier|static
name|char
name|buff
index|[
literal|16384
index|]
decl_stmt|;
name|struct
name|cpio
name|_cpio
decl_stmt|;
comment|/* Allocated on stack. */
name|struct
name|cpio
modifier|*
name|cpio
decl_stmt|;
name|int
name|uid
decl_stmt|,
name|gid
decl_stmt|;
name|int
name|opt
decl_stmt|;
name|cpio
operator|=
operator|&
name|_cpio
expr_stmt|;
name|memset
argument_list|(
name|cpio
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cpio
argument_list|)
argument_list|)
expr_stmt|;
name|cpio
operator|->
name|buff
operator|=
name|buff
expr_stmt|;
name|cpio
operator|->
name|buff_size
operator|=
sizeof|sizeof
argument_list|(
name|buff
argument_list|)
expr_stmt|;
comment|/* Need cpio_progname before calling cpio_warnc. */
if|if
condition|(
operator|*
name|argv
operator|==
name|NULL
condition|)
name|cpio_progname
operator|=
literal|"bsdcpio"
expr_stmt|;
else|else
block|{
name|cpio_progname
operator|=
name|strrchr
argument_list|(
operator|*
name|argv
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpio_progname
operator|!=
name|NULL
condition|)
name|cpio_progname
operator|++
expr_stmt|;
else|else
name|cpio_progname
operator|=
operator|*
name|argv
expr_stmt|;
block|}
name|cpio
operator|->
name|uid_override
operator|=
operator|-
literal|1
expr_stmt|;
name|cpio
operator|->
name|gid_override
operator|=
operator|-
literal|1
expr_stmt|;
name|cpio
operator|->
name|argv
operator|=
name|argv
expr_stmt|;
name|cpio
operator|->
name|argc
operator|=
name|argc
expr_stmt|;
name|cpio
operator|->
name|line_separator
operator|=
literal|'\n'
expr_stmt|;
name|cpio
operator|->
name|mode
operator|=
literal|'\0'
expr_stmt|;
name|cpio
operator|->
name|verbose
operator|=
literal|0
expr_stmt|;
name|cpio
operator|->
name|compress
operator|=
literal|'\0'
expr_stmt|;
comment|/* TODO: Implement old binary format in libarchive, use that here. */
name|cpio
operator|->
name|format
operator|=
literal|"odc"
expr_stmt|;
comment|/* Default format */
name|cpio
operator|->
name|extract_flags
operator|=
name|ARCHIVE_EXTRACT_NO_AUTODIR
expr_stmt|;
name|cpio
operator|->
name|extract_flags
operator||=
name|ARCHIVE_EXTRACT_NO_OVERWRITE_NEWER
expr_stmt|;
name|cpio
operator|->
name|extract_flags
operator||=
name|ARCHIVE_EXTRACT_SECURE_SYMLINKS
expr_stmt|;
name|cpio
operator|->
name|extract_flags
operator||=
name|ARCHIVE_EXTRACT_SECURE_NODOTDOT
expr_stmt|;
if|if
condition|(
name|geteuid
argument_list|()
operator|==
literal|0
condition|)
name|cpio
operator|->
name|extract_flags
operator||=
name|ARCHIVE_EXTRACT_OWNER
expr_stmt|;
name|cpio
operator|->
name|bytes_per_block
operator|=
literal|512
expr_stmt|;
name|cpio
operator|->
name|filename
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|opt
operator|=
name|cpio_getopt
argument_list|(
name|cpio
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|opt
condition|)
block|{
case|case
literal|'0'
case|:
comment|/* GNU convention: --null, -0 */
name|cpio
operator|->
name|line_separator
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
comment|/* NetBSD/OpenBSD */
name|cpio
operator|->
name|option_append
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
comment|/* POSIX 1997 */
name|cpio
operator|->
name|option_atime_restore
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
comment|/* POSIX 1997 */
name|cpio
operator|->
name|bytes_per_block
operator|=
literal|5120
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
comment|/* NetBSD/OpenBSD */
name|cpio
operator|->
name|bytes_per_block
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpio
operator|->
name|bytes_per_block
operator|<=
literal|0
condition|)
name|cpio_errc
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Invalid blocksize %s"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
comment|/* POSIX 1997 */
name|cpio
operator|->
name|format
operator|=
literal|"odc"
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
comment|/* POSIX 1997 */
name|cpio
operator|->
name|extract_flags
operator|&=
operator|~
name|ARCHIVE_EXTRACT_NO_AUTODIR
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
comment|/* NetBSD/OpenBSD */
name|include_from_file
argument_list|(
name|cpio
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
comment|/* NetBSD/OpenBSD/GNU cpio */
name|cpio
operator|->
name|filename
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
comment|/* POSIX 1997 */
name|exclude
argument_list|(
name|cpio
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
comment|/* GNU cpio (also --format) */
name|cpio
operator|->
name|format
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|long_help
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
comment|/* NetBSD/OpenBSD */
name|cpio
operator|->
name|filename
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
comment|/* POSIX 1997 */
name|cpio
operator|->
name|mode
operator|=
name|opt
expr_stmt|;
break|break;
case|case
name|OPTION_INSECURE
case|:
name|cpio
operator|->
name|extract_flags
operator|&=
operator|~
name|ARCHIVE_EXTRACT_SECURE_SYMLINKS
expr_stmt|;
name|cpio
operator|->
name|extract_flags
operator|&=
operator|~
name|ARCHIVE_EXTRACT_SECURE_NODOTDOT
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
comment|/* GNU cpio */
name|cpio
operator|->
name|option_follow_links
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
comment|/* POSIX 1997 */
name|cpio
operator|->
name|option_link
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
comment|/* POSIX 1997 */
name|cpio
operator|->
name|extract_flags
operator||=
name|ARCHIVE_EXTRACT_TIME
expr_stmt|;
break|break;
case|case
name|OPTION_NO_PRESERVE_OWNER
case|:
comment|/* GNU cpio */
name|cpio
operator|->
name|extract_flags
operator|&=
operator|~
name|ARCHIVE_EXTRACT_OWNER
expr_stmt|;
break|break;
case|case
literal|'O'
case|:
comment|/* GNU cpio */
name|cpio
operator|->
name|filename
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
comment|/* POSIX 1997 */
name|cpio
operator|->
name|mode
operator|=
name|opt
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
comment|/* POSIX 1997 */
name|cpio
operator|->
name|mode
operator|=
name|opt
expr_stmt|;
name|cpio
operator|->
name|extract_flags
operator|&=
operator|~
name|ARCHIVE_EXTRACT_SECURE_NODOTDOT
expr_stmt|;
break|break;
case|case
name|OPTION_QUIET
case|:
comment|/* GNU cpio */
name|cpio
operator|->
name|quiet
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
comment|/* GNU cpio, also --owner */
if|if
condition|(
name|owner_parse
argument_list|(
name|optarg
argument_list|,
operator|&
name|uid
argument_list|,
operator|&
name|gid
argument_list|)
condition|)
name|usage
argument_list|()
expr_stmt|;
if|if
condition|(
name|uid
operator|!=
operator|-
literal|1
condition|)
name|cpio
operator|->
name|uid_override
operator|=
name|uid
expr_stmt|;
if|if
condition|(
name|gid
operator|!=
operator|-
literal|1
condition|)
name|cpio
operator|->
name|gid_override
operator|=
name|gid
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
comment|/* POSIX 1997 */
name|cpio
operator|->
name|option_rename
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
comment|/* POSIX 1997 */
name|cpio
operator|->
name|option_list
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
comment|/* POSIX 1997 */
name|cpio
operator|->
name|extract_flags
operator|&=
operator|~
name|ARCHIVE_EXTRACT_NO_OVERWRITE_NEWER
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
comment|/* POSIX 1997 */
name|cpio
operator|->
name|verbose
operator|++
expr_stmt|;
break|break;
case|case
name|OPTION_VERSION
case|:
comment|/* GNU convention */
name|version
argument_list|()
expr_stmt|;
break|break;
if|#
directive|if
literal|0
comment|/* 		 * cpio_getopt() handles -W specially, so it's not 		 * available here. 		 */
block|case 'W':
comment|/* Obscure, but useful GNU convention. */
block|break;
endif|#
directive|endif
case|case
literal|'y'
case|:
comment|/* tar convention */
name|cpio
operator|->
name|compress
operator|=
name|opt
expr_stmt|;
break|break;
case|case
literal|'Z'
case|:
comment|/* tar convention */
name|cpio
operator|->
name|compress
operator|=
name|opt
expr_stmt|;
break|break;
case|case
literal|'z'
case|:
comment|/* tar convention */
name|cpio
operator|->
name|compress
operator|=
name|opt
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* TODO: Sanity-check args, error out on nonsensical combinations. */
name|cpio
operator|->
name|argc
operator|-=
name|optind
expr_stmt|;
name|cpio
operator|->
name|argv
operator|+=
name|optind
expr_stmt|;
switch|switch
condition|(
name|cpio
operator|->
name|mode
condition|)
block|{
case|case
literal|'o'
case|:
name|mode_out
argument_list|(
name|cpio
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
while|while
condition|(
operator|*
name|cpio
operator|->
name|argv
operator|!=
name|NULL
condition|)
block|{
name|include
argument_list|(
name|cpio
argument_list|,
operator|*
name|cpio
operator|->
name|argv
argument_list|)
expr_stmt|;
operator|--
name|cpio
operator|->
name|argc
expr_stmt|;
operator|++
name|cpio
operator|->
name|argv
expr_stmt|;
block|}
if|if
condition|(
name|cpio
operator|->
name|option_list
condition|)
name|mode_list
argument_list|(
name|cpio
argument_list|)
expr_stmt|;
else|else
name|mode_in
argument_list|(
name|cpio
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
if|if
condition|(
operator|*
name|cpio
operator|->
name|argv
operator|==
name|NULL
operator|||
operator|*
operator|*
name|cpio
operator|->
name|argv
operator|==
literal|'\0'
condition|)
name|cpio_errc
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"-p mode requires a target directory"
argument_list|)
expr_stmt|;
name|mode_pass
argument_list|(
name|cpio
argument_list|,
operator|*
name|cpio
operator|->
name|argv
argument_list|)
expr_stmt|;
break|break;
default|default:
name|cpio_errc
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Must specify at least one of -i, -o, or -p"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|cpio_progname
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Brief Usage:\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  List:    %s -it< archive\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  Extract: %s -i< archive\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  Create:  %s -o< filenames> archive\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_GETOPT_LONG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  Help:    %s --help\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  Help:    %s -h\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|long_help_msg
init|=
literal|"First option must be a mode specifier:\n"
literal|"  -i Input  -o Output  -p Pass\n"
literal|"Common Options:\n"
literal|"  -v    Verbose\n"
literal|"Create: %p -o [options]< [list of files]> [archive]\n"
literal|"  -z, -y  Compress archive with gzip/bzip2\n"
literal|"  --format {odc|newc|ustar}  Select archive format\n"
literal|"List: %p -it< [archive]\n"
literal|"Extract: %p -i [options]< [archive]\n"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Note that the word 'bsdcpio' will always appear in the first line  * of output.  *  * In particular, /bin/sh scripts that need to test for the presence  * of bsdcpio can use the following template:  *  * if (cpio --help 2>&1 | grep bsdcpio>/dev/null 2>&1 ) then \  *          echo bsdcpio; else echo not bsdcpio; fi  */
end_comment

begin_function
specifier|static
name|void
name|long_help
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|prog
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|prog
operator|=
name|cpio_progname
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
name|strcmp
argument_list|(
name|prog
argument_list|,
literal|"bsdcpio"
argument_list|)
operator|!=
literal|0
operator|)
condition|?
literal|"(bsdcpio)"
else|:
literal|""
expr_stmt|;
name|printf
argument_list|(
literal|"%s%s: manipulate archive files\n"
argument_list|,
name|prog
argument_list|,
name|p
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|long_help_msg
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'%'
condition|)
block|{
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|'p'
condition|)
block|{
name|fputs
argument_list|(
name|prog
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
else|else
name|putchar
argument_list|(
literal|'%'
argument_list|)
expr_stmt|;
block|}
else|else
name|putchar
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
block|}
name|version
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|version
parameter_list|(
name|void
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"bsdcpio %s -- %s\n"
argument_list|,
name|BSDCPIO_VERSION_STRING
argument_list|,
name|archive_version
argument_list|()
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mode_out
parameter_list|(
name|struct
name|cpio
modifier|*
name|cpio
parameter_list|)
block|{
name|unsigned
name|long
name|blocks
decl_stmt|;
name|struct
name|archive_entry
modifier|*
name|entry
decl_stmt|,
modifier|*
name|spare
decl_stmt|;
name|struct
name|line_reader
modifier|*
name|lr
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|r
decl_stmt|;
if|if
condition|(
name|cpio
operator|->
name|option_append
condition|)
name|cpio_errc
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Append mode not yet supported."
argument_list|)
expr_stmt|;
name|cpio
operator|->
name|archive
operator|=
name|archive_write_new
argument_list|()
expr_stmt|;
if|if
condition|(
name|cpio
operator|->
name|archive
operator|==
name|NULL
condition|)
name|cpio_errc
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Failed to allocate archive object"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cpio
operator|->
name|compress
condition|)
block|{
case|case
literal|'j'
case|:
case|case
literal|'y'
case|:
name|archive_write_set_compression_bzip2
argument_list|(
name|cpio
operator|->
name|archive
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'z'
case|:
name|archive_write_set_compression_gzip
argument_list|(
name|cpio
operator|->
name|archive
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'Z'
case|:
name|archive_write_set_compression_compress
argument_list|(
name|cpio
operator|->
name|archive
argument_list|)
expr_stmt|;
break|break;
default|default:
name|archive_write_set_compression_none
argument_list|(
name|cpio
operator|->
name|archive
argument_list|)
expr_stmt|;
break|break;
block|}
name|r
operator|=
name|archive_write_set_format_by_name
argument_list|(
name|cpio
operator|->
name|archive
argument_list|,
name|cpio
operator|->
name|format
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
name|cpio_errc
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
name|archive_error_string
argument_list|(
name|cpio
operator|->
name|archive
argument_list|)
argument_list|)
expr_stmt|;
name|archive_write_set_bytes_per_block
argument_list|(
name|cpio
operator|->
name|archive
argument_list|,
name|cpio
operator|->
name|bytes_per_block
argument_list|)
expr_stmt|;
name|cpio
operator|->
name|linkresolver
operator|=
name|archive_entry_linkresolver_new
argument_list|()
expr_stmt|;
name|archive_entry_linkresolver_set_strategy
argument_list|(
name|cpio
operator|->
name|linkresolver
argument_list|,
name|archive_format
argument_list|(
name|cpio
operator|->
name|archive
argument_list|)
argument_list|)
expr_stmt|;
name|r
operator|=
name|archive_write_open_file
argument_list|(
name|cpio
operator|->
name|archive
argument_list|,
name|cpio
operator|->
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
name|cpio_errc
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
name|archive_error_string
argument_list|(
name|cpio
operator|->
name|archive
argument_list|)
argument_list|)
expr_stmt|;
name|lr
operator|=
name|process_lines_init
argument_list|(
literal|"-"
argument_list|,
name|cpio
operator|->
name|line_separator
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|p
operator|=
name|process_lines_next
argument_list|(
name|lr
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|file_to_archive
argument_list|(
name|cpio
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|process_lines_free
argument_list|(
name|lr
argument_list|)
expr_stmt|;
comment|/* 	 * The hardlink detection may have queued up a couple of entries 	 * that can now be flushed. 	 */
name|entry
operator|=
name|NULL
expr_stmt|;
name|archive_entry_linkify
argument_list|(
name|cpio
operator|->
name|linkresolver
argument_list|,
operator|&
name|entry
argument_list|,
operator|&
name|spare
argument_list|)
expr_stmt|;
while|while
condition|(
name|entry
operator|!=
name|NULL
condition|)
block|{
name|entry_to_archive
argument_list|(
name|cpio
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|archive_entry_free
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|entry
operator|=
name|NULL
expr_stmt|;
name|archive_entry_linkify
argument_list|(
name|cpio
operator|->
name|linkresolver
argument_list|,
operator|&
name|entry
argument_list|,
operator|&
name|spare
argument_list|)
expr_stmt|;
block|}
name|r
operator|=
name|archive_write_close
argument_list|(
name|cpio
operator|->
name|archive
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
name|cpio_errc
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
name|archive_error_string
argument_list|(
name|cpio
operator|->
name|archive
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cpio
operator|->
name|quiet
condition|)
block|{
name|blocks
operator|=
operator|(
name|archive_position_uncompressed
argument_list|(
name|cpio
operator|->
name|archive
argument_list|)
operator|+
literal|511
operator|)
operator|/
literal|512
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%lu %s\n"
argument_list|,
name|blocks
argument_list|,
name|blocks
operator|==
literal|1
condition|?
literal|"block"
else|:
literal|"blocks"
argument_list|)
expr_stmt|;
block|}
name|archive_write_finish
argument_list|(
name|cpio
operator|->
name|archive
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This is used by both out mode (to copy objects from disk into  * an archive) and pass mode (to copy objects from disk to  * an archive_write_disk "archive").  */
end_comment

begin_function
specifier|static
name|int
name|file_to_archive
parameter_list|(
name|struct
name|cpio
modifier|*
name|cpio
parameter_list|,
specifier|const
name|char
modifier|*
name|srcpath
parameter_list|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
specifier|const
name|char
modifier|*
name|destpath
decl_stmt|;
name|struct
name|archive_entry
modifier|*
name|entry
decl_stmt|,
modifier|*
name|spare
decl_stmt|;
name|size_t
name|len
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|lnklen
decl_stmt|;
name|int
name|r
decl_stmt|;
comment|/* 	 * Create an archive_entry describing the source file. 	 */
name|entry
operator|=
name|archive_entry_new
argument_list|()
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
name|cpio_errc
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Couldn't allocate entry"
argument_list|)
expr_stmt|;
name|archive_entry_copy_sourcepath
argument_list|(
name|entry
argument_list|,
name|srcpath
argument_list|)
expr_stmt|;
comment|/* Get stat information. */
if|if
condition|(
name|cpio
operator|->
name|option_follow_links
condition|)
name|r
operator|=
name|stat
argument_list|(
name|srcpath
argument_list|,
operator|&
name|st
argument_list|)
expr_stmt|;
else|else
name|r
operator|=
name|lstat
argument_list|(
name|srcpath
argument_list|,
operator|&
name|st
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
block|{
name|cpio_warnc
argument_list|(
name|errno
argument_list|,
literal|"Couldn't stat \"%s\""
argument_list|,
name|srcpath
argument_list|)
expr_stmt|;
name|archive_entry_free
argument_list|(
name|entry
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|cpio
operator|->
name|uid_override
operator|>=
literal|0
condition|)
name|st
operator|.
name|st_uid
operator|=
name|cpio
operator|->
name|uid_override
expr_stmt|;
if|if
condition|(
name|cpio
operator|->
name|gid_override
operator|>=
literal|0
condition|)
name|st
operator|.
name|st_gid
operator|=
name|cpio
operator|->
name|uid_override
expr_stmt|;
name|archive_entry_copy_stat
argument_list|(
name|entry
argument_list|,
operator|&
name|st
argument_list|)
expr_stmt|;
comment|/* If its a symlink, pull the target. */
if|if
condition|(
name|S_ISLNK
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|lnklen
operator|=
name|readlink
argument_list|(
name|srcpath
argument_list|,
name|cpio
operator|->
name|buff
argument_list|,
name|cpio
operator|->
name|buff_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|lnklen
operator|<
literal|0
condition|)
block|{
name|cpio_warnc
argument_list|(
name|errno
argument_list|,
literal|"%s: Couldn't read symbolic link"
argument_list|,
name|srcpath
argument_list|)
expr_stmt|;
name|archive_entry_free
argument_list|(
name|entry
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|cpio
operator|->
name|buff
index|[
name|lnklen
index|]
operator|=
literal|0
expr_stmt|;
name|archive_entry_set_symlink
argument_list|(
name|entry
argument_list|,
name|cpio
operator|->
name|buff
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Generate a destination path for this entry. 	 * "destination path" is the name to which it will be copied in 	 * pass mode or the name that will go into the archive in 	 * output mode. 	 */
name|destpath
operator|=
name|srcpath
expr_stmt|;
if|if
condition|(
name|cpio
operator|->
name|destdir
condition|)
block|{
name|len
operator|=
name|strlen
argument_list|(
name|cpio
operator|->
name|destdir
argument_list|)
operator|+
name|strlen
argument_list|(
name|srcpath
argument_list|)
operator|+
literal|8
expr_stmt|;
if|if
condition|(
name|len
operator|>=
name|cpio
operator|->
name|pass_destpath_alloc
condition|)
block|{
while|while
condition|(
name|len
operator|>=
name|cpio
operator|->
name|pass_destpath_alloc
condition|)
block|{
name|cpio
operator|->
name|pass_destpath_alloc
operator|+=
literal|512
expr_stmt|;
name|cpio
operator|->
name|pass_destpath_alloc
operator|*=
literal|2
expr_stmt|;
block|}
name|free
argument_list|(
name|cpio
operator|->
name|pass_destpath
argument_list|)
expr_stmt|;
name|cpio
operator|->
name|pass_destpath
operator|=
name|malloc
argument_list|(
name|cpio
operator|->
name|pass_destpath_alloc
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpio
operator|->
name|pass_destpath
operator|==
name|NULL
condition|)
name|cpio_errc
argument_list|(
literal|1
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate path buffer"
argument_list|)
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|cpio
operator|->
name|pass_destpath
argument_list|,
name|cpio
operator|->
name|destdir
argument_list|)
expr_stmt|;
name|p
operator|=
name|srcpath
expr_stmt|;
while|while
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
operator|++
name|p
expr_stmt|;
name|strcat
argument_list|(
name|cpio
operator|->
name|pass_destpath
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|destpath
operator|=
name|cpio
operator|->
name|pass_destpath
expr_stmt|;
block|}
if|if
condition|(
name|cpio
operator|->
name|option_rename
condition|)
name|destpath
operator|=
name|cpio_rename
argument_list|(
name|destpath
argument_list|)
expr_stmt|;
if|if
condition|(
name|destpath
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|archive_entry_copy_pathname
argument_list|(
name|entry
argument_list|,
name|destpath
argument_list|)
expr_stmt|;
comment|/* 	 * If we're trying to preserve hardlinks, match them here. 	 */
name|spare
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|cpio
operator|->
name|linkresolver
operator|!=
name|NULL
operator|&&
operator|!
name|S_ISDIR
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|archive_entry_linkify
argument_list|(
name|cpio
operator|->
name|linkresolver
argument_list|,
operator|&
name|entry
argument_list|,
operator|&
name|spare
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|entry
operator|!=
name|NULL
condition|)
block|{
name|r
operator|=
name|entry_to_archive
argument_list|(
name|cpio
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|archive_entry_free
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|spare
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|r
operator|==
literal|0
condition|)
name|r
operator|=
name|entry_to_archive
argument_list|(
name|cpio
argument_list|,
name|spare
argument_list|)
expr_stmt|;
name|archive_entry_free
argument_list|(
name|spare
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|entry_to_archive
parameter_list|(
name|struct
name|cpio
modifier|*
name|cpio
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|destpath
init|=
name|archive_entry_pathname
argument_list|(
name|entry
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|srcpath
init|=
name|archive_entry_sourcepath
argument_list|(
name|entry
argument_list|)
decl_stmt|;
name|int
name|fd
init|=
operator|-
literal|1
decl_stmt|;
name|ssize_t
name|bytes_read
decl_stmt|;
name|int
name|r
decl_stmt|;
comment|/* Print out the destination name to the user. */
if|if
condition|(
name|cpio
operator|->
name|verbose
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s"
argument_list|,
name|destpath
argument_list|)
expr_stmt|;
comment|/* 	 * Option_link only makes sense in pass mode and for 	 * regular files.  Also note: if a link operation fails 	 * because of cross-device restrictions, we'll fall back 	 * to copy mode for that entry. 	 * 	 * TODO: Test other cpio implementations to see if they 	 * hard-link anything other than regular files here. 	 */
if|if
condition|(
name|cpio
operator|->
name|option_link
operator|&&
name|archive_entry_filetype
argument_list|(
name|entry
argument_list|)
operator|==
name|AE_IFREG
condition|)
block|{
name|struct
name|archive_entry
modifier|*
name|t
decl_stmt|;
comment|/* Save the original entry in case we need it later. */
name|t
operator|=
name|archive_entry_clone
argument_list|(
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL
condition|)
name|cpio_errc
argument_list|(
literal|1
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't create link"
argument_list|)
expr_stmt|;
comment|/* Note: link(2) doesn't create parent directories, 		 * so we use archive_write_header() instead as a 		 * convenience. */
name|archive_entry_set_hardlink
argument_list|(
name|t
argument_list|,
name|srcpath
argument_list|)
expr_stmt|;
comment|/* This is a straight link that carries no data. */
name|archive_entry_set_size
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|r
operator|=
name|archive_write_header
argument_list|(
name|cpio
operator|->
name|archive
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|archive_entry_free
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
name|cpio_warnc
argument_list|(
name|archive_errno
argument_list|(
name|cpio
operator|->
name|archive
argument_list|)
argument_list|,
name|archive_error_string
argument_list|(
name|cpio
operator|->
name|archive
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|ARCHIVE_FATAL
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EXDEV
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
operator|&&
name|archive_errno
argument_list|(
name|cpio
operator|->
name|archive
argument_list|)
operator|==
name|EXDEV
condition|)
block|{
comment|/* Cross-device link:  Just fall through and use 			 * the original entry to copy the file over. */
name|cpio_warnc
argument_list|(
literal|0
argument_list|,
literal|"Copying file instead"
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Make sure we can open the file (if necessary) before 	 * trying to write the header. 	 */
if|if
condition|(
name|archive_entry_filetype
argument_list|(
name|entry
argument_list|)
operator|==
name|AE_IFREG
condition|)
block|{
if|if
condition|(
name|archive_entry_size
argument_list|(
name|entry
argument_list|)
operator|>
literal|0
condition|)
block|{
name|fd
operator|=
name|open
argument_list|(
name|srcpath
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|cpio_warnc
argument_list|(
name|errno
argument_list|,
literal|"%s: could not open file"
argument_list|,
name|srcpath
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
block|}
block|}
else|else
block|{
name|archive_entry_set_size
argument_list|(
name|entry
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|r
operator|=
name|archive_write_header
argument_list|(
name|cpio
operator|->
name|archive
argument_list|,
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
name|cpio_warnc
argument_list|(
name|archive_errno
argument_list|(
name|cpio
operator|->
name|archive
argument_list|)
argument_list|,
literal|"%s: %s"
argument_list|,
name|destpath
argument_list|,
name|archive_error_string
argument_list|(
name|cpio
operator|->
name|archive
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|ARCHIVE_FATAL
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|>=
name|ARCHIVE_WARN
operator|&&
name|fd
operator|>=
literal|0
condition|)
block|{
name|bytes_read
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|cpio
operator|->
name|buff
argument_list|,
name|cpio
operator|->
name|buff_size
argument_list|)
expr_stmt|;
while|while
condition|(
name|bytes_read
operator|>
literal|0
condition|)
block|{
name|r
operator|=
name|archive_write_data
argument_list|(
name|cpio
operator|->
name|archive
argument_list|,
name|cpio
operator|->
name|buff
argument_list|,
name|bytes_read
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
name|cpio_errc
argument_list|(
literal|1
argument_list|,
name|archive_errno
argument_list|(
name|cpio
operator|->
name|archive
argument_list|)
argument_list|,
name|archive_error_string
argument_list|(
name|cpio
operator|->
name|archive
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
name|bytes_read
condition|)
block|{
name|cpio_warnc
argument_list|(
literal|0
argument_list|,
literal|"Truncated write; file may have grown while being archived."
argument_list|)
expr_stmt|;
block|}
name|bytes_read
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|cpio
operator|->
name|buff
argument_list|,
name|cpio
operator|->
name|buff_size
argument_list|)
expr_stmt|;
block|}
block|}
name|restore_time
argument_list|(
name|cpio
argument_list|,
name|entry
argument_list|,
name|srcpath
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|cleanup
label|:
if|if
condition|(
name|cpio
operator|->
name|verbose
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|>=
literal|0
condition|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|restore_time
parameter_list|(
name|struct
name|cpio
modifier|*
name|cpio
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|fd
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|HAVE_UTIMES
specifier|static
name|int
name|warned
init|=
literal|0
decl_stmt|;
operator|(
name|void
operator|)
name|cpio
expr_stmt|;
comment|/* UNUSED */
operator|(
name|void
operator|)
name|entry
expr_stmt|;
comment|/* UNUSED */
operator|(
name|void
operator|)
name|name
expr_stmt|;
comment|/* UNUSED */
operator|(
name|void
operator|)
name|fd
expr_stmt|;
comment|/* UNUSED */
if|if
condition|(
operator|!
name|warned
condition|)
name|cpio_warnc
argument_list|(
literal|0
argument_list|,
literal|"Can't restore access times on this platform"
argument_list|)
expr_stmt|;
name|warned
operator|=
literal|1
expr_stmt|;
return|return;
else|#
directive|else
name|struct
name|timeval
name|times
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|cpio
operator|->
name|option_atime_restore
condition|)
return|return;
name|times
index|[
literal|1
index|]
operator|.
name|tv_sec
operator|=
name|archive_entry_mtime
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|times
index|[
literal|1
index|]
operator|.
name|tv_usec
operator|=
name|archive_entry_mtime_nsec
argument_list|(
name|entry
argument_list|)
operator|/
literal|1000
expr_stmt|;
name|times
index|[
literal|0
index|]
operator|.
name|tv_sec
operator|=
name|archive_entry_atime
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|times
index|[
literal|0
index|]
operator|.
name|tv_usec
operator|=
name|archive_entry_atime_nsec
argument_list|(
name|entry
argument_list|)
operator|/
literal|1000
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_FUTIMES
if|if
condition|(
name|fd
operator|>=
literal|0
operator|&&
name|futimes
argument_list|(
name|fd
argument_list|,
name|times
argument_list|)
operator|==
literal|0
condition|)
return|return;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_LUTIMES
if|if
condition|(
name|lutimes
argument_list|(
name|name
argument_list|,
name|times
argument_list|)
operator|!=
literal|0
condition|)
else|#
directive|else
if|if
condition|(
operator|!
name|S_ISLNK
argument_list|(
name|archive_entry_mode
argument_list|(
name|entry
argument_list|)
argument_list|)
operator|&&
name|utimes
argument_list|(
name|name
argument_list|,
name|times
argument_list|)
operator|!=
literal|0
condition|)
endif|#
directive|endif
name|cpio_warnc
argument_list|(
name|errno
argument_list|,
literal|"Can't update time for %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|mode_in
parameter_list|(
name|struct
name|cpio
modifier|*
name|cpio
parameter_list|)
block|{
name|struct
name|archive
modifier|*
name|a
decl_stmt|;
name|struct
name|archive_entry
modifier|*
name|entry
decl_stmt|;
name|struct
name|archive
modifier|*
name|ext
decl_stmt|;
specifier|const
name|char
modifier|*
name|destpath
decl_stmt|;
name|unsigned
name|long
name|blocks
decl_stmt|;
name|int
name|r
decl_stmt|;
name|ext
operator|=
name|archive_write_disk_new
argument_list|()
expr_stmt|;
if|if
condition|(
name|ext
operator|==
name|NULL
condition|)
name|cpio_errc
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Couldn't allocate restore object"
argument_list|)
expr_stmt|;
name|r
operator|=
name|archive_write_disk_set_options
argument_list|(
name|ext
argument_list|,
name|cpio
operator|->
name|extract_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
name|cpio_errc
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
name|archive_error_string
argument_list|(
name|ext
argument_list|)
argument_list|)
expr_stmt|;
name|a
operator|=
name|archive_read_new
argument_list|()
expr_stmt|;
if|if
condition|(
name|a
operator|==
name|NULL
condition|)
name|cpio_errc
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Couldn't allocate archive object"
argument_list|)
expr_stmt|;
name|archive_read_support_compression_all
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|archive_read_support_format_all
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|archive_read_open_file
argument_list|(
name|a
argument_list|,
name|cpio
operator|->
name|filename
argument_list|,
name|cpio
operator|->
name|bytes_per_block
argument_list|)
condition|)
name|cpio_errc
argument_list|(
literal|1
argument_list|,
name|archive_errno
argument_list|(
name|a
argument_list|)
argument_list|,
name|archive_error_string
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|r
operator|=
name|archive_read_next_header
argument_list|(
name|a
argument_list|,
operator|&
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|ARCHIVE_EOF
condition|)
break|break;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
block|{
name|cpio_errc
argument_list|(
literal|1
argument_list|,
name|archive_errno
argument_list|(
name|a
argument_list|)
argument_list|,
name|archive_error_string
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|excluded
argument_list|(
name|cpio
argument_list|,
name|archive_entry_pathname
argument_list|(
name|entry
argument_list|)
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|cpio
operator|->
name|option_rename
condition|)
block|{
name|destpath
operator|=
name|cpio_rename
argument_list|(
name|archive_entry_pathname
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|archive_entry_set_pathname
argument_list|(
name|entry
argument_list|,
name|destpath
argument_list|)
expr_stmt|;
block|}
else|else
name|destpath
operator|=
name|archive_entry_pathname
argument_list|(
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|destpath
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|cpio
operator|->
name|verbose
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s\n"
argument_list|,
name|destpath
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpio
operator|->
name|uid_override
operator|>=
literal|0
condition|)
name|archive_entry_set_uid
argument_list|(
name|entry
argument_list|,
name|cpio
operator|->
name|uid_override
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpio
operator|->
name|gid_override
operator|>=
literal|0
condition|)
name|archive_entry_set_gid
argument_list|(
name|entry
argument_list|,
name|cpio
operator|->
name|gid_override
argument_list|)
expr_stmt|;
name|r
operator|=
name|archive_write_header
argument_list|(
name|ext
argument_list|,
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s\n"
argument_list|,
name|archive_entry_pathname
argument_list|(
name|entry
argument_list|)
argument_list|,
name|archive_error_string
argument_list|(
name|ext
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|archive_entry_size
argument_list|(
name|entry
argument_list|)
operator|>
literal|0
condition|)
block|{
name|r
operator|=
name|copy_data
argument_list|(
name|a
argument_list|,
name|ext
argument_list|)
expr_stmt|;
block|}
block|}
name|r
operator|=
name|archive_read_close
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
name|cpio_errc
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
name|archive_error_string
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
name|r
operator|=
name|archive_write_close
argument_list|(
name|ext
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
name|cpio_errc
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
name|archive_error_string
argument_list|(
name|ext
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cpio
operator|->
name|quiet
condition|)
block|{
name|blocks
operator|=
operator|(
name|archive_position_uncompressed
argument_list|(
name|a
argument_list|)
operator|+
literal|511
operator|)
operator|/
literal|512
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%lu %s\n"
argument_list|,
name|blocks
argument_list|,
name|blocks
operator|==
literal|1
condition|?
literal|"block"
else|:
literal|"blocks"
argument_list|)
expr_stmt|;
block|}
name|archive_read_finish
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|archive_write_finish
argument_list|(
name|ext
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|copy_data
parameter_list|(
name|struct
name|archive
modifier|*
name|ar
parameter_list|,
name|struct
name|archive
modifier|*
name|aw
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
name|size_t
name|size
decl_stmt|;
specifier|const
name|void
modifier|*
name|block
decl_stmt|;
name|off_t
name|offset
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|r
operator|=
name|archive_read_data_block
argument_list|(
name|ar
argument_list|,
operator|&
name|block
argument_list|,
operator|&
name|size
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|ARCHIVE_EOF
condition|)
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
block|{
name|cpio_warnc
argument_list|(
name|archive_errno
argument_list|(
name|ar
argument_list|)
argument_list|,
literal|"%s"
argument_list|,
name|archive_error_string
argument_list|(
name|ar
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
name|r
operator|=
name|archive_write_data_block
argument_list|(
name|aw
argument_list|,
name|block
argument_list|,
name|size
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
block|{
name|cpio_warnc
argument_list|(
name|archive_errno
argument_list|(
name|aw
argument_list|)
argument_list|,
name|archive_error_string
argument_list|(
name|aw
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|mode_list
parameter_list|(
name|struct
name|cpio
modifier|*
name|cpio
parameter_list|)
block|{
name|struct
name|archive
modifier|*
name|a
decl_stmt|;
name|struct
name|archive_entry
modifier|*
name|entry
decl_stmt|;
name|unsigned
name|long
name|blocks
decl_stmt|;
name|int
name|r
decl_stmt|;
name|a
operator|=
name|archive_read_new
argument_list|()
expr_stmt|;
if|if
condition|(
name|a
operator|==
name|NULL
condition|)
name|cpio_errc
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Couldn't allocate archive object"
argument_list|)
expr_stmt|;
name|archive_read_support_compression_all
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|archive_read_support_format_all
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|archive_read_open_file
argument_list|(
name|a
argument_list|,
name|cpio
operator|->
name|filename
argument_list|,
name|cpio
operator|->
name|bytes_per_block
argument_list|)
condition|)
name|cpio_errc
argument_list|(
literal|1
argument_list|,
name|archive_errno
argument_list|(
name|a
argument_list|)
argument_list|,
name|archive_error_string
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|r
operator|=
name|archive_read_next_header
argument_list|(
name|a
argument_list|,
operator|&
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|ARCHIVE_EOF
condition|)
break|break;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
block|{
name|cpio_errc
argument_list|(
literal|1
argument_list|,
name|archive_errno
argument_list|(
name|a
argument_list|)
argument_list|,
name|archive_error_string
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|excluded
argument_list|(
name|cpio
argument_list|,
name|archive_entry_pathname
argument_list|(
name|entry
argument_list|)
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|cpio
operator|->
name|verbose
condition|)
block|{
comment|/* TODO: uname/gname lookups */
comment|/* TODO: Clean this up. */
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s%3d %8s%8s "
name|CPIO_FILESIZE_PRINTF
literal|" %s\n"
argument_list|,
name|archive_entry_strmode
argument_list|(
name|entry
argument_list|)
argument_list|,
name|archive_entry_nlink
argument_list|(
name|entry
argument_list|)
argument_list|,
name|archive_entry_uname
argument_list|(
name|entry
argument_list|)
argument_list|,
name|archive_entry_gname
argument_list|(
name|entry
argument_list|)
argument_list|,
operator|(
name|CPIO_FILESIZE_TYPE
operator|)
name|archive_entry_size
argument_list|(
name|entry
argument_list|)
argument_list|,
name|archive_entry_pathname
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s\n"
argument_list|,
name|archive_entry_pathname
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|r
operator|=
name|archive_read_close
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
name|cpio_errc
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
name|archive_error_string
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cpio
operator|->
name|quiet
condition|)
block|{
name|blocks
operator|=
operator|(
name|archive_position_uncompressed
argument_list|(
name|a
argument_list|)
operator|+
literal|511
operator|)
operator|/
literal|512
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%lu %s\n"
argument_list|,
name|blocks
argument_list|,
name|blocks
operator|==
literal|1
condition|?
literal|"block"
else|:
literal|"blocks"
argument_list|)
expr_stmt|;
block|}
name|archive_read_finish
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mode_pass
parameter_list|(
name|struct
name|cpio
modifier|*
name|cpio
parameter_list|,
specifier|const
name|char
modifier|*
name|destdir
parameter_list|)
block|{
name|struct
name|line_reader
modifier|*
name|lr
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|r
decl_stmt|;
comment|/* Ensure target dir has a trailing '/' to simplify path surgery. */
name|cpio
operator|->
name|destdir
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|destdir
argument_list|)
operator|+
literal|8
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|cpio
operator|->
name|destdir
argument_list|,
name|destdir
argument_list|)
expr_stmt|;
if|if
condition|(
name|destdir
index|[
name|strlen
argument_list|(
name|destdir
argument_list|)
operator|-
literal|1
index|]
operator|!=
literal|'/'
condition|)
name|strcat
argument_list|(
name|cpio
operator|->
name|destdir
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|cpio
operator|->
name|archive
operator|=
name|archive_write_disk_new
argument_list|()
expr_stmt|;
if|if
condition|(
name|cpio
operator|->
name|archive
operator|==
name|NULL
condition|)
name|cpio_errc
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Failed to allocate archive object"
argument_list|)
expr_stmt|;
name|r
operator|=
name|archive_write_disk_set_options
argument_list|(
name|cpio
operator|->
name|archive
argument_list|,
name|cpio
operator|->
name|extract_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
name|cpio_errc
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
name|archive_error_string
argument_list|(
name|cpio
operator|->
name|archive
argument_list|)
argument_list|)
expr_stmt|;
name|cpio
operator|->
name|linkresolver
operator|=
name|archive_entry_linkresolver_new
argument_list|()
expr_stmt|;
name|archive_write_disk_set_standard_lookup
argument_list|(
name|cpio
operator|->
name|archive
argument_list|)
expr_stmt|;
name|lr
operator|=
name|process_lines_init
argument_list|(
literal|"-"
argument_list|,
name|cpio
operator|->
name|line_separator
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|p
operator|=
name|process_lines_next
argument_list|(
name|lr
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|file_to_archive
argument_list|(
name|cpio
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|process_lines_free
argument_list|(
name|lr
argument_list|)
expr_stmt|;
name|archive_entry_linkresolver_free
argument_list|(
name|cpio
operator|->
name|linkresolver
argument_list|)
expr_stmt|;
name|r
operator|=
name|archive_write_close
argument_list|(
name|cpio
operator|->
name|archive
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
name|cpio_errc
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
name|archive_error_string
argument_list|(
name|cpio
operator|->
name|archive
argument_list|)
argument_list|)
expr_stmt|;
name|archive_write_finish
argument_list|(
name|cpio
operator|->
name|archive
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Prompt for a new name for this entry.  Returns a pointer to the  * new name or NULL if the entry should not be copied.  This  * implements the semantics defined in POSIX.1-1996, which specifies  * that an input of '.' means the name should be unchanged.  GNU cpio  * treats '.' as a literal new name.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|cpio_rename
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
specifier|static
name|char
name|buff
index|[
literal|1024
index|]
decl_stmt|;
name|FILE
modifier|*
name|t
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|ret
decl_stmt|;
name|t
operator|=
name|fopen
argument_list|(
literal|"/dev/tty"
argument_list|,
literal|"r+"
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL
condition|)
return|return
operator|(
name|name
operator|)
return|;
name|fprintf
argument_list|(
name|t
argument_list|,
literal|"%s (Enter/./(new name))? "
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|p
operator|=
name|fgets
argument_list|(
name|buff
argument_list|,
sizeof|sizeof
argument_list|(
name|buff
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
comment|/* End-of-file is a blank line. */
return|return
operator|(
name|NULL
operator|)
return|;
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
operator|++
name|p
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\n'
operator|||
operator|*
name|p
operator|==
literal|'\0'
condition|)
comment|/* Empty line. */
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'.'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
comment|/* Single period preserves original name. */
return|return
operator|(
name|name
operator|)
return|;
name|ret
operator|=
name|p
expr_stmt|;
comment|/* Trim the final newline. */
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
operator|*
name|p
operator|!=
literal|'\n'
condition|)
operator|++
name|p
expr_stmt|;
comment|/* Overwrite the final \n with a null character. */
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read lines from file and do something with each one.  If option_null  * is set, lines are terminated with zero bytes; otherwise, they're  * terminated with newlines.  *  * This uses a self-sizing buffer to handle arbitrarily-long lines.  */
end_comment

begin_struct
struct|struct
name|line_reader
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
name|char
modifier|*
name|buff
decl_stmt|,
modifier|*
name|buff_end
decl_stmt|,
modifier|*
name|line_start
decl_stmt|,
modifier|*
name|line_end
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|pathname
decl_stmt|;
name|size_t
name|buff_length
decl_stmt|;
name|int
name|separator
decl_stmt|;
name|int
name|ret
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|struct
name|line_reader
modifier|*
name|process_lines_init
parameter_list|(
specifier|const
name|char
modifier|*
name|pathname
parameter_list|,
name|char
name|separator
parameter_list|)
block|{
name|struct
name|line_reader
modifier|*
name|lr
decl_stmt|;
name|lr
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lr
operator|==
name|NULL
condition|)
name|cpio_errc
argument_list|(
literal|1
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't open %s"
argument_list|,
name|pathname
argument_list|)
expr_stmt|;
name|lr
operator|->
name|separator
operator|=
name|separator
expr_stmt|;
name|lr
operator|->
name|pathname
operator|=
name|strdup
argument_list|(
name|pathname
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|pathname
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
name|lr
operator|->
name|f
operator|=
name|stdin
expr_stmt|;
else|else
name|lr
operator|->
name|f
operator|=
name|fopen
argument_list|(
name|pathname
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|lr
operator|->
name|f
operator|==
name|NULL
condition|)
name|cpio_errc
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"Couldn't open %s"
argument_list|,
name|pathname
argument_list|)
expr_stmt|;
name|lr
operator|->
name|buff_length
operator|=
literal|8192
expr_stmt|;
name|lr
operator|->
name|buff
operator|=
name|malloc
argument_list|(
name|lr
operator|->
name|buff_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|lr
operator|->
name|buff
operator|==
name|NULL
condition|)
name|cpio_errc
argument_list|(
literal|1
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't read %s"
argument_list|,
name|pathname
argument_list|)
expr_stmt|;
name|lr
operator|->
name|line_start
operator|=
name|lr
operator|->
name|line_end
operator|=
name|lr
operator|->
name|buff_end
operator|=
name|lr
operator|->
name|buff
expr_stmt|;
return|return
operator|(
name|lr
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|process_lines_next
parameter_list|(
name|struct
name|line_reader
modifier|*
name|lr
parameter_list|)
block|{
name|size_t
name|bytes_wanted
decl_stmt|,
name|bytes_read
decl_stmt|,
name|new_buff_size
decl_stmt|;
name|char
modifier|*
name|line_start
decl_stmt|,
modifier|*
name|p
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* If there's a line in the buffer, return it immediately. */
while|while
condition|(
name|lr
operator|->
name|line_end
operator|<
name|lr
operator|->
name|buff_end
condition|)
block|{
if|if
condition|(
operator|*
name|lr
operator|->
name|line_end
operator|==
name|lr
operator|->
name|separator
condition|)
block|{
operator|*
name|lr
operator|->
name|line_end
operator|=
literal|'\0'
expr_stmt|;
name|line_start
operator|=
name|lr
operator|->
name|line_start
expr_stmt|;
name|lr
operator|->
name|line_start
operator|=
name|lr
operator|->
name|line_end
operator|+
literal|1
expr_stmt|;
name|lr
operator|->
name|line_end
operator|=
name|lr
operator|->
name|line_start
expr_stmt|;
return|return
operator|(
name|line_start
operator|)
return|;
block|}
else|else
name|lr
operator|->
name|line_end
operator|++
expr_stmt|;
block|}
comment|/* If we're at end-of-file, process the final data. */
if|if
condition|(
name|lr
operator|->
name|f
operator|==
name|NULL
condition|)
block|{
comment|/* If there's more text, return one last line. */
if|if
condition|(
name|lr
operator|->
name|line_end
operator|>
name|lr
operator|->
name|line_start
condition|)
block|{
operator|*
name|lr
operator|->
name|line_end
operator|=
literal|'\0'
expr_stmt|;
name|line_start
operator|=
name|lr
operator|->
name|line_start
expr_stmt|;
name|lr
operator|->
name|line_start
operator|=
name|lr
operator|->
name|line_end
operator|+
literal|1
expr_stmt|;
name|lr
operator|->
name|line_end
operator|=
name|lr
operator|->
name|line_start
expr_stmt|;
return|return
operator|(
name|line_start
operator|)
return|;
block|}
comment|/* Otherwise, we're done. */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* Buffer only has part of a line. */
if|if
condition|(
name|lr
operator|->
name|line_start
operator|>
name|lr
operator|->
name|buff
condition|)
block|{
comment|/* Move a leftover fractional line to the beginning. */
name|memmove
argument_list|(
name|lr
operator|->
name|buff
argument_list|,
name|lr
operator|->
name|line_start
argument_list|,
name|lr
operator|->
name|buff_end
operator|-
name|lr
operator|->
name|line_start
argument_list|)
expr_stmt|;
name|lr
operator|->
name|buff_end
operator|-=
name|lr
operator|->
name|line_start
operator|-
name|lr
operator|->
name|buff
expr_stmt|;
name|lr
operator|->
name|line_end
operator|-=
name|lr
operator|->
name|line_start
operator|-
name|lr
operator|->
name|buff
expr_stmt|;
name|lr
operator|->
name|line_start
operator|=
name|lr
operator|->
name|buff
expr_stmt|;
block|}
else|else
block|{
comment|/* Line is too big; enlarge the buffer. */
name|new_buff_size
operator|=
name|lr
operator|->
name|buff_length
operator|*
literal|2
expr_stmt|;
if|if
condition|(
name|new_buff_size
operator|<=
name|lr
operator|->
name|buff_length
condition|)
name|cpio_errc
argument_list|(
literal|1
argument_list|,
name|ENOMEM
argument_list|,
literal|"Line too long in %s"
argument_list|,
name|lr
operator|->
name|pathname
argument_list|)
expr_stmt|;
name|lr
operator|->
name|buff_length
operator|=
name|new_buff_size
expr_stmt|;
name|p
operator|=
name|realloc
argument_list|(
name|lr
operator|->
name|buff
argument_list|,
name|new_buff_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|cpio_errc
argument_list|(
literal|1
argument_list|,
name|ENOMEM
argument_list|,
literal|"Line too long in %s"
argument_list|,
name|lr
operator|->
name|pathname
argument_list|)
expr_stmt|;
name|lr
operator|->
name|buff_end
operator|=
name|p
operator|+
operator|(
name|lr
operator|->
name|buff_end
operator|-
name|lr
operator|->
name|buff
operator|)
expr_stmt|;
name|lr
operator|->
name|line_end
operator|=
name|p
operator|+
operator|(
name|lr
operator|->
name|line_end
operator|-
name|lr
operator|->
name|buff
operator|)
expr_stmt|;
name|lr
operator|->
name|line_start
operator|=
name|lr
operator|->
name|buff
operator|=
name|p
expr_stmt|;
block|}
comment|/* Get some more data into the buffer. */
name|bytes_wanted
operator|=
name|lr
operator|->
name|buff
operator|+
name|lr
operator|->
name|buff_length
operator|-
name|lr
operator|->
name|buff_end
expr_stmt|;
name|bytes_read
operator|=
name|fread
argument_list|(
name|lr
operator|->
name|buff_end
argument_list|,
literal|1
argument_list|,
name|bytes_wanted
argument_list|,
name|lr
operator|->
name|f
argument_list|)
expr_stmt|;
name|lr
operator|->
name|buff_end
operator|+=
name|bytes_read
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|lr
operator|->
name|f
argument_list|)
condition|)
name|cpio_errc
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"Can't read %s"
argument_list|,
name|lr
operator|->
name|pathname
argument_list|)
expr_stmt|;
if|if
condition|(
name|feof
argument_list|(
name|lr
operator|->
name|f
argument_list|)
condition|)
block|{
if|if
condition|(
name|lr
operator|->
name|f
operator|!=
name|stdin
condition|)
name|fclose
argument_list|(
name|lr
operator|->
name|f
argument_list|)
expr_stmt|;
name|lr
operator|->
name|f
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|process_lines_free
parameter_list|(
name|struct
name|line_reader
modifier|*
name|lr
parameter_list|)
block|{
name|free
argument_list|(
name|lr
operator|->
name|buff
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lr
operator|->
name|pathname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lr
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

