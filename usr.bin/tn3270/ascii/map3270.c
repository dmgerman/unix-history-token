begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1988, 1993  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)map3270.c	8.1 (Berkeley) 6/6/93"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/*	This program reads a description file, somewhat like /etc/termcap,     that describes the mapping between the current terminal's keyboard and     a 3270 keyboard.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DOCUMENTATION_ONLY
end_ifdef

begin_comment
comment|/* here is a sample (very small) entry...  	# this table is sensitive to position on a line.  In particular, 	# a terminal definition for a terminal is terminated whenever a 	# (non-comment) line beginning in column one is found. 	# 	# this is an entry to map tvi924 to 3270 keys... 	v8|tvi924|924|televideo model 924 { 		pfk1 =	'\E1'; 		pfk2 =	'\E2'; 		clear = '^z';		# clear the screen 	}  */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DOCUMENTATION_ONLY */
end_comment

begin_escape
end_escape

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|unix
argument_list|)
end_if

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* defined(unix) */
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(unix) */
end_comment

begin_define
define|#
directive|define
name|IsPrint
parameter_list|(
name|c
parameter_list|)
value|((isprint(c)&& !isspace(c)) || ((c) == ' '))
end_define

begin_include
include|#
directive|include
file|"state.h"
end_include

begin_include
include|#
directive|include
file|"map3270.h"
end_include

begin_include
include|#
directive|include
file|"../general/globals.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* this is the list of types returned by the lex processor */
end_comment

begin_define
define|#
directive|define
name|LEX_CHAR
value|400
end_define

begin_comment
comment|/* plain unadorned character */
end_comment

begin_define
define|#
directive|define
name|LEX_ESCAPED
value|LEX_CHAR+1
end_define

begin_comment
comment|/* escaped with \ */
end_comment

begin_define
define|#
directive|define
name|LEX_CARETED
value|LEX_ESCAPED+1
end_define

begin_comment
comment|/* escaped with ^ */
end_comment

begin_define
define|#
directive|define
name|LEX_END_OF_FILE
value|LEX_CARETED+1
end_define

begin_comment
comment|/* end of file encountered */
end_comment

begin_define
define|#
directive|define
name|LEX_ILLEGAL
value|LEX_END_OF_FILE+1
end_define

begin_comment
comment|/* trailing escape character */
end_comment

begin_comment
comment|/* the following is part of our character set dependancy... */
end_comment

begin_define
define|#
directive|define
name|ESCAPE
value|0x1b
end_define

begin_define
define|#
directive|define
name|TAB
value|0x09
end_define

begin_define
define|#
directive|define
name|NEWLINE
value|0x0a
end_define

begin_define
define|#
directive|define
name|CARRIAGE_RETURN
value|0x0d
end_define

begin_typedef
typedef|typedef
struct|struct
block|{
name|int
name|type
decl_stmt|;
comment|/* LEX_* - type of character */
name|int
name|value
decl_stmt|;
comment|/* character this was */
block|}
name|lexicon
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|int
name|length
decl_stmt|;
comment|/* length of character string */
name|char
name|array
index|[
literal|500
index|]
decl_stmt|;
comment|/* character string */
block|}
name|stringWithLength
typedef|;
end_typedef

begin_define
define|#
directive|define
name|panic
parameter_list|(
name|s
parameter_list|)
value|{ fprintf(stderr, s); exit(1); }
end_define

begin_decl_stmt
specifier|static
name|state
name|firstentry
init|=
block|{
literal|0
block|,
name|STATE_NULL
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|state
modifier|*
name|headOfQueue
init|=
operator|&
name|firstentry
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* the following is a primitive adm3a table, to be used when nothing  * else seems to be avaliable.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* debug flag (for debuggin tables) */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG */
end_comment

begin_function_decl
specifier|static
name|int
function_decl|(
modifier|*
name|GetTc
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|doPaste
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* should we have side effects */
end_comment

begin_decl_stmt
specifier|static
name|int
name|picky
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* do we complain of unknown functions? */
end_comment

begin_decl_stmt
specifier|static
name|char
name|usePointer
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* use pointer, or file */
end_comment

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|ourFile
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|environPointer
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* if non-zero, point to input 				 * string in core. 				 */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|whichkey
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|keysgeneric
index|[]
init|=
block|{
include|#
directive|include
file|"default.map"
comment|/* Define the default default */
literal|0
block|,
comment|/* Terminate list of entries */
block|}
decl_stmt|;
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|int
name|Empty
init|=
literal|1
decl_stmt|,
comment|/* is the unget lifo empty? */
name|Full
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* is the unget lifo full? */
end_comment

begin_decl_stmt
specifier|static
name|lexicon
name|lifo
index|[
literal|200
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* character stack for parser */
end_comment

begin_decl_stmt
specifier|static
name|int
name|rp
init|=
literal|0
decl_stmt|,
comment|/* read pointer into lifo */
name|wp
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* write pointer into lifo */
end_comment

begin_function
specifier|static
name|int
name|GetC
parameter_list|()
block|{
name|int
name|character
decl_stmt|;
if|if
condition|(
name|usePointer
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|environPointer
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 	     * If we have reached the end of this string, go on to 	     * the next (if there is a next). 	     */
if|if
condition|(
name|whichkey
operator|==
literal|0
condition|)
block|{
specifier|static
name|char
name|suffix
init|=
literal|'A'
decl_stmt|;
comment|/* From environment */
name|char
name|envname
index|[
literal|9
index|]
decl_stmt|;
specifier|extern
name|char
modifier|*
name|getenv
parameter_list|()
function_decl|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|envname
argument_list|,
literal|"MAP3270%c"
argument_list|,
name|suffix
operator|++
argument_list|)
expr_stmt|;
name|environPointer
operator|=
name|getenv
argument_list|(
name|envname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|whichkey
operator|++
expr_stmt|;
comment|/* default map */
name|environPointer
operator|=
operator|*
name|whichkey
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|*
name|environPointer
condition|)
block|{
name|character
operator|=
literal|0xff
operator|&
operator|*
name|environPointer
operator|++
expr_stmt|;
block|}
else|else
block|{
name|character
operator|=
name|EOF
expr_stmt|;
block|}
block|}
else|else
block|{
name|character
operator|=
name|getc
argument_list|(
name|ourFile
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|character
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|lexicon
name|Get
parameter_list|()
block|{
specifier|static
name|lexicon
name|c
decl_stmt|;
specifier|register
name|lexicon
modifier|*
name|pC
init|=
operator|&
name|c
decl_stmt|;
specifier|register
name|int
name|character
decl_stmt|;
if|if
condition|(
operator|!
name|Empty
condition|)
block|{
operator|*
name|pC
operator|=
name|lifo
index|[
name|rp
index|]
expr_stmt|;
name|rp
operator|++
expr_stmt|;
if|if
condition|(
name|rp
operator|==
sizeof|sizeof
name|lifo
operator|/
sizeof|sizeof
argument_list|(
name|lexicon
argument_list|)
condition|)
block|{
name|rp
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|rp
operator|==
name|wp
condition|)
block|{
name|Empty
operator|=
literal|1
expr_stmt|;
block|}
name|Full
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|character
operator|=
name|GetC
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|character
condition|)
block|{
case|case
name|EOF
case|:
name|pC
operator|->
name|type
operator|=
name|LEX_END_OF_FILE
expr_stmt|;
break|break;
case|case
literal|'^'
case|:
name|character
operator|=
name|GetC
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|IsPrint
argument_list|(
name|character
argument_list|)
condition|)
block|{
name|pC
operator|->
name|type
operator|=
name|LEX_ILLEGAL
expr_stmt|;
block|}
else|else
block|{
name|pC
operator|->
name|type
operator|=
name|LEX_CARETED
expr_stmt|;
if|if
condition|(
name|character
operator|==
literal|'?'
condition|)
block|{
name|character
operator||=
literal|0x40
expr_stmt|;
comment|/* rubout */
block|}
else|else
block|{
name|character
operator|&=
literal|0x1f
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'\\'
case|:
name|character
operator|=
name|GetC
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|IsPrint
argument_list|(
name|character
argument_list|)
condition|)
block|{
name|pC
operator|->
name|type
operator|=
name|LEX_ILLEGAL
expr_stmt|;
block|}
else|else
block|{
name|pC
operator|->
name|type
operator|=
name|LEX_ESCAPED
expr_stmt|;
switch|switch
condition|(
name|character
condition|)
block|{
case|case
literal|'E'
case|:
case|case
literal|'e'
case|:
name|character
operator|=
name|ESCAPE
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|character
operator|=
name|TAB
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|character
operator|=
name|NEWLINE
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|character
operator|=
name|CARRIAGE_RETURN
expr_stmt|;
break|break;
default|default:
name|pC
operator|->
name|type
operator|=
name|LEX_ILLEGAL
expr_stmt|;
break|break;
block|}
block|}
break|break;
default|default:
if|if
condition|(
operator|(
name|IsPrint
argument_list|(
name|character
argument_list|)
operator|)
operator|||
name|isspace
argument_list|(
name|character
argument_list|)
condition|)
block|{
name|pC
operator|->
name|type
operator|=
name|LEX_CHAR
expr_stmt|;
block|}
else|else
block|{
name|pC
operator|->
name|type
operator|=
name|LEX_ILLEGAL
expr_stmt|;
block|}
break|break;
block|}
name|pC
operator|->
name|value
operator|=
name|character
expr_stmt|;
block|}
return|return
operator|(
operator|*
name|pC
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|UnGet
parameter_list|(
name|c
parameter_list|)
name|lexicon
name|c
decl_stmt|;
comment|/* character to unget */
block|{
if|if
condition|(
name|Full
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"attempt to put too many characters in lifo\n"
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"map3270"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
else|else
block|{
name|lifo
index|[
name|wp
index|]
operator|=
name|c
expr_stmt|;
name|wp
operator|++
expr_stmt|;
if|if
condition|(
name|wp
operator|==
sizeof|sizeof
name|lifo
operator|/
sizeof|sizeof
argument_list|(
name|lexicon
argument_list|)
condition|)
block|{
name|wp
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|wp
operator|==
name|rp
condition|)
block|{
name|Full
operator|=
literal|1
expr_stmt|;
block|}
name|Empty
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * Construct a control character sequence  * for a special character.  */
end_comment

begin_function
name|char
modifier|*
name|uncontrol
parameter_list|(
name|c
parameter_list|)
specifier|register
name|int
name|c
decl_stmt|;
block|{
specifier|static
name|char
name|buf
index|[
literal|3
index|]
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|0x7f
condition|)
return|return
operator|(
literal|"^?"
operator|)
return|;
if|if
condition|(
name|c
operator|==
literal|'\377'
condition|)
block|{
return|return
literal|"-1"
return|;
block|}
if|if
condition|(
name|c
operator|>=
literal|0x20
condition|)
block|{
name|buf
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|buf
index|[
literal|0
index|]
operator|=
literal|'^'
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
literal|'@'
operator|+
name|c
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* compare two strings, ignoring case */
end_comment

begin_expr_stmt
name|ustrcmp
argument_list|(
name|string1
argument_list|,
name|string2
argument_list|)
specifier|register
name|char
operator|*
name|string1
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|char
modifier|*
name|string2
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|c1
decl_stmt|,
name|c2
decl_stmt|;
while|while
condition|(
operator|(
name|c1
operator|=
operator|(
name|unsigned
name|char
operator|)
operator|*
name|string1
operator|++
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|isupper
argument_list|(
name|c1
argument_list|)
condition|)
block|{
name|c1
operator|=
name|tolower
argument_list|(
name|c1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isupper
argument_list|(
name|c2
operator|=
operator|(
name|unsigned
name|char
operator|)
operator|*
name|string2
operator|++
argument_list|)
condition|)
block|{
name|c2
operator|=
name|tolower
argument_list|(
name|c2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c1
operator|<
name|c2
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|c1
operator|>
name|c2
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
operator|*
name|string2
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_block

begin_escape
end_escape

begin_function
specifier|static
name|stringWithLength
modifier|*
name|GetQuotedString
parameter_list|()
block|{
name|lexicon
name|lex
decl_stmt|,
modifier|*
name|lp
decl_stmt|;
specifier|static
name|stringWithLength
name|output
init|=
block|{
literal|0
block|}
decl_stmt|;
comment|/* where return value is held */
name|char
modifier|*
name|pointer
init|=
name|output
operator|.
name|array
decl_stmt|;
name|lex
operator|=
name|Get
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|lex
operator|.
name|type
operator|!=
name|LEX_CHAR
operator|)
operator|||
operator|(
name|lex
operator|.
name|value
operator|!=
literal|'\''
operator|)
condition|)
block|{
name|UnGet
argument_list|(
name|lex
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
while|while
condition|(
literal|1
condition|)
block|{
name|lex
operator|=
name|Get
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|lex
operator|.
name|type
operator|==
name|LEX_CHAR
operator|)
operator|&&
operator|(
name|lex
operator|.
name|value
operator|==
literal|'\''
operator|)
condition|)
block|{
break|break;
block|}
name|lp
operator|=
operator|&
name|lex
expr_stmt|;
if|if
condition|(
operator|(
name|lp
operator|->
name|type
operator|==
name|LEX_CHAR
operator|)
operator|&&
operator|!
name|IsPrint
argument_list|(
name|lp
operator|->
name|value
argument_list|)
condition|)
block|{
name|UnGet
argument_list|(
name|lex
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* illegal character in quoted string */
block|}
if|if
condition|(
name|pointer
operator|>=
name|output
operator|.
name|array
operator|+
sizeof|sizeof
name|output
operator|.
name|array
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
comment|/* too long */
block|}
operator|*
name|pointer
operator|++
operator|=
name|lex
operator|.
name|value
expr_stmt|;
block|}
name|output
operator|.
name|length
operator|=
name|pointer
operator|-
name|output
operator|.
name|array
expr_stmt|;
return|return
operator|(
operator|&
name|output
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|NOTUSED
end_ifdef

begin_function
specifier|static
name|stringWithLength
modifier|*
name|GetCharString
parameter_list|()
block|{
name|lexicon
name|lex
decl_stmt|;
specifier|static
name|stringWithLength
name|output
decl_stmt|;
name|char
modifier|*
name|pointer
init|=
name|output
operator|.
name|array
decl_stmt|;
name|lex
operator|=
name|Get
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|lex
operator|.
name|type
operator|==
name|LEX_CHAR
operator|)
operator|&&
operator|!
name|isspace
argument_list|(
name|lex
operator|.
name|value
argument_list|)
operator|&&
operator|(
name|lex
operator|.
name|value
operator|!=
literal|'='
operator|)
condition|)
block|{
operator|*
name|pointer
operator|++
operator|=
name|lex
operator|.
name|value
expr_stmt|;
name|lex
operator|=
name|Get
argument_list|()
expr_stmt|;
if|if
condition|(
name|pointer
operator|>=
name|output
operator|.
name|array
operator|+
sizeof|sizeof
name|output
operator|.
name|array
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
comment|/* too long */
block|}
block|}
name|UnGet
argument_list|(
name|lex
argument_list|)
expr_stmt|;
name|output
operator|.
name|length
operator|=
name|pointer
operator|-
name|output
operator|.
name|array
expr_stmt|;
return|return
operator|(
operator|&
name|output
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOTUSED */
end_comment

begin_expr_stmt
specifier|static
name|GetCharacter
argument_list|(
argument|character
argument_list|)
name|int
name|character
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* desired character */
end_comment

begin_block
block|{
name|lexicon
name|lex
decl_stmt|;
name|lex
operator|=
name|Get
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|lex
operator|.
name|type
operator|!=
name|LEX_CHAR
operator|)
operator|||
operator|(
name|lex
operator|.
name|value
operator|!=
name|character
operator|)
condition|)
block|{
name|UnGet
argument_list|(
name|lex
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|NOTUSED
end_ifdef

begin_expr_stmt
specifier|static
name|GetString
argument_list|(
argument|string
argument_list|)
name|char
operator|*
name|string
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* string to get */
end_comment

begin_block
block|{
name|lexicon
name|lex
decl_stmt|;
while|while
condition|(
operator|*
name|string
condition|)
block|{
name|lex
operator|=
name|Get
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|lex
operator|.
name|type
operator|!=
name|LEX_CHAR
operator|)
operator|||
operator|(
name|lex
operator|.
name|value
operator|!=
operator|*
name|string
operator|&
literal|0xff
operator|)
condition|)
block|{
name|UnGet
argument_list|(
name|lex
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* XXX restore to state on entry */
block|}
name|string
operator|++
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOTUSED */
end_comment

begin_function
specifier|static
name|stringWithLength
modifier|*
name|GetAlphaMericString
parameter_list|()
block|{
name|lexicon
name|lex
decl_stmt|,
modifier|*
name|lp
decl_stmt|;
specifier|static
name|stringWithLength
name|output
init|=
block|{
literal|0
block|}
decl_stmt|;
name|char
modifier|*
name|pointer
init|=
name|output
operator|.
name|array
decl_stmt|;
define|#
directive|define
name|IsAlnum
parameter_list|(
name|c
parameter_list|)
value|(isalnum(c) || (c == '_') \ 					|| (c == '-') || (c == '.'))
name|lex
operator|=
name|Get
argument_list|()
expr_stmt|;
name|lp
operator|=
operator|&
name|lex
expr_stmt|;
if|if
condition|(
operator|(
name|lp
operator|->
name|type
operator|!=
name|LEX_CHAR
operator|)
operator|||
operator|!
name|IsAlnum
argument_list|(
name|lp
operator|->
name|value
argument_list|)
condition|)
block|{
name|UnGet
argument_list|(
name|lex
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
while|while
condition|(
operator|(
name|lp
operator|->
name|type
operator|==
name|LEX_CHAR
operator|)
operator|&&
name|IsAlnum
argument_list|(
name|lp
operator|->
name|value
argument_list|)
condition|)
block|{
operator|*
name|pointer
operator|++
operator|=
name|lex
operator|.
name|value
expr_stmt|;
name|lex
operator|=
name|Get
argument_list|()
expr_stmt|;
block|}
name|UnGet
argument_list|(
name|lex
argument_list|)
expr_stmt|;
operator|*
name|pointer
operator|=
literal|0
expr_stmt|;
name|output
operator|.
name|length
operator|=
name|pointer
operator|-
name|output
operator|.
name|array
expr_stmt|;
return|return
operator|(
operator|&
name|output
operator|)
return|;
block|}
end_function

begin_comment
comment|/* eat up characters until a new line, or end of file.  returns terminating 	character.  */
end_comment

begin_function
specifier|static
name|lexicon
name|EatToNL
parameter_list|()
block|{
name|lexicon
name|lex
decl_stmt|;
name|lex
operator|=
name|Get
argument_list|()
expr_stmt|;
while|while
condition|(
operator|!
operator|(
operator|(
name|lex
operator|.
name|type
operator|!=
name|LEX_ESCAPED
operator|)
operator|&&
operator|(
name|lex
operator|.
name|type
operator|!=
name|LEX_CARETED
operator|)
operator|&&
operator|(
name|lex
operator|.
name|value
operator|==
literal|'\n'
operator|)
operator|)
operator|&&
operator|(
operator|!
operator|(
name|lex
operator|.
name|type
operator|==
name|LEX_END_OF_FILE
operator|)
operator|)
condition|)
block|{
name|lex
operator|=
name|Get
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|lex
operator|.
name|type
operator|!=
name|LEX_END_OF_FILE
condition|)
block|{
return|return
operator|(
name|Get
argument_list|()
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|lex
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|GetWS
parameter_list|()
block|{
name|lexicon
name|lex
decl_stmt|,
modifier|*
name|lp
decl_stmt|;
name|lex
operator|=
name|Get
argument_list|()
expr_stmt|;
name|lp
operator|=
operator|&
name|lex
expr_stmt|;
while|while
condition|(
operator|(
name|lp
operator|->
name|type
operator|==
name|LEX_CHAR
operator|)
operator|&&
operator|(
name|isspace
argument_list|(
name|lp
operator|->
name|value
argument_list|)
operator|||
operator|(
name|lp
operator|->
name|value
operator|==
literal|'#'
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|lex
operator|.
name|value
operator|==
literal|'#'
condition|)
block|{
name|lex
operator|=
name|EatToNL
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|lex
operator|=
name|Get
argument_list|()
expr_stmt|;
block|}
block|}
name|UnGet
argument_list|(
name|lex
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|FreeState
parameter_list|(
name|pState
parameter_list|)
name|state
modifier|*
name|pState
decl_stmt|;
block|{
specifier|extern
name|int
name|free
parameter_list|()
function_decl|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pState
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|state
modifier|*
name|GetState
parameter_list|()
block|{
name|state
modifier|*
name|pState
decl_stmt|;
specifier|extern
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
name|pState
operator|=
operator|(
name|state
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|state
argument_list|)
argument_list|)
expr_stmt|;
name|pState
operator|->
name|result
operator|=
name|STATE_NULL
expr_stmt|;
name|pState
operator|->
name|next
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|pState
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|state
modifier|*
name|FindMatchAtThisLevel
parameter_list|(
name|pState
parameter_list|,
name|character
parameter_list|)
name|state
modifier|*
name|pState
decl_stmt|;
name|int
name|character
decl_stmt|;
block|{
while|while
condition|(
name|pState
condition|)
block|{
if|if
condition|(
name|pState
operator|->
name|match
operator|==
name|character
condition|)
block|{
return|return
operator|(
name|pState
operator|)
return|;
block|}
name|pState
operator|=
name|pState
operator|->
name|next
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|state
modifier|*
name|PasteEntry
parameter_list|(
name|head
parameter_list|,
name|string
parameter_list|,
name|count
parameter_list|,
name|identifier
parameter_list|)
name|state
modifier|*
name|head
decl_stmt|;
comment|/* points to who should point here... */
name|char
modifier|*
name|string
decl_stmt|;
comment|/* which characters to paste */
name|int
name|count
decl_stmt|;
comment|/* number of character to do */
name|char
modifier|*
name|identifier
decl_stmt|;
comment|/* for error messages */
block|{
name|state
modifier|*
name|pState
decl_stmt|,
modifier|*
name|other
decl_stmt|;
if|if
condition|(
operator|!
name|doPaste
condition|)
block|{
comment|/* flag to not have any side effects */
return|return
operator|(
operator|(
name|state
operator|*
operator|)
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|count
condition|)
block|{
return|return
operator|(
name|head
operator|)
return|;
comment|/* return pointer to the parent */
block|}
if|if
condition|(
operator|(
name|head
operator|->
name|result
operator|!=
name|STATE_NULL
operator|)
operator|&&
operator|(
name|head
operator|->
name|result
operator|!=
name|STATE_GOTO
operator|)
condition|)
block|{
comment|/* this means that a previously defined sequence is an initial 	 * part of this one. 	 */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Conflicting entries found when scanning %s\n"
argument_list|,
name|identifier
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s"
argument_list|,
name|uncontrol
argument_list|(
operator|*
name|string
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* DEBUG */
name|pState
operator|=
name|GetState
argument_list|()
expr_stmt|;
name|pState
operator|->
name|match
operator|=
operator|*
name|string
expr_stmt|;
if|if
condition|(
name|head
operator|->
name|result
operator|==
name|STATE_NULL
condition|)
block|{
name|head
operator|->
name|result
operator|=
name|STATE_GOTO
expr_stmt|;
name|head
operator|->
name|address
operator|=
name|pState
expr_stmt|;
name|other
operator|=
name|pState
expr_stmt|;
block|}
else|else
block|{
comment|/* search for same character */
if|if
condition|(
operator|(
name|other
operator|=
name|FindMatchAtThisLevel
argument_list|(
name|head
operator|->
name|address
argument_list|,
operator|*
name|string
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|FreeState
argument_list|(
name|pState
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pState
operator|->
name|next
operator|=
name|head
operator|->
name|address
expr_stmt|;
name|head
operator|->
name|address
operator|=
name|pState
expr_stmt|;
name|other
operator|=
name|pState
expr_stmt|;
block|}
block|}
return|return
operator|(
name|PasteEntry
argument_list|(
name|other
argument_list|,
name|string
operator|+
literal|1
argument_list|,
name|count
operator|-
literal|1
argument_list|,
name|identifier
argument_list|)
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_expr_stmt
specifier|static
name|GetInput
argument_list|(
argument|tc
argument_list|,
argument|identifier
argument_list|)
name|int
name|tc
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|identifier
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* entry being parsed (for error messages) */
end_comment

begin_block
block|{
name|stringWithLength
modifier|*
name|outputString
decl_stmt|;
name|state
modifier|*
name|head
decl_stmt|;
name|state
name|fakeQueue
decl_stmt|;
if|if
condition|(
name|doPaste
condition|)
block|{
name|head
operator|=
name|headOfQueue
expr_stmt|;
comment|/* always points to level above this one */
block|}
else|else
block|{
name|head
operator|=
operator|&
name|fakeQueue
expr_stmt|;
comment|/* don't have any side effects... */
block|}
if|if
condition|(
operator|(
name|outputString
operator|=
name|GetQuotedString
argument_list|()
operator|)
operator|==
literal|0
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|IsPrint
argument_list|(
name|outputString
operator|->
name|array
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"first character of sequence for %s is not a control type character\n"
argument_list|,
name|identifier
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|head
operator|=
name|PasteEntry
argument_list|(
name|head
argument_list|,
name|outputString
operator|->
name|array
argument_list|,
name|outputString
operator|->
name|length
argument_list|,
name|identifier
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|GetWS
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|outputString
operator|=
name|GetQuotedString
argument_list|()
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|head
operator|=
name|PasteEntry
argument_list|(
name|head
argument_list|,
name|outputString
operator|->
name|array
argument_list|,
name|outputString
operator|->
name|length
argument_list|,
name|identifier
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|GetWS
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|doPaste
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|head
operator|->
name|result
operator|!=
name|STATE_NULL
operator|)
operator|&&
operator|(
name|head
operator|->
name|result
operator|!=
name|tc
operator|)
condition|)
block|{
comment|/* this means that this sequence is an initial part 	 * of a previously defined one. 	 */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Conflicting entries found when scanning %s\n"
argument_list|,
name|identifier
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
name|head
operator|->
name|result
operator|=
name|tc
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
comment|/* done */
block|}
block|}
end_block

begin_escape
end_escape

begin_expr_stmt
specifier|static
name|GetDefinition
argument_list|()
block|{
name|stringWithLength
operator|*
name|string
block|;
name|int
name|Tc
block|;
name|GetWS
argument_list|()
block|;
if|if
condition|(
operator|(
name|string
operator|=
name|GetAlphaMericString
argument_list|()
operator|)
operator|==
literal|0
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|string
operator|->
name|array
index|[
name|string
operator|->
name|length
index|]
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|doPaste
condition|)
block|{
if|if
condition|(
operator|(
name|Tc
operator|=
call|(
modifier|*
name|GetTc
call|)
argument_list|(
name|string
operator|->
name|array
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|picky
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: unknown 3270 key identifier\n"
argument_list|,
name|string
operator|->
name|array
argument_list|)
expr_stmt|;
block|}
name|Tc
operator|=
name|STATE_NULL
expr_stmt|;
block|}
block|}
else|else
block|{
name|Tc
operator|=
name|STATE_NULL
expr_stmt|;
comment|/* XXX ? */
block|}
end_if

begin_expr_stmt
name|GetWS
argument_list|()
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|GetCharacter
argument_list|(
literal|'='
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Required equal sign after 3270 key identifier %s missing\n"
argument_list|,
name|string
operator|->
name|array
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_if

begin_expr_stmt
name|GetWS
argument_list|()
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|GetInput
argument_list|(
name|Tc
argument_list|,
name|string
operator|->
name|array
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Missing definition part for 3270 key %s\n"
argument_list|,
name|string
operator|->
name|array
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
name|GetWS
argument_list|()
expr_stmt|;
while|while
condition|(
name|GetCharacter
argument_list|(
literal|'|'
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" or "
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* DEBUG */
name|GetWS
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|GetInput
argument_list|(
name|Tc
argument_list|,
name|string
operator|->
name|array
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Missing definition part for 3270 key %s\n"
argument_list|,
name|string
operator|->
name|array
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|GetWS
argument_list|()
expr_stmt|;
block|}
block|}
end_if

begin_expr_stmt
name|GetWS
argument_list|()
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|GetCharacter
argument_list|(
literal|';'
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Missing semi-colon for 3270 key %s\n"
argument_list|,
name|string
operator|->
name|array
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_if
if|if
condition|(
name|debug
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|";\n"
argument_list|)
expr_stmt|;
block|}
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG */
end_comment

begin_return
return|return
operator|(
literal|1
operator|)
return|;
end_return

begin_macro
unit|}   static
name|GetDefinitions
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
operator|!
name|GetDefinition
argument_list|()
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
while|while
condition|(
name|GetDefinition
argument_list|()
condition|)
block|{
empty_stmt|;
block|}
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_expr_stmt
specifier|static
name|GetBegin
argument_list|()
block|{
name|GetWS
argument_list|()
block|;
if|if
condition|(
operator|!
name|GetCharacter
argument_list|(
literal|'{'
argument_list|)
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_expr_stmt

begin_return
return|return
operator|(
literal|1
operator|)
return|;
end_return

begin_macro
unit|}  static
name|GetEnd
argument_list|()
end_macro

begin_block
block|{
name|GetWS
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|GetCharacter
argument_list|(
literal|'}'
argument_list|)
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_expr_stmt
specifier|static
name|GetName
argument_list|()
block|{
if|if
condition|(
operator|!
name|GetAlphaMericString
argument_list|()
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|GetWS
argument_list|()
expr_stmt|;
end_expr_stmt

begin_while
while|while
condition|(
name|GetAlphaMericString
argument_list|()
condition|)
block|{
name|GetWS
argument_list|()
expr_stmt|;
block|}
end_while

begin_return
return|return
operator|(
literal|1
operator|)
return|;
end_return

begin_macro
unit|}  static
name|GetNames
argument_list|()
end_macro

begin_block
block|{
name|GetWS
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|GetName
argument_list|()
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
name|GetWS
argument_list|()
expr_stmt|;
while|while
condition|(
name|GetCharacter
argument_list|(
literal|'|'
argument_list|)
condition|)
block|{
name|GetWS
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|GetName
argument_list|()
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_expr_stmt
specifier|static
name|GetEntry0
argument_list|()
block|{
if|if
condition|(
operator|!
name|GetBegin
argument_list|()
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"no '{'\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_expr_stmt

begin_elseif
elseif|else
if|if
condition|(
operator|!
name|GetDefinitions
argument_list|()
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"unable to parse the definitions\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_elseif

begin_elseif
elseif|else
if|if
condition|(
operator|!
name|GetEnd
argument_list|()
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No '}' or scanning stopped early due to error.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_elseif

begin_else
else|else
block|{
comment|/* done */
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_else

begin_macro
unit|}   static
name|GetEntry
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
operator|!
name|GetNames
argument_list|()
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Invalid name field in entry.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|GetEntry0
argument_list|()
operator|)
return|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* position ourselves within a given filename to the entry for the current  *	KEYBD (or TERM) variable  */
end_comment

begin_macro
name|Position
argument_list|(
argument|filename
argument_list|,
argument|keybdPointer
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|filename
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|keybdPointer
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|lexicon
name|lex
decl_stmt|;
name|stringWithLength
modifier|*
name|name
init|=
literal|0
decl_stmt|;
name|stringWithLength
modifier|*
name|oldName
decl_stmt|;
define|#
directive|define
name|Return
parameter_list|(
name|x
parameter_list|)
value|{doPaste = 1; return(x);}
name|doPaste
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|ourFile
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|MSDOS
argument_list|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unable to open file %s\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !defined(MSDOS) */
name|Return
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|lex
operator|=
name|Get
argument_list|()
expr_stmt|;
while|while
condition|(
name|lex
operator|.
name|type
operator|!=
name|LEX_END_OF_FILE
condition|)
block|{
name|UnGet
argument_list|(
name|lex
argument_list|)
expr_stmt|;
comment|/* now, find an entry that is our type. */
name|GetWS
argument_list|()
expr_stmt|;
name|oldName
operator|=
name|name
expr_stmt|;
if|if
condition|(
operator|(
name|name
operator|=
name|GetAlphaMericString
argument_list|()
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|ustrcmp
argument_list|(
name|name
operator|->
name|array
argument_list|,
name|keybdPointer
argument_list|)
condition|)
block|{
comment|/* need to make sure there is a name here... */
name|lex
operator|.
name|type
operator|=
name|LEX_CHAR
expr_stmt|;
name|lex
operator|.
name|value
operator|=
literal|'a'
expr_stmt|;
name|UnGet
argument_list|(
name|lex
argument_list|)
expr_stmt|;
name|Return
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GetCharacter
argument_list|(
literal|'|'
argument_list|)
condition|)
block|{
empty_stmt|;
comment|/* more names coming */
block|}
else|else
block|{
name|lex
operator|=
name|Get
argument_list|()
expr_stmt|;
name|UnGet
argument_list|(
name|lex
argument_list|)
expr_stmt|;
if|if
condition|(
name|lex
operator|.
name|type
operator|!=
name|LEX_END_OF_FILE
condition|)
block|{
if|if
condition|(
operator|!
name|GetEntry0
argument_list|()
condition|)
block|{
comment|/* start of an entry */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"error was in entry for %s in file %s\n"
argument_list|,
operator|(
name|oldName
operator|)
condition|?
name|oldName
operator|->
name|array
else|:
literal|"(unknown)"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|Return
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|lex
operator|=
name|Get
argument_list|()
expr_stmt|;
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|MSDOS
argument_list|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unable to find entry for %s in file %s\n"
argument_list|,
name|keybdPointer
argument_list|,
name|filename
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !defined(MSDOS) */
name|Return
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|char
modifier|*
name|strsave
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
specifier|extern
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
name|p
operator|=
name|malloc
argument_list|(
operator|(
name|unsigned
name|int
operator|)
name|strlen
argument_list|(
name|string
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
literal|0
condition|)
block|{
name|strcpy
argument_list|(
name|p
argument_list|,
name|string
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * InitControl - our interface to the outside.  What we should  *  do is figure out keyboard (or terminal) type, set up file pointer  *  (or string pointer), etc.  */
end_comment

begin_decl_stmt
name|state
modifier|*
name|InitControl
argument_list|(
name|keybdPointer
argument_list|,
name|pickyarg
argument_list|,
name|translator
argument_list|)
name|char
modifier|*
name|keybdPointer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pickyarg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Should we be picky? */
end_comment

begin_function_decl
name|int
function_decl|(
modifier|*
name|translator
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Translates ascii string to integer */
end_comment

begin_block
block|{
specifier|extern
name|char
modifier|*
name|getenv
parameter_list|()
function_decl|;
name|int
name|GotIt
decl_stmt|;
name|picky
operator|=
name|pickyarg
expr_stmt|;
name|GetTc
operator|=
name|translator
expr_stmt|;
if|if
condition|(
name|keybdPointer
operator|==
literal|0
condition|)
block|{
name|keybdPointer
operator|=
name|getenv
argument_list|(
literal|"KEYBD"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|keybdPointer
operator|==
literal|0
condition|)
block|{
name|keybdPointer
operator|=
name|getenv
argument_list|(
literal|"TERM"
argument_list|)
expr_stmt|;
block|}
comment|/* 		     * Some environments have getenv() return 		     * out of a static area.  So, save the keyboard name. 		     */
if|if
condition|(
name|keybdPointer
condition|)
block|{
name|keybdPointer
operator|=
name|strsave
argument_list|(
name|keybdPointer
argument_list|)
expr_stmt|;
block|}
name|environPointer
operator|=
name|getenv
argument_list|(
literal|"MAP3270"
argument_list|)
expr_stmt|;
if|if
condition|(
name|environPointer
operator|&&
operator|(
name|environPointer
index|[
literal|0
index|]
operator|!=
literal|'/'
operator|)
if|#
directive|if
name|defined
argument_list|(
name|MSDOS
argument_list|)
operator|&&
operator|(
name|environPointer
index|[
literal|0
index|]
operator|!=
literal|'\\'
operator|)
endif|#
directive|endif
comment|/* defined(MSDOS) */
operator|&&
operator|(
name|strncmp
argument_list|(
name|keybdPointer
argument_list|,
name|environPointer
argument_list|,
name|strlen
argument_list|(
name|keybdPointer
argument_list|)
operator|!=
literal|0
argument_list|)
operator|||
operator|(
name|environPointer
index|[
name|strlen
argument_list|(
name|keybdPointer
argument_list|)
index|]
operator|!=
literal|'{'
operator|)
operator|)
condition|)
comment|/* } */
block|{
name|environPointer
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|!
name|environPointer
operator|)
if|#
directive|if
name|defined
argument_list|(
name|MSDOS
argument_list|)
operator|||
operator|(
operator|*
name|environPointer
operator|==
literal|'\\'
operator|)
endif|#
directive|endif
comment|/* defined(MSDOS) */
operator|||
operator|(
operator|*
name|environPointer
operator|==
literal|'/'
operator|)
condition|)
block|{
name|usePointer
operator|=
literal|0
expr_stmt|;
name|GotIt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|keybdPointer
condition|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|MSDOS
argument_list|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s%s%s%s"
argument_list|,
literal|"Neither the KEYBD environment variable nor the TERM "
argument_list|,
literal|"environment variable\n(one of which is needed to determine "
argument_list|,
literal|"the type of keyboard you are using)\n"
argument_list|,
literal|"is set.  To set it, say 'setenv KEYBD<type>'\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !defined(MSDOS) */
block|}
else|else
block|{
if|if
condition|(
name|environPointer
condition|)
block|{
name|GotIt
operator|=
name|Position
argument_list|(
name|environPointer
argument_list|,
name|keybdPointer
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|GotIt
condition|)
block|{
name|GotIt
operator|=
name|Position
argument_list|(
literal|"/etc/map3270"
argument_list|,
name|keybdPointer
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|GotIt
condition|)
block|{
if|if
condition|(
name|environPointer
condition|)
block|{
name|GotIt
operator|=
name|Position
argument_list|(
name|environPointer
argument_list|,
literal|"unknown"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|GotIt
condition|)
block|{
name|GotIt
operator|=
name|Position
argument_list|(
literal|"/etc/map3270"
argument_list|,
name|keybdPointer
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|GotIt
condition|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|MSDOS
argument_list|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Using default key mappings.\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !defined(MSDOS) */
name|usePointer
operator|=
literal|1
expr_stmt|;
comment|/* flag use of non-file */
name|whichkey
operator|=
name|keysgeneric
expr_stmt|;
name|environPointer
operator|=
operator|*
name|whichkey
expr_stmt|;
comment|/* use default table */
block|}
block|}
else|else
block|{
name|usePointer
operator|=
literal|1
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|GetEntry
argument_list|()
expr_stmt|;
return|return
operator|(
name|firstentry
operator|.
name|address
operator|)
return|;
block|}
end_block

end_unit

