begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1988 Mark Nudleman  * Portions copyright (c) 1999 T. Michael Vanderhoek  * Copyright (c) 1988, 1993  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)command.c	8.1 (Berkeley) 6/6/93"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/*  * Functions for interacting with the user directly printing hello  * messages or reading from the terminal.  All of these functions deal  * specifically with the prompt line, and only the prompt line.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"less.h"
end_include

begin_include
include|#
directive|include
file|"pathnames.h"
end_include

begin_decl_stmt
specifier|extern
name|int
name|erase_char
decl_stmt|,
name|kill_char
decl_stmt|,
name|werase_char
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|sigs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|quit_at_eof
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|hit_eof
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|horiz_off
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|sc_width
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|bo_width
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|be_width
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|so_width
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|se_width
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|curr_ac
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|ac
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
modifier|*
name|av
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|screen_trashed
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The screen has been overwritten */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cmd_col
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current screen column when accepting input */
end_comment

begin_expr_stmt
specifier|static
name|cmd_char
argument_list|()
operator|,
name|cmd_erase
argument_list|()
operator|,
name|getcc
argument_list|()
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*****************************************************************************  *  * Functions for reading-in user input.  *  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|biggetinputhack_f
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* biggetinputhack()  *  * Performs as advertised.  */
end_comment

begin_macro
name|biggetinputhack
argument_list|()
end_macro

begin_block
block|{
name|biggetinputhack_f
operator|=
literal|1
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Read a line of input from the terminal.  Reads at most bufsiz - 1 characters  * and places them in buffer buf.  They are NUL-terminated.  Prints the  * temporary prompt prompt.  Returns true if the user aborted the input and  * returns false otherwise.  */
end_comment

begin_function
name|int
name|getinput
parameter_list|(
name|prompt
parameter_list|,
name|buf
parameter_list|,
name|bufsiz
parameter_list|)
specifier|const
name|char
modifier|*
name|prompt
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|bufsiz
decl_stmt|;
block|{
extern|extern bo_width
operator|,
extern|be_width;
name|char
modifier|*
name|bufcur
decl_stmt|;
name|int
name|c
decl_stmt|;
name|prmpt
argument_list|(
name|prompt
argument_list|)
expr_stmt|;
name|bufcur
operator|=
name|buf
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
name|getcc
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
operator|*
name|bufcur
operator|=
literal|'\0'
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|c
operator|==
name|READ_INTR
operator|||
name|cmd_char
argument_list|(
name|c
argument_list|,
name|buf
argument_list|,
operator|&
name|bufcur
argument_list|,
name|buf
operator|+
name|bufsiz
operator|-
literal|1
argument_list|)
condition|)
block|{
comment|/* input cancelled */
if|if
condition|(
name|bufsiz
condition|)
operator|*
name|buf
operator|=
literal|'\0'
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|biggetinputhack_f
condition|)
block|{
name|biggetinputhack_f
operator|=
literal|0
expr_stmt|;
operator|*
name|bufcur
operator|=
literal|'\0'
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Process a single character of a multi-character input, such as  * a number, or the pattern of a search command.  Returns true if the user  * has cancelled the multi-character input, false otherwise and attempts  * to add it to buf (not exceeding bufsize).  Prints the character on the  * terminal output.  The bufcur should initially equal bufbeg.  After that  * it does not need to be touched or modified by the user, but may be expected  * to point at the future position of the next character.  */
end_comment

begin_function
specifier|static
name|int
name|cmd_char
parameter_list|(
name|c
parameter_list|,
name|bufbeg
parameter_list|,
name|bufcur
parameter_list|,
name|bufend
parameter_list|)
name|int
name|c
decl_stmt|;
comment|/* The character to process */
name|char
modifier|*
name|bufbeg
decl_stmt|;
comment|/* The buffer to add the character to */
name|char
modifier|*
modifier|*
name|bufcur
decl_stmt|;
comment|/* The position at which to add the character */
name|char
modifier|*
name|bufend
decl_stmt|;
comment|/* One after the last address available in the buffer. 	                 * No character will be placed into *bufend. */
block|{
if|if
condition|(
name|c
operator|==
name|erase_char
condition|)
return|return
operator|(
name|cmd_erase
argument_list|(
name|bufbeg
argument_list|,
name|bufcur
argument_list|)
operator|)
return|;
comment|/* in this order, in case werase == erase_char */
if|if
condition|(
name|c
operator|==
name|werase_char
condition|)
block|{
if|if
condition|(
operator|*
name|bufcur
operator|>
name|bufbeg
condition|)
block|{
while|while
condition|(
name|isspace
argument_list|(
operator|(
operator|*
name|bufcur
operator|)
index|[
operator|-
literal|1
index|]
argument_list|)
operator|&&
operator|!
name|cmd_erase
argument_list|(
name|bufbeg
argument_list|,
name|bufcur
argument_list|)
condition|)
empty_stmt|;
while|while
condition|(
operator|!
name|isspace
argument_list|(
operator|(
operator|*
name|bufcur
operator|)
index|[
operator|-
literal|1
index|]
argument_list|)
operator|&&
operator|!
name|cmd_erase
argument_list|(
name|bufbeg
argument_list|,
name|bufcur
argument_list|)
condition|)
empty_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|(
operator|*
name|bufcur
operator|)
index|[
operator|-
literal|1
index|]
argument_list|)
operator|&&
operator|!
name|cmd_erase
argument_list|(
name|bufbeg
argument_list|,
name|bufcur
argument_list|)
condition|)
empty_stmt|;
block|}
return|return
operator|*
name|bufcur
operator|==
name|bufbeg
return|;
block|}
if|if
condition|(
name|c
operator|==
name|kill_char
condition|)
block|{
while|while
condition|(
operator|!
name|cmd_erase
argument_list|(
name|bufbeg
argument_list|,
name|bufcur
argument_list|)
condition|)
empty_stmt|;
return|return
literal|1
return|;
block|}
comment|/* 	 * No room in the command buffer, or no room on the screen; 	 * XXX If there is no room on the screen, we should just let the 	 * screen scroll down and set screen_trashed=1 appropriately, or 	 * alternatively, scroll the prompt line horizontally. 	 */
name|assert
argument_list|(
operator|*
name|bufcur
operator|<=
name|bufend
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|bufcur
operator|==
name|bufend
operator|||
name|cmd_col
operator|>=
name|sc_width
operator|-
literal|3
condition|)
name|bell
argument_list|()
expr_stmt|;
else|else
block|{
operator|*
operator|(
operator|*
name|bufcur
operator|)
operator|++
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|CONTROL_CHAR
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|putchr
argument_list|(
literal|'^'
argument_list|)
expr_stmt|;
name|cmd_col
operator|++
expr_stmt|;
name|c
operator|&=
operator|~
literal|0200
expr_stmt|;
name|c
operator|=
name|CARAT_CHAR
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
name|putchr
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|cmd_col
operator|++
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Helper function to cmd_char().  Backs-up one character from bufcur in the  * buffer passed, and prints a backspace on the screen.  Returns true if the  * we backspaced past bufbegin (ie. the input is being aborted), and false  * otherwise.  The bufcur is expected to point to the future location of the  * next character in the buffer, and is modified appropriately.  */
end_comment

begin_expr_stmt
specifier|static
name|cmd_erase
argument_list|(
argument|bufbegin
argument_list|,
argument|bufcur
argument_list|)
name|char
operator|*
name|bufbegin
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|bufcur
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|c
decl_stmt|;
comment|/* 	 * XXX Could add code to detect a backspace that is backing us over 	 * the beginning of a line and onto the previous line.  The backspace 	 * would not be printed for some terminals (eg. hardcopy) in that 	 * case. 	 */
comment|/* 	 * backspace past beginning of the string: this usually means 	 * abort the input. 	 */
if|if
condition|(
operator|*
name|bufcur
operator|==
name|bufbegin
condition|)
return|return
literal|1
return|;
operator|(
operator|*
name|bufcur
operator|)
operator|--
expr_stmt|;
comment|/* If erasing a control-char, erase an extra character for the carat. */
name|c
operator|=
operator|*
operator|*
name|bufcur
expr_stmt|;
if|if
condition|(
name|CONTROL_CHAR
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|backspace
argument_list|()
expr_stmt|;
name|cmd_col
operator|--
expr_stmt|;
block|}
name|backspace
argument_list|()
expr_stmt|;
name|cmd_col
operator|--
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_decl_stmt
specifier|static
name|int
name|ungotcc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Get command character from the terminal.  */
end_comment

begin_expr_stmt
specifier|static
name|getcc
argument_list|()
block|{
name|int
name|ch
block|;
name|off_t
name|position
argument_list|()
block|;
comment|/* left over from error() routine. */
if|if
condition|(
name|ungotcc
condition|)
block|{
name|ch
operator|=
name|ungotcc
expr_stmt|;
name|ungotcc
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|ch
operator|)
return|;
block|}
end_expr_stmt

begin_return
return|return
operator|(
name|getchr
argument_list|()
operator|)
return|;
end_return

begin_comment
unit|}
comment|/*  * Same as ungetc(), but works for people who don't like to use streams.  */
end_comment

begin_expr_stmt
unit|ungetcc
operator|(
name|c
operator|)
name|int
name|c
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|ungotcc
operator|=
name|c
expr_stmt|;
block|}
end_block

begin_comment
comment|/*****************************************************************************  *  * prompts  *  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|longprompt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Prints prmpt where the prompt would normally appear.  This is different  * from changing the current prompt --- this is more like printing a  * unimportant notice or error.  The prmpt line will be printed in bold (if  * possible).  Will in the future print only the last sc_width - 1 - bo_width  * characters (to prevent newline).    */
end_comment

begin_macro
name|prmpt
argument_list|(
argument|prmpt
argument_list|)
end_macro

begin_decl_stmt
specifier|const
name|char
modifier|*
name|prmpt
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|lower_left
argument_list|()
expr_stmt|;
name|clear_eol
argument_list|()
expr_stmt|;
name|bo_enter
argument_list|()
expr_stmt|;
name|putxstr
argument_list|(
name|prmpt
argument_list|)
expr_stmt|;
name|bo_exit
argument_list|()
expr_stmt|;
name|flush
argument_list|()
expr_stmt|;
name|cmd_col
operator|=
name|strlen
argument_list|(
name|prmpt
argument_list|)
operator|+
name|bo_width
operator|+
name|be_width
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Print the main prompt that signals we are ready for user commands.  This  * also magically positions the current file where it should be (either by  * calling repaint() if screen_trashed or by searching for a search  * string that was specified through option.c on the more(1) command line).  * Additional magic will randomly call the quit() function.  *  * This is really intended to do a lot of the work of commands().  It has  * little purpose outside of commands().  */
end_comment

begin_macro
name|prompt
argument_list|()
end_macro

begin_block
block|{
specifier|extern
name|int
name|linenums
decl_stmt|,
name|short_file
decl_stmt|,
name|ispipe
decl_stmt|;
specifier|extern
name|char
modifier|*
name|current_name
decl_stmt|,
modifier|*
name|firstsearch
decl_stmt|,
modifier|*
name|next_name
decl_stmt|;
name|off_t
name|len
decl_stmt|,
name|pos
decl_stmt|,
name|ch_length
argument_list|()
decl_stmt|,
name|position
argument_list|()
decl_stmt|,
name|forw_line
argument_list|()
decl_stmt|;
name|char
name|pbuf
index|[
literal|40
index|]
decl_stmt|;
comment|/* 	 * if nothing is displayed yet, display starting from line 1; 	 * if search string provided, go there instead. 	 */
if|if
condition|(
name|position
argument_list|(
name|TOP
argument_list|)
operator|==
name|NULL_POSITION
condition|)
block|{
if|#
directive|if
literal|0
comment|/* This code causes "more zero-byte-file /etc/termcap" to skip straight  * to the /etc/termcap file ... that is undesireable.  There are only a few  * instances where these two lines perform something useful. */
block|if (forw_line((off_t)0) == NULL_POSITION) 			return 0 ;
endif|#
directive|endif
if|if
condition|(
operator|!
name|firstsearch
operator|||
operator|!
name|search
argument_list|(
literal|1
argument_list|,
name|firstsearch
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
condition|)
name|jump_back
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|screen_trashed
condition|)
name|repaint
argument_list|()
expr_stmt|;
comment|/* if no -e flag and we've hit EOF on the last file, quit. */
if|if
condition|(
operator|!
name|quit_at_eof
operator|&&
name|hit_eof
operator|&&
name|curr_ac
operator|+
literal|1
operator|>=
name|ac
condition|)
name|quit
argument_list|()
expr_stmt|;
comment|/* select the proper prompt and display it. */
name|lower_left
argument_list|()
expr_stmt|;
name|clear_eol
argument_list|()
expr_stmt|;
name|pbuf
index|[
sizeof|sizeof
argument_list|(
name|pbuf
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|longprompt
condition|)
block|{
comment|/* 		 * Get the current line/pos from the BOTTOM of the screen 		 * even though that's potentially confusing for the user 		 * when switching between wraplines=true and a valid horiz_off 		 * (with wraplines=false).  In exchange, it is sometimes 		 * easier for the user to tell when a file is relatively 		 * short vs. long. 		 */
name|so_enter
argument_list|()
expr_stmt|;
name|putstr
argument_list|(
name|current_name
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
literal|":"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ispipe
condition|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|pbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|pbuf
argument_list|)
operator|-
literal|1
argument_list|,
literal|" file %d/%d"
argument_list|,
name|curr_ac
operator|+
literal|1
argument_list|,
name|ac
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
name|pbuf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|linenums
condition|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|pbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|pbuf
argument_list|)
operator|-
literal|1
argument_list|,
literal|" line %d"
argument_list|,
name|currline
argument_list|(
name|BOTTOM
argument_list|)
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
name|pbuf
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|pbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|pbuf
argument_list|)
operator|-
literal|1
argument_list|,
literal|" col %d"
argument_list|,
name|horiz_off
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
name|pbuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pos
operator|=
name|position
argument_list|(
name|BOTTOM
argument_list|)
operator|)
operator|!=
name|NULL_POSITION
condition|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|pbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|pbuf
argument_list|)
operator|-
literal|1
argument_list|,
literal|" byte %qd"
argument_list|,
name|pos
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
name|pbuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ispipe
operator|&&
operator|(
name|len
operator|=
name|ch_length
argument_list|()
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|pbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|pbuf
argument_list|)
operator|-
literal|1
argument_list|,
literal|"/%qd pct %qd%%"
argument_list|,
name|len
argument_list|,
operator|(
operator|(
literal|100
operator|*
name|pos
operator|)
operator|/
name|len
operator|)
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
name|pbuf
argument_list|)
expr_stmt|;
block|}
block|}
name|so_exit
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|so_enter
argument_list|()
expr_stmt|;
name|putstr
argument_list|(
name|current_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|hit_eof
condition|)
if|if
condition|(
name|next_name
condition|)
block|{
name|putstr
argument_list|(
literal|": END (next file: "
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
name|next_name
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
block|}
else|else
name|putstr
argument_list|(
literal|": END"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|ispipe
operator|&&
operator|(
name|pos
operator|=
name|position
argument_list|(
name|BOTTOM
argument_list|)
operator|)
operator|!=
name|NULL_POSITION
operator|&&
operator|(
name|len
operator|=
name|ch_length
argument_list|()
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|pbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|pbuf
argument_list|)
operator|-
literal|1
argument_list|,
literal|" (%qd%%)"
argument_list|,
operator|(
operator|(
literal|100
operator|*
name|pos
operator|)
operator|/
name|len
operator|)
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
name|pbuf
argument_list|)
expr_stmt|;
block|}
name|so_exit
argument_list|()
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_block

begin_comment
comment|/*  * Sets the current prompt.  Currently it sets the current prompt to the  * long prompt.  */
end_comment

begin_macro
name|statprompt
argument_list|(
argument|nostatprompt
argument_list|)
end_macro

begin_decl_stmt
name|int
name|nostatprompt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Turn off the stat prompt?  (off by default...) */
end_comment

begin_block
block|{
if|if
condition|(
name|nostatprompt
condition|)
name|longprompt
operator|=
literal|0
expr_stmt|;
else|else
name|longprompt
operator|=
literal|1
expr_stmt|;
block|}
end_block

begin_comment
comment|/*****************************************************************************  *  * Errors, next-of-kin to prompts.  *  */
end_comment

begin_comment
comment|/*  * Shortcut function that may be used when setting the current erreur  * and erreur string at the same time.  The function name is chosen to be  * symetric with the SETERR() macro in less.h.  This could be written as  * macro, too, but we'd need to use a GNU C extension.  */
end_comment

begin_macro
name|SETERRSTR
argument_list|(
argument|enum error e
argument_list|,
argument|const char *s
argument_list|,
argument|...
argument_list|)
end_macro

begin_block
block|{
name|va_list
name|args
decl_stmt|;
name|erreur
operator|=
name|e
expr_stmt|;
if|if
condition|(
name|errstr
condition|)
name|free
argument_list|(
name|errstr
argument_list|)
expr_stmt|;
name|errstr
operator|=
name|NULL
expr_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|vasprintf
argument_list|(
operator|&
name|errstr
argument_list|,
name|s
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Prints an error message and clears the current error.  */
end_comment

begin_macro
name|handle_error
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|erreur
operator|==
name|E_OK
condition|)
return|return;
name|bell
argument_list|()
expr_stmt|;
if|if
condition|(
name|errstr
condition|)
name|error
argument_list|(
name|errstr
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
name|deferr
index|[
name|erreur
index|]
argument_list|)
expr_stmt|;
name|erreur
operator|=
name|E_OK
expr_stmt|;
name|errstr
operator|=
name|NULL
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Clears any error messages and pretends they never occurred.  */
end_comment

begin_macro
name|clear_error
argument_list|()
end_macro

begin_block
block|{
name|erreur
operator|=
name|E_OK
expr_stmt|;
if|if
condition|(
name|errstr
condition|)
name|free
argument_list|(
name|errstr
argument_list|)
expr_stmt|;
name|errstr
operator|=
name|NULL
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|int
name|errmsgs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|return_to_continue
index|[]
init|=
literal|"(press RETURN)"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Output a message in the lower left corner of the screen  * and wait for carriage return.  */
end_comment

begin_comment
comment|/* static */
end_comment

begin_macro
name|error
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|extern
name|int
name|any_display
decl_stmt|;
name|int
name|ch
decl_stmt|;
name|errmsgs
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|any_display
condition|)
block|{
comment|/* 		 * Nothing has been displayed yet.  Output this message on 		 * error output (file descriptor 2) and don't wait for a 		 * keystroke to continue. 		 * 		 * This has the desirable effect of producing all error 		 * messages on error output if standard output is directed 		 * to a file.  It also does the same if we never produce 		 * any real output; for example, if the input file(s) cannot 		 * be opened.  If we do eventually produce output, code in 		 * edit() makes sure these messages can be seen before they 		 * are overwritten or scrolled away. 		 */
operator|(
name|void
operator|)
name|write
argument_list|(
literal|2
argument_list|,
name|s
argument_list|,
name|strlen
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|write
argument_list|(
literal|2
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
name|lower_left
argument_list|()
expr_stmt|;
name|clear_eol
argument_list|()
expr_stmt|;
name|so_enter
argument_list|()
expr_stmt|;
if|if
condition|(
name|s
condition|)
block|{
name|putstr
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
block|}
name|putstr
argument_list|(
name|return_to_continue
argument_list|)
expr_stmt|;
name|so_exit
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|ch
operator|=
name|getchr
argument_list|()
operator|)
operator|!=
literal|'\n'
condition|)
block|{
comment|/* XXX hardcoded */
if|if
condition|(
name|ch
operator|==
literal|'q'
condition|)
name|quit
argument_list|()
expr_stmt|;
name|ungotcc
operator|=
name|ch
expr_stmt|;
block|}
name|lower_left
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|==
name|NULL
operator|)
condition|?
literal|0
else|:
operator|(
name|strlen
argument_list|(
name|s
argument_list|)
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|return_to_continue
argument_list|)
operator|+
name|so_width
operator|+
name|se_width
operator|+
literal|1
operator|>
name|sc_width
condition|)
block|{
comment|/* 		 * Printing the message has probably scrolled the screen. 		 * {{ Unless the terminal doesn't have auto margins, 		 *    in which case we just hammered on the right margin. }} 		 */
comment|/* XXX Should probably just set screen_trashed=1, but I'm 		 * not going to touch that until all the places that call 		 * error() have been checked, or until error() is staticized. */
name|repaint
argument_list|()
expr_stmt|;
block|}
name|flush
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/****************************************************************************  *  * The main command processor.  *  * (Well, it deals with things on the prompt line, doesn't it?)  *  */
end_comment

begin_comment
comment|/*  * Main command processor.  *  * Accept and execute commands until a quit command, then return.  */
end_comment

begin_macro
name|commands
argument_list|()
end_macro

begin_block
block|{
name|enum
name|runmacro
name|runmacro
parameter_list|()
function_decl|;
name|enum
name|runmacro
name|rmret
decl_stmt|;
name|long
name|numberN
decl_stmt|;
enum|enum
block|{
name|NOTGOTTEN
init|=
literal|0
block|,
name|GOTTEN
init|=
literal|1
block|,
name|GETTING
block|}
name|Nstate
enum|;
comment|/* ie. numberNstate */
name|int
name|c
decl_stmt|;
name|char
name|inbuf
index|[
literal|20
index|]
decl_stmt|,
modifier|*
name|incur
init|=
name|inbuf
decl_stmt|;
operator|*
name|inbuf
operator|=
literal|'\0'
expr_stmt|;
name|Nstate
operator|=
name|GETTING
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 		 * See if any signals need processing. 		 */
if|if
condition|(
name|sigs
condition|)
name|psignals
argument_list|()
expr_stmt|;
comment|/* 		 * Display prompt and generally get setup.  Don't display the 		 * prompt if we are already in the middle of accepting a 		 * set of characters. 		 */
if|if
condition|(
operator|!
operator|*
name|inbuf
operator|&&
operator|!
name|prompt
argument_list|()
condition|)
block|{
name|next_file
argument_list|(
literal|1
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|c
operator|=
name|getcc
argument_list|()
expr_stmt|;
comment|/* Check sigs here --- getcc() may have given us READ_INTR */
if|if
condition|(
name|sigs
condition|)
block|{
comment|/* terminate any current macro */
operator|*
name|inbuf
operator|=
literal|'\0'
expr_stmt|;
name|incur
operator|=
name|inbuf
expr_stmt|;
continue|continue;
comment|/* process the sigs */
block|}
if|if
condition|(
name|Nstate
operator|==
name|GETTING
operator|&&
operator|!
name|isdigit
argument_list|(
name|c
argument_list|)
operator|&&
name|c
operator|!=
name|erase_char
operator|&&
name|c
operator|!=
name|werase_char
operator|&&
name|c
operator|!=
name|kill_char
condition|)
block|{
comment|/* 			 * Mark the end of an input number N, if any. 			 */
if|if
condition|(
operator|!
operator|*
name|inbuf
condition|)
block|{
comment|/* We never actually got an input number */
name|Nstate
operator|=
name|NOTGOTTEN
expr_stmt|;
block|}
else|else
block|{
name|numberN
operator|=
name|atol
argument_list|(
name|inbuf
argument_list|)
expr_stmt|;
name|Nstate
operator|=
name|GOTTEN
expr_stmt|;
block|}
operator|*
name|inbuf
operator|=
literal|'\0'
expr_stmt|;
name|incur
operator|=
name|inbuf
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|cmd_char
argument_list|(
name|c
argument_list|,
name|inbuf
argument_list|,
operator|&
name|incur
argument_list|,
name|inbuf
operator|+
sizeof|sizeof
argument_list|(
name|inbuf
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
operator|*
name|incur
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|*
name|inbuf
condition|)
name|prmpt
argument_list|(
name|inbuf
argument_list|)
expr_stmt|;
else|else
name|Nstate
operator|=
name|GETTING
expr_stmt|;
comment|/* abort command */
if|if
condition|(
name|Nstate
operator|==
name|GETTING
condition|)
block|{
comment|/* Still reading in the number N ... don't want to 			 * try running the macro expander. */
continue|continue;
block|}
else|else
block|{
comment|/* Try expanding the macro */
switch|switch
condition|(
name|runmacro
argument_list|(
name|inbuf
argument_list|,
name|numberN
argument_list|,
name|Nstate
argument_list|)
condition|)
block|{
case|case
name|TOOMACRO
case|:
break|break;
case|case
name|BADMACRO
case|:
case|case
name|NOMACRO
case|:
case|case
name|BADCOMMAND
case|:
name|handle_error
argument_list|()
expr_stmt|;
comment|/* fallthrough */
case|case
name|OK
case|:
comment|/* recock */
operator|*
name|inbuf
operator|=
literal|'\0'
expr_stmt|;
name|incur
operator|=
name|inbuf
expr_stmt|;
name|Nstate
operator|=
name|GETTING
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* for (;;) */
block|}
end_block

begin_comment
comment|/*****************************************************************************  *  * Misc functions that belong in ncommand.c but are here for historical  * and for copyright reasons.  *   */
end_comment

begin_macro
name|editfile
argument_list|()
end_macro

begin_block
block|{
name|off_t
name|position
parameter_list|()
function_decl|;
specifier|extern
name|char
modifier|*
name|current_file
decl_stmt|;
specifier|static
name|int
name|dolinenumber
decl_stmt|;
specifier|static
name|char
modifier|*
name|editor
decl_stmt|;
name|char
modifier|*
name|base
decl_stmt|;
name|int
name|linenumber
decl_stmt|;
name|char
name|buf
index|[
name|MAXPATHLEN
operator|*
literal|2
operator|+
literal|20
index|]
decl_stmt|,
modifier|*
name|getenv
argument_list|()
decl_stmt|;
if|if
condition|(
name|editor
operator|==
name|NULL
condition|)
block|{
name|editor
operator|=
name|getenv
argument_list|(
literal|"EDITOR"
argument_list|)
expr_stmt|;
comment|/* default editor is vi */
if|if
condition|(
name|editor
operator|==
name|NULL
operator|||
operator|*
name|editor
operator|==
literal|'\0'
condition|)
name|editor
operator|=
name|_PATH_VI
expr_stmt|;
comment|/* check last component in case of full path */
name|base
operator|=
name|strrchr
argument_list|(
name|editor
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|base
condition|)
name|base
operator|=
name|editor
expr_stmt|;
else|else
name|base
operator|++
expr_stmt|;
comment|/* emacs also accepts vi-style +nnnn */
if|if
condition|(
name|strncmp
argument_list|(
name|base
argument_list|,
literal|"vi"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|base
argument_list|,
literal|"emacs"
argument_list|)
operator|==
literal|0
condition|)
name|dolinenumber
operator|=
literal|1
expr_stmt|;
else|else
name|dolinenumber
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * XXX Can't just use currline(MIDDLE) since that might be NULL_POSITION 	 * if we are editting a short file or some kind of search positioned 	 * us near the last line.  It's not clear what currline() should do 	 * in those circumstances, but as of this writing, it doesn't do 	 * anything reasonable from our perspective.  The currline(MIDDLE) 	 * never had the desired results for an editfile() after a search() 	 * anyways.  Note, though, that when vi(1) starts its editting, it 	 * positions the focus line in the middle of the screen, not the top. 	 * 	 * I think what is needed is some kind of setfocus() and getfocus() 	 * function.  This could put the focussed line in the middle, top, 	 * or wherever as per the user's wishes, and allow things like us 	 * to getfocus() the correct file-position/line-number.  A search would 	 * then search forward (or backward) from the current focus position, 	 * etc. 	 * 	 * currline() doesn't belong. 	 */
if|if
condition|(
name|position
argument_list|(
name|MIDDLE
argument_list|)
operator|==
name|NULL_POSITION
condition|)
name|linenumber
operator|=
name|currline
argument_list|(
name|TOP
argument_list|)
expr_stmt|;
else|else
name|linenumber
operator|=
name|currline
argument_list|(
name|MIDDLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|dolinenumber
operator|&&
name|linenumber
condition|)
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%s +%d %s"
argument_list|,
name|editor
argument_list|,
name|linenumber
argument_list|,
name|current_file
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%s %s"
argument_list|,
name|editor
argument_list|,
name|current_file
argument_list|)
expr_stmt|;
name|lsystem
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|showlist
argument_list|()
end_macro

begin_block
block|{
specifier|extern
name|int
name|sc_width
decl_stmt|;
specifier|register
name|int
name|indx
decl_stmt|,
name|width
decl_stmt|;
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|ac
operator|<=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"No files provided as arguments."
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|width
operator|=
name|indx
operator|=
literal|0
init|;
name|indx
operator|<
name|ac
condition|;
control|)
block|{
name|p
operator|=
name|strcmp
argument_list|(
name|av
index|[
name|indx
index|]
argument_list|,
literal|"-"
argument_list|)
condition|?
name|av
index|[
name|indx
index|]
else|:
literal|"stdin"
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|p
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|curr_ac
operator|==
name|indx
condition|)
name|len
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|width
operator|+
name|len
operator|+
literal|1
operator|>=
name|sc_width
condition|)
block|{
if|if
condition|(
operator|!
name|width
condition|)
block|{
if|if
condition|(
name|curr_ac
operator|==
name|indx
condition|)
name|putchr
argument_list|(
literal|'['
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|curr_ac
operator|==
name|indx
condition|)
name|putchr
argument_list|(
literal|']'
argument_list|)
expr_stmt|;
operator|++
name|indx
expr_stmt|;
block|}
name|width
operator|=
literal|0
expr_stmt|;
name|putchr
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|width
condition|)
name|putchr
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|curr_ac
operator|==
name|indx
condition|)
name|putchr
argument_list|(
literal|'['
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|curr_ac
operator|==
name|indx
condition|)
name|putchr
argument_list|(
literal|']'
argument_list|)
expr_stmt|;
name|width
operator|+=
name|len
expr_stmt|;
operator|++
name|indx
expr_stmt|;
block|}
name|putchr
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|error
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

