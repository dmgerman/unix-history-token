begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1999 Timmy M. Vanderhoek  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/*  * These functions handle evaluation of primitive commands.  In general,  * commands either come from macro.h as it expands user input, or  * directly from a .morerc file (in which case only a limited set of  * commands is valid.  *  * Commands are matched by command() against a command table.  The rest  * of the command line string passed to command() is then passed to a  * function corresponding to the given command.  The specific command  * function evaluates the remainder of the command string with the help  * of getstr() and getnumb(), both of which also handle variable expansion  * into a single word.  It may in the future be desirable to add a special  * getsstring(), get-search-string, function.  Specific command functions  * should not try grokking the command string by themselves.  *  * A command and its arguments are terminated by either a NUL or a ';'.  * This is recognized by both getstr() and getint().  Specific command  * functions return a pointer to the end of the command (and its arguments)  * thus allowing command() to accept commands that are chained together  * by semicolons.  If a specific command fails it returns NULL preventing  * any proceeding commands (chained together with ';') from being parsed.  * This can be considered as a feature.  *   * All variable-access functions and variable state are internal to  * ncommand.c.  The sole exceptions are setvar() and setvari().  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"less.h"
end_include

begin_include
include|#
directive|include
file|"pathnames.h"
end_include

begin_expr_stmt
specifier|static
name|getint
argument_list|()
operator|,
name|getstr_free
argument_list|()
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|void
modifier|*
modifier|*
name|getstr_raisectxt
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* The internal command table. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|cscroll
argument_list|()
decl_stmt|,
modifier|*
name|cquit
argument_list|()
decl_stmt|,
modifier|*
name|cerror
argument_list|()
decl_stmt|,
modifier|*
name|ceval
argument_list|()
decl_stmt|,
modifier|*
name|cset
argument_list|()
decl_stmt|,
modifier|*
name|cflush
argument_list|()
decl_stmt|,
modifier|*
name|cmacro
argument_list|()
decl_stmt|,
modifier|*
name|caskfile
argument_list|()
decl_stmt|,
modifier|*
name|cusercom
argument_list|()
decl_stmt|,
modifier|*
name|ctags
argument_list|()
decl_stmt|,
modifier|*
name|chscroll
argument_list|()
decl_stmt|,
modifier|*
name|cgomisc
argument_list|()
decl_stmt|,
modifier|*
name|cgoend
argument_list|()
decl_stmt|,
modifier|*
name|csearch
argument_list|()
decl_stmt|,
modifier|*
name|cstat
argument_list|()
decl_stmt|,
modifier|*
name|cdeftog
argument_list|()
decl_stmt|,
modifier|*
name|ccondition
argument_list|()
decl_stmt|,
modifier|*
name|chelp
argument_list|()
decl_stmt|,
modifier|*
name|cfile
argument_list|()
decl_stmt|,
modifier|*
name|cfile_list
argument_list|()
decl_stmt|,
modifier|*
name|cedit
argument_list|()
decl_stmt|,
modifier|*
name|cmark
argument_list|()
decl_stmt|,
modifier|*
name|creadrc
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* An enum identifying each command */
end_comment

begin_enum
enum|enum
name|cident
block|{
name|DEFTOG
block|,
comment|/* Initialize toggle values */
name|EVAL
block|,
comment|/* Evaluate a subexpression */
name|SET
block|,
comment|/* Set a variable */
name|MACRO
block|,
comment|/* Create a new macro */
name|ERROR
block|,
comment|/* Print a notification message */
name|CONDITION
block|,
comment|/* Condition evaluation of (almost) _all_ commands */
name|CONDITION_N
block|,
comment|/* CONDITION with an inverse truth table */
name|CONDITION_TOGGLE
block|,
comment|/* Switch to the reverse sense of the last condition */
name|USERCOM
block|,
comment|/* Get the user to type in a direct command */
name|READRC
block|,
comment|/* Read-in a named rc file */
name|QUIT
block|,
comment|/* Quit */
name|HELP
block|,
comment|/* Help */
name|FLUSH
block|,
comment|/* Flush file buffer and friends */
name|REPAINT
block|,
comment|/* Redraw the screen (useful if it got trashed) */
name|FORW_SCROLL
block|,
comment|/* Scroll forward N lines */
name|BACK_SCROLL
block|,
comment|/* Scroll backward N lines */
name|FORW
block|,
comment|/* Jump or scroll forward N lines */
name|BACK
block|,
comment|/* Jump or scroll backwards N lines */
name|LSCROLL
block|,
comment|/* Scroll horizontally leftwards */
name|RSCROLL
block|,
comment|/* Scroll horizontally to the right */
name|GOLINE
block|,
comment|/* Goto line number N */
name|GOPERCENT
block|,
comment|/* Goto percent N of the file */
name|GOEND
block|,
comment|/* Goto the end of the file */
name|EDIT
block|,
comment|/* Edit the current file, using getenv(EDITOR) */
name|ASKFILE
block|,
comment|/* Ask for a different, new file */
name|CFILE
block|,
comment|/* Page/view the N'th next or prev file */
name|FILE_LIST
block|,
comment|/* List the files that CFILE moves around in */
name|STAT
block|,
comment|/* List detailed file statistics in prompt */
name|MAGICASKSEARCH
block|,
comment|/* Ask for a regexp search string */
name|SEARCH
block|,
comment|/* Search for a regexp */
name|RESEARCH
block|,
comment|/* Search for the next N'th occurrence */
name|SETMARK
block|,
comment|/* Set a bookmark to the current position */
name|GOMARK
block|,
comment|/* Goto a previously set bookmark */
name|ASKFTAG
block|,
comment|/* Ask for a tag to goto */
name|NEXTFTAG
block|,
comment|/* Move forward N in the tag queue */
name|PREVFTAG
block|,
comment|/* Move backwards N in the tag queue */
block|}
enum|;
end_enum

begin_struct
specifier|static
struct|struct
name|ctable
block|{
specifier|const
name|char
modifier|*
name|cname
decl_stmt|;
name|enum
name|cident
name|cident
decl_stmt|;
specifier|const
name|char
modifier|*
function_decl|(
modifier|*
name|cfunc
function_decl|)
parameter_list|(
name|enum
name|cident
parameter_list|,
specifier|const
name|char
modifier|*
name|args
parameter_list|)
function_decl|;
block|}
name|ctable
index|[]
init|=
block|{
block|{
literal|"deftog"
block|,
name|DEFTOG
block|,
name|cdeftog
block|}
block|,
block|{
literal|"eval"
block|,
name|EVAL
block|,
name|ceval
block|}
block|,
block|{
literal|"set"
block|,
name|SET
block|,
name|cset
block|}
block|,
block|{
literal|"macro"
block|,
name|MACRO
block|,
name|cmacro
block|}
block|,
block|{
literal|"error"
block|,
name|ERROR
block|,
name|cerror
block|}
block|,
block|{
literal|"condition"
block|,
name|CONDITION
block|,
name|ccondition
block|}
block|,
block|{
literal|"condition_!"
block|,
name|CONDITION_N
block|,
name|ccondition
block|}
block|,
block|{
literal|"condition_toggle"
block|,
name|CONDITION_TOGGLE
block|,
name|ccondition
block|}
block|,
block|{
literal|"condition_else"
block|,
name|CONDITION_TOGGLE
block|,
name|ccondition
block|}
block|,
block|{
literal|"usercom"
block|,
name|USERCOM
block|,
name|cusercom
block|}
block|,
block|{
literal|"readrc"
block|,
name|READRC
block|,
name|creadrc
block|}
block|,
block|{
literal|"quit"
block|,
name|QUIT
block|,
name|cquit
block|}
block|,
block|{
literal|"help"
block|,
name|HELP
block|,
name|chelp
block|}
block|,
block|{
literal|"flush"
block|,
name|FLUSH
block|,
name|cflush
block|}
block|,
block|{
literal|"repaint"
block|,
name|REPAINT
block|,
name|cflush
block|}
block|,
block|{
literal|"forw_scroll"
block|,
name|FORW_SCROLL
block|,
name|cscroll
block|}
block|,
block|{
literal|"back_scroll"
block|,
name|BACK_SCROLL
block|,
name|cscroll
block|}
block|,
block|{
literal|"forw"
block|,
name|FORW
block|,
name|cscroll
block|}
block|,
block|{
literal|"back"
block|,
name|BACK
block|,
name|cscroll
block|}
block|,
block|{
literal|"rscroll"
block|,
name|RSCROLL
block|,
name|chscroll
block|}
block|,
block|{
literal|"lscroll"
block|,
name|LSCROLL
block|,
name|chscroll
block|}
block|,
block|{
literal|"goline"
block|,
name|GOLINE
block|,
name|cgomisc
block|}
block|,
block|{
literal|"gopercent"
block|,
name|GOPERCENT
block|,
name|cgomisc
block|}
block|,
block|{
literal|"goend"
block|,
name|GOEND
block|,
name|cgoend
block|}
block|,
block|{
literal|"edit"
block|,
name|EDIT
block|,
name|cedit
block|}
block|,
block|{
literal|"askfile"
block|,
name|ASKFILE
block|,
name|caskfile
block|}
block|,
block|{
literal|"file"
block|,
name|CFILE
block|,
name|cfile
block|}
block|,
block|{
literal|"file_list"
block|,
name|FILE_LIST
block|,
name|cfile_list
block|}
block|,
block|{
literal|"stat"
block|,
name|STAT
block|,
name|cstat
block|}
block|,
block|{
literal|"magicasksearch"
block|,
name|MAGICASKSEARCH
block|,
name|csearch
block|}
block|,
block|{
literal|"search"
block|,
name|SEARCH
block|,
name|csearch
block|}
block|,
block|{
literal|"research"
block|,
name|RESEARCH
block|,
name|csearch
block|}
block|,
block|{
literal|"setmark"
block|,
name|SETMARK
block|,
name|cmark
block|}
block|,
block|{
literal|"gomark"
block|,
name|GOMARK
block|,
name|cmark
block|}
block|,
block|{
literal|"asktag"
block|,
name|ASKFTAG
block|,
name|ctags
block|}
block|,
block|{
literal|"nexttag"
block|,
name|NEXTFTAG
block|,
name|ctags
block|}
block|,
block|{
literal|"prevtag"
block|,
name|PREVFTAG
block|,
name|ctags
block|}
block|, }
struct|;
end_struct

begin_comment
comment|/* I believe this is just for cosmetic purposes. */
end_comment

begin_define
define|#
directive|define
name|CMD_EXEC
value|lower_left(); flush()
end_define

begin_comment
comment|/*  * Prototypes are for people who can't program.  */
end_comment

begin_comment
comment|/*  * The main command string evaluator.  Returns -1 if an error occurred  * in the command or in executing the command, returns 0 otherwise.  If an  * error occurs while evaluating a command line containing multiple commands,  * commands after the error are not processed.  Multiple commands may be  * separated by ';' or '\n'.  (Multiple commands may also be separated by  * a ' ', but this is really a bug...)  */
end_comment

begin_function
name|int
name|command
parameter_list|(
name|line
parameter_list|)
specifier|const
name|char
modifier|*
name|line
decl_stmt|;
block|{
name|struct
name|ctable
modifier|*
name|i
decl_stmt|;
name|donextcommand
label|:
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|line
argument_list|)
operator|||
operator|*
name|line
operator|==
literal|';'
operator|||
operator|*
name|line
operator|==
literal|'\n'
condition|)
name|line
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|line
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
name|ctable
init|;
name|i
operator|!=
name|ctable
operator|+
sizeof|sizeof
argument_list|(
name|ctable
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|ctable
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|i
operator|->
name|cname
argument_list|,
name|line
argument_list|,
name|strlen
argument_list|(
name|i
operator|->
name|cname
argument_list|)
argument_list|)
operator|&&
operator|(
name|line
index|[
name|strlen
argument_list|(
name|i
operator|->
name|cname
argument_list|)
index|]
operator|==
literal|' '
operator|||
name|line
index|[
name|strlen
argument_list|(
name|i
operator|->
name|cname
argument_list|)
index|]
operator|==
literal|';'
operator|||
name|line
index|[
name|strlen
argument_list|(
name|i
operator|->
name|cname
argument_list|)
index|]
operator|==
literal|'\0'
operator|)
condition|)
block|{
comment|/* Found a match! */
name|void
modifier|*
modifier|*
name|ctxt
decl_stmt|;
name|CMD_EXEC
expr_stmt|;
name|ctxt
operator|=
name|getstr_raisectxt
argument_list|()
expr_stmt|;
name|line
operator|=
name|i
operator|->
name|cfunc
argument_list|(
name|i
operator|->
name|cident
argument_list|,
name|line
operator|+
name|strlen
argument_list|(
name|i
operator|->
name|cname
argument_list|)
argument_list|)
expr_stmt|;
name|getstr_free
argument_list|(
name|ctxt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|line
condition|)
return|return
operator|-
literal|1
return|;
comment|/* error evaluating command */
goto|goto
name|donextcommand
goto|;
block|}
block|}
name|SETERRSTR
argument_list|(
name|E_BOGCOM
argument_list|,
literal|"invalid command: ``%s''"
argument_list|,
name|line
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|command
argument_list|(
literal|"condition true"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************  *  * Functions to help specific command functions to parse their arguments.  *  * The three functions here, getstr(), getint(), and gettog() could in theory  * have vastly different concepts of what a number is, and what a string is,  * etc., but in practice they don't.  */
end_comment

begin_function_decl
specifier|static
name|char
modifier|*
name|readvar
parameter_list|()
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|NCTXTS
value|30
end_define

begin_decl_stmt
name|void
modifier|*
name|getstr_ctxts
index|[
name|NCTXTS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* could easily be made dynamic... */
end_comment

begin_decl_stmt
name|void
modifier|*
modifier|*
name|getstr_curctxt
init|=
name|getstr_ctxts
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Read a single argument string from a command string.  This understands  * $variables, "double quotes", 'single quotes', and backslash escapes  * for \\, \$, \n, \e, \t, and \" (the latter only inside double quotes).  A  * string may be delimited by double quotes or spaces, not both (duh).  It  * may be worthwhile to add another quotation style in which arithmetic  * expressions are expanded.  Currently an arithmetic expression is expanded  * iff it is the only component of the string.  *  * Returns a pointer to the beginning of the string or NULL if it was unable to  * read a string.  The line is modified to point somewhere between the end of  * the command argument just read-in and the beginning of the next command  * argument (if any).  The returned pointer will be free()'d by calling  * getstr_free().  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|getstr
parameter_list|(
name|line
parameter_list|)
name|char
modifier|*
modifier|*
name|line
decl_stmt|;
comment|/* Where to look for the return string */
block|{
name|int
name|doquotes
init|=
literal|0
decl_stmt|;
comment|/* Doing a double-quote string */
name|char
modifier|*
name|retr
decl_stmt|;
if|if
condition|(
name|getstr_curctxt
operator|-
name|getstr_ctxts
operator|==
name|NCTXTS
condition|)
block|{
name|SETERRSTR
argument_list|(
name|E_COMPLIM
argument_list|,
literal|"compile-time limit exceeded: command contexts"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
comment|/* wouldn't be able to register return pointer */
block|}
while|while
condition|(
name|isspace
argument_list|(
operator|*
operator|*
name|line
argument_list|)
condition|)
operator|(
operator|*
name|line
operator|)
operator|++
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|line
operator|==
literal|'\''
condition|)
block|{
comment|/* Read until closing quote or '\0'. */
name|char
modifier|*
name|nextw
init|=
name|retr
operator|=
name|malloc
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|char
modifier|*
name|c
init|=
operator|++
operator|(
operator|*
name|line
operator|)
decl_stmt|;
name|int
name|l
decl_stmt|;
for|for
control|(
init|;
operator|*
name|c
condition|;
name|c
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|c
operator|==
literal|'\''
condition|)
block|{
if|if
condition|(
name|c
index|[
operator|-
literal|1
index|]
operator|==
literal|'\\'
condition|)
block|{
name|nextw
index|[
operator|-
literal|1
index|]
operator|=
literal|'\''
expr_stmt|;
continue|continue;
block|}
else|else
block|{
operator|*
name|nextw
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|line
operator|=
name|c
operator|+
literal|1
expr_stmt|;
operator|*
name|getstr_curctxt
operator|=
name|retr
expr_stmt|;
name|getstr_curctxt
operator|++
expr_stmt|;
return|return
name|retr
return|;
block|}
block|}
name|l
operator|=
name|nextw
operator|-
name|retr
expr_stmt|;
comment|/* XXX How many realloc()'s can you make per second? */
if|if
condition|(
operator|!
operator|(
name|retr
operator|=
name|reallocf
argument_list|(
name|retr
argument_list|,
name|c
operator|-
operator|*
name|line
operator|+
literal|250
argument_list|)
operator|)
condition|)
block|{
name|SETERR
argument_list|(
name|E_MALLOC
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|nextw
operator|=
name|retr
operator|+
name|l
expr_stmt|;
operator|*
name|nextw
operator|=
operator|*
name|c
expr_stmt|;
name|nextw
operator|++
expr_stmt|;
block|}
name|SETERR
argument_list|(
name|E_CANTPARSE
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|*
operator|*
name|line
operator|==
literal|'"'
condition|)
block|{
name|doquotes
operator|=
literal|1
expr_stmt|;
operator|(
operator|*
name|line
operator|)
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
operator|*
name|line
operator|==
literal|'('
condition|)
block|{
comment|/* An arithmetic expression instead of a string...  Well, I 		 * guess this is valid.  See comment leading this function. */
name|int
name|n
decl_stmt|;
if|if
condition|(
name|getint
argument_list|(
operator|&
name|n
argument_list|,
name|line
argument_list|)
condition|)
return|return
name|NULL
return|;
name|retr
operator|=
name|NULL
expr_stmt|;
name|asprintf
argument_list|(
operator|&
name|retr
argument_list|,
literal|"%d"
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|retr
condition|)
name|SETERR
argument_list|(
name|E_MALLOC
argument_list|)
expr_stmt|;
operator|*
name|getstr_curctxt
operator|=
name|retr
expr_stmt|;
name|getstr_curctxt
operator|++
expr_stmt|;
return|return
name|retr
return|;
block|}
if|if
condition|(
operator|!
name|FMALLOC
argument_list|(
literal|1
argument_list|,
name|retr
argument_list|)
condition|)
return|return
name|NULL
return|;
operator|*
name|retr
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|char
modifier|*
name|c
decl_stmt|,
name|hack
index|[
literal|2
index|]
decl_stmt|;
switch|switch
condition|(
operator|*
operator|*
name|line
condition|)
block|{
case|case
literal|'\\'
case|:
switch|switch
condition|(
operator|*
operator|(
operator|*
name|line
operator|+
literal|1
operator|)
condition|)
block|{
case|case
literal|'\\'
case|:
case|case
literal|'$'
case|:
case|case
literal|'\''
case|:
case|case
literal|'t'
case|:
case|case
literal|' '
case|:
case|case
literal|';'
case|:
name|hack
index|[
literal|0
index|]
operator|=
operator|*
operator|(
operator|*
name|line
operator|+
literal|1
operator|)
expr_stmt|;
name|hack
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|c
operator|=
name|hack
expr_stmt|;
operator|(
operator|*
name|line
operator|)
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|c
operator|=
literal|"\n"
expr_stmt|;
operator|(
operator|*
name|line
operator|)
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|c
operator|=
literal|"\e"
expr_stmt|;
operator|(
operator|*
name|line
operator|)
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
literal|'"'
case|:
if|if
condition|(
name|doquotes
condition|)
block|{
name|c
operator|=
literal|"\""
expr_stmt|;
operator|(
operator|*
name|line
operator|)
operator|+=
literal|2
expr_stmt|;
break|break;
block|}
else|else
empty_stmt|;
comment|/* fallthrough */
default|default:
name|c
operator|=
literal|"\\"
expr_stmt|;
operator|(
operator|*
name|line
operator|)
operator|++
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'$'
case|:
operator|(
operator|*
name|line
operator|)
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|c
operator|=
name|readvar
argument_list|(
name|line
argument_list|)
operator|)
condition|)
block|{
name|free
argument_list|(
name|retr
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
break|break;
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
case|case
literal|';'
case|:
if|if
condition|(
operator|!
name|doquotes
condition|)
block|{
name|doquotes
operator|=
literal|1
expr_stmt|;
case|case
literal|'"'
case|:
if|if
condition|(
name|doquotes
condition|)
block|{
comment|/* The end of the string */
operator|(
operator|*
name|line
operator|)
operator|++
expr_stmt|;
case|case
literal|'\0'
case|:
operator|*
name|getstr_curctxt
operator|=
name|retr
expr_stmt|;
name|getstr_curctxt
operator|++
expr_stmt|;
return|return
name|retr
return|;
block|}
block|}
comment|/* fallthrough */
default|default:
name|hack
index|[
literal|0
index|]
operator|=
operator|*
operator|*
name|line
expr_stmt|;
name|hack
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|c
operator|=
name|hack
expr_stmt|;
operator|(
operator|*
name|line
operator|)
operator|++
expr_stmt|;
break|break;
block|}
name|retr
operator|=
name|reallocf
argument_list|(
name|retr
argument_list|,
name|strlen
argument_list|(
name|retr
argument_list|)
operator|+
name|strlen
argument_list|(
name|c
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|retr
condition|)
block|{
name|SETERR
argument_list|(
name|E_MALLOC
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|strcat
argument_list|(
name|retr
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Returns a new context that should be passed to getstr_free() so that  * getstr_free() only free()'s memory from that particular context.  */
end_comment

begin_function
specifier|static
name|void
modifier|*
modifier|*
name|getstr_raisectxt
parameter_list|()
block|{
return|return
name|getstr_curctxt
return|;
block|}
end_function

begin_comment
comment|/*  * Calls free() on all memory from context or higher.  */
end_comment

begin_expr_stmt
specifier|static
name|getstr_free
argument_list|(
argument|context
argument_list|)
name|void
operator|*
operator|*
name|context
expr_stmt|;
end_expr_stmt

begin_block
block|{
while|while
condition|(
name|getstr_curctxt
operator|!=
name|context
condition|)
block|{
name|getstr_curctxt
operator|--
expr_stmt|;
name|free
argument_list|(
operator|*
name|getstr_curctxt
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Reads an integer value from a command string.  Typed numbers must be  * in base10.  If a '(' is found as the first character of the integer value,  * then getint() will read until a closing ')' unless interupted by an  * end-of-command marker (error).  The parentheses are expected to contain a  * simple arithmetic statement involving only one '*', '/', etc. operation.  The  * rightmost digit or the closing parenthesis should be followed by either a  * space or an end-of-command marker.  *  * Returns 0 on success, -1 on failure.  The line will be modified to just  * after the last piece of text parsed.  *  * XXX We may add support for negative numbers, someday...  */
end_comment

begin_function
specifier|static
name|int
name|getint
parameter_list|(
name|numb
parameter_list|,
name|line
parameter_list|)
name|long
modifier|*
name|numb
decl_stmt|;
comment|/* The read-in number is returned through this */
name|char
modifier|*
modifier|*
name|line
decl_stmt|;
comment|/* The command line from which to read numb */
block|{
name|long
name|n
decl_stmt|;
name|int
name|j
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|t
decl_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
operator|*
name|line
argument_list|)
condition|)
operator|(
operator|*
name|line
operator|)
operator|++
expr_stmt|;
switch|switch
condition|(
operator|*
operator|*
name|line
condition|)
block|{
case|case
literal|'('
case|:
operator|(
operator|*
name|line
operator|)
operator|++
expr_stmt|;
if|if
condition|(
name|getint
argument_list|(
name|numb
argument_list|,
name|line
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
operator|*
name|line
argument_list|)
condition|)
operator|(
operator|*
name|line
operator|)
operator|++
expr_stmt|;
name|j
operator|=
operator|*
operator|*
name|line
expr_stmt|;
operator|(
operator|*
name|line
operator|)
operator|++
expr_stmt|;
if|if
condition|(
name|j
operator|==
literal|')'
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|*
operator|*
name|line
operator|==
literal|'='
operator|&&
operator|(
name|j
operator|==
literal|'!'
operator|||
name|j
operator|==
literal|'='
operator|)
operator|||
name|j
operator|==
literal|'&'
operator|&&
operator|*
operator|*
name|line
operator|==
literal|'&'
operator|||
name|j
operator|==
literal|'|'
operator|&&
operator|*
operator|*
name|line
operator|==
literal|'|'
condition|)
name|j
operator|=
operator|(
name|j
operator|<<
literal|8
operator|)
operator|+
operator|*
operator|(
operator|(
operator|*
name|line
operator|)
operator|++
operator|)
expr_stmt|;
if|if
condition|(
name|getint
argument_list|(
operator|&
name|n
argument_list|,
name|line
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
operator|*
name|line
argument_list|)
condition|)
operator|(
operator|*
name|line
operator|)
operator|++
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|line
operator|!=
literal|')'
condition|)
block|{
name|SETERRSTR
argument_list|(
name|E_BADMATH
argument_list|,
literal|"missing arithmetic close parenthesis"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
else|else
operator|(
operator|*
name|line
operator|)
operator|++
expr_stmt|;
switch|switch
condition|(
name|j
condition|)
block|{
case|case
operator|(
literal|'!'
operator|<<
literal|8
operator|)
operator|+
literal|'='
case|:
operator|*
name|numb
operator|=
operator|*
name|numb
operator|!=
name|n
expr_stmt|;
return|return
literal|0
return|;
case|case
operator|(
literal|'='
operator|<<
literal|8
operator|)
operator|+
literal|'='
case|:
operator|*
name|numb
operator|=
operator|*
name|numb
operator|==
name|n
expr_stmt|;
return|return
literal|0
return|;
case|case
operator|(
literal|'&'
operator|<<
literal|8
operator|)
operator|+
literal|'&'
case|:
operator|*
name|numb
operator|=
operator|*
name|numb
operator|&&
name|n
expr_stmt|;
return|return
literal|0
return|;
case|case
operator|(
literal|'|'
operator|<<
literal|8
operator|)
operator|+
literal|'|'
case|:
operator|*
name|numb
operator|=
operator|*
name|numb
operator|||
name|n
expr_stmt|;
return|return
literal|0
return|;
case|case
literal|'+'
case|:
operator|*
name|numb
operator|+=
name|n
expr_stmt|;
return|return
literal|0
return|;
case|case
literal|'-'
case|:
operator|*
name|numb
operator|-=
name|n
expr_stmt|;
return|return
literal|0
return|;
case|case
literal|'*'
case|:
operator|*
name|numb
operator|*=
name|n
expr_stmt|;
return|return
literal|0
return|;
case|case
literal|'/'
case|:
if|if
condition|(
name|n
operator|==
literal|0
condition|)
operator|*
name|numb
operator|=
literal|1
expr_stmt|;
else|else
operator|*
name|numb
operator|/=
name|n
expr_stmt|;
return|return
literal|0
return|;
default|default:
name|SETERRSTR
argument_list|(
name|E_BADMATH
argument_list|,
literal|"bad arithmetic operator: ``%c''"
argument_list|,
name|j
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
case|case
literal|'$'
case|:
name|t
operator|=
operator|(
operator|*
name|line
operator|)
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|p
operator|=
name|readvar
argument_list|(
name|line
argument_list|)
operator|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
name|SETERRSTR
argument_list|(
name|E_BADMATH
argument_list|,
literal|"non-number found (``%s'') "
literal|"after expanding variable at ``%s''"
argument_list|,
name|p
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
operator|*
name|numb
operator|=
name|atol
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
literal|'9'
case|:
case|case
literal|'0'
case|:
case|case
literal|'8'
case|:
case|case
literal|'1'
case|:
case|case
literal|'7'
case|:
case|case
literal|'2'
case|:
case|case
literal|'6'
case|:
case|case
literal|'3'
case|:
case|case
literal|'5'
case|:
case|case
literal|'4'
case|:
operator|*
name|numb
operator|=
name|atol
argument_list|(
operator|*
name|line
argument_list|)
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|*
operator|*
name|line
argument_list|)
condition|)
operator|(
operator|*
name|line
operator|)
operator|++
expr_stmt|;
return|return
literal|0
return|;
case|case
literal|'"'
case|:
case|case
literal|'\''
case|:
comment|/* Uh-oh.  It's really a string.  We'll go through getstr() 		 * and hope for the best, but this isn't looking good. */
if|if
condition|(
operator|!
operator|(
name|p
operator|=
name|getstr
argument_list|(
name|line
argument_list|)
operator|)
condition|)
return|return
operator|-
literal|1
return|;
operator|*
name|numb
operator|=
name|atol
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
default|default:
name|SETERRSTR
argument_list|(
name|E_BADMATH
argument_list|,
literal|"non-number found, number expected, before parsing ``%s''"
argument_list|,
operator|*
name|line
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Read an argument from the command string and match that argument against  * a series of legitimate values.  For example,  *  * command<<opt0|opt1|opt2>>  *  * This command by be given to the command() processor as a variant of either  * "command opt1" or "command 4", both of which will cause this function to  * return the value 1.  This function returns -1 on failure.  *  * Note that an option (eg. "opt1") must _not_ start with a digit!!  */
end_comment

begin_function
specifier|static
name|int
name|gettog
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|line
parameter_list|,
name|int
name|nopts
parameter_list|,
modifier|...
parameter_list|)
block|{
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|n
decl_stmt|;
name|va_list
name|opts
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|str
operator|=
name|getstr
argument_list|(
name|line
argument_list|)
operator|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|str
argument_list|)
condition|)
block|{
name|n
operator|=
name|atol
argument_list|(
name|str
argument_list|)
operator|%
name|nopts
expr_stmt|;
return|return
name|n
return|;
block|}
name|va_start
argument_list|(
name|opts
argument_list|,
name|nopts
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|nopts
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|str
argument_list|,
name|va_arg
argument_list|(
name|opts
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
condition|)
block|{
name|va_end
argument_list|(
name|opts
argument_list|)
expr_stmt|;
return|return
name|n
return|;
block|}
block|}
name|va_end
argument_list|(
name|opts
argument_list|)
expr_stmt|;
name|SETERR
argument_list|(
name|E_NOTOG
argument_list|)
expr_stmt|;
comment|/* XXX would be nice to list valid toggles... */
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * A companion function for gettog().  Example,  *  * optnumb = gettog(&args, 3, "opt1", "opt2", "opt3");  * settog("_lastoptnumb", optnumb, "opt1", "opt2", "opt3");  *  * And the variable named _lastoptnumb_s will be set to one of "opt1", "opt2",  * or "opt3" as per the value of optnumb.  The variable _lastoptnumb_n will  * also be set to a corresponding value.  The optnumb argument had better  * be within the correct range (between 0 and 2 in the above example)!!  */
end_comment

begin_macro
name|settog
argument_list|(
argument|const char *varname
argument_list|,
argument|int optval
argument_list|,
argument|int nargs
argument_list|,
argument|...
argument_list|)
end_macro

begin_block
block|{
name|va_list
name|opts
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|optval_orig
init|=
name|optval
decl_stmt|;
name|assert
argument_list|(
name|optval
operator|<
name|nargs
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|optval
operator|>=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|s
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|varname
argument_list|)
operator|+
literal|3
argument_list|)
operator|)
condition|)
return|return;
name|strcpy
argument_list|(
name|s
argument_list|,
name|varname
argument_list|)
expr_stmt|;
name|va_start
argument_list|(
name|opts
argument_list|,
name|nargs
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|optval
condition|;
name|optval
operator|--
control|)
name|va_arg
argument_list|(
name|opts
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
name|s
index|[
name|strlen
argument_list|(
name|varname
argument_list|)
index|]
operator|=
literal|'_'
expr_stmt|;
name|s
index|[
name|strlen
argument_list|(
name|varname
argument_list|)
operator|+
literal|1
index|]
operator|=
literal|'s'
expr_stmt|;
name|s
index|[
name|strlen
argument_list|(
name|varname
argument_list|)
operator|+
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|setvar
argument_list|(
name|s
argument_list|,
name|va_arg
argument_list|(
name|opts
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|s
index|[
name|strlen
argument_list|(
name|varname
argument_list|)
operator|+
literal|1
index|]
operator|=
literal|'n'
expr_stmt|;
operator|(
name|void
operator|)
name|setvari
argument_list|(
name|s
argument_list|,
operator|(
name|long
operator|)
name|optval_orig
argument_list|)
expr_stmt|;
name|clear_error
argument_list|()
expr_stmt|;
name|va_end
argument_list|(
name|opts
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Read {text} and return the string associated with the variable named  *<<text>>.  Returns NULL on failure.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|readvar
parameter_list|(
name|line
parameter_list|)
name|char
modifier|*
modifier|*
name|line
decl_stmt|;
block|{
name|int
name|vlength
decl_stmt|;
name|char
modifier|*
name|vstart
decl_stmt|;
specifier|static
name|char
modifier|*
name|getvar
parameter_list|()
function_decl|;
if|if
condition|(
operator|*
operator|*
name|line
operator|!=
literal|'{'
condition|)
block|{
name|SETERR
argument_list|(
name|E_BADVAR
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
operator|(
operator|*
name|line
operator|)
operator|++
expr_stmt|;
for|for
control|(
name|vlength
operator|=
literal|0
operator|,
name|vstart
operator|=
operator|*
name|line
init|;
operator|*
operator|*
name|line
operator|&&
operator|(
name|isalpha
argument_list|(
operator|*
operator|*
name|line
argument_list|)
operator|||
operator|*
operator|*
name|line
operator|==
literal|'_'
operator|)
condition|;
operator|(
operator|*
name|line
operator|)
operator|++
control|)
name|vlength
operator|++
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|line
operator|!=
literal|'}'
operator|||
name|vlength
operator|==
literal|0
condition|)
block|{
name|SETERRSTR
argument_list|(
name|E_BADVAR
argument_list|,
literal|"bad character ``%c'' in variable ``%.*s''"
argument_list|,
operator|*
operator|*
name|line
argument_list|,
name|vlength
argument_list|,
name|vstart
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
operator|(
operator|*
name|line
operator|)
operator|++
expr_stmt|;
return|return
name|getvar
argument_list|(
name|vstart
argument_list|,
name|vlength
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************  *  * Track variables.  *  */
end_comment

begin_struct
specifier|static
struct|struct
name|vble
block|{
name|struct
name|vble
modifier|*
name|next
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
block|}
modifier|*
name|vble_l
struct|;
end_struct

begin_comment
comment|/* linked-list of existing variables */
end_comment

begin_comment
comment|/*  * Return a pointer to the string that variable var represents.  Returns  * NULL if a match could not be found and sets erreur.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|getvar
parameter_list|(
name|var
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|var
decl_stmt|;
name|int
name|len
decl_stmt|;
comment|/* strncmp(var, varmatch, len); is used to match variables */
block|{
name|struct
name|vble
modifier|*
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|vble_l
init|;
name|i
condition|;
name|i
operator|=
name|i
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|strncasecmp
argument_list|(
name|i
operator|->
name|name
argument_list|,
name|var
argument_list|,
name|len
argument_list|)
condition|)
return|return
name|i
operator|->
name|value
return|;
block|}
name|SETERRSTR
argument_list|(
name|E_BADVAR
argument_list|,
literal|"variable ``%.*s'' not set"
argument_list|,
name|len
argument_list|,
name|var
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * Set variable var to val.  Returns -1 on failure, 0 on success.  */
end_comment

begin_function
name|int
name|setvar
parameter_list|(
name|var
parameter_list|,
name|val
parameter_list|)
name|char
modifier|*
name|var
decl_stmt|;
comment|/* variable to set */
name|char
modifier|*
name|val
decl_stmt|;
comment|/* value to set variable to */
block|{
name|struct
name|vble
modifier|*
name|i
decl_stmt|,
modifier|*
name|last
decl_stmt|;
name|char
modifier|*
name|var_n
decl_stmt|,
modifier|*
name|val_n
decl_stmt|;
name|char
modifier|*
name|c
decl_stmt|;
for|for
control|(
name|c
operator|=
name|var
init|;
operator|*
name|c
operator|&&
operator|(
name|isalpha
argument_list|(
operator|*
name|c
argument_list|)
operator|||
operator|*
name|c
operator|==
literal|'_'
operator|)
condition|;
name|c
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|c
condition|)
block|{
name|SETERRSTR
argument_list|(
name|E_BADVAR
argument_list|,
literal|"bad character ``%c'' in variable ``%s''"
argument_list|,
operator|*
name|c
argument_list|,
name|var
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
for|for
control|(
name|i
operator|=
name|vble_l
init|;
name|i
condition|;
name|last
operator|=
name|i
operator|,
name|i
operator|=
name|i
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|i
operator|->
name|name
argument_list|,
name|var
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|FMALLOC
argument_list|(
name|strlen
argument_list|(
name|val
argument_list|)
operator|+
literal|1
argument_list|,
name|val_n
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|free
argument_list|(
name|i
operator|->
name|value
argument_list|)
expr_stmt|;
name|i
operator|->
name|value
operator|=
name|val_n
expr_stmt|;
name|strcpy
argument_list|(
name|i
operator|->
name|value
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
comment|/* Need to add another variable to the list vble_l */
if|if
condition|(
operator|!
name|FMALLOC
argument_list|(
name|strlen
argument_list|(
name|var
argument_list|)
operator|+
literal|1
argument_list|,
name|var_n
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|!
name|FMALLOC
argument_list|(
name|strlen
argument_list|(
name|val
argument_list|)
operator|+
literal|1
argument_list|,
name|val_n
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|!
name|vble_l
condition|)
block|{
if|if
condition|(
operator|!
name|FMALLOC
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|vble
argument_list|)
argument_list|,
name|vble_l
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|i
operator|=
name|vble_l
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|FMALLOC
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|vble
argument_list|)
argument_list|,
name|last
operator|->
name|next
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|i
operator|=
name|last
operator|->
name|next
expr_stmt|;
block|}
name|i
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|i
operator|->
name|name
operator|=
name|var_n
expr_stmt|;
name|strcpy
argument_list|(
name|i
operator|->
name|name
argument_list|,
name|var
argument_list|)
expr_stmt|;
name|i
operator|->
name|value
operator|=
name|val_n
expr_stmt|;
name|strcpy
argument_list|(
name|i
operator|->
name|value
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Set or reset, as appropriate, variable var to val.  */
end_comment

begin_function
name|int
name|setvari
parameter_list|(
name|var
parameter_list|,
name|val
parameter_list|)
specifier|const
name|char
modifier|*
name|var
decl_stmt|;
name|long
name|val
decl_stmt|;
block|{
name|char
name|n
index|[
literal|21
index|]
decl_stmt|;
comment|/* XXX */
name|snprintf
argument_list|(
name|n
argument_list|,
sizeof|sizeof
argument_list|(
name|n
argument_list|)
argument_list|,
literal|"%ld"
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|n
index|[
literal|20
index|]
operator|=
literal|'\0'
expr_stmt|;
name|setvar
argument_list|(
name|var
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*****************************************************************************  *  * Specific command functions.  These aren't actually individual functions,  * since using a gigantic switch statement is faster to type, but they  * pretend to be individual functions.  *  */
end_comment

begin_decl_stmt
name|int
name|condition_eval
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* false if we just parse commands, but do nothing */
end_comment

begin_define
define|#
directive|define
name|ARGSTR
parameter_list|(
name|v
parameter_list|)
value|do {                                                         \ 		if (!((v) = getstr(&args))) return NULL;                       \ 	} while (0)
end_define

begin_define
define|#
directive|define
name|ARGNUM
parameter_list|(
name|v
parameter_list|)
value|do {                                                         \ 		if (getint(&(v),&args)) return NULL;                          \ 	} while (0)
end_define

begin_comment
comment|/* semi-gratuitous use of GNU cpp extension */
end_comment

begin_define
define|#
directive|define
name|ARGTOG
parameter_list|(
name|v
parameter_list|,
name|n
parameter_list|,
name|togs
modifier|...
parameter_list|)
value|do {                                             \ 		if (((v) = gettog(&args, n, togs)) == -1)                      \ 			return NULL;                                           \ 	} while (0)
end_define

begin_define
define|#
directive|define
name|ENDPARSE
value|do {                                                          \ 		if (!condition_eval) return args;                              \ 	} while (0)
end_define

begin_comment
comment|/*  * deftog  *  * Set all toggle options to their default values, provided the toggle option  * is registered with this function.  This command is meant to be used at the  * beginning of the startup command list.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|cdeftog
parameter_list|(
name|cident
parameter_list|,
name|args
parameter_list|)
name|enum
name|cident
name|cident
decl_stmt|;
specifier|const
name|char
modifier|*
name|args
decl_stmt|;
block|{
specifier|extern
name|int
name|horiz_off
decl_stmt|,
name|wraplines
decl_stmt|;
name|ENDPARSE
expr_stmt|;
name|settog
argument_list|(
literal|"_stat"
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|"on"
argument_list|,
literal|"off"
argument_list|)
expr_stmt|;
name|settog
argument_list|(
literal|"_ls_direction"
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|"forw"
argument_list|,
literal|"back"
argument_list|)
expr_stmt|;
name|settog
argument_list|(
literal|"_ls_sense"
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|"noinvert"
argument_list|,
literal|"invert"
argument_list|)
expr_stmt|;
name|setvari
argument_list|(
literal|"_curhscroll"
argument_list|,
operator|(
name|long
operator|)
name|horiz_off
argument_list|)
expr_stmt|;
name|settog
argument_list|(
literal|"_wraplines"
argument_list|,
name|wraplines
argument_list|,
literal|2
argument_list|,
literal|"off"
argument_list|,
literal|"on"
argument_list|)
expr_stmt|;
name|setvar
argument_list|(
literal|"_ls_regexp"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* 	 * not present: _file_direction 	 */
return|return
name|args
return|;
block|}
end_function

begin_comment
comment|/*  * eval<<string>>  *  * Passes string back into the command evaluator.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|ceval
parameter_list|(
name|cident
parameter_list|,
name|args
parameter_list|)
name|enum
name|cident
name|cident
decl_stmt|;
specifier|const
name|char
modifier|*
name|args
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|com
decl_stmt|;
name|ARGSTR
argument_list|(
name|com
argument_list|)
expr_stmt|;
comment|/* The command line to evaluate */
name|ENDPARSE
expr_stmt|;
comment|/* It's not clear what to do with the command() return code */
operator|(
name|void
operator|)
name|command
argument_list|(
name|com
argument_list|)
expr_stmt|;
return|return
name|args
return|;
block|}
end_function

begin_comment
comment|/*  * set<<variablename>><<variablestring>>  *  * Sets variable variablename to string variablestring.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|cset
parameter_list|(
name|cident
parameter_list|,
name|args
parameter_list|)
name|enum
name|cident
name|cident
decl_stmt|;
specifier|const
name|char
modifier|*
name|args
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|str
decl_stmt|,
modifier|*
name|var
decl_stmt|;
name|ARGSTR
argument_list|(
name|var
argument_list|)
expr_stmt|;
comment|/* name of variable to set */
name|ARGSTR
argument_list|(
name|str
argument_list|)
expr_stmt|;
comment|/* value to set variable to */
name|ENDPARSE
expr_stmt|;
if|if
condition|(
operator|*
name|var
operator|==
literal|'_'
condition|)
block|{
name|SETERRSTR
argument_list|(
name|E_BADVAR
argument_list|,
literal|"variables beginning with '_' are reserved"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|setvar
argument_list|(
name|var
argument_list|,
name|str
argument_list|)
condition|)
return|return
name|NULL
return|;
return|return
name|args
return|;
block|}
end_function

begin_comment
comment|/*  * macro<<default_number>><<keys>><<command>>  *  * Associates the macro keys with command.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|cmacro
parameter_list|(
name|cident
parameter_list|,
name|args
parameter_list|)
name|enum
name|cident
name|cident
decl_stmt|;
specifier|const
name|char
modifier|*
name|args
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|keys
decl_stmt|,
modifier|*
name|com
decl_stmt|;
name|long
name|num
decl_stmt|;
name|ARGNUM
argument_list|(
name|num
argument_list|)
expr_stmt|;
comment|/* the default number N for this macro */
name|ARGSTR
argument_list|(
name|keys
argument_list|)
expr_stmt|;
comment|/* string of keys representing a macro */
name|ARGSTR
argument_list|(
name|com
argument_list|)
expr_stmt|;
comment|/* command line to associate with macro */
name|ENDPARSE
expr_stmt|;
if|if
condition|(
name|setmacro
argument_list|(
name|keys
argument_list|,
name|com
argument_list|)
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|setmacnumb
argument_list|(
name|keys
argument_list|,
name|num
argument_list|)
condition|)
return|return
name|NULL
return|;
return|return
name|args
return|;
block|}
end_function

begin_comment
comment|/*  * error<<string>>  *  * Prints a notification message.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|cerror
parameter_list|(
name|cident
parameter_list|,
name|args
parameter_list|)
name|enum
name|cident
name|cident
decl_stmt|;
specifier|const
name|char
modifier|*
name|args
decl_stmt|;
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|ARGSTR
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* error message */
name|ENDPARSE
expr_stmt|;
name|error
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|args
return|;
block|}
end_function

begin_comment
comment|/*  * condition<<boolean>>  * condition_!<<boolean>>  *  * If boolean is false, causes all commands except for other condition  * commands to be ignored.  The<<boolean>> may be specified as a number  * (in which case even numbers are true, odd numbers are false), or one  * of "on", "off", "true", and "false".  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|ccondition
parameter_list|(
name|cident
parameter_list|,
name|args
parameter_list|)
name|enum
name|cident
name|cident
decl_stmt|;
specifier|const
name|char
modifier|*
name|args
decl_stmt|;
block|{
comment|/* ENDPARSE; */
if|if
condition|(
name|cident
operator|==
name|CONDITION_TOGGLE
condition|)
block|{
name|condition_eval
operator|=
operator|!
name|condition_eval
expr_stmt|;
return|return
name|args
return|;
block|}
switch|switch
condition|(
name|gettog
argument_list|(
operator|&
name|args
argument_list|,
literal|4
argument_list|,
literal|"off"
argument_list|,
literal|"on"
argument_list|,
literal|"false"
argument_list|,
literal|"true"
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
case|case
literal|2
case|:
name|condition_eval
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|1
case|:
case|case
literal|3
case|:
name|condition_eval
operator|=
literal|1
expr_stmt|;
break|break;
case|case
operator|-
literal|1
case|:
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|cident
operator|==
name|CONDITION_N
condition|)
name|condition_eval
operator|=
operator|!
name|condition_eval
expr_stmt|;
return|return
name|args
return|;
block|}
end_function

begin_comment
comment|/*  * usercom  *  * Accept a direct command from the user's terminal.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|cusercom
parameter_list|(
name|cident
parameter_list|,
name|args
parameter_list|)
name|enum
name|cident
name|cident
decl_stmt|;
specifier|const
name|char
modifier|*
name|args
decl_stmt|;
block|{
name|char
name|buf
index|[
literal|125
index|]
decl_stmt|;
comment|/* XXX should avoid static buffer... */
name|ENDPARSE
expr_stmt|;
name|getinput
argument_list|(
literal|"Command: "
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|command
argument_list|(
name|buf
argument_list|)
condition|)
return|return
name|NULL
return|;
return|return
name|args
return|;
block|}
end_function

begin_comment
comment|/*  * readrc<<filename>>  *  * Read-in rc commands from the named file.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|creadrc
parameter_list|(
name|cident
parameter_list|,
name|args
parameter_list|)
name|enum
name|cident
name|cident
decl_stmt|;
specifier|const
name|char
modifier|*
name|args
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
name|FILE
modifier|*
name|fd
decl_stmt|;
name|ARGSTR
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|ENDPARSE
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|file
condition|)
return|return
name|args
return|;
comment|/* 	 * Should perhaps warn user if file perms or ownership look suspicious. 	 */
name|fd
operator|=
name|fopen
argument_list|(
name|file
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fd
condition|)
block|{
name|SETERRSTR
argument_list|(
name|E_NULL
argument_list|,
literal|"could not open file ``%s''"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|readrc
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
name|args
return|;
block|}
end_function

begin_comment
comment|/*  * quit  *  * Performs as advertised.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|cquit
parameter_list|(
name|cident
parameter_list|,
name|args
parameter_list|)
name|enum
name|cident
name|cident
decl_stmt|;
specifier|const
name|char
modifier|*
name|args
decl_stmt|;
block|{
name|ENDPARSE
expr_stmt|;
name|quit
argument_list|()
expr_stmt|;
return|return
name|NULL
return|;
comment|/* oh boy... */
block|}
end_function

begin_comment
comment|/*  * help  *  * Doesn't do much.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|chelp
parameter_list|(
name|cident
parameter_list|,
name|args
parameter_list|)
name|enum
name|cident
name|cident
decl_stmt|;
specifier|const
name|char
modifier|*
name|args
decl_stmt|;
block|{
specifier|extern
name|int
name|ac
decl_stmt|,
name|curr_ac
decl_stmt|;
specifier|extern
name|char
modifier|*
modifier|*
name|av
decl_stmt|;
name|ENDPARSE
expr_stmt|;
if|if
condition|(
name|ac
operator|>
literal|0
operator|&&
operator|!
name|strcmp
argument_list|(
name|_PATH_HELPFILE
argument_list|,
name|av
index|[
name|curr_ac
index|]
argument_list|)
condition|)
block|{
name|SETERRSTR
argument_list|(
name|E_NULL
argument_list|,
literal|"already viewing help"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|help
argument_list|()
expr_stmt|;
return|return
name|args
return|;
block|}
end_function

begin_comment
comment|/*  * flush  * repaint  *  * Flushes the file buffer, provided we are not reading from a pipe.  * Frees any other memory that I can get my hands on from here.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|cflush
parameter_list|(
name|cident
parameter_list|,
name|args
parameter_list|)
name|enum
name|cident
name|cident
decl_stmt|;
specifier|const
name|char
modifier|*
name|args
decl_stmt|;
block|{
specifier|extern
name|int
name|ispipe
decl_stmt|;
name|ENDPARSE
expr_stmt|;
if|if
condition|(
name|cident
operator|==
name|FLUSH
operator|&&
operator|!
name|ispipe
condition|)
block|{
name|ch_init
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* XXX should this be ch_init(ctags,0) */
name|clr_linenum
argument_list|()
expr_stmt|;
block|}
name|repaint
argument_list|()
expr_stmt|;
return|return
name|args
return|;
block|}
end_function

begin_comment
comment|/*  * forw_scroll<<n>>  * back_scroll<<n>>  * forw<<n>>  * back<<n>>  *  * Move forward number n lines.  The _scroll variants force a scroll, the  * others may scroll or may just redraw the screen at the appropriate location,  * whichever is faster.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|cscroll
parameter_list|(
name|cident
parameter_list|,
name|args
parameter_list|)
name|enum
name|cident
name|cident
decl_stmt|;
name|char
modifier|*
name|args
decl_stmt|;
block|{
name|long
name|n
decl_stmt|;
name|char
modifier|*
name|retr
decl_stmt|;
name|ARGNUM
argument_list|(
name|n
argument_list|)
expr_stmt|;
comment|/* number of lines to move by */
name|ENDPARSE
expr_stmt|;
switch|switch
condition|(
name|cident
condition|)
block|{
case|case
name|FORW_SCROLL
case|:
name|forward
argument_list|(
name|n
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|BACK_SCROLL
case|:
name|backward
argument_list|(
name|n
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|FORW
case|:
name|forward
argument_list|(
name|n
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|BACK
case|:
name|backward
argument_list|(
name|n
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|args
return|;
block|}
end_function

begin_comment
comment|/*  * rscroll<<n>>  * lscroll<<n>>  *  * Scroll left or right by n lines.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|chscroll
parameter_list|(
name|cident
parameter_list|,
name|args
parameter_list|)
name|enum
name|cident
name|cident
decl_stmt|;
specifier|const
name|char
modifier|*
name|args
decl_stmt|;
block|{
name|long
name|n
decl_stmt|;
name|char
modifier|*
name|retr
decl_stmt|;
specifier|extern
name|int
name|horiz_off
decl_stmt|,
name|wraplines
decl_stmt|;
name|ARGNUM
argument_list|(
name|n
argument_list|)
expr_stmt|;
comment|/* Number of columns to scroll by */
name|ENDPARSE
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
return|return
name|args
return|;
switch|switch
condition|(
name|cident
condition|)
block|{
case|case
name|RSCROLL
case|:
if|if
condition|(
name|wraplines
condition|)
block|{
name|wraplines
operator|=
literal|0
expr_stmt|;
name|assert
argument_list|(
name|horiz_off
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|horiz_off
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|horiz_off
operator|<
literal|0
condition|)
name|horiz_off
operator|=
name|INT_MAX
expr_stmt|;
comment|/* disaster control */
block|}
break|break;
case|case
name|LSCROLL
case|:
if|if
condition|(
name|horiz_off
operator|!=
literal|0
condition|)
block|{
name|horiz_off
operator|-=
name|n
expr_stmt|;
if|if
condition|(
name|horiz_off
operator|<
literal|0
condition|)
name|horiz_off
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|wraplines
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|repaint
argument_list|()
expr_stmt|;
comment|/* screen_trashed = 1 */
name|setvari
argument_list|(
literal|"_curhscroll"
argument_list|,
operator|(
name|long
operator|)
name|horiz_off
argument_list|)
expr_stmt|;
name|settog
argument_list|(
literal|"_wraplines"
argument_list|,
name|wraplines
argument_list|,
literal|2
argument_list|,
literal|"off"
argument_list|,
literal|"on"
argument_list|)
expr_stmt|;
return|return
name|args
return|;
block|}
end_function

begin_comment
comment|/*  * goline<<line>>  * gopercent<<percent>>  *  * Goto the line numbered<<line>>, if possible.  Goto<<percent>> percent of  * the file.  Whole-numbered percents only, of course.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|cgomisc
parameter_list|(
name|cident
parameter_list|,
name|args
parameter_list|)
name|enum
name|cident
name|cident
decl_stmt|;
specifier|const
name|char
modifier|*
name|args
decl_stmt|;
block|{
name|long
name|n
decl_stmt|;
name|ARGNUM
argument_list|(
name|n
argument_list|)
expr_stmt|;
comment|/* number N */
name|ENDPARSE
expr_stmt|;
switch|switch
condition|(
name|cident
condition|)
block|{
case|case
name|GOLINE
case|:
name|jump_back
argument_list|(
name|n
argument_list|)
expr_stmt|;
break|break;
case|case
name|GOPERCENT
case|:
if|if
condition|(
name|n
operator|>
literal|100
condition|)
name|n
operator|=
literal|100
expr_stmt|;
name|jump_percent
argument_list|(
name|n
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|args
return|;
block|}
end_function

begin_comment
comment|/*  * goend  *  * Goto the end of the file.  Future variation should include the GNU less(1)-  * style follow a-la tail(1).  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|cgoend
parameter_list|(
name|cident
parameter_list|,
name|args
parameter_list|)
name|enum
name|cident
name|cident
decl_stmt|;
specifier|const
name|char
modifier|*
name|args
decl_stmt|;
block|{
name|ENDPARSE
expr_stmt|;
name|jump_forw
argument_list|()
expr_stmt|;
return|return
name|args
return|;
block|}
end_function

begin_comment
comment|/*  * edit  *  * Edits the current file with a word editor.  This command is just begging  * to be extended to allow the user to specify an editor.  Additionally, this  * would require some kind of getenv command or similar change.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|cedit
parameter_list|(
name|cident
parameter_list|,
name|args
parameter_list|)
name|enum
name|cident
name|cident
decl_stmt|;
specifier|const
name|char
modifier|*
name|args
decl_stmt|;
block|{
extern|extern ispipe;
name|ENDPARSE
expr_stmt|;
if|if
condition|(
name|ispipe
condition|)
block|{
name|SETERRSTR
argument_list|(
name|E_NULL
argument_list|,
literal|"cannot edit standard input"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|editfile
argument_list|()
expr_stmt|;
comment|/* 	 * XXX less-than brilliant things happen if the user while editing 	 * deletes a large section at the end of the file where we think we 	 * are currently viewing... 	 */
name|ch_init
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Clear the internal file buffer */
name|clr_linenum
argument_list|()
expr_stmt|;
return|return
name|args
return|;
block|}
end_function

begin_comment
comment|/*  * askfile  *  * Loads a new file.  Queries the user for the name of the new file.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|caskfile
parameter_list|(
name|cident
parameter_list|,
name|args
parameter_list|)
name|enum
name|cident
name|cident
decl_stmt|;
specifier|const
name|char
modifier|*
name|args
decl_stmt|;
block|{
name|char
name|buf
index|[
name|MAXPATHLEN
operator|+
literal|1
index|]
decl_stmt|;
name|ENDPARSE
expr_stmt|;
name|getinput
argument_list|(
literal|"Examine: "
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXX should modify this() or edit() to handle lists of file, ie. 	 * the type of lists that I get if I try to glob("*") */
operator|(
name|void
operator|)
name|edit
argument_list|(
name|glob
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|args
return|;
block|}
end_function

begin_comment
comment|/*  * file<<next|previous>><<N>>  *  * Loads the N'th next or previous file, typically from the list of files  * given on the command line.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|cfile
parameter_list|(
name|cident
parameter_list|,
name|args
parameter_list|)
name|enum
name|cident
name|cident
decl_stmt|;
specifier|const
name|char
modifier|*
name|args
decl_stmt|;
block|{
enum|enum
block|{
name|FORW
init|=
literal|0
block|,
name|BACK
init|=
literal|1
block|}
name|direction
enum|;
name|long
name|N
decl_stmt|;
name|ARGTOG
argument_list|(
name|direction
argument_list|,
literal|10
argument_list|,
literal|"next"
argument_list|,
literal|"previous"
argument_list|,
literal|"forward"
argument_list|,
literal|"backward"
argument_list|,
literal|"forwards"
argument_list|,
literal|"backwards"
argument_list|,
literal|"next"
argument_list|,
literal|"prev"
argument_list|,
literal|"forw"
argument_list|,
literal|"back"
argument_list|)
expr_stmt|;
name|ARGNUM
argument_list|(
name|N
argument_list|)
expr_stmt|;
name|ENDPARSE
expr_stmt|;
name|direction
operator|%=
literal|2
expr_stmt|;
comment|/* next_file() and prev_file() call error() directly (bad) */
switch|switch
condition|(
name|direction
condition|)
block|{
case|case
name|FORW
case|:
name|next_file
argument_list|(
name|N
argument_list|)
expr_stmt|;
break|break;
case|case
name|BACK
case|:
name|prev_file
argument_list|(
name|N
argument_list|)
expr_stmt|;
break|break;
block|}
name|settog
argument_list|(
literal|"_file_direction"
argument_list|,
name|direction
argument_list|,
literal|2
argument_list|,
literal|"next"
argument_list|,
literal|"previous"
argument_list|)
expr_stmt|;
return|return
name|args
return|;
block|}
end_function

begin_comment
comment|/*  * file_list  *  * Lists the files the "file next" and "file prev" are moving around in.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|cfile_list
parameter_list|(
name|cident
parameter_list|,
name|args
parameter_list|)
name|enum
name|cident
name|cident
decl_stmt|;
specifier|const
name|char
modifier|*
name|args
decl_stmt|;
block|{
name|ENDPARSE
expr_stmt|;
name|showlist
argument_list|()
expr_stmt|;
name|repaint
argument_list|()
expr_stmt|;
comment|/* screen_trashed = 1; */
return|return
name|args
return|;
block|}
end_function

begin_comment
comment|/*  * stat<<on|off>>  *  * Display the detailed statistics as part of the prompt.  The toggle option  * variable is called _stat (giving ${_stat_s} and ${_stat_n}).  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|cstat
parameter_list|(
name|cident
parameter_list|,
name|args
parameter_list|)
name|enum
name|cident
name|cident
decl_stmt|;
specifier|const
name|char
modifier|*
name|args
decl_stmt|;
block|{
name|int
name|onoff
decl_stmt|;
name|ARGTOG
argument_list|(
name|onoff
argument_list|,
literal|2
argument_list|,
literal|"on"
argument_list|,
literal|"off"
argument_list|)
expr_stmt|;
name|ENDPARSE
expr_stmt|;
name|statprompt
argument_list|(
name|onoff
argument_list|)
expr_stmt|;
name|settog
argument_list|(
literal|"_stat"
argument_list|,
name|onoff
argument_list|,
literal|2
argument_list|,
literal|"on"
argument_list|,
literal|"off"
argument_list|)
expr_stmt|;
return|return
name|args
return|;
block|}
end_function

begin_comment
comment|/*  * magicasksearch<<forw|back>><<n>>  * search<<forw|back>><<n>><<<noinvert|invert>><searchstring>>  * research<<forw|back>><<n>>  *   * Arguments specifying an option (ie.<<forw|back>> and<<noinvert|invert>>  * may be specified either as text (eg. "forw"), or as a number, in which case  * even numbers specify the former setting and odd numbers the latter setting.  *  * The magicasksearch will ask the user for a regexp and intuit whether they  * want to invert the sense of matching or not: if the first character of the  * regexp is a '!', it is removed and the sense is inverted.  If the regexp  * entered is null, then we will use ${_ls_regexp} (error if not set).  *  * The toggle options are called _ls_direction and _ls_sense.  In addition,  * ${_ls_regexp} is set to the regexp used.  These variables are only set  * when the search and magicsearch commands are used.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|csearch
parameter_list|(
name|cident
parameter_list|,
name|args
parameter_list|)
name|enum
name|cident
name|cident
decl_stmt|;
specifier|const
name|char
modifier|*
name|args
decl_stmt|;
block|{
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|,
modifier|*
name|str
decl_stmt|;
enum|enum
block|{
name|FORW
init|=
literal|0
block|,
name|BACK
init|=
literal|1
block|}
name|direction
enum|;
specifier|static
enum|enum
block|{
name|NOINVERT
init|=
literal|0
block|,
name|INVERT
init|=
literal|1
block|}
name|sense
enum|;
name|long
name|N
decl_stmt|;
name|ARGTOG
argument_list|(
name|direction
argument_list|,
literal|6
argument_list|,
literal|"forw"
argument_list|,
literal|"back"
argument_list|,
literal|"forward"
argument_list|,
literal|"backward"
argument_list|,
literal|"forwards"
argument_list|,
literal|"backwards"
argument_list|)
expr_stmt|;
name|ARGNUM
argument_list|(
name|N
argument_list|)
expr_stmt|;
if|if
condition|(
name|cident
operator|==
name|SEARCH
condition|)
block|{
name|ARGTOG
argument_list|(
name|sense
argument_list|,
literal|2
argument_list|,
literal|"noinvert"
argument_list|,
literal|"invert"
argument_list|)
expr_stmt|;
name|ARGSTR
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
name|ENDPARSE
expr_stmt|;
name|direction
operator|%=
literal|2
expr_stmt|;
comment|/* Get the search string, one way or another */
switch|switch
condition|(
name|cident
condition|)
block|{
case|case
name|MAGICASKSEARCH
case|:
name|biggetinputhack
argument_list|()
expr_stmt|;
comment|/* It's magic, boys */
if|if
condition|(
name|direction
operator|==
name|FORW
condition|)
name|getinput
argument_list|(
literal|"Search: /"
argument_list|,
name|buf
argument_list|,
literal|2
argument_list|)
expr_stmt|;
else|else
name|getinput
argument_list|(
literal|"Search: ?"
argument_list|,
name|buf
argument_list|,
literal|2
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|*
name|buf
condition|)
block|{
case|case
literal|'!'
case|:
comment|/* Magic */
if|if
condition|(
name|direction
operator|==
name|FORW
condition|)
name|getinput
argument_list|(
literal|"Search: !/"
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|getinput
argument_list|(
literal|"Search: !?"
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|sense
operator|=
name|INVERT
expr_stmt|;
break|break;
default|default:
comment|/* No magic */
name|ungetcc
argument_list|(
operator|*
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|direction
operator|==
name|FORW
condition|)
name|getinput
argument_list|(
literal|"Search: /"
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|getinput
argument_list|(
literal|"Search: ?"
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
case|case
literal|'\0'
case|:
name|sense
operator|=
name|NOINVERT
expr_stmt|;
break|break;
block|}
name|str
operator|=
name|buf
expr_stmt|;
break|break;
case|case
name|SEARCH
case|:
break|break;
case|case
name|RESEARCH
case|:
name|str
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|cident
operator|==
name|SEARCH
operator|||
name|cident
operator|==
name|MAGICASKSEARCH
condition|)
block|{
name|settog
argument_list|(
literal|"_ls_direction"
argument_list|,
name|direction
argument_list|,
literal|2
argument_list|,
literal|"forw"
argument_list|,
literal|"back"
argument_list|)
expr_stmt|;
name|settog
argument_list|(
literal|"_ls_sense"
argument_list|,
name|sense
argument_list|,
literal|2
argument_list|,
literal|"noinvert"
argument_list|,
literal|"invert"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|str
condition|)
name|setvar
argument_list|(
literal|"_ls_regexp"
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * XXX Currently search() contains magic to deal with (*str=='\0'). 	 * This magic should be moved into this function so that we can work 	 * as described in the function comment header. 	 */
name|search
argument_list|(
operator|!
name|direction
argument_list|,
name|str
argument_list|,
name|N
argument_list|,
operator|!
name|sense
argument_list|)
expr_stmt|;
return|return
name|args
return|;
block|}
end_function

begin_comment
comment|/*  * setmark<<character>>  * gomark<<character>>  *  * Set a marker at the current position, or goto a previously set marker.  * Character may be a-z, or '?' to ask the user to enter a character.  The  * special mark '\'' may not be set, but may be the target of a goto.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|cmark
parameter_list|(
name|cident
parameter_list|,
name|args
parameter_list|)
name|enum
name|cident
name|cident
decl_stmt|;
specifier|const
name|char
modifier|*
name|args
decl_stmt|;
block|{
name|char
name|smark
index|[
literal|2
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|mark
decl_stmt|;
name|ARGSTR
argument_list|(
name|mark
argument_list|)
expr_stmt|;
name|ENDPARSE
expr_stmt|;
comment|/* gomark() and setmark() will further check mark's validity */
if|if
condition|(
operator|!
operator|*
name|mark
operator|||
name|mark
index|[
literal|1
index|]
condition|)
block|{
name|SETERRSTR
argument_list|(
name|E_NULL
argument_list|,
literal|"bad mark character"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|*
name|mark
operator|==
literal|'?'
condition|)
block|{
name|biggetinputhack
argument_list|()
expr_stmt|;
comment|/* so getinput() returns after one char */
switch|switch
condition|(
name|cident
condition|)
block|{
case|case
name|GOMARK
case|:
name|getinput
argument_list|(
literal|"goto mark: "
argument_list|,
name|smark
argument_list|,
sizeof|sizeof
name|smark
argument_list|)
expr_stmt|;
break|break;
case|case
name|SETMARK
case|:
name|getinput
argument_list|(
literal|"set mark: "
argument_list|,
name|smark
argument_list|,
sizeof|sizeof
name|smark
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
operator|*
name|smark
condition|)
return|return
name|args
return|;
name|mark
operator|=
name|smark
expr_stmt|;
block|}
switch|switch
condition|(
name|cident
condition|)
block|{
case|case
name|GOMARK
case|:
name|gomark
argument_list|(
operator|*
name|mark
argument_list|)
expr_stmt|;
break|break;
case|case
name|SETMARK
case|:
name|setmark
argument_list|(
operator|*
name|mark
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|args
return|;
block|}
end_function

begin_comment
comment|/*  * asktag  * nexttag<<number>>  * prevtag<<number>>  *  * Asks the user for a tag, or moves around the tag queue.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|ctags
parameter_list|(
name|cident
parameter_list|,
name|args
parameter_list|)
name|enum
name|cident
name|cident
decl_stmt|;
specifier|const
name|char
modifier|*
name|args
decl_stmt|;
block|{
specifier|extern
name|char
modifier|*
name|tagfile
decl_stmt|;
comment|/* XXX No reason for this to be a global... */
name|long
name|n
decl_stmt|;
if|if
condition|(
name|cident
operator|!=
name|ASKFTAG
condition|)
name|ARGNUM
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|ENDPARSE
expr_stmt|;
if|if
condition|(
name|cident
operator|==
name|ASKFTAG
condition|)
block|{
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
comment|/* XXX should do something else... */
name|getinput
argument_list|(
literal|"Tag: "
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|buf
condition|)
return|return
name|args
return|;
name|findtag
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|cident
condition|)
block|{
case|case
name|NEXTFTAG
case|:
name|nexttag
argument_list|(
name|n
argument_list|)
expr_stmt|;
break|break;
case|case
name|PREVFTAG
case|:
name|prevtag
argument_list|(
name|n
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* Load the tagfile and position ourselves. */
if|if
condition|(
name|tagfile
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|edit
argument_list|(
name|tagfile
argument_list|)
condition|)
name|tagsearch
argument_list|()
expr_stmt|;
return|return
name|args
return|;
comment|/* tag stuff still calls error() on its own */
block|}
end_function

end_unit

