begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1988 Mark Nudleman  * Copyright (c) 1988, 1993  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)prim.c	8.1 (Berkeley) 6/6/93"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/*  * Primitives for displaying the file on the screen.  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<regex.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"less.h"
end_include

begin_decl_stmt
name|int
name|back_scroll
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|hit_eof
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* true if we're displaying the end of the input */
end_comment

begin_decl_stmt
name|int
name|screen_trashed
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|squished
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|sigs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|top_scroll
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|sc_width
decl_stmt|,
name|sc_height
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|horiz_off
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|caseless
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|linenums
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|tagoption
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|line
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|retain_below
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|off_t
name|position
argument_list|()
decl_stmt|,
name|forw_line
argument_list|()
decl_stmt|,
name|back_line
argument_list|()
decl_stmt|,
name|forw_raw_line
argument_list|()
decl_stmt|,
name|back_raw_line
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|off_t
name|ch_length
argument_list|()
decl_stmt|,
name|ch_tell
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Check to see if the end of file is currently "displayed".  */
end_comment

begin_expr_stmt
specifier|static
name|eof_check
argument_list|()
block|{
name|off_t
name|pos
block|;
if|if
condition|(
name|sigs
condition|)
return|return;
comment|/* 	 * If the bottom line is empty, we are at EOF. 	 * If the bottom line ends at the file length, 	 * we must be just at EOF. 	 */
name|pos
operator|=
name|position
argument_list|(
name|BOTTOM_PLUS_ONE
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|pos
operator|==
name|NULL_POSITION
operator|||
name|pos
operator|==
name|ch_length
argument_list|()
condition|)
name|hit_eof
operator|++
expr_stmt|;
end_if

begin_comment
unit|}
comment|/*  * If the screen is "squished", repaint it.  * "Squished" means the first displayed line is not at the top  * of the screen; this can happen when we display a short file  * for the first time.  */
end_comment

begin_macro
unit|static
name|squish_check
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|squished
condition|)
block|{
name|squished
operator|=
literal|0
expr_stmt|;
name|repaint
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Display n lines, scrolling forward, starting at position pos in the  * input file.  "only_last" means display only the last screenful if  * n> screen size.  */
end_comment

begin_expr_stmt
specifier|static
name|forw
argument_list|(
name|n
argument_list|,
name|pos
argument_list|,
name|only_last
argument_list|)
specifier|register
name|int
name|n
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|off_t
name|pos
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|only_last
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|extern
name|int
name|short_file
decl_stmt|;
specifier|static
name|int
name|first_time
init|=
literal|1
decl_stmt|;
name|int
name|eof
init|=
literal|0
decl_stmt|,
name|do_repaint
decl_stmt|;
name|squish_check
argument_list|()
expr_stmt|;
comment|/* 	 * do_repaint tells us not to display anything till the end, 	 * then just repaint the entire screen. 	 */
name|do_repaint
operator|=
operator|(
name|only_last
operator|&&
name|n
operator|>
name|sc_height
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|do_repaint
condition|)
block|{
if|if
condition|(
name|top_scroll
operator|&&
name|n
operator|>=
name|sc_height
operator|-
literal|1
condition|)
block|{
comment|/* 			 * Start a new screen. 			 * {{ This is not really desirable if we happen 			 *    to hit eof in the middle of this screen, 			 *    but we don't yet know if that will happen. }} 			 */
name|clear
argument_list|()
expr_stmt|;
name|home
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|lower_left
argument_list|()
expr_stmt|;
name|clear_eol
argument_list|()
expr_stmt|;
block|}
comment|/* 		 * This is not contiguous with what is currently displayed. 		 * Clear the screen image (position table) and start a new 		 * screen. 		 */
if|if
condition|(
name|pos
operator|!=
name|position
argument_list|(
name|BOTTOM_PLUS_ONE
argument_list|)
condition|)
block|{
name|pos_clear
argument_list|()
expr_stmt|;
name|add_forw_pos
argument_list|(
name|pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|top_scroll
condition|)
block|{
name|clear
argument_list|()
expr_stmt|;
name|home
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|first_time
condition|)
name|putstr
argument_list|(
literal|"...skipping...\n"
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|short_file
operator|=
literal|0
init|;
operator|--
name|n
operator|>=
literal|0
condition|;
control|)
block|{
comment|/* 		 * Read the next line of input. 		 */
name|pos
operator|=
name|forw_line
argument_list|(
name|pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|==
name|NULL_POSITION
condition|)
block|{
comment|/* 			 * end of file; copy the table if the file was 			 * too small for an entire screen. 			 */
name|eof
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|position
argument_list|(
name|TOP
argument_list|)
operator|==
name|NULL_POSITION
condition|)
block|{
name|copytable
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|position
argument_list|(
name|TOP
argument_list|)
condition|)
name|short_file
operator|=
literal|1
expr_stmt|;
block|}
break|break;
block|}
comment|/* 		 * Add the position of the next line to the position table. 		 * Display the current line on the screen. 		 */
name|add_forw_pos
argument_list|(
name|pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_repaint
condition|)
continue|continue;
comment|/* 		 * If this is the first screen displayed and we hit an early 		 * EOF (i.e. before the requested number of lines), we 		 * "squish" the display down at the bottom of the screen. 		 * But don't do this if a -t option was given; it can cause 		 * us to start the display after the beginning of the file, 		 * and it is not appropriate to squish in that case. 		 */
if|if
condition|(
name|first_time
operator|&&
name|line
operator|==
name|NULL
operator|&&
operator|!
name|top_scroll
operator|&&
operator|!
name|tagoption
condition|)
block|{
name|squished
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
name|put_line
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|eof
operator|&&
operator|!
name|sigs
condition|)
name|hit_eof
operator|++
expr_stmt|;
else|else
name|eof_check
argument_list|()
expr_stmt|;
if|if
condition|(
name|do_repaint
condition|)
name|repaint
argument_list|()
expr_stmt|;
name|first_time
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|currline
argument_list|(
name|BOTTOM
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Display n lines, scrolling backward.  */
end_comment

begin_expr_stmt
specifier|static
name|back
argument_list|(
name|n
argument_list|,
name|pos
argument_list|,
name|only_last
argument_list|)
specifier|register
name|int
name|n
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|off_t
name|pos
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|only_last
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|do_repaint
decl_stmt|;
name|squish_check
argument_list|()
expr_stmt|;
name|do_repaint
operator|=
operator|(
name|n
operator|>
name|get_back_scroll
argument_list|()
operator|||
operator|(
name|only_last
operator|&&
name|n
operator|>
name|sc_height
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|hit_eof
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|--
name|n
operator|>=
literal|0
condition|)
block|{
comment|/* 		 * Get the previous line of input. 		 */
name|pos
operator|=
name|back_line
argument_list|(
name|pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|==
name|NULL_POSITION
condition|)
break|break;
comment|/* 		 * Add the position of the previous line to the position table. 		 * Display the line on the screen. 		 */
name|add_back_pos
argument_list|(
name|pos
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|do_repaint
condition|)
block|{
if|if
condition|(
name|retain_below
condition|)
block|{
name|lower_left
argument_list|()
expr_stmt|;
name|clear_eol
argument_list|()
expr_stmt|;
block|}
name|home
argument_list|()
expr_stmt|;
name|add_line
argument_list|()
expr_stmt|;
name|put_line
argument_list|()
expr_stmt|;
block|}
block|}
name|eof_check
argument_list|()
expr_stmt|;
if|if
condition|(
name|do_repaint
condition|)
name|repaint
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|currline
argument_list|(
name|BOTTOM
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Display n more lines, forward.  * Start just after the line currently displayed at the bottom of the screen.  */
end_comment

begin_macro
name|forward
argument_list|(
argument|n
argument_list|,
argument|only_last
argument_list|)
end_macro

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|only_last
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|off_t
name|pos
decl_stmt|;
if|if
condition|(
name|hit_eof
condition|)
block|{
comment|/* 		 * If we're trying to go forward from end-of-file, 		 * go on to the next file. 		 */
name|next_file
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
name|pos
operator|=
name|position
argument_list|(
name|BOTTOM_PLUS_ONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|==
name|NULL_POSITION
condition|)
block|{
name|hit_eof
operator|++
expr_stmt|;
return|return;
block|}
name|forw
argument_list|(
name|n
argument_list|,
name|pos
argument_list|,
name|only_last
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Display n more lines, backward.  * Start just before the line currently displayed at the top of the screen.  */
end_comment

begin_macro
name|backward
argument_list|(
argument|n
argument_list|,
argument|only_last
argument_list|)
end_macro

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|only_last
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|off_t
name|pos
decl_stmt|;
name|pos
operator|=
name|position
argument_list|(
name|TOP
argument_list|)
expr_stmt|;
comment|/* 	 * This will almost never happen, because the top line is almost 	 * never empty. 	 */
if|if
condition|(
name|pos
operator|==
name|NULL_POSITION
condition|)
return|return;
name|back
argument_list|(
name|n
argument_list|,
name|pos
argument_list|,
name|only_last
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Repaint the screen, starting from a specified position.  */
end_comment

begin_macro
name|prepaint
argument_list|(
argument|pos
argument_list|)
end_macro

begin_decl_stmt
name|off_t
name|pos
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|hit_eof
operator|=
literal|0
expr_stmt|;
name|forw
argument_list|(
name|sc_height
operator|-
literal|1
argument_list|,
name|pos
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|screen_trashed
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Repaint the screen.  */
end_comment

begin_macro
name|repaint
argument_list|()
end_macro

begin_block
block|{
comment|/* 	 * Start at the line currently at the top of the screen 	 * and redisplay the screen. 	 */
name|prepaint
argument_list|(
name|position
argument_list|(
name|TOP
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Jump to the end of the file.  * It is more convenient to paint the screen backward,  * from the end of the file toward the beginning.  */
end_comment

begin_macro
name|jump_forw
argument_list|()
end_macro

begin_block
block|{
name|off_t
name|pos
decl_stmt|;
if|if
condition|(
name|ch_end_seek
argument_list|()
condition|)
block|{
name|error
argument_list|(
literal|"Cannot seek to end of file"
argument_list|)
expr_stmt|;
return|return;
block|}
name|lastmark
argument_list|()
expr_stmt|;
name|pos
operator|=
name|ch_tell
argument_list|()
expr_stmt|;
name|clear
argument_list|()
expr_stmt|;
name|pos_clear
argument_list|()
expr_stmt|;
name|add_back_pos
argument_list|(
name|pos
argument_list|)
expr_stmt|;
name|back
argument_list|(
name|sc_height
operator|-
literal|1
argument_list|,
name|pos
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Jump to line n in the file.  */
end_comment

begin_expr_stmt
name|jump_back
argument_list|(
name|n
argument_list|)
specifier|register
name|int
name|n
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|,
name|nlines
decl_stmt|;
comment|/* 	 * This is done the slow way, by starting at the beginning 	 * of the file and counting newlines. 	 * 	 * {{ Now that we have line numbering (in linenum.c), 	 *    we could improve on this by starting at the 	 *    nearest known line rather than at the beginning. }} 	 */
if|if
condition|(
name|ch_seek
argument_list|(
operator|(
name|off_t
operator|)
literal|0
argument_list|)
condition|)
block|{
comment|/* 		 * Probably a pipe with beginning of file no longer buffered. 		 * If he wants to go to line 1, we do the best we can, 		 * by going to the first line which is still buffered. 		 */
if|if
condition|(
name|n
operator|<=
literal|1
operator|&&
name|ch_beg_seek
argument_list|()
operator|==
literal|0
condition|)
name|jump_loc
argument_list|(
name|ch_tell
argument_list|()
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Cannot get to beginning of file"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Start counting lines. 	 */
for|for
control|(
name|nlines
operator|=
literal|1
init|;
name|nlines
operator|<
name|n
condition|;
name|nlines
operator|++
control|)
while|while
condition|(
operator|(
name|c
operator|=
name|ch_forw_get
argument_list|()
operator|)
operator|!=
literal|'\n'
condition|)
if|if
condition|(
name|c
operator|==
name|EOI
condition|)
block|{
name|char
name|message
index|[
literal|40
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|message
argument_list|,
sizeof|sizeof
argument_list|(
name|message
argument_list|)
argument_list|,
literal|"File has only %d lines"
argument_list|,
name|nlines
operator|-
literal|1
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|message
argument_list|)
expr_stmt|;
return|return;
block|}
name|jump_loc
argument_list|(
name|ch_tell
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Jump to a specified percentage into the file.  * This is a poor compensation for not being able to  * quickly jump to a specific line number.  */
end_comment

begin_macro
name|jump_percent
argument_list|(
argument|percent
argument_list|)
end_macro

begin_decl_stmt
name|int
name|percent
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|off_t
name|pos
decl_stmt|,
name|len
decl_stmt|,
name|ch_length
argument_list|()
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
comment|/* 	 * Determine the position in the file 	 * (the specified percentage of the file's length). 	 */
if|if
condition|(
operator|(
name|len
operator|=
name|ch_length
argument_list|()
operator|)
operator|==
name|NULL_POSITION
condition|)
block|{
name|error
argument_list|(
literal|"Don't know length of file"
argument_list|)
expr_stmt|;
return|return;
block|}
name|pos
operator|=
operator|(
name|percent
operator|*
name|len
operator|)
operator|/
literal|100
expr_stmt|;
comment|/* 	 * Back up to the beginning of the line. 	 */
if|if
condition|(
name|ch_seek
argument_list|(
name|pos
argument_list|)
operator|==
literal|0
condition|)
block|{
while|while
condition|(
operator|(
name|c
operator|=
name|ch_back_get
argument_list|()
operator|)
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
name|EOI
condition|)
empty_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
operator|(
name|void
operator|)
name|ch_forw_get
argument_list|()
expr_stmt|;
name|pos
operator|=
name|ch_tell
argument_list|()
expr_stmt|;
block|}
name|jump_loc
argument_list|(
name|pos
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Jump to a specified position in the file.  */
end_comment

begin_macro
name|jump_loc
argument_list|(
argument|pos
argument_list|)
end_macro

begin_decl_stmt
name|off_t
name|pos
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|nline
decl_stmt|;
name|off_t
name|tpos
decl_stmt|;
if|if
condition|(
operator|(
name|nline
operator|=
name|onscreen
argument_list|(
name|pos
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
comment|/* 		 * The line is currently displayed. 		 * Just scroll there. 		 */
name|forw
argument_list|(
name|nline
argument_list|,
name|position
argument_list|(
name|BOTTOM_PLUS_ONE
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Line is not on screen. 	 * Seek to the desired location. 	 */
if|if
condition|(
name|ch_seek
argument_list|(
name|pos
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"Cannot seek to that position"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * See if the desired line is BEFORE the currently displayed screen. 	 * If so, then move forward far enough so the line we're on will be 	 * at the bottom of the screen, in order to be able to call back() 	 * to make the screen scroll backwards& put the line at the top of 	 * the screen. 	 * {{ This seems inefficient, but it's not so bad, 	 *    since we can never move forward more than a 	 *    screenful before we stop to redraw the screen. }} 	 */
name|tpos
operator|=
name|position
argument_list|(
name|TOP
argument_list|)
expr_stmt|;
if|if
condition|(
name|tpos
operator|!=
name|NULL_POSITION
operator|&&
name|pos
operator|<
name|tpos
condition|)
block|{
name|off_t
name|npos
init|=
name|pos
decl_stmt|;
comment|/* 		 * Note that we can't forw_line() past tpos here, 		 * so there should be no EOI at this stage. 		 */
for|for
control|(
name|nline
operator|=
literal|0
init|;
name|npos
operator|<
name|tpos
operator|&&
name|nline
operator|<
name|sc_height
operator|-
literal|1
condition|;
name|nline
operator|++
control|)
name|npos
operator|=
name|forw_line
argument_list|(
name|npos
argument_list|)
expr_stmt|;
if|if
condition|(
name|npos
operator|<
name|tpos
condition|)
block|{
comment|/* 			 * More than a screenful back. 			 */
name|lastmark
argument_list|()
expr_stmt|;
name|clear
argument_list|()
expr_stmt|;
name|pos_clear
argument_list|()
expr_stmt|;
name|add_back_pos
argument_list|(
name|npos
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Note that back() will repaint() if nline> back_scroll. 		 */
name|back
argument_list|(
name|nline
argument_list|,
name|npos
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Remember where we were; clear and paint the screen. 	 */
name|lastmark
argument_list|()
expr_stmt|;
name|prepaint
argument_list|(
name|pos
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * The table of marks.  * A mark is simply a position in the file.  */
end_comment

begin_define
define|#
directive|define
name|NMARKS
value|(27)
end_define

begin_comment
comment|/* 26 for a-z plus one for quote */
end_comment

begin_define
define|#
directive|define
name|LASTMARK
value|(NMARKS-1)
end_define

begin_comment
comment|/* For quote */
end_comment

begin_struct
specifier|static
struct|struct
name|mark
block|{
name|int
name|horiz_off
decl_stmt|;
name|off_t
name|pos
decl_stmt|;
block|}
name|marks
index|[
name|NMARKS
index|]
struct|;
end_struct

begin_comment
comment|/*  * Initialize the mark table to show no marks are set.  */
end_comment

begin_macro
name|init_mark
argument_list|()
end_macro

begin_block
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NMARKS
condition|;
name|i
operator|++
control|)
name|marks
index|[
name|i
index|]
operator|.
name|pos
operator|=
name|NULL_POSITION
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * See if a mark letter is valid (between a and z).  */
end_comment

begin_function
specifier|static
name|int
name|badmark
parameter_list|(
name|c
parameter_list|)
name|int
name|c
decl_stmt|;
block|{
if|if
condition|(
name|c
operator|<
literal|'a'
operator|||
name|c
operator|>
literal|'z'
condition|)
block|{
name|error
argument_list|(
literal|"Choose a letter between 'a' and 'z'"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set a mark.  */
end_comment

begin_macro
name|setmark
argument_list|(
argument|c
argument_list|)
end_macro

begin_decl_stmt
name|int
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|badmark
argument_list|(
name|c
argument_list|)
condition|)
return|return;
name|marks
index|[
name|c
operator|-
literal|'a'
index|]
operator|.
name|pos
operator|=
name|position
argument_list|(
name|TOP
argument_list|)
expr_stmt|;
name|marks
index|[
name|c
operator|-
literal|'a'
index|]
operator|.
name|horiz_off
operator|=
name|horiz_off
expr_stmt|;
block|}
end_block

begin_macro
name|lastmark
argument_list|()
end_macro

begin_block
block|{
name|marks
index|[
name|LASTMARK
index|]
operator|.
name|pos
operator|=
name|position
argument_list|(
name|TOP
argument_list|)
expr_stmt|;
name|marks
index|[
name|LASTMARK
index|]
operator|.
name|horiz_off
operator|=
name|horiz_off
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Go to a previously set mark.  */
end_comment

begin_macro
name|gomark
argument_list|(
argument|c
argument_list|)
end_macro

begin_decl_stmt
name|int
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|off_t
name|pos
decl_stmt|;
name|int
name|new_horiz_off
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\''
condition|)
block|{
name|pos
operator|=
name|marks
index|[
name|LASTMARK
index|]
operator|.
name|pos
expr_stmt|;
if|if
condition|(
name|pos
operator|==
name|NULL_POSITION
condition|)
name|pos
operator|=
literal|0
expr_stmt|;
name|new_horiz_off
operator|=
name|marks
index|[
name|LASTMARK
index|]
operator|.
name|horiz_off
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|badmark
argument_list|(
name|c
argument_list|)
condition|)
return|return;
name|pos
operator|=
name|marks
index|[
name|c
operator|-
literal|'a'
index|]
operator|.
name|pos
expr_stmt|;
if|if
condition|(
name|pos
operator|==
name|NULL_POSITION
condition|)
block|{
name|error
argument_list|(
literal|"mark not set"
argument_list|)
expr_stmt|;
return|return;
block|}
name|new_horiz_off
operator|=
name|marks
index|[
name|c
operator|-
literal|'a'
index|]
operator|.
name|horiz_off
expr_stmt|;
block|}
comment|/* Try to be nice about changing the horizontal scroll and wrapping */
if|if
condition|(
name|new_horiz_off
operator|>
name|sc_width
operator|/
literal|3
operator|+
name|horiz_off
condition|)
block|{
comment|/* 		 * We should change horiz_off: if we don't change horiz_off 		 * the bookmarked location won't be readily visible. 		 */
name|horiz_off
operator|=
name|new_horiz_off
expr_stmt|;
name|prepaint
argument_list|(
name|pos
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * We can honour the bookmark request without doing any 		 * horizontal scrolling. 		 */
name|jump_loc
argument_list|(
name|pos
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Get the backwards scroll limit.  * Must call this function instead of just using the value of  * back_scroll, because the default case depends on sc_height and  * top_scroll, as well as back_scroll.  */
end_comment

begin_macro
name|get_back_scroll
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|back_scroll
operator|>=
literal|0
condition|)
return|return
operator|(
name|back_scroll
operator|)
return|;
if|if
condition|(
name|top_scroll
condition|)
return|return
operator|(
name|sc_height
operator|-
literal|2
operator|)
return|;
return|return
operator|(
name|sc_height
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Search for the n-th occurence of a specified pattern,  * either forward or backward.  */
end_comment

begin_expr_stmt
name|search
argument_list|(
name|search_forward
argument_list|,
name|pattern
argument_list|,
name|n
argument_list|,
name|wantmatch
argument_list|)
specifier|register
name|int
name|search_forward
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|char
modifier|*
name|pattern
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|wantmatch
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|off_t
name|pos
decl_stmt|,
name|linepos
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|q
decl_stmt|;
name|int
name|linenum
decl_stmt|;
name|int
name|linematch
decl_stmt|;
specifier|static
name|regex_t
name|rx
decl_stmt|;
specifier|static
name|int
name|oncethru
decl_stmt|;
name|int
name|regerr
decl_stmt|;
name|char
name|errbuf
index|[
name|_POSIX2_LINE_MAX
index|]
decl_stmt|;
if|if
condition|(
name|pattern
operator|&&
name|pattern
index|[
literal|0
index|]
condition|)
block|{
if|if
condition|(
name|oncethru
condition|)
block|{
name|regfree
argument_list|(
operator|&
name|rx
argument_list|)
expr_stmt|;
block|}
name|regerr
operator|=
name|regcomp
argument_list|(
operator|&
name|rx
argument_list|,
name|pattern
argument_list|,
operator|(
name|REG_EXTENDED
operator||
name|REG_NOSUB
operator||
operator|(
name|caseless
condition|?
name|REG_ICASE
else|:
literal|0
operator|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|regerr
condition|)
block|{
name|regerror
argument_list|(
name|regerr
argument_list|,
operator|&
name|rx
argument_list|,
name|errbuf
argument_list|,
sizeof|sizeof
name|errbuf
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|errbuf
argument_list|)
expr_stmt|;
name|oncethru
operator|=
literal|0
expr_stmt|;
name|regfree
argument_list|(
operator|&
name|rx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|oncethru
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|oncethru
condition|)
block|{
name|error
argument_list|(
literal|"No previous regular expression"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Figure out where to start the search. 	 * 	 * XXX This should probably be adapted to handle horizontal 	 * scrolling.  Consider a long line at the top of the screen 	 * that might be hiding more matches to its right (when doing 	 * successive searches). 	 */
if|if
condition|(
name|position
argument_list|(
name|TOP
argument_list|)
operator|==
name|NULL_POSITION
condition|)
block|{
comment|/* 		 * Nothing is currently displayed.  Start at the beginning 		 * of the file.  (This case is mainly for searches from the 		 * command line. 		 */
name|pos
operator|=
operator|(
name|off_t
operator|)
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|search_forward
condition|)
block|{
comment|/* 		 * Backward search: start just before the top line 		 * displayed on the screen. 		 */
name|pos
operator|=
name|position
argument_list|(
name|TOP
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Start at the second screen line displayed on the screen. 		 */
name|pos
operator|=
name|position
argument_list|(
name|TOP_PLUS_ONE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pos
operator|==
name|NULL_POSITION
condition|)
block|{
comment|/* 		 * Can't find anyplace to start searching from. 		 */
name|error
argument_list|(
literal|"Nothing to search"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|linenum
operator|=
name|find_linenum
argument_list|(
name|pos
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 		 * Get lines until we find a matching one or 		 * until we hit end-of-file (or beginning-of-file 		 * if we're going backwards). 		 */
if|if
condition|(
name|sigs
condition|)
comment|/* 			 * A signal aborts the search. 			 */
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|search_forward
condition|)
block|{
comment|/* 			 * Read the next line, and save the 			 * starting position of that line in linepos. 			 */
name|linepos
operator|=
name|pos
expr_stmt|;
name|pos
operator|=
name|forw_raw_line
argument_list|(
name|pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|linenum
operator|!=
literal|0
condition|)
name|linenum
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Read the previous line and save the 			 * starting position of that line in linepos. 			 */
name|pos
operator|=
name|back_raw_line
argument_list|(
name|pos
argument_list|)
expr_stmt|;
name|linepos
operator|=
name|pos
expr_stmt|;
if|if
condition|(
name|linenum
operator|!=
literal|0
condition|)
name|linenum
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|pos
operator|==
name|NULL_POSITION
condition|)
block|{
comment|/* 			 * We hit EOF/BOF without a match. 			 */
name|error
argument_list|(
literal|"Pattern not found"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 		 * If we're using line numbers, we might as well 		 * remember the information we have now (the position 		 * and line number of the current line). 		 */
if|if
condition|(
name|linenums
condition|)
name|add_lnum
argument_list|(
name|linenum
argument_list|,
name|pos
argument_list|)
expr_stmt|;
comment|/* 		 * Remove any backspaces along with the preceeding char. 		 * This allows us to match text which is underlined or 		 * overstruck. 		 */
for|for
control|(
name|p
operator|=
name|q
operator|=
name|line
init|;
operator|*
name|p
condition|;
name|p
operator|++
operator|,
name|q
operator|++
control|)
if|if
condition|(
name|q
operator|>
name|line
operator|&&
operator|*
name|p
operator|==
literal|'\b'
condition|)
comment|/* Delete BS and preceeding char. */
name|q
operator|-=
literal|2
expr_stmt|;
else|else
comment|/* Otherwise, just copy. */
operator|*
name|q
operator|=
operator|*
name|p
expr_stmt|;
comment|/* 		 * Test the next line to see if we have a match. 		 */
name|linematch
operator|=
operator|!
name|regexec
argument_list|(
operator|&
name|rx
argument_list|,
name|line
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 		 * We are successful if wantmatch and linematch are 		 * both true (want a match and got it), 		 * or both false (want a non-match and got it). 		 */
if|if
condition|(
operator|(
operator|(
name|wantmatch
operator|&&
name|linematch
operator|)
operator|||
operator|(
operator|!
name|wantmatch
operator|&&
operator|!
name|linematch
operator|)
operator|)
operator|&&
operator|--
name|n
operator|<=
literal|0
condition|)
comment|/* 			 * Found the line. 			 */
break|break;
block|}
name|jump_loc
argument_list|(
name|linepos
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

end_unit

