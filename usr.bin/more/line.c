begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1988 Mark Nudleman  * Copyright (c) 1988, 1993  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)line.c	8.1 (Berkeley) 6/6/93"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/*  * Routines to manipulate the "line buffer".  * The line buffer holds a line of output as it is being built  * in preparation for output to the screen.  * We keep track of the PRINTABLE length of the line as it is being built.  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<less.h>
end_include

begin_decl_stmt
specifier|static
name|char
name|linebuf
index|[
literal|1024
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Buffer which holds the current output line */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|curr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer into linebuf */
end_comment

begin_decl_stmt
specifier|static
name|int
name|column
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Printable length, accounting for 				   backspaces, etc. */
end_comment

begin_comment
comment|/*  * A ridiculously complex state machine takes care of backspaces.  The  * complexity arises from the attempt to deal with all cases, especially  * involving long lines with underlining, boldfacing or whatever.  There  * are still some cases which will break it.  *  * There are four states:  *	LN_NORMAL is the normal state (not in underline mode).  *	LN_UNDERLINE means we are in underline mode.  We expect to get  *		either a sequence like "_\bX" or "X\b_" to continue  *		underline mode, or anything else to end underline mode.  *	LN_BOLDFACE means we are in boldface mode.  We expect to get sequences  *		like "X\bX\b...X\bX" to continue boldface mode, or anything  *		else to end boldface mode.  *	LN_UL_X means we are one character after LN_UNDERLINE  *		(we have gotten the '_' in "_\bX" or the 'X' in "X\b_").  *	LN_UL_XB means we are one character after LN_UL_X   *		(we have gotten the backspace in "_\bX" or "X\b_";  *		we expect one more ordinary character,   *		which will put us back in state LN_UNDERLINE).  *	LN_BO_X means we are one character after LN_BOLDFACE  *		(we have gotten the 'X' in "X\bX").  *	LN_BO_XB means we are one character after LN_BO_X  *		(we have gotten the backspace in "X\bX";  *		we expect one more 'X' which will put us back  *		in LN_BOLDFACE).  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ln_state
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Currently in normal/underline/bold/etc mode? */
end_comment

begin_define
define|#
directive|define
name|LN_NORMAL
value|0
end_define

begin_comment
comment|/* Not in underline, boldface or whatever mode */
end_comment

begin_define
define|#
directive|define
name|LN_UNDERLINE
value|1
end_define

begin_comment
comment|/* In underline, need next char */
end_comment

begin_define
define|#
directive|define
name|LN_UL_X
value|2
end_define

begin_comment
comment|/* In underline, got char, need \b */
end_comment

begin_define
define|#
directive|define
name|LN_UL_XB
value|3
end_define

begin_comment
comment|/* In underline, got char& \b, need one more */
end_comment

begin_define
define|#
directive|define
name|LN_BOLDFACE
value|4
end_define

begin_comment
comment|/* In boldface, need next char */
end_comment

begin_define
define|#
directive|define
name|LN_BO_X
value|5
end_define

begin_comment
comment|/* In boldface, got char, need \b */
end_comment

begin_define
define|#
directive|define
name|LN_BO_XB
value|6
end_define

begin_comment
comment|/* In boldface, got char& \b, need same char */
end_comment

begin_decl_stmt
name|char
modifier|*
name|line
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to the current line. 				   Usually points to linebuf. */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|bs_mode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|tabstop
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|bo_width
decl_stmt|,
name|be_width
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|ul_width
decl_stmt|,
name|ue_width
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|sc_width
decl_stmt|,
name|sc_height
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Rewind the line buffer.  */
end_comment

begin_macro
name|prewind
argument_list|()
end_macro

begin_block
block|{
name|line
operator|=
name|curr
operator|=
name|linebuf
expr_stmt|;
name|ln_state
operator|=
name|LN_NORMAL
expr_stmt|;
name|column
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Append a character to the line buffer.  * Expand tabs into spaces, handle underlining, boldfacing, etc.  * Returns 0 if ok, 1 if couldn't fit in buffer.  */
end_comment

begin_define
define|#
directive|define
name|NEW_COLUMN
parameter_list|(
name|addon
parameter_list|)
define|\
value|if (column + addon + (ln_state ? ue_width : 0)> sc_width) \ 		return(1); \ 	else \ 		column += addon
end_define

begin_macro
name|pappend
argument_list|(
argument|c
argument_list|)
end_macro

begin_decl_stmt
name|int
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
block|{
comment|/* 		 * Terminate any special modes, if necessary. 		 * Append a '\0' to the end of the line. 		 */
switch|switch
condition|(
name|ln_state
condition|)
block|{
case|case
name|LN_UL_X
case|:
name|curr
index|[
literal|0
index|]
operator|=
name|curr
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|curr
index|[
operator|-
literal|1
index|]
operator|=
name|UE_CHAR
expr_stmt|;
name|curr
operator|++
expr_stmt|;
break|break;
case|case
name|LN_BO_X
case|:
name|curr
index|[
literal|0
index|]
operator|=
name|curr
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|curr
index|[
operator|-
literal|1
index|]
operator|=
name|BE_CHAR
expr_stmt|;
name|curr
operator|++
expr_stmt|;
break|break;
case|case
name|LN_UL_XB
case|:
case|case
name|LN_UNDERLINE
case|:
operator|*
name|curr
operator|++
operator|=
name|UE_CHAR
expr_stmt|;
break|break;
case|case
name|LN_BO_XB
case|:
case|case
name|LN_BOLDFACE
case|:
operator|*
name|curr
operator|++
operator|=
name|BE_CHAR
expr_stmt|;
break|break;
block|}
name|ln_state
operator|=
name|LN_NORMAL
expr_stmt|;
operator|*
name|curr
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|curr
operator|>
name|linebuf
operator|+
sizeof|sizeof
argument_list|(
name|linebuf
argument_list|)
operator|-
literal|12
condition|)
comment|/* 		 * Almost out of room in the line buffer. 		 * Don't take any chances. 		 * {{ Linebuf is supposed to be big enough that this 		 *    will never happen, but may need to be made  		 *    bigger for wide screens or lots of backspaces. }} 		 */
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
operator|!
name|bs_mode
condition|)
block|{
comment|/* 		 * Advance the state machine. 		 */
switch|switch
condition|(
name|ln_state
condition|)
block|{
case|case
name|LN_NORMAL
case|:
if|if
condition|(
name|curr
operator|<=
name|linebuf
operator|+
literal|1
operator|||
name|curr
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\b'
condition|)
break|break;
if|if
condition|(
name|c
operator|==
operator|(
name|curr
index|[
operator|-
literal|2
index|]
operator|&
literal|0xff
operator|)
condition|)
goto|goto
name|enter_boldface
goto|;
if|if
condition|(
name|c
operator|==
literal|'_'
operator|||
name|curr
index|[
operator|-
literal|2
index|]
operator|==
literal|'_'
condition|)
goto|goto
name|enter_underline
goto|;
name|curr
operator|-=
literal|2
expr_stmt|;
break|break;
name|enter_boldface
label|:
comment|/* 			 * We have "X\bX" (including the current char). 			 * Switch into boldface mode. 			 */
name|column
operator|--
expr_stmt|;
if|if
condition|(
name|column
operator|+
name|bo_width
operator|+
name|be_width
operator|>=
name|sc_width
condition|)
comment|/* 				 * Not enough room left on the screen to  				 * enter and exit boldface mode. 				 */
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|bo_width
operator|>
literal|0
operator|&&
name|curr
operator|>
name|linebuf
operator|+
literal|2
operator|&&
name|curr
index|[
operator|-
literal|3
index|]
operator|==
literal|' '
condition|)
block|{
comment|/* 				 * Special case for magic cookie terminals: 				 * if the previous char was a space, replace  				 * it with the "enter boldface" sequence. 				 */
name|curr
index|[
operator|-
literal|3
index|]
operator|=
name|BO_CHAR
expr_stmt|;
name|column
operator|+=
name|bo_width
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|curr
index|[
operator|-
literal|1
index|]
operator|=
name|curr
index|[
operator|-
literal|2
index|]
expr_stmt|;
name|curr
index|[
operator|-
literal|2
index|]
operator|=
name|BO_CHAR
expr_stmt|;
name|column
operator|+=
name|bo_width
expr_stmt|;
name|curr
operator|++
expr_stmt|;
block|}
goto|goto
name|ln_bo_xb_case
goto|;
name|enter_underline
label|:
comment|/* 			 * We have either "_\bX" or "X\b_" (including 			 * the current char).  Switch into underline mode. 			 */
name|column
operator|--
expr_stmt|;
if|if
condition|(
name|column
operator|+
name|ul_width
operator|+
name|ue_width
operator|>=
name|sc_width
condition|)
comment|/* 				 * Not enough room left on the screen to  				 * enter and exit underline mode. 				 */
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|ul_width
operator|>
literal|0
operator|&&
name|curr
operator|>
name|linebuf
operator|+
literal|2
operator|&&
name|curr
index|[
operator|-
literal|3
index|]
operator|==
literal|' '
condition|)
block|{
comment|/* 				 * Special case for magic cookie terminals: 				 * if the previous char was a space, replace  				 * it with the "enter underline" sequence. 				 */
name|curr
index|[
operator|-
literal|3
index|]
operator|=
name|UL_CHAR
expr_stmt|;
name|column
operator|+=
name|ul_width
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|curr
index|[
operator|-
literal|1
index|]
operator|=
name|curr
index|[
operator|-
literal|2
index|]
expr_stmt|;
name|curr
index|[
operator|-
literal|2
index|]
operator|=
name|UL_CHAR
expr_stmt|;
name|column
operator|+=
name|ul_width
expr_stmt|;
name|curr
operator|++
expr_stmt|;
block|}
goto|goto
name|ln_ul_xb_case
goto|;
comment|/*NOTREACHED*/
case|case
name|LN_UL_XB
case|:
comment|/* 			 * Termination of a sequence "_\bX" or "X\b_". 			 */
if|if
condition|(
name|c
operator|!=
literal|'_'
operator|&&
name|curr
index|[
operator|-
literal|2
index|]
operator|!=
literal|'_'
operator|&&
name|c
operator|==
operator|(
name|curr
index|[
operator|-
literal|2
index|]
operator|&
literal|0xff
operator|)
condition|)
block|{
comment|/* 				 * We seem to have run on from underlining 				 * into boldfacing - this is a nasty fix, but 				 * until this whole routine is rewritten as a 				 * real DFA, ...  well ... 				 */
name|curr
index|[
literal|0
index|]
operator|=
name|curr
index|[
operator|-
literal|2
index|]
expr_stmt|;
name|curr
index|[
operator|-
literal|2
index|]
operator|=
name|UE_CHAR
expr_stmt|;
name|curr
index|[
operator|-
literal|1
index|]
operator|=
name|BO_CHAR
expr_stmt|;
name|curr
operator|+=
literal|2
expr_stmt|;
comment|/* char& non-existent backspace */
name|ln_state
operator|=
name|LN_BO_XB
expr_stmt|;
goto|goto
name|ln_bo_xb_case
goto|;
block|}
name|ln_ul_xb_case
label|:
if|if
condition|(
name|c
operator|==
literal|'_'
condition|)
name|c
operator|=
name|curr
index|[
operator|-
literal|2
index|]
operator|&
literal|0xff
expr_stmt|;
name|curr
operator|-=
literal|2
expr_stmt|;
name|ln_state
operator|=
name|LN_UNDERLINE
expr_stmt|;
break|break;
case|case
name|LN_BO_XB
case|:
comment|/* 			 * Termination of a sequnce "X\bX". 			 */
if|if
condition|(
name|c
operator|!=
operator|(
name|curr
index|[
operator|-
literal|2
index|]
operator|&
literal|0xff
operator|)
operator|&&
operator|(
name|c
operator|==
literal|'_'
operator|||
name|curr
index|[
operator|-
literal|2
index|]
operator|==
literal|'_'
operator|)
condition|)
block|{
comment|/* 				 * We seem to have run on from 				 * boldfacing into underlining. 				 */
name|curr
index|[
literal|0
index|]
operator|=
name|curr
index|[
operator|-
literal|2
index|]
expr_stmt|;
name|curr
index|[
operator|-
literal|2
index|]
operator|=
name|BE_CHAR
expr_stmt|;
name|curr
index|[
operator|-
literal|1
index|]
operator|=
name|UL_CHAR
expr_stmt|;
name|curr
operator|+=
literal|2
expr_stmt|;
comment|/* char& non-existent backspace */
name|ln_state
operator|=
name|LN_UL_XB
expr_stmt|;
goto|goto
name|ln_ul_xb_case
goto|;
block|}
name|ln_bo_xb_case
label|:
name|curr
operator|-=
literal|2
expr_stmt|;
name|ln_state
operator|=
name|LN_BOLDFACE
expr_stmt|;
break|break;
case|case
name|LN_UNDERLINE
case|:
if|if
condition|(
name|column
operator|+
name|ue_width
operator|+
name|bo_width
operator|+
name|be_width
operator|>=
name|sc_width
condition|)
comment|/* 				 * We have just barely enough room to  				 * exit underline mode and handle a possible 				 * underline/boldface run on mixup. 				 */
return|return
operator|(
literal|1
operator|)
return|;
name|ln_state
operator|=
name|LN_UL_X
expr_stmt|;
break|break;
case|case
name|LN_BOLDFACE
case|:
if|if
condition|(
name|c
operator|==
literal|'\b'
condition|)
block|{
name|ln_state
operator|=
name|LN_BO_XB
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|column
operator|+
name|be_width
operator|+
name|ul_width
operator|+
name|ue_width
operator|>=
name|sc_width
condition|)
comment|/* 				 * We have just barely enough room to  				 * exit underline mode and handle a possible 				 * underline/boldface run on mixup. 				 */
return|return
operator|(
literal|1
operator|)
return|;
name|ln_state
operator|=
name|LN_BO_X
expr_stmt|;
break|break;
case|case
name|LN_UL_X
case|:
if|if
condition|(
name|c
operator|==
literal|'\b'
condition|)
name|ln_state
operator|=
name|LN_UL_XB
expr_stmt|;
else|else
block|{
comment|/* 				 * Exit underline mode. 				 * We have to shuffle the chars a bit 				 * to make this work. 				 */
name|curr
index|[
literal|0
index|]
operator|=
name|curr
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|curr
index|[
operator|-
literal|1
index|]
operator|=
name|UE_CHAR
expr_stmt|;
name|column
operator|+=
name|ue_width
expr_stmt|;
if|if
condition|(
name|ue_width
operator|>
literal|0
operator|&&
name|curr
index|[
literal|0
index|]
operator|==
literal|' '
condition|)
comment|/* 					 * Another special case for magic 					 * cookie terminals: if the next 					 * char is a space, replace it 					 * with the "exit underline" sequence. 					 */
name|column
operator|--
expr_stmt|;
else|else
name|curr
operator|++
expr_stmt|;
name|ln_state
operator|=
name|LN_NORMAL
expr_stmt|;
block|}
break|break;
case|case
name|LN_BO_X
case|:
if|if
condition|(
name|c
operator|==
literal|'\b'
condition|)
name|ln_state
operator|=
name|LN_BO_XB
expr_stmt|;
else|else
block|{
comment|/* 				 * Exit boldface mode. 				 * We have to shuffle the chars a bit 				 * to make this work. 				 */
name|curr
index|[
literal|0
index|]
operator|=
name|curr
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|curr
index|[
operator|-
literal|1
index|]
operator|=
name|BE_CHAR
expr_stmt|;
name|column
operator|+=
name|be_width
expr_stmt|;
if|if
condition|(
name|be_width
operator|>
literal|0
operator|&&
name|curr
index|[
literal|0
index|]
operator|==
literal|' '
condition|)
comment|/* 					 * Another special case for magic 					 * cookie terminals: if the next 					 * char is a space, replace it 					 * with the "exit boldface" sequence. 					 */
name|column
operator|--
expr_stmt|;
else|else
name|curr
operator|++
expr_stmt|;
name|ln_state
operator|=
name|LN_NORMAL
expr_stmt|;
block|}
break|break;
block|}
block|}
if|if
condition|(
name|c
operator|==
literal|'\t'
condition|)
block|{
comment|/* 		 * Expand a tab into spaces. 		 */
do|do
block|{
name|NEW_COLUMN
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|column
operator|%
name|tabstop
operator|)
operator|!=
literal|0
condition|)
do|;
operator|*
name|curr
operator|++
operator|=
literal|'\t'
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|c
operator|==
literal|'\b'
condition|)
block|{
if|if
condition|(
name|ln_state
operator|==
name|LN_NORMAL
condition|)
name|NEW_COLUMN
argument_list|(
literal|0
argument_list|)
expr_stmt|;
else|else
name|column
operator|--
expr_stmt|;
operator|*
name|curr
operator|++
operator|=
name|c
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
switch|switch
condition|(
operator|(
name|char
operator|)
name|c
condition|)
block|{
case|case
name|UL_CHAR
case|:
case|case
name|UE_CHAR
case|:
case|case
name|BO_CHAR
case|:
case|case
name|BE_CHAR
case|:
name|c
operator|&=
operator|~
literal|0200
expr_stmt|;
comment|/* fall through */
case|case
literal|'\200'
case|:
name|NEW_COLUMN
argument_list|(
literal|2
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|CONTROL_CHAR
argument_list|(
name|c
argument_list|)
condition|)
name|NEW_COLUMN
argument_list|(
literal|2
argument_list|)
expr_stmt|;
else|else
name|NEW_COLUMN
argument_list|(
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
operator|*
name|curr
operator|++
operator|=
name|c
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Analogous to forw_line(), but deals with "raw lines":  * lines which are not split for screen width.  * {{ This is supposed to be more efficient than forw_line(). }}  */
end_comment

begin_function
name|off_t
name|forw_raw_line
parameter_list|(
name|curr_pos
parameter_list|)
name|off_t
name|curr_pos
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|off_t
name|new_pos
decl_stmt|,
name|ch_tell
argument_list|()
decl_stmt|;
if|if
condition|(
name|curr_pos
operator|==
name|NULL_POSITION
operator|||
name|ch_seek
argument_list|(
name|curr_pos
argument_list|)
operator|||
operator|(
name|c
operator|=
name|ch_forw_get
argument_list|()
operator|)
operator|==
name|EOI
condition|)
return|return
operator|(
name|NULL_POSITION
operator|)
return|;
name|p
operator|=
name|linebuf
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
name|EOI
condition|)
block|{
name|new_pos
operator|=
name|ch_tell
argument_list|()
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|p
operator|>=
operator|&
name|linebuf
index|[
sizeof|sizeof
argument_list|(
name|linebuf
argument_list|)
operator|-
literal|1
index|]
condition|)
block|{
comment|/* 			 * Overflowed the input buffer. 			 * Pretend the line ended here. 			 * {{ The line buffer is supposed to be big 			 *    enough that this never happens. }} 			 */
name|new_pos
operator|=
name|ch_tell
argument_list|()
operator|-
literal|1
expr_stmt|;
break|break;
block|}
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
name|c
operator|=
name|ch_forw_get
argument_list|()
expr_stmt|;
block|}
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|line
operator|=
name|linebuf
expr_stmt|;
return|return
operator|(
name|new_pos
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Analogous to back_line(), but deals with "raw lines".  * {{ This is supposed to be more efficient than back_line(). }}  */
end_comment

begin_function
name|off_t
name|back_raw_line
parameter_list|(
name|curr_pos
parameter_list|)
name|off_t
name|curr_pos
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|off_t
name|new_pos
decl_stmt|,
name|ch_tell
argument_list|()
decl_stmt|;
if|if
condition|(
name|curr_pos
operator|==
name|NULL_POSITION
operator|||
name|curr_pos
operator|<=
operator|(
name|off_t
operator|)
literal|0
operator|||
name|ch_seek
argument_list|(
name|curr_pos
operator|-
literal|1
argument_list|)
condition|)
return|return
operator|(
name|NULL_POSITION
operator|)
return|;
name|p
operator|=
operator|&
name|linebuf
index|[
sizeof|sizeof
argument_list|(
name|linebuf
argument_list|)
index|]
expr_stmt|;
operator|*
operator|--
name|p
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
name|ch_back_get
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
comment|/* 			 * This is the newline ending the previous line. 			 * We have hit the beginning of the line. 			 */
name|new_pos
operator|=
name|ch_tell
argument_list|()
operator|+
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|c
operator|==
name|EOI
condition|)
block|{
comment|/* 			 * We have hit the beginning of the file. 			 * This must be the first line in the file. 			 * This must, of course, be the beginning of the line. 			 */
name|new_pos
operator|=
operator|(
name|off_t
operator|)
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|p
operator|<=
name|linebuf
condition|)
block|{
comment|/* 			 * Overflowed the input buffer. 			 * Pretend the line ended here. 			 */
name|new_pos
operator|=
name|ch_tell
argument_list|()
operator|+
literal|1
expr_stmt|;
break|break;
block|}
operator|*
operator|--
name|p
operator|=
name|c
expr_stmt|;
block|}
name|line
operator|=
name|p
expr_stmt|;
return|return
operator|(
name|new_pos
operator|)
return|;
block|}
end_function

end_unit

