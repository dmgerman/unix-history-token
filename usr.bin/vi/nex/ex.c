begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1992, 1993  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)ex.c	8.90 (Berkeley) 1/23/94"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"vi.h"
end_include

begin_include
include|#
directive|include
file|"excmd.h"
end_include

begin_decl_stmt
specifier|static
specifier|inline
name|EXCMDLIST
specifier|const
modifier|*
name|ex_comm_search
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ep_line
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|EXF
operator|*
operator|,
name|MARK
operator|*
operator|,
name|char
operator|*
operator|*
operator|,
name|size_t
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ep_range
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|EXF
operator|*
operator|,
name|EXCMDARG
operator|*
operator|,
name|char
operator|*
operator|*
operator|,
name|size_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|DEFCOM
value|".+1"
end_define

begin_comment
comment|/*  * ex --  *	Read an ex command and execute it.  */
end_comment

begin_function
name|int
name|ex
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
block|{
name|TEXT
modifier|*
name|tp
decl_stmt|;
name|u_int
name|saved_mode
decl_stmt|;
name|int
name|eval
decl_stmt|;
name|char
name|defcom
index|[
sizeof|sizeof
argument_list|(
name|DEFCOM
argument_list|)
index|]
decl_stmt|;
if|if
condition|(
name|ex_init
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|sp
operator|->
name|s_refresh
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|)
condition|)
return|return
operator|(
name|ex_end
argument_list|(
name|sp
argument_list|)
operator|)
return|;
comment|/* If reading from a file, messages should have line info. */
if|if
condition|(
operator|!
name|F_ISSET
argument_list|(
name|sp
operator|->
name|gp
argument_list|,
name|G_ISFROMTTY
argument_list|)
condition|)
block|{
name|sp
operator|->
name|if_lno
operator|=
literal|1
expr_stmt|;
name|sp
operator|->
name|if_name
operator|=
name|strdup
argument_list|(
literal|"input"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|eval
operator|=
literal|0
init|;
condition|;
operator|++
name|sp
operator|->
name|if_lno
control|)
block|{
comment|/* Get the next command. */
switch|switch
condition|(
name|sp
operator|->
name|s_get
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|sp
operator|->
name|tiq
argument_list|,
literal|':'
argument_list|,
name|TXT_CR
operator||
name|TXT_PROMPT
argument_list|)
condition|)
block|{
case|case
name|INP_OK
case|:
break|break;
case|case
name|INP_EOF
case|:
name|F_SET
argument_list|(
name|sp
argument_list|,
name|S_EXIT_FORCE
argument_list|)
expr_stmt|;
goto|goto
name|ret
goto|;
case|case
name|INP_ERR
case|:
continue|continue;
block|}
name|saved_mode
operator|=
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|S_SCREENS
operator||
name|S_MAJOR_CHANGE
argument_list|)
expr_stmt|;
name|tp
operator|=
name|sp
operator|->
name|tiq
operator|.
name|cqh_first
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|len
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|F_ISSET
argument_list|(
name|sp
operator|->
name|gp
argument_list|,
name|G_ISFROMTTY
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fputc
argument_list|(
literal|'\r'
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
name|memmove
argument_list|(
name|defcom
argument_list|,
name|DEFCOM
argument_list|,
sizeof|sizeof
argument_list|(
name|DEFCOM
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ex_icmd
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|defcom
argument_list|,
sizeof|sizeof
argument_list|(
name|DEFCOM
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|F_ISSET
argument_list|(
name|sp
operator|->
name|gp
argument_list|,
name|G_ISFROMTTY
argument_list|)
condition|)
operator|(
name|void
operator|)
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ex_icmd
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|tp
operator|->
name|lb
argument_list|,
name|tp
operator|->
name|len
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|msg_rpt
argument_list|(
name|sp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|saved_mode
operator|!=
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|S_SCREENS
operator||
name|S_MAJOR_CHANGE
argument_list|)
condition|)
break|break;
if|if
condition|(
name|sp
operator|->
name|s_refresh
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|)
condition|)
block|{
name|eval
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
name|ret
label|:
if|if
condition|(
name|sp
operator|->
name|if_name
operator|!=
name|NULL
condition|)
block|{
name|FREE
argument_list|(
name|sp
operator|->
name|if_name
argument_list|,
name|strlen
argument_list|(
name|sp
operator|->
name|if_name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sp
operator|->
name|if_name
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|ex_end
argument_list|(
name|sp
argument_list|)
operator|||
name|eval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ex_cfile --  *	Execute ex commands from a file.  */
end_comment

begin_function
name|int
name|ex_cfile
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|,
name|filename
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|struct
name|stat
name|sb
decl_stmt|;
name|int
name|fd
decl_stmt|,
name|len
decl_stmt|,
name|rval
decl_stmt|;
name|char
modifier|*
name|bp
decl_stmt|;
name|bp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|filename
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
operator|||
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|sb
argument_list|)
condition|)
goto|goto
name|err
goto|;
comment|/* 	 * XXX 	 * We'd like to test if the file is too big to malloc.  Since we don't 	 * know what size or type off_t's or size_t's are, what the largest 	 * unsigned integral type is, or what random insanity the local C 	 * compiler will perpetrate, doing the comparison in a portable way 	 * is flatly impossible.  Hope that malloc fails if the file is too 	 * large. 	 */
name|MALLOC
argument_list|(
name|sp
argument_list|,
name|bp
argument_list|,
name|char
operator|*
argument_list|,
operator|(
name|size_t
operator|)
name|sb
operator|.
name|st_size
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
name|len
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|bp
argument_list|,
operator|(
name|int
operator|)
name|sb
operator|.
name|st_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
operator|-
literal|1
operator|||
name|len
operator|!=
name|sb
operator|.
name|st_size
condition|)
block|{
if|if
condition|(
name|len
operator|!=
name|sb
operator|.
name|st_size
condition|)
name|errno
operator|=
name|EIO
expr_stmt|;
name|err
label|:
name|rval
operator|=
literal|1
expr_stmt|;
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_SYSERR
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bp
index|[
name|sb
operator|.
name|st_size
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* XXX */
comment|/* Run the command.  Messages include file/line information. */
name|sp
operator|->
name|if_lno
operator|=
literal|1
expr_stmt|;
name|sp
operator|->
name|if_name
operator|=
name|strdup
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|rval
operator|=
name|ex_icmd
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|bp
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|sp
operator|->
name|if_name
argument_list|,
name|strlen
argument_list|(
name|sp
operator|->
name|if_name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sp
operator|->
name|if_name
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * !!! 	 * THE UNDERLYING EXF MAY HAVE CHANGED. 	 */
if|if
condition|(
name|bp
operator|!=
name|NULL
condition|)
name|FREE
argument_list|(
name|bp
argument_list|,
name|sb
operator|.
name|st_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|>=
literal|0
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
name|rval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ex_icmd --  *	Call ex_cmd() after turning off interruptible bits.  */
end_comment

begin_function
name|int
name|ex_icmd
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|,
name|cmd
parameter_list|,
name|len
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
name|char
modifier|*
name|cmd
decl_stmt|;
name|size_t
name|len
decl_stmt|;
block|{
comment|/* 	 * Ex goes through here for each vi :colon command and for each ex 	 * command, however, globally executed commands don't go through 	 * here, instead, they call ex_cmd directly.  So, reset all of the 	 * interruptible flags now. 	 */
name|F_CLR
argument_list|(
name|sp
argument_list|,
name|S_INTERRUPTED
operator||
name|S_INTERRUPTIBLE
argument_list|)
expr_stmt|;
return|return
operator|(
name|ex_cmd
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|cmd
argument_list|,
name|len
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Special command structure for :s as a repeat substitution command. */
end_comment

begin_decl_stmt
specifier|static
name|EXCMDLIST
specifier|const
name|cmd_subagain
init|=
block|{
literal|"s"
block|,
name|ex_subagain
block|,
name|E_ADDR2
operator||
name|E_NORC
block|,
literal|"s"
block|,
literal|"[line [,line]] s [cgr] [count] [#lp]"
block|,
literal|"repeat the last subsitution"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * ex_cmd --  *	Parse and execute a string containing ex commands.  */
end_comment

begin_function
name|int
name|ex_cmd
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|,
name|cmd
parameter_list|,
name|cmdlen
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
name|char
modifier|*
name|cmd
decl_stmt|;
name|size_t
name|cmdlen
decl_stmt|;
block|{
name|CHAR_T
name|vlit
decl_stmt|;
name|EX_PRIVATE
modifier|*
name|exp
decl_stmt|;
name|EXCMDARG
name|exc
decl_stmt|;
name|EXCMDLIST
specifier|const
modifier|*
name|cp
decl_stmt|;
name|MARK
name|cur
decl_stmt|;
name|recno_t
name|lno
decl_stmt|,
name|num
decl_stmt|;
name|size_t
name|arg1_len
decl_stmt|,
name|len
decl_stmt|,
name|save_cmdlen
decl_stmt|;
name|long
name|flagoff
decl_stmt|;
name|u_int
name|saved_mode
decl_stmt|;
name|int
name|ch
decl_stmt|,
name|cnt
decl_stmt|,
name|delim
decl_stmt|,
name|flags
decl_stmt|,
name|namelen
decl_stmt|,
name|nl
decl_stmt|,
name|uselastcmd
decl_stmt|,
name|tmp
decl_stmt|;
name|char
modifier|*
name|arg1
decl_stmt|,
modifier|*
name|save_cmd
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|t
decl_stmt|;
comment|/* Init. */
name|nl
operator|=
literal|0
expr_stmt|;
name|loop
label|:
if|if
condition|(
name|nl
condition|)
block|{
name|nl
operator|=
literal|0
expr_stmt|;
operator|++
name|sp
operator|->
name|if_lno
expr_stmt|;
block|}
name|arg1
operator|=
name|NULL
expr_stmt|;
name|save_cmdlen
operator|=
literal|0
expr_stmt|;
comment|/* 	 * It's possible that we've been interrupted during a 	 * command. 	 */
if|if
condition|(
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|S_INTERRUPTED
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Skip whitespace, separators, newlines. */
for|for
control|(
init|;
name|cmdlen
operator|>
literal|0
condition|;
operator|++
name|cmd
operator|,
operator|--
name|cmdlen
control|)
if|if
condition|(
operator|(
name|ch
operator|=
operator|*
name|cmd
operator|)
operator|==
literal|'\n'
condition|)
operator|++
name|sp
operator|->
name|if_lno
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|isblank
argument_list|(
name|ch
argument_list|)
condition|)
break|break;
if|if
condition|(
name|cmdlen
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Command lines that start with a double-quote are comments. */
if|if
condition|(
name|ch
operator|==
literal|'"'
condition|)
block|{
while|while
condition|(
operator|--
name|cmdlen
operator|>
literal|0
operator|&&
operator|*
operator|++
name|cmd
operator|!=
literal|'\n'
condition|)
empty_stmt|;
if|if
condition|(
operator|*
name|cmd
operator|==
literal|'\n'
condition|)
block|{
operator|++
name|cmd
expr_stmt|;
operator|--
name|cmdlen
expr_stmt|;
operator|++
name|sp
operator|->
name|if_lno
expr_stmt|;
block|}
goto|goto
name|loop
goto|;
block|}
comment|/* 	 * !!! 	 * Permit extra colons at the start of the line.  Historically, 	 * ex/vi allowed a single extra one.  It's simpler not to count. 	 * The stripping is done here because, historically, any command 	 * could have preceding colons, e.g. ":g/pattern/:p" worked. 	 */
if|if
condition|(
name|ch
operator|==
literal|':'
condition|)
while|while
condition|(
operator|--
name|cmdlen
operator|>
literal|0
operator|&&
operator|*
operator|++
name|cmd
operator|==
literal|':'
condition|)
empty_stmt|;
comment|/* Skip whitespace. */
for|for
control|(
init|;
name|cmdlen
operator|>
literal|0
condition|;
operator|++
name|cmd
operator|,
operator|--
name|cmdlen
control|)
block|{
name|ch
operator|=
operator|*
name|cmd
expr_stmt|;
if|if
condition|(
operator|!
name|isblank
argument_list|(
name|ch
argument_list|)
condition|)
break|break;
block|}
comment|/* The last point at which an empty line means do nothing. */
if|if
condition|(
name|cmdlen
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Initialize the structure passed to underlying functions. */
name|memset
argument_list|(
operator|&
name|exc
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|EXCMDARG
argument_list|)
argument_list|)
expr_stmt|;
name|exp
operator|=
name|EXP
argument_list|(
name|sp
argument_list|)
expr_stmt|;
if|if
condition|(
name|argv_init
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|exc
argument_list|)
condition|)
goto|goto
name|err
goto|;
comment|/* Parse command addresses. */
if|if
condition|(
name|ep_range
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|exc
argument_list|,
operator|&
name|cmd
argument_list|,
operator|&
name|cmdlen
argument_list|)
condition|)
goto|goto
name|err
goto|;
comment|/* Skip whitespace. */
for|for
control|(
init|;
name|cmdlen
operator|>
literal|0
condition|;
operator|++
name|cmd
operator|,
operator|--
name|cmdlen
control|)
block|{
name|ch
operator|=
operator|*
name|cmd
expr_stmt|;
if|if
condition|(
operator|!
name|isblank
argument_list|(
name|ch
argument_list|)
condition|)
break|break;
block|}
comment|/* 	 * If no command, ex does the last specified of p, l, or #, and vi 	 * moves to the line.  Otherwise, determine the length of the command 	 * name by looking for the first non-alphabetic character.  (There 	 * are a few non-alphabetic characters in command names, but they're 	 * all single character commands.)  This isn't a great test, because 	 * it means that, for the command ":e +cut.c file", we'll report that 	 * the command "cut" wasn't known.  However, it makes ":e+35 file" work 	 * correctly. 	 */
define|#
directive|define
name|SINGLE_CHAR_COMMANDS
value|"!#&<=>@~"
if|if
condition|(
name|cmdlen
operator|!=
literal|0
operator|&&
name|cmd
index|[
literal|0
index|]
operator|!=
literal|'|'
operator|&&
name|cmd
index|[
literal|0
index|]
operator|!=
literal|'\n'
condition|)
block|{
if|if
condition|(
name|strchr
argument_list|(
name|SINGLE_CHAR_COMMANDS
argument_list|,
operator|*
name|cmd
argument_list|)
condition|)
block|{
name|p
operator|=
name|cmd
expr_stmt|;
operator|++
name|cmd
expr_stmt|;
operator|--
name|cmdlen
expr_stmt|;
name|namelen
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|p
operator|=
name|cmd
init|;
name|cmdlen
operator|>
literal|0
condition|;
operator|--
name|cmdlen
operator|,
operator|++
name|cmd
control|)
if|if
condition|(
operator|!
name|isalpha
argument_list|(
operator|*
name|cmd
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|(
name|namelen
operator|=
name|cmd
operator|-
name|p
operator|)
operator|==
literal|0
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"Unknown command name."
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
block|}
comment|/* 		 * Search the table for the command. 		 * 		 * !!! 		 * Historic vi permitted the mark to immediately follow the 		 * 'k' in the 'k' command.  Make it work. 		 * 		 * !!! 		 * Historic vi permitted pretty much anything to follow the 		 * substitute command, e.g. "s/e/E/|s|sgc3p" was fine.  Make 		 * it work. 		 * 		 * Use of msgq below is safe, command names are all alphabetics. 		 */
if|if
condition|(
operator|(
name|cp
operator|=
name|ex_comm_search
argument_list|(
name|p
argument_list|,
name|namelen
argument_list|)
operator|)
operator|==
name|NULL
condition|)
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'k'
operator|&&
name|p
index|[
literal|1
index|]
operator|&&
operator|!
name|p
index|[
literal|2
index|]
condition|)
block|{
name|cmd
operator|-=
name|namelen
operator|-
literal|1
expr_stmt|;
name|cmdlen
operator|+=
name|namelen
operator|-
literal|1
expr_stmt|;
name|cp
operator|=
operator|&
name|cmds
index|[
name|C_K
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'s'
condition|)
block|{
name|cmd
operator|-=
name|namelen
operator|-
literal|1
expr_stmt|;
name|cmdlen
operator|+=
name|namelen
operator|-
literal|1
expr_stmt|;
name|cp
operator|=
operator|&
name|cmd_subagain
expr_stmt|;
block|}
else|else
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"The %.*s command is unknown."
argument_list|,
name|namelen
argument_list|,
name|p
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* Some commands are either not implemented or turned off. */
if|if
condition|(
name|F_ISSET
argument_list|(
name|cp
argument_list|,
name|E_NOPERM
argument_list|)
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"The %s command is not currently supported."
argument_list|,
name|cp
operator|->
name|name
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* Some commands aren't okay in globals. */
if|if
condition|(
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|S_GLOBAL
argument_list|)
operator|&&
name|F_ISSET
argument_list|(
name|cp
argument_list|,
name|E_NOGLOBAL
argument_list|)
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"The %s command can't be used as part of a global command."
argument_list|,
name|cp
operator|->
name|name
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* 		 * Multiple< and> characters; another "feature".  Note, 		 * The string passed to the underlying function may not be 		 * nul terminated in this case. 		 */
if|if
condition|(
operator|(
name|cp
operator|==
operator|&
name|cmds
index|[
name|C_SHIFTL
index|]
operator|&&
operator|*
name|p
operator|==
literal|'<'
operator|)
operator|||
operator|(
name|cp
operator|==
operator|&
name|cmds
index|[
name|C_SHIFTR
index|]
operator|&&
operator|*
name|p
operator|==
literal|'>'
operator|)
condition|)
block|{
for|for
control|(
name|ch
operator|=
operator|*
name|p
init|;
name|cmdlen
operator|>
literal|0
condition|;
operator|--
name|cmdlen
operator|,
operator|++
name|cmd
control|)
if|if
condition|(
operator|*
name|cmd
operator|!=
name|ch
condition|)
break|break;
if|if
condition|(
name|argv_exp0
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|exc
argument_list|,
name|p
argument_list|,
name|cmd
operator|-
name|p
argument_list|)
condition|)
goto|goto
name|err
goto|;
block|}
comment|/* 		 * The visual command has a different syntax when called 		 * from ex than when called from a vi colon command.  FMH. 		 */
if|if
condition|(
name|cp
operator|==
operator|&
name|cmds
index|[
name|C_VISUAL_EX
index|]
operator|&&
name|IN_VI_MODE
argument_list|(
name|sp
argument_list|)
condition|)
name|cp
operator|=
operator|&
name|cmds
index|[
name|C_VISUAL_VI
index|]
expr_stmt|;
name|uselastcmd
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|cp
operator|=
name|exp
operator|->
name|lastcmd
expr_stmt|;
name|uselastcmd
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Initialize local flags to the command flags. */
name|LF_INIT
argument_list|(
name|cp
operator|->
name|flags
argument_list|)
expr_stmt|;
comment|/* 	 * File state must be checked throughout this code, because it is 	 * called when reading the .exrc file and similar things.  There's 	 * this little chicken and egg problem -- if we read the file first, 	 * we won't know how to display it.  If we read/set the exrc stuff 	 * first, we can't allow any command that requires file state. 	 * Historic vi generally took the easy way out and dropped core.  	 */
if|if
condition|(
name|LF_ISSET
argument_list|(
name|E_NORC
argument_list|)
operator|&&
name|ep
operator|==
name|NULL
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"The %s command requires that a file already have been read in."
argument_list|,
name|cp
operator|->
name|name
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* 	 * There are three normal termination cases for an ex command.  They 	 * are the end of the string (cmdlen), or unescaped (by literal next 	 * characters) newline or '|' characters.  As we're past any addresses, 	 * we can now determine how long the command is, so we don't have to 	 * look for all the possible terminations.  There are three exciting 	 * special cases: 	 * 	 * 1: The bang, global, vglobal and the filter versions of the read and 	 *    write commands are delimited by newlines (they can contain shell 	 *    pipes). 	 * 2: The ex, edit and visual in vi mode commands take ex commands as 	 *    their first arguments. 	 * 3: The substitute command takes an RE as its first argument, and 	 *    wants it to be specially delimited. 	 * 	 * Historically, '|' characters in the first argument of the ex, edit, 	 * and substitute commands did not delimit the command.  And, in the 	 * filter cases for read and write, and the bang, global and vglobal 	 * commands, they did not delimit the command at all. 	 * 	 * For example, the following commands were legal: 	 * 	 *	:edit +25|s/abc/ABC/ file.c 	 *	:substitute s/|/PIPE/ 	 *	:read !spell % | columnate 	 *	:global/pattern/p|l 	 * 	 * It's not quite as simple as it sounds, however.  The command: 	 * 	 *	:substitute s/a/b/|s/c/d|set 	 * 	 * was also legal, i.e. the historic ex parser (using the word loosely, 	 * since "parser" implies some regularity) delimited the RE's based on 	 * its delimiter and not anything so irretrievably vulgar as a command 	 * syntax. 	 * 	 * One thing that makes this easier is that we can ignore most of the 	 * command termination conditions for the commands that want to take 	 * the command up to the next newline.  None of them are legal in .exrc 	 * files, so if we're here, we only dealing with a single line, and we 	 * can just eat it. 	 * 	 * Anyhow, the following code makes this all work.  First, for the 	 * special cases we move past their special argument.  Then, we do 	 * normal command processing on whatever is left.  Barf-O-Rama. 	 */
name|arg1_len
operator|=
literal|0
expr_stmt|;
name|save_cmd
operator|=
name|cmd
expr_stmt|;
operator|(
name|void
operator|)
name|term_key_ch
argument_list|(
name|sp
argument_list|,
name|K_VLNEXT
argument_list|,
operator|&
name|vlit
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
operator|&
name|cmds
index|[
name|C_EDIT
index|]
operator|||
name|cp
operator|==
operator|&
name|cmds
index|[
name|C_EX
index|]
operator|||
name|cp
operator|==
operator|&
name|cmds
index|[
name|C_VISUAL_VI
index|]
condition|)
block|{
comment|/* 		 * Move to the next non-whitespace character.  As '+' must 		 * be the character after the command name, if there isn't 		 * one, we're done. 		 */
for|for
control|(
init|;
name|cmdlen
operator|>
literal|0
condition|;
operator|--
name|cmdlen
operator|,
operator|++
name|cmd
control|)
block|{
name|ch
operator|=
operator|*
name|cmd
expr_stmt|;
if|if
condition|(
operator|!
name|isblank
argument_list|(
name|ch
argument_list|)
condition|)
break|break;
block|}
comment|/* 		 * QUOTING NOTE: 		 * 		 * The historic implementation ignored all escape characters 		 * so there was no way to put a space or newline into the +cmd 		 * field.  We do a simplistic job of fixing it by moving to the 		 * first whitespace character that isn't escaped by a literal 		 * next character.  The literal next characters are stripped 		 * as they're no longer useful. 		 */
if|if
condition|(
name|cmdlen
operator|>
literal|0
operator|&&
name|ch
operator|==
literal|'+'
condition|)
block|{
operator|++
name|cmd
expr_stmt|;
operator|--
name|cmdlen
expr_stmt|;
for|for
control|(
name|arg1
operator|=
name|p
operator|=
name|cmd
init|;
name|cmdlen
operator|>
literal|0
condition|;
operator|--
name|cmdlen
operator|,
operator|++
name|cmd
control|)
block|{
if|if
condition|(
operator|(
name|ch
operator|=
operator|*
name|cmd
operator|)
operator|==
name|vlit
operator|&&
name|cmdlen
operator|>
literal|1
condition|)
block|{
operator|--
name|cmdlen
expr_stmt|;
name|ch
operator|=
operator|*
operator|++
name|cmd
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isblank
argument_list|(
name|ch
argument_list|)
condition|)
break|break;
operator|*
name|p
operator|++
operator|=
name|ch
expr_stmt|;
block|}
name|arg1_len
operator|=
name|cmd
operator|-
name|arg1
expr_stmt|;
comment|/* Reset, so the first argument isn't reparsed. */
name|save_cmd
operator|=
name|cmd
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|cp
operator|==
operator|&
name|cmds
index|[
name|C_BANG
index|]
operator|||
name|cp
operator|==
operator|&
name|cmds
index|[
name|C_GLOBAL
index|]
operator|||
name|cp
operator|==
operator|&
name|cmds
index|[
name|C_VGLOBAL
index|]
condition|)
block|{
name|cmd
operator|+=
name|cmdlen
expr_stmt|;
name|cmdlen
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cp
operator|==
operator|&
name|cmds
index|[
name|C_READ
index|]
operator|||
name|cp
operator|==
operator|&
name|cmds
index|[
name|C_WRITE
index|]
condition|)
block|{
comment|/* 		 * Move to the next character.  If it's a '!', it's a filter 		 * command and we want to eat it all, otherwise, we're done. 		 */
for|for
control|(
init|;
name|cmdlen
operator|>
literal|0
condition|;
operator|--
name|cmdlen
operator|,
operator|++
name|cmd
control|)
block|{
name|ch
operator|=
operator|*
name|cmd
expr_stmt|;
if|if
condition|(
operator|!
name|isblank
argument_list|(
name|ch
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|cmdlen
operator|>
literal|0
operator|&&
name|ch
operator|==
literal|'!'
condition|)
block|{
name|cmd
operator|+=
name|cmdlen
expr_stmt|;
name|cmdlen
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|cp
operator|==
operator|&
name|cmds
index|[
name|C_SUBSTITUTE
index|]
condition|)
block|{
comment|/* 		 * Move to the next non-whitespace character, we'll use it as 		 * the delimiter.  If the character isn't an alphanumeric or 		 * a '|', it's the delimiter, so parse it.  Otherwise, we're 		 * into something like ":s g", so use the special substitute 		 * command. 		 */
for|for
control|(
init|;
name|cmdlen
operator|>
literal|0
condition|;
operator|--
name|cmdlen
operator|,
operator|++
name|cmd
control|)
if|if
condition|(
operator|!
name|isblank
argument_list|(
name|cmd
index|[
literal|0
index|]
argument_list|)
condition|)
break|break;
if|if
condition|(
name|isalnum
argument_list|(
name|cmd
index|[
literal|0
index|]
argument_list|)
operator|||
name|cmd
index|[
literal|0
index|]
operator|==
literal|'|'
condition|)
name|cp
operator|=
operator|&
name|cmd_subagain
expr_stmt|;
elseif|else
if|if
condition|(
name|cmdlen
operator|>
literal|0
condition|)
block|{
comment|/* 			 * QUOTING NOTE: 			 * 			 * Backslashes quote delimiter characters for RE's. 			 * The backslashes are NOT removed since they'll be 			 * used by the RE code.  Move to the third delimiter 			 * that's not escaped (or the end of the command). 			 */
name|delim
operator|=
operator|*
name|cmd
expr_stmt|;
operator|++
name|cmd
expr_stmt|;
operator|--
name|cmdlen
expr_stmt|;
for|for
control|(
name|cnt
operator|=
literal|2
init|;
name|cmdlen
operator|>
literal|0
operator|&&
name|cnt
condition|;
operator|--
name|cmdlen
operator|,
operator|++
name|cmd
control|)
if|if
condition|(
name|cmd
index|[
literal|0
index|]
operator|==
literal|'\\'
operator|&&
name|cmdlen
operator|>
literal|1
condition|)
block|{
operator|++
name|cmd
expr_stmt|;
operator|--
name|cmdlen
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmd
index|[
literal|0
index|]
operator|==
name|delim
condition|)
operator|--
name|cnt
expr_stmt|;
block|}
block|}
comment|/* 	 * Use normal quoting and termination rules to find the end 	 * of this command. 	 * 	 * QUOTING NOTE: 	 * 	 * Historically, vi permitted ^V's to escape<newline>'s in the .exrc 	 * file.  It was almost certainly a bug, but that's what bug-for-bug 	 * compatibility means, Grasshopper.  Also, ^V's escape the command  	 * delimiters.  Literal next quote characters in front of the newlines, 	 * '|' characters or literal next characters are stripped as as they're 	 * no longer useful. 	 */
for|for
control|(
name|p
operator|=
name|cmd
operator|,
name|cnt
operator|=
literal|0
init|;
name|cmdlen
operator|>
literal|0
condition|;
operator|--
name|cmdlen
operator|,
operator|++
name|cmd
control|)
block|{
if|if
condition|(
operator|(
name|ch
operator|=
name|cmd
index|[
literal|0
index|]
operator|)
operator|==
name|vlit
operator|&&
name|cmdlen
operator|>
literal|1
condition|)
block|{
name|ch
operator|=
name|cmd
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'\n'
operator|||
name|ch
operator|==
literal|'|'
condition|)
block|{
if|if
condition|(
name|ch
operator|==
literal|'\n'
condition|)
operator|++
name|sp
operator|->
name|if_lno
expr_stmt|;
operator|--
name|cmdlen
expr_stmt|;
operator|++
name|cmd
expr_stmt|;
operator|++
name|cnt
expr_stmt|;
block|}
else|else
name|ch
operator|=
name|vlit
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'\n'
operator|||
name|ch
operator|==
literal|'|'
condition|)
block|{
if|if
condition|(
name|ch
operator|==
literal|'\n'
condition|)
name|nl
operator|=
literal|1
expr_stmt|;
operator|--
name|cmdlen
expr_stmt|;
break|break;
block|}
operator|*
name|p
operator|++
operator|=
name|ch
expr_stmt|;
block|}
comment|/* 	 * Save off the next command information, go back to the 	 * original start of the command. 	 */
name|p
operator|=
name|cmd
operator|+
literal|1
expr_stmt|;
name|cmd
operator|=
name|save_cmd
expr_stmt|;
name|save_cmd
operator|=
name|p
expr_stmt|;
name|save_cmdlen
operator|=
name|cmdlen
expr_stmt|;
name|cmdlen
operator|=
operator|(
operator|(
name|save_cmd
operator|-
name|cmd
operator|)
operator|-
literal|1
operator|)
operator|-
name|cnt
expr_stmt|;
comment|/* 	 * !!! 	 * The "set tags" command historically used a backslash, not the 	 * user's literal next character, to escape whitespace.  Handle 	 * it here instead of complicating the argv_exp3() code.  Note, 	 * this isn't a particularly complex trap, and if backslashes were 	 * legal in set commands, this would have to be much more complicated. 	 */
if|if
condition|(
name|cp
operator|==
operator|&
name|cmds
index|[
name|C_SET
index|]
condition|)
for|for
control|(
name|p
operator|=
name|cmd
operator|,
name|len
operator|=
name|cmdlen
init|;
name|len
operator|>
literal|0
condition|;
operator|--
name|len
operator|,
operator|++
name|p
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|'\\'
condition|)
operator|*
name|p
operator|=
name|vlit
expr_stmt|;
comment|/* 	 * Set the default addresses.  It's an error to specify an address for 	 * a command that doesn't take them.  If two addresses are specified 	 * for a command that only takes one, lose the first one.  Two special 	 * cases here, some commands take 0 or 2 addresses.  For most of them 	 * (the E_ADDR2_ALL flag), 0 defaults to the entire file.  For one 	 * (the `!' command, the E_ADDR2_NONE flag), 0 defaults to no lines. 	 * 	 * Also, if the file is empty, some commands want to use an address of 	 * 0, i.e. the entire file is 0 to 0, and the default first address is 	 * 0.  Otherwise, an entire file is 1 to N and the default line is 1. 	 * Note, we also add the E_ZERO flag to the command flags, for the case 	 * where the 0 address is only valid if it's a default address. 	 * 	 * Also, set a flag if we set the default addresses.  Some commands 	 * (ex: z) care if the user specified an address of if we just used 	 * the current cursor. 	 */
switch|switch
condition|(
name|LF_ISSET
argument_list|(
name|E_ADDR1
operator||
name|E_ADDR2
operator||
name|E_ADDR2_ALL
operator||
name|E_ADDR2_NONE
argument_list|)
condition|)
block|{
case|case
name|E_ADDR1
case|:
comment|/* One address: */
switch|switch
condition|(
name|exc
operator|.
name|addrcnt
condition|)
block|{
case|case
literal|0
case|:
comment|/* Default cursor/empty file. */
name|exc
operator|.
name|addrcnt
operator|=
literal|1
expr_stmt|;
name|F_SET
argument_list|(
operator|&
name|exc
argument_list|,
name|E_ADDRDEF
argument_list|)
expr_stmt|;
if|if
condition|(
name|LF_ISSET
argument_list|(
name|E_ZERODEF
argument_list|)
condition|)
block|{
if|if
condition|(
name|file_lline
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|lno
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|lno
operator|==
literal|0
condition|)
block|{
name|exc
operator|.
name|addr1
operator|.
name|lno
operator|=
literal|0
expr_stmt|;
name|LF_SET
argument_list|(
name|E_ZERO
argument_list|)
expr_stmt|;
block|}
else|else
name|exc
operator|.
name|addr1
operator|.
name|lno
operator|=
name|sp
operator|->
name|lno
expr_stmt|;
block|}
else|else
name|exc
operator|.
name|addr1
operator|.
name|lno
operator|=
name|sp
operator|->
name|lno
expr_stmt|;
name|exc
operator|.
name|addr1
operator|.
name|cno
operator|=
name|sp
operator|->
name|cno
expr_stmt|;
break|break;
case|case
literal|1
case|:
break|break;
case|case
literal|2
case|:
comment|/* Lose the first address. */
name|exc
operator|.
name|addrcnt
operator|=
literal|1
expr_stmt|;
name|exc
operator|.
name|addr1
operator|=
name|exc
operator|.
name|addr2
expr_stmt|;
block|}
break|break;
case|case
name|E_ADDR2_NONE
case|:
comment|/* Zero/two addresses: */
if|if
condition|(
name|exc
operator|.
name|addrcnt
operator|==
literal|0
condition|)
comment|/* Default to nothing. */
break|break;
goto|goto
name|two
goto|;
case|case
name|E_ADDR2_ALL
case|:
comment|/* Zero/two addresses: */
if|if
condition|(
name|exc
operator|.
name|addrcnt
operator|==
literal|0
condition|)
block|{
comment|/* Default entire/empty file. */
name|exc
operator|.
name|addrcnt
operator|=
literal|2
expr_stmt|;
name|F_SET
argument_list|(
operator|&
name|exc
argument_list|,
name|E_ADDRDEF
argument_list|)
expr_stmt|;
if|if
condition|(
name|file_lline
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|exc
operator|.
name|addr2
operator|.
name|lno
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|LF_ISSET
argument_list|(
name|E_ZERODEF
argument_list|)
operator|&&
name|exc
operator|.
name|addr2
operator|.
name|lno
operator|==
literal|0
condition|)
block|{
name|exc
operator|.
name|addr1
operator|.
name|lno
operator|=
literal|0
expr_stmt|;
name|LF_SET
argument_list|(
name|E_ZERO
argument_list|)
expr_stmt|;
block|}
else|else
name|exc
operator|.
name|addr1
operator|.
name|lno
operator|=
literal|1
expr_stmt|;
name|exc
operator|.
name|addr1
operator|.
name|cno
operator|=
name|exc
operator|.
name|addr2
operator|.
name|cno
operator|=
literal|0
expr_stmt|;
name|F_SET
argument_list|(
operator|&
name|exc
argument_list|,
name|E_ADDR2_ALL
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* FALLTHROUGH */
case|case
name|E_ADDR2
case|:
comment|/* Two addresses: */
name|two
label|:
switch|switch
condition|(
name|exc
operator|.
name|addrcnt
condition|)
block|{
case|case
literal|0
case|:
comment|/* Default cursor/empty file. */
name|exc
operator|.
name|addrcnt
operator|=
literal|2
expr_stmt|;
name|F_SET
argument_list|(
operator|&
name|exc
argument_list|,
name|E_ADDRDEF
argument_list|)
expr_stmt|;
if|if
condition|(
name|LF_ISSET
argument_list|(
name|E_ZERODEF
argument_list|)
operator|&&
name|sp
operator|->
name|lno
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|file_lline
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|lno
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|lno
operator|==
literal|0
condition|)
block|{
name|exc
operator|.
name|addr1
operator|.
name|lno
operator|=
name|exc
operator|.
name|addr2
operator|.
name|lno
operator|=
literal|0
expr_stmt|;
name|LF_SET
argument_list|(
name|E_ZERO
argument_list|)
expr_stmt|;
block|}
else|else
name|exc
operator|.
name|addr1
operator|.
name|lno
operator|=
name|exc
operator|.
name|addr2
operator|.
name|lno
operator|=
name|sp
operator|->
name|lno
expr_stmt|;
block|}
else|else
name|exc
operator|.
name|addr1
operator|.
name|lno
operator|=
name|exc
operator|.
name|addr2
operator|.
name|lno
operator|=
name|sp
operator|->
name|lno
expr_stmt|;
name|exc
operator|.
name|addr1
operator|.
name|cno
operator|=
name|exc
operator|.
name|addr2
operator|.
name|cno
operator|=
name|sp
operator|->
name|cno
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* Default to first address. */
name|exc
operator|.
name|addrcnt
operator|=
literal|2
expr_stmt|;
name|exc
operator|.
name|addr2
operator|=
name|exc
operator|.
name|addr1
expr_stmt|;
break|break;
case|case
literal|2
case|:
break|break;
block|}
break|break;
default|default:
if|if
condition|(
name|exc
operator|.
name|addrcnt
condition|)
comment|/* Error. */
goto|goto
name|usage
goto|;
block|}
name|flagoff
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|cp
operator|->
name|syntax
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
operator|++
name|p
control|)
block|{
comment|/* 		 * The write command is sensitive to leading whitespace, e.g. 		 * "write !" is different from "write!".  If not the write 		 * command, skip leading whitespace. 		 */
if|if
condition|(
name|cp
operator|!=
operator|&
name|cmds
index|[
name|C_WRITE
index|]
condition|)
for|for
control|(
init|;
name|cmdlen
operator|>
literal|0
condition|;
operator|--
name|cmdlen
operator|,
operator|++
name|cmd
control|)
block|{
name|ch
operator|=
operator|*
name|cmd
expr_stmt|;
if|if
condition|(
operator|!
name|isblank
argument_list|(
name|ch
argument_list|)
condition|)
break|break;
block|}
comment|/* 		 * Quit when reach the end of the command, unless it's a 		 * command that does its own parsing, in which case we want 		 * to build a reasonable argv for it.  This code guarantees 		 * that there will be an argv when the function gets called, 		 * so the correct test is for a length of 0, not for the 		 * argc> 0. 		 */
if|if
condition|(
name|cmdlen
operator|==
literal|0
operator|&&
operator|*
name|p
operator|!=
literal|'!'
operator|&&
operator|*
name|p
operator|!=
literal|'S'
operator|&&
operator|*
name|p
operator|!=
literal|'s'
condition|)
break|break;
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|'!'
case|:
comment|/* ! */
if|if
condition|(
operator|*
name|cmd
operator|==
literal|'!'
condition|)
block|{
operator|++
name|cmd
expr_stmt|;
operator|--
name|cmdlen
expr_stmt|;
name|F_SET
argument_list|(
operator|&
name|exc
argument_list|,
name|E_FORCE
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'1'
case|:
comment|/* +, -, #, l, p */
comment|/* 			 * !!! 			 * Historically, some flags were ignored depending 			 * on where they occurred in the command line.  For 			 * example, in the command, ":3+++p--#", historic vi 			 * acted on the '#' flag, but ignored the '-' flags. 			 * It's unambiguous what the flags mean, so we just 			 * handle them regardless of the stupidity of their 			 * location. 			 */
for|for
control|(
init|;
name|cmdlen
condition|;
operator|--
name|cmdlen
operator|,
operator|++
name|cmd
control|)
switch|switch
condition|(
operator|*
name|cmd
condition|)
block|{
case|case
literal|'+'
case|:
operator|++
name|flagoff
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
operator|--
name|flagoff
expr_stmt|;
break|break;
case|case
literal|'#'
case|:
name|F_SET
argument_list|(
operator|&
name|exc
argument_list|,
name|E_F_HASH
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|F_SET
argument_list|(
operator|&
name|exc
argument_list|,
name|E_F_LIST
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|F_SET
argument_list|(
operator|&
name|exc
argument_list|,
name|E_F_PRINT
argument_list|)
expr_stmt|;
break|break;
default|default:
goto|goto
name|end1
goto|;
block|}
name|end1
label|:
break|break;
case|case
literal|'2'
case|:
comment|/* -, ., +, ^ */
case|case
literal|'3'
case|:
comment|/* -, ., +, ^, = */
for|for
control|(
init|;
name|cmdlen
condition|;
operator|--
name|cmdlen
operator|,
operator|++
name|cmd
control|)
switch|switch
condition|(
operator|*
name|cmd
condition|)
block|{
case|case
literal|'-'
case|:
name|F_SET
argument_list|(
operator|&
name|exc
argument_list|,
name|E_F_DASH
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'.'
case|:
name|F_SET
argument_list|(
operator|&
name|exc
argument_list|,
name|E_F_DOT
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'+'
case|:
name|F_SET
argument_list|(
operator|&
name|exc
argument_list|,
name|E_F_PLUS
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'^'
case|:
name|F_SET
argument_list|(
operator|&
name|exc
argument_list|,
name|E_F_CARAT
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'='
case|:
if|if
condition|(
operator|*
name|p
operator|==
literal|'3'
condition|)
block|{
name|F_SET
argument_list|(
operator|&
name|exc
argument_list|,
name|E_F_EQUAL
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* FALLTHROUGH */
default|default:
goto|goto
name|end2
goto|;
block|}
name|end2
label|:
break|break;
case|case
literal|'b'
case|:
comment|/* buffer */
comment|/* 			 * Digits can't be buffer names in ex commands, or the 			 * command "d2" would be a delete into buffer '2', and 			 * not a two-line deletion. 			 */
if|if
condition|(
operator|!
name|isdigit
argument_list|(
name|cmd
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|exc
operator|.
name|buffer
operator|=
operator|*
name|cmd
expr_stmt|;
operator|++
name|cmd
expr_stmt|;
operator|--
name|cmdlen
expr_stmt|;
name|F_SET
argument_list|(
operator|&
name|exc
argument_list|,
name|E_BUFFER
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'c'
case|:
comment|/* count [01+a] */
operator|++
name|p
expr_stmt|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
name|cmd
argument_list|)
operator|&&
operator|(
operator|*
name|p
operator|!=
literal|'+'
operator|||
operator|(
operator|*
name|cmd
operator|!=
literal|'+'
operator|&&
operator|*
name|cmd
operator|!=
literal|'-'
operator|)
operator|)
condition|)
break|break;
comment|/* 8-bit XXX */
if|if
condition|(
operator|(
name|lno
operator|=
name|strtol
argument_list|(
name|cmd
argument_list|,
operator|&
name|t
argument_list|,
literal|10
argument_list|)
operator|)
operator|==
literal|0
operator|&&
operator|*
name|p
operator|!=
literal|'0'
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"Count may not be zero."
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|cmdlen
operator|-=
operator|(
name|t
operator|-
name|cmd
operator|)
expr_stmt|;
name|cmd
operator|=
name|t
expr_stmt|;
comment|/* 			 * Count as address offsets occur in commands taking 			 * two addresses.  Historic vi practice was to use 			 * the count as an offset from the *second* address. 			 * 			 * Set a count flag; some underlying commands (see 			 * join) do different things with counts than with 			 * line addresses. 			 */
if|if
condition|(
operator|*
name|p
operator|==
literal|'a'
condition|)
block|{
name|exc
operator|.
name|addr1
operator|=
name|exc
operator|.
name|addr2
expr_stmt|;
name|exc
operator|.
name|addr2
operator|.
name|lno
operator|=
name|exc
operator|.
name|addr1
operator|.
name|lno
operator|+
name|lno
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|exc
operator|.
name|count
operator|=
name|lno
expr_stmt|;
name|F_SET
argument_list|(
operator|&
name|exc
argument_list|,
name|E_COUNT
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
comment|/* file */
if|if
condition|(
name|argv_exp2
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|exc
argument_list|,
name|cmd
argument_list|,
name|cmdlen
argument_list|,
name|cp
operator|==
operator|&
name|cmds
index|[
name|C_BANG
index|]
argument_list|)
condition|)
goto|goto
name|err
goto|;
goto|goto
name|countchk
goto|;
case|case
literal|'l'
case|:
comment|/* line */
if|if
condition|(
name|ep_line
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|cur
argument_list|,
operator|&
name|cmd
argument_list|,
operator|&
name|cmdlen
argument_list|,
operator|&
name|tmp
argument_list|)
condition|)
goto|goto
name|err
goto|;
comment|/* Line specifications are always required. */
if|if
condition|(
operator|!
name|tmp
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"%s: bad line specification"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|exc
operator|.
name|lineno
operator|=
name|cur
operator|.
name|lno
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
comment|/* string, file exp. */
if|if
condition|(
name|argv_exp1
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|exc
argument_list|,
name|cmd
argument_list|,
name|cmdlen
argument_list|,
name|cp
operator|==
operator|&
name|cmds
index|[
name|C_BANG
index|]
argument_list|)
condition|)
goto|goto
name|err
goto|;
goto|goto
name|addr2
goto|;
case|case
literal|'s'
case|:
comment|/* string */
if|if
condition|(
name|argv_exp0
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|exc
argument_list|,
name|cmd
argument_list|,
name|cmdlen
argument_list|)
condition|)
goto|goto
name|err
goto|;
goto|goto
name|addr2
goto|;
case|case
literal|'W'
case|:
comment|/* word string */
comment|/* 			 * QUOTING NOTE: 			 * 			 * Literal next characters escape the following 			 * character.  Quoting characters are stripped 			 * here since they are no longer useful. 			 * 			 * First there was the word. 			 */
for|for
control|(
name|p
operator|=
name|t
operator|=
name|cmd
init|;
name|cmdlen
operator|>
literal|0
condition|;
operator|--
name|cmdlen
operator|,
operator|++
name|cmd
control|)
block|{
if|if
condition|(
operator|(
name|ch
operator|=
operator|*
name|cmd
operator|)
operator|==
name|vlit
operator|&&
name|cmdlen
operator|>
literal|1
condition|)
block|{
operator|--
name|cmdlen
expr_stmt|;
operator|*
name|p
operator|++
operator|=
operator|*
operator|++
name|cmd
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isblank
argument_list|(
name|ch
argument_list|)
condition|)
block|{
operator|++
name|cmd
expr_stmt|;
operator|--
name|cmdlen
expr_stmt|;
break|break;
block|}
else|else
operator|*
name|p
operator|++
operator|=
name|ch
expr_stmt|;
block|}
if|if
condition|(
name|argv_exp0
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|exc
argument_list|,
name|t
argument_list|,
name|p
operator|-
name|t
argument_list|)
condition|)
goto|goto
name|err
goto|;
comment|/* Delete intervening whitespace. */
for|for
control|(
init|;
name|cmdlen
operator|>
literal|0
condition|;
operator|--
name|cmdlen
operator|,
operator|++
name|cmd
control|)
block|{
name|ch
operator|=
operator|*
name|cmd
expr_stmt|;
if|if
condition|(
operator|!
name|isblank
argument_list|(
name|ch
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|cmdlen
operator|==
literal|0
condition|)
goto|goto
name|usage
goto|;
comment|/* Followed by the string. */
for|for
control|(
name|p
operator|=
name|t
operator|=
name|cmd
init|;
name|cmdlen
operator|>
literal|0
condition|;
operator|--
name|cmdlen
operator|,
operator|++
name|cmd
operator|,
operator|++
name|p
control|)
if|if
condition|(
operator|(
name|ch
operator|=
operator|*
name|cmd
operator|)
operator|==
name|vlit
operator|&&
name|cmdlen
operator|>
literal|1
condition|)
block|{
operator|--
name|cmdlen
expr_stmt|;
operator|*
name|p
operator|=
operator|*
operator|++
name|cmd
expr_stmt|;
block|}
else|else
operator|*
name|p
operator|=
name|ch
expr_stmt|;
if|if
condition|(
name|argv_exp0
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|exc
argument_list|,
name|t
argument_list|,
name|p
operator|-
name|t
argument_list|)
condition|)
goto|goto
name|err
goto|;
goto|goto
name|addr2
goto|;
case|case
literal|'w'
case|:
comment|/* word */
if|if
condition|(
name|argv_exp3
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|exc
argument_list|,
name|cmd
argument_list|,
name|cmdlen
argument_list|)
condition|)
goto|goto
name|err
goto|;
name|countchk
label|:
if|if
condition|(
operator|*
operator|++
name|p
operator|!=
literal|'N'
condition|)
block|{
comment|/* N */
comment|/* 				 * If a number is specified, must either be 				 * 0 or that number, if optional, and that 				 * number, if required. 				 */
name|num
operator|=
operator|*
name|p
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
operator|(
operator|*
operator|++
name|p
operator|!=
literal|'o'
operator|||
name|exp
operator|->
name|argsoff
operator|!=
literal|0
operator|)
operator|&&
name|exp
operator|->
name|argsoff
operator|!=
name|num
condition|)
goto|goto
name|usage
goto|;
block|}
goto|goto
name|addr2
goto|;
default|default:
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"Internal syntax table error (%s: %c)."
argument_list|,
name|cp
operator|->
name|name
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Skip trailing whitespace. */
for|for
control|(
init|;
name|cmdlen
condition|;
operator|--
name|cmdlen
control|)
block|{
name|ch
operator|=
operator|*
name|cmd
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|isblank
argument_list|(
name|ch
argument_list|)
condition|)
break|break;
block|}
comment|/* 	 * There shouldn't be anything left, and no more required 	 * fields, i.e neither 'l' or 'r' in the syntax string. 	 */
if|if
condition|(
name|cmdlen
operator|||
name|strpbrk
argument_list|(
name|p
argument_list|,
literal|"lr"
argument_list|)
condition|)
block|{
name|usage
label|:
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"Usage: %s."
argument_list|,
name|cp
operator|->
name|usage
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* Verify that the addresses are legal. */
name|addr2
label|:
switch|switch
condition|(
name|exc
operator|.
name|addrcnt
condition|)
block|{
case|case
literal|2
case|:
if|if
condition|(
name|file_lline
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|lno
argument_list|)
condition|)
goto|goto
name|err
goto|;
comment|/* 		 * Historic ex/vi permitted commands with counts to go past 		 * EOF.  So, for example, if the file only had 5 lines, the 		 * ex command "1,6>" would fail, but the command ">300" 		 * would succeed.  Since we don't want to have to make all 		 * of the underlying commands handle random line numbers, 		 * fix it here. 		 */
if|if
condition|(
name|exc
operator|.
name|addr2
operator|.
name|lno
operator|>
name|lno
condition|)
if|if
condition|(
name|F_ISSET
argument_list|(
operator|&
name|exc
argument_list|,
name|E_COUNT
argument_list|)
condition|)
name|exc
operator|.
name|addr2
operator|.
name|lno
operator|=
name|lno
expr_stmt|;
else|else
block|{
if|if
condition|(
name|lno
operator|==
literal|0
condition|)
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"The file is empty."
argument_list|)
expr_stmt|;
else|else
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"Only %lu line%s in the file"
argument_list|,
name|lno
argument_list|,
name|lno
operator|>
literal|1
condition|?
literal|"s"
else|:
literal|""
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* FALLTHROUGH */
case|case
literal|1
case|:
name|num
operator|=
name|exc
operator|.
name|addr1
operator|.
name|lno
expr_stmt|;
comment|/* 		 * If it's a "default vi command", zero is okay.  Historic 		 * vi allowed this, note, it's also the hack that allows 		 * "vi + nonexistent_file" to work. 		 */
if|if
condition|(
name|num
operator|==
literal|0
operator|&&
operator|(
operator|!
name|IN_VI_MODE
argument_list|(
name|sp
argument_list|)
operator|||
name|uselastcmd
operator|!=
literal|1
operator|)
operator|&&
operator|!
name|LF_ISSET
argument_list|(
name|E_ZERO
argument_list|)
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"The %s command doesn't permit an address of 0."
argument_list|,
name|cp
operator|->
name|name
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|file_lline
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|lno
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|num
operator|>
name|lno
condition|)
block|{
if|if
condition|(
name|lno
operator|==
literal|0
condition|)
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"The file is empty."
argument_list|)
expr_stmt|;
else|else
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"Only %lu line%s in the file"
argument_list|,
name|lno
argument_list|,
name|lno
operator|>
literal|1
condition|?
literal|"s"
else|:
literal|""
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
break|break;
block|}
comment|/* If doing a default command, vi just moves to the line. */
if|if
condition|(
name|IN_VI_MODE
argument_list|(
name|sp
argument_list|)
operator|&&
name|uselastcmd
condition|)
block|{
switch|switch
condition|(
name|exc
operator|.
name|addrcnt
condition|)
block|{
case|case
literal|2
case|:
name|sp
operator|->
name|lno
operator|=
name|exc
operator|.
name|addr2
operator|.
name|lno
condition|?
name|exc
operator|.
name|addr2
operator|.
name|lno
else|:
literal|1
expr_stmt|;
name|sp
operator|->
name|cno
operator|=
name|exc
operator|.
name|addr2
operator|.
name|cno
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|sp
operator|->
name|lno
operator|=
name|exc
operator|.
name|addr1
operator|.
name|lno
condition|?
name|exc
operator|.
name|addr1
operator|.
name|lno
else|:
literal|1
expr_stmt|;
name|sp
operator|->
name|cno
operator|=
name|exc
operator|.
name|addr1
operator|.
name|cno
expr_stmt|;
break|break;
block|}
name|cmd
operator|=
name|save_cmd
expr_stmt|;
name|cmdlen
operator|=
name|save_cmdlen
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
comment|/* Reset "last" command. */
if|if
condition|(
name|LF_ISSET
argument_list|(
name|E_SETLAST
argument_list|)
condition|)
name|exp
operator|->
name|lastcmd
operator|=
name|cp
expr_stmt|;
comment|/* Final setup for the command. */
name|exc
operator|.
name|cmd
operator|=
name|cp
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG
argument_list|)
operator|&&
literal|0
name|TRACE
argument_list|(
name|sp
argument_list|,
literal|"ex_cmd: %s"
argument_list|,
name|exc
operator|.
name|cmd
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|exc
operator|.
name|addrcnt
operator|>
literal|0
condition|)
block|{
name|TRACE
argument_list|(
name|sp
argument_list|,
literal|"\taddr1 %d"
argument_list|,
name|exc
operator|.
name|addr1
operator|.
name|lno
argument_list|)
expr_stmt|;
if|if
condition|(
name|exc
operator|.
name|addrcnt
operator|>
literal|1
condition|)
name|TRACE
argument_list|(
name|sp
argument_list|,
literal|" addr2: %d"
argument_list|,
name|exc
operator|.
name|addr2
operator|.
name|lno
argument_list|)
expr_stmt|;
name|TRACE
argument_list|(
name|sp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|exc
operator|.
name|lineno
condition|)
name|TRACE
argument_list|(
name|sp
argument_list|,
literal|"\tlineno %d"
argument_list|,
name|exc
operator|.
name|lineno
argument_list|)
expr_stmt|;
if|if
condition|(
name|exc
operator|.
name|flags
condition|)
name|TRACE
argument_list|(
name|sp
argument_list|,
literal|"\tflags %0x"
argument_list|,
name|exc
operator|.
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|F_ISSET
argument_list|(
operator|&
name|exc
argument_list|,
name|E_BUFFER
argument_list|)
condition|)
name|TRACE
argument_list|(
name|sp
argument_list|,
literal|"\tbuffer %c"
argument_list|,
name|exc
operator|.
name|buffer
argument_list|)
expr_stmt|;
name|TRACE
argument_list|(
name|sp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|exc
operator|.
name|argc
condition|)
block|{
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
name|exc
operator|.
name|argc
condition|;
operator|++
name|cnt
control|)
name|TRACE
argument_list|(
name|sp
argument_list|,
literal|"\targ %d: {%s}"
argument_list|,
name|cnt
argument_list|,
name|exc
operator|.
name|argv
index|[
name|cnt
index|]
argument_list|)
expr_stmt|;
name|TRACE
argument_list|(
name|sp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Clear autoprint flag. */
name|F_CLR
argument_list|(
name|exp
argument_list|,
name|EX_AUTOPRINT
argument_list|)
expr_stmt|;
comment|/* Increment the command count if not called from vi. */
if|if
condition|(
operator|!
name|IN_VI_MODE
argument_list|(
name|sp
argument_list|)
condition|)
operator|++
name|sp
operator|->
name|ccnt
expr_stmt|;
comment|/* 	 * If file state and not doing a global command, log the start of 	 * an action. 	 */
if|if
condition|(
name|ep
operator|!=
name|NULL
operator|&&
operator|!
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|S_GLOBAL
argument_list|)
condition|)
operator|(
name|void
operator|)
name|log_cursor
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|)
expr_stmt|;
comment|/* Save the current mode. */
name|saved_mode
operator|=
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|S_SCREENS
operator||
name|S_MAJOR_CHANGE
argument_list|)
expr_stmt|;
comment|/* Do the command. */
if|if
condition|(
call|(
name|cp
operator|->
name|fn
call|)
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|exc
argument_list|)
condition|)
goto|goto
name|err
goto|;
ifdef|#
directive|ifdef
name|DEBUG
comment|/* Make sure no function left the temporary space locked. */
if|if
condition|(
name|F_ISSET
argument_list|(
name|sp
operator|->
name|gp
argument_list|,
name|G_TMP_INUSE
argument_list|)
condition|)
block|{
name|F_CLR
argument_list|(
name|sp
operator|->
name|gp
argument_list|,
name|G_TMP_INUSE
argument_list|)
expr_stmt|;
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"Error: ex: temporary buffer not released."
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
endif|#
directive|endif
if|if
condition|(
name|saved_mode
operator|!=
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|S_SCREENS
operator||
name|S_MAJOR_CHANGE
argument_list|)
condition|)
block|{
comment|/* 		 * Only here if the mode of the underlying file changed, e.g. 		 * the user switched files or is exiting.  There are two things 		 * that we might have to save.  First, any "+cmd" field set up 		 * for an ex/edit command will have to be saved for later, also, 		 * any not yet executed part of the current ex command. 		 * 		 *	:edit +25 file.c|s/abc/ABC/|1 		 * 		 * for example. 		 * 		 * The historic vi just hung, of course; we handle by 		 * pushing the keys onto the tty queue.  If we're 		 * switching modes to vi, since the commands are intended 		 * as ex commands, add the extra characters to make it 		 * work. 		 * 		 * For the fun of it, if you want to see if a vi clone got 		 * the ex argument parsing right, try:  		 * 		 *	echo 'foo|bar'> file1; echo 'foo/bar'> file2; 		 *	vi 		 *	:edit +1|s/|/PIPE/|w file1| e file2|1 | s/\//SLASH/|wq 		 */
if|if
condition|(
name|arg1_len
operator|==
name|NULL
operator|&&
name|save_cmdlen
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|IN_VI_MODE
argument_list|(
name|sp
argument_list|)
operator|&&
name|term_push
argument_list|(
name|sp
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|save_cmdlen
operator|!=
literal|0
condition|)
if|if
condition|(
name|term_push
argument_list|(
name|sp
argument_list|,
name|save_cmd
argument_list|,
name|save_cmdlen
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|arg1
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|IN_VI_MODE
argument_list|(
name|sp
argument_list|)
operator|&&
name|save_cmdlen
operator|!=
literal|0
operator|&&
name|term_push
argument_list|(
name|sp
argument_list|,
literal|"|"
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|term_push
argument_list|(
name|sp
argument_list|,
name|arg1
argument_list|,
name|arg1_len
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|IN_VI_MODE
argument_list|(
name|sp
argument_list|)
operator|&&
name|term_push
argument_list|(
name|sp
argument_list|,
literal|":"
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|err
goto|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|IN_EX_MODE
argument_list|(
name|sp
argument_list|)
operator|&&
name|ep
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * The print commands have already handled the `print' flags. 		 * If so, clear them.  Don't return, autoprint may still have 		 * stuff to print out. 		 */
if|if
condition|(
name|LF_ISSET
argument_list|(
name|E_F_PRCLEAR
argument_list|)
condition|)
name|F_CLR
argument_list|(
operator|&
name|exc
argument_list|,
name|E_F_HASH
operator||
name|E_F_LIST
operator||
name|E_F_PRINT
argument_list|)
expr_stmt|;
comment|/* 		 * If the command was successful, and there was an explicit 		 * flag to display the new cursor line, or we're in ex mode, 		 * autoprint is set, and a change was made, display the line. 		 */
if|if
condition|(
name|flagoff
condition|)
block|{
if|if
condition|(
name|flagoff
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|sp
operator|->
name|lno
operator|<
operator|-
name|flagoff
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"Flag offset before line 1."
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|file_lline
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|lno
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|sp
operator|->
name|lno
operator|+
name|flagoff
operator|>
name|lno
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"Flag offset past end-of-file."
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
block|}
name|sp
operator|->
name|lno
operator|+=
name|flagoff
expr_stmt|;
block|}
if|if
condition|(
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_AUTOPRINT
argument_list|)
operator|&&
operator|(
name|F_ISSET
argument_list|(
name|exp
argument_list|,
name|EX_AUTOPRINT
argument_list|)
operator|||
name|F_ISSET
argument_list|(
name|cp
argument_list|,
name|E_AUTOPRINT
argument_list|)
operator|)
condition|)
name|LF_INIT
argument_list|(
name|E_F_PRINT
argument_list|)
expr_stmt|;
else|else
name|LF_INIT
argument_list|(
name|F_ISSET
argument_list|(
operator|&
name|exc
argument_list|,
name|E_F_HASH
operator||
name|E_F_LIST
operator||
name|E_F_PRINT
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|exc
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|EXCMDARG
argument_list|)
argument_list|)
expr_stmt|;
name|exc
operator|.
name|addrcnt
operator|=
literal|2
expr_stmt|;
name|exc
operator|.
name|addr1
operator|.
name|lno
operator|=
name|exc
operator|.
name|addr2
operator|.
name|lno
operator|=
name|sp
operator|->
name|lno
expr_stmt|;
name|exc
operator|.
name|addr1
operator|.
name|cno
operator|=
name|exc
operator|.
name|addr2
operator|.
name|cno
operator|=
name|sp
operator|->
name|cno
expr_stmt|;
switch|switch
condition|(
name|LF_ISSET
argument_list|(
name|E_F_HASH
operator||
name|E_F_LIST
operator||
name|E_F_PRINT
argument_list|)
condition|)
block|{
case|case
name|E_F_HASH
case|:
name|exc
operator|.
name|cmd
operator|=
operator|&
name|cmds
index|[
name|C_HASH
index|]
expr_stmt|;
name|ex_number
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|exc
argument_list|)
expr_stmt|;
break|break;
case|case
name|E_F_LIST
case|:
name|exc
operator|.
name|cmd
operator|=
operator|&
name|cmds
index|[
name|C_LIST
index|]
expr_stmt|;
name|ex_list
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|exc
argument_list|)
expr_stmt|;
break|break;
case|case
name|E_F_PRINT
case|:
name|exc
operator|.
name|cmd
operator|=
operator|&
name|cmds
index|[
name|C_PRINT
index|]
expr_stmt|;
name|ex_pr
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|exc
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|cmd
operator|=
name|save_cmd
expr_stmt|;
name|cmdlen
operator|=
name|save_cmdlen
expr_stmt|;
goto|goto
name|loop
goto|;
comment|/* NOTREACHED */
comment|/* 	 * On error, we discard any keys we have left, as well as any keys 	 * that were mapped.  The test of save_cmdlen isn't necessarily 	 * correct.  If we fail early enough we don't know if the entire 	 * string was a single command or not.  Try and guess, it's useful 	 * to know if part of the command was discarded. 	 */
name|err
label|:
if|if
condition|(
name|save_cmdlen
operator|==
literal|0
condition|)
for|for
control|(
init|;
name|cmdlen
condition|;
operator|--
name|cmdlen
control|)
if|if
condition|(
operator|(
name|ch
operator|=
operator|*
name|cmd
operator|++
operator|)
operator|==
name|vlit
operator|&&
name|cmdlen
operator|>
literal|1
condition|)
block|{
operator|--
name|cmdlen
expr_stmt|;
operator|++
name|cmd
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'\n'
operator|||
name|ch
operator|==
literal|'|'
condition|)
block|{
if|if
condition|(
name|cmdlen
operator|>
literal|1
condition|)
name|save_cmdlen
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|save_cmdlen
operator|!=
literal|0
condition|)
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"Ex command failed: remaining command input discarded."
argument_list|)
expr_stmt|;
name|term_map_flush
argument_list|(
name|sp
argument_list|,
literal|"Ex command failed"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ep_range --  *	Get a line range for ex commands.  */
end_comment

begin_function
specifier|static
name|int
name|ep_range
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|,
name|excp
parameter_list|,
name|cmdp
parameter_list|,
name|cmdlenp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
name|EXCMDARG
modifier|*
name|excp
decl_stmt|;
name|char
modifier|*
modifier|*
name|cmdp
decl_stmt|;
name|size_t
modifier|*
name|cmdlenp
decl_stmt|;
block|{
name|MARK
name|cur
decl_stmt|,
name|savecursor
decl_stmt|;
name|size_t
name|cmdlen
decl_stmt|;
name|int
name|savecursor_set
decl_stmt|,
name|tmp
decl_stmt|;
name|char
modifier|*
name|cmd
decl_stmt|;
comment|/* Percent character is all lines in the file. */
name|cmd
operator|=
operator|*
name|cmdp
expr_stmt|;
name|cmdlen
operator|=
operator|*
name|cmdlenp
expr_stmt|;
if|if
condition|(
operator|*
name|cmd
operator|==
literal|'%'
condition|)
block|{
name|excp
operator|->
name|addr1
operator|.
name|lno
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|file_lline
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|excp
operator|->
name|addr2
operator|.
name|lno
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* If an empty file, then the first line is 0, not 1. */
if|if
condition|(
name|excp
operator|->
name|addr2
operator|.
name|lno
operator|==
literal|0
condition|)
name|excp
operator|->
name|addr1
operator|.
name|lno
operator|=
literal|0
expr_stmt|;
name|excp
operator|->
name|addr1
operator|.
name|cno
operator|=
name|excp
operator|->
name|addr2
operator|.
name|cno
operator|=
literal|0
expr_stmt|;
name|excp
operator|->
name|addrcnt
operator|=
literal|2
expr_stmt|;
operator|++
operator|*
name|cmdp
expr_stmt|;
operator|--
operator|*
name|cmdlenp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Parse comma or semi-colon delimited line specs. */
for|for
control|(
name|savecursor_set
operator|=
literal|0
operator|,
name|excp
operator|->
name|addrcnt
operator|=
literal|0
init|;
name|cmdlen
operator|>
literal|0
condition|;
control|)
switch|switch
condition|(
operator|*
name|cmd
condition|)
block|{
case|case
literal|';'
case|:
comment|/* Semi-colon delimiter. */
comment|/* 			 * Comma delimiters delimit; semi-colon delimiters 			 * change the current address for the 2nd address 			 * to be the first address.  Trailing or multiple 			 * delimiters are discarded. 			 */
if|if
condition|(
name|excp
operator|->
name|addrcnt
operator|==
literal|0
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
operator|!
name|savecursor_set
condition|)
block|{
name|savecursor
operator|.
name|lno
operator|=
name|sp
operator|->
name|lno
expr_stmt|;
name|savecursor
operator|.
name|cno
operator|=
name|sp
operator|->
name|cno
expr_stmt|;
name|sp
operator|->
name|lno
operator|=
name|excp
operator|->
name|addr1
operator|.
name|lno
expr_stmt|;
name|sp
operator|->
name|cno
operator|=
name|excp
operator|->
name|addr1
operator|.
name|cno
expr_stmt|;
name|savecursor_set
operator|=
literal|1
expr_stmt|;
block|}
operator|++
name|cmd
expr_stmt|;
operator|--
name|cmdlen
expr_stmt|;
break|break;
case|case
literal|','
case|:
comment|/* Comma delimiter. */
comment|/* If no addresses yet, defaults to ".". */
if|if
condition|(
name|excp
operator|->
name|addrcnt
operator|==
literal|0
condition|)
block|{
name|excp
operator|->
name|addr1
operator|.
name|lno
operator|=
name|sp
operator|->
name|lno
expr_stmt|;
name|excp
operator|->
name|addr1
operator|.
name|cno
operator|=
name|sp
operator|->
name|cno
expr_stmt|;
name|excp
operator|->
name|addrcnt
operator|=
literal|1
expr_stmt|;
block|}
comment|/* FALLTHROUGH */
case|case
literal|' '
case|:
comment|/* Whitespace. */
case|case
literal|'\t'
case|:
comment|/* Whitespace. */
operator|++
name|cmd
expr_stmt|;
operator|--
name|cmdlen
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|ep_line
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|cur
argument_list|,
operator|&
name|cmd
argument_list|,
operator|&
name|cmdlen
argument_list|,
operator|&
name|tmp
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
operator|!
name|tmp
condition|)
goto|goto
name|done
goto|;
comment|/* 			 * Extra addresses are discarded, starting with 			 * the first. 			 */
switch|switch
condition|(
name|excp
operator|->
name|addrcnt
condition|)
block|{
case|case
literal|0
case|:
name|excp
operator|->
name|addr1
operator|=
name|cur
expr_stmt|;
name|excp
operator|->
name|addrcnt
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|excp
operator|->
name|addr2
operator|=
name|cur
expr_stmt|;
name|excp
operator|->
name|addrcnt
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|excp
operator|->
name|addr1
operator|=
name|excp
operator|->
name|addr2
expr_stmt|;
name|excp
operator|->
name|addr2
operator|=
name|cur
expr_stmt|;
break|break;
block|}
break|break;
block|}
comment|/* 	 * XXX 	 * This is probably not right behavior for savecursor -- need 	 * to figure out what the historical ex did for ";,;,;5p" or 	 * similar stupidity. 	 */
name|done
label|:
if|if
condition|(
name|savecursor_set
condition|)
block|{
name|sp
operator|->
name|lno
operator|=
name|savecursor
operator|.
name|lno
expr_stmt|;
name|sp
operator|->
name|cno
operator|=
name|savecursor
operator|.
name|cno
expr_stmt|;
block|}
if|if
condition|(
name|excp
operator|->
name|addrcnt
operator|==
literal|2
operator|&&
operator|(
name|excp
operator|->
name|addr2
operator|.
name|lno
operator|<
name|excp
operator|->
name|addr1
operator|.
name|lno
operator|||
name|excp
operator|->
name|addr2
operator|.
name|lno
operator|==
name|excp
operator|->
name|addr1
operator|.
name|lno
operator|&&
name|excp
operator|->
name|addr2
operator|.
name|cno
operator|<
name|excp
operator|->
name|addr1
operator|.
name|cno
operator|)
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"The second address is smaller than the first."
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
operator|*
name|cmdp
operator|=
name|cmd
expr_stmt|;
operator|*
name|cmdlenp
operator|=
name|cmdlen
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get a single line address specifier.  */
end_comment

begin_function
specifier|static
name|int
name|ep_line
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|,
name|cur
parameter_list|,
name|cmdp
parameter_list|,
name|cmdlenp
parameter_list|,
name|addr_found
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
name|MARK
modifier|*
name|cur
decl_stmt|;
name|char
modifier|*
modifier|*
name|cmdp
decl_stmt|;
name|size_t
modifier|*
name|cmdlenp
decl_stmt|;
name|int
modifier|*
name|addr_found
decl_stmt|;
block|{
name|MARK
name|m
decl_stmt|,
modifier|*
name|mp
decl_stmt|;
name|long
name|total
decl_stmt|;
name|u_int
name|flags
decl_stmt|;
name|size_t
name|cmdlen
decl_stmt|;
name|char
modifier|*
name|cmd
decl_stmt|,
modifier|*
name|endp
decl_stmt|;
operator|*
name|addr_found
operator|=
literal|0
expr_stmt|;
name|cmd
operator|=
operator|*
name|cmdp
expr_stmt|;
name|cmdlen
operator|=
operator|*
name|cmdlenp
expr_stmt|;
switch|switch
condition|(
operator|*
name|cmd
condition|)
block|{
case|case
literal|'$'
case|:
comment|/* Last line in the file. */
operator|*
name|addr_found
operator|=
literal|1
expr_stmt|;
name|cur
operator|->
name|cno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|file_lline
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|cur
operator|->
name|lno
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
operator|++
name|cmd
expr_stmt|;
operator|--
name|cmdlen
expr_stmt|;
break|break;
comment|/* Absolute line number. */
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
operator|*
name|addr_found
operator|=
literal|1
expr_stmt|;
comment|/* 		 * The way the vi "previous context" mark worked was that 		 * "non-relative" motions set it.  While vi wasn't totally 		 * consistent about this, ANY numeric address was considered 		 * non-relative, and set the value.  Which is why we're 		 * hacking marks down here. 		 */
if|if
condition|(
name|IN_VI_MODE
argument_list|(
name|sp
argument_list|)
condition|)
block|{
name|m
operator|.
name|lno
operator|=
name|sp
operator|->
name|lno
expr_stmt|;
name|m
operator|.
name|cno
operator|=
name|sp
operator|->
name|cno
expr_stmt|;
if|if
condition|(
name|mark_set
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|ABSMARK1
argument_list|,
operator|&
name|m
argument_list|,
literal|1
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|cur
operator|->
name|cno
operator|=
literal|0
expr_stmt|;
comment|/* 8-bit XXX */
name|cur
operator|->
name|lno
operator|=
name|strtol
argument_list|(
name|cmd
argument_list|,
operator|&
name|endp
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|cmdlen
operator|-=
operator|(
name|endp
operator|-
name|cmd
operator|)
expr_stmt|;
name|cmd
operator|=
name|endp
expr_stmt|;
break|break;
case|case
literal|'\''
case|:
comment|/* Use a mark. */
operator|*
name|addr_found
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|cmdlen
operator|==
literal|1
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"No mark name supplied."
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|mp
operator|=
name|mark_get
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|cmd
index|[
literal|1
index|]
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
operator|*
name|cur
operator|=
operator|*
name|mp
expr_stmt|;
name|cmd
operator|+=
literal|2
expr_stmt|;
name|cmdlen
operator|-=
literal|2
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
comment|/* Search: forward/backward. */
comment|/* 		 * !!! 		 * I can't find any difference between // and \/ or 		 * between ?? and \?.  Mark Horton doesn't remember 		 * there being any difference.  C'est la vie. 		 */
if|if
condition|(
name|cmdlen
operator|<
literal|2
operator|||
name|cmd
index|[
literal|1
index|]
operator|!=
literal|'/'
operator|&&
name|cmd
index|[
literal|1
index|]
operator|!=
literal|'?'
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"\\ not followed by / or ?."
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
operator|++
name|cmd
expr_stmt|;
operator|--
name|cmdlen
expr_stmt|;
if|if
condition|(
name|cmd
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
goto|goto
name|forward
goto|;
if|if
condition|(
name|cmd
index|[
literal|0
index|]
operator|==
literal|'?'
condition|)
goto|goto
name|backward
goto|;
comment|/* NOTREACHED */
case|case
literal|'/'
case|:
comment|/* Search forward. */
name|forward
label|:
operator|*
name|addr_found
operator|=
literal|1
expr_stmt|;
name|m
operator|.
name|lno
operator|=
name|sp
operator|->
name|lno
expr_stmt|;
name|m
operator|.
name|cno
operator|=
name|sp
operator|->
name|cno
expr_stmt|;
name|flags
operator|=
name|SEARCH_MSG
operator||
name|SEARCH_PARSE
operator||
name|SEARCH_SET
expr_stmt|;
if|if
condition|(
name|f_search
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|m
argument_list|,
operator|&
name|m
argument_list|,
name|cmd
argument_list|,
operator|&
name|endp
argument_list|,
operator|&
name|flags
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|cur
operator|->
name|lno
operator|=
name|m
operator|.
name|lno
expr_stmt|;
name|cur
operator|->
name|cno
operator|=
name|m
operator|.
name|cno
expr_stmt|;
name|cmdlen
operator|-=
operator|(
name|endp
operator|-
name|cmd
operator|)
expr_stmt|;
name|cmd
operator|=
name|endp
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
comment|/* Search backward. */
name|backward
label|:
operator|*
name|addr_found
operator|=
literal|1
expr_stmt|;
name|m
operator|.
name|lno
operator|=
name|sp
operator|->
name|lno
expr_stmt|;
name|m
operator|.
name|cno
operator|=
name|sp
operator|->
name|cno
expr_stmt|;
name|flags
operator|=
name|SEARCH_MSG
operator||
name|SEARCH_PARSE
operator||
name|SEARCH_SET
expr_stmt|;
if|if
condition|(
name|b_search
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|m
argument_list|,
operator|&
name|m
argument_list|,
name|cmd
argument_list|,
operator|&
name|endp
argument_list|,
operator|&
name|flags
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|cur
operator|->
name|lno
operator|=
name|m
operator|.
name|lno
expr_stmt|;
name|cur
operator|->
name|cno
operator|=
name|m
operator|.
name|cno
expr_stmt|;
name|cmdlen
operator|-=
operator|(
name|endp
operator|-
name|cmd
operator|)
expr_stmt|;
name|cmd
operator|=
name|endp
expr_stmt|;
break|break;
case|case
literal|'.'
case|:
comment|/* Current position. */
operator|*
name|addr_found
operator|=
literal|1
expr_stmt|;
name|cur
operator|->
name|cno
operator|=
name|sp
operator|->
name|cno
expr_stmt|;
comment|/* If an empty file, then '.' is 0, not 1. */
if|if
condition|(
name|sp
operator|->
name|lno
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|file_lline
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|cur
operator|->
name|lno
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|cur
operator|->
name|lno
operator|!=
literal|0
condition|)
name|cur
operator|->
name|lno
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|cur
operator|->
name|lno
operator|=
name|sp
operator|->
name|lno
expr_stmt|;
operator|++
name|cmd
expr_stmt|;
operator|--
name|cmdlen
expr_stmt|;
break|break;
block|}
comment|/* 	 * Evaluate any offset.  Offsets are +/- any number, or any number 	 * of +/- signs, or any combination thereof.  If no address found 	 * yet, offset is relative to ".". 	 */
for|for
control|(
name|total
operator|=
literal|0
init|;
name|cmdlen
operator|>
literal|0
operator|&&
operator|(
name|cmd
index|[
literal|0
index|]
operator|==
literal|'-'
operator|||
name|cmd
index|[
literal|0
index|]
operator|==
literal|'+'
operator|)
condition|;
control|)
block|{
if|if
condition|(
operator|!
operator|*
name|addr_found
condition|)
block|{
name|cur
operator|->
name|lno
operator|=
name|sp
operator|->
name|lno
expr_stmt|;
name|cur
operator|->
name|cno
operator|=
name|sp
operator|->
name|cno
expr_stmt|;
operator|*
name|addr_found
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|cmdlen
operator|>
literal|1
operator|&&
name|isdigit
argument_list|(
name|cmd
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
comment|/* 8-bit XXX */
name|total
operator|+=
name|strtol
argument_list|(
name|cmd
argument_list|,
operator|&
name|endp
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|cmdlen
operator|-=
operator|(
name|endp
operator|-
name|cmd
operator|)
expr_stmt|;
name|cmd
operator|=
name|endp
expr_stmt|;
block|}
else|else
block|{
name|total
operator|+=
name|cmd
index|[
literal|0
index|]
operator|==
literal|'-'
condition|?
operator|-
literal|1
else|:
literal|1
expr_stmt|;
operator|--
name|cmdlen
expr_stmt|;
operator|++
name|cmd
expr_stmt|;
block|}
block|}
if|if
condition|(
name|total
operator|<
literal|0
operator|&&
operator|-
name|total
operator|>
name|cur
operator|->
name|lno
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"Reference to a line number less than 0."
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|cur
operator|->
name|lno
operator|+=
name|total
expr_stmt|;
operator|*
name|cmdp
operator|=
name|cmd
expr_stmt|;
operator|*
name|cmdlenp
operator|=
name|cmdlen
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ex_is_abbrev -  *	The vi text input routine needs to know if ex thinks this is  *	an [un]abbreviate command, so it can turn off abbreviations.  *	Usual ranting in the vi/v_ntext:txt_abbrev() routine.  */
end_comment

begin_function
name|int
name|ex_is_abbrev
parameter_list|(
name|name
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|size_t
name|len
decl_stmt|;
block|{
name|EXCMDLIST
specifier|const
modifier|*
name|cp
decl_stmt|;
return|return
operator|(
operator|(
name|cp
operator|=
name|ex_comm_search
argument_list|(
name|name
argument_list|,
name|len
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
operator|(
name|cp
operator|==
operator|&
name|cmds
index|[
name|C_ABBR
index|]
operator|||
name|cp
operator|==
operator|&
name|cmds
index|[
name|C_UNABBREVIATE
index|]
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|EXCMDLIST
specifier|const
modifier|*
name|ex_comm_search
parameter_list|(
name|name
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|size_t
name|len
decl_stmt|;
block|{
name|EXCMDLIST
specifier|const
modifier|*
name|cp
decl_stmt|;
for|for
control|(
name|cp
operator|=
name|cmds
init|;
name|cp
operator|->
name|name
operator|!=
name|NULL
condition|;
operator|++
name|cp
control|)
block|{
if|if
condition|(
name|cp
operator|->
name|name
index|[
literal|0
index|]
operator|>
name|name
index|[
literal|0
index|]
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|cp
operator|->
name|name
index|[
literal|0
index|]
operator|!=
name|name
index|[
literal|0
index|]
condition|)
continue|continue;
if|if
condition|(
operator|!
name|memcmp
argument_list|(
name|name
argument_list|,
name|cp
operator|->
name|name
argument_list|,
name|len
argument_list|)
condition|)
return|return
operator|(
name|cp
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

end_unit

