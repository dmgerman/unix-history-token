begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1991, 1993, 1994  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)term.c	8.56 (Berkeley) 3/23/94"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<bitstring.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<curses.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<termios.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<db.h>
end_include

begin_include
include|#
directive|include
file|<regex.h>
end_include

begin_include
include|#
directive|include
file|"vi.h"
end_include

begin_include
include|#
directive|include
file|"seq.h"
end_include

begin_decl_stmt
specifier|static
name|int
name|keycmp
name|__P
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|,
specifier|const
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|termkeyset
name|__P
argument_list|(
operator|(
name|GS
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * If we're reading less than 20 characters, up the size of the tty buffer.  * This shouldn't ever happen, other than the first time through, but it's  * possible if a map is large enough.  */
end_comment

begin_define
define|#
directive|define
name|term_read_grow
parameter_list|(
name|sp
parameter_list|,
name|tty
parameter_list|)
define|\
value|(tty)->nelem - (tty)->cnt>= 20 ? 0 : __term_read_grow(sp, tty, 64)
end_define

begin_decl_stmt
specifier|static
name|int
name|__term_read_grow
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|IBUF
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * XXX  * THIS REQUIRES THAT ALL SCREENS SHARE A TERMINAL TYPE.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|_tklist
block|{
name|char
modifier|*
name|ts
decl_stmt|;
comment|/* Key's termcap string. */
name|char
modifier|*
name|output
decl_stmt|;
comment|/* Corresponding vi command. */
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Name. */
name|u_char
name|value
decl_stmt|;
comment|/* Special value (for lookup). */
block|}
name|TKLIST
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|TKLIST
specifier|const
name|c_tklist
index|[]
init|=
block|{
comment|/* Command mappings. */
block|{
literal|"kA"
block|,
literal|"O"
block|,
literal|"insert line"
block|}
block|,
block|{
literal|"kD"
block|,
literal|"x"
block|,
literal|"delete character"
block|}
block|,
block|{
literal|"kd"
block|,
literal|"j"
block|,
literal|"cursor down"
block|}
block|,
block|{
literal|"kE"
block|,
literal|"D"
block|,
literal|"delete to eol"
block|}
block|,
block|{
literal|"kF"
block|,
literal|"\004"
block|,
literal|"scroll down"
block|}
block|,
block|{
literal|"kH"
block|,
literal|"$"
block|,
literal|"go to eol"
block|}
block|,
block|{
literal|"kh"
block|,
literal|"^"
block|,
literal|"go to sol"
block|}
block|,
block|{
literal|"kI"
block|,
literal|"i"
block|,
literal|"insert at cursor"
block|}
block|,
block|{
literal|"kL"
block|,
literal|"dd"
block|,
literal|"delete line"
block|}
block|,
block|{
literal|"kl"
block|,
literal|"h"
block|,
literal|"cursor left"
block|}
block|,
block|{
literal|"kN"
block|,
literal|"\006"
block|,
literal|"page down"
block|}
block|,
block|{
literal|"kP"
block|,
literal|"\002"
block|,
literal|"page up"
block|}
block|,
block|{
literal|"kR"
block|,
literal|"\025"
block|,
literal|"scroll up"
block|}
block|,
block|{
literal|"kS"
block|,
literal|"dG"
block|,
literal|"delete to end of screen"
block|}
block|,
block|{
literal|"kr"
block|,
literal|"l"
block|,
literal|"cursor right"
block|}
block|,
block|{
literal|"ku"
block|,
literal|"k"
block|,
literal|"cursor up"
block|}
block|,
block|{
name|NULL
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|TKLIST
specifier|const
name|m1_tklist
index|[]
init|=
block|{
comment|/* Input mappings (lookup). */
block|{
literal|"kl"
block|,
name|NULL
block|,
literal|"cursor erase"
block|,
name|K_VERASE
block|}
block|,
block|{
name|NULL
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|TKLIST
specifier|const
name|m2_tklist
index|[]
init|=
block|{
comment|/* Input mappings (set or delete). */
block|{
literal|"kd"
block|,
name|NULL
block|,
literal|"cursor down"
block|}
block|,
block|{
literal|"ku"
block|,
name|NULL
block|,
literal|"cursor up"
block|}
block|,
block|{
literal|"kr"
block|,
literal|" "
block|,
literal|"cursor space"
block|}
block|,
block|{
name|NULL
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * !!!  * Historic ex/vi always used:  *  *	^D: autoindent deletion  *	^H: last character deletion  *	^W: last word deletion  *	^Q: quote the next character (if not used in flow control).  *	^V: quote the next character  *  * regardless of the user's choices for these characters.  The user's erase  * and kill characters worked in addition to these characters.  Ex was not  * completely consistent with this scheme, as it did map the scroll command  * to the user's current EOF character.  This implementation wires down the  * above characters, but in addition uses the VERASE, VINTR, VKILL and VWERASE  * characters described by the user's termios structure.  We don't do the EOF  * mapping for ex, but I think I'm unlikely to get caught on that one.  *  * XXX  * THIS REQUIRES THAT ALL SCREENS SHARE A SPECIAL KEY SET.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|_keylist
block|{
name|u_char
name|value
decl_stmt|;
comment|/* Special value. */
name|CHAR_T
name|ch
decl_stmt|;
comment|/* Key. */
block|}
name|KEYLIST
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|KEYLIST
name|keylist
index|[]
init|=
block|{
block|{
name|K_CARAT
block|,
literal|'^'
block|}
block|,
comment|/*  ^ */
block|{
name|K_CNTRLD
block|,
literal|'\004'
block|}
block|,
comment|/* ^D */
block|{
name|K_CNTRLR
block|,
literal|'\022'
block|}
block|,
comment|/* ^R */
block|{
name|K_CNTRLT
block|,
literal|'\024'
block|}
block|,
comment|/* ^T */
block|{
name|K_CNTRLZ
block|,
literal|'\032'
block|}
block|,
comment|/* ^Z */
block|{
name|K_COLON
block|,
literal|':'
block|}
block|,
comment|/*  : */
block|{
name|K_CR
block|,
literal|'\r'
block|}
block|,
comment|/* \r */
block|{
name|K_ESCAPE
block|,
literal|'\033'
block|}
block|,
comment|/* ^[ */
block|{
name|K_FORMFEED
block|,
literal|'\f'
block|}
block|,
comment|/* \f */
block|{
name|K_NL
block|,
literal|'\n'
block|}
block|,
comment|/* \n */
block|{
name|K_RIGHTBRACE
block|,
literal|'}'
block|}
block|,
comment|/*  } */
block|{
name|K_RIGHTPAREN
block|,
literal|')'
block|}
block|,
comment|/*  ) */
block|{
name|K_TAB
block|,
literal|'\t'
block|}
block|,
comment|/* \t */
block|{
name|K_VERASE
block|,
literal|'\b'
block|}
block|,
comment|/* \b */
block|{
name|K_VINTR
block|,
literal|'\003'
block|}
block|,
comment|/* ^C */
block|{
name|K_VKILL
block|,
literal|'\025'
block|}
block|,
comment|/* ^U */
block|{
name|K_VLNEXT
block|,
literal|'\021'
block|}
block|,
comment|/* ^Q */
block|{
name|K_VLNEXT
block|,
literal|'\026'
block|}
block|,
comment|/* ^V */
block|{
name|K_VWERASE
block|,
literal|'\027'
block|}
block|,
comment|/* ^W */
block|{
name|K_ZERO
block|,
literal|'0'
block|}
block|,
comment|/*  0 */
block|{
name|K_NOTUSED
block|,
literal|0
block|}
block|,
comment|/* VERASE, VINTR, VKILL, VWERASE */
block|{
name|K_NOTUSED
block|,
literal|0
block|}
block|,
block|{
name|K_NOTUSED
block|,
literal|0
block|}
block|,
block|{
name|K_NOTUSED
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nkeylist
init|=
operator|(
sizeof|sizeof
argument_list|(
name|keylist
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|keylist
index|[
literal|0
index|]
argument_list|)
operator|)
operator|-
literal|4
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * term_init --  *	Initialize the special key lookup table, and the special keys  *	defined by the terminal's termcap entry.  */
end_comment

begin_function
name|int
name|term_init
parameter_list|(
name|sp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
block|{
specifier|extern
name|CHNAME
specifier|const
name|asciiname
index|[]
decl_stmt|;
comment|/* XXX */
name|GS
modifier|*
name|gp
decl_stmt|;
name|KEYLIST
modifier|*
name|kp
decl_stmt|;
name|TKLIST
specifier|const
modifier|*
name|tkp
decl_stmt|;
name|int
name|cnt
decl_stmt|;
name|char
modifier|*
name|sbp
decl_stmt|,
modifier|*
name|t
decl_stmt|,
name|buf
index|[
literal|2
operator|*
literal|1024
index|]
decl_stmt|,
name|sbuf
index|[
literal|128
index|]
decl_stmt|;
comment|/* 	 * XXX 	 * 8-bit, ASCII only, for now.  Recompilation should get you 	 * any 8-bit character set, as long as nul isn't a character. 	 */
name|gp
operator|=
name|sp
operator|->
name|gp
expr_stmt|;
name|gp
operator|->
name|cname
operator|=
name|asciiname
expr_stmt|;
comment|/* XXX */
ifdef|#
directive|ifdef
name|VERASE
name|termkeyset
argument_list|(
name|gp
argument_list|,
name|VERASE
argument_list|,
name|K_VERASE
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|VINTR
name|termkeyset
argument_list|(
name|gp
argument_list|,
name|VINTR
argument_list|,
name|K_VINTR
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|VKILL
name|termkeyset
argument_list|(
name|gp
argument_list|,
name|VKILL
argument_list|,
name|K_VKILL
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|VWERASE
name|termkeyset
argument_list|(
name|gp
argument_list|,
name|VWERASE
argument_list|,
name|K_VWERASE
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Sort the special key list. */
name|qsort
argument_list|(
name|keylist
argument_list|,
name|nkeylist
argument_list|,
sizeof|sizeof
argument_list|(
name|keylist
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|keycmp
argument_list|)
expr_stmt|;
comment|/* Initialize the fast lookup table. */
name|CALLOC_RET
argument_list|(
name|sp
argument_list|,
name|gp
operator|->
name|special_key
argument_list|,
name|u_char
operator|*
argument_list|,
name|MAX_FAST_KEY
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|u_char
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|gp
operator|->
name|max_special
operator|=
literal|0
operator|,
name|kp
operator|=
name|keylist
operator|,
name|cnt
operator|=
name|nkeylist
init|;
name|cnt
operator|--
condition|;
operator|++
name|kp
control|)
block|{
if|if
condition|(
name|gp
operator|->
name|max_special
operator|<
name|kp
operator|->
name|value
condition|)
name|gp
operator|->
name|max_special
operator|=
name|kp
operator|->
name|value
expr_stmt|;
if|if
condition|(
name|kp
operator|->
name|ch
operator|<=
name|MAX_FAST_KEY
condition|)
name|gp
operator|->
name|special_key
index|[
name|kp
operator|->
name|ch
index|]
operator|=
name|kp
operator|->
name|value
expr_stmt|;
block|}
comment|/* Set key sequences found in the termcap entry. */
switch|switch
condition|(
name|tgetent
argument_list|(
name|buf
argument_list|,
name|O_STR
argument_list|(
name|sp
argument_list|,
name|O_TERM
argument_list|)
argument_list|)
condition|)
block|{
case|case
operator|-
literal|1
case|:
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"tgetent: %s: %s."
argument_list|,
name|O_STR
argument_list|(
name|sp
argument_list|,
name|O_TERM
argument_list|)
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|0
case|:
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"%s: unknown terminal type."
argument_list|,
name|O_STR
argument_list|(
name|sp
argument_list|,
name|O_TERM
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Command mappings. */
for|for
control|(
name|tkp
operator|=
name|c_tklist
init|;
name|tkp
operator|->
name|name
operator|!=
name|NULL
condition|;
operator|++
name|tkp
control|)
block|{
name|sbp
operator|=
name|sbuf
expr_stmt|;
if|if
condition|(
operator|(
name|t
operator|=
name|tgetstr
argument_list|(
name|tkp
operator|->
name|ts
argument_list|,
operator|&
name|sbp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|seq_set
argument_list|(
name|sp
argument_list|,
name|tkp
operator|->
name|name
argument_list|,
name|strlen
argument_list|(
name|tkp
operator|->
name|name
argument_list|)
argument_list|,
name|t
argument_list|,
name|strlen
argument_list|(
name|t
argument_list|)
argument_list|,
name|tkp
operator|->
name|output
argument_list|,
name|strlen
argument_list|(
name|tkp
operator|->
name|output
argument_list|)
argument_list|,
name|SEQ_COMMAND
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* Input mappings needing to be looked up. */
for|for
control|(
name|tkp
operator|=
name|m1_tklist
init|;
name|tkp
operator|->
name|name
operator|!=
name|NULL
condition|;
operator|++
name|tkp
control|)
block|{
name|sbp
operator|=
name|sbuf
expr_stmt|;
if|if
condition|(
operator|(
name|t
operator|=
name|tgetstr
argument_list|(
name|tkp
operator|->
name|ts
argument_list|,
operator|&
name|sbp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
continue|continue;
for|for
control|(
name|kp
operator|=
name|keylist
init|;
condition|;
operator|++
name|kp
control|)
if|if
condition|(
name|kp
operator|->
name|value
operator|==
name|tkp
operator|->
name|value
condition|)
break|break;
if|if
condition|(
name|kp
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|seq_set
argument_list|(
name|sp
argument_list|,
name|tkp
operator|->
name|name
argument_list|,
name|strlen
argument_list|(
name|tkp
operator|->
name|name
argument_list|)
argument_list|,
name|t
argument_list|,
name|strlen
argument_list|(
name|t
argument_list|)
argument_list|,
operator|&
name|kp
operator|->
name|ch
argument_list|,
literal|1
argument_list|,
name|SEQ_INPUT
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* Input mappings that are already set or are text deletions. */
for|for
control|(
name|tkp
operator|=
name|m2_tklist
init|;
name|tkp
operator|->
name|name
operator|!=
name|NULL
condition|;
operator|++
name|tkp
control|)
block|{
name|sbp
operator|=
name|sbuf
expr_stmt|;
if|if
condition|(
operator|(
name|t
operator|=
name|tgetstr
argument_list|(
name|tkp
operator|->
name|ts
argument_list|,
operator|&
name|sbp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|tkp
operator|->
name|output
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|seq_set
argument_list|(
name|sp
argument_list|,
name|tkp
operator|->
name|name
argument_list|,
name|strlen
argument_list|(
name|tkp
operator|->
name|name
argument_list|)
argument_list|,
name|t
argument_list|,
name|strlen
argument_list|(
name|t
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|SEQ_INPUT
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|seq_set
argument_list|(
name|sp
argument_list|,
name|tkp
operator|->
name|name
argument_list|,
name|strlen
argument_list|(
name|tkp
operator|->
name|name
argument_list|)
argument_list|,
name|t
argument_list|,
name|strlen
argument_list|(
name|t
argument_list|)
argument_list|,
name|tkp
operator|->
name|output
argument_list|,
name|strlen
argument_list|(
name|tkp
operator|->
name|output
argument_list|)
argument_list|,
name|SEQ_INPUT
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * termkeyset --  *	Set keys found in the termios structure.  VERASE, VINTR and VKILL are  *	required by POSIX 1003.1-1990, VWERASE is a 4.4BSD extension.  We've  *	left four open slots in the keylist table, if these values exist, put  *	them into place.  Note, they may reset (or duplicate) values already  *	in the table, so we check for that first.  */
end_comment

begin_function
specifier|static
name|void
name|termkeyset
parameter_list|(
name|gp
parameter_list|,
name|name
parameter_list|,
name|val
parameter_list|)
name|GS
modifier|*
name|gp
decl_stmt|;
name|int
name|name
decl_stmt|,
name|val
decl_stmt|;
block|{
name|KEYLIST
modifier|*
name|kp
decl_stmt|;
name|cc_t
name|ch
decl_stmt|;
if|if
condition|(
operator|!
name|F_ISSET
argument_list|(
name|gp
argument_list|,
name|G_TERMIOS_SET
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|(
name|ch
operator|=
name|gp
operator|->
name|original_termios
operator|.
name|c_cc
index|[
operator|(
name|name
operator|)
index|]
operator|)
operator|==
name|_POSIX_VDISABLE
condition|)
return|return;
comment|/* Check for duplication. */
for|for
control|(
name|kp
operator|=
name|keylist
init|;
name|kp
operator|->
name|value
operator|!=
name|K_NOTUSED
condition|;
operator|++
name|kp
control|)
if|if
condition|(
name|kp
operator|->
name|ch
operator|==
name|ch
condition|)
block|{
name|kp
operator|->
name|value
operator|=
name|val
expr_stmt|;
return|return;
block|}
comment|/* Add a new entry. */
if|if
condition|(
name|kp
operator|->
name|value
operator|==
name|K_NOTUSED
condition|)
block|{
name|keylist
index|[
name|nkeylist
index|]
operator|.
name|ch
operator|=
name|ch
expr_stmt|;
name|keylist
index|[
name|nkeylist
index|]
operator|.
name|value
operator|=
name|val
expr_stmt|;
operator|++
name|nkeylist
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * term_push --  *	Push keys onto the front of a buffer.  *  * There is a single input buffer in ex/vi.  Characters are read onto the  * end of the buffer by the terminal input routines, and pushed onto the  * front of the buffer by various other functions in ex/vi.  Each key has  * an associated flag value, which indicates if it has already been quoted,  * if it is the result of a mapping or an abbreviation, as well as a count  * of the number of times it has been mapped.  */
end_comment

begin_function
name|int
name|term_push
parameter_list|(
name|sp
parameter_list|,
name|s
parameter_list|,
name|nchars
parameter_list|,
name|cmap
parameter_list|,
name|flags
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|CHAR_T
modifier|*
name|s
decl_stmt|;
comment|/* Characters. */
name|size_t
name|nchars
decl_stmt|;
comment|/* Number of chars. */
name|u_int
name|cmap
decl_stmt|;
comment|/* Map count. */
name|u_int
name|flags
decl_stmt|;
comment|/* CH_* flags. */
block|{
name|IBUF
modifier|*
name|tty
decl_stmt|;
comment|/* If we have room, stuff the keys into the buffer. */
name|tty
operator|=
name|sp
operator|->
name|gp
operator|->
name|tty
expr_stmt|;
if|if
condition|(
name|nchars
operator|<=
name|tty
operator|->
name|next
operator|||
operator|(
name|tty
operator|->
name|ch
operator|!=
name|NULL
operator|&&
name|tty
operator|->
name|cnt
operator|==
literal|0
operator|&&
name|nchars
operator|<=
name|tty
operator|->
name|nelem
operator|)
condition|)
block|{
if|if
condition|(
name|tty
operator|->
name|cnt
operator|!=
literal|0
condition|)
name|tty
operator|->
name|next
operator|-=
name|nchars
expr_stmt|;
name|tty
operator|->
name|cnt
operator|+=
name|nchars
expr_stmt|;
name|MEMMOVE
argument_list|(
name|tty
operator|->
name|ch
operator|+
name|tty
operator|->
name|next
argument_list|,
name|s
argument_list|,
name|nchars
argument_list|)
expr_stmt|;
name|MEMSET
argument_list|(
name|tty
operator|->
name|chf
operator|+
name|tty
operator|->
name|next
argument_list|,
name|flags
argument_list|,
name|nchars
argument_list|)
expr_stmt|;
name|MEMSET
argument_list|(
name|tty
operator|->
name|cmap
operator|+
name|tty
operator|->
name|next
argument_list|,
name|cmap
argument_list|,
name|nchars
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Get enough space plus a little extra. */
if|if
condition|(
name|tty
operator|->
name|cnt
operator|+
name|nchars
operator|>=
name|tty
operator|->
name|nelem
operator|&&
name|__term_read_grow
argument_list|(
name|sp
argument_list|,
name|tty
argument_list|,
name|MAX
argument_list|(
name|nchars
argument_list|,
literal|64
argument_list|)
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 	 * If there are currently characters in the queue, shift them up, 	 * leaving some extra room. 	 */
define|#
directive|define
name|TERM_PUSH_SHIFT
value|30
if|if
condition|(
name|tty
operator|->
name|cnt
condition|)
block|{
name|MEMMOVE
argument_list|(
name|tty
operator|->
name|ch
operator|+
name|TERM_PUSH_SHIFT
operator|+
name|nchars
argument_list|,
name|tty
operator|->
name|ch
operator|+
name|tty
operator|->
name|next
argument_list|,
name|tty
operator|->
name|cnt
argument_list|)
expr_stmt|;
name|MEMMOVE
argument_list|(
name|tty
operator|->
name|chf
operator|+
name|TERM_PUSH_SHIFT
operator|+
name|nchars
argument_list|,
name|tty
operator|->
name|chf
operator|+
name|tty
operator|->
name|next
argument_list|,
name|tty
operator|->
name|cnt
argument_list|)
expr_stmt|;
name|MEMMOVE
argument_list|(
name|tty
operator|->
name|cmap
operator|+
name|TERM_PUSH_SHIFT
operator|+
name|nchars
argument_list|,
name|tty
operator|->
name|cmap
operator|+
name|tty
operator|->
name|next
argument_list|,
name|tty
operator|->
name|cnt
argument_list|)
expr_stmt|;
block|}
comment|/* Put the new characters into the queue. */
name|tty
operator|->
name|next
operator|=
name|TERM_PUSH_SHIFT
expr_stmt|;
name|tty
operator|->
name|cnt
operator|+=
name|nchars
expr_stmt|;
name|MEMMOVE
argument_list|(
name|tty
operator|->
name|ch
operator|+
name|TERM_PUSH_SHIFT
argument_list|,
name|s
argument_list|,
name|nchars
argument_list|)
expr_stmt|;
name|MEMSET
argument_list|(
name|tty
operator|->
name|chf
operator|+
name|TERM_PUSH_SHIFT
argument_list|,
name|flags
argument_list|,
name|nchars
argument_list|)
expr_stmt|;
name|MEMSET
argument_list|(
name|tty
operator|->
name|cmap
operator|+
name|TERM_PUSH_SHIFT
argument_list|,
name|cmap
argument_list|,
name|nchars
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Remove characters from the queue, simultaneously clearing the flag  * and map counts.  */
end_comment

begin_define
define|#
directive|define
name|QREM_HEAD
parameter_list|(
name|q
parameter_list|,
name|len
parameter_list|)
value|{						\ 	size_t __off = (q)->next;					\ 	if (len == 1) {							\ 		tty->chf[__off] = 0;					\ 		tty->cmap[__off] = 0;					\ 	} else {							\ 		MEMSET(tty->chf + __off, 0, len);			\ 		MEMSET(tty->cmap + __off, 0, len);			\ 	}								\ 	if (((q)->cnt -= len) == 0)					\ 		(q)->next = 0;						\ 	else								\ 		(q)->next += len;					\ }
end_define

begin_define
define|#
directive|define
name|QREM_TAIL
parameter_list|(
name|q
parameter_list|,
name|len
parameter_list|)
value|{						\ 	size_t __off = (q)->next + (q)->cnt - 1;			\ 	if (len == 1) {							\ 		tty->chf[__off] = 0;					\ 		tty->cmap[__off] = 0;					\ 	} else {							\ 		MEMSET(tty->chf + __off, 0, len);			\ 		MEMSET(tty->cmap + __off, 0, len);			\ 	}								\ 	if (((q)->cnt -= len) == 0)					\ 		(q)->next = 0;						\ }
end_define

begin_comment
comment|/*  * term_key --  *	Get the next key.  *  * !!!  * The flag TXT_MAPNODIGIT probably needs some explanation.  First, the idea  * of mapping keys is that one or more keystrokes act like a function key.  * What's going on is that vi is reading a number, and the character following  * the number may or may not be mapped (TXT_MAPCOMMAND).  For example, if the  * user is entering the z command, a valid command is "z40+", and we don't want  * to map the '+', i.e. if '+' is mapped to "xxx", we don't want to change it  * into "z40xxx".  However, if the user enters "35x", we want to put all of the  * characters through the mapping code.  *  * Historical practice is a bit muddled here.  (Surprise!)  It always permitted  * mapping digits as long as they weren't the first character of the map, e.g.  * ":map ^A1 xxx" was okay.  It also permitted the mapping of the digits 1-9  * (the digit 0 was a special case as it doesn't indicate the start of a count)  * as the first character of the map, but then ignored those mappings.  While  * it's probably stupid to map digits, vi isn't your mother.  *  * The way this works is that the TXT_MAPNODIGIT causes term_key to return the  * end-of-digit without "looking" at the next character, i.e. leaving it as the  * user entered it.  Presumably, the next term_key call will tell us how the  * user wants it handled.  *  * There is one more complication.  Users might map keys to digits, and, as  * it's described above, the commands "map g 1G|d2g" would return the keys  * "d2<end-of-digits>1G", when the user probably wanted "d21<end-of-digits>G".  * So, if a map starts off with a digit we continue as before, otherwise, we  * pretend that we haven't mapped the character and return<end-of-digits>.  *  * Now that that's out of the way, let's talk about Energizer Bunny macros.  * It's easy to create macros that expand to a loop, e.g. map x 3x.  It's  * fairly easy to detect this example, because it's all internal to term_key.  * If we're expanding a macro and it gets big enough, at some point we can  * assume it's looping and kill it.  The examples that are tough are the ones  * where the parser is involved, e.g. map x "ayyx"byy.  We do an expansion  * on 'x', and get "ayyx"byy.  We then return the first 4 characters, and then  * find the looping macro again.  There is no way that we can detect this  * without doing a full parse of the command, because the character that might  * cause the loop (in this case 'x') may be a literal character, e.g. the map  * map x "ayy"xyy"byy is perfectly legal and won't cause a loop.  *  * Historic vi tried to detect looping macros by disallowing obvious cases in  * the map command, maps that that ended with the same letter as they started  * (which wrongly disallowed "map x 'x"), and detecting macros that expanded  * too many times before keys were returned to the command parser.  It didn't  * get many (most?) of the tricky cases right, however, and it was certainly  * possible to create macros that ran forever.  And, even if it did figure out  * what was going on, the user was usually tossed into ex mode.  Finally, any  * changes made before vi realized that the macro was recursing were left in  * place.  This implementation counts how many times each input character has  * been mapped.  If it reaches some arbitrary value, we flush all mapped keys  * and return an error.  *  * XXX  * The final issue is recovery.  It would be possible to undo all of the work  * that was done by the macro if we entered a record into the log so that we  * knew when the macro started, and, in fact, this might be worth doing at some  * point.  Given that this might make the log grow unacceptably (consider that  * cursor keys are done with maps), for now we leave any changes made in place.  */
end_comment

begin_function
name|enum
name|input
name|term_key
parameter_list|(
name|sp
parameter_list|,
name|chp
parameter_list|,
name|flags
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|CH
modifier|*
name|chp
decl_stmt|;
name|u_int
name|flags
decl_stmt|;
block|{
name|enum
name|input
name|rval
decl_stmt|;
name|struct
name|timeval
name|t
decl_stmt|,
modifier|*
name|tp
decl_stmt|;
name|CHAR_T
name|ch
decl_stmt|;
name|GS
modifier|*
name|gp
decl_stmt|;
name|IBUF
modifier|*
name|tty
decl_stmt|;
name|SEQ
modifier|*
name|qp
decl_stmt|;
name|int
name|cmap
decl_stmt|,
name|ispartial
decl_stmt|,
name|nr
decl_stmt|,
name|itear
decl_stmt|;
name|gp
operator|=
name|sp
operator|->
name|gp
expr_stmt|;
name|tty
operator|=
name|gp
operator|->
name|tty
expr_stmt|;
comment|/* 	 * If the queue is empty, read more keys in.  Since no timeout is 	 * requested, s_key_read will either return an error or will read 	 * some number of characters. 	 */
name|loop
label|:
if|if
condition|(
name|tty
operator|->
name|cnt
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|term_read_grow
argument_list|(
name|sp
argument_list|,
name|tty
argument_list|)
condition|)
return|return
operator|(
name|INP_ERR
operator|)
return|;
if|if
condition|(
name|rval
operator|=
name|sp
operator|->
name|s_key_read
argument_list|(
name|sp
argument_list|,
operator|&
name|nr
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
operator|(
name|rval
operator|)
return|;
comment|/* 		 * If there's something on the mode line that we wanted 		 * the user to see, they just entered a character so we 		 * can presume they saw it. 		 */
if|if
condition|(
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|S_UPDATE_MODE
argument_list|)
condition|)
name|F_CLR
argument_list|(
name|sp
argument_list|,
name|S_UPDATE_MODE
argument_list|)
expr_stmt|;
block|}
comment|/* If no limit on remaps, set it up so the user can interrupt. */
name|itear
operator|=
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_REMAPMAX
argument_list|)
condition|?
literal|0
else|:
operator|!
name|intr_init
argument_list|(
name|sp
argument_list|)
expr_stmt|;
comment|/* If the key is mappable and should be mapped, look it up. */
if|if
condition|(
operator|!
operator|(
name|tty
operator|->
name|chf
index|[
name|tty
operator|->
name|next
index|]
operator|&
name|CH_NOMAP
operator|)
operator|&&
name|LF_ISSET
argument_list|(
name|TXT_MAPCOMMAND
operator||
name|TXT_MAPINPUT
argument_list|)
condition|)
block|{
comment|/* Set up timeout value. */
if|if
condition|(
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_TIMEOUT
argument_list|)
condition|)
block|{
name|tp
operator|=
operator|&
name|t
expr_stmt|;
name|t
operator|.
name|tv_sec
operator|=
name|O_VAL
argument_list|(
name|sp
argument_list|,
name|O_KEYTIME
argument_list|)
operator|/
literal|10
expr_stmt|;
name|t
operator|.
name|tv_usec
operator|=
operator|(
name|O_VAL
argument_list|(
name|sp
argument_list|,
name|O_KEYTIME
argument_list|)
operator|%
literal|10
operator|)
operator|*
literal|100000L
expr_stmt|;
block|}
else|else
name|tp
operator|=
name|NULL
expr_stmt|;
comment|/* Get the next key. */
name|newmap
label|:
name|ch
operator|=
name|tty
operator|->
name|ch
index|[
name|tty
operator|->
name|next
index|]
expr_stmt|;
if|if
condition|(
name|ch
operator|<
name|MAX_BIT_SEQ
operator|&&
operator|!
name|bit_test
argument_list|(
name|gp
operator|->
name|seqb
argument_list|,
name|ch
argument_list|)
condition|)
goto|goto
name|nomap
goto|;
comment|/* Search the map. */
name|remap
label|:
name|qp
operator|=
name|seq_find
argument_list|(
name|sp
argument_list|,
name|NULL
argument_list|,
operator|&
name|tty
operator|->
name|ch
index|[
name|tty
operator|->
name|next
index|]
argument_list|,
name|tty
operator|->
name|cnt
argument_list|,
name|LF_ISSET
argument_list|(
name|TXT_MAPCOMMAND
argument_list|)
condition|?
name|SEQ_COMMAND
else|:
name|SEQ_INPUT
argument_list|,
operator|&
name|ispartial
argument_list|)
expr_stmt|;
comment|/* 		 * If get a partial match, read more characters and retry 		 * the map.  If no characters read, return the characters 		 * unmapped. 		 */
if|if
condition|(
name|ispartial
condition|)
block|{
if|if
condition|(
name|term_read_grow
argument_list|(
name|sp
argument_list|,
name|tty
argument_list|)
condition|)
block|{
name|rval
operator|=
name|INP_ERR
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
if|if
condition|(
name|rval
operator|=
name|sp
operator|->
name|s_key_read
argument_list|(
name|sp
argument_list|,
operator|&
name|nr
argument_list|,
name|tp
argument_list|)
condition|)
goto|goto
name|ret
goto|;
if|if
condition|(
name|nr
condition|)
goto|goto
name|remap
goto|;
goto|goto
name|nomap
goto|;
block|}
comment|/* If no map, return the character. */
if|if
condition|(
name|qp
operator|==
name|NULL
condition|)
goto|goto
name|nomap
goto|;
comment|/* 		 * If looking for the end of a digit string, and the first 		 * character of the map is it, pretend we haven't seen the 		 * character. 		 */
if|if
condition|(
name|LF_ISSET
argument_list|(
name|TXT_MAPNODIGIT
argument_list|)
operator|&&
name|qp
operator|->
name|output
operator|!=
name|NULL
operator|&&
operator|!
name|isdigit
argument_list|(
name|qp
operator|->
name|output
index|[
literal|0
index|]
argument_list|)
condition|)
goto|goto
name|not_digit_ch
goto|;
comment|/* 		 * Only permit a character to be remapped a certain number 		 * of times before we figure that it's not going to finish. 		 */
if|if
condition|(
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_REMAPMAX
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|cmap
operator|=
name|tty
operator|->
name|cmap
index|[
name|tty
operator|->
name|next
index|]
operator|)
operator|>
name|MAX_MAP_COUNT
condition|)
goto|goto
name|flush
goto|;
block|}
elseif|else
if|if
condition|(
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|S_INTERRUPTED
argument_list|)
condition|)
block|{
name|flush
label|:
name|term_map_flush
argument_list|(
name|sp
argument_list|,
literal|"Character remapped too many times"
argument_list|)
expr_stmt|;
name|rval
operator|=
name|INP_ERR
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
else|else
name|cmap
operator|=
literal|0
expr_stmt|;
comment|/* Delete the mapped characters from the queue. */
name|QREM_HEAD
argument_list|(
name|tty
argument_list|,
name|qp
operator|->
name|ilen
argument_list|)
expr_stmt|;
comment|/* If keys mapped to nothing, go get more. */
if|if
condition|(
name|qp
operator|->
name|output
operator|==
name|NULL
condition|)
goto|goto
name|loop
goto|;
comment|/* If remapping characters, push the character on the queue. */
if|if
condition|(
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_REMAP
argument_list|)
condition|)
block|{
if|if
condition|(
name|term_push
argument_list|(
name|sp
argument_list|,
name|qp
operator|->
name|output
argument_list|,
name|qp
operator|->
name|olen
argument_list|,
operator|++
name|cmap
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|rval
operator|=
name|INP_ERR
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
goto|goto
name|newmap
goto|;
block|}
comment|/* Else, push the characters on the queue and return one. */
if|if
condition|(
name|term_push
argument_list|(
name|sp
argument_list|,
name|qp
operator|->
name|output
argument_list|,
name|qp
operator|->
name|olen
argument_list|,
literal|0
argument_list|,
name|CH_NOMAP
argument_list|)
condition|)
block|{
name|rval
operator|=
name|INP_ERR
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
block|}
name|nomap
label|:
name|ch
operator|=
name|tty
operator|->
name|ch
index|[
name|tty
operator|->
name|next
index|]
expr_stmt|;
if|if
condition|(
name|LF_ISSET
argument_list|(
name|TXT_MAPNODIGIT
argument_list|)
operator|&&
operator|!
name|isdigit
argument_list|(
name|ch
argument_list|)
condition|)
block|{
name|not_digit_ch
label|:
name|chp
operator|->
name|ch
operator|=
name|NOT_DIGIT_CH
expr_stmt|;
name|chp
operator|->
name|value
operator|=
literal|0
expr_stmt|;
name|chp
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|rval
operator|=
name|INP_OK
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
comment|/* Fill in the return information. */
name|chp
operator|->
name|ch
operator|=
name|ch
expr_stmt|;
name|chp
operator|->
name|flags
operator|=
name|tty
operator|->
name|chf
index|[
name|tty
operator|->
name|next
index|]
expr_stmt|;
name|chp
operator|->
name|value
operator|=
name|term_key_val
argument_list|(
name|sp
argument_list|,
name|ch
argument_list|)
expr_stmt|;
comment|/* Delete the character from the queue. */
name|QREM_HEAD
argument_list|(
name|tty
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|rval
operator|=
name|INP_OK
expr_stmt|;
name|ret
label|:
if|if
condition|(
name|itear
condition|)
name|intr_end
argument_list|(
name|sp
argument_list|)
expr_stmt|;
return|return
operator|(
name|rval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * term_ab_flush --  *	Flush any abbreviated keys.  */
end_comment

begin_function
name|void
name|term_ab_flush
parameter_list|(
name|sp
parameter_list|,
name|msg
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|char
modifier|*
name|msg
decl_stmt|;
block|{
name|IBUF
modifier|*
name|tty
decl_stmt|;
name|tty
operator|=
name|sp
operator|->
name|gp
operator|->
name|tty
expr_stmt|;
if|if
condition|(
operator|!
name|tty
operator|->
name|cnt
operator|||
operator|!
operator|(
name|tty
operator|->
name|chf
index|[
name|tty
operator|->
name|next
index|]
operator|&
name|CH_ABBREVIATED
operator|)
condition|)
return|return;
do|do
block|{
name|QREM_HEAD
argument_list|(
name|tty
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|tty
operator|->
name|cnt
operator|&&
name|tty
operator|->
name|chf
index|[
name|tty
operator|->
name|next
index|]
operator|&
name|CH_ABBREVIATED
condition|)
do|;
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"%s: keys flushed."
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * term_map_flush --  *	Flush any mapped keys.  */
end_comment

begin_function
name|void
name|term_map_flush
parameter_list|(
name|sp
parameter_list|,
name|msg
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|char
modifier|*
name|msg
decl_stmt|;
block|{
name|IBUF
modifier|*
name|tty
decl_stmt|;
name|tty
operator|=
name|sp
operator|->
name|gp
operator|->
name|tty
expr_stmt|;
if|if
condition|(
operator|!
name|tty
operator|->
name|cnt
operator|||
operator|!
name|tty
operator|->
name|cmap
index|[
name|tty
operator|->
name|next
index|]
condition|)
return|return;
do|do
block|{
name|QREM_HEAD
argument_list|(
name|tty
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|tty
operator|->
name|cnt
operator|&&
name|tty
operator|->
name|cmap
index|[
name|tty
operator|->
name|next
index|]
condition|)
do|;
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"%s: keys flushed."
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * term_user_key --  *	Get the next key, but require the user enter one.  */
end_comment

begin_function
name|enum
name|input
name|term_user_key
parameter_list|(
name|sp
parameter_list|,
name|chp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|CH
modifier|*
name|chp
decl_stmt|;
block|{
name|enum
name|input
name|rval
decl_stmt|;
name|IBUF
modifier|*
name|tty
decl_stmt|;
name|int
name|nr
decl_stmt|;
comment|/* 	 * Read any keys the user has waiting.  Make the race 	 * condition as short as possible. 	 */
if|if
condition|(
name|rval
operator|=
name|term_key_queue
argument_list|(
name|sp
argument_list|)
condition|)
return|return
operator|(
name|rval
operator|)
return|;
comment|/* Wait and read another key. */
if|if
condition|(
name|rval
operator|=
name|sp
operator|->
name|s_key_read
argument_list|(
name|sp
argument_list|,
operator|&
name|nr
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
operator|(
name|rval
operator|)
return|;
comment|/* Fill in the return information. */
name|tty
operator|=
name|sp
operator|->
name|gp
operator|->
name|tty
expr_stmt|;
name|chp
operator|->
name|ch
operator|=
name|tty
operator|->
name|ch
index|[
name|tty
operator|->
name|next
operator|+
operator|(
name|tty
operator|->
name|cnt
operator|-
literal|1
operator|)
index|]
expr_stmt|;
name|chp
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|chp
operator|->
name|value
operator|=
name|term_key_val
argument_list|(
name|sp
argument_list|,
name|chp
operator|->
name|ch
argument_list|)
expr_stmt|;
name|QREM_TAIL
argument_list|(
name|tty
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|INP_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * term_key_queue --  *	Read the keys off of the terminal queue until it's empty.  */
end_comment

begin_function
name|int
name|term_key_queue
parameter_list|(
name|sp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
block|{
name|enum
name|input
name|rval
decl_stmt|;
name|struct
name|timeval
name|t
decl_stmt|;
name|IBUF
modifier|*
name|tty
decl_stmt|;
name|int
name|nr
decl_stmt|;
name|t
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|t
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|tty
operator|=
name|sp
operator|->
name|gp
operator|->
name|tty
init|;
condition|;
control|)
block|{
if|if
condition|(
name|term_read_grow
argument_list|(
name|sp
argument_list|,
name|tty
argument_list|)
condition|)
return|return
operator|(
name|INP_ERR
operator|)
return|;
if|if
condition|(
name|rval
operator|=
name|sp
operator|->
name|s_key_read
argument_list|(
name|sp
argument_list|,
operator|&
name|nr
argument_list|,
operator|&
name|t
argument_list|)
condition|)
return|return
operator|(
name|rval
operator|)
return|;
if|if
condition|(
name|nr
operator|==
literal|0
condition|)
break|break;
block|}
return|return
operator|(
name|INP_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * __term_key_val --  *	Fill in the value for a key.  This routine is the backup  *	for the term_key_val() macro.  */
end_comment

begin_function
name|int
name|__term_key_val
parameter_list|(
name|sp
parameter_list|,
name|ch
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|ARG_CHAR_T
name|ch
decl_stmt|;
block|{
name|KEYLIST
name|k
decl_stmt|,
modifier|*
name|kp
decl_stmt|;
name|k
operator|.
name|ch
operator|=
name|ch
expr_stmt|;
name|kp
operator|=
name|bsearch
argument_list|(
operator|&
name|k
argument_list|,
name|keylist
argument_list|,
name|nkeylist
argument_list|,
sizeof|sizeof
argument_list|(
name|keylist
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|keycmp
argument_list|)
expr_stmt|;
return|return
operator|(
name|kp
operator|==
name|NULL
condition|?
name|K_NOTUSED
else|:
name|kp
operator|->
name|value
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * __term_read_grow --  *	Grow the terminal queue.  This routine is the backup for  *	the term_read_grow() macro.  */
end_comment

begin_function
specifier|static
name|int
name|__term_read_grow
parameter_list|(
name|sp
parameter_list|,
name|tty
parameter_list|,
name|add
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|IBUF
modifier|*
name|tty
decl_stmt|;
name|int
name|add
decl_stmt|;
block|{
name|size_t
name|new_nelem
decl_stmt|,
name|olen
decl_stmt|;
name|new_nelem
operator|=
name|tty
operator|->
name|nelem
operator|+
name|add
expr_stmt|;
name|olen
operator|=
name|tty
operator|->
name|nelem
operator|*
sizeof|sizeof
argument_list|(
name|tty
operator|->
name|ch
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|BINC_RET
argument_list|(
name|sp
argument_list|,
name|tty
operator|->
name|ch
argument_list|,
name|olen
argument_list|,
name|new_nelem
operator|*
sizeof|sizeof
argument_list|(
name|tty
operator|->
name|ch
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|olen
operator|=
name|tty
operator|->
name|nelem
operator|*
sizeof|sizeof
argument_list|(
name|tty
operator|->
name|chf
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|BINC_RET
argument_list|(
name|sp
argument_list|,
name|tty
operator|->
name|chf
argument_list|,
name|olen
argument_list|,
name|new_nelem
operator|*
sizeof|sizeof
argument_list|(
name|tty
operator|->
name|chf
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|olen
operator|=
name|tty
operator|->
name|nelem
operator|*
sizeof|sizeof
argument_list|(
name|tty
operator|->
name|cmap
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|BINC_RET
argument_list|(
name|sp
argument_list|,
name|tty
operator|->
name|cmap
argument_list|,
name|olen
argument_list|,
name|new_nelem
operator|*
sizeof|sizeof
argument_list|(
name|tty
operator|->
name|cmap
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|tty
operator|->
name|nelem
operator|=
name|new_nelem
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|keycmp
parameter_list|(
name|ap
parameter_list|,
name|bp
parameter_list|)
specifier|const
name|void
modifier|*
name|ap
decl_stmt|,
decl|*
name|bp
decl_stmt|;
end_function

begin_block
block|{
return|return
operator|(
operator|(
operator|(
name|KEYLIST
operator|*
operator|)
name|ap
operator|)
operator|->
name|ch
operator|-
operator|(
operator|(
name|KEYLIST
operator|*
operator|)
name|bp
operator|)
operator|->
name|ch
operator|)
return|;
block|}
end_block

end_unit

