begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1993  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)svi_smap.c	8.29 (Berkeley) 11/30/93"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<curses.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"vi.h"
end_include

begin_include
include|#
directive|include
file|"vcmd.h"
end_include

begin_include
include|#
directive|include
file|"svi_screen.h"
end_include

begin_decl_stmt
specifier|static
name|int
name|svi_deleteln
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|svi_insertln
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|svi_sm_delete
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|EXF
operator|*
operator|,
name|recno_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|svi_sm_insert
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|EXF
operator|*
operator|,
name|recno_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|svi_sm_reset
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|EXF
operator|*
operator|,
name|recno_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * svi_change --  *	Make a change to the screen.  */
end_comment

begin_function
name|int
name|svi_change
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|,
name|lno
parameter_list|,
name|op
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
name|recno_t
name|lno
decl_stmt|;
name|enum
name|operation
name|op
decl_stmt|;
block|{
name|SMAP
modifier|*
name|p
decl_stmt|;
name|size_t
name|oldy
decl_stmt|,
name|oldx
decl_stmt|;
comment|/* Appending is the same as inserting, if the line is incremented. */
if|if
condition|(
name|op
operator|==
name|LINE_APPEND
condition|)
block|{
operator|++
name|lno
expr_stmt|;
name|op
operator|=
name|LINE_INSERT
expr_stmt|;
block|}
comment|/* Ignore the change if the line is after the map. */
if|if
condition|(
name|lno
operator|>
name|TMAP
operator|->
name|lno
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * If the line is before the map, and it's a decrement, decrement 	 * the map.  If it's an increment, increment the map.  Otherwise, 	 * ignore it. 	 */
if|if
condition|(
name|lno
operator|<
name|HMAP
operator|->
name|lno
condition|)
block|{
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|LINE_APPEND
case|:
name|abort
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
case|case
name|LINE_DELETE
case|:
for|for
control|(
name|p
operator|=
name|HMAP
init|;
name|p
operator|<=
name|TMAP
condition|;
operator|++
name|p
control|)
operator|--
name|p
operator|->
name|lno
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|lno
operator|>=
name|lno
condition|)
operator|--
name|sp
operator|->
name|lno
expr_stmt|;
name|F_SET
argument_list|(
name|sp
argument_list|,
name|S_RENUMBER
argument_list|)
expr_stmt|;
break|break;
case|case
name|LINE_INSERT
case|:
for|for
control|(
name|p
operator|=
name|HMAP
init|;
name|p
operator|<=
name|TMAP
condition|;
operator|++
name|p
control|)
operator|++
name|p
operator|->
name|lno
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|lno
operator|>=
name|lno
condition|)
operator|++
name|sp
operator|->
name|lno
expr_stmt|;
name|F_SET
argument_list|(
name|sp
argument_list|,
name|S_RENUMBER
argument_list|)
expr_stmt|;
break|break;
case|case
name|LINE_RESET
case|:
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|F_SET
argument_list|(
name|SVP
argument_list|(
name|sp
argument_list|)
argument_list|,
name|SVI_SCREENDIRTY
argument_list|)
expr_stmt|;
comment|/* Flush cached information from svi_screens(). */
name|SVP
argument_list|(
name|sp
argument_list|)
operator|->
name|ss_lno
operator|=
name|OOBLNO
expr_stmt|;
comment|/* Invalidate the cursor, if it's on this line. */
if|if
condition|(
name|sp
operator|->
name|lno
operator|==
name|lno
condition|)
name|F_SET
argument_list|(
name|SVP
argument_list|(
name|sp
argument_list|)
argument_list|,
name|SVI_CUR_INVALID
argument_list|)
expr_stmt|;
name|getyx
argument_list|(
name|stdscr
argument_list|,
name|oldy
argument_list|,
name|oldx
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|LINE_DELETE
case|:
if|if
condition|(
name|svi_sm_delete
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|lno
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|F_SET
argument_list|(
name|sp
argument_list|,
name|S_RENUMBER
argument_list|)
expr_stmt|;
break|break;
case|case
name|LINE_INSERT
case|:
if|if
condition|(
name|svi_sm_insert
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|lno
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|F_SET
argument_list|(
name|sp
argument_list|,
name|S_RENUMBER
argument_list|)
expr_stmt|;
break|break;
case|case
name|LINE_RESET
case|:
if|if
condition|(
name|svi_sm_reset
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|lno
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|MOVEA
argument_list|(
name|sp
argument_list|,
name|oldy
argument_list|,
name|oldx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * svi_sm_fill --  *	Fill in the screen map, placing the specified line at the  *	right position.  There isn't any way to tell if an SMAP  *	entry has been filled in, so this routine had better be  *	called with P_FILL set before anything else is done.  *  * !!!  * Unexported interface: if lno is OOBLNO, P_TOP means that the HMAP  * slot is already filled in, P_BOTTOM means that the TMAP slot is  * already filled in, and we just finish up the job.  */
end_comment

begin_function
name|int
name|svi_sm_fill
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|,
name|lno
parameter_list|,
name|pos
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
name|recno_t
name|lno
decl_stmt|;
name|enum
name|position
name|pos
decl_stmt|;
block|{
name|SMAP
modifier|*
name|p
decl_stmt|,
name|tmp
decl_stmt|;
comment|/* Flush all cached information from the SMAP. */
for|for
control|(
name|p
operator|=
name|HMAP
init|;
name|p
operator|<=
name|TMAP
condition|;
operator|++
name|p
control|)
name|SMAP_FLUSH
argument_list|(
name|p
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pos
condition|)
block|{
case|case
name|P_FILL
case|:
name|tmp
operator|.
name|lno
operator|=
literal|1
expr_stmt|;
name|tmp
operator|.
name|off
operator|=
literal|1
expr_stmt|;
comment|/* See if less than half a screen from the top. */
if|if
condition|(
name|svi_sm_nlines
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|tmp
argument_list|,
name|lno
argument_list|,
name|HALFTEXT
argument_list|(
name|sp
argument_list|)
argument_list|)
operator|<=
name|HALFTEXT
argument_list|(
name|sp
argument_list|)
condition|)
block|{
name|lno
operator|=
literal|1
expr_stmt|;
goto|goto
name|top
goto|;
block|}
comment|/* See if less than half a screen from the bottom. */
if|if
condition|(
name|file_lline
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|tmp
operator|.
name|lno
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|tmp
operator|.
name|off
operator|=
name|svi_screens
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|tmp
operator|.
name|lno
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|svi_sm_nlines
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|tmp
argument_list|,
name|lno
argument_list|,
name|HALFTEXT
argument_list|(
name|sp
argument_list|)
argument_list|)
operator|<=
name|HALFTEXT
argument_list|(
name|sp
argument_list|)
condition|)
block|{
name|TMAP
operator|->
name|lno
operator|=
name|tmp
operator|.
name|lno
expr_stmt|;
name|TMAP
operator|->
name|off
operator|=
name|tmp
operator|.
name|off
expr_stmt|;
goto|goto
name|bottom
goto|;
block|}
goto|goto
name|middle
goto|;
case|case
name|P_TOP
case|:
if|if
condition|(
name|lno
operator|!=
name|OOBLNO
condition|)
block|{
name|top
label|:
name|HMAP
operator|->
name|lno
operator|=
name|lno
expr_stmt|;
name|HMAP
operator|->
name|off
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If we fail, just punt. */
for|for
control|(
name|p
operator|=
name|HMAP
init|;
name|p
operator|<
name|TMAP
condition|;
operator|++
name|p
control|)
if|if
condition|(
name|svi_sm_next
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|p
argument_list|,
name|p
operator|+
literal|1
argument_list|)
condition|)
goto|goto
name|err
goto|;
break|break;
case|case
name|P_MIDDLE
case|:
comment|/* If we fail, guess that the file is too small. */
name|middle
label|:
name|p
operator|=
name|HMAP
operator|+
operator|(
name|TMAP
operator|-
name|HMAP
operator|)
operator|/
literal|2
expr_stmt|;
for|for
control|(
name|p
operator|->
name|lno
operator|=
name|lno
operator|,
name|p
operator|->
name|off
operator|=
literal|1
init|;
name|p
operator|>
name|HMAP
condition|;
operator|--
name|p
control|)
if|if
condition|(
name|svi_sm_prev
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|p
argument_list|,
name|p
operator|-
literal|1
argument_list|)
condition|)
block|{
name|lno
operator|=
literal|1
expr_stmt|;
goto|goto
name|top
goto|;
block|}
comment|/* If we fail, just punt. */
name|p
operator|=
name|HMAP
operator|+
operator|(
name|TMAP
operator|-
name|HMAP
operator|)
operator|/
literal|2
expr_stmt|;
for|for
control|(
init|;
name|p
operator|<
name|TMAP
condition|;
operator|++
name|p
control|)
if|if
condition|(
name|svi_sm_next
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|p
argument_list|,
name|p
operator|+
literal|1
argument_list|)
condition|)
goto|goto
name|err
goto|;
break|break;
case|case
name|P_BOTTOM
case|:
if|if
condition|(
name|lno
operator|!=
name|OOBLNO
condition|)
block|{
name|TMAP
operator|->
name|lno
operator|=
name|lno
expr_stmt|;
name|TMAP
operator|->
name|off
operator|=
name|svi_screens
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|lno
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* If we fail, guess that the file is too small. */
name|bottom
label|:
for|for
control|(
name|p
operator|=
name|TMAP
init|;
name|p
operator|>
name|HMAP
condition|;
operator|--
name|p
control|)
if|if
condition|(
name|svi_sm_prev
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|p
argument_list|,
name|p
operator|-
literal|1
argument_list|)
condition|)
block|{
name|lno
operator|=
literal|1
expr_stmt|;
goto|goto
name|top
goto|;
block|}
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Try and put *something* on the screen.  If this fails, 	 * we have a serious hard error. 	 */
name|err
label|:
name|HMAP
operator|->
name|lno
operator|=
literal|1
expr_stmt|;
name|HMAP
operator|->
name|off
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|p
operator|=
name|HMAP
init|;
name|p
operator|<
name|TMAP
condition|;
operator|++
name|p
control|)
if|if
condition|(
name|svi_sm_next
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|p
argument_list|,
name|p
operator|+
literal|1
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * For the routines svi_sm_reset, svi_sm_delete and svi_sm_insert: if the  * screen only contains one line, or, if the line is the entire screen, this  * gets fairly exciting.  Skip the fun and simply return if there's only one  * line in the screen, or just call fill.  Fill may not be entirely accurate,  * i.e. we may be painting the screen with something not even close to the  * cursor, but it's not like we're into serious performance issues here, and  * the refresh routine will fix it for us.  */
end_comment

begin_define
define|#
directive|define
name|TOO_WEIRD
value|{							\ 	if (cnt_orig>= sp->t_rows) {					\ 		if (cnt_orig == 1)					\ 			return (0);					\ 		if (file_gline(sp, ep, lno, NULL) == NULL)		\ 			if (file_lline(sp, ep,&lno))			\ 				return (1);				\ 		F_SET(sp, S_REDRAW);					\ 		return (svi_sm_fill(sp, ep, lno, P_TOP));		\ 	}								\ }
end_define

begin_comment
comment|/*  * svi_sm_delete --  *	Delete a line out of the SMAP.  */
end_comment

begin_function
specifier|static
name|int
name|svi_sm_delete
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|,
name|lno
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
name|recno_t
name|lno
decl_stmt|;
block|{
name|SMAP
modifier|*
name|p
decl_stmt|,
modifier|*
name|t
decl_stmt|;
name|size_t
name|cnt_orig
decl_stmt|;
comment|/* 	 * Find the line in the map, and count the number of screen lines 	 * which display any part of the deleted line. 	 */
for|for
control|(
name|p
operator|=
name|HMAP
init|;
name|p
operator|->
name|lno
operator|!=
name|lno
condition|;
operator|++
name|p
control|)
empty_stmt|;
for|for
control|(
name|cnt_orig
operator|=
literal|1
operator|,
name|t
operator|=
name|p
operator|+
literal|1
init|;
name|t
operator|<=
name|TMAP
operator|&&
name|t
operator|->
name|lno
operator|==
name|lno
condition|;
operator|++
name|cnt_orig
operator|,
operator|++
name|t
control|)
empty_stmt|;
name|TOO_WEIRD
expr_stmt|;
comment|/* Delete that many lines from the screen. */
name|MOVE
argument_list|(
name|sp
argument_list|,
name|p
operator|-
name|HMAP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|svi_deleteln
argument_list|(
name|sp
argument_list|,
name|cnt_orig
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Shift the screen map up. */
name|memmove
argument_list|(
name|p
argument_list|,
name|p
operator|+
name|cnt_orig
argument_list|,
operator|(
operator|(
operator|(
name|TMAP
operator|-
name|p
operator|)
operator|-
name|cnt_orig
operator|)
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|SMAP
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Decrement the line numbers for the rest of the map. */
for|for
control|(
name|t
operator|=
name|TMAP
operator|-
name|cnt_orig
init|;
name|p
operator|<=
name|t
condition|;
operator|++
name|p
control|)
operator|--
name|p
operator|->
name|lno
expr_stmt|;
comment|/* Display the new lines. */
for|for
control|(
name|p
operator|=
name|TMAP
operator|-
name|cnt_orig
init|;
condition|;
control|)
block|{
if|if
condition|(
name|p
operator|<
name|TMAP
operator|&&
name|svi_sm_next
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|p
argument_list|,
name|p
operator|+
literal|1
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* svi_sm_next() flushed the cache. */
if|if
condition|(
name|svi_line
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|++
name|p
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|p
operator|==
name|TMAP
condition|)
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * svi_sm_insert --  *	Insert a line into the SMAP.  */
end_comment

begin_function
specifier|static
name|int
name|svi_sm_insert
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|,
name|lno
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
name|recno_t
name|lno
decl_stmt|;
block|{
name|SMAP
modifier|*
name|p
decl_stmt|,
modifier|*
name|t
decl_stmt|;
name|size_t
name|cnt_orig
decl_stmt|,
name|cnt
decl_stmt|;
comment|/* 	 * Find the line in the map, find out how many screen lines 	 * needed to display the line. 	 */
for|for
control|(
name|p
operator|=
name|HMAP
init|;
name|p
operator|->
name|lno
operator|!=
name|lno
condition|;
operator|++
name|p
control|)
empty_stmt|;
name|cnt_orig
operator|=
name|svi_screens
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|lno
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|TOO_WEIRD
expr_stmt|;
comment|/* 	 * The lines left in the screen override the number of screen 	 * lines in the inserted line. 	 */
name|cnt
operator|=
operator|(
name|TMAP
operator|-
name|p
operator|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|cnt_orig
operator|>
name|cnt
condition|)
name|cnt_orig
operator|=
name|cnt
expr_stmt|;
comment|/* Push down that many lines. */
name|MOVE
argument_list|(
name|sp
argument_list|,
name|p
operator|-
name|HMAP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|svi_insertln
argument_list|(
name|sp
argument_list|,
name|cnt_orig
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Shift the screen map down. */
name|memmove
argument_list|(
name|p
operator|+
name|cnt_orig
argument_list|,
name|p
argument_list|,
operator|(
operator|(
operator|(
name|TMAP
operator|-
name|p
operator|)
operator|-
name|cnt_orig
operator|)
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|SMAP
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Increment the line numbers for the rest of the map. */
for|for
control|(
name|t
operator|=
name|p
operator|+
name|cnt_orig
init|;
name|t
operator|<=
name|TMAP
condition|;
operator|++
name|t
control|)
operator|++
name|t
operator|->
name|lno
expr_stmt|;
comment|/* Fill in the SMAP for the new lines, and display. */
for|for
control|(
name|cnt
operator|=
literal|1
operator|,
name|t
operator|=
name|p
init|;
name|cnt
operator|<=
name|cnt_orig
condition|;
operator|++
name|t
operator|,
operator|++
name|cnt
control|)
block|{
name|t
operator|->
name|lno
operator|=
name|lno
expr_stmt|;
name|t
operator|->
name|off
operator|=
name|cnt
expr_stmt|;
name|SMAP_FLUSH
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|svi_line
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|t
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * svi_sm_reset --  *	Reset a line in the SMAP.  */
end_comment

begin_function
specifier|static
name|int
name|svi_sm_reset
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|,
name|lno
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
name|recno_t
name|lno
decl_stmt|;
block|{
name|SMAP
modifier|*
name|p
decl_stmt|,
modifier|*
name|t
decl_stmt|;
name|size_t
name|cnt_orig
decl_stmt|,
name|cnt_new
decl_stmt|,
name|cnt
decl_stmt|,
name|diff
decl_stmt|;
comment|/* 	 * See if the number of on-screen rows taken up by the old display 	 * for the line is the same as the number needed for the new one. 	 * If so, repaint, otherwise do it the hard way. 	 */
for|for
control|(
name|p
operator|=
name|HMAP
init|;
name|p
operator|->
name|lno
operator|!=
name|lno
condition|;
operator|++
name|p
control|)
empty_stmt|;
for|for
control|(
name|cnt_orig
operator|=
literal|0
operator|,
name|t
operator|=
name|p
init|;
name|t
operator|<=
name|TMAP
operator|&&
name|t
operator|->
name|lno
operator|==
name|lno
condition|;
operator|++
name|cnt_orig
operator|,
operator|++
name|t
control|)
empty_stmt|;
name|cnt_new
operator|=
name|svi_screens
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|lno
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|TOO_WEIRD
expr_stmt|;
if|if
condition|(
name|cnt_orig
operator|==
name|cnt_new
condition|)
block|{
do|do
block|{
name|SMAP_FLUSH
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|svi_line
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|p
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
do|while
condition|(
operator|++
name|p
operator|<
name|t
condition|)
do|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|cnt_orig
operator|<
name|cnt_new
condition|)
block|{
comment|/* Get the difference. */
name|diff
operator|=
name|cnt_new
operator|-
name|cnt_orig
expr_stmt|;
comment|/* 		 * The lines left in the screen override the number of screen 		 * lines in the inserted line. 		 */
name|cnt
operator|=
operator|(
name|TMAP
operator|-
name|p
operator|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|diff
operator|>
name|cnt
condition|)
name|diff
operator|=
name|cnt
expr_stmt|;
comment|/* Push down the extra lines. */
name|MOVE
argument_list|(
name|sp
argument_list|,
name|p
operator|-
name|HMAP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|svi_insertln
argument_list|(
name|sp
argument_list|,
name|diff
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Shift the screen map down. */
name|memmove
argument_list|(
name|p
operator|+
name|diff
argument_list|,
name|p
argument_list|,
operator|(
operator|(
operator|(
name|TMAP
operator|-
name|p
operator|)
operator|-
name|diff
operator|)
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|SMAP
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fill in the SMAP for the replaced line, and display. */
for|for
control|(
name|cnt
operator|=
literal|1
operator|,
name|t
operator|=
name|p
init|;
name|cnt_new
operator|--
operator|&&
name|t
operator|<=
name|TMAP
condition|;
operator|++
name|t
operator|,
operator|++
name|cnt
control|)
block|{
name|t
operator|->
name|lno
operator|=
name|lno
expr_stmt|;
name|t
operator|->
name|off
operator|=
name|cnt
expr_stmt|;
name|SMAP_FLUSH
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|svi_line
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|t
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/* Get the difference. */
name|diff
operator|=
name|cnt_orig
operator|-
name|cnt_new
expr_stmt|;
comment|/* Delete that many lines from the screen. */
name|MOVE
argument_list|(
name|sp
argument_list|,
name|p
operator|-
name|HMAP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|svi_deleteln
argument_list|(
name|sp
argument_list|,
name|diff
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Shift the screen map up. */
name|memmove
argument_list|(
name|p
argument_list|,
name|p
operator|+
name|diff
argument_list|,
operator|(
operator|(
operator|(
name|TMAP
operator|-
name|p
operator|)
operator|-
name|diff
operator|)
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|SMAP
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fill in the SMAP for the replaced line, and display. */
for|for
control|(
name|cnt
operator|=
literal|1
operator|,
name|t
operator|=
name|p
init|;
name|cnt_new
operator|--
condition|;
operator|++
name|t
operator|,
operator|++
name|cnt
control|)
block|{
name|t
operator|->
name|lno
operator|=
name|lno
expr_stmt|;
name|t
operator|->
name|off
operator|=
name|cnt
expr_stmt|;
name|SMAP_FLUSH
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|svi_line
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|t
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* Display the new lines at the bottom of the screen. */
for|for
control|(
name|t
operator|=
name|TMAP
operator|-
name|diff
init|;
condition|;
control|)
block|{
if|if
condition|(
name|t
operator|<
name|TMAP
operator|&&
name|svi_sm_next
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|t
argument_list|,
name|t
operator|+
literal|1
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* svi_sm_next() flushed the cache. */
if|if
condition|(
name|svi_line
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|++
name|t
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|t
operator|==
name|TMAP
condition|)
break|break;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * svi_sm_up --  *	Scroll the SMAP up count logical lines.  */
end_comment

begin_function
name|int
name|svi_sm_up
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|,
name|rp
parameter_list|,
name|count
parameter_list|,
name|cursor_move
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
name|MARK
modifier|*
name|rp
decl_stmt|;
name|recno_t
name|count
decl_stmt|;
name|int
name|cursor_move
decl_stmt|;
block|{
name|SMAP
modifier|*
name|p
decl_stmt|,
name|svmap
decl_stmt|,
name|tmp
decl_stmt|;
name|int
name|ignore_cursor
decl_stmt|;
comment|/* Set the default return position. */
name|rp
operator|->
name|lno
operator|=
name|sp
operator|->
name|lno
expr_stmt|;
name|rp
operator|->
name|cno
operator|=
name|sp
operator|->
name|cno
expr_stmt|;
comment|/* 	 * Invalidate the cursor.  The line is probably going to change, 	 * but if cursor_move isn't set it may not.  In any case, this 	 * routine moves the cursor to draw things. 	 */
name|F_SET
argument_list|(
name|SVP
argument_list|(
name|sp
argument_list|)
argument_list|,
name|SVI_CUR_INVALID
argument_list|)
expr_stmt|;
comment|/* 	 * There are two forms of this command, one where the cursor tries to 	 * follow the line, and one where it doesn't.  In the latter, we try 	 * and keep the cursor at the same position on the screen, but, if the 	 * screen is small enough and the line length large enough, the cursor 	 * can end up in very strange places.  Probably not worth fixing. 	 * 	 * Find the line in the SMAP -- ignore the cursor if it wasn't on the 	 * screen. 	 */
if|if
condition|(
name|svi_sm_cursor
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|p
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|ignore_cursor
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|svmap
operator|=
operator|*
name|p
expr_stmt|;
name|ignore_cursor
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Check to see if movement is possible.  Lots of checks... 	 * 	 * Find out if it's possible to move past the end of the map.  If 	 * that's okay because we think that we can move the cursor down 	 * in the map, check to make sure that the map isn't mostly empty. 	 */
if|if
condition|(
name|svi_sm_next
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|TMAP
argument_list|,
operator|&
name|tmp
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|tmp
operator|.
name|lno
operator|>
name|TMAP
operator|->
name|lno
operator|&&
operator|!
name|file_gline
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|tmp
operator|.
name|lno
argument_list|,
name|NULL
argument_list|)
operator|||
name|tmp
operator|.
name|off
operator|>
name|svi_screens
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|tmp
operator|.
name|lno
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|cursor_move
operator|||
name|ignore_cursor
operator|||
name|p
operator|==
name|TMAP
condition|)
block|{
name|v_eof
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|svi_sm_next
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|p
argument_list|,
operator|&
name|tmp
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
operator|!
name|file_gline
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|tmp
operator|.
name|lno
argument_list|,
name|NULL
argument_list|)
operator|||
name|tmp
operator|.
name|off
operator|>
name|svi_screens
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|tmp
operator|.
name|lno
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|v_eof
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
comment|/* 	 * Small screens: see svi/svi_refresh.c:svi_refresh, section 3b. 	 * 	 * If it's a small screen, and the movement is small, open up the 	 * screen.  Otherwise, compress and repaint.  If we compress, we 	 * ignore the cursor, the movement is too large to care. 	 */
if|if
condition|(
name|ISSMALLSCREEN
argument_list|(
name|sp
argument_list|)
condition|)
if|if
condition|(
name|count
operator|<=
name|HALFTEXT
argument_list|(
name|sp
argument_list|)
condition|)
block|{
for|for
control|(
init|;
name|count
operator|&&
name|sp
operator|->
name|t_rows
operator|!=
name|sp
operator|->
name|t_maxrows
condition|;
operator|--
name|count
operator|,
operator|++
name|sp
operator|->
name|t_rows
control|)
block|{
if|if
condition|(
name|svi_sm_next
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|TMAP
argument_list|,
operator|&
name|tmp
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|TMAP
operator|->
name|lno
operator|!=
name|tmp
operator|.
name|lno
operator|&&
operator|!
name|file_gline
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|tmp
operator|.
name|lno
argument_list|,
name|NULL
argument_list|)
condition|)
break|break;
operator|*
operator|++
name|TMAP
operator|=
name|tmp
expr_stmt|;
comment|/* svi_sm_next() flushed the cache. */
if|if
condition|(
name|svi_line
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|TMAP
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|count
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
name|MOVE
argument_list|(
name|sp
argument_list|,
name|INFOLINE
argument_list|(
name|sp
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|clrtoeol
argument_list|()
expr_stmt|;
for|for
control|(
init|;
name|sp
operator|->
name|t_rows
operator|>
name|sp
operator|->
name|t_minrows
condition|;
operator|--
name|sp
operator|->
name|t_rows
operator|,
operator|--
name|TMAP
control|)
block|{
name|MOVE
argument_list|(
name|sp
argument_list|,
name|TMAP
operator|-
name|HMAP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|clrtoeol
argument_list|()
expr_stmt|;
block|}
name|ignore_cursor
operator|=
literal|1
expr_stmt|;
block|}
for|for
control|(
init|;
name|count
condition|;
operator|--
name|count
control|)
block|{
comment|/* Decide what would show up on the screen. */
if|if
condition|(
name|svi_sm_next
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|TMAP
argument_list|,
operator|&
name|tmp
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* If the line doesn't exist, we're done. */
if|if
condition|(
name|TMAP
operator|->
name|lno
operator|!=
name|tmp
operator|.
name|lno
operator|&&
operator|!
name|file_gline
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|tmp
operator|.
name|lno
argument_list|,
name|NULL
argument_list|)
condition|)
break|break;
comment|/* Scroll the screen cursor up one logical line. */
if|if
condition|(
name|svi_sm_1up
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
operator|!
name|cursor_move
operator|&&
operator|!
name|ignore_cursor
operator|&&
name|p
operator|>
name|HMAP
condition|)
operator|--
name|p
expr_stmt|;
block|}
comment|/* If ignoring the cursor, we're done. */
if|if
condition|(
name|ignore_cursor
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|cursor_move
condition|)
block|{
comment|/* 		 * If we didn't move enough, head toward EOF.  Check to make 		 * sure the lines actually, if the file is smaller than the 		 * screen they may not. 		 */
for|for
control|(
init|;
name|count
condition|;
operator|--
name|count
operator|,
operator|++
name|p
control|)
if|if
condition|(
name|p
operator|==
name|TMAP
operator|||
operator|!
name|file_gline
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|p
index|[
literal|1
index|]
operator|.
name|lno
argument_list|,
name|NULL
argument_list|)
condition|)
break|break;
block|}
else|else
block|{
comment|/* 		 * If the line itself moved, invalidate the cursor, because 		 * the comparison with the old line/new line won't be right 		 */
name|F_SET
argument_list|(
name|SVP
argument_list|(
name|sp
argument_list|)
argument_list|,
name|SVI_CUR_INVALID
argument_list|)
expr_stmt|;
comment|/* If didn't move enough, it's an error. */
if|if
condition|(
name|count
condition|)
block|{
name|v_eof
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* If the cursor moved off the screen, move it to the top. */
if|if
condition|(
name|sp
operator|->
name|lno
operator|<
name|HMAP
operator|->
name|lno
condition|)
name|p
operator|=
name|HMAP
expr_stmt|;
block|}
comment|/* 	 * On a logical movement, we try and keep the cursor as close as 	 * possible to the last position, but also set it up so that the 	 * next "real" movement will return the cursor to the closest position 	 * to the last real movement. 	 */
if|if
condition|(
name|p
operator|->
name|lno
operator|!=
name|svmap
operator|.
name|lno
operator|||
name|p
operator|->
name|off
operator|!=
name|svmap
operator|.
name|off
condition|)
block|{
name|rp
operator|->
name|lno
operator|=
name|p
operator|->
name|lno
expr_stmt|;
name|rp
operator|->
name|cno
operator|=
name|svi_lrelative
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|p
operator|->
name|lno
argument_list|,
name|p
operator|->
name|off
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * svi_sm_1up --  *	Scroll the SMAP up one.  */
end_comment

begin_function
name|int
name|svi_sm_1up
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
block|{
comment|/* 	 * Delete the top line of the screen.  Shift the screen map up. 	 * Display a new line at the bottom of the screen. 	 */
name|MOVE
argument_list|(
name|sp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|svi_deleteln
argument_list|(
name|sp
argument_list|,
literal|1
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* One-line screens can fail. */
if|if
condition|(
name|HMAP
operator|==
name|TMAP
condition|)
block|{
if|if
condition|(
name|svi_sm_next
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|TMAP
argument_list|,
name|TMAP
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
name|memmove
argument_list|(
name|HMAP
argument_list|,
name|HMAP
operator|+
literal|1
argument_list|,
operator|(
name|sp
operator|->
name|rows
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|SMAP
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|svi_sm_next
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|TMAP
operator|-
literal|1
argument_list|,
name|TMAP
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* svi_sm_next() flushed the cache. */
if|if
condition|(
name|svi_line
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|TMAP
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * svi_deleteln --  *	Delete a line a la curses, make sure to put the information  *	line and other screens back.  */
end_comment

begin_function
specifier|static
name|int
name|svi_deleteln
parameter_list|(
name|sp
parameter_list|,
name|cnt
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|int
name|cnt
decl_stmt|;
block|{
name|size_t
name|oldy
decl_stmt|,
name|oldx
decl_stmt|;
name|getyx
argument_list|(
name|stdscr
argument_list|,
name|oldy
argument_list|,
name|oldx
argument_list|)
expr_stmt|;
while|while
condition|(
name|cnt
operator|--
condition|)
block|{
name|deleteln
argument_list|()
expr_stmt|;
name|MOVE
argument_list|(
name|sp
argument_list|,
name|INFOLINE
argument_list|(
name|sp
argument_list|)
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|insertln
argument_list|()
expr_stmt|;
name|MOVEA
argument_list|(
name|sp
argument_list|,
name|oldy
argument_list|,
name|oldx
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * svi_sm_down --  *	Scroll the SMAP down count logical lines.  */
end_comment

begin_function
name|int
name|svi_sm_down
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|,
name|rp
parameter_list|,
name|count
parameter_list|,
name|cursor_move
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
name|MARK
modifier|*
name|rp
decl_stmt|;
name|recno_t
name|count
decl_stmt|;
name|int
name|cursor_move
decl_stmt|;
block|{
name|SMAP
modifier|*
name|p
decl_stmt|,
name|svmap
decl_stmt|;
name|int
name|ignore_cursor
decl_stmt|;
comment|/* Set the default return position. */
name|rp
operator|->
name|lno
operator|=
name|sp
operator|->
name|lno
expr_stmt|;
name|rp
operator|->
name|cno
operator|=
name|sp
operator|->
name|cno
expr_stmt|;
comment|/* 	 * Invalidate the cursor.  The line is probably going to change, 	 * but if cursor_move isn't set it may not.  In any case, this 	 * routine moves the cursor to draw things. 	 */
name|F_SET
argument_list|(
name|SVP
argument_list|(
name|sp
argument_list|)
argument_list|,
name|SVI_CUR_INVALID
argument_list|)
expr_stmt|;
comment|/* 	 * There are two forms of this command, one where the cursor tries to 	 * follow the line, and one where it doesn't.  In the latter, we try 	 * and keep the cursor at the same position on the screen, but, if the 	 * screen is small enough and the line length large enough, the cursor 	 * can end up in very strange places.  Probably not worth fixing. 	 * 	 * Find the line in the SMAP -- ignore the cursor if it wasn't on the 	 * screen. 	 */
if|if
condition|(
name|svi_sm_cursor
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|p
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|ignore_cursor
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|svmap
operator|=
operator|*
name|p
expr_stmt|;
name|ignore_cursor
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Check to see if movement is possible. */
if|if
condition|(
name|HMAP
operator|->
name|lno
operator|==
literal|1
operator|&&
name|HMAP
operator|->
name|off
operator|==
literal|1
operator|&&
operator|(
operator|!
name|cursor_move
operator|||
name|ignore_cursor
operator|||
name|p
operator|==
name|HMAP
operator|)
condition|)
block|{
name|v_sof
argument_list|(
name|sp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * Small screens: see svi/svi_refresh.c:svi_refresh, section 3b. 	 * 	 * If it's a small screen, and the movement is small, open up the 	 * screen.  Otherwise, compress and repaint.  If we compress, we 	 * ignore the cursor, the movement is too large to care. 	 */
if|if
condition|(
name|ISSMALLSCREEN
argument_list|(
name|sp
argument_list|)
condition|)
if|if
condition|(
name|count
operator|<=
name|HALFTEXT
argument_list|(
name|sp
argument_list|)
condition|)
block|{
for|for
control|(
init|;
name|count
operator|&&
name|sp
operator|->
name|t_rows
operator|!=
name|sp
operator|->
name|t_maxrows
operator|&&
operator|(
name|HMAP
operator|->
name|lno
operator|>
literal|1
operator|||
name|HMAP
operator|->
name|off
operator|>
literal|1
operator|)
condition|;
operator|--
name|count
operator|,
operator|++
name|sp
operator|->
name|t_rows
control|)
block|{
operator|++
name|TMAP
expr_stmt|;
if|if
condition|(
name|svi_sm_1down
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
operator|!
name|cursor_move
condition|)
operator|++
name|p
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
name|MOVE
argument_list|(
name|sp
argument_list|,
name|INFOLINE
argument_list|(
name|sp
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|clrtoeol
argument_list|()
expr_stmt|;
for|for
control|(
init|;
name|sp
operator|->
name|t_rows
operator|>
name|sp
operator|->
name|t_minrows
condition|;
operator|--
name|sp
operator|->
name|t_rows
operator|,
operator|--
name|TMAP
control|)
block|{
name|MOVE
argument_list|(
name|sp
argument_list|,
name|TMAP
operator|-
name|HMAP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|clrtoeol
argument_list|()
expr_stmt|;
block|}
name|ignore_cursor
operator|=
literal|1
expr_stmt|;
block|}
for|for
control|(
init|;
name|count
condition|;
operator|--
name|count
control|)
block|{
comment|/* If the line doesn't exist, we're done. */
if|if
condition|(
name|HMAP
operator|->
name|lno
operator|==
literal|1
operator|&&
name|HMAP
operator|->
name|off
operator|==
literal|1
condition|)
break|break;
comment|/* Scroll the screen and cursor down one logical line. */
if|if
condition|(
name|svi_sm_1down
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
operator|!
name|cursor_move
operator|&&
operator|!
name|ignore_cursor
operator|&&
name|p
operator|<
name|TMAP
condition|)
operator|++
name|p
expr_stmt|;
block|}
comment|/* If ignoring the cursor, we're done. */
if|if
condition|(
name|ignore_cursor
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|cursor_move
condition|)
block|{
comment|/* If we didn't move enough, move to SOF. */
if|if
condition|(
name|count
condition|)
name|p
operator|=
name|HMAP
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * If the line itself moved, invalidate the cursor, because 		 * the comparison with the old line/new line won't be right. 		 */
name|F_SET
argument_list|(
name|SVP
argument_list|(
name|sp
argument_list|)
argument_list|,
name|SVI_CUR_INVALID
argument_list|)
expr_stmt|;
comment|/* If didn't move enough, it's an error. */
if|if
condition|(
name|count
condition|)
block|{
name|v_sof
argument_list|(
name|sp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* If the cursor moved off the screen, move it to the bottom. */
if|if
condition|(
name|sp
operator|->
name|lno
operator|>
name|TMAP
operator|->
name|lno
condition|)
name|p
operator|=
name|TMAP
expr_stmt|;
block|}
comment|/* 	 * On a logical movement, we try and keep the cursor as close as 	 * possible to the last position, but also set it up so that the 	 * next "real" movement will return the cursor to the closest position 	 * to the last real movement. 	 */
if|if
condition|(
name|p
operator|->
name|lno
operator|!=
name|svmap
operator|.
name|lno
operator|||
name|p
operator|->
name|off
operator|!=
name|svmap
operator|.
name|off
condition|)
block|{
name|rp
operator|->
name|lno
operator|=
name|p
operator|->
name|lno
expr_stmt|;
name|rp
operator|->
name|cno
operator|=
name|svi_lrelative
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|p
operator|->
name|lno
argument_list|,
name|p
operator|->
name|off
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * svi_sm_1down --  *	Scroll the SMAP down one.  */
end_comment

begin_function
name|int
name|svi_sm_1down
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
block|{
comment|/* 	 * Clear the bottom line of the screen, insert a line at the top 	 * of the screen.  Shift the screen map down, display a new line 	 * at the top of the screen. 	 */
name|MOVE
argument_list|(
name|sp
argument_list|,
name|sp
operator|->
name|t_rows
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|clrtoeol
argument_list|()
expr_stmt|;
name|MOVE
argument_list|(
name|sp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|svi_insertln
argument_list|(
name|sp
argument_list|,
literal|1
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|memmove
argument_list|(
name|HMAP
operator|+
literal|1
argument_list|,
name|HMAP
argument_list|,
operator|(
name|sp
operator|->
name|rows
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|SMAP
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|svi_sm_prev
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|HMAP
operator|+
literal|1
argument_list|,
name|HMAP
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* svi_sm_prev() flushed the cache. */
if|if
condition|(
name|svi_line
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|HMAP
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * svi_insertln --  *	Insert a line a la curses, make sure to put the information  *	line and other screens back.  */
end_comment

begin_function
specifier|static
name|int
name|svi_insertln
parameter_list|(
name|sp
parameter_list|,
name|cnt
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|int
name|cnt
decl_stmt|;
block|{
name|size_t
name|oldy
decl_stmt|,
name|oldx
decl_stmt|;
name|getyx
argument_list|(
name|stdscr
argument_list|,
name|oldy
argument_list|,
name|oldx
argument_list|)
expr_stmt|;
while|while
condition|(
name|cnt
operator|--
condition|)
block|{
name|MOVE
argument_list|(
name|sp
argument_list|,
name|INFOLINE
argument_list|(
name|sp
argument_list|)
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|deleteln
argument_list|()
expr_stmt|;
name|MOVEA
argument_list|(
name|sp
argument_list|,
name|oldy
argument_list|,
name|oldx
argument_list|)
expr_stmt|;
name|insertln
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * svi_sm_next --  *	Fill in the next entry in the SMAP.  */
end_comment

begin_function
name|int
name|svi_sm_next
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|,
name|p
parameter_list|,
name|t
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
name|SMAP
modifier|*
name|p
decl_stmt|,
decl|*
name|t
decl_stmt|;
end_function

begin_block
block|{
name|size_t
name|lcnt
decl_stmt|;
name|SMAP_FLUSH
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_LEFTRIGHT
argument_list|)
condition|)
block|{
name|t
operator|->
name|lno
operator|=
name|p
operator|->
name|lno
operator|+
literal|1
expr_stmt|;
name|t
operator|->
name|off
operator|=
name|p
operator|->
name|off
expr_stmt|;
block|}
else|else
block|{
name|lcnt
operator|=
name|svi_screens
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|p
operator|->
name|lno
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|lcnt
operator|==
name|p
operator|->
name|off
condition|)
block|{
name|t
operator|->
name|lno
operator|=
name|p
operator|->
name|lno
operator|+
literal|1
expr_stmt|;
name|t
operator|->
name|off
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|t
operator|->
name|lno
operator|=
name|p
operator|->
name|lno
expr_stmt|;
name|t
operator|->
name|off
operator|=
name|p
operator|->
name|off
operator|+
literal|1
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * svi_sm_prev --  *	Fill in the previous entry in the SMAP.  */
end_comment

begin_function
name|int
name|svi_sm_prev
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|,
name|p
parameter_list|,
name|t
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
name|SMAP
modifier|*
name|p
decl_stmt|,
decl|*
name|t
decl_stmt|;
end_function

begin_block
block|{
name|SMAP_FLUSH
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_LEFTRIGHT
argument_list|)
condition|)
block|{
name|t
operator|->
name|lno
operator|=
name|p
operator|->
name|lno
operator|-
literal|1
expr_stmt|;
name|t
operator|->
name|off
operator|=
name|p
operator|->
name|off
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|off
operator|!=
literal|1
condition|)
block|{
name|t
operator|->
name|lno
operator|=
name|p
operator|->
name|lno
expr_stmt|;
name|t
operator|->
name|off
operator|=
name|p
operator|->
name|off
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|t
operator|->
name|lno
operator|=
name|p
operator|->
name|lno
operator|-
literal|1
expr_stmt|;
name|t
operator|->
name|off
operator|=
name|svi_screens
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|t
operator|->
name|lno
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|t
operator|->
name|lno
operator|==
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * svi_sm_cursor --  *	Return the SMAP entry referenced by the cursor.  */
end_comment

begin_function
name|int
name|svi_sm_cursor
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|,
name|smp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
name|SMAP
modifier|*
modifier|*
name|smp
decl_stmt|;
block|{
name|SMAP
modifier|*
name|p
decl_stmt|;
comment|/* See if the cursor is not in the map. */
if|if
condition|(
name|sp
operator|->
name|lno
operator|<
name|HMAP
operator|->
name|lno
operator|||
name|sp
operator|->
name|lno
operator|>
name|TMAP
operator|->
name|lno
condition|)
block|{
operator|*
name|smp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Find the first occurence of the line. */
for|for
control|(
name|p
operator|=
name|HMAP
init|;
name|p
operator|->
name|lno
operator|!=
name|sp
operator|->
name|lno
condition|;
operator|++
name|p
control|)
empty_stmt|;
comment|/* Fill in the map information until we find the right line. */
for|for
control|(
init|;
name|p
operator|<=
name|TMAP
condition|;
operator|++
name|p
control|)
block|{
comment|/* Short lines are common and easy to detect. */
if|if
condition|(
name|p
operator|!=
name|TMAP
operator|&&
operator|(
name|p
operator|+
literal|1
operator|)
operator|->
name|lno
operator|!=
name|p
operator|->
name|lno
condition|)
block|{
operator|*
name|smp
operator|=
name|p
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|SMAP_CACHE
argument_list|(
name|p
argument_list|)
operator|&&
name|svi_line
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|p
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|p
operator|->
name|c_eboff
operator|>=
name|sp
operator|->
name|cno
condition|)
block|{
operator|*
name|smp
operator|=
name|p
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
comment|/* It was past the end of the map after all. */
operator|*
name|smp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * svi_sm_position --  *	Return the line/column of the top, middle or last line on the screen.  *	(The vi H, M and L commands.)  Here because only the screen routines  *	know what's really out there.  */
end_comment

begin_function
name|int
name|svi_sm_position
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|,
name|rp
parameter_list|,
name|cnt
parameter_list|,
name|pos
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
name|MARK
modifier|*
name|rp
decl_stmt|;
name|u_long
name|cnt
decl_stmt|;
name|enum
name|position
name|pos
decl_stmt|;
block|{
name|SMAP
modifier|*
name|smp
decl_stmt|;
name|recno_t
name|last
decl_stmt|;
switch|switch
condition|(
name|pos
condition|)
block|{
case|case
name|P_TOP
case|:
if|if
condition|(
name|cnt
operator|>
name|TMAP
operator|-
name|HMAP
condition|)
goto|goto
name|err
goto|;
name|smp
operator|=
name|HMAP
operator|+
name|cnt
expr_stmt|;
break|break;
case|case
name|P_MIDDLE
case|:
if|if
condition|(
name|cnt
operator|>
operator|(
name|TMAP
operator|-
name|HMAP
operator|)
operator|/
literal|2
condition|)
goto|goto
name|err
goto|;
name|smp
operator|=
operator|(
name|HMAP
operator|+
operator|(
name|TMAP
operator|-
name|HMAP
operator|)
operator|/
literal|2
operator|)
operator|+
name|cnt
expr_stmt|;
goto|goto
name|eof
goto|;
case|case
name|P_BOTTOM
case|:
if|if
condition|(
name|cnt
operator|>
name|TMAP
operator|-
name|HMAP
condition|)
block|{
name|err
label|:
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_BERR
argument_list|,
literal|"Movement past the end-of-screen."
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|smp
operator|=
name|TMAP
operator|-
name|cnt
expr_stmt|;
name|eof
label|:
if|if
condition|(
name|file_gline
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|smp
operator|->
name|lno
argument_list|,
name|NULL
argument_list|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|file_lline
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|last
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
for|for
control|(
init|;
name|smp
operator|->
name|lno
operator|>
name|last
operator|&&
name|smp
operator|>
name|HMAP
condition|;
operator|--
name|smp
control|)
empty_stmt|;
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|SMAP_CACHE
argument_list|(
name|smp
argument_list|)
operator|&&
name|svi_line
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|smp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|rp
operator|->
name|lno
operator|=
name|smp
operator|->
name|lno
expr_stmt|;
name|rp
operator|->
name|cno
operator|=
name|smp
operator|->
name|c_sboff
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * svi_sm_nlines --  *	Return the number of screen lines from an SMAP entry to the  *	start of some file line, less than a maximum value.  */
end_comment

begin_function
name|recno_t
name|svi_sm_nlines
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|,
name|from_sp
parameter_list|,
name|to_lno
parameter_list|,
name|max
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
name|SMAP
modifier|*
name|from_sp
decl_stmt|;
name|recno_t
name|to_lno
decl_stmt|;
name|size_t
name|max
decl_stmt|;
block|{
name|recno_t
name|lno
decl_stmt|,
name|lcnt
decl_stmt|;
if|if
condition|(
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_LEFTRIGHT
argument_list|)
condition|)
return|return
operator|(
name|from_sp
operator|->
name|lno
operator|>
name|to_lno
condition|?
name|from_sp
operator|->
name|lno
operator|-
name|to_lno
else|:
name|to_lno
operator|-
name|from_sp
operator|->
name|lno
operator|)
return|;
if|if
condition|(
name|from_sp
operator|->
name|lno
operator|==
name|to_lno
condition|)
return|return
operator|(
name|from_sp
operator|->
name|off
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|from_sp
operator|->
name|lno
operator|>
name|to_lno
condition|)
block|{
name|lcnt
operator|=
name|from_sp
operator|->
name|off
operator|-
literal|1
expr_stmt|;
comment|/* Correct for off-by-one. */
for|for
control|(
name|lno
operator|=
name|from_sp
operator|->
name|lno
init|;
operator|--
name|lno
operator|>=
name|to_lno
operator|&&
name|lcnt
operator|<=
name|max
condition|;
control|)
name|lcnt
operator|+=
name|svi_screens
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|lno
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lno
operator|=
name|from_sp
operator|->
name|lno
expr_stmt|;
name|lcnt
operator|=
operator|(
name|svi_screens
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|lno
argument_list|,
name|NULL
argument_list|)
operator|-
name|from_sp
operator|->
name|off
operator|)
operator|+
literal|1
expr_stmt|;
for|for
control|(
init|;
operator|++
name|lno
operator|<
name|to_lno
operator|&&
name|lcnt
operator|<=
name|max
condition|;
control|)
name|lcnt
operator|+=
name|svi_screens
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|lno
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|lcnt
operator|)
return|;
block|}
end_function

end_unit

