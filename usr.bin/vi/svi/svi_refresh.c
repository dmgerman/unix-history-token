begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1992, 1993  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)svi_refresh.c	8.43 (Berkeley) 12/23/93"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<curses.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"vi.h"
end_include

begin_include
include|#
directive|include
file|"svi_screen.h"
end_include

begin_include
include|#
directive|include
file|"sex/sex_screen.h"
end_include

begin_decl_stmt
specifier|static
name|int
name|svi_modeline
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|EXF
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|svi_msgflush
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|svi_refresh
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
block|{
name|SCR
modifier|*
name|tsp
decl_stmt|;
name|u_int
name|paintbits
decl_stmt|;
comment|/* 	 * 1: Resize the screen. 	 * 	 * Notice that a resize is requested, and set up everything so that 	 * the file gets reinitialized.  Done here, instead of in the vi loop 	 * because there may be other initialization that other screens need 	 * to do.  The actual changing of the row/column values was done by 	 * calling the ex options code which put them into the environment, 	 * which is used by curses.  Stupid, but ugly. 	 */
if|if
condition|(
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|S_RESIZE
argument_list|)
condition|)
block|{
comment|/* Reinitialize curses. */
if|if
condition|(
name|svi_curses_end
argument_list|(
name|sp
argument_list|)
operator|||
name|svi_curses_init
argument_list|(
name|sp
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Lose any svi_screens() cached information. */
name|SVP
argument_list|(
name|sp
argument_list|)
operator|->
name|ss_lno
operator|=
name|OOBLNO
expr_stmt|;
comment|/* 		 * Fill the map, incidentally losing any svi_line() 		 * cached information. 		 */
if|if
condition|(
name|sp
operator|->
name|s_fill
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|sp
operator|->
name|lno
argument_list|,
name|P_FILL
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|F_CLR
argument_list|(
name|sp
argument_list|,
name|S_RESIZE
operator||
name|S_REFORMAT
argument_list|)
expr_stmt|;
name|F_SET
argument_list|(
name|sp
argument_list|,
name|S_REDRAW
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * 2: S_REFRESH 	 * 	 * If S_REFRESH is set in the current screen, repaint everything 	 * that we can find. 	 */
if|if
condition|(
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|S_REFRESH
argument_list|)
condition|)
for|for
control|(
name|tsp
operator|=
name|sp
operator|->
name|gp
operator|->
name|dq
operator|.
name|cqh_first
init|;
name|tsp
operator|!=
operator|(
name|void
operator|*
operator|)
operator|&
name|sp
operator|->
name|gp
operator|->
name|dq
condition|;
name|tsp
operator|=
name|tsp
operator|->
name|q
operator|.
name|cqe_next
control|)
if|if
condition|(
name|tsp
operator|!=
name|sp
condition|)
name|F_SET
argument_list|(
name|tsp
argument_list|,
name|S_REDRAW
argument_list|)
expr_stmt|;
comment|/* 	 * 3: Related or dirtied screens, or screens with messages. 	 * 	 * If related screens share a view into a file, they may have been 	 * modified as well.  Refresh any screens with paint or dirty bits 	 * set, or where messages are waiting.  Finally, if we refresh any 	 * screens other than the current one, the cursor will be trashed. 	 */
name|paintbits
operator|=
name|S_REDRAW
operator||
name|S_REFORMAT
operator||
name|S_REFRESH
expr_stmt|;
if|if
condition|(
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_NUMBER
argument_list|)
condition|)
name|paintbits
operator||=
name|S_RENUMBER
expr_stmt|;
for|for
control|(
name|tsp
operator|=
name|sp
operator|->
name|gp
operator|->
name|dq
operator|.
name|cqh_first
init|;
name|tsp
operator|!=
operator|(
name|void
operator|*
operator|)
operator|&
name|sp
operator|->
name|gp
operator|->
name|dq
condition|;
name|tsp
operator|=
name|tsp
operator|->
name|q
operator|.
name|cqe_next
control|)
if|if
condition|(
name|tsp
operator|!=
name|sp
operator|&&
operator|(
name|F_ISSET
argument_list|(
name|tsp
argument_list|,
name|paintbits
argument_list|)
operator|||
name|F_ISSET
argument_list|(
name|SVP
argument_list|(
name|tsp
argument_list|)
argument_list|,
name|SVI_SCREENDIRTY
argument_list|)
operator|||
name|tsp
operator|->
name|msgq
operator|.
name|lh_first
operator|!=
name|NULL
operator|&&
operator|!
name|F_ISSET
argument_list|(
name|tsp
operator|->
name|msgq
operator|.
name|lh_first
argument_list|,
name|M_EMPTY
argument_list|)
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|svi_paint
argument_list|(
name|tsp
argument_list|,
name|tsp
operator|->
name|ep
argument_list|)
expr_stmt|;
name|F_CLR
argument_list|(
name|SVP
argument_list|(
name|tsp
argument_list|)
argument_list|,
name|SVI_SCREENDIRTY
argument_list|)
expr_stmt|;
name|F_SET
argument_list|(
name|SVP
argument_list|(
name|sp
argument_list|)
argument_list|,
name|SVI_CUR_INVALID
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * 4: Refresh the current screen. 	 * 	 * Always refresh the current screen, it may be a cursor movement. 	 * Also, always do it last -- that way, S_REFRESH can be set in 	 * the current screen only, and the screen won't flash. 	 */
name|F_CLR
argument_list|(
name|sp
argument_list|,
name|SVI_SCREENDIRTY
argument_list|)
expr_stmt|;
return|return
operator|(
name|svi_paint
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * svi_paint --  *	This is the guts of the vi curses screen code.  The idea is that  *	the SCR structure passed in contains the new coordinates of the  *	screen.  What makes this hard is that we don't know how big  *	characters are, doing input can put the cursor in illegal places,  *	and we're frantically trying to avoid repainting unless it's  *	absolutely necessary.  If you change this code, you'd better know  *	what you're doing.  It's subtle and quick to anger.  */
end_comment

begin_function
name|int
name|svi_paint
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
block|{
name|CHNAME
specifier|const
modifier|*
name|cname
decl_stmt|;
name|SMAP
modifier|*
name|smp
decl_stmt|,
name|tmp
decl_stmt|;
name|SVI_PRIVATE
modifier|*
name|svp
decl_stmt|;
name|recno_t
name|lastline
decl_stmt|,
name|lcnt
decl_stmt|;
name|size_t
name|cwtotal
decl_stmt|,
name|cnt
decl_stmt|,
name|len
decl_stmt|,
name|x
decl_stmt|,
name|y
decl_stmt|;
name|int
name|ch
decl_stmt|,
name|didpaint
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
define|#
directive|define
name|LNO
value|sp->lno
define|#
directive|define
name|OLNO
value|svp->olno
define|#
directive|define
name|CNO
value|sp->cno
define|#
directive|define
name|OCNO
value|svp->ocno
define|#
directive|define
name|SCNO
value|svp->sc_col
name|didpaint
operator|=
literal|0
expr_stmt|;
name|svp
operator|=
name|SVP
argument_list|(
name|sp
argument_list|)
expr_stmt|;
comment|/* 	 * 1: Reformat the lines. 	 * 	 * If the lines themselves have changed (:set list, for example), 	 * fill in the map from scratch.  Adjust the screen that's being 	 * displayed if the leftright flag is set. 	 */
if|if
condition|(
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|S_REFORMAT
argument_list|)
condition|)
block|{
comment|/* Toss svi_screens() cached information. */
name|SVP
argument_list|(
name|sp
argument_list|)
operator|->
name|ss_lno
operator|=
name|OOBLNO
expr_stmt|;
comment|/* Toss svi_line() cached information. */
if|if
condition|(
name|svi_sm_fill
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|HMAP
operator|->
name|lno
argument_list|,
name|P_TOP
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_LEFTRIGHT
argument_list|)
operator|&&
operator|(
name|cnt
operator|=
name|svi_screens
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|LNO
argument_list|,
operator|&
name|CNO
argument_list|)
operator|)
operator|!=
literal|1
condition|)
for|for
control|(
name|smp
operator|=
name|HMAP
init|;
name|smp
operator|<=
name|TMAP
condition|;
operator|++
name|smp
control|)
name|smp
operator|->
name|off
operator|=
name|cnt
expr_stmt|;
name|F_CLR
argument_list|(
name|sp
argument_list|,
name|S_REFORMAT
argument_list|)
expr_stmt|;
name|F_SET
argument_list|(
name|sp
argument_list|,
name|S_REDRAW
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * 2: Line movement. 	 * 	 * Line changes can cause the top line to change as well.  As 	 * before, if the movement is large, the screen is repainted. 	 * 	 * 2a: Tiny screens. 	 * 	 * Tiny screens cannot be permitted into the "scrolling" parts of 	 * the smap code for two reasons.  If the screen size is 1 line, 	 * HMAP == TMAP and the code will quickly drop core.  If the screen 	 * size is 2, none of the divisions by 2 will work, and scrolling 	 * won't work.  In fact, because no line change will be less than 	 * HALFTEXT(sp), we always ending up "filling" the map, with a 	 * P_MIDDLE flag, which isn't what the user wanted.  Tiny screens 	 * can go into the "fill" portions of the smap code, however. 	 */
if|if
condition|(
name|sp
operator|->
name|t_rows
operator|<=
literal|2
condition|)
block|{
if|if
condition|(
name|LNO
operator|<
name|HMAP
operator|->
name|lno
condition|)
block|{
if|if
condition|(
name|svi_sm_fill
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|LNO
argument_list|,
name|P_TOP
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|LNO
operator|>
name|TMAP
operator|->
name|lno
condition|)
if|if
condition|(
name|svi_sm_fill
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|LNO
argument_list|,
name|P_BOTTOM
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|sp
operator|->
name|t_rows
operator|==
literal|1
condition|)
block|{
name|HMAP
operator|->
name|off
operator|=
name|svi_screens
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|LNO
argument_list|,
operator|&
name|CNO
argument_list|)
expr_stmt|;
goto|goto
name|paint
goto|;
block|}
name|F_SET
argument_list|(
name|sp
argument_list|,
name|S_REDRAW
argument_list|)
expr_stmt|;
goto|goto
name|adjust
goto|;
block|}
comment|/* 	 * 2b: Small screens. 	 * 	 * Users can use the window, w300, w1200 and w9600 options to make 	 * the screen artificially small.  The behavior of these options 	 * in the historic vi wasn't all that consistent, and, in fact, it 	 * was never documented how various screen movements affected the 	 * screen size.  Generally, one of three things would happen: 	 *	1: The screen would expand in size, showing the line 	 *	2: The screen would scroll, showing the line 	 *	3: The screen would compress to its smallest size and 	 *		repaint. 	 * In general, scrolling didn't cause compression (200^D was handled 	 * the same as ^D), movement to a specific line would (:N where N 	 * was 1 line below the screen caused a screen compress), and cursor 	 * movement would scroll if it was 11 lines or less, and compress if 	 * it was more than 11 lines.  (And, no, I have no idea where the 11 	 * comes from.) 	 * 	 * What we do is try and figure out if the line is less than half of 	 * a full screen away.  If it is, we expand the screen if there's 	 * room, and then scroll as necessary.  The alternative is to compress 	 * and repaint. 	 * 	 * !!! 	 * This code is a special case from beginning to end.  Unfortunately, 	 * home modems are still slow enough that it's worth having. 	 * 	 * XXX 	 * If the line a really long one, i.e. part of the line is on the 	 * screen but the column offset is not, we'll end up in the adjust 	 * code, when we should probably have compressed the screen. 	 */
if|if
condition|(
name|ISSMALLSCREEN
argument_list|(
name|sp
argument_list|)
condition|)
if|if
condition|(
name|LNO
operator|<
name|HMAP
operator|->
name|lno
condition|)
block|{
name|lcnt
operator|=
name|svi_sm_nlines
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|HMAP
argument_list|,
name|LNO
argument_list|,
name|sp
operator|->
name|t_maxrows
argument_list|)
expr_stmt|;
if|if
condition|(
name|lcnt
operator|<=
name|HALFSCREEN
argument_list|(
name|sp
argument_list|)
condition|)
for|for
control|(
init|;
name|lcnt
operator|&&
name|sp
operator|->
name|t_rows
operator|!=
name|sp
operator|->
name|t_maxrows
condition|;
operator|--
name|lcnt
operator|,
operator|++
name|sp
operator|->
name|t_rows
control|)
block|{
operator|++
name|TMAP
expr_stmt|;
if|if
condition|(
name|svi_sm_1down
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
goto|goto
name|small_fill
goto|;
block|}
elseif|else
if|if
condition|(
name|LNO
operator|>
name|TMAP
operator|->
name|lno
condition|)
block|{
name|lcnt
operator|=
name|svi_sm_nlines
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|TMAP
argument_list|,
name|LNO
argument_list|,
name|sp
operator|->
name|t_maxrows
argument_list|)
expr_stmt|;
if|if
condition|(
name|lcnt
operator|<=
name|HALFSCREEN
argument_list|(
name|sp
argument_list|)
condition|)
for|for
control|(
init|;
name|lcnt
operator|&&
name|sp
operator|->
name|t_rows
operator|!=
name|sp
operator|->
name|t_maxrows
condition|;
operator|--
name|lcnt
operator|,
operator|++
name|sp
operator|->
name|t_rows
control|)
block|{
if|if
condition|(
name|svi_sm_next
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|TMAP
argument_list|,
name|TMAP
operator|+
literal|1
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
operator|++
name|TMAP
expr_stmt|;
if|if
condition|(
name|svi_line
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|TMAP
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
name|small_fill
label|:
name|MOVE
argument_list|(
name|sp
argument_list|,
name|INFOLINE
argument_list|(
name|sp
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|clrtoeol
argument_list|()
expr_stmt|;
for|for
control|(
init|;
name|sp
operator|->
name|t_rows
operator|>
name|sp
operator|->
name|t_minrows
condition|;
operator|--
name|sp
operator|->
name|t_rows
operator|,
operator|--
name|TMAP
control|)
block|{
name|MOVE
argument_list|(
name|sp
argument_list|,
name|TMAP
operator|-
name|HMAP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|clrtoeol
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|svi_sm_fill
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|LNO
argument_list|,
name|P_FILL
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|F_SET
argument_list|(
name|sp
argument_list|,
name|S_REDRAW
argument_list|)
expr_stmt|;
goto|goto
name|adjust
goto|;
block|}
block|}
comment|/* 	 * 3a: Line down. 	 */
if|if
condition|(
name|LNO
operator|>=
name|HMAP
operator|->
name|lno
condition|)
block|{
if|if
condition|(
name|LNO
operator|<=
name|TMAP
operator|->
name|lno
condition|)
goto|goto
name|adjust
goto|;
comment|/* 		 * If less than half a screen away, scroll down until the 		 * line is on the screen. 		 */
name|lcnt
operator|=
name|svi_sm_nlines
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|TMAP
argument_list|,
name|LNO
argument_list|,
name|HALFTEXT
argument_list|(
name|sp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lcnt
operator|<
name|HALFTEXT
argument_list|(
name|sp
argument_list|)
condition|)
block|{
while|while
condition|(
name|lcnt
operator|--
condition|)
if|if
condition|(
name|svi_sm_1up
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
goto|goto
name|adjust
goto|;
block|}
comment|/* 		 * If less than a full screen from the bottom of the file, put 		 * the last line of the file on the bottom of the screen.  The 		 * calculation is safe because we know there's at least one 		 * full screen of lines, otherwise couldn't have gotten here. 		 */
if|if
condition|(
name|file_lline
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|lastline
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|tmp
operator|.
name|lno
operator|=
name|LNO
expr_stmt|;
name|tmp
operator|.
name|off
operator|=
literal|1
expr_stmt|;
name|lcnt
operator|=
name|svi_sm_nlines
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|tmp
argument_list|,
name|lastline
argument_list|,
name|sp
operator|->
name|t_rows
argument_list|)
expr_stmt|;
if|if
condition|(
name|lcnt
operator|<
name|sp
operator|->
name|t_rows
condition|)
block|{
if|if
condition|(
name|svi_sm_fill
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|lastline
argument_list|,
name|P_BOTTOM
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|F_SET
argument_list|(
name|sp
argument_list|,
name|S_REDRAW
argument_list|)
expr_stmt|;
goto|goto
name|adjust
goto|;
block|}
comment|/* 		 * If more than a full screen from the last line of the file, 		 * put the new line in the middle of the screen. 		 */
goto|goto
name|middle
goto|;
block|}
comment|/* 	 * 3b: Line up. 	 * 	 * If less than half a screen away, scroll up until the line is 	 * the first line on the screen. 	 */
name|lcnt
operator|=
name|svi_sm_nlines
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|HMAP
argument_list|,
name|LNO
argument_list|,
name|HALFTEXT
argument_list|(
name|sp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lcnt
operator|<
name|HALFTEXT
argument_list|(
name|sp
argument_list|)
condition|)
block|{
while|while
condition|(
name|lcnt
operator|--
condition|)
if|if
condition|(
name|svi_sm_1down
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
goto|goto
name|adjust
goto|;
block|}
comment|/* 	 * If less than half a screen from the top of the file, put the first 	 * line of the file at the top of the screen.  Otherwise, put the line 	 * in the middle of the screen. 	 */
name|tmp
operator|.
name|lno
operator|=
literal|1
expr_stmt|;
name|tmp
operator|.
name|off
operator|=
literal|1
expr_stmt|;
name|lcnt
operator|=
name|svi_sm_nlines
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|tmp
argument_list|,
name|LNO
argument_list|,
name|HALFTEXT
argument_list|(
name|sp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lcnt
operator|<
name|HALFTEXT
argument_list|(
name|sp
argument_list|)
condition|)
block|{
if|if
condition|(
name|svi_sm_fill
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
literal|1
argument_list|,
name|P_TOP
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
name|middle
label|:
if|if
condition|(
name|svi_sm_fill
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|LNO
argument_list|,
name|P_MIDDLE
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|F_SET
argument_list|(
name|sp
argument_list|,
name|S_REDRAW
argument_list|)
expr_stmt|;
comment|/* 	 * At this point we know part of the line is on the screen.  Since 	 * scrolling is done using logical lines, not physical, all of the 	 * line may not be on the screen.  While that's not necessarily bad, 	 * if the part the cursor is on isn't there, we're going to lose. 	 * This can be tricky; if the line covers the entire screen, lno 	 * may be the same as both ends of the map, that's why we test BOTH 	 * the top and the bottom of the map.  This isn't a problem for 	 * left-right scrolling, the cursor movement code handles the problem. 	 * 	 * There's a performance issue here if editing *really* long lines. 	 * This gets to the right spot by scrolling, and, in a binary, by 	 * scrolling hundreds of lines.  If the adjustment looks like it's 	 * going to be a serious problem, refill the screen and repaint. 	 */
name|adjust
label|:
if|if
condition|(
operator|!
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_LEFTRIGHT
argument_list|)
operator|&&
operator|(
name|LNO
operator|==
name|HMAP
operator|->
name|lno
operator|||
name|LNO
operator|==
name|TMAP
operator|->
name|lno
operator|)
condition|)
block|{
name|cnt
operator|=
name|svi_screens
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|LNO
argument_list|,
operator|&
name|CNO
argument_list|)
expr_stmt|;
if|if
condition|(
name|LNO
operator|==
name|HMAP
operator|->
name|lno
operator|&&
name|cnt
operator|<
name|HMAP
operator|->
name|off
condition|)
if|if
condition|(
operator|(
name|HMAP
operator|->
name|off
operator|-
name|cnt
operator|)
operator|>
name|HALFTEXT
argument_list|(
name|sp
argument_list|)
condition|)
block|{
name|HMAP
operator|->
name|off
operator|=
name|cnt
expr_stmt|;
name|svi_sm_fill
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|OOBLNO
argument_list|,
name|P_TOP
argument_list|)
expr_stmt|;
name|F_SET
argument_list|(
name|sp
argument_list|,
name|S_REDRAW
argument_list|)
expr_stmt|;
block|}
else|else
while|while
condition|(
name|cnt
operator|<
name|HMAP
operator|->
name|off
condition|)
if|if
condition|(
name|svi_sm_1down
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|LNO
operator|==
name|TMAP
operator|->
name|lno
operator|&&
name|cnt
operator|>
name|TMAP
operator|->
name|off
condition|)
if|if
condition|(
operator|(
name|cnt
operator|-
name|TMAP
operator|->
name|off
operator|)
operator|>
name|HALFTEXT
argument_list|(
name|sp
argument_list|)
condition|)
block|{
name|TMAP
operator|->
name|off
operator|=
name|cnt
expr_stmt|;
name|svi_sm_fill
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|OOBLNO
argument_list|,
name|P_BOTTOM
argument_list|)
expr_stmt|;
name|F_SET
argument_list|(
name|sp
argument_list|,
name|S_REDRAW
argument_list|)
expr_stmt|;
block|}
else|else
while|while
condition|(
name|cnt
operator|>
name|TMAP
operator|->
name|off
condition|)
if|if
condition|(
name|svi_sm_1up
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* If the screen needs to be repainted, skip cursor optimization. */
if|if
condition|(
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|S_REDRAW
argument_list|)
condition|)
goto|goto
name|paint
goto|;
comment|/* 	 * 4: Cursor movements. 	 * 	 * Decide cursor position.  If the line has changed, the cursor has 	 * moved over a tab, or don't know where the cursor was, reparse the 	 * line.  Note, if we think that the cursor "hasn't moved", reparse 	 * the line.  This is 'cause if it hasn't moved, we've almost always 	 * lost track of it. 	 * 	 * Otherwise, we've just moved over fixed-width characters, and can 	 * calculate the left/right scrolling and cursor movement without 	 * reparsing the line.  Note that we don't know which (if any) of 	 * the characters between the old and new cursor positions changed. 	 * 	 * XXX 	 * With some work, it should be possible to handle tabs quickly, at 	 * least in obvious situations, like moving right and encountering 	 * a tab, without reparsing the whole line. 	 */
comment|/* If the line we're working with has changed, reparse. */
if|if
condition|(
name|F_ISSET
argument_list|(
name|SVP
argument_list|(
name|sp
argument_list|)
argument_list|,
name|SVI_CUR_INVALID
argument_list|)
operator|||
name|LNO
operator|!=
name|OLNO
condition|)
block|{
name|F_CLR
argument_list|(
name|SVP
argument_list|(
name|sp
argument_list|)
argument_list|,
name|SVI_CUR_INVALID
argument_list|)
expr_stmt|;
goto|goto
name|slow
goto|;
block|}
comment|/* Otherwise, if nothing's changed, go fast. */
if|if
condition|(
name|CNO
operator|==
name|OCNO
condition|)
goto|goto
name|fast
goto|;
comment|/* 	 * Get the current line.  If this fails, we either have an empty 	 * file and can just repaint, or there's a real problem.  This 	 * isn't a performance issue because there aren't any ways to get 	 * here repeatedly. 	 */
if|if
condition|(
operator|(
name|p
operator|=
name|file_gline
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|LNO
argument_list|,
operator|&
name|len
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|file_lline
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|lastline
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|lastline
operator|==
literal|0
condition|)
goto|goto
name|slow
goto|;
name|GETLINE_ERR
argument_list|(
name|sp
argument_list|,
name|LNO
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
comment|/* This is just a test. */
if|if
condition|(
name|CNO
operator|>=
name|len
operator|&&
name|len
operator|!=
literal|0
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"Error: %s/%d: cno (%u)>= len (%u)"
argument_list|,
name|tail
argument_list|(
name|__FILE__
argument_list|)
argument_list|,
name|__LINE__
argument_list|,
name|CNO
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* 	 * The basic scheme here is to look at the characters in between 	 * the old and new positions and decide how big they are on the 	 * screen, and therefore, how many screen positions to move. 	 */
name|cname
operator|=
name|sp
operator|->
name|gp
operator|->
name|cname
expr_stmt|;
if|if
condition|(
name|CNO
operator|<
name|OCNO
condition|)
block|{
comment|/* 		 * 4a: Cursor moved left. 		 * 		 * Point to the old character.  The old cursor position can 		 * be past EOL if, for example, we just deleted the rest of 		 * the line.  In this case, since we don't know the width of 		 * the characters we traversed, we have to do it slowly. 		 */
name|p
operator|+=
name|OCNO
expr_stmt|;
name|cnt
operator|=
operator|(
name|OCNO
operator|-
name|CNO
operator|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|OCNO
operator|>=
name|len
condition|)
goto|goto
name|slow
goto|;
comment|/* 		 * Quit sanity check -- it's hard to figure out exactly when 		 * we cross a screen boundary as we do in the cursor right 		 * movement.  If cnt is so large that we're going to cross the 		 * boundary no matter what, stop now. 		 */
if|if
condition|(
name|SCNO
operator|+
literal|1
operator|+
name|MAX_CHARACTER_COLUMNS
operator|<
name|cnt
condition|)
goto|goto
name|lscreen
goto|;
comment|/* 		 * Count up the widths of the characters.  If it's a tab 		 * character, go do it the the slow way. 		 */
for|for
control|(
name|cwtotal
operator|=
literal|0
init|;
name|cnt
operator|--
condition|;
name|cwtotal
operator|+=
name|cname
index|[
name|ch
index|]
operator|.
name|len
control|)
if|if
condition|(
operator|(
name|ch
operator|=
operator|*
operator|(
name|u_char
operator|*
operator|)
name|p
operator|--
operator|)
operator|==
literal|'\t'
condition|)
goto|goto
name|slow
goto|;
comment|/* 		 * Decrement the screen cursor by the total width of the 		 * characters minus 1. 		 */
name|cwtotal
operator|-=
literal|1
expr_stmt|;
comment|/* 		 * If we're moving left, and there's a wide character in the 		 * current position, go to the end of the character. 		 */
if|if
condition|(
name|cname
index|[
name|ch
index|]
operator|.
name|len
operator|>
literal|1
condition|)
name|cwtotal
operator|-=
name|cname
index|[
name|ch
index|]
operator|.
name|len
operator|-
literal|1
expr_stmt|;
comment|/* 		 * If the new column moved us out of the current screen, 		 * calculate a new screen. 		 */
if|if
condition|(
name|SCNO
operator|<
name|cwtotal
condition|)
block|{
name|lscreen
label|:
if|if
condition|(
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_LEFTRIGHT
argument_list|)
condition|)
block|{
for|for
control|(
name|smp
operator|=
name|HMAP
init|;
name|smp
operator|<=
name|TMAP
condition|;
operator|++
name|smp
control|)
operator|--
name|smp
operator|->
name|off
expr_stmt|;
goto|goto
name|paint
goto|;
block|}
goto|goto
name|slow
goto|;
block|}
name|SCNO
operator|-=
name|cwtotal
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * 4b: Cursor moved right. 		 * 		 * Point to the first character to the right. 		 */
name|p
operator|+=
name|OCNO
operator|+
literal|1
expr_stmt|;
name|cnt
operator|=
name|CNO
operator|-
name|OCNO
expr_stmt|;
comment|/* 		 * Count up the widths of the characters.  If it's a tab 		 * character, go do it the the slow way.  If we cross a 		 * screen boundary, we can quit. 		 */
for|for
control|(
name|cwtotal
operator|=
name|SCNO
init|;
name|cnt
operator|--
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|ch
operator|=
operator|*
operator|(
name|u_char
operator|*
operator|)
name|p
operator|++
operator|)
operator|==
literal|'\t'
condition|)
goto|goto
name|slow
goto|;
if|if
condition|(
operator|(
name|cwtotal
operator|+=
name|cname
index|[
name|ch
index|]
operator|.
name|len
operator|)
operator|>=
name|SCREEN_COLS
argument_list|(
name|sp
argument_list|)
condition|)
break|break;
block|}
comment|/* 		 * Increment the screen cursor by the total width of the 		 * characters. 		 */
name|SCNO
operator|=
name|cwtotal
expr_stmt|;
comment|/* 		 * If the new column moved us out of the current screen, 		 * calculate a new screen. 		 */
if|if
condition|(
name|SCNO
operator|>=
name|SCREEN_COLS
argument_list|(
name|sp
argument_list|)
condition|)
block|{
if|if
condition|(
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_LEFTRIGHT
argument_list|)
condition|)
block|{
name|SCNO
operator|-=
name|SCREEN_COLS
argument_list|(
name|sp
argument_list|)
expr_stmt|;
for|for
control|(
name|smp
operator|=
name|HMAP
init|;
name|smp
operator|<=
name|TMAP
condition|;
operator|++
name|smp
control|)
operator|++
name|smp
operator|->
name|off
expr_stmt|;
goto|goto
name|paint
goto|;
block|}
goto|goto
name|slow
goto|;
block|}
block|}
comment|/* 	 * 4c: Fast cursor update. 	 * 	 * Retrieve the current cursor position, and correct it 	 * for split screens. 	 */
name|fast
label|:
name|getyx
argument_list|(
name|stdscr
argument_list|,
name|y
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|y
operator|-=
name|sp
operator|->
name|woff
expr_stmt|;
goto|goto
name|number
goto|;
comment|/* 	 * 4d: Slow cursor update. 	 * 	 * Walk through the map and find the current line.  If doing left-right 	 * scrolling and the cursor movement has changed the screen displayed, 	 * scroll the screen left or right, unless we're updating the info line 	 * in which case we just scroll that one line.  Then update the screen 	 * lines for this file line until we have a new screen cursor position. 	 */
name|slow
label|:
for|for
control|(
name|smp
operator|=
name|HMAP
init|;
name|smp
operator|->
name|lno
operator|!=
name|LNO
condition|;
operator|++
name|smp
control|)
empty_stmt|;
if|if
condition|(
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_LEFTRIGHT
argument_list|)
condition|)
block|{
name|cnt
operator|=
name|svi_screens
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|LNO
argument_list|,
operator|&
name|CNO
argument_list|)
operator|%
name|SCREEN_COLS
argument_list|(
name|sp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnt
operator|!=
name|HMAP
operator|->
name|off
condition|)
block|{
if|if
condition|(
name|ISINFOLINE
argument_list|(
name|sp
argument_list|,
name|smp
argument_list|)
condition|)
name|smp
operator|->
name|off
operator|=
name|cnt
expr_stmt|;
else|else
for|for
control|(
name|smp
operator|=
name|HMAP
init|;
name|smp
operator|<=
name|TMAP
condition|;
operator|++
name|smp
control|)
name|smp
operator|->
name|off
operator|=
name|cnt
expr_stmt|;
goto|goto
name|paint
goto|;
block|}
block|}
for|for
control|(
name|y
operator|=
operator|-
literal|1
init|;
name|smp
operator|<=
name|TMAP
operator|&&
name|smp
operator|->
name|lno
operator|==
name|LNO
condition|;
operator|++
name|smp
control|)
block|{
if|if
condition|(
name|svi_line
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|smp
argument_list|,
operator|&
name|y
argument_list|,
operator|&
name|SCNO
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|y
operator|!=
operator|-
literal|1
condition|)
break|break;
block|}
goto|goto
name|number
goto|;
comment|/* 	 * 5: Repaint the entire screen. 	 * 	 * Lost big, do what you have to do.  We flush the cache as S_REDRAW 	 * gets set when the screen isn't worth fixing, and it's simpler to 	 * repaint.  So, don't trust anything that we think we know about it. 	 */
name|paint
label|:
for|for
control|(
name|smp
operator|=
name|HMAP
init|;
name|smp
operator|<=
name|TMAP
condition|;
operator|++
name|smp
control|)
name|SMAP_FLUSH
argument_list|(
name|smp
argument_list|)
expr_stmt|;
for|for
control|(
name|smp
operator|=
name|HMAP
init|;
name|smp
operator|<=
name|TMAP
condition|;
operator|++
name|smp
control|)
if|if
condition|(
name|svi_line
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|smp
argument_list|,
operator|&
name|y
argument_list|,
operator|&
name|SCNO
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 	 * If it's a small screen and we're redrawing, clear the unused lines, 	 * ex may have overwritten them. 	 */
if|if
condition|(
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|S_REDRAW
argument_list|)
condition|)
block|{
if|if
condition|(
name|ISSMALLSCREEN
argument_list|(
name|sp
argument_list|)
condition|)
for|for
control|(
name|cnt
operator|=
name|sp
operator|->
name|t_rows
init|;
name|cnt
operator|<=
name|sp
operator|->
name|t_maxrows
condition|;
operator|++
name|cnt
control|)
block|{
name|MOVE
argument_list|(
name|sp
argument_list|,
name|cnt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|clrtoeol
argument_list|()
expr_stmt|;
block|}
name|F_CLR
argument_list|(
name|sp
argument_list|,
name|S_REDRAW
argument_list|)
expr_stmt|;
block|}
name|didpaint
operator|=
literal|1
expr_stmt|;
comment|/* 	 * 6: Repaint the line numbers. 	 * 	 * If O_NUMBER is set and the S_RENUMBER bit is set, and we didn't 	 * repaint the screen, repaint all of the line numbers, they've 	 * changed. 	 */
name|number
label|:
if|if
condition|(
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_NUMBER
argument_list|)
operator|&&
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|S_RENUMBER
argument_list|)
operator|&&
operator|!
name|didpaint
condition|)
block|{
if|if
condition|(
name|svi_number
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|F_CLR
argument_list|(
name|sp
argument_list|,
name|S_RENUMBER
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * 7: Refresh the screen. 	 * 	 * If the screen was corrupted, refresh it. 	 */
if|if
condition|(
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|S_REFRESH
argument_list|)
condition|)
block|{
name|wrefresh
argument_list|(
name|curscr
argument_list|)
expr_stmt|;
name|F_CLR
argument_list|(
name|sp
argument_list|,
name|S_REFRESH
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|S_BELLSCHED
argument_list|)
condition|)
name|svi_bell
argument_list|(
name|sp
argument_list|)
expr_stmt|;
comment|/* 	 * If the bottom line isn't in use by the colon command: 	 * 	 *	Display any messages.  Don't test S_UPDATE_MODE.  The 	 *	message printing routine set it to avoid anyone else 	 *	destroying the message we're about to display. 	 * 	 *	If the bottom line isn't in use by anyone, put out the 	 *	standard status line. 	 */
if|if
condition|(
operator|!
name|F_ISSET
argument_list|(
name|SVP
argument_list|(
name|sp
argument_list|)
argument_list|,
name|SVI_INFOLINE
argument_list|)
condition|)
if|if
condition|(
name|sp
operator|->
name|msgq
operator|.
name|lh_first
operator|!=
name|NULL
operator|&&
operator|!
name|F_ISSET
argument_list|(
name|sp
operator|->
name|msgq
operator|.
name|lh_first
argument_list|,
name|M_EMPTY
argument_list|)
condition|)
name|svi_msgflush
argument_list|(
name|sp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|S_UPDATE_MODE
argument_list|)
condition|)
name|svi_modeline
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|)
expr_stmt|;
comment|/* Update saved information. */
name|OCNO
operator|=
name|CNO
expr_stmt|;
name|OLNO
operator|=
name|LNO
expr_stmt|;
comment|/* Place the cursor. */
name|MOVE
argument_list|(
name|sp
argument_list|,
name|y
argument_list|,
name|SCNO
argument_list|)
expr_stmt|;
comment|/* Flush it all out. */
name|refresh
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * svi_msgflush --  *	Flush any accumulated messages.  */
end_comment

begin_function
specifier|static
name|int
name|svi_msgflush
parameter_list|(
name|sp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
block|{
name|CH
name|ikey
decl_stmt|;
name|CHAR_T
name|ch
decl_stmt|;
name|CHNAME
specifier|const
modifier|*
name|cname
decl_stmt|;
name|MSG
modifier|*
name|mp
decl_stmt|;
name|size_t
name|chlen
decl_stmt|,
name|len
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
define|#
directive|define
name|MCONTMSG
value|" [More ...]"
comment|/* Display the messages. */
name|cname
operator|=
name|sp
operator|->
name|gp
operator|->
name|cname
expr_stmt|;
for|for
control|(
name|mp
operator|=
name|sp
operator|->
name|msgq
operator|.
name|lh_first
operator|,
name|p
operator|=
name|NULL
init|;
name|mp
operator|!=
name|NULL
operator|&&
operator|!
name|F_ISSET
argument_list|(
name|mp
argument_list|,
name|M_EMPTY
argument_list|)
condition|;
name|mp
operator|=
name|mp
operator|->
name|q
operator|.
name|le_next
control|)
block|{
name|p
operator|=
name|mp
operator|->
name|mbuf
expr_stmt|;
name|lcont
label|:
comment|/* Move to the message line and clear it. */
name|MOVE
argument_list|(
name|sp
argument_list|,
name|INFOLINE
argument_list|(
name|sp
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|clrtoeol
argument_list|()
expr_stmt|;
comment|/* 		 * Turn on standout mode if requested, or, if we've split 		 * the screen and need a divider. 		 */
if|if
condition|(
name|F_ISSET
argument_list|(
name|mp
argument_list|,
name|M_INV_VIDEO
argument_list|)
operator|||
name|sp
operator|->
name|q
operator|.
name|cqe_next
operator|!=
operator|(
name|void
operator|*
operator|)
operator|&
name|sp
operator|->
name|gp
operator|->
name|dq
condition|)
name|standout
argument_list|()
expr_stmt|;
comment|/* 		 * Print up to the "more" message.  Avoid the last character 		 * in the last line, some hardware doesn't like it. 		 */
if|if
condition|(
name|svi_ncols
argument_list|(
name|sp
argument_list|,
name|p
argument_list|,
name|mp
operator|->
name|len
argument_list|,
name|NULL
argument_list|)
operator|<
name|sp
operator|->
name|cols
operator|-
literal|1
condition|)
name|len
operator|=
name|sp
operator|->
name|cols
operator|-
literal|1
expr_stmt|;
else|else
name|len
operator|=
operator|(
name|sp
operator|->
name|cols
operator|-
sizeof|sizeof
argument_list|(
name|MCONTMSG
argument_list|)
operator|)
operator|-
literal|1
expr_stmt|;
for|for
control|(
init|;
condition|;
operator|++
name|p
control|)
block|{
if|if
condition|(
operator|!
name|mp
operator|->
name|len
condition|)
break|break;
name|ch
operator|=
operator|*
operator|(
name|u_char
operator|*
operator|)
name|p
expr_stmt|;
name|chlen
operator|=
name|cname
index|[
name|ch
index|]
operator|.
name|len
expr_stmt|;
if|if
condition|(
name|chlen
operator|>=
name|len
condition|)
break|break;
name|len
operator|-=
name|chlen
expr_stmt|;
operator|--
name|mp
operator|->
name|len
expr_stmt|;
name|ADDNSTR
argument_list|(
name|cname
index|[
name|ch
index|]
operator|.
name|name
argument_list|,
name|chlen
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * If more, print continue message.  If user key fails, 		 * keep showing the messages anyway. 		 */
if|if
condition|(
name|mp
operator|->
name|len
operator|||
operator|(
name|mp
operator|->
name|q
operator|.
name|le_next
operator|!=
name|NULL
operator|&&
operator|!
name|F_ISSET
argument_list|(
name|mp
operator|->
name|q
operator|.
name|le_next
argument_list|,
name|M_EMPTY
argument_list|)
operator|)
condition|)
block|{
name|ADDNSTR
argument_list|(
name|MCONTMSG
argument_list|,
sizeof|sizeof
argument_list|(
name|MCONTMSG
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|term_user_key
argument_list|(
name|sp
argument_list|,
operator|&
name|ikey
argument_list|)
operator|!=
name|INP_OK
condition|)
break|break;
if|if
condition|(
name|ikey
operator|.
name|value
operator|==
name|K_CR
operator|||
name|ikey
operator|.
name|value
operator|==
name|K_NL
operator|||
name|ikey
operator|.
name|ch
operator|==
literal|' '
condition|)
break|break;
name|svi_bell
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Turn off standout mode. */
if|if
condition|(
name|F_ISSET
argument_list|(
name|mp
argument_list|,
name|M_INV_VIDEO
argument_list|)
operator|||
name|sp
operator|->
name|q
operator|.
name|cqe_next
operator|!=
operator|(
name|void
operator|*
operator|)
operator|&
name|sp
operator|->
name|gp
operator|->
name|dq
condition|)
name|standend
argument_list|()
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|len
condition|)
goto|goto
name|lcont
goto|;
name|refresh
argument_list|()
expr_stmt|;
name|F_SET
argument_list|(
name|mp
argument_list|,
name|M_EMPTY
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|RULERSIZE
value|15
end_define

begin_define
define|#
directive|define
name|MODESIZE
value|(RULERSIZE + 15)
end_define

begin_comment
comment|/*  * svi_modeline --  *	Update the mode line.  */
end_comment

begin_function
specifier|static
name|int
name|svi_modeline
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
block|{
name|char
modifier|*
name|s
decl_stmt|,
name|buf
index|[
name|RULERSIZE
index|]
decl_stmt|;
name|MOVE
argument_list|(
name|sp
argument_list|,
name|INFOLINE
argument_list|(
name|sp
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|clrtoeol
argument_list|()
expr_stmt|;
comment|/* Display a dividing line if not the bottom screen. */
if|if
condition|(
name|sp
operator|->
name|q
operator|.
name|cqe_next
operator|!=
operator|(
name|void
operator|*
operator|)
operator|&
name|sp
operator|->
name|gp
operator|->
name|dq
condition|)
name|svi_divider
argument_list|(
name|sp
argument_list|)
expr_stmt|;
comment|/* Display the ruler. */
if|if
condition|(
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_RULER
argument_list|)
operator|&&
name|sp
operator|->
name|cols
operator|>
name|RULERSIZE
operator|+
literal|2
condition|)
block|{
name|MOVE
argument_list|(
name|sp
argument_list|,
name|INFOLINE
argument_list|(
name|sp
argument_list|)
argument_list|,
name|sp
operator|->
name|cols
operator|/
literal|2
operator|-
name|RULERSIZE
operator|/
literal|2
argument_list|)
expr_stmt|;
name|clrtoeol
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%lu,%lu"
argument_list|,
name|sp
operator|->
name|lno
argument_list|,
name|sp
operator|->
name|cno
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ADDSTR
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
comment|/* Show the modified bit. */
if|if
condition|(
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_SHOWDIRTY
argument_list|)
operator|&&
name|F_ISSET
argument_list|(
name|ep
argument_list|,
name|F_MODIFIED
argument_list|)
operator|&&
name|sp
operator|->
name|cols
operator|>
name|MODESIZE
condition|)
block|{
name|MOVE
argument_list|(
name|sp
argument_list|,
name|INFOLINE
argument_list|(
name|sp
argument_list|)
argument_list|,
name|sp
operator|->
name|cols
operator|-
literal|9
argument_list|)
expr_stmt|;
name|ADDSTR
argument_list|(
literal|"*"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Show the mode.  Leave the last character blank, in case it's a 	 * really dumb terminal with hardware scroll.  Second, don't try 	 * to *paint* the last character, SunOS 4.1.1 and Ultrix 4.2 curses 	 * won't let you paint the last character in the screen. 	 */
if|if
condition|(
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_SHOWMODE
argument_list|)
operator|&&
name|sp
operator|->
name|cols
operator|>
name|MODESIZE
condition|)
block|{
name|MOVE
argument_list|(
name|sp
argument_list|,
name|INFOLINE
argument_list|(
name|sp
argument_list|)
argument_list|,
name|sp
operator|->
name|cols
operator|-
literal|8
argument_list|)
expr_stmt|;
name|s
operator|=
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|S_INPUT
argument_list|)
condition|?
literal|"  Input"
else|:
literal|"Command"
expr_stmt|;
name|ADDSTR
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * svi_divider --  *	Draw a dividing line between the screens.  */
end_comment

begin_function
name|int
name|svi_divider
parameter_list|(
name|sp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
block|{
name|size_t
name|len
decl_stmt|;
define|#
directive|define
name|DIVIDESTR
value|"+=+=+=+=+=+=+=+"
name|len
operator|=
sizeof|sizeof
argument_list|(
name|DIVIDESTR
argument_list|)
operator|-
literal|1
operator|>
name|sp
operator|->
name|cols
condition|?
name|sp
operator|->
name|cols
else|:
sizeof|sizeof
argument_list|(
name|DIVIDESTR
argument_list|)
operator|-
literal|1
expr_stmt|;
name|ADDNSTR
argument_list|(
name|DIVIDESTR
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

