begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1992, 1993  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)exf.c	8.71 (Berkeley) 3/23/94"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_comment
comment|/*  * We include<sys/file.h>, because the flock(2) #defines were  * found there on historical systems.  We also include<fcntl.h>  * because the open(2) #defines are found there on newer systems.  */
end_comment

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<bitstring.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<termios.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<db.h>
end_include

begin_include
include|#
directive|include
file|<regex.h>
end_include

begin_include
include|#
directive|include
file|<pathnames.h>
end_include

begin_include
include|#
directive|include
file|"vi.h"
end_include

begin_include
include|#
directive|include
file|"excmd.h"
end_include

begin_comment
comment|/*  * file_add --  *	Insert a file name into the FREF list, if it doesn't already  *	appear in it.  *  * !!!  * The "if it doesn't already appear" changes vi's semantics slightly.  If  * you do a "vi foo bar", and then execute "next bar baz", the edit of bar  * will reflect the line/column of the previous edit session.  Historic nvi  * did not do this.  The change is a logical extension of the change where  * vi now remembers the last location in any file that it has ever edited,  * not just the previously edited file.  */
end_comment

begin_function
name|FREF
modifier|*
name|file_add
parameter_list|(
name|sp
parameter_list|,
name|frp_append
parameter_list|,
name|name
parameter_list|,
name|ignore
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|FREF
modifier|*
name|frp_append
decl_stmt|;
name|CHAR_T
modifier|*
name|name
decl_stmt|;
name|int
name|ignore
decl_stmt|;
block|{
name|FREF
modifier|*
name|frp
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
comment|/* 	 * Return it if it already exists.  Note that we test against the 	 * user's current name, whatever that happens to be, including if 	 * it's a temporary file.  If the user is trying to set an argument 	 * list, the ignore argument will be on -- if we're ignoring the 	 * file turn off the ignore bit, so it's back in the argument list. 	 */
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
for|for
control|(
name|frp
operator|=
name|sp
operator|->
name|frefq
operator|.
name|cqh_first
init|;
name|frp
operator|!=
operator|(
name|FREF
operator|*
operator|)
operator|&
name|sp
operator|->
name|frefq
condition|;
name|frp
operator|=
name|frp
operator|->
name|q
operator|.
name|cqe_next
control|)
if|if
condition|(
operator|(
name|p
operator|=
name|FILENAME
argument_list|(
name|frp
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|ignore
condition|)
name|F_CLR
argument_list|(
name|frp
argument_list|,
name|FR_IGNORE
argument_list|)
expr_stmt|;
return|return
operator|(
name|frp
operator|)
return|;
block|}
comment|/* Allocate and initialize the FREF structure. */
name|CALLOC
argument_list|(
name|sp
argument_list|,
name|frp
argument_list|,
name|FREF
operator|*
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|FREF
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|frp
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* 	 * If no file name specified, or if the file name is a request 	 * for something temporary, file_init() will allocate the file 	 * name.  Temporary files are always ignored. 	 */
define|#
directive|define
name|TEMPORARY_FILE_STRING
value|"/tmp"
if|if
condition|(
name|name
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
name|TEMPORARY_FILE_STRING
argument_list|)
operator|&&
operator|(
name|frp
operator|->
name|name
operator|=
name|strdup
argument_list|(
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|FREE
argument_list|(
name|frp
argument_list|,
sizeof|sizeof
argument_list|(
name|FREF
argument_list|)
argument_list|)
expr_stmt|;
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_SYSERR
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* Only the initial argument list is "remembered". */
if|if
condition|(
name|ignore
condition|)
name|F_SET
argument_list|(
name|frp
argument_list|,
name|FR_IGNORE
argument_list|)
expr_stmt|;
comment|/* Append into the chain of file names. */
if|if
condition|(
name|frp_append
operator|!=
name|NULL
condition|)
block|{
name|CIRCLEQ_INSERT_AFTER
argument_list|(
operator|&
name|sp
operator|->
name|frefq
argument_list|,
name|frp_append
argument_list|,
name|frp
argument_list|,
name|q
argument_list|)
expr_stmt|;
block|}
else|else
name|CIRCLEQ_INSERT_TAIL
argument_list|(
operator|&
name|sp
operator|->
name|frefq
argument_list|,
name|frp
argument_list|,
name|q
argument_list|)
expr_stmt|;
return|return
operator|(
name|frp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * file_first --  *	Return the first file name for editing, if any.  */
end_comment

begin_function
name|FREF
modifier|*
name|file_first
parameter_list|(
name|sp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
block|{
name|FREF
modifier|*
name|frp
decl_stmt|;
comment|/* Return the first file name. */
for|for
control|(
name|frp
operator|=
name|sp
operator|->
name|frefq
operator|.
name|cqh_first
init|;
name|frp
operator|!=
operator|(
name|FREF
operator|*
operator|)
operator|&
name|sp
operator|->
name|frefq
condition|;
name|frp
operator|=
name|frp
operator|->
name|q
operator|.
name|cqe_next
control|)
if|if
condition|(
operator|!
name|F_ISSET
argument_list|(
name|frp
argument_list|,
name|FR_IGNORE
argument_list|)
condition|)
return|return
operator|(
name|frp
operator|)
return|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * file_next --  *	Return the next file name, if any.  */
end_comment

begin_function
name|FREF
modifier|*
name|file_next
parameter_list|(
name|sp
parameter_list|,
name|frp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|FREF
modifier|*
name|frp
decl_stmt|;
block|{
while|while
condition|(
operator|(
name|frp
operator|=
name|frp
operator|->
name|q
operator|.
name|cqe_next
operator|)
operator|!=
operator|(
name|FREF
operator|*
operator|)
operator|&
name|sp
operator|->
name|frefq
condition|)
if|if
condition|(
operator|!
name|F_ISSET
argument_list|(
name|frp
argument_list|,
name|FR_IGNORE
argument_list|)
condition|)
return|return
operator|(
name|frp
operator|)
return|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * file_prev --  *	Return the previous file name, if any.  */
end_comment

begin_function
name|FREF
modifier|*
name|file_prev
parameter_list|(
name|sp
parameter_list|,
name|frp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|FREF
modifier|*
name|frp
decl_stmt|;
block|{
while|while
condition|(
operator|(
name|frp
operator|=
name|frp
operator|->
name|q
operator|.
name|cqe_prev
operator|)
operator|!=
operator|(
name|FREF
operator|*
operator|)
operator|&
name|sp
operator|->
name|frefq
condition|)
if|if
condition|(
operator|!
name|F_ISSET
argument_list|(
name|frp
argument_list|,
name|FR_IGNORE
argument_list|)
condition|)
return|return
operator|(
name|frp
operator|)
return|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * file_unedited --  *	Return if there are files that aren't ignored and are unedited.  */
end_comment

begin_function
name|FREF
modifier|*
name|file_unedited
parameter_list|(
name|sp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
block|{
name|FREF
modifier|*
name|frp
decl_stmt|;
comment|/* Return the next file name. */
for|for
control|(
name|frp
operator|=
name|sp
operator|->
name|frefq
operator|.
name|cqh_first
init|;
name|frp
operator|!=
operator|(
name|FREF
operator|*
operator|)
operator|&
name|sp
operator|->
name|frefq
condition|;
name|frp
operator|=
name|frp
operator|->
name|q
operator|.
name|cqe_next
control|)
if|if
condition|(
operator|!
name|F_ISSET
argument_list|(
name|frp
argument_list|,
name|FR_EDITED
operator||
name|FR_IGNORE
argument_list|)
condition|)
return|return
operator|(
name|frp
operator|)
return|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * file_init --  *	Start editing a file, based on the FREF structure.  If successsful,  *	let go of any previous file.  Don't release the previous file until  *	absolutely sure we have the new one.  */
end_comment

begin_function
name|int
name|file_init
parameter_list|(
name|sp
parameter_list|,
name|frp
parameter_list|,
name|rcv_name
parameter_list|,
name|force
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|FREF
modifier|*
name|frp
decl_stmt|;
name|char
modifier|*
name|rcv_name
decl_stmt|;
name|int
name|force
decl_stmt|;
block|{
name|EXF
modifier|*
name|ep
decl_stmt|;
name|RECNOINFO
name|oinfo
decl_stmt|;
name|struct
name|stat
name|sb
decl_stmt|;
name|size_t
name|psize
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|oname
decl_stmt|,
name|tname
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
comment|/* 	 * Required ep initialization: 	 *	Flush the line caches. 	 *	Default recover mail file fd to -1. 	 *	Set initial EXF flag bits. 	 */
name|CALLOC_RET
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|EXF
operator|*
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|EXF
argument_list|)
argument_list|)
expr_stmt|;
name|ep
operator|->
name|c_lno
operator|=
name|ep
operator|->
name|c_nlines
operator|=
name|OOBLNO
expr_stmt|;
name|ep
operator|->
name|rcv_fd
operator|=
operator|-
literal|1
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|ep
operator|->
name|marks
argument_list|)
expr_stmt|;
name|F_SET
argument_list|(
name|ep
argument_list|,
name|F_FIRSTMODIFY
argument_list|)
expr_stmt|;
comment|/* 	 * If no name or backing file, create a backing temporary file, saving 	 * the temp file name so can later unlink it.  Repoint the name to the 	 * temporary name (we display it to the user until they rename it). 	 * There are some games we play with the FR_FREE_TNAME and FR_NONAME 	 * flags (see ex/ex_file.c) to make sure that the temporary memory gets 	 * free'd up. 	 */
if|if
condition|(
operator|(
name|oname
operator|=
name|FILENAME
argument_list|(
name|frp
argument_list|)
operator|)
operator|==
name|NULL
operator|||
name|stat
argument_list|(
name|oname
argument_list|,
operator|&
name|sb
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|tname
argument_list|,
sizeof|sizeof
argument_list|(
name|tname
argument_list|)
argument_list|,
literal|"%s/vi.XXXXXX"
argument_list|,
name|O_STR
argument_list|(
name|sp
argument_list|,
name|O_DIRECTORY
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|mkstemp
argument_list|(
name|tname
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_SYSERR
argument_list|,
literal|"Temporary file"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|frp
operator|->
name|tname
operator|=
name|strdup
argument_list|(
name|tname
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_SYSERR
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|tname
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|oname
operator|=
name|frp
operator|->
name|tname
expr_stmt|;
name|psize
operator|=
literal|4
operator|*
literal|1024
expr_stmt|;
name|F_SET
argument_list|(
name|frp
argument_list|,
name|FR_NEWFILE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Try to keep it at 10 pages or less per file. */
if|if
condition|(
name|sb
operator|.
name|st_size
operator|<
literal|40
operator|*
literal|1024
condition|)
name|psize
operator|=
literal|4
operator|*
literal|1024
expr_stmt|;
elseif|else
if|if
condition|(
name|sb
operator|.
name|st_size
operator|<
literal|320
operator|*
literal|1024
condition|)
name|psize
operator|=
literal|32
operator|*
literal|1024
expr_stmt|;
else|else
name|psize
operator|=
literal|64
operator|*
literal|1024
expr_stmt|;
name|frp
operator|->
name|mtime
operator|=
name|sb
operator|.
name|st_mtime
expr_stmt|;
if|if
condition|(
operator|!
name|S_ISREG
argument_list|(
name|sb
operator|.
name|st_mode
argument_list|)
condition|)
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"Warning: %s is not a regular file."
argument_list|,
name|oname
argument_list|)
expr_stmt|;
block|}
comment|/* Set up recovery. */
name|memset
argument_list|(
operator|&
name|oinfo
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|RECNOINFO
argument_list|)
argument_list|)
expr_stmt|;
name|oinfo
operator|.
name|bval
operator|=
literal|'\n'
expr_stmt|;
comment|/* Always set. */
name|oinfo
operator|.
name|psize
operator|=
name|psize
expr_stmt|;
name|oinfo
operator|.
name|flags
operator|=
name|F_ISSET
argument_list|(
name|sp
operator|->
name|gp
argument_list|,
name|G_SNAPSHOT
argument_list|)
condition|?
name|R_SNAPSHOT
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|rcv_name
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|rcv_tmp
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|FILENAME
argument_list|(
name|frp
argument_list|)
argument_list|)
condition|)
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"Modifications not recoverable if the system crashes."
argument_list|)
expr_stmt|;
else|else
name|oinfo
operator|.
name|bfname
operator|=
name|ep
operator|->
name|rcv_path
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ep
operator|->
name|rcv_path
operator|=
name|strdup
argument_list|(
name|rcv_name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_SYSERR
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
else|else
block|{
name|oinfo
operator|.
name|bfname
operator|=
name|ep
operator|->
name|rcv_path
expr_stmt|;
name|F_SET
argument_list|(
name|ep
argument_list|,
name|F_MODIFIED
operator||
name|F_RCV_ON
argument_list|)
expr_stmt|;
block|}
comment|/* Open a db structure. */
if|if
condition|(
operator|(
name|ep
operator|->
name|db
operator|=
name|dbopen
argument_list|(
name|rcv_name
operator|==
name|NULL
condition|?
name|oname
else|:
name|NULL
argument_list|,
name|O_NONBLOCK
operator||
name|O_RDONLY
argument_list|,
name|DEFFILEMODE
argument_list|,
name|DB_RECNO
argument_list|,
operator|&
name|oinfo
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_SYSERR
argument_list|,
name|rcv_name
operator|==
name|NULL
condition|?
name|oname
else|:
name|rcv_name
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* Init file marks. */
if|if
condition|(
name|mark_init
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|)
condition|)
goto|goto
name|err
goto|;
comment|/* Start logging. */
if|if
condition|(
name|log_init
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|)
condition|)
goto|goto
name|err
goto|;
comment|/* 	 * The -R flag, or doing a "set readonly" during a session causes 	 * all files edited during the session (using an edit command, or 	 * even using tags) to be marked read-only.  Changing the file name 	 * (see ex/ex_file.c), clears this flag. 	 * 	 * Otherwise, try and figure out if a file is readonly.  This is a 	 * dangerous thing to do.  The kernel is the only arbiter of whether 	 * or not a file is writeable, and the best that a user program can 	 * do is guess.  Obvious loopholes are files that are on a file system 	 * mounted readonly (access catches this one on a few systems), or 	 * alternate protection mechanisms, ACL's for example, that we can't 	 * portably check.  Lots of fun, and only here because users whined. 	 * 	 * !!! 	 * Historic vi displayed the readonly message if none of the file 	 * write bits were set, or if an an access(2) call on the path 	 * failed.  This seems reasonable.  If the file is mode 444, root 	 * users may want to know that the owner of the file did not expect 	 * it to be written. 	 * 	 * Historic vi set the readonly bit if no write bits were set for 	 * a file, even if the access call would have succeeded.  This makes 	 * the superuser force the write even when vi expects that it will 	 * succeed.  I'm less supportive of this semantic, but it's historic 	 * practice and the conservative approach to vi'ing files as root. 	 * 	 * It would be nice if there was some way to update this when the user 	 * does a "^Z; chmod ...".  The problem is that we'd first have to 	 * distinguish between readonly bits set because of file permissions 	 * and those set for other reasons.  That's not too hard, but deciding 	 * when to reevaluate the permissions is trickier.  An alternative 	 * might be to turn off the readonly bit if the user forces a write 	 * and it succeeds. 	 * 	 * XXX 	 * Access(2) doesn't consider the effective uid/gid values.  This 	 * probably isn't a problem for vi when it's running standalone. 	 */
if|if
condition|(
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_READONLY
argument_list|)
operator|||
operator|!
name|F_ISSET
argument_list|(
name|frp
argument_list|,
name|FR_NEWFILE
argument_list|)
operator|&&
operator|(
operator|!
operator|(
name|sb
operator|.
name|st_mode
operator|&
operator|(
name|S_IWUSR
operator||
name|S_IWGRP
operator||
name|S_IWOTH
operator|)
operator|)
operator|||
name|access
argument_list|(
name|FILENAME
argument_list|(
name|frp
argument_list|)
argument_list|,
name|W_OK
argument_list|)
operator|)
condition|)
name|F_SET
argument_list|(
name|frp
argument_list|,
name|FR_RDONLY
argument_list|)
expr_stmt|;
else|else
name|F_CLR
argument_list|(
name|frp
argument_list|,
name|FR_RDONLY
argument_list|)
expr_stmt|;
comment|/* 	 * Close the previous file; if that fails, close the new one 	 * and run for the border. 	 */
if|if
condition|(
name|sp
operator|->
name|ep
operator|!=
name|NULL
operator|&&
name|file_end
argument_list|(
name|sp
argument_list|,
name|sp
operator|->
name|ep
argument_list|,
name|force
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|file_end
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* 	 * 4.4BSD supports locking in the open call, other systems don't. 	 * Since the user can't interrupt us between the open and here, 	 * it's a don't care. 	 * 	 * !!! 	 * We need to distinguish a lock not being available for the file 	 * from the file system not supporting locking.  Assume that EAGAIN 	 * or EWOULDBLOCK is the former.  There isn't a portable way to do 	 * this. 	 * 	 * XXX 	 * The locking is flock(2) style, not fcntl(2).  The latter is known 	 * to fail badly on some systems, and its only advantage is that it 	 * occasionally works over NFS. 	 */
if|if
condition|(
name|flock
argument_list|(
name|ep
operator|->
name|db
operator|->
name|fd
argument_list|(
name|ep
operator|->
name|db
argument_list|)
argument_list|,
name|LOCK_EX
operator||
name|LOCK_NB
argument_list|)
condition|)
if|if
condition|(
name|errno
operator|==
name|EAGAIN
operator|||
name|errno
operator|==
name|EWOULDBLOCK
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_INFO
argument_list|,
literal|"%s already locked, session is read-only"
argument_list|,
name|oname
argument_list|)
expr_stmt|;
name|F_SET
argument_list|(
name|frp
argument_list|,
name|FR_RDONLY
argument_list|)
expr_stmt|;
block|}
else|else
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_VINFO
argument_list|,
literal|"%s cannot be locked"
argument_list|,
name|oname
argument_list|)
expr_stmt|;
comment|/* 	 * Set the previous file pointer and the alternate file name to be 	 * the file we're about to discard. 	 * 	 * !!! 	 * If the current file was a temporary file, the call to file_end() 	 * unlinked it and free'd the name.  So, there is no previous file, 	 * and there is no alternate file name.  This matches historical 	 * practice, although in historical vi it could only happen as the 	 * result of the initial command, i.e. if vi was execute without a 	 * file name. 	 */
if|if
condition|(
name|sp
operator|->
name|frp
operator|!=
name|NULL
condition|)
block|{
name|p
operator|=
name|FILENAME
argument_list|(
name|sp
operator|->
name|frp
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|sp
operator|->
name|p_frp
operator|=
name|NULL
expr_stmt|;
else|else
name|sp
operator|->
name|p_frp
operator|=
name|sp
operator|->
name|frp
expr_stmt|;
name|set_alt_name
argument_list|(
name|sp
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
comment|/* The new file has now been officially edited. */
name|F_SET
argument_list|(
name|frp
argument_list|,
name|FR_EDITED
argument_list|)
expr_stmt|;
comment|/* Switch... */
operator|++
name|ep
operator|->
name|refcnt
expr_stmt|;
name|sp
operator|->
name|ep
operator|=
name|ep
expr_stmt|;
name|sp
operator|->
name|frp
operator|=
name|frp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|err
label|:
if|if
condition|(
name|frp
operator|->
name|tname
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|frp
operator|->
name|tname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|frp
operator|->
name|tname
argument_list|)
expr_stmt|;
name|frp
operator|->
name|tname
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ep
operator|->
name|rcv_path
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|ep
operator|->
name|rcv_path
argument_list|)
expr_stmt|;
name|ep
operator|->
name|rcv_path
operator|=
name|NULL
expr_stmt|;
block|}
name|FREE
argument_list|(
name|ep
argument_list|,
sizeof|sizeof
argument_list|(
name|EXF
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * file_end --  *	Stop editing a file.  */
end_comment

begin_function
name|int
name|file_end
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|,
name|force
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
name|int
name|force
decl_stmt|;
block|{
name|FREF
modifier|*
name|frp
decl_stmt|;
comment|/* 	 * 	 * sp->ep MAY NOT BE THE SAME AS THE ARGUMENT ep, SO DON'T USE IT! 	 * 	 * Save the cursor location. 	 * 	 * XXX 	 * It would be cleaner to do this somewhere else, but by the time 	 * ex or vi knows that we're changing files it's already happened. 	 */
name|frp
operator|=
name|sp
operator|->
name|frp
expr_stmt|;
name|frp
operator|->
name|lno
operator|=
name|sp
operator|->
name|lno
expr_stmt|;
name|frp
operator|->
name|cno
operator|=
name|sp
operator|->
name|cno
expr_stmt|;
name|F_SET
argument_list|(
name|frp
argument_list|,
name|FR_CURSORSET
argument_list|)
expr_stmt|;
comment|/* If multiply referenced, just decrement the count and return. */
if|if
condition|(
operator|--
name|ep
operator|->
name|refcnt
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Close the db structure. */
if|if
condition|(
name|ep
operator|->
name|db
operator|->
name|close
operator|!=
name|NULL
operator|&&
name|ep
operator|->
name|db
operator|->
name|close
argument_list|(
name|ep
operator|->
name|db
argument_list|)
operator|&&
operator|!
name|force
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"%s: close: %s"
argument_list|,
name|FILENAME
argument_list|(
name|frp
argument_list|)
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|ep
operator|->
name|refcnt
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* COMMITTED TO THE CLOSE.  THERE'S NO GOING BACK... */
comment|/* Stop logging. */
operator|(
name|void
operator|)
name|log_end
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|)
expr_stmt|;
comment|/* Free up any marks. */
name|mark_end
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|)
expr_stmt|;
comment|/* 	 * Delete the recovery files, close the open descriptor, 	 * free recovery memory. 	 */
if|if
condition|(
operator|!
name|F_ISSET
argument_list|(
name|ep
argument_list|,
name|F_RCV_NORM
argument_list|)
condition|)
block|{
if|if
condition|(
name|ep
operator|->
name|rcv_path
operator|!=
name|NULL
operator|&&
name|unlink
argument_list|(
name|ep
operator|->
name|rcv_path
argument_list|)
condition|)
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"%s: remove: %s"
argument_list|,
name|ep
operator|->
name|rcv_path
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|rcv_mpath
operator|!=
name|NULL
operator|&&
name|unlink
argument_list|(
name|ep
operator|->
name|rcv_mpath
argument_list|)
condition|)
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"%s: remove: %s"
argument_list|,
name|ep
operator|->
name|rcv_mpath
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ep
operator|->
name|rcv_fd
operator|!=
operator|-
literal|1
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|ep
operator|->
name|rcv_fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|rcv_path
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|ep
operator|->
name|rcv_path
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|rcv_mpath
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|ep
operator|->
name|rcv_mpath
argument_list|)
expr_stmt|;
comment|/* 	 * Unlink any temporary file, file name.  We also turn on the 	 * ignore bit at this point, because it was a "created" file, 	 * not an argument file. 	 */
if|if
condition|(
name|frp
operator|->
name|tname
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|unlink
argument_list|(
name|frp
operator|->
name|tname
argument_list|)
condition|)
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"%s: remove: %s"
argument_list|,
name|frp
operator|->
name|tname
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|frp
operator|->
name|tname
argument_list|)
expr_stmt|;
name|frp
operator|->
name|tname
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|frp
operator|->
name|name
operator|==
name|NULL
operator|&&
name|frp
operator|->
name|cname
operator|==
name|NULL
condition|)
name|F_SET
argument_list|(
name|frp
argument_list|,
name|FR_IGNORE
argument_list|)
expr_stmt|;
block|}
comment|/* Free the EXF structure. */
name|FREE
argument_list|(
name|ep
argument_list|,
sizeof|sizeof
argument_list|(
name|EXF
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * file_write --  *	Write the file to disk.  Historic vi had fairly convoluted  *	semantics for whether or not writes would happen.  That's  *	why all the flags.  */
end_comment

begin_function
name|int
name|file_write
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|,
name|fm
parameter_list|,
name|tm
parameter_list|,
name|name
parameter_list|,
name|flags
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
name|MARK
modifier|*
name|fm
decl_stmt|,
decl|*
name|tm
decl_stmt|;
end_function

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flags
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|stat
name|sb
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|FREF
modifier|*
name|frp
decl_stmt|;
name|MARK
name|from
decl_stmt|,
name|to
decl_stmt|;
name|u_long
name|nlno
decl_stmt|,
name|nch
decl_stmt|;
name|int
name|btear
decl_stmt|,
name|fd
decl_stmt|,
name|itear
decl_stmt|,
name|oflags
decl_stmt|,
name|rval
decl_stmt|;
name|char
modifier|*
name|msg
decl_stmt|;
comment|/* 	 * Don't permit writing to temporary files.  The problem is that 	 * if it's a temp file, and the user does ":wq", we write and quit, 	 * unlinking the temporary file.  Not what the user had in mind 	 * at all.  This test cannot be forced. 	 */
name|frp
operator|=
name|sp
operator|->
name|frp
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
operator|&&
name|frp
operator|->
name|cname
operator|==
name|NULL
operator|&&
name|frp
operator|->
name|name
operator|==
name|NULL
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"No filename to which to write."
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* Can't write files marked read-only, unless forced. */
if|if
condition|(
operator|!
name|LF_ISSET
argument_list|(
name|FS_FORCE
argument_list|)
operator|&&
name|name
operator|==
name|NULL
operator|&&
name|F_ISSET
argument_list|(
name|frp
argument_list|,
name|FR_RDONLY
argument_list|)
condition|)
block|{
if|if
condition|(
name|LF_ISSET
argument_list|(
name|FS_POSSIBLE
argument_list|)
condition|)
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"Read-only file, not written; use ! to override."
argument_list|)
expr_stmt|;
else|else
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"Read-only file, not written."
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* If not forced, not appending, and "writeany" not set ... */
if|if
condition|(
operator|!
name|LF_ISSET
argument_list|(
name|FS_FORCE
operator||
name|FS_APPEND
argument_list|)
operator|&&
operator|!
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_WRITEANY
argument_list|)
condition|)
block|{
comment|/* Don't overwrite anything but the original file. */
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|stat
argument_list|(
name|name
argument_list|,
operator|&
name|sb
argument_list|)
condition|)
goto|goto
name|exists
goto|;
block|}
elseif|else
if|if
condition|(
name|frp
operator|->
name|cname
operator|!=
name|NULL
operator|&&
operator|!
name|F_ISSET
argument_list|(
name|frp
argument_list|,
name|FR_CHANGEWRITE
argument_list|)
operator|&&
operator|!
name|stat
argument_list|(
name|frp
operator|->
name|cname
argument_list|,
operator|&
name|sb
argument_list|)
condition|)
block|{
name|name
operator|=
name|frp
operator|->
name|cname
expr_stmt|;
name|exists
label|:
if|if
condition|(
name|LF_ISSET
argument_list|(
name|FS_POSSIBLE
argument_list|)
condition|)
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"%s exists, not written; use ! to override."
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"%s exists, not written."
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 		 * Don't write part of any existing file.  Only test for the 		 * original file, the previous test catches anything else. 		 */
if|if
condition|(
operator|!
name|LF_ISSET
argument_list|(
name|FS_ALL
argument_list|)
operator|&&
name|name
operator|==
name|NULL
operator|&&
name|frp
operator|->
name|cname
operator|==
name|NULL
operator|&&
operator|!
name|stat
argument_list|(
name|frp
operator|->
name|name
argument_list|,
operator|&
name|sb
argument_list|)
condition|)
block|{
if|if
condition|(
name|LF_ISSET
argument_list|(
name|FS_POSSIBLE
argument_list|)
condition|)
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"Use ! to write a partial file."
argument_list|)
expr_stmt|;
else|else
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"Partial file, not written."
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
comment|/* 	 * Figure out if the file already exists -- if it doesn't, we display 	 * the "new file" message.  The stat might not be necessary, but we 	 * just repeat it because it's easier than hacking the previous tests. 	 * The information is only used for the user message and modification 	 * time test, so we can ignore the obvious race condition. 	 * 	 * If the user is overwriting a file other than the original file, and 	 * O_WRITEANY was what got us here (neither force nor append was set), 	 * display the "existing file" messsage.  Since the FR_CHANGEWRITE flag 	 * is set on a successful write, the message only appears once when the 	 * user changes a file name.  This is historic practice. 	 * 	 * One final test.  If we're not forcing or appending, and we have a 	 * saved modification time, stop the user if it's been written since 	 * we last edited or wrote it, and make them force it. 	 */
if|if
condition|(
name|stat
argument_list|(
name|name
operator|==
name|NULL
condition|?
name|FILENAME
argument_list|(
name|frp
argument_list|)
else|:
name|name
argument_list|,
operator|&
name|sb
argument_list|)
condition|)
name|msg
operator|=
literal|": new file"
expr_stmt|;
else|else
block|{
name|msg
operator|=
literal|""
expr_stmt|;
if|if
condition|(
operator|!
name|LF_ISSET
argument_list|(
name|FS_FORCE
operator||
name|FS_APPEND
argument_list|)
condition|)
block|{
if|if
condition|(
name|frp
operator|->
name|mtime
operator|&&
name|sb
operator|.
name|st_mtime
operator|>
name|frp
operator|->
name|mtime
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"%s: file modified more recently than this copy%s."
argument_list|,
name|name
operator|==
name|NULL
condition|?
name|frp
operator|->
name|name
else|:
name|name
argument_list|,
name|LF_ISSET
argument_list|(
name|FS_POSSIBLE
argument_list|)
condition|?
literal|"; use ! to override"
else|:
literal|""
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|name
operator|!=
name|NULL
operator|||
operator|!
name|F_ISSET
argument_list|(
name|frp
argument_list|,
name|FR_CHANGEWRITE
argument_list|)
operator|&&
name|frp
operator|->
name|cname
operator|!=
name|NULL
condition|)
name|msg
operator|=
literal|": existing file"
expr_stmt|;
block|}
block|}
comment|/* We no longer care where the name came from. */
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
name|name
operator|=
name|FILENAME
argument_list|(
name|frp
argument_list|)
expr_stmt|;
comment|/* Set flags to either append or truncate. */
name|oflags
operator|=
name|O_CREAT
operator||
name|O_WRONLY
expr_stmt|;
if|if
condition|(
name|LF_ISSET
argument_list|(
name|FS_APPEND
argument_list|)
condition|)
name|oflags
operator||=
name|O_APPEND
expr_stmt|;
else|else
name|oflags
operator||=
name|O_TRUNC
expr_stmt|;
comment|/* Open the file. */
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|name
argument_list|,
name|oflags
argument_list|,
name|DEFFILEMODE
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_SYSERR
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* Use stdio for buffering. */
if|if
condition|(
operator|(
name|fp
operator|=
name|fdopen
argument_list|(
name|fd
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_SYSERR
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* Build fake addresses, if necessary. */
if|if
condition|(
name|fm
operator|==
name|NULL
condition|)
block|{
name|from
operator|.
name|lno
operator|=
literal|1
expr_stmt|;
name|from
operator|.
name|cno
operator|=
literal|0
expr_stmt|;
name|fm
operator|=
operator|&
name|from
expr_stmt|;
if|if
condition|(
name|file_lline
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|to
operator|.
name|lno
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|to
operator|.
name|cno
operator|=
literal|0
expr_stmt|;
name|tm
operator|=
operator|&
name|to
expr_stmt|;
block|}
comment|/* Write the file, allowing interrupts. */
name|btear
operator|=
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|S_EXSILENT
argument_list|)
condition|?
literal|0
else|:
operator|!
name|busy_on
argument_list|(
name|sp
argument_list|,
literal|"Writing..."
argument_list|)
expr_stmt|;
name|itear
operator|=
operator|!
name|intr_init
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|rval
operator|=
name|ex_writefp
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|name
argument_list|,
name|fp
argument_list|,
name|fm
argument_list|,
name|tm
argument_list|,
operator|&
name|nlno
argument_list|,
operator|&
name|nch
argument_list|)
expr_stmt|;
if|if
condition|(
name|btear
condition|)
name|busy_off
argument_list|(
name|sp
argument_list|)
expr_stmt|;
if|if
condition|(
name|itear
condition|)
name|intr_end
argument_list|(
name|sp
argument_list|)
expr_stmt|;
comment|/* 	 * Save the new last modification time -- even if the write fails 	 * we re-init the time.  That way the user can clean up the disk 	 * and rewrite without having to force it. 	 */
name|frp
operator|->
name|mtime
operator|=
name|stat
argument_list|(
name|name
argument_list|,
operator|&
name|sb
argument_list|)
condition|?
literal|0
else|:
name|sb
operator|.
name|st_mtime
expr_stmt|;
comment|/* If the write failed, complain loudly. */
if|if
condition|(
name|rval
condition|)
block|{
if|if
condition|(
operator|!
name|LF_ISSET
argument_list|(
name|FS_APPEND
argument_list|)
condition|)
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"%s: WARNING: file truncated!"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * Once we've actually written the file, it doesn't matter that the 	 * file name was changed -- if it was, we've already whacked it. 	 */
name|F_SET
argument_list|(
name|frp
argument_list|,
name|FR_CHANGEWRITE
argument_list|)
expr_stmt|;
comment|/* If wrote the entire file, clear the modified bit. */
if|if
condition|(
name|LF_ISSET
argument_list|(
name|FS_ALL
argument_list|)
condition|)
name|F_CLR
argument_list|(
name|ep
argument_list|,
name|F_MODIFIED
argument_list|)
expr_stmt|;
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_INFO
argument_list|,
literal|"%s%s: %lu line%s, %lu characters."
argument_list|,
name|name
argument_list|,
name|msg
argument_list|,
name|nlno
argument_list|,
name|nlno
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|,
name|nch
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

end_unit

