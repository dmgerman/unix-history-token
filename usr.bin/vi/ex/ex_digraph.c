begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1992, 1993, 1994  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|sccsid
index|[]
init|=
literal|"@(#)ex_digraph.c	8.7 (Berkeley) 8/17/94"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NO_DIGRAPH
end_ifndef

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<bitstring.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<termios.h>
end_include

begin_include
include|#
directive|include
file|"compat.h"
end_include

begin_include
include|#
directive|include
file|<curses.h>
end_include

begin_include
include|#
directive|include
file|<db.h>
end_include

begin_include
include|#
directive|include
file|<regex.h>
end_include

begin_include
include|#
directive|include
file|"vi.h"
end_include

begin_include
include|#
directive|include
file|"excmd.h"
end_include

begin_decl_stmt
specifier|static
name|void
name|do_digraph
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|EXF
operator|*
operator|,
name|int
operator|,
name|u_char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This stuff is used to build the default digraphs table. */
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|digtable
index|[]
index|[
literal|4
index|]
init|=
block|{
ifdef|#
directive|ifdef
name|CS_IBMPC
literal|"C,\200"
block|,
literal|"u\"\1"
block|,
literal|"e'\2"
block|,
literal|"a^\3"
block|,
literal|"a\"\4"
block|,
literal|"a`\5"
block|,
literal|"a@\6"
block|,
literal|"c,\7"
block|,
literal|"e^\10"
block|,
literal|"e\"\211"
block|,
literal|"e`\12"
block|,
literal|"i\"\13"
block|,
literal|"i^\14"
block|,
literal|"i`\15"
block|,
literal|"A\"\16"
block|,
literal|"A@\17"
block|,
literal|"E'\20"
block|,
literal|"ae\21"
block|,
literal|"AE\22"
block|,
literal|"o^\23"
block|,
literal|"o\"\24"
block|,
literal|"o`\25"
block|,
literal|"u^\26"
block|,
literal|"u`\27"
block|,
literal|"y\"\30"
block|,
literal|"O\"\31"
block|,
literal|"U\"\32"
block|,
literal|"a'\240"
block|,
literal|"i'!"
block|,
literal|"o'\""
block|,
literal|"u'#"
block|,
literal|"n~$"
block|,
literal|"N~%"
block|,
literal|"a-&"
block|,
literal|"o-'"
block|,
literal|"~?("
block|,
literal|"~!-"
block|,
literal|"\"<."
block|,
literal|"\">/"
block|,
ifdef|#
directive|ifdef
name|CS_SPECIAL
literal|"2/+"
block|,
literal|"4/,"
block|,
literal|"^+;"
block|,
literal|"^q<"
block|,
literal|"^c="
block|,
literal|"^r>"
block|,
literal|"^t?"
block|,
literal|"pp]"
block|,
literal|"^^^"
block|,
literal|"oo_"
block|,
literal|"*a`"
block|,
literal|"*ba"
block|,
literal|"*pc"
block|,
literal|"*Sd"
block|,
literal|"*se"
block|,
literal|"*uf"
block|,
literal|"*tg"
block|,
literal|"*Ph"
block|,
literal|"*Ti"
block|,
literal|"*Oj"
block|,
literal|"*dk"
block|,
literal|"*Hl"
block|,
literal|"*hm"
block|,
literal|"*En"
block|,
literal|"*No"
block|,
literal|"eqp"
block|,
literal|"pmq"
block|,
literal|"ger"
block|,
literal|"les"
block|,
literal|"*It"
block|,
literal|"*iu"
block|,
literal|"*/v"
block|,
literal|"*=w"
block|,
literal|"sq{"
block|,
literal|"^n|"
block|,
literal|"^2}"
block|,
literal|"^3~"
block|,
literal|"^_\377"
block|,
endif|#
directive|endif
comment|/* CS_SPECIAL */
endif|#
directive|endif
comment|/* CS_IBMPC */
ifdef|#
directive|ifdef
name|CS_LATIN1
literal|"~!!"
block|,
literal|"a-*"
block|,
literal|"\">+"
block|,
literal|"o-:"
block|,
literal|"\"<>"
block|,
literal|"~??"
block|,
literal|"A`@"
block|,
literal|"A'A"
block|,
literal|"A^B"
block|,
literal|"A~C"
block|,
literal|"A\"D"
block|,
literal|"A@E"
block|,
literal|"AEF"
block|,
literal|"C,G"
block|,
literal|"E`H"
block|,
literal|"E'I"
block|,
literal|"E^J"
block|,
literal|"E\"K"
block|,
literal|"I`L"
block|,
literal|"I'M"
block|,
literal|"I^N"
block|,
literal|"I\"O"
block|,
literal|"-DP"
block|,
literal|"N~Q"
block|,
literal|"O`R"
block|,
literal|"O'S"
block|,
literal|"O^T"
block|,
literal|"O~U"
block|,
literal|"O\"V"
block|,
literal|"O/X"
block|,
literal|"U`Y"
block|,
literal|"U'Z"
block|,
literal|"U^["
block|,
literal|"U\"\\"
block|,
literal|"Y'_"
block|,
literal|"a``"
block|,
literal|"a'a"
block|,
literal|"a^b"
block|,
literal|"a~c"
block|,
literal|"a\"d"
block|,
literal|"a@e"
block|,
literal|"aef"
block|,
literal|"c,g"
block|,
literal|"e`h"
block|,
literal|"e'i"
block|,
literal|"e^j"
block|,
literal|"e\"k"
block|,
literal|"i`l"
block|,
literal|"i'm"
block|,
literal|"i^n"
block|,
literal|"i\"o"
block|,
literal|"-dp"
block|,
literal|"n~q"
block|,
literal|"o`r"
block|,
literal|"o's"
block|,
literal|"o^t"
block|,
literal|"o~u"
block|,
literal|"o\"v"
block|,
literal|"o/x"
block|,
literal|"u`y"
block|,
literal|"u'z"
block|,
literal|"u^{"
block|,
literal|"u\"|"
block|,
literal|"y'~"
block|,
endif|#
directive|endif
comment|/* CS_LATIN1 */
literal|""
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|digraph_init
parameter_list|(
name|sp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|*
name|digtable
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
name|do_digraph
argument_list|(
name|sp
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|digtable
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|do_digraph
argument_list|(
name|sp
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ex_digraph
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|,
name|cmdp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
name|EXCMDARG
modifier|*
name|cmdp
decl_stmt|;
block|{
name|do_digraph
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|F_ISSET
argument_list|(
name|cmdp
argument_list|,
name|E_FORCE
argument_list|)
argument_list|,
name|cmdp
operator|->
name|argv
index|[
literal|0
index|]
operator|->
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_struct
specifier|static
struct|struct
name|_DIG
block|{
name|struct
name|_DIG
modifier|*
name|next
decl_stmt|;
name|char
name|key1
decl_stmt|;
name|char
name|key2
decl_stmt|;
name|char
name|dig
decl_stmt|;
name|char
name|save
decl_stmt|;
block|}
modifier|*
name|digs
struct|;
end_struct

begin_function
name|int
name|digraph
parameter_list|(
name|sp
parameter_list|,
name|key1
parameter_list|,
name|key2
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|char
name|key1
decl_stmt|;
comment|/* the underlying character */
name|char
name|key2
decl_stmt|;
comment|/* the second character */
block|{
name|int
name|new_key
decl_stmt|;
specifier|register
name|struct
name|_DIG
modifier|*
name|dp
decl_stmt|;
comment|/* if digraphs are disabled, then just return the new char */
if|if
condition|(
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_DIGRAPH
argument_list|)
condition|)
block|{
return|return
name|key2
return|;
block|}
comment|/* remember the new key, so we can return it if this isn't a digraph */
name|new_key
operator|=
name|key2
expr_stmt|;
comment|/* sort key1 and key2, so that their original order won't matter */
if|if
condition|(
name|key1
operator|>
name|key2
condition|)
block|{
name|key2
operator|=
name|key1
expr_stmt|;
name|key1
operator|=
name|new_key
expr_stmt|;
block|}
comment|/* scan through the digraph chart */
for|for
control|(
name|dp
operator|=
name|digs
init|;
name|dp
operator|&&
operator|(
name|dp
operator|->
name|key1
operator|!=
name|key1
operator|||
name|dp
operator|->
name|key2
operator|!=
name|key2
operator|)
condition|;
name|dp
operator|=
name|dp
operator|->
name|next
control|)
block|{ 	}
comment|/* if this combination isn't in there, just use the new key */
if|if
condition|(
operator|!
name|dp
condition|)
block|{
return|return
name|new_key
return|;
block|}
comment|/* else use the digraph key */
return|return
name|dp
operator|->
name|dig
return|;
block|}
end_function

begin_comment
comment|/* this function lists or defines digraphs */
end_comment

begin_function
specifier|static
name|void
name|do_digraph
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|,
name|bang
parameter_list|,
name|extra
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
name|int
name|bang
decl_stmt|;
name|u_char
modifier|*
name|extra
decl_stmt|;
block|{
name|int
name|dig
decl_stmt|;
specifier|register
name|struct
name|_DIG
modifier|*
name|dp
decl_stmt|;
name|struct
name|_DIG
modifier|*
name|prev
decl_stmt|;
specifier|static
name|int
name|user_defined
init|=
literal|0
decl_stmt|;
comment|/* boolean: are all later digraphs user-defined? */
name|char
name|listbuf
index|[
literal|8
index|]
decl_stmt|;
comment|/* if "extra" is NULL, then we've reached the end of the built-ins */
if|if
condition|(
operator|!
name|extra
condition|)
block|{
name|user_defined
operator|=
literal|1
expr_stmt|;
return|return;
block|}
comment|/* if no args, then display the existing digraphs */
if|if
condition|(
operator|*
name|extra
operator|<
literal|' '
condition|)
block|{
name|listbuf
index|[
literal|0
index|]
operator|=
name|listbuf
index|[
literal|1
index|]
operator|=
name|listbuf
index|[
literal|2
index|]
operator|=
name|listbuf
index|[
literal|5
index|]
operator|=
literal|' '
expr_stmt|;
name|listbuf
index|[
literal|7
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|dig
operator|=
literal|0
operator|,
name|dp
operator|=
name|digs
init|;
name|dp
condition|;
name|dp
operator|=
name|dp
operator|->
name|next
control|)
block|{
if|if
condition|(
name|dp
operator|->
name|save
operator|||
name|bang
condition|)
block|{
name|dig
operator|+=
literal|7
expr_stmt|;
if|if
condition|(
name|dig
operator|>=
name|sp
operator|->
name|cno
condition|)
block|{
name|addch
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
name|dig
operator|=
literal|7
expr_stmt|;
block|}
name|listbuf
index|[
literal|3
index|]
operator|=
name|dp
operator|->
name|key1
expr_stmt|;
name|listbuf
index|[
literal|4
index|]
operator|=
name|dp
operator|->
name|key2
expr_stmt|;
name|listbuf
index|[
literal|6
index|]
operator|=
name|dp
operator|->
name|dig
expr_stmt|;
name|addstr
argument_list|(
name|listbuf
argument_list|)
expr_stmt|;
block|}
block|}
name|addch
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* make sure we have at least two characters */
if|if
condition|(
operator|!
name|extra
index|[
literal|1
index|]
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"Digraphs must be composed of two characters"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* sort key1 and key2, so that their original order won't matter */
if|if
condition|(
name|extra
index|[
literal|0
index|]
operator|>
name|extra
index|[
literal|1
index|]
condition|)
block|{
name|dig
operator|=
name|extra
index|[
literal|0
index|]
expr_stmt|;
name|extra
index|[
literal|0
index|]
operator|=
name|extra
index|[
literal|1
index|]
expr_stmt|;
name|extra
index|[
literal|1
index|]
operator|=
name|dig
expr_stmt|;
block|}
comment|/* locate the new digraph character */
for|for
control|(
name|dig
operator|=
literal|2
init|;
name|extra
index|[
name|dig
index|]
operator|==
literal|' '
operator|||
name|extra
index|[
name|dig
index|]
operator|==
literal|'\t'
condition|;
name|dig
operator|++
control|)
block|{ 	}
name|dig
operator|=
name|extra
index|[
name|dig
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|bang
operator|&&
name|dig
condition|)
block|{
name|dig
operator||=
literal|0x80
expr_stmt|;
block|}
comment|/* search for the digraph */
for|for
control|(
name|prev
operator|=
operator|(
expr|struct
name|_DIG
operator|*
operator|)
literal|0
operator|,
name|dp
operator|=
name|digs
init|;
name|dp
operator|&&
operator|(
name|dp
operator|->
name|key1
operator|!=
name|extra
index|[
literal|0
index|]
operator|||
name|dp
operator|->
name|key2
operator|!=
name|extra
index|[
literal|1
index|]
operator|)
condition|;
name|prev
operator|=
name|dp
operator|,
name|dp
operator|=
name|dp
operator|->
name|next
control|)
block|{ 	}
comment|/* deleting the digraph? */
if|if
condition|(
operator|!
name|dig
condition|)
block|{
if|if
condition|(
operator|!
name|dp
condition|)
block|{
ifndef|#
directive|ifndef
name|CRUNCH
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"%c%c not a digraph"
argument_list|,
name|extra
index|[
literal|0
index|]
argument_list|,
name|extra
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
if|if
condition|(
name|prev
condition|)
name|prev
operator|->
name|next
operator|=
name|dp
operator|->
name|next
expr_stmt|;
else|else
name|digs
operator|=
name|dp
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|dp
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* if necessary, create a new digraph struct for the new digraph */
if|if
condition|(
name|dig
operator|&&
operator|!
name|dp
condition|)
block|{
name|MALLOC
argument_list|(
name|sp
argument_list|,
name|dp
argument_list|,
expr|struct
name|_DIG
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|_DIG
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|prev
condition|)
name|prev
operator|->
name|next
operator|=
name|dp
expr_stmt|;
else|else
name|digs
operator|=
name|dp
expr_stmt|;
name|dp
operator|->
name|next
operator|=
operator|(
expr|struct
name|_DIG
operator|*
operator|)
literal|0
expr_stmt|;
block|}
comment|/* assign it the new digraph value */
name|dp
operator|->
name|key1
operator|=
name|extra
index|[
literal|0
index|]
expr_stmt|;
name|dp
operator|->
name|key2
operator|=
name|extra
index|[
literal|1
index|]
expr_stmt|;
name|dp
operator|->
name|dig
operator|=
name|dig
expr_stmt|;
name|dp
operator|->
name|save
operator|=
name|user_defined
expr_stmt|;
block|}
end_function

begin_function
name|void
name|digraph_save
parameter_list|(
name|sp
parameter_list|,
name|fd
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|int
name|fd
decl_stmt|;
block|{
specifier|static
name|char
name|buf
index|[]
init|=
literal|"digraph! XX Y\n"
decl_stmt|;
specifier|register
name|struct
name|_DIG
modifier|*
name|dp
decl_stmt|;
for|for
control|(
name|dp
operator|=
name|digs
init|;
name|dp
condition|;
name|dp
operator|=
name|dp
operator|->
name|next
control|)
block|{
if|if
condition|(
name|dp
operator|->
name|save
condition|)
block|{
name|buf
index|[
literal|9
index|]
operator|=
name|dp
operator|->
name|key1
expr_stmt|;
name|buf
index|[
literal|10
index|]
operator|=
name|dp
operator|->
name|key2
expr_stmt|;
name|buf
index|[
literal|12
index|]
operator|=
name|dp
operator|->
name|dig
expr_stmt|;
name|write
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
operator|(
name|unsigned
operator|)
literal|14
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

