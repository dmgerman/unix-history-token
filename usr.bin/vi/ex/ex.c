begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1992, 1993, 1994  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|sccsid
index|[]
init|=
literal|"@(#)ex.c	8.156 (Berkeley) 8/17/94"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<bitstring.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<termios.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"compat.h"
end_include

begin_include
include|#
directive|include
file|<db.h>
end_include

begin_include
include|#
directive|include
file|<regex.h>
end_include

begin_include
include|#
directive|include
file|"vi.h"
end_include

begin_include
include|#
directive|include
file|"excmd.h"
end_include

begin_decl_stmt
specifier|static
name|void
name|badlno
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|recno_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|__inline
name|EXCMDLIST
specifier|const
modifier|*
name|ex_comm_search
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ep_line
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|EXF
operator|*
operator|,
name|MARK
operator|*
operator|,
name|char
operator|*
operator|*
operator|,
name|size_t
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ep_range
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|EXF
operator|*
operator|,
name|EXCMDARG
operator|*
operator|,
name|char
operator|*
operator|*
operator|,
name|size_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * ex --  *	Read an ex command and execute it.  */
end_comment

begin_function
name|int
name|ex
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
block|{
name|enum
name|input
name|irval
decl_stmt|;
name|TEXT
modifier|*
name|tp
decl_stmt|;
name|u_int
name|flags
decl_stmt|,
name|saved_mode
decl_stmt|;
name|int
name|eval
decl_stmt|;
if|if
condition|(
name|ex_init
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|sp
operator|->
name|s_refresh
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|)
condition|)
return|return
operator|(
name|ex_end
argument_list|(
name|sp
argument_list|)
operator|)
return|;
comment|/* If reading from a file, messages should have line info. */
if|if
condition|(
operator|!
name|F_ISSET
argument_list|(
name|sp
operator|->
name|gp
argument_list|,
name|G_STDIN_TTY
argument_list|)
condition|)
block|{
name|sp
operator|->
name|if_lno
operator|=
literal|1
expr_stmt|;
name|sp
operator|->
name|if_name
operator|=
name|strdup
argument_list|(
literal|"input"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * !!! 	 * Historically, the beautify option applies to ex command input read 	 * from a file.  In addition, the first time a ^H was discarded from 	 * the input, a message "^H discarded" was displayed.  We don't bother. 	 */
name|LF_INIT
argument_list|(
name|TXT_BACKSLASH
operator||
name|TXT_CNTRLD
operator||
name|TXT_CR
operator||
name|TXT_EXSUSPEND
argument_list|)
expr_stmt|;
for|for
control|(
name|eval
operator|=
literal|0
init|;
condition|;
operator|++
name|sp
operator|->
name|if_lno
control|)
block|{
comment|/* Set the flags that the user can change. */
if|if
condition|(
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_BEAUTIFY
argument_list|)
condition|)
name|LF_SET
argument_list|(
name|TXT_BEAUTIFY
argument_list|)
expr_stmt|;
else|else
name|LF_CLR
argument_list|(
name|TXT_BEAUTIFY
argument_list|)
expr_stmt|;
if|if
condition|(
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_PROMPT
argument_list|)
condition|)
name|LF_SET
argument_list|(
name|TXT_PROMPT
argument_list|)
expr_stmt|;
else|else
name|LF_CLR
argument_list|(
name|TXT_PROMPT
argument_list|)
expr_stmt|;
comment|/* 		 * Get the next command.  Interrupt flag manipulation is 		 * safe because ex_icmd clears them all. 		 */
name|CLR_INTERRUPT
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|F_SET
argument_list|(
name|sp
argument_list|,
name|S_INTERRUPTIBLE
argument_list|)
expr_stmt|;
name|irval
operator|=
name|sp
operator|->
name|s_get
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|sp
operator|->
name|tiqp
argument_list|,
literal|':'
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|INTERRUPTED
argument_list|(
name|sp
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
goto|goto
name|refresh
goto|;
block|}
switch|switch
condition|(
name|irval
condition|)
block|{
case|case
name|INP_OK
case|:
break|break;
case|case
name|INP_EOF
case|:
case|case
name|INP_ERR
case|:
name|F_SET
argument_list|(
name|sp
argument_list|,
name|S_EXIT_FORCE
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|INP_INTR
case|:
goto|goto
name|ret
goto|;
block|}
comment|/* 		 * If the user entered a carriage return, send ex_cmd() 		 * a separator -- it discards single newlines. 		 */
name|tp
operator|=
name|sp
operator|->
name|tiqp
operator|->
name|cqh_first
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|len
operator|==
literal|0
condition|)
block|{
name|tp
operator|->
name|len
operator|=
literal|1
expr_stmt|;
name|tp
operator|->
name|lb
index|[
literal|0
index|]
operator|=
literal|' '
expr_stmt|;
block|}
name|saved_mode
operator|=
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|S_SCREENS
operator||
name|S_MAJOR_CHANGE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ex_icmd
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|tp
operator|->
name|lb
argument_list|,
name|tp
operator|->
name|len
argument_list|,
literal|1
argument_list|)
operator|&&
operator|!
name|F_ISSET
argument_list|(
name|sp
operator|->
name|gp
argument_list|,
name|G_STDIN_TTY
argument_list|)
condition|)
name|F_SET
argument_list|(
name|sp
argument_list|,
name|S_EXIT_FORCE
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|msg_rpt
argument_list|(
name|sp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|saved_mode
operator|!=
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|S_SCREENS
operator||
name|S_MAJOR_CHANGE
argument_list|)
condition|)
break|break;
name|refresh
label|:
if|if
condition|(
name|sp
operator|->
name|s_refresh
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|)
condition|)
block|{
name|eval
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
name|ret
label|:
if|if
condition|(
name|sp
operator|->
name|if_name
operator|!=
name|NULL
condition|)
block|{
name|FREE
argument_list|(
name|sp
operator|->
name|if_name
argument_list|,
name|strlen
argument_list|(
name|sp
operator|->
name|if_name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sp
operator|->
name|if_name
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|ex_end
argument_list|(
name|sp
argument_list|)
operator|||
name|eval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ex_cfile --  *	Execute ex commands from a file.  */
end_comment

begin_function
name|int
name|ex_cfile
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|,
name|filename
parameter_list|,
name|needsep
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|needsep
decl_stmt|;
block|{
name|struct
name|stat
name|sb
decl_stmt|;
name|int
name|fd
decl_stmt|,
name|len
decl_stmt|,
name|rval
decl_stmt|;
name|char
modifier|*
name|bp
decl_stmt|;
name|bp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|filename
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
operator|||
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|sb
argument_list|)
condition|)
goto|goto
name|err
goto|;
comment|/* 	 * XXX 	 * We'd like to test if the file is too big to malloc.  Since we don't 	 * know what size or type off_t's or size_t's are, what the largest 	 * unsigned integral type is, or what random insanity the local C 	 * compiler will perpetrate, doing the comparison in a portable way 	 * is flatly impossible.  Hope that malloc fails if the file is too 	 * large. 	 */
name|MALLOC
argument_list|(
name|sp
argument_list|,
name|bp
argument_list|,
name|char
operator|*
argument_list|,
operator|(
name|size_t
operator|)
name|sb
operator|.
name|st_size
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
name|len
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|bp
argument_list|,
operator|(
name|int
operator|)
name|sb
operator|.
name|st_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
operator|-
literal|1
operator|||
name|len
operator|!=
name|sb
operator|.
name|st_size
condition|)
block|{
if|if
condition|(
name|len
operator|!=
name|sb
operator|.
name|st_size
condition|)
name|errno
operator|=
name|EIO
expr_stmt|;
name|err
label|:
name|rval
operator|=
literal|1
expr_stmt|;
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_SYSERR
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bp
index|[
name|sb
operator|.
name|st_size
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* XXX */
comment|/* 		 * Run the command.  Messages include file/line information, 		 * but we don't care if we can't get space. 		 */
name|sp
operator|->
name|if_lno
operator|=
literal|1
expr_stmt|;
name|sp
operator|->
name|if_name
operator|=
name|strdup
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|F_SET
argument_list|(
name|sp
argument_list|,
name|S_VLITONLY
argument_list|)
expr_stmt|;
name|rval
operator|=
name|ex_icmd
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|bp
argument_list|,
name|len
argument_list|,
name|needsep
argument_list|)
expr_stmt|;
name|F_CLR
argument_list|(
name|sp
argument_list|,
name|S_VLITONLY
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sp
operator|->
name|if_name
argument_list|)
expr_stmt|;
name|sp
operator|->
name|if_name
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * !!! 	 * THE UNDERLYING EXF MAY HAVE CHANGED. 	 */
if|if
condition|(
name|bp
operator|!=
name|NULL
condition|)
name|FREE
argument_list|(
name|bp
argument_list|,
name|sb
operator|.
name|st_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|>=
literal|0
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
name|rval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ex_icmd --  *	Call ex_cmd() after turning off interruptible bits.  */
end_comment

begin_function
name|int
name|ex_icmd
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|,
name|cmd
parameter_list|,
name|len
parameter_list|,
name|needsep
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
name|char
modifier|*
name|cmd
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|int
name|needsep
decl_stmt|;
block|{
comment|/* 	 * Ex goes through here for each vi :colon command and for each ex 	 * command, however, globally executed commands don't go through 	 * here, instead, they call ex_cmd directly.  So, reset all of the 	 * interruptible flags now. 	 * 	 * !!! 	 * Previous versions of nvi cleared mapped characters on error.  This 	 * feature was removed when users complained that it wasn't historic 	 * practice. 	 */
name|CLR_INTERRUPT
argument_list|(
name|sp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ex_cmd
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|cmd
argument_list|,
name|len
argument_list|,
name|needsep
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Special command structure for :s as a repeat substitution command. */
end_comment

begin_decl_stmt
specifier|static
name|EXCMDLIST
specifier|const
name|cmd_subagain
init|=
block|{
literal|"s"
block|,
name|ex_subagain
block|,
name|E_ADDR2
operator||
name|E_NORC
block|,
literal|"s"
block|,
literal|"[line [,line]] s [cgr] [count] [#lp]"
block|,
literal|"repeat the last subsitution"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Special command structure for :d[flags]. */
end_comment

begin_decl_stmt
specifier|static
name|EXCMDLIST
specifier|const
name|cmd_del2
init|=
block|{
literal|"delete"
block|,
name|ex_delete
block|,
name|E_ADDR2
operator||
name|E_AUTOPRINT
operator||
name|E_NORC
block|,
literal|"1bca1"
block|,
literal|"[line [,line]] d[elete][flags] [buffer] [count] [flags]"
block|,
literal|"delete lines from the file"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * ex_cmd --  *	Parse and execute a string containing ex commands.  */
end_comment

begin_function
name|int
name|ex_cmd
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|,
name|cmd
parameter_list|,
name|cmdlen
parameter_list|,
name|needsep
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
name|char
modifier|*
name|cmd
decl_stmt|;
name|size_t
name|cmdlen
decl_stmt|;
name|int
name|needsep
decl_stmt|;
block|{
enum|enum
block|{
name|NOTSET
block|,
name|NEEDSEP_N
block|,
name|NEEDSEP_NR
block|,
name|NONE
block|}
name|sep
enum|;
name|EX_PRIVATE
modifier|*
name|exp
decl_stmt|;
name|EXCMDARG
name|exc
decl_stmt|;
name|EXCMDLIST
specifier|const
modifier|*
name|cp
decl_stmt|;
name|MARK
name|cur
decl_stmt|;
name|recno_t
name|lno
decl_stmt|,
name|num
decl_stmt|;
name|size_t
name|arg1_len
decl_stmt|,
name|len
decl_stmt|,
name|save_cmdlen
decl_stmt|;
name|long
name|flagoff
decl_stmt|;
name|u_int
name|saved_mode
decl_stmt|;
name|int
name|blank
decl_stmt|,
name|ch
decl_stmt|,
name|cnt
decl_stmt|,
name|delim
decl_stmt|,
name|flags
decl_stmt|,
name|namelen
decl_stmt|,
name|nl
decl_stmt|;
name|int
name|optnum
decl_stmt|,
name|uselastcmd
decl_stmt|,
name|tmp
decl_stmt|,
name|vi_address
decl_stmt|;
name|char
modifier|*
name|arg1
decl_stmt|,
modifier|*
name|save_cmd
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|s
decl_stmt|,
modifier|*
name|t
decl_stmt|;
comment|/* Init. */
name|nl
operator|=
literal|0
expr_stmt|;
name|sep
operator|=
name|needsep
condition|?
name|NOTSET
else|:
name|NONE
expr_stmt|;
name|loop
label|:
if|if
condition|(
name|nl
condition|)
block|{
name|nl
operator|=
literal|0
expr_stmt|;
operator|++
name|sp
operator|->
name|if_lno
expr_stmt|;
block|}
name|arg1
operator|=
name|NULL
expr_stmt|;
name|save_cmdlen
operator|=
literal|0
expr_stmt|;
comment|/* It's possible that we've been interrupted during a command. */
if|if
condition|(
name|INTERRUPTED
argument_list|(
name|sp
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Skip<blank>s, empty lines.  */
for|for
control|(
name|blank
operator|=
literal|0
init|;
name|cmdlen
operator|>
literal|0
condition|;
operator|++
name|cmd
operator|,
operator|--
name|cmdlen
control|)
if|if
condition|(
operator|(
name|ch
operator|=
operator|*
name|cmd
operator|)
operator|==
literal|'\n'
condition|)
operator|++
name|sp
operator|->
name|if_lno
expr_stmt|;
elseif|else
if|if
condition|(
name|isblank
argument_list|(
name|ch
argument_list|)
condition|)
name|blank
operator|=
literal|1
expr_stmt|;
else|else
break|break;
comment|/* 	 * !!! 	 * Permit extra colons at the start of the line.  Historically, 	 * ex/vi allowed a single extra one.  It's simpler not to count. 	 * The stripping is done here because, historically, any command 	 * could have preceding colons, e.g. ":g/pattern/:p" worked. 	 */
if|if
condition|(
name|cmdlen
operator|!=
literal|0
operator|&&
name|ch
operator|==
literal|':'
condition|)
block|{
if|if
condition|(
name|sep
operator|==
name|NOTSET
condition|)
name|sep
operator|=
name|NEEDSEP_N
expr_stmt|;
while|while
condition|(
operator|--
name|cmdlen
operator|>
literal|0
operator|&&
operator|(
name|ch
operator|=
operator|*
operator|++
name|cmd
operator|)
operator|==
literal|':'
condition|)
empty_stmt|;
block|}
comment|/* 	 * Command lines that start with a double-quote are comments. 	 * 	 * !!! 	 * Historically, there was no escape or delimiter for a comment, 	 * e.g. :"foo|set was a single comment and nothing was output. 	 * Since nvi permits users to escape<newline> characters into 	 * command lines, we have to check for that case. 	 */
if|if
condition|(
name|cmdlen
operator|!=
literal|0
operator|&&
name|ch
operator|==
literal|'"'
condition|)
block|{
while|while
condition|(
operator|--
name|cmdlen
operator|>
literal|0
operator|&&
operator|*
operator|++
name|cmd
operator|!=
literal|'\n'
condition|)
empty_stmt|;
if|if
condition|(
operator|*
name|cmd
operator|==
literal|'\n'
condition|)
block|{
name|nl
operator|=
literal|1
expr_stmt|;
operator|++
name|cmd
expr_stmt|;
operator|--
name|cmdlen
expr_stmt|;
block|}
goto|goto
name|loop
goto|;
block|}
comment|/* Skip whitespace. */
for|for
control|(
init|;
name|cmdlen
operator|>
literal|0
condition|;
operator|++
name|cmd
operator|,
operator|--
name|cmdlen
control|)
block|{
name|ch
operator|=
operator|*
name|cmd
expr_stmt|;
if|if
condition|(
operator|!
name|isblank
argument_list|(
name|ch
argument_list|)
condition|)
break|break;
block|}
comment|/* 	 * The last point at which an empty line can mean do nothing. 	 * 	 * !!! 	 * Historically, in ex mode, lines containing only<blank> characters 	 * were the same as a single<carriage-return>, i.e. a default command. 	 * In vi mode, they were ignored. 	 * 	 * In .exrc files this was a serious annoyance, as vi kept trying to 	 * treat them as print commands.  We ignore backward compatibility in 	 * this case, and discard lines containing only<blank> characters from 	 * .exrc files. 	 */
if|if
condition|(
name|cmdlen
operator|==
literal|0
operator|&&
operator|(
operator|!
name|IN_EX_MODE
argument_list|(
name|sp
argument_list|)
operator|||
name|ep
operator|==
name|NULL
operator|||
operator|!
name|blank
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Initialize the structure passed to underlying functions. */
name|memset
argument_list|(
operator|&
name|exc
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|EXCMDARG
argument_list|)
argument_list|)
expr_stmt|;
name|exp
operator|=
name|EXP
argument_list|(
name|sp
argument_list|)
expr_stmt|;
if|if
condition|(
name|argv_init
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|exc
argument_list|)
condition|)
goto|goto
name|err
goto|;
comment|/* 	 * Check to see if this is a command for which we may want to output 	 * a \r separator instead of a \n.  (The command :1<CR> puts out a \n, 	 * but the command :<CR> puts out a \r.)  If the line is empty except 	 * for<blank>s,<carriage-return> or<eof>, we'll probably want to 	 * output \r.  I don't think there's any way to get<blank> characters 	 * *after* the command character, but this is the ex parser, and I've 	 * been wrong before. 	 */
if|if
condition|(
name|sep
operator|==
name|NOTSET
condition|)
name|sep
operator|=
name|cmdlen
operator|==
literal|0
operator|||
name|cmdlen
operator|==
literal|1
operator|&&
name|cmd
index|[
literal|0
index|]
operator|==
literal|'\004'
condition|?
name|NEEDSEP_NR
else|:
name|NEEDSEP_N
expr_stmt|;
comment|/* Parse command addresses. */
if|if
condition|(
name|ep_range
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|exc
argument_list|,
operator|&
name|cmd
argument_list|,
operator|&
name|cmdlen
argument_list|)
condition|)
goto|goto
name|err
goto|;
comment|/* Skip whitespace. */
for|for
control|(
init|;
name|cmdlen
operator|>
literal|0
condition|;
operator|++
name|cmd
operator|,
operator|--
name|cmdlen
control|)
block|{
name|ch
operator|=
operator|*
name|cmd
expr_stmt|;
if|if
condition|(
operator|!
name|isblank
argument_list|(
name|ch
argument_list|)
condition|)
break|break;
block|}
comment|/* 	 * If no command, ex does the last specified of p, l, or #, and vi 	 * moves to the line.  Otherwise, determine the length of the command 	 * name by looking for the first non-alphabetic character.  (There 	 * are a few non-alphabetic characters in command names, but they're 	 * all single character commands.)  This isn't a great test, because 	 * it means that, for the command ":e +cut.c file", we'll report that 	 * the command "cut" wasn't known.  However, it makes ":e+35 file" work 	 * correctly. 	 * 	 * !!! 	 * Historically, lines with multiple adjacent (or<blank> separated) 	 * command separators were very strange.  For example, the command 	 * |||<carriage-return>, when the cursor was on line 1, displayed 	 * lines 2, 3 and 5 of the file.  In addition, the command "   |  " 	 * would only display the line after the next line, instead of the 	 * next two lines.  No ideas why.  It worked reasonably when executed 	 * from vi mode, and displayed lines 2, 3, and 4, so we do a default 	 * command for each separator. 	 */
define|#
directive|define
name|SINGLE_CHAR_COMMANDS
value|"\004!#&*<=>@~"
if|if
condition|(
name|cmdlen
operator|!=
literal|0
operator|&&
name|cmd
index|[
literal|0
index|]
operator|!=
literal|'|'
operator|&&
name|cmd
index|[
literal|0
index|]
operator|!=
literal|'\n'
condition|)
block|{
if|if
condition|(
name|strchr
argument_list|(
name|SINGLE_CHAR_COMMANDS
argument_list|,
operator|*
name|cmd
argument_list|)
condition|)
block|{
name|p
operator|=
name|cmd
expr_stmt|;
operator|++
name|cmd
expr_stmt|;
operator|--
name|cmdlen
expr_stmt|;
name|namelen
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|p
operator|=
name|cmd
init|;
name|cmdlen
operator|>
literal|0
condition|;
operator|--
name|cmdlen
operator|,
operator|++
name|cmd
control|)
if|if
condition|(
operator|!
name|isalpha
argument_list|(
operator|*
name|cmd
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|(
name|namelen
operator|=
name|cmd
operator|-
name|p
operator|)
operator|==
literal|0
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"Unknown command name"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
block|}
comment|/* 		 * !!! 		 * Historic vi permitted flags to immediately follow any 		 * subset of the 'delete' command, but then did not permit 		 * further arguments (flag, buffer, count).  Make it work. 		 * Permit further arguments for the few shreds of dignity 		 * it offers. 		 * 		 * !!! 		 * Note, adding commands that start with 'd', and match 		 * "delete" up to a l, p, +, - or # character can break 		 * this code. 		 */
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'d'
condition|)
block|{
for|for
control|(
name|s
operator|=
name|p
operator|,
name|t
operator|=
name|cmds
index|[
name|C_DELETE
index|]
operator|.
name|name
init|;
operator|*
name|s
operator|==
operator|*
name|t
condition|;
operator|++
name|s
operator|,
operator|++
name|t
control|)
empty_stmt|;
if|if
condition|(
name|s
index|[
literal|0
index|]
operator|==
literal|'l'
operator|||
name|s
index|[
literal|0
index|]
operator|==
literal|'p'
operator|||
name|s
index|[
literal|0
index|]
operator|==
literal|'+'
operator|||
name|s
index|[
literal|0
index|]
operator|==
literal|'-'
operator|||
name|s
index|[
literal|0
index|]
operator|==
literal|'#'
condition|)
block|{
name|len
operator|=
operator|(
name|cmd
operator|-
name|p
operator|)
operator|-
operator|(
name|s
operator|-
name|p
operator|)
expr_stmt|;
name|cmd
operator|-=
name|len
expr_stmt|;
name|cmdlen
operator|+=
name|len
expr_stmt|;
name|cp
operator|=
operator|&
name|cmd_del2
expr_stmt|;
goto|goto
name|skip
goto|;
block|}
block|}
comment|/* 		 * Search the table for the command. 		 * 		 * !!! 		 * Historic vi permitted the mark to immediately follow the 		 * 'k' in the 'k' command.  Make it work. 		 * 		 * !!! 		 * Historic vi permitted pretty much anything to follow the 		 * substitute command, e.g. "s/e/E/|s|sgc3p" was fine.  Make 		 * the command "sgc" work. 		 */
if|if
condition|(
operator|(
name|cp
operator|=
name|ex_comm_search
argument_list|(
name|p
argument_list|,
name|namelen
argument_list|)
operator|)
operator|==
name|NULL
condition|)
switch|switch
condition|(
name|p
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'s'
case|:
name|cmd
operator|-=
name|namelen
operator|-
literal|1
expr_stmt|;
name|cmdlen
operator|+=
name|namelen
operator|-
literal|1
expr_stmt|;
name|cp
operator|=
operator|&
name|cmd_subagain
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|&&
operator|!
name|p
index|[
literal|2
index|]
condition|)
block|{
name|cmd
operator|-=
name|namelen
operator|-
literal|1
expr_stmt|;
name|cmdlen
operator|+=
name|namelen
operator|-
literal|1
expr_stmt|;
name|cp
operator|=
operator|&
name|cmds
index|[
name|C_K
index|]
expr_stmt|;
break|break;
block|}
comment|/* FALLTHROUGH */
default|default:
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"The %.*s command is unknown"
argument_list|,
name|namelen
argument_list|,
name|p
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* Some commands are either not implemented or turned off. */
name|skip
label|:
if|if
condition|(
name|F_ISSET
argument_list|(
name|cp
argument_list|,
name|E_NOPERM
argument_list|)
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"The %s command is not currently supported"
argument_list|,
name|cp
operator|->
name|name
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* Some commands aren't okay in globals. */
if|if
condition|(
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|S_GLOBAL
argument_list|)
operator|&&
name|F_ISSET
argument_list|(
name|cp
argument_list|,
name|E_NOGLOBAL
argument_list|)
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"The %s command can't be used as part of a global command"
argument_list|,
name|cp
operator|->
name|name
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* 		 * Multiple< and> characters; another "feature".  Note, 		 * The string passed to the underlying function may not be 		 * nul terminated in this case. 		 */
if|if
condition|(
operator|(
name|cp
operator|==
operator|&
name|cmds
index|[
name|C_SHIFTL
index|]
operator|&&
operator|*
name|p
operator|==
literal|'<'
operator|)
operator|||
operator|(
name|cp
operator|==
operator|&
name|cmds
index|[
name|C_SHIFTR
index|]
operator|&&
operator|*
name|p
operator|==
literal|'>'
operator|)
condition|)
block|{
for|for
control|(
name|ch
operator|=
operator|*
name|p
init|;
name|cmdlen
operator|>
literal|0
condition|;
operator|--
name|cmdlen
operator|,
operator|++
name|cmd
control|)
if|if
condition|(
operator|*
name|cmd
operator|!=
name|ch
condition|)
break|break;
if|if
condition|(
name|argv_exp0
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|exc
argument_list|,
name|p
argument_list|,
name|cmd
operator|-
name|p
argument_list|)
condition|)
goto|goto
name|err
goto|;
block|}
comment|/* 		 * The visual command has a different syntax when called 		 * from ex than when called from a vi colon command.  FMH. 		 */
if|if
condition|(
name|cp
operator|==
operator|&
name|cmds
index|[
name|C_VISUAL_EX
index|]
operator|&&
name|IN_VI_MODE
argument_list|(
name|sp
argument_list|)
condition|)
name|cp
operator|=
operator|&
name|cmds
index|[
name|C_VISUAL_VI
index|]
expr_stmt|;
comment|/* Set the format style flags for the next command. */
if|if
condition|(
name|cp
operator|==
operator|&
name|cmds
index|[
name|C_HASH
index|]
condition|)
name|exp
operator|->
name|fdef
operator|=
name|E_F_HASH
expr_stmt|;
elseif|else
if|if
condition|(
name|cp
operator|==
operator|&
name|cmds
index|[
name|C_LIST
index|]
condition|)
name|exp
operator|->
name|fdef
operator|=
name|E_F_LIST
expr_stmt|;
elseif|else
if|if
condition|(
name|cp
operator|==
operator|&
name|cmds
index|[
name|C_PRINT
index|]
condition|)
name|exp
operator|->
name|fdef
operator|=
name|E_F_PRINT
expr_stmt|;
name|uselastcmd
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* Print is the default command. */
name|cp
operator|=
operator|&
name|cmds
index|[
name|C_PRINT
index|]
expr_stmt|;
comment|/* Set the saved format flags. */
name|F_SET
argument_list|(
operator|&
name|exc
argument_list|,
name|exp
operator|->
name|fdef
argument_list|)
expr_stmt|;
comment|/* 		 * !!! 		 * If no address was specified, and it's not a global command, 		 * we up the address by one.  (I have not an idea why global 		 * commands are exempted, but it's (ahem) historic practice. 		 */
if|if
condition|(
name|exc
operator|.
name|addrcnt
operator|==
literal|0
operator|&&
operator|!
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|S_GLOBAL
argument_list|)
condition|)
block|{
name|exc
operator|.
name|addrcnt
operator|=
literal|1
expr_stmt|;
name|exc
operator|.
name|addr1
operator|.
name|lno
operator|=
name|sp
operator|->
name|lno
operator|+
literal|1
expr_stmt|;
name|exc
operator|.
name|addr1
operator|.
name|cno
operator|=
name|sp
operator|->
name|cno
expr_stmt|;
block|}
name|uselastcmd
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 	 * !!! 	 * Historically, the number option applied to both ex and vi.  One 	 * strangeness was that ex didn't switch display formats until a 	 * command was entered, e.g.<CR>'s after the set didn't change to 	 * the new format, but :1p would. 	 */
if|if
condition|(
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_NUMBER
argument_list|)
condition|)
block|{
name|optnum
operator|=
literal|1
expr_stmt|;
name|F_SET
argument_list|(
operator|&
name|exc
argument_list|,
name|E_F_HASH
argument_list|)
expr_stmt|;
block|}
else|else
name|optnum
operator|=
literal|0
expr_stmt|;
comment|/* Initialize local flags to the command flags. */
name|LF_INIT
argument_list|(
name|cp
operator|->
name|flags
argument_list|)
expr_stmt|;
comment|/* 	 * File state must be checked throughout this code, because it is 	 * called when reading the .exrc file and similar things.  There's 	 * this little chicken and egg problem -- if we read the file first, 	 * we won't know how to display it.  If we read/set the exrc stuff 	 * first, we can't allow any command that requires file state.  We 	 * don't have a "reading an rc" bit, because we want the commands 	 * to work when the user source's the rc file later.  Historic vi 	 * generally took the easy way out and dropped core.  	 */
if|if
condition|(
name|LF_ISSET
argument_list|(
name|E_NORC
argument_list|)
operator|&&
name|ep
operator|==
name|NULL
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"The %s command requires that a file have already been read in"
argument_list|,
name|cp
operator|->
name|name
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* 	 * There are three normal termination cases for an ex command.  They 	 * are the end of the string (cmdlen), or unescaped (by literal next 	 * characters) newline or '|' characters.  As we're past any addresses, 	 * we can now determine how long the command is, so we don't have to 	 * look for all the possible terminations.  There are three exciting 	 * special cases: 	 * 	 * 1: The bang, global, vglobal and the filter versions of the read and 	 *    write commands are delimited by newlines (they can contain shell 	 *    pipes). 	 * 2: The ex, edit, next and visual in vi mode commands all take ex 	 *    commands as their first arguments. 	 * 3: The substitute command takes an RE as its first argument, and 	 *    wants it to be specially delimited. 	 * 	 * Historically, '|' characters in the first argument of the ex, edit, 	 * next, vi visual, and substitute commands didn't delimit the command. 	 * And, in the filter cases for read and write, and the bang, global 	 * and vglobal commands, they did not delimit the command at all. 	 * 	 * For example, the following commands were legal: 	 * 	 *	:edit +25|s/abc/ABC/ file.c 	 *	:substitute s/|/PIPE/ 	 *	:read !spell % | columnate 	 *	:global/pattern/p|l 	 * 	 * It's not quite as simple as it sounds, however.  The command: 	 * 	 *	:substitute s/a/b/|s/c/d|set 	 * 	 * was also legal, i.e. the historic ex parser (using the word loosely, 	 * since "parser" implies some regularity) delimited the RE's based on 	 * its delimiter and not anything so irretrievably vulgar as a command 	 * syntax. 	 * 	 * One thing that makes this easier is that we can ignore most of the 	 * command termination conditions for the commands that want to take 	 * the command up to the next newline.  None of them are legal in .exrc 	 * files, so if we're here, we only dealing with a single line, and we 	 * can just eat it. 	 * 	 * Anyhow, the following code makes this all work.  First, for the 	 * special cases we move past their special argument(s).  Then, we 	 * do normal command processing on whatever is left.  Barf-O-Rama. 	 */
name|arg1_len
operator|=
literal|0
expr_stmt|;
name|save_cmd
operator|=
name|cmd
expr_stmt|;
if|if
condition|(
name|cp
operator|==
operator|&
name|cmds
index|[
name|C_EDIT
index|]
operator|||
name|cp
operator|==
operator|&
name|cmds
index|[
name|C_EX
index|]
operator|||
name|cp
operator|==
operator|&
name|cmds
index|[
name|C_NEXT
index|]
operator|||
name|cp
operator|==
operator|&
name|cmds
index|[
name|C_VISUAL_VI
index|]
condition|)
block|{
comment|/* 		 * Move to the next non-whitespace character.  A '!' 		 * immediately following the command is eaten as a 		 * force flag. 		 */
if|if
condition|(
name|cmdlen
operator|>
literal|0
operator|&&
operator|*
name|cmd
operator|==
literal|'!'
condition|)
block|{
operator|++
name|cmd
expr_stmt|;
operator|--
name|cmdlen
expr_stmt|;
name|F_SET
argument_list|(
operator|&
name|exc
argument_list|,
name|E_FORCE
argument_list|)
expr_stmt|;
comment|/* Reset, don't reparse. */
name|save_cmd
operator|=
name|cmd
expr_stmt|;
block|}
for|for
control|(
name|tmp
operator|=
literal|0
init|;
name|cmdlen
operator|>
literal|0
condition|;
operator|--
name|cmdlen
operator|,
operator|++
name|cmd
control|)
if|if
condition|(
operator|!
name|isblank
argument_list|(
operator|*
name|cmd
argument_list|)
condition|)
break|break;
comment|/* 		 * QUOTING NOTE: 		 * 		 * The historic implementation ignored all escape characters 		 * so there was no way to put a space or newline into the +cmd 		 * field.  We do a simplistic job of fixing it by moving to the 		 * first whitespace character that isn't escaped by a literal 		 * next character.  The literal next characters are stripped 		 * as they're no longer useful. 		 */
if|if
condition|(
name|cmdlen
operator|>
literal|0
operator|&&
operator|*
name|cmd
operator|==
literal|'+'
condition|)
block|{
operator|++
name|cmd
expr_stmt|;
operator|--
name|cmdlen
expr_stmt|;
for|for
control|(
name|arg1
operator|=
name|p
operator|=
name|cmd
init|;
name|cmdlen
operator|>
literal|0
condition|;
operator|--
name|cmdlen
operator|,
operator|++
name|cmd
control|)
block|{
name|ch
operator|=
operator|*
name|cmd
expr_stmt|;
if|if
condition|(
name|IS_ESCAPE
argument_list|(
name|sp
argument_list|,
name|ch
argument_list|)
operator|&&
name|cmdlen
operator|>
literal|1
condition|)
block|{
operator|--
name|cmdlen
expr_stmt|;
name|ch
operator|=
operator|*
operator|++
name|cmd
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isblank
argument_list|(
name|ch
argument_list|)
condition|)
break|break;
operator|*
name|p
operator|++
operator|=
name|ch
expr_stmt|;
block|}
name|arg1_len
operator|=
name|cmd
operator|-
name|arg1
expr_stmt|;
comment|/* Reset, so the first argument isn't reparsed. */
name|save_cmd
operator|=
name|cmd
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|cp
operator|==
operator|&
name|cmds
index|[
name|C_BANG
index|]
operator|||
name|cp
operator|==
operator|&
name|cmds
index|[
name|C_GLOBAL
index|]
operator|||
name|cp
operator|==
operator|&
name|cmds
index|[
name|C_VGLOBAL
index|]
condition|)
block|{
name|cmd
operator|+=
name|cmdlen
expr_stmt|;
name|cmdlen
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cp
operator|==
operator|&
name|cmds
index|[
name|C_READ
index|]
operator|||
name|cp
operator|==
operator|&
name|cmds
index|[
name|C_WRITE
index|]
condition|)
block|{
comment|/* 		 * Move to the next character.  If it's a '!', it's a filter 		 * command and we want to eat it all, otherwise, we're done. 		 */
for|for
control|(
init|;
name|cmdlen
operator|>
literal|0
condition|;
operator|--
name|cmdlen
operator|,
operator|++
name|cmd
control|)
block|{
name|ch
operator|=
operator|*
name|cmd
expr_stmt|;
if|if
condition|(
operator|!
name|isblank
argument_list|(
name|ch
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|cmdlen
operator|>
literal|0
operator|&&
name|ch
operator|==
literal|'!'
condition|)
block|{
name|cmd
operator|+=
name|cmdlen
expr_stmt|;
name|cmdlen
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|cp
operator|==
operator|&
name|cmds
index|[
name|C_SUBSTITUTE
index|]
condition|)
block|{
comment|/* 		 * Move to the next non-whitespace character, we'll use it as 		 * the delimiter.  If the character isn't an alphanumeric or 		 * a '|', it's the delimiter, so parse it.  Otherwise, we're 		 * into something like ":s g", so use the special substitute 		 * command. 		 */
for|for
control|(
init|;
name|cmdlen
operator|>
literal|0
condition|;
operator|--
name|cmdlen
operator|,
operator|++
name|cmd
control|)
if|if
condition|(
operator|!
name|isblank
argument_list|(
name|cmd
index|[
literal|0
index|]
argument_list|)
condition|)
break|break;
if|if
condition|(
name|isalnum
argument_list|(
name|cmd
index|[
literal|0
index|]
argument_list|)
operator|||
name|cmd
index|[
literal|0
index|]
operator|==
literal|'|'
condition|)
name|cp
operator|=
operator|&
name|cmd_subagain
expr_stmt|;
elseif|else
if|if
condition|(
name|cmdlen
operator|>
literal|0
condition|)
block|{
comment|/* 			 * QUOTING NOTE: 			 * 			 * Backslashes quote delimiter characters for RE's. 			 * The backslashes are NOT removed since they'll be 			 * used by the RE code.  Move to the third delimiter 			 * that's not escaped (or the end of the command). 			 */
name|delim
operator|=
operator|*
name|cmd
expr_stmt|;
operator|++
name|cmd
expr_stmt|;
operator|--
name|cmdlen
expr_stmt|;
for|for
control|(
name|cnt
operator|=
literal|2
init|;
name|cmdlen
operator|>
literal|0
operator|&&
name|cnt
condition|;
operator|--
name|cmdlen
operator|,
operator|++
name|cmd
control|)
if|if
condition|(
name|cmd
index|[
literal|0
index|]
operator|==
literal|'\\'
operator|&&
name|cmdlen
operator|>
literal|1
condition|)
block|{
operator|++
name|cmd
expr_stmt|;
operator|--
name|cmdlen
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmd
index|[
literal|0
index|]
operator|==
name|delim
condition|)
operator|--
name|cnt
expr_stmt|;
block|}
block|}
comment|/* 	 * Use normal quoting and termination rules to find the end of this 	 * command. 	 * 	 * QUOTING NOTE: 	 * 	 * Historically, vi permitted ^V's to escape<newline>'s in the .exrc 	 * file.  It was almost certainly a bug, but that's what bug-for-bug 	 * compatibility means, Grasshopper.  Also, ^V's escape the command 	 * delimiters.  Literal next quote characters in front of the newlines, 	 * '|' characters or literal next characters are stripped as as they're 	 * no longer useful. 	 */
name|vi_address
operator|=
name|cmdlen
operator|!=
literal|0
operator|&&
name|cmd
index|[
literal|0
index|]
operator|!=
literal|'\n'
expr_stmt|;
for|for
control|(
name|p
operator|=
name|cmd
operator|,
name|cnt
operator|=
literal|0
init|;
name|cmdlen
operator|>
literal|0
condition|;
operator|--
name|cmdlen
operator|,
operator|++
name|cmd
control|)
block|{
name|ch
operator|=
name|cmd
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|IS_ESCAPE
argument_list|(
name|sp
argument_list|,
name|ch
argument_list|)
operator|&&
name|cmdlen
operator|>
literal|1
condition|)
block|{
name|tmp
operator|=
name|cmd
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
literal|'\n'
operator|||
name|tmp
operator|==
literal|'|'
condition|)
block|{
if|if
condition|(
name|tmp
operator|==
literal|'\n'
condition|)
operator|++
name|sp
operator|->
name|if_lno
expr_stmt|;
operator|--
name|cmdlen
expr_stmt|;
operator|++
name|cmd
expr_stmt|;
operator|++
name|cnt
expr_stmt|;
name|ch
operator|=
name|tmp
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'\n'
operator|||
name|ch
operator|==
literal|'|'
condition|)
block|{
if|if
condition|(
name|ch
operator|==
literal|'\n'
condition|)
name|nl
operator|=
literal|1
expr_stmt|;
operator|--
name|cmdlen
expr_stmt|;
break|break;
block|}
operator|*
name|p
operator|++
operator|=
name|ch
expr_stmt|;
block|}
comment|/* 	 * Save off the next command information, go back to the 	 * original start of the command. 	 */
name|p
operator|=
name|cmd
operator|+
literal|1
expr_stmt|;
name|cmd
operator|=
name|save_cmd
expr_stmt|;
name|save_cmd
operator|=
name|p
expr_stmt|;
name|save_cmdlen
operator|=
name|cmdlen
expr_stmt|;
name|cmdlen
operator|=
operator|(
operator|(
name|save_cmd
operator|-
name|cmd
operator|)
operator|-
literal|1
operator|)
operator|-
name|cnt
expr_stmt|;
comment|/* 	 * !!! 	 * The "set tags" command historically used a backslash, not the 	 * user's literal next character, to escape whitespace.  Handle 	 * it here instead of complicating the argv_exp3() code.  Note, 	 * this isn't a particularly complex trap, and if backslashes were 	 * legal in set commands, this would have to be much more complicated. 	 */
if|if
condition|(
name|cp
operator|==
operator|&
name|cmds
index|[
name|C_SET
index|]
condition|)
for|for
control|(
name|p
operator|=
name|cmd
operator|,
name|len
operator|=
name|cmdlen
init|;
name|len
operator|>
literal|0
condition|;
operator|--
name|len
operator|,
operator|++
name|p
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|'\\'
condition|)
operator|*
name|p
operator|=
name|CH_LITERAL
expr_stmt|;
comment|/* 	 * Set the default addresses.  It's an error to specify an address for 	 * a command that doesn't take them.  If two addresses are specified 	 * for a command that only takes one, lose the first one.  Two special 	 * cases here, some commands take 0 or 2 addresses.  For most of them 	 * (the E_ADDR2_ALL flag), 0 defaults to the entire file.  For one 	 * (the `!' command, the E_ADDR2_NONE flag), 0 defaults to no lines. 	 * 	 * Also, if the file is empty, some commands want to use an address of 	 * 0, i.e. the entire file is 0 to 0, and the default first address is 	 * 0.  Otherwise, an entire file is 1 to N and the default line is 1. 	 * Note, we also add the E_ZERO flag to the command flags, for the case 	 * where the 0 address is only valid if it's a default address. 	 * 	 * Also, set a flag if we set the default addresses.  Some commands 	 * (ex: z) care if the user specified an address of if we just used 	 * the current cursor. 	 */
switch|switch
condition|(
name|LF_ISSET
argument_list|(
name|E_ADDR1
operator||
name|E_ADDR2
operator||
name|E_ADDR2_ALL
operator||
name|E_ADDR2_NONE
argument_list|)
condition|)
block|{
case|case
name|E_ADDR1
case|:
comment|/* One address: */
switch|switch
condition|(
name|exc
operator|.
name|addrcnt
condition|)
block|{
case|case
literal|0
case|:
comment|/* Default cursor/empty file. */
name|exc
operator|.
name|addrcnt
operator|=
literal|1
expr_stmt|;
name|F_SET
argument_list|(
operator|&
name|exc
argument_list|,
name|E_ADDRDEF
argument_list|)
expr_stmt|;
if|if
condition|(
name|LF_ISSET
argument_list|(
name|E_ZERODEF
argument_list|)
condition|)
block|{
if|if
condition|(
name|file_lline
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|lno
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|lno
operator|==
literal|0
condition|)
block|{
name|exc
operator|.
name|addr1
operator|.
name|lno
operator|=
literal|0
expr_stmt|;
name|LF_SET
argument_list|(
name|E_ZERO
argument_list|)
expr_stmt|;
block|}
else|else
name|exc
operator|.
name|addr1
operator|.
name|lno
operator|=
name|sp
operator|->
name|lno
expr_stmt|;
block|}
else|else
name|exc
operator|.
name|addr1
operator|.
name|lno
operator|=
name|sp
operator|->
name|lno
expr_stmt|;
name|exc
operator|.
name|addr1
operator|.
name|cno
operator|=
name|sp
operator|->
name|cno
expr_stmt|;
break|break;
case|case
literal|1
case|:
break|break;
case|case
literal|2
case|:
comment|/* Lose the first address. */
name|exc
operator|.
name|addrcnt
operator|=
literal|1
expr_stmt|;
name|exc
operator|.
name|addr1
operator|=
name|exc
operator|.
name|addr2
expr_stmt|;
block|}
break|break;
case|case
name|E_ADDR2_NONE
case|:
comment|/* Zero/two addresses: */
if|if
condition|(
name|exc
operator|.
name|addrcnt
operator|==
literal|0
condition|)
comment|/* Default to nothing. */
break|break;
goto|goto
name|two
goto|;
case|case
name|E_ADDR2_ALL
case|:
comment|/* Zero/two addresses: */
if|if
condition|(
name|exc
operator|.
name|addrcnt
operator|==
literal|0
condition|)
block|{
comment|/* Default entire/empty file. */
name|exc
operator|.
name|addrcnt
operator|=
literal|2
expr_stmt|;
name|F_SET
argument_list|(
operator|&
name|exc
argument_list|,
name|E_ADDRDEF
argument_list|)
expr_stmt|;
if|if
condition|(
name|file_lline
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|exc
operator|.
name|addr2
operator|.
name|lno
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|LF_ISSET
argument_list|(
name|E_ZERODEF
argument_list|)
operator|&&
name|exc
operator|.
name|addr2
operator|.
name|lno
operator|==
literal|0
condition|)
block|{
name|exc
operator|.
name|addr1
operator|.
name|lno
operator|=
literal|0
expr_stmt|;
name|LF_SET
argument_list|(
name|E_ZERO
argument_list|)
expr_stmt|;
block|}
else|else
name|exc
operator|.
name|addr1
operator|.
name|lno
operator|=
literal|1
expr_stmt|;
name|exc
operator|.
name|addr1
operator|.
name|cno
operator|=
name|exc
operator|.
name|addr2
operator|.
name|cno
operator|=
literal|0
expr_stmt|;
name|F_SET
argument_list|(
operator|&
name|exc
argument_list|,
name|E_ADDR2_ALL
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* FALLTHROUGH */
case|case
name|E_ADDR2
case|:
comment|/* Two addresses: */
name|two
label|:
switch|switch
condition|(
name|exc
operator|.
name|addrcnt
condition|)
block|{
case|case
literal|0
case|:
comment|/* Default cursor/empty file. */
name|exc
operator|.
name|addrcnt
operator|=
literal|2
expr_stmt|;
name|F_SET
argument_list|(
operator|&
name|exc
argument_list|,
name|E_ADDRDEF
argument_list|)
expr_stmt|;
if|if
condition|(
name|LF_ISSET
argument_list|(
name|E_ZERODEF
argument_list|)
operator|&&
name|sp
operator|->
name|lno
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|file_lline
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|lno
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|lno
operator|==
literal|0
condition|)
block|{
name|exc
operator|.
name|addr1
operator|.
name|lno
operator|=
name|exc
operator|.
name|addr2
operator|.
name|lno
operator|=
literal|0
expr_stmt|;
name|LF_SET
argument_list|(
name|E_ZERO
argument_list|)
expr_stmt|;
block|}
else|else
name|exc
operator|.
name|addr1
operator|.
name|lno
operator|=
name|exc
operator|.
name|addr2
operator|.
name|lno
operator|=
name|sp
operator|->
name|lno
expr_stmt|;
block|}
else|else
name|exc
operator|.
name|addr1
operator|.
name|lno
operator|=
name|exc
operator|.
name|addr2
operator|.
name|lno
operator|=
name|sp
operator|->
name|lno
expr_stmt|;
name|exc
operator|.
name|addr1
operator|.
name|cno
operator|=
name|exc
operator|.
name|addr2
operator|.
name|cno
operator|=
name|sp
operator|->
name|cno
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* Default to first address. */
name|exc
operator|.
name|addrcnt
operator|=
literal|2
expr_stmt|;
name|exc
operator|.
name|addr2
operator|=
name|exc
operator|.
name|addr1
expr_stmt|;
break|break;
case|case
literal|2
case|:
break|break;
block|}
break|break;
default|default:
if|if
condition|(
name|exc
operator|.
name|addrcnt
condition|)
comment|/* Error. */
goto|goto
name|usage
goto|;
block|}
comment|/* 	 * !!! 	 * The ^D scroll command historically scrolled the value of the scroll 	 * option or to EOF.  It was an error if the cursor was already at EOF. 	 * (Leading addresses were permitted, but were then ignored.) 	 */
if|if
condition|(
name|cp
operator|==
operator|&
name|cmds
index|[
name|C_SCROLL
index|]
condition|)
block|{
name|exc
operator|.
name|addrcnt
operator|=
literal|2
expr_stmt|;
name|exc
operator|.
name|addr1
operator|.
name|lno
operator|=
name|sp
operator|->
name|lno
operator|+
literal|1
expr_stmt|;
name|exc
operator|.
name|addr2
operator|.
name|lno
operator|=
name|sp
operator|->
name|lno
operator|+
name|O_VAL
argument_list|(
name|sp
argument_list|,
name|O_SCROLL
argument_list|)
expr_stmt|;
name|exc
operator|.
name|addr1
operator|.
name|cno
operator|=
name|exc
operator|.
name|addr2
operator|.
name|cno
operator|=
name|sp
operator|->
name|cno
expr_stmt|;
if|if
condition|(
name|file_lline
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|lno
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|lno
operator|!=
literal|0
operator|&&
name|lno
operator|>
name|sp
operator|->
name|lno
operator|&&
name|exc
operator|.
name|addr2
operator|.
name|lno
operator|>
name|lno
condition|)
name|exc
operator|.
name|addr2
operator|.
name|lno
operator|=
name|lno
expr_stmt|;
block|}
name|flagoff
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|cp
operator|->
name|syntax
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
operator|++
name|p
control|)
block|{
comment|/* 		 * The force flag is sensitive to leading whitespace, i.e. 		 * "next !" is different from "next!".  Handle it before 		 * skipping leading<blank>s. 		 */
if|if
condition|(
operator|*
name|p
operator|==
literal|'!'
condition|)
block|{
if|if
condition|(
name|cmdlen
operator|>
literal|0
operator|&&
operator|*
name|cmd
operator|==
literal|'!'
condition|)
block|{
operator|++
name|cmd
expr_stmt|;
operator|--
name|cmdlen
expr_stmt|;
name|F_SET
argument_list|(
operator|&
name|exc
argument_list|,
name|E_FORCE
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
comment|/* Skip leading<blank>s. */
for|for
control|(
init|;
name|cmdlen
operator|>
literal|0
condition|;
operator|--
name|cmdlen
operator|,
operator|++
name|cmd
control|)
if|if
condition|(
operator|!
name|isblank
argument_list|(
operator|*
name|cmd
argument_list|)
condition|)
break|break;
comment|/* 		 * Quit when reach the end of the command, unless it's a 		 * command that does its own parsing, in which case we want 		 * to build a reasonable argv for it.  This code guarantees 		 * that there will be an argv when the function gets called, 		 * so the correct test is for a length of 0, not for the 		 * argc> 0.  Since '!' can precede commands that do their 		 * own parsing, we have to have already handled it. 		 */
if|if
condition|(
name|cmdlen
operator|==
literal|0
operator|&&
operator|*
name|p
operator|!=
literal|'S'
operator|&&
operator|*
name|p
operator|!=
literal|'s'
condition|)
break|break;
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|'1'
case|:
comment|/* +, -, #, l, p */
comment|/* 			 * !!! 			 * Historically, some flags were ignored depending 			 * on where they occurred in the command line.  For 			 * example, in the command, ":3+++p--#", historic vi 			 * acted on the '#' flag, but ignored the '-' flags. 			 * It's unambiguous what the flags mean, so we just 			 * handle them regardless of the stupidity of their 			 * location. 			 */
for|for
control|(
init|;
name|cmdlen
condition|;
operator|--
name|cmdlen
operator|,
operator|++
name|cmd
control|)
switch|switch
condition|(
operator|*
name|cmd
condition|)
block|{
case|case
literal|'+'
case|:
operator|++
name|flagoff
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
operator|--
name|flagoff
expr_stmt|;
break|break;
case|case
literal|'#'
case|:
name|optnum
operator|=
literal|0
expr_stmt|;
name|F_SET
argument_list|(
operator|&
name|exc
argument_list|,
name|E_F_HASH
argument_list|)
expr_stmt|;
name|exp
operator|->
name|fdef
operator||=
name|E_F_HASH
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|F_SET
argument_list|(
operator|&
name|exc
argument_list|,
name|E_F_LIST
argument_list|)
expr_stmt|;
name|exp
operator|->
name|fdef
operator||=
name|E_F_LIST
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|F_SET
argument_list|(
operator|&
name|exc
argument_list|,
name|E_F_PRINT
argument_list|)
expr_stmt|;
name|exp
operator|->
name|fdef
operator||=
name|E_F_PRINT
expr_stmt|;
break|break;
default|default:
goto|goto
name|end1
goto|;
block|}
name|end1
label|:
break|break;
case|case
literal|'2'
case|:
comment|/* -, ., +, ^ */
case|case
literal|'3'
case|:
comment|/* -, ., +, ^, = */
for|for
control|(
init|;
name|cmdlen
condition|;
operator|--
name|cmdlen
operator|,
operator|++
name|cmd
control|)
switch|switch
condition|(
operator|*
name|cmd
condition|)
block|{
case|case
literal|'-'
case|:
name|F_SET
argument_list|(
operator|&
name|exc
argument_list|,
name|E_F_DASH
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'.'
case|:
name|F_SET
argument_list|(
operator|&
name|exc
argument_list|,
name|E_F_DOT
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'+'
case|:
name|F_SET
argument_list|(
operator|&
name|exc
argument_list|,
name|E_F_PLUS
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'^'
case|:
name|F_SET
argument_list|(
operator|&
name|exc
argument_list|,
name|E_F_CARAT
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'='
case|:
if|if
condition|(
operator|*
name|p
operator|==
literal|'3'
condition|)
block|{
name|F_SET
argument_list|(
operator|&
name|exc
argument_list|,
name|E_F_EQUAL
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* FALLTHROUGH */
default|default:
goto|goto
name|end2
goto|;
block|}
name|end2
label|:
break|break;
case|case
literal|'b'
case|:
comment|/* buffer */
comment|/* 			 * !!! 			 * Historically, "d #" was a delete with a flag, not a 			 * delete into the '#' buffer.  If the current command 			 * permits a flag, don't use one as a buffer.  However, 			 * the 'l' and 'p' flags were legal buffer names in the 			 * historic ex, and were used as buffers, not flags. 			 */
if|if
condition|(
operator|(
name|cmd
index|[
literal|0
index|]
operator|==
literal|'+'
operator|||
name|cmd
index|[
literal|0
index|]
operator|==
literal|'-'
operator|||
name|cmd
index|[
literal|0
index|]
operator|==
literal|'#'
operator|)
operator|&&
name|strchr
argument_list|(
name|p
argument_list|,
literal|'1'
argument_list|)
operator|!=
name|NULL
condition|)
break|break;
comment|/* 			 * !!! 			 * Digits can't be buffer names in ex commands, or the 			 * command "d2" would be a delete into buffer '2', and 			 * not a two-line deletion. 			 */
if|if
condition|(
operator|!
name|isdigit
argument_list|(
name|cmd
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|exc
operator|.
name|buffer
operator|=
operator|*
name|cmd
expr_stmt|;
operator|++
name|cmd
expr_stmt|;
operator|--
name|cmdlen
expr_stmt|;
name|F_SET
argument_list|(
operator|&
name|exc
argument_list|,
name|E_BUFFER
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'c'
case|:
comment|/* count [01+a] */
operator|++
name|p
expr_stmt|;
comment|/* Validate any signed value. */
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
name|cmd
argument_list|)
operator|&&
operator|(
operator|*
name|p
operator|!=
literal|'+'
operator|||
operator|(
operator|*
name|cmd
operator|!=
literal|'+'
operator|&&
operator|*
name|cmd
operator|!=
literal|'-'
operator|)
operator|)
condition|)
break|break;
comment|/* If a signed value, set appropriate flags. */
if|if
condition|(
operator|*
name|cmd
operator|==
literal|'-'
condition|)
name|F_SET
argument_list|(
operator|&
name|exc
argument_list|,
name|E_COUNT_NEG
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|cmd
operator|==
literal|'+'
condition|)
name|F_SET
argument_list|(
operator|&
name|exc
argument_list|,
name|E_COUNT_POS
argument_list|)
expr_stmt|;
comment|/* 8-bit XXX */
if|if
condition|(
operator|(
name|lno
operator|=
name|strtol
argument_list|(
name|cmd
argument_list|,
operator|&
name|t
argument_list|,
literal|10
argument_list|)
operator|)
operator|==
literal|0
operator|&&
operator|*
name|p
operator|!=
literal|'0'
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"Count may not be zero"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|cmdlen
operator|-=
operator|(
name|t
operator|-
name|cmd
operator|)
expr_stmt|;
name|cmd
operator|=
name|t
expr_stmt|;
comment|/* 			 * Count as address offsets occur in commands taking 			 * two addresses.  Historic vi practice was to use 			 * the count as an offset from the *second* address. 			 * 			 * Set a count flag; some underlying commands (see 			 * join) do different things with counts than with 			 * line addresses. 			 */
if|if
condition|(
operator|*
name|p
operator|==
literal|'a'
condition|)
block|{
name|exc
operator|.
name|addr1
operator|=
name|exc
operator|.
name|addr2
expr_stmt|;
name|exc
operator|.
name|addr2
operator|.
name|lno
operator|=
name|exc
operator|.
name|addr1
operator|.
name|lno
operator|+
name|lno
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|exc
operator|.
name|count
operator|=
name|lno
expr_stmt|;
name|F_SET
argument_list|(
operator|&
name|exc
argument_list|,
name|E_COUNT
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
comment|/* file */
if|if
condition|(
name|argv_exp2
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|exc
argument_list|,
name|cmd
argument_list|,
name|cmdlen
argument_list|,
name|cp
operator|==
operator|&
name|cmds
index|[
name|C_BANG
index|]
argument_list|)
condition|)
goto|goto
name|err
goto|;
goto|goto
name|countchk
goto|;
case|case
literal|'l'
case|:
comment|/* line */
if|if
condition|(
name|ep_line
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|cur
argument_list|,
operator|&
name|cmd
argument_list|,
operator|&
name|cmdlen
argument_list|,
operator|&
name|tmp
argument_list|)
condition|)
goto|goto
name|err
goto|;
comment|/* Line specifications are always required. */
if|if
condition|(
operator|!
name|tmp
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"%s: bad line specification"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* The line must exist for these commands. */
if|if
condition|(
name|file_lline
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|lno
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|cur
operator|.
name|lno
operator|>
name|lno
condition|)
block|{
name|badlno
argument_list|(
name|sp
argument_list|,
name|lno
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|exc
operator|.
name|lineno
operator|=
name|cur
operator|.
name|lno
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
comment|/* string, file exp. */
if|if
condition|(
name|argv_exp1
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|exc
argument_list|,
name|cmd
argument_list|,
name|cmdlen
argument_list|,
name|cp
operator|==
operator|&
name|cmds
index|[
name|C_BANG
index|]
argument_list|)
condition|)
goto|goto
name|err
goto|;
goto|goto
name|addr2
goto|;
case|case
literal|'s'
case|:
comment|/* string */
if|if
condition|(
name|argv_exp0
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|exc
argument_list|,
name|cmd
argument_list|,
name|cmdlen
argument_list|)
condition|)
goto|goto
name|err
goto|;
goto|goto
name|addr2
goto|;
case|case
literal|'W'
case|:
comment|/* word string */
comment|/* 			 * QUOTING NOTE: 			 * 			 * Literal next characters escape the following 			 * character.  Quoting characters are stripped 			 * here since they are no longer useful. 			 * 			 * First there was the word. 			 */
for|for
control|(
name|p
operator|=
name|t
operator|=
name|cmd
init|;
name|cmdlen
operator|>
literal|0
condition|;
operator|--
name|cmdlen
operator|,
operator|++
name|cmd
control|)
block|{
name|ch
operator|=
operator|*
name|cmd
expr_stmt|;
if|if
condition|(
name|IS_ESCAPE
argument_list|(
name|sp
argument_list|,
name|ch
argument_list|)
operator|&&
name|cmdlen
operator|>
literal|1
condition|)
block|{
operator|--
name|cmdlen
expr_stmt|;
operator|*
name|p
operator|++
operator|=
operator|*
operator|++
name|cmd
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isblank
argument_list|(
name|ch
argument_list|)
condition|)
block|{
operator|++
name|cmd
expr_stmt|;
operator|--
name|cmdlen
expr_stmt|;
break|break;
block|}
else|else
operator|*
name|p
operator|++
operator|=
name|ch
expr_stmt|;
block|}
if|if
condition|(
name|argv_exp0
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|exc
argument_list|,
name|t
argument_list|,
name|p
operator|-
name|t
argument_list|)
condition|)
goto|goto
name|err
goto|;
comment|/* Delete intervening whitespace. */
for|for
control|(
init|;
name|cmdlen
operator|>
literal|0
condition|;
operator|--
name|cmdlen
operator|,
operator|++
name|cmd
control|)
block|{
name|ch
operator|=
operator|*
name|cmd
expr_stmt|;
if|if
condition|(
operator|!
name|isblank
argument_list|(
name|ch
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|cmdlen
operator|==
literal|0
condition|)
goto|goto
name|usage
goto|;
comment|/* Followed by the string. */
for|for
control|(
name|p
operator|=
name|t
operator|=
name|cmd
init|;
name|cmdlen
operator|>
literal|0
condition|;
operator|--
name|cmdlen
operator|,
operator|++
name|cmd
operator|,
operator|++
name|p
control|)
block|{
name|ch
operator|=
operator|*
name|cmd
expr_stmt|;
if|if
condition|(
name|IS_ESCAPE
argument_list|(
name|sp
argument_list|,
name|ch
argument_list|)
operator|&&
name|cmdlen
operator|>
literal|1
condition|)
block|{
operator|--
name|cmdlen
expr_stmt|;
operator|*
name|p
operator|=
operator|*
operator|++
name|cmd
expr_stmt|;
block|}
else|else
operator|*
name|p
operator|=
name|ch
expr_stmt|;
block|}
if|if
condition|(
name|argv_exp0
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|exc
argument_list|,
name|t
argument_list|,
name|p
operator|-
name|t
argument_list|)
condition|)
goto|goto
name|err
goto|;
goto|goto
name|addr2
goto|;
case|case
literal|'w'
case|:
comment|/* word */
if|if
condition|(
name|argv_exp3
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|exc
argument_list|,
name|cmd
argument_list|,
name|cmdlen
argument_list|)
condition|)
goto|goto
name|err
goto|;
name|countchk
label|:
if|if
condition|(
operator|*
operator|++
name|p
operator|!=
literal|'N'
condition|)
block|{
comment|/* N */
comment|/* 				 * If a number is specified, must either be 				 * 0 or that number, if optional, and that 				 * number, if required. 				 */
name|num
operator|=
operator|*
name|p
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
operator|(
operator|*
operator|++
name|p
operator|!=
literal|'o'
operator|||
name|exp
operator|->
name|argsoff
operator|!=
literal|0
operator|)
operator|&&
name|exp
operator|->
name|argsoff
operator|!=
name|num
condition|)
goto|goto
name|usage
goto|;
block|}
goto|goto
name|addr2
goto|;
default|default:
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"Internal syntax table error (%s: %c)"
argument_list|,
name|cp
operator|->
name|name
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Skip trailing whitespace. */
for|for
control|(
init|;
name|cmdlen
condition|;
operator|--
name|cmdlen
control|)
block|{
name|ch
operator|=
operator|*
name|cmd
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|isblank
argument_list|(
name|ch
argument_list|)
condition|)
break|break;
block|}
comment|/* 	 * There shouldn't be anything left, and no more required 	 * fields, i.e neither 'l' or 'r' in the syntax string. 	 */
if|if
condition|(
name|cmdlen
operator|||
name|strpbrk
argument_list|(
name|p
argument_list|,
literal|"lr"
argument_list|)
condition|)
block|{
name|usage
label|:
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"Usage: %s"
argument_list|,
name|cp
operator|->
name|usage
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* Verify that the addresses are legal. */
name|addr2
label|:
switch|switch
condition|(
name|exc
operator|.
name|addrcnt
condition|)
block|{
case|case
literal|2
case|:
if|if
condition|(
name|file_lline
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|lno
argument_list|)
condition|)
goto|goto
name|err
goto|;
comment|/* 		 * Historic ex/vi permitted commands with counts to go past 		 * EOF.  So, for example, if the file only had 5 lines, the 		 * ex command "1,6>" would fail, but the command ">300" 		 * would succeed.  Since we don't want to have to make all 		 * of the underlying commands handle random line numbers, 		 * fix it here. 		 */
if|if
condition|(
name|exc
operator|.
name|addr2
operator|.
name|lno
operator|>
name|lno
condition|)
if|if
condition|(
name|F_ISSET
argument_list|(
operator|&
name|exc
argument_list|,
name|E_COUNT
argument_list|)
condition|)
name|exc
operator|.
name|addr2
operator|.
name|lno
operator|=
name|lno
expr_stmt|;
else|else
block|{
name|badlno
argument_list|(
name|sp
argument_list|,
name|lno
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* FALLTHROUGH */
case|case
literal|1
case|:
name|num
operator|=
name|exc
operator|.
name|addr1
operator|.
name|lno
expr_stmt|;
comment|/* 		 * If it's a "default vi command", zero is okay.  Historic 		 * vi allowed this, note, it's also the hack that allows 		 * "vi +100 nonexistent_file" to work. 		 */
if|if
condition|(
name|num
operator|==
literal|0
operator|&&
operator|(
name|IN_EX_MODE
argument_list|(
name|sp
argument_list|)
operator|||
name|uselastcmd
operator|!=
literal|1
operator|)
operator|&&
operator|!
name|LF_ISSET
argument_list|(
name|E_ZERO
argument_list|)
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"The %s command doesn't permit an address of 0"
argument_list|,
name|cp
operator|->
name|name
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|file_lline
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|lno
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|num
operator|>
name|lno
condition|)
block|{
name|badlno
argument_list|(
name|sp
argument_list|,
name|lno
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
break|break;
block|}
comment|/* 	 * If doing a default command and there's nothing left on the line, 	 * vi just moves to the line.  For example, ":3" and ":'a,'b" just 	 * move to line 3 and line 'b, respectively, but ":3|" prints line 3. 	 * 	 * !!! 	 * This is done before the absolute mark gets set; historically, 	 * "/a/,/b/" did NOT set vi's absolute mark, but "/a/,/b/d" did. 	 */
if|if
condition|(
name|IN_VI_MODE
argument_list|(
name|sp
argument_list|)
operator|&&
name|uselastcmd
operator|&&
name|vi_address
operator|==
literal|0
condition|)
block|{
switch|switch
condition|(
name|exc
operator|.
name|addrcnt
condition|)
block|{
case|case
literal|2
case|:
name|sp
operator|->
name|lno
operator|=
name|exc
operator|.
name|addr2
operator|.
name|lno
condition|?
name|exc
operator|.
name|addr2
operator|.
name|lno
else|:
literal|1
expr_stmt|;
name|sp
operator|->
name|cno
operator|=
name|exc
operator|.
name|addr2
operator|.
name|cno
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|sp
operator|->
name|lno
operator|=
name|exc
operator|.
name|addr1
operator|.
name|lno
condition|?
name|exc
operator|.
name|addr1
operator|.
name|lno
else|:
literal|1
expr_stmt|;
name|sp
operator|->
name|cno
operator|=
name|exc
operator|.
name|addr1
operator|.
name|cno
expr_stmt|;
break|break;
block|}
name|cmd
operator|=
name|save_cmd
expr_stmt|;
name|cmdlen
operator|=
name|save_cmdlen
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
comment|/* 	 * Set the absolute mark -- we have to set it for vi here, in case 	 * it's a compound command, e.g. ":5p|6" should set the absolute 	 * mark for vi. 	 */
if|if
condition|(
name|F_ISSET
argument_list|(
name|exp
argument_list|,
name|EX_ABSMARK
argument_list|)
condition|)
block|{
name|cur
operator|.
name|lno
operator|=
name|sp
operator|->
name|lno
expr_stmt|;
name|cur
operator|.
name|cno
operator|=
name|sp
operator|->
name|cno
expr_stmt|;
name|F_CLR
argument_list|(
name|exp
argument_list|,
name|EX_ABSMARK
argument_list|)
expr_stmt|;
if|if
condition|(
name|mark_set
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|ABSMARK1
argument_list|,
operator|&
name|cur
argument_list|,
literal|1
argument_list|)
condition|)
goto|goto
name|err
goto|;
block|}
comment|/* Final setup for the command. */
name|exc
operator|.
name|cmd
operator|=
name|cp
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG
argument_list|)
operator|&&
literal|0
name|TRACE
argument_list|(
name|sp
argument_list|,
literal|"ex_cmd: %s"
argument_list|,
name|exc
operator|.
name|cmd
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|exc
operator|.
name|addrcnt
operator|>
literal|0
condition|)
block|{
name|TRACE
argument_list|(
name|sp
argument_list|,
literal|"\taddr1 %d"
argument_list|,
name|exc
operator|.
name|addr1
operator|.
name|lno
argument_list|)
expr_stmt|;
if|if
condition|(
name|exc
operator|.
name|addrcnt
operator|>
literal|1
condition|)
name|TRACE
argument_list|(
name|sp
argument_list|,
literal|" addr2: %d"
argument_list|,
name|exc
operator|.
name|addr2
operator|.
name|lno
argument_list|)
expr_stmt|;
name|TRACE
argument_list|(
name|sp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|exc
operator|.
name|lineno
condition|)
name|TRACE
argument_list|(
name|sp
argument_list|,
literal|"\tlineno %d"
argument_list|,
name|exc
operator|.
name|lineno
argument_list|)
expr_stmt|;
if|if
condition|(
name|exc
operator|.
name|flags
condition|)
name|TRACE
argument_list|(
name|sp
argument_list|,
literal|"\tflags %0x"
argument_list|,
name|exc
operator|.
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|F_ISSET
argument_list|(
operator|&
name|exc
argument_list|,
name|E_BUFFER
argument_list|)
condition|)
name|TRACE
argument_list|(
name|sp
argument_list|,
literal|"\tbuffer %c"
argument_list|,
name|exc
operator|.
name|buffer
argument_list|)
expr_stmt|;
name|TRACE
argument_list|(
name|sp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|exc
operator|.
name|argc
condition|)
block|{
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
name|exc
operator|.
name|argc
condition|;
operator|++
name|cnt
control|)
name|TRACE
argument_list|(
name|sp
argument_list|,
literal|"\targ %d: {%s}"
argument_list|,
name|cnt
argument_list|,
name|exc
operator|.
name|argv
index|[
name|cnt
index|]
argument_list|)
expr_stmt|;
name|TRACE
argument_list|(
name|sp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Clear autoprint flag. */
name|F_CLR
argument_list|(
name|exp
argument_list|,
name|EX_AUTOPRINT
argument_list|)
expr_stmt|;
comment|/* Increment the command count if not called from vi. */
if|if
condition|(
name|IN_EX_MODE
argument_list|(
name|sp
argument_list|)
condition|)
operator|++
name|sp
operator|->
name|ccnt
expr_stmt|;
comment|/* 	 * If file state available, and not doing a global command, 	 * log the start of an action. 	 */
if|if
condition|(
name|ep
operator|!=
name|NULL
operator|&&
operator|!
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|S_GLOBAL
argument_list|)
condition|)
operator|(
name|void
operator|)
name|log_cursor
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|)
expr_stmt|;
comment|/* 	 * !!! 	 * There are two special commands for the purposes of this code: the 	 * default command (<carriage-return>) or the scrolling commands (^D 	 * and<EOF>) as the first non-<blank> characters  in the line. 	 * 	 * If this is the first command in the command line, we received the 	 * command from the ex command loop and we're talking to a tty, and 	 * and there's nothing else on the command line, and it's one of the 	 * special commands, we erase the prompt character with a '\r'.  Else, 	 * we put out a newline character to separate the command from the 	 * output from the command.  It's OK if vi calls us -- we won't be in 	 * ex mode so we'll do nothing. 	 * 	 * !!! 	 * Historically, ex only put out a \r, so, if the displayed line was 	 * only a single character long, and<eof> was represented as ^D, the 	 * output wouldn't overwrite the user's input.  Sex currently doesn't 	 * display the<eof> character if it's going to be the scroll command, 	 * i.e. if it's the first non-<blank> character in the line.  If sex 	 * is changed to run in cooked mode, i.e.<eof> is displayed, this code 	 * will have to overwrite it.  We also don't treat lines with extra 	 * prompt characters as empty -- it's not worth the effort since we'd 	 * have to overwrite some indeterminate number of columns with spaces 	 * to clean up.  For now, put out enough spaces to overwrite the prompt. 	 */
if|if
condition|(
name|sep
operator|!=
name|NONE
condition|)
block|{
if|if
condition|(
name|ep
operator|!=
name|NULL
operator|&&
name|IN_EX_MODE
argument_list|(
name|sp
argument_list|)
operator|&&
name|F_ISSET
argument_list|(
name|sp
operator|->
name|gp
argument_list|,
name|G_STDIN_TTY
argument_list|)
condition|)
if|if
condition|(
name|sep
operator|==
name|NEEDSEP_NR
operator|&&
operator|(
name|uselastcmd
operator|||
name|cp
operator|==
operator|&
name|cmds
index|[
name|C_SCROLL
index|]
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|putchar
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
for|for
control|(
name|len
operator|=
name|KEY_LEN
argument_list|(
name|sp
argument_list|,
name|PROMPTCHAR
argument_list|)
init|;
name|len
operator|--
condition|;
control|)
operator|(
name|void
operator|)
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putchar
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|sep
operator|=
name|NONE
expr_stmt|;
block|}
comment|/* Save the current mode. */
name|saved_mode
operator|=
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|S_SCREENS
operator||
name|S_MAJOR_CHANGE
argument_list|)
expr_stmt|;
comment|/* Do the command. */
if|if
condition|(
name|cp
operator|->
name|fn
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|exc
argument_list|)
condition|)
goto|goto
name|err
goto|;
ifdef|#
directive|ifdef
name|DEBUG
comment|/* Make sure no function left the temporary space locked. */
if|if
condition|(
name|F_ISSET
argument_list|(
name|sp
operator|->
name|gp
argument_list|,
name|G_TMP_INUSE
argument_list|)
condition|)
block|{
name|F_CLR
argument_list|(
name|sp
operator|->
name|gp
argument_list|,
name|G_TMP_INUSE
argument_list|)
expr_stmt|;
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"Error: ex: temporary buffer not released"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
endif|#
directive|endif
if|if
condition|(
name|saved_mode
operator|!=
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|S_SCREENS
operator||
name|S_MAJOR_CHANGE
argument_list|)
condition|)
block|{
comment|/* 		 * Only here if the mode of the underlying file changed, e.g. 		 * the user switched files or is exiting.  Two things that we 		 * might have to save: first, any "+cmd" field set up for an 		 * ex/edit command will have to be saved for later, also, any 		 * part of the current ex command that hasn't been executed 		 * yet.  For example: 		 * 		 *	:edit +25 file.c|s/abc/ABC/|1 		 * 		 * !!! 		 * The historic vi just hung, of course; nvi handles it by 		 * pushing the keys onto the tty queue.  Since the commands 		 * are intended as ex commands, add additional characters 		 * to make it all work if we're switching modes to vi.  Also, 		 * + commands were oriented to the last line in the file, 		 * historically, make the cursor start out there. 		 * 		 * For the fun of it, if you want to see if a vi clone got the 		 * ex argument parsing right, try:  		 * 		 *	echo 'foo|bar'> file1; echo 'foo/bar'> file2; 		 *	vi 		 *	:edit +1|s/|/PIPE/|w file1| e file2|1 | s/\//SLASH/|wq 		 */
if|if
condition|(
name|arg1_len
operator|==
literal|0
operator|&&
name|save_cmdlen
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|term_push
argument_list|(
name|sp
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|save_cmdlen
operator|!=
literal|0
condition|)
if|if
condition|(
name|term_push
argument_list|(
name|sp
argument_list|,
name|save_cmd
argument_list|,
name|save_cmdlen
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|arg1
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|IN_VI_MODE
argument_list|(
name|sp
argument_list|)
operator|&&
name|save_cmdlen
operator|!=
literal|0
operator|&&
name|term_push
argument_list|(
name|sp
argument_list|,
literal|"|"
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|term_push
argument_list|(
name|sp
argument_list|,
name|arg1
argument_list|,
name|arg1_len
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|file_lline
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|sp
operator|->
name|frp
operator|->
name|lno
argument_list|)
condition|)
goto|goto
name|err
goto|;
name|F_SET
argument_list|(
name|sp
operator|->
name|frp
argument_list|,
name|FR_CURSORSET
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|IN_VI_MODE
argument_list|(
name|sp
argument_list|)
operator|&&
name|term_push
argument_list|(
name|sp
argument_list|,
literal|":"
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|err
goto|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Integrate any offset parsed by the underlying command, and make 	 * sure the referenced line exists. 	 * 	 * XXX 	 * May not match historic practice (I've never been able to completely 	 * figure it out.)  For example, the '=' command from vi mode often 	 * got the offset wrong, and complained it was too large, but didn't 	 * seem to have a problem with the cursor.  If anyone complains, ask 	 * them how it's supposed to work, they probably know. 	 */
if|if
condition|(
name|ep
operator|!=
name|NULL
operator|&&
operator|(
name|flagoff
operator|+=
name|exc
operator|.
name|flagoff
operator|)
condition|)
block|{
if|if
condition|(
name|flagoff
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|sp
operator|->
name|lno
operator|<=
operator|-
name|flagoff
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"Flag offset before line 1"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|file_lline
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|lno
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|sp
operator|->
name|lno
operator|+
name|flagoff
operator|>
name|lno
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"Flag offset past end-of-file"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
block|}
name|sp
operator|->
name|lno
operator|+=
name|flagoff
expr_stmt|;
block|}
comment|/* 	 * If the command was successful and we're in ex command mode, we 	 * may want to display a line.  Make sure there's a line to display. 	 */
if|if
condition|(
name|ep
operator|!=
name|NULL
operator|&&
name|IN_EX_MODE
argument_list|(
name|sp
argument_list|)
operator|&&
operator|!
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|S_GLOBAL
argument_list|)
operator|&&
name|sp
operator|->
name|lno
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * The print commands have already handled the `print' flags. 		 * If so, clear them. 		 */
if|if
condition|(
name|LF_ISSET
argument_list|(
name|E_F_PRCLEAR
argument_list|)
condition|)
name|F_CLR
argument_list|(
operator|&
name|exc
argument_list|,
name|E_F_HASH
operator||
name|E_F_LIST
operator||
name|E_F_PRINT
argument_list|)
expr_stmt|;
comment|/* If hash only set because of the number option, discard it. */
if|if
condition|(
name|optnum
condition|)
name|F_CLR
argument_list|(
operator|&
name|exc
argument_list|,
name|E_F_HASH
argument_list|)
expr_stmt|;
comment|/* 		 * If there was an explicit flag to display the new cursor 		 * line, or we're in ex mode, autoprint is set, and a change 		 * was made, display the line.  If any print flags set use 		 * them, otherwise default to print. 		 */
name|LF_INIT
argument_list|(
name|F_ISSET
argument_list|(
operator|&
name|exc
argument_list|,
name|E_F_HASH
operator||
name|E_F_LIST
operator||
name|E_F_PRINT
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|LF_ISSET
argument_list|(
name|E_F_HASH
operator||
name|E_F_LIST
operator||
name|E_F_PRINT
argument_list|)
operator|&&
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_AUTOPRINT
argument_list|)
operator|&&
operator|(
name|F_ISSET
argument_list|(
name|exp
argument_list|,
name|EX_AUTOPRINT
argument_list|)
operator|||
name|F_ISSET
argument_list|(
name|cp
argument_list|,
name|E_AUTOPRINT
argument_list|)
operator|)
condition|)
name|LF_INIT
argument_list|(
name|E_F_PRINT
argument_list|)
expr_stmt|;
if|if
condition|(
name|LF_ISSET
argument_list|(
name|E_F_HASH
operator||
name|E_F_LIST
operator||
name|E_F_PRINT
argument_list|)
condition|)
block|{
name|memset
argument_list|(
operator|&
name|exc
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|EXCMDARG
argument_list|)
argument_list|)
expr_stmt|;
name|exc
operator|.
name|addrcnt
operator|=
literal|2
expr_stmt|;
name|exc
operator|.
name|addr1
operator|.
name|lno
operator|=
name|exc
operator|.
name|addr2
operator|.
name|lno
operator|=
name|sp
operator|->
name|lno
expr_stmt|;
name|exc
operator|.
name|addr1
operator|.
name|cno
operator|=
name|exc
operator|.
name|addr2
operator|.
name|cno
operator|=
name|sp
operator|->
name|cno
expr_stmt|;
operator|(
name|void
operator|)
name|ex_print
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|exc
operator|.
name|addr1
argument_list|,
operator|&
name|exc
operator|.
name|addr2
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
block|}
name|cmd
operator|=
name|save_cmd
expr_stmt|;
name|cmdlen
operator|=
name|save_cmdlen
expr_stmt|;
goto|goto
name|loop
goto|;
comment|/* NOTREACHED */
comment|/* 	 * If we haven't put out a separator line, do it now.  For more 	 * detailed comments, see above. 	 */
name|err
label|:
if|if
condition|(
name|sep
operator|!=
name|NONE
operator|&&
name|ep
operator|!=
name|NULL
operator|&&
name|IN_EX_MODE
argument_list|(
name|sp
argument_list|)
operator|&&
name|F_ISSET
argument_list|(
name|sp
operator|->
name|gp
argument_list|,
name|G_STDIN_TTY
argument_list|)
condition|)
operator|(
name|void
operator|)
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
comment|/* 	 * On error, we discard any keys we have left, as well as any keys 	 * that were mapped.  The test of save_cmdlen isn't necessarily 	 * correct.  If we fail early enough we don't know if the entire 	 * string was a single command or not.  Try and guess, it's useful 	 * to know if part of the command was discarded. 	 */
if|if
condition|(
name|save_cmdlen
operator|==
literal|0
condition|)
for|for
control|(
init|;
name|cmdlen
condition|;
operator|--
name|cmdlen
control|)
block|{
name|ch
operator|=
operator|*
name|cmd
operator|++
expr_stmt|;
if|if
condition|(
name|IS_ESCAPE
argument_list|(
name|sp
argument_list|,
name|ch
argument_list|)
operator|&&
name|cmdlen
operator|>
literal|1
condition|)
block|{
operator|--
name|cmdlen
expr_stmt|;
operator|++
name|cmd
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'\n'
operator|||
name|ch
operator|==
literal|'|'
condition|)
block|{
if|if
condition|(
name|cmdlen
operator|>
literal|1
condition|)
name|save_cmdlen
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|save_cmdlen
operator|!=
literal|0
condition|)
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"Ex command failed: remaining command input discarded"
argument_list|)
expr_stmt|;
comment|/* 	 * !!! 	 * Previous versions of nvi cleared mapped characters on error.  This 	 * feature was removed when users complained that it wasn't historic 	 * practice. 	 */
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ep_range --  *	Get a line range for ex commands.  */
end_comment

begin_function
specifier|static
name|int
name|ep_range
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|,
name|excp
parameter_list|,
name|cmdp
parameter_list|,
name|cmdlenp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
name|EXCMDARG
modifier|*
name|excp
decl_stmt|;
name|char
modifier|*
modifier|*
name|cmdp
decl_stmt|;
name|size_t
modifier|*
name|cmdlenp
decl_stmt|;
block|{
name|MARK
name|cur
decl_stmt|,
name|savecursor
decl_stmt|;
name|size_t
name|cmdlen
decl_stmt|;
name|int
name|savecursor_set
decl_stmt|,
name|tmp
decl_stmt|;
name|char
modifier|*
name|cmd
decl_stmt|;
comment|/* Percent character is all lines in the file. */
name|cmd
operator|=
operator|*
name|cmdp
expr_stmt|;
name|cmdlen
operator|=
operator|*
name|cmdlenp
expr_stmt|;
if|if
condition|(
operator|*
name|cmd
operator|==
literal|'%'
condition|)
block|{
name|excp
operator|->
name|addr1
operator|.
name|lno
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|file_lline
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|excp
operator|->
name|addr2
operator|.
name|lno
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* If an empty file, then the first line is 0, not 1. */
if|if
condition|(
name|excp
operator|->
name|addr2
operator|.
name|lno
operator|==
literal|0
condition|)
name|excp
operator|->
name|addr1
operator|.
name|lno
operator|=
literal|0
expr_stmt|;
name|excp
operator|->
name|addr1
operator|.
name|cno
operator|=
name|excp
operator|->
name|addr2
operator|.
name|cno
operator|=
literal|0
expr_stmt|;
name|excp
operator|->
name|addrcnt
operator|=
literal|2
expr_stmt|;
operator|++
operator|*
name|cmdp
expr_stmt|;
operator|--
operator|*
name|cmdlenp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Parse comma or semi-colon delimited line specs. */
for|for
control|(
name|savecursor_set
operator|=
literal|0
operator|,
name|excp
operator|->
name|addrcnt
operator|=
literal|0
init|;
name|cmdlen
operator|>
literal|0
condition|;
control|)
switch|switch
condition|(
operator|*
name|cmd
condition|)
block|{
case|case
literal|';'
case|:
comment|/* Semi-colon delimiter. */
comment|/* 			 * Comma delimiters delimit; semi-colon delimiters 			 * change the current address for the 2nd address 			 * to be the first address.  Trailing or multiple 			 * delimiters are discarded. 			 */
if|if
condition|(
name|excp
operator|->
name|addrcnt
operator|==
literal|0
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
operator|!
name|savecursor_set
condition|)
block|{
name|savecursor
operator|.
name|lno
operator|=
name|sp
operator|->
name|lno
expr_stmt|;
name|savecursor
operator|.
name|cno
operator|=
name|sp
operator|->
name|cno
expr_stmt|;
name|sp
operator|->
name|lno
operator|=
name|excp
operator|->
name|addr1
operator|.
name|lno
expr_stmt|;
name|sp
operator|->
name|cno
operator|=
name|excp
operator|->
name|addr1
operator|.
name|cno
expr_stmt|;
name|savecursor_set
operator|=
literal|1
expr_stmt|;
block|}
operator|++
name|cmd
expr_stmt|;
operator|--
name|cmdlen
expr_stmt|;
break|break;
case|case
literal|','
case|:
comment|/* Comma delimiter. */
comment|/* If no addresses yet, defaults to ".". */
if|if
condition|(
name|excp
operator|->
name|addrcnt
operator|==
literal|0
condition|)
block|{
name|excp
operator|->
name|addr1
operator|.
name|lno
operator|=
name|sp
operator|->
name|lno
expr_stmt|;
name|excp
operator|->
name|addr1
operator|.
name|cno
operator|=
name|sp
operator|->
name|cno
expr_stmt|;
name|excp
operator|->
name|addrcnt
operator|=
literal|1
expr_stmt|;
block|}
comment|/* FALLTHROUGH */
case|case
literal|' '
case|:
comment|/* Whitespace. */
case|case
literal|'\t'
case|:
comment|/* Whitespace. */
operator|++
name|cmd
expr_stmt|;
operator|--
name|cmdlen
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|ep_line
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|cur
argument_list|,
operator|&
name|cmd
argument_list|,
operator|&
name|cmdlen
argument_list|,
operator|&
name|tmp
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
operator|!
name|tmp
condition|)
goto|goto
name|done
goto|;
comment|/* 			 * Extra addresses are discarded, starting with 			 * the first. 			 */
switch|switch
condition|(
name|excp
operator|->
name|addrcnt
condition|)
block|{
case|case
literal|0
case|:
name|excp
operator|->
name|addr1
operator|=
name|cur
expr_stmt|;
name|excp
operator|->
name|addrcnt
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|excp
operator|->
name|addr2
operator|=
name|cur
expr_stmt|;
name|excp
operator|->
name|addrcnt
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|excp
operator|->
name|addr1
operator|=
name|excp
operator|->
name|addr2
expr_stmt|;
name|excp
operator|->
name|addr2
operator|=
name|cur
expr_stmt|;
break|break;
block|}
break|break;
block|}
comment|/* 	 * XXX 	 * This is probably not the right behavior for savecursor -- 	 * need to figure out what the historical ex did for ";,;,;5p" 	 * or similar stupidity. 	 */
name|done
label|:
if|if
condition|(
name|savecursor_set
condition|)
block|{
name|sp
operator|->
name|lno
operator|=
name|savecursor
operator|.
name|lno
expr_stmt|;
name|sp
operator|->
name|cno
operator|=
name|savecursor
operator|.
name|cno
expr_stmt|;
block|}
if|if
condition|(
name|excp
operator|->
name|addrcnt
operator|==
literal|2
operator|&&
name|excp
operator|->
name|addr2
operator|.
name|lno
operator|<
name|excp
operator|->
name|addr1
operator|.
name|lno
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"The second address is smaller than the first"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
operator|*
name|cmdp
operator|=
name|cmd
expr_stmt|;
operator|*
name|cmdlenp
operator|=
name|cmdlen
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get a single line address specifier.  *  * The way the "previous context" mark worked was that any "non-relative"  * motion set it.  While ex/vi wasn't totally consistent about this, ANY  * numeric address, search pattern, '$', or mark reference in an address  * was considered non-relative, and set the value.  Which should explain  * why we're hacking marks down here.  The problem was that the mark was  * only set if the command was called, i.e. we have to set a flag and test  * it later.  *  * XXX  * This is not exactly historic practice, although it's fairly close.  */
end_comment

begin_function
specifier|static
name|int
name|ep_line
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|,
name|cur
parameter_list|,
name|cmdp
parameter_list|,
name|cmdlenp
parameter_list|,
name|addr_found
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
name|MARK
modifier|*
name|cur
decl_stmt|;
name|char
modifier|*
modifier|*
name|cmdp
decl_stmt|;
name|size_t
modifier|*
name|cmdlenp
decl_stmt|;
name|int
modifier|*
name|addr_found
decl_stmt|;
block|{
name|EX_PRIVATE
modifier|*
name|exp
decl_stmt|;
name|MARK
name|m
decl_stmt|;
name|long
name|total
decl_stmt|;
name|u_int
name|flags
decl_stmt|;
name|size_t
name|cmdlen
decl_stmt|;
name|int
argument_list|(
argument|*sf
argument_list|)
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|EXF
operator|*
operator|,
name|MARK
operator|*
operator|,
name|MARK
operator|*
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|*
operator|,
name|u_int
operator|*
operator|)
argument_list|)
expr_stmt|;
name|char
modifier|*
name|cmd
decl_stmt|,
modifier|*
name|endp
decl_stmt|;
name|exp
operator|=
name|EXP
argument_list|(
name|sp
argument_list|)
expr_stmt|;
operator|*
name|addr_found
operator|=
literal|0
expr_stmt|;
name|cmd
operator|=
operator|*
name|cmdp
expr_stmt|;
name|cmdlen
operator|=
operator|*
name|cmdlenp
expr_stmt|;
switch|switch
condition|(
operator|*
name|cmd
condition|)
block|{
case|case
literal|'$'
case|:
comment|/* Last line in the file. */
operator|*
name|addr_found
operator|=
literal|1
expr_stmt|;
name|F_SET
argument_list|(
name|exp
argument_list|,
name|EX_ABSMARK
argument_list|)
expr_stmt|;
name|cur
operator|->
name|cno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|file_lline
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|cur
operator|->
name|lno
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
operator|++
name|cmd
expr_stmt|;
operator|--
name|cmdlen
expr_stmt|;
break|break;
comment|/* Absolute line number. */
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
operator|*
name|addr_found
operator|=
literal|1
expr_stmt|;
name|F_SET
argument_list|(
name|exp
argument_list|,
name|EX_ABSMARK
argument_list|)
expr_stmt|;
name|cur
operator|->
name|cno
operator|=
literal|0
expr_stmt|;
comment|/* 8-bit XXX */
name|cur
operator|->
name|lno
operator|=
name|strtol
argument_list|(
name|cmd
argument_list|,
operator|&
name|endp
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|cmdlen
operator|-=
operator|(
name|endp
operator|-
name|cmd
operator|)
expr_stmt|;
name|cmd
operator|=
name|endp
expr_stmt|;
break|break;
case|case
literal|'\''
case|:
comment|/* Use a mark. */
operator|*
name|addr_found
operator|=
literal|1
expr_stmt|;
name|F_SET
argument_list|(
name|exp
argument_list|,
name|EX_ABSMARK
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmdlen
operator|==
literal|1
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"No mark name supplied"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|mark_get
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|cmd
index|[
literal|1
index|]
argument_list|,
name|cur
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|cmd
operator|+=
literal|2
expr_stmt|;
name|cmdlen
operator|-=
literal|2
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
comment|/* Search: forward/backward. */
comment|/* 		 * !!! 		 * I can't find any difference between // and \/ or between 		 * ?? and \?.  Mark Horton doesn't remember there being any 		 * difference.  C'est la vie. 		 */
if|if
condition|(
name|cmdlen
operator|<
literal|2
operator|||
name|cmd
index|[
literal|1
index|]
operator|!=
literal|'/'
operator|&&
name|cmd
index|[
literal|1
index|]
operator|!=
literal|'?'
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"\\ not followed by / or ?"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
operator|++
name|cmd
expr_stmt|;
operator|--
name|cmdlen
expr_stmt|;
name|sf
operator|=
name|cmd
index|[
literal|0
index|]
operator|==
literal|'/'
condition|?
name|f_search
else|:
name|b_search
expr_stmt|;
goto|goto
name|search
goto|;
case|case
literal|'/'
case|:
comment|/* Search forward. */
name|sf
operator|=
name|f_search
expr_stmt|;
goto|goto
name|search
goto|;
case|case
literal|'?'
case|:
comment|/* Search backward. */
name|sf
operator|=
name|b_search
expr_stmt|;
name|search
label|:
name|F_SET
argument_list|(
name|exp
argument_list|,
name|EX_ABSMARK
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|==
name|NULL
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"A search address requires that a file have already been read in"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
operator|*
name|addr_found
operator|=
literal|1
expr_stmt|;
name|m
operator|.
name|lno
operator|=
name|sp
operator|->
name|lno
expr_stmt|;
name|m
operator|.
name|cno
operator|=
name|sp
operator|->
name|cno
expr_stmt|;
name|flags
operator|=
name|SEARCH_MSG
operator||
name|SEARCH_PARSE
operator||
name|SEARCH_SET
expr_stmt|;
if|if
condition|(
name|sf
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|m
argument_list|,
operator|&
name|m
argument_list|,
name|cmd
argument_list|,
operator|&
name|endp
argument_list|,
operator|&
name|flags
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|cur
operator|->
name|lno
operator|=
name|m
operator|.
name|lno
expr_stmt|;
name|cur
operator|->
name|cno
operator|=
name|m
operator|.
name|cno
expr_stmt|;
name|cmdlen
operator|-=
operator|(
name|endp
operator|-
name|cmd
operator|)
expr_stmt|;
name|cmd
operator|=
name|endp
expr_stmt|;
break|break;
case|case
literal|'.'
case|:
comment|/* Current position. */
operator|*
name|addr_found
operator|=
literal|1
expr_stmt|;
name|cur
operator|->
name|cno
operator|=
name|sp
operator|->
name|cno
expr_stmt|;
comment|/* If an empty file, then '.' is 0, not 1. */
if|if
condition|(
name|sp
operator|->
name|lno
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|file_lline
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|cur
operator|->
name|lno
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|cur
operator|->
name|lno
operator|!=
literal|0
condition|)
name|cur
operator|->
name|lno
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|cur
operator|->
name|lno
operator|=
name|sp
operator|->
name|lno
expr_stmt|;
operator|++
name|cmd
expr_stmt|;
operator|--
name|cmdlen
expr_stmt|;
break|break;
block|}
comment|/* 	 * Evaluate any offset.  Offsets are +/- any number, or any number 	 * of +/- signs, or any combination thereof.  If no address found 	 * yet, offset is relative to ".". 	 */
for|for
control|(
name|total
operator|=
literal|0
init|;
name|cmdlen
operator|>
literal|0
operator|&&
operator|(
name|cmd
index|[
literal|0
index|]
operator|==
literal|'-'
operator|||
name|cmd
index|[
literal|0
index|]
operator|==
literal|'+'
operator|)
condition|;
control|)
block|{
if|if
condition|(
operator|!
operator|*
name|addr_found
condition|)
block|{
name|cur
operator|->
name|lno
operator|=
name|sp
operator|->
name|lno
expr_stmt|;
name|cur
operator|->
name|cno
operator|=
name|sp
operator|->
name|cno
expr_stmt|;
operator|*
name|addr_found
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|cmdlen
operator|>
literal|1
operator|&&
name|isdigit
argument_list|(
name|cmd
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
comment|/* 8-bit XXX */
name|total
operator|+=
name|strtol
argument_list|(
name|cmd
argument_list|,
operator|&
name|endp
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|cmdlen
operator|-=
operator|(
name|endp
operator|-
name|cmd
operator|)
expr_stmt|;
name|cmd
operator|=
name|endp
expr_stmt|;
block|}
else|else
block|{
name|total
operator|+=
name|cmd
index|[
literal|0
index|]
operator|==
literal|'-'
condition|?
operator|-
literal|1
else|:
literal|1
expr_stmt|;
operator|--
name|cmdlen
expr_stmt|;
operator|++
name|cmd
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|*
name|addr_found
condition|)
block|{
if|if
condition|(
name|total
operator|<
literal|0
operator|&&
operator|-
name|total
operator|>
name|cur
operator|->
name|lno
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"Reference to a line number less than 0"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|cur
operator|->
name|lno
operator|+=
name|total
expr_stmt|;
operator|*
name|cmdp
operator|=
name|cmd
expr_stmt|;
operator|*
name|cmdlenp
operator|=
name|cmdlen
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ex_is_abbrev -  *	The vi text input routine needs to know if ex thinks this is  *	an [un]abbreviate command, so it can turn off abbreviations.  *	Usual ranting in the vi/v_ntext:txt_abbrev() routine.  */
end_comment

begin_function
name|int
name|ex_is_abbrev
parameter_list|(
name|name
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|size_t
name|len
decl_stmt|;
block|{
name|EXCMDLIST
specifier|const
modifier|*
name|cp
decl_stmt|;
return|return
operator|(
operator|(
name|cp
operator|=
name|ex_comm_search
argument_list|(
name|name
argument_list|,
name|len
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
operator|(
name|cp
operator|==
operator|&
name|cmds
index|[
name|C_ABBR
index|]
operator|||
name|cp
operator|==
operator|&
name|cmds
index|[
name|C_UNABBREVIATE
index|]
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ex_is_unmap -  *	The vi text input routine needs to know if ex thinks this is  *	an unmap command, so it can turn off input mapping.  Usual  *	ranting in the vi/v_ntext:txt_unmap() routine.  */
end_comment

begin_function
name|int
name|ex_is_unmap
parameter_list|(
name|name
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|size_t
name|len
decl_stmt|;
block|{
name|EXCMDLIST
specifier|const
modifier|*
name|cp
decl_stmt|;
comment|/* 	 * The command the vi input routines are really interested in 	 * is "unmap!", not just unmap. 	 */
if|if
condition|(
name|name
index|[
name|len
operator|-
literal|1
index|]
operator|!=
literal|'!'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|--
name|len
expr_stmt|;
return|return
operator|(
operator|(
name|cp
operator|=
name|ex_comm_search
argument_list|(
name|name
argument_list|,
name|len
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|cp
operator|==
operator|&
name|cmds
index|[
name|C_UNMAP
index|]
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|EXCMDLIST
specifier|const
modifier|*
name|ex_comm_search
parameter_list|(
name|name
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|size_t
name|len
decl_stmt|;
block|{
name|EXCMDLIST
specifier|const
modifier|*
name|cp
decl_stmt|;
for|for
control|(
name|cp
operator|=
name|cmds
init|;
name|cp
operator|->
name|name
operator|!=
name|NULL
condition|;
operator|++
name|cp
control|)
block|{
if|if
condition|(
name|cp
operator|->
name|name
index|[
literal|0
index|]
operator|>
name|name
index|[
literal|0
index|]
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|cp
operator|->
name|name
index|[
literal|0
index|]
operator|!=
name|name
index|[
literal|0
index|]
condition|)
continue|continue;
if|if
condition|(
operator|!
name|memcmp
argument_list|(
name|name
argument_list|,
name|cp
operator|->
name|name
argument_list|,
name|len
argument_list|)
condition|)
return|return
operator|(
name|cp
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|badlno
parameter_list|(
name|sp
parameter_list|,
name|lno
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|recno_t
name|lno
decl_stmt|;
block|{
if|if
condition|(
name|lno
operator|==
literal|0
condition|)
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"Illegal address: the file is empty"
argument_list|)
expr_stmt|;
else|else
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"Illegal address: only %lu line%s in the file"
argument_list|,
name|lno
argument_list|,
name|lno
operator|>
literal|1
condition|?
literal|"s"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

