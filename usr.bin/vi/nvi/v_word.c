begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1992, 1993  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)v_word.c	8.10 (Berkeley) 10/26/93"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"vi.h"
end_include

begin_include
include|#
directive|include
file|"vcmd.h"
end_include

begin_comment
comment|/*  * There are two types of "words".  Bigwords are easy -- groups of anything  * delimited by whitespace.  Normal words are trickier.  They are either a  * group of characters, numbers and underscores, or a group of anything but,  * delimited by whitespace.  When for a word, if you're in whitespace, it's  * easy, just remove the whitespace and go to the beginning or end of the  * word.  Otherwise, figure out if the next character is in a different group.  * If it is, go to the beginning or end of that group, otherwise, go to the  * beginning or end of the current group.  The historic version of vi didn't  * get this right, so, for example, there were cases where "4e" was not the  * same as "eeee".  To get it right you have to resolve the cursor after each  * search so that the look-ahead to figure out what type of "word" the cursor  * is in will be correct.  *  * Empty lines, and lines that consist of only white-space characters count  * as a single word, and the beginning and end of the file counts as an  * infinite number of words.  *  * Movements associated with commands are different than movement commands.  * For example, in "abc  def", with the cursor on the 'a', "cw" is from  * 'a' to 'c', while "w" is from 'a' to 'd'.  In general, trailing white  * space is discarded from the change movement.  Another example is that,  * in the same string, a "cw" on any white space character replaces that  * single character, and nothing else.  Ain't nothin' in here that's easy.  *  * One historic note -- in the original vi, the 'w', 'W' and 'B' commands  * would treat groups of empty lines as individual words, i.e. the command  * would move the cursor to each new empty line.  The 'e' and 'E' commands  * would treat groups of empty lines as a single word, i.e. the first use  * would move past the group of lines.  The 'b' command would just beep at  * you.  If the lines contained only white-space characters, the 'w' and 'W'  * commands will just beep at you, and the 'B', 'b', 'E' and 'e' commands  * will treat the group as a single word, and the 'B' and 'b' commands will  * treat the lines as individual words.  This implementation treats both  * cases as a single white-space word.  */
end_comment

begin_define
define|#
directive|define
name|FW
parameter_list|(
name|test
parameter_list|)
value|for (; len&& (test); --len, ++p)
end_define

begin_define
define|#
directive|define
name|BW
parameter_list|(
name|test
parameter_list|)
value|for (; len&& (test); --len, --p)
end_define

begin_enum
enum|enum
name|which
block|{
name|BIGWORD
block|,
name|LITTLEWORD
block|}
enum|;
end_enum

begin_decl_stmt
specifier|static
name|int
name|bword
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|EXF
operator|*
operator|,
name|VICMDARG
operator|*
operator|,
name|MARK
operator|*
operator|,
name|MARK
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|eword
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|EXF
operator|*
operator|,
name|VICMDARG
operator|*
operator|,
name|MARK
operator|*
operator|,
name|MARK
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fword
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|EXF
operator|*
operator|,
name|VICMDARG
operator|*
operator|,
name|MARK
operator|*
operator|,
name|MARK
operator|*
operator|,
expr|enum
name|which
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * v_wordw -- [count]w  *	Move forward a word at a time.  */
end_comment

begin_function
name|int
name|v_wordw
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|,
name|vp
parameter_list|,
name|fm
parameter_list|,
name|tm
parameter_list|,
name|rp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
name|VICMDARG
modifier|*
name|vp
decl_stmt|;
name|MARK
modifier|*
name|fm
decl_stmt|,
decl|*
name|tm
decl_stmt|,
modifier|*
name|rp
decl_stmt|;
end_function

begin_block
block|{
return|return
operator|(
name|fword
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|vp
argument_list|,
name|fm
argument_list|,
name|rp
argument_list|,
name|LITTLEWORD
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * v_wordW -- [count]W  *	Move forward a bigword at a time.  */
end_comment

begin_function
name|int
name|v_wordW
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|,
name|vp
parameter_list|,
name|fm
parameter_list|,
name|tm
parameter_list|,
name|rp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
name|VICMDARG
modifier|*
name|vp
decl_stmt|;
name|MARK
modifier|*
name|fm
decl_stmt|,
decl|*
name|tm
decl_stmt|,
modifier|*
name|rp
decl_stmt|;
end_function

begin_block
block|{
return|return
operator|(
name|fword
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|vp
argument_list|,
name|fm
argument_list|,
name|rp
argument_list|,
name|BIGWORD
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * fword --  *	Move forward by words.  */
end_comment

begin_function
specifier|static
name|int
name|fword
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|,
name|vp
parameter_list|,
name|fm
parameter_list|,
name|rp
parameter_list|,
name|type
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
name|VICMDARG
modifier|*
name|vp
decl_stmt|;
name|MARK
modifier|*
name|fm
decl_stmt|,
decl|*
name|rp
decl_stmt|;
end_function

begin_decl_stmt
name|enum
name|which
name|type
decl_stmt|;
end_decl_stmt

begin_block
block|{
enum|enum
block|{
name|INWORD
block|,
name|NOTWORD
block|}
name|state
enum|;
name|VCS
name|cs
decl_stmt|;
name|u_long
name|cnt
decl_stmt|;
name|cs
operator|.
name|cs_lno
operator|=
name|fm
operator|->
name|lno
expr_stmt|;
name|cs
operator|.
name|cs_cno
operator|=
name|fm
operator|->
name|cno
expr_stmt|;
if|if
condition|(
name|cs_init
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|cs
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|cnt
operator|=
name|F_ISSET
argument_list|(
name|vp
argument_list|,
name|VC_C1SET
argument_list|)
condition|?
name|vp
operator|->
name|count
else|:
literal|1
expr_stmt|;
comment|/* 	 * If in white-space: 	 *	If the count is 1, and it's a change command, we're done. 	 *	Else, move to the first non-white-space character, which 	 *	counts as a single word move.  If it's a motion command, 	 *	don't move off the end of the line. 	 */
if|if
condition|(
name|cs
operator|.
name|cs_flags
operator|==
name|CS_EMP
operator|||
name|cs
operator|.
name|cs_flags
operator|==
literal|0
operator|&&
name|isblank
argument_list|(
name|cs
operator|.
name|cs_ch
argument_list|)
condition|)
block|{
if|if
condition|(
name|cs
operator|.
name|cs_flags
operator|!=
name|CS_EMP
operator|&&
name|cnt
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|F_ISSET
argument_list|(
name|vp
argument_list|,
name|VC_C
argument_list|)
condition|)
block|{
operator|++
name|cs
operator|.
name|cs_cno
expr_stmt|;
goto|goto
name|ret3
goto|;
block|}
if|if
condition|(
name|F_ISSET
argument_list|(
name|vp
argument_list|,
name|VC_D
operator||
name|VC_Y
argument_list|)
condition|)
block|{
if|if
condition|(
name|cs_fspace
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|cs
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
goto|goto
name|ret1
goto|;
block|}
block|}
if|if
condition|(
name|cs_fblank
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|cs
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
operator|--
name|cnt
expr_stmt|;
block|}
comment|/* 	 * Cyclically move to the next word -- this involves skipping 	 * over word characters and then any trailing non-word characters. 	 * Note, for the 'w' command, the definition of a word keeps 	 * switching. 	 */
if|if
condition|(
name|type
operator|==
name|BIGWORD
condition|)
while|while
condition|(
name|cnt
operator|--
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|cs_next
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|cs
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|cs
operator|.
name|cs_flags
operator|==
name|CS_EOF
condition|)
goto|goto
name|ret2
goto|;
if|if
condition|(
name|cs
operator|.
name|cs_flags
operator|!=
literal|0
operator|||
name|isblank
argument_list|(
name|cs
operator|.
name|cs_ch
argument_list|)
condition|)
break|break;
block|}
comment|/* 			 * If a motion command and we're at the end of the 			 * last word, we're done.  Delete and yank eat any 			 * trailing blanks, but we don't move off the end 			 * of the line regardless. 			 */
if|if
condition|(
name|cnt
operator|==
literal|0
operator|&&
name|F_ISSET
argument_list|(
name|vp
argument_list|,
name|VC_C
operator||
name|VC_D
operator||
name|VC_Y
argument_list|)
condition|)
block|{
if|if
condition|(
name|F_ISSET
argument_list|(
name|vp
argument_list|,
name|VC_D
operator||
name|VC_Y
argument_list|)
operator|&&
name|cs_fspace
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|cs
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
break|break;
block|}
comment|/* Eat whitespace characters. */
if|if
condition|(
name|cs_fblank
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|cs
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|cs
operator|.
name|cs_flags
operator|==
name|CS_EOF
condition|)
goto|goto
name|ret2
goto|;
block|}
else|else
while|while
condition|(
name|cnt
operator|--
condition|)
block|{
name|state
operator|=
name|cs
operator|.
name|cs_flags
operator|==
literal|0
operator|&&
name|inword
argument_list|(
name|cs
operator|.
name|cs_ch
argument_list|)
condition|?
name|INWORD
else|:
name|NOTWORD
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|cs_next
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|cs
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|cs
operator|.
name|cs_flags
operator|==
name|CS_EOF
condition|)
goto|goto
name|ret2
goto|;
if|if
condition|(
name|cs
operator|.
name|cs_flags
operator|!=
literal|0
operator|||
name|isblank
argument_list|(
name|cs
operator|.
name|cs_ch
argument_list|)
condition|)
break|break;
if|if
condition|(
name|state
operator|==
name|INWORD
condition|)
block|{
if|if
condition|(
operator|!
name|inword
argument_list|(
name|cs
operator|.
name|cs_ch
argument_list|)
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|inword
argument_list|(
name|cs
operator|.
name|cs_ch
argument_list|)
condition|)
break|break;
block|}
comment|/* See comment above. */
if|if
condition|(
name|cnt
operator|==
literal|0
operator|&&
name|F_ISSET
argument_list|(
name|vp
argument_list|,
name|VC_C
operator||
name|VC_D
operator||
name|VC_Y
argument_list|)
condition|)
block|{
if|if
condition|(
name|F_ISSET
argument_list|(
name|vp
argument_list|,
name|VC_D
operator||
name|VC_Y
argument_list|)
operator|&&
name|cs_fspace
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|cs
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
break|break;
block|}
comment|/* Eat whitespace characters. */
if|if
condition|(
name|cs
operator|.
name|cs_flags
operator|!=
literal|0
operator|||
name|isblank
argument_list|(
name|cs
operator|.
name|cs_ch
argument_list|)
condition|)
if|if
condition|(
name|cs_fblank
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|cs
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|cs
operator|.
name|cs_flags
operator|==
name|CS_EOF
condition|)
goto|goto
name|ret2
goto|;
block|}
comment|/* 	 * If a motion command, and eating the trailing non-word would 	 * move us off this line, don't do it.  Move the return cursor 	 * to one past the EOL instead. 	 */
name|ret1
label|:
if|if
condition|(
name|F_ISSET
argument_list|(
name|vp
argument_list|,
name|VC_C
operator||
name|VC_D
operator||
name|VC_Y
argument_list|)
operator|&&
name|cs
operator|.
name|cs_flags
operator|==
name|CS_EOL
condition|)
operator|++
name|cs
operator|.
name|cs_cno
expr_stmt|;
comment|/* If we didn't move, we must be at EOF. */
name|ret2
label|:
if|if
condition|(
name|cs
operator|.
name|cs_lno
operator|==
name|fm
operator|->
name|lno
operator|&&
name|cs
operator|.
name|cs_cno
operator|==
name|fm
operator|->
name|cno
condition|)
block|{
name|v_eof
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|fm
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * If at EOF, and it's a motion command, move the return cursor 	 * one past the EOF. 	 */
if|if
condition|(
name|F_ISSET
argument_list|(
name|vp
argument_list|,
name|VC_C
operator||
name|VC_D
operator||
name|VC_Y
argument_list|)
operator|&&
name|cs
operator|.
name|cs_flags
operator|==
name|CS_EOF
condition|)
operator|++
name|cs
operator|.
name|cs_cno
expr_stmt|;
name|ret3
label|:
name|rp
operator|->
name|lno
operator|=
name|cs
operator|.
name|cs_lno
expr_stmt|;
name|rp
operator|->
name|cno
operator|=
name|cs
operator|.
name|cs_cno
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * v_wordb -- [count]b  *	Move backward a word at a time.  */
end_comment

begin_function
name|int
name|v_wordb
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|,
name|vp
parameter_list|,
name|fm
parameter_list|,
name|tm
parameter_list|,
name|rp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
name|VICMDARG
modifier|*
name|vp
decl_stmt|;
name|MARK
modifier|*
name|fm
decl_stmt|,
decl|*
name|tm
decl_stmt|,
modifier|*
name|rp
decl_stmt|;
end_function

begin_block
block|{
return|return
operator|(
name|bword
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|vp
argument_list|,
name|fm
argument_list|,
name|rp
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * v_WordB -- [count]B  *	Move backward a bigword at a time.  */
end_comment

begin_function
name|int
name|v_wordB
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|,
name|vp
parameter_list|,
name|fm
parameter_list|,
name|tm
parameter_list|,
name|rp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
name|VICMDARG
modifier|*
name|vp
decl_stmt|;
name|MARK
modifier|*
name|fm
decl_stmt|,
decl|*
name|tm
decl_stmt|,
modifier|*
name|rp
decl_stmt|;
end_function

begin_block
block|{
return|return
operator|(
name|bword
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|vp
argument_list|,
name|fm
argument_list|,
name|rp
argument_list|,
literal|1
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * bword --  *	Move backward by words.  */
end_comment

begin_function
specifier|static
name|int
name|bword
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|,
name|vp
parameter_list|,
name|fm
parameter_list|,
name|rp
parameter_list|,
name|spaceonly
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
name|VICMDARG
modifier|*
name|vp
decl_stmt|;
name|MARK
modifier|*
name|fm
decl_stmt|,
decl|*
name|rp
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|spaceonly
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|recno_t
name|lno
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|u_long
name|cno
decl_stmt|,
name|cnt
decl_stmt|;
name|char
modifier|*
name|startp
decl_stmt|;
name|lno
operator|=
name|fm
operator|->
name|lno
expr_stmt|;
name|cno
operator|=
name|fm
operator|->
name|cno
expr_stmt|;
comment|/* Check for start of file. */
if|if
condition|(
name|lno
operator|==
literal|1
operator|&&
name|cno
operator|==
literal|0
condition|)
block|{
name|v_sof
argument_list|(
name|sp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|p
operator|=
name|file_gline
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|lno
argument_list|,
operator|&
name|len
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|file_lline
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|lno
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|lno
operator|==
literal|0
condition|)
name|v_sof
argument_list|(
name|sp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|GETLINE_ERR
argument_list|(
name|sp
argument_list|,
name|lno
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|cnt
operator|=
name|F_ISSET
argument_list|(
name|vp
argument_list|,
name|VC_C1SET
argument_list|)
condition|?
name|vp
operator|->
name|count
else|:
literal|1
expr_stmt|;
comment|/* 	 * Reset the length to the number of characters in the line; the 	 * first character is the current cursor position. 	 */
name|len
operator|=
name|cno
condition|?
name|cno
operator|+
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
goto|goto
name|line
goto|;
for|for
control|(
name|startp
operator|=
name|p
operator|,
name|p
operator|+=
name|cno
init|;
name|cnt
operator|--
condition|;
control|)
block|{
if|if
condition|(
name|spaceonly
condition|)
block|{
if|if
condition|(
operator|!
name|isblank
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
if|if
condition|(
name|len
operator|<
literal|2
condition|)
goto|goto
name|line
goto|;
operator|--
name|p
expr_stmt|;
operator|--
name|len
expr_stmt|;
block|}
name|BW
argument_list|(
name|isblank
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
condition|)
name|BW
argument_list|(
operator|!
name|isblank
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
else|else
goto|goto
name|line
goto|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|isblank
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
if|if
condition|(
name|len
operator|<
literal|2
condition|)
goto|goto
name|line
goto|;
operator|--
name|p
expr_stmt|;
operator|--
name|len
expr_stmt|;
block|}
name|BW
argument_list|(
name|isblank
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
condition|)
if|if
condition|(
name|inword
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|BW
argument_list|(
name|inword
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|BW
argument_list|(
operator|!
name|isblank
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
operator|!
name|inword
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
else|else
goto|goto
name|line
goto|;
block|}
if|if
condition|(
name|cnt
operator|&&
name|len
operator|==
literal|0
condition|)
block|{
comment|/* If we hit SOF, stay there (historic practice). */
name|line
label|:
if|if
condition|(
name|lno
operator|==
literal|1
condition|)
block|{
name|rp
operator|->
name|lno
operator|=
literal|1
expr_stmt|;
name|rp
operator|->
name|cno
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 			 * Get the line.  If the line is empty, decrement 			 * count and get another one. 			 */
if|if
condition|(
operator|(
name|p
operator|=
name|file_gline
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|--
name|lno
argument_list|,
operator|&
name|len
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|GETLINE_ERR
argument_list|(
name|sp
argument_list|,
name|lno
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|cnt
operator|==
literal|0
operator|||
operator|--
name|cnt
operator|==
literal|0
condition|)
block|{
name|rp
operator|->
name|lno
operator|=
name|lno
expr_stmt|;
name|rp
operator|->
name|cno
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
goto|goto
name|line
goto|;
block|}
comment|/* 			 * Set the cursor to the end of the line.  If the word 			 * at the end of this line has only a single character, 			 * we've already skipped over it. 			 */
name|startp
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|len
condition|)
block|{
name|p
operator|+=
name|len
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|cnt
operator|&&
name|len
operator|>
literal|1
operator|&&
operator|!
name|isblank
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|)
condition|)
if|if
condition|(
name|inword
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|inword
argument_list|(
name|p
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
operator|--
name|cnt
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|isblank
argument_list|(
name|p
index|[
operator|-
literal|1
index|]
argument_list|)
operator|&&
operator|!
name|inword
argument_list|(
name|p
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
operator|--
name|cnt
expr_stmt|;
block|}
block|}
else|else
block|{
operator|++
name|p
expr_stmt|;
operator|++
name|len
expr_stmt|;
block|}
block|}
name|rp
operator|->
name|lno
operator|=
name|lno
expr_stmt|;
name|rp
operator|->
name|cno
operator|=
name|p
operator|-
name|startp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * v_worde -- [count]e  *	Move forward to the end of the word.  */
end_comment

begin_function
name|int
name|v_worde
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|,
name|vp
parameter_list|,
name|fm
parameter_list|,
name|tm
parameter_list|,
name|rp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
name|VICMDARG
modifier|*
name|vp
decl_stmt|;
name|MARK
modifier|*
name|fm
decl_stmt|,
decl|*
name|tm
decl_stmt|,
modifier|*
name|rp
decl_stmt|;
end_function

begin_block
block|{
return|return
operator|(
name|eword
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|vp
argument_list|,
name|fm
argument_list|,
name|rp
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * v_wordE -- [count]E  *	Move forward to the end of the bigword.  */
end_comment

begin_function
name|int
name|v_wordE
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|,
name|vp
parameter_list|,
name|fm
parameter_list|,
name|tm
parameter_list|,
name|rp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
name|VICMDARG
modifier|*
name|vp
decl_stmt|;
name|MARK
modifier|*
name|fm
decl_stmt|,
decl|*
name|tm
decl_stmt|,
modifier|*
name|rp
decl_stmt|;
end_function

begin_block
block|{
return|return
operator|(
name|eword
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|vp
argument_list|,
name|fm
argument_list|,
name|rp
argument_list|,
literal|1
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * eword --  *	Move forward to the end of the word.  */
end_comment

begin_function
specifier|static
name|int
name|eword
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|,
name|vp
parameter_list|,
name|fm
parameter_list|,
name|rp
parameter_list|,
name|spaceonly
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
name|VICMDARG
modifier|*
name|vp
decl_stmt|;
name|MARK
modifier|*
name|fm
decl_stmt|,
decl|*
name|rp
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|spaceonly
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|recno_t
name|lno
decl_stmt|;
name|size_t
name|len
decl_stmt|,
name|llen
decl_stmt|;
name|u_long
name|cno
decl_stmt|,
name|cnt
decl_stmt|;
name|int
name|empty
decl_stmt|;
name|char
modifier|*
name|startp
decl_stmt|;
name|lno
operator|=
name|fm
operator|->
name|lno
expr_stmt|;
name|cno
operator|=
name|fm
operator|->
name|cno
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|file_gline
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|lno
argument_list|,
operator|&
name|llen
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|file_lline
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|lno
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|lno
operator|==
literal|0
condition|)
name|v_eof
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|GETLINE_ERR
argument_list|(
name|sp
argument_list|,
name|lno
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|cnt
operator|=
name|F_ISSET
argument_list|(
name|vp
argument_list|,
name|VC_C1SET
argument_list|)
condition|?
name|vp
operator|->
name|count
else|:
literal|1
expr_stmt|;
comment|/* 	 * Reset the length; the first character is the current cursor 	 * position.  If no more characters in this line, may already 	 * be at EOF. 	 */
name|len
operator|=
name|llen
operator|-
name|cno
expr_stmt|;
if|if
condition|(
name|empty
operator|=
name|llen
operator|==
literal|0
operator|||
name|llen
operator|==
name|cno
operator|+
literal|1
condition|)
goto|goto
name|line
goto|;
for|for
control|(
name|startp
operator|=
name|p
operator|+=
name|cno
init|;
name|cnt
operator|--
condition|;
name|empty
operator|=
literal|0
control|)
block|{
if|if
condition|(
name|spaceonly
condition|)
block|{
if|if
condition|(
operator|!
name|isblank
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
if|if
condition|(
name|len
operator|<
literal|2
condition|)
goto|goto
name|line
goto|;
operator|++
name|p
expr_stmt|;
operator|--
name|len
expr_stmt|;
block|}
name|FW
argument_list|(
name|isblank
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
condition|)
name|FW
argument_list|(
operator|!
name|isblank
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
else|else
operator|++
name|cnt
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|isblank
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
if|if
condition|(
name|len
operator|<
literal|2
condition|)
goto|goto
name|line
goto|;
operator|++
name|p
expr_stmt|;
operator|--
name|len
expr_stmt|;
block|}
name|FW
argument_list|(
name|isblank
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
condition|)
if|if
condition|(
name|inword
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|FW
argument_list|(
name|inword
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|FW
argument_list|(
operator|!
name|isblank
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
operator|!
name|inword
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
else|else
operator|++
name|cnt
expr_stmt|;
block|}
if|if
condition|(
name|cnt
operator|&&
name|len
operator|==
literal|0
condition|)
block|{
comment|/* If we hit EOF, stay there (historic practice). */
name|line
label|:
if|if
condition|(
operator|(
name|p
operator|=
name|file_gline
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|++
name|lno
argument_list|,
operator|&
name|llen
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* 				 * If already at eof, complain, unless it's 				 * a change command or a delete command and 				 * there's something to delete. 				 */
if|if
condition|(
name|empty
condition|)
block|{
if|if
condition|(
name|F_ISSET
argument_list|(
name|vp
argument_list|,
name|VC_C
argument_list|)
operator|||
name|F_ISSET
argument_list|(
name|vp
argument_list|,
name|VC_D
argument_list|)
operator|&&
name|llen
operator|!=
literal|0
condition|)
block|{
name|rp
operator|->
name|lno
operator|=
name|lno
operator|-
literal|1
expr_stmt|;
name|rp
operator|->
name|cno
operator|=
name|llen
condition|?
name|llen
else|:
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|v_eof
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|p
operator|=
name|file_gline
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|--
name|lno
argument_list|,
operator|&
name|llen
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|GETLINE_ERR
argument_list|(
name|sp
argument_list|,
name|lno
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|rp
operator|->
name|lno
operator|=
name|lno
expr_stmt|;
name|rp
operator|->
name|cno
operator|=
name|llen
condition|?
name|llen
operator|-
literal|1
else|:
literal|0
expr_stmt|;
comment|/* The 'c', 'd' and 'y' need one more space. */
if|if
condition|(
name|F_ISSET
argument_list|(
name|vp
argument_list|,
name|VC_C
operator||
name|VC_D
operator||
name|VC_Y
argument_list|)
condition|)
operator|++
name|rp
operator|->
name|cno
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|len
operator|=
name|llen
expr_stmt|;
name|cno
operator|=
literal|0
expr_stmt|;
name|startp
operator|=
name|p
expr_stmt|;
block|}
else|else
block|{
operator|--
name|p
expr_stmt|;
operator|++
name|len
expr_stmt|;
block|}
block|}
name|rp
operator|->
name|lno
operator|=
name|lno
expr_stmt|;
name|rp
operator|->
name|cno
operator|=
name|cno
operator|+
operator|(
name|p
operator|-
name|startp
operator|)
expr_stmt|;
comment|/* The 'c', 'd' and 'y' need one more space. */
if|if
condition|(
name|F_ISSET
argument_list|(
name|vp
argument_list|,
name|VC_C
operator||
name|VC_D
operator||
name|VC_Y
argument_list|)
condition|)
operator|++
name|rp
operator|->
name|cno
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

end_unit

