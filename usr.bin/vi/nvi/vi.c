begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1992, 1993  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)vi.c	8.45 (Berkeley) 1/22/94"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"vi.h"
end_include

begin_include
include|#
directive|include
file|"vcmd.h"
end_include

begin_decl_stmt
specifier|static
name|int
name|getcmd
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|EXF
operator|*
operator|,
name|VICMDARG
operator|*
operator|,
name|VICMDARG
operator|*
operator|,
name|VICMDARG
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|inline
name|int
name|getcount
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|ARG_CHAR_T
operator|,
name|u_long
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|inline
name|int
name|getkey
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|CH
operator|*
operator|,
name|u_int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|getkeyword
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|EXF
operator|*
operator|,
name|VICMDARG
operator|*
operator|,
name|u_int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|getmotion
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|EXF
operator|*
operator|,
name|VICMDARG
operator|*
operator|,
name|VICMDARG
operator|*
operator|,
name|MARK
operator|*
operator|,
name|MARK
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Side-effect:  *	The dot structure can be set by the underlying vi functions,  *	see v_Put() and v_put().  */
end_comment

begin_define
define|#
directive|define
name|DOT
value|(&VIP(sp)->sdot)
end_define

begin_define
define|#
directive|define
name|DOTMOTION
value|(&VIP(sp)->sdotmotion)
end_define

begin_comment
comment|/*  * vi --  * 	Main vi command loop.  */
end_comment

begin_function
name|int
name|vi
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
block|{
name|MARK
name|abs
decl_stmt|,
name|fm
decl_stmt|,
name|tm
decl_stmt|,
name|m
decl_stmt|;
name|VICMDARG
name|cmd
decl_stmt|,
modifier|*
name|vp
decl_stmt|;
name|u_int
name|flags
decl_stmt|,
name|saved_mode
decl_stmt|;
name|int
name|comcount
decl_stmt|,
name|eval
decl_stmt|;
comment|/* Start vi. */
if|if
condition|(
name|v_init
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Paint the screen. */
if|if
condition|(
name|sp
operator|->
name|s_refresh
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|v_end
argument_list|(
name|sp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* Command initialization. */
name|memset
argument_list|(
operator|&
name|cmd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|VICMDARG
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|eval
operator|=
literal|0
operator|,
name|vp
operator|=
operator|&
name|cmd
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|!
name|MAPPED_KEYS_WAITING
argument_list|(
name|sp
argument_list|)
operator|&&
name|log_cursor
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|)
condition|)
goto|goto
name|err
goto|;
comment|/* 		 * We get a command, which may or may not have an associated 		 * motion.  If it does, we get it too, calling its underlying 		 * function to get the resulting mark.  We then call the 		 * command setting the cursor to the resulting mark. 		 */
if|if
condition|(
name|getcmd
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|DOT
argument_list|,
name|vp
argument_list|,
name|NULL
argument_list|,
operator|&
name|comcount
argument_list|)
condition|)
goto|goto
name|err
goto|;
comment|/* 		 * Historical practice: if a dot command gets a new count, 		 * any motion component goes away, i.e. "d3w2." deletes a 		 * total of 5 words. 		 */
if|if
condition|(
name|F_ISSET
argument_list|(
name|vp
argument_list|,
name|VC_ISDOT
argument_list|)
operator|&&
name|comcount
condition|)
name|DOTMOTION
operator|->
name|count
operator|=
literal|1
expr_stmt|;
comment|/* Get any associated keyword. */
name|flags
operator|=
name|vp
operator|->
name|kp
operator|->
name|flags
expr_stmt|;
if|if
condition|(
name|LF_ISSET
argument_list|(
name|V_KEYNUM
operator||
name|V_KEYW
argument_list|)
operator|&&
name|getkeyword
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|vp
argument_list|,
name|flags
argument_list|)
condition|)
goto|goto
name|err
goto|;
comment|/* If a non-relative movement, copy the future absolute mark. */
if|if
condition|(
name|LF_ISSET
argument_list|(
name|V_ABS
argument_list|)
condition|)
block|{
name|abs
operator|.
name|lno
operator|=
name|sp
operator|->
name|lno
expr_stmt|;
name|abs
operator|.
name|cno
operator|=
name|sp
operator|->
name|cno
expr_stmt|;
block|}
comment|/* 		 * Do any required motion; getmotion sets the from MARK 		 * and the line mode flag. 		 */
if|if
condition|(
name|LF_ISSET
argument_list|(
name|V_MOTION
argument_list|)
condition|)
block|{
if|if
condition|(
name|getmotion
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|DOTMOTION
argument_list|,
name|vp
argument_list|,
operator|&
name|fm
argument_list|,
operator|&
name|tm
argument_list|)
condition|)
goto|goto
name|err
goto|;
block|}
else|else
block|{
comment|/* 			 * Set everything to the current cursor position. 			 * Line commands (ex: Y) default to the current line. 			 */
name|tm
operator|.
name|lno
operator|=
name|fm
operator|.
name|lno
operator|=
name|sp
operator|->
name|lno
expr_stmt|;
name|tm
operator|.
name|cno
operator|=
name|fm
operator|.
name|cno
operator|=
name|sp
operator|->
name|cno
expr_stmt|;
comment|/* 			 * Set line mode flag, for example, "yy". 			 * 			 * If a count is set, we set the to MARK here relative 			 * to the cursor/from MARK.  This is done for commands 			 * that take both counts and motions, i.e. "4yy" and 			 * "y%" -- there's no way the command can known which 			 * the user did, so we have to do it here.  There are 			 * other commands that are line mode commands and take 			 * counts ("#G", "#H") and for which this calculation 			 * is either meaningless or wrong.  Each command must 			 * do its own validity checking of the value. 			 */
if|if
condition|(
name|F_ISSET
argument_list|(
name|vp
operator|->
name|kp
argument_list|,
name|V_LMODE
argument_list|)
condition|)
block|{
name|F_SET
argument_list|(
name|vp
argument_list|,
name|VC_LMODE
argument_list|)
expr_stmt|;
if|if
condition|(
name|F_ISSET
argument_list|(
name|vp
argument_list|,
name|VC_C1SET
argument_list|)
condition|)
block|{
name|tm
operator|.
name|lno
operator|=
name|sp
operator|->
name|lno
operator|+
name|vp
operator|->
name|count
operator|-
literal|1
expr_stmt|;
name|tm
operator|.
name|cno
operator|=
name|sp
operator|->
name|cno
expr_stmt|;
block|}
block|}
block|}
comment|/* Increment the command count. */
operator|++
name|sp
operator|->
name|ccnt
expr_stmt|;
comment|/* 		 * Call the function.  Set the return cursor to the current 		 * cursor position first -- the underlying routines don't 		 * bother to do the work if it doesn't move. 		 */
name|m
operator|.
name|lno
operator|=
name|sp
operator|->
name|lno
expr_stmt|;
name|m
operator|.
name|cno
operator|=
name|sp
operator|->
name|cno
expr_stmt|;
name|saved_mode
operator|=
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|S_SCREENS
operator||
name|S_MAJOR_CHANGE
argument_list|)
expr_stmt|;
if|if
condition|(
call|(
name|vp
operator|->
name|kp
operator|->
name|func
call|)
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|vp
argument_list|,
operator|&
name|fm
argument_list|,
operator|&
name|tm
argument_list|,
operator|&
name|m
argument_list|)
condition|)
goto|goto
name|err
goto|;
ifdef|#
directive|ifdef
name|DEBUG
comment|/* Make sure no function left the temporary space locked. */
if|if
condition|(
name|F_ISSET
argument_list|(
name|sp
operator|->
name|gp
argument_list|,
name|G_TMP_INUSE
argument_list|)
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"Error: vi: temporary buffer not released."
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* 		 * If that command took us out of vi or changed the screen, 		 * then exit the loop without further action. 		 */
if|if
condition|(
name|saved_mode
operator|!=
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|S_SCREENS
operator||
name|S_MAJOR_CHANGE
argument_list|)
condition|)
break|break;
comment|/* Set the absolute mark. */
if|if
condition|(
name|LF_ISSET
argument_list|(
name|V_ABS
argument_list|)
operator|&&
name|mark_set
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|ABSMARK1
argument_list|,
operator|&
name|abs
argument_list|,
literal|1
argument_list|)
condition|)
goto|goto
name|err
goto|;
comment|/* Set the dot command structure. */
if|if
condition|(
name|LF_ISSET
argument_list|(
name|V_DOT
argument_list|)
condition|)
block|{
operator|*
name|DOT
operator|=
name|cmd
expr_stmt|;
name|F_SET
argument_list|(
name|DOT
argument_list|,
name|VC_ISDOT
argument_list|)
expr_stmt|;
comment|/* 			 * If a count was supplied for both the command and 			 * its motion, the count was used only for the motion. 			 * Turn the count back on for the dot structure. 			 */
if|if
condition|(
name|F_ISSET
argument_list|(
name|vp
argument_list|,
name|VC_C1RESET
argument_list|)
condition|)
name|F_SET
argument_list|(
name|DOT
argument_list|,
name|VC_C1SET
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Some vi row movements are "attracted" to the last position 		 * set, i.e. the V_RCM commands are moths to the V_RCM_SET 		 * commands' candle.  It's broken into two parts.  Here we deal 		 * with the command flags.  In sp->relative(), we deal with the 		 * screen flags.  If the movement is to the EOL the vi command 		 * handles it.  If it's to the beginning, we handle it here. 		 * 		 * Note, some commands (e.g. _, ^) don't set the V_RCM_SETFNB 		 * flag, but do the work themselves.  The reason is that they 		 * have to modify the column in case they're being used as a 		 * motion component.  Other similar commands (e.g. +, -) don't 		 * have to modify the column because they are always line mode 		 * operations when used as motions, so the column number isn't 		 * of any interest. 		 * 		 * Does this totally violate the screen and editor layering? 		 * You betcha.  As they say, if you think you understand it, 		 * you don't. 		 */
switch|switch
condition|(
name|LF_ISSET
argument_list|(
name|V_RCM
operator||
name|V_RCM_SETFNB
operator||
name|V_RCM_SETLAST
operator||
name|V_RCM_SETLFNB
operator||
name|V_RCM_SETNNB
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
break|break;
case|case
name|V_RCM
case|:
name|m
operator|.
name|cno
operator|=
name|sp
operator|->
name|s_relative
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|m
operator|.
name|lno
argument_list|)
expr_stmt|;
break|break;
case|case
name|V_RCM_SETLAST
case|:
name|sp
operator|->
name|rcmflags
operator|=
name|RCM_LAST
expr_stmt|;
break|break;
case|case
name|V_RCM_SETLFNB
case|:
if|if
condition|(
name|fm
operator|.
name|lno
operator|!=
name|m
operator|.
name|lno
condition|)
block|{
if|if
condition|(
name|nonblank
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|m
operator|.
name|lno
argument_list|,
operator|&
name|m
operator|.
name|cno
argument_list|)
condition|)
goto|goto
name|err
goto|;
name|sp
operator|->
name|rcmflags
operator|=
name|RCM_FNB
expr_stmt|;
block|}
break|break;
case|case
name|V_RCM_SETFNB
case|:
name|m
operator|.
name|cno
operator|=
literal|0
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|V_RCM_SETNNB
case|:
if|if
condition|(
name|nonblank
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|m
operator|.
name|lno
argument_list|,
operator|&
name|m
operator|.
name|cno
argument_list|)
condition|)
goto|goto
name|err
goto|;
name|sp
operator|->
name|rcmflags
operator|=
name|RCM_FNB
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Update the cursor. */
name|sp
operator|->
name|lno
operator|=
name|m
operator|.
name|lno
expr_stmt|;
name|sp
operator|->
name|cno
operator|=
name|m
operator|.
name|cno
expr_stmt|;
if|if
condition|(
operator|!
name|MAPPED_KEYS_WAITING
argument_list|(
name|sp
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|msg_rpt
argument_list|(
name|sp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
condition|)
name|err
label|:
name|term_map_flush
argument_list|(
name|sp
argument_list|,
literal|"Vi error"
argument_list|)
expr_stmt|;
block|}
comment|/* Refresh the screen. */
if|if
condition|(
name|sp
operator|->
name|s_refresh
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|)
condition|)
block|{
name|eval
operator|=
literal|1
expr_stmt|;
break|break;
block|}
comment|/* Set the new favorite position. */
if|if
condition|(
name|LF_ISSET
argument_list|(
name|V_RCM_SET
argument_list|)
condition|)
block|{
name|sp
operator|->
name|rcmflags
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|sp
operator|->
name|s_column
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|sp
operator|->
name|rcm
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|v_end
argument_list|(
name|sp
argument_list|)
operator|||
name|eval
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|KEY
parameter_list|(
name|key
parameter_list|,
name|map
parameter_list|)
value|{							\ 	if (getkey(sp,&ikey, map))					\ 		return (1);						\ 	key = ikey.ch;							\ }
end_define

begin_comment
comment|/*  * getcmd --  *  * The command structure for vi is less complex than ex (and don't think  * I'm not grateful!)  The command syntax is:  *  *	[count] [buffer] [count] key [[motion] | [buffer] [character]]  *  * and there are several special cases.  The motion value is itself a vi  * command, with the syntax:  *  *	[count] key [character]  */
end_comment

begin_function
specifier|static
name|int
name|getcmd
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|,
name|dp
parameter_list|,
name|vp
parameter_list|,
name|ismotion
parameter_list|,
name|comcountp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
name|VICMDARG
modifier|*
name|dp
decl_stmt|,
decl|*
name|vp
decl_stmt|;
end_function

begin_decl_stmt
name|VICMDARG
modifier|*
name|ismotion
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Previous key if getting motion component. */
end_comment

begin_decl_stmt
name|int
modifier|*
name|comcountp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|VIKEYS
specifier|const
modifier|*
name|kp
decl_stmt|;
name|u_int
name|flags
decl_stmt|;
name|CH
name|ikey
decl_stmt|;
name|CHAR_T
name|key
decl_stmt|;
comment|/* Refresh the command structure. */
name|memset
argument_list|(
operator|&
name|vp
operator|->
name|vp_startzero
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|vp
operator|->
name|vp_endzero
operator|-
operator|(
name|char
operator|*
operator|)
operator|&
name|vp
operator|->
name|vp_startzero
argument_list|)
expr_stmt|;
comment|/* An escape bells the user if in command mode. */
if|if
condition|(
name|getkey
argument_list|(
name|sp
argument_list|,
operator|&
name|ikey
argument_list|,
name|TXT_MAPCOMMAND
argument_list|)
condition|)
block|{
if|if
condition|(
name|ikey
operator|.
name|value
operator|==
name|K_ESCAPE
operator|&&
name|ismotion
operator|==
name|NULL
condition|)
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_BERR
argument_list|,
literal|"Already in command mode"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|key
operator|=
name|ikey
operator|.
name|ch
expr_stmt|;
if|if
condition|(
name|key
operator|>
name|MAXVIKEY
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_BERR
argument_list|,
literal|"%s isn't a vi command"
argument_list|,
name|charname
argument_list|(
name|sp
argument_list|,
name|key
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* Pick up optional buffer. */
if|if
condition|(
name|key
operator|==
literal|'"'
condition|)
block|{
name|KEY
argument_list|(
name|vp
operator|->
name|buffer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|F_SET
argument_list|(
name|vp
argument_list|,
name|VC_BUFFER
argument_list|)
expr_stmt|;
name|KEY
argument_list|(
name|key
argument_list|,
name|TXT_MAPCOMMAND
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Pick up optional count, where a leading 0 is not a count, 	 * it's a command. 	 */
if|if
condition|(
name|isdigit
argument_list|(
name|key
argument_list|)
operator|&&
name|key
operator|!=
literal|'0'
condition|)
block|{
if|if
condition|(
name|getcount
argument_list|(
name|sp
argument_list|,
name|key
argument_list|,
operator|&
name|vp
operator|->
name|count
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|F_SET
argument_list|(
name|vp
argument_list|,
name|VC_C1SET
argument_list|)
expr_stmt|;
operator|*
name|comcountp
operator|=
literal|1
expr_stmt|;
name|KEY
argument_list|(
name|key
argument_list|,
name|TXT_MAPCOMMAND
argument_list|)
expr_stmt|;
block|}
else|else
operator|*
name|comcountp
operator|=
literal|0
expr_stmt|;
comment|/* Pick up optional buffer. */
if|if
condition|(
name|key
operator|==
literal|'"'
condition|)
block|{
if|if
condition|(
name|F_ISSET
argument_list|(
name|vp
argument_list|,
name|VC_BUFFER
argument_list|)
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"Only one buffer can be specified."
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|KEY
argument_list|(
name|vp
operator|->
name|buffer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|F_SET
argument_list|(
name|vp
argument_list|,
name|VC_BUFFER
argument_list|)
expr_stmt|;
name|KEY
argument_list|(
name|key
argument_list|,
name|TXT_MAPCOMMAND
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Find the command.  The only legal command with no underlying 	 * function is dot. 	 */
name|kp
operator|=
name|vp
operator|->
name|kp
operator|=
operator|&
name|vikeys
index|[
name|vp
operator|->
name|key
operator|=
name|key
index|]
expr_stmt|;
if|if
condition|(
name|kp
operator|->
name|func
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|key
operator|!=
literal|'.'
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"%s isn't a command"
argument_list|,
name|charname
argument_list|(
name|sp
argument_list|,
name|key
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* If called for a motion command, stop now. */
if|if
condition|(
name|dp
operator|==
name|NULL
condition|)
goto|goto
name|usage
goto|;
comment|/* A repeatable command must have been executed. */
if|if
condition|(
operator|!
name|F_ISSET
argument_list|(
name|dp
argument_list|,
name|VC_ISDOT
argument_list|)
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"No command to repeat."
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 		 * !!! 		 * If a '.' is immediately entered after an undo command, we 		 * replay the log instead of redoing the last command.  This 		 * is necessary because 'u' can't set the dot command -- see 		 * vi/v_undo.c:v_undo for details. 		 */
if|if
condition|(
name|VIP
argument_list|(
name|sp
argument_list|)
operator|->
name|u_ccnt
operator|==
name|sp
operator|->
name|ccnt
condition|)
block|{
name|vp
operator|->
name|kp
operator|=
operator|&
name|vikeys
index|[
literal|'u'
index|]
expr_stmt|;
name|F_SET
argument_list|(
name|vp
argument_list|,
name|VC_ISDOT
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Set new count/buffer, if any, and return. */
if|if
condition|(
name|F_ISSET
argument_list|(
name|vp
argument_list|,
name|VC_C1SET
argument_list|)
condition|)
block|{
name|F_SET
argument_list|(
name|dp
argument_list|,
name|VC_C1SET
argument_list|)
expr_stmt|;
name|dp
operator|->
name|count
operator|=
name|vp
operator|->
name|count
expr_stmt|;
block|}
if|if
condition|(
name|F_ISSET
argument_list|(
name|vp
argument_list|,
name|VC_BUFFER
argument_list|)
condition|)
name|dp
operator|->
name|buffer
operator|=
name|vp
operator|->
name|buffer
expr_stmt|;
operator|*
name|vp
operator|=
operator|*
name|dp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|flags
operator|=
name|kp
operator|->
name|flags
expr_stmt|;
comment|/* Check for illegal count. */
if|if
condition|(
name|F_ISSET
argument_list|(
name|vp
argument_list|,
name|VC_C1SET
argument_list|)
operator|&&
operator|!
name|LF_ISSET
argument_list|(
name|V_CNT
argument_list|)
condition|)
goto|goto
name|usage
goto|;
comment|/* Illegal motion command. */
if|if
condition|(
name|ismotion
operator|==
name|NULL
condition|)
block|{
comment|/* Illegal buffer. */
if|if
condition|(
operator|!
name|LF_ISSET
argument_list|(
name|V_OBUF
argument_list|)
operator|&&
name|F_ISSET
argument_list|(
name|vp
argument_list|,
name|VC_BUFFER
argument_list|)
condition|)
goto|goto
name|usage
goto|;
comment|/* Required buffer. */
if|if
condition|(
name|LF_ISSET
argument_list|(
name|V_RBUF
argument_list|)
condition|)
name|KEY
argument_list|(
name|vp
operator|->
name|buffer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 		 * Special case: '[', ']' and 'Z' commands.  Doesn't the 		 * fact that the *single* characters don't mean anything 		 * but the *doubled* characters do just frost your shorts? 		 */
if|if
condition|(
name|vp
operator|->
name|key
operator|==
literal|'['
operator|||
name|vp
operator|->
name|key
operator|==
literal|']'
operator|||
name|vp
operator|->
name|key
operator|==
literal|'Z'
condition|)
block|{
name|KEY
argument_list|(
name|key
argument_list|,
name|TXT_MAPCOMMAND
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|key
operator|!=
name|key
condition|)
goto|goto
name|usage
goto|;
block|}
comment|/* Special case: 'z' command. */
if|if
condition|(
name|vp
operator|->
name|key
operator|==
literal|'z'
condition|)
block|{
name|KEY
argument_list|(
name|vp
operator|->
name|character
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
name|vp
operator|->
name|character
argument_list|)
condition|)
block|{
if|if
condition|(
name|getcount
argument_list|(
name|sp
argument_list|,
name|vp
operator|->
name|character
argument_list|,
operator|&
name|vp
operator|->
name|count2
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|F_SET
argument_list|(
name|vp
argument_list|,
name|VC_C2SET
argument_list|)
expr_stmt|;
name|KEY
argument_list|(
name|vp
operator|->
name|character
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * Commands that have motion components can be doubled to 	 * imply the current line. 	 */
elseif|else
if|if
condition|(
name|ismotion
operator|->
name|key
operator|!=
name|key
operator|&&
operator|!
name|LF_ISSET
argument_list|(
name|V_MOVE
argument_list|)
condition|)
block|{
name|usage
label|:
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"Usage: %s"
argument_list|,
name|ismotion
operator|!=
name|NULL
condition|?
name|vikeys
index|[
name|ismotion
operator|->
name|key
index|]
operator|.
name|usage
else|:
name|kp
operator|->
name|usage
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* Required character. */
if|if
condition|(
name|LF_ISSET
argument_list|(
name|V_CHAR
argument_list|)
condition|)
name|KEY
argument_list|(
name|vp
operator|->
name|character
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * getmotion --  *  * Get resulting motion mark.  */
end_comment

begin_function
specifier|static
name|int
name|getmotion
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|,
name|dm
parameter_list|,
name|vp
parameter_list|,
name|fm
parameter_list|,
name|tm
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
name|VICMDARG
modifier|*
name|dm
decl_stmt|,
decl|*
name|vp
decl_stmt|;
end_function

begin_decl_stmt
name|MARK
modifier|*
name|fm
decl_stmt|,
modifier|*
name|tm
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|MARK
name|m
decl_stmt|;
name|VICMDARG
name|motion
decl_stmt|;
name|u_long
name|cnt
decl_stmt|;
name|int
name|notused
decl_stmt|;
comment|/* If '.' command, use the dot motion, else get the motion command. */
if|if
condition|(
name|F_ISSET
argument_list|(
name|vp
argument_list|,
name|VC_ISDOT
argument_list|)
condition|)
block|{
name|motion
operator|=
operator|*
name|dm
expr_stmt|;
name|F_SET
argument_list|(
operator|&
name|motion
argument_list|,
name|VC_ISDOT
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|getcmd
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|NULL
argument_list|,
operator|&
name|motion
argument_list|,
name|vp
argument_list|,
operator|&
name|notused
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 	 * A count may be provided both to the command and to the motion, in 	 * which case the count is multiplicative.  For example, "3y4y" is the 	 * same as "12yy".  This count is provided to the motion command and 	 * not to the regular function.  	 */
name|cnt
operator|=
name|motion
operator|.
name|count
operator|=
name|F_ISSET
argument_list|(
operator|&
name|motion
argument_list|,
name|VC_C1SET
argument_list|)
condition|?
name|motion
operator|.
name|count
else|:
literal|1
expr_stmt|;
if|if
condition|(
name|F_ISSET
argument_list|(
name|vp
argument_list|,
name|VC_C1SET
argument_list|)
condition|)
block|{
name|motion
operator|.
name|count
operator|*=
name|vp
operator|->
name|count
expr_stmt|;
name|F_SET
argument_list|(
operator|&
name|motion
argument_list|,
name|VC_C1SET
argument_list|)
expr_stmt|;
comment|/* 		 * Set flags to restore the original values of the command 		 * structure so dot commands can change the count values, 		 * e.g. "2dw" "3." deletes a total of five words. 		 */
name|F_CLR
argument_list|(
name|vp
argument_list|,
name|VC_C1SET
argument_list|)
expr_stmt|;
name|F_SET
argument_list|(
name|vp
argument_list|,
name|VC_C1RESET
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Some commands can be repeated to indicate the current line.  In 	 * this case, or if the command is a "line command", set the flags 	 * appropriately.  If not a doubled command, run the function to get 	 * the resulting mark.  	 */
if|if
condition|(
name|vp
operator|->
name|key
operator|==
name|motion
operator|.
name|key
condition|)
block|{
name|F_SET
argument_list|(
name|vp
argument_list|,
name|VC_LMODE
argument_list|)
expr_stmt|;
comment|/* 		 * Set the end of the command; the column is after the line. 		 * 		 * If the current line is missing, i.e. the file is empty, 		 * historic vi permitted a "cc" or "!!" command to insert 		 * text. 		 */
name|tm
operator|->
name|lno
operator|=
name|sp
operator|->
name|lno
operator|+
name|motion
operator|.
name|count
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|file_gline
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|tm
operator|->
name|lno
argument_list|,
operator|&
name|tm
operator|->
name|cno
argument_list|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|tm
operator|->
name|lno
operator|!=
literal|1
operator|||
name|vp
operator|->
name|key
operator|!=
literal|'c'
operator|&&
name|vp
operator|->
name|key
operator|!=
literal|'!'
condition|)
block|{
name|m
operator|.
name|lno
operator|=
name|sp
operator|->
name|lno
expr_stmt|;
name|m
operator|.
name|cno
operator|=
name|sp
operator|->
name|cno
expr_stmt|;
name|v_eof
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|tm
operator|->
name|cno
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Set the origin of the command. */
name|fm
operator|->
name|lno
operator|=
name|sp
operator|->
name|lno
expr_stmt|;
name|fm
operator|->
name|cno
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Motion commands change the underlying movement (*snarl*). 		 * For example, "l" is illegal at the end of a line, but "dl" 		 * is not.  Set flags so the function knows the situation. 		 */
name|F_SET
argument_list|(
operator|&
name|motion
argument_list|,
name|vp
operator|->
name|kp
operator|->
name|flags
operator|&
name|VC_COMMASK
argument_list|)
expr_stmt|;
comment|/* 		 * Everything starts at the current position.  This permits 		 * commands like 'j' and 'k', that are line oriented motions 		 * and have special cursor suck semantics when they are used 		 * as standalone commands, to ignore column positioning. 		 */
name|fm
operator|->
name|lno
operator|=
name|tm
operator|->
name|lno
operator|=
name|sp
operator|->
name|lno
expr_stmt|;
name|fm
operator|->
name|cno
operator|=
name|tm
operator|->
name|cno
operator|=
name|sp
operator|->
name|cno
expr_stmt|;
if|if
condition|(
call|(
name|motion
operator|.
name|kp
operator|->
name|func
call|)
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|motion
argument_list|,
name|fm
argument_list|,
name|NULL
argument_list|,
name|tm
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 		 * If the underlying motion was a line motion, set the flag 		 * in the command structure.  Underlying commands can also 		 * flag the movement as a line motion (see v_sentence). 		 */
if|if
condition|(
name|F_ISSET
argument_list|(
name|motion
operator|.
name|kp
argument_list|,
name|V_LMODE
argument_list|)
operator|||
name|F_ISSET
argument_list|(
operator|&
name|motion
argument_list|,
name|VC_LMODE
argument_list|)
condition|)
name|F_SET
argument_list|(
name|vp
argument_list|,
name|VC_LMODE
argument_list|)
expr_stmt|;
comment|/* 		 * If the motion is in the reverse direction, switch the from 		 * and to MARK's so that it's always in a forward direction. 		 * Because the motion is always from the from MARK to, but not 		 * including, the to MARK, the function may have modified the 		 * from MARK, so that it gets the one-past-the-place semantics 		 * we use; see v_match() for an example.  Also set a flag so 		 * that the underlying function knows that we did this; v_yank, 		 * for example, has to know so it gets the return cursor right. 		 */
if|if
condition|(
name|tm
operator|->
name|lno
operator|<
name|fm
operator|->
name|lno
operator|||
name|tm
operator|->
name|lno
operator|==
name|fm
operator|->
name|lno
operator|&&
name|tm
operator|->
name|cno
operator|<
name|fm
operator|->
name|cno
condition|)
block|{
name|m
operator|=
operator|*
name|fm
expr_stmt|;
operator|*
name|fm
operator|=
operator|*
name|tm
expr_stmt|;
operator|*
name|tm
operator|=
name|m
expr_stmt|;
name|F_SET
argument_list|(
name|vp
argument_list|,
name|VC_REVMOVE
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * If the command sets dot, save the motion structure.  The 	 * motion count was changed above and needs to be reset, that's 	 * why this is done here, and not in the calling routine. 	 */
if|if
condition|(
name|F_ISSET
argument_list|(
name|vp
operator|->
name|kp
argument_list|,
name|V_DOT
argument_list|)
condition|)
block|{
operator|*
name|dm
operator|=
name|motion
expr_stmt|;
name|dm
operator|->
name|count
operator|=
name|cnt
expr_stmt|;
block|}
comment|/* Let the underlying function know what motion command was used. */
name|vp
operator|->
name|mkp
operator|=
name|motion
operator|.
name|kp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_define
define|#
directive|define
name|innum
parameter_list|(
name|c
parameter_list|)
value|(isdigit(c) || strchr("abcdefABCDEF", c))
end_define

begin_comment
comment|/*  * getkeyword --  *	Get the "word" the cursor is on.  */
end_comment

begin_function
specifier|static
name|int
name|getkeyword
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|,
name|kp
parameter_list|,
name|flags
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
name|VICMDARG
modifier|*
name|kp
decl_stmt|;
name|u_int
name|flags
decl_stmt|;
block|{
name|recno_t
name|lno
decl_stmt|;
name|size_t
name|beg
decl_stmt|,
name|end
decl_stmt|,
name|len
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|file_gline
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|sp
operator|->
name|lno
argument_list|,
operator|&
name|len
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|file_lline
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|lno
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|lno
operator|==
literal|0
condition|)
name|v_eof
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|GETLINE_ERR
argument_list|(
name|sp
argument_list|,
name|sp
operator|->
name|lno
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|beg
operator|=
name|sp
operator|->
name|cno
expr_stmt|;
comment|/* May not be a keyword at all. */
if|if
condition|(
name|p
operator|==
name|NULL
operator|||
name|len
operator|==
literal|0
operator|||
name|LF_ISSET
argument_list|(
name|V_KEYW
argument_list|)
operator|&&
operator|!
name|inword
argument_list|(
name|p
index|[
name|beg
index|]
argument_list|)
operator|||
name|LF_ISSET
argument_list|(
name|V_KEYNUM
argument_list|)
operator|&&
operator|!
name|innum
argument_list|(
name|p
index|[
name|beg
index|]
argument_list|)
operator|&&
name|p
index|[
name|beg
index|]
operator|!=
literal|'-'
operator|&&
name|p
index|[
name|beg
index|]
operator|!=
literal|'+'
condition|)
block|{
name|noword
label|:
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_BERR
argument_list|,
literal|"Cursor not in a %s"
argument_list|,
name|LF_ISSET
argument_list|(
name|V_KEYW
argument_list|)
condition|?
literal|"word"
else|:
literal|"number"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * !!! 	 * Find the beginning/end of the keyword.  Keywords (V_KEYW) are 	 * used for cursor-word searching and for tags.  Historical vi 	 * only used the word in a tag search from the cursor to the end 	 * of the word, i.e. if the cursor was on the 'b' in " abc ", the 	 * tag was "bc".  For no particular reason, we make cursor word 	 * searches follow the same rule. 	 */
if|if
condition|(
name|beg
operator|!=
literal|0
condition|)
if|if
condition|(
name|LF_ISSET
argument_list|(
name|V_KEYW
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|MOVE_TO_KEYWORD_BEGINNING
for|for
control|(
init|;
condition|;
control|)
block|{
operator|--
name|beg
expr_stmt|;
if|if
condition|(
operator|!
name|inword
argument_list|(
name|p
index|[
name|beg
index|]
argument_list|)
condition|)
block|{
operator|++
name|beg
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|beg
operator|==
literal|0
condition|)
break|break;
block|}
endif|#
directive|endif
block|}
else|else
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
operator|--
name|beg
expr_stmt|;
if|if
condition|(
operator|!
name|innum
argument_list|(
name|p
index|[
name|beg
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|beg
operator|>
literal|0
operator|&&
name|p
index|[
name|beg
operator|-
literal|1
index|]
operator|==
literal|'0'
operator|&&
operator|(
name|p
index|[
name|beg
index|]
operator|==
literal|'X'
operator|||
name|p
index|[
name|beg
index|]
operator|==
literal|'x'
operator|)
condition|)
operator|--
name|beg
expr_stmt|;
else|else
operator|++
name|beg
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|beg
operator|==
literal|0
condition|)
break|break;
block|}
comment|/* Skip possible leading sign. */
if|if
condition|(
name|beg
operator|!=
literal|0
operator|&&
name|p
index|[
name|beg
index|]
operator|!=
literal|'0'
operator|&&
operator|(
name|p
index|[
name|beg
operator|-
literal|1
index|]
operator|==
literal|'+'
operator|||
name|p
index|[
name|beg
operator|-
literal|1
index|]
operator|==
literal|'-'
operator|)
condition|)
operator|--
name|beg
expr_stmt|;
block|}
if|if
condition|(
name|LF_ISSET
argument_list|(
name|V_KEYW
argument_list|)
condition|)
block|{
for|for
control|(
name|end
operator|=
name|sp
operator|->
name|cno
init|;
operator|++
name|end
operator|<
name|len
operator|&&
name|inword
argument_list|(
name|p
index|[
name|end
index|]
argument_list|)
condition|;
control|)
empty_stmt|;
operator|--
name|end
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|end
operator|=
name|sp
operator|->
name|cno
init|;
operator|++
name|end
operator|<
name|len
condition|;
control|)
block|{
if|if
condition|(
name|p
index|[
name|end
index|]
operator|==
literal|'X'
operator|||
name|p
index|[
name|end
index|]
operator|==
literal|'x'
condition|)
block|{
if|if
condition|(
name|end
operator|!=
name|beg
operator|+
literal|1
operator|||
name|p
index|[
name|beg
index|]
operator|!=
literal|'0'
condition|)
break|break;
continue|continue;
block|}
if|if
condition|(
operator|!
name|innum
argument_list|(
name|p
index|[
name|end
index|]
argument_list|)
condition|)
break|break;
block|}
comment|/* Just a sign isn't a number. */
if|if
condition|(
name|end
operator|==
name|beg
operator|&&
operator|(
name|p
index|[
name|beg
index|]
operator|==
literal|'+'
operator|||
name|p
index|[
name|beg
index|]
operator|==
literal|'-'
operator|)
condition|)
goto|goto
name|noword
goto|;
operator|--
name|end
expr_stmt|;
block|}
comment|/* 	 * Getting a keyword implies moving the cursor to its beginning. 	 * Refresh now. 	 */
if|if
condition|(
name|beg
operator|!=
name|sp
operator|->
name|cno
condition|)
block|{
name|sp
operator|->
name|cno
operator|=
name|beg
expr_stmt|;
name|sp
operator|->
name|s_refresh
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * XXX 	 * 8-bit clean problem.  Numeric keywords are handled using strtol(3) 	 * and friends.  This would have to be fixed in v_increment and here 	 * to not depend on a trailing NULL. 	 */
name|len
operator|=
operator|(
name|end
operator|-
name|beg
operator|)
operator|+
literal|2
expr_stmt|;
comment|/* XXX */
name|kp
operator|->
name|klen
operator|=
operator|(
name|end
operator|-
name|beg
operator|)
operator|+
literal|1
expr_stmt|;
name|BINC_RET
argument_list|(
name|sp
argument_list|,
name|kp
operator|->
name|keyword
argument_list|,
name|kp
operator|->
name|kbuflen
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|kp
operator|->
name|keyword
argument_list|,
name|p
operator|+
name|beg
argument_list|,
name|kp
operator|->
name|klen
argument_list|)
expr_stmt|;
name|kp
operator|->
name|keyword
index|[
name|kp
operator|->
name|klen
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* XXX */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * getcount --  *	Return the next count.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|getcount
parameter_list|(
name|sp
parameter_list|,
name|fkey
parameter_list|,
name|countp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|ARG_CHAR_T
name|fkey
decl_stmt|;
name|u_long
modifier|*
name|countp
decl_stmt|;
block|{
name|u_long
name|count
decl_stmt|,
name|tc
decl_stmt|;
name|CH
name|ikey
decl_stmt|;
name|ikey
operator|.
name|ch
operator|=
name|fkey
expr_stmt|;
name|count
operator|=
name|tc
operator|=
literal|0
expr_stmt|;
do|do
block|{
comment|/* Assume that overflow results in a smaller number. */
name|tc
operator|=
name|count
operator|*
literal|10
operator|+
name|ikey
operator|.
name|ch
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|count
operator|>
name|tc
condition|)
block|{
comment|/* Toss to the next non-digit. */
do|do
block|{
if|if
condition|(
name|getkey
argument_list|(
name|sp
argument_list|,
operator|&
name|ikey
argument_list|,
name|TXT_MAPCOMMAND
operator||
name|TXT_MAPNODIGIT
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
do|while
condition|(
name|isdigit
argument_list|(
name|ikey
operator|.
name|ch
argument_list|)
condition|)
do|;
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"Number larger than %lu"
argument_list|,
name|ULONG_MAX
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|count
operator|=
name|tc
expr_stmt|;
if|if
condition|(
name|getkey
argument_list|(
name|sp
argument_list|,
operator|&
name|ikey
argument_list|,
name|TXT_MAPCOMMAND
operator||
name|TXT_MAPNODIGIT
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
do|while
condition|(
name|isdigit
argument_list|(
name|ikey
operator|.
name|ch
argument_list|)
condition|)
do|;
operator|*
name|countp
operator|=
name|count
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * getkey --  *	Return the next key.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|getkey
parameter_list|(
name|sp
parameter_list|,
name|ikeyp
parameter_list|,
name|map
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|CH
modifier|*
name|ikeyp
decl_stmt|;
name|u_int
name|map
decl_stmt|;
block|{
switch|switch
condition|(
name|term_key
argument_list|(
name|sp
argument_list|,
name|ikeyp
argument_list|,
name|map
argument_list|)
condition|)
block|{
case|case
name|INP_OK
case|:
break|break;
case|case
name|INP_EOF
case|:
name|F_SET
argument_list|(
name|sp
argument_list|,
name|S_EXIT_FORCE
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|INP_ERR
case|:
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
name|ikeyp
operator|->
name|value
operator|==
name|K_ESCAPE
operator|)
return|;
block|}
end_function

end_unit

