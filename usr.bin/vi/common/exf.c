begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1992, 1993, 1994  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)exf.c	8.94 (Berkeley) 8/7/94"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_comment
comment|/*  * We include<sys/file.h>, because the flock(2) and open(2) #defines  * were found there on historical systems.  We also include<fcntl.h>  * because the open(2) #defines are found there on newer systems.  */
end_comment

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<bitstring.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<termios.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"compat.h"
end_include

begin_include
include|#
directive|include
file|<db.h>
end_include

begin_include
include|#
directive|include
file|<regex.h>
end_include

begin_include
include|#
directive|include
file|<pathnames.h>
end_include

begin_include
include|#
directive|include
file|"vi.h"
end_include

begin_include
include|#
directive|include
file|"excmd.h"
end_include

begin_comment
comment|/*  * file_add --  *	Insert a file name into the FREF list, if it doesn't already  *	appear in it.  *  * !!!  * The "if it doesn't already appear" changes vi's semantics slightly.  If  * you do a "vi foo bar", and then execute "next bar baz", the edit of bar  * will reflect the line/column of the previous edit session.  Historic nvi  * did not do this.  The change is a logical extension of the change where  * vi now remembers the last location in any file that it has ever edited,  * not just the previously edited file.  */
end_comment

begin_function
name|FREF
modifier|*
name|file_add
parameter_list|(
name|sp
parameter_list|,
name|name
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|CHAR_T
modifier|*
name|name
decl_stmt|;
block|{
name|FREF
modifier|*
name|frp
decl_stmt|;
comment|/* 	 * Return it if it already exists.  Note that we test against the 	 * user's name, whatever that happens to be, including if it's a 	 * temporary file. 	 */
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
for|for
control|(
name|frp
operator|=
name|sp
operator|->
name|frefq
operator|.
name|cqh_first
init|;
name|frp
operator|!=
operator|(
name|FREF
operator|*
operator|)
operator|&
name|sp
operator|->
name|frefq
condition|;
name|frp
operator|=
name|frp
operator|->
name|q
operator|.
name|cqe_next
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|frp
operator|->
name|name
argument_list|,
name|name
argument_list|)
condition|)
return|return
operator|(
name|frp
operator|)
return|;
comment|/* Allocate and initialize the FREF structure. */
name|CALLOC
argument_list|(
name|sp
argument_list|,
name|frp
argument_list|,
name|FREF
operator|*
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|FREF
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|frp
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* 	 * If no file name specified, or if the file name is a request 	 * for something temporary, file_init() will allocate the file 	 * name.  Temporary files are always ignored. 	 */
if|if
condition|(
name|name
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
name|TEMPORARY_FILE_STRING
argument_list|)
operator|&&
operator|(
name|frp
operator|->
name|name
operator|=
name|strdup
argument_list|(
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|FREE
argument_list|(
name|frp
argument_list|,
sizeof|sizeof
argument_list|(
name|FREF
argument_list|)
argument_list|)
expr_stmt|;
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_SYSERR
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* Append into the chain of file names. */
name|CIRCLEQ_INSERT_TAIL
argument_list|(
operator|&
name|sp
operator|->
name|frefq
argument_list|,
name|frp
argument_list|,
name|q
argument_list|)
expr_stmt|;
return|return
operator|(
name|frp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * file_init --  *	Start editing a file, based on the FREF structure.  If successsful,  *	let go of any previous file.  Don't release the previous file until  *	absolutely sure we have the new one.  */
end_comment

begin_function
name|int
name|file_init
parameter_list|(
name|sp
parameter_list|,
name|frp
parameter_list|,
name|rcv_name
parameter_list|,
name|force
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|FREF
modifier|*
name|frp
decl_stmt|;
name|char
modifier|*
name|rcv_name
decl_stmt|;
name|int
name|force
decl_stmt|;
block|{
name|EXF
modifier|*
name|ep
decl_stmt|;
name|RECNOINFO
name|oinfo
decl_stmt|;
name|struct
name|stat
name|sb
decl_stmt|;
name|size_t
name|psize
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|char
modifier|*
name|oname
decl_stmt|,
name|tname
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
comment|/* 	 * If the file is a recovery file, let the recovery code handle it. 	 * Clear the FR_RECOVER flag first -- the recovery code does set up, 	 * and then calls us!  If the recovery call fails, it's probably 	 * because the named file doesn't exist.  So, move boldly forward, 	 * presuming that there's an error message the user will get to see. 	 */
if|if
condition|(
name|F_ISSET
argument_list|(
name|frp
argument_list|,
name|FR_RECOVER
argument_list|)
condition|)
block|{
name|F_CLR
argument_list|(
name|frp
argument_list|,
name|FR_RECOVER
argument_list|)
expr_stmt|;
return|return
operator|(
name|rcv_read
argument_list|(
name|sp
argument_list|,
name|frp
argument_list|)
operator|)
return|;
block|}
comment|/* 	 * Required FRP initialization; the only flag we keep is the 	 * cursor information. 	 */
name|F_CLR
argument_list|(
name|frp
argument_list|,
operator|~
name|FR_CURSORSET
argument_list|)
expr_stmt|;
comment|/* 	 * Required EXF initialization: 	 *	Flush the line caches. 	 *	Default recover mail file fd to -1. 	 *	Set initial EXF flag bits. 	 */
name|CALLOC_RET
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|EXF
operator|*
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|EXF
argument_list|)
argument_list|)
expr_stmt|;
name|ep
operator|->
name|c_lno
operator|=
name|ep
operator|->
name|c_nlines
operator|=
name|OOBLNO
expr_stmt|;
name|ep
operator|->
name|rcv_fd
operator|=
name|ep
operator|->
name|fcntl_fd
operator|=
operator|-
literal|1
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|ep
operator|->
name|marks
argument_list|)
expr_stmt|;
name|F_SET
argument_list|(
name|ep
argument_list|,
name|F_FIRSTMODIFY
argument_list|)
expr_stmt|;
comment|/* 	 * If no name or backing file, create a backing temporary file, saving 	 * the temp file name so we can later unlink it.  If the user never 	 * named this file, copy the temporary file name to the real name (we 	 * display that until the user renames it). 	 */
if|if
condition|(
operator|(
name|oname
operator|=
name|frp
operator|->
name|name
operator|)
operator|==
name|NULL
operator|||
name|stat
argument_list|(
name|oname
argument_list|,
operator|&
name|sb
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|tname
argument_list|,
sizeof|sizeof
argument_list|(
name|tname
argument_list|)
argument_list|,
literal|"%s/vi.XXXXXX"
argument_list|,
name|O_STR
argument_list|(
name|sp
argument_list|,
name|O_DIRECTORY
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|mkstemp
argument_list|(
name|tname
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_SYSERR
argument_list|,
literal|"Temporary file"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|frp
operator|->
name|name
operator|==
name|NULL
condition|)
name|F_SET
argument_list|(
name|frp
argument_list|,
name|FR_TMPFILE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|frp
operator|->
name|tname
operator|=
name|strdup
argument_list|(
name|tname
argument_list|)
operator|)
operator|==
name|NULL
operator|||
name|frp
operator|->
name|name
operator|==
name|NULL
operator|&&
operator|(
name|frp
operator|->
name|name
operator|=
name|strdup
argument_list|(
name|tname
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|frp
operator|->
name|tname
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|frp
operator|->
name|tname
argument_list|)
expr_stmt|;
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_SYSERR
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|tname
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|oname
operator|=
name|frp
operator|->
name|tname
expr_stmt|;
name|psize
operator|=
literal|4
operator|*
literal|1024
expr_stmt|;
name|F_SET
argument_list|(
name|frp
argument_list|,
name|FR_NEWFILE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Try to keep it at 10 pages or less per file.  This 		 * isn't friendly on a loaded machine, btw. 		 */
if|if
condition|(
name|sb
operator|.
name|st_size
operator|<
literal|40
operator|*
literal|1024
condition|)
name|psize
operator|=
literal|4
operator|*
literal|1024
expr_stmt|;
elseif|else
if|if
condition|(
name|sb
operator|.
name|st_size
operator|<
literal|320
operator|*
literal|1024
condition|)
name|psize
operator|=
literal|32
operator|*
literal|1024
expr_stmt|;
else|else
name|psize
operator|=
literal|64
operator|*
literal|1024
expr_stmt|;
name|ep
operator|->
name|mtime
operator|=
name|sb
operator|.
name|st_mtime
expr_stmt|;
if|if
condition|(
operator|!
name|S_ISREG
argument_list|(
name|sb
operator|.
name|st_mode
argument_list|)
condition|)
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"Warning: %s is not a regular file"
argument_list|,
name|oname
argument_list|)
expr_stmt|;
block|}
comment|/* Set up recovery. */
name|memset
argument_list|(
operator|&
name|oinfo
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|RECNOINFO
argument_list|)
argument_list|)
expr_stmt|;
name|oinfo
operator|.
name|bval
operator|=
literal|'\n'
expr_stmt|;
comment|/* Always set. */
name|oinfo
operator|.
name|psize
operator|=
name|psize
expr_stmt|;
name|oinfo
operator|.
name|flags
operator|=
name|F_ISSET
argument_list|(
name|sp
operator|->
name|gp
argument_list|,
name|G_SNAPSHOT
argument_list|)
condition|?
name|R_SNAPSHOT
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|rcv_name
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|rcv_tmp
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|frp
operator|->
name|name
argument_list|)
condition|)
name|oinfo
operator|.
name|bfname
operator|=
name|ep
operator|->
name|rcv_path
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|ep
operator|->
name|rcv_path
operator|=
name|strdup
argument_list|(
name|rcv_name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_SYSERR
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|oinfo
operator|.
name|bfname
operator|=
name|ep
operator|->
name|rcv_path
expr_stmt|;
name|F_SET
argument_list|(
name|ep
argument_list|,
name|F_MODIFIED
argument_list|)
expr_stmt|;
block|}
comment|/* Open a db structure. */
if|if
condition|(
operator|(
name|ep
operator|->
name|db
operator|=
name|dbopen
argument_list|(
name|rcv_name
operator|==
name|NULL
condition|?
name|oname
else|:
name|NULL
argument_list|,
name|O_NONBLOCK
operator||
name|O_RDONLY
argument_list|,
name|DEFFILEMODE
argument_list|,
name|DB_RECNO
argument_list|,
operator|&
name|oinfo
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_SYSERR
argument_list|,
name|rcv_name
operator|==
name|NULL
condition|?
name|oname
else|:
name|rcv_name
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* 	 * Do the remaining things that can cause failure of the new file, 	 * mark and logging initialization. 	 */
if|if
condition|(
name|mark_init
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|)
operator|||
name|log_init
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|)
condition|)
goto|goto
name|err
goto|;
comment|/* 	 * Close the previous file; if that fails, close the new one and 	 * run for the border. 	 * 	 * !!! 	 * There's a nasty special case.  If the user edits a temporary file, 	 * and then does an ":e! %", we need to re-initialize the backing 	 * file, but we can't change the name.  (It's worse -- we're dealing 	 * with *names* here, we can't even detect that it happened.)  Set a 	 * flag so that the file_end routine ignores the backing information 	 * of the old file if it happens to be the same as the new one. 	 * 	 * !!! 	 * Side-effect: after the call to file_end(), sp->frp may be NULL. 	 */
name|F_SET
argument_list|(
name|frp
argument_list|,
name|FR_DONTDELETE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|ep
operator|!=
name|NULL
operator|&&
name|file_end
argument_list|(
name|sp
argument_list|,
name|sp
operator|->
name|ep
argument_list|,
name|force
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|file_end
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|F_CLR
argument_list|(
name|frp
argument_list|,
name|FR_DONTDELETE
argument_list|)
expr_stmt|;
comment|/* 	 * Lock the file; if it's a recovery file, it should already be 	 * locked.  Note, we acquire the lock after the previous file 	 * has been ended, so that we don't get an "already locked" error 	 * for ":edit!". 	 * 	 * XXX 	 * While the user can't interrupt us between the open and here, 	 * there's a race between the dbopen() and the lock.  Not much 	 * we can do about it. 	 * 	 * XXX 	 * We don't make a big deal of not being able to lock the file.  As 	 * locking rarely works over NFS, and often fails if the file was 	 * mmap(2)'d, it's far too common to do anything like print an error 	 * message, let alone make the file readonly.  At some future time, 	 * when locking is a little more reliable, this should change to be 	 * an error. 	 */
if|if
condition|(
name|rcv_name
operator|==
name|NULL
condition|)
switch|switch
condition|(
name|file_lock
argument_list|(
name|oname
argument_list|,
operator|&
name|ep
operator|->
name|fcntl_fd
argument_list|,
name|ep
operator|->
name|db
operator|->
name|fd
argument_list|(
name|ep
operator|->
name|db
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
block|{
case|case
name|LOCK_FAILED
case|:
name|F_SET
argument_list|(
name|frp
argument_list|,
name|FR_UNLOCKED
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOCK_UNAVAIL
case|:
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_INFO
argument_list|,
literal|"%s already locked, session is read-only"
argument_list|,
name|oname
argument_list|)
expr_stmt|;
name|F_SET
argument_list|(
name|frp
argument_list|,
name|FR_RDONLY
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOCK_SUCCESS
case|:
break|break;
block|}
comment|/* 	 * The -R flag, or doing a "set readonly" during a session causes 	 * all files edited during the session (using an edit command, or 	 * even using tags) to be marked read-only.  Changing the file name 	 * (see ex/ex_file.c), clears this flag. 	 * 	 * Otherwise, try and figure out if a file is readonly.  This is a 	 * dangerous thing to do.  The kernel is the only arbiter of whether 	 * or not a file is writeable, and the best that a user program can 	 * do is guess.  Obvious loopholes are files that are on a file system 	 * mounted readonly (access catches this one on a few systems), or 	 * alternate protection mechanisms, ACL's for example, that we can't 	 * portably check.  Lots of fun, and only here because users whined. 	 * 	 * !!! 	 * Historic vi displayed the readonly message if none of the file 	 * write bits were set, or if an an access(2) call on the path 	 * failed.  This seems reasonable.  If the file is mode 444, root 	 * users may want to know that the owner of the file did not expect 	 * it to be written. 	 * 	 * Historic vi set the readonly bit if no write bits were set for 	 * a file, even if the access call would have succeeded.  This makes 	 * the superuser force the write even when vi expects that it will 	 * succeed.  I'm less supportive of this semantic, but it's historic 	 * practice and the conservative approach to vi'ing files as root. 	 * 	 * It would be nice if there was some way to update this when the user 	 * does a "^Z; chmod ...".  The problem is that we'd first have to 	 * distinguish between readonly bits set because of file permissions 	 * and those set for other reasons.  That's not too hard, but deciding 	 * when to reevaluate the permissions is trickier.  An alternative 	 * might be to turn off the readonly bit if the user forces a write 	 * and it succeeds. 	 * 	 * XXX 	 * Access(2) doesn't consider the effective uid/gid values.  This 	 * probably isn't a problem for vi when it's running standalone. 	 */
if|if
condition|(
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_READONLY
argument_list|)
operator|||
operator|!
name|F_ISSET
argument_list|(
name|frp
argument_list|,
name|FR_NEWFILE
argument_list|)
operator|&&
operator|(
operator|!
operator|(
name|sb
operator|.
name|st_mode
operator|&
operator|(
name|S_IWUSR
operator||
name|S_IWGRP
operator||
name|S_IWOTH
operator|)
operator|)
operator|||
name|access
argument_list|(
name|frp
operator|->
name|name
argument_list|,
name|W_OK
argument_list|)
operator|)
condition|)
name|F_SET
argument_list|(
name|frp
argument_list|,
name|FR_RDONLY
argument_list|)
expr_stmt|;
comment|/* 	 * Set the alternate file name to be the file we've just discarded. 	 * 	 * !!! 	 * If the current file was a temporary file, the call to file_end() 	 * unlinked it and free'd the name.  So, there is no previous file, 	 * and there is no alternate file name.  This matches historical 	 * practice, although in historical vi it could only happen as the 	 * result of the initial command, i.e. if vi was executed without a 	 * file name. 	 */
name|set_alt_name
argument_list|(
name|sp
argument_list|,
name|sp
operator|->
name|frp
operator|==
name|NULL
condition|?
name|NULL
else|:
name|sp
operator|->
name|frp
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* Switch... */
operator|++
name|ep
operator|->
name|refcnt
expr_stmt|;
name|sp
operator|->
name|ep
operator|=
name|ep
expr_stmt|;
name|sp
operator|->
name|frp
operator|=
name|frp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|err
label|:
if|if
condition|(
name|frp
operator|->
name|name
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|frp
operator|->
name|name
argument_list|)
expr_stmt|;
name|frp
operator|->
name|name
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|frp
operator|->
name|tname
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|frp
operator|->
name|tname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|frp
operator|->
name|tname
argument_list|)
expr_stmt|;
name|frp
operator|->
name|tname
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ep
operator|->
name|rcv_path
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|ep
operator|->
name|rcv_path
argument_list|)
expr_stmt|;
name|ep
operator|->
name|rcv_path
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ep
operator|->
name|db
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|ep
operator|->
name|db
operator|->
name|close
argument_list|(
name|ep
operator|->
name|db
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|ep
argument_list|,
sizeof|sizeof
argument_list|(
name|EXF
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * file_end --  *	Stop editing a file.  */
end_comment

begin_function
name|int
name|file_end
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|,
name|force
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
name|int
name|force
decl_stmt|;
block|{
name|FREF
modifier|*
name|frp
decl_stmt|;
comment|/* 	 * Clean up the FREF structure. 	 * 	 * Save the cursor location. 	 * 	 * XXX 	 * It would be cleaner to do this somewhere else, but by the time 	 * ex or vi knows that we're changing files it's already happened. 	 */
name|frp
operator|=
name|sp
operator|->
name|frp
expr_stmt|;
name|frp
operator|->
name|lno
operator|=
name|sp
operator|->
name|lno
expr_stmt|;
name|frp
operator|->
name|cno
operator|=
name|sp
operator|->
name|cno
expr_stmt|;
name|F_SET
argument_list|(
name|frp
argument_list|,
name|FR_CURSORSET
argument_list|)
expr_stmt|;
comment|/* 	 * We may no longer need the temporary backing file, so clean it 	 * up.  We don't need the FREF structure either, if the file was 	 * never named, so lose it. 	 * 	 * !!! 	 * Re: FR_DONTDELETE, see the comment above in file_init(). 	 */
if|if
condition|(
operator|!
name|F_ISSET
argument_list|(
name|frp
argument_list|,
name|FR_DONTDELETE
argument_list|)
operator|&&
name|frp
operator|->
name|tname
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|unlink
argument_list|(
name|frp
operator|->
name|tname
argument_list|)
condition|)
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_SYSERR
argument_list|,
literal|"%s: remove"
argument_list|,
name|frp
operator|->
name|tname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|frp
operator|->
name|tname
argument_list|)
expr_stmt|;
name|frp
operator|->
name|tname
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|F_ISSET
argument_list|(
name|frp
argument_list|,
name|FR_TMPFILE
argument_list|)
condition|)
block|{
name|CIRCLEQ_REMOVE
argument_list|(
operator|&
name|sp
operator|->
name|frefq
argument_list|,
name|frp
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|frp
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|frp
argument_list|)
expr_stmt|;
block|}
name|sp
operator|->
name|frp
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * Clean up the EXF structure. 	 * 	 * sp->ep MAY NOT BE THE SAME AS THE ARGUMENT ep, SO DON'T USE IT! 	 * 	 * If multiply referenced, just decrement the count and return. 	 */
if|if
condition|(
operator|--
name|ep
operator|->
name|refcnt
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Close the db structure. */
if|if
condition|(
name|ep
operator|->
name|db
operator|->
name|close
operator|!=
name|NULL
operator|&&
name|ep
operator|->
name|db
operator|->
name|close
argument_list|(
name|ep
operator|->
name|db
argument_list|)
operator|&&
operator|!
name|force
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"%s: close: %s"
argument_list|,
name|frp
operator|->
name|name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|ep
operator|->
name|refcnt
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* COMMITTED TO THE CLOSE.  THERE'S NO GOING BACK... */
comment|/* Stop logging. */
operator|(
name|void
operator|)
name|log_end
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|)
expr_stmt|;
comment|/* Free up any marks. */
operator|(
name|void
operator|)
name|mark_end
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|)
expr_stmt|;
comment|/* 	 * Delete recovery files, close the open descriptor, free recovery 	 * memory.  See recover.c for a description of the protocol. 	 * 	 * XXX 	 * Unlink backup file first, we can detect that the recovery file 	 * doesn't reference anything when the user tries to recover it. 	 * There's a race, here, obviously, but it's fairly small. 	 */
if|if
condition|(
operator|!
name|F_ISSET
argument_list|(
name|ep
argument_list|,
name|F_RCV_NORM
argument_list|)
condition|)
block|{
if|if
condition|(
name|ep
operator|->
name|rcv_path
operator|!=
name|NULL
operator|&&
name|unlink
argument_list|(
name|ep
operator|->
name|rcv_path
argument_list|)
condition|)
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"%s: remove: %s"
argument_list|,
name|ep
operator|->
name|rcv_path
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|rcv_mpath
operator|!=
name|NULL
operator|&&
name|unlink
argument_list|(
name|ep
operator|->
name|rcv_mpath
argument_list|)
condition|)
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"%s: remove: %s"
argument_list|,
name|ep
operator|->
name|rcv_mpath
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ep
operator|->
name|fcntl_fd
operator|!=
operator|-
literal|1
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|ep
operator|->
name|fcntl_fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|rcv_fd
operator|!=
operator|-
literal|1
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|ep
operator|->
name|rcv_fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|rcv_path
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|ep
operator|->
name|rcv_path
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|rcv_mpath
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|ep
operator|->
name|rcv_mpath
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|ep
argument_list|,
sizeof|sizeof
argument_list|(
name|EXF
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * file_write --  *	Write the file to disk.  Historic vi had fairly convoluted  *	semantics for whether or not writes would happen.  That's  *	why all the flags.  */
end_comment

begin_function
name|int
name|file_write
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|,
name|fm
parameter_list|,
name|tm
parameter_list|,
name|name
parameter_list|,
name|flags
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
name|MARK
modifier|*
name|fm
decl_stmt|,
decl|*
name|tm
decl_stmt|;
end_function

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flags
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|stat
name|sb
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|FREF
modifier|*
name|frp
decl_stmt|;
name|MARK
name|from
decl_stmt|,
name|to
decl_stmt|;
name|u_long
name|nlno
decl_stmt|,
name|nch
decl_stmt|;
name|int
name|btear
decl_stmt|,
name|fd
decl_stmt|,
name|noname
decl_stmt|,
name|oflags
decl_stmt|,
name|rval
decl_stmt|;
name|char
modifier|*
name|msg
decl_stmt|;
name|frp
operator|=
name|sp
operator|->
name|frp
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
block|{
name|noname
operator|=
literal|1
expr_stmt|;
name|name
operator|=
name|frp
operator|->
name|name
expr_stmt|;
block|}
else|else
name|noname
operator|=
literal|0
expr_stmt|;
comment|/* Can't write files marked read-only, unless forced. */
if|if
condition|(
operator|!
name|LF_ISSET
argument_list|(
name|FS_FORCE
argument_list|)
operator|&&
name|noname
operator|&&
name|F_ISSET
argument_list|(
name|frp
argument_list|,
name|FR_RDONLY
argument_list|)
condition|)
block|{
if|if
condition|(
name|LF_ISSET
argument_list|(
name|FS_POSSIBLE
argument_list|)
condition|)
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"Read-only file, not written; use ! to override"
argument_list|)
expr_stmt|;
else|else
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"Read-only file, not written"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* If not forced, not appending, and "writeany" not set ... */
if|if
condition|(
operator|!
name|LF_ISSET
argument_list|(
name|FS_FORCE
operator||
name|FS_APPEND
argument_list|)
operator|&&
operator|!
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_WRITEANY
argument_list|)
condition|)
block|{
comment|/* Don't overwrite anything but the original file. */
if|if
condition|(
operator|(
operator|!
name|noname
operator|||
name|F_ISSET
argument_list|(
name|frp
argument_list|,
name|FR_NAMECHANGE
argument_list|)
operator|)
operator|&&
operator|!
name|stat
argument_list|(
name|name
argument_list|,
operator|&
name|sb
argument_list|)
condition|)
block|{
if|if
condition|(
name|LF_ISSET
argument_list|(
name|FS_POSSIBLE
argument_list|)
condition|)
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"%s exists, not written; use ! to override"
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"%s exists, not written"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 		 * Don't write part of any existing file.  Only test for the 		 * original file, the previous test catches anything else. 		 */
if|if
condition|(
operator|!
name|LF_ISSET
argument_list|(
name|FS_ALL
argument_list|)
operator|&&
name|noname
operator|&&
operator|!
name|stat
argument_list|(
name|name
argument_list|,
operator|&
name|sb
argument_list|)
condition|)
block|{
if|if
condition|(
name|LF_ISSET
argument_list|(
name|FS_POSSIBLE
argument_list|)
condition|)
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"Use ! to write a partial file"
argument_list|)
expr_stmt|;
else|else
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"Partial file, not written"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
comment|/* 	 * Figure out if the file already exists -- if it doesn't, we display 	 * the "new file" message.  The stat might not be necessary, but we 	 * just repeat it because it's easier than hacking the previous tests. 	 * The information is only used for the user message and modification 	 * time test, so we can ignore the obvious race condition. 	 * 	 * If the user is overwriting a file other than the original file, and 	 * O_WRITEANY was what got us here (neither force nor append was set), 	 * display the "existing file" messsage.  Since the FR_NAMECHANGE flag 	 * is cleared on a successful write, the message only appears once when 	 * the user changes a file name.  This is historic practice. 	 * 	 * One final test.  If we're not forcing or appending, and we have a 	 * saved modification time, stop the user if it's been written since 	 * we last edited or wrote it, and make them force it. 	 */
if|if
condition|(
name|stat
argument_list|(
name|name
argument_list|,
operator|&
name|sb
argument_list|)
condition|)
name|msg
operator|=
literal|": new file"
expr_stmt|;
else|else
block|{
name|msg
operator|=
literal|""
expr_stmt|;
if|if
condition|(
operator|!
name|LF_ISSET
argument_list|(
name|FS_FORCE
operator||
name|FS_APPEND
argument_list|)
condition|)
block|{
if|if
condition|(
name|ep
operator|->
name|mtime
operator|&&
name|sb
operator|.
name|st_mtime
operator|>
name|ep
operator|->
name|mtime
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"%s: file modified more recently than this copy%s"
argument_list|,
name|name
argument_list|,
name|LF_ISSET
argument_list|(
name|FS_POSSIBLE
argument_list|)
condition|?
literal|"; use ! to override"
else|:
literal|""
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|noname
operator|||
name|F_ISSET
argument_list|(
name|frp
argument_list|,
name|FR_NAMECHANGE
argument_list|)
condition|)
name|msg
operator|=
literal|": existing file"
expr_stmt|;
block|}
block|}
comment|/* Set flags to either append or truncate. */
name|oflags
operator|=
name|O_CREAT
operator||
name|O_WRONLY
expr_stmt|;
if|if
condition|(
name|LF_ISSET
argument_list|(
name|FS_APPEND
argument_list|)
condition|)
name|oflags
operator||=
name|O_APPEND
expr_stmt|;
else|else
name|oflags
operator||=
name|O_TRUNC
expr_stmt|;
comment|/* Open the file. */
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|name
argument_list|,
name|oflags
argument_list|,
name|DEFFILEMODE
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_SYSERR
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* Use stdio for buffering. */
if|if
condition|(
operator|(
name|fp
operator|=
name|fdopen
argument_list|(
name|fd
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_SYSERR
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* Build fake addresses, if necessary. */
if|if
condition|(
name|fm
operator|==
name|NULL
condition|)
block|{
name|from
operator|.
name|lno
operator|=
literal|1
expr_stmt|;
name|from
operator|.
name|cno
operator|=
literal|0
expr_stmt|;
name|fm
operator|=
operator|&
name|from
expr_stmt|;
if|if
condition|(
name|file_lline
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|to
operator|.
name|lno
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|to
operator|.
name|cno
operator|=
literal|0
expr_stmt|;
name|tm
operator|=
operator|&
name|to
expr_stmt|;
block|}
comment|/* Turn on the busy message. */
name|btear
operator|=
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|S_EXSILENT
argument_list|)
condition|?
literal|0
else|:
operator|!
name|busy_on
argument_list|(
name|sp
argument_list|,
literal|"Writing..."
argument_list|)
expr_stmt|;
name|rval
operator|=
name|ex_writefp
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|name
argument_list|,
name|fp
argument_list|,
name|fm
argument_list|,
name|tm
argument_list|,
operator|&
name|nlno
argument_list|,
operator|&
name|nch
argument_list|)
expr_stmt|;
if|if
condition|(
name|btear
condition|)
name|busy_off
argument_list|(
name|sp
argument_list|)
expr_stmt|;
comment|/* 	 * Save the new last modification time -- even if the write fails 	 * we re-init the time.  That way the user can clean up the disk 	 * and rewrite without having to force it. 	 */
name|ep
operator|->
name|mtime
operator|=
name|stat
argument_list|(
name|name
argument_list|,
operator|&
name|sb
argument_list|)
condition|?
literal|0
else|:
name|sb
operator|.
name|st_mtime
expr_stmt|;
comment|/* If the write failed, complain loudly. */
if|if
condition|(
name|rval
condition|)
block|{
if|if
condition|(
operator|!
name|LF_ISSET
argument_list|(
name|FS_APPEND
argument_list|)
condition|)
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"%s: WARNING: file truncated!"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * Once we've actually written the file, it doesn't matter that the 	 * file name was changed -- if it was, we've already whacked it. 	 */
name|F_CLR
argument_list|(
name|frp
argument_list|,
name|FR_NAMECHANGE
argument_list|)
expr_stmt|;
comment|/* 	 * If wrote the entire file clear the modified bit.  If the file was 	 * written back to the original file name and the file is a temporary, 	 * set the "no exit" bit.  This permits the user to write the file and 	 * use it in the context of the file system, but still keeps them from 	 * losing their changes by exiting. 	 */
if|if
condition|(
name|LF_ISSET
argument_list|(
name|FS_ALL
argument_list|)
condition|)
block|{
name|F_CLR
argument_list|(
name|ep
argument_list|,
name|F_MODIFIED
argument_list|)
expr_stmt|;
if|if
condition|(
name|F_ISSET
argument_list|(
name|frp
argument_list|,
name|FR_TMPFILE
argument_list|)
condition|)
if|if
condition|(
name|noname
condition|)
name|F_SET
argument_list|(
name|frp
argument_list|,
name|FR_TMPEXIT
argument_list|)
expr_stmt|;
else|else
name|F_CLR
argument_list|(
name|frp
argument_list|,
name|FR_TMPEXIT
argument_list|)
expr_stmt|;
block|}
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_INFO
argument_list|,
literal|"%s%s%s: %lu line%s, %lu characters"
argument_list|,
name|INTERRUPTED
argument_list|(
name|sp
argument_list|)
condition|?
literal|"Interrupted write: "
else|:
literal|""
argument_list|,
name|name
argument_list|,
name|msg
argument_list|,
name|nlno
argument_list|,
name|nlno
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|,
name|nch
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * file_m1 --  * 	First modification check routine.  The :next, :prev, :rewind, :tag,  *	:tagpush, :tagpop, ^^ modifications check.  */
end_comment

begin_function
name|int
name|file_m1
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|,
name|force
parameter_list|,
name|flags
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
name|int
name|force
decl_stmt|,
name|flags
decl_stmt|;
block|{
comment|/* 	 * If the file has been modified, we'll want to write it back or 	 * fail.  If autowrite is set, we'll write it back automatically, 	 * unless force is also set.  Otherwise, we fail unless forced or 	 * there's another open screen on this file. 	 */
if|if
condition|(
name|F_ISSET
argument_list|(
name|ep
argument_list|,
name|F_MODIFIED
argument_list|)
condition|)
if|if
condition|(
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_AUTOWRITE
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|force
operator|&&
name|file_write
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|flags
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|ep
operator|->
name|refcnt
operator|<=
literal|1
operator|&&
operator|!
name|force
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"File modified since last complete write; write or use %s to override"
argument_list|,
name|LF_ISSET
argument_list|(
name|FS_POSSIBLE
argument_list|)
condition|?
literal|"!"
else|:
literal|":edit!"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
name|file_m3
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|force
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * file_m2 --  * 	Second modification check routine.  The :edit, :quit, :recover  *	modifications check.  */
end_comment

begin_function
name|int
name|file_m2
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|,
name|force
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
name|int
name|force
decl_stmt|;
block|{
comment|/* 	 * If the file has been modified, we'll want to fail, unless forced 	 * or there's another open screen on this file. 	 */
if|if
condition|(
name|F_ISSET
argument_list|(
name|ep
argument_list|,
name|F_MODIFIED
argument_list|)
operator|&&
name|ep
operator|->
name|refcnt
operator|<=
literal|1
operator|&&
operator|!
name|force
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"File modified since last complete write; write or use ! to override"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
name|file_m3
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|force
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * file_m3 --  * 	Third modification check routine.  */
end_comment

begin_function
name|int
name|file_m3
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|,
name|force
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
name|int
name|force
decl_stmt|;
block|{
comment|/* 	 * Don't exit while in a temporary files if the file was ever modified. 	 * The problem is that if the user does a ":wq", we write and quit, 	 * unlinking the temporary file.  Not what the user had in mind at all. 	 * We permit writing to temporary files, so that user maps using file 	 * system names work with temporary files. 	 */
if|if
condition|(
name|F_ISSET
argument_list|(
name|sp
operator|->
name|frp
argument_list|,
name|FR_TMPEXIT
argument_list|)
operator|&&
name|ep
operator|->
name|refcnt
operator|<=
literal|1
operator|&&
operator|!
name|force
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"File is a temporary; exit will discard modifications"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * file_lock --  *	Get an exclusive lock on a file.  *   * XXX  * The default locking is flock(2) style, not fcntl(2).  The latter is  * known to fail badly on some systems, and its only advantage is that  * it occasionally works over NFS.  *  * Furthermore, the semantics of fcntl(2) are wrong.  The problems are  * two-fold: you can't close any file descriptor associated with the file  * without losing all of the locks, and you can't get an exclusive lock  * unless you have the file open for writing.  Someone ought to be shot,  * but it's probably too late, they may already have reproduced.  To get  * around these problems, nvi opens the files for writing when it can and  * acquires a second file descriptor when it can't.  The recovery files  * are examples of the former, they're always opened for writing.  The DB  * files can't be opened for writing because the semantics of DB are that  * files opened for writing are flushed back to disk when the DB session  * is ended. So, in that case we have to acquire an extra file descriptor.  */
end_comment

begin_function
name|enum
name|lockt
name|file_lock
parameter_list|(
name|name
parameter_list|,
name|fdp
parameter_list|,
name|fd
parameter_list|,
name|iswrite
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|fd
decl_stmt|,
decl|*
name|fdp
decl_stmt|,
name|iswrite
decl_stmt|;
end_function

begin_block
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|USE_FCNTL
argument_list|)
operator|&&
name|defined
argument_list|(
name|LOCK_EX
argument_list|)
comment|/* Hurrah!  We've got flock(2). */
comment|/* 	 * !!! 	 * We need to distinguish a lock not being available for the file 	 * from the file system not supporting locking.  Flock is documented 	 * as returning EWOULDBLOCK; add EAGAIN for good measure, and assume 	 * they are the former.  There's no portable way to do this. 	 */
name|errno
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|flock
argument_list|(
name|fd
argument_list|,
name|LOCK_EX
operator||
name|LOCK_NB
argument_list|)
condition|?
name|errno
operator|==
name|EAGAIN
operator|||
name|errno
operator|==
name|EWOULDBLOCK
condition|?
name|LOCK_UNAVAIL
else|:
name|LOCK_FAILED
else|:
name|LOCK_SUCCESS
operator|)
return|;
else|#
directive|else
comment|/* Gag me.  We've got fcntl(2). */
name|struct
name|flock
name|arg
decl_stmt|;
name|int
name|didopen
decl_stmt|,
name|sverrno
decl_stmt|;
name|arg
operator|.
name|l_type
operator|=
name|F_WRLCK
expr_stmt|;
name|arg
operator|.
name|l_whence
operator|=
literal|0
expr_stmt|;
comment|/* SEEK_SET */
name|arg
operator|.
name|l_start
operator|=
name|arg
operator|.
name|l_len
operator|=
literal|0
expr_stmt|;
name|arg
operator|.
name|l_pid
operator|=
literal|0
expr_stmt|;
comment|/* If the file descriptor isn't opened for writing, it must fail. */
if|if
condition|(
operator|!
name|iswrite
condition|)
block|{
if|if
condition|(
name|name
operator|==
name|NULL
operator|||
name|fdp
operator|==
name|NULL
condition|)
return|return
operator|(
name|LOCK_FAILED
operator|)
return|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|name
argument_list|,
name|O_RDWR
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|LOCK_FAILED
operator|)
return|;
operator|*
name|fdp
operator|=
name|fd
expr_stmt|;
name|didopen
operator|=
literal|1
expr_stmt|;
block|}
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_SETLK
argument_list|,
operator|&
name|arg
argument_list|)
condition|)
return|return
operator|(
name|LOCK_SUCCESS
operator|)
return|;
if|if
condition|(
name|didopen
condition|)
block|{
name|sverrno
operator|=
name|errno
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|errno
operator|=
name|sverrno
expr_stmt|;
block|}
comment|/* 	 * !!! 	 * We need to distinguish a lock not being available for the file 	 * from the file system not supporting locking.  Fcntl is documented 	 * as returning EACCESS and EAGAIN; add EWOULDBLOCK for good measure, 	 * and assume they are the former.  There's no portable way to do this. 	 */
return|return
operator|(
name|errno
operator|==
name|EACCES
operator|||
name|errno
operator|==
name|EAGAIN
operator|||
name|errno
operator|==
name|EWOULDBLOCK
condition|?
name|LOCK_UNAVAIL
else|:
name|LOCK_FAILED
operator|)
return|;
endif|#
directive|endif
block|}
end_block

end_unit

