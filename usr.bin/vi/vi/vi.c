begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1992, 1993, 1994  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)vi.c	8.91 (Berkeley) 8/17/94"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<bitstring.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<termios.h>
end_include

begin_include
include|#
directive|include
file|"compat.h"
end_include

begin_include
include|#
directive|include
file|<db.h>
end_include

begin_include
include|#
directive|include
file|<regex.h>
end_include

begin_include
include|#
directive|include
file|"vi.h"
end_include

begin_include
include|#
directive|include
file|"vcmd.h"
end_include

begin_decl_stmt
specifier|static
name|int
name|getcmd
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|EXF
operator|*
operator|,
name|VICMDARG
operator|*
operator|,
name|VICMDARG
operator|*
operator|,
name|VICMDARG
operator|*
operator|,
name|int
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|__inline
name|int
name|getcount
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|ARG_CHAR_T
operator|,
name|u_long
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|__inline
name|int
name|getkey
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|CH
operator|*
operator|,
name|u_int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|getkeyword
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|EXF
operator|*
operator|,
name|VICMDARG
operator|*
operator|,
name|u_int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|getmotion
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|EXF
operator|*
operator|,
name|VICMDARG
operator|*
operator|,
name|VICMDARG
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Side-effect:  *	The dot structure can be set by the underlying vi functions,  *	see v_Put() and v_put().  */
end_comment

begin_define
define|#
directive|define
name|DOT
value|(&VIP(sp)->sdot)
end_define

begin_define
define|#
directive|define
name|DOTMOTION
value|(&VIP(sp)->sdotmotion)
end_define

begin_comment
comment|/*  * vi --  * 	Main vi command loop.  */
end_comment

begin_function
name|int
name|vi
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
block|{
name|MARK
name|abs
decl_stmt|;
name|VICMDARG
name|cmd
decl_stmt|,
modifier|*
name|vp
decl_stmt|;
name|u_int
name|flags
decl_stmt|,
name|saved_mode
decl_stmt|;
name|int
name|comcount
decl_stmt|,
name|eval
decl_stmt|,
name|mapped
decl_stmt|;
comment|/* Start vi and paint the screen. */
if|if
condition|(
name|v_init
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Command initialization. */
name|memset
argument_list|(
operator|&
name|cmd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|VICMDARG
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|eval
operator|=
literal|0
operator|,
name|vp
operator|=
operator|&
name|cmd
init|;
condition|;
control|)
block|{
comment|/* Refresh the screen. */
name|sp
operator|->
name|showmode
operator|=
literal|"Command"
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|s_refresh
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|)
condition|)
block|{
name|eval
operator|=
literal|1
expr_stmt|;
break|break;
block|}
comment|/* Set the new favorite position. */
if|if
condition|(
name|F_ISSET
argument_list|(
name|vp
argument_list|,
name|VM_RCM_SET
operator||
name|VM_RCM_SETFNB
operator||
name|VM_RCM_SETNNB
argument_list|)
condition|)
block|{
name|sp
operator|->
name|rcm_last
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|sp
operator|->
name|s_column
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|sp
operator|->
name|rcm
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * If not currently in a map, log the cursor position, 		 * and set a flag so that this command can become the 		 * DOT command. 		 */
if|if
condition|(
name|MAPPED_KEYS_WAITING
argument_list|(
name|sp
argument_list|)
condition|)
name|mapped
operator|=
literal|1
expr_stmt|;
else|else
block|{
if|if
condition|(
name|log_cursor
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|)
condition|)
goto|goto
name|err
goto|;
name|mapped
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 		 * We get a command, which may or may not have an associated 		 * motion.  If it does, we get it too, calling its underlying 		 * function to get the resulting mark.  We then call the 		 * command setting the cursor to the resulting mark. 		 */
if|if
condition|(
name|getcmd
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|DOT
argument_list|,
name|vp
argument_list|,
name|NULL
argument_list|,
operator|&
name|comcount
argument_list|,
operator|&
name|mapped
argument_list|)
condition|)
goto|goto
name|err
goto|;
comment|/* 		 * Historical practice: if a dot command gets a new count, 		 * any motion component goes away, i.e. "d3w2." deletes a 		 * total of 5 words. 		 */
if|if
condition|(
name|F_ISSET
argument_list|(
name|vp
argument_list|,
name|VC_ISDOT
argument_list|)
operator|&&
name|comcount
condition|)
name|DOTMOTION
operator|->
name|count
operator|=
literal|1
expr_stmt|;
comment|/* Copy the key flags into the local structure. */
name|F_SET
argument_list|(
name|vp
argument_list|,
name|vp
operator|->
name|kp
operator|->
name|flags
argument_list|)
expr_stmt|;
comment|/* Get any associated keyword. */
if|if
condition|(
name|F_ISSET
argument_list|(
name|vp
argument_list|,
name|V_KEYNUM
operator||
name|V_KEYW
argument_list|)
operator|&&
name|getkeyword
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|vp
argument_list|,
name|vp
operator|->
name|flags
argument_list|)
condition|)
goto|goto
name|err
goto|;
comment|/* Prepare to set the previous context. */
if|if
condition|(
name|F_ISSET
argument_list|(
name|vp
argument_list|,
name|V_ABS
operator||
name|V_ABS_C
operator||
name|V_ABS_L
argument_list|)
condition|)
block|{
name|abs
operator|.
name|lno
operator|=
name|sp
operator|->
name|lno
expr_stmt|;
name|abs
operator|.
name|cno
operator|=
name|sp
operator|->
name|cno
expr_stmt|;
block|}
comment|/* 		 * Set the three cursor locations to the current cursor.  The 		 * underlying routines don't bother if the cursor doesn't move. 		 * This also handles line commands (e.g. Y) defaulting to the 		 * current line. 		 */
name|vp
operator|->
name|m_start
operator|.
name|lno
operator|=
name|vp
operator|->
name|m_stop
operator|.
name|lno
operator|=
name|vp
operator|->
name|m_final
operator|.
name|lno
operator|=
name|sp
operator|->
name|lno
expr_stmt|;
name|vp
operator|->
name|m_start
operator|.
name|cno
operator|=
name|vp
operator|->
name|m_stop
operator|.
name|cno
operator|=
name|vp
operator|->
name|m_final
operator|.
name|cno
operator|=
name|sp
operator|->
name|cno
expr_stmt|;
comment|/* 		 * Do any required motion; getmotion sets the from MARK and the 		 * line mode flag.  We save off the RCM mask and only restore 		 * it if it no RCM flags are set by the motion command.  This 		 * means that the motion command is expected to determine where 		 * the cursor ends up! 		 */
if|if
condition|(
name|F_ISSET
argument_list|(
name|vp
argument_list|,
name|V_MOTION
argument_list|)
condition|)
block|{
name|flags
operator|=
name|F_ISSET
argument_list|(
name|vp
argument_list|,
name|VM_RCM_MASK
argument_list|)
expr_stmt|;
name|F_CLR
argument_list|(
name|vp
argument_list|,
name|VM_RCM_MASK
argument_list|)
expr_stmt|;
if|if
condition|(
name|getmotion
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|DOTMOTION
argument_list|,
name|vp
argument_list|,
operator|&
name|mapped
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|F_ISSET
argument_list|(
name|vp
argument_list|,
name|VM_NOMOTION
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|F_ISSET
argument_list|(
name|vp
argument_list|,
name|VM_RCM_MASK
argument_list|)
condition|)
name|F_SET
argument_list|(
name|vp
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * If a count is set and the command is line oriented, set the 		 * to MARK here relative to the cursor/from MARK.  This is for 		 * commands that take both counts and motions, i.e. "4yy" and 		 * "y%".  As there's no way the command can know which the user 		 * did, we have to do it here.  (There are commands that are 		 * line oriented and that take counts ("#G", "#H"), for which 		 * this calculation is either completely meaningless or wrong. 		 * Each command must validate the value for itself. 		 */
if|if
condition|(
name|F_ISSET
argument_list|(
name|vp
argument_list|,
name|VC_C1SET
argument_list|)
operator|&&
name|F_ISSET
argument_list|(
name|vp
argument_list|,
name|VM_LMODE
argument_list|)
condition|)
name|vp
operator|->
name|m_stop
operator|.
name|lno
operator|+=
name|vp
operator|->
name|count
operator|-
literal|1
expr_stmt|;
comment|/* Increment the command count. */
operator|++
name|sp
operator|->
name|ccnt
expr_stmt|;
comment|/* Save the mode and call the function. */
name|saved_mode
operator|=
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|S_SCREENS
operator||
name|S_MAJOR_CHANGE
argument_list|)
expr_stmt|;
if|if
condition|(
call|(
name|vp
operator|->
name|kp
operator|->
name|func
call|)
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|vp
argument_list|)
condition|)
goto|goto
name|err
goto|;
ifdef|#
directive|ifdef
name|DEBUG
comment|/* Make sure no function left the temporary space locked. */
if|if
condition|(
name|F_ISSET
argument_list|(
name|sp
operator|->
name|gp
argument_list|,
name|G_TMP_INUSE
argument_list|)
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"Error: vi: temporary buffer not released"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* 		 * If that command took us out of vi or changed the screen, 		 * then exit the loop without further action. 		 */
if|if
condition|(
name|saved_mode
operator|!=
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|S_SCREENS
operator||
name|S_MAJOR_CHANGE
argument_list|)
condition|)
break|break;
comment|/* 		 * Set the dot command structure. 		 * 		 * !!! 		 * Historically, no command which used any mapped keys became 		 * the dot command. 		 */
if|if
condition|(
name|F_ISSET
argument_list|(
name|vp
argument_list|,
name|V_DOT
argument_list|)
operator|&&
operator|!
name|mapped
condition|)
block|{
operator|*
name|DOT
operator|=
name|cmd
expr_stmt|;
name|F_SET
argument_list|(
name|DOT
argument_list|,
name|VC_ISDOT
argument_list|)
expr_stmt|;
comment|/* 			 * If a count was supplied for both the command and 			 * its motion, the count was used only for the motion. 			 * Turn the count back on for the dot structure. 			 */
if|if
condition|(
name|F_ISSET
argument_list|(
name|vp
argument_list|,
name|VC_C1RESET
argument_list|)
condition|)
name|F_SET
argument_list|(
name|DOT
argument_list|,
name|VC_C1SET
argument_list|)
expr_stmt|;
comment|/* VM flags aren't retained. */
name|F_CLR
argument_list|(
name|DOT
argument_list|,
name|VM_COMMASK
operator||
name|VM_RCM_MASK
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Some vi row movements are "attracted" to the last position 		 * set, i.e. the VM_RCM commands are moths to the VM_RCM_SET 		 * commands' candle.  It's broken into two parts.  Here we deal 		 * with the command flags.  In sp->relative(), we deal with the 		 * screen flags.  If the movement is to the EOL the vi command 		 * handles it.  If it's to the beginning, we handle it here. 		 * 		 * Note, some commands (e.g. _, ^) don't set the VM_RCM_SETFNB 		 * flag, but do the work themselves.  The reason is that they 		 * have to modify the column in case they're being used as a 		 * motion component.  Other similar commands (e.g. +, -) don't 		 * have to modify the column because they are always line mode 		 * operations when used as motions, so the column number isn't 		 * of any interest. 		 * 		 * Does this totally violate the screen and editor layering? 		 * You betcha.  As they say, if you think you understand it, 		 * you don't. 		 */
switch|switch
condition|(
name|F_ISSET
argument_list|(
name|vp
argument_list|,
name|VM_RCM_MASK
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
case|case
name|VM_RCM_SET
case|:
break|break;
case|case
name|VM_RCM
case|:
name|vp
operator|->
name|m_final
operator|.
name|cno
operator|=
name|sp
operator|->
name|s_rcm
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|vp
operator|->
name|m_final
operator|.
name|lno
argument_list|)
expr_stmt|;
break|break;
case|case
name|VM_RCM_SETLAST
case|:
name|sp
operator|->
name|rcm_last
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|VM_RCM_SETFNB
case|:
name|vp
operator|->
name|m_final
operator|.
name|cno
operator|=
literal|0
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|VM_RCM_SETNNB
case|:
if|if
condition|(
name|nonblank
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|vp
operator|->
name|m_final
operator|.
name|lno
argument_list|,
operator|&
name|vp
operator|->
name|m_final
operator|.
name|cno
argument_list|)
condition|)
goto|goto
name|err
goto|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Update the cursor. */
name|sp
operator|->
name|lno
operator|=
name|vp
operator|->
name|m_final
operator|.
name|lno
expr_stmt|;
name|sp
operator|->
name|cno
operator|=
name|vp
operator|->
name|m_final
operator|.
name|cno
expr_stmt|;
comment|/* 		 * Set the absolute mark -- set even if a tags or similar 		 * command, since the tag may be moving to the same file. 		 */
if|if
condition|(
operator|(
name|F_ISSET
argument_list|(
name|vp
argument_list|,
name|V_ABS
argument_list|)
operator|||
name|F_ISSET
argument_list|(
name|vp
argument_list|,
name|V_ABS_L
argument_list|)
operator|&&
name|sp
operator|->
name|lno
operator|!=
name|abs
operator|.
name|lno
operator|||
name|F_ISSET
argument_list|(
name|vp
argument_list|,
name|V_ABS_C
argument_list|)
operator|&&
operator|(
name|sp
operator|->
name|lno
operator|!=
name|abs
operator|.
name|lno
operator|||
name|sp
operator|->
name|cno
operator|!=
name|abs
operator|.
name|cno
operator|)
operator|)
operator|&&
name|mark_set
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|ABSMARK1
argument_list|,
operator|&
name|abs
argument_list|,
literal|1
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|MAPPED_KEYS_WAITING
argument_list|(
name|sp
argument_list|)
condition|)
operator|(
name|void
operator|)
name|msg_rpt
argument_list|(
name|sp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 		 * Check and clear the interrupts.  There's an obvious race, 		 * but it's not worth cleaning up.  This is done after the 		 * err: lable, so that if the "error" was an interupt it gets 		 * cleaned up. 		 * 		 * !!! 		 * Previous versions of nvi cleared mapped characters on error, 		 * even if it wasn't an interrupt.  This feature was removed as 		 * users complained that it wasn't historic practice and that 		 * they used leading (illegal)<escape> characters in the map 		 * to clean up vi state before the map was interpreted. 		 */
name|err
label|:
if|if
condition|(
name|INTERRUPTED
argument_list|(
name|sp
argument_list|)
condition|)
name|term_flush
argument_list|(
name|sp
argument_list|,
literal|"Interrupted"
argument_list|,
name|CH_MAPPED
argument_list|)
expr_stmt|;
name|CLR_INTERRUPT
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|}
comment|/* Free allocated keyword memory. */
if|if
condition|(
name|cmd
operator|.
name|keyword
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|cmd
operator|.
name|keyword
argument_list|)
expr_stmt|;
return|return
operator|(
name|v_end
argument_list|(
name|sp
argument_list|)
operator|||
name|eval
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|KEY
parameter_list|(
name|key
parameter_list|,
name|map
parameter_list|)
value|{							\ 	if (getkey(sp,&ikey, map))					\ 		return (1);						\ 	if (ikey.value == K_ESCAPE)					\ 		goto esc;						\ 	if (F_ISSET(&ikey, CH_MAPPED))					\ 		*mappedp = 1;						\ 	key = ikey.ch;							\ }
end_define

begin_comment
comment|/*  * The O_TILDEOP option makes the ~ command take a motion instead  * of a straight count.  This is the replacement structure we use  * instead of the one currently in the VIKEYS table.  *  * XXX  * Note, I used VC_Y instead of creating a new motion command, it's  * a lot easier.  */
end_comment

begin_decl_stmt
name|VIKEYS
specifier|const
name|tmotion
init|=
block|{
name|v_mulcase
block|,
name|V_CNT
operator||
name|V_DOT
operator||
name|V_MOTION
operator||
name|VC_Y
operator||
name|VM_RCM_SET
block|,
literal|"[count]~[count]motion"
block|,
literal|" ~ change case to motion"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * getcmd --  *  * The command structure for vi is less complex than ex (and don't think  * I'm not grateful!)  The command syntax is:  *  *	[count] [buffer] [count] key [[motion] | [buffer] [character]]  *  * and there are several special cases.  The motion value is itself a vi  * command, with the syntax:  *  *	[count] key [character]  */
end_comment

begin_function
specifier|static
name|int
name|getcmd
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|,
name|dp
parameter_list|,
name|vp
parameter_list|,
name|ismotion
parameter_list|,
name|comcountp
parameter_list|,
name|mappedp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
name|VICMDARG
modifier|*
name|dp
decl_stmt|,
decl|*
name|vp
decl_stmt|;
end_function

begin_decl_stmt
name|VICMDARG
modifier|*
name|ismotion
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Previous key if getting motion component. */
end_comment

begin_decl_stmt
name|int
modifier|*
name|comcountp
decl_stmt|,
modifier|*
name|mappedp
decl_stmt|;
end_decl_stmt

begin_block
block|{
enum|enum
block|{
name|COMMANDMODE
block|,
name|ISPARTIAL
block|,
name|NOTPARTIAL
block|}
name|cpart
enum|;
name|VIKEYS
specifier|const
modifier|*
name|kp
decl_stmt|;
name|u_int
name|flags
decl_stmt|;
name|CH
name|ikey
decl_stmt|;
name|CHAR_T
name|key
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
comment|/* Refresh the command structure. */
name|memset
argument_list|(
operator|&
name|vp
operator|->
name|vp_startzero
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|vp
operator|->
name|vp_endzero
operator|-
operator|(
name|char
operator|*
operator|)
operator|&
name|vp
operator|->
name|vp_startzero
argument_list|)
expr_stmt|;
comment|/* 	 * Get a key. 	 * 	 *<escape> cancels partial commands, i.e. a command where at least 	 * one non-numeric character has been entered.  Otherwise, it beeps 	 * the terminal. 	 * 	 * !!! 	 * POSIX 1003.2-1992 explicitly disallows cancelling commands where 	 * all that's been entered is a number, requiring that the terminal 	 * be alerted. 	 */
name|cpart
operator|=
name|ismotion
operator|==
name|NULL
condition|?
name|COMMANDMODE
else|:
name|ISPARTIAL
expr_stmt|;
name|KEY
argument_list|(
name|key
argument_list|,
name|TXT_MAPCOMMAND
argument_list|)
expr_stmt|;
if|if
condition|(
name|ismotion
operator|==
name|NULL
condition|)
name|cpart
operator|=
name|NOTPARTIAL
expr_stmt|;
comment|/* Pick up optional buffer. */
if|if
condition|(
name|key
operator|==
literal|'"'
condition|)
block|{
name|cpart
operator|=
name|ISPARTIAL
expr_stmt|;
if|if
condition|(
name|ismotion
operator|!=
name|NULL
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_BERR
argument_list|,
literal|"Buffers should be specified before the command"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|KEY
argument_list|(
name|vp
operator|->
name|buffer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|F_SET
argument_list|(
name|vp
argument_list|,
name|VC_BUFFER
argument_list|)
expr_stmt|;
name|KEY
argument_list|(
name|key
argument_list|,
name|TXT_MAPCOMMAND
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Pick up optional count, where a leading 0 is not a count, 	 * it's a command. 	 */
if|if
condition|(
name|isdigit
argument_list|(
name|key
argument_list|)
operator|&&
name|key
operator|!=
literal|'0'
condition|)
block|{
if|if
condition|(
name|getcount
argument_list|(
name|sp
argument_list|,
name|key
argument_list|,
operator|&
name|vp
operator|->
name|count
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|F_SET
argument_list|(
name|vp
argument_list|,
name|VC_C1SET
argument_list|)
expr_stmt|;
operator|*
name|comcountp
operator|=
literal|1
expr_stmt|;
name|KEY
argument_list|(
name|key
argument_list|,
name|TXT_MAPCOMMAND
argument_list|)
expr_stmt|;
block|}
else|else
operator|*
name|comcountp
operator|=
literal|0
expr_stmt|;
comment|/* Pick up optional buffer. */
if|if
condition|(
name|key
operator|==
literal|'"'
condition|)
block|{
name|cpart
operator|=
name|ISPARTIAL
expr_stmt|;
if|if
condition|(
name|F_ISSET
argument_list|(
name|vp
argument_list|,
name|VC_BUFFER
argument_list|)
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"Only one buffer can be specified"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|ismotion
operator|!=
name|NULL
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_BERR
argument_list|,
literal|"Buffers should be specified before the command"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|KEY
argument_list|(
name|vp
operator|->
name|buffer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|F_SET
argument_list|(
name|vp
argument_list|,
name|VC_BUFFER
argument_list|)
expr_stmt|;
name|KEY
argument_list|(
name|key
argument_list|,
name|TXT_MAPCOMMAND
argument_list|)
expr_stmt|;
block|}
comment|/* Check for an OOB command key. */
name|cpart
operator|=
name|ISPARTIAL
expr_stmt|;
if|if
condition|(
name|key
operator|>
name|MAXVIKEY
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_BERR
argument_list|,
literal|"%s isn't a vi command"
argument_list|,
name|KEY_NAME
argument_list|(
name|sp
argument_list|,
name|key
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|kp
operator|=
operator|&
name|vikeys
index|[
name|vp
operator|->
name|key
operator|=
name|key
index|]
expr_stmt|;
comment|/* The tildeop option makes the ~ command take a motion. */
if|if
condition|(
name|key
operator|==
literal|'~'
operator|&&
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_TILDEOP
argument_list|)
condition|)
name|kp
operator|=
operator|&
name|tmotion
expr_stmt|;
name|vp
operator|->
name|kp
operator|=
name|kp
expr_stmt|;
comment|/* 	 * Find the command.  The only legal command with no underlying 	 * function is dot.  It's historic practice that<escape> doesn't 	 * just erase the preceding number, it beeps the terminal as well. 	 * It's a common problem, so just beep the terminal unless verbose 	 * was set. 	 */
if|if
condition|(
name|kp
operator|->
name|func
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|key
operator|!=
literal|'.'
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|ikey
operator|.
name|value
operator|==
name|K_ESCAPE
condition|?
name|M_BERR
else|:
name|M_ERR
argument_list|,
literal|"%s isn't a vi command"
argument_list|,
name|KEY_NAME
argument_list|(
name|sp
argument_list|,
name|key
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* If called for a motion command, stop now. */
if|if
condition|(
name|dp
operator|==
name|NULL
condition|)
goto|goto
name|usage
goto|;
comment|/* A repeatable command must have been executed. */
if|if
condition|(
operator|!
name|F_ISSET
argument_list|(
name|dp
argument_list|,
name|VC_ISDOT
argument_list|)
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"No command to repeat"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 		 * !!! 		 * If a '.' is immediately entered after an undo command, we 		 * replay the log instead of redoing the last command.  This 		 * is necessary because 'u' can't set the dot command -- see 		 * vi/v_undo.c:v_undo for details. 		 */
if|if
condition|(
name|VIP
argument_list|(
name|sp
argument_list|)
operator|->
name|u_ccnt
operator|==
name|sp
operator|->
name|ccnt
condition|)
block|{
name|vp
operator|->
name|kp
operator|=
operator|&
name|vikeys
index|[
literal|'u'
index|]
expr_stmt|;
name|F_SET
argument_list|(
name|vp
argument_list|,
name|VC_ISDOT
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Set new count/buffer, if any, and return. */
if|if
condition|(
name|F_ISSET
argument_list|(
name|vp
argument_list|,
name|VC_C1SET
argument_list|)
condition|)
block|{
name|F_SET
argument_list|(
name|dp
argument_list|,
name|VC_C1SET
argument_list|)
expr_stmt|;
name|dp
operator|->
name|count
operator|=
name|vp
operator|->
name|count
expr_stmt|;
block|}
if|if
condition|(
name|F_ISSET
argument_list|(
name|vp
argument_list|,
name|VC_BUFFER
argument_list|)
condition|)
name|dp
operator|->
name|buffer
operator|=
name|vp
operator|->
name|buffer
expr_stmt|;
operator|*
name|vp
operator|=
operator|*
name|dp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Set the flags based on the command flags. */
name|flags
operator|=
name|kp
operator|->
name|flags
expr_stmt|;
comment|/* Check for illegal count. */
if|if
condition|(
name|F_ISSET
argument_list|(
name|vp
argument_list|,
name|VC_C1SET
argument_list|)
operator|&&
operator|!
name|LF_ISSET
argument_list|(
name|V_CNT
argument_list|)
condition|)
goto|goto
name|usage
goto|;
comment|/* Illegal motion command. */
if|if
condition|(
name|ismotion
operator|==
name|NULL
condition|)
block|{
comment|/* Illegal buffer. */
if|if
condition|(
operator|!
name|LF_ISSET
argument_list|(
name|V_OBUF
argument_list|)
operator|&&
name|F_ISSET
argument_list|(
name|vp
argument_list|,
name|VC_BUFFER
argument_list|)
condition|)
goto|goto
name|usage
goto|;
comment|/* Required buffer. */
if|if
condition|(
name|LF_ISSET
argument_list|(
name|V_RBUF
argument_list|)
condition|)
block|{
name|KEY
argument_list|(
name|vp
operator|->
name|buffer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|F_SET
argument_list|(
name|vp
argument_list|,
name|VC_BUFFER
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Special case: '[', ']' and 'Z' commands.  Doesn't the fact that 	 * the *single* characters don't mean anything but the *doubled* 	 * characters do just frost your shorts? 	 */
if|if
condition|(
name|vp
operator|->
name|key
operator|==
literal|'['
operator|||
name|vp
operator|->
name|key
operator|==
literal|']'
operator|||
name|vp
operator|->
name|key
operator|==
literal|'Z'
condition|)
block|{
comment|/* 		 * Historically, half entered [[, ]] or Z commands weren't 		 * cancelled by<escape>, the terminal was beeped instead. 		 * POSIX.2-1992 probably didn't notice, and requires that 		 * they be cancelled instead of beeping.  Seems fine to me. 		 */
name|KEY
argument_list|(
name|key
argument_list|,
name|TXT_MAPCOMMAND
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|key
operator|!=
name|key
condition|)
block|{
name|usage
label|:
if|if
condition|(
name|ismotion
operator|==
name|NULL
condition|)
name|s
operator|=
name|kp
operator|->
name|usage
expr_stmt|;
elseif|else
if|if
condition|(
name|ismotion
operator|->
name|key
operator|==
literal|'~'
operator|&&
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_TILDEOP
argument_list|)
condition|)
name|s
operator|=
name|tmotion
operator|.
name|usage
expr_stmt|;
else|else
name|s
operator|=
name|vikeys
index|[
name|ismotion
operator|->
name|key
index|]
operator|.
name|usage
expr_stmt|;
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"Usage: %s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
comment|/* Special case: 'z' command. */
if|if
condition|(
name|vp
operator|->
name|key
operator|==
literal|'z'
condition|)
block|{
name|KEY
argument_list|(
name|vp
operator|->
name|character
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
name|vp
operator|->
name|character
argument_list|)
condition|)
block|{
if|if
condition|(
name|getcount
argument_list|(
name|sp
argument_list|,
name|vp
operator|->
name|character
argument_list|,
operator|&
name|vp
operator|->
name|count2
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|F_SET
argument_list|(
name|vp
argument_list|,
name|VC_C2SET
argument_list|)
expr_stmt|;
name|KEY
argument_list|(
name|vp
operator|->
name|character
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Commands that have motion components can be doubled to 	 * imply the current line. 	 */
if|if
condition|(
name|ismotion
operator|!=
name|NULL
operator|&&
name|ismotion
operator|->
name|key
operator|!=
name|key
operator|&&
operator|!
name|LF_ISSET
argument_list|(
name|V_MOVE
argument_list|)
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"%s may not be used as a motion command"
argument_list|,
name|KEY_NAME
argument_list|(
name|sp
argument_list|,
name|key
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* Required character. */
if|if
condition|(
name|LF_ISSET
argument_list|(
name|V_CHAR
argument_list|)
condition|)
name|KEY
argument_list|(
name|vp
operator|->
name|character
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|esc
label|:
switch|switch
condition|(
name|cpart
condition|)
block|{
case|case
name|COMMANDMODE
case|:
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_BERR
argument_list|,
literal|"Already in command mode"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ISPARTIAL
case|:
break|break;
case|case
name|NOTPARTIAL
case|:
operator|(
name|void
operator|)
name|sp
operator|->
name|s_bell
argument_list|(
name|sp
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * getmotion --  *  * Get resulting motion mark.  */
end_comment

begin_function
specifier|static
name|int
name|getmotion
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|,
name|dm
parameter_list|,
name|vp
parameter_list|,
name|mappedp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
name|VICMDARG
modifier|*
name|dm
decl_stmt|,
decl|*
name|vp
decl_stmt|;
end_function

begin_decl_stmt
name|int
modifier|*
name|mappedp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|MARK
name|m
decl_stmt|;
name|VICMDARG
name|motion
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|u_long
name|cnt
decl_stmt|;
name|int
name|notused
decl_stmt|;
comment|/* 	 * If '.' command, use the dot motion, else get the motion command. 	 * Clear any line motion flags, the subsequent motion isn't always 	 * the same, i.e. "/aaa" may or may not be a line motion. 	 */
if|if
condition|(
name|F_ISSET
argument_list|(
name|vp
argument_list|,
name|VC_ISDOT
argument_list|)
condition|)
block|{
name|motion
operator|=
operator|*
name|dm
expr_stmt|;
name|F_SET
argument_list|(
operator|&
name|motion
argument_list|,
name|VC_ISDOT
argument_list|)
expr_stmt|;
name|F_CLR
argument_list|(
operator|&
name|motion
argument_list|,
name|VM_COMMASK
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|getcmd
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|NULL
argument_list|,
operator|&
name|motion
argument_list|,
name|vp
argument_list|,
operator|&
name|notused
argument_list|,
name|mappedp
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 	 * A count may be provided both to the command and to the motion, in 	 * which case the count is multiplicative.  For example, "3y4y" is the 	 * same as "12yy".  This count is provided to the motion command and 	 * not to the regular function. 	 */
name|cnt
operator|=
name|motion
operator|.
name|count
operator|=
name|F_ISSET
argument_list|(
operator|&
name|motion
argument_list|,
name|VC_C1SET
argument_list|)
condition|?
name|motion
operator|.
name|count
else|:
literal|1
expr_stmt|;
if|if
condition|(
name|F_ISSET
argument_list|(
name|vp
argument_list|,
name|VC_C1SET
argument_list|)
condition|)
block|{
name|motion
operator|.
name|count
operator|*=
name|vp
operator|->
name|count
expr_stmt|;
name|F_SET
argument_list|(
operator|&
name|motion
argument_list|,
name|VC_C1SET
argument_list|)
expr_stmt|;
comment|/* 		 * Set flags to restore the original values of the command 		 * structure so dot commands can change the count values, 		 * e.g. "2dw" "3." deletes a total of five words. 		 */
name|F_CLR
argument_list|(
name|vp
argument_list|,
name|VC_C1SET
argument_list|)
expr_stmt|;
name|F_SET
argument_list|(
name|vp
argument_list|,
name|VC_C1RESET
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Some commands can be repeated to indicate the current line.  In 	 * this case, or if the command is a "line command", set the flags 	 * appropriately.  If not a doubled command, run the function to get 	 * the resulting mark.  	 */
if|if
condition|(
name|vp
operator|->
name|key
operator|==
name|motion
operator|.
name|key
condition|)
block|{
name|F_SET
argument_list|(
name|vp
argument_list|,
name|VM_LDOUBLE
operator||
name|VM_LMODE
argument_list|)
expr_stmt|;
comment|/* Set the origin of the command. */
name|vp
operator|->
name|m_start
operator|.
name|lno
operator|=
name|sp
operator|->
name|lno
expr_stmt|;
name|vp
operator|->
name|m_start
operator|.
name|cno
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Set the end of the command. 		 * 		 * If the current line is missing, i.e. the file is empty, 		 * historic vi permitted a "cc" or "!!" command to insert 		 * text. 		 */
name|vp
operator|->
name|m_stop
operator|.
name|lno
operator|=
name|sp
operator|->
name|lno
operator|+
name|motion
operator|.
name|count
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|file_gline
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|vp
operator|->
name|m_stop
operator|.
name|lno
argument_list|,
operator|&
name|len
argument_list|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|vp
operator|->
name|m_stop
operator|.
name|lno
operator|!=
literal|1
operator|||
name|vp
operator|->
name|key
operator|!=
literal|'c'
operator|&&
name|vp
operator|->
name|key
operator|!=
literal|'!'
condition|)
block|{
name|m
operator|.
name|lno
operator|=
name|sp
operator|->
name|lno
expr_stmt|;
name|m
operator|.
name|cno
operator|=
name|sp
operator|->
name|cno
expr_stmt|;
name|v_eof
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|vp
operator|->
name|m_stop
operator|.
name|cno
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|vp
operator|->
name|m_stop
operator|.
name|cno
operator|=
name|len
condition|?
name|len
operator|-
literal|1
else|:
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Motion commands change the underlying movement (*snarl*). 		 * For example, "l" is illegal at the end of a line, but "dl" 		 * is not.  Set flags so the function knows the situation. 		 */
name|F_SET
argument_list|(
operator|&
name|motion
argument_list|,
name|vp
operator|->
name|kp
operator|->
name|flags
operator|&
name|VC_COMMASK
argument_list|)
expr_stmt|;
comment|/* 		 * Copy the key flags into the local structure, except for 		 * the RCM flags, the motion command will set the RCM flags 		 * in the vp structure as necessary. 		 */
name|F_SET
argument_list|(
operator|&
name|motion
argument_list|,
name|motion
operator|.
name|kp
operator|->
name|flags
operator|&
operator|~
name|VM_RCM_MASK
argument_list|)
expr_stmt|;
comment|/* 		 * Set the three cursor locations to the current cursor.  This 		 * permits commands like 'j' and 'k', that are line oriented 		 * motions and have special cursor suck semantics when they are 		 * used as standalone commands, to ignore column positioning. 		 */
name|motion
operator|.
name|m_final
operator|.
name|lno
operator|=
name|motion
operator|.
name|m_stop
operator|.
name|lno
operator|=
name|motion
operator|.
name|m_start
operator|.
name|lno
operator|=
name|sp
operator|->
name|lno
expr_stmt|;
name|motion
operator|.
name|m_final
operator|.
name|cno
operator|=
name|motion
operator|.
name|m_stop
operator|.
name|cno
operator|=
name|motion
operator|.
name|m_start
operator|.
name|cno
operator|=
name|sp
operator|->
name|cno
expr_stmt|;
comment|/* Run the function. */
if|if
condition|(
call|(
name|motion
operator|.
name|kp
operator|->
name|func
call|)
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|motion
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 		 * Copy cut buffer, line mode and cursor position information 		 * from the motion command structure, i.e. anything that the 		 * motion command can set for us.  The commands can flag the 		 * movement as a line motion (see v_sentence) as well as set 		 * the VM_RCM_* flags explicitly. 		 */
name|F_SET
argument_list|(
name|vp
argument_list|,
name|F_ISSET
argument_list|(
operator|&
name|motion
argument_list|,
name|VM_COMMASK
operator||
name|VM_RCM_MASK
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * Motion commands can reset all of the cursor information. 		 * If the motion is in the reverse direction, switch the 		 * from and to MARK's so that it's in a forward direction. 		 * Motions are from the from MARK to the to MARK (inclusive). 		 */
if|if
condition|(
name|motion
operator|.
name|m_start
operator|.
name|lno
operator|>
name|motion
operator|.
name|m_stop
operator|.
name|lno
operator|||
name|motion
operator|.
name|m_start
operator|.
name|lno
operator|==
name|motion
operator|.
name|m_stop
operator|.
name|lno
operator|&&
name|motion
operator|.
name|m_start
operator|.
name|cno
operator|>
name|motion
operator|.
name|m_stop
operator|.
name|cno
condition|)
block|{
name|vp
operator|->
name|m_start
operator|=
name|motion
operator|.
name|m_stop
expr_stmt|;
name|vp
operator|->
name|m_stop
operator|=
name|motion
operator|.
name|m_start
expr_stmt|;
block|}
else|else
block|{
name|vp
operator|->
name|m_start
operator|=
name|motion
operator|.
name|m_start
expr_stmt|;
name|vp
operator|->
name|m_stop
operator|=
name|motion
operator|.
name|m_stop
expr_stmt|;
block|}
name|vp
operator|->
name|m_final
operator|=
name|motion
operator|.
name|m_final
expr_stmt|;
block|}
comment|/* 	 * If the command sets dot, save the motion structure.  The motion 	 * count was changed above and needs to be reset, that's why this 	 * is done here, and not in the calling routine. 	 */
if|if
condition|(
name|F_ISSET
argument_list|(
name|vp
operator|->
name|kp
argument_list|,
name|V_DOT
argument_list|)
condition|)
block|{
operator|*
name|dm
operator|=
name|motion
expr_stmt|;
name|dm
operator|->
name|count
operator|=
name|cnt
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_define
define|#
directive|define
name|innum
parameter_list|(
name|c
parameter_list|)
value|(isdigit(c) || strchr("abcdefABCDEF", c))
end_define

begin_comment
comment|/*  * getkeyword --  *	Get the "word" the cursor is on.  */
end_comment

begin_function
specifier|static
name|int
name|getkeyword
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|,
name|kp
parameter_list|,
name|flags
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
name|VICMDARG
modifier|*
name|kp
decl_stmt|;
name|u_int
name|flags
decl_stmt|;
block|{
name|recno_t
name|lno
decl_stmt|;
name|size_t
name|beg
decl_stmt|,
name|end
decl_stmt|,
name|len
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|file_gline
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|sp
operator|->
name|lno
argument_list|,
operator|&
name|len
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|file_lline
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
operator|&
name|lno
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|lno
operator|==
literal|0
condition|)
name|v_eof
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|GETLINE_ERR
argument_list|(
name|sp
argument_list|,
name|sp
operator|->
name|lno
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * !!! 	 * Historically, tag commands skipped over any leading whitespace 	 * characters. 	 */
for|for
control|(
name|beg
operator|=
name|sp
operator|->
name|cno
init|;
name|beg
operator|<
name|len
operator|&&
name|isspace
argument_list|(
name|p
index|[
name|beg
index|]
argument_list|)
condition|;
operator|++
name|beg
control|)
empty_stmt|;
if|if
condition|(
name|beg
operator|>=
name|len
operator|||
name|LF_ISSET
argument_list|(
name|V_KEYW
argument_list|)
operator|&&
operator|!
name|inword
argument_list|(
name|p
index|[
name|beg
index|]
argument_list|)
operator|||
name|LF_ISSET
argument_list|(
name|V_KEYNUM
argument_list|)
operator|&&
operator|!
name|innum
argument_list|(
name|p
index|[
name|beg
index|]
argument_list|)
operator|&&
name|p
index|[
name|beg
index|]
operator|!=
literal|'-'
operator|&&
name|p
index|[
name|beg
index|]
operator|!=
literal|'+'
condition|)
goto|goto
name|noword
goto|;
comment|/* 	 * !!! 	 * Find the beginning/end of the keyword.  Keywords (V_KEYW) are 	 * used for cursor-word searching and for tags.  Historical vi 	 * only used the word in a tag search from the cursor to the end 	 * of the word, i.e. if the cursor was on the 'b' in " abc ", the 	 * tag was "bc".  For no particular reason, we make the cursor 	 * word searches follow the same rule. 	 */
if|if
condition|(
name|beg
operator|!=
literal|0
condition|)
if|if
condition|(
name|LF_ISSET
argument_list|(
name|V_KEYW
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|MOVE_TO_KEYWORD_BEGINNING
for|for
control|(
init|;
condition|;
control|)
block|{
operator|--
name|beg
expr_stmt|;
if|if
condition|(
operator|!
name|inword
argument_list|(
name|p
index|[
name|beg
index|]
argument_list|)
condition|)
block|{
operator|++
name|beg
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|beg
operator|==
literal|0
condition|)
break|break;
block|}
endif|#
directive|endif
block|}
else|else
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
operator|--
name|beg
expr_stmt|;
if|if
condition|(
operator|!
name|innum
argument_list|(
name|p
index|[
name|beg
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|beg
operator|>
literal|0
operator|&&
name|p
index|[
name|beg
operator|-
literal|1
index|]
operator|==
literal|'0'
operator|&&
operator|(
name|p
index|[
name|beg
index|]
operator|==
literal|'X'
operator|||
name|p
index|[
name|beg
index|]
operator|==
literal|'x'
operator|)
condition|)
operator|--
name|beg
expr_stmt|;
else|else
operator|++
name|beg
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|beg
operator|==
literal|0
condition|)
break|break;
block|}
comment|/* Skip possible leading sign. */
if|if
condition|(
name|beg
operator|!=
literal|0
operator|&&
name|p
index|[
name|beg
index|]
operator|!=
literal|'0'
operator|&&
operator|(
name|p
index|[
name|beg
operator|-
literal|1
index|]
operator|==
literal|'+'
operator|||
name|p
index|[
name|beg
operator|-
literal|1
index|]
operator|==
literal|'-'
operator|)
condition|)
operator|--
name|beg
expr_stmt|;
block|}
if|if
condition|(
name|LF_ISSET
argument_list|(
name|V_KEYW
argument_list|)
condition|)
block|{
for|for
control|(
name|end
operator|=
name|beg
init|;
operator|++
name|end
operator|<
name|len
operator|&&
name|inword
argument_list|(
name|p
index|[
name|end
index|]
argument_list|)
condition|;
control|)
empty_stmt|;
operator|--
name|end
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|end
operator|=
name|beg
init|;
operator|++
name|end
operator|<
name|len
condition|;
control|)
block|{
if|if
condition|(
name|p
index|[
name|end
index|]
operator|==
literal|'X'
operator|||
name|p
index|[
name|end
index|]
operator|==
literal|'x'
condition|)
block|{
if|if
condition|(
name|end
operator|!=
name|beg
operator|+
literal|1
operator|||
name|p
index|[
name|beg
index|]
operator|!=
literal|'0'
condition|)
break|break;
continue|continue;
block|}
if|if
condition|(
operator|!
name|innum
argument_list|(
name|p
index|[
name|end
index|]
argument_list|)
condition|)
break|break;
block|}
comment|/* Just a sign isn't a number. */
if|if
condition|(
name|end
operator|==
name|beg
operator|&&
operator|(
name|p
index|[
name|beg
index|]
operator|==
literal|'+'
operator|||
name|p
index|[
name|beg
index|]
operator|==
literal|'-'
operator|)
condition|)
block|{
name|noword
label|:
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_BERR
argument_list|,
literal|"Cursor not in a %s"
argument_list|,
name|LF_ISSET
argument_list|(
name|V_KEYW
argument_list|)
condition|?
literal|"word"
else|:
literal|"number"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
operator|--
name|end
expr_stmt|;
block|}
comment|/* 	 * Getting a keyword implies moving the cursor to its beginning. 	 * Refresh now. 	 */
if|if
condition|(
name|beg
operator|!=
name|sp
operator|->
name|cno
condition|)
block|{
name|sp
operator|->
name|cno
operator|=
name|beg
expr_stmt|;
name|sp
operator|->
name|s_refresh
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * XXX 	 * 8-bit clean problem.  Numeric keywords are handled using strtol(3) 	 * and friends.  This would have to be fixed in v_increment and here 	 * to not depend on a trailing NULL. 	 */
name|len
operator|=
operator|(
name|end
operator|-
name|beg
operator|)
operator|+
literal|2
expr_stmt|;
comment|/* XXX */
name|kp
operator|->
name|klen
operator|=
operator|(
name|end
operator|-
name|beg
operator|)
operator|+
literal|1
expr_stmt|;
name|BINC_RET
argument_list|(
name|sp
argument_list|,
name|kp
operator|->
name|keyword
argument_list|,
name|kp
operator|->
name|kbuflen
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|kp
operator|->
name|keyword
argument_list|,
name|p
operator|+
name|beg
argument_list|,
name|kp
operator|->
name|klen
argument_list|)
expr_stmt|;
name|kp
operator|->
name|keyword
index|[
name|kp
operator|->
name|klen
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* XXX */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * getcount --  *	Return the next count.  */
end_comment

begin_function
specifier|static
name|__inline
name|int
name|getcount
parameter_list|(
name|sp
parameter_list|,
name|fkey
parameter_list|,
name|countp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|ARG_CHAR_T
name|fkey
decl_stmt|;
name|u_long
modifier|*
name|countp
decl_stmt|;
block|{
name|u_long
name|count
decl_stmt|,
name|tc
decl_stmt|;
name|CH
name|ikey
decl_stmt|;
name|ikey
operator|.
name|ch
operator|=
name|fkey
expr_stmt|;
name|count
operator|=
name|tc
operator|=
literal|0
expr_stmt|;
do|do
block|{
comment|/* Assume that overflow results in a smaller number. */
name|tc
operator|=
name|count
operator|*
literal|10
operator|+
name|ikey
operator|.
name|ch
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|count
operator|>
name|tc
condition|)
block|{
comment|/* Toss to the next non-digit. */
do|do
block|{
if|if
condition|(
name|getkey
argument_list|(
name|sp
argument_list|,
operator|&
name|ikey
argument_list|,
name|TXT_MAPCOMMAND
operator||
name|TXT_MAPNODIGIT
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
do|while
condition|(
name|isdigit
argument_list|(
name|ikey
operator|.
name|ch
argument_list|)
condition|)
do|;
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"Number larger than %lu"
argument_list|,
name|ULONG_MAX
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|count
operator|=
name|tc
expr_stmt|;
if|if
condition|(
name|getkey
argument_list|(
name|sp
argument_list|,
operator|&
name|ikey
argument_list|,
name|TXT_MAPCOMMAND
operator||
name|TXT_MAPNODIGIT
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
do|while
condition|(
name|isdigit
argument_list|(
name|ikey
operator|.
name|ch
argument_list|)
condition|)
do|;
operator|*
name|countp
operator|=
name|count
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * getkey --  *	Return the next key.  */
end_comment

begin_function
specifier|static
name|__inline
name|int
name|getkey
parameter_list|(
name|sp
parameter_list|,
name|ikeyp
parameter_list|,
name|map
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|CH
modifier|*
name|ikeyp
decl_stmt|;
name|u_int
name|map
decl_stmt|;
block|{
switch|switch
condition|(
name|term_key
argument_list|(
name|sp
argument_list|,
name|ikeyp
argument_list|,
name|map
argument_list|)
condition|)
block|{
case|case
name|INP_EOF
case|:
case|case
name|INP_ERR
case|:
name|F_SET
argument_list|(
name|sp
argument_list|,
name|S_EXIT_FORCE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|INP_INTR
case|:
comment|/* 		 * !!! 		 * Historically, vi beeped on command level interrupts. 		 * 		 * Historically, vi exited to ex mode if no file was named 		 * on the command line, and two interrupts were generated 		 * in a row.  (Just figured you might want to know that.) 		 */
operator|(
name|void
operator|)
name|sp
operator|->
name|s_bell
argument_list|(
name|sp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|INP_OK
case|:
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* NOTREACHED */
block|}
end_function

end_unit

