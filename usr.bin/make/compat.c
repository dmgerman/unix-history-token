begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1988, 1989, 1990 The Regents of the University of California.  * Copyright (c) 1988, 1989 by Adam de Boor  * Copyright (c) 1989 by Berkeley Softworks  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Adam de Boor.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * @(#)compat.c	8.2 (Berkeley) 3/19/94  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__RCSID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/*-  * compat.c --  *	The routines in this file implement the full-compatibility  *	mode of PMake. Most of the special functionality of PMake  *	is available in this mode. Things not supported:  *	    - different shells.  *	    - friendly variable substitution.  *  * Interface:  *	Compat_Run	    Initialize things for this module and recreate  *	    	  	    thems as need creatin'  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|"make.h"
end_include

begin_include
include|#
directive|include
file|"hash.h"
end_include

begin_include
include|#
directive|include
file|"dir.h"
end_include

begin_include
include|#
directive|include
file|"job.h"
end_include

begin_comment
comment|/*  * The following array is used to make a fast determination of which  * characters are interpreted specially by the shell.  If a command  * contains any of these characters, it is executed by the shell, not  * directly by us.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|meta
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|GNode
modifier|*
name|curTarg
init|=
name|NILGNODE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|GNode
modifier|*
name|ENDNode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|CompatInterrupt
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|CompatRunCommand
name|__P
argument_list|(
operator|(
name|ClientData
operator|,
name|ClientData
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|CompatMake
name|__P
argument_list|(
operator|(
name|ClientData
operator|,
name|ClientData
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|sh_builtin
index|[]
init|=
block|{
literal|"alias"
block|,
literal|"cd"
block|,
literal|"eval"
block|,
literal|"exec"
block|,
literal|"exit"
block|,
literal|"read"
block|,
literal|"set"
block|,
literal|"ulimit"
block|,
literal|"unalias"
block|,
literal|"umask"
block|,
literal|"unset"
block|,
literal|"wait"
block|,
literal|":"
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * CompatInterrupt --  *	Interrupt the creation of the current target and remove it if  *	it ain't precious.  *  * Results:  *	None.  *  * Side Effects:  *	The target is removed and the process exits. If .INTERRUPT exists,  *	its commands are run first WITH INTERRUPTS IGNORED..  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|CompatInterrupt
parameter_list|(
name|signo
parameter_list|)
name|int
name|signo
decl_stmt|;
block|{
name|GNode
modifier|*
name|gn
decl_stmt|;
if|if
condition|(
operator|(
name|curTarg
operator|!=
name|NILGNODE
operator|)
operator|&&
operator|!
name|Targ_Precious
argument_list|(
name|curTarg
argument_list|)
condition|)
block|{
name|char
modifier|*
name|p1
decl_stmt|;
name|char
modifier|*
name|file
init|=
name|Var_Value
argument_list|(
name|TARGET
argument_list|,
name|curTarg
argument_list|,
operator|&
name|p1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|noExecute
operator|&&
name|eunlink
argument_list|(
name|file
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"*** %s removed\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
name|efree
argument_list|(
name|p1
argument_list|)
expr_stmt|;
comment|/* 	 * Run .INTERRUPT only if hit with interrupt signal 	 */
if|if
condition|(
name|signo
operator|==
name|SIGINT
condition|)
block|{
name|gn
operator|=
name|Targ_FindNode
argument_list|(
literal|".INTERRUPT"
argument_list|,
name|TARG_NOCREATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|gn
operator|!=
name|NILGNODE
condition|)
block|{
name|Lst_ForEach
argument_list|(
name|gn
operator|->
name|commands
argument_list|,
name|CompatRunCommand
argument_list|,
operator|(
name|ClientData
operator|)
name|gn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|signo
operator|==
name|SIGQUIT
condition|)
name|exit
argument_list|(
name|signo
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|signo
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|kill
argument_list|(
name|getpid
argument_list|()
argument_list|,
name|signo
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * shellneed --  *	  * Results:  *	Returns 1 if a specified line must be executed by the shell,  *	0 if it can be run via execve, and -1 if the command is a no-op.  *  * Side Effects:  *	None.  *	  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|shellneed
parameter_list|(
name|cmd
parameter_list|)
name|char
modifier|*
name|cmd
decl_stmt|;
block|{
name|char
modifier|*
modifier|*
name|av
decl_stmt|,
modifier|*
modifier|*
name|p
decl_stmt|;
name|int
name|ac
decl_stmt|;
name|av
operator|=
name|brk_string
argument_list|(
name|cmd
argument_list|,
operator|&
name|ac
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|sh_builtin
init|;
operator|*
name|p
operator|!=
literal|0
condition|;
name|p
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|av
index|[
literal|1
index|]
argument_list|,
operator|*
name|p
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * CompatRunCommand --  *	Execute the next command for a target. If the command returns an  *	error, the node's made field is set to ERROR and creation stops.  *  * Results:  *	0 if the command succeeded, 1 if an error occurred.  *  * Side Effects:  *	The node's 'made' field may be set to ERROR.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|CompatRunCommand
parameter_list|(
name|cmdp
parameter_list|,
name|gnp
parameter_list|)
name|ClientData
name|cmdp
decl_stmt|;
comment|/* Command to execute */
name|ClientData
name|gnp
decl_stmt|;
comment|/* Node from which the command came */
block|{
name|char
modifier|*
name|cmdStart
decl_stmt|;
comment|/* Start of expanded command */
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|Boolean
name|silent
decl_stmt|,
comment|/* Don't print command */
name|errCheck
decl_stmt|;
comment|/* Check errors */
name|int
name|reason
decl_stmt|;
comment|/* Reason for child's death */
name|int
name|status
decl_stmt|;
comment|/* Description of child's death */
name|int
name|cpid
decl_stmt|;
comment|/* Child actually found */
name|ReturnStatus
name|stat
decl_stmt|;
comment|/* Status of fork */
name|LstNode
name|cmdNode
decl_stmt|;
comment|/* Node where current command is located */
name|char
modifier|*
modifier|*
name|av
decl_stmt|;
comment|/* Argument vector for thing to exec */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments in av or 0 if not 				 * dynamically allocated */
name|Boolean
name|local
decl_stmt|;
comment|/* TRUE if command should be executed 				 * locally */
name|int
name|internal
decl_stmt|;
comment|/* Various values.. */
name|char
modifier|*
name|cmd
init|=
operator|(
name|char
operator|*
operator|)
name|cmdp
decl_stmt|;
name|GNode
modifier|*
name|gn
init|=
operator|(
name|GNode
operator|*
operator|)
name|gnp
decl_stmt|;
comment|/*      * Avoid clobbered variable warnings by forcing the compiler      * to ``unregister'' variables      */
if|#
directive|if
name|__GNUC__
operator|(
name|void
operator|)
operator|&
name|av
expr_stmt|;
operator|(
name|void
operator|)
operator|&
name|errCheck
expr_stmt|;
endif|#
directive|endif
name|silent
operator|=
name|gn
operator|->
name|type
operator|&
name|OP_SILENT
expr_stmt|;
name|errCheck
operator|=
operator|!
operator|(
name|gn
operator|->
name|type
operator|&
name|OP_IGNORE
operator|)
expr_stmt|;
name|cmdNode
operator|=
name|Lst_Member
argument_list|(
name|gn
operator|->
name|commands
argument_list|,
operator|(
name|ClientData
operator|)
name|cmd
argument_list|)
expr_stmt|;
name|cmdStart
operator|=
name|Var_Subst
argument_list|(
name|NULL
argument_list|,
name|cmd
argument_list|,
name|gn
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/*      * brk_string will return an argv with a NULL in av[0], thus causing      * execvp to choke and die horribly. Besides, how can we execute a null      * command? In any case, we warn the user that the command expanded to      * nothing (is this the right thing to do?).      */
if|if
condition|(
operator|*
name|cmdStart
operator|==
literal|'\0'
condition|)
block|{
name|free
argument_list|(
name|cmdStart
argument_list|)
expr_stmt|;
name|Error
argument_list|(
literal|"%s expands to empty string"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
name|cmd
operator|=
name|cmdStart
expr_stmt|;
block|}
name|Lst_Replace
argument_list|(
name|cmdNode
argument_list|,
operator|(
name|ClientData
operator|)
name|cmdStart
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|gn
operator|->
name|type
operator|&
name|OP_SAVE_CMDS
operator|)
operator|&&
operator|(
name|gn
operator|!=
name|ENDNode
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|Lst_AtEnd
argument_list|(
name|ENDNode
operator|->
name|commands
argument_list|,
operator|(
name|ClientData
operator|)
name|cmdStart
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|cmdStart
argument_list|,
literal|"..."
argument_list|)
operator|==
literal|0
condition|)
block|{
name|gn
operator|->
name|type
operator||=
name|OP_SAVE_CMDS
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
while|while
condition|(
operator|(
operator|*
name|cmd
operator|==
literal|'@'
operator|)
operator|||
operator|(
operator|*
name|cmd
operator|==
literal|'-'
operator|)
condition|)
block|{
if|if
condition|(
operator|*
name|cmd
operator|==
literal|'@'
condition|)
block|{
name|silent
operator|=
name|DEBUG
argument_list|(
name|LOUD
argument_list|)
condition|?
name|FALSE
else|:
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|errCheck
operator|=
name|FALSE
expr_stmt|;
block|}
name|cmd
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cmd
argument_list|)
condition|)
name|cmd
operator|++
expr_stmt|;
comment|/*      * Search for meta characters in the command. If there are no meta      * characters, there's no need to execute a shell to execute the      * command.      */
for|for
control|(
name|cp
operator|=
name|cmd
init|;
operator|!
name|meta
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cp
index|]
condition|;
name|cp
operator|++
control|)
block|{
continue|continue;
block|}
comment|/*      * Print the command before echoing if we're not supposed to be quiet for      * this one. We also print the command if -n given.      */
if|if
condition|(
operator|!
name|silent
operator|||
name|noExecute
condition|)
block|{
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
comment|/*      * If we're not supposed to execute any commands, this is as far as      * we go...      */
if|if
condition|(
name|noExecute
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
block|{
comment|/* 	 * If *cp isn't the null character, we hit a "meta" character and 	 * need to pass the command off to the shell. We give the shell the 	 * -e flag as well as -c if it's supposed to exit when it hits an 	 * error. 	 */
specifier|static
name|char
modifier|*
name|shargv
index|[
literal|4
index|]
init|=
block|{
literal|"/bin/sh"
block|}
decl_stmt|;
name|shargv
index|[
literal|1
index|]
operator|=
operator|(
name|errCheck
condition|?
literal|"-ec"
else|:
literal|"-c"
operator|)
expr_stmt|;
name|shargv
index|[
literal|2
index|]
operator|=
name|cmd
expr_stmt|;
name|shargv
index|[
literal|3
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|av
operator|=
name|shargv
expr_stmt|;
name|argc
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|internal
operator|=
name|shellneed
argument_list|(
name|cmd
argument_list|)
operator|)
condition|)
block|{
comment|/* 	 * This command must be passed by the shell for other reasons.. 	 * or.. possibly not at all. 	 */
specifier|static
name|char
modifier|*
name|shargv
index|[
literal|4
index|]
init|=
block|{
literal|"/bin/sh"
block|}
decl_stmt|;
if|if
condition|(
name|internal
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* Command does not need to be executed */
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|shargv
index|[
literal|1
index|]
operator|=
operator|(
name|errCheck
condition|?
literal|"-ec"
else|:
literal|"-c"
operator|)
expr_stmt|;
name|shargv
index|[
literal|2
index|]
operator|=
name|cmd
expr_stmt|;
name|shargv
index|[
literal|3
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|av
operator|=
name|shargv
expr_stmt|;
name|argc
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* 	 * No meta-characters, so no need to exec a shell. Break the command 	 * into words to form an argument vector we can execute. 	 * brk_string sticks our name in av[0], so we have to 	 * skip over it... 	 */
name|av
operator|=
name|brk_string
argument_list|(
name|cmd
argument_list|,
operator|&
name|argc
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|av
operator|+=
literal|1
expr_stmt|;
block|}
name|local
operator|=
name|TRUE
expr_stmt|;
comment|/*      * Fork and execute the single command. If the fork fails, we abort.      */
name|cpid
operator|=
name|vfork
argument_list|()
expr_stmt|;
if|if
condition|(
name|cpid
operator|<
literal|0
condition|)
block|{
name|Fatal
argument_list|(
literal|"Could not fork"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cpid
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|local
condition|)
block|{
name|execvp
argument_list|(
name|av
index|[
literal|0
index|]
argument_list|,
name|av
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|write
argument_list|(
literal|2
argument_list|,
name|av
index|[
literal|0
index|]
argument_list|,
name|strlen
argument_list|(
name|av
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|write
argument_list|(
literal|2
argument_list|,
literal|":"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|write
argument_list|(
literal|2
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|,
name|strlen
argument_list|(
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|write
argument_list|(
literal|2
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|execv
argument_list|(
name|av
index|[
literal|0
index|]
argument_list|,
name|av
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/*       * we need to print out the command associated with this Gnode in      * Targ_PrintCmd from Targ_PrintGraph when debugging at level g2,      * in main(), Fatal() and DieHorribly(), therefore do not free it      * when debugging.       */
if|if
condition|(
operator|!
name|DEBUG
argument_list|(
name|GRAPH2
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|cmdStart
argument_list|)
expr_stmt|;
name|Lst_Replace
argument_list|(
name|cmdNode
argument_list|,
name|cmdp
argument_list|)
expr_stmt|;
block|}
comment|/*      * The child is off and running. Now all we can do is wait...      */
while|while
condition|(
literal|1
condition|)
block|{
while|while
condition|(
operator|(
name|stat
operator|=
name|wait
argument_list|(
operator|&
name|reason
argument_list|)
operator|)
operator|!=
name|cpid
condition|)
block|{
if|if
condition|(
name|stat
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|!=
name|EINTR
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|stat
operator|>
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|WIFSTOPPED
argument_list|(
name|reason
argument_list|)
condition|)
block|{
name|status
operator|=
name|WSTOPSIG
argument_list|(
name|reason
argument_list|)
expr_stmt|;
comment|/* stopped */
block|}
elseif|else
if|if
condition|(
name|WIFEXITED
argument_list|(
name|reason
argument_list|)
condition|)
block|{
name|status
operator|=
name|WEXITSTATUS
argument_list|(
name|reason
argument_list|)
expr_stmt|;
comment|/* exited */
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"*** Error code %d"
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|status
operator|=
name|WTERMSIG
argument_list|(
name|reason
argument_list|)
expr_stmt|;
comment|/* signaled */
name|printf
argument_list|(
literal|"*** Signal %d"
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|WIFEXITED
argument_list|(
name|reason
argument_list|)
operator|||
operator|(
name|status
operator|!=
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|errCheck
condition|)
block|{
name|gn
operator|->
name|made
operator|=
name|ERROR
expr_stmt|;
if|if
condition|(
name|keepgoing
condition|)
block|{
comment|/* 			 * Abort the current target, but let others 			 * continue. 			 */
name|printf
argument_list|(
literal|" (continuing)\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		     * Continue executing commands for this target. 		     * If we return 0, this will happen... 		     */
name|printf
argument_list|(
literal|" (ignored)\n"
argument_list|)
expr_stmt|;
name|status
operator|=
literal|0
expr_stmt|;
block|}
block|}
break|break;
block|}
else|else
block|{
name|Fatal
argument_list|(
literal|"error in wait: %d"
argument_list|,
name|stat
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
block|}
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * CompatMake --  *	Make a target.  *  * Results:  *	0  *  * Side Effects:  *	If an error is detected and not being ignored, the process exits.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|CompatMake
parameter_list|(
name|gnp
parameter_list|,
name|pgnp
parameter_list|)
name|ClientData
name|gnp
decl_stmt|;
comment|/* The node to make */
name|ClientData
name|pgnp
decl_stmt|;
comment|/* Parent to abort if necessary */
block|{
name|GNode
modifier|*
name|gn
init|=
operator|(
name|GNode
operator|*
operator|)
name|gnp
decl_stmt|;
name|GNode
modifier|*
name|pgn
init|=
operator|(
name|GNode
operator|*
operator|)
name|pgnp
decl_stmt|;
if|if
condition|(
name|gn
operator|->
name|type
operator|&
name|OP_USE
condition|)
block|{
name|Make_HandleUse
argument_list|(
name|gn
argument_list|,
name|pgn
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|gn
operator|->
name|made
operator|==
name|UNMADE
condition|)
block|{
comment|/* 	 * First mark ourselves to be made, then apply whatever transformations 	 * the suffix module thinks are necessary. Once that's done, we can 	 * descend and make all our children. If any of them has an error 	 * but the -k flag was given, our 'make' field will be set FALSE again. 	 * This is our signal to not attempt to do anything but abort our 	 * parent as well. 	 */
name|gn
operator|->
name|make
operator|=
name|TRUE
expr_stmt|;
name|gn
operator|->
name|made
operator|=
name|BEINGMADE
expr_stmt|;
name|Suff_FindDeps
argument_list|(
name|gn
argument_list|)
expr_stmt|;
name|Lst_ForEach
argument_list|(
name|gn
operator|->
name|children
argument_list|,
name|CompatMake
argument_list|,
operator|(
name|ClientData
operator|)
name|gn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|gn
operator|->
name|make
condition|)
block|{
name|gn
operator|->
name|made
operator|=
name|ABORTED
expr_stmt|;
name|pgn
operator|->
name|make
operator|=
name|FALSE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|Lst_Member
argument_list|(
name|gn
operator|->
name|iParents
argument_list|,
name|pgn
argument_list|)
operator|!=
name|NILLNODE
condition|)
block|{
name|char
modifier|*
name|p1
decl_stmt|;
name|Var_Set
argument_list|(
name|IMPSRC
argument_list|,
name|Var_Value
argument_list|(
name|TARGET
argument_list|,
name|gn
argument_list|,
operator|&
name|p1
argument_list|)
argument_list|,
name|pgn
argument_list|)
expr_stmt|;
name|efree
argument_list|(
name|p1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * All the children were made ok. Now cmtime contains the modification 	 * time of the newest child, we need to find out if we exist and when 	 * we were modified last. The criteria for datedness are defined by the 	 * Make_OODate function. 	 */
if|if
condition|(
name|DEBUG
argument_list|(
name|MAKE
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Examining %s..."
argument_list|,
name|gn
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|Make_OODate
argument_list|(
name|gn
argument_list|)
condition|)
block|{
name|gn
operator|->
name|made
operator|=
name|UPTODATE
expr_stmt|;
if|if
condition|(
name|DEBUG
argument_list|(
name|MAKE
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"up-to-date.\n"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|DEBUG
argument_list|(
name|MAKE
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"out-of-date.\n"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If the user is just seeing if something is out-of-date, exit now 	 * to tell him/her "yes". 	 */
if|if
condition|(
name|queryFlag
condition|)
block|{
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * We need to be re-made. We also have to make sure we've got a $? 	 * variable. To be nice, we also define the $> variable using 	 * Make_DoAllVar(). 	 */
name|Make_DoAllVar
argument_list|(
name|gn
argument_list|)
expr_stmt|;
comment|/* 	 * Alter our type to tell if errors should be ignored or things 	 * should not be printed so CompatRunCommand knows what to do. 	 */
if|if
condition|(
name|Targ_Ignore
argument_list|(
name|gn
argument_list|)
condition|)
block|{
name|gn
operator|->
name|type
operator||=
name|OP_IGNORE
expr_stmt|;
block|}
if|if
condition|(
name|Targ_Silent
argument_list|(
name|gn
argument_list|)
condition|)
block|{
name|gn
operator|->
name|type
operator||=
name|OP_SILENT
expr_stmt|;
block|}
if|if
condition|(
name|Job_CheckCommands
argument_list|(
name|gn
argument_list|,
name|Fatal
argument_list|)
condition|)
block|{
comment|/* 	     * Our commands are ok, but we still have to worry about the -t 	     * flag... 	     */
if|if
condition|(
operator|!
name|touchFlag
condition|)
block|{
name|curTarg
operator|=
name|gn
expr_stmt|;
name|Lst_ForEach
argument_list|(
name|gn
operator|->
name|commands
argument_list|,
name|CompatRunCommand
argument_list|,
operator|(
name|ClientData
operator|)
name|gn
argument_list|)
expr_stmt|;
name|curTarg
operator|=
name|NILGNODE
expr_stmt|;
block|}
else|else
block|{
name|Job_Touch
argument_list|(
name|gn
argument_list|,
name|gn
operator|->
name|type
operator|&
name|OP_SILENT
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|gn
operator|->
name|made
operator|=
name|ERROR
expr_stmt|;
block|}
if|if
condition|(
name|gn
operator|->
name|made
operator|!=
name|ERROR
condition|)
block|{
comment|/* 	     * If the node was made successfully, mark it so, update 	     * its modification time and timestamp all its parents. Note 	     * that for .ZEROTIME targets, the timestamping isn't done. 	     * This is to keep its state from affecting that of its parent. 	     */
name|gn
operator|->
name|made
operator|=
name|MADE
expr_stmt|;
ifndef|#
directive|ifndef
name|RECHECK
comment|/* 	     * We can't re-stat the thing, but we can at least take care of 	     * rules where a target depends on a source that actually creates 	     * the target, but only if it has changed, e.g. 	     * 	     * parse.h : parse.o 	     * 	     * parse.o : parse.y 	     *  	yacc -d parse.y 	     *  	cc -c y.tab.c 	     *  	mv y.tab.o parse.o 	     *  	cmp -s y.tab.h parse.h || mv y.tab.h parse.h 	     * 	     * In this case, if the definitions produced by yacc haven't 	     * changed from before, parse.h won't have been updated and 	     * gn->mtime will reflect the current modification time for 	     * parse.h. This is something of a kludge, I admit, but it's a 	     * useful one.. 	     * 	     * XXX: People like to use a rule like 	     * 	     * FRC: 	     * 	     * To force things that depend on FRC to be made, so we have to 	     * check for gn->children being empty as well... 	     */
if|if
condition|(
operator|!
name|Lst_IsEmpty
argument_list|(
name|gn
operator|->
name|commands
argument_list|)
operator|||
name|Lst_IsEmpty
argument_list|(
name|gn
operator|->
name|children
argument_list|)
condition|)
block|{
name|gn
operator|->
name|mtime
operator|=
name|now
expr_stmt|;
block|}
else|#
directive|else
comment|/* 	     * This is what Make does and it's actually a good thing, as it 	     * allows rules like 	     * 	     *	cmp -s y.tab.h parse.h || cp y.tab.h parse.h 	     * 	     * to function as intended. Unfortunately, thanks to the stateless 	     * nature of NFS (and the speed of this program), there are times 	     * when the modification time of a file created on a remote 	     * machine will not be modified before the stat() implied by 	     * the Dir_MTime occurs, thus leading us to believe that the file 	     * is unchanged, wreaking havoc with files that depend on this one. 	     * 	     * I have decided it is better to make too much than to make too 	     * little, so this stuff is commented out unless you're sure it's 	     * ok. 	     * -- ardeb 1/12/88 	     */
if|if
condition|(
name|noExecute
operator|||
name|Dir_MTime
argument_list|(
name|gn
argument_list|)
operator|==
literal|0
condition|)
block|{
name|gn
operator|->
name|mtime
operator|=
name|now
expr_stmt|;
block|}
if|if
condition|(
name|gn
operator|->
name|cmtime
operator|>
name|gn
operator|->
name|mtime
condition|)
name|gn
operator|->
name|mtime
operator|=
name|gn
operator|->
name|cmtime
expr_stmt|;
if|if
condition|(
name|DEBUG
argument_list|(
name|MAKE
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"update time: %s\n"
argument_list|,
name|Targ_FmtTime
argument_list|(
name|gn
operator|->
name|mtime
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
operator|(
name|gn
operator|->
name|type
operator|&
name|OP_EXEC
operator|)
condition|)
block|{
name|pgn
operator|->
name|childMade
operator|=
name|TRUE
expr_stmt|;
name|Make_TimeStamp
argument_list|(
name|pgn
argument_list|,
name|gn
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|keepgoing
condition|)
block|{
name|pgn
operator|->
name|make
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|p1
decl_stmt|;
name|printf
argument_list|(
literal|"\n\nStop in %s.\n"
argument_list|,
name|Var_Value
argument_list|(
literal|".CURDIR"
argument_list|,
name|gn
argument_list|,
operator|&
name|p1
argument_list|)
argument_list|)
expr_stmt|;
name|efree
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|gn
operator|->
name|made
operator|==
name|ERROR
condition|)
block|{
comment|/* 	 * Already had an error when making this beastie. Tell the parent 	 * to abort. 	 */
name|pgn
operator|->
name|make
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|Lst_Member
argument_list|(
name|gn
operator|->
name|iParents
argument_list|,
name|pgn
argument_list|)
operator|!=
name|NILLNODE
condition|)
block|{
name|char
modifier|*
name|p1
decl_stmt|;
name|Var_Set
argument_list|(
name|IMPSRC
argument_list|,
name|Var_Value
argument_list|(
name|TARGET
argument_list|,
name|gn
argument_list|,
operator|&
name|p1
argument_list|)
argument_list|,
name|pgn
argument_list|)
expr_stmt|;
name|efree
argument_list|(
name|p1
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|gn
operator|->
name|made
condition|)
block|{
case|case
name|BEINGMADE
case|:
name|Error
argument_list|(
literal|"Graph cycles through %s\n"
argument_list|,
name|gn
operator|->
name|name
argument_list|)
expr_stmt|;
name|gn
operator|->
name|made
operator|=
name|ERROR
expr_stmt|;
name|pgn
operator|->
name|make
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|MADE
case|:
if|if
condition|(
operator|(
name|gn
operator|->
name|type
operator|&
name|OP_EXEC
operator|)
operator|==
literal|0
condition|)
block|{
name|pgn
operator|->
name|childMade
operator|=
name|TRUE
expr_stmt|;
name|Make_TimeStamp
argument_list|(
name|pgn
argument_list|,
name|gn
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|UPTODATE
case|:
if|if
condition|(
operator|(
name|gn
operator|->
name|type
operator|&
name|OP_EXEC
operator|)
operator|==
literal|0
condition|)
block|{
name|Make_TimeStamp
argument_list|(
name|pgn
argument_list|,
name|gn
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Compat_Run --  *	Initialize this mode and start making.  *  * Results:  *	None.  *  * Side Effects:  *	Guess what?  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Compat_Run
parameter_list|(
name|targs
parameter_list|)
name|Lst
name|targs
decl_stmt|;
comment|/* List of target nodes to re-create */
block|{
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* Pointer to string of shell meta-characters */
name|GNode
modifier|*
name|gn
init|=
name|NULL
decl_stmt|;
comment|/* Current root target */
name|int
name|errors
decl_stmt|;
comment|/* Number of targets not remade due to errors */
if|if
condition|(
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
block|{
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|CompatInterrupt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
block|{
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|CompatInterrupt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
block|{
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|CompatInterrupt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
block|{
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|CompatInterrupt
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|cp
operator|=
literal|"#=|^(){};&<>*?[]:$`\\\n"
init|;
operator|*
name|cp
operator|!=
literal|'\0'
condition|;
name|cp
operator|++
control|)
block|{
name|meta
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cp
index|]
operator|=
literal|1
expr_stmt|;
block|}
comment|/*      * The null character serves as a sentinel in the string.      */
name|meta
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
name|ENDNode
operator|=
name|Targ_FindNode
argument_list|(
literal|".END"
argument_list|,
name|TARG_CREATE
argument_list|)
expr_stmt|;
comment|/*      * If the user has defined a .BEGIN target, execute the commands attached      * to it.      */
if|if
condition|(
operator|!
name|queryFlag
condition|)
block|{
name|gn
operator|=
name|Targ_FindNode
argument_list|(
literal|".BEGIN"
argument_list|,
name|TARG_NOCREATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|gn
operator|!=
name|NILGNODE
condition|)
block|{
name|Lst_ForEach
argument_list|(
name|gn
operator|->
name|commands
argument_list|,
name|CompatRunCommand
argument_list|,
operator|(
name|ClientData
operator|)
name|gn
argument_list|)
expr_stmt|;
if|if
condition|(
name|gn
operator|->
name|made
operator|==
name|ERROR
condition|)
block|{
name|printf
argument_list|(
literal|"\n\nStop.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/*      * For each entry in the list of targets to create, call CompatMake on      * it to create the thing. CompatMake will leave the 'made' field of gn      * in one of several states:      *	    UPTODATE	    gn was already up-to-date      *	    MADE  	    gn was recreated successfully      *	    ERROR 	    An error occurred while gn was being created      *	    ABORTED	    gn was not remade because one of its inferiors      *	    	  	    could not be made due to errors.      */
name|errors
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|Lst_IsEmpty
argument_list|(
name|targs
argument_list|)
condition|)
block|{
name|gn
operator|=
operator|(
name|GNode
operator|*
operator|)
name|Lst_DeQueue
argument_list|(
name|targs
argument_list|)
expr_stmt|;
name|CompatMake
argument_list|(
name|gn
argument_list|,
name|gn
argument_list|)
expr_stmt|;
if|if
condition|(
name|gn
operator|->
name|made
operator|==
name|UPTODATE
condition|)
block|{
name|printf
argument_list|(
literal|"`%s' is up to date.\n"
argument_list|,
name|gn
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|gn
operator|->
name|made
operator|==
name|ABORTED
condition|)
block|{
name|printf
argument_list|(
literal|"`%s' not remade because of errors.\n"
argument_list|,
name|gn
operator|->
name|name
argument_list|)
expr_stmt|;
name|errors
operator|+=
literal|1
expr_stmt|;
block|}
block|}
comment|/*      * If the user has defined a .END target, run its commands.      */
if|if
condition|(
name|errors
operator|==
literal|0
condition|)
block|{
name|Lst_ForEach
argument_list|(
name|ENDNode
operator|->
name|commands
argument_list|,
name|CompatRunCommand
argument_list|,
operator|(
name|ClientData
operator|)
name|gn
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

