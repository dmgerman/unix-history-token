begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2002 Juli Mallett.  * Copyright (c) 1988, 1989, 1990, 1993  *	The Regents of the University of California.  All rights reserved.  * Copyright (c) 1989 by Berkeley Softworks  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Adam de Boor.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * @(#)var.c	8.3 (Berkeley) 3/19/94  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<regex.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|"make.h"
end_include

begin_include
include|#
directive|include
file|"buf.h"
end_include

begin_include
include|#
directive|include
file|"var.h"
end_include

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * VarHead --  *	Remove the tail of the given word and place the result in the given  *	buffer.  *  * Results:  *	TRUE if characters were added to the buffer (a space needs to be  *	added to the buffer before the next word).  *  * Side Effects:  *	The trimmed word is added to the buffer.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|Boolean
name|VarHead
parameter_list|(
specifier|const
name|char
modifier|*
name|word
parameter_list|,
name|Boolean
name|addSpace
parameter_list|,
name|Buffer
name|buf
parameter_list|,
name|void
modifier|*
name|dummy
name|__unused
parameter_list|)
block|{
name|char
modifier|*
name|slash
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
name|buffer
operator|=
name|estrdup
argument_list|(
name|word
argument_list|)
expr_stmt|;
name|slash
operator|=
name|strrchr
argument_list|(
name|buffer
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|slash
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|addSpace
condition|)
block|{
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
operator|(
name|Byte
operator|)
literal|' '
argument_list|)
expr_stmt|;
block|}
operator|*
name|slash
operator|=
literal|'\0'
expr_stmt|;
name|Buf_AddBytes
argument_list|(
name|buf
argument_list|,
name|strlen
argument_list|(
name|buffer
argument_list|)
argument_list|,
operator|(
name|Byte
operator|*
operator|)
name|buffer
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
else|else
block|{
comment|/* 	 * If no directory part, give . (q.v. the POSIX standard) 	 */
if|if
condition|(
name|addSpace
condition|)
block|{
name|Buf_AddBytes
argument_list|(
name|buf
argument_list|,
literal|2
argument_list|,
operator|(
specifier|const
name|Byte
operator|*
operator|)
literal|" ."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
operator|(
name|Byte
operator|)
literal|'.'
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * VarTail --  *	Remove the head of the given word and place the result in the given  *	buffer.  *  * Results:  *	TRUE if characters were added to the buffer (a space needs to be  *	added to the buffer before the next word).  *  * Side Effects:  *	The trimmed word is added to the buffer.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|Boolean
name|VarTail
parameter_list|(
specifier|const
name|char
modifier|*
name|word
parameter_list|,
name|Boolean
name|addSpace
parameter_list|,
name|Buffer
name|buf
parameter_list|,
name|void
modifier|*
name|dummy
name|__unused
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|slash
decl_stmt|;
if|if
condition|(
name|addSpace
condition|)
block|{
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
operator|(
name|Byte
operator|)
literal|' '
argument_list|)
expr_stmt|;
block|}
name|slash
operator|=
name|strrchr
argument_list|(
name|word
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|slash
operator|++
operator|!=
name|NULL
condition|)
block|{
name|Buf_AddBytes
argument_list|(
name|buf
argument_list|,
name|strlen
argument_list|(
name|slash
argument_list|)
argument_list|,
operator|(
specifier|const
name|Byte
operator|*
operator|)
name|slash
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Buf_AddBytes
argument_list|(
name|buf
argument_list|,
name|strlen
argument_list|(
name|word
argument_list|)
argument_list|,
operator|(
specifier|const
name|Byte
operator|*
operator|)
name|word
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * VarSuffix --  *	Place the suffix of the given word in the given buffer.  *  * Results:  *	TRUE if characters were added to the buffer (a space needs to be  *	added to the buffer before the next word).  *  * Side Effects:  *	The suffix from the word is placed in the buffer.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|Boolean
name|VarSuffix
parameter_list|(
specifier|const
name|char
modifier|*
name|word
parameter_list|,
name|Boolean
name|addSpace
parameter_list|,
name|Buffer
name|buf
parameter_list|,
name|void
modifier|*
name|dummy
name|__unused
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|dot
decl_stmt|;
name|dot
operator|=
name|strrchr
argument_list|(
name|word
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|dot
operator|++
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|addSpace
condition|)
block|{
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
operator|(
name|Byte
operator|)
literal|' '
argument_list|)
expr_stmt|;
block|}
name|Buf_AddBytes
argument_list|(
name|buf
argument_list|,
name|strlen
argument_list|(
name|dot
argument_list|)
argument_list|,
operator|(
specifier|const
name|Byte
operator|*
operator|)
name|dot
argument_list|)
expr_stmt|;
name|addSpace
operator|=
name|TRUE
expr_stmt|;
block|}
return|return
operator|(
name|addSpace
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * VarRoot --  *	Remove the suffix of the given word and place the result in the  *	buffer.  *  * Results:  *	TRUE if characters were added to the buffer (a space needs to be  *	added to the buffer before the next word).  *  * Side Effects:  *	The trimmed word is added to the buffer.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|Boolean
name|VarRoot
parameter_list|(
specifier|const
name|char
modifier|*
name|word
parameter_list|,
name|Boolean
name|addSpace
parameter_list|,
name|Buffer
name|buf
parameter_list|,
name|void
modifier|*
name|dummy
name|__unused
parameter_list|)
block|{
name|char
modifier|*
name|buffer
decl_stmt|;
name|char
modifier|*
name|dot
decl_stmt|;
if|if
condition|(
name|addSpace
condition|)
block|{
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
operator|(
name|Byte
operator|)
literal|' '
argument_list|)
expr_stmt|;
block|}
name|buffer
operator|=
name|estrdup
argument_list|(
name|word
argument_list|)
expr_stmt|;
name|dot
operator|=
name|strrchr
argument_list|(
name|buffer
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|dot
operator|!=
name|NULL
condition|)
block|{
operator|*
name|dot
operator|=
literal|'\0'
expr_stmt|;
block|}
name|Buf_AddBytes
argument_list|(
name|buf
argument_list|,
name|strlen
argument_list|(
name|buffer
argument_list|)
argument_list|,
operator|(
name|Byte
operator|*
operator|)
name|buffer
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * VarMatch --  *	Place the word in the buffer if it matches the given pattern.  *	Callback function for VarModify to implement the :M modifier.  *	A space will be added if requested.  A pattern is supplied  *	which the word must match.  *  * Results:  *	TRUE if a space should be placed in the buffer before the next  *	word.  *  * Side Effects:  *	The word may be copied to the buffer.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|Boolean
name|VarMatch
parameter_list|(
specifier|const
name|char
modifier|*
name|word
parameter_list|,
name|Boolean
name|addSpace
parameter_list|,
name|Buffer
name|buf
parameter_list|,
name|void
modifier|*
name|pattern
parameter_list|)
block|{
if|if
condition|(
name|Str_Match
argument_list|(
name|word
argument_list|,
name|pattern
argument_list|)
condition|)
block|{
if|if
condition|(
name|addSpace
condition|)
block|{
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
operator|(
name|Byte
operator|)
literal|' '
argument_list|)
expr_stmt|;
block|}
name|addSpace
operator|=
name|TRUE
expr_stmt|;
name|Buf_AddBytes
argument_list|(
name|buf
argument_list|,
name|strlen
argument_list|(
name|word
argument_list|)
argument_list|,
name|word
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|addSpace
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SYSVVARSUB
end_ifdef

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * VarSYSVMatch --  *	Place the word in the buffer if it matches the given pattern.  *	Callback function for VarModify to implement the System V %  *	modifiers.  A space is added if requested.  *  * Results:  *	TRUE if a space should be placed in the buffer before the next  *	word.  *  * Side Effects:  *	The word may be copied to the buffer.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|Boolean
name|VarSYSVMatch
parameter_list|(
specifier|const
name|char
modifier|*
name|word
parameter_list|,
name|Boolean
name|addSpace
parameter_list|,
name|Buffer
name|buf
parameter_list|,
name|void
modifier|*
name|patp
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
specifier|const
name|char
modifier|*
name|ptr
decl_stmt|;
name|VarPattern
modifier|*
name|pat
init|=
operator|(
name|VarPattern
operator|*
operator|)
name|patp
decl_stmt|;
if|if
condition|(
name|addSpace
condition|)
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
operator|(
name|Byte
operator|)
literal|' '
argument_list|)
expr_stmt|;
name|addSpace
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|(
name|ptr
operator|=
name|Str_SYSVMatch
argument_list|(
name|word
argument_list|,
name|pat
operator|->
name|lhs
argument_list|,
operator|&
name|len
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|Str_SYSVSubst
argument_list|(
name|buf
argument_list|,
name|pat
operator|->
name|rhs
argument_list|,
name|ptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
else|else
name|Buf_AddBytes
argument_list|(
name|buf
argument_list|,
name|strlen
argument_list|(
name|word
argument_list|)
argument_list|,
operator|(
specifier|const
name|Byte
operator|*
operator|)
name|word
argument_list|)
expr_stmt|;
return|return
operator|(
name|addSpace
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * VarNoMatch --  *	Place the word in the buffer if it doesn't match the given pattern.  *	Callback function for VarModify to implement the :N modifier.  A  *	space is added if requested.  *  * Results:  *	TRUE if a space should be placed in the buffer before the next  *	word.  *  * Side Effects:  *	The word may be copied to the buffer.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|Boolean
name|VarNoMatch
parameter_list|(
specifier|const
name|char
modifier|*
name|word
parameter_list|,
name|Boolean
name|addSpace
parameter_list|,
name|Buffer
name|buf
parameter_list|,
name|void
modifier|*
name|pattern
parameter_list|)
block|{
if|if
condition|(
operator|!
name|Str_Match
argument_list|(
name|word
argument_list|,
name|pattern
argument_list|)
condition|)
block|{
if|if
condition|(
name|addSpace
condition|)
block|{
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
operator|(
name|Byte
operator|)
literal|' '
argument_list|)
expr_stmt|;
block|}
name|addSpace
operator|=
name|TRUE
expr_stmt|;
name|Buf_AddBytes
argument_list|(
name|buf
argument_list|,
name|strlen
argument_list|(
name|word
argument_list|)
argument_list|,
operator|(
specifier|const
name|Byte
operator|*
operator|)
name|word
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|addSpace
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * VarSubstitute --  *	Perform a string-substitution on the given word, placing the  *	result in the passed buffer.  A space is added if requested.  *  * Results:  *	TRUE if a space is needed before more characters are added.  *  * Side Effects:  *	None.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|Boolean
name|VarSubstitute
parameter_list|(
specifier|const
name|char
modifier|*
name|word
parameter_list|,
name|Boolean
name|addSpace
parameter_list|,
name|Buffer
name|buf
parameter_list|,
name|void
modifier|*
name|patternp
parameter_list|)
block|{
name|size_t
name|wordLen
decl_stmt|;
comment|/* Length of word */
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* General pointer */
name|VarPattern
modifier|*
name|pattern
init|=
name|patternp
decl_stmt|;
name|wordLen
operator|=
name|strlen
argument_list|(
name|word
argument_list|)
expr_stmt|;
if|if
condition|(
literal|1
condition|)
block|{
comment|/* substitute in each word of the variable */
comment|/* 	 * Break substitution down into simple anchored cases 	 * and if none of them fits, perform the general substitution case. 	 */
if|if
condition|(
operator|(
name|pattern
operator|->
name|flags
operator|&
name|VAR_MATCH_START
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|word
argument_list|,
name|pattern
operator|->
name|lhs
argument_list|,
name|pattern
operator|->
name|leftLen
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* 		 * Anchored at start and beginning of word matches pattern 		 */
if|if
condition|(
operator|(
name|pattern
operator|->
name|flags
operator|&
name|VAR_MATCH_END
operator|)
operator|&&
operator|(
name|wordLen
operator|==
name|pattern
operator|->
name|leftLen
operator|)
condition|)
block|{
comment|/* 			 * Also anchored at end and matches to the end (word 			 * is same length as pattern) add space and rhs only 			 * if rhs is non-null. 			 */
if|if
condition|(
name|pattern
operator|->
name|rightLen
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|addSpace
condition|)
block|{
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
operator|(
name|Byte
operator|)
literal|' '
argument_list|)
expr_stmt|;
block|}
name|addSpace
operator|=
name|TRUE
expr_stmt|;
name|Buf_AddBytes
argument_list|(
name|buf
argument_list|,
name|pattern
operator|->
name|rightLen
argument_list|,
operator|(
name|Byte
operator|*
operator|)
name|pattern
operator|->
name|rhs
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|pattern
operator|->
name|flags
operator|&
name|VAR_MATCH_END
condition|)
block|{
comment|/* 		     * Doesn't match to end -- copy word wholesale 		     */
goto|goto
name|nosub
goto|;
block|}
else|else
block|{
comment|/* 		     * Matches at start but need to copy in trailing characters 		     */
if|if
condition|(
operator|(
name|pattern
operator|->
name|rightLen
operator|+
name|wordLen
operator|-
name|pattern
operator|->
name|leftLen
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|addSpace
condition|)
block|{
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
operator|(
name|Byte
operator|)
literal|' '
argument_list|)
expr_stmt|;
block|}
name|addSpace
operator|=
name|TRUE
expr_stmt|;
block|}
name|Buf_AddBytes
argument_list|(
name|buf
argument_list|,
name|pattern
operator|->
name|rightLen
argument_list|,
operator|(
name|Byte
operator|*
operator|)
name|pattern
operator|->
name|rhs
argument_list|)
expr_stmt|;
name|Buf_AddBytes
argument_list|(
name|buf
argument_list|,
name|wordLen
operator|-
name|pattern
operator|->
name|leftLen
argument_list|,
operator|(
specifier|const
name|Byte
operator|*
operator|)
operator|(
name|word
operator|+
name|pattern
operator|->
name|leftLen
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|pattern
operator|->
name|flags
operator|&
name|VAR_MATCH_START
condition|)
block|{
comment|/* 	     * Had to match at start of word and didn't -- copy whole word. 	     */
goto|goto
name|nosub
goto|;
block|}
elseif|else
if|if
condition|(
name|pattern
operator|->
name|flags
operator|&
name|VAR_MATCH_END
condition|)
block|{
comment|/* 	     * Anchored at end, Find only place match could occur (leftLen 	     * characters from the end of the word) and see if it does. Note 	     * that because the $ will be left at the end of the lhs, we have 	     * to use strncmp. 	     */
name|cp
operator|=
name|word
operator|+
operator|(
name|wordLen
operator|-
name|pattern
operator|->
name|leftLen
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|>=
name|word
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|cp
argument_list|,
name|pattern
operator|->
name|lhs
argument_list|,
name|pattern
operator|->
name|leftLen
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* 		 * Match found. If we will place characters in the buffer, 		 * add a space before hand as indicated by addSpace, then 		 * stuff in the initial, unmatched part of the word followed 		 * by the right-hand-side. 		 */
if|if
condition|(
operator|(
operator|(
name|cp
operator|-
name|word
operator|)
operator|+
name|pattern
operator|->
name|rightLen
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|addSpace
condition|)
block|{
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
operator|(
name|Byte
operator|)
literal|' '
argument_list|)
expr_stmt|;
block|}
name|addSpace
operator|=
name|TRUE
expr_stmt|;
block|}
name|Buf_AddBytes
argument_list|(
name|buf
argument_list|,
name|cp
operator|-
name|word
argument_list|,
operator|(
specifier|const
name|Byte
operator|*
operator|)
name|word
argument_list|)
expr_stmt|;
name|Buf_AddBytes
argument_list|(
name|buf
argument_list|,
name|pattern
operator|->
name|rightLen
argument_list|,
operator|(
name|Byte
operator|*
operator|)
name|pattern
operator|->
name|rhs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Had to match at end and didn't. Copy entire word. 		 */
goto|goto
name|nosub
goto|;
block|}
block|}
else|else
block|{
comment|/* 	     * Pattern is unanchored: search for the pattern in the word using 	     * strstr(3), copying unmatched portions and the 	     * right-hand-side for each match found, handling non-global 	     * substitutions correctly, etc. When the loop is done, any 	     * remaining part of the word (word and wordLen are adjusted 	     * accordingly through the loop) is copied straight into the 	     * buffer. 	     * addSpace is set FALSE as soon as a space is added to the 	     * buffer. 	     */
name|Boolean
name|done
decl_stmt|;
name|size_t
name|origSize
decl_stmt|;
name|done
operator|=
name|FALSE
expr_stmt|;
name|origSize
operator|=
name|Buf_Size
argument_list|(
name|buf
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|done
condition|)
block|{
name|cp
operator|=
name|strstr
argument_list|(
name|word
argument_list|,
name|pattern
operator|->
name|lhs
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|addSpace
operator|&&
operator|(
operator|(
operator|(
name|cp
operator|-
name|word
operator|)
operator|+
name|pattern
operator|->
name|rightLen
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
operator|(
name|Byte
operator|)
literal|' '
argument_list|)
expr_stmt|;
name|addSpace
operator|=
name|FALSE
expr_stmt|;
block|}
name|Buf_AddBytes
argument_list|(
name|buf
argument_list|,
name|cp
operator|-
name|word
argument_list|,
operator|(
specifier|const
name|Byte
operator|*
operator|)
name|word
argument_list|)
expr_stmt|;
name|Buf_AddBytes
argument_list|(
name|buf
argument_list|,
name|pattern
operator|->
name|rightLen
argument_list|,
operator|(
name|Byte
operator|*
operator|)
name|pattern
operator|->
name|rhs
argument_list|)
expr_stmt|;
name|wordLen
operator|-=
operator|(
name|cp
operator|-
name|word
operator|)
operator|+
name|pattern
operator|->
name|leftLen
expr_stmt|;
name|word
operator|=
name|cp
operator|+
name|pattern
operator|->
name|leftLen
expr_stmt|;
if|if
condition|(
name|wordLen
operator|==
literal|0
operator|||
operator|(
name|pattern
operator|->
name|flags
operator|&
name|VAR_SUB_GLOBAL
operator|)
operator|==
literal|0
condition|)
block|{
name|done
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
else|else
block|{
name|done
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|wordLen
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|addSpace
condition|)
block|{
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
operator|(
name|Byte
operator|)
literal|' '
argument_list|)
expr_stmt|;
block|}
name|Buf_AddBytes
argument_list|(
name|buf
argument_list|,
name|wordLen
argument_list|,
operator|(
specifier|const
name|Byte
operator|*
operator|)
name|word
argument_list|)
expr_stmt|;
block|}
comment|/* 	     * If added characters to the buffer, need to add a space 	     * before we add any more. If we didn't add any, just return 	     * the previous value of addSpace. 	     */
return|return
operator|(
operator|(
name|Buf_Size
argument_list|(
name|buf
argument_list|)
operator|!=
name|origSize
operator|)
operator|||
name|addSpace
operator|)
return|;
block|}
comment|/* 	 * Common code for anchored substitutions: 	 * addSpace was set TRUE if characters were added to the buffer. 	 */
return|return
operator|(
name|addSpace
operator|)
return|;
block|}
name|nosub
label|:
if|if
condition|(
name|addSpace
condition|)
block|{
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
operator|(
name|Byte
operator|)
literal|' '
argument_list|)
expr_stmt|;
block|}
name|Buf_AddBytes
argument_list|(
name|buf
argument_list|,
name|wordLen
argument_list|,
operator|(
specifier|const
name|Byte
operator|*
operator|)
name|word
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * VarRESubstitute --  *	Perform a regex substitution on the given word, placing the  *	result in the passed buffer.  A space is added if requested.  *  * Results:  *	TRUE if a space is needed before more characters are added.  *  * Side Effects:  *	None.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|Boolean
name|VarRESubstitute
parameter_list|(
specifier|const
name|char
modifier|*
name|word
parameter_list|,
name|Boolean
name|addSpace
parameter_list|,
name|Buffer
name|buf
parameter_list|,
name|void
modifier|*
name|patternp
parameter_list|)
block|{
name|VarREPattern
modifier|*
name|pat
decl_stmt|;
name|int
name|xrv
decl_stmt|;
specifier|const
name|char
modifier|*
name|wp
decl_stmt|;
name|char
modifier|*
name|rp
decl_stmt|;
name|int
name|added
decl_stmt|;
name|int
name|flags
init|=
literal|0
decl_stmt|;
define|#
directive|define
name|MAYBE_ADD_SPACE
parameter_list|()
define|\
value|if (addSpace&& !added)			\ 	    Buf_AddByte(buf, (Byte)' ');	\ 	added = 1
name|added
operator|=
literal|0
expr_stmt|;
name|wp
operator|=
name|word
expr_stmt|;
name|pat
operator|=
name|patternp
expr_stmt|;
if|if
condition|(
operator|(
name|pat
operator|->
name|flags
operator|&
operator|(
name|VAR_SUB_ONE
operator||
name|VAR_SUB_MATCHED
operator|)
operator|)
operator|==
operator|(
name|VAR_SUB_ONE
operator||
name|VAR_SUB_MATCHED
operator|)
condition|)
name|xrv
operator|=
name|REG_NOMATCH
expr_stmt|;
else|else
block|{
name|tryagain
label|:
name|xrv
operator|=
name|regexec
argument_list|(
operator|&
name|pat
operator|->
name|re
argument_list|,
name|wp
argument_list|,
name|pat
operator|->
name|nsub
argument_list|,
name|pat
operator|->
name|matches
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|xrv
condition|)
block|{
case|case
literal|0
case|:
name|pat
operator|->
name|flags
operator||=
name|VAR_SUB_MATCHED
expr_stmt|;
if|if
condition|(
name|pat
operator|->
name|matches
index|[
literal|0
index|]
operator|.
name|rm_so
operator|>
literal|0
condition|)
block|{
name|MAYBE_ADD_SPACE
argument_list|()
expr_stmt|;
name|Buf_AddBytes
argument_list|(
name|buf
argument_list|,
name|pat
operator|->
name|matches
index|[
literal|0
index|]
operator|.
name|rm_so
argument_list|,
operator|(
specifier|const
name|Byte
operator|*
operator|)
name|wp
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|rp
operator|=
name|pat
operator|->
name|replace
init|;
operator|*
name|rp
condition|;
name|rp
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|rp
operator|==
literal|'\\'
operator|)
operator|&&
operator|(
operator|(
name|rp
index|[
literal|1
index|]
operator|==
literal|'&'
operator|)
operator|||
operator|(
name|rp
index|[
literal|1
index|]
operator|==
literal|'\\'
operator|)
operator|)
condition|)
block|{
name|MAYBE_ADD_SPACE
argument_list|()
expr_stmt|;
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
operator|(
name|Byte
operator|)
name|rp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|rp
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|rp
operator|==
literal|'&'
operator|)
operator|||
operator|(
operator|(
operator|*
name|rp
operator|==
literal|'\\'
operator|)
operator|&&
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|rp
index|[
literal|1
index|]
argument_list|)
operator|)
condition|)
block|{
name|int
name|n
decl_stmt|;
specifier|const
name|char
modifier|*
name|subbuf
decl_stmt|;
name|int
name|sublen
decl_stmt|;
name|char
name|errstr
index|[
literal|3
index|]
decl_stmt|;
if|if
condition|(
operator|*
name|rp
operator|==
literal|'&'
condition|)
block|{
name|n
operator|=
literal|0
expr_stmt|;
name|errstr
index|[
literal|0
index|]
operator|=
literal|'&'
expr_stmt|;
name|errstr
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
name|n
operator|=
name|rp
index|[
literal|1
index|]
operator|-
literal|'0'
expr_stmt|;
name|errstr
index|[
literal|0
index|]
operator|=
literal|'\\'
expr_stmt|;
name|errstr
index|[
literal|1
index|]
operator|=
name|rp
index|[
literal|1
index|]
expr_stmt|;
name|errstr
index|[
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
name|rp
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|>
name|pat
operator|->
name|nsub
condition|)
block|{
name|Error
argument_list|(
literal|"No subexpression %s"
argument_list|,
operator|&
name|errstr
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|subbuf
operator|=
literal|""
expr_stmt|;
name|sublen
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|pat
operator|->
name|matches
index|[
name|n
index|]
operator|.
name|rm_so
operator|==
operator|-
literal|1
operator|)
operator|&&
operator|(
name|pat
operator|->
name|matches
index|[
name|n
index|]
operator|.
name|rm_eo
operator|==
operator|-
literal|1
operator|)
condition|)
block|{
name|Error
argument_list|(
literal|"No match for subexpression %s"
argument_list|,
operator|&
name|errstr
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|subbuf
operator|=
literal|""
expr_stmt|;
name|sublen
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|subbuf
operator|=
name|wp
operator|+
name|pat
operator|->
name|matches
index|[
name|n
index|]
operator|.
name|rm_so
expr_stmt|;
name|sublen
operator|=
name|pat
operator|->
name|matches
index|[
name|n
index|]
operator|.
name|rm_eo
operator|-
name|pat
operator|->
name|matches
index|[
name|n
index|]
operator|.
name|rm_so
expr_stmt|;
block|}
if|if
condition|(
name|sublen
operator|>
literal|0
condition|)
block|{
name|MAYBE_ADD_SPACE
argument_list|()
expr_stmt|;
name|Buf_AddBytes
argument_list|(
name|buf
argument_list|,
name|sublen
argument_list|,
operator|(
specifier|const
name|Byte
operator|*
operator|)
name|subbuf
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|MAYBE_ADD_SPACE
argument_list|()
expr_stmt|;
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
operator|(
name|Byte
operator|)
operator|*
name|rp
argument_list|)
expr_stmt|;
block|}
block|}
name|wp
operator|+=
name|pat
operator|->
name|matches
index|[
literal|0
index|]
operator|.
name|rm_eo
expr_stmt|;
if|if
condition|(
name|pat
operator|->
name|flags
operator|&
name|VAR_SUB_GLOBAL
condition|)
block|{
name|flags
operator||=
name|REG_NOTBOL
expr_stmt|;
if|if
condition|(
name|pat
operator|->
name|matches
index|[
literal|0
index|]
operator|.
name|rm_so
operator|==
literal|0
operator|&&
name|pat
operator|->
name|matches
index|[
literal|0
index|]
operator|.
name|rm_eo
operator|==
literal|0
condition|)
block|{
name|MAYBE_ADD_SPACE
argument_list|()
expr_stmt|;
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
operator|(
name|Byte
operator|)
operator|*
name|wp
argument_list|)
expr_stmt|;
name|wp
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|wp
condition|)
goto|goto
name|tryagain
goto|;
block|}
if|if
condition|(
operator|*
name|wp
condition|)
block|{
name|MAYBE_ADD_SPACE
argument_list|()
expr_stmt|;
name|Buf_AddBytes
argument_list|(
name|buf
argument_list|,
name|strlen
argument_list|(
name|wp
argument_list|)
argument_list|,
operator|(
specifier|const
name|Byte
operator|*
operator|)
name|wp
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|VarREError
argument_list|(
name|xrv
argument_list|,
operator|&
name|pat
operator|->
name|re
argument_list|,
literal|"Unexpected regex error"
argument_list|)
expr_stmt|;
comment|/* fall through */
case|case
name|REG_NOMATCH
case|:
if|if
condition|(
operator|*
name|wp
condition|)
block|{
name|MAYBE_ADD_SPACE
argument_list|()
expr_stmt|;
name|Buf_AddBytes
argument_list|(
name|buf
argument_list|,
name|strlen
argument_list|(
name|wp
argument_list|)
argument_list|,
operator|(
specifier|const
name|Byte
operator|*
operator|)
name|wp
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
return|return
operator|(
name|addSpace
operator|||
name|added
operator|)
return|;
block|}
end_function

end_unit

