begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1988, 1989, 1990, 1993  *	The Regents of the University of California.  All rights reserved.  * Copyright (c) 1988, 1989 by Adam de Boor  * Copyright (c) 1989 by Berkeley Softworks  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Adam de Boor.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * @(#)dir.c	8.2 (Berkeley) 1/2/94  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*-  * dir.c --  *	Directory searching using wildcards and/or normal names...  *	Used both for source wildcarding in the Makefile and for finding  *	implicit sources.  *  * The interface for this module is:  *	Dir_Init	Initialize the module.  *  *	Dir_HasWildcards Returns TRUE if the name given it needs to  *			be wildcard-expanded.  *  *	Path_Expand	Given a pattern and a path, return a Lst of names  *			which match the pattern on the search path.  *  *	Path_FindFile	Searches for a file on a given search path.  *			If it exists, the entire path is returned.  *			Otherwise NULL is returned.  *  *	Dir_FindHereOrAbove Search for a path in the current directory and  *			then all the directories above it in turn until  *			the path is found or we reach the root ("/").  *  *	Dir_MTime	Return the modification time of a node. The file  *			is searched for along the default search path.  *			The path and mtime fields of the node are filled in.  *  *	Path_AddDir	Add a directory to a search path.  *  *	Dir_MakeFlags	Given a search path and a command flag, create  *			a string with each of the directories in the path  *			preceded by the command flag and all of them  *			separated by a space.  *  *	Dir_Destroy	Destroy an element of a search path. Frees up all  *			things that can be freed for the element as long  *			as the element is no longer referenced by any other  *			search path.  *  *	Dir_ClearPath	Resets a search path to the empty list.  *  * For debugging:  *	Dir_PrintDirectories	Print stats about the directory cache.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<dirent.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"arch.h"
end_include

begin_include
include|#
directive|include
file|"dir.h"
end_include

begin_include
include|#
directive|include
file|"globals.h"
end_include

begin_include
include|#
directive|include
file|"GNode.h"
end_include

begin_include
include|#
directive|include
file|"hash.h"
end_include

begin_include
include|#
directive|include
file|"lst.h"
end_include

begin_include
include|#
directive|include
file|"str.h"
end_include

begin_include
include|#
directive|include
file|"targ.h"
end_include

begin_include
include|#
directive|include
file|"util.h"
end_include

begin_comment
comment|/*  *	A search path consists of a list of Dir structures. A Dir structure  *	has in it the name of the directory and a hash table of all the files  *	in the directory. This is used to cut down on the number of system  *	calls necessary to find implicit dependents and their like. Since  *	these searches are made before any actions are taken, we need not  *	worry about the directory changing due to creation commands. If this  *	hampers the style of some makefiles, they must be changed.  *  *	A list of all previously-read directories is kept in the  *	openDirectories list. This list is checked first before a directory  *	is opened.  *  *	The need for the caching of whole directories is brought about by  *	the multi-level transformation code in suff.c, which tends to search  *	for far more files than regular make does. In the initial  *	implementation, the amount of time spent performing "stat" calls was  *	truly astronomical. The problem with hashing at the start is,  *	of course, that pmake doesn't then detect changes to these directories  *	during the course of the make. Three possibilities suggest themselves:  *  *	    1) just use stat to test for a file's existence. As mentioned  *	       above, this is very inefficient due to the number of checks  *	       engendered by the multi-level transformation code.  *	    2) use readdir() and company to search the directories, keeping  *	       them open between checks. I have tried this and while it  *	       didn't slow down the process too much, it could severely  *	       affect the amount of parallelism available as each directory  *	       open would take another file descriptor out of play for  *	       handling I/O for another job. Given that it is only recently  *	       that UNIX OS's have taken to allowing more than 20 or 32  *	       file descriptors for a process, this doesn't seem acceptable  *	       to me.  *	    3) record the mtime of the directory in the Dir structure and  *	       verify the directory hasn't changed since the contents were  *	       hashed. This will catch the creation or deletion of files,  *	       but not the updating of files. However, since it is the  *	       creation and deletion that is the problem, this could be  *	       a good thing to do. Unfortunately, if the directory (say ".")  *	       were fairly large and changed fairly frequently, the constant  *	       rehashing could seriously degrade performance. It might be  *	       good in such cases to keep track of the number of rehashes  *	       and if the number goes over a (small) limit, resort to using  *	       stat in its place.  *  *	An additional thing to consider is that pmake is used primarily  *	to create C programs and until recently pcc-based compilers refused  *	to allow you to specify where the resulting object file should be  *	placed. This forced all objects to be created in the current  *	directory. This isn't meant as a full excuse, just an explanation of  *	some of the reasons for the caching used here.  *  *	One more note: the location of a target's file is only performed  *	on the downward traversal of the graph and then only for terminal  *	nodes in the graph. This could be construed as wrong in some cases,  *	but prevents inadvertent modification of files when the "installed"  *	directory for a file is provided in the search path.  *  *	Another data structure maintained by this module is an mtime  *	cache used when the searching of cached directories fails to find  *	a file. In the past, Path_FindFile would simply perform an access()  *	call in such a case to determine if the file could be found using  *	just the name given. When this hit, however, all that was gained  *	was the knowledge that the file existed. Given that an access() is  *	essentially a stat() without the copyout() call, and that the same  *	filesystem overhead would have to be incurred in Dir_MTime, it made  *	sense to replace the access() with a stat() and record the mtime  *	in a cache for when Dir_MTime was actually called.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|Dir
block|{
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Name of directory */
name|int
name|refCount
decl_stmt|;
comment|/* No. of paths with this directory */
name|int
name|hits
decl_stmt|;
comment|/* No. of times a file has been found here */
name|Hash_Table
name|files
decl_stmt|;
comment|/* Hash table of files in directory */
name|TAILQ_ENTRY
argument_list|(
argument|Dir
argument_list|)
name|link
expr_stmt|;
comment|/* allDirs link */
block|}
name|Dir
typedef|;
end_typedef

begin_comment
comment|/*  * A path is a list of pointers to directories. These directories are  * reference counted so a directory can be on more than one path.  */
end_comment

begin_struct
struct|struct
name|PathElement
block|{
name|struct
name|Dir
modifier|*
name|dir
decl_stmt|;
comment|/* pointer to the directory */
name|TAILQ_ENTRY
argument_list|(
argument|PathElement
argument_list|)
name|link
expr_stmt|;
comment|/* path link */
block|}
struct|;
end_struct

begin_comment
comment|/* main search path */
end_comment

begin_decl_stmt
name|struct
name|Path
name|dirSearchPath
init|=
name|TAILQ_HEAD_INITIALIZER
argument_list|(
name|dirSearchPath
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the list of all open directories */
end_comment

begin_expr_stmt
specifier|static
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|Dir
argument_list|)
name|openDirectories
operator|=
name|TAILQ_HEAD_INITIALIZER
argument_list|(
name|openDirectories
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Variables for gathering statistics on the efficiency of the hashing  * mechanism.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|hits
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Found in directory cache */
end_comment

begin_decl_stmt
specifier|static
name|int
name|misses
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Sad, but not evil misses */
end_comment

begin_decl_stmt
specifier|static
name|int
name|nearmisses
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Found under search path */
end_comment

begin_decl_stmt
specifier|static
name|int
name|bigmisses
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Sought by itself */
end_comment

begin_decl_stmt
specifier|static
name|Dir
modifier|*
name|dot
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* contents of current directory */
end_comment

begin_comment
comment|/* Results of doing a last-resort stat in Path_FindFile --  * if we have to go to the system to find the file, we might as well  * have its mtime on record.  * XXX: If this is done way early, there's a chance other rules will  * have already updated the file, in which case we'll update it again.  * Generally, there won't be two rules to update a single file, so this  * should be ok, but...  */
end_comment

begin_decl_stmt
specifier|static
name|Hash_Table
name|mtimes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Dir_Init --  *	initialize things for this module  *  * Results:  *	none  *  * Side Effects:  *	none  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Dir_Init
parameter_list|(
name|void
parameter_list|)
block|{
name|Hash_InitTable
argument_list|(
operator|&
name|mtimes
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Dir_InitDot --  *	initialize the "." directory  *  * Results:  *	none  *  * Side Effects:  *	some directories may be opened.  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Dir_InitDot
parameter_list|(
name|void
parameter_list|)
block|{
name|dot
operator|=
name|Path_AddDir
argument_list|(
name|NULL
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
if|if
condition|(
name|dot
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"cannot open current directory"
argument_list|)
expr_stmt|;
comment|/* 	 * We always need to have dot around, so we increment its 	 * reference count to make sure it's not destroyed. 	 */
name|dot
operator|->
name|refCount
operator|+=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Dir_HasWildcards  --  *	See if the given name has any wildcard characters in it.  *  * Results:  *	returns TRUE if the word should be expanded, FALSE otherwise  *  * Side Effects:  *	none  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|Boolean
name|Dir_HasWildcards
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|wild
init|=
literal|0
decl_stmt|,
name|brace
init|=
literal|0
decl_stmt|,
name|bracket
init|=
literal|0
decl_stmt|;
for|for
control|(
name|cp
operator|=
name|name
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|cp
condition|)
block|{
case|case
literal|'{'
case|:
name|brace
operator|++
expr_stmt|;
name|wild
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'}'
case|:
name|brace
operator|--
expr_stmt|;
break|break;
case|case
literal|'['
case|:
name|bracket
operator|++
expr_stmt|;
name|wild
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|']'
case|:
name|bracket
operator|--
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
case|case
literal|'*'
case|:
name|wild
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
return|return
operator|(
name|wild
operator|&&
name|bracket
operator|==
literal|0
operator|&&
name|brace
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * DirMatchFiles --  *	Given a pattern and a Dir structure, see if any files  *	match the pattern and add their names to the 'expansions' list if  *	any do. This is incomplete -- it doesn't take care of patterns like  *	src / *src / *.c properly (just *.c on any of the directories), but it  *	will do for now.  *  * Results:  *	Always returns 0  *  * Side Effects:  *	File names are added to the expansions lst. The directory will be  *	fully hashed when this is done.  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|DirMatchFiles
parameter_list|(
specifier|const
name|char
modifier|*
name|pattern
parameter_list|,
specifier|const
name|Dir
modifier|*
name|p
parameter_list|,
name|Lst
modifier|*
name|expansions
parameter_list|)
block|{
name|Hash_Search
name|search
decl_stmt|;
comment|/* Index into the directory's table */
name|Hash_Entry
modifier|*
name|entry
decl_stmt|;
comment|/* Current entry in the table */
name|Boolean
name|isDot
decl_stmt|;
comment|/* TRUE if the directory being searched is . */
name|isDot
operator|=
operator|(
operator|*
name|p
operator|->
name|name
operator|==
literal|'.'
operator|&&
name|p
operator|->
name|name
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|)
expr_stmt|;
for|for
control|(
name|entry
operator|=
name|Hash_EnumFirst
argument_list|(
operator|&
name|p
operator|->
name|files
argument_list|,
operator|&
name|search
argument_list|)
init|;
name|entry
operator|!=
name|NULL
condition|;
name|entry
operator|=
name|Hash_EnumNext
argument_list|(
operator|&
name|search
argument_list|)
control|)
block|{
comment|/* 		 * See if the file matches the given pattern. Note we follow 		 * the UNIX convention that dot files will only be found if 		 * the pattern begins with a dot (note also that as a side 		 * effect of the hashing scheme, .* won't match . or .. 		 * since they aren't hashed). 		 */
if|if
condition|(
name|Str_Match
argument_list|(
name|entry
operator|->
name|name
argument_list|,
name|pattern
argument_list|)
operator|&&
operator|(
operator|(
name|entry
operator|->
name|name
index|[
literal|0
index|]
operator|!=
literal|'.'
operator|)
operator|||
operator|(
name|pattern
index|[
literal|0
index|]
operator|==
literal|'.'
operator|)
operator|)
condition|)
block|{
name|Lst_AtEnd
argument_list|(
name|expansions
argument_list|,
operator|(
name|isDot
condition|?
name|estrdup
argument_list|(
name|entry
operator|->
name|name
argument_list|)
else|:
name|str_concat
argument_list|(
name|p
operator|->
name|name
argument_list|,
name|entry
operator|->
name|name
argument_list|,
name|STR_ADDSLASH
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * DirExpandCurly --  *	Expand curly braces like the C shell. Does this recursively.  *	Note the special case: if after the piece of the curly brace is  *	done there are no wildcard characters in the result, the result is  *	placed on the list WITHOUT CHECKING FOR ITS EXISTENCE.  The  *	given arguments are the entire word to expand, the first curly  *	brace in the word, the search path, and the list to store the  *	expansions in.  *  * Results:  *	None.  *  * Side Effects:  *	The given list is filled with the expansions...  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|DirExpandCurly
parameter_list|(
specifier|const
name|char
modifier|*
name|word
parameter_list|,
specifier|const
name|char
modifier|*
name|brace
parameter_list|,
name|struct
name|Path
modifier|*
name|path
parameter_list|,
name|Lst
modifier|*
name|expansions
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|end
decl_stmt|;
comment|/* Character after the closing brace */
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* Current position in brace clause */
specifier|const
name|char
modifier|*
name|start
decl_stmt|;
comment|/* Start of current piece of brace clause */
name|int
name|bracelevel
decl_stmt|;
comment|/* Number of braces we've seen. If we see a right brace 			 * when this is 0, we've hit the end of the clause. */
name|char
modifier|*
name|file
decl_stmt|;
comment|/* Current expansion */
name|int
name|otherLen
decl_stmt|;
comment|/* The length of the other pieces of the expansion 			 * (chars before and after the clause in 'word') */
name|char
modifier|*
name|cp2
decl_stmt|;
comment|/* Pointer for checking for wildcards in 			 * expansion before calling Dir_Expand */
name|start
operator|=
name|brace
operator|+
literal|1
expr_stmt|;
comment|/* 	 * Find the end of the brace clause first, being wary of nested brace 	 * clauses. 	 */
for|for
control|(
name|end
operator|=
name|start
operator|,
name|bracelevel
operator|=
literal|0
init|;
operator|*
name|end
operator|!=
literal|'\0'
condition|;
name|end
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|end
operator|==
literal|'{'
condition|)
name|bracelevel
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
operator|*
name|end
operator|==
literal|'}'
operator|)
operator|&&
operator|(
name|bracelevel
operator|--
operator|==
literal|0
operator|)
condition|)
break|break;
block|}
if|if
condition|(
operator|*
name|end
operator|==
literal|'\0'
condition|)
block|{
name|Error
argument_list|(
literal|"Unterminated {} clause \"%s\""
argument_list|,
name|start
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
name|end
operator|++
expr_stmt|;
name|otherLen
operator|=
name|brace
operator|-
name|word
operator|+
name|strlen
argument_list|(
name|end
argument_list|)
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|start
init|;
name|cp
operator|<
name|end
condition|;
name|cp
operator|++
control|)
block|{
comment|/* 		 * Find the end of this piece of the clause. 		 */
name|bracelevel
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|!=
literal|','
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'{'
condition|)
name|bracelevel
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
operator|*
name|cp
operator|==
literal|'}'
operator|)
operator|&&
operator|(
name|bracelevel
operator|--
operator|<=
literal|0
operator|)
condition|)
break|break;
name|cp
operator|++
expr_stmt|;
block|}
comment|/* 		 * Allocate room for the combination and install the 		 * three pieces. 		 */
name|file
operator|=
name|emalloc
argument_list|(
name|otherLen
operator|+
name|cp
operator|-
name|start
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|brace
operator|!=
name|word
condition|)
name|strncpy
argument_list|(
name|file
argument_list|,
name|word
argument_list|,
name|brace
operator|-
name|word
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|start
condition|)
name|strncpy
argument_list|(
operator|&
name|file
index|[
name|brace
operator|-
name|word
index|]
argument_list|,
name|start
argument_list|,
name|cp
operator|-
name|start
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
operator|&
name|file
index|[
operator|(
name|brace
operator|-
name|word
operator|)
operator|+
operator|(
name|cp
operator|-
name|start
operator|)
index|]
argument_list|,
name|end
argument_list|)
expr_stmt|;
comment|/* 		 * See if the result has any wildcards in it. If we find one, 		 * call Dir_Expand right away, telling it to place the result 		 * on our list of expansions. 		 */
for|for
control|(
name|cp2
operator|=
name|file
init|;
operator|*
name|cp2
operator|!=
literal|'\0'
condition|;
name|cp2
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|cp2
condition|)
block|{
case|case
literal|'*'
case|:
case|case
literal|'?'
case|:
case|case
literal|'{'
case|:
case|case
literal|'['
case|:
name|Path_Expand
argument_list|(
name|file
argument_list|,
name|path
argument_list|,
name|expansions
argument_list|)
expr_stmt|;
goto|goto
name|next
goto|;
default|default:
break|break;
block|}
block|}
if|if
condition|(
operator|*
name|cp2
operator|==
literal|'\0'
condition|)
block|{
comment|/* 			 * Hit the end w/o finding any wildcards, so stick 			 * the expansion on the end of the list. 			 */
name|Lst_AtEnd
argument_list|(
name|expansions
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|next
label|:
name|free
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
name|start
operator|=
name|cp
operator|+
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * DirExpandInt --  *	Internal expand routine. Passes through the directories in the  *	path one by one, calling DirMatchFiles for each. NOTE: This still  *	doesn't handle patterns in directories...  Works given a word to  *	expand, a path to look in, and a list to store expansions in.  *  * Results:  *	None.  *  * Side Effects:  *	Things are added to the expansions list.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|DirExpandInt
parameter_list|(
specifier|const
name|char
modifier|*
name|word
parameter_list|,
specifier|const
name|struct
name|Path
modifier|*
name|path
parameter_list|,
name|Lst
modifier|*
name|expansions
parameter_list|)
block|{
name|struct
name|PathElement
modifier|*
name|pe
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|pe
argument_list|,
argument|path
argument_list|,
argument|link
argument_list|)
name|DirMatchFiles
argument_list|(
name|word
argument_list|,
name|pe
operator|->
name|dir
argument_list|,
name|expansions
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Dir_Expand  --  *	Expand the given word into a list of words by globbing it looking  *	in the directories on the given search path.  *  * Results:  *	A list of words consisting of the files which exist along the search  *	path matching the given pattern is placed in expansions.  *  * Side Effects:  *	Directories may be opened. Who knows?  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Path_Expand
parameter_list|(
name|char
modifier|*
name|word
parameter_list|,
name|struct
name|Path
modifier|*
name|path
parameter_list|,
name|Lst
modifier|*
name|expansions
parameter_list|)
block|{
name|LstNode
modifier|*
name|ln
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|DEBUGF
argument_list|(
name|DIR
argument_list|,
operator|(
literal|"expanding \"%s\"..."
operator|,
name|word
operator|)
argument_list|)
expr_stmt|;
name|cp
operator|=
name|strchr
argument_list|(
name|word
argument_list|,
literal|'{'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
name|DirExpandCurly
argument_list|(
name|word
argument_list|,
name|cp
argument_list|,
name|path
argument_list|,
name|expansions
argument_list|)
expr_stmt|;
else|else
block|{
name|cp
operator|=
name|strchr
argument_list|(
name|word
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * The thing has a directory component -- find the 			 * first wildcard in the string. 			 */
for|for
control|(
name|cp
operator|=
name|word
init|;
operator|*
name|cp
operator|!=
literal|'\0'
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'?'
operator|||
operator|*
name|cp
operator|==
literal|'['
operator|||
operator|*
name|cp
operator|==
literal|'*'
operator|||
operator|*
name|cp
operator|==
literal|'{'
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
operator|*
name|cp
operator|==
literal|'{'
condition|)
block|{
comment|/* 				 * This one will be fun. 				 */
name|DirExpandCurly
argument_list|(
name|word
argument_list|,
name|cp
argument_list|,
name|path
argument_list|,
name|expansions
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
block|{
comment|/* 				 * Back up to the start of the component 				 */
name|char
modifier|*
name|dirpath
decl_stmt|;
while|while
condition|(
name|cp
operator|>
name|word
operator|&&
operator|*
name|cp
operator|!=
literal|'/'
condition|)
name|cp
operator|--
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|word
condition|)
block|{
name|char
name|sc
decl_stmt|;
comment|/* 					 * If the glob isn't in the first 					 * component, try and find all the 					 * components up to the one with a 					 * wildcard. 					 */
name|sc
operator|=
name|cp
index|[
literal|1
index|]
expr_stmt|;
name|cp
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|dirpath
operator|=
name|Path_FindFile
argument_list|(
name|word
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|cp
index|[
literal|1
index|]
operator|=
name|sc
expr_stmt|;
comment|/* 					 * dirpath is null if can't find the 					 * leading component 					 * XXX: Path_FindFile won't find internal 					 * components. i.e. if the path contains 					 * ../Etc/Object and we're looking for 					 * Etc, * it won't be found. Ah well. 					 * Probably not important. 					 */
if|if
condition|(
name|dirpath
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|dp
init|=
operator|&
name|dirpath
index|[
name|strlen
argument_list|(
name|dirpath
argument_list|)
operator|-
literal|1
index|]
decl_stmt|;
name|struct
name|Path
name|tp
init|=
name|TAILQ_HEAD_INITIALIZER
argument_list|(
name|tp
argument_list|)
decl_stmt|;
if|if
condition|(
operator|*
name|dp
operator|==
literal|'/'
condition|)
operator|*
name|dp
operator|=
literal|'\0'
expr_stmt|;
name|Path_AddDir
argument_list|(
operator|&
name|tp
argument_list|,
name|dirpath
argument_list|)
expr_stmt|;
name|DirExpandInt
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
operator|&
name|tp
argument_list|,
name|expansions
argument_list|)
expr_stmt|;
name|Path_Clear
argument_list|(
operator|&
name|tp
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 					 * Start the search from the local 					 * directory 					 */
name|DirExpandInt
argument_list|(
name|word
argument_list|,
name|path
argument_list|,
name|expansions
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 				 * Return the file -- this should never happen. 				 */
name|DirExpandInt
argument_list|(
name|word
argument_list|,
name|path
argument_list|,
name|expansions
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 			 * First the files in dot 			 */
name|DirMatchFiles
argument_list|(
name|word
argument_list|,
name|dot
argument_list|,
name|expansions
argument_list|)
expr_stmt|;
comment|/* 			 * Then the files in every other directory on the path. 			 */
name|DirExpandInt
argument_list|(
name|word
argument_list|,
name|path
argument_list|,
name|expansions
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|DEBUG
argument_list|(
name|DIR
argument_list|)
condition|)
block|{
name|LST_FOREACH
argument_list|(
argument|ln
argument_list|,
argument|expansions
argument_list|)
name|DEBUGF
argument_list|(
name|DIR
argument_list|,
operator|(
literal|"%s "
operator|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|DEBUGF
argument_list|(
name|DIR
argument_list|,
operator|(
literal|"\n"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * Path_FindFile  *	Find the file with the given name along the given search path.  *  * Results:  *	The path to the file or NULL. This path is guaranteed to be in a  *	different part of memory than name and so may be safely free'd.  *  * Side Effects:  *	If the file is found in a directory which is not on the path  *	already (either 'name' is absolute or it is a relative path  *	[ dir1/.../dirn/file ] which exists below one of the directories  *	already on the search path), its directory is added to the end  *	of the path on the assumption that there will be more files in  *	that directory later on. Sometimes this is true. Sometimes not.  */
end_comment

begin_function
name|char
modifier|*
name|Path_FindFile
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|Path
modifier|*
name|path
parameter_list|)
block|{
name|char
modifier|*
name|p1
decl_stmt|;
comment|/* pointer into p->name */
name|char
modifier|*
name|p2
decl_stmt|;
comment|/* pointer into name */
name|char
modifier|*
name|file
decl_stmt|;
comment|/* the current filename to check */
specifier|const
name|struct
name|PathElement
modifier|*
name|pe
decl_stmt|;
comment|/* current path member */
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* final component of the name */
name|Boolean
name|hasSlash
decl_stmt|;
comment|/* true if 'name' contains a / */
name|struct
name|stat
name|stb
decl_stmt|;
comment|/* Buffer for stat, if necessary */
name|Hash_Entry
modifier|*
name|entry
decl_stmt|;
comment|/* Entry for mtimes table */
comment|/* 	 * Find the final component of the name and note whether it has a 	 * slash in it (the name, I mean) 	 */
name|cp
operator|=
name|strrchr
argument_list|(
name|name
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
block|{
name|hasSlash
operator|=
name|TRUE
expr_stmt|;
name|cp
operator|+=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|hasSlash
operator|=
name|FALSE
expr_stmt|;
name|cp
operator|=
name|name
expr_stmt|;
block|}
name|DEBUGF
argument_list|(
name|DIR
argument_list|,
operator|(
literal|"Searching for %s..."
operator|,
name|name
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * No matter what, we always look for the file in the current directory 	 * before anywhere else and we *do not* add the ./ to it if it exists. 	 * This is so there are no conflicts between what the user specifies 	 * (fish.c) and what pmake finds (./fish.c). 	 */
if|if
condition|(
operator|(
operator|!
name|hasSlash
operator|||
operator|(
name|cp
operator|-
name|name
operator|==
literal|2
operator|&&
operator|*
name|name
operator|==
literal|'.'
operator|)
operator|)
operator|&&
operator|(
name|Hash_FindEntry
argument_list|(
operator|&
name|dot
operator|->
name|files
argument_list|,
name|cp
argument_list|)
operator|!=
name|NULL
operator|)
condition|)
block|{
name|DEBUGF
argument_list|(
name|DIR
argument_list|,
operator|(
literal|"in '.'\n"
operator|)
argument_list|)
expr_stmt|;
name|hits
operator|+=
literal|1
expr_stmt|;
name|dot
operator|->
name|hits
operator|+=
literal|1
expr_stmt|;
return|return
operator|(
name|estrdup
argument_list|(
name|name
argument_list|)
operator|)
return|;
block|}
comment|/* 	 * We look through all the directories on the path seeking one which 	 * contains the final component of the given name and whose final 	 * component(s) match the name's initial component(s). If such a beast 	 * is found, we concatenate the directory name and the final component 	 * and return the resulting string. If we don't find any such thing, 	 * we go on to phase two... 	 */
name|TAILQ_FOREACH
argument_list|(
argument|pe
argument_list|,
argument|path
argument_list|,
argument|link
argument_list|)
block|{
name|DEBUGF
argument_list|(
name|DIR
argument_list|,
operator|(
literal|"%s..."
operator|,
name|pe
operator|->
name|dir
operator|->
name|name
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|Hash_FindEntry
argument_list|(
operator|&
name|pe
operator|->
name|dir
operator|->
name|files
argument_list|,
name|cp
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|DEBUGF
argument_list|(
name|DIR
argument_list|,
operator|(
literal|"here..."
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hasSlash
condition|)
block|{
comment|/* 				 * If the name had a slash, its initial 				 * components and p's final components must 				 * match. This is false if a mismatch is 				 * encountered before all of the initial 				 * components have been checked (p2> name at 				 * the end of the loop), or we matched only 				 * part of one of the components of p 				 * along with all the rest of them (*p1 != '/'). 				 */
name|p1
operator|=
name|pe
operator|->
name|dir
operator|->
name|name
operator|+
name|strlen
argument_list|(
name|pe
operator|->
name|dir
operator|->
name|name
argument_list|)
operator|-
literal|1
expr_stmt|;
name|p2
operator|=
name|cp
operator|-
literal|2
expr_stmt|;
while|while
condition|(
name|p2
operator|>=
name|name
operator|&&
name|p1
operator|>=
name|pe
operator|->
name|dir
operator|->
name|name
operator|&&
operator|*
name|p1
operator|==
operator|*
name|p2
condition|)
block|{
name|p1
operator|-=
literal|1
expr_stmt|;
name|p2
operator|-=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|p2
operator|>=
name|name
operator|||
operator|(
name|p1
operator|>=
name|pe
operator|->
name|dir
operator|->
name|name
operator|&&
operator|*
name|p1
operator|!=
literal|'/'
operator|)
condition|)
block|{
name|DEBUGF
argument_list|(
name|DIR
argument_list|,
operator|(
literal|"component mismatch -- "
literal|"continuing..."
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
name|file
operator|=
name|str_concat
argument_list|(
name|pe
operator|->
name|dir
operator|->
name|name
argument_list|,
name|cp
argument_list|,
name|STR_ADDSLASH
argument_list|)
expr_stmt|;
name|DEBUGF
argument_list|(
name|DIR
argument_list|,
operator|(
literal|"returning %s\n"
operator|,
name|file
operator|)
argument_list|)
expr_stmt|;
name|pe
operator|->
name|dir
operator|->
name|hits
operator|+=
literal|1
expr_stmt|;
name|hits
operator|+=
literal|1
expr_stmt|;
return|return
operator|(
name|file
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|hasSlash
condition|)
block|{
comment|/* 			 * If the file has a leading path component and that 			 * component exactly matches the entire name of the 			 * current search directory, we assume the file 			 * doesn't exist and return NULL. 			 */
for|for
control|(
name|p1
operator|=
name|pe
operator|->
name|dir
operator|->
name|name
operator|,
name|p2
operator|=
name|name
init|;
operator|*
name|p1
operator|&&
operator|*
name|p1
operator|==
operator|*
name|p2
condition|;
name|p1
operator|++
operator|,
name|p2
operator|++
control|)
continue|continue;
if|if
condition|(
operator|*
name|p1
operator|==
literal|'\0'
operator|&&
name|p2
operator|==
name|cp
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
operator|||
name|ISDOT
argument_list|(
name|cp
argument_list|)
operator|||
name|ISDOTDOT
argument_list|(
name|cp
argument_list|)
condition|)
block|{
name|DEBUGF
argument_list|(
name|DIR
argument_list|,
operator|(
literal|"returning %s\n"
operator|,
name|name
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|estrdup
argument_list|(
name|name
argument_list|)
operator|)
return|;
block|}
else|else
block|{
name|DEBUGF
argument_list|(
name|DIR
argument_list|,
operator|(
literal|"must be here but isn't --"
literal|" returning NULL\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
block|}
block|}
comment|/* 	 * We didn't find the file on any existing members of the directory. 	 * If the name doesn't contain a slash, that means it doesn't exist. 	 * If it *does* contain a slash, however, there is still hope: it 	 * could be in a subdirectory of one of the members of the search 	 * path. (eg. /usr/include and sys/types.h. The above search would 	 * fail to turn up types.h in /usr/include, but it *is* in 	 * /usr/include/sys/types.h) If we find such a beast, we assume there 	 * will be more (what else can we assume?) and add all but the last 	 * component of the resulting name onto the search path (at the 	 * end). This phase is only performed if the file is *not* absolute. 	 */
if|if
condition|(
operator|!
name|hasSlash
condition|)
block|{
name|DEBUGF
argument_list|(
name|DIR
argument_list|,
operator|(
literal|"failed.\n"
operator|)
argument_list|)
expr_stmt|;
name|misses
operator|+=
literal|1
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
operator|*
name|name
operator|!=
literal|'/'
condition|)
block|{
name|Boolean
name|checkedDot
init|=
name|FALSE
decl_stmt|;
name|DEBUGF
argument_list|(
name|DIR
argument_list|,
operator|(
literal|"failed. Trying subdirectories..."
operator|)
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|pe
argument_list|,
argument|path
argument_list|,
argument|link
argument_list|)
block|{
if|if
condition|(
name|pe
operator|->
name|dir
operator|!=
name|dot
condition|)
block|{
name|file
operator|=
name|str_concat
argument_list|(
name|pe
operator|->
name|dir
operator|->
name|name
argument_list|,
name|name
argument_list|,
name|STR_ADDSLASH
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * Checking in dot -- DON'T put a leading ./ 				 * on the thing. 				 */
name|file
operator|=
name|estrdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|checkedDot
operator|=
name|TRUE
expr_stmt|;
block|}
name|DEBUGF
argument_list|(
name|DIR
argument_list|,
operator|(
literal|"checking %s..."
operator|,
name|file
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|file
argument_list|,
operator|&
name|stb
argument_list|)
operator|==
literal|0
condition|)
block|{
name|DEBUGF
argument_list|(
name|DIR
argument_list|,
operator|(
literal|"got it.\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* 				 * We've found another directory to search. We 				 * know there's a slash in 'file' because we put 				 * one there. We nuke it after finding it and 				 * call Path_AddDir to add this new directory 				 * onto the existing search path. Once that's 				 * done, we restore the slash and triumphantly 				 * return the file name, knowing that should a 				 * file in this directory every be referenced 				 * again in such a manner, we will find it 				 * without having to do numerous numbers of 				 * access calls. Hurrah! 				 */
name|cp
operator|=
name|strrchr
argument_list|(
name|file
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|Path_AddDir
argument_list|(
name|path
argument_list|,
name|file
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|=
literal|'/'
expr_stmt|;
comment|/* 				 * Save the modification time so if 				 * it's needed, we don't have to fetch it again. 				 */
name|DEBUGF
argument_list|(
name|DIR
argument_list|,
operator|(
literal|"Caching %s for %s\n"
operator|,
name|Targ_FmtTime
argument_list|(
name|stb
operator|.
name|st_mtime
argument_list|)
operator|,
name|file
operator|)
argument_list|)
expr_stmt|;
name|entry
operator|=
name|Hash_CreateEntry
argument_list|(
operator|&
name|mtimes
argument_list|,
name|file
argument_list|,
operator|(
name|Boolean
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|Hash_SetValue
argument_list|(
name|entry
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|long
operator|)
name|stb
operator|.
name|st_mtime
argument_list|)
expr_stmt|;
name|nearmisses
operator|+=
literal|1
expr_stmt|;
return|return
operator|(
name|file
operator|)
return|;
block|}
else|else
block|{
name|free
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
block|}
name|DEBUGF
argument_list|(
name|DIR
argument_list|,
operator|(
literal|"failed. "
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|checkedDot
condition|)
block|{
comment|/* 			 * Already checked by the given name, since . was in 			 * the path, so no point in proceeding... 			 */
name|DEBUGF
argument_list|(
name|DIR
argument_list|,
operator|(
literal|"Checked . already, returning NULL\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
comment|/* 	 * Didn't find it that way, either. Sigh. Phase 3. Add its directory 	 * onto the search path in any case, just in case, then look for the 	 * thing in the hash table. If we find it, grand. We return a new 	 * copy of the name. Otherwise we sadly return a NULL pointer. Sigh. 	 * Note that if the directory holding the file doesn't exist, this will 	 * do an extra search of the final directory on the path. Unless 	 * something weird happens, this search won't succeed and life will 	 * be groovy. 	 * 	 * Sigh. We cannot add the directory onto the search path because 	 * of this amusing case: 	 * $(INSTALLDIR)/$(FILE): $(FILE) 	 * 	 * $(FILE) exists in $(INSTALLDIR) but not in the current one. 	 * When searching for $(FILE), we will find it in $(INSTALLDIR) 	 * b/c we added it here. This is not good... 	 */
name|DEBUGF
argument_list|(
name|DIR
argument_list|,
operator|(
literal|"Looking for \"%s\"..."
operator|,
name|name
operator|)
argument_list|)
expr_stmt|;
name|bigmisses
operator|+=
literal|1
expr_stmt|;
name|entry
operator|=
name|Hash_FindEntry
argument_list|(
operator|&
name|mtimes
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|!=
name|NULL
condition|)
block|{
name|DEBUGF
argument_list|(
name|DIR
argument_list|,
operator|(
literal|"got it (in mtime cache)\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|estrdup
argument_list|(
name|name
argument_list|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|stat
argument_list|(
name|name
argument_list|,
operator|&
name|stb
argument_list|)
operator|==
literal|0
condition|)
block|{
name|entry
operator|=
name|Hash_CreateEntry
argument_list|(
operator|&
name|mtimes
argument_list|,
name|name
argument_list|,
operator|(
name|Boolean
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|DEBUGF
argument_list|(
name|DIR
argument_list|,
operator|(
literal|"Caching %s for %s\n"
operator|,
name|Targ_FmtTime
argument_list|(
name|stb
operator|.
name|st_mtime
argument_list|)
operator|,
name|name
operator|)
argument_list|)
expr_stmt|;
name|Hash_SetValue
argument_list|(
name|entry
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|long
operator|)
name|stb
operator|.
name|st_mtime
argument_list|)
expr_stmt|;
return|return
operator|(
name|estrdup
argument_list|(
name|name
argument_list|)
operator|)
return|;
block|}
else|else
block|{
name|DEBUGF
argument_list|(
name|DIR
argument_list|,
operator|(
literal|"failed. Returning NULL\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Dir_FindHereOrAbove  --  *	search for a path starting at a given directory and then working  *	our way up towards the root.  *  * Input:  *	here		starting directory  *	search_path	the path we are looking for  *	result		the result of a successful search is placed here  *	rlen		the length of the result buffer  *			(typically MAXPATHLEN + 1)  *  * Results:  *	0 on failure, 1 on success [in which case the found path is put  *	in the result buffer].  *  * Side Effects:  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Dir_FindHereOrAbove
parameter_list|(
name|char
modifier|*
name|here
parameter_list|,
name|char
modifier|*
name|search_path
parameter_list|,
name|char
modifier|*
name|result
parameter_list|,
name|int
name|rlen
parameter_list|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
name|char
name|dirbase
index|[
name|MAXPATHLEN
operator|+
literal|1
index|]
decl_stmt|,
modifier|*
name|db_end
decl_stmt|;
name|char
name|try
index|[
name|MAXPATHLEN
operator|+
literal|1
index|]
decl_stmt|,
modifier|*
name|try_end
decl_stmt|;
comment|/* copy out our starting point */
name|snprintf
argument_list|(
name|dirbase
argument_list|,
sizeof|sizeof
argument_list|(
name|dirbase
argument_list|)
argument_list|,
literal|"%s"
argument_list|,
name|here
argument_list|)
expr_stmt|;
name|db_end
operator|=
name|dirbase
operator|+
name|strlen
argument_list|(
name|dirbase
argument_list|)
expr_stmt|;
comment|/* loop until we determine a result */
while|while
condition|(
literal|1
condition|)
block|{
comment|/* try and stat(2) it ... */
name|snprintf
argument_list|(
name|try
argument_list|,
sizeof|sizeof
argument_list|(
name|try
argument_list|)
argument_list|,
literal|"%s/%s"
argument_list|,
name|dirbase
argument_list|,
name|search_path
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|try
argument_list|,
operator|&
name|st
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* 			 * Success!  If we found a file, chop off 			 * the filename so we return a directory. 			 */
if|if
condition|(
operator|(
name|st
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|!=
name|S_IFDIR
condition|)
block|{
name|try_end
operator|=
name|try
operator|+
name|strlen
argument_list|(
name|try
argument_list|)
expr_stmt|;
while|while
condition|(
name|try_end
operator|>
name|try
operator|&&
operator|*
name|try_end
operator|!=
literal|'/'
condition|)
name|try_end
operator|--
expr_stmt|;
if|if
condition|(
name|try_end
operator|>
name|try
condition|)
operator|*
name|try_end
operator|=
literal|0
expr_stmt|;
comment|/* chop! */
block|}
comment|/* 			 * Done! 			 */
name|snprintf
argument_list|(
name|result
argument_list|,
name|rlen
argument_list|,
literal|"%s"
argument_list|,
name|try
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 		 * Nope, we didn't find it.  If we used up dirbase we've 		 * reached the root and failed. 		 */
if|if
condition|(
name|db_end
operator|==
name|dirbase
condition|)
break|break;
comment|/* Failed! */
comment|/* 		 * truncate dirbase from the end to move up a dir 		 */
while|while
condition|(
name|db_end
operator|>
name|dirbase
operator|&&
operator|*
name|db_end
operator|!=
literal|'/'
condition|)
name|db_end
operator|--
expr_stmt|;
operator|*
name|db_end
operator|=
literal|0
expr_stmt|;
comment|/* chop! */
block|}
comment|/* while (1) */
comment|/* 	 * We failed... 	 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Dir_MTime  --  *	Find the modification time of the file described by gn along the  *	search path dirSearchPath.  *  * Results:  *	The modification time or 0 if it doesn't exist  *  * Side Effects:  *	The modification time is placed in the node's mtime slot.  *	If the node didn't have a path entry before, and Path_FindFile  *	found one for it, the full name is placed in the path slot.  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Dir_MTime
parameter_list|(
name|GNode
modifier|*
name|gn
parameter_list|)
block|{
name|char
modifier|*
name|fullName
decl_stmt|;
comment|/* the full pathname of name */
name|struct
name|stat
name|stb
decl_stmt|;
comment|/* buffer for finding the mod time */
name|Hash_Entry
modifier|*
name|entry
decl_stmt|;
if|if
condition|(
name|gn
operator|->
name|type
operator|&
name|OP_ARCHV
condition|)
return|return
operator|(
name|Arch_MTime
argument_list|(
name|gn
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
name|gn
operator|->
name|path
operator|==
name|NULL
condition|)
name|fullName
operator|=
name|Path_FindFile
argument_list|(
name|gn
operator|->
name|name
argument_list|,
operator|&
name|dirSearchPath
argument_list|)
expr_stmt|;
else|else
name|fullName
operator|=
name|gn
operator|->
name|path
expr_stmt|;
if|if
condition|(
name|fullName
operator|==
name|NULL
condition|)
name|fullName
operator|=
name|estrdup
argument_list|(
name|gn
operator|->
name|name
argument_list|)
expr_stmt|;
name|entry
operator|=
name|Hash_FindEntry
argument_list|(
operator|&
name|mtimes
argument_list|,
name|fullName
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Only do this once -- the second time folks are checking to 		 * see if the file was actually updated, so we need to 		 * actually go to the filesystem. 		 */
name|DEBUGF
argument_list|(
name|DIR
argument_list|,
operator|(
literal|"Using cached time %s for %s\n"
operator|,
name|Targ_FmtTime
argument_list|(
operator|(
name|time_t
operator|)
operator|(
name|long
operator|)
name|Hash_GetValue
argument_list|(
name|entry
argument_list|)
argument_list|)
operator|,
name|fullName
operator|)
argument_list|)
expr_stmt|;
name|stb
operator|.
name|st_mtime
operator|=
operator|(
name|time_t
operator|)
operator|(
name|long
operator|)
name|Hash_GetValue
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|Hash_DeleteEntry
argument_list|(
operator|&
name|mtimes
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|stat
argument_list|(
name|fullName
argument_list|,
operator|&
name|stb
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|gn
operator|->
name|type
operator|&
name|OP_MEMBER
condition|)
block|{
if|if
condition|(
name|fullName
operator|!=
name|gn
operator|->
name|path
condition|)
name|free
argument_list|(
name|fullName
argument_list|)
expr_stmt|;
return|return
operator|(
name|Arch_MemMTime
argument_list|(
name|gn
argument_list|)
operator|)
return|;
block|}
else|else
block|{
name|stb
operator|.
name|st_mtime
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fullName
operator|&&
name|gn
operator|->
name|path
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
name|gn
operator|->
name|path
operator|=
name|fullName
expr_stmt|;
name|gn
operator|->
name|mtime
operator|=
name|stb
operator|.
name|st_mtime
expr_stmt|;
return|return
operator|(
name|gn
operator|->
name|mtime
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Path_AddDir --  *	Add the given name to the end of the given path.  *  * Results:  *	none  *  * Side Effects:  *	A structure is added to the list and the directory is  *	read and hashed.  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|struct
name|Dir
modifier|*
name|Path_AddDir
parameter_list|(
name|struct
name|Path
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|Dir
modifier|*
name|d
decl_stmt|;
comment|/* pointer to new Path structure */
name|DIR
modifier|*
name|dir
decl_stmt|;
comment|/* for reading directory */
name|struct
name|PathElement
modifier|*
name|pe
decl_stmt|;
name|struct
name|dirent
modifier|*
name|dp
decl_stmt|;
comment|/* entry in directory */
comment|/* check whether we know this directory */
name|TAILQ_FOREACH
argument_list|(
argument|d
argument_list|,
argument|&openDirectories
argument_list|,
argument|link
argument_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|d
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Found it. */
if|if
condition|(
name|path
operator|==
name|NULL
condition|)
return|return
operator|(
name|d
operator|)
return|;
comment|/* Check whether its already on the path. */
name|TAILQ_FOREACH
argument_list|(
argument|pe
argument_list|,
argument|path
argument_list|,
argument|link
argument_list|)
block|{
if|if
condition|(
name|pe
operator|->
name|dir
operator|==
name|d
condition|)
return|return
operator|(
name|d
operator|)
return|;
block|}
comment|/* Add it to the path */
name|d
operator|->
name|refCount
operator|+=
literal|1
expr_stmt|;
name|pe
operator|=
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|pe
argument_list|)
argument_list|)
expr_stmt|;
name|pe
operator|->
name|dir
operator|=
name|d
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
name|path
argument_list|,
name|pe
argument_list|,
name|link
argument_list|)
expr_stmt|;
return|return
operator|(
name|d
operator|)
return|;
block|}
block|}
name|DEBUGF
argument_list|(
name|DIR
argument_list|,
operator|(
literal|"Caching %s..."
operator|,
name|name
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dir
operator|=
name|opendir
argument_list|(
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|DEBUGF
argument_list|(
name|DIR
argument_list|,
operator|(
literal|" cannot open\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|d
operator|=
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|d
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|->
name|name
operator|=
name|estrdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|d
operator|->
name|hits
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|refCount
operator|=
literal|1
expr_stmt|;
name|Hash_InitTable
argument_list|(
operator|&
name|d
operator|->
name|files
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|dp
operator|=
name|readdir
argument_list|(
name|dir
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
operator|&&
name|defined
argument_list|(
name|d_ino
argument_list|)
comment|/* d_ino is a sunos4 #define	for d_fileno */
comment|/* 		 * The sun directory library doesn't check for 		 * a 0 inode (0-inode slots just take up space), 		 * so we have to do it ourselves. 		 */
if|if
condition|(
name|dp
operator|->
name|d_fileno
operator|==
literal|0
condition|)
continue|continue;
endif|#
directive|endif
comment|/* sun&& d_ino */
comment|/* Skip the '.' and '..' entries by checking 		 * for them specifically instead of assuming 		 * readdir() reuturns them in that order when 		 * first going through a directory.  This is 		 * needed for XFS over NFS filesystems since 		 * SGI does not guarantee that these are the 		 * first two entries returned from readdir(). 		 */
if|if
condition|(
name|ISDOT
argument_list|(
name|dp
operator|->
name|d_name
argument_list|)
operator|||
name|ISDOTDOT
argument_list|(
name|dp
operator|->
name|d_name
argument_list|)
condition|)
continue|continue;
name|Hash_CreateEntry
argument_list|(
operator|&
name|d
operator|->
name|files
argument_list|,
name|dp
operator|->
name|d_name
argument_list|,
operator|(
name|Boolean
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
name|closedir
argument_list|(
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
operator|!=
name|NULL
condition|)
block|{
comment|/* Add it to the path */
name|d
operator|->
name|refCount
operator|+=
literal|1
expr_stmt|;
name|pe
operator|=
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|pe
argument_list|)
argument_list|)
expr_stmt|;
name|pe
operator|->
name|dir
operator|=
name|d
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
name|path
argument_list|,
name|pe
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
comment|/* Add to list of all directories */
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|openDirectories
argument_list|,
name|d
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|DEBUGF
argument_list|(
name|DIR
argument_list|,
operator|(
literal|"done\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|d
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Path_Duplicate  *	Duplicate a path. Ups the reference count for the directories.  */
end_comment

begin_function
name|void
name|Path_Duplicate
parameter_list|(
name|struct
name|Path
modifier|*
name|dst
parameter_list|,
specifier|const
name|struct
name|Path
modifier|*
name|src
parameter_list|)
block|{
name|struct
name|PathElement
modifier|*
name|ped
decl_stmt|,
modifier|*
name|pes
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|pes
argument_list|,
argument|src
argument_list|,
argument|link
argument_list|)
block|{
name|ped
operator|=
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ped
argument_list|)
argument_list|)
expr_stmt|;
name|ped
operator|->
name|dir
operator|=
name|pes
operator|->
name|dir
expr_stmt|;
name|ped
operator|->
name|dir
operator|->
name|refCount
operator|++
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
name|dst
argument_list|,
name|ped
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * Path_MakeFlags  *	Make a string by taking all the directories in the given search  *	path and preceding them by the given flag. Used by the suffix  *	module to create variables for compilers based on suffix search  *	paths.  *  * Results:  *	The string mentioned above. Note that there is no space between  *	the given flag and each directory. The empty string is returned if  *	Things don't go well.  */
end_comment

begin_function
name|char
modifier|*
name|Path_MakeFlags
parameter_list|(
specifier|const
name|char
modifier|*
name|flag
parameter_list|,
specifier|const
name|struct
name|Path
modifier|*
name|path
parameter_list|)
block|{
name|char
modifier|*
name|str
decl_stmt|;
comment|/* the string which will be returned */
name|char
modifier|*
name|tstr
decl_stmt|;
comment|/* the current directory preceded by 'flag' */
name|char
modifier|*
name|nstr
decl_stmt|;
specifier|const
name|struct
name|PathElement
modifier|*
name|pe
decl_stmt|;
name|str
operator|=
name|estrdup
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|pe
argument_list|,
argument|path
argument_list|,
argument|link
argument_list|)
block|{
name|tstr
operator|=
name|str_concat
argument_list|(
name|flag
argument_list|,
name|pe
operator|->
name|dir
operator|->
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|nstr
operator|=
name|str_concat
argument_list|(
name|str
argument_list|,
name|tstr
argument_list|,
name|STR_ADDSPACE
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tstr
argument_list|)
expr_stmt|;
name|str
operator|=
name|nstr
expr_stmt|;
block|}
return|return
operator|(
name|str
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Path_Clear  *  *	Destroy a path. This decrements the reference counts of all  *	directories of this path and, if a reference count goes 0,  *	destroys the directory object.  */
end_comment

begin_function
name|void
name|Path_Clear
parameter_list|(
name|struct
name|Path
modifier|*
name|path
parameter_list|)
block|{
name|struct
name|PathElement
modifier|*
name|pe
decl_stmt|;
while|while
condition|(
operator|(
name|pe
operator|=
name|TAILQ_FIRST
argument_list|(
name|path
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|pe
operator|->
name|dir
operator|->
name|refCount
operator|--
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
name|path
argument_list|,
name|pe
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|pe
operator|->
name|dir
operator|->
name|refCount
operator|==
literal|0
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|openDirectories
argument_list|,
name|pe
operator|->
name|dir
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|Hash_DeleteTable
argument_list|(
operator|&
name|pe
operator|->
name|dir
operator|->
name|files
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pe
operator|->
name|dir
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pe
operator|->
name|dir
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|pe
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * Path_Concat  *  *	Concatenate two paths, adding the second to the end of the first.  *	Make sure to avoid duplicates.  *  * Side Effects:  *	Reference counts for added dirs are upped.  */
end_comment

begin_function
name|void
name|Path_Concat
parameter_list|(
name|struct
name|Path
modifier|*
name|path1
parameter_list|,
specifier|const
name|struct
name|Path
modifier|*
name|path2
parameter_list|)
block|{
name|struct
name|PathElement
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|p2
argument_list|,
argument|path2
argument_list|,
argument|link
argument_list|)
block|{
name|TAILQ_FOREACH
argument_list|(
argument|p1
argument_list|,
argument|path1
argument_list|,
argument|link
argument_list|)
block|{
if|if
condition|(
name|p1
operator|->
name|dir
operator|==
name|p2
operator|->
name|dir
condition|)
break|break;
block|}
if|if
condition|(
name|p1
operator|==
name|NULL
condition|)
block|{
name|p1
operator|=
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|p1
argument_list|)
argument_list|)
expr_stmt|;
name|p1
operator|->
name|dir
operator|=
name|p2
operator|->
name|dir
expr_stmt|;
name|p1
operator|->
name|dir
operator|->
name|refCount
operator|++
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
name|path1
argument_list|,
name|p1
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/********** DEBUG INFO **********/
end_comment

begin_function
name|void
name|Dir_PrintDirectories
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|Dir
modifier|*
name|d
decl_stmt|;
name|printf
argument_list|(
literal|"#*** Directory Cache:\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"# Stats: %d hits %d misses %d near misses %d losers (%d%%)\n"
argument_list|,
name|hits
argument_list|,
name|misses
argument_list|,
name|nearmisses
argument_list|,
name|bigmisses
argument_list|,
operator|(
name|hits
operator|+
name|bigmisses
operator|+
name|nearmisses
condition|?
name|hits
operator|*
literal|100
operator|/
operator|(
name|hits
operator|+
name|bigmisses
operator|+
name|nearmisses
operator|)
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"# %-20s referenced\thits\n"
argument_list|,
literal|"directory"
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|d
argument_list|,
argument|&openDirectories
argument_list|,
argument|link
argument_list|)
name|printf
argument_list|(
literal|"# %-20s %10d\t%4d\n"
argument_list|,
name|d
operator|->
name|name
argument_list|,
name|d
operator|->
name|refCount
argument_list|,
name|d
operator|->
name|hits
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|Path_Print
parameter_list|(
specifier|const
name|struct
name|Path
modifier|*
name|path
parameter_list|)
block|{
specifier|const
name|struct
name|PathElement
modifier|*
name|p
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|p
argument_list|,
argument|path
argument_list|,
argument|link
argument_list|)
name|printf
argument_list|(
literal|"%s "
argument_list|,
name|p
operator|->
name|dir
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

