begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1988, 1989, 1990, 1993  *	The Regents of the University of California.  All rights reserved.  * Copyright (c) 1988, 1989 by Adam de Boor  * Copyright (c) 1989 by Berkeley Softworks  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Adam de Boor.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * @(#)job.c	8.2 (Berkeley) 3/19/94  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|OLD_JOKE
end_ifndef

begin_define
define|#
directive|define
name|OLD_JOKE
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OLD_JOKE */
end_comment

begin_comment
comment|/*-  * job.c --  *	handle the creation etc. of our child processes.  *  * Interface:  *	Job_Make  	    	Start the creation of the given target.  *  *	Job_CatchChildren   	Check for and handle the termination of any  *	    	  	    	children. This must be called reasonably  *	    	  	    	frequently to keep the whole make going at  *	    	  	    	a decent clip, since job table entries aren't  *	    	  	    	removed until their process is caught this way.  *	    	  	    	Its single argument is TRUE if the function  *	    	  	    	should block waiting for a child to terminate.  *  *	Job_CatchOutput	    	Print any output our children have produced.  *	    	  	    	Should also be called fairly frequently to  *	    	  	    	keep the user informed of what's going on.  *	    	  	    	If no output is waiting, it will block for  *	    	  	    	a time given by the SEL_* constants, below,  *	    	  	    	or until output is ready.  *  *	Job_Init  	    	Called to intialize this module. in addition,  *	    	  	    	any commands attached to the .BEGIN target  *	    	  	    	are executed before this function returns.  *	    	  	    	Hence, the makefile must have been parsed  *	    	  	    	before this function is called.  *  *	Job_Full  	    	Return TRUE if the job table is filled.  *  *	Job_Empty 	    	Return TRUE if the job table is completely  *	    	  	    	empty.  *  *	Job_ParseShell	    	Given the line following a .SHELL target, parse  *	    	  	    	the line as a shell specification. Returns  *	    	  	    	FAILURE if the spec was incorrect.  *  *	Job_Finish	  	    	Perform any final processing which needs doing.  *	    	  	    	This includes the execution of any commands  *	    	  	    	which have been/were attached to the .END  *	    	  	    	target. It should only be called when the  *	    	  	    	job table is empty.  *  *	Job_AbortAll	    	Abort all currently running jobs. It doesn't  *	    	  	    	handle output or do anything for the jobs,  *	    	  	    	just kills them. It should only be called in  *	    	  	    	an emergency, as it were.  *  *	Job_CheckCommands   	Verify that the commands for a target are  *	    	  	    	ok. Provide them if necessary and possible.  *  *	Job_Touch 	    	Update a target without really updating it.  *  *	Job_Wait  	    	Wait for all currently-running jobs to finish.  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/select.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|USE_KQUEUE
end_ifdef

begin_include
include|#
directive|include
file|<sys/event.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<utime.h>
end_include

begin_include
include|#
directive|include
file|"arch.h"
end_include

begin_include
include|#
directive|include
file|"buf.h"
end_include

begin_include
include|#
directive|include
file|"compat.h"
end_include

begin_include
include|#
directive|include
file|"dir.h"
end_include

begin_include
include|#
directive|include
file|"globals.h"
end_include

begin_include
include|#
directive|include
file|"GNode.h"
end_include

begin_include
include|#
directive|include
file|"job.h"
end_include

begin_include
include|#
directive|include
file|"make.h"
end_include

begin_include
include|#
directive|include
file|"parse.h"
end_include

begin_include
include|#
directive|include
file|"pathnames.h"
end_include

begin_include
include|#
directive|include
file|"str.h"
end_include

begin_include
include|#
directive|include
file|"targ.h"
end_include

begin_include
include|#
directive|include
file|"util.h"
end_include

begin_include
include|#
directive|include
file|"var.h"
end_include

begin_define
define|#
directive|define
name|STATIC
value|static
end_define

begin_comment
comment|/*  * error handling variables  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|errors
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of errors reported */
end_comment

begin_decl_stmt
specifier|static
name|int
name|aborting
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* why is the make aborting? */
end_comment

begin_define
define|#
directive|define
name|ABORT_ERROR
value|1
end_define

begin_comment
comment|/* Because of an error */
end_comment

begin_define
define|#
directive|define
name|ABORT_INTERRUPT
value|2
end_define

begin_comment
comment|/* Because it was interrupted */
end_comment

begin_define
define|#
directive|define
name|ABORT_WAIT
value|3
end_define

begin_comment
comment|/* Waiting for jobs to finish */
end_comment

begin_comment
comment|/*  * XXX: Avoid SunOS bug... FILENO() is fp->_file, and file  * is a char! So when we go above 127 we turn negative!  */
end_comment

begin_define
define|#
directive|define
name|FILENO
parameter_list|(
name|a
parameter_list|)
value|((unsigned)fileno(a))
end_define

begin_comment
comment|/*  * post-make command processing. The node postCommands is really just the  * .END target but we keep it around to avoid having to search for it  * all the time.  */
end_comment

begin_decl_stmt
specifier|static
name|GNode
modifier|*
name|postCommands
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* node containing commands to execute when 				     * everything else is done */
end_comment

begin_decl_stmt
specifier|static
name|int
name|numCommands
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of commands actually printed 				     * for a target. Should this number be 				     * 0, no shell will be executed. */
end_comment

begin_comment
comment|/*  * Return values from JobStart.  */
end_comment

begin_define
define|#
directive|define
name|JOB_RUNNING
value|0
end_define

begin_comment
comment|/* Job is running */
end_comment

begin_define
define|#
directive|define
name|JOB_ERROR
value|1
end_define

begin_comment
comment|/* Error in starting the job */
end_comment

begin_define
define|#
directive|define
name|JOB_FINISHED
value|2
end_define

begin_comment
comment|/* The job is already finished */
end_comment

begin_define
define|#
directive|define
name|JOB_STOPPED
value|3
end_define

begin_comment
comment|/* The job is stopped */
end_comment

begin_comment
comment|/*  * tfile is used to build temp file names to store shell commands to  * execute.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|tfile
index|[
sizeof|sizeof
argument_list|(
name|TMPPAT
argument_list|)
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Descriptions for various shells.  */
end_comment

begin_expr_stmt
specifier|static
specifier|const
name|DEF_SHELL_STRUCT
argument_list|(
argument|CShell
argument_list|,
argument|const
argument_list|)
name|shells
index|[]
operator|=
block|{
comment|/*      * CSH description. The csh can do echo control by playing      * with the setting of the 'echo' shell variable. Sadly,      * however, it is unable to do error control nicely.      */
block|{
literal|"csh"
block|,
name|TRUE
block|,
literal|"unset verbose"
block|,
literal|"set verbose"
block|,
literal|"unset verbose"
block|,
literal|13
block|,
name|FALSE
block|,
literal|"echo \"%s\"\n"
block|,
literal|"csh -c \"%s || exit 0\""
block|,
literal|"v"
block|,
literal|"e"
block|, }
block|,
comment|/*      * SH description. Echo control is also possible and, under      * sun UNIX anyway, one can even control error checking.      */
block|{
literal|"sh"
block|,
name|TRUE
block|,
literal|"set -"
block|,
literal|"set -v"
block|,
literal|"set -"
block|,
literal|5
block|,
name|TRUE
block|,
literal|"set -e"
block|,
literal|"set +e"
block|,
ifdef|#
directive|ifdef
name|OLDBOURNESHELL
name|FALSE
block|,
literal|"echo \"%s\"\n"
block|,
literal|"sh -c '%s || exit 0'\n"
block|,
endif|#
directive|endif
literal|"v"
block|,
literal|"e"
block|, }
block|,
comment|/*      * KSH description. The Korn shell has a superset of      * the Bourne shell's functionality.      */
block|{
literal|"ksh"
block|,
name|TRUE
block|,
literal|"set -"
block|,
literal|"set -v"
block|,
literal|"set -"
block|,
literal|5
block|,
name|TRUE
block|,
literal|"set -e"
block|,
literal|"set +e"
block|,
literal|"v"
block|,
literal|"e"
block|, }
block|, }
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|Shell
modifier|*
name|commandShell
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* this is the shell to which we pass 					 * all commands in the Makefile. It is 					 * set by the Job_ParseShell function */
end_comment

begin_decl_stmt
name|char
modifier|*
name|shellPath
init|=
name|NULL
decl_stmt|,
comment|/* full pathname of executable image */
modifier|*
name|shellName
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* last component of shell */
end_comment

begin_decl_stmt
name|int
name|maxJobs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The most children we can run at once */
end_comment

begin_decl_stmt
name|STATIC
name|int
name|nJobs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of children currently running */
end_comment

begin_comment
comment|/* The structures that describe them */
end_comment

begin_decl_stmt
name|STATIC
name|Lst
name|jobs
init|=
name|Lst_Initializer
argument_list|(
name|jobs
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|Boolean
name|jobFull
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flag to tell when the job table is full. It 				 * is set TRUE when (1) the total number of 				 * running jobs equals the maximum allowed */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USE_KQUEUE
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|kqfd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* File descriptor obtained by kqueue() */
end_comment

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|fd_set
name|outputs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set of descriptors of pipes connected to 				 * the output channels of children */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|STATIC
name|GNode
modifier|*
name|lastNode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The node for which output was most recently 				 * produced. */
end_comment

begin_decl_stmt
name|STATIC
specifier|const
name|char
modifier|*
name|targFmt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Format string to use to head output from a 				 * job when it's not the most-recent job heard 				 * from */
end_comment

begin_define
define|#
directive|define
name|TARG_FMT
value|"--- %s ---\n"
end_define

begin_comment
comment|/* Default format */
end_comment

begin_define
define|#
directive|define
name|MESSAGE
parameter_list|(
name|fp
parameter_list|,
name|gn
parameter_list|)
define|\
value|fprintf(fp, targFmt, gn->name);
end_define

begin_comment
comment|/*  * When JobStart attempts to run a job but isn't allowed to  * or when Job_CatchChildren detects a job that has  * been stopped somehow, the job is placed on the stoppedJobs queue to be run  * when the next job finishes.  *  * Lst of Job structures describing jobs that were stopped due to  * concurrency limits or externally  */
end_comment

begin_decl_stmt
name|STATIC
name|Lst
name|stoppedJobs
init|=
name|Lst_Initializer
argument_list|(
name|stoppedJobs
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|int
name|fifoFd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Fd of our job fifo */
end_comment

begin_decl_stmt
name|STATIC
name|char
name|fifoName
index|[]
init|=
literal|"/tmp/make_fifo_XXXXXXXXX"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|int
name|fifoMaster
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|sig_atomic_t
name|interrupted
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|USE_PGRP
argument_list|)
operator|&&
name|defined
argument_list|(
name|SYSV
argument_list|)
end_if

begin_define
define|#
directive|define
name|KILL
parameter_list|(
name|pid
parameter_list|,
name|sig
parameter_list|)
value|killpg(-(pid), (sig))
end_define

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|defined
argument_list|(
name|USE_PGRP
argument_list|)
end_if

begin_define
define|#
directive|define
name|KILL
parameter_list|(
name|pid
parameter_list|,
name|sig
parameter_list|)
value|killpg((pid), (sig))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|KILL
parameter_list|(
name|pid
parameter_list|,
name|sig
parameter_list|)
value|kill((pid), (sig))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Grmpf... There is no way to set bits of the wait structure  * anymore with the stupid W*() macros. I liked the union wait  * stuff much more. So, we devise our own macros... This is  * really ugly, use dramamine sparingly. You have been warned.  */
end_comment

begin_define
define|#
directive|define
name|W_SETMASKED
parameter_list|(
name|st
parameter_list|,
name|val
parameter_list|,
name|fun
parameter_list|)
define|\
value|{							\ 		int sh = (int)~0;				\ 		int mask = fun(sh);				\ 								\ 		for (sh = 0; ((mask>> sh)& 1) == 0; sh++)	\ 			continue;				\ 		*(st) = (*(st)& ~mask) | ((val)<< sh);	\ 	}
end_define

begin_define
define|#
directive|define
name|W_SETTERMSIG
parameter_list|(
name|st
parameter_list|,
name|val
parameter_list|)
value|W_SETMASKED(st, val, WTERMSIG)
end_define

begin_define
define|#
directive|define
name|W_SETEXITSTATUS
parameter_list|(
name|st
parameter_list|,
name|val
parameter_list|)
value|W_SETMASKED(st, val, WEXITSTATUS)
end_define

begin_function_decl
specifier|static
name|void
name|JobPassSig
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|JobPrintCommand
parameter_list|(
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|JobClose
parameter_list|(
name|Job
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|JobFinish
parameter_list|(
name|Job
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|JobExec
parameter_list|(
name|Job
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|JobMakeArgv
parameter_list|(
name|Job
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|JobRestart
parameter_list|(
name|Job
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|JobStart
parameter_list|(
name|GNode
modifier|*
parameter_list|,
name|int
parameter_list|,
name|Job
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|JobOutput
parameter_list|(
name|Job
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|JobDoOutput
parameter_list|(
name|Job
modifier|*
parameter_list|,
name|Boolean
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|Shell
modifier|*
name|JobMatchShell
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|JobInterrupt
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|JobRestartJobs
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * JobCatchSignal  *  * Got a signal. Set global variables and hope that someone will  * handle it.  */
end_comment

begin_function
specifier|static
name|void
name|JobCatchSig
parameter_list|(
name|int
name|signo
parameter_list|)
block|{
name|interrupted
operator|=
name|signo
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * JobCondPassSig --  *	Pass a signal to all jobs  *  * Side Effects:  *	None, except the job may bite it.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|JobCondPassSig
parameter_list|(
name|int
name|signo
parameter_list|)
block|{
name|LstNode
modifier|*
name|ln
decl_stmt|;
name|Job
modifier|*
name|job
decl_stmt|;
name|LST_FOREACH
argument_list|(
argument|ln
argument_list|,
argument|&jobs
argument_list|)
block|{
name|job
operator|=
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
expr_stmt|;
name|DEBUGF
argument_list|(
name|JOB
argument_list|,
operator|(
literal|"JobCondPassSig passing signal %d to child %d.\n"
operator|,
name|signo
operator|,
name|job
operator|->
name|pid
operator|)
argument_list|)
expr_stmt|;
name|KILL
argument_list|(
name|job
operator|->
name|pid
argument_list|,
name|signo
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * JobPassSig --  *	Pass a signal on to all local jobs if  *	USE_PGRP is defined, then die ourselves.  *  * Results:  *	None.  *  * Side Effects:  *	We die by the same signal.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|JobPassSig
parameter_list|(
name|int
name|signo
parameter_list|)
block|{
name|sigset_t
name|nmask
decl_stmt|,
name|omask
decl_stmt|;
name|struct
name|sigaction
name|act
decl_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|nmask
argument_list|)
expr_stmt|;
name|sigaddset
argument_list|(
operator|&
name|nmask
argument_list|,
name|signo
argument_list|)
expr_stmt|;
name|sigprocmask
argument_list|(
name|SIG_SETMASK
argument_list|,
operator|&
name|nmask
argument_list|,
operator|&
name|omask
argument_list|)
expr_stmt|;
name|DEBUGF
argument_list|(
name|JOB
argument_list|,
operator|(
literal|"JobPassSig(%d) called.\n"
operator|,
name|signo
operator|)
argument_list|)
expr_stmt|;
name|JobCondPassSig
argument_list|(
name|signo
argument_list|)
expr_stmt|;
comment|/*      * Deal with proper cleanup based on the signal received. We only run      * the .INTERRUPT target if the signal was in fact an interrupt. The other      * three termination signals are more of a "get out *now*" command.      */
if|if
condition|(
name|signo
operator|==
name|SIGINT
condition|)
block|{
name|JobInterrupt
argument_list|(
name|TRUE
argument_list|,
name|signo
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|signo
operator|==
name|SIGHUP
operator|)
operator|||
operator|(
name|signo
operator|==
name|SIGTERM
operator|)
operator|||
operator|(
name|signo
operator|==
name|SIGQUIT
operator|)
condition|)
block|{
name|JobInterrupt
argument_list|(
name|FALSE
argument_list|,
name|signo
argument_list|)
expr_stmt|;
block|}
comment|/*      * Leave gracefully if SIGQUIT, rather than core dumping.      */
if|if
condition|(
name|signo
operator|==
name|SIGQUIT
condition|)
block|{
name|signo
operator|=
name|SIGINT
expr_stmt|;
block|}
comment|/*      * Send ourselves the signal now we've given the message to everyone else.      * Note we block everything else possible while we're getting the signal.      * This ensures that all our jobs get continued when we wake up before      * we take any other signal.      * XXX this comment seems wrong.      */
name|act
operator|.
name|sa_handler
operator|=
name|SIG_DFL
expr_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|act
operator|.
name|sa_mask
argument_list|)
expr_stmt|;
name|act
operator|.
name|sa_flags
operator|=
literal|0
expr_stmt|;
name|sigaction
argument_list|(
name|signo
argument_list|,
operator|&
name|act
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|DEBUGF
argument_list|(
name|JOB
argument_list|,
operator|(
literal|"JobPassSig passing signal to self, mask = %x.\n"
operator|,
operator|~
literal|0
operator|&
operator|~
operator|(
literal|1
operator|<<
operator|(
name|signo
operator|-
literal|1
operator|)
operator|)
operator|)
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|signo
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|KILL
argument_list|(
name|getpid
argument_list|()
argument_list|,
name|signo
argument_list|)
expr_stmt|;
name|signo
operator|=
name|SIGCONT
expr_stmt|;
name|JobCondPassSig
argument_list|(
name|signo
argument_list|)
expr_stmt|;
name|sigprocmask
argument_list|(
name|SIG_SETMASK
argument_list|,
operator|&
name|omask
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|sigprocmask
argument_list|(
name|SIG_SETMASK
argument_list|,
operator|&
name|omask
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|act
operator|.
name|sa_handler
operator|=
name|JobPassSig
expr_stmt|;
name|sigaction
argument_list|(
name|signo
argument_list|,
operator|&
name|act
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * JobPrintCommand  --  *	Put out another command for the given job. If the command starts  *	with an @ or a - we process it specially. In the former case,  *	so long as the -s and -n flags weren't given to make, we stick  *	a shell-specific echoOff command in the script. In the latter,  *	we ignore errors for the entire job, unless the shell has error  *	control.  *	If the command is just "..." we take all future commands for this  *	job to be commands to be executed once the entire graph has been  *	made and return non-zero to signal that the end of the commands  *	was reached. These commands are later attached to the postCommands  *	node and executed by Job_Finish when all things are done.  *	This function is called from JobStart via LST_FOREACH.  *  * Results:  *	Always 0, unless the command was "..."  *  * Side Effects:  *	If the command begins with a '-' and the shell has no error control,  *	the JOB_IGNERR flag is set in the job descriptor.  *	If the command is "..." and we're not ignoring such things,  *	tailCmds is set to the successor node of the cmd.  *	numCommands is incremented if the command is actually printed.  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|JobPrintCommand
parameter_list|(
name|void
modifier|*
name|cmdp
parameter_list|,
name|void
modifier|*
name|jobp
parameter_list|)
block|{
name|Boolean
name|noSpecials
decl_stmt|;
comment|/* true if we shouldn't worry about 				 * inserting special commands into 				 * the input stream. */
name|Boolean
name|shutUp
init|=
name|FALSE
decl_stmt|;
comment|/* true if we put a no echo command 				 * into the command file */
name|Boolean
name|errOff
init|=
name|FALSE
decl_stmt|;
comment|/* true if we turned error checking 				 * off before printing the command 				 * and need to turn it back on */
specifier|const
name|char
modifier|*
name|cmdTemplate
decl_stmt|;
comment|/* Template to use when printing the 				 * command */
name|char
modifier|*
name|cmdStart
decl_stmt|;
comment|/* Start of expanded command */
name|LstNode
modifier|*
name|cmdNode
decl_stmt|;
comment|/* Node for replacing the command */
name|char
modifier|*
name|cmd
init|=
name|cmdp
decl_stmt|;
name|Job
modifier|*
name|job
init|=
name|jobp
decl_stmt|;
name|Buffer
modifier|*
name|buf
decl_stmt|;
name|noSpecials
operator|=
operator|(
name|noExecute
operator|&&
operator|!
operator|(
name|job
operator|->
name|node
operator|->
name|type
operator|&
name|OP_MAKE
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|cmd
argument_list|,
literal|"..."
argument_list|)
operator|==
literal|0
condition|)
block|{
name|job
operator|->
name|node
operator|->
name|type
operator||=
name|OP_SAVE_CMDS
expr_stmt|;
if|if
condition|(
operator|(
name|job
operator|->
name|flags
operator|&
name|JOB_IGNDOTS
operator|)
operator|==
literal|0
condition|)
block|{
name|job
operator|->
name|tailCmds
operator|=
name|Lst_Succ
argument_list|(
name|Lst_Member
argument_list|(
operator|&
name|job
operator|->
name|node
operator|->
name|commands
argument_list|,
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
define|#
directive|define
name|DBPRINTF
parameter_list|(
name|fmt
parameter_list|,
name|arg
parameter_list|)
define|\
value|DEBUGF(JOB, (fmt, arg));			\     fprintf(job->cmdFILE, fmt, arg);	\     fflush(job->cmdFILE);
name|numCommands
operator|+=
literal|1
expr_stmt|;
comment|/*      * For debugging, we replace each command with the result of expanding      * the variables in the command.      */
name|cmdNode
operator|=
name|Lst_Member
argument_list|(
operator|&
name|job
operator|->
name|node
operator|->
name|commands
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|buf
operator|=
name|Var_Subst
argument_list|(
name|NULL
argument_list|,
name|cmd
argument_list|,
name|job
operator|->
name|node
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|cmd
operator|=
name|Buf_GetAll
argument_list|(
name|buf
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|Buf_Destroy
argument_list|(
name|buf
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|cmdStart
operator|=
name|cmd
expr_stmt|;
name|Lst_Replace
argument_list|(
name|cmdNode
argument_list|,
name|cmdStart
argument_list|)
expr_stmt|;
name|cmdTemplate
operator|=
literal|"%s\n"
expr_stmt|;
comment|/*      * Check for leading @', -' or +'s to control echoing, error checking,      * and execution on -n.      */
while|while
condition|(
operator|*
name|cmd
operator|==
literal|'@'
operator|||
operator|*
name|cmd
operator|==
literal|'-'
operator|||
operator|*
name|cmd
operator|==
literal|'+'
condition|)
block|{
switch|switch
condition|(
operator|*
name|cmd
condition|)
block|{
case|case
literal|'@'
case|:
name|shutUp
operator|=
name|DEBUG
argument_list|(
name|LOUD
argument_list|)
condition|?
name|FALSE
else|:
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
name|errOff
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'+'
case|:
if|if
condition|(
name|noSpecials
condition|)
block|{
comment|/* 		 * We're not actually exececuting anything... 		 * but this one needs to be - use compat mode just for it. 		 */
name|Compat_RunCommand
argument_list|(
name|cmdp
argument_list|,
name|job
operator|->
name|node
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
break|break;
block|}
name|cmd
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cmd
argument_list|)
condition|)
name|cmd
operator|++
expr_stmt|;
if|if
condition|(
name|shutUp
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|job
operator|->
name|flags
operator|&
name|JOB_SILENT
operator|)
operator|&&
operator|!
name|noSpecials
operator|&&
name|commandShell
operator|->
name|hasEchoCtl
condition|)
block|{
name|DBPRINTF
argument_list|(
literal|"%s\n"
argument_list|,
name|commandShell
operator|->
name|echoOff
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|shutUp
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|errOff
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|job
operator|->
name|flags
operator|&
name|JOB_IGNERR
operator|)
operator|&&
operator|!
name|noSpecials
condition|)
block|{
if|if
condition|(
name|commandShell
operator|->
name|hasErrCtl
condition|)
block|{
comment|/* 		 * we don't want the error-control commands showing 		 * up either, so we turn off echoing while executing 		 * them. We could put another field in the shell 		 * structure to tell JobDoOutput to look for this 		 * string too, but why make it any more complex than 		 * it already is? 		 */
if|if
condition|(
operator|!
operator|(
name|job
operator|->
name|flags
operator|&
name|JOB_SILENT
operator|)
operator|&&
operator|!
name|shutUp
operator|&&
name|commandShell
operator|->
name|hasEchoCtl
condition|)
block|{
name|DBPRINTF
argument_list|(
literal|"%s\n"
argument_list|,
name|commandShell
operator|->
name|echoOff
argument_list|)
expr_stmt|;
name|DBPRINTF
argument_list|(
literal|"%s\n"
argument_list|,
name|commandShell
operator|->
name|ignErr
argument_list|)
expr_stmt|;
name|DBPRINTF
argument_list|(
literal|"%s\n"
argument_list|,
name|commandShell
operator|->
name|echoOn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DBPRINTF
argument_list|(
literal|"%s\n"
argument_list|,
name|commandShell
operator|->
name|ignErr
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|commandShell
operator|->
name|ignErr
operator|&&
operator|(
operator|*
name|commandShell
operator|->
name|ignErr
operator|!=
literal|'\0'
operator|)
condition|)
block|{
comment|/* 		 * The shell has no error control, so we need to be 		 * weird to get it to ignore any errors from the command. 		 * If echoing is turned on, we turn it off and use the 		 * errCheck template to echo the command. Leave echoing 		 * off so the user doesn't see the weirdness we go through 		 * to ignore errors. Set cmdTemplate to use the weirdness 		 * instead of the simple "%s\n" template. 		 */
if|if
condition|(
operator|!
operator|(
name|job
operator|->
name|flags
operator|&
name|JOB_SILENT
operator|)
operator|&&
operator|!
name|shutUp
operator|&&
name|commandShell
operator|->
name|hasEchoCtl
condition|)
block|{
name|DBPRINTF
argument_list|(
literal|"%s\n"
argument_list|,
name|commandShell
operator|->
name|echoOff
argument_list|)
expr_stmt|;
name|DBPRINTF
argument_list|(
name|commandShell
operator|->
name|errCheck
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|shutUp
operator|=
name|TRUE
expr_stmt|;
block|}
name|cmdTemplate
operator|=
name|commandShell
operator|->
name|ignErr
expr_stmt|;
comment|/* 		 * The error ignoration (hee hee) is already taken care 		 * of by the ignErr template, so pretend error checking 		 * is still on. 		 */
name|errOff
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
name|errOff
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
else|else
block|{
name|errOff
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
name|DBPRINTF
argument_list|(
name|cmdTemplate
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|errOff
condition|)
block|{
comment|/* 	 * If echoing is already off, there's no point in issuing the 	 * echoOff command. Otherwise we issue it and pretend it was on 	 * for the whole command... 	 */
if|if
condition|(
operator|!
name|shutUp
operator|&&
operator|!
operator|(
name|job
operator|->
name|flags
operator|&
name|JOB_SILENT
operator|)
operator|&&
name|commandShell
operator|->
name|hasEchoCtl
condition|)
block|{
name|DBPRINTF
argument_list|(
literal|"%s\n"
argument_list|,
name|commandShell
operator|->
name|echoOff
argument_list|)
expr_stmt|;
name|shutUp
operator|=
name|TRUE
expr_stmt|;
block|}
name|DBPRINTF
argument_list|(
literal|"%s\n"
argument_list|,
name|commandShell
operator|->
name|errCheck
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|shutUp
condition|)
block|{
name|DBPRINTF
argument_list|(
literal|"%s\n"
argument_list|,
name|commandShell
operator|->
name|echoOn
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * JobClose --  *	Called to close both input and output pipes when a job is finished.  *  * Results:  *	Nada  *  * Side Effects:  *	The file descriptors associated with the job are closed.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|JobClose
parameter_list|(
name|Job
modifier|*
name|job
parameter_list|)
block|{
if|if
condition|(
name|usePipes
condition|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|USE_KQUEUE
argument_list|)
name|FD_CLR
argument_list|(
name|job
operator|->
name|inPipe
argument_list|,
operator|&
name|outputs
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|job
operator|->
name|outPipe
operator|!=
name|job
operator|->
name|inPipe
condition|)
block|{
name|close
argument_list|(
name|job
operator|->
name|outPipe
argument_list|)
expr_stmt|;
block|}
name|JobDoOutput
argument_list|(
name|job
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|job
operator|->
name|inPipe
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|close
argument_list|(
name|job
operator|->
name|outFd
argument_list|)
expr_stmt|;
name|JobDoOutput
argument_list|(
name|job
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * JobFinish  --  *	Do final processing for the given job including updating  *	parents and starting new jobs as available/necessary. Note  *	that we pay no attention to the JOB_IGNERR flag here.  *	This is because when we're called because of a noexecute flag  *	or something, jstat.w_status is 0 and when called from  *	Job_CatchChildren, the status is zeroed if it s/b ignored.  *  * Results:  *	None  *  * Side Effects:  *	Some nodes may be put on the toBeMade queue.  *	Final commands for the job are placed on postCommands.  *  *	If we got an error and are aborting (aborting == ABORT_ERROR) and  *	the job list is now empty, we are done for the day.  *	If we recognized an error (errors !=0), we set the aborting flag  *	to ABORT_ERROR so no more jobs will be started.  *-----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|JobFinish
parameter_list|(
name|Job
modifier|*
name|job
parameter_list|,
name|int
modifier|*
name|status
parameter_list|)
block|{
name|Boolean
name|done
decl_stmt|;
name|LstNode
modifier|*
name|ln
decl_stmt|;
if|if
condition|(
operator|(
name|WIFEXITED
argument_list|(
operator|*
name|status
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|WEXITSTATUS
argument_list|(
operator|*
name|status
argument_list|)
operator|!=
literal|0
operator|)
operator|&&
operator|!
operator|(
name|job
operator|->
name|flags
operator|&
name|JOB_IGNERR
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|WIFSIGNALED
argument_list|(
operator|*
name|status
argument_list|)
operator|&&
operator|(
name|WTERMSIG
argument_list|(
operator|*
name|status
argument_list|)
operator|!=
name|SIGCONT
operator|)
operator|)
condition|)
block|{
comment|/* 	 * If it exited non-zero and either we're doing things our 	 * way or we're not ignoring errors, the job is finished. 	 * Similarly, if the shell died because of a signal 	 * the job is also finished. In these 	 * cases, finish out the job's output before printing the exit 	 * status... 	 */
name|JobClose
argument_list|(
name|job
argument_list|)
expr_stmt|;
if|if
condition|(
name|job
operator|->
name|cmdFILE
operator|!=
name|NULL
operator|&&
name|job
operator|->
name|cmdFILE
operator|!=
name|stdout
condition|)
block|{
name|fclose
argument_list|(
name|job
operator|->
name|cmdFILE
argument_list|)
expr_stmt|;
block|}
name|done
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|WIFEXITED
argument_list|(
operator|*
name|status
argument_list|)
condition|)
block|{
comment|/* 	 * Deal with ignored errors in -B mode. We need to print a message 	 * telling of the ignored error as well as setting status.w_status 	 * to 0 so the next command gets run. To do this, we set done to be 	 * TRUE if in -B mode and the job exited non-zero. 	 */
name|done
operator|=
name|WEXITSTATUS
argument_list|(
operator|*
name|status
argument_list|)
operator|!=
literal|0
expr_stmt|;
comment|/* 	 * Old comment said: "Note we don't 	 * want to close down any of the streams until we know we're at the 	 * end." 	 * But we do. Otherwise when are we going to print the rest of the 	 * stuff? 	 */
name|JobClose
argument_list|(
name|job
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 	 * No need to close things down or anything. 	 */
name|done
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|done
operator|||
name|WIFSTOPPED
argument_list|(
operator|*
name|status
argument_list|)
operator|||
operator|(
name|WIFSIGNALED
argument_list|(
operator|*
name|status
argument_list|)
operator|&&
operator|(
name|WTERMSIG
argument_list|(
operator|*
name|status
argument_list|)
operator|==
name|SIGCONT
operator|)
operator|)
operator|||
name|DEBUG
argument_list|(
name|JOB
argument_list|)
condition|)
block|{
name|FILE
modifier|*
name|out
decl_stmt|;
if|if
condition|(
name|compatMake
operator|&&
operator|!
name|usePipes
operator|&&
operator|(
name|job
operator|->
name|flags
operator|&
name|JOB_IGNERR
operator|)
condition|)
block|{
comment|/* 	     * If output is going to a file and this job is ignoring 	     * errors, arrange to have the exit status sent to the 	     * output file as well. 	     */
name|out
operator|=
name|fdopen
argument_list|(
name|job
operator|->
name|outFd
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|out
operator|==
name|NULL
condition|)
name|Punt
argument_list|(
literal|"Cannot fdopen"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|out
operator|=
name|stdout
expr_stmt|;
block|}
if|if
condition|(
name|WIFEXITED
argument_list|(
operator|*
name|status
argument_list|)
condition|)
block|{
name|DEBUGF
argument_list|(
name|JOB
argument_list|,
operator|(
literal|"Process %d exited.\n"
operator|,
name|job
operator|->
name|pid
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|WEXITSTATUS
argument_list|(
operator|*
name|status
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|usePipes
operator|&&
name|job
operator|->
name|node
operator|!=
name|lastNode
condition|)
block|{
name|MESSAGE
argument_list|(
name|out
argument_list|,
name|job
operator|->
name|node
argument_list|)
expr_stmt|;
name|lastNode
operator|=
name|job
operator|->
name|node
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"*** Error code %d%s\n"
argument_list|,
name|WEXITSTATUS
argument_list|(
operator|*
name|status
argument_list|)
argument_list|,
operator|(
name|job
operator|->
name|flags
operator|&
name|JOB_IGNERR
operator|)
condition|?
literal|"(ignored)"
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|job
operator|->
name|flags
operator|&
name|JOB_IGNERR
condition|)
block|{
operator|*
name|status
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|DEBUG
argument_list|(
name|JOB
argument_list|)
condition|)
block|{
if|if
condition|(
name|usePipes
operator|&&
name|job
operator|->
name|node
operator|!=
name|lastNode
condition|)
block|{
name|MESSAGE
argument_list|(
name|out
argument_list|,
name|job
operator|->
name|node
argument_list|)
expr_stmt|;
name|lastNode
operator|=
name|job
operator|->
name|node
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"*** Completed successfully\n"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|WIFSTOPPED
argument_list|(
operator|*
name|status
argument_list|)
condition|)
block|{
name|DEBUGF
argument_list|(
name|JOB
argument_list|,
operator|(
literal|"Process %d stopped.\n"
operator|,
name|job
operator|->
name|pid
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|usePipes
operator|&&
name|job
operator|->
name|node
operator|!=
name|lastNode
condition|)
block|{
name|MESSAGE
argument_list|(
name|out
argument_list|,
name|job
operator|->
name|node
argument_list|)
expr_stmt|;
name|lastNode
operator|=
name|job
operator|->
name|node
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"*** Stopped -- signal %d\n"
argument_list|,
name|WSTOPSIG
argument_list|(
operator|*
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|job
operator|->
name|flags
operator||=
name|JOB_RESUME
expr_stmt|;
name|Lst_AtEnd
argument_list|(
operator|&
name|stoppedJobs
argument_list|,
name|job
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|out
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|WTERMSIG
argument_list|(
operator|*
name|status
argument_list|)
operator|==
name|SIGCONT
condition|)
block|{
comment|/* 	     * If the beastie has continued, shift the Job from the stopped 	     * list to the running one (or re-stop it if concurrency is 	     * exceeded) and go and get another child. 	     */
if|if
condition|(
name|job
operator|->
name|flags
operator|&
operator|(
name|JOB_RESUME
operator||
name|JOB_RESTART
operator|)
condition|)
block|{
if|if
condition|(
name|usePipes
operator|&&
name|job
operator|->
name|node
operator|!=
name|lastNode
condition|)
block|{
name|MESSAGE
argument_list|(
name|out
argument_list|,
name|job
operator|->
name|node
argument_list|)
expr_stmt|;
name|lastNode
operator|=
name|job
operator|->
name|node
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"*** Continued\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|job
operator|->
name|flags
operator|&
name|JOB_CONTINUING
operator|)
condition|)
block|{
name|DEBUGF
argument_list|(
name|JOB
argument_list|,
operator|(
literal|"Warning: process %d was not continuing.\n"
operator|,
name|job
operator|->
name|pid
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|notdef
comment|/* 		 * We don't really want to restart a job from scratch just 		 * because it continued, especially not without killing the 		 * continuing process!  That's why this is ifdef'ed out. 		 * FD - 9/17/90 		 */
name|JobRestart
argument_list|(
name|job
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|job
operator|->
name|flags
operator|&=
operator|~
name|JOB_CONTINUING
expr_stmt|;
name|Lst_AtEnd
argument_list|(
operator|&
name|jobs
argument_list|,
name|job
argument_list|)
expr_stmt|;
name|nJobs
operator|+=
literal|1
expr_stmt|;
name|DEBUGF
argument_list|(
name|JOB
argument_list|,
operator|(
literal|"Process %d is continuing locally.\n"
operator|,
name|job
operator|->
name|pid
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nJobs
operator|==
name|maxJobs
condition|)
block|{
name|jobFull
operator|=
name|TRUE
expr_stmt|;
name|DEBUGF
argument_list|(
name|JOB
argument_list|,
operator|(
literal|"Job queue is full.\n"
operator|)
argument_list|)
expr_stmt|;
block|}
name|fflush
argument_list|(
name|out
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
if|if
condition|(
name|usePipes
operator|&&
name|job
operator|->
name|node
operator|!=
name|lastNode
condition|)
block|{
name|MESSAGE
argument_list|(
name|out
argument_list|,
name|job
operator|->
name|node
argument_list|)
expr_stmt|;
name|lastNode
operator|=
name|job
operator|->
name|node
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"*** Signal %d\n"
argument_list|,
name|WTERMSIG
argument_list|(
operator|*
name|status
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fflush
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
comment|/*      * Now handle the -B-mode stuff. If the beast still isn't finished,      * try and restart the job on the next command. If JobStart says it's      * ok, it's ok. If there's an error, this puppy is done.      */
if|if
condition|(
name|compatMake
operator|&&
name|WIFEXITED
argument_list|(
operator|*
name|status
argument_list|)
operator|&&
name|Lst_Succ
argument_list|(
name|job
operator|->
name|node
operator|->
name|compat_command
argument_list|)
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
name|JobStart
argument_list|(
name|job
operator|->
name|node
argument_list|,
name|job
operator|->
name|flags
operator|&
name|JOB_IGNDOTS
argument_list|,
name|job
argument_list|)
condition|)
block|{
case|case
name|JOB_RUNNING
case|:
name|done
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|JOB_ERROR
case|:
name|done
operator|=
name|TRUE
expr_stmt|;
name|W_SETEXITSTATUS
argument_list|(
name|status
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|JOB_FINISHED
case|:
comment|/* 	     * If we got back a JOB_FINISHED code, JobStart has already 	     * called Make_Update and freed the job descriptor. We set 	     * done to false here to avoid fake cycles and double frees. 	     * JobStart needs to do the update so we can proceed up the 	     * graph when given the -n flag.. 	     */
name|done
operator|=
name|FALSE
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
else|else
block|{
name|done
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|done
operator|&&
operator|(
name|aborting
operator|!=
name|ABORT_ERROR
operator|)
operator|&&
operator|(
name|aborting
operator|!=
name|ABORT_INTERRUPT
operator|)
operator|&&
operator|(
operator|*
name|status
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* 	 * As long as we aren't aborting and the job didn't return a non-zero 	 * status that we shouldn't ignore, we call Make_Update to update 	 * the parents. In addition, any saved commands for the node are placed 	 * on the .END target. 	 */
for|for
control|(
name|ln
operator|=
name|job
operator|->
name|tailCmds
init|;
name|ln
operator|!=
name|NULL
condition|;
name|ln
operator|=
name|LST_NEXT
argument_list|(
name|ln
argument_list|)
control|)
block|{
name|Lst_AtEnd
argument_list|(
operator|&
name|postCommands
operator|->
name|commands
argument_list|,
name|Buf_Peel
argument_list|(
name|Var_Subst
argument_list|(
name|NULL
argument_list|,
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
argument_list|,
name|job
operator|->
name|node
argument_list|,
name|FALSE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|job
operator|->
name|node
operator|->
name|made
operator|=
name|MADE
expr_stmt|;
name|Make_Update
argument_list|(
name|job
operator|->
name|node
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|job
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|status
operator|!=
literal|0
condition|)
block|{
name|errors
operator|+=
literal|1
expr_stmt|;
name|free
argument_list|(
name|job
argument_list|)
expr_stmt|;
block|}
name|JobRestartJobs
argument_list|()
expr_stmt|;
comment|/*      * Set aborting if any error.      */
if|if
condition|(
name|errors
operator|&&
operator|!
name|keepgoing
operator|&&
operator|(
name|aborting
operator|!=
name|ABORT_INTERRUPT
operator|)
condition|)
block|{
comment|/* 	 * If we found any errors in this batch of children and the -k flag 	 * wasn't given, we set the aborting flag so no more jobs get 	 * started. 	 */
name|aborting
operator|=
name|ABORT_ERROR
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|aborting
operator|==
name|ABORT_ERROR
operator|)
operator|&&
name|Job_Empty
argument_list|()
condition|)
comment|/* 	 * If we are aborting and the job table is now empty, we finish. 	 */
name|Finish
argument_list|(
name|errors
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Job_Touch --  *	Touch the given target. Called by JobStart when the -t flag was  *	given.  Prints messages unless told to be silent.  *  * Results:  *	None  *  * Side Effects:  *	The data modification of the file is changed. In addition, if the  *	file did not exist, it is created.  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Job_Touch
parameter_list|(
name|GNode
modifier|*
name|gn
parameter_list|,
name|Boolean
name|silent
parameter_list|)
block|{
name|int
name|streamID
decl_stmt|;
comment|/* ID of stream opened to do the touch */
name|struct
name|utimbuf
name|times
decl_stmt|;
comment|/* Times for utime() call */
if|if
condition|(
name|gn
operator|->
name|type
operator|&
operator|(
name|OP_JOIN
operator||
name|OP_USE
operator||
name|OP_EXEC
operator||
name|OP_OPTIONAL
operator|)
condition|)
block|{
comment|/* 	 * .JOIN, .USE, .ZEROTIME and .OPTIONAL targets are "virtual" targets 	 * and, as such, shouldn't really be created. 	 */
return|return;
block|}
if|if
condition|(
operator|!
name|silent
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"touch %s\n"
argument_list|,
name|gn
operator|->
name|name
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|noExecute
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|gn
operator|->
name|type
operator|&
name|OP_ARCHV
condition|)
block|{
name|Arch_Touch
argument_list|(
name|gn
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|gn
operator|->
name|type
operator|&
name|OP_LIB
condition|)
block|{
name|Arch_TouchLib
argument_list|(
name|gn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|file
init|=
name|gn
operator|->
name|path
condition|?
name|gn
operator|->
name|path
else|:
name|gn
operator|->
name|name
decl_stmt|;
name|times
operator|.
name|actime
operator|=
name|times
operator|.
name|modtime
operator|=
name|now
expr_stmt|;
if|if
condition|(
name|utime
argument_list|(
name|file
argument_list|,
operator|&
name|times
argument_list|)
operator|<
literal|0
condition|)
block|{
name|streamID
operator|=
name|open
argument_list|(
name|file
argument_list|,
name|O_RDWR
operator||
name|O_CREAT
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
if|if
condition|(
name|streamID
operator|>=
literal|0
condition|)
block|{
name|char
name|c
decl_stmt|;
comment|/* 		 * Read and write a byte to the file to change the 		 * modification time, then close the file. 		 */
if|if
condition|(
name|read
argument_list|(
name|streamID
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
operator|==
literal|1
condition|)
block|{
name|lseek
argument_list|(
name|streamID
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|streamID
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|streamID
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"*** couldn't touch %s: %s"
argument_list|,
name|file
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Job_CheckCommands --  *	Make sure the given node has all the commands it needs.  *  * Results:  *	TRUE if the commands list is/was ok.  *  * Side Effects:  *	The node will have commands from the .DEFAULT rule added to it  *	if it needs them.  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|Boolean
name|Job_CheckCommands
parameter_list|(
name|GNode
modifier|*
name|gn
parameter_list|,
name|void
function_decl|(
modifier|*
name|abortProc
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
modifier|...
parameter_list|)
parameter_list|)
block|{
if|if
condition|(
name|OP_NOP
argument_list|(
name|gn
operator|->
name|type
argument_list|)
operator|&&
name|Lst_IsEmpty
argument_list|(
operator|&
name|gn
operator|->
name|commands
argument_list|)
operator|&&
operator|(
name|gn
operator|->
name|type
operator|&
name|OP_LIB
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 	 * No commands. Look for .DEFAULT rule from which we might infer 	 * commands 	 */
if|if
condition|(
operator|(
name|DEFAULT
operator|!=
name|NULL
operator|)
operator|&&
operator|!
name|Lst_IsEmpty
argument_list|(
operator|&
name|DEFAULT
operator|->
name|commands
argument_list|)
condition|)
block|{
name|char
modifier|*
name|p1
decl_stmt|;
comment|/* 	     * Make only looks for a .DEFAULT if the node was never the 	     * target of an operator, so that's what we do too. If 	     * a .DEFAULT was given, we substitute its commands for gn's 	     * commands and set the IMPSRC variable to be the target's name 	     * The DEFAULT node acts like a transformation rule, in that 	     * gn also inherits any attributes or sources attached to 	     * .DEFAULT itself. 	     */
name|Make_HandleUse
argument_list|(
name|DEFAULT
argument_list|,
name|gn
argument_list|)
expr_stmt|;
name|Var_Set
argument_list|(
name|IMPSRC
argument_list|,
name|Var_Value
argument_list|(
name|TARGET
argument_list|,
name|gn
argument_list|,
operator|&
name|p1
argument_list|)
argument_list|,
name|gn
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Dir_MTime
argument_list|(
name|gn
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 	     * The node wasn't the target of an operator we have no .DEFAULT 	     * rule to go on and the target doesn't already exist. There's 	     * nothing more we can do for this branch. If the -k flag wasn't 	     * given, we stop in our tracks, otherwise we just don't update 	     * this node's parents so they never get examined. 	     */
specifier|static
specifier|const
name|char
name|msg
index|[]
init|=
literal|"make: don't know how to make"
decl_stmt|;
if|if
condition|(
name|gn
operator|->
name|type
operator|&
name|OP_OPTIONAL
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s %s(ignored)\n"
argument_list|,
name|msg
argument_list|,
name|gn
operator|->
name|name
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|keepgoing
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s %s(continuing)\n"
argument_list|,
name|msg
argument_list|,
name|gn
operator|->
name|name
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
else|else
block|{
if|#
directive|if
name|OLD_JOKE
if|if
condition|(
name|strcmp
argument_list|(
name|gn
operator|->
name|name
argument_list|,
literal|"love"
argument_list|)
operator|==
literal|0
condition|)
call|(
modifier|*
name|abortProc
call|)
argument_list|(
literal|"Not war."
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
call|(
modifier|*
name|abortProc
call|)
argument_list|(
literal|"%s %s. Stop"
argument_list|,
name|msg
argument_list|,
name|gn
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
block|}
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * JobExec --  *	Execute the shell for the given job. Called from JobStart and  *	JobRestart.  *  * Results:  *	None.  *  * Side Effects:  *	A shell is executed, outputs is altered and the Job structure added  *	to the job table.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|JobExec
parameter_list|(
name|Job
modifier|*
name|job
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|cpid
decl_stmt|;
comment|/* ID of new child */
if|if
condition|(
name|DEBUG
argument_list|(
name|JOB
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|;
name|DEBUGF
argument_list|(
name|JOB
argument_list|,
operator|(
literal|"Running %s\n"
operator|,
name|job
operator|->
name|node
operator|->
name|name
operator|)
argument_list|)
expr_stmt|;
name|DEBUGF
argument_list|(
name|JOB
argument_list|,
operator|(
literal|"\tCommand: "
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|argv
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
name|DEBUGF
argument_list|(
name|JOB
argument_list|,
operator|(
literal|"%s "
operator|,
name|argv
index|[
name|i
index|]
operator|)
argument_list|)
expr_stmt|;
block|}
name|DEBUGF
argument_list|(
name|JOB
argument_list|,
operator|(
literal|"\n"
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/*      * Some jobs produce no output and it's disconcerting to have      * no feedback of their running (since they produce no output, the      * banner with their name in it never appears). This is an attempt to      * provide that feedback, even if nothing follows it.      */
if|if
condition|(
operator|(
name|lastNode
operator|!=
name|job
operator|->
name|node
operator|)
operator|&&
operator|(
name|job
operator|->
name|flags
operator|&
name|JOB_FIRST
operator|)
operator|&&
operator|!
operator|(
name|job
operator|->
name|flags
operator|&
name|JOB_SILENT
operator|)
condition|)
block|{
name|MESSAGE
argument_list|(
name|stdout
argument_list|,
name|job
operator|->
name|node
argument_list|)
expr_stmt|;
name|lastNode
operator|=
name|job
operator|->
name|node
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|cpid
operator|=
name|vfork
argument_list|()
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|Punt
argument_list|(
literal|"Cannot fork"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cpid
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|fifoFd
operator|>=
literal|0
condition|)
name|close
argument_list|(
name|fifoFd
argument_list|)
expr_stmt|;
comment|/* 	 * Must duplicate the input stream down to the child's input and 	 * reset it to the beginning (again). Since the stream was marked 	 * close-on-exec, we must clear that bit in the new input. 	 */
if|if
condition|(
name|dup2
argument_list|(
name|FILENO
argument_list|(
name|job
operator|->
name|cmdFILE
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|Punt
argument_list|(
literal|"Cannot dup2: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|fcntl
argument_list|(
literal|0
argument_list|,
name|F_SETFD
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lseek
argument_list|(
literal|0
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|usePipes
condition|)
block|{
comment|/* 	     * Set up the child's output to be routed through the pipe 	     * we've created for it. 	     */
if|if
condition|(
name|dup2
argument_list|(
name|job
operator|->
name|outPipe
argument_list|,
literal|1
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|Punt
argument_list|(
literal|"Cannot dup2: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 	     * We're capturing output in a file, so we duplicate the 	     * descriptor to the temporary file into the standard 	     * output. 	     */
if|if
condition|(
name|dup2
argument_list|(
name|job
operator|->
name|outFd
argument_list|,
literal|1
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|Punt
argument_list|(
literal|"Cannot dup2: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * The output channels are marked close on exec. This bit was 	 * duplicated by the dup2 (on some systems), so we have to clear 	 * it before routing the shell's error output to the same place as 	 * its standard output. 	 */
name|fcntl
argument_list|(
literal|1
argument_list|,
name|F_SETFD
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|dup2
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|Punt
argument_list|(
literal|"Cannot dup2: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_PGRP
comment|/* 	 * We want to switch the child into a different process family so 	 * we can kill it and all its descendants in one fell swoop, 	 * by killing its process family, but not commit suicide. 	 */
if|#
directive|if
name|defined
argument_list|(
name|SYSV
argument_list|)
name|setsid
argument_list|()
expr_stmt|;
else|#
directive|else
name|setpgid
argument_list|(
literal|0
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* USE_PGRP */
name|execv
argument_list|(
name|shellPath
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|STDERR_FILENO
argument_list|,
literal|"Could not execute shell\n"
argument_list|,
sizeof|sizeof
argument_list|(
literal|"Could not execute shell"
argument_list|)
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|job
operator|->
name|pid
operator|=
name|cpid
expr_stmt|;
if|if
condition|(
name|usePipes
operator|&&
operator|(
name|job
operator|->
name|flags
operator|&
name|JOB_FIRST
operator|)
condition|)
block|{
comment|/* 	     * The first time a job is run for a node, we set the current 	     * position in the buffer to the beginning and mark another 	     * stream to watch in the outputs mask 	     */
ifdef|#
directive|ifdef
name|USE_KQUEUE
name|struct
name|kevent
name|kev
index|[
literal|2
index|]
decl_stmt|;
endif|#
directive|endif
name|job
operator|->
name|curPos
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|USE_KQUEUE
argument_list|)
name|EV_SET
argument_list|(
operator|&
name|kev
index|[
literal|0
index|]
argument_list|,
name|job
operator|->
name|inPipe
argument_list|,
name|EVFILT_READ
argument_list|,
name|EV_ADD
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|job
argument_list|)
expr_stmt|;
name|EV_SET
argument_list|(
operator|&
name|kev
index|[
literal|1
index|]
argument_list|,
name|job
operator|->
name|pid
argument_list|,
name|EVFILT_PROC
argument_list|,
name|EV_ADD
operator||
name|EV_ONESHOT
argument_list|,
name|NOTE_EXIT
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|kevent
argument_list|(
name|kqfd
argument_list|,
name|kev
argument_list|,
literal|2
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* kevent() will fail if the job is already finished */
if|if
condition|(
name|errno
operator|!=
name|EINTR
operator|&&
name|errno
operator|!=
name|EBADF
operator|&&
name|errno
operator|!=
name|ESRCH
condition|)
name|Punt
argument_list|(
literal|"kevent: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|FD_SET
argument_list|(
name|job
operator|->
name|inPipe
argument_list|,
operator|&
name|outputs
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USE_KQUEUE */
block|}
if|if
condition|(
name|job
operator|->
name|cmdFILE
operator|!=
name|NULL
operator|&&
name|job
operator|->
name|cmdFILE
operator|!=
name|stdout
condition|)
block|{
name|fclose
argument_list|(
name|job
operator|->
name|cmdFILE
argument_list|)
expr_stmt|;
name|job
operator|->
name|cmdFILE
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/*      * Now the job is actually running, add it to the table.      */
name|nJobs
operator|+=
literal|1
expr_stmt|;
name|Lst_AtEnd
argument_list|(
operator|&
name|jobs
argument_list|,
name|job
argument_list|)
expr_stmt|;
if|if
condition|(
name|nJobs
operator|==
name|maxJobs
condition|)
block|{
name|jobFull
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * JobMakeArgv --  *	Create the argv needed to execute the shell for a given job.  *  *  * Results:  *  * Side Effects:  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|JobMakeArgv
parameter_list|(
name|Job
modifier|*
name|job
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|argc
decl_stmt|;
specifier|static
name|char
name|args
index|[
literal|10
index|]
decl_stmt|;
comment|/* For merged arguments */
name|argv
index|[
literal|0
index|]
operator|=
name|shellName
expr_stmt|;
name|argc
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|commandShell
operator|->
name|exit
operator|&&
operator|(
operator|*
name|commandShell
operator|->
name|exit
operator|!=
literal|'-'
operator|)
operator|)
operator|||
operator|(
name|commandShell
operator|->
name|echo
operator|&&
operator|(
operator|*
name|commandShell
operator|->
name|echo
operator|!=
literal|'-'
operator|)
operator|)
condition|)
block|{
comment|/* 	 * At least one of the flags doesn't have a minus before it, so 	 * merge them together. Have to do this because the *(&(@*#*&#$# 	 * Bourne shell thinks its second argument is a file to source. 	 * Grrrr. Note the ten-character limitation on the combined arguments. 	 */
name|sprintf
argument_list|(
name|args
argument_list|,
literal|"-%s%s"
argument_list|,
operator|(
operator|(
name|job
operator|->
name|flags
operator|&
name|JOB_IGNERR
operator|)
condition|?
literal|""
else|:
operator|(
name|commandShell
operator|->
name|exit
condition|?
name|commandShell
operator|->
name|exit
else|:
literal|""
operator|)
operator|)
argument_list|,
operator|(
operator|(
name|job
operator|->
name|flags
operator|&
name|JOB_SILENT
operator|)
condition|?
literal|""
else|:
operator|(
name|commandShell
operator|->
name|echo
condition|?
name|commandShell
operator|->
name|echo
else|:
literal|""
operator|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
index|[
literal|1
index|]
condition|)
block|{
name|argv
index|[
name|argc
index|]
operator|=
name|args
expr_stmt|;
name|argc
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|job
operator|->
name|flags
operator|&
name|JOB_IGNERR
operator|)
operator|&&
name|commandShell
operator|->
name|exit
condition|)
block|{
name|argv
index|[
name|argc
index|]
operator|=
name|commandShell
operator|->
name|exit
expr_stmt|;
name|argc
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|job
operator|->
name|flags
operator|&
name|JOB_SILENT
operator|)
operator|&&
name|commandShell
operator|->
name|echo
condition|)
block|{
name|argv
index|[
name|argc
index|]
operator|=
name|commandShell
operator|->
name|echo
expr_stmt|;
name|argc
operator|++
expr_stmt|;
block|}
block|}
name|argv
index|[
name|argc
index|]
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * JobRestart --  *	Restart a job that stopped for some reason.  *  * Results:  *	None.  *  * Side Effects:  *	jobFull will be set if the job couldn't be run.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|JobRestart
parameter_list|(
name|Job
modifier|*
name|job
parameter_list|)
block|{
if|if
condition|(
name|job
operator|->
name|flags
operator|&
name|JOB_RESTART
condition|)
block|{
comment|/* 	 * Set up the control arguments to the shell. This is based on the 	 * flags set earlier for this job. If the JOB_IGNERR flag is clear, 	 * the 'exit' flag of the commandShell is used to cause it to exit 	 * upon receiving an error. If the JOB_SILENT flag is clear, the 	 * 'echo' flag of the commandShell is used to get it to start echoing 	 * as soon as it starts processing commands. 	 */
name|char
modifier|*
name|argv
index|[
literal|4
index|]
decl_stmt|;
name|JobMakeArgv
argument_list|(
name|job
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|DEBUGF
argument_list|(
name|JOB
argument_list|,
operator|(
literal|"Restarting %s..."
operator|,
name|job
operator|->
name|node
operator|->
name|name
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|nJobs
operator|>=
name|maxJobs
operator|)
operator|&&
operator|!
operator|(
name|job
operator|->
name|flags
operator|&
name|JOB_SPECIAL
operator|)
operator|)
condition|)
block|{
comment|/* 	     * Can't be exported and not allowed to run locally -- put it 	     * back on the hold queue and mark the table full 	     */
name|DEBUGF
argument_list|(
name|JOB
argument_list|,
operator|(
literal|"holding\n"
operator|)
argument_list|)
expr_stmt|;
name|Lst_AtFront
argument_list|(
operator|&
name|stoppedJobs
argument_list|,
operator|(
name|void
operator|*
operator|)
name|job
argument_list|)
expr_stmt|;
name|jobFull
operator|=
name|TRUE
expr_stmt|;
name|DEBUGF
argument_list|(
name|JOB
argument_list|,
operator|(
literal|"Job queue is full.\n"
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
comment|/* 	     * Job may be run locally. 	     */
name|DEBUGF
argument_list|(
name|JOB
argument_list|,
operator|(
literal|"running locally\n"
operator|)
argument_list|)
expr_stmt|;
block|}
name|JobExec
argument_list|(
name|job
argument_list|,
name|argv
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 	 * The job has stopped and needs to be restarted. Why it stopped, 	 * we don't know... 	 */
name|DEBUGF
argument_list|(
name|JOB
argument_list|,
operator|(
literal|"Resuming %s..."
operator|,
name|job
operator|->
name|node
operator|->
name|name
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|nJobs
operator|<
name|maxJobs
operator|)
operator|||
operator|(
operator|(
name|job
operator|->
name|flags
operator|&
name|JOB_SPECIAL
operator|)
operator|&&
operator|(
name|maxJobs
operator|==
literal|0
operator|)
operator|)
operator|)
operator|&&
operator|(
name|nJobs
operator|!=
name|maxJobs
operator|)
condition|)
block|{
comment|/* 	     * If we haven't reached the concurrency limit already (or the 	     * job must be run and maxJobs is 0), it's ok to resume it. 	     */
name|Boolean
name|error
decl_stmt|;
name|int
name|status
decl_stmt|;
name|error
operator|=
operator|(
name|KILL
argument_list|(
name|job
operator|->
name|pid
argument_list|,
name|SIGCONT
argument_list|)
operator|!=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
comment|/* 		 * Make sure the user knows we've continued the beast and 		 * actually put the thing in the job table. 		 */
name|job
operator|->
name|flags
operator||=
name|JOB_CONTINUING
expr_stmt|;
name|status
operator|=
literal|0
expr_stmt|;
name|W_SETTERMSIG
argument_list|(
operator|&
name|status
argument_list|,
name|SIGCONT
argument_list|)
expr_stmt|;
name|JobFinish
argument_list|(
name|job
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
name|job
operator|->
name|flags
operator|&=
operator|~
operator|(
name|JOB_RESUME
operator||
name|JOB_CONTINUING
operator|)
expr_stmt|;
name|DEBUGF
argument_list|(
name|JOB
argument_list|,
operator|(
literal|"done\n"
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Error
argument_list|(
literal|"couldn't resume %s: %s"
argument_list|,
name|job
operator|->
name|node
operator|->
name|name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
literal|0
expr_stmt|;
name|W_SETEXITSTATUS
argument_list|(
operator|&
name|status
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|JobFinish
argument_list|(
name|job
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 	     * Job cannot be restarted. Mark the table as full and 	     * place the job back on the list of stopped jobs. 	     */
name|DEBUGF
argument_list|(
name|JOB
argument_list|,
operator|(
literal|"table full\n"
operator|)
argument_list|)
expr_stmt|;
name|Lst_AtFront
argument_list|(
operator|&
name|stoppedJobs
argument_list|,
operator|(
name|void
operator|*
operator|)
name|job
argument_list|)
expr_stmt|;
name|jobFull
operator|=
name|TRUE
expr_stmt|;
name|DEBUGF
argument_list|(
name|JOB
argument_list|,
operator|(
literal|"Job queue is full.\n"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * JobStart  --  *	Start a target-creation process going for the target described  *	by the graph node gn.  *  * Results:  *	JOB_ERROR if there was an error in the commands, JOB_FINISHED  *	if there isn't actually anything left to do for the job and  *	JOB_RUNNING if the job has been started.  *  * Side Effects:  *	A new Job node is created and added to the list of running  *	jobs. PMake is forked and a child shell created.  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|JobStart
parameter_list|(
name|GNode
modifier|*
name|gn
parameter_list|,
name|int
name|flags
parameter_list|,
name|Job
modifier|*
name|previous
parameter_list|)
block|{
name|Job
modifier|*
name|job
decl_stmt|;
comment|/* new job descriptor */
name|char
modifier|*
name|argv
index|[
literal|4
index|]
decl_stmt|;
comment|/* Argument vector to shell */
name|Boolean
name|cmdsOK
decl_stmt|;
comment|/* true if the nodes commands were all right */
name|Boolean
name|noExec
decl_stmt|;
comment|/* Set true if we decide not to run the job */
name|int
name|tfd
decl_stmt|;
comment|/* File descriptor for temp file */
name|LstNode
modifier|*
name|ln
decl_stmt|;
if|if
condition|(
name|interrupted
condition|)
block|{
name|JobPassSig
argument_list|(
name|interrupted
argument_list|)
expr_stmt|;
return|return
operator|(
name|JOB_ERROR
operator|)
return|;
block|}
if|if
condition|(
name|previous
operator|!=
name|NULL
condition|)
block|{
name|previous
operator|->
name|flags
operator|&=
operator|~
operator|(
name|JOB_FIRST
operator||
name|JOB_IGNERR
operator||
name|JOB_SILENT
operator|)
expr_stmt|;
name|job
operator|=
name|previous
expr_stmt|;
block|}
else|else
block|{
name|job
operator|=
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Job
argument_list|)
argument_list|)
expr_stmt|;
name|flags
operator||=
name|JOB_FIRST
expr_stmt|;
block|}
name|job
operator|->
name|node
operator|=
name|gn
expr_stmt|;
name|job
operator|->
name|tailCmds
operator|=
name|NULL
expr_stmt|;
comment|/*      * Set the initial value of the flags for this job based on the global      * ones and the node's attributes... Any flags supplied by the caller      * are also added to the field.      */
name|job
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|Targ_Ignore
argument_list|(
name|gn
argument_list|)
condition|)
block|{
name|job
operator|->
name|flags
operator||=
name|JOB_IGNERR
expr_stmt|;
block|}
if|if
condition|(
name|Targ_Silent
argument_list|(
name|gn
argument_list|)
condition|)
block|{
name|job
operator|->
name|flags
operator||=
name|JOB_SILENT
expr_stmt|;
block|}
name|job
operator|->
name|flags
operator||=
name|flags
expr_stmt|;
comment|/*      * Check the commands now so any attributes from .DEFAULT have a chance      * to migrate to the node      */
if|if
condition|(
operator|!
name|compatMake
operator|&&
name|job
operator|->
name|flags
operator|&
name|JOB_FIRST
condition|)
block|{
name|cmdsOK
operator|=
name|Job_CheckCommands
argument_list|(
name|gn
argument_list|,
name|Error
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cmdsOK
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/*      * If the -n flag wasn't given, we open up OUR (not the child's)      * temporary file to stuff commands in it. The thing is rd/wr so we don't      * need to reopen it to feed it to the shell. If the -n flag *was* given,      * we just set the file to be stdout. Cute, huh?      */
if|if
condition|(
operator|(
name|gn
operator|->
name|type
operator|&
name|OP_MAKE
operator|)
operator|||
operator|(
operator|!
name|noExecute
operator|&&
operator|!
name|touchFlag
operator|)
condition|)
block|{
comment|/* 	 * We're serious here, but if the commands were bogus, we're 	 * also dead... 	 */
if|if
condition|(
operator|!
name|cmdsOK
condition|)
block|{
name|DieHorribly
argument_list|()
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|tfile
argument_list|,
name|TMPPAT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tfd
operator|=
name|mkstemp
argument_list|(
name|tfile
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|Punt
argument_list|(
literal|"Cannot create temp file: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|job
operator|->
name|cmdFILE
operator|=
name|fdopen
argument_list|(
name|tfd
argument_list|,
literal|"w+"
argument_list|)
expr_stmt|;
name|eunlink
argument_list|(
name|tfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|job
operator|->
name|cmdFILE
operator|==
name|NULL
condition|)
block|{
name|close
argument_list|(
name|tfd
argument_list|)
expr_stmt|;
name|Punt
argument_list|(
literal|"Could not open %s"
argument_list|,
name|tfile
argument_list|)
expr_stmt|;
block|}
name|fcntl
argument_list|(
name|FILENO
argument_list|(
name|job
operator|->
name|cmdFILE
argument_list|)
argument_list|,
name|F_SETFD
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * Send the commands to the command file, flush all its buffers then 	 * rewind and remove the thing. 	 */
name|noExec
operator|=
name|FALSE
expr_stmt|;
comment|/* 	 * used to be backwards; replace when start doing multiple commands 	 * per shell. 	 */
if|if
condition|(
name|compatMake
condition|)
block|{
comment|/* 	     * Be compatible: If this is the first time for this node, 	     * verify its commands are ok and open the commands list for 	     * sequential access by later invocations of JobStart. 	     * Once that is done, we take the next command off the list 	     * and print it to the command file. If the command was an 	     * ellipsis, note that there's nothing more to execute. 	     */
if|if
condition|(
name|job
operator|->
name|flags
operator|&
name|JOB_FIRST
condition|)
name|gn
operator|->
name|compat_command
operator|=
name|Lst_First
argument_list|(
operator|&
name|gn
operator|->
name|commands
argument_list|)
expr_stmt|;
else|else
name|gn
operator|->
name|compat_command
operator|=
name|Lst_Succ
argument_list|(
name|gn
operator|->
name|compat_command
argument_list|)
expr_stmt|;
if|if
condition|(
name|gn
operator|->
name|compat_command
operator|==
name|NULL
operator|||
name|JobPrintCommand
argument_list|(
name|Lst_Datum
argument_list|(
name|gn
operator|->
name|compat_command
argument_list|)
argument_list|,
name|job
argument_list|)
condition|)
name|noExec
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|noExec
operator|&&
operator|!
operator|(
name|job
operator|->
name|flags
operator|&
name|JOB_FIRST
operator|)
condition|)
block|{
comment|/* 		 * If we're not going to execute anything, the job 		 * is done and we need to close down the various 		 * file descriptors we've opened for output, then 		 * call JobDoOutput to catch the final characters or 		 * send the file to the screen... Note that the i/o streams 		 * are only open if this isn't the first job. 		 * Note also that this could not be done in 		 * Job_CatchChildren b/c it wasn't clear if there were 		 * more commands to execute or not... 		 */
name|JobClose
argument_list|(
name|job
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 	     * We can do all the commands at once. hooray for sanity 	     */
name|numCommands
operator|=
literal|0
expr_stmt|;
name|LST_FOREACH
argument_list|(
argument|ln
argument_list|,
argument|&gn->commands
argument_list|)
block|{
if|if
condition|(
name|JobPrintCommand
argument_list|(
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
argument_list|,
name|job
argument_list|)
condition|)
break|break;
block|}
comment|/* 	     * If we didn't print out any commands to the shell script, 	     * there's not much point in executing the shell, is there? 	     */
if|if
condition|(
name|numCommands
operator|==
literal|0
condition|)
block|{
name|noExec
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|noExecute
condition|)
block|{
comment|/* 	 * Not executing anything -- just print all the commands to stdout 	 * in one fell swoop. This will still set up job->tailCmds correctly. 	 */
if|if
condition|(
name|lastNode
operator|!=
name|gn
condition|)
block|{
name|MESSAGE
argument_list|(
name|stdout
argument_list|,
name|gn
argument_list|)
expr_stmt|;
name|lastNode
operator|=
name|gn
expr_stmt|;
block|}
name|job
operator|->
name|cmdFILE
operator|=
name|stdout
expr_stmt|;
comment|/* 	 * Only print the commands if they're ok, but don't die if they're 	 * not -- just let the user know they're bad and keep going. It 	 * doesn't do any harm in this case and may do some good. 	 */
if|if
condition|(
name|cmdsOK
condition|)
block|{
name|LST_FOREACH
argument_list|(
argument|ln
argument_list|,
argument|&gn->commands
argument_list|)
block|{
if|if
condition|(
name|JobPrintCommand
argument_list|(
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
argument_list|,
name|job
argument_list|)
condition|)
break|break;
block|}
block|}
comment|/* 	 * Don't execute the shell, thank you. 	 */
name|noExec
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
comment|/* 	 * Just touch the target and note that no shell should be executed. 	 * Set cmdFILE to stdout to make life easier. Check the commands, too, 	 * but don't die if they're no good -- it does no harm to keep working 	 * up the graph. 	 */
name|job
operator|->
name|cmdFILE
operator|=
name|stdout
expr_stmt|;
name|Job_Touch
argument_list|(
name|gn
argument_list|,
name|job
operator|->
name|flags
operator|&
name|JOB_SILENT
argument_list|)
expr_stmt|;
name|noExec
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/*      * If we're not supposed to execute a shell, don't.      */
if|if
condition|(
name|noExec
condition|)
block|{
comment|/* 	 * Unlink and close the command file if we opened one 	 */
if|if
condition|(
name|job
operator|->
name|cmdFILE
operator|!=
name|stdout
condition|)
block|{
if|if
condition|(
name|job
operator|->
name|cmdFILE
operator|!=
name|NULL
condition|)
name|fclose
argument_list|(
name|job
operator|->
name|cmdFILE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * We only want to work our way up the graph if we aren't here because 	 * the commands for the job were no good. 	 */
if|if
condition|(
name|cmdsOK
condition|)
block|{
if|if
condition|(
name|aborting
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|ln
operator|=
name|job
operator|->
name|tailCmds
init|;
name|ln
operator|!=
name|NULL
condition|;
name|ln
operator|=
name|LST_NEXT
argument_list|(
name|ln
argument_list|)
control|)
block|{
name|Lst_AtEnd
argument_list|(
operator|&
name|postCommands
operator|->
name|commands
argument_list|,
name|Buf_Peel
argument_list|(
name|Var_Subst
argument_list|(
name|NULL
argument_list|,
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
argument_list|,
name|job
operator|->
name|node
argument_list|,
name|FALSE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|job
operator|->
name|node
operator|->
name|made
operator|=
name|MADE
expr_stmt|;
name|Make_Update
argument_list|(
name|job
operator|->
name|node
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|job
argument_list|)
expr_stmt|;
return|return
operator|(
name|JOB_FINISHED
operator|)
return|;
block|}
else|else
block|{
name|free
argument_list|(
name|job
argument_list|)
expr_stmt|;
return|return
operator|(
name|JOB_ERROR
operator|)
return|;
block|}
block|}
else|else
block|{
name|fflush
argument_list|(
name|job
operator|->
name|cmdFILE
argument_list|)
expr_stmt|;
block|}
comment|/*      * Set up the control arguments to the shell. This is based on the flags      * set earlier for this job.      */
name|JobMakeArgv
argument_list|(
name|job
argument_list|,
name|argv
argument_list|)
expr_stmt|;
comment|/*      * If we're using pipes to catch output, create the pipe by which we'll      * get the shell's output. If we're using files, print out that we're      * starting a job and then set up its temporary-file name.      */
if|if
condition|(
operator|!
name|compatMake
operator|||
operator|(
name|job
operator|->
name|flags
operator|&
name|JOB_FIRST
operator|)
condition|)
block|{
if|if
condition|(
name|usePipes
condition|)
block|{
name|int
name|fd
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|pipe
argument_list|(
name|fd
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|Punt
argument_list|(
literal|"Cannot create pipe: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|job
operator|->
name|inPipe
operator|=
name|fd
index|[
literal|0
index|]
expr_stmt|;
name|job
operator|->
name|outPipe
operator|=
name|fd
index|[
literal|1
index|]
expr_stmt|;
name|fcntl
argument_list|(
name|job
operator|->
name|inPipe
argument_list|,
name|F_SETFD
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fcntl
argument_list|(
name|job
operator|->
name|outPipe
argument_list|,
name|F_SETFD
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Remaking `%s'\n"
argument_list|,
name|gn
operator|->
name|name
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|job
operator|->
name|outFile
argument_list|,
name|TMPPAT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|job
operator|->
name|outFd
operator|=
name|mkstemp
argument_list|(
name|job
operator|->
name|outFile
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|Punt
argument_list|(
literal|"cannot create temp file: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|fcntl
argument_list|(
name|job
operator|->
name|outFd
argument_list|,
name|F_SETFD
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|nJobs
operator|>=
name|maxJobs
operator|)
operator|&&
operator|!
operator|(
name|job
operator|->
name|flags
operator|&
name|JOB_SPECIAL
operator|)
operator|&&
operator|(
name|maxJobs
operator|!=
literal|0
operator|)
condition|)
block|{
comment|/* 	 * We've hit the limit of concurrency, so put the job on hold until 	 * some other job finishes. Note that the special jobs (.BEGIN, 	 * .INTERRUPT and .END) may be run even when the limit has been reached 	 * (e.g. when maxJobs == 0). 	 */
name|jobFull
operator|=
name|TRUE
expr_stmt|;
name|DEBUGF
argument_list|(
name|JOB
argument_list|,
operator|(
literal|"Can only run job locally.\n"
operator|)
argument_list|)
expr_stmt|;
name|job
operator|->
name|flags
operator||=
name|JOB_RESTART
expr_stmt|;
name|Lst_AtEnd
argument_list|(
operator|&
name|stoppedJobs
argument_list|,
name|job
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|nJobs
operator|>=
name|maxJobs
condition|)
block|{
comment|/* 	     * If we're running this job locally as a special case (see above), 	     * at least say the table is full. 	     */
name|jobFull
operator|=
name|TRUE
expr_stmt|;
name|DEBUGF
argument_list|(
name|JOB
argument_list|,
operator|(
literal|"Local job queue is full.\n"
operator|)
argument_list|)
expr_stmt|;
block|}
name|JobExec
argument_list|(
name|job
argument_list|,
name|argv
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|JOB_RUNNING
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|JobOutput
parameter_list|(
name|Job
modifier|*
name|job
parameter_list|,
name|char
modifier|*
name|cp
parameter_list|,
name|char
modifier|*
name|endp
parameter_list|,
name|int
name|msg
parameter_list|)
block|{
name|char
modifier|*
name|ecp
decl_stmt|;
if|if
condition|(
name|commandShell
operator|->
name|noPrint
condition|)
block|{
name|ecp
operator|=
name|strstr
argument_list|(
name|cp
argument_list|,
name|commandShell
operator|->
name|noPrint
argument_list|)
expr_stmt|;
while|while
condition|(
name|ecp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|cp
operator|!=
name|ecp
condition|)
block|{
operator|*
name|ecp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|msg
operator|&&
name|job
operator|->
name|node
operator|!=
name|lastNode
condition|)
block|{
name|MESSAGE
argument_list|(
name|stdout
argument_list|,
name|job
operator|->
name|node
argument_list|)
expr_stmt|;
name|lastNode
operator|=
name|job
operator|->
name|node
expr_stmt|;
block|}
comment|/* 		 * The only way there wouldn't be a newline after 		 * this line is if it were the last in the buffer. 		 * however, since the non-printable comes after it, 		 * there must be a newline, so we don't print one. 		 */
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
name|cp
operator|=
name|ecp
operator|+
name|commandShell
operator|->
name|noPLen
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|endp
condition|)
block|{
comment|/* 		 * Still more to print, look again after skipping 		 * the whitespace following the non-printable 		 * command.... 		 */
name|cp
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|==
literal|' '
operator|||
operator|*
name|cp
operator|==
literal|'\t'
operator|||
operator|*
name|cp
operator|==
literal|'\n'
condition|)
block|{
name|cp
operator|++
expr_stmt|;
block|}
name|ecp
operator|=
name|strstr
argument_list|(
name|cp
argument_list|,
name|commandShell
operator|->
name|noPrint
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return
operator|(
name|cp
operator|)
return|;
block|}
block|}
block|}
return|return
operator|(
name|cp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * JobDoOutput  --  *	This function is called at different times depending on  *	whether the user has specified that output is to be collected  *	via pipes or temporary files. In the former case, we are called  *	whenever there is something to read on the pipe. We collect more  *	output from the given job and store it in the job's outBuf. If  *	this makes up a line, we print it tagged by the job's identifier,  *	as necessary.  *	If output has been collected in a temporary file, we open the  *	file and read it line by line, transfering it to our own  *	output channel until the file is empty. At which point we  *	remove the temporary file.  *	In both cases, however, we keep our figurative eye out for the  *	'noPrint' line for the shell from which the output came. If  *	we recognize a line, we don't print it. If the command is not  *	alone on the line (the character after it is not \0 or \n), we  *	do print whatever follows it.  *  * Results:  *	None  *  * Side Effects:  *	curPos may be shifted as may the contents of outBuf.  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|STATIC
name|void
name|JobDoOutput
parameter_list|(
name|Job
modifier|*
name|job
parameter_list|,
name|Boolean
name|finish
parameter_list|)
block|{
name|Boolean
name|gotNL
init|=
name|FALSE
decl_stmt|;
comment|/* true if got a newline */
name|Boolean
name|fbuf
decl_stmt|;
comment|/* true if our buffer filled up */
name|int
name|nr
decl_stmt|;
comment|/* number of bytes read */
name|int
name|i
decl_stmt|;
comment|/* auxiliary index into outBuf */
name|int
name|max
decl_stmt|;
comment|/* limit for i (end of current data) */
name|int
name|nRead
decl_stmt|;
comment|/* (Temporary) number of bytes read */
name|FILE
modifier|*
name|oFILE
decl_stmt|;
comment|/* Stream pointer to shell's output file */
name|char
name|inLine
index|[
literal|132
index|]
decl_stmt|;
if|if
condition|(
name|usePipes
condition|)
block|{
comment|/* 	 * Read as many bytes as will fit in the buffer. 	 */
name|end_loop
label|:
name|gotNL
operator|=
name|FALSE
expr_stmt|;
name|fbuf
operator|=
name|FALSE
expr_stmt|;
name|nRead
operator|=
name|read
argument_list|(
name|job
operator|->
name|inPipe
argument_list|,
operator|&
name|job
operator|->
name|outBuf
index|[
name|job
operator|->
name|curPos
index|]
argument_list|,
name|JOB_BUFSIZE
operator|-
name|job
operator|->
name|curPos
argument_list|)
expr_stmt|;
comment|/* 	 * Check for interrupt here too, because the above read may block 	 * when the child process is stopped. In this case the interrupt 	 * will unblock it (we don't use SA_RESTART). 	 */
if|if
condition|(
name|interrupted
condition|)
name|JobPassSig
argument_list|(
name|interrupted
argument_list|)
expr_stmt|;
if|if
condition|(
name|nRead
operator|<
literal|0
condition|)
block|{
name|DEBUGF
argument_list|(
name|JOB
argument_list|,
operator|(
literal|"JobDoOutput(piperead)"
operator|)
argument_list|)
expr_stmt|;
name|nr
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|nr
operator|=
name|nRead
expr_stmt|;
block|}
comment|/* 	 * If we hit the end-of-file (the job is dead), we must flush its 	 * remaining output, so pretend we read a newline if there's any 	 * output remaining in the buffer. 	 * Also clear the 'finish' flag so we stop looping. 	 */
if|if
condition|(
operator|(
name|nr
operator|==
literal|0
operator|)
operator|&&
operator|(
name|job
operator|->
name|curPos
operator|!=
literal|0
operator|)
condition|)
block|{
name|job
operator|->
name|outBuf
index|[
name|job
operator|->
name|curPos
index|]
operator|=
literal|'\n'
expr_stmt|;
name|nr
operator|=
literal|1
expr_stmt|;
name|finish
operator|=
name|FALSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nr
operator|==
literal|0
condition|)
block|{
name|finish
operator|=
name|FALSE
expr_stmt|;
block|}
comment|/* 	 * Look for the last newline in the bytes we just got. If there is 	 * one, break out of the loop with 'i' as its index and gotNL set 	 * TRUE. 	 */
name|max
operator|=
name|job
operator|->
name|curPos
operator|+
name|nr
expr_stmt|;
for|for
control|(
name|i
operator|=
name|job
operator|->
name|curPos
operator|+
name|nr
operator|-
literal|1
init|;
name|i
operator|>=
name|job
operator|->
name|curPos
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|job
operator|->
name|outBuf
index|[
name|i
index|]
operator|==
literal|'\n'
condition|)
block|{
name|gotNL
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|job
operator|->
name|outBuf
index|[
name|i
index|]
operator|==
literal|'\0'
condition|)
block|{
comment|/* 		 * Why? 		 */
name|job
operator|->
name|outBuf
index|[
name|i
index|]
operator|=
literal|' '
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|gotNL
condition|)
block|{
name|job
operator|->
name|curPos
operator|+=
name|nr
expr_stmt|;
if|if
condition|(
name|job
operator|->
name|curPos
operator|==
name|JOB_BUFSIZE
condition|)
block|{
comment|/* 		 * If we've run out of buffer space, we have no choice 		 * but to print the stuff. sigh. 		 */
name|fbuf
operator|=
name|TRUE
expr_stmt|;
name|i
operator|=
name|job
operator|->
name|curPos
expr_stmt|;
block|}
block|}
if|if
condition|(
name|gotNL
operator|||
name|fbuf
condition|)
block|{
comment|/* 	     * Need to send the output to the screen. Null terminate it 	     * first, overwriting the newline character if there was one. 	     * So long as the line isn't one we should filter (according 	     * to the shell description), we print the line, preceded 	     * by a target banner if this target isn't the same as the 	     * one for which we last printed something. 	     * The rest of the data in the buffer are then shifted down 	     * to the start of the buffer and curPos is set accordingly. 	     */
name|job
operator|->
name|outBuf
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|job
operator|->
name|curPos
condition|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|cp
operator|=
name|JobOutput
argument_list|(
name|job
argument_list|,
name|job
operator|->
name|outBuf
argument_list|,
operator|&
name|job
operator|->
name|outBuf
index|[
name|i
index|]
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* 		 * There's still more in that thar buffer. This time, though, 		 * we know there's no newline at the end, so we add one of 		 * our own free will. 		 */
if|if
condition|(
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|job
operator|->
name|node
operator|!=
name|lastNode
condition|)
block|{
name|MESSAGE
argument_list|(
name|stdout
argument_list|,
name|job
operator|->
name|node
argument_list|)
expr_stmt|;
name|lastNode
operator|=
name|job
operator|->
name|node
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s%s"
argument_list|,
name|cp
argument_list|,
name|gotNL
condition|?
literal|"\n"
else|:
literal|""
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|i
operator|<
name|max
operator|-
literal|1
condition|)
block|{
comment|/* shift the remaining characters down */
name|memcpy
argument_list|(
name|job
operator|->
name|outBuf
argument_list|,
operator|&
name|job
operator|->
name|outBuf
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
name|max
operator|-
operator|(
name|i
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|job
operator|->
name|curPos
operator|=
name|max
operator|-
operator|(
name|i
operator|+
literal|1
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * We have written everything out, so we just start over 		 * from the start of the buffer. No copying. No nothing. 		 */
name|job
operator|->
name|curPos
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|finish
condition|)
block|{
comment|/* 	     * If the finish flag is true, we must loop until we hit 	     * end-of-file on the pipe. This is guaranteed to happen 	     * eventually since the other end of the pipe is now closed 	     * (we closed it explicitly and the child has exited). When 	     * we do get an EOF, finish will be set FALSE and we'll fall 	     * through and out. 	     */
goto|goto
name|end_loop
goto|;
block|}
block|}
else|else
block|{
comment|/* 	 * We've been called to retrieve the output of the job from the 	 * temporary file where it's been squirreled away. This consists of 	 * opening the file, reading the output line by line, being sure not 	 * to print the noPrint line for the shell we used, then close and 	 * remove the temporary file. Very simple. 	 * 	 * Change to read in blocks and do FindSubString type things as for 	 * pipes? That would allow for "@echo -n..." 	 */
name|oFILE
operator|=
name|fopen
argument_list|(
name|job
operator|->
name|outFile
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|oFILE
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Results of making %s:\n"
argument_list|,
name|job
operator|->
name|node
operator|->
name|name
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|inLine
argument_list|,
sizeof|sizeof
argument_list|(
name|inLine
argument_list|)
argument_list|,
name|oFILE
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|endp
decl_stmt|,
modifier|*
name|oendp
decl_stmt|;
name|cp
operator|=
name|inLine
expr_stmt|;
name|oendp
operator|=
name|endp
operator|=
name|inLine
operator|+
name|strlen
argument_list|(
name|inLine
argument_list|)
expr_stmt|;
if|if
condition|(
name|endp
index|[
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
block|{
operator|*
operator|--
name|endp
operator|=
literal|'\0'
expr_stmt|;
block|}
name|cp
operator|=
name|JobOutput
argument_list|(
name|job
argument_list|,
name|inLine
argument_list|,
name|endp
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* 		 * There's still more in that thar buffer. This time, though, 		 * we know there's no newline at the end, so we add one of 		 * our own free will. 		 */
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|endp
operator|!=
name|oendp
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
name|fclose
argument_list|(
name|oFILE
argument_list|)
expr_stmt|;
name|eunlink
argument_list|(
name|job
operator|->
name|outFile
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Job_CatchChildren --  *	Handle the exit of a child. Called from Make_Make.  *  * Results:  *	none.  *  * Side Effects:  *	The job descriptor is removed from the list of children.  *  * Notes:  *	We do waits, blocking or not, according to the wisdom of our  *	caller, until there are no more children to report. For each  *	job, call JobFinish to finish things off. This will take care of  *	putting jobs on the stoppedJobs queue.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Job_CatchChildren
parameter_list|(
name|Boolean
name|block
parameter_list|)
block|{
name|int
name|pid
decl_stmt|;
comment|/* pid of dead child */
name|Job
modifier|*
name|job
decl_stmt|;
comment|/* job descriptor for dead child */
name|LstNode
modifier|*
name|jnode
decl_stmt|;
comment|/* list element for finding job */
name|int
name|status
decl_stmt|;
comment|/* Exit/termination status */
comment|/*      * Don't even bother if we know there's no one around.      */
if|if
condition|(
name|nJobs
operator|==
literal|0
condition|)
block|{
return|return;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|pid
operator|=
name|waitpid
argument_list|(
operator|(
name|pid_t
operator|)
operator|-
literal|1
argument_list|,
operator|&
name|status
argument_list|,
operator|(
name|block
condition|?
literal|0
else|:
name|WNOHANG
operator|)
operator||
name|WUNTRACED
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|<=
literal|0
condition|)
break|break;
name|DEBUGF
argument_list|(
name|JOB
argument_list|,
operator|(
literal|"Process %d exited or stopped.\n"
operator|,
name|pid
operator|)
argument_list|)
expr_stmt|;
name|LST_FOREACH
argument_list|(
argument|jnode
argument_list|,
argument|&jobs
argument_list|)
block|{
if|if
condition|(
operator|(
operator|(
specifier|const
name|Job
operator|*
operator|)
name|Lst_Datum
argument_list|(
name|jnode
argument_list|)
operator|)
operator|->
name|pid
operator|==
name|pid
condition|)
break|break;
block|}
if|if
condition|(
name|jnode
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|WIFSIGNALED
argument_list|(
name|status
argument_list|)
operator|&&
operator|(
name|WTERMSIG
argument_list|(
name|status
argument_list|)
operator|==
name|SIGCONT
operator|)
condition|)
block|{
name|LST_FOREACH
argument_list|(
argument|jnode
argument_list|,
argument|&stoppedJobs
argument_list|)
block|{
if|if
condition|(
operator|(
operator|(
specifier|const
name|Job
operator|*
operator|)
name|Lst_Datum
argument_list|(
name|jnode
argument_list|)
operator|)
operator|->
name|pid
operator|==
name|pid
condition|)
break|break;
block|}
if|if
condition|(
name|jnode
operator|==
name|NULL
condition|)
block|{
name|Error
argument_list|(
literal|"Resumed child (%d) not in table"
argument_list|,
name|pid
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|job
operator|=
name|Lst_Datum
argument_list|(
name|jnode
argument_list|)
expr_stmt|;
name|Lst_Remove
argument_list|(
operator|&
name|stoppedJobs
argument_list|,
name|jnode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Error
argument_list|(
literal|"Child (%d) not in table?"
argument_list|,
name|pid
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
else|else
block|{
name|job
operator|=
name|Lst_Datum
argument_list|(
name|jnode
argument_list|)
expr_stmt|;
name|Lst_Remove
argument_list|(
operator|&
name|jobs
argument_list|,
name|jnode
argument_list|)
expr_stmt|;
name|nJobs
operator|-=
literal|1
expr_stmt|;
if|if
condition|(
name|fifoFd
operator|>=
literal|0
operator|&&
name|maxJobs
operator|>
literal|1
condition|)
block|{
name|write
argument_list|(
name|fifoFd
argument_list|,
literal|"+"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|maxJobs
operator|--
expr_stmt|;
if|if
condition|(
name|nJobs
operator|>=
name|maxJobs
condition|)
name|jobFull
operator|=
name|TRUE
expr_stmt|;
else|else
name|jobFull
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
name|DEBUGF
argument_list|(
name|JOB
argument_list|,
operator|(
literal|"Job queue is no longer full.\n"
operator|)
argument_list|)
expr_stmt|;
name|jobFull
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
name|JobFinish
argument_list|(
name|job
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|interrupted
condition|)
name|JobPassSig
argument_list|(
name|interrupted
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Job_CatchOutput --  *	Catch the output from our children, if we're using  *	pipes do so. Otherwise just block time until we get a  *	signal(most likely a SIGCHLD) since there's no point in  *	just spinning when there's nothing to do and the reaping  *	of a child can wait for a while.  *  * Results:  *	None  *  * Side Effects:  *	Output is read from pipes if we're piping.  * -----------------------------------------------------------------------  */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|USE_KQUEUE
name|Job_CatchOutput
parameter_list|(
name|int
name|flag
name|__unused
parameter_list|)
else|#
directive|else
function|Job_CatchOutput
parameter_list|(
name|int
name|flag
parameter_list|)
endif|#
directive|endif
block|{
name|int
name|nfds
decl_stmt|;
ifdef|#
directive|ifdef
name|USE_KQUEUE
define|#
directive|define
name|KEV_SIZE
value|4
name|struct
name|kevent
name|kev
index|[
name|KEV_SIZE
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
else|#
directive|else
name|struct
name|timeval
name|timeout
decl_stmt|;
name|fd_set
name|readfds
decl_stmt|;
name|LstNode
modifier|*
name|ln
decl_stmt|;
name|Job
modifier|*
name|job
decl_stmt|;
endif|#
directive|endif
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|usePipes
condition|)
block|{
ifdef|#
directive|ifdef
name|USE_KQUEUE
if|if
condition|(
operator|(
name|nfds
operator|=
name|kevent
argument_list|(
name|kqfd
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|kev
argument_list|,
name|KEV_SIZE
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EINTR
condition|)
name|Punt
argument_list|(
literal|"kevent: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|interrupted
condition|)
name|JobPassSig
argument_list|(
name|interrupted
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfds
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|kev
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|EV_ERROR
condition|)
block|{
name|warnc
argument_list|(
name|kev
index|[
name|i
index|]
operator|.
name|data
argument_list|,
literal|"kevent"
argument_list|)
expr_stmt|;
continue|continue;
block|}
switch|switch
condition|(
name|kev
index|[
name|i
index|]
operator|.
name|filter
condition|)
block|{
case|case
name|EVFILT_READ
case|:
name|JobDoOutput
argument_list|(
name|kev
index|[
name|i
index|]
operator|.
name|udata
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
break|break;
case|case
name|EVFILT_PROC
case|:
comment|/* Just wake up and let Job_CatchChildren() collect the 		     * terminated job. */
break|break;
block|}
block|}
block|}
else|#
directive|else
name|readfds
operator|=
name|outputs
expr_stmt|;
name|timeout
operator|.
name|tv_sec
operator|=
name|SEL_SEC
expr_stmt|;
name|timeout
operator|.
name|tv_usec
operator|=
name|SEL_USEC
expr_stmt|;
if|if
condition|(
name|flag
operator|&&
name|jobFull
operator|&&
name|fifoFd
operator|>=
literal|0
condition|)
name|FD_SET
argument_list|(
name|fifoFd
argument_list|,
operator|&
name|readfds
argument_list|)
expr_stmt|;
name|nfds
operator|=
name|select
argument_list|(
name|FD_SETSIZE
argument_list|,
operator|&
name|readfds
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|nfds
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|interrupted
condition|)
name|JobPassSig
argument_list|(
name|interrupted
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|fifoFd
operator|>=
literal|0
operator|&&
name|FD_ISSET
argument_list|(
name|fifoFd
argument_list|,
operator|&
name|readfds
argument_list|)
condition|)
block|{
if|if
condition|(
operator|--
name|nfds
operator|<=
literal|0
condition|)
return|return;
block|}
for|for
control|(
name|ln
operator|=
name|Lst_First
argument_list|(
operator|&
name|jobs
argument_list|)
init|;
name|nfds
operator|!=
literal|0
operator|&&
name|ln
operator|!=
name|NULL
condition|;
name|ln
operator|=
name|Lst_Succ
argument_list|(
name|ln
argument_list|)
control|)
block|{
name|job
operator|=
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
expr_stmt|;
if|if
condition|(
name|FD_ISSET
argument_list|(
name|job
operator|->
name|inPipe
argument_list|,
operator|&
name|readfds
argument_list|)
condition|)
block|{
name|JobDoOutput
argument_list|(
name|job
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|nfds
operator|-=
literal|1
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* !USE_KQUEUE */
block|}
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Job_Make --  *	Start the creation of a target. Basically a front-end for  *	JobStart used by the Make module.  *  * Results:  *	None.  *  * Side Effects:  *	Another job is started.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Job_Make
parameter_list|(
name|GNode
modifier|*
name|gn
parameter_list|)
block|{
name|JobStart
argument_list|(
name|gn
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * JobCopyShell:  *  * Make a new copy of the shell structure including a copy of the strings  * in it. This also defaults some fields in case they are NULL.  *  * The function returns a pointer to the new shell structure otherwise.  */
end_comment

begin_function
specifier|static
name|Shell
modifier|*
name|JobCopyShell
parameter_list|(
specifier|const
name|Shell
modifier|*
name|osh
parameter_list|)
block|{
name|Shell
modifier|*
name|nsh
decl_stmt|;
name|nsh
operator|=
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|nsh
argument_list|)
argument_list|)
expr_stmt|;
name|nsh
operator|->
name|name
operator|=
name|estrdup
argument_list|(
name|osh
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|osh
operator|->
name|echoOff
operator|!=
name|NULL
condition|)
name|nsh
operator|->
name|echoOff
operator|=
name|estrdup
argument_list|(
name|osh
operator|->
name|echoOff
argument_list|)
expr_stmt|;
else|else
name|nsh
operator|->
name|echoOff
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|osh
operator|->
name|echoOn
operator|!=
name|NULL
condition|)
name|nsh
operator|->
name|echoOn
operator|=
name|estrdup
argument_list|(
name|osh
operator|->
name|echoOn
argument_list|)
expr_stmt|;
else|else
name|nsh
operator|->
name|echoOn
operator|=
name|NULL
expr_stmt|;
name|nsh
operator|->
name|hasEchoCtl
operator|=
name|osh
operator|->
name|hasEchoCtl
expr_stmt|;
if|if
condition|(
name|osh
operator|->
name|noPrint
operator|!=
name|NULL
condition|)
name|nsh
operator|->
name|noPrint
operator|=
name|estrdup
argument_list|(
name|osh
operator|->
name|noPrint
argument_list|)
expr_stmt|;
else|else
name|nsh
operator|->
name|noPrint
operator|=
name|NULL
expr_stmt|;
name|nsh
operator|->
name|noPLen
operator|=
name|osh
operator|->
name|noPLen
expr_stmt|;
name|nsh
operator|->
name|hasErrCtl
operator|=
name|osh
operator|->
name|hasErrCtl
expr_stmt|;
if|if
condition|(
name|osh
operator|->
name|errCheck
operator|==
name|NULL
condition|)
name|nsh
operator|->
name|errCheck
operator|=
name|estrdup
argument_list|(
literal|""
argument_list|)
expr_stmt|;
else|else
name|nsh
operator|->
name|errCheck
operator|=
name|estrdup
argument_list|(
name|osh
operator|->
name|errCheck
argument_list|)
expr_stmt|;
if|if
condition|(
name|osh
operator|->
name|ignErr
operator|==
name|NULL
condition|)
name|nsh
operator|->
name|ignErr
operator|=
name|estrdup
argument_list|(
literal|"%s"
argument_list|)
expr_stmt|;
else|else
name|nsh
operator|->
name|ignErr
operator|=
name|estrdup
argument_list|(
name|osh
operator|->
name|ignErr
argument_list|)
expr_stmt|;
if|if
condition|(
name|osh
operator|->
name|echo
operator|==
name|NULL
condition|)
name|nsh
operator|->
name|echo
operator|=
name|estrdup
argument_list|(
literal|""
argument_list|)
expr_stmt|;
else|else
name|nsh
operator|->
name|echo
operator|=
name|estrdup
argument_list|(
name|osh
operator|->
name|echo
argument_list|)
expr_stmt|;
if|if
condition|(
name|osh
operator|->
name|exit
operator|==
name|NULL
condition|)
name|nsh
operator|->
name|exit
operator|=
name|estrdup
argument_list|(
literal|""
argument_list|)
expr_stmt|;
else|else
name|nsh
operator|->
name|exit
operator|=
name|estrdup
argument_list|(
name|osh
operator|->
name|exit
argument_list|)
expr_stmt|;
return|return
operator|(
name|nsh
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * JobFreeShell:  *  * Free a shell structure and all associated strings.  */
end_comment

begin_function
specifier|static
name|void
name|JobFreeShell
parameter_list|(
name|Shell
modifier|*
name|sh
parameter_list|)
block|{
if|if
condition|(
name|sh
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|sh
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sh
operator|->
name|echoOff
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sh
operator|->
name|echoOn
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sh
operator|->
name|noPrint
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sh
operator|->
name|errCheck
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sh
operator|->
name|ignErr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sh
operator|->
name|echo
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sh
operator|->
name|exit
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sh
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|Shell_Init
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|commandShell
operator|==
name|NULL
condition|)
name|commandShell
operator|=
name|JobMatchShell
argument_list|(
name|shells
index|[
name|DEFSHELL
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|shellPath
operator|==
name|NULL
condition|)
block|{
comment|/* 	 * The user didn't specify a shell to use, so we are using the 	 * default one... Both the absolute path and the last component 	 * must be set. The last component is taken from the 'name' field 	 * of the default shell description pointed-to by commandShell. 	 * All default shells are located in PATH_DEFSHELLDIR. 	 */
name|shellName
operator|=
name|commandShell
operator|->
name|name
expr_stmt|;
name|shellPath
operator|=
name|str_concat
argument_list|(
name|PATH_DEFSHELLDIR
argument_list|,
name|shellName
argument_list|,
name|STR_ADDSLASH
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Job_Init --  *	Initialize the process module, given a maximum number of jobs.  *  * Results:  *	none  *  * Side Effects:  *	lists and counters are initialized  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Job_Init
parameter_list|(
name|int
name|maxproc
parameter_list|)
block|{
name|GNode
modifier|*
name|begin
decl_stmt|;
comment|/* node for commands to do at the very start */
specifier|const
name|char
modifier|*
name|env
decl_stmt|;
name|struct
name|sigaction
name|sa
decl_stmt|;
name|fifoFd
operator|=
operator|-
literal|1
expr_stmt|;
name|env
operator|=
name|getenv
argument_list|(
literal|"MAKE_JOBS_FIFO"
argument_list|)
expr_stmt|;
if|if
condition|(
name|env
operator|==
name|NULL
operator|&&
name|maxproc
operator|>
literal|1
condition|)
block|{
comment|/* 	 * We did not find the environment variable so we are the leader. 	 * Create the fifo, open it, write one char per allowed job into 	 * the pipe. 	 */
name|mktemp
argument_list|(
name|fifoName
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mkfifo
argument_list|(
name|fifoName
argument_list|,
literal|0600
argument_list|)
condition|)
block|{
name|fifoFd
operator|=
name|open
argument_list|(
name|fifoName
argument_list|,
name|O_RDWR
operator||
name|O_NONBLOCK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fifoFd
operator|>=
literal|0
condition|)
block|{
name|fifoMaster
operator|=
literal|1
expr_stmt|;
name|fcntl
argument_list|(
name|fifoFd
argument_list|,
name|F_SETFL
argument_list|,
name|O_NONBLOCK
argument_list|)
expr_stmt|;
name|env
operator|=
name|fifoName
expr_stmt|;
name|setenv
argument_list|(
literal|"MAKE_JOBS_FIFO"
argument_list|,
name|env
argument_list|,
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|maxproc
operator|--
operator|>
literal|0
condition|)
block|{
name|write
argument_list|(
name|fifoFd
argument_list|,
literal|"+"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* The master make does not get a magic token */
name|jobFull
operator|=
name|TRUE
expr_stmt|;
name|maxJobs
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|unlink
argument_list|(
name|fifoName
argument_list|)
expr_stmt|;
name|env
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|env
operator|!=
name|NULL
condition|)
block|{
comment|/* 	 * We had the environment variable so we are a slave. 	 * Open fifo and give ourselves a magic token which represents 	 * the token our parent make has grabbed to start his make process. 	 * Otherwise the sub-makes would gobble up tokens and the proper 	 * number of tokens to specify to -j would depend on the depth of 	 * the tree and the order of execution. 	 */
name|fifoFd
operator|=
name|open
argument_list|(
name|env
argument_list|,
name|O_RDWR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fifoFd
operator|>=
literal|0
condition|)
block|{
name|fcntl
argument_list|(
name|fifoFd
argument_list|,
name|F_SETFL
argument_list|,
name|O_NONBLOCK
argument_list|)
expr_stmt|;
name|maxJobs
operator|=
literal|1
expr_stmt|;
name|jobFull
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fifoFd
operator|<=
literal|0
condition|)
block|{
name|maxJobs
operator|=
name|maxproc
expr_stmt|;
name|jobFull
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{     }
name|nJobs
operator|=
literal|0
expr_stmt|;
name|aborting
operator|=
literal|0
expr_stmt|;
name|errors
operator|=
literal|0
expr_stmt|;
name|lastNode
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|maxJobs
operator|==
literal|1
operator|&&
name|fifoFd
operator|<
literal|0
operator|)
operator|||
name|beVerbose
operator|==
literal|0
condition|)
block|{
comment|/* 	 * If only one job can run at a time, there's no need for a banner, 	 * no is there? 	 */
name|targFmt
operator|=
literal|""
expr_stmt|;
block|}
else|else
block|{
name|targFmt
operator|=
name|TARG_FMT
expr_stmt|;
block|}
name|Shell_Init
argument_list|()
expr_stmt|;
comment|/*      * Catch the four signals that POSIX specifies if they aren't ignored.      * JobCatchSignal will just set global variables and hope someone      * else is going to handle the interrupt.      */
name|sa
operator|.
name|sa_handler
operator|=
name|JobCatchSig
expr_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|sa
operator|.
name|sa_mask
argument_list|)
expr_stmt|;
name|sa
operator|.
name|sa_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
block|{
name|sigaction
argument_list|(
name|SIGINT
argument_list|,
operator|&
name|sa
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
block|{
name|sigaction
argument_list|(
name|SIGHUP
argument_list|,
operator|&
name|sa
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
block|{
name|sigaction
argument_list|(
name|SIGQUIT
argument_list|,
operator|&
name|sa
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
block|{
name|sigaction
argument_list|(
name|SIGTERM
argument_list|,
operator|&
name|sa
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/*      * There are additional signals that need to be caught and passed if      * either the export system wants to be told directly of signals or if      * we're giving each job its own process group (since then it won't get      * signals from the terminal driver as we own the terminal)      */
if|#
directive|if
name|defined
argument_list|(
name|USE_PGRP
argument_list|)
if|if
condition|(
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
block|{
name|sigaction
argument_list|(
name|SIGTSTP
argument_list|,
operator|&
name|sa
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|signal
argument_list|(
name|SIGTTOU
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
block|{
name|sigaction
argument_list|(
name|SIGTTOU
argument_list|,
operator|&
name|sa
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|signal
argument_list|(
name|SIGTTIN
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
block|{
name|sigaction
argument_list|(
name|SIGTTIN
argument_list|,
operator|&
name|sa
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|signal
argument_list|(
name|SIGWINCH
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
block|{
name|sigaction
argument_list|(
name|SIGWINCH
argument_list|,
operator|&
name|sa
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USE_KQUEUE
if|if
condition|(
operator|(
name|kqfd
operator|=
name|kqueue
argument_list|()
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|Punt
argument_list|(
literal|"kqueue: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|begin
operator|=
name|Targ_FindNode
argument_list|(
literal|".BEGIN"
argument_list|,
name|TARG_NOCREATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|begin
operator|!=
name|NULL
condition|)
block|{
name|JobStart
argument_list|(
name|begin
argument_list|,
name|JOB_SPECIAL
argument_list|,
operator|(
name|Job
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
while|while
condition|(
name|nJobs
condition|)
block|{
name|Job_CatchOutput
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|Job_CatchChildren
argument_list|(
operator|!
name|usePipes
argument_list|)
expr_stmt|;
block|}
block|}
name|postCommands
operator|=
name|Targ_FindNode
argument_list|(
literal|".END"
argument_list|,
name|TARG_CREATE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Job_Full --  *	See if the job table is full. It is considered full if it is OR  *	if we are in the process of aborting OR if we have  *	reached/exceeded our local quota. This prevents any more jobs  *	from starting up.  *  * Results:  *	TRUE if the job table is full, FALSE otherwise  * Side Effects:  *	None.  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|Boolean
name|Job_Full
parameter_list|(
name|void
parameter_list|)
block|{
name|char
name|c
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|aborting
condition|)
return|return
operator|(
name|aborting
operator|)
return|;
if|if
condition|(
name|fifoFd
operator|>=
literal|0
operator|&&
name|jobFull
condition|)
block|{
name|i
operator|=
name|read
argument_list|(
name|fifoFd
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|maxJobs
operator|++
expr_stmt|;
name|jobFull
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
return|return
operator|(
name|jobFull
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Job_Empty --  *	See if the job table is empty.  Because the local concurrency may  *	be set to 0, it is possible for the job table to become empty,  *	while the list of stoppedJobs remains non-empty. In such a case,  *	we want to restart as many jobs as we can.  *  * Results:  *	TRUE if it is. FALSE if it ain't.  *  * Side Effects:  *	None.  *  * -----------------------------------------------------------------------  */
end_comment

begin_function
name|Boolean
name|Job_Empty
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|nJobs
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|Lst_IsEmpty
argument_list|(
operator|&
name|stoppedJobs
argument_list|)
operator|&&
operator|!
name|aborting
condition|)
block|{
comment|/* 	     * The job table is obviously not full if it has no jobs in 	     * it...Try and restart the stopped jobs. 	     */
name|jobFull
operator|=
name|FALSE
expr_stmt|;
name|JobRestartJobs
argument_list|()
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
block|}
else|else
block|{
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * JobMatchShell --  *	Find a matching shell in 'shells' given its final component.  *  * Results:  *	A pointer to a freshly allocated Shell structure with a copy  *	of the static structure or NULL if no shell with the given name  *	is found.  *  * Side Effects:  *	None.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|Shell
modifier|*
name|JobMatchShell
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
specifier|const
name|struct
name|CShell
modifier|*
name|sh
decl_stmt|;
comment|/* Pointer into shells table */
name|struct
name|Shell
modifier|*
name|nsh
decl_stmt|;
for|for
control|(
name|sh
operator|=
name|shells
init|;
name|sh
operator|<
name|shells
operator|+
sizeof|sizeof
argument_list|(
name|shells
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|shells
index|[
literal|0
index|]
argument_list|)
condition|;
name|sh
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|sh
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|sh
operator|==
name|shells
operator|+
sizeof|sizeof
argument_list|(
name|shells
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|shells
index|[
literal|0
index|]
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* make a copy */
name|nsh
operator|=
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|nsh
argument_list|)
argument_list|)
expr_stmt|;
name|nsh
operator|->
name|name
operator|=
name|estrdup
argument_list|(
name|sh
operator|->
name|name
argument_list|)
expr_stmt|;
name|nsh
operator|->
name|echoOff
operator|=
name|estrdup
argument_list|(
name|sh
operator|->
name|echoOff
argument_list|)
expr_stmt|;
name|nsh
operator|->
name|echoOn
operator|=
name|estrdup
argument_list|(
name|sh
operator|->
name|echoOn
argument_list|)
expr_stmt|;
name|nsh
operator|->
name|hasEchoCtl
operator|=
name|sh
operator|->
name|hasEchoCtl
expr_stmt|;
name|nsh
operator|->
name|noPrint
operator|=
name|estrdup
argument_list|(
name|sh
operator|->
name|noPrint
argument_list|)
expr_stmt|;
name|nsh
operator|->
name|noPLen
operator|=
name|sh
operator|->
name|noPLen
expr_stmt|;
name|nsh
operator|->
name|hasErrCtl
operator|=
name|sh
operator|->
name|hasErrCtl
expr_stmt|;
name|nsh
operator|->
name|errCheck
operator|=
name|estrdup
argument_list|(
name|sh
operator|->
name|errCheck
argument_list|)
expr_stmt|;
name|nsh
operator|->
name|ignErr
operator|=
name|estrdup
argument_list|(
name|sh
operator|->
name|ignErr
argument_list|)
expr_stmt|;
name|nsh
operator|->
name|echo
operator|=
name|estrdup
argument_list|(
name|sh
operator|->
name|echo
argument_list|)
expr_stmt|;
name|nsh
operator|->
name|exit
operator|=
name|estrdup
argument_list|(
name|sh
operator|->
name|exit
argument_list|)
expr_stmt|;
return|return
operator|(
name|nsh
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Job_ParseShell --  *	Parse a shell specification and set up commandShell, shellPath  *	and shellName appropriately.  *  * Results:  *	FAILURE if the specification was incorrect.  *  * Side Effects:  *	commandShell points to a Shell structure (either predefined or  *	created from the shell spec), shellPath is the full path of the  *	shell described by commandShell, while shellName is just the  *	final component of shellPath.  *  * Notes:  *	A shell specification consists of a .SHELL target, with dependency  *	operator, followed by a series of blank-separated words. Double  *	quotes can be used to use blanks in words. A backslash escapes  *	anything (most notably a double-quote and a space) and  *	provides the functionality it does in C. Each word consists of  *	keyword and value separated by an equal sign. There should be no  *	unnecessary spaces in the word. The keywords are as follows:  *	    name  	    Name of shell.  *	    path  	    Location of shell. Overrides "name" if given  *	    quiet 	    Command to turn off echoing.  *	    echo  	    Command to turn echoing on  *	    filter	    Result of turning off echoing that shouldn't be  *	    	  	    printed.  *	    echoFlag	    Flag to turn echoing on at the start  *	    errFlag	    Flag to turn error checking on at the start  *	    hasErrCtl	    True if shell has error checking control  *	    check 	    Command to turn on error checking if hasErrCtl  *	    	  	    is TRUE or template of command to echo a command  *	    	  	    for which error checking is off if hasErrCtl is  *	    	  	    FALSE.  *	    ignore	    Command to turn off error checking if hasErrCtl  *	    	  	    is TRUE or template of command to execute a  *	    	  	    command so as to ignore any errors it returns if  *	    	  	    hasErrCtl is FALSE.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|ReturnStatus
name|Job_ParseShell
parameter_list|(
name|char
modifier|*
name|line
parameter_list|)
block|{
name|char
modifier|*
modifier|*
name|words
decl_stmt|;
name|int
name|wordCount
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|path
decl_stmt|;
name|Shell
name|newShell
decl_stmt|;
name|Shell
modifier|*
name|sh
decl_stmt|;
name|Boolean
name|fullSpec
init|=
name|FALSE
decl_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|line
argument_list|)
condition|)
block|{
name|line
operator|++
expr_stmt|;
block|}
name|words
operator|=
name|brk_string
argument_list|(
name|line
argument_list|,
operator|&
name|wordCount
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|newShell
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|newShell
argument_list|)
argument_list|)
expr_stmt|;
comment|/*      * Parse the specification by keyword      */
for|for
control|(
name|path
operator|=
name|NULL
operator|,
name|argc
operator|=
name|wordCount
operator|-
literal|1
operator|,
name|argv
operator|=
name|words
operator|+
literal|1
init|;
name|argc
operator|!=
literal|0
condition|;
name|argc
operator|--
operator|,
name|argv
operator|++
control|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"path="
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|path
operator|=
operator|&
name|argv
index|[
literal|0
index|]
index|[
literal|5
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"name="
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|newShell
operator|.
name|name
operator|=
operator|&
name|argv
index|[
literal|0
index|]
index|[
literal|5
index|]
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|strncmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"quiet="
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
block|{
name|newShell
operator|.
name|echoOff
operator|=
operator|&
name|argv
index|[
literal|0
index|]
index|[
literal|6
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"echo="
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|newShell
operator|.
name|echoOn
operator|=
operator|&
name|argv
index|[
literal|0
index|]
index|[
literal|5
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"filter="
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
condition|)
block|{
name|newShell
operator|.
name|noPrint
operator|=
operator|&
name|argv
index|[
literal|0
index|]
index|[
literal|7
index|]
expr_stmt|;
name|newShell
operator|.
name|noPLen
operator|=
name|strlen
argument_list|(
name|newShell
operator|.
name|noPrint
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"echoFlag="
argument_list|,
literal|9
argument_list|)
operator|==
literal|0
condition|)
block|{
name|newShell
operator|.
name|echo
operator|=
operator|&
name|argv
index|[
literal|0
index|]
index|[
literal|9
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"errFlag="
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
condition|)
block|{
name|newShell
operator|.
name|exit
operator|=
operator|&
name|argv
index|[
literal|0
index|]
index|[
literal|8
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"hasErrCtl="
argument_list|,
literal|10
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
name|c
init|=
name|argv
index|[
literal|0
index|]
index|[
literal|10
index|]
decl_stmt|;
name|newShell
operator|.
name|hasErrCtl
operator|=
operator|!
operator|(
operator|(
name|c
operator|!=
literal|'Y'
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|'y'
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|'T'
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|'t'
operator|)
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"check="
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
block|{
name|newShell
operator|.
name|errCheck
operator|=
operator|&
name|argv
index|[
literal|0
index|]
index|[
literal|6
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"ignore="
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
condition|)
block|{
name|newShell
operator|.
name|ignErr
operator|=
operator|&
name|argv
index|[
literal|0
index|]
index|[
literal|7
index|]
expr_stmt|;
block|}
else|else
block|{
name|Parse_Error
argument_list|(
name|PARSE_FATAL
argument_list|,
literal|"Unknown keyword \"%s\""
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
return|return
operator|(
name|FAILURE
operator|)
return|;
block|}
name|fullSpec
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
comment|/*      * Some checks (could be more)      */
if|if
condition|(
name|fullSpec
condition|)
block|{
if|if
condition|(
operator|(
name|newShell
operator|.
name|echoOn
operator|!=
name|NULL
operator|)
operator|^
operator|(
name|newShell
operator|.
name|echoOff
operator|!=
name|NULL
operator|)
condition|)
name|Parse_Error
argument_list|(
name|PARSE_FATAL
argument_list|,
literal|"Shell must have either both echoOff and "
literal|"echoOn or none of them"
argument_list|)
expr_stmt|;
if|if
condition|(
name|newShell
operator|.
name|echoOn
operator|!=
name|NULL
operator|&&
name|newShell
operator|.
name|echoOff
condition|)
name|newShell
operator|.
name|hasEchoCtl
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|path
operator|==
name|NULL
condition|)
block|{
comment|/* 	 * If no path was given, the user wants one of the pre-defined shells, 	 * yes? So we find the one s/he wants with the help of JobMatchShell 	 * and set things up the right way. shellPath will be set up by 	 * Job_Init. 	 */
if|if
condition|(
name|newShell
operator|.
name|name
operator|==
name|NULL
condition|)
block|{
name|Parse_Error
argument_list|(
name|PARSE_FATAL
argument_list|,
literal|"Neither path nor name specified"
argument_list|)
expr_stmt|;
return|return
operator|(
name|FAILURE
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|sh
operator|=
name|JobMatchShell
argument_list|(
name|newShell
operator|.
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|Parse_Error
argument_list|(
name|PARSE_FATAL
argument_list|,
literal|"%s: no matching shell"
argument_list|,
name|newShell
operator|.
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|FAILURE
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/* 	 * The user provided a path. If s/he gave nothing else (fullSpec is 	 * FALSE), try and find a matching shell in the ones we know of. 	 * Else we just take the specification at its word and copy it 	 * to a new location. In either case, we need to record the 	 * path the user gave for the shell. 	 */
name|free
argument_list|(
name|shellPath
argument_list|)
expr_stmt|;
name|shellPath
operator|=
name|estrdup
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|newShell
operator|.
name|name
operator|==
name|NULL
condition|)
block|{
comment|/* get the base name as the name */
name|path
operator|=
name|strrchr
argument_list|(
name|path
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
operator|==
name|NULL
condition|)
block|{
name|path
operator|=
name|shellPath
expr_stmt|;
block|}
else|else
block|{
name|path
operator|+=
literal|1
expr_stmt|;
block|}
name|newShell
operator|.
name|name
operator|=
name|path
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|fullSpec
condition|)
block|{
if|if
condition|(
operator|(
name|sh
operator|=
name|JobMatchShell
argument_list|(
name|newShell
operator|.
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|Parse_Error
argument_list|(
name|PARSE_FATAL
argument_list|,
literal|"%s: no matching shell"
argument_list|,
name|newShell
operator|.
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|FAILURE
operator|)
return|;
block|}
block|}
else|else
block|{
name|sh
operator|=
name|JobCopyShell
argument_list|(
operator|&
name|newShell
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* set the new shell */
name|JobFreeShell
argument_list|(
name|commandShell
argument_list|)
expr_stmt|;
name|commandShell
operator|=
name|sh
expr_stmt|;
name|shellName
operator|=
name|commandShell
operator|->
name|name
expr_stmt|;
return|return
operator|(
name|SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * JobInterrupt --  *	Handle the receipt of an interrupt.  *  * Results:  *	None  *  * Side Effects:  *	All children are killed. Another job will be started if the  *	.INTERRUPT target was given.  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|JobInterrupt
parameter_list|(
name|int
name|runINTERRUPT
parameter_list|,
name|int
name|signo
parameter_list|)
block|{
name|LstNode
modifier|*
name|ln
decl_stmt|;
comment|/* element in job table */
name|Job
modifier|*
name|job
decl_stmt|;
comment|/* job descriptor in that element */
name|GNode
modifier|*
name|interrupt
decl_stmt|;
comment|/* the node describing the .INTERRUPT target */
name|aborting
operator|=
name|ABORT_INTERRUPT
expr_stmt|;
for|for
control|(
name|ln
operator|=
name|Lst_First
argument_list|(
operator|&
name|jobs
argument_list|)
init|;
name|ln
operator|!=
name|NULL
condition|;
name|ln
operator|=
name|Lst_Succ
argument_list|(
name|ln
argument_list|)
control|)
block|{
name|job
operator|=
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Targ_Precious
argument_list|(
name|job
operator|->
name|node
argument_list|)
condition|)
block|{
name|char
modifier|*
name|file
init|=
operator|(
name|job
operator|->
name|node
operator|->
name|path
operator|==
name|NULL
condition|?
name|job
operator|->
name|node
operator|->
name|name
else|:
name|job
operator|->
name|node
operator|->
name|path
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|noExecute
operator|&&
name|eunlink
argument_list|(
name|file
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|Error
argument_list|(
literal|"*** %s removed"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|job
operator|->
name|pid
condition|)
block|{
name|DEBUGF
argument_list|(
name|JOB
argument_list|,
operator|(
literal|"JobInterrupt passing signal to child %d.\n"
operator|,
name|job
operator|->
name|pid
operator|)
argument_list|)
expr_stmt|;
name|KILL
argument_list|(
name|job
operator|->
name|pid
argument_list|,
name|signo
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|runINTERRUPT
operator|&&
operator|!
name|touchFlag
condition|)
block|{
comment|/* clear the interrupted flag because we would get an 	 * infinite loop otherwise */
name|interrupted
operator|=
literal|0
expr_stmt|;
name|interrupt
operator|=
name|Targ_FindNode
argument_list|(
literal|".INTERRUPT"
argument_list|,
name|TARG_NOCREATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|interrupt
operator|!=
name|NULL
condition|)
block|{
name|ignoreErrors
operator|=
name|FALSE
expr_stmt|;
name|JobStart
argument_list|(
name|interrupt
argument_list|,
name|JOB_IGNDOTS
argument_list|,
operator|(
name|Job
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
while|while
condition|(
name|nJobs
condition|)
block|{
name|Job_CatchOutput
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|Job_CatchChildren
argument_list|(
operator|!
name|usePipes
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  *-----------------------------------------------------------------------  * Job_Finish --  *	Do final processing such as the running of the commands  *	attached to the .END target.  *  * Results:  *	Number of errors reported.  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Job_Finish
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|postCommands
operator|!=
name|NULL
operator|&&
operator|!
name|Lst_IsEmpty
argument_list|(
operator|&
name|postCommands
operator|->
name|commands
argument_list|)
condition|)
block|{
if|if
condition|(
name|errors
condition|)
block|{
name|Error
argument_list|(
literal|"Errors reported so .END ignored"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|JobStart
argument_list|(
name|postCommands
argument_list|,
name|JOB_SPECIAL
operator||
name|JOB_IGNDOTS
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
while|while
condition|(
name|nJobs
condition|)
block|{
name|Job_CatchOutput
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|Job_CatchChildren
argument_list|(
operator|!
name|usePipes
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|fifoFd
operator|>=
literal|0
condition|)
block|{
name|close
argument_list|(
name|fifoFd
argument_list|)
expr_stmt|;
name|fifoFd
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|fifoMaster
condition|)
name|unlink
argument_list|(
name|fifoName
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|errors
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Job_Wait --  *	Waits for all running jobs to finish and returns. Sets 'aborting'  *	to ABORT_WAIT to prevent other jobs from starting.  *  * Results:  *	None.  *  * Side Effects:  *	Currently running jobs finish.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Job_Wait
parameter_list|(
name|void
parameter_list|)
block|{
name|aborting
operator|=
name|ABORT_WAIT
expr_stmt|;
while|while
condition|(
name|nJobs
operator|!=
literal|0
condition|)
block|{
name|Job_CatchOutput
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|Job_CatchChildren
argument_list|(
operator|!
name|usePipes
argument_list|)
expr_stmt|;
block|}
name|aborting
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Job_AbortAll --  *	Abort all currently running jobs without handling output or anything.  *	This function is to be called only in the event of a major  *	error. Most definitely NOT to be called from JobInterrupt.  *  * Results:  *	None  *  * Side Effects:  *	All children are killed, not just the firstborn  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Job_AbortAll
parameter_list|(
name|void
parameter_list|)
block|{
name|LstNode
modifier|*
name|ln
decl_stmt|;
comment|/* element in job table */
name|Job
modifier|*
name|job
decl_stmt|;
comment|/* the job descriptor in that element */
name|int
name|foo
decl_stmt|;
name|aborting
operator|=
name|ABORT_ERROR
expr_stmt|;
if|if
condition|(
name|nJobs
condition|)
block|{
for|for
control|(
name|ln
operator|=
name|Lst_First
argument_list|(
operator|&
name|jobs
argument_list|)
init|;
name|ln
operator|!=
name|NULL
condition|;
name|ln
operator|=
name|Lst_Succ
argument_list|(
name|ln
argument_list|)
control|)
block|{
name|job
operator|=
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
expr_stmt|;
comment|/* 	     * kill the child process with increasingly drastic signals to make 	     * darn sure it's dead. 	     */
name|KILL
argument_list|(
name|job
operator|->
name|pid
argument_list|,
name|SIGINT
argument_list|)
expr_stmt|;
name|KILL
argument_list|(
name|job
operator|->
name|pid
argument_list|,
name|SIGKILL
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*      * Catch as many children as want to report in at first, then give up      */
while|while
condition|(
name|waitpid
argument_list|(
operator|(
name|pid_t
operator|)
operator|-
literal|1
argument_list|,
operator|&
name|foo
argument_list|,
name|WNOHANG
argument_list|)
operator|>
literal|0
condition|)
continue|continue;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * JobRestartJobs --  *	Tries to restart stopped jobs if there are slots available.  *	Note that this tries to restart them regardless of pending errors.  *	It's not good to leave stopped jobs lying around!  *  * Results:  *	None.  *  * Side Effects:  *	Resumes(and possibly migrates) jobs.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|JobRestartJobs
parameter_list|(
name|void
parameter_list|)
block|{
while|while
condition|(
operator|!
name|jobFull
operator|&&
operator|!
name|Lst_IsEmpty
argument_list|(
operator|&
name|stoppedJobs
argument_list|)
condition|)
block|{
name|DEBUGF
argument_list|(
name|JOB
argument_list|,
operator|(
literal|"Job queue is not full. Restarting a stopped job.\n"
operator|)
argument_list|)
expr_stmt|;
name|JobRestart
argument_list|(
name|Lst_DeQueue
argument_list|(
operator|&
name|stoppedJobs
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

