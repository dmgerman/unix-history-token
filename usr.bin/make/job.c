begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1988, 1989, 1990, 1993  *	The Regents of the University of California.  All rights reserved.  * Copyright (c) 1988, 1989 by Adam de Boor  * Copyright (c) 1989 by Berkeley Softworks  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Adam de Boor.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * @(#)job.c	8.2 (Berkeley) 3/19/94  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|OLD_JOKE
end_ifndef

begin_define
define|#
directive|define
name|OLD_JOKE
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OLD_JOKE */
end_comment

begin_comment
comment|/*-  * job.c --  *	handle the creation etc. of our child processes.  *  * Interface:  *	Job_Make	Start the creation of the given target.  *  *	Job_CatchChildren  *			Check for and handle the termination of any children.  *			This must be called reasonably frequently to keep the  *			whole make going at a decent clip, since job table  *			entries aren't removed until their process is caught  *			this way. Its single argument is TRUE if the function  *			should block waiting for a child to terminate.  *  *	Job_CatchOutput	Print any output our children have produced. Should  *			also be called fairly frequently to keep the user  *			informed of what's going on. If no output is waiting,  *			it will block for a time given by the SEL_* constants,  *			below, or until output is ready.  *  *	Job_Init	Called to intialize this module. in addition, any  *			commands attached to the .BEGIN target are executed  *			before this function returns. Hence, the makefile must  *			have been parsed before this function is called.  *  *	Job_Full	Return TRUE if the job table is filled.  *  *	Job_Empty	Return TRUE if the job table is completely empty.  *  *	Job_ParseShell	Given the line following a .SHELL target, parse the  *			line as a shell specification. Returns FAILURE if the  *			spec was incorrect.  *  *	Job_Finish	Perform any final processing which needs doing. This  *			includes the execution of any commands which have  *			been/were attached to the .END target. It should only  *			be called when the job table is empty.  *  *	Job_AbortAll	Abort all currently running jobs. It doesn't handle  *			output or do anything for the jobs, just kills them.  *			It should only be called in an emergency, as it were.  *  *	Job_CheckCommands  *			Verify that the commands for a target are ok. Provide  *			them if necessary and possible.  *  *	Job_Touch	Update a target without really updating it.  *  *	Job_Wait	Wait for all currently-running jobs to finish.  *  * compat.c --  *	The routines in this file implement the full-compatibility  *	mode of PMake. Most of the special functionality of PMake  *	is available in this mode. Things not supported:  *	    - different shells.  *	    - friendly variable substitution.  *  * Interface:  *	Compat_Run	    Initialize things for this module and recreate  *			    thems as need creatin'  */
end_comment

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/select.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|USE_KQUEUE
end_ifdef

begin_include
include|#
directive|include
file|<sys/event.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<inttypes.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<utime.h>
end_include

begin_include
include|#
directive|include
file|"arch.h"
end_include

begin_include
include|#
directive|include
file|"buf.h"
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"dir.h"
end_include

begin_include
include|#
directive|include
file|"globals.h"
end_include

begin_include
include|#
directive|include
file|"GNode.h"
end_include

begin_include
include|#
directive|include
file|"job.h"
end_include

begin_include
include|#
directive|include
file|"make.h"
end_include

begin_include
include|#
directive|include
file|"parse.h"
end_include

begin_include
include|#
directive|include
file|"pathnames.h"
end_include

begin_include
include|#
directive|include
file|"str.h"
end_include

begin_include
include|#
directive|include
file|"suff.h"
end_include

begin_include
include|#
directive|include
file|"targ.h"
end_include

begin_include
include|#
directive|include
file|"util.h"
end_include

begin_include
include|#
directive|include
file|"var.h"
end_include

begin_define
define|#
directive|define
name|TMPPAT
value|"/tmp/makeXXXXXXXXXX"
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|USE_KQUEUE
end_ifndef

begin_comment
comment|/*  * The SEL_ constants determine the maximum amount of time spent in select  * before coming out to see if a child has finished. SEL_SEC is the number of  * seconds and SEL_USEC is the number of micro-seconds  */
end_comment

begin_define
define|#
directive|define
name|SEL_SEC
value|2
end_define

begin_define
define|#
directive|define
name|SEL_USEC
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !USE_KQUEUE */
end_comment

begin_comment
comment|/*  * Job Table definitions.  *  * The job "table" is kept as a linked Lst in 'jobs', with the number of  * active jobs maintained in the 'nJobs' variable. At no time will this  * exceed the value of 'maxJobs', initialized by the Job_Init function.  *  * When a job is finished, the Make_Update function is called on each of the  * parents of the node which was just remade. This takes care of the upward  * traversal of the dependency graph.  */
end_comment

begin_define
define|#
directive|define
name|JOB_BUFSIZE
value|1024
end_define

begin_typedef
typedef|typedef
struct|struct
name|Job
block|{
name|pid_t
name|pid
decl_stmt|;
comment|/* The child's process ID */
name|struct
name|GNode
modifier|*
name|node
decl_stmt|;
comment|/* The target the child is making */
comment|/* 	 * A LstNode for the first command to be saved after the job completes. 	 * This is NULL if there was no "..." in the job's commands. 	 */
name|LstNode
modifier|*
name|tailCmds
decl_stmt|;
comment|/* 	 * An FILE* for writing out the commands. This is only 	 * used before the job is actually started. 	 */
name|FILE
modifier|*
name|cmdFILE
decl_stmt|;
comment|/* 	 * A word of flags which determine how the module handles errors, 	 * echoing, etc. for the job 	 */
name|short
name|flags
decl_stmt|;
comment|/* Flags to control treatment of job */
define|#
directive|define
name|JOB_IGNERR
value|0x001
comment|/* Ignore non-zero exits */
define|#
directive|define
name|JOB_SILENT
value|0x002
comment|/* no output */
define|#
directive|define
name|JOB_SPECIAL
value|0x004
comment|/* Target is a special one. i.e. run it locally 				 * if we can't export it and maxLocal is 0 */
define|#
directive|define
name|JOB_IGNDOTS
value|0x008
comment|/* Ignore "..." lines when processing 				 * commands */
define|#
directive|define
name|JOB_FIRST
value|0x020
comment|/* Job is first job for the node */
define|#
directive|define
name|JOB_RESTART
value|0x080
comment|/* Job needs to be completely restarted */
define|#
directive|define
name|JOB_RESUME
value|0x100
comment|/* Job needs to be resumed b/c it stopped, 				 * for some reason */
define|#
directive|define
name|JOB_CONTINUING
value|0x200
comment|/* We are in the process of resuming this job. 				 * Used to avoid infinite recursion between 				 * JobFinish and JobRestart */
comment|/* union for handling shell's output */
union|union
block|{
comment|/* 		 * This part is used when usePipes is true. 		 * The output is being caught via a pipe and the descriptors 		 * of our pipe, an array in which output is line buffered and 		 * the current position in that buffer are all maintained for 		 * each job. 		 */
struct|struct
block|{
comment|/* 			 * Input side of pipe associated with 			 * job's output channel 			 */
name|int
name|op_inPipe
decl_stmt|;
comment|/* 			 * Output side of pipe associated with job's 			 * output channel 			 */
name|int
name|op_outPipe
decl_stmt|;
comment|/* 			 * Buffer for storing the output of the 			 * job, line by line 			 */
name|char
name|op_outBuf
index|[
name|JOB_BUFSIZE
operator|+
literal|1
index|]
decl_stmt|;
comment|/* Current position in op_outBuf */
name|int
name|op_curPos
decl_stmt|;
block|}
name|o_pipe
struct|;
comment|/* 		 * If usePipes is false the output is routed to a temporary 		 * file and all that is kept is the name of the file and the 		 * descriptor open to the file. 		 */
struct|struct
block|{
comment|/* Name of file to which shell output was rerouted */
name|char
name|of_outFile
index|[
sizeof|sizeof
argument_list|(
name|TMPPAT
argument_list|)
index|]
decl_stmt|;
comment|/* 			 * Stream open to the output file. Used to funnel all 			 * from a single job to one file while still allowing 			 * multiple shell invocations 			 */
name|int
name|of_outFd
decl_stmt|;
block|}
name|o_file
struct|;
block|}
name|output
union|;
comment|/* Data for tracking a shell's output */
name|TAILQ_ENTRY
argument_list|(
argument|Job
argument_list|)
name|link
expr_stmt|;
comment|/* list link */
block|}
name|Job
typedef|;
end_typedef

begin_define
define|#
directive|define
name|outPipe
value|output.o_pipe.op_outPipe
end_define

begin_define
define|#
directive|define
name|inPipe
value|output.o_pipe.op_inPipe
end_define

begin_define
define|#
directive|define
name|outBuf
value|output.o_pipe.op_outBuf
end_define

begin_define
define|#
directive|define
name|curPos
value|output.o_pipe.op_curPos
end_define

begin_define
define|#
directive|define
name|outFile
value|output.o_file.of_outFile
end_define

begin_define
define|#
directive|define
name|outFd
value|output.o_file.of_outFd
end_define

begin_expr_stmt
name|TAILQ_HEAD
argument_list|(
name|JobList
argument_list|,
name|Job
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Shell Specifications:  *  * Some special stuff goes on if a shell doesn't have error control. In such  * a case, errCheck becomes a printf template for echoing the command,  * should echoing be on and ignErr becomes another printf template for  * executing the command while ignoring the return status. If either of these  * strings is empty when hasErrCtl is FALSE, the command will be executed  * anyway as is and if it causes an error, so be it.  */
end_comment

begin_define
define|#
directive|define
name|DEF_SHELL_STRUCT
parameter_list|(
name|TAG
parameter_list|,
name|CONST
parameter_list|)
define|\
value|struct TAG {								\
comment|/*								\ 	 * the name of the shell. For Bourne and C shells, this is used	\ 	 * only to find the shell description when used as the single	\ 	 * source of a .SHELL target. For user-defined shells, this is	\ 	 * the full path of the shell.					\ 	 */
value|\ 	CONST char	*name;						\ 									\
comment|/* True if both echoOff and echoOn defined */
value|\ 	Boolean		hasEchoCtl;					\ 									\ 	CONST char	*echoOff;
comment|/* command to turn off echo */
value|\ 	CONST char	*echoOn;
comment|/* command to turn it back on */
value|\ 									\
comment|/*								\ 	 * What the shell prints, and its length, when given the	\ 	 * echo-off command. This line will not be printed when		\ 	 * received from the shell. This is usually the command which	\ 	 * was executed to turn off echoing				\ 	 */
value|\ 	CONST char	*noPrint;					\ 									\
comment|/* set if can control error checking for individual commands */
value|\ 	Boolean		hasErrCtl;					\ 									\
comment|/* string to turn error checking on */
value|\ 	CONST char	*errCheck;					\ 									\
comment|/* string to turn off error checking */
value|\ 	CONST char	*ignErr;					\ 									\ 	CONST char	*echo;
comment|/* command line flag: echo commands */
value|\ 	CONST char	*exit;
comment|/* command line flag: exit on error */
value|\ }
end_define

begin_expr_stmt
name|DEF_SHELL_STRUCT
argument_list|(
name|Shell
argument_list|,)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DEF_SHELL_STRUCT
argument_list|(
name|CShell
argument_list|,
specifier|const
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * error handling variables  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|errors
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of errors reported */
end_comment

begin_decl_stmt
specifier|static
name|int
name|aborting
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* why is the make aborting? */
end_comment

begin_define
define|#
directive|define
name|ABORT_ERROR
value|1
end_define

begin_comment
comment|/* Because of an error */
end_comment

begin_define
define|#
directive|define
name|ABORT_INTERRUPT
value|2
end_define

begin_comment
comment|/* Because it was interrupted */
end_comment

begin_define
define|#
directive|define
name|ABORT_WAIT
value|3
end_define

begin_comment
comment|/* Waiting for jobs to finish */
end_comment

begin_comment
comment|/*  * XXX: Avoid SunOS bug... FILENO() is fp->_file, and file  * is a char! So when we go above 127 we turn negative!  */
end_comment

begin_define
define|#
directive|define
name|FILENO
parameter_list|(
name|a
parameter_list|)
value|((unsigned)fileno(a))
end_define

begin_comment
comment|/*  * post-make command processing. The node postCommands is really just the  * .END target but we keep it around to avoid having to search for it  * all the time.  */
end_comment

begin_decl_stmt
specifier|static
name|GNode
modifier|*
name|postCommands
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The number of commands actually printed for a target. Should this  * number be 0, no shell will be executed.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|numCommands
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Return values from JobStart.  */
end_comment

begin_define
define|#
directive|define
name|JOB_RUNNING
value|0
end_define

begin_comment
comment|/* Job is running */
end_comment

begin_define
define|#
directive|define
name|JOB_ERROR
value|1
end_define

begin_comment
comment|/* Error in starting the job */
end_comment

begin_define
define|#
directive|define
name|JOB_FINISHED
value|2
end_define

begin_comment
comment|/* The job is already finished */
end_comment

begin_define
define|#
directive|define
name|JOB_STOPPED
value|3
end_define

begin_comment
comment|/* The job is stopped */
end_comment

begin_comment
comment|/*  * Descriptions for various shells.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|CShell
name|shells
index|[]
init|=
block|{
comment|/* 	 * CSH description. The csh can do echo control by playing 	 * with the setting of the 'echo' shell variable. Sadly, 	 * however, it is unable to do error control nicely. 	 */
block|{
literal|"csh"
block|,
name|TRUE
block|,
literal|"unset verbose"
block|,
literal|"set verbose"
block|,
literal|"unset verbose"
block|,
name|FALSE
block|,
literal|"echo \"%s\"\n"
block|,
literal|"csh -c \"%s || exit 0\""
block|,
literal|"v"
block|,
literal|"e"
block|, 	}
block|,
comment|/* 	 * SH description. Echo control is also possible and, under 	 * sun UNIX anyway, one can even control error checking. 	 */
block|{
literal|"sh"
block|,
name|TRUE
block|,
literal|"set -"
block|,
literal|"set -v"
block|,
literal|"set -"
block|,
name|TRUE
block|,
literal|"set -e"
block|,
literal|"set +e"
block|,
ifdef|#
directive|ifdef
name|OLDBOURNESHELL
name|FALSE
block|,
literal|"echo \"%s\"\n"
block|,
literal|"sh -c '%s || exit 0'\n"
block|,
endif|#
directive|endif
literal|"v"
block|,
literal|"e"
block|, 	}
block|,
comment|/* 	 * KSH description. The Korn shell has a superset of 	 * the Bourne shell's functionality. 	 */
block|{
literal|"ksh"
block|,
name|TRUE
block|,
literal|"set -"
block|,
literal|"set -v"
block|,
literal|"set -"
block|,
name|TRUE
block|,
literal|"set -e"
block|,
literal|"set +e"
block|,
literal|"v"
block|,
literal|"e"
block|, 	}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This is the shell to which we pass all commands in the Makefile.  * It is set by the Job_ParseShell function.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|Shell
modifier|*
name|commandShell
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|shellPath
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* full pathname of executable image */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|shellName
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* last component of shell */
end_comment

begin_comment
comment|/*  * The maximum number of jobs that may run. This is initialize from the  * -j argument for the leading make and from the FIFO for sub-makes.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|maxJobs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nJobs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of children currently running */
end_comment

begin_comment
comment|/* The structures that describe them */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|JobList
name|jobs
init|=
name|TAILQ_HEAD_INITIALIZER
argument_list|(
name|jobs
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Boolean
name|jobFull
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flag to tell when the job table is full. It 				 * is set TRUE when (1) the total number of 				 * running jobs equals the maximum allowed */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USE_KQUEUE
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|kqfd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* File descriptor obtained by kqueue() */
end_comment

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|fd_set
name|outputs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set of descriptors of pipes connected to 				 * the output channels of children */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|GNode
modifier|*
name|lastNode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The node for which output was most recently 				 * produced. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|targFmt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Format string to use to head output from a 				 * job when it's not the most-recent job heard 				 * from */
end_comment

begin_define
define|#
directive|define
name|TARG_FMT
value|"--- %s ---\n"
end_define

begin_comment
comment|/* Default format */
end_comment

begin_define
define|#
directive|define
name|MESSAGE
parameter_list|(
name|fp
parameter_list|,
name|gn
parameter_list|)
define|\
value|fprintf(fp, targFmt, gn->name);
end_define

begin_comment
comment|/*  * When JobStart attempts to run a job but isn't allowed to  * or when Job_CatchChildren detects a job that has  * been stopped somehow, the job is placed on the stoppedJobs queue to be run  * when the next job finishes.  *  * Lst of Job structures describing jobs that were stopped due to  * concurrency limits or externally  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|JobList
name|stoppedJobs
init|=
name|TAILQ_HEAD_INITIALIZER
argument_list|(
name|stoppedJobs
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fifoFd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Fd of our job fifo */
end_comment

begin_decl_stmt
specifier|static
name|char
name|fifoName
index|[]
init|=
literal|"/tmp/make_fifo_XXXXXXXXX"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fifoMaster
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|sig_atomic_t
name|interrupted
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|USE_PGRP
argument_list|)
operator|&&
name|defined
argument_list|(
name|SYSV
argument_list|)
end_if

begin_define
define|#
directive|define
name|KILL
parameter_list|(
name|pid
parameter_list|,
name|sig
parameter_list|)
value|killpg(-(pid), (sig))
end_define

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|defined
argument_list|(
name|USE_PGRP
argument_list|)
end_if

begin_define
define|#
directive|define
name|KILL
parameter_list|(
name|pid
parameter_list|,
name|sig
parameter_list|)
value|killpg((pid), (sig))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|KILL
parameter_list|(
name|pid
parameter_list|,
name|sig
parameter_list|)
value|kill((pid), (sig))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Grmpf... There is no way to set bits of the wait structure  * anymore with the stupid W*() macros. I liked the union wait  * stuff much more. So, we devise our own macros... This is  * really ugly, use dramamine sparingly. You have been warned.  */
end_comment

begin_define
define|#
directive|define
name|W_SETMASKED
parameter_list|(
name|st
parameter_list|,
name|val
parameter_list|,
name|fun
parameter_list|)
define|\
value|{							\ 		int sh = (int)~0;				\ 		int mask = fun(sh);				\ 								\ 		for (sh = 0; ((mask>> sh)& 1) == 0; sh++)	\ 			continue;				\ 		*(st) = (*(st)& ~mask) | ((val)<< sh);	\ 	}
end_define

begin_define
define|#
directive|define
name|W_SETTERMSIG
parameter_list|(
name|st
parameter_list|,
name|val
parameter_list|)
value|W_SETMASKED(st, val, WTERMSIG)
end_define

begin_define
define|#
directive|define
name|W_SETEXITSTATUS
parameter_list|(
name|st
parameter_list|,
name|val
parameter_list|)
value|W_SETMASKED(st, val, WEXITSTATUS)
end_define

begin_comment
comment|/**  * Information used to create a new process.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|ProcStuff
block|{
name|int
name|in
decl_stmt|;
comment|/* stdin for new process */
name|int
name|out
decl_stmt|;
comment|/* stdout for new process */
name|int
name|err
decl_stmt|;
comment|/* stderr for new process */
name|int
name|merge_errors
decl_stmt|;
comment|/* true if stderr is redirected to stdin */
name|int
name|pgroup
decl_stmt|;
comment|/* true if new process a process leader */
name|int
name|searchpath
decl_stmt|;
comment|/* true if binary should be found via $PATH */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|pid_t
name|child_pid
decl_stmt|;
block|}
name|ProcStuff
typedef|;
end_typedef

begin_function_decl
specifier|static
name|void
name|JobRestart
parameter_list|(
name|Job
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|JobStart
parameter_list|(
name|GNode
modifier|*
parameter_list|,
name|int
parameter_list|,
name|Job
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|JobDoOutput
parameter_list|(
name|Job
modifier|*
parameter_list|,
name|Boolean
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|Shell
modifier|*
name|JobMatchShell
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|JobInterrupt
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|JobRestartJobs
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|void
name|ProcExec
argument_list|(
specifier|const
name|ProcStuff
operator|*
argument_list|)
name|__dead2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The following array is used to make a fast determination of which  * commands and characters are interpreted specially by the shell.  * If a command is one of these or contains any of these characters,  * it is executed by the shell, not directly by us.  * XXX Both of these arrays should be configurable via .SHELL  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
specifier|const
modifier|*
name|sh_builtin
index|[]
init|=
block|{
literal|"alias"
block|,
literal|"cd"
block|,
literal|"eval"
block|,
literal|"exec"
block|,
literal|"exit"
block|,
literal|"read"
block|,
literal|"set"
block|,
literal|"ulimit"
block|,
literal|"unalias"
block|,
literal|"umask"
block|,
literal|"unset"
block|,
literal|"wait"
block|,
literal|":"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|sh_meta
init|=
literal|"#=|^(){};&<>*?[]:$`\\\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|GNode
modifier|*
name|curTarg
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|GNode
modifier|*
name|ENDNode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**  * Replace the current process.  */
end_comment

begin_function
specifier|static
name|void
name|ProcExec
parameter_list|(
specifier|const
name|ProcStuff
modifier|*
name|ps
parameter_list|)
block|{
if|if
condition|(
name|ps
operator|->
name|in
operator|!=
name|STDIN_FILENO
condition|)
block|{
comment|/* 		 * Redirect the child's stdin to the input fd 		 * and reset it to the beginning (again). 		 */
if|if
condition|(
name|dup2
argument_list|(
name|ps
operator|->
name|in
argument_list|,
name|STDIN_FILENO
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|Punt
argument_list|(
literal|"Cannot dup2: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|lseek
argument_list|(
name|STDIN_FILENO
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ps
operator|->
name|out
operator|!=
name|STDOUT_FILENO
condition|)
block|{
comment|/* 		 * Redirect the child's stdout to the output fd. 		 */
if|if
condition|(
name|dup2
argument_list|(
name|ps
operator|->
name|out
argument_list|,
name|STDOUT_FILENO
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|Punt
argument_list|(
literal|"Cannot dup2: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|ps
operator|->
name|out
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ps
operator|->
name|err
operator|!=
name|STDERR_FILENO
condition|)
block|{
comment|/* 		 * Redirect the child's stderr to the err fd. 		 */
if|if
condition|(
name|dup2
argument_list|(
name|ps
operator|->
name|err
argument_list|,
name|STDERR_FILENO
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|Punt
argument_list|(
literal|"Cannot dup2: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|ps
operator|->
name|err
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ps
operator|->
name|merge_errors
condition|)
block|{
comment|/* 		 * Send stderr to parent process too.  		 */
if|if
condition|(
name|dup2
argument_list|(
name|STDOUT_FILENO
argument_list|,
name|STDERR_FILENO
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|Punt
argument_list|(
literal|"Cannot dup2: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * The file descriptors for stdin, stdout, or stderr might 	 * have been marked close-on-exec.  Clear the flag on all 	 * of them. 	 */
name|fcntl
argument_list|(
name|STDIN_FILENO
argument_list|,
name|F_SETFD
argument_list|,
name|fcntl
argument_list|(
name|STDIN_FILENO
argument_list|,
name|F_GETFD
argument_list|)
operator|&
operator|(
operator|~
name|FD_CLOEXEC
operator|)
argument_list|)
expr_stmt|;
name|fcntl
argument_list|(
name|STDOUT_FILENO
argument_list|,
name|F_SETFD
argument_list|,
name|fcntl
argument_list|(
name|STDOUT_FILENO
argument_list|,
name|F_GETFD
argument_list|)
operator|&
operator|(
operator|~
name|FD_CLOEXEC
operator|)
argument_list|)
expr_stmt|;
name|fcntl
argument_list|(
name|STDERR_FILENO
argument_list|,
name|F_SETFD
argument_list|,
name|fcntl
argument_list|(
name|STDERR_FILENO
argument_list|,
name|F_GETFD
argument_list|)
operator|&
operator|(
operator|~
name|FD_CLOEXEC
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ps
operator|->
name|pgroup
condition|)
block|{
ifdef|#
directive|ifdef
name|USE_PGRP
comment|/* 		 * Become a process group leader, so we can kill it and all 		 * its descendants in one fell swoop, by killing its process 		 * family, but not commit suicide. 		 */
if|#
directive|if
name|defined
argument_list|(
name|SYSV
argument_list|)
name|setsid
argument_list|()
expr_stmt|;
else|#
directive|else
name|setpgid
argument_list|(
literal|0
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* USE_PGRP */
block|}
if|if
condition|(
name|ps
operator|->
name|searchpath
condition|)
block|{
name|execvp
argument_list|(
name|ps
operator|->
name|argv
index|[
literal|0
index|]
argument_list|,
name|ps
operator|->
name|argv
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|STDERR_FILENO
argument_list|,
name|ps
operator|->
name|argv
index|[
literal|0
index|]
argument_list|,
name|strlen
argument_list|(
name|ps
operator|->
name|argv
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|STDERR_FILENO
argument_list|,
literal|":"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|STDERR_FILENO
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|,
name|strlen
argument_list|(
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|STDERR_FILENO
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|execv
argument_list|(
name|shellPath
argument_list|,
name|ps
operator|->
name|argv
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|STDERR_FILENO
argument_list|,
literal|"Could not execute shell\n"
argument_list|,
sizeof|sizeof
argument_list|(
literal|"Could not execute shell"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Since we are the child process, exit without flushing buffers. 	 */
name|_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/**  * Wait for child process to terminate.  */
end_comment

begin_function
specifier|static
name|int
name|ProcWait
parameter_list|(
name|ProcStuff
modifier|*
name|ps
parameter_list|)
block|{
name|pid_t
name|pid
decl_stmt|;
name|int
name|status
decl_stmt|;
comment|/* 	 * Wait for the process to exit. 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
name|pid
operator|=
name|wait
argument_list|(
operator|&
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|!=
name|EINTR
condition|)
block|{
name|Fatal
argument_list|(
literal|"error in wait: %d"
argument_list|,
name|pid
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
if|if
condition|(
name|pid
operator|==
name|ps
operator|->
name|child_pid
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|interrupted
condition|)
block|{
break|break;
block|}
block|}
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * JobCatchSignal  *	Got a signal. Set global variables and hope that someone will  *	handle it.  */
end_comment

begin_function
specifier|static
name|void
name|JobCatchSig
parameter_list|(
name|int
name|signo
parameter_list|)
block|{
name|interrupted
operator|=
name|signo
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * JobPassSig --  *	Pass a signal on to all local jobs if  *	USE_PGRP is defined, then die ourselves.  *  * Side Effects:  *	We die by the same signal.  */
end_comment

begin_function
specifier|static
name|void
name|JobPassSig
parameter_list|(
name|int
name|signo
parameter_list|)
block|{
name|Job
modifier|*
name|job
decl_stmt|;
name|sigset_t
name|nmask
decl_stmt|,
name|omask
decl_stmt|;
name|struct
name|sigaction
name|act
decl_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|nmask
argument_list|)
expr_stmt|;
name|sigaddset
argument_list|(
operator|&
name|nmask
argument_list|,
name|signo
argument_list|)
expr_stmt|;
name|sigprocmask
argument_list|(
name|SIG_SETMASK
argument_list|,
operator|&
name|nmask
argument_list|,
operator|&
name|omask
argument_list|)
expr_stmt|;
name|DEBUGF
argument_list|(
name|JOB
argument_list|,
operator|(
literal|"JobPassSig(%d) called.\n"
operator|,
name|signo
operator|)
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|job
argument_list|,
argument|&jobs
argument_list|,
argument|link
argument_list|)
block|{
name|DEBUGF
argument_list|(
name|JOB
argument_list|,
operator|(
literal|"JobPassSig passing signal %d to child %jd.\n"
operator|,
name|signo
operator|,
operator|(
name|intmax_t
operator|)
name|job
operator|->
name|pid
operator|)
argument_list|)
expr_stmt|;
name|KILL
argument_list|(
name|job
operator|->
name|pid
argument_list|,
name|signo
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Deal with proper cleanup based on the signal received. We only run 	 * the .INTERRUPT target if the signal was in fact an interrupt. 	 * The other three termination signals are more of a "get out *now*" 	 * command. 	 */
if|if
condition|(
name|signo
operator|==
name|SIGINT
condition|)
block|{
name|JobInterrupt
argument_list|(
name|TRUE
argument_list|,
name|signo
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|signo
operator|==
name|SIGHUP
operator|||
name|signo
operator|==
name|SIGTERM
operator|||
name|signo
operator|==
name|SIGQUIT
condition|)
block|{
name|JobInterrupt
argument_list|(
name|FALSE
argument_list|,
name|signo
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Leave gracefully if SIGQUIT, rather than core dumping. 	 */
if|if
condition|(
name|signo
operator|==
name|SIGQUIT
condition|)
block|{
name|signo
operator|=
name|SIGINT
expr_stmt|;
block|}
comment|/* 	 * Send ourselves the signal now we've given the message to everyone 	 * else. Note we block everything else possible while we're getting 	 * the signal. This ensures that all our jobs get continued when we 	 * wake up before we take any other signal. 	 * XXX this comment seems wrong. 	 */
name|act
operator|.
name|sa_handler
operator|=
name|SIG_DFL
expr_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|act
operator|.
name|sa_mask
argument_list|)
expr_stmt|;
name|act
operator|.
name|sa_flags
operator|=
literal|0
expr_stmt|;
name|sigaction
argument_list|(
name|signo
argument_list|,
operator|&
name|act
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|DEBUGF
argument_list|(
name|JOB
argument_list|,
operator|(
literal|"JobPassSig passing signal to self, mask = %x.\n"
operator|,
operator|~
literal|0
operator|&
operator|~
operator|(
literal|1
operator|<<
operator|(
name|signo
operator|-
literal|1
operator|)
operator|)
operator|)
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|signo
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|KILL
argument_list|(
name|getpid
argument_list|()
argument_list|,
name|signo
argument_list|)
expr_stmt|;
name|signo
operator|=
name|SIGCONT
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|job
argument_list|,
argument|&jobs
argument_list|,
argument|link
argument_list|)
block|{
name|DEBUGF
argument_list|(
name|JOB
argument_list|,
operator|(
literal|"JobPassSig passing signal %d to child %jd.\n"
operator|,
name|signo
operator|,
operator|(
name|intmax_t
operator|)
name|job
operator|->
name|pid
operator|)
argument_list|)
expr_stmt|;
name|KILL
argument_list|(
name|job
operator|->
name|pid
argument_list|,
name|signo
argument_list|)
expr_stmt|;
block|}
name|sigprocmask
argument_list|(
name|SIG_SETMASK
argument_list|,
operator|&
name|omask
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|sigprocmask
argument_list|(
name|SIG_SETMASK
argument_list|,
operator|&
name|omask
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|act
operator|.
name|sa_handler
operator|=
name|JobPassSig
expr_stmt|;
name|sigaction
argument_list|(
name|signo
argument_list|,
operator|&
name|act
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * JobPrintCommand  --  *	Put out another command for the given job. If the command starts  *	with an @ or a - we process it specially. In the former case,  *	so long as the -s and -n flags weren't given to make, we stick  *	a shell-specific echoOff command in the script. In the latter,  *	we ignore errors for the entire job, unless the shell has error  *	control.  *	If the command is just "..." we take all future commands for this  *	job to be commands to be executed once the entire graph has been  *	made and return non-zero to signal that the end of the commands  *	was reached. These commands are later attached to the postCommands  *	node and executed by Job_Finish when all things are done.  *	This function is called from JobStart via LST_FOREACH.  *  * Results:  *	Always 0, unless the command was "..."  *  * Side Effects:  *	If the command begins with a '-' and the shell has no error control,  *	the JOB_IGNERR flag is set in the job descriptor.  *	If the command is "..." and we're not ignoring such things,  *	tailCmds is set to the successor node of the cmd.  *	numCommands is incremented if the command is actually printed.  */
end_comment

begin_function
specifier|static
name|int
name|JobPrintCommand
parameter_list|(
name|char
modifier|*
name|cmd
parameter_list|,
name|Job
modifier|*
name|job
parameter_list|)
block|{
name|Boolean
name|noSpecials
decl_stmt|;
comment|/* true if we shouldn't worry about 				 * inserting special commands into 				 * the input stream. */
name|Boolean
name|shutUp
init|=
name|FALSE
decl_stmt|;
comment|/* true if we put a no echo command 				 * into the command file */
name|Boolean
name|errOff
init|=
name|FALSE
decl_stmt|;
comment|/* true if we turned error checking 				 * off before printing the command 				 * and need to turn it back on */
specifier|const
name|char
modifier|*
name|cmdTemplate
decl_stmt|;
comment|/* Template to use when printing the command */
name|char
modifier|*
name|cmdStart
decl_stmt|;
comment|/* Start of expanded command */
name|LstNode
modifier|*
name|cmdNode
decl_stmt|;
comment|/* Node for replacing the command */
name|noSpecials
operator|=
operator|(
name|noExecute
operator|&&
operator|!
operator|(
name|job
operator|->
name|node
operator|->
name|type
operator|&
name|OP_MAKE
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|cmd
argument_list|,
literal|"..."
argument_list|)
operator|==
literal|0
condition|)
block|{
name|job
operator|->
name|node
operator|->
name|type
operator||=
name|OP_SAVE_CMDS
expr_stmt|;
if|if
condition|(
operator|(
name|job
operator|->
name|flags
operator|&
name|JOB_IGNDOTS
operator|)
operator|==
literal|0
condition|)
block|{
name|job
operator|->
name|tailCmds
operator|=
name|Lst_Succ
argument_list|(
name|Lst_Member
argument_list|(
operator|&
name|job
operator|->
name|node
operator|->
name|commands
argument_list|,
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
define|#
directive|define
name|DBPRINTF
parameter_list|(
name|fmt
parameter_list|,
name|arg
parameter_list|)
define|\
value|DEBUGF(JOB, (fmt, arg));		\ 	fprintf(job->cmdFILE, fmt, arg);	\ 	fflush(job->cmdFILE);
name|numCommands
operator|+=
literal|1
expr_stmt|;
comment|/* 	 * For debugging, we replace each command with the result of expanding 	 * the variables in the command. 	 */
name|cmdNode
operator|=
name|Lst_Member
argument_list|(
operator|&
name|job
operator|->
name|node
operator|->
name|commands
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|cmd
operator|=
name|Buf_Peel
argument_list|(
name|Var_Subst
argument_list|(
name|cmd
argument_list|,
name|job
operator|->
name|node
argument_list|,
name|FALSE
argument_list|)
argument_list|)
expr_stmt|;
name|cmdStart
operator|=
name|cmd
expr_stmt|;
name|Lst_Replace
argument_list|(
name|cmdNode
argument_list|,
name|cmdStart
argument_list|)
expr_stmt|;
name|cmdTemplate
operator|=
literal|"%s\n"
expr_stmt|;
comment|/* 	 * Check for leading @', -' or +'s to control echoing, error checking, 	 * and execution on -n. 	 */
while|while
condition|(
operator|*
name|cmd
operator|==
literal|'@'
operator|||
operator|*
name|cmd
operator|==
literal|'-'
operator|||
operator|*
name|cmd
operator|==
literal|'+'
condition|)
block|{
switch|switch
condition|(
operator|*
name|cmd
condition|)
block|{
case|case
literal|'@'
case|:
name|shutUp
operator|=
name|DEBUG
argument_list|(
name|LOUD
argument_list|)
condition|?
name|FALSE
else|:
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
name|errOff
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'+'
case|:
if|if
condition|(
name|noSpecials
condition|)
block|{
comment|/* 				 * We're not actually exececuting anything... 				 * but this one needs to be - use compat mode 				 * just for it. 				 */
name|Compat_RunCommand
argument_list|(
name|cmd
argument_list|,
name|job
operator|->
name|node
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
break|break;
block|}
name|cmd
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cmd
argument_list|)
condition|)
name|cmd
operator|++
expr_stmt|;
if|if
condition|(
name|shutUp
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|job
operator|->
name|flags
operator|&
name|JOB_SILENT
operator|)
operator|&&
operator|!
name|noSpecials
operator|&&
name|commandShell
operator|->
name|hasEchoCtl
condition|)
block|{
name|DBPRINTF
argument_list|(
literal|"%s\n"
argument_list|,
name|commandShell
operator|->
name|echoOff
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|shutUp
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|errOff
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|job
operator|->
name|flags
operator|&
name|JOB_IGNERR
operator|)
operator|&&
operator|!
name|noSpecials
condition|)
block|{
if|if
condition|(
name|commandShell
operator|->
name|hasErrCtl
condition|)
block|{
comment|/* 				 * We don't want the error-control commands 				 * showing up either, so we turn off echoing 				 * while executing them. We could put another 				 * field in the shell structure to tell 				 * JobDoOutput to look for this string too, 				 * but why make it any more complex than 				 * it already is? 				 */
if|if
condition|(
operator|!
operator|(
name|job
operator|->
name|flags
operator|&
name|JOB_SILENT
operator|)
operator|&&
operator|!
name|shutUp
operator|&&
name|commandShell
operator|->
name|hasEchoCtl
condition|)
block|{
name|DBPRINTF
argument_list|(
literal|"%s\n"
argument_list|,
name|commandShell
operator|->
name|echoOff
argument_list|)
expr_stmt|;
name|DBPRINTF
argument_list|(
literal|"%s\n"
argument_list|,
name|commandShell
operator|->
name|ignErr
argument_list|)
expr_stmt|;
name|DBPRINTF
argument_list|(
literal|"%s\n"
argument_list|,
name|commandShell
operator|->
name|echoOn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DBPRINTF
argument_list|(
literal|"%s\n"
argument_list|,
name|commandShell
operator|->
name|ignErr
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|commandShell
operator|->
name|ignErr
operator|&&
operator|*
name|commandShell
operator|->
name|ignErr
operator|!=
literal|'\0'
condition|)
block|{
comment|/* 				 * The shell has no error control, so we need to 				 * be weird to get it to ignore any errors from 				 * the command. If echoing is turned on, we turn 				 * it off and use the errCheck template to echo 				 * the command. Leave echoing off so the user 				 * doesn't see the weirdness we go through to 				 * ignore errors. Set cmdTemplate to use the 				 * weirdness instead of the simple "%s\n" 				 * template. 				 */
if|if
condition|(
operator|!
operator|(
name|job
operator|->
name|flags
operator|&
name|JOB_SILENT
operator|)
operator|&&
operator|!
name|shutUp
operator|&&
name|commandShell
operator|->
name|hasEchoCtl
condition|)
block|{
name|DBPRINTF
argument_list|(
literal|"%s\n"
argument_list|,
name|commandShell
operator|->
name|echoOff
argument_list|)
expr_stmt|;
name|DBPRINTF
argument_list|(
name|commandShell
operator|->
name|errCheck
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|shutUp
operator|=
name|TRUE
expr_stmt|;
block|}
name|cmdTemplate
operator|=
name|commandShell
operator|->
name|ignErr
expr_stmt|;
comment|/* 				 * The error ignoration (hee hee) is already 				 * taken care of by the ignErr template, so 				 * pretend error checking is still on. 				*/
name|errOff
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
name|errOff
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
else|else
block|{
name|errOff
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
name|DBPRINTF
argument_list|(
name|cmdTemplate
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|errOff
condition|)
block|{
comment|/* 		 * If echoing is already off, there's no point in issuing the 		 * echoOff command. Otherwise we issue it and pretend it was on 		 * for the whole command... 		 */
if|if
condition|(
operator|!
name|shutUp
operator|&&
operator|!
operator|(
name|job
operator|->
name|flags
operator|&
name|JOB_SILENT
operator|)
operator|&&
name|commandShell
operator|->
name|hasEchoCtl
condition|)
block|{
name|DBPRINTF
argument_list|(
literal|"%s\n"
argument_list|,
name|commandShell
operator|->
name|echoOff
argument_list|)
expr_stmt|;
name|shutUp
operator|=
name|TRUE
expr_stmt|;
block|}
name|DBPRINTF
argument_list|(
literal|"%s\n"
argument_list|,
name|commandShell
operator|->
name|errCheck
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|shutUp
condition|)
block|{
name|DBPRINTF
argument_list|(
literal|"%s\n"
argument_list|,
name|commandShell
operator|->
name|echoOn
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * JobClose --  *	Called to close both input and output pipes when a job is finished.  *  * Side Effects:  *	The file descriptors associated with the job are closed.  */
end_comment

begin_function
specifier|static
name|void
name|JobClose
parameter_list|(
name|Job
modifier|*
name|job
parameter_list|)
block|{
if|if
condition|(
name|usePipes
condition|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|USE_KQUEUE
argument_list|)
name|FD_CLR
argument_list|(
name|job
operator|->
name|inPipe
argument_list|,
operator|&
name|outputs
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|job
operator|->
name|outPipe
operator|!=
name|job
operator|->
name|inPipe
condition|)
block|{
name|close
argument_list|(
name|job
operator|->
name|outPipe
argument_list|)
expr_stmt|;
block|}
name|JobDoOutput
argument_list|(
name|job
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|job
operator|->
name|inPipe
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|close
argument_list|(
name|job
operator|->
name|outFd
argument_list|)
expr_stmt|;
name|JobDoOutput
argument_list|(
name|job
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * JobFinish  --  *	Do final processing for the given job including updating  *	parents and starting new jobs as available/necessary. Note  *	that we pay no attention to the JOB_IGNERR flag here.  *	This is because when we're called because of a noexecute flag  *	or something, jstat.w_status is 0 and when called from  *	Job_CatchChildren, the status is zeroed if it s/b ignored.  *  * Side Effects:  *	Some nodes may be put on the toBeMade queue.  *	Final commands for the job are placed on postCommands.  *  *	If we got an error and are aborting (aborting == ABORT_ERROR) and  *	the job list is now empty, we are done for the day.  *	If we recognized an error (errors !=0), we set the aborting flag  *	to ABORT_ERROR so no more jobs will be started.  */
end_comment

begin_function
specifier|static
name|void
name|JobFinish
parameter_list|(
name|Job
modifier|*
name|job
parameter_list|,
name|int
modifier|*
name|status
parameter_list|)
block|{
name|Boolean
name|done
decl_stmt|;
name|LstNode
modifier|*
name|ln
decl_stmt|;
if|if
condition|(
name|WIFEXITED
argument_list|(
operator|*
name|status
argument_list|)
condition|)
block|{
name|int
name|job_status
init|=
name|WEXITSTATUS
argument_list|(
operator|*
name|status
argument_list|)
decl_stmt|;
name|JobClose
argument_list|(
name|job
argument_list|)
expr_stmt|;
comment|/* 		 * Deal with ignored errors in -B mode. We need to 		 * print a message telling of the ignored error as 		 * well as setting status.w_status to 0 so the next 		 * command gets run. To do this, we set done to be 		 * TRUE if in -B mode and the job exited non-zero. 		 */
if|if
condition|(
name|job_status
operator|==
literal|0
condition|)
block|{
name|done
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|job
operator|->
name|flags
operator|&
name|JOB_IGNERR
condition|)
block|{
name|done
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * If it exited non-zero and either we're 				 * doing things our way or we're not ignoring 				 * errors, the job is finished. Similarly, if 				 * the shell died because of a signal the job 				 * is also finished. In these cases, finish 				 * out the job's output before printing the 				 * exit status... 				 */
name|done
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|job
operator|->
name|cmdFILE
operator|!=
name|NULL
operator|&&
name|job
operator|->
name|cmdFILE
operator|!=
name|stdout
condition|)
block|{
name|fclose
argument_list|(
name|job
operator|->
name|cmdFILE
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|WIFSIGNALED
argument_list|(
operator|*
name|status
argument_list|)
condition|)
block|{
if|if
condition|(
name|WTERMSIG
argument_list|(
operator|*
name|status
argument_list|)
operator|==
name|SIGCONT
condition|)
block|{
comment|/* 			 * No need to close things down or anything. 			 */
name|done
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * If it exited non-zero and either we're 			 * doing things our way or we're not ignoring 			 * errors, the job is finished. Similarly, if 			 * the shell died because of a signal the job 			 * is also finished. In these cases, finish 			 * out the job's output before printing the 			 * exit status... 			 */
name|JobClose
argument_list|(
name|job
argument_list|)
expr_stmt|;
if|if
condition|(
name|job
operator|->
name|cmdFILE
operator|!=
name|NULL
operator|&&
name|job
operator|->
name|cmdFILE
operator|!=
name|stdout
condition|)
block|{
name|fclose
argument_list|(
name|job
operator|->
name|cmdFILE
argument_list|)
expr_stmt|;
block|}
name|done
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * No need to close things down or anything. 		 */
name|done
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|WIFEXITED
argument_list|(
operator|*
name|status
argument_list|)
condition|)
block|{
if|if
condition|(
name|done
operator|||
name|DEBUG
argument_list|(
name|JOB
argument_list|)
condition|)
block|{
name|FILE
modifier|*
name|out
decl_stmt|;
if|if
condition|(
name|compatMake
operator|&&
operator|!
name|usePipes
operator|&&
operator|(
name|job
operator|->
name|flags
operator|&
name|JOB_IGNERR
operator|)
condition|)
block|{
comment|/* 				 * If output is going to a file and this job 				 * is ignoring errors, arrange to have the 				 * exit status sent to the output file as 				 * well. 				 */
name|out
operator|=
name|fdopen
argument_list|(
name|job
operator|->
name|outFd
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|out
operator|==
name|NULL
condition|)
name|Punt
argument_list|(
literal|"Cannot fdopen"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|out
operator|=
name|stdout
expr_stmt|;
block|}
name|DEBUGF
argument_list|(
name|JOB
argument_list|,
operator|(
literal|"Process %jd exited.\n"
operator|,
operator|(
name|intmax_t
operator|)
name|job
operator|->
name|pid
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|WEXITSTATUS
argument_list|(
operator|*
name|status
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|DEBUG
argument_list|(
name|JOB
argument_list|)
condition|)
block|{
if|if
condition|(
name|usePipes
operator|&&
name|job
operator|->
name|node
operator|!=
name|lastNode
condition|)
block|{
name|MESSAGE
argument_list|(
name|out
argument_list|,
name|job
operator|->
name|node
argument_list|)
expr_stmt|;
name|lastNode
operator|=
name|job
operator|->
name|node
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"*** Completed successfully\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|usePipes
operator|&&
name|job
operator|->
name|node
operator|!=
name|lastNode
condition|)
block|{
name|MESSAGE
argument_list|(
name|out
argument_list|,
name|job
operator|->
name|node
argument_list|)
expr_stmt|;
name|lastNode
operator|=
name|job
operator|->
name|node
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"*** Error code %d%s\n"
argument_list|,
name|WEXITSTATUS
argument_list|(
operator|*
name|status
argument_list|)
argument_list|,
operator|(
name|job
operator|->
name|flags
operator|&
name|JOB_IGNERR
operator|)
condition|?
literal|"(ignored)"
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|job
operator|->
name|flags
operator|&
name|JOB_IGNERR
condition|)
block|{
operator|*
name|status
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|fflush
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|WIFSIGNALED
argument_list|(
operator|*
name|status
argument_list|)
condition|)
block|{
if|if
condition|(
name|done
operator|||
name|DEBUG
argument_list|(
name|JOB
argument_list|)
operator|||
operator|(
name|WTERMSIG
argument_list|(
operator|*
name|status
argument_list|)
operator|==
name|SIGCONT
operator|)
condition|)
block|{
name|FILE
modifier|*
name|out
decl_stmt|;
if|if
condition|(
name|compatMake
operator|&&
operator|!
name|usePipes
operator|&&
operator|(
name|job
operator|->
name|flags
operator|&
name|JOB_IGNERR
operator|)
condition|)
block|{
comment|/* 				 * If output is going to a file and this job 				 * is ignoring errors, arrange to have the 				 * exit status sent to the output file as 				 * well. 				 */
name|out
operator|=
name|fdopen
argument_list|(
name|job
operator|->
name|outFd
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|out
operator|==
name|NULL
condition|)
name|Punt
argument_list|(
literal|"Cannot fdopen"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|out
operator|=
name|stdout
expr_stmt|;
block|}
if|if
condition|(
name|WTERMSIG
argument_list|(
operator|*
name|status
argument_list|)
operator|==
name|SIGCONT
condition|)
block|{
comment|/* 				 * If the beastie has continued, shift the 				 * Job from the stopped list to the running 				 * one (or re-stop it if concurrency is 				 * exceeded) and go and get another child. 				 */
if|if
condition|(
name|job
operator|->
name|flags
operator|&
operator|(
name|JOB_RESUME
operator||
name|JOB_RESTART
operator|)
condition|)
block|{
if|if
condition|(
name|usePipes
operator|&&
name|job
operator|->
name|node
operator|!=
name|lastNode
condition|)
block|{
name|MESSAGE
argument_list|(
name|out
argument_list|,
name|job
operator|->
name|node
argument_list|)
expr_stmt|;
name|lastNode
operator|=
name|job
operator|->
name|node
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"*** Continued\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|job
operator|->
name|flags
operator|&
name|JOB_CONTINUING
operator|)
condition|)
block|{
name|DEBUGF
argument_list|(
name|JOB
argument_list|,
operator|(
literal|"Warning: process %jd was not "
literal|"continuing.\n"
operator|,
operator|(
name|intmax_t
operator|)
name|job
operator|->
name|pid
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|notdef
comment|/* 					 * We don't really want to restart a 					 * job from scratch just because it 					 * continued, especially not without 					 * killing the continuing process! 					 * That's why this is ifdef'ed out. 					 * FD - 9/17/90 					 */
name|JobRestart
argument_list|(
name|job
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|job
operator|->
name|flags
operator|&=
operator|~
name|JOB_CONTINUING
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|jobs
argument_list|,
name|job
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|nJobs
operator|+=
literal|1
expr_stmt|;
name|DEBUGF
argument_list|(
name|JOB
argument_list|,
operator|(
literal|"Process %jd is continuing locally.\n"
operator|,
operator|(
name|intmax_t
operator|)
name|job
operator|->
name|pid
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nJobs
operator|==
name|maxJobs
condition|)
block|{
name|jobFull
operator|=
name|TRUE
expr_stmt|;
name|DEBUGF
argument_list|(
name|JOB
argument_list|,
operator|(
literal|"Job queue is full.\n"
operator|)
argument_list|)
expr_stmt|;
block|}
name|fflush
argument_list|(
name|out
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
if|if
condition|(
name|usePipes
operator|&&
name|job
operator|->
name|node
operator|!=
name|lastNode
condition|)
block|{
name|MESSAGE
argument_list|(
name|out
argument_list|,
name|job
operator|->
name|node
argument_list|)
expr_stmt|;
name|lastNode
operator|=
name|job
operator|->
name|node
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"*** Signal %d\n"
argument_list|,
name|WTERMSIG
argument_list|(
operator|*
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* STOPPED */
name|FILE
modifier|*
name|out
decl_stmt|;
if|if
condition|(
name|compatMake
operator|&&
operator|!
name|usePipes
operator|&&
operator|(
name|job
operator|->
name|flags
operator|&
name|JOB_IGNERR
operator|)
condition|)
block|{
comment|/* 			 * If output is going to a file and this job 			 * is ignoring errors, arrange to have the 			 * exit status sent to the output file as 			 * well. 			 */
name|out
operator|=
name|fdopen
argument_list|(
name|job
operator|->
name|outFd
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|out
operator|==
name|NULL
condition|)
name|Punt
argument_list|(
literal|"Cannot fdopen"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|out
operator|=
name|stdout
expr_stmt|;
block|}
name|DEBUGF
argument_list|(
name|JOB
argument_list|,
operator|(
literal|"Process %jd stopped.\n"
operator|,
operator|(
name|intmax_t
operator|)
name|job
operator|->
name|pid
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|usePipes
operator|&&
name|job
operator|->
name|node
operator|!=
name|lastNode
condition|)
block|{
name|MESSAGE
argument_list|(
name|out
argument_list|,
name|job
operator|->
name|node
argument_list|)
expr_stmt|;
name|lastNode
operator|=
name|job
operator|->
name|node
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"*** Stopped -- signal %d\n"
argument_list|,
name|WSTOPSIG
argument_list|(
operator|*
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|job
operator|->
name|flags
operator||=
name|JOB_RESUME
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|stoppedJobs
argument_list|,
name|job
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|out
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Now handle the -B-mode stuff. If the beast still isn't finished, 	 * try and restart the job on the next command. If JobStart says it's 	 * ok, it's ok. If there's an error, this puppy is done. 	 */
if|if
condition|(
name|compatMake
operator|&&
name|WIFEXITED
argument_list|(
operator|*
name|status
argument_list|)
operator|&&
name|Lst_Succ
argument_list|(
name|job
operator|->
name|node
operator|->
name|compat_command
argument_list|)
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
name|JobStart
argument_list|(
name|job
operator|->
name|node
argument_list|,
name|job
operator|->
name|flags
operator|&
name|JOB_IGNDOTS
argument_list|,
name|job
argument_list|)
condition|)
block|{
case|case
name|JOB_RUNNING
case|:
name|done
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|JOB_ERROR
case|:
name|done
operator|=
name|TRUE
expr_stmt|;
name|W_SETEXITSTATUS
argument_list|(
name|status
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|JOB_FINISHED
case|:
comment|/* 			 * If we got back a JOB_FINISHED code, JobStart has 			 * already called Make_Update and freed the job 			 * descriptor. We set done to false here to avoid fake 			 * cycles and double frees. JobStart needs to do the 			 * update so we can proceed up the graph when given 			 * the -n flag.. 			 */
name|done
operator|=
name|FALSE
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
else|else
block|{
name|done
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|done
operator|&&
name|aborting
operator|!=
name|ABORT_ERROR
operator|&&
name|aborting
operator|!=
name|ABORT_INTERRUPT
operator|&&
operator|*
name|status
operator|==
literal|0
condition|)
block|{
comment|/* 		 * As long as we aren't aborting and the job didn't return a 		 * non-zero status that we shouldn't ignore, we call 		 * Make_Update to update the parents. In addition, any saved 		 * commands for the node are placed on the .END target. 		 */
for|for
control|(
name|ln
operator|=
name|job
operator|->
name|tailCmds
init|;
name|ln
operator|!=
name|NULL
condition|;
name|ln
operator|=
name|LST_NEXT
argument_list|(
name|ln
argument_list|)
control|)
block|{
name|Lst_AtEnd
argument_list|(
operator|&
name|postCommands
operator|->
name|commands
argument_list|,
name|Buf_Peel
argument_list|(
name|Var_Subst
argument_list|(
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
argument_list|,
name|job
operator|->
name|node
argument_list|,
name|FALSE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|job
operator|->
name|node
operator|->
name|made
operator|=
name|MADE
expr_stmt|;
name|Make_Update
argument_list|(
name|job
operator|->
name|node
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|job
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|status
operator|!=
literal|0
condition|)
block|{
name|errors
operator|+=
literal|1
expr_stmt|;
name|free
argument_list|(
name|job
argument_list|)
expr_stmt|;
block|}
name|JobRestartJobs
argument_list|()
expr_stmt|;
comment|/* 	 * Set aborting if any error. 	 */
if|if
condition|(
name|errors
operator|&&
operator|!
name|keepgoing
operator|&&
name|aborting
operator|!=
name|ABORT_INTERRUPT
condition|)
block|{
comment|/* 		 * If we found any errors in this batch of children and the -k 		 * flag wasn't given, we set the aborting flag so no more jobs 		 * get started. 		 */
name|aborting
operator|=
name|ABORT_ERROR
expr_stmt|;
block|}
if|if
condition|(
name|aborting
operator|==
name|ABORT_ERROR
operator|&&
name|Job_Empty
argument_list|()
condition|)
block|{
comment|/* 		 * If we are aborting and the job table is now empty, we finish. 		 */
name|Finish
argument_list|(
name|errors
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * Job_Touch  *	Touch the given target. Called by JobStart when the -t flag was  *	given.  Prints messages unless told to be silent.  *  * Side Effects:  *	The data modification of the file is changed. In addition, if the  *	file did not exist, it is created.  */
end_comment

begin_function
name|void
name|Job_Touch
parameter_list|(
name|GNode
modifier|*
name|gn
parameter_list|,
name|Boolean
name|silent
parameter_list|)
block|{
name|int
name|streamID
decl_stmt|;
comment|/* ID of stream opened to do the touch */
name|struct
name|utimbuf
name|times
decl_stmt|;
comment|/* Times for utime() call */
if|if
condition|(
name|gn
operator|->
name|type
operator|&
operator|(
name|OP_JOIN
operator||
name|OP_USE
operator||
name|OP_EXEC
operator||
name|OP_OPTIONAL
operator|)
condition|)
block|{
comment|/* 		 * .JOIN, .USE, .ZEROTIME and .OPTIONAL targets are "virtual" 		 * targets and, as such, shouldn't really be created. 		 */
return|return;
block|}
if|if
condition|(
operator|!
name|silent
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"touch %s\n"
argument_list|,
name|gn
operator|->
name|name
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|noExecute
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|gn
operator|->
name|type
operator|&
name|OP_ARCHV
condition|)
block|{
name|Arch_Touch
argument_list|(
name|gn
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|gn
operator|->
name|type
operator|&
name|OP_LIB
condition|)
block|{
name|Arch_TouchLib
argument_list|(
name|gn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|file
init|=
name|gn
operator|->
name|path
condition|?
name|gn
operator|->
name|path
else|:
name|gn
operator|->
name|name
decl_stmt|;
name|times
operator|.
name|actime
operator|=
name|times
operator|.
name|modtime
operator|=
name|now
expr_stmt|;
if|if
condition|(
name|utime
argument_list|(
name|file
argument_list|,
operator|&
name|times
argument_list|)
operator|<
literal|0
condition|)
block|{
name|streamID
operator|=
name|open
argument_list|(
name|file
argument_list|,
name|O_RDWR
operator||
name|O_CREAT
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
if|if
condition|(
name|streamID
operator|>=
literal|0
condition|)
block|{
name|char
name|c
decl_stmt|;
comment|/* 				 * Read and write a byte to the file to change 				 * the modification time, then close the file. 				 */
if|if
condition|(
name|read
argument_list|(
name|streamID
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
operator|==
literal|1
condition|)
block|{
name|lseek
argument_list|(
name|streamID
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|streamID
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|streamID
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"*** couldn't touch %s: %s"
argument_list|,
name|file
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/**  * Job_CheckCommands  *	Make sure the given node has all the commands it needs.  *  * Results:  *	TRUE if the commands list is/was ok.  *  * Side Effects:  *	The node will have commands from the .DEFAULT rule added to it  *	if it needs them.  */
end_comment

begin_function
name|Boolean
name|Job_CheckCommands
parameter_list|(
name|GNode
modifier|*
name|gn
parameter_list|,
name|void
function_decl|(
modifier|*
name|abortProc
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
modifier|...
parameter_list|)
parameter_list|)
block|{
if|if
condition|(
name|OP_NOP
argument_list|(
name|gn
operator|->
name|type
argument_list|)
operator|&&
name|Lst_IsEmpty
argument_list|(
operator|&
name|gn
operator|->
name|commands
argument_list|)
operator|&&
operator|(
name|gn
operator|->
name|type
operator|&
name|OP_LIB
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * No commands. Look for .DEFAULT rule from which we might infer 		 * commands. 		 */
if|if
condition|(
name|DEFAULT
operator|!=
name|NULL
operator|&&
operator|!
name|Lst_IsEmpty
argument_list|(
operator|&
name|DEFAULT
operator|->
name|commands
argument_list|)
condition|)
block|{
name|char
modifier|*
name|p1
decl_stmt|;
comment|/* 			 * Make only looks for a .DEFAULT if the node was 			 * never the target of an operator, so that's what we 			 * do too. If a .DEFAULT was given, we substitute its 			 * commands for gn's commands and set the IMPSRC 			 * variable to be the target's name The DEFAULT node 			 * acts like a transformation rule, in that gn also 			 * inherits any attributes or sources attached to 			 * .DEFAULT itself. 			 */
name|Make_HandleUse
argument_list|(
name|DEFAULT
argument_list|,
name|gn
argument_list|)
expr_stmt|;
name|Var_Set
argument_list|(
name|IMPSRC
argument_list|,
name|Var_Value
argument_list|(
name|TARGET
argument_list|,
name|gn
argument_list|,
operator|&
name|p1
argument_list|)
argument_list|,
name|gn
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Dir_MTime
argument_list|(
name|gn
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * The node wasn't the target of an operator we have 			 * no .DEFAULT rule to go on and the target doesn't 			 * already exist. There's nothing more we can do for 			 * this branch. If the -k flag wasn't given, we stop 			 * in our tracks, otherwise we just don't update 			 * this node's parents so they never get examined. 			 */
specifier|static
specifier|const
name|char
name|msg
index|[]
init|=
literal|"make: don't know how to make"
decl_stmt|;
if|if
condition|(
name|gn
operator|->
name|type
operator|&
name|OP_OPTIONAL
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s %s(ignored)\n"
argument_list|,
name|msg
argument_list|,
name|gn
operator|->
name|name
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|keepgoing
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s %s(continuing)\n"
argument_list|,
name|msg
argument_list|,
name|gn
operator|->
name|name
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
else|else
block|{
if|#
directive|if
name|OLD_JOKE
if|if
condition|(
name|strcmp
argument_list|(
name|gn
operator|->
name|name
argument_list|,
literal|"love"
argument_list|)
operator|==
literal|0
condition|)
call|(
modifier|*
name|abortProc
call|)
argument_list|(
literal|"Not war."
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
call|(
modifier|*
name|abortProc
call|)
argument_list|(
literal|"%s %s. Stop"
argument_list|,
name|msg
argument_list|,
name|gn
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
block|}
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * JobExec  *	Execute the shell for the given job. Called from JobStart and  *	JobRestart.  *  * Side Effects:  *	A shell is executed, outputs is altered and the Job structure added  *	to the job table.  */
end_comment

begin_function
specifier|static
name|void
name|JobExec
parameter_list|(
name|Job
modifier|*
name|job
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|ProcStuff
name|ps
decl_stmt|;
if|if
condition|(
name|DEBUG
argument_list|(
name|JOB
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|;
name|DEBUGF
argument_list|(
name|JOB
argument_list|,
operator|(
literal|"Running %s\n"
operator|,
name|job
operator|->
name|node
operator|->
name|name
operator|)
argument_list|)
expr_stmt|;
name|DEBUGF
argument_list|(
name|JOB
argument_list|,
operator|(
literal|"\tCommand: "
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|argv
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
name|DEBUGF
argument_list|(
name|JOB
argument_list|,
operator|(
literal|"%s "
operator|,
name|argv
index|[
name|i
index|]
operator|)
argument_list|)
expr_stmt|;
block|}
name|DEBUGF
argument_list|(
name|JOB
argument_list|,
operator|(
literal|"\n"
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Some jobs produce no output and it's disconcerting to have 	 * no feedback of their running (since they produce no output, the 	 * banner with their name in it never appears). This is an attempt to 	 * provide that feedback, even if nothing follows it. 	 */
if|if
condition|(
name|lastNode
operator|!=
name|job
operator|->
name|node
operator|&&
operator|(
name|job
operator|->
name|flags
operator|&
name|JOB_FIRST
operator|)
operator|&&
operator|!
operator|(
name|job
operator|->
name|flags
operator|&
name|JOB_SILENT
operator|)
condition|)
block|{
name|MESSAGE
argument_list|(
name|stdout
argument_list|,
name|job
operator|->
name|node
argument_list|)
expr_stmt|;
name|lastNode
operator|=
name|job
operator|->
name|node
expr_stmt|;
block|}
name|ps
operator|.
name|in
operator|=
name|FILENO
argument_list|(
name|job
operator|->
name|cmdFILE
argument_list|)
expr_stmt|;
if|if
condition|(
name|usePipes
condition|)
block|{
comment|/* 		 * Set up the child's output to be routed through the 		 * pipe we've created for it. 		 */
name|ps
operator|.
name|out
operator|=
name|job
operator|->
name|outPipe
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * We're capturing output in a file, so we duplicate 		 * the descriptor to the temporary file into the 		 * standard output. 		 */
name|ps
operator|.
name|out
operator|=
name|job
operator|->
name|outFd
expr_stmt|;
block|}
name|ps
operator|.
name|err
operator|=
name|STDERR_FILENO
expr_stmt|;
name|ps
operator|.
name|merge_errors
operator|=
literal|1
expr_stmt|;
name|ps
operator|.
name|pgroup
operator|=
literal|1
expr_stmt|;
name|ps
operator|.
name|searchpath
operator|=
literal|0
expr_stmt|;
name|ps
operator|.
name|argv
operator|=
name|argv
expr_stmt|;
comment|/* 	 * Fork.  Warning since we are doing vfork() instead of fork(), 	 * do not allocate memory in the child process! 	 */
if|if
condition|(
operator|(
name|ps
operator|.
name|child_pid
operator|=
name|vfork
argument_list|()
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|Punt
argument_list|(
literal|"Cannot fork"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ps
operator|.
name|child_pid
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Child 		 */
if|if
condition|(
name|fifoFd
operator|>=
literal|0
condition|)
name|close
argument_list|(
name|fifoFd
argument_list|)
expr_stmt|;
name|ProcExec
argument_list|(
operator|&
name|ps
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
comment|/* 	 * Parent 	 */
name|job
operator|->
name|pid
operator|=
name|ps
operator|.
name|child_pid
expr_stmt|;
if|if
condition|(
name|usePipes
operator|&&
operator|(
name|job
operator|->
name|flags
operator|&
name|JOB_FIRST
operator|)
condition|)
block|{
comment|/* 		 * The first time a job is run for a node, we set the 		 * current position in the buffer to the beginning and 		 * mark another stream to watch in the outputs mask. 		 */
ifdef|#
directive|ifdef
name|USE_KQUEUE
name|struct
name|kevent
name|kev
index|[
literal|2
index|]
decl_stmt|;
endif|#
directive|endif
name|job
operator|->
name|curPos
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|USE_KQUEUE
argument_list|)
name|EV_SET
argument_list|(
operator|&
name|kev
index|[
literal|0
index|]
argument_list|,
name|job
operator|->
name|inPipe
argument_list|,
name|EVFILT_READ
argument_list|,
name|EV_ADD
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|job
argument_list|)
expr_stmt|;
name|EV_SET
argument_list|(
operator|&
name|kev
index|[
literal|1
index|]
argument_list|,
name|job
operator|->
name|pid
argument_list|,
name|EVFILT_PROC
argument_list|,
name|EV_ADD
operator||
name|EV_ONESHOT
argument_list|,
name|NOTE_EXIT
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|kevent
argument_list|(
name|kqfd
argument_list|,
name|kev
argument_list|,
literal|2
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * kevent() will fail if the job is already 			 * finished 			 */
if|if
condition|(
name|errno
operator|!=
name|EINTR
operator|&&
name|errno
operator|!=
name|EBADF
operator|&&
name|errno
operator|!=
name|ESRCH
condition|)
name|Punt
argument_list|(
literal|"kevent: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|FD_SET
argument_list|(
name|job
operator|->
name|inPipe
argument_list|,
operator|&
name|outputs
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USE_KQUEUE */
block|}
if|if
condition|(
name|job
operator|->
name|cmdFILE
operator|!=
name|NULL
operator|&&
name|job
operator|->
name|cmdFILE
operator|!=
name|stdout
condition|)
block|{
name|fclose
argument_list|(
name|job
operator|->
name|cmdFILE
argument_list|)
expr_stmt|;
name|job
operator|->
name|cmdFILE
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * Now the job is actually running, add it to the table. 	 */
name|nJobs
operator|+=
literal|1
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|jobs
argument_list|,
name|job
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|nJobs
operator|==
name|maxJobs
condition|)
block|{
name|jobFull
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * JobMakeArgv  *	Create the argv needed to execute the shell for a given job.  */
end_comment

begin_function
specifier|static
name|void
name|JobMakeArgv
parameter_list|(
name|Job
modifier|*
name|job
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|argc
decl_stmt|;
specifier|static
name|char
name|args
index|[
literal|10
index|]
decl_stmt|;
comment|/* For merged arguments */
name|argv
index|[
literal|0
index|]
operator|=
name|shellName
expr_stmt|;
name|argc
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|commandShell
operator|->
name|exit
operator|&&
operator|*
name|commandShell
operator|->
name|exit
operator|!=
literal|'-'
operator|)
operator|||
operator|(
name|commandShell
operator|->
name|echo
operator|&&
operator|*
name|commandShell
operator|->
name|echo
operator|!=
literal|'-'
operator|)
condition|)
block|{
comment|/* 		 * At least one of the flags doesn't have a minus before it, so 		 * merge them together. Have to do this because the *(&(@*#*&#$# 		 * Bourne shell thinks its second argument is a file to source. 		 * Grrrr. Note the ten-character limitation on the combined 		 * arguments. 		 */
name|sprintf
argument_list|(
name|args
argument_list|,
literal|"-%s%s"
argument_list|,
operator|(
name|job
operator|->
name|flags
operator|&
name|JOB_IGNERR
operator|)
condition|?
literal|""
else|:
name|commandShell
operator|->
name|exit
condition|?
name|commandShell
operator|->
name|exit
else|:
literal|""
argument_list|,
operator|(
name|job
operator|->
name|flags
operator|&
name|JOB_SILENT
operator|)
condition|?
literal|""
else|:
name|commandShell
operator|->
name|echo
condition|?
name|commandShell
operator|->
name|echo
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
index|[
literal|1
index|]
condition|)
block|{
name|argv
index|[
name|argc
index|]
operator|=
name|args
expr_stmt|;
name|argc
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|job
operator|->
name|flags
operator|&
name|JOB_IGNERR
operator|)
operator|&&
name|commandShell
operator|->
name|exit
condition|)
block|{
name|argv
index|[
name|argc
index|]
operator|=
name|commandShell
operator|->
name|exit
expr_stmt|;
name|argc
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|job
operator|->
name|flags
operator|&
name|JOB_SILENT
operator|)
operator|&&
name|commandShell
operator|->
name|echo
condition|)
block|{
name|argv
index|[
name|argc
index|]
operator|=
name|commandShell
operator|->
name|echo
expr_stmt|;
name|argc
operator|++
expr_stmt|;
block|}
block|}
name|argv
index|[
name|argc
index|]
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * JobRestart  *	Restart a job that stopped for some reason. The job must be neither  *	on the jobs nor on the stoppedJobs list.  *  * Side Effects:  *	jobFull will be set if the job couldn't be run.  */
end_comment

begin_function
specifier|static
name|void
name|JobRestart
parameter_list|(
name|Job
modifier|*
name|job
parameter_list|)
block|{
if|if
condition|(
name|job
operator|->
name|flags
operator|&
name|JOB_RESTART
condition|)
block|{
comment|/* 		 * Set up the control arguments to the shell. This is based on 		 * the flags set earlier for this job. If the JOB_IGNERR flag 		 * is clear, the 'exit' flag of the commandShell is used to 		 * cause it to exit upon receiving an error. If the JOB_SILENT 		 * flag is clear, the 'echo' flag of the commandShell is used 		 * to get it to start echoing as soon as it starts 		 * processing commands. 		 */
name|char
modifier|*
name|argv
index|[
literal|4
index|]
decl_stmt|;
name|JobMakeArgv
argument_list|(
name|job
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|DEBUGF
argument_list|(
name|JOB
argument_list|,
operator|(
literal|"Restarting %s..."
operator|,
name|job
operator|->
name|node
operator|->
name|name
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nJobs
operator|>=
name|maxJobs
operator|&&
operator|!
operator|(
name|job
operator|->
name|flags
operator|&
name|JOB_SPECIAL
operator|)
condition|)
block|{
comment|/* 			 * Not allowed to run -- put it back on the hold 			 * queue and mark the table full 			 */
name|DEBUGF
argument_list|(
name|JOB
argument_list|,
operator|(
literal|"holding\n"
operator|)
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|stoppedJobs
argument_list|,
name|job
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|jobFull
operator|=
name|TRUE
expr_stmt|;
name|DEBUGF
argument_list|(
name|JOB
argument_list|,
operator|(
literal|"Job queue is full.\n"
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
comment|/* 			 * Job may be run locally. 			 */
name|DEBUGF
argument_list|(
name|JOB
argument_list|,
operator|(
literal|"running locally\n"
operator|)
argument_list|)
expr_stmt|;
block|}
name|JobExec
argument_list|(
name|job
argument_list|,
name|argv
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * The job has stopped and needs to be restarted. 		 * Why it stopped, we don't know... 		 */
name|DEBUGF
argument_list|(
name|JOB
argument_list|,
operator|(
literal|"Resuming %s..."
operator|,
name|job
operator|->
name|node
operator|->
name|name
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|nJobs
operator|<
name|maxJobs
operator|||
operator|(
operator|(
name|job
operator|->
name|flags
operator|&
name|JOB_SPECIAL
operator|)
operator|&&
name|maxJobs
operator|==
literal|0
operator|)
operator|)
operator|&&
name|nJobs
operator|!=
name|maxJobs
condition|)
block|{
comment|/* 			 * If we haven't reached the concurrency limit already 			 * (or the job must be run and maxJobs is 0), it's ok 			 * to resume it. 			 */
name|Boolean
name|error
decl_stmt|;
name|int
name|status
decl_stmt|;
name|error
operator|=
operator|(
name|KILL
argument_list|(
name|job
operator|->
name|pid
argument_list|,
name|SIGCONT
argument_list|)
operator|!=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
comment|/* 				 * Make sure the user knows we've continued 				 * the beast and actually put the thing in the 				 * job table. 				 */
name|job
operator|->
name|flags
operator||=
name|JOB_CONTINUING
expr_stmt|;
name|status
operator|=
literal|0
expr_stmt|;
name|W_SETTERMSIG
argument_list|(
operator|&
name|status
argument_list|,
name|SIGCONT
argument_list|)
expr_stmt|;
name|JobFinish
argument_list|(
name|job
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
name|job
operator|->
name|flags
operator|&=
operator|~
operator|(
name|JOB_RESUME
operator||
name|JOB_CONTINUING
operator|)
expr_stmt|;
name|DEBUGF
argument_list|(
name|JOB
argument_list|,
operator|(
literal|"done\n"
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Error
argument_list|(
literal|"couldn't resume %s: %s"
argument_list|,
name|job
operator|->
name|node
operator|->
name|name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
literal|0
expr_stmt|;
name|W_SETEXITSTATUS
argument_list|(
operator|&
name|status
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|JobFinish
argument_list|(
name|job
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 			* Job cannot be restarted. Mark the table as full and 			* place the job back on the list of stopped jobs. 			*/
name|DEBUGF
argument_list|(
name|JOB
argument_list|,
operator|(
literal|"table full\n"
operator|)
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|stoppedJobs
argument_list|,
name|job
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|jobFull
operator|=
name|TRUE
expr_stmt|;
name|DEBUGF
argument_list|(
name|JOB
argument_list|,
operator|(
literal|"Job queue is full.\n"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/**  * JobStart  *	Start a target-creation process going for the target described  *	by the graph node gn.  *  * Results:  *	JOB_ERROR if there was an error in the commands, JOB_FINISHED  *	if there isn't actually anything left to do for the job and  *	JOB_RUNNING if the job has been started.  *  * Side Effects:  *	A new Job node is created and added to the list of running  *	jobs. PMake is forked and a child shell created.  */
end_comment

begin_function
specifier|static
name|int
name|JobStart
parameter_list|(
name|GNode
modifier|*
name|gn
parameter_list|,
name|int
name|flags
parameter_list|,
name|Job
modifier|*
name|previous
parameter_list|)
block|{
name|Job
modifier|*
name|job
decl_stmt|;
comment|/* new job descriptor */
name|char
modifier|*
name|argv
index|[
literal|4
index|]
decl_stmt|;
comment|/* Argument vector to shell */
name|Boolean
name|cmdsOK
decl_stmt|;
comment|/* true if the nodes commands were all right */
name|Boolean
name|noExec
decl_stmt|;
comment|/* Set true if we decide not to run the job */
name|int
name|tfd
decl_stmt|;
comment|/* File descriptor for temp file */
name|LstNode
modifier|*
name|ln
decl_stmt|;
name|char
name|tfile
index|[
sizeof|sizeof
argument_list|(
name|TMPPAT
argument_list|)
index|]
decl_stmt|;
if|if
condition|(
name|interrupted
condition|)
block|{
name|JobPassSig
argument_list|(
name|interrupted
argument_list|)
expr_stmt|;
return|return
operator|(
name|JOB_ERROR
operator|)
return|;
block|}
if|if
condition|(
name|previous
operator|!=
name|NULL
condition|)
block|{
name|previous
operator|->
name|flags
operator|&=
operator|~
operator|(
name|JOB_FIRST
operator||
name|JOB_IGNERR
operator||
name|JOB_SILENT
operator|)
expr_stmt|;
name|job
operator|=
name|previous
expr_stmt|;
block|}
else|else
block|{
name|job
operator|=
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Job
argument_list|)
argument_list|)
expr_stmt|;
name|flags
operator||=
name|JOB_FIRST
expr_stmt|;
block|}
name|job
operator|->
name|node
operator|=
name|gn
expr_stmt|;
name|job
operator|->
name|tailCmds
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Set the initial value of the flags for this job based on the global 	 * ones and the node's attributes... Any flags supplied by the caller 	 * are also added to the field. 	 */
name|job
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|Targ_Ignore
argument_list|(
name|gn
argument_list|)
condition|)
block|{
name|job
operator|->
name|flags
operator||=
name|JOB_IGNERR
expr_stmt|;
block|}
if|if
condition|(
name|Targ_Silent
argument_list|(
name|gn
argument_list|)
condition|)
block|{
name|job
operator|->
name|flags
operator||=
name|JOB_SILENT
expr_stmt|;
block|}
name|job
operator|->
name|flags
operator||=
name|flags
expr_stmt|;
comment|/* 	 * Check the commands now so any attributes from .DEFAULT have a chance 	 * to migrate to the node. 	 */
if|if
condition|(
operator|!
name|compatMake
operator|&&
operator|(
name|job
operator|->
name|flags
operator|&
name|JOB_FIRST
operator|)
condition|)
block|{
name|cmdsOK
operator|=
name|Job_CheckCommands
argument_list|(
name|gn
argument_list|,
name|Error
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cmdsOK
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* 	 * If the -n flag wasn't given, we open up OUR (not the child's) 	 * temporary file to stuff commands in it. The thing is rd/wr so we 	 * don't need to reopen it to feed it to the shell. If the -n flag 	 * *was* given, we just set the file to be stdout. Cute, huh? 	 */
if|if
condition|(
operator|(
name|gn
operator|->
name|type
operator|&
name|OP_MAKE
operator|)
operator|||
operator|(
operator|!
name|noExecute
operator|&&
operator|!
name|touchFlag
operator|)
condition|)
block|{
comment|/* 		 * We're serious here, but if the commands were bogus, we're 		 * also dead... 		 */
if|if
condition|(
operator|!
name|cmdsOK
condition|)
block|{
name|DieHorribly
argument_list|()
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|tfile
argument_list|,
name|TMPPAT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tfd
operator|=
name|mkstemp
argument_list|(
name|tfile
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|Punt
argument_list|(
literal|"Cannot create temp file: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|job
operator|->
name|cmdFILE
operator|=
name|fdopen
argument_list|(
name|tfd
argument_list|,
literal|"w+"
argument_list|)
expr_stmt|;
name|eunlink
argument_list|(
name|tfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|job
operator|->
name|cmdFILE
operator|==
name|NULL
condition|)
block|{
name|close
argument_list|(
name|tfd
argument_list|)
expr_stmt|;
name|Punt
argument_list|(
literal|"Could not open %s"
argument_list|,
name|tfile
argument_list|)
expr_stmt|;
block|}
name|fcntl
argument_list|(
name|FILENO
argument_list|(
name|job
operator|->
name|cmdFILE
argument_list|)
argument_list|,
name|F_SETFD
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 		 * Send the commands to the command file, flush all its 		 * buffers then rewind and remove the thing. 		 */
name|noExec
operator|=
name|FALSE
expr_stmt|;
comment|/* 		 * Used to be backwards; replace when start doing multiple 		 * commands per shell. 		 */
if|if
condition|(
name|compatMake
condition|)
block|{
comment|/* 			 * Be compatible: If this is the first time for this 			 * node, verify its commands are ok and open the 			 * commands list for sequential access by later 			 * invocations of JobStart. Once that is done, we take 			 * the next command off the list and print it to the 			 * command file. If the command was an ellipsis, note 			 * that there's nothing more to execute. 			 */
if|if
condition|(
name|job
operator|->
name|flags
operator|&
name|JOB_FIRST
condition|)
name|gn
operator|->
name|compat_command
operator|=
name|Lst_First
argument_list|(
operator|&
name|gn
operator|->
name|commands
argument_list|)
expr_stmt|;
else|else
name|gn
operator|->
name|compat_command
operator|=
name|Lst_Succ
argument_list|(
name|gn
operator|->
name|compat_command
argument_list|)
expr_stmt|;
if|if
condition|(
name|gn
operator|->
name|compat_command
operator|==
name|NULL
operator|||
name|JobPrintCommand
argument_list|(
name|Lst_Datum
argument_list|(
name|gn
operator|->
name|compat_command
argument_list|)
argument_list|,
name|job
argument_list|)
condition|)
name|noExec
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|noExec
operator|&&
operator|!
operator|(
name|job
operator|->
name|flags
operator|&
name|JOB_FIRST
operator|)
condition|)
block|{
comment|/* 				 * If we're not going to execute anything, the 				 * job is done and we need to close down the 				 * various file descriptors we've opened for 				 * output, then call JobDoOutput to catch the 				 * final characters or send the file to the 				 * screen... Note that the i/o streams are only 				 * open if this isn't the first job. Note also 				 * that this could not be done in 				 * Job_CatchChildren b/c it wasn't clear if 				 * there were more commands to execute or not... 				 */
name|JobClose
argument_list|(
name|job
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 			 * We can do all the commands at once. hooray for sanity 			 */
name|numCommands
operator|=
literal|0
expr_stmt|;
name|LST_FOREACH
argument_list|(
argument|ln
argument_list|,
argument|&gn->commands
argument_list|)
block|{
if|if
condition|(
name|JobPrintCommand
argument_list|(
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
argument_list|,
name|job
argument_list|)
condition|)
break|break;
block|}
comment|/* 			 * If we didn't print out any commands to the shell 			 * script, there's not much point in executing the 			 * shell, is there? 			 */
if|if
condition|(
name|numCommands
operator|==
literal|0
condition|)
block|{
name|noExec
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|noExecute
condition|)
block|{
comment|/* 		 * Not executing anything -- just print all the commands to 		 * stdout in one fell swoop. This will still set up 		 * job->tailCmds correctly. 		 */
if|if
condition|(
name|lastNode
operator|!=
name|gn
condition|)
block|{
name|MESSAGE
argument_list|(
name|stdout
argument_list|,
name|gn
argument_list|)
expr_stmt|;
name|lastNode
operator|=
name|gn
expr_stmt|;
block|}
name|job
operator|->
name|cmdFILE
operator|=
name|stdout
expr_stmt|;
comment|/* 		 * Only print the commands if they're ok, but don't die if 		 * they're not -- just let the user know they're bad and keep 		 * going. It doesn't do any harm in this case and may do 		 * some good. 		 */
if|if
condition|(
name|cmdsOK
condition|)
block|{
name|LST_FOREACH
argument_list|(
argument|ln
argument_list|,
argument|&gn->commands
argument_list|)
block|{
if|if
condition|(
name|JobPrintCommand
argument_list|(
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
argument_list|,
name|job
argument_list|)
condition|)
break|break;
block|}
block|}
comment|/* 		* Don't execute the shell, thank you. 		*/
name|noExec
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Just touch the target and note that no shell should be 		 * executed. Set cmdFILE to stdout to make life easier. Check 		 * the commands, too, but don't die if they're no good -- it 		 * does no harm to keep working up the graph. 		 */
name|job
operator|->
name|cmdFILE
operator|=
name|stdout
expr_stmt|;
name|Job_Touch
argument_list|(
name|gn
argument_list|,
name|job
operator|->
name|flags
operator|&
name|JOB_SILENT
argument_list|)
expr_stmt|;
name|noExec
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* 	 * If we're not supposed to execute a shell, don't. 	 */
if|if
condition|(
name|noExec
condition|)
block|{
comment|/* 		 * Unlink and close the command file if we opened one 		 */
if|if
condition|(
name|job
operator|->
name|cmdFILE
operator|!=
name|stdout
condition|)
block|{
if|if
condition|(
name|job
operator|->
name|cmdFILE
operator|!=
name|NULL
condition|)
name|fclose
argument_list|(
name|job
operator|->
name|cmdFILE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * We only want to work our way up the graph if we aren't here 		 * because the commands for the job were no good. 		*/
if|if
condition|(
name|cmdsOK
condition|)
block|{
if|if
condition|(
name|aborting
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|ln
operator|=
name|job
operator|->
name|tailCmds
init|;
name|ln
operator|!=
name|NULL
condition|;
name|ln
operator|=
name|LST_NEXT
argument_list|(
name|ln
argument_list|)
control|)
block|{
name|Lst_AtEnd
argument_list|(
operator|&
name|postCommands
operator|->
name|commands
argument_list|,
name|Buf_Peel
argument_list|(
name|Var_Subst
argument_list|(
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
argument_list|,
name|job
operator|->
name|node
argument_list|,
name|FALSE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|job
operator|->
name|node
operator|->
name|made
operator|=
name|MADE
expr_stmt|;
name|Make_Update
argument_list|(
name|job
operator|->
name|node
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|job
argument_list|)
expr_stmt|;
return|return
operator|(
name|JOB_FINISHED
operator|)
return|;
block|}
else|else
block|{
name|free
argument_list|(
name|job
argument_list|)
expr_stmt|;
return|return
operator|(
name|JOB_ERROR
operator|)
return|;
block|}
block|}
else|else
block|{
name|fflush
argument_list|(
name|job
operator|->
name|cmdFILE
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Set up the control arguments to the shell. This is based on the flags 	 * set earlier for this job. 	 */
name|JobMakeArgv
argument_list|(
name|job
argument_list|,
name|argv
argument_list|)
expr_stmt|;
comment|/* 	 * If we're using pipes to catch output, create the pipe by which we'll 	 * get the shell's output. If we're using files, print out that we're 	 * starting a job and then set up its temporary-file name. 	 */
if|if
condition|(
operator|!
name|compatMake
operator|||
operator|(
name|job
operator|->
name|flags
operator|&
name|JOB_FIRST
operator|)
condition|)
block|{
if|if
condition|(
name|usePipes
condition|)
block|{
name|int
name|fd
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|pipe
argument_list|(
name|fd
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|Punt
argument_list|(
literal|"Cannot create pipe: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|job
operator|->
name|inPipe
operator|=
name|fd
index|[
literal|0
index|]
expr_stmt|;
name|job
operator|->
name|outPipe
operator|=
name|fd
index|[
literal|1
index|]
expr_stmt|;
name|fcntl
argument_list|(
name|job
operator|->
name|inPipe
argument_list|,
name|F_SETFD
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fcntl
argument_list|(
name|job
operator|->
name|outPipe
argument_list|,
name|F_SETFD
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Remaking `%s'\n"
argument_list|,
name|gn
operator|->
name|name
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|job
operator|->
name|outFile
argument_list|,
name|TMPPAT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|job
operator|->
name|outFd
operator|=
name|mkstemp
argument_list|(
name|job
operator|->
name|outFile
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|Punt
argument_list|(
literal|"cannot create temp file: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|fcntl
argument_list|(
name|job
operator|->
name|outFd
argument_list|,
name|F_SETFD
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nJobs
operator|>=
name|maxJobs
operator|&&
operator|!
operator|(
name|job
operator|->
name|flags
operator|&
name|JOB_SPECIAL
operator|)
operator|&&
name|maxJobs
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * We've hit the limit of concurrency, so put the job on hold 		 * until some other job finishes. Note that the special jobs 		 * (.BEGIN, .INTERRUPT and .END) may be run even when the 		 * limit has been reached (e.g. when maxJobs == 0). 		 */
name|jobFull
operator|=
name|TRUE
expr_stmt|;
name|DEBUGF
argument_list|(
name|JOB
argument_list|,
operator|(
literal|"Can only run job locally.\n"
operator|)
argument_list|)
expr_stmt|;
name|job
operator|->
name|flags
operator||=
name|JOB_RESTART
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|stoppedJobs
argument_list|,
name|job
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|nJobs
operator|>=
name|maxJobs
condition|)
block|{
comment|/* 			 * If we're running this job as a special case 			 * (see above), at least say the table is full. 			 */
name|jobFull
operator|=
name|TRUE
expr_stmt|;
name|DEBUGF
argument_list|(
name|JOB
argument_list|,
operator|(
literal|"Local job queue is full.\n"
operator|)
argument_list|)
expr_stmt|;
block|}
name|JobExec
argument_list|(
name|job
argument_list|,
name|argv
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|JOB_RUNNING
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|JobOutput
parameter_list|(
name|Job
modifier|*
name|job
parameter_list|,
name|char
modifier|*
name|cp
parameter_list|,
name|char
modifier|*
name|endp
parameter_list|,
name|int
name|msg
parameter_list|)
block|{
name|char
modifier|*
name|ecp
decl_stmt|;
if|if
condition|(
name|commandShell
operator|->
name|noPrint
condition|)
block|{
name|ecp
operator|=
name|strstr
argument_list|(
name|cp
argument_list|,
name|commandShell
operator|->
name|noPrint
argument_list|)
expr_stmt|;
while|while
condition|(
name|ecp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|cp
operator|!=
name|ecp
condition|)
block|{
operator|*
name|ecp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|msg
operator|&&
name|job
operator|->
name|node
operator|!=
name|lastNode
condition|)
block|{
name|MESSAGE
argument_list|(
name|stdout
argument_list|,
name|job
operator|->
name|node
argument_list|)
expr_stmt|;
name|lastNode
operator|=
name|job
operator|->
name|node
expr_stmt|;
block|}
comment|/* 				 * The only way there wouldn't be a newline 				 * after this line is if it were the last in 				 * the buffer. However, since the non-printable 				 * comes after it, there must be a newline, so 				 * we don't print one. 				 */
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
name|cp
operator|=
name|ecp
operator|+
name|strlen
argument_list|(
name|commandShell
operator|->
name|noPrint
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|endp
condition|)
block|{
comment|/* 				 * Still more to print, look again after 				 * skipping the whitespace following the 				 * non-printable command.... 				 */
name|cp
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|==
literal|' '
operator|||
operator|*
name|cp
operator|==
literal|'\t'
operator|||
operator|*
name|cp
operator|==
literal|'\n'
condition|)
block|{
name|cp
operator|++
expr_stmt|;
block|}
name|ecp
operator|=
name|strstr
argument_list|(
name|cp
argument_list|,
name|commandShell
operator|->
name|noPrint
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return
operator|(
name|cp
operator|)
return|;
block|}
block|}
block|}
return|return
operator|(
name|cp
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * JobDoOutput  *	This function is called at different times depending on  *	whether the user has specified that output is to be collected  *	via pipes or temporary files. In the former case, we are called  *	whenever there is something to read on the pipe. We collect more  *	output from the given job and store it in the job's outBuf. If  *	this makes up a line, we print it tagged by the job's identifier,  *	as necessary.  *	If output has been collected in a temporary file, we open the  *	file and read it line by line, transfering it to our own  *	output channel until the file is empty. At which point we  *	remove the temporary file.  *	In both cases, however, we keep our figurative eye out for the  *	'noPrint' line for the shell from which the output came. If  *	we recognize a line, we don't print it. If the command is not  *	alone on the line (the character after it is not \0 or \n), we  *	do print whatever follows it.  *  * Side Effects:  *	curPos may be shifted as may the contents of outBuf.  */
end_comment

begin_function
specifier|static
name|void
name|JobDoOutput
parameter_list|(
name|Job
modifier|*
name|job
parameter_list|,
name|Boolean
name|finish
parameter_list|)
block|{
name|Boolean
name|gotNL
init|=
name|FALSE
decl_stmt|;
comment|/* true if got a newline */
name|Boolean
name|fbuf
decl_stmt|;
comment|/* true if our buffer filled up */
name|int
name|nr
decl_stmt|;
comment|/* number of bytes read */
name|int
name|i
decl_stmt|;
comment|/* auxiliary index into outBuf */
name|int
name|max
decl_stmt|;
comment|/* limit for i (end of current data) */
name|int
name|nRead
decl_stmt|;
comment|/* (Temporary) number of bytes read */
name|FILE
modifier|*
name|oFILE
decl_stmt|;
comment|/* Stream pointer to shell's output file */
name|char
name|inLine
index|[
literal|132
index|]
decl_stmt|;
if|if
condition|(
name|usePipes
condition|)
block|{
comment|/* 		 * Read as many bytes as will fit in the buffer. 		 */
name|end_loop
label|:
name|gotNL
operator|=
name|FALSE
expr_stmt|;
name|fbuf
operator|=
name|FALSE
expr_stmt|;
name|nRead
operator|=
name|read
argument_list|(
name|job
operator|->
name|inPipe
argument_list|,
operator|&
name|job
operator|->
name|outBuf
index|[
name|job
operator|->
name|curPos
index|]
argument_list|,
name|JOB_BUFSIZE
operator|-
name|job
operator|->
name|curPos
argument_list|)
expr_stmt|;
comment|/* 		 * Check for interrupt here too, because the above read may 		 * block when the child process is stopped. In this case the 		 * interrupt will unblock it (we don't use SA_RESTART). 		 */
if|if
condition|(
name|interrupted
condition|)
name|JobPassSig
argument_list|(
name|interrupted
argument_list|)
expr_stmt|;
if|if
condition|(
name|nRead
operator|<
literal|0
condition|)
block|{
name|DEBUGF
argument_list|(
name|JOB
argument_list|,
operator|(
literal|"JobDoOutput(piperead)"
operator|)
argument_list|)
expr_stmt|;
name|nr
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|nr
operator|=
name|nRead
expr_stmt|;
block|}
comment|/* 		 * If we hit the end-of-file (the job is dead), we must flush 		 * its remaining output, so pretend we read a newline if 		 * there's any output remaining in the buffer. 		 * Also clear the 'finish' flag so we stop looping. 		 */
if|if
condition|(
name|nr
operator|==
literal|0
operator|&&
name|job
operator|->
name|curPos
operator|!=
literal|0
condition|)
block|{
name|job
operator|->
name|outBuf
index|[
name|job
operator|->
name|curPos
index|]
operator|=
literal|'\n'
expr_stmt|;
name|nr
operator|=
literal|1
expr_stmt|;
name|finish
operator|=
name|FALSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nr
operator|==
literal|0
condition|)
block|{
name|finish
operator|=
name|FALSE
expr_stmt|;
block|}
comment|/* 		 * Look for the last newline in the bytes we just got. If there 		 * is one, break out of the loop with 'i' as its index and 		 * gotNL set TRUE. 		*/
name|max
operator|=
name|job
operator|->
name|curPos
operator|+
name|nr
expr_stmt|;
for|for
control|(
name|i
operator|=
name|job
operator|->
name|curPos
operator|+
name|nr
operator|-
literal|1
init|;
name|i
operator|>=
name|job
operator|->
name|curPos
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|job
operator|->
name|outBuf
index|[
name|i
index|]
operator|==
literal|'\n'
condition|)
block|{
name|gotNL
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|job
operator|->
name|outBuf
index|[
name|i
index|]
operator|==
literal|'\0'
condition|)
block|{
comment|/* 				 * Why? 				 */
name|job
operator|->
name|outBuf
index|[
name|i
index|]
operator|=
literal|' '
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|gotNL
condition|)
block|{
name|job
operator|->
name|curPos
operator|+=
name|nr
expr_stmt|;
if|if
condition|(
name|job
operator|->
name|curPos
operator|==
name|JOB_BUFSIZE
condition|)
block|{
comment|/* 				 * If we've run out of buffer space, we have 				 * no choice but to print the stuff. sigh. 				 */
name|fbuf
operator|=
name|TRUE
expr_stmt|;
name|i
operator|=
name|job
operator|->
name|curPos
expr_stmt|;
block|}
block|}
if|if
condition|(
name|gotNL
operator|||
name|fbuf
condition|)
block|{
comment|/* 			 * Need to send the output to the screen. Null terminate 			 * it first, overwriting the newline character if there 			 * was one. So long as the line isn't one we should 			 * filter (according to the shell description), we print 			 * the line, preceded by a target banner if this target 			 * isn't the same as the one for which we last printed 			 * something. The rest of the data in the buffer are 			 * then shifted down to the start of the buffer and 			 * curPos is set accordingly. 			 */
name|job
operator|->
name|outBuf
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|job
operator|->
name|curPos
condition|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|cp
operator|=
name|JobOutput
argument_list|(
name|job
argument_list|,
name|job
operator|->
name|outBuf
argument_list|,
operator|&
name|job
operator|->
name|outBuf
index|[
name|i
index|]
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* 				 * There's still more in that buffer. This time, 				 * though, we know there's no newline at the 				 * end, so we add one of our own free will. 				 */
if|if
condition|(
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|job
operator|->
name|node
operator|!=
name|lastNode
condition|)
block|{
name|MESSAGE
argument_list|(
name|stdout
argument_list|,
name|job
operator|->
name|node
argument_list|)
expr_stmt|;
name|lastNode
operator|=
name|job
operator|->
name|node
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s%s"
argument_list|,
name|cp
argument_list|,
name|gotNL
condition|?
literal|"\n"
else|:
literal|""
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|i
operator|<
name|max
operator|-
literal|1
condition|)
block|{
comment|/* shift the remaining characters down */
name|memcpy
argument_list|(
name|job
operator|->
name|outBuf
argument_list|,
operator|&
name|job
operator|->
name|outBuf
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
name|max
operator|-
operator|(
name|i
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|job
operator|->
name|curPos
operator|=
name|max
operator|-
operator|(
name|i
operator|+
literal|1
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * We have written everything out, so we just 				 * start over from the start of the buffer. 				 * No copying. No nothing. 				 */
name|job
operator|->
name|curPos
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|finish
condition|)
block|{
comment|/* 			 * If the finish flag is true, we must loop until we hit 			 * end-of-file on the pipe. This is guaranteed to happen 			 * eventually since the other end of the pipe is now 			 * closed (we closed it explicitly and the child has 			 * exited). When we do get an EOF, finish will be set 			 * FALSE and we'll fall through and out. 			 */
goto|goto
name|end_loop
goto|;
block|}
block|}
else|else
block|{
comment|/* 		 * We've been called to retrieve the output of the job from the 		 * temporary file where it's been squirreled away. This consists 		 * of opening the file, reading the output line by line, being 		 * sure not to print the noPrint line for the shell we used, 		 * then close and remove the temporary file. Very simple. 		 * 		 * Change to read in blocks and do FindSubString type things 		 * as for pipes? That would allow for "@echo -n..." 		 */
name|oFILE
operator|=
name|fopen
argument_list|(
name|job
operator|->
name|outFile
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|oFILE
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Results of making %s:\n"
argument_list|,
name|job
operator|->
name|node
operator|->
name|name
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|inLine
argument_list|,
sizeof|sizeof
argument_list|(
name|inLine
argument_list|)
argument_list|,
name|oFILE
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|endp
decl_stmt|,
modifier|*
name|oendp
decl_stmt|;
name|cp
operator|=
name|inLine
expr_stmt|;
name|oendp
operator|=
name|endp
operator|=
name|inLine
operator|+
name|strlen
argument_list|(
name|inLine
argument_list|)
expr_stmt|;
if|if
condition|(
name|endp
index|[
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
block|{
operator|*
operator|--
name|endp
operator|=
literal|'\0'
expr_stmt|;
block|}
name|cp
operator|=
name|JobOutput
argument_list|(
name|job
argument_list|,
name|inLine
argument_list|,
name|endp
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* 				 * There's still more in that buffer. This time, 				 * though, we know there's no newline at the 				 * end, so we add one of our own free will. 				 */
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|endp
operator|!=
name|oendp
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
name|fclose
argument_list|(
name|oFILE
argument_list|)
expr_stmt|;
name|eunlink
argument_list|(
name|job
operator|->
name|outFile
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/**  * Job_CatchChildren  *	Handle the exit of a child. Called from Make_Make.  *  * Side Effects:  *	The job descriptor is removed from the list of children.  *  * Notes:  *	We do waits, blocking or not, according to the wisdom of our  *	caller, until there are no more children to report. For each  *	job, call JobFinish to finish things off. This will take care of  *	putting jobs on the stoppedJobs queue.  */
end_comment

begin_function
name|void
name|Job_CatchChildren
parameter_list|(
name|Boolean
name|block
parameter_list|)
block|{
name|pid_t
name|pid
decl_stmt|;
comment|/* pid of dead child */
name|Job
modifier|*
name|job
decl_stmt|;
comment|/* job descriptor for dead child */
name|int
name|status
decl_stmt|;
comment|/* Exit/termination status */
comment|/* 	 * Don't even bother if we know there's no one around. 	 */
if|if
condition|(
name|nJobs
operator|==
literal|0
condition|)
block|{
return|return;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|pid
operator|=
name|waitpid
argument_list|(
operator|(
name|pid_t
operator|)
operator|-
literal|1
argument_list|,
operator|&
name|status
argument_list|,
operator|(
name|block
condition|?
literal|0
else|:
name|WNOHANG
operator|)
operator||
name|WUNTRACED
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|<=
literal|0
condition|)
break|break;
name|DEBUGF
argument_list|(
name|JOB
argument_list|,
operator|(
literal|"Process %jd exited or stopped.\n"
operator|,
operator|(
name|intmax_t
operator|)
name|pid
operator|)
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|job
argument_list|,
argument|&jobs
argument_list|,
argument|link
argument_list|)
block|{
if|if
condition|(
name|job
operator|->
name|pid
operator|==
name|pid
condition|)
break|break;
block|}
if|if
condition|(
name|job
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|WIFSIGNALED
argument_list|(
name|status
argument_list|)
operator|&&
operator|(
name|WTERMSIG
argument_list|(
name|status
argument_list|)
operator|==
name|SIGCONT
operator|)
condition|)
block|{
name|TAILQ_FOREACH
argument_list|(
argument|job
argument_list|,
argument|&jobs
argument_list|,
argument|link
argument_list|)
block|{
if|if
condition|(
name|job
operator|->
name|pid
operator|==
name|pid
condition|)
break|break;
block|}
if|if
condition|(
name|job
operator|==
name|NULL
condition|)
block|{
name|Error
argument_list|(
literal|"Resumed child (%jd) "
literal|"not in table"
argument_list|,
operator|(
name|intmax_t
operator|)
name|pid
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|TAILQ_REMOVE
argument_list|(
operator|&
name|stoppedJobs
argument_list|,
name|job
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Error
argument_list|(
literal|"Child (%jd) not in table?"
argument_list|,
operator|(
name|intmax_t
operator|)
name|pid
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
else|else
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|jobs
argument_list|,
name|job
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|nJobs
operator|-=
literal|1
expr_stmt|;
if|if
condition|(
name|fifoFd
operator|>=
literal|0
operator|&&
name|maxJobs
operator|>
literal|1
condition|)
block|{
name|write
argument_list|(
name|fifoFd
argument_list|,
literal|"+"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|maxJobs
operator|--
expr_stmt|;
if|if
condition|(
name|nJobs
operator|>=
name|maxJobs
condition|)
name|jobFull
operator|=
name|TRUE
expr_stmt|;
else|else
name|jobFull
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
name|DEBUGF
argument_list|(
name|JOB
argument_list|,
operator|(
literal|"Job queue is no longer full.\n"
operator|)
argument_list|)
expr_stmt|;
name|jobFull
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
name|JobFinish
argument_list|(
name|job
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|interrupted
condition|)
name|JobPassSig
argument_list|(
name|interrupted
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Job_CatchOutput  *	Catch the output from our children, if we're using  *	pipes do so. Otherwise just block time until we get a  *	signal(most likely a SIGCHLD) since there's no point in  *	just spinning when there's nothing to do and the reaping  *	of a child can wait for a while.  *  * Side Effects:  *	Output is read from pipes if we're piping.  * -----------------------------------------------------------------------  */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|USE_KQUEUE
name|Job_CatchOutput
parameter_list|(
name|int
name|flag
name|__unused
parameter_list|)
else|#
directive|else
function|Job_CatchOutput
parameter_list|(
name|int
name|flag
parameter_list|)
endif|#
directive|endif
block|{
name|int
name|nfds
decl_stmt|;
ifdef|#
directive|ifdef
name|USE_KQUEUE
define|#
directive|define
name|KEV_SIZE
value|4
name|struct
name|kevent
name|kev
index|[
name|KEV_SIZE
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
else|#
directive|else
name|struct
name|timeval
name|timeout
decl_stmt|;
name|fd_set
name|readfds
decl_stmt|;
name|Job
modifier|*
name|job
decl_stmt|;
endif|#
directive|endif
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|usePipes
condition|)
block|{
ifdef|#
directive|ifdef
name|USE_KQUEUE
if|if
condition|(
operator|(
name|nfds
operator|=
name|kevent
argument_list|(
name|kqfd
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|kev
argument_list|,
name|KEV_SIZE
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EINTR
condition|)
name|Punt
argument_list|(
literal|"kevent: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|interrupted
condition|)
name|JobPassSig
argument_list|(
name|interrupted
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfds
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|kev
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|EV_ERROR
condition|)
block|{
name|warnc
argument_list|(
name|kev
index|[
name|i
index|]
operator|.
name|data
argument_list|,
literal|"kevent"
argument_list|)
expr_stmt|;
continue|continue;
block|}
switch|switch
condition|(
name|kev
index|[
name|i
index|]
operator|.
name|filter
condition|)
block|{
case|case
name|EVFILT_READ
case|:
name|JobDoOutput
argument_list|(
name|kev
index|[
name|i
index|]
operator|.
name|udata
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
break|break;
case|case
name|EVFILT_PROC
case|:
comment|/* 					 * Just wake up and let 					 * Job_CatchChildren() collect the 					 * terminated job. 					 */
break|break;
block|}
block|}
block|}
else|#
directive|else
name|readfds
operator|=
name|outputs
expr_stmt|;
name|timeout
operator|.
name|tv_sec
operator|=
name|SEL_SEC
expr_stmt|;
name|timeout
operator|.
name|tv_usec
operator|=
name|SEL_USEC
expr_stmt|;
if|if
condition|(
name|flag
operator|&&
name|jobFull
operator|&&
name|fifoFd
operator|>=
literal|0
condition|)
name|FD_SET
argument_list|(
name|fifoFd
argument_list|,
operator|&
name|readfds
argument_list|)
expr_stmt|;
name|nfds
operator|=
name|select
argument_list|(
name|FD_SETSIZE
argument_list|,
operator|&
name|readfds
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|nfds
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|interrupted
condition|)
name|JobPassSig
argument_list|(
name|interrupted
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|fifoFd
operator|>=
literal|0
operator|&&
name|FD_ISSET
argument_list|(
name|fifoFd
argument_list|,
operator|&
name|readfds
argument_list|)
condition|)
block|{
if|if
condition|(
operator|--
name|nfds
operator|<=
literal|0
condition|)
return|return;
block|}
name|job
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|jobs
argument_list|)
expr_stmt|;
while|while
condition|(
name|nfds
operator|!=
literal|0
operator|&&
name|job
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|FD_ISSET
argument_list|(
name|job
operator|->
name|inPipe
argument_list|,
operator|&
name|readfds
argument_list|)
condition|)
block|{
name|JobDoOutput
argument_list|(
name|job
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|nfds
operator|--
expr_stmt|;
block|}
name|job
operator|=
name|TAILQ_NEXT
argument_list|(
name|job
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* !USE_KQUEUE */
block|}
block|}
end_function

begin_comment
comment|/**  * Job_Make  *	Start the creation of a target. Basically a front-end for  *	JobStart used by the Make module.  *  * Side Effects:  *	Another job is started.  */
end_comment

begin_function
name|void
name|Job_Make
parameter_list|(
name|GNode
modifier|*
name|gn
parameter_list|)
block|{
name|JobStart
argument_list|(
name|gn
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * JobCopyShell  *	Make a new copy of the shell structure including a copy of the strings  *	in it. This also defaults some fields in case they are NULL.  *  * Returns:  *	The function returns a pointer to the new shell structure.  */
end_comment

begin_function
specifier|static
name|struct
name|Shell
modifier|*
name|JobCopyShell
parameter_list|(
specifier|const
name|struct
name|Shell
modifier|*
name|osh
parameter_list|)
block|{
name|struct
name|Shell
modifier|*
name|nsh
decl_stmt|;
name|nsh
operator|=
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|nsh
argument_list|)
argument_list|)
expr_stmt|;
name|nsh
operator|->
name|name
operator|=
name|estrdup
argument_list|(
name|osh
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|osh
operator|->
name|echoOff
operator|!=
name|NULL
condition|)
name|nsh
operator|->
name|echoOff
operator|=
name|estrdup
argument_list|(
name|osh
operator|->
name|echoOff
argument_list|)
expr_stmt|;
else|else
name|nsh
operator|->
name|echoOff
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|osh
operator|->
name|echoOn
operator|!=
name|NULL
condition|)
name|nsh
operator|->
name|echoOn
operator|=
name|estrdup
argument_list|(
name|osh
operator|->
name|echoOn
argument_list|)
expr_stmt|;
else|else
name|nsh
operator|->
name|echoOn
operator|=
name|NULL
expr_stmt|;
name|nsh
operator|->
name|hasEchoCtl
operator|=
name|osh
operator|->
name|hasEchoCtl
expr_stmt|;
if|if
condition|(
name|osh
operator|->
name|noPrint
operator|!=
name|NULL
condition|)
name|nsh
operator|->
name|noPrint
operator|=
name|estrdup
argument_list|(
name|osh
operator|->
name|noPrint
argument_list|)
expr_stmt|;
else|else
name|nsh
operator|->
name|noPrint
operator|=
name|NULL
expr_stmt|;
name|nsh
operator|->
name|hasErrCtl
operator|=
name|osh
operator|->
name|hasErrCtl
expr_stmt|;
if|if
condition|(
name|osh
operator|->
name|errCheck
operator|==
name|NULL
condition|)
name|nsh
operator|->
name|errCheck
operator|=
name|estrdup
argument_list|(
literal|""
argument_list|)
expr_stmt|;
else|else
name|nsh
operator|->
name|errCheck
operator|=
name|estrdup
argument_list|(
name|osh
operator|->
name|errCheck
argument_list|)
expr_stmt|;
if|if
condition|(
name|osh
operator|->
name|ignErr
operator|==
name|NULL
condition|)
name|nsh
operator|->
name|ignErr
operator|=
name|estrdup
argument_list|(
literal|"%s"
argument_list|)
expr_stmt|;
else|else
name|nsh
operator|->
name|ignErr
operator|=
name|estrdup
argument_list|(
name|osh
operator|->
name|ignErr
argument_list|)
expr_stmt|;
if|if
condition|(
name|osh
operator|->
name|echo
operator|==
name|NULL
condition|)
name|nsh
operator|->
name|echo
operator|=
name|estrdup
argument_list|(
literal|""
argument_list|)
expr_stmt|;
else|else
name|nsh
operator|->
name|echo
operator|=
name|estrdup
argument_list|(
name|osh
operator|->
name|echo
argument_list|)
expr_stmt|;
if|if
condition|(
name|osh
operator|->
name|exit
operator|==
name|NULL
condition|)
name|nsh
operator|->
name|exit
operator|=
name|estrdup
argument_list|(
literal|""
argument_list|)
expr_stmt|;
else|else
name|nsh
operator|->
name|exit
operator|=
name|estrdup
argument_list|(
name|osh
operator|->
name|exit
argument_list|)
expr_stmt|;
return|return
operator|(
name|nsh
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * JobFreeShell  *	Free a shell structure and all associated strings.  */
end_comment

begin_function
specifier|static
name|void
name|JobFreeShell
parameter_list|(
name|struct
name|Shell
modifier|*
name|sh
parameter_list|)
block|{
if|if
condition|(
name|sh
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|sh
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sh
operator|->
name|echoOff
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sh
operator|->
name|echoOn
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sh
operator|->
name|noPrint
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sh
operator|->
name|errCheck
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sh
operator|->
name|ignErr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sh
operator|->
name|echo
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sh
operator|->
name|exit
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sh
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|Shell_Init
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|commandShell
operator|==
name|NULL
condition|)
name|commandShell
operator|=
name|JobMatchShell
argument_list|(
name|shells
index|[
name|DEFSHELL
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|shellPath
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * The user didn't specify a shell to use, so we are using the 		 * default one... Both the absolute path and the last component 		 * must be set. The last component is taken from the 'name' 		 * field of the default shell description pointed-to by 		 * commandShell. All default shells are located in 		 * PATH_DEFSHELLDIR. 		 */
name|shellName
operator|=
name|commandShell
operator|->
name|name
expr_stmt|;
name|shellPath
operator|=
name|str_concat
argument_list|(
name|PATH_DEFSHELLDIR
argument_list|,
name|shellName
argument_list|,
name|STR_ADDSLASH
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * Job_Init  *	Initialize the process module, given a maximum number of jobs.  *  * Side Effects:  *	lists and counters are initialized  */
end_comment

begin_function
name|void
name|Job_Init
parameter_list|(
name|int
name|maxproc
parameter_list|)
block|{
name|GNode
modifier|*
name|begin
decl_stmt|;
comment|/* node for commands to do at the very start */
specifier|const
name|char
modifier|*
name|env
decl_stmt|;
name|struct
name|sigaction
name|sa
decl_stmt|;
name|fifoFd
operator|=
operator|-
literal|1
expr_stmt|;
name|env
operator|=
name|getenv
argument_list|(
literal|"MAKE_JOBS_FIFO"
argument_list|)
expr_stmt|;
if|if
condition|(
name|env
operator|==
name|NULL
operator|&&
name|maxproc
operator|>
literal|1
condition|)
block|{
comment|/* 		 * We did not find the environment variable so we are the 		 * leader. Create the fifo, open it, write one char per 		 * allowed job into the pipe. 		 */
name|mktemp
argument_list|(
name|fifoName
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mkfifo
argument_list|(
name|fifoName
argument_list|,
literal|0600
argument_list|)
condition|)
block|{
name|fifoFd
operator|=
name|open
argument_list|(
name|fifoName
argument_list|,
name|O_RDWR
operator||
name|O_NONBLOCK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fifoFd
operator|>=
literal|0
condition|)
block|{
name|fifoMaster
operator|=
literal|1
expr_stmt|;
name|fcntl
argument_list|(
name|fifoFd
argument_list|,
name|F_SETFL
argument_list|,
name|O_NONBLOCK
argument_list|)
expr_stmt|;
name|env
operator|=
name|fifoName
expr_stmt|;
name|setenv
argument_list|(
literal|"MAKE_JOBS_FIFO"
argument_list|,
name|env
argument_list|,
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|maxproc
operator|--
operator|>
literal|0
condition|)
block|{
name|write
argument_list|(
name|fifoFd
argument_list|,
literal|"+"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* The master make does not get a magic token */
name|jobFull
operator|=
name|TRUE
expr_stmt|;
name|maxJobs
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|unlink
argument_list|(
name|fifoName
argument_list|)
expr_stmt|;
name|env
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|env
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * We had the environment variable so we are a slave. 		 * Open fifo and give ourselves a magic token which represents 		 * the token our parent make has grabbed to start his make 		 * process. Otherwise the sub-makes would gobble up tokens and 		 * the proper number of tokens to specify to -j would depend 		 * on the depth of the tree and the order of execution. 		 */
name|fifoFd
operator|=
name|open
argument_list|(
name|env
argument_list|,
name|O_RDWR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fifoFd
operator|>=
literal|0
condition|)
block|{
name|fcntl
argument_list|(
name|fifoFd
argument_list|,
name|F_SETFL
argument_list|,
name|O_NONBLOCK
argument_list|)
expr_stmt|;
name|maxJobs
operator|=
literal|1
expr_stmt|;
name|jobFull
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fifoFd
operator|<=
literal|0
condition|)
block|{
name|maxJobs
operator|=
name|maxproc
expr_stmt|;
name|jobFull
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{ 	}
name|nJobs
operator|=
literal|0
expr_stmt|;
name|aborting
operator|=
literal|0
expr_stmt|;
name|errors
operator|=
literal|0
expr_stmt|;
name|lastNode
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|maxJobs
operator|==
literal|1
operator|&&
name|fifoFd
operator|<
literal|0
operator|)
operator|||
name|beVerbose
operator|==
literal|0
condition|)
block|{
comment|/* 		 * If only one job can run at a time, there's no need for a 		 * banner, no is there? 		 */
name|targFmt
operator|=
literal|""
expr_stmt|;
block|}
else|else
block|{
name|targFmt
operator|=
name|TARG_FMT
expr_stmt|;
block|}
name|Shell_Init
argument_list|()
expr_stmt|;
comment|/* 	 * Catch the four signals that POSIX specifies if they aren't ignored. 	 * JobCatchSignal will just set global variables and hope someone 	 * else is going to handle the interrupt. 	 */
name|sa
operator|.
name|sa_handler
operator|=
name|JobCatchSig
expr_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|sa
operator|.
name|sa_mask
argument_list|)
expr_stmt|;
name|sa
operator|.
name|sa_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
block|{
name|sigaction
argument_list|(
name|SIGINT
argument_list|,
operator|&
name|sa
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
block|{
name|sigaction
argument_list|(
name|SIGHUP
argument_list|,
operator|&
name|sa
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
block|{
name|sigaction
argument_list|(
name|SIGQUIT
argument_list|,
operator|&
name|sa
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
block|{
name|sigaction
argument_list|(
name|SIGTERM
argument_list|,
operator|&
name|sa
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * There are additional signals that need to be caught and passed if 	 * either the export system wants to be told directly of signals or if 	 * we're giving each job its own process group (since then it won't get 	 * signals from the terminal driver as we own the terminal) 	 */
if|#
directive|if
name|defined
argument_list|(
name|USE_PGRP
argument_list|)
if|if
condition|(
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
block|{
name|sigaction
argument_list|(
name|SIGTSTP
argument_list|,
operator|&
name|sa
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|signal
argument_list|(
name|SIGTTOU
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
block|{
name|sigaction
argument_list|(
name|SIGTTOU
argument_list|,
operator|&
name|sa
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|signal
argument_list|(
name|SIGTTIN
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
block|{
name|sigaction
argument_list|(
name|SIGTTIN
argument_list|,
operator|&
name|sa
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|signal
argument_list|(
name|SIGWINCH
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
block|{
name|sigaction
argument_list|(
name|SIGWINCH
argument_list|,
operator|&
name|sa
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USE_KQUEUE
if|if
condition|(
operator|(
name|kqfd
operator|=
name|kqueue
argument_list|()
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|Punt
argument_list|(
literal|"kqueue: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|begin
operator|=
name|Targ_FindNode
argument_list|(
literal|".BEGIN"
argument_list|,
name|TARG_NOCREATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|begin
operator|!=
name|NULL
condition|)
block|{
name|JobStart
argument_list|(
name|begin
argument_list|,
name|JOB_SPECIAL
argument_list|,
operator|(
name|Job
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
while|while
condition|(
name|nJobs
condition|)
block|{
name|Job_CatchOutput
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|Job_CatchChildren
argument_list|(
operator|!
name|usePipes
argument_list|)
expr_stmt|;
block|}
block|}
name|postCommands
operator|=
name|Targ_FindNode
argument_list|(
literal|".END"
argument_list|,
name|TARG_CREATE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Job_Full  *	See if the job table is full. It is considered full if it is OR  *	if we are in the process of aborting OR if we have  *	reached/exceeded our local quota. This prevents any more jobs  *	from starting up.  *  * Results:  *	TRUE if the job table is full, FALSE otherwise  */
end_comment

begin_function
name|Boolean
name|Job_Full
parameter_list|(
name|void
parameter_list|)
block|{
name|char
name|c
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|aborting
condition|)
return|return
operator|(
name|aborting
operator|)
return|;
if|if
condition|(
name|fifoFd
operator|>=
literal|0
operator|&&
name|jobFull
condition|)
block|{
name|i
operator|=
name|read
argument_list|(
name|fifoFd
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|maxJobs
operator|++
expr_stmt|;
name|jobFull
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
return|return
operator|(
name|jobFull
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Job_Empty  *	See if the job table is empty.  Because the local concurrency may  *	be set to 0, it is possible for the job table to become empty,  *	while the list of stoppedJobs remains non-empty. In such a case,  *	we want to restart as many jobs as we can.  *  * Results:  *	TRUE if it is. FALSE if it ain't.  */
end_comment

begin_function
name|Boolean
name|Job_Empty
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|nJobs
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|stoppedJobs
argument_list|)
operator|&&
operator|!
name|aborting
condition|)
block|{
comment|/* 			 * The job table is obviously not full if it has no 			 * jobs in it...Try and restart the stopped jobs. 			 */
name|jobFull
operator|=
name|FALSE
expr_stmt|;
name|JobRestartJobs
argument_list|()
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
block|}
else|else
block|{
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/**  * JobMatchShell  *	Find a matching shell in 'shells' given its final component.  *  * Results:  *	A pointer to a freshly allocated Shell structure with a copy  *	of the static structure or NULL if no shell with the given name  *	is found.  */
end_comment

begin_function
specifier|static
name|struct
name|Shell
modifier|*
name|JobMatchShell
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
specifier|const
name|struct
name|CShell
modifier|*
name|sh
decl_stmt|;
comment|/* Pointer into shells table */
name|struct
name|Shell
modifier|*
name|nsh
decl_stmt|;
for|for
control|(
name|sh
operator|=
name|shells
init|;
name|sh
operator|<
name|shells
operator|+
sizeof|sizeof
argument_list|(
name|shells
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|shells
index|[
literal|0
index|]
argument_list|)
condition|;
name|sh
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|sh
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|sh
operator|==
name|shells
operator|+
sizeof|sizeof
argument_list|(
name|shells
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|shells
index|[
literal|0
index|]
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* make a copy */
name|nsh
operator|=
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|nsh
argument_list|)
argument_list|)
expr_stmt|;
name|nsh
operator|->
name|name
operator|=
name|estrdup
argument_list|(
name|sh
operator|->
name|name
argument_list|)
expr_stmt|;
name|nsh
operator|->
name|echoOff
operator|=
name|estrdup
argument_list|(
name|sh
operator|->
name|echoOff
argument_list|)
expr_stmt|;
name|nsh
operator|->
name|echoOn
operator|=
name|estrdup
argument_list|(
name|sh
operator|->
name|echoOn
argument_list|)
expr_stmt|;
name|nsh
operator|->
name|hasEchoCtl
operator|=
name|sh
operator|->
name|hasEchoCtl
expr_stmt|;
name|nsh
operator|->
name|noPrint
operator|=
name|estrdup
argument_list|(
name|sh
operator|->
name|noPrint
argument_list|)
expr_stmt|;
name|nsh
operator|->
name|hasErrCtl
operator|=
name|sh
operator|->
name|hasErrCtl
expr_stmt|;
name|nsh
operator|->
name|errCheck
operator|=
name|estrdup
argument_list|(
name|sh
operator|->
name|errCheck
argument_list|)
expr_stmt|;
name|nsh
operator|->
name|ignErr
operator|=
name|estrdup
argument_list|(
name|sh
operator|->
name|ignErr
argument_list|)
expr_stmt|;
name|nsh
operator|->
name|echo
operator|=
name|estrdup
argument_list|(
name|sh
operator|->
name|echo
argument_list|)
expr_stmt|;
name|nsh
operator|->
name|exit
operator|=
name|estrdup
argument_list|(
name|sh
operator|->
name|exit
argument_list|)
expr_stmt|;
return|return
operator|(
name|nsh
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Job_ParseShell  *	Parse a shell specification and set up commandShell, shellPath  *	and shellName appropriately.  *  * Results:  *	FAILURE if the specification was incorrect.  *  * Side Effects:  *	commandShell points to a Shell structure (either predefined or  *	created from the shell spec), shellPath is the full path of the  *	shell described by commandShell, while shellName is just the  *	final component of shellPath.  *  * Notes:  *	A shell specification consists of a .SHELL target, with dependency  *	operator, followed by a series of blank-separated words. Double  *	quotes can be used to use blanks in words. A backslash escapes  *	anything (most notably a double-quote and a space) and  *	provides the functionality it does in C. Each word consists of  *	keyword and value separated by an equal sign. There should be no  *	unnecessary spaces in the word. The keywords are as follows:  *	    name	    Name of shell.  *	    path	    Location of shell. Overrides "name" if given  *	    quiet	    Command to turn off echoing.  *	    echo	    Command to turn echoing on  *	    filter	    Result of turning off echoing that shouldn't be  *			    printed.  *	    echoFlag	    Flag to turn echoing on at the start  *	    errFlag	    Flag to turn error checking on at the start  *	    hasErrCtl	    True if shell has error checking control  *	    check	    Command to turn on error checking if hasErrCtl  *			    is TRUE or template of command to echo a command  *			    for which error checking is off if hasErrCtl is  *			    FALSE.  *	    ignore	    Command to turn off error checking if hasErrCtl  *			    is TRUE or template of command to execute a  *			    command so as to ignore any errors it returns if  *			    hasErrCtl is FALSE.  */
end_comment

begin_function
name|ReturnStatus
name|Job_ParseShell
parameter_list|(
name|char
modifier|*
name|line
parameter_list|)
block|{
name|char
modifier|*
modifier|*
name|words
decl_stmt|;
name|int
name|wordCount
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|path
decl_stmt|;
name|char
modifier|*
name|eq
decl_stmt|;
name|Boolean
name|fullSpec
init|=
name|FALSE
decl_stmt|;
name|struct
name|Shell
name|newShell
decl_stmt|;
name|struct
name|Shell
modifier|*
name|sh
decl_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|line
argument_list|)
condition|)
block|{
name|line
operator|++
expr_stmt|;
block|}
name|words
operator|=
name|brk_string
argument_list|(
name|line
argument_list|,
operator|&
name|wordCount
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|newShell
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|newShell
argument_list|)
argument_list|)
expr_stmt|;
name|path
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Parse the specification by keyword but skip the first word - it 	 * is not set by brk_string. 	 */
name|wordCount
operator|--
expr_stmt|;
name|words
operator|++
expr_stmt|;
for|for
control|(
name|argc
operator|=
name|wordCount
operator|,
name|argv
operator|=
name|words
init|;
name|argc
operator|!=
literal|0
condition|;
name|argc
operator|--
operator|,
name|argv
operator|++
control|)
block|{
comment|/* 		 * Split keyword and value 		 */
if|if
condition|(
operator|(
name|eq
operator|=
name|strchr
argument_list|(
operator|*
name|argv
argument_list|,
literal|'='
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|Parse_Error
argument_list|(
name|PARSE_FATAL
argument_list|,
literal|"missing '=' in shell "
literal|"specification keyword '%s'"
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
return|return
operator|(
name|FAILURE
operator|)
return|;
block|}
operator|*
name|eq
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"path"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|path
operator|=
name|eq
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"name"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|newShell
operator|.
name|name
operator|=
name|eq
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"quiet"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|newShell
operator|.
name|echoOff
operator|=
name|eq
expr_stmt|;
name|fullSpec
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"echo"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|newShell
operator|.
name|echoOn
operator|=
name|eq
expr_stmt|;
name|fullSpec
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"filter"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|newShell
operator|.
name|noPrint
operator|=
name|eq
expr_stmt|;
name|fullSpec
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"echoFlag"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|newShell
operator|.
name|echo
operator|=
name|eq
expr_stmt|;
name|fullSpec
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"errFlag"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|newShell
operator|.
name|exit
operator|=
name|eq
expr_stmt|;
name|fullSpec
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"hasErrCtl"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|newShell
operator|.
name|hasErrCtl
operator|=
operator|(
operator|*
name|eq
operator|==
literal|'Y'
operator|||
operator|*
name|eq
operator|==
literal|'y'
operator|||
operator|*
name|eq
operator|==
literal|'T'
operator|||
operator|*
name|eq
operator|==
literal|'t'
operator|)
expr_stmt|;
name|fullSpec
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"check"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|newShell
operator|.
name|errCheck
operator|=
name|eq
expr_stmt|;
name|fullSpec
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"ignore"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|newShell
operator|.
name|ignErr
operator|=
name|eq
expr_stmt|;
name|fullSpec
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|Parse_Error
argument_list|(
name|PARSE_FATAL
argument_list|,
literal|"unknown keyword in shell "
literal|"specification '%s'"
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
return|return
operator|(
name|FAILURE
operator|)
return|;
block|}
block|}
comment|/* 	 * Some checks (could be more) 	 */
if|if
condition|(
name|fullSpec
condition|)
block|{
if|if
condition|(
operator|(
name|newShell
operator|.
name|echoOn
operator|!=
name|NULL
operator|)
operator|^
operator|(
name|newShell
operator|.
name|echoOff
operator|!=
name|NULL
operator|)
condition|)
name|Parse_Error
argument_list|(
name|PARSE_FATAL
argument_list|,
literal|"Shell must have either both "
literal|"echoOff and echoOn or none of them"
argument_list|)
expr_stmt|;
if|if
condition|(
name|newShell
operator|.
name|echoOn
operator|!=
name|NULL
operator|&&
name|newShell
operator|.
name|echoOff
condition|)
name|newShell
operator|.
name|hasEchoCtl
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|path
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * If no path was given, the user wants one of the pre-defined 		 * shells, yes? So we find the one s/he wants with the help of 		 * JobMatchShell and set things up the right way. shellPath 		 * will be set up by Job_Init. 		 */
if|if
condition|(
name|newShell
operator|.
name|name
operator|==
name|NULL
condition|)
block|{
name|Parse_Error
argument_list|(
name|PARSE_FATAL
argument_list|,
literal|"Neither path nor name specified"
argument_list|)
expr_stmt|;
return|return
operator|(
name|FAILURE
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|sh
operator|=
name|JobMatchShell
argument_list|(
name|newShell
operator|.
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|Parse_Error
argument_list|(
name|PARSE_FATAL
argument_list|,
literal|"%s: no matching shell"
argument_list|,
name|newShell
operator|.
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|FAILURE
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/* 		 * The user provided a path. If s/he gave nothing else 		 * (fullSpec is FALSE), try and find a matching shell in the 		 * ones we know of. Else we just take the specification at its 		 * word and copy it to a new location. In either case, we need 		 * to record the path the user gave for the shell. 		 */
name|free
argument_list|(
name|shellPath
argument_list|)
expr_stmt|;
name|shellPath
operator|=
name|estrdup
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|newShell
operator|.
name|name
operator|==
name|NULL
condition|)
block|{
comment|/* get the base name as the name */
name|path
operator|=
name|strrchr
argument_list|(
name|path
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
operator|==
name|NULL
condition|)
block|{
name|path
operator|=
name|shellPath
expr_stmt|;
block|}
else|else
block|{
name|path
operator|+=
literal|1
expr_stmt|;
block|}
name|newShell
operator|.
name|name
operator|=
name|path
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|fullSpec
condition|)
block|{
if|if
condition|(
operator|(
name|sh
operator|=
name|JobMatchShell
argument_list|(
name|newShell
operator|.
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|Parse_Error
argument_list|(
name|PARSE_FATAL
argument_list|,
literal|"%s: no matching shell"
argument_list|,
name|newShell
operator|.
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|FAILURE
operator|)
return|;
block|}
block|}
else|else
block|{
name|sh
operator|=
name|JobCopyShell
argument_list|(
operator|&
name|newShell
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* set the new shell */
name|JobFreeShell
argument_list|(
name|commandShell
argument_list|)
expr_stmt|;
name|commandShell
operator|=
name|sh
expr_stmt|;
name|shellName
operator|=
name|commandShell
operator|->
name|name
expr_stmt|;
return|return
operator|(
name|SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * JobInterrupt  *	Handle the receipt of an interrupt.  *  * Side Effects:  *	All children are killed. Another job will be started if the  *	.INTERRUPT target was given.  */
end_comment

begin_function
specifier|static
name|void
name|JobInterrupt
parameter_list|(
name|int
name|runINTERRUPT
parameter_list|,
name|int
name|signo
parameter_list|)
block|{
name|Job
modifier|*
name|job
decl_stmt|;
comment|/* job descriptor in that element */
name|GNode
modifier|*
name|interrupt
decl_stmt|;
comment|/* the node describing the .INTERRUPT target */
name|aborting
operator|=
name|ABORT_INTERRUPT
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|job
argument_list|,
argument|&jobs
argument_list|,
argument|link
argument_list|)
block|{
if|if
condition|(
operator|!
name|Targ_Precious
argument_list|(
name|job
operator|->
name|node
argument_list|)
condition|)
block|{
name|char
modifier|*
name|file
init|=
operator|(
name|job
operator|->
name|node
operator|->
name|path
operator|==
name|NULL
condition|?
name|job
operator|->
name|node
operator|->
name|name
else|:
name|job
operator|->
name|node
operator|->
name|path
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|noExecute
operator|&&
name|eunlink
argument_list|(
name|file
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|Error
argument_list|(
literal|"*** %s removed"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|job
operator|->
name|pid
condition|)
block|{
name|DEBUGF
argument_list|(
name|JOB
argument_list|,
operator|(
literal|"JobInterrupt passing signal to child "
literal|"%jd.\n"
operator|,
operator|(
name|intmax_t
operator|)
name|job
operator|->
name|pid
operator|)
argument_list|)
expr_stmt|;
name|KILL
argument_list|(
name|job
operator|->
name|pid
argument_list|,
name|signo
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|runINTERRUPT
operator|&&
operator|!
name|touchFlag
condition|)
block|{
comment|/* 		 * clear the interrupted flag because we would get an 		 * infinite loop otherwise. 		 */
name|interrupted
operator|=
literal|0
expr_stmt|;
name|interrupt
operator|=
name|Targ_FindNode
argument_list|(
literal|".INTERRUPT"
argument_list|,
name|TARG_NOCREATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|interrupt
operator|!=
name|NULL
condition|)
block|{
name|ignoreErrors
operator|=
name|FALSE
expr_stmt|;
name|JobStart
argument_list|(
name|interrupt
argument_list|,
name|JOB_IGNDOTS
argument_list|,
operator|(
name|Job
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
while|while
condition|(
name|nJobs
condition|)
block|{
name|Job_CatchOutput
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|Job_CatchChildren
argument_list|(
operator|!
name|usePipes
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/**  * Job_Finish  *	Do final processing such as the running of the commands  *	attached to the .END target.  *  * Results:  *	Number of errors reported.  */
end_comment

begin_function
name|int
name|Job_Finish
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|postCommands
operator|!=
name|NULL
operator|&&
operator|!
name|Lst_IsEmpty
argument_list|(
operator|&
name|postCommands
operator|->
name|commands
argument_list|)
condition|)
block|{
if|if
condition|(
name|errors
condition|)
block|{
name|Error
argument_list|(
literal|"Errors reported so .END ignored"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|JobStart
argument_list|(
name|postCommands
argument_list|,
name|JOB_SPECIAL
operator||
name|JOB_IGNDOTS
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
while|while
condition|(
name|nJobs
condition|)
block|{
name|Job_CatchOutput
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|Job_CatchChildren
argument_list|(
operator|!
name|usePipes
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|fifoFd
operator|>=
literal|0
condition|)
block|{
name|close
argument_list|(
name|fifoFd
argument_list|)
expr_stmt|;
name|fifoFd
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|fifoMaster
condition|)
name|unlink
argument_list|(
name|fifoName
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|errors
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Job_Wait  *	Waits for all running jobs to finish and returns. Sets 'aborting'  *	to ABORT_WAIT to prevent other jobs from starting.  *  * Side Effects:  *	Currently running jobs finish.  */
end_comment

begin_function
name|void
name|Job_Wait
parameter_list|(
name|void
parameter_list|)
block|{
name|aborting
operator|=
name|ABORT_WAIT
expr_stmt|;
while|while
condition|(
name|nJobs
operator|!=
literal|0
condition|)
block|{
name|Job_CatchOutput
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|Job_CatchChildren
argument_list|(
operator|!
name|usePipes
argument_list|)
expr_stmt|;
block|}
name|aborting
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Job_AbortAll  *	Abort all currently running jobs without handling output or anything.  *	This function is to be called only in the event of a major  *	error. Most definitely NOT to be called from JobInterrupt.  *  * Side Effects:  *	All children are killed, not just the firstborn  */
end_comment

begin_function
name|void
name|Job_AbortAll
parameter_list|(
name|void
parameter_list|)
block|{
name|Job
modifier|*
name|job
decl_stmt|;
comment|/* the job descriptor in that element */
name|int
name|foo
decl_stmt|;
name|aborting
operator|=
name|ABORT_ERROR
expr_stmt|;
if|if
condition|(
name|nJobs
condition|)
block|{
name|TAILQ_FOREACH
argument_list|(
argument|job
argument_list|,
argument|&jobs
argument_list|,
argument|link
argument_list|)
block|{
comment|/* 			 * kill the child process with increasingly drastic 			 * signals to make darn sure it's dead. 			 */
name|KILL
argument_list|(
name|job
operator|->
name|pid
argument_list|,
name|SIGINT
argument_list|)
expr_stmt|;
name|KILL
argument_list|(
name|job
operator|->
name|pid
argument_list|,
name|SIGKILL
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Catch as many children as want to report in at first, then give up 	 */
while|while
condition|(
name|waitpid
argument_list|(
operator|(
name|pid_t
operator|)
operator|-
literal|1
argument_list|,
operator|&
name|foo
argument_list|,
name|WNOHANG
argument_list|)
operator|>
literal|0
condition|)
empty_stmt|;
block|}
end_function

begin_comment
comment|/**  * JobRestartJobs  *	Tries to restart stopped jobs if there are slots available.  *	Note that this tries to restart them regardless of pending errors.  *	It's not good to leave stopped jobs lying around!  *  * Side Effects:  *	Resumes(and possibly migrates) jobs.  */
end_comment

begin_function
specifier|static
name|void
name|JobRestartJobs
parameter_list|(
name|void
parameter_list|)
block|{
name|Job
modifier|*
name|job
decl_stmt|;
while|while
condition|(
operator|!
name|jobFull
operator|&&
operator|(
name|job
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|stoppedJobs
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|DEBUGF
argument_list|(
name|JOB
argument_list|,
operator|(
literal|"Job queue is not full. "
literal|"Restarting a stopped job.\n"
operator|)
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|stoppedJobs
argument_list|,
name|job
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|JobRestart
argument_list|(
name|job
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * Cmd_Exec  *	Execute the command in cmd, and return the output of that command  *	in a string.  *  * Results:  *	A string containing the output of the command, or the empty string  *	If error is not NULL, it contains the reason for the command failure  *	Any output sent to stderr in the child process is passed to stderr,  *	and not captured in the string.  *  * Side Effects:  *	The string must be freed by the caller.  */
end_comment

begin_function
name|Buffer
modifier|*
name|Cmd_Exec
parameter_list|(
specifier|const
name|char
modifier|*
name|cmd
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|error
parameter_list|)
block|{
name|int
name|fds
index|[
literal|2
index|]
decl_stmt|;
comment|/* Pipe streams */
name|int
name|status
decl_stmt|;
comment|/* command exit status */
name|Buffer
modifier|*
name|buf
decl_stmt|;
comment|/* buffer to store the result */
name|ssize_t
name|rcnt
decl_stmt|;
name|ProcStuff
name|ps
decl_stmt|;
operator|*
name|error
operator|=
name|NULL
expr_stmt|;
name|buf
operator|=
name|Buf_Init
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|shellPath
operator|==
name|NULL
condition|)
name|Shell_Init
argument_list|()
expr_stmt|;
comment|/* 	 * Open a pipe for fetching its output 	 */
if|if
condition|(
name|pipe
argument_list|(
name|fds
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
operator|*
name|error
operator|=
literal|"Couldn't create pipe for \"%s\""
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
comment|/* Set close-on-exec on read side of pipe. */
name|fcntl
argument_list|(
name|fds
index|[
literal|0
index|]
argument_list|,
name|F_SETFD
argument_list|,
name|fcntl
argument_list|(
name|fds
index|[
literal|0
index|]
argument_list|,
name|F_GETFD
argument_list|)
operator||
name|FD_CLOEXEC
argument_list|)
expr_stmt|;
name|ps
operator|.
name|in
operator|=
name|STDIN_FILENO
expr_stmt|;
name|ps
operator|.
name|out
operator|=
name|fds
index|[
literal|1
index|]
expr_stmt|;
name|ps
operator|.
name|err
operator|=
name|STDERR_FILENO
expr_stmt|;
name|ps
operator|.
name|merge_errors
operator|=
literal|0
expr_stmt|;
name|ps
operator|.
name|pgroup
operator|=
literal|0
expr_stmt|;
name|ps
operator|.
name|searchpath
operator|=
literal|0
expr_stmt|;
comment|/* Set up arguments for shell */
name|ps
operator|.
name|argv
operator|=
name|emalloc
argument_list|(
literal|4
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|ps
operator|.
name|argv
index|[
literal|0
index|]
operator|=
name|strdup
argument_list|(
name|shellName
argument_list|)
expr_stmt|;
name|ps
operator|.
name|argv
index|[
literal|1
index|]
operator|=
name|strdup
argument_list|(
literal|"-c"
argument_list|)
expr_stmt|;
name|ps
operator|.
name|argv
index|[
literal|2
index|]
operator|=
name|strdup
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|ps
operator|.
name|argv
index|[
literal|3
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Fork.  Warning since we are doing vfork() instead of fork(), 	 * do not allocate memory in the child process! 	 */
if|if
condition|(
operator|(
name|ps
operator|.
name|child_pid
operator|=
name|vfork
argument_list|()
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
operator|*
name|error
operator|=
literal|"Couldn't exec \"%s\""
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|ps
operator|.
name|child_pid
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Child   		 */
name|ProcExec
argument_list|(
operator|&
name|ps
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
name|free
argument_list|(
name|ps
operator|.
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ps
operator|.
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ps
operator|.
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ps
operator|.
name|argv
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fds
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* No need for the writing half of the pipe. */
do|do
block|{
name|char
name|result
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|rcnt
operator|=
name|read
argument_list|(
name|fds
index|[
literal|0
index|]
argument_list|,
name|result
argument_list|,
sizeof|sizeof
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcnt
operator|!=
operator|-
literal|1
condition|)
name|Buf_AddBytes
argument_list|(
name|buf
argument_list|,
operator|(
name|size_t
operator|)
name|rcnt
argument_list|,
operator|(
name|Byte
operator|*
operator|)
name|result
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|rcnt
operator|>
literal|0
operator|||
operator|(
name|rcnt
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|EINTR
operator|)
condition|)
do|;
if|if
condition|(
name|rcnt
operator|==
operator|-
literal|1
condition|)
operator|*
name|error
operator|=
literal|"Error reading shell's output for \"%s\""
expr_stmt|;
comment|/* 	 * Close the input side of the pipe. 	 */
name|close
argument_list|(
name|fds
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|status
operator|=
name|ProcWait
argument_list|(
operator|&
name|ps
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
operator|*
name|error
operator|=
literal|"\"%s\" returned non-zero status"
expr_stmt|;
name|Buf_StripNewlines
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Interrupt handler - set flag and defer handling to the main code  */
end_comment

begin_function
specifier|static
name|void
name|CompatCatchSig
parameter_list|(
name|int
name|signo
parameter_list|)
block|{
name|interrupted
operator|=
name|signo
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * CompatInterrupt --  *	Interrupt the creation of the current target and remove it if  *	it ain't precious.  *  * Results:  *	None.  *  * Side Effects:  *	The target is removed and the process exits. If .INTERRUPT exists,  *	its commands are run first WITH INTERRUPTS IGNORED..  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|CompatInterrupt
parameter_list|(
name|int
name|signo
parameter_list|)
block|{
name|GNode
modifier|*
name|gn
decl_stmt|;
name|sigset_t
name|nmask
decl_stmt|,
name|omask
decl_stmt|;
name|LstNode
modifier|*
name|ln
decl_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|nmask
argument_list|)
expr_stmt|;
name|sigaddset
argument_list|(
operator|&
name|nmask
argument_list|,
name|SIGINT
argument_list|)
expr_stmt|;
name|sigaddset
argument_list|(
operator|&
name|nmask
argument_list|,
name|SIGTERM
argument_list|)
expr_stmt|;
name|sigaddset
argument_list|(
operator|&
name|nmask
argument_list|,
name|SIGHUP
argument_list|)
expr_stmt|;
name|sigaddset
argument_list|(
operator|&
name|nmask
argument_list|,
name|SIGQUIT
argument_list|)
expr_stmt|;
name|sigprocmask
argument_list|(
name|SIG_SETMASK
argument_list|,
operator|&
name|nmask
argument_list|,
operator|&
name|omask
argument_list|)
expr_stmt|;
comment|/* prevent recursion in evaluation of .INTERRUPT */
name|interrupted
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|curTarg
operator|!=
name|NULL
operator|&&
operator|!
name|Targ_Precious
argument_list|(
name|curTarg
argument_list|)
condition|)
block|{
name|char
modifier|*
name|p1
decl_stmt|;
name|char
modifier|*
name|file
init|=
name|Var_Value
argument_list|(
name|TARGET
argument_list|,
name|curTarg
argument_list|,
operator|&
name|p1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|noExecute
operator|&&
name|eunlink
argument_list|(
name|file
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"*** %s removed\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|p1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Run .INTERRUPT only if hit with interrupt signal 	 */
if|if
condition|(
name|signo
operator|==
name|SIGINT
condition|)
block|{
name|gn
operator|=
name|Targ_FindNode
argument_list|(
literal|".INTERRUPT"
argument_list|,
name|TARG_NOCREATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|gn
operator|!=
name|NULL
condition|)
block|{
name|LST_FOREACH
argument_list|(
argument|ln
argument_list|,
argument|&gn->commands
argument_list|)
block|{
if|if
condition|(
name|Compat_RunCommand
argument_list|(
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
argument_list|,
name|gn
argument_list|)
condition|)
break|break;
block|}
block|}
block|}
name|sigprocmask
argument_list|(
name|SIG_SETMASK
argument_list|,
operator|&
name|omask
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|signo
operator|==
name|SIGQUIT
condition|)
name|exit
argument_list|(
name|signo
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|signo
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|kill
argument_list|(
name|getpid
argument_list|()
argument_list|,
name|signo
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * shellneed  *  * Results:  *	Returns NULL if a specified line must be executed by the shell,  *	and an argument vector if it can be run via execvp().  *  * Side Effects:  *	Uses brk_string so destroys the contents of argv.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
modifier|*
name|shellneed
parameter_list|(
name|char
modifier|*
name|cmd
parameter_list|)
block|{
name|char
modifier|*
modifier|*
name|av
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|strpbrk
argument_list|(
name|cmd
argument_list|,
name|sh_meta
argument_list|)
operator|!=
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|av
operator|=
name|brk_string
argument_list|(
name|cmd
argument_list|,
name|NULL
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|sh_builtin
init|;
operator|*
name|p
operator|!=
literal|0
condition|;
name|p
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|av
index|[
literal|1
index|]
argument_list|,
operator|*
name|p
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
name|av
operator|+
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Compat_RunCommand --  *	Execute the next command for a target. If the command returns an  *	error, the node's made field is set to ERROR and creation stops.  *	The node from which the command came is also given.  *  * Results:  *	0 if the command succeeded, 1 if an error occurred.  *  * Side Effects:  *	The node's 'made' field may be set to ERROR.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Compat_RunCommand
parameter_list|(
name|char
modifier|*
name|cmd
parameter_list|,
name|GNode
modifier|*
name|gn
parameter_list|)
block|{
name|char
modifier|*
name|cmdStart
decl_stmt|;
comment|/* Start of expanded command */
name|Boolean
name|silent
decl_stmt|;
comment|/* Don't print command */
name|Boolean
name|doit
decl_stmt|;
comment|/* Execute even in -n */
name|Boolean
name|errCheck
decl_stmt|;
comment|/* Check errors */
name|int
name|reason
decl_stmt|;
comment|/* Reason for child's death */
name|int
name|status
decl_stmt|;
comment|/* Description of child's death */
name|LstNode
modifier|*
name|cmdNode
decl_stmt|;
comment|/* Node where current command is located */
name|char
modifier|*
modifier|*
name|av
decl_stmt|;
comment|/* Argument vector for thing to exec */
name|char
modifier|*
name|cmd_save
decl_stmt|;
comment|/* saved cmd */
name|ProcStuff
name|ps
decl_stmt|;
name|silent
operator|=
name|gn
operator|->
name|type
operator|&
name|OP_SILENT
expr_stmt|;
name|errCheck
operator|=
operator|!
operator|(
name|gn
operator|->
name|type
operator|&
name|OP_IGNORE
operator|)
expr_stmt|;
name|doit
operator|=
name|FALSE
expr_stmt|;
name|cmdNode
operator|=
name|Lst_Member
argument_list|(
operator|&
name|gn
operator|->
name|commands
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|cmdStart
operator|=
name|Buf_Peel
argument_list|(
name|Var_Subst
argument_list|(
name|cmd
argument_list|,
name|gn
argument_list|,
name|FALSE
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * brk_string will return an argv with a NULL in av[0], thus causing 	 * execvp() to choke and die horribly. Besides, how can we execute a 	 * null command? In any case, we warn the user that the command 	 * expanded to nothing (is this the right thing to do?). 	 */
if|if
condition|(
operator|*
name|cmdStart
operator|==
literal|'\0'
condition|)
block|{
name|free
argument_list|(
name|cmdStart
argument_list|)
expr_stmt|;
name|Error
argument_list|(
literal|"%s expands to empty string"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
name|cmd
operator|=
name|cmdStart
expr_stmt|;
block|}
name|Lst_Replace
argument_list|(
name|cmdNode
argument_list|,
name|cmdStart
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|gn
operator|->
name|type
operator|&
name|OP_SAVE_CMDS
operator|)
operator|&&
operator|(
name|gn
operator|!=
name|ENDNode
operator|)
condition|)
block|{
name|Lst_AtEnd
argument_list|(
operator|&
name|ENDNode
operator|->
name|commands
argument_list|,
name|cmdStart
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|cmdStart
argument_list|,
literal|"..."
argument_list|)
operator|==
literal|0
condition|)
block|{
name|gn
operator|->
name|type
operator||=
name|OP_SAVE_CMDS
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
while|while
condition|(
operator|*
name|cmd
operator|==
literal|'@'
operator|||
operator|*
name|cmd
operator|==
literal|'-'
operator|||
operator|*
name|cmd
operator|==
literal|'+'
condition|)
block|{
switch|switch
condition|(
operator|*
name|cmd
condition|)
block|{
case|case
literal|'@'
case|:
name|silent
operator|=
name|DEBUG
argument_list|(
name|LOUD
argument_list|)
condition|?
name|FALSE
else|:
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
name|errCheck
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
literal|'+'
case|:
name|doit
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
name|cmd
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cmd
argument_list|)
condition|)
name|cmd
operator|++
expr_stmt|;
comment|/* 	 * Print the command before echoing if we're not supposed to be quiet 	 * for this one. We also print the command if -n given, but not if '+'. 	 */
if|if
condition|(
operator|!
name|silent
operator|||
operator|(
name|noExecute
operator|&&
operator|!
name|doit
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If we're not supposed to execute any commands, this is as far as 	 * we go... 	 */
if|if
condition|(
operator|!
name|doit
operator|&&
name|noExecute
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|ps
operator|.
name|in
operator|=
name|STDIN_FILENO
expr_stmt|;
name|ps
operator|.
name|out
operator|=
name|STDOUT_FILENO
expr_stmt|;
name|ps
operator|.
name|err
operator|=
name|STDERR_FILENO
expr_stmt|;
name|ps
operator|.
name|merge_errors
operator|=
literal|0
expr_stmt|;
name|ps
operator|.
name|pgroup
operator|=
literal|0
expr_stmt|;
name|ps
operator|.
name|searchpath
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|av
operator|=
name|shellneed
argument_list|(
name|cmd
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * Shell meta character or shell builtin found - pass 		 * command to shell. We give the shell the -e flag as 		 * well as -c if it is supposed to exit when it hits an error. 		 */
name|ps
operator|.
name|argv
operator|=
name|emalloc
argument_list|(
literal|4
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|ps
operator|.
name|argv
index|[
literal|0
index|]
operator|=
name|strdup
argument_list|(
name|shellName
argument_list|)
expr_stmt|;
name|ps
operator|.
name|argv
index|[
literal|1
index|]
operator|=
name|strdup
argument_list|(
name|errCheck
condition|?
literal|"-ec"
else|:
literal|"-c"
argument_list|)
expr_stmt|;
name|ps
operator|.
name|argv
index|[
literal|2
index|]
operator|=
name|strdup
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|ps
operator|.
name|argv
index|[
literal|3
index|]
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|ps
operator|.
name|argv
operator|=
name|av
expr_stmt|;
block|}
comment|/* 	 * Warning since we are doing vfork() instead of fork(), 	 * do not allocate memory in the child process! 	 */
if|if
condition|(
operator|(
name|ps
operator|.
name|child_pid
operator|=
name|vfork
argument_list|()
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|Fatal
argument_list|(
literal|"Could not fork"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ps
operator|.
name|child_pid
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Child 		 */
name|ProcExec
argument_list|(
operator|&
name|ps
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
else|else
block|{
if|if
condition|(
name|av
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|ps
operator|.
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ps
operator|.
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ps
operator|.
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ps
operator|.
name|argv
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * we need to print out the command associated with this 		 * Gnode in Targ_PrintCmd from Targ_PrintGraph when debugging 		 * at level g2, in main(), Fatal() and DieHorribly(), 		 * therefore do not free it when debugging. 		 */
if|if
condition|(
operator|!
name|DEBUG
argument_list|(
name|GRAPH2
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|cmdStart
argument_list|)
expr_stmt|;
name|Lst_Replace
argument_list|(
name|cmdNode
argument_list|,
name|cmd_save
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * The child is off and running. Now all we can do is wait... 		 */
name|reason
operator|=
name|ProcWait
argument_list|(
operator|&
name|ps
argument_list|)
expr_stmt|;
if|if
condition|(
name|interrupted
condition|)
name|CompatInterrupt
argument_list|(
name|interrupted
argument_list|)
expr_stmt|;
comment|/* 		 * Decode and report the reason child exited, then 		 * indicate how we handled it. 		 */
if|if
condition|(
name|WIFEXITED
argument_list|(
name|reason
argument_list|)
condition|)
block|{
name|status
operator|=
name|WEXITSTATUS
argument_list|(
name|reason
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|0
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"*** Error code %d"
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|WIFSTOPPED
argument_list|(
name|reason
argument_list|)
condition|)
block|{
name|status
operator|=
name|WSTOPSIG
argument_list|(
name|reason
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|status
operator|=
name|WTERMSIG
argument_list|(
name|reason
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"*** Signal %d"
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|errCheck
condition|)
block|{
name|gn
operator|->
name|made
operator|=
name|ERROR
expr_stmt|;
if|if
condition|(
name|keepgoing
condition|)
block|{
comment|/* 				 * Abort the current 				 * target, but let 				 * others continue. 				 */
name|printf
argument_list|(
literal|" (continuing)\n"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|status
operator|)
return|;
block|}
else|else
block|{
comment|/* 			 * Continue executing 			 * commands for this target. 			 * If we return 0, this will 			 * happen... 			 */
name|printf
argument_list|(
literal|" (ignored)\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * CompatMake --  *	Make a target, given the parent, to abort if necessary.  *  * Side Effects:  *	If an error is detected and not being ignored, the process exits.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|CompatMake
parameter_list|(
name|GNode
modifier|*
name|gn
parameter_list|,
name|GNode
modifier|*
name|pgn
parameter_list|)
block|{
name|LstNode
modifier|*
name|ln
decl_stmt|;
if|if
condition|(
name|gn
operator|->
name|type
operator|&
name|OP_USE
condition|)
block|{
name|Make_HandleUse
argument_list|(
name|gn
argument_list|,
name|pgn
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|gn
operator|->
name|made
operator|==
name|UNMADE
condition|)
block|{
comment|/* 		 * First mark ourselves to be made, then apply whatever 		 * transformations the suffix module thinks are necessary. 		 * Once that's done, we can descend and make all our children. 		 * If any of them has an error but the -k flag was given, our 		 * 'make' field will be set FALSE again. This is our signal to 		 * not attempt to do anything but abort our parent as well. 		 */
name|gn
operator|->
name|make
operator|=
name|TRUE
expr_stmt|;
name|gn
operator|->
name|made
operator|=
name|BEINGMADE
expr_stmt|;
name|Suff_FindDeps
argument_list|(
name|gn
argument_list|)
expr_stmt|;
name|LST_FOREACH
argument_list|(
argument|ln
argument_list|,
argument|&gn->children
argument_list|)
name|CompatMake
argument_list|(
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
argument_list|,
name|gn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|gn
operator|->
name|make
condition|)
block|{
name|gn
operator|->
name|made
operator|=
name|ABORTED
expr_stmt|;
name|pgn
operator|->
name|make
operator|=
name|FALSE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|Lst_Member
argument_list|(
operator|&
name|gn
operator|->
name|iParents
argument_list|,
name|pgn
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|p1
decl_stmt|;
name|Var_Set
argument_list|(
name|IMPSRC
argument_list|,
name|Var_Value
argument_list|(
name|TARGET
argument_list|,
name|gn
argument_list|,
operator|&
name|p1
argument_list|)
argument_list|,
name|pgn
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p1
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * All the children were made ok. Now cmtime contains the 		 * modification time of the newest child, we need to find out 		 * if we exist and when we were modified last. The criteria for 		 * datedness are defined by the Make_OODate function. 		 */
name|DEBUGF
argument_list|(
name|MAKE
argument_list|,
operator|(
literal|"Examining %s..."
operator|,
name|gn
operator|->
name|name
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Make_OODate
argument_list|(
name|gn
argument_list|)
condition|)
block|{
name|gn
operator|->
name|made
operator|=
name|UPTODATE
expr_stmt|;
name|DEBUGF
argument_list|(
name|MAKE
argument_list|,
operator|(
literal|"up-to-date.\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
name|DEBUGF
argument_list|(
name|MAKE
argument_list|,
operator|(
literal|"out-of-date.\n"
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * If the user is just seeing if something is out-of-date, 		 * exit now to tell him/her "yes". 		 */
if|if
condition|(
name|queryFlag
condition|)
block|{
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * We need to be re-made. We also have to make sure we've got 		 * a $? variable. To be nice, we also define the $> variable 		 * using Make_DoAllVar(). 		 */
name|Make_DoAllVar
argument_list|(
name|gn
argument_list|)
expr_stmt|;
comment|/* 		 * Alter our type to tell if errors should be ignored or things 		 * should not be printed so Compat_RunCommand knows what to do. 		 */
if|if
condition|(
name|Targ_Ignore
argument_list|(
name|gn
argument_list|)
condition|)
block|{
name|gn
operator|->
name|type
operator||=
name|OP_IGNORE
expr_stmt|;
block|}
if|if
condition|(
name|Targ_Silent
argument_list|(
name|gn
argument_list|)
condition|)
block|{
name|gn
operator|->
name|type
operator||=
name|OP_SILENT
expr_stmt|;
block|}
if|if
condition|(
name|Job_CheckCommands
argument_list|(
name|gn
argument_list|,
name|Fatal
argument_list|)
condition|)
block|{
comment|/* 			 * Our commands are ok, but we still have to worry 			 * about the -t flag... 			 */
if|if
condition|(
operator|!
name|touchFlag
condition|)
block|{
name|curTarg
operator|=
name|gn
expr_stmt|;
name|LST_FOREACH
argument_list|(
argument|ln
argument_list|,
argument|&gn->commands
argument_list|)
block|{
if|if
condition|(
name|Compat_RunCommand
argument_list|(
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
argument_list|,
name|gn
argument_list|)
condition|)
break|break;
block|}
name|curTarg
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|Job_Touch
argument_list|(
name|gn
argument_list|,
name|gn
operator|->
name|type
operator|&
name|OP_SILENT
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|gn
operator|->
name|made
operator|=
name|ERROR
expr_stmt|;
block|}
if|if
condition|(
name|gn
operator|->
name|made
operator|!=
name|ERROR
condition|)
block|{
comment|/* 			 * If the node was made successfully, mark it so, update 			 * its modification time and timestamp all its parents. 			 * Note that for .ZEROTIME targets, the timestamping 			 * isn't done. This is to keep its state from affecting 			 * that of its parent. 			 */
name|gn
operator|->
name|made
operator|=
name|MADE
expr_stmt|;
ifndef|#
directive|ifndef
name|RECHECK
comment|/* 			 * We can't re-stat the thing, but we can at least take 			 * care of rules where a target depends on a source that 			 * actually creates the target, but only if it has 			 * changed, e.g. 			 * 			 * parse.h : parse.o 			 * 			 * parse.o : parse.y 			 *	yacc -d parse.y 			 *	cc -c y.tab.c 			 *	mv y.tab.o parse.o 			 *	cmp -s y.tab.h parse.h || mv y.tab.h parse.h 			 * 			 * In this case, if the definitions produced by yacc 			 * haven't changed from before, parse.h won't have been 			 * updated and gn->mtime will reflect the current 			 * modification time for parse.h. This is something of a 			 * kludge, I admit, but it's a useful one.. 			 * 			 * XXX: People like to use a rule like 			 * 			 * FRC: 			 * 			 * To force things that depend on FRC to be made, so we 			 * have to check for gn->children being empty as well... 			 */
if|if
condition|(
operator|!
name|Lst_IsEmpty
argument_list|(
operator|&
name|gn
operator|->
name|commands
argument_list|)
operator|||
name|Lst_IsEmpty
argument_list|(
operator|&
name|gn
operator|->
name|children
argument_list|)
condition|)
block|{
name|gn
operator|->
name|mtime
operator|=
name|now
expr_stmt|;
block|}
else|#
directive|else
comment|/* 			 * This is what Make does and it's actually a good 			 * thing, as it allows rules like 			 * 			 *	cmp -s y.tab.h parse.h || cp y.tab.h parse.h 			 * 			 * to function as intended. Unfortunately, thanks to 			 * the stateless nature of NFS (and the speed of this 			 * program), there are times when the modification time 			 * of a file created on a remote machine will not be 			 * modified before the stat() implied by the Dir_MTime 			 * occurs, thus leading us to believe that the file 			 * is unchanged, wreaking havoc with files that depend 			 * on this one. 			 * 			 * I have decided it is better to make too much than to 			 * make too little, so this stuff is commented out 			 * unless you're sure it's ok. 			 * -- ardeb 1/12/88 			 */
if|if
condition|(
name|noExecute
operator|||
name|Dir_MTime
argument_list|(
name|gn
argument_list|)
operator|==
literal|0
condition|)
block|{
name|gn
operator|->
name|mtime
operator|=
name|now
expr_stmt|;
block|}
if|if
condition|(
name|gn
operator|->
name|cmtime
operator|>
name|gn
operator|->
name|mtime
condition|)
name|gn
operator|->
name|mtime
operator|=
name|gn
operator|->
name|cmtime
expr_stmt|;
name|DEBUGF
argument_list|(
name|MAKE
argument_list|,
operator|(
literal|"update time: %s\n"
operator|,
name|Targ_FmtTime
argument_list|(
name|gn
operator|->
name|mtime
argument_list|)
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
operator|(
name|gn
operator|->
name|type
operator|&
name|OP_EXEC
operator|)
condition|)
block|{
name|pgn
operator|->
name|childMade
operator|=
name|TRUE
expr_stmt|;
name|Make_TimeStamp
argument_list|(
name|pgn
argument_list|,
name|gn
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|keepgoing
condition|)
block|{
name|pgn
operator|->
name|make
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|p1
decl_stmt|;
name|printf
argument_list|(
literal|"\n\nStop in %s.\n"
argument_list|,
name|Var_Value
argument_list|(
literal|".CURDIR"
argument_list|,
name|gn
argument_list|,
operator|&
name|p1
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|gn
operator|->
name|made
operator|==
name|ERROR
condition|)
block|{
comment|/* 		 * Already had an error when making this beastie. Tell the 		 * parent to abort. 		 */
name|pgn
operator|->
name|make
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|Lst_Member
argument_list|(
operator|&
name|gn
operator|->
name|iParents
argument_list|,
name|pgn
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|p1
decl_stmt|;
name|Var_Set
argument_list|(
name|IMPSRC
argument_list|,
name|Var_Value
argument_list|(
name|TARGET
argument_list|,
name|gn
argument_list|,
operator|&
name|p1
argument_list|)
argument_list|,
name|pgn
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p1
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|gn
operator|->
name|made
condition|)
block|{
case|case
name|BEINGMADE
case|:
name|Error
argument_list|(
literal|"Graph cycles through %s\n"
argument_list|,
name|gn
operator|->
name|name
argument_list|)
expr_stmt|;
name|gn
operator|->
name|made
operator|=
name|ERROR
expr_stmt|;
name|pgn
operator|->
name|make
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|MADE
case|:
if|if
condition|(
operator|(
name|gn
operator|->
name|type
operator|&
name|OP_EXEC
operator|)
operator|==
literal|0
condition|)
block|{
name|pgn
operator|->
name|childMade
operator|=
name|TRUE
expr_stmt|;
name|Make_TimeStamp
argument_list|(
name|pgn
argument_list|,
name|gn
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|UPTODATE
case|:
if|if
condition|(
operator|(
name|gn
operator|->
name|type
operator|&
name|OP_EXEC
operator|)
operator|==
literal|0
condition|)
block|{
name|Make_TimeStamp
argument_list|(
name|pgn
argument_list|,
name|gn
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Compat_Run --  *	Start making again, given a list of target nodes.  *  * Results:  *	None.  *  * Side Effects:  *	Guess what?  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Compat_Run
parameter_list|(
name|Lst
modifier|*
name|targs
parameter_list|)
block|{
name|GNode
modifier|*
name|gn
init|=
name|NULL
decl_stmt|;
comment|/* Current root target */
name|int
name|error_cnt
decl_stmt|;
comment|/* Number of targets not remade due to errors */
name|LstNode
modifier|*
name|ln
decl_stmt|;
name|Shell_Init
argument_list|()
expr_stmt|;
comment|/* Set up shell. */
if|if
condition|(
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
block|{
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|CompatCatchSig
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
block|{
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|CompatCatchSig
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
block|{
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|CompatCatchSig
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
block|{
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|CompatCatchSig
argument_list|)
expr_stmt|;
block|}
name|ENDNode
operator|=
name|Targ_FindNode
argument_list|(
literal|".END"
argument_list|,
name|TARG_CREATE
argument_list|)
expr_stmt|;
comment|/* 	 * If the user has defined a .BEGIN target, execute the commands 	 * attached to it. 	*/
if|if
condition|(
operator|!
name|queryFlag
condition|)
block|{
name|gn
operator|=
name|Targ_FindNode
argument_list|(
literal|".BEGIN"
argument_list|,
name|TARG_NOCREATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|gn
operator|!=
name|NULL
condition|)
block|{
name|LST_FOREACH
argument_list|(
argument|ln
argument_list|,
argument|&gn->commands
argument_list|)
block|{
if|if
condition|(
name|Compat_RunCommand
argument_list|(
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
argument_list|,
name|gn
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|gn
operator|->
name|made
operator|==
name|ERROR
condition|)
block|{
name|printf
argument_list|(
literal|"\n\nStop.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * For each entry in the list of targets to create, call CompatMake on 	 * it to create the thing. CompatMake will leave the 'made' field of gn 	 * in one of several states: 	 *	UPTODATE  gn was already up-to-date 	 *	MADE	  gn was recreated successfully 	 *	ERROR	  An error occurred while gn was being created 	 *	ABORTED	  gn was not remade because one of its inferiors 	 *		  could not be made due to errors. 	 */
name|error_cnt
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|Lst_IsEmpty
argument_list|(
name|targs
argument_list|)
condition|)
block|{
name|gn
operator|=
name|Lst_DeQueue
argument_list|(
name|targs
argument_list|)
expr_stmt|;
name|CompatMake
argument_list|(
name|gn
argument_list|,
name|gn
argument_list|)
expr_stmt|;
if|if
condition|(
name|gn
operator|->
name|made
operator|==
name|UPTODATE
condition|)
block|{
name|printf
argument_list|(
literal|"`%s' is up to date.\n"
argument_list|,
name|gn
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|gn
operator|->
name|made
operator|==
name|ABORTED
condition|)
block|{
name|printf
argument_list|(
literal|"`%s' not remade because of errors.\n"
argument_list|,
name|gn
operator|->
name|name
argument_list|)
expr_stmt|;
name|error_cnt
operator|+=
literal|1
expr_stmt|;
block|}
block|}
comment|/* 	 * If the user has defined a .END target, run its commands. 	 */
if|if
condition|(
name|error_cnt
operator|==
literal|0
condition|)
block|{
name|LST_FOREACH
argument_list|(
argument|ln
argument_list|,
argument|&ENDNode->commands
argument_list|)
block|{
if|if
condition|(
name|Compat_RunCommand
argument_list|(
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
argument_list|,
name|gn
argument_list|)
condition|)
break|break;
block|}
block|}
block|}
end_function

end_unit

