begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2002 Juli Mallett.  * Copyright (c) 1988, 1989, 1990, 1993  *	The Regents of the University of California.  All rights reserved.  * Copyright (c) 1989 by Berkeley Softworks  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Adam de Boor.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * @(#)var.c	8.3 (Berkeley) 3/19/94  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/**  * var.c --  *	Variable-handling functions  *  * Interface:  *	Var_Set		Set the value of a variable in the given  *			context. The variable is created if it doesn't  *			yet exist. The value and variable name need not  *			be preserved.  *  *	Var_Append	Append more characters to an existing variable  *			in the given context. The variable needn't  *			exist already -- it will be created if it doesn't.  *			A space is placed between the old value and the  *			new one.  *  *	Var_Exists	See if a variable exists.  *  *	Var_Value	Return the value of a variable in a context or  *			NULL if the variable is undefined.  *  *	Var_Subst	Substitute named variable, or all variables if  *			NULL in a string using  *			the given context as the top-most one. If the  *			third argument is non-zero, Parse_Error is  *			called if any variables are undefined.  *  *	Var_Parse	Parse a variable expansion from a string and  *			return the result and the number of characters  *			consumed.  *  *	Var_Delete	Delete a variable in a context.  *  *	Var_Init	Initialize this module.  *  * Debugging:  *	Var_Dump	Print out all variables defined in the given  *			context.  *  * XXX: There's a lot of duplication in these functions.  */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<regex.h>
end_include

begin_include
include|#
directive|include
file|"buf.h"
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"globals.h"
end_include

begin_include
include|#
directive|include
file|"GNode.h"
end_include

begin_include
include|#
directive|include
file|"job.h"
end_include

begin_include
include|#
directive|include
file|"lst.h"
end_include

begin_include
include|#
directive|include
file|"parse.h"
end_include

begin_include
include|#
directive|include
file|"str.h"
end_include

begin_include
include|#
directive|include
file|"targ.h"
end_include

begin_include
include|#
directive|include
file|"util.h"
end_include

begin_include
include|#
directive|include
file|"var.h"
end_include

begin_comment
comment|/**  *  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|VarParser
block|{
specifier|const
name|char
modifier|*
specifier|const
name|input
decl_stmt|;
comment|/* pointer to input string */
specifier|const
name|char
modifier|*
name|ptr
decl_stmt|;
comment|/* current parser pos in input str */
name|GNode
modifier|*
name|ctxt
decl_stmt|;
name|Boolean
name|err
decl_stmt|;
name|Boolean
name|execute
decl_stmt|;
block|}
name|VarParser
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|Var
block|{
name|char
modifier|*
name|name
decl_stmt|;
comment|/* the variable's name */
name|struct
name|Buffer
modifier|*
name|val
decl_stmt|;
comment|/* its value */
name|int
name|flags
decl_stmt|;
comment|/* miscellaneous status flags */
define|#
directive|define
name|VAR_IN_USE
value|1
comment|/* Variable's value currently being used. 				 * Used to avoid recursion */
define|#
directive|define
name|VAR_JUNK
value|4
comment|/* Variable is a junk variable that 				 * should be destroyed when done with 				 * it. Used by Var_Parse for undefined, 				 * modified variables */
define|#
directive|define
name|VAR_TO_ENV
value|8
comment|/* Place variable in environment */
block|}
name|Var
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|struct
name|Buffer
modifier|*
name|lhs
decl_stmt|;
comment|/* String to match */
name|struct
name|Buffer
modifier|*
name|rhs
decl_stmt|;
comment|/* Replacement string (w/&'s removed) */
name|regex_t
name|re
decl_stmt|;
name|int
name|nsub
decl_stmt|;
name|regmatch_t
modifier|*
name|matches
decl_stmt|;
name|int
name|flags
decl_stmt|;
define|#
directive|define
name|VAR_SUB_GLOBAL
value|0x01
comment|/* Apply substitution globally */
define|#
directive|define
name|VAR_SUB_ONE
value|0x02
comment|/* Apply substitution to one word */
define|#
directive|define
name|VAR_SUB_MATCHED
value|0x04
comment|/* There was a match */
define|#
directive|define
name|VAR_MATCH_START
value|0x08
comment|/* Match at start of word */
define|#
directive|define
name|VAR_MATCH_END
value|0x10
comment|/* Match at end of word */
block|}
name|VarPattern
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|Boolean
name|VarModifyProc
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|Boolean
parameter_list|,
name|struct
name|Buffer
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_typedef

begin_function_decl
specifier|static
name|char
modifier|*
name|VarParse
parameter_list|(
name|VarParser
modifier|*
parameter_list|,
name|Boolean
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * This is a harmless return value for Var_Parse that can be used by Var_Subst  * to determine if there was an error in parsing -- easier than returning  * a flag, as things outside this module don't give a hoot.  */
end_comment

begin_decl_stmt
name|char
name|var_Error
index|[]
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Similar to var_Error, but returned when the 'err' flag for Var_Parse is  * set false. Why not just use a constant? Well, gcc likes to condense  * identical string instances...  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|varNoError
index|[]
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Internally, variables are contained in four different contexts.  *	1) the environment. They may not be changed. If an environment  *	   variable is appended-to, the result is placed in the global  *	   context.  *	2) the global context. Variables set in the Makefile are located in  *	   the global context. It is the penultimate context searched when  *	   substituting.  *	3) the command-line context. All variables set on the command line  *	   are placed in this context. They are UNALTERABLE once placed here.  *	4) the local context. Each target has associated with it a context  *	   list. On this list are located the structures describing such  *	   local variables as $(@) and $(*)  * The four contexts are searched in the reverse order from which they are  * listed.  */
end_comment

begin_decl_stmt
specifier|static
name|GNode
modifier|*
name|VAR_ENV
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* variables from the environment */
end_comment

begin_decl_stmt
name|GNode
modifier|*
name|VAR_GLOBAL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* variables from the makefile */
end_comment

begin_decl_stmt
name|GNode
modifier|*
name|VAR_CMD
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* variables defined on the command-line */
end_comment

begin_decl_stmt
name|Boolean
name|oldVars
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* variable substitution style */
end_comment

begin_decl_stmt
name|Boolean
name|checkEnvFirst
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -e flag */
end_comment

begin_define
define|#
directive|define
name|OPEN_PAREN
value|'('
end_define

begin_define
define|#
directive|define
name|CLOSE_PAREN
value|')'
end_define

begin_define
define|#
directive|define
name|OPEN_BRACE
value|'{'
end_define

begin_define
define|#
directive|define
name|CLOSE_BRACE
value|'}'
end_define

begin_comment
comment|/**  * Create a Var object.  *  * Params:  *	name		Name of variable (copied).  *	value		Value of variable (copied) or NULL.  *	flags		Flags set on variable.  *  * Returns:  *	New variable.  */
end_comment

begin_function
specifier|static
name|Var
modifier|*
name|VarCreate
parameter_list|(
specifier|const
name|char
name|name
index|[]
parameter_list|,
specifier|const
name|char
name|value
index|[]
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|Var
modifier|*
name|v
decl_stmt|;
name|v
operator|=
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Var
argument_list|)
argument_list|)
expr_stmt|;
name|v
operator|->
name|name
operator|=
name|estrdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|v
operator|->
name|val
operator|=
name|Buf_Init
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|v
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
if|if
condition|(
name|value
operator|!=
name|NULL
condition|)
block|{
name|Buf_Append
argument_list|(
name|v
operator|->
name|val
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|v
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Destroy a Var object.  *  * Params:  *	v	Object to destroy.  *	f	True if internal buffer in Buffer object is to be removed.  */
end_comment

begin_function
specifier|static
name|void
name|VarDestroy
parameter_list|(
name|Var
modifier|*
name|v
parameter_list|,
name|Boolean
name|f
parameter_list|)
block|{
name|Buf_Destroy
argument_list|(
name|v
operator|->
name|val
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|v
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Remove the tail of the given word and place the result in the given  * buffer.  *  * Results:  *	TRUE if characters were added to the buffer (a space needs to be  *	added to the buffer before the next word).  *  * Side Effects:  *	The trimmed word is added to the buffer.  */
end_comment

begin_function
specifier|static
name|Boolean
name|VarHead
parameter_list|(
specifier|const
name|char
modifier|*
name|word
parameter_list|,
name|Boolean
name|addSpace
parameter_list|,
name|Buffer
modifier|*
name|buf
parameter_list|,
name|void
modifier|*
name|dummy
name|__unused
parameter_list|)
block|{
name|char
modifier|*
name|slash
decl_stmt|;
name|slash
operator|=
name|strrchr
argument_list|(
name|word
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|slash
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|addSpace
condition|)
block|{
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
operator|(
name|Byte
operator|)
literal|' '
argument_list|)
expr_stmt|;
block|}
name|Buf_AppendRange
argument_list|(
name|buf
argument_list|,
name|word
argument_list|,
name|slash
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * If no directory part, give . (q.v. the POSIX standard) 		 */
if|if
condition|(
name|addSpace
condition|)
block|{
name|Buf_Append
argument_list|(
name|buf
argument_list|,
literal|" ."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
operator|(
name|Byte
operator|)
literal|'.'
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Remove the head of the given word and place the result in the given  * buffer.  *  * Results:  *	TRUE if characters were added to the buffer (a space needs to be  *	added to the buffer before the next word).  *  * Side Effects:  *	The trimmed word is added to the buffer.  */
end_comment

begin_function
specifier|static
name|Boolean
name|VarTail
parameter_list|(
specifier|const
name|char
modifier|*
name|word
parameter_list|,
name|Boolean
name|addSpace
parameter_list|,
name|Buffer
modifier|*
name|buf
parameter_list|,
name|void
modifier|*
name|dummy
name|__unused
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|slash
decl_stmt|;
if|if
condition|(
name|addSpace
condition|)
block|{
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
operator|(
name|Byte
operator|)
literal|' '
argument_list|)
expr_stmt|;
block|}
name|slash
operator|=
name|strrchr
argument_list|(
name|word
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|slash
operator|!=
name|NULL
condition|)
block|{
name|slash
operator|++
expr_stmt|;
name|Buf_Append
argument_list|(
name|buf
argument_list|,
name|slash
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Buf_Append
argument_list|(
name|buf
argument_list|,
name|word
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Place the suffix of the given word in the given buffer.  *  * Results:  *	TRUE if characters were added to the buffer (a space needs to be  *	added to the buffer before the next word).  *  * Side Effects:  *	The suffix from the word is placed in the buffer.  */
end_comment

begin_function
specifier|static
name|Boolean
name|VarSuffix
parameter_list|(
specifier|const
name|char
modifier|*
name|word
parameter_list|,
name|Boolean
name|addSpace
parameter_list|,
name|Buffer
modifier|*
name|buf
parameter_list|,
name|void
modifier|*
name|dummy
name|__unused
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|dot
decl_stmt|;
name|dot
operator|=
name|strrchr
argument_list|(
name|word
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|dot
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|addSpace
condition|)
block|{
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
operator|(
name|Byte
operator|)
literal|' '
argument_list|)
expr_stmt|;
block|}
name|dot
operator|++
expr_stmt|;
name|Buf_Append
argument_list|(
name|buf
argument_list|,
name|dot
argument_list|)
expr_stmt|;
name|addSpace
operator|=
name|TRUE
expr_stmt|;
block|}
return|return
operator|(
name|addSpace
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Remove the suffix of the given word and place the result in the  * buffer.  *  * Results:  *	TRUE if characters were added to the buffer (a space needs to be  *	added to the buffer before the next word).  *  * Side Effects:  *	The trimmed word is added to the buffer.  */
end_comment

begin_function
specifier|static
name|Boolean
name|VarRoot
parameter_list|(
specifier|const
name|char
modifier|*
name|word
parameter_list|,
name|Boolean
name|addSpace
parameter_list|,
name|Buffer
modifier|*
name|buf
parameter_list|,
name|void
modifier|*
name|dummy
name|__unused
parameter_list|)
block|{
name|char
modifier|*
name|dot
decl_stmt|;
if|if
condition|(
name|addSpace
condition|)
block|{
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
operator|(
name|Byte
operator|)
literal|' '
argument_list|)
expr_stmt|;
block|}
name|dot
operator|=
name|strrchr
argument_list|(
name|word
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|dot
operator|!=
name|NULL
condition|)
block|{
name|Buf_AppendRange
argument_list|(
name|buf
argument_list|,
name|word
argument_list|,
name|dot
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Buf_Append
argument_list|(
name|buf
argument_list|,
name|word
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Place the word in the buffer if it matches the given pattern.  * Callback function for VarModify to implement the :M modifier.  * A space will be added if requested.  A pattern is supplied  * which the word must match.  *  * Results:  *	TRUE if a space should be placed in the buffer before the next  *	word.  *  * Side Effects:  *	The word may be copied to the buffer.  */
end_comment

begin_function
specifier|static
name|Boolean
name|VarMatch
parameter_list|(
specifier|const
name|char
modifier|*
name|word
parameter_list|,
name|Boolean
name|addSpace
parameter_list|,
name|Buffer
modifier|*
name|buf
parameter_list|,
name|void
modifier|*
name|pattern
parameter_list|)
block|{
if|if
condition|(
name|Str_Match
argument_list|(
name|word
argument_list|,
name|pattern
argument_list|)
condition|)
block|{
if|if
condition|(
name|addSpace
condition|)
block|{
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
operator|(
name|Byte
operator|)
literal|' '
argument_list|)
expr_stmt|;
block|}
name|addSpace
operator|=
name|TRUE
expr_stmt|;
name|Buf_Append
argument_list|(
name|buf
argument_list|,
name|word
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|addSpace
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SYSVVARSUB
end_ifdef

begin_comment
comment|/**  * Place the word in the buffer if it matches the given pattern.  * Callback function for VarModify to implement the System V %  * modifiers.  A space is added if requested.  *  * Results:  *	TRUE if a space should be placed in the buffer before the next  *	word.  *  * Side Effects:  *	The word may be copied to the buffer.  */
end_comment

begin_function
specifier|static
name|Boolean
name|VarSYSVMatch
parameter_list|(
specifier|const
name|char
modifier|*
name|word
parameter_list|,
name|Boolean
name|addSpace
parameter_list|,
name|Buffer
modifier|*
name|buf
parameter_list|,
name|void
modifier|*
name|patp
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
specifier|const
name|char
modifier|*
name|ptr
decl_stmt|;
name|VarPattern
modifier|*
name|pat
init|=
operator|(
name|VarPattern
operator|*
operator|)
name|patp
decl_stmt|;
if|if
condition|(
name|addSpace
condition|)
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
operator|(
name|Byte
operator|)
literal|' '
argument_list|)
expr_stmt|;
name|addSpace
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|(
name|ptr
operator|=
name|Str_SYSVMatch
argument_list|(
name|word
argument_list|,
name|Buf_Data
argument_list|(
name|pat
operator|->
name|lhs
argument_list|)
argument_list|,
operator|&
name|len
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|Str_SYSVSubst
argument_list|(
name|buf
argument_list|,
name|Buf_Data
argument_list|(
name|pat
operator|->
name|rhs
argument_list|)
argument_list|,
name|ptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
else|else
name|Buf_Append
argument_list|(
name|buf
argument_list|,
name|word
argument_list|)
expr_stmt|;
return|return
operator|(
name|addSpace
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * Place the word in the buffer if it doesn't match the given pattern.  * Callback function for VarModify to implement the :N modifier.  A  * space is added if requested.  *  * Results:  *	TRUE if a space should be placed in the buffer before the next  *	word.  *  * Side Effects:  *	The word may be copied to the buffer.  */
end_comment

begin_function
specifier|static
name|Boolean
name|VarNoMatch
parameter_list|(
specifier|const
name|char
modifier|*
name|word
parameter_list|,
name|Boolean
name|addSpace
parameter_list|,
name|Buffer
modifier|*
name|buf
parameter_list|,
name|void
modifier|*
name|pattern
parameter_list|)
block|{
if|if
condition|(
operator|!
name|Str_Match
argument_list|(
name|word
argument_list|,
name|pattern
argument_list|)
condition|)
block|{
if|if
condition|(
name|addSpace
condition|)
block|{
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
operator|(
name|Byte
operator|)
literal|' '
argument_list|)
expr_stmt|;
block|}
name|addSpace
operator|=
name|TRUE
expr_stmt|;
name|Buf_Append
argument_list|(
name|buf
argument_list|,
name|word
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|addSpace
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Perform a string-substitution on the given word, placing the  * result in the passed buffer.  A space is added if requested.  *  * Results:  *	TRUE if a space is needed before more characters are added.  */
end_comment

begin_function
specifier|static
name|Boolean
name|VarSubstitute
parameter_list|(
specifier|const
name|char
modifier|*
name|word
parameter_list|,
name|Boolean
name|addSpace
parameter_list|,
name|Buffer
modifier|*
name|buf
parameter_list|,
name|void
modifier|*
name|patternp
parameter_list|)
block|{
name|size_t
name|wordLen
decl_stmt|;
comment|/* Length of word */
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* General pointer */
name|VarPattern
modifier|*
name|pattern
init|=
name|patternp
decl_stmt|;
name|wordLen
operator|=
name|strlen
argument_list|(
name|word
argument_list|)
expr_stmt|;
if|if
condition|(
literal|1
condition|)
block|{
comment|/* substitute in each word of the variable */
comment|/* 		 * Break substitution down into simple anchored cases 		 * and if none of them fits, perform the general substitution 		 * case. 		 */
if|if
condition|(
operator|(
name|pattern
operator|->
name|flags
operator|&
name|VAR_MATCH_START
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|word
argument_list|,
name|Buf_Data
argument_list|(
name|pattern
operator|->
name|lhs
argument_list|)
argument_list|,
name|Buf_Size
argument_list|(
name|pattern
operator|->
name|lhs
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* 			 * Anchored at start and beginning of word matches 			 * pattern. 			 */
if|if
condition|(
operator|(
name|pattern
operator|->
name|flags
operator|&
name|VAR_MATCH_END
operator|)
operator|&&
operator|(
name|wordLen
operator|==
name|Buf_Size
argument_list|(
name|pattern
operator|->
name|lhs
argument_list|)
operator|)
condition|)
block|{
comment|/* 				 * Also anchored at end and matches to the end 				 * (word is same length as pattern) add space 				 * and rhs only if rhs is non-null. 				 */
if|if
condition|(
name|Buf_Size
argument_list|(
name|pattern
operator|->
name|rhs
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|addSpace
condition|)
block|{
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
operator|(
name|Byte
operator|)
literal|' '
argument_list|)
expr_stmt|;
block|}
name|addSpace
operator|=
name|TRUE
expr_stmt|;
name|Buf_AppendBuf
argument_list|(
name|buf
argument_list|,
name|pattern
operator|->
name|rhs
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|pattern
operator|->
name|flags
operator|&
name|VAR_MATCH_END
condition|)
block|{
comment|/* 				 * Doesn't match to end -- copy word wholesale 				 */
goto|goto
name|nosub
goto|;
block|}
else|else
block|{
comment|/* 				 * Matches at start but need to copy in 				 * trailing characters. 				 */
if|if
condition|(
operator|(
name|Buf_Size
argument_list|(
name|pattern
operator|->
name|rhs
argument_list|)
operator|+
name|wordLen
operator|-
name|Buf_Size
argument_list|(
name|pattern
operator|->
name|lhs
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|addSpace
condition|)
block|{
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
operator|(
name|Byte
operator|)
literal|' '
argument_list|)
expr_stmt|;
block|}
name|addSpace
operator|=
name|TRUE
expr_stmt|;
block|}
name|Buf_AppendBuf
argument_list|(
name|buf
argument_list|,
name|pattern
operator|->
name|rhs
argument_list|)
expr_stmt|;
name|Buf_AddBytes
argument_list|(
name|buf
argument_list|,
name|wordLen
operator|-
name|Buf_Size
argument_list|(
name|pattern
operator|->
name|lhs
argument_list|)
argument_list|,
operator|(
name|word
operator|+
name|Buf_Size
argument_list|(
name|pattern
operator|->
name|lhs
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|pattern
operator|->
name|flags
operator|&
name|VAR_MATCH_START
condition|)
block|{
comment|/* 			 * Had to match at start of word and didn't -- copy 			 * whole word. 			 */
goto|goto
name|nosub
goto|;
block|}
elseif|else
if|if
condition|(
name|pattern
operator|->
name|flags
operator|&
name|VAR_MATCH_END
condition|)
block|{
comment|/* 			 * Anchored at end, Find only place match could occur 			 * (leftLen characters from the end of the word) and 			 * see if it does. Note that because the $ will be 			 * left at the end of the lhs, we have to use strncmp. 			 */
name|cp
operator|=
name|word
operator|+
operator|(
name|wordLen
operator|-
name|Buf_Size
argument_list|(
name|pattern
operator|->
name|lhs
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|>=
name|word
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|cp
argument_list|,
name|Buf_Data
argument_list|(
name|pattern
operator|->
name|lhs
argument_list|)
argument_list|,
name|Buf_Size
argument_list|(
name|pattern
operator|->
name|lhs
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* 				 * Match found. If we will place characters in 				 * the buffer, add a space before hand as 				 * indicated by addSpace, then stuff in the 				 * initial, unmatched part of the word followed 				 * by the right-hand-side. 				 */
if|if
condition|(
operator|(
name|cp
operator|-
name|word
operator|)
operator|+
name|Buf_Size
argument_list|(
name|pattern
operator|->
name|rhs
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|addSpace
condition|)
block|{
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
operator|(
name|Byte
operator|)
literal|' '
argument_list|)
expr_stmt|;
block|}
name|addSpace
operator|=
name|TRUE
expr_stmt|;
block|}
name|Buf_AppendRange
argument_list|(
name|buf
argument_list|,
name|word
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|Buf_AppendBuf
argument_list|(
name|buf
argument_list|,
name|pattern
operator|->
name|rhs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * Had to match at end and didn't. Copy entire 				 * word. 				 */
goto|goto
name|nosub
goto|;
block|}
block|}
else|else
block|{
comment|/* 			 * Pattern is unanchored: search for the pattern in the 			 * word using strstr(3), copying unmatched portions and 			 * the right-hand-side for each match found, handling 			 * non-global substitutions correctly, etc. When the 			 * loop is done, any remaining part of the word (word 			 * and wordLen are adjusted accordingly through the 			 * loop) is copied straight into the buffer. 			 * addSpace is set FALSE as soon as a space is added 			 * to the buffer. 			 */
name|Boolean
name|done
decl_stmt|;
name|size_t
name|origSize
decl_stmt|;
name|done
operator|=
name|FALSE
expr_stmt|;
name|origSize
operator|=
name|Buf_Size
argument_list|(
name|buf
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|done
condition|)
block|{
name|cp
operator|=
name|strstr
argument_list|(
name|word
argument_list|,
name|Buf_Data
argument_list|(
name|pattern
operator|->
name|lhs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|addSpace
operator|&&
operator|(
operator|(
operator|(
name|cp
operator|-
name|word
operator|)
operator|+
name|Buf_Size
argument_list|(
name|pattern
operator|->
name|rhs
argument_list|)
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
operator|(
name|Byte
operator|)
literal|' '
argument_list|)
expr_stmt|;
name|addSpace
operator|=
name|FALSE
expr_stmt|;
block|}
name|Buf_AppendRange
argument_list|(
name|buf
argument_list|,
name|word
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|Buf_AppendBuf
argument_list|(
name|buf
argument_list|,
name|pattern
operator|->
name|rhs
argument_list|)
expr_stmt|;
name|wordLen
operator|-=
operator|(
name|cp
operator|-
name|word
operator|)
operator|+
name|Buf_Size
argument_list|(
name|pattern
operator|->
name|lhs
argument_list|)
expr_stmt|;
name|word
operator|=
name|cp
operator|+
name|Buf_Size
argument_list|(
name|pattern
operator|->
name|lhs
argument_list|)
expr_stmt|;
if|if
condition|(
name|wordLen
operator|==
literal|0
operator|||
operator|(
name|pattern
operator|->
name|flags
operator|&
name|VAR_SUB_GLOBAL
operator|)
operator|==
literal|0
condition|)
block|{
name|done
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
else|else
block|{
name|done
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|wordLen
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|addSpace
condition|)
block|{
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
operator|(
name|Byte
operator|)
literal|' '
argument_list|)
expr_stmt|;
block|}
name|Buf_AddBytes
argument_list|(
name|buf
argument_list|,
name|wordLen
argument_list|,
operator|(
specifier|const
name|Byte
operator|*
operator|)
name|word
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * If added characters to the buffer, need to add a 			 * space before we add any more. If we didn't add any, 			 * just return the previous value of addSpace. 			 */
return|return
operator|(
operator|(
name|Buf_Size
argument_list|(
name|buf
argument_list|)
operator|!=
name|origSize
operator|)
operator|||
name|addSpace
operator|)
return|;
block|}
comment|/* 		 * Common code for anchored substitutions: 		 * addSpace was set TRUE if characters were added to the buffer. 		 */
return|return
operator|(
name|addSpace
operator|)
return|;
block|}
name|nosub
label|:
if|if
condition|(
name|addSpace
condition|)
block|{
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
operator|(
name|Byte
operator|)
literal|' '
argument_list|)
expr_stmt|;
block|}
name|Buf_AddBytes
argument_list|(
name|buf
argument_list|,
name|wordLen
argument_list|,
operator|(
specifier|const
name|Byte
operator|*
operator|)
name|word
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Print the error caused by a regcomp or regexec call.  *  * Side Effects:  *	An error gets printed.  */
end_comment

begin_function
specifier|static
name|void
name|VarREError
parameter_list|(
name|int
name|err
parameter_list|,
name|regex_t
modifier|*
name|pat
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
name|char
modifier|*
name|errbuf
decl_stmt|;
name|int
name|errlen
decl_stmt|;
name|errlen
operator|=
name|regerror
argument_list|(
name|err
argument_list|,
name|pat
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|errbuf
operator|=
name|emalloc
argument_list|(
name|errlen
argument_list|)
expr_stmt|;
name|regerror
argument_list|(
name|err
argument_list|,
name|pat
argument_list|,
name|errbuf
argument_list|,
name|errlen
argument_list|)
expr_stmt|;
name|Error
argument_list|(
literal|"%s: %s"
argument_list|,
name|str
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|errbuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Perform a regex substitution on the given word, placing the  * result in the passed buffer.  A space is added if requested.  *  * Results:  *	TRUE if a space is needed before more characters are added.  */
end_comment

begin_function
specifier|static
name|Boolean
name|VarRESubstitute
parameter_list|(
specifier|const
name|char
modifier|*
name|word
parameter_list|,
name|Boolean
name|addSpace
parameter_list|,
name|Buffer
modifier|*
name|buf
parameter_list|,
name|void
modifier|*
name|patternp
parameter_list|)
block|{
name|VarPattern
modifier|*
name|pat
decl_stmt|;
name|int
name|xrv
decl_stmt|;
specifier|const
name|char
modifier|*
name|wp
decl_stmt|;
name|char
modifier|*
name|rp
decl_stmt|;
name|int
name|added
decl_stmt|;
name|int
name|flags
init|=
literal|0
decl_stmt|;
define|#
directive|define
name|MAYBE_ADD_SPACE
parameter_list|()
define|\
value|if (addSpace&& !added)			\ 		Buf_AddByte(buf, (Byte)' ');	\ 	added = 1
name|added
operator|=
literal|0
expr_stmt|;
name|wp
operator|=
name|word
expr_stmt|;
name|pat
operator|=
name|patternp
expr_stmt|;
if|if
condition|(
operator|(
name|pat
operator|->
name|flags
operator|&
operator|(
name|VAR_SUB_ONE
operator||
name|VAR_SUB_MATCHED
operator|)
operator|)
operator|==
operator|(
name|VAR_SUB_ONE
operator||
name|VAR_SUB_MATCHED
operator|)
condition|)
block|{
name|xrv
operator|=
name|REG_NOMATCH
expr_stmt|;
block|}
else|else
block|{
name|tryagain
label|:
name|xrv
operator|=
name|regexec
argument_list|(
operator|&
name|pat
operator|->
name|re
argument_list|,
name|wp
argument_list|,
name|pat
operator|->
name|nsub
argument_list|,
name|pat
operator|->
name|matches
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|xrv
condition|)
block|{
case|case
literal|0
case|:
name|pat
operator|->
name|flags
operator||=
name|VAR_SUB_MATCHED
expr_stmt|;
if|if
condition|(
name|pat
operator|->
name|matches
index|[
literal|0
index|]
operator|.
name|rm_so
operator|>
literal|0
condition|)
block|{
name|MAYBE_ADD_SPACE
argument_list|()
expr_stmt|;
name|Buf_AddBytes
argument_list|(
name|buf
argument_list|,
name|pat
operator|->
name|matches
index|[
literal|0
index|]
operator|.
name|rm_so
argument_list|,
operator|(
specifier|const
name|Byte
operator|*
operator|)
name|wp
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|rp
operator|=
name|Buf_Data
argument_list|(
name|pat
operator|->
name|rhs
argument_list|)
init|;
operator|*
name|rp
condition|;
name|rp
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|rp
operator|==
literal|'\\'
operator|)
operator|&&
operator|(
operator|(
name|rp
index|[
literal|1
index|]
operator|==
literal|'&'
operator|)
operator|||
operator|(
name|rp
index|[
literal|1
index|]
operator|==
literal|'\\'
operator|)
operator|)
condition|)
block|{
name|MAYBE_ADD_SPACE
argument_list|()
expr_stmt|;
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
operator|(
name|Byte
operator|)
name|rp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|rp
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|rp
operator|==
literal|'&'
operator|)
operator|||
operator|(
operator|(
operator|*
name|rp
operator|==
literal|'\\'
operator|)
operator|&&
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|rp
index|[
literal|1
index|]
argument_list|)
operator|)
condition|)
block|{
name|int
name|n
decl_stmt|;
specifier|const
name|char
modifier|*
name|subbuf
decl_stmt|;
name|int
name|sublen
decl_stmt|;
name|char
name|errstr
index|[
literal|3
index|]
decl_stmt|;
if|if
condition|(
operator|*
name|rp
operator|==
literal|'&'
condition|)
block|{
name|n
operator|=
literal|0
expr_stmt|;
name|errstr
index|[
literal|0
index|]
operator|=
literal|'&'
expr_stmt|;
name|errstr
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
name|n
operator|=
name|rp
index|[
literal|1
index|]
operator|-
literal|'0'
expr_stmt|;
name|errstr
index|[
literal|0
index|]
operator|=
literal|'\\'
expr_stmt|;
name|errstr
index|[
literal|1
index|]
operator|=
name|rp
index|[
literal|1
index|]
expr_stmt|;
name|errstr
index|[
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
name|rp
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|>
name|pat
operator|->
name|nsub
condition|)
block|{
name|Error
argument_list|(
literal|"No subexpression %s"
argument_list|,
operator|&
name|errstr
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|subbuf
operator|=
literal|""
expr_stmt|;
name|sublen
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|pat
operator|->
name|matches
index|[
name|n
index|]
operator|.
name|rm_so
operator|==
operator|-
literal|1
operator|)
operator|&&
operator|(
name|pat
operator|->
name|matches
index|[
name|n
index|]
operator|.
name|rm_eo
operator|==
operator|-
literal|1
operator|)
condition|)
block|{
name|Error
argument_list|(
literal|"No match for subexpression %s"
argument_list|,
operator|&
name|errstr
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|subbuf
operator|=
literal|""
expr_stmt|;
name|sublen
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|subbuf
operator|=
name|wp
operator|+
name|pat
operator|->
name|matches
index|[
name|n
index|]
operator|.
name|rm_so
expr_stmt|;
name|sublen
operator|=
name|pat
operator|->
name|matches
index|[
name|n
index|]
operator|.
name|rm_eo
operator|-
name|pat
operator|->
name|matches
index|[
name|n
index|]
operator|.
name|rm_so
expr_stmt|;
block|}
if|if
condition|(
name|sublen
operator|>
literal|0
condition|)
block|{
name|MAYBE_ADD_SPACE
argument_list|()
expr_stmt|;
name|Buf_AddBytes
argument_list|(
name|buf
argument_list|,
name|sublen
argument_list|,
operator|(
specifier|const
name|Byte
operator|*
operator|)
name|subbuf
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|MAYBE_ADD_SPACE
argument_list|()
expr_stmt|;
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
operator|(
name|Byte
operator|)
operator|*
name|rp
argument_list|)
expr_stmt|;
block|}
block|}
name|wp
operator|+=
name|pat
operator|->
name|matches
index|[
literal|0
index|]
operator|.
name|rm_eo
expr_stmt|;
if|if
condition|(
name|pat
operator|->
name|flags
operator|&
name|VAR_SUB_GLOBAL
condition|)
block|{
name|flags
operator||=
name|REG_NOTBOL
expr_stmt|;
if|if
condition|(
name|pat
operator|->
name|matches
index|[
literal|0
index|]
operator|.
name|rm_so
operator|==
literal|0
operator|&&
name|pat
operator|->
name|matches
index|[
literal|0
index|]
operator|.
name|rm_eo
operator|==
literal|0
condition|)
block|{
name|MAYBE_ADD_SPACE
argument_list|()
expr_stmt|;
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
operator|(
name|Byte
operator|)
operator|*
name|wp
argument_list|)
expr_stmt|;
name|wp
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|wp
condition|)
goto|goto
name|tryagain
goto|;
block|}
if|if
condition|(
operator|*
name|wp
condition|)
block|{
name|MAYBE_ADD_SPACE
argument_list|()
expr_stmt|;
name|Buf_Append
argument_list|(
name|buf
argument_list|,
name|wp
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|VarREError
argument_list|(
name|xrv
argument_list|,
operator|&
name|pat
operator|->
name|re
argument_list|,
literal|"Unexpected regex error"
argument_list|)
expr_stmt|;
comment|/* fall through */
case|case
name|REG_NOMATCH
case|:
if|if
condition|(
operator|*
name|wp
condition|)
block|{
name|MAYBE_ADD_SPACE
argument_list|()
expr_stmt|;
name|Buf_Append
argument_list|(
name|buf
argument_list|,
name|wp
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
return|return
operator|(
name|addSpace
operator|||
name|added
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Find a variable in a variable list.  */
end_comment

begin_function
specifier|static
name|Var
modifier|*
name|VarLookup
parameter_list|(
name|Lst
modifier|*
name|vlist
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|LstNode
modifier|*
name|ln
decl_stmt|;
name|LST_FOREACH
argument_list|(
argument|ln
argument_list|,
argument|vlist
argument_list|)
if|if
condition|(
name|strcmp
argument_list|(
operator|(
operator|(
specifier|const
name|Var
operator|*
operator|)
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
operator|)
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
operator|)
return|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Expand a variable name's embedded variables in the given context.  *  * Results:  *	The contents of name, possibly expanded.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|VarPossiblyExpand
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|GNode
modifier|*
name|ctxt
parameter_list|)
block|{
name|Buffer
modifier|*
name|buf
decl_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|name
argument_list|,
literal|'$'
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|buf
operator|=
name|Var_Subst
argument_list|(
name|name
argument_list|,
name|ctxt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|Buf_Peel
argument_list|(
name|buf
argument_list|)
operator|)
return|;
block|}
else|else
block|{
return|return
name|estrdup
argument_list|(
name|name
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/**  * If the variable name begins with a '.', it could very well be  * one of the local ones.  We check the name against all the local  * variables and substitute the short version in for 'name' if it  * matches one of them.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|VarLocal
parameter_list|(
specifier|const
name|char
name|name
index|[]
parameter_list|)
block|{
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
block|{
switch|switch
condition|(
name|name
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'A'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".ALLSRC"
argument_list|)
condition|)
return|return
operator|(
name|ALLSRC
operator|)
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".ARCHIVE"
argument_list|)
condition|)
return|return
operator|(
name|ARCHIVE
operator|)
return|;
break|break;
case|case
literal|'I'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".IMPSRC"
argument_list|)
condition|)
return|return
operator|(
name|IMPSRC
operator|)
return|;
break|break;
case|case
literal|'M'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".MEMBER"
argument_list|)
condition|)
return|return
operator|(
name|MEMBER
operator|)
return|;
break|break;
case|case
literal|'O'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".OODATE"
argument_list|)
condition|)
return|return
operator|(
name|OODATE
operator|)
return|;
break|break;
case|case
literal|'P'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".PREFIX"
argument_list|)
condition|)
return|return
operator|(
name|PREFIX
operator|)
return|;
break|break;
case|case
literal|'T'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".TARGET"
argument_list|)
condition|)
return|return
operator|(
name|TARGET
operator|)
return|;
break|break;
default|default:
break|break;
block|}
block|}
return|return
operator|(
name|name
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Find the given variable in the given context and the enviornment.  *  * Results:  *	A pointer to the structure describing the desired variable or  *	NULL if the variable does not exist.  */
end_comment

begin_function
specifier|static
name|Var
modifier|*
name|VarFindEnv
parameter_list|(
specifier|const
name|char
name|name
index|[]
parameter_list|,
name|GNode
modifier|*
name|ctxt
parameter_list|)
block|{
name|Var
modifier|*
name|var
decl_stmt|;
name|name
operator|=
name|VarLocal
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|var
operator|=
name|VarLookup
argument_list|(
operator|&
name|ctxt
operator|->
name|context
argument_list|,
name|name
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
return|return
operator|(
name|var
operator|)
return|;
if|if
condition|(
operator|(
name|var
operator|=
name|VarLookup
argument_list|(
operator|&
name|VAR_ENV
operator|->
name|context
argument_list|,
name|name
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
return|return
operator|(
name|var
operator|)
return|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Look for the variable in the given context.  */
end_comment

begin_function
specifier|static
name|Var
modifier|*
name|VarFindOnly
parameter_list|(
specifier|const
name|char
name|name
index|[]
parameter_list|,
name|GNode
modifier|*
name|ctxt
parameter_list|)
block|{
name|Var
modifier|*
name|var
decl_stmt|;
name|name
operator|=
name|VarLocal
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|var
operator|=
name|VarLookup
argument_list|(
operator|&
name|ctxt
operator|->
name|context
argument_list|,
name|name
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
return|return
operator|(
name|var
operator|)
return|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Look for the variable in all contexts.  */
end_comment

begin_function
specifier|static
name|Var
modifier|*
name|VarFindAny
parameter_list|(
specifier|const
name|char
name|name
index|[]
parameter_list|,
name|GNode
modifier|*
name|ctxt
parameter_list|)
block|{
name|Boolean
name|localCheckEnvFirst
decl_stmt|;
name|LstNode
modifier|*
name|ln
decl_stmt|;
name|Var
modifier|*
name|var
decl_stmt|;
name|name
operator|=
name|VarLocal
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* 	 * Note whether this is one of the specific variables we were told 	 * through the -E flag to use environment-variable-override for. 	 */
name|localCheckEnvFirst
operator|=
name|FALSE
expr_stmt|;
name|LST_FOREACH
argument_list|(
argument|ln
argument_list|,
argument|&envFirstVars
argument_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|localCheckEnvFirst
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
comment|/* 	 * First look for the variable in the given context. If it's not there, 	 * look for it in VAR_CMD, VAR_GLOBAL and the environment, 	 * in that order, depending on the FIND_* flags in 'flags' 	 */
if|if
condition|(
operator|(
name|var
operator|=
name|VarLookup
argument_list|(
operator|&
name|ctxt
operator|->
name|context
argument_list|,
name|name
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
return|return
operator|(
name|var
operator|)
return|;
comment|/* not there - try command line context */
if|if
condition|(
name|ctxt
operator|!=
name|VAR_CMD
condition|)
block|{
if|if
condition|(
operator|(
name|var
operator|=
name|VarLookup
argument_list|(
operator|&
name|VAR_CMD
operator|->
name|context
argument_list|,
name|name
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
return|return
operator|(
name|var
operator|)
return|;
block|}
comment|/* not there - try global context, but only if not -e/-E */
if|if
condition|(
name|ctxt
operator|!=
name|VAR_GLOBAL
operator|&&
operator|(
operator|!
name|checkEnvFirst
operator|&&
operator|!
name|localCheckEnvFirst
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|var
operator|=
name|VarLookup
argument_list|(
operator|&
name|VAR_GLOBAL
operator|->
name|context
argument_list|,
name|name
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
return|return
operator|(
name|var
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|var
operator|=
name|VarLookup
argument_list|(
operator|&
name|VAR_ENV
operator|->
name|context
argument_list|,
name|name
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
return|return
operator|(
name|var
operator|)
return|;
comment|/* deferred check for the environment (in case of -e/-E) */
if|if
condition|(
operator|(
name|ctxt
operator|!=
name|VAR_GLOBAL
operator|)
operator|&&
operator|(
name|checkEnvFirst
operator|||
name|localCheckEnvFirst
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|var
operator|=
name|VarLookup
argument_list|(
operator|&
name|VAR_GLOBAL
operator|->
name|context
argument_list|,
name|name
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
return|return
operator|(
name|var
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Add a new variable of name name and value val to the given context.  *  * Side Effects:  *	The new variable is placed at the front of the given context  *	The name and val arguments are duplicated so they may  *	safely be freed.  */
end_comment

begin_function
specifier|static
name|Var
modifier|*
name|VarAdd
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|val
parameter_list|,
name|GNode
modifier|*
name|ctxt
parameter_list|)
block|{
name|Var
modifier|*
name|v
decl_stmt|;
name|Lst_AtFront
argument_list|(
operator|&
name|ctxt
operator|->
name|context
argument_list|,
name|v
operator|=
name|VarCreate
argument_list|(
name|name
argument_list|,
name|val
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|DEBUGF
argument_list|(
name|VAR
argument_list|,
operator|(
literal|"%s:%s = %s\n"
operator|,
name|ctxt
operator|->
name|name
operator|,
name|name
operator|,
name|val
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|v
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Remove a variable from a context.  *  * Side Effects:  *	The Var structure is removed and freed.  */
end_comment

begin_function
name|void
name|Var_Delete
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|GNode
modifier|*
name|ctxt
parameter_list|)
block|{
name|LstNode
modifier|*
name|ln
decl_stmt|;
name|DEBUGF
argument_list|(
name|VAR
argument_list|,
operator|(
literal|"%s:delete %s\n"
operator|,
name|ctxt
operator|->
name|name
operator|,
name|name
operator|)
argument_list|)
expr_stmt|;
name|LST_FOREACH
argument_list|(
argument|ln
argument_list|,
argument|&ctxt->context
argument_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
operator|(
operator|(
specifier|const
name|Var
operator|*
operator|)
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
operator|)
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|VarDestroy
argument_list|(
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|Lst_Remove
argument_list|(
operator|&
name|ctxt
operator|->
name|context
argument_list|,
name|ln
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/**  * Set the variable name to the value val in the given context.  *  * Side Effects:  *	If the variable doesn't yet exist, a new record is created for it.  *	Else the old value is freed and the new one stuck in its place  *  * Notes:  *	The variable is searched for only in its context before being  *	created in that context. I.e. if the context is VAR_GLOBAL,  *	only VAR_GLOBAL->context is searched. Likewise if it is VAR_CMD, only  *	VAR_CMD->context is searched. This is done to avoid the literally  *	thousands of unnecessary strcmp's that used to be done to  *	set, say, $(@) or $(<).  */
end_comment

begin_function
name|void
name|Var_Set
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|val
parameter_list|,
name|GNode
modifier|*
name|ctxt
parameter_list|)
block|{
name|Var
modifier|*
name|v
decl_stmt|;
name|char
modifier|*
name|n
decl_stmt|;
comment|/* 	 * We only look for a variable in the given context since anything 	 * set here will override anything in a lower context, so there's not 	 * much point in searching them all just to save a bit of memory... 	 */
name|n
operator|=
name|VarPossiblyExpand
argument_list|(
name|name
argument_list|,
name|ctxt
argument_list|)
expr_stmt|;
name|v
operator|=
name|VarFindOnly
argument_list|(
name|n
argument_list|,
name|ctxt
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|==
name|NULL
condition|)
block|{
name|v
operator|=
name|VarAdd
argument_list|(
name|n
argument_list|,
name|val
argument_list|,
name|ctxt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Buf_Clear
argument_list|(
name|v
operator|->
name|val
argument_list|)
expr_stmt|;
name|Buf_Append
argument_list|(
name|v
operator|->
name|val
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|DEBUGF
argument_list|(
name|VAR
argument_list|,
operator|(
literal|"%s:%s = %s\n"
operator|,
name|ctxt
operator|->
name|name
operator|,
name|n
operator|,
name|val
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ctxt
operator|==
name|VAR_CMD
operator|||
operator|(
name|v
operator|->
name|flags
operator|&
name|VAR_TO_ENV
operator|)
condition|)
block|{
comment|/* 		 * Any variables given on the command line 		 * are automatically exported to the 		 * environment (as per POSIX standard) 		 */
name|setenv
argument_list|(
name|n
argument_list|,
name|val
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Set the a global name variable to the value.  */
end_comment

begin_function
name|void
name|Var_SetGlobal
parameter_list|(
specifier|const
name|char
name|name
index|[]
parameter_list|,
specifier|const
name|char
name|value
index|[]
parameter_list|)
block|{
name|Var_Set
argument_list|(
name|name
argument_list|,
name|value
argument_list|,
name|VAR_GLOBAL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Set the VAR_TO_ENV flag on a variable  */
end_comment

begin_function
name|void
name|Var_SetEnv
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|GNode
modifier|*
name|ctxt
parameter_list|)
block|{
name|Var
modifier|*
name|v
decl_stmt|;
name|v
operator|=
name|VarFindOnly
argument_list|(
name|name
argument_list|,
name|VAR_CMD
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Do not allow .EXPORT: to be set on variables 		 * from the comand line or MAKEFLAGS. 		 */
name|Error
argument_list|(
literal|"Warning: Did not set .EXPORTVAR: on %s because it "
literal|"is from the comand line or MAKEFLAGS"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
name|v
operator|=
name|VarFindAny
argument_list|(
name|name
argument_list|,
name|ctxt
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|==
name|NULL
condition|)
block|{
name|Lst_AtFront
argument_list|(
operator|&
name|VAR_ENV
operator|->
name|context
argument_list|,
name|VarCreate
argument_list|(
name|name
argument_list|,
name|NULL
argument_list|,
name|VAR_TO_ENV
argument_list|)
argument_list|)
expr_stmt|;
name|setenv
argument_list|(
name|name
argument_list|,
literal|""
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|Error
argument_list|(
literal|"Warning: .EXPORTVAR: set on undefined variable %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|v
operator|->
name|flags
operator|&
name|VAR_TO_ENV
operator|)
operator|==
literal|0
condition|)
block|{
name|v
operator|->
name|flags
operator||=
name|VAR_TO_ENV
expr_stmt|;
name|setenv
argument_list|(
name|v
operator|->
name|name
argument_list|,
name|Buf_Data
argument_list|(
name|v
operator|->
name|val
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/**  * The variable of the given name has the given value appended to it in  * the given context.  *  * Side Effects:  *	If the variable doesn't exist, it is created. Else the strings  *	are concatenated (with a space in between).  *  * Notes:  *	Only if the variable is being sought in the global context is the  *	environment searched.  *	XXX: Knows its calling circumstances in that if called with ctxt  *	an actual target, it will only search that context since only  *	a local variable could be being appended to. This is actually  *	a big win and must be tolerated.  */
end_comment

begin_function
name|void
name|Var_Append
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|val
parameter_list|,
name|GNode
modifier|*
name|ctxt
parameter_list|)
block|{
name|Var
modifier|*
name|v
decl_stmt|;
name|char
modifier|*
name|n
decl_stmt|;
name|n
operator|=
name|VarPossiblyExpand
argument_list|(
name|name
argument_list|,
name|ctxt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctxt
operator|==
name|VAR_GLOBAL
condition|)
block|{
name|v
operator|=
name|VarFindEnv
argument_list|(
name|n
argument_list|,
name|ctxt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|v
operator|=
name|VarFindOnly
argument_list|(
name|n
argument_list|,
name|ctxt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|v
operator|==
name|NULL
condition|)
block|{
name|VarAdd
argument_list|(
name|n
argument_list|,
name|val
argument_list|,
name|ctxt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Buf_AddByte
argument_list|(
name|v
operator|->
name|val
argument_list|,
operator|(
name|Byte
operator|)
literal|' '
argument_list|)
expr_stmt|;
name|Buf_Append
argument_list|(
name|v
operator|->
name|val
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|DEBUGF
argument_list|(
name|VAR
argument_list|,
operator|(
literal|"%s:%s = %s\n"
operator|,
name|ctxt
operator|->
name|name
operator|,
name|n
operator|,
name|Buf_Data
argument_list|(
name|v
operator|->
name|val
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * See if the given variable exists.  *  * Results:  *	TRUE if it does, FALSE if it doesn't  */
end_comment

begin_function
name|Boolean
name|Var_Exists
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|GNode
modifier|*
name|ctxt
parameter_list|)
block|{
name|Var
modifier|*
name|v
decl_stmt|;
name|char
modifier|*
name|n
decl_stmt|;
name|n
operator|=
name|VarPossiblyExpand
argument_list|(
name|name
argument_list|,
name|ctxt
argument_list|)
expr_stmt|;
name|v
operator|=
name|VarFindAny
argument_list|(
name|n
argument_list|,
name|ctxt
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|n
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
else|else
block|{
name|free
argument_list|(
name|n
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/**  * Return the value of the named variable in the given context  *  * Results:  *	The value if the variable exists, NULL if it doesn't.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|Var_Value
parameter_list|(
specifier|const
name|char
name|name
index|[]
parameter_list|,
name|GNode
modifier|*
name|ctxt
parameter_list|)
block|{
name|Var
modifier|*
name|v
decl_stmt|;
name|char
modifier|*
name|n
decl_stmt|;
name|n
operator|=
name|VarPossiblyExpand
argument_list|(
name|name
argument_list|,
name|ctxt
argument_list|)
expr_stmt|;
name|v
operator|=
name|VarFindAny
argument_list|(
name|n
argument_list|,
name|ctxt
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|Buf_Data
argument_list|(
name|v
operator|->
name|val
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/**  * Modify each of the words of the passed string using the given  * function. Used to implement all modifiers.  *  * Results:  *	A string of all the words modified appropriately.  *  * Side Effects:  *	Uses brk_string() so it invalidates any previous call to  *	brk_string().  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|VarModify
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|VarModifyProc
modifier|*
name|modProc
parameter_list|,
name|void
modifier|*
name|datum
parameter_list|)
block|{
name|ArgArray
name|aa
decl_stmt|;
name|Buffer
modifier|*
name|buf
decl_stmt|;
comment|/* Buffer for the new string */
name|int
name|i
decl_stmt|;
name|Boolean
name|addSpace
decl_stmt|;
comment|/* 					 * TRUE if need to add a space to 					 * the buffer before adding the 					 * trimmed word 					 */
name|brk_string
argument_list|(
operator|&
name|aa
argument_list|,
name|str
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|addSpace
operator|=
name|FALSE
expr_stmt|;
name|buf
operator|=
name|Buf_Init
argument_list|(
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|aa
operator|.
name|argc
condition|;
name|i
operator|++
control|)
name|addSpace
operator|=
call|(
modifier|*
name|modProc
call|)
argument_list|(
name|aa
operator|.
name|argv
index|[
name|i
index|]
argument_list|,
name|addSpace
argument_list|,
name|buf
argument_list|,
name|datum
argument_list|)
expr_stmt|;
name|ArgArray_Done
argument_list|(
operator|&
name|aa
argument_list|)
expr_stmt|;
return|return
operator|(
name|Buf_Peel
argument_list|(
name|buf
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Sort the words in the string.  *  * Input:  *	str		String whose words should be sorted  *	cmp		A comparison function to control the ordering  *  * Results:  *	A string containing the words sorted  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|VarSortWords
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|int
function_decl|(
modifier|*
name|cmp
function_decl|)
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
parameter_list|)
block|{
name|ArgArray
name|aa
decl_stmt|;
name|Buffer
modifier|*
name|buf
decl_stmt|;
name|int
name|i
decl_stmt|;
name|brk_string
argument_list|(
operator|&
name|aa
argument_list|,
name|str
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|qsort
argument_list|(
name|aa
operator|.
name|argv
operator|+
literal|1
argument_list|,
name|aa
operator|.
name|argc
operator|-
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|,
name|cmp
argument_list|)
expr_stmt|;
name|buf
operator|=
name|Buf_Init
argument_list|(
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|aa
operator|.
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|Buf_Append
argument_list|(
name|buf
argument_list|,
name|aa
operator|.
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
call|(
name|Byte
call|)
argument_list|(
operator|(
name|i
operator|<
name|aa
operator|.
name|argc
operator|-
literal|1
operator|)
condition|?
literal|' '
else|:
literal|'\0'
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ArgArray_Done
argument_list|(
operator|&
name|aa
argument_list|)
expr_stmt|;
return|return
operator|(
name|Buf_Peel
argument_list|(
name|buf
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|SortIncreasing
parameter_list|(
specifier|const
name|void
modifier|*
name|l
parameter_list|,
specifier|const
name|void
modifier|*
name|r
parameter_list|)
block|{
return|return
operator|(
name|strcmp
argument_list|(
operator|*
operator|(
specifier|const
name|char
operator|*
specifier|const
operator|*
operator|)
name|l
argument_list|,
operator|*
operator|(
specifier|const
name|char
operator|*
specifier|const
operator|*
operator|)
name|r
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Remove adjacent duplicate words.  *  * Results:  *	A string containing the resulting words.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|VarUniq
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
name|ArgArray
name|aa
decl_stmt|;
name|Buffer
modifier|*
name|buf
decl_stmt|;
comment|/* Buffer for new string */
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|buf
operator|=
name|Buf_Init
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|brk_string
argument_list|(
operator|&
name|aa
argument_list|,
name|str
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|aa
operator|.
name|argc
operator|>
literal|2
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|1
operator|,
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|aa
operator|.
name|argc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|aa
operator|.
name|argv
index|[
name|i
index|]
argument_list|,
name|aa
operator|.
name|argv
index|[
name|j
index|]
argument_list|)
operator|!=
literal|0
operator|&&
operator|(
operator|++
name|j
operator|!=
name|i
operator|)
condition|)
name|aa
operator|.
name|argv
index|[
name|j
index|]
operator|=
name|aa
operator|.
name|argv
index|[
name|i
index|]
expr_stmt|;
block|}
name|aa
operator|.
name|argc
operator|=
name|j
operator|+
literal|1
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|aa
operator|.
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|Buf_AddBytes
argument_list|(
name|buf
argument_list|,
name|strlen
argument_list|(
name|aa
operator|.
name|argv
index|[
name|i
index|]
argument_list|)
argument_list|,
operator|(
name|Byte
operator|*
operator|)
name|aa
operator|.
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|aa
operator|.
name|argc
operator|-
literal|1
condition|)
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
block|}
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
name|ArgArray_Done
argument_list|(
operator|&
name|aa
argument_list|)
expr_stmt|;
return|return
operator|(
name|Buf_Peel
argument_list|(
name|buf
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Pass through the tstr looking for 1) escaped delimiters,  * '$'s and backslashes (place the escaped character in  * uninterpreted) and 2) unescaped $'s that aren't before  * the delimiter (expand the variable substitution).  * Return the expanded string or NULL if the delimiter was missing  * If pattern is specified, handle escaped ampersands, and replace  * unescaped ampersands with the lhs of the pattern.  *  * Results:  *	A string of all the words modified appropriately.  *	If length is specified, return the string length of the buffer  *	If flags is specified and the last character of the pattern is a  *	$ set the VAR_MATCH_END bit of flags.  */
end_comment

begin_function
specifier|static
name|Buffer
modifier|*
name|VarGetPattern
parameter_list|(
name|VarParser
modifier|*
name|vp
parameter_list|,
name|int
name|delim
parameter_list|,
name|int
modifier|*
name|flags
parameter_list|,
name|VarPattern
modifier|*
name|patt
parameter_list|)
block|{
name|Buffer
modifier|*
name|buf
decl_stmt|;
name|buf
operator|=
name|Buf_Init
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Skim through until the matching delimiter is found; pick up 	 * variable substitutions on the way. Also allow backslashes to quote 	 * the delimiter, $, and \, but don't touch other backslashes. 	 */
while|while
condition|(
operator|*
name|vp
operator|->
name|ptr
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|*
name|vp
operator|->
name|ptr
operator|==
name|delim
condition|)
block|{
return|return
operator|(
name|buf
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|vp
operator|->
name|ptr
index|[
literal|0
index|]
operator|==
literal|'\\'
operator|)
operator|&&
operator|(
operator|(
name|vp
operator|->
name|ptr
index|[
literal|1
index|]
operator|==
name|delim
operator|)
operator|||
operator|(
name|vp
operator|->
name|ptr
index|[
literal|1
index|]
operator|==
literal|'\\'
operator|)
operator|||
operator|(
name|vp
operator|->
name|ptr
index|[
literal|1
index|]
operator|==
literal|'$'
operator|)
operator|||
operator|(
name|vp
operator|->
name|ptr
index|[
literal|1
index|]
operator|==
literal|'&'
operator|&&
name|patt
operator|!=
name|NULL
operator|)
operator|)
condition|)
block|{
name|vp
operator|->
name|ptr
operator|++
expr_stmt|;
comment|/* consume backslash */
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
operator|(
name|Byte
operator|)
name|vp
operator|->
name|ptr
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|vp
operator|->
name|ptr
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vp
operator|->
name|ptr
index|[
literal|0
index|]
operator|==
literal|'$'
condition|)
block|{
if|if
condition|(
name|vp
operator|->
name|ptr
index|[
literal|1
index|]
operator|==
name|delim
condition|)
block|{
if|if
condition|(
name|flags
operator|==
name|NULL
condition|)
block|{
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
operator|(
name|Byte
operator|)
name|vp
operator|->
name|ptr
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|vp
operator|->
name|ptr
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* 					 * Unescaped $ at end of patt => 					 * anchor patt at end. 					 */
operator|*
name|flags
operator||=
name|VAR_MATCH_END
expr_stmt|;
name|vp
operator|->
name|ptr
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
name|VarParser
name|subvp
init|=
block|{
name|vp
operator|->
name|ptr
block|,
name|vp
operator|->
name|ptr
block|,
name|vp
operator|->
name|ctxt
block|,
name|vp
operator|->
name|err
block|,
name|vp
operator|->
name|execute
block|}
decl_stmt|;
name|char
modifier|*
name|rval
decl_stmt|;
name|Boolean
name|rfree
decl_stmt|;
comment|/* 				 * If unescaped dollar sign not 				 * before the delimiter, assume it's 				 * a variable substitution and 				 * recurse. 				 */
name|rval
operator|=
name|VarParse
argument_list|(
operator|&
name|subvp
argument_list|,
operator|&
name|rfree
argument_list|)
expr_stmt|;
name|Buf_Append
argument_list|(
name|buf
argument_list|,
name|rval
argument_list|)
expr_stmt|;
if|if
condition|(
name|rfree
condition|)
name|free
argument_list|(
name|rval
argument_list|)
expr_stmt|;
name|vp
operator|->
name|ptr
operator|=
name|subvp
operator|.
name|ptr
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|vp
operator|->
name|ptr
index|[
literal|0
index|]
operator|==
literal|'&'
operator|&&
name|patt
operator|!=
name|NULL
condition|)
block|{
name|Buf_AppendBuf
argument_list|(
name|buf
argument_list|,
name|patt
operator|->
name|lhs
argument_list|)
expr_stmt|;
name|vp
operator|->
name|ptr
operator|++
expr_stmt|;
block|}
else|else
block|{
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
operator|(
name|Byte
operator|)
name|vp
operator|->
name|ptr
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|vp
operator|->
name|ptr
operator|++
expr_stmt|;
block|}
block|}
name|Buf_Destroy
argument_list|(
name|buf
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Make sure this variable is fully expanded.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|VarExpand
parameter_list|(
name|Var
modifier|*
name|v
parameter_list|,
name|VarParser
modifier|*
name|vp
parameter_list|)
block|{
name|char
modifier|*
name|value
decl_stmt|;
name|char
modifier|*
name|result
decl_stmt|;
if|if
condition|(
name|v
operator|->
name|flags
operator|&
name|VAR_IN_USE
condition|)
block|{
name|Fatal
argument_list|(
literal|"Variable %s is recursive."
argument_list|,
name|v
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
name|v
operator|->
name|flags
operator||=
name|VAR_IN_USE
expr_stmt|;
comment|/* 	 * Before doing any modification, we have to make sure the 	 * value has been fully expanded. If it looks like recursion 	 * might be necessary (there's a dollar sign somewhere in the 	 * variable's value) we just call Var_Subst to do any other 	 * substitutions that are necessary. Note that the value 	 * returned by Var_Subst will have been 	 * dynamically-allocated, so it will need freeing when we 	 * return. 	 */
name|value
operator|=
name|Buf_Data
argument_list|(
name|v
operator|->
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|value
argument_list|,
literal|'$'
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|strdup
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Buffer
modifier|*
name|buf
decl_stmt|;
name|buf
operator|=
name|Var_Subst
argument_list|(
name|value
argument_list|,
name|vp
operator|->
name|ctxt
argument_list|,
name|vp
operator|->
name|err
argument_list|)
expr_stmt|;
name|result
operator|=
name|Buf_Peel
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
name|v
operator|->
name|flags
operator|&=
operator|~
name|VAR_IN_USE
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Select only those words in value that match the modifier.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|modifier_M
parameter_list|(
name|VarParser
modifier|*
name|vp
parameter_list|,
specifier|const
name|char
name|value
index|[]
parameter_list|,
name|char
name|endc
parameter_list|)
block|{
name|char
modifier|*
name|patt
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
name|char
modifier|*
name|newValue
decl_stmt|;
name|char
name|modifier
decl_stmt|;
name|modifier
operator|=
name|vp
operator|->
name|ptr
index|[
literal|0
index|]
expr_stmt|;
name|vp
operator|->
name|ptr
operator|++
expr_stmt|;
comment|/* consume 'M' or 'N' */
comment|/* 	 * Compress the \:'s out of the pattern, so allocate enough 	 * room to hold the uncompressed pattern and compress the 	 * pattern into that space. 	 */
name|patt
operator|=
name|estrdup
argument_list|(
name|vp
operator|->
name|ptr
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|patt
expr_stmt|;
while|while
condition|(
name|vp
operator|->
name|ptr
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|vp
operator|->
name|ptr
index|[
literal|0
index|]
operator|==
name|endc
operator|||
name|vp
operator|->
name|ptr
index|[
literal|0
index|]
operator|==
literal|':'
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|vp
operator|->
name|ptr
index|[
literal|0
index|]
operator|==
literal|'\\'
operator|&&
operator|(
name|vp
operator|->
name|ptr
index|[
literal|1
index|]
operator|==
name|endc
operator|||
name|vp
operator|->
name|ptr
index|[
literal|1
index|]
operator|==
literal|':'
operator|)
condition|)
block|{
name|vp
operator|->
name|ptr
operator|++
expr_stmt|;
comment|/* consume backslash */
block|}
operator|*
name|ptr
operator|=
name|vp
operator|->
name|ptr
index|[
literal|0
index|]
expr_stmt|;
name|ptr
operator|++
expr_stmt|;
name|vp
operator|->
name|ptr
operator|++
expr_stmt|;
block|}
operator|*
name|ptr
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|modifier
operator|==
literal|'M'
condition|)
block|{
name|newValue
operator|=
name|VarModify
argument_list|(
name|value
argument_list|,
name|VarMatch
argument_list|,
name|patt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|newValue
operator|=
name|VarModify
argument_list|(
name|value
argument_list|,
name|VarNoMatch
argument_list|,
name|patt
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|patt
argument_list|)
expr_stmt|;
return|return
operator|(
name|newValue
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Substitute the replacement string for the pattern.  The substitution  * is applied to each word in value.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|modifier_S
parameter_list|(
name|VarParser
modifier|*
name|vp
parameter_list|,
specifier|const
name|char
name|value
index|[]
parameter_list|,
name|Var
modifier|*
name|v
parameter_list|)
block|{
name|VarPattern
name|patt
decl_stmt|;
name|char
name|delim
decl_stmt|;
name|char
modifier|*
name|newValue
decl_stmt|;
name|patt
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|vp
operator|->
name|ptr
operator|++
expr_stmt|;
comment|/* consume 'S' */
name|delim
operator|=
operator|*
name|vp
operator|->
name|ptr
expr_stmt|;
comment|/* used to find end of pattern */
name|vp
operator|->
name|ptr
operator|++
expr_stmt|;
comment|/* consume 1st delim */
comment|/* 	 * If pattern begins with '^', it is anchored to the start of the 	 * word -- skip over it and flag pattern. 	 */
if|if
condition|(
operator|*
name|vp
operator|->
name|ptr
operator|==
literal|'^'
condition|)
block|{
name|patt
operator|.
name|flags
operator||=
name|VAR_MATCH_START
expr_stmt|;
name|vp
operator|->
name|ptr
operator|++
expr_stmt|;
block|}
name|patt
operator|.
name|lhs
operator|=
name|VarGetPattern
argument_list|(
name|vp
argument_list|,
name|delim
argument_list|,
operator|&
name|patt
operator|.
name|flags
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|patt
operator|.
name|lhs
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * LHS didn't end with the delim, complain and exit. 		 */
name|Fatal
argument_list|(
literal|"Unclosed substitution for %s (%c missing)"
argument_list|,
name|v
operator|->
name|name
argument_list|,
name|delim
argument_list|)
expr_stmt|;
block|}
name|vp
operator|->
name|ptr
operator|++
expr_stmt|;
comment|/* consume 2nd delim */
name|patt
operator|.
name|rhs
operator|=
name|VarGetPattern
argument_list|(
name|vp
argument_list|,
name|delim
argument_list|,
name|NULL
argument_list|,
operator|&
name|patt
argument_list|)
expr_stmt|;
if|if
condition|(
name|patt
operator|.
name|rhs
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * RHS didn't end with the delim, complain and exit. 		 */
name|Fatal
argument_list|(
literal|"Unclosed substitution for %s (%c missing)"
argument_list|,
name|v
operator|->
name|name
argument_list|,
name|delim
argument_list|)
expr_stmt|;
block|}
name|vp
operator|->
name|ptr
operator|++
expr_stmt|;
comment|/* consume last delim */
comment|/* 	 * Check for global substitution. If 'g' after the final delimiter, 	 * substitution is global and is marked that way. 	 */
if|if
condition|(
name|vp
operator|->
name|ptr
index|[
literal|0
index|]
operator|==
literal|'g'
condition|)
block|{
name|patt
operator|.
name|flags
operator||=
name|VAR_SUB_GLOBAL
expr_stmt|;
name|vp
operator|->
name|ptr
operator|++
expr_stmt|;
block|}
comment|/* 	 * Global substitution of the empty string causes an infinite number 	 * of matches, unless anchored by '^' (start of string) or '$' (end 	 * of string). Catch the infinite substitution here. Note that flags 	 * can only contain the 3 bits we're interested in so we don't have 	 * to mask unrelated bits. We can test for equality. 	 */
if|if
condition|(
name|Buf_Size
argument_list|(
name|patt
operator|.
name|lhs
argument_list|)
operator|==
literal|0
operator|&&
name|patt
operator|.
name|flags
operator|==
name|VAR_SUB_GLOBAL
condition|)
name|Fatal
argument_list|(
literal|"Global substitution of the empty string"
argument_list|)
expr_stmt|;
name|newValue
operator|=
name|VarModify
argument_list|(
name|value
argument_list|,
name|VarSubstitute
argument_list|,
operator|&
name|patt
argument_list|)
expr_stmt|;
comment|/* 	 * Free the two strings. 	 */
name|free
argument_list|(
name|patt
operator|.
name|lhs
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|patt
operator|.
name|rhs
argument_list|)
expr_stmt|;
return|return
operator|(
name|newValue
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|modifier_C
parameter_list|(
name|VarParser
modifier|*
name|vp
parameter_list|,
name|char
name|value
index|[]
parameter_list|,
name|Var
modifier|*
name|v
parameter_list|)
block|{
name|VarPattern
name|patt
decl_stmt|;
name|char
name|delim
decl_stmt|;
name|int
name|error
decl_stmt|;
name|char
modifier|*
name|newValue
decl_stmt|;
name|patt
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|vp
operator|->
name|ptr
operator|++
expr_stmt|;
comment|/* consume 'C' */
name|delim
operator|=
operator|*
name|vp
operator|->
name|ptr
expr_stmt|;
comment|/* delimiter between sections */
name|vp
operator|->
name|ptr
operator|++
expr_stmt|;
comment|/* consume 1st delim */
name|patt
operator|.
name|lhs
operator|=
name|VarGetPattern
argument_list|(
name|vp
argument_list|,
name|delim
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|patt
operator|.
name|lhs
operator|==
name|NULL
condition|)
block|{
name|Fatal
argument_list|(
literal|"Unclosed substitution for %s (%c missing)"
argument_list|,
name|v
operator|->
name|name
argument_list|,
name|delim
argument_list|)
expr_stmt|;
block|}
name|vp
operator|->
name|ptr
operator|++
expr_stmt|;
comment|/* consume 2st delim */
name|patt
operator|.
name|rhs
operator|=
name|VarGetPattern
argument_list|(
name|vp
argument_list|,
name|delim
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|patt
operator|.
name|rhs
operator|==
name|NULL
condition|)
block|{
name|Fatal
argument_list|(
literal|"Unclosed substitution for %s (%c missing)"
argument_list|,
name|v
operator|->
name|name
argument_list|,
name|delim
argument_list|)
expr_stmt|;
block|}
name|vp
operator|->
name|ptr
operator|++
expr_stmt|;
comment|/* consume last delim */
switch|switch
condition|(
operator|*
name|vp
operator|->
name|ptr
condition|)
block|{
case|case
literal|'g'
case|:
name|patt
operator|.
name|flags
operator||=
name|VAR_SUB_GLOBAL
expr_stmt|;
name|vp
operator|->
name|ptr
operator|++
expr_stmt|;
comment|/* consume 'g' */
break|break;
case|case
literal|'1'
case|:
name|patt
operator|.
name|flags
operator||=
name|VAR_SUB_ONE
expr_stmt|;
name|vp
operator|->
name|ptr
operator|++
expr_stmt|;
comment|/* consume '1' */
break|break;
default|default:
break|break;
block|}
name|error
operator|=
name|regcomp
argument_list|(
operator|&
name|patt
operator|.
name|re
argument_list|,
name|Buf_Data
argument_list|(
name|patt
operator|.
name|lhs
argument_list|)
argument_list|,
name|REG_EXTENDED
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|VarREError
argument_list|(
name|error
argument_list|,
operator|&
name|patt
operator|.
name|re
argument_list|,
literal|"RE substitution error"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|patt
operator|.
name|rhs
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|patt
operator|.
name|lhs
argument_list|)
expr_stmt|;
return|return
operator|(
name|var_Error
operator|)
return|;
block|}
name|patt
operator|.
name|nsub
operator|=
name|patt
operator|.
name|re
operator|.
name|re_nsub
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|patt
operator|.
name|nsub
operator|<
literal|1
condition|)
name|patt
operator|.
name|nsub
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|patt
operator|.
name|nsub
operator|>
literal|10
condition|)
name|patt
operator|.
name|nsub
operator|=
literal|10
expr_stmt|;
name|patt
operator|.
name|matches
operator|=
name|emalloc
argument_list|(
name|patt
operator|.
name|nsub
operator|*
sizeof|sizeof
argument_list|(
name|regmatch_t
argument_list|)
argument_list|)
expr_stmt|;
name|newValue
operator|=
name|VarModify
argument_list|(
name|value
argument_list|,
name|VarRESubstitute
argument_list|,
operator|&
name|patt
argument_list|)
expr_stmt|;
name|regfree
argument_list|(
operator|&
name|patt
operator|.
name|re
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|patt
operator|.
name|matches
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|patt
operator|.
name|rhs
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|patt
operator|.
name|lhs
argument_list|)
expr_stmt|;
return|return
operator|(
name|newValue
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|sysVvarsub
parameter_list|(
name|VarParser
modifier|*
name|vp
parameter_list|,
name|char
name|startc
parameter_list|,
name|Var
modifier|*
name|v
parameter_list|,
specifier|const
name|char
name|value
index|[]
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SYSVVARSUB
comment|/* 	 * This can either be a bogus modifier or a System-V substitution 	 * command. 	 */
name|char
name|endc
decl_stmt|;
name|VarPattern
name|patt
decl_stmt|;
name|Boolean
name|eqFound
decl_stmt|;
name|int
name|cnt
decl_stmt|;
name|char
modifier|*
name|newStr
decl_stmt|;
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
name|endc
operator|=
operator|(
name|startc
operator|==
name|OPEN_PAREN
operator|)
condition|?
name|CLOSE_PAREN
else|:
name|CLOSE_BRACE
expr_stmt|;
name|patt
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
comment|/* 	 * First we make a pass through the string trying to verify it is a 	 * SYSV-make-style translation: it must be:<string1>=<string2>) 	 */
name|eqFound
operator|=
name|FALSE
expr_stmt|;
name|cp
operator|=
name|vp
operator|->
name|ptr
expr_stmt|;
name|cnt
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|!=
literal|'\0'
operator|&&
name|cnt
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'='
condition|)
block|{
name|eqFound
operator|=
name|TRUE
expr_stmt|;
comment|/* continue looking for endc */
block|}
elseif|else
if|if
condition|(
operator|*
name|cp
operator|==
name|endc
condition|)
name|cnt
operator|--
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|cp
operator|==
name|startc
condition|)
name|cnt
operator|++
expr_stmt|;
if|if
condition|(
name|cnt
condition|)
name|cp
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|cp
operator|==
name|endc
operator|&&
name|eqFound
condition|)
block|{
comment|/* 		 * Now we break this sucker into the lhs and rhs. 		 */
name|patt
operator|.
name|lhs
operator|=
name|VarGetPattern
argument_list|(
name|vp
argument_list|,
literal|'='
argument_list|,
operator|&
name|patt
operator|.
name|flags
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|patt
operator|.
name|lhs
operator|==
name|NULL
condition|)
block|{
name|Fatal
argument_list|(
literal|"Unclosed substitution for %s (%c missing)"
argument_list|,
name|v
operator|->
name|name
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
block|}
name|vp
operator|->
name|ptr
operator|++
expr_stmt|;
comment|/* consume '=' */
name|patt
operator|.
name|rhs
operator|=
name|VarGetPattern
argument_list|(
name|vp
argument_list|,
name|endc
argument_list|,
name|NULL
argument_list|,
operator|&
name|patt
argument_list|)
expr_stmt|;
if|if
condition|(
name|patt
operator|.
name|rhs
operator|==
name|NULL
condition|)
block|{
name|Fatal
argument_list|(
literal|"Unclosed substitution for %s (%c missing)"
argument_list|,
name|v
operator|->
name|name
argument_list|,
name|endc
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * SYSV modifications happen through the whole string. Note 		 * the pattern is anchored at the end. 		 */
name|newStr
operator|=
name|VarModify
argument_list|(
name|value
argument_list|,
name|VarSYSVMatch
argument_list|,
operator|&
name|patt
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|patt
operator|.
name|lhs
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|patt
operator|.
name|rhs
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|Error
argument_list|(
literal|"Unknown modifier '%c'\n"
argument_list|,
operator|*
name|vp
operator|->
name|ptr
argument_list|)
expr_stmt|;
name|vp
operator|->
name|ptr
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|vp
operator|->
name|ptr
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|*
name|vp
operator|->
name|ptr
operator|==
name|endc
operator|&&
operator|*
name|vp
operator|->
name|ptr
operator|==
literal|':'
condition|)
block|{
break|break;
block|}
name|vp
operator|->
name|ptr
operator|++
expr_stmt|;
block|}
name|newStr
operator|=
name|var_Error
expr_stmt|;
block|}
return|return
operator|(
name|newStr
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Quote shell meta-characters in the string  *  * Results:  *	The quoted string  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|Var_Quote
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
name|Buffer
modifier|*
name|buf
decl_stmt|;
comment|/* This should cover most shells :-( */
specifier|static
name|char
name|meta
index|[]
init|=
literal|"\n \t'`\";&<>()|*?{}[]\\$!#^~"
decl_stmt|;
name|buf
operator|=
name|Buf_Init
argument_list|(
name|MAKE_BSIZE
argument_list|)
expr_stmt|;
for|for
control|(
init|;
operator|*
name|str
condition|;
name|str
operator|++
control|)
block|{
if|if
condition|(
name|strchr
argument_list|(
name|meta
argument_list|,
operator|*
name|str
argument_list|)
operator|!=
name|NULL
condition|)
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
operator|(
name|Byte
operator|)
literal|'\\'
argument_list|)
expr_stmt|;
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
operator|(
name|Byte
operator|)
operator|*
name|str
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|Buf_Peel
argument_list|(
name|buf
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Now we need to apply any modifiers the user wants applied.  * These are:  *	:M<pattern>  *		words which match the given<pattern>.  *<pattern> is of the standard file  *		wildcarding form.  *	:N<pattern>  *		words which do not match the given<pattern>  *<pattern> is of the standard file  *		wildcarding form.  *	:S<d><pat1><d><pat2><d>[g]  *		Substitute<pat2> for<pat1> in the value  *	:C<d><pat1><d><pat2><d>[g]  *		Substitute<pat2> for regex<pat1> in the value  *	:H	Substitute the head of each word  *	:T	Substitute the tail of each word  *	:E	Substitute the extension (minus '.') of  *		each word  *	:R	Substitute the root of each word  *		(pathname minus the suffix).  *	:lhs=rhs  *		Like :S, but the rhs goes to the end of  *		the invocation.  *	:U	Converts variable to upper-case.  *	:L	Converts variable to lower-case.  *	:O	("Order") Alphabeticaly sort words in variable.  *	:u	("uniq") Remove adjacent duplicate words.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|ParseModifier
parameter_list|(
name|VarParser
modifier|*
name|vp
parameter_list|,
name|char
name|startc
parameter_list|,
name|Var
modifier|*
name|v
parameter_list|,
name|Boolean
modifier|*
name|freeResult
parameter_list|)
block|{
name|char
modifier|*
name|value
decl_stmt|;
name|char
name|endc
decl_stmt|;
name|value
operator|=
name|VarExpand
argument_list|(
name|v
argument_list|,
name|vp
argument_list|)
expr_stmt|;
operator|*
name|freeResult
operator|=
name|TRUE
expr_stmt|;
name|endc
operator|=
operator|(
name|startc
operator|==
name|OPEN_PAREN
operator|)
condition|?
name|CLOSE_PAREN
else|:
name|CLOSE_BRACE
expr_stmt|;
name|vp
operator|->
name|ptr
operator|++
expr_stmt|;
comment|/* consume first colon */
while|while
condition|(
operator|*
name|vp
operator|->
name|ptr
operator|!=
literal|'\0'
condition|)
block|{
name|char
modifier|*
name|newStr
decl_stmt|;
comment|/* New value to return */
if|if
condition|(
operator|*
name|vp
operator|->
name|ptr
operator|==
name|endc
condition|)
block|{
return|return
operator|(
name|value
operator|)
return|;
block|}
name|DEBUGF
argument_list|(
name|VAR
argument_list|,
operator|(
literal|"Applying :%c to \"%s\"\n"
operator|,
operator|*
name|vp
operator|->
name|ptr
operator|,
name|value
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|*
name|vp
operator|->
name|ptr
condition|)
block|{
case|case
literal|'N'
case|:
case|case
literal|'M'
case|:
name|newStr
operator|=
name|modifier_M
argument_list|(
name|vp
argument_list|,
name|value
argument_list|,
name|endc
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|newStr
operator|=
name|modifier_S
argument_list|(
name|vp
argument_list|,
name|value
argument_list|,
name|v
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
name|newStr
operator|=
name|modifier_C
argument_list|(
name|vp
argument_list|,
name|value
argument_list|,
name|v
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|vp
operator|->
name|ptr
index|[
literal|1
index|]
operator|!=
name|endc
operator|&&
name|vp
operator|->
name|ptr
index|[
literal|1
index|]
operator|!=
literal|':'
condition|)
block|{
ifdef|#
directive|ifdef
name|SUNSHCMD
if|if
condition|(
operator|(
name|vp
operator|->
name|ptr
index|[
literal|0
index|]
operator|==
literal|'s'
operator|)
operator|&&
operator|(
name|vp
operator|->
name|ptr
index|[
literal|1
index|]
operator|==
literal|'h'
operator|)
operator|&&
operator|(
name|vp
operator|->
name|ptr
index|[
literal|2
index|]
operator|==
name|endc
operator|||
name|vp
operator|->
name|ptr
index|[
literal|2
index|]
operator|==
literal|':'
operator|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|error
decl_stmt|;
if|if
condition|(
name|vp
operator|->
name|execute
condition|)
block|{
name|newStr
operator|=
name|Buf_Peel
argument_list|(
name|Cmd_Exec
argument_list|(
name|value
argument_list|,
operator|&
name|error
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|newStr
operator|=
name|estrdup
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
name|Error
argument_list|(
name|error
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|vp
operator|->
name|ptr
operator|+=
literal|2
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|newStr
operator|=
name|sysVvarsub
argument_list|(
name|vp
argument_list|,
name|startc
argument_list|,
name|v
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
switch|switch
condition|(
name|vp
operator|->
name|ptr
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'L'
case|:
block|{
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
name|Buffer
modifier|*
name|buf
decl_stmt|;
name|buf
operator|=
name|Buf_Init
argument_list|(
name|MAKE_BSIZE
argument_list|)
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|value
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
operator|(
name|Byte
operator|)
name|tolower
argument_list|(
operator|*
name|cp
argument_list|)
argument_list|)
expr_stmt|;
name|newStr
operator|=
name|Buf_Peel
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|vp
operator|->
name|ptr
operator|++
expr_stmt|;
break|break;
block|}
case|case
literal|'O'
case|:
name|newStr
operator|=
name|VarSortWords
argument_list|(
name|value
argument_list|,
name|SortIncreasing
argument_list|)
expr_stmt|;
name|vp
operator|->
name|ptr
operator|++
expr_stmt|;
break|break;
case|case
literal|'Q'
case|:
name|newStr
operator|=
name|Var_Quote
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|vp
operator|->
name|ptr
operator|++
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
name|newStr
operator|=
name|VarModify
argument_list|(
name|value
argument_list|,
name|VarTail
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|vp
operator|->
name|ptr
operator|++
expr_stmt|;
break|break;
case|case
literal|'U'
case|:
block|{
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
name|Buffer
modifier|*
name|buf
decl_stmt|;
name|buf
operator|=
name|Buf_Init
argument_list|(
name|MAKE_BSIZE
argument_list|)
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|value
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
operator|(
name|Byte
operator|)
name|toupper
argument_list|(
operator|*
name|cp
argument_list|)
argument_list|)
expr_stmt|;
name|newStr
operator|=
name|Buf_Peel
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|vp
operator|->
name|ptr
operator|++
expr_stmt|;
break|break;
block|}
case|case
literal|'H'
case|:
name|newStr
operator|=
name|VarModify
argument_list|(
name|value
argument_list|,
name|VarHead
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|vp
operator|->
name|ptr
operator|++
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
name|newStr
operator|=
name|VarModify
argument_list|(
name|value
argument_list|,
name|VarSuffix
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|vp
operator|->
name|ptr
operator|++
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|newStr
operator|=
name|VarModify
argument_list|(
name|value
argument_list|,
name|VarRoot
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|vp
operator|->
name|ptr
operator|++
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|newStr
operator|=
name|VarUniq
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|vp
operator|->
name|ptr
operator|++
expr_stmt|;
break|break;
default|default:
name|newStr
operator|=
name|sysVvarsub
argument_list|(
name|vp
argument_list|,
name|startc
argument_list|,
name|v
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
block|}
name|DEBUGF
argument_list|(
name|VAR
argument_list|,
operator|(
literal|"Result is \"%s\"\n"
operator|,
name|newStr
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|freeResult
condition|)
block|{
name|free
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
name|value
operator|=
name|newStr
expr_stmt|;
operator|*
name|freeResult
operator|=
operator|(
name|value
operator|==
name|var_Error
operator|)
condition|?
name|FALSE
else|:
name|TRUE
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|ptr
index|[
literal|0
index|]
operator|==
literal|':'
condition|)
block|{
name|vp
operator|->
name|ptr
operator|++
expr_stmt|;
comment|/* consume colon */
block|}
block|}
return|return
operator|(
name|value
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|ParseRestModifier
parameter_list|(
name|VarParser
modifier|*
name|vp
parameter_list|,
name|char
name|startc
parameter_list|,
name|Buffer
modifier|*
name|buf
parameter_list|,
name|Boolean
modifier|*
name|freeResult
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|vname
decl_stmt|;
name|size_t
name|vlen
decl_stmt|;
name|Var
modifier|*
name|v
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
name|vname
operator|=
name|Buf_GetAll
argument_list|(
name|buf
argument_list|,
operator|&
name|vlen
argument_list|)
expr_stmt|;
name|v
operator|=
name|VarFindAny
argument_list|(
name|vname
argument_list|,
name|vp
operator|->
name|ctxt
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|!=
name|NULL
condition|)
block|{
name|value
operator|=
name|ParseModifier
argument_list|(
name|vp
argument_list|,
name|startc
argument_list|,
name|v
argument_list|,
name|freeResult
argument_list|)
expr_stmt|;
return|return
operator|(
name|value
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|vp
operator|->
name|ctxt
operator|==
name|VAR_CMD
operator|)
operator|||
operator|(
name|vp
operator|->
name|ctxt
operator|==
name|VAR_GLOBAL
operator|)
condition|)
block|{
name|size_t
name|consumed
decl_stmt|;
comment|/* 		 * Still need to get to the end of the variable 		 * specification, so kludge up a Var structure for the 		 * modifications 		 */
name|v
operator|=
name|VarCreate
argument_list|(
name|vname
argument_list|,
name|NULL
argument_list|,
name|VAR_JUNK
argument_list|)
expr_stmt|;
name|value
operator|=
name|ParseModifier
argument_list|(
name|vp
argument_list|,
name|startc
argument_list|,
name|v
argument_list|,
name|freeResult
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|freeResult
condition|)
block|{
name|free
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
name|VarDestroy
argument_list|(
name|v
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|consumed
operator|=
name|vp
operator|->
name|ptr
operator|-
name|vp
operator|->
name|input
operator|+
literal|1
expr_stmt|;
comment|/* 		 * If substituting a local variable in a non-local context, 		 * assume it's for dynamic source stuff. We have to handle 		 * this specially and return the longhand for the variable 		 * with the dollar sign escaped so it makes it back to the 		 * caller. Only four of the local variables are treated 		 * specially as they are the only four that will be set when 		 * dynamic sources are expanded. 		 */
if|if
condition|(
name|vlen
operator|==
literal|1
operator|||
operator|(
name|vlen
operator|==
literal|2
operator|&&
operator|(
name|vname
index|[
literal|1
index|]
operator|==
literal|'F'
operator|||
name|vname
index|[
literal|1
index|]
operator|==
literal|'D'
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|strchr
argument_list|(
literal|"!%*@"
argument_list|,
name|vname
index|[
literal|0
index|]
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|value
operator|=
name|emalloc
argument_list|(
name|consumed
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|value
argument_list|,
name|vp
operator|->
name|input
argument_list|,
name|consumed
argument_list|)
expr_stmt|;
name|value
index|[
name|consumed
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|freeResult
operator|=
name|TRUE
expr_stmt|;
return|return
operator|(
name|value
operator|)
return|;
block|}
block|}
if|if
condition|(
name|vlen
operator|>
literal|2
operator|&&
name|vname
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|isupper
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|vname
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|strncmp
argument_list|(
name|vname
argument_list|,
literal|".TARGET"
argument_list|,
name|vlen
operator|-
literal|1
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|strncmp
argument_list|(
name|vname
argument_list|,
literal|".ARCHIVE"
argument_list|,
name|vlen
operator|-
literal|1
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|strncmp
argument_list|(
name|vname
argument_list|,
literal|".PREFIX"
argument_list|,
name|vlen
operator|-
literal|1
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|strncmp
argument_list|(
name|vname
argument_list|,
literal|".MEMBER"
argument_list|,
name|vlen
operator|-
literal|1
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|value
operator|=
name|emalloc
argument_list|(
name|consumed
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|value
argument_list|,
name|vp
operator|->
name|input
argument_list|,
name|consumed
argument_list|)
expr_stmt|;
name|value
index|[
name|consumed
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|freeResult
operator|=
name|TRUE
expr_stmt|;
return|return
operator|(
name|value
operator|)
return|;
block|}
block|}
operator|*
name|freeResult
operator|=
name|FALSE
expr_stmt|;
return|return
operator|(
name|vp
operator|->
name|err
condition|?
name|var_Error
else|:
name|varNoError
operator|)
return|;
block|}
else|else
block|{
comment|/* 		 * Check for D and F forms of local variables since we're in 		 * a local context and the name is the right length. 		 */
if|if
condition|(
name|vlen
operator|==
literal|2
operator|&&
operator|(
name|vname
index|[
literal|1
index|]
operator|==
literal|'F'
operator|||
name|vname
index|[
literal|1
index|]
operator|==
literal|'D'
operator|)
operator|&&
operator|(
name|strchr
argument_list|(
literal|"!%*<>@"
argument_list|,
name|vname
index|[
literal|0
index|]
argument_list|)
operator|!=
name|NULL
operator|)
condition|)
block|{
name|char
name|name
index|[
literal|2
index|]
decl_stmt|;
name|name
index|[
literal|0
index|]
operator|=
name|vname
index|[
literal|0
index|]
expr_stmt|;
name|name
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|v
operator|=
name|VarFindOnly
argument_list|(
name|name
argument_list|,
name|vp
operator|->
name|ctxt
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|!=
name|NULL
condition|)
block|{
name|value
operator|=
name|ParseModifier
argument_list|(
name|vp
argument_list|,
name|startc
argument_list|,
name|v
argument_list|,
name|freeResult
argument_list|)
expr_stmt|;
return|return
operator|(
name|value
operator|)
return|;
block|}
block|}
comment|/* 		 * Still need to get to the end of the variable 		 * specification, so kludge up a Var structure for the 		 * modifications 		 */
name|v
operator|=
name|VarCreate
argument_list|(
name|vname
argument_list|,
name|NULL
argument_list|,
name|VAR_JUNK
argument_list|)
expr_stmt|;
name|value
operator|=
name|ParseModifier
argument_list|(
name|vp
argument_list|,
name|startc
argument_list|,
name|v
argument_list|,
name|freeResult
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|freeResult
condition|)
block|{
name|free
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
name|VarDestroy
argument_list|(
name|v
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
operator|*
name|freeResult
operator|=
name|FALSE
expr_stmt|;
return|return
operator|(
name|vp
operator|->
name|err
condition|?
name|var_Error
else|:
name|varNoError
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|ParseRestEnd
parameter_list|(
name|VarParser
modifier|*
name|vp
parameter_list|,
name|Buffer
modifier|*
name|buf
parameter_list|,
name|Boolean
modifier|*
name|freeResult
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|vname
decl_stmt|;
name|size_t
name|vlen
decl_stmt|;
name|Var
modifier|*
name|v
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
name|vname
operator|=
name|Buf_GetAll
argument_list|(
name|buf
argument_list|,
operator|&
name|vlen
argument_list|)
expr_stmt|;
name|v
operator|=
name|VarFindAny
argument_list|(
name|vname
argument_list|,
name|vp
operator|->
name|ctxt
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|!=
name|NULL
condition|)
block|{
name|value
operator|=
name|VarExpand
argument_list|(
name|v
argument_list|,
name|vp
argument_list|)
expr_stmt|;
operator|*
name|freeResult
operator|=
name|TRUE
expr_stmt|;
return|return
operator|(
name|value
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|vp
operator|->
name|ctxt
operator|==
name|VAR_CMD
operator|)
operator|||
operator|(
name|vp
operator|->
name|ctxt
operator|==
name|VAR_GLOBAL
operator|)
condition|)
block|{
name|size_t
name|consumed
init|=
name|vp
operator|->
name|ptr
operator|-
name|vp
operator|->
name|input
operator|+
literal|1
decl_stmt|;
comment|/* 		 * If substituting a local variable in a non-local context, 		 * assume it's for dynamic source stuff. We have to handle 		 * this specially and return the longhand for the variable 		 * with the dollar sign escaped so it makes it back to the 		 * caller. Only four of the local variables are treated 		 * specially as they are the only four that will be set when 		 * dynamic sources are expanded. 		 */
if|if
condition|(
name|vlen
operator|==
literal|1
operator|||
operator|(
name|vlen
operator|==
literal|2
operator|&&
operator|(
name|vname
index|[
literal|1
index|]
operator|==
literal|'F'
operator|||
name|vname
index|[
literal|1
index|]
operator|==
literal|'D'
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|strchr
argument_list|(
literal|"!%*@"
argument_list|,
name|vname
index|[
literal|0
index|]
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|value
operator|=
name|emalloc
argument_list|(
name|consumed
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|value
argument_list|,
name|vp
operator|->
name|input
argument_list|,
name|consumed
argument_list|)
expr_stmt|;
name|value
index|[
name|consumed
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|freeResult
operator|=
name|TRUE
expr_stmt|;
return|return
operator|(
name|value
operator|)
return|;
block|}
block|}
if|if
condition|(
name|vlen
operator|>
literal|2
operator|&&
name|vname
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|isupper
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|vname
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|strncmp
argument_list|(
name|vname
argument_list|,
literal|".TARGET"
argument_list|,
name|vlen
operator|-
literal|1
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|strncmp
argument_list|(
name|vname
argument_list|,
literal|".ARCHIVE"
argument_list|,
name|vlen
operator|-
literal|1
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|strncmp
argument_list|(
name|vname
argument_list|,
literal|".PREFIX"
argument_list|,
name|vlen
operator|-
literal|1
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|strncmp
argument_list|(
name|vname
argument_list|,
literal|".MEMBER"
argument_list|,
name|vlen
operator|-
literal|1
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|value
operator|=
name|emalloc
argument_list|(
name|consumed
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|value
argument_list|,
name|vp
operator|->
name|input
argument_list|,
name|consumed
argument_list|)
expr_stmt|;
name|value
index|[
name|consumed
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|freeResult
operator|=
name|TRUE
expr_stmt|;
return|return
operator|(
name|value
operator|)
return|;
block|}
block|}
block|}
else|else
block|{
comment|/* 		 * Check for D and F forms of local variables since we're in 		 * a local context and the name is the right length. 		 */
if|if
condition|(
name|vlen
operator|==
literal|2
operator|&&
operator|(
name|vname
index|[
literal|1
index|]
operator|==
literal|'F'
operator|||
name|vname
index|[
literal|1
index|]
operator|==
literal|'D'
operator|)
operator|&&
operator|(
name|strchr
argument_list|(
literal|"!%*<>@"
argument_list|,
name|vname
index|[
literal|0
index|]
argument_list|)
operator|!=
name|NULL
operator|)
condition|)
block|{
name|char
name|name
index|[
literal|2
index|]
decl_stmt|;
name|name
index|[
literal|0
index|]
operator|=
name|vname
index|[
literal|0
index|]
expr_stmt|;
name|name
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|v
operator|=
name|VarFindOnly
argument_list|(
name|name
argument_list|,
name|vp
operator|->
name|ctxt
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|val
decl_stmt|;
comment|/* 				 * No need for nested expansion or anything, 				 * as we're the only one who sets these 				 * things and we sure don't put nested 				 * invocations in them... 				 */
name|val
operator|=
name|Buf_Data
argument_list|(
name|v
operator|->
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|vname
index|[
literal|1
index|]
operator|==
literal|'D'
condition|)
block|{
name|val
operator|=
name|VarModify
argument_list|(
name|val
argument_list|,
name|VarHead
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|val
operator|=
name|VarModify
argument_list|(
name|val
argument_list|,
name|VarTail
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
operator|*
name|freeResult
operator|=
name|TRUE
expr_stmt|;
return|return
operator|(
name|val
operator|)
return|;
block|}
block|}
block|}
operator|*
name|freeResult
operator|=
name|FALSE
expr_stmt|;
return|return
operator|(
name|vp
operator|->
name|err
condition|?
name|var_Error
else|:
name|varNoError
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Parse a multi letter variable name, and return it's value.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|VarParseLong
parameter_list|(
name|VarParser
modifier|*
name|vp
parameter_list|,
name|Boolean
modifier|*
name|freeResult
parameter_list|)
block|{
name|Buffer
modifier|*
name|buf
decl_stmt|;
name|char
name|startc
decl_stmt|;
name|char
name|endc
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
name|buf
operator|=
name|Buf_Init
argument_list|(
name|MAKE_BSIZE
argument_list|)
expr_stmt|;
name|startc
operator|=
name|vp
operator|->
name|ptr
index|[
literal|0
index|]
expr_stmt|;
name|vp
operator|->
name|ptr
operator|++
expr_stmt|;
comment|/* consume opening paren or brace */
name|endc
operator|=
operator|(
name|startc
operator|==
name|OPEN_PAREN
operator|)
condition|?
name|CLOSE_PAREN
else|:
name|CLOSE_BRACE
expr_stmt|;
comment|/* 	 * Process characters until we reach an end character or a colon, 	 * replacing embedded variables as we go. 	 */
while|while
condition|(
operator|*
name|vp
operator|->
name|ptr
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|*
name|vp
operator|->
name|ptr
operator|==
name|endc
condition|)
block|{
name|value
operator|=
name|ParseRestEnd
argument_list|(
name|vp
argument_list|,
name|buf
argument_list|,
name|freeResult
argument_list|)
expr_stmt|;
name|vp
operator|->
name|ptr
operator|++
expr_stmt|;
comment|/* consume closing paren or brace */
name|Buf_Destroy
argument_list|(
name|buf
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
operator|(
name|value
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|*
name|vp
operator|->
name|ptr
operator|==
literal|':'
condition|)
block|{
name|value
operator|=
name|ParseRestModifier
argument_list|(
name|vp
argument_list|,
name|startc
argument_list|,
name|buf
argument_list|,
name|freeResult
argument_list|)
expr_stmt|;
name|vp
operator|->
name|ptr
operator|++
expr_stmt|;
comment|/* consume closing paren or brace */
name|Buf_Destroy
argument_list|(
name|buf
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
operator|(
name|value
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|*
name|vp
operator|->
name|ptr
operator|==
literal|'$'
condition|)
block|{
name|VarParser
name|subvp
init|=
block|{
name|vp
operator|->
name|ptr
block|,
name|vp
operator|->
name|ptr
block|,
name|vp
operator|->
name|ctxt
block|,
name|vp
operator|->
name|err
block|,
name|vp
operator|->
name|execute
block|}
decl_stmt|;
name|char
modifier|*
name|rval
decl_stmt|;
name|Boolean
name|rfree
decl_stmt|;
name|rval
operator|=
name|VarParse
argument_list|(
operator|&
name|subvp
argument_list|,
operator|&
name|rfree
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
operator|==
name|var_Error
condition|)
block|{
name|Fatal
argument_list|(
literal|"Error expanding embedded variable."
argument_list|)
expr_stmt|;
block|}
name|Buf_Append
argument_list|(
name|buf
argument_list|,
name|rval
argument_list|)
expr_stmt|;
if|if
condition|(
name|rfree
condition|)
name|free
argument_list|(
name|rval
argument_list|)
expr_stmt|;
name|vp
operator|->
name|ptr
operator|=
name|subvp
operator|.
name|ptr
expr_stmt|;
block|}
else|else
block|{
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
operator|(
name|Byte
operator|)
operator|*
name|vp
operator|->
name|ptr
argument_list|)
expr_stmt|;
name|vp
operator|->
name|ptr
operator|++
expr_stmt|;
block|}
block|}
comment|/* If we did not find the end character, return var_Error */
name|Buf_Destroy
argument_list|(
name|buf
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
operator|*
name|freeResult
operator|=
name|FALSE
expr_stmt|;
return|return
operator|(
name|var_Error
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Parse a single letter variable name, and return it's value.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|VarParseShort
parameter_list|(
name|VarParser
modifier|*
name|vp
parameter_list|,
name|Boolean
modifier|*
name|freeResult
parameter_list|)
block|{
name|char
name|vname
index|[
literal|2
index|]
decl_stmt|;
name|Var
modifier|*
name|v
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
name|vname
index|[
literal|0
index|]
operator|=
name|vp
operator|->
name|ptr
index|[
literal|0
index|]
expr_stmt|;
name|vname
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|vp
operator|->
name|ptr
operator|++
expr_stmt|;
comment|/* consume single letter */
name|v
operator|=
name|VarFindAny
argument_list|(
name|vname
argument_list|,
name|vp
operator|->
name|ctxt
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|!=
name|NULL
condition|)
block|{
name|value
operator|=
name|VarExpand
argument_list|(
name|v
argument_list|,
name|vp
argument_list|)
expr_stmt|;
operator|*
name|freeResult
operator|=
name|TRUE
expr_stmt|;
return|return
operator|(
name|value
operator|)
return|;
block|}
comment|/* 	 * If substituting a local variable in a non-local context, assume 	 * it's for dynamic source stuff. We have to handle this specially 	 * and return the longhand for the variable with the dollar sign 	 * escaped so it makes it back to the caller. Only four of the local 	 * variables are treated specially as they are the only four that 	 * will be set when dynamic sources are expanded. 	 */
if|if
condition|(
operator|(
name|vp
operator|->
name|ctxt
operator|==
name|VAR_CMD
operator|)
operator|||
operator|(
name|vp
operator|->
name|ctxt
operator|==
name|VAR_GLOBAL
operator|)
condition|)
block|{
comment|/* XXX: It looks like $% and $! are reversed here */
switch|switch
condition|(
name|vname
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'@'
case|:
operator|*
name|freeResult
operator|=
name|TRUE
expr_stmt|;
return|return
operator|(
name|estrdup
argument_list|(
literal|"$(.TARGET)"
argument_list|)
operator|)
return|;
case|case
literal|'%'
case|:
operator|*
name|freeResult
operator|=
name|TRUE
expr_stmt|;
return|return
operator|(
name|estrdup
argument_list|(
literal|"$(.ARCHIVE)"
argument_list|)
operator|)
return|;
case|case
literal|'*'
case|:
operator|*
name|freeResult
operator|=
name|TRUE
expr_stmt|;
return|return
operator|(
name|estrdup
argument_list|(
literal|"$(.PREFIX)"
argument_list|)
operator|)
return|;
case|case
literal|'!'
case|:
operator|*
name|freeResult
operator|=
name|TRUE
expr_stmt|;
return|return
operator|(
name|estrdup
argument_list|(
literal|"$(.MEMBER)"
argument_list|)
operator|)
return|;
default|default:
operator|*
name|freeResult
operator|=
name|FALSE
expr_stmt|;
return|return
operator|(
name|vp
operator|->
name|err
condition|?
name|var_Error
else|:
name|varNoError
operator|)
return|;
block|}
block|}
comment|/* Variable name was not found. */
operator|*
name|freeResult
operator|=
name|FALSE
expr_stmt|;
return|return
operator|(
name|vp
operator|->
name|err
condition|?
name|var_Error
else|:
name|varNoError
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|VarParse
parameter_list|(
name|VarParser
modifier|*
name|vp
parameter_list|,
name|Boolean
modifier|*
name|freeResult
parameter_list|)
block|{
name|vp
operator|->
name|ptr
operator|++
expr_stmt|;
comment|/* consume '$' or last letter of conditional */
if|if
condition|(
name|vp
operator|->
name|ptr
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
comment|/* Error, there is only a dollar sign in the input string. */
operator|*
name|freeResult
operator|=
name|FALSE
expr_stmt|;
return|return
operator|(
name|vp
operator|->
name|err
condition|?
name|var_Error
else|:
name|varNoError
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|vp
operator|->
name|ptr
index|[
literal|0
index|]
operator|==
name|OPEN_PAREN
operator|||
name|vp
operator|->
name|ptr
index|[
literal|0
index|]
operator|==
name|OPEN_BRACE
condition|)
block|{
comment|/* multi letter variable name */
return|return
operator|(
name|VarParseLong
argument_list|(
name|vp
argument_list|,
name|freeResult
argument_list|)
operator|)
return|;
block|}
else|else
block|{
comment|/* single letter variable name */
return|return
operator|(
name|VarParseShort
argument_list|(
name|vp
argument_list|,
name|freeResult
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/**  * Given the start of a variable invocation, extract the variable  * name and find its value, then modify it according to the  * specification.  *  * Results:  *	The value of the variable or var_Error if the specification  *	is invalid.  The number of characters in the specification  *	is placed in the variable pointed to by consumed.  (for  *	invalid specifications, this is just 2 to skip the '$' and  *	the following letter, or 1 if '$' was the last character  *	in the string).  A Boolean in *freeResult telling whether the  *	returned string should be freed by the caller.  */
end_comment

begin_function
name|char
modifier|*
name|Var_Parse
parameter_list|(
specifier|const
name|char
name|input
index|[]
parameter_list|,
name|GNode
modifier|*
name|ctxt
parameter_list|,
name|Boolean
name|err
parameter_list|,
name|size_t
modifier|*
name|consumed
parameter_list|,
name|Boolean
modifier|*
name|freeResult
parameter_list|)
block|{
name|VarParser
name|vp
init|=
block|{
name|input
block|,
name|input
block|,
name|ctxt
block|,
name|err
block|,
name|TRUE
block|}
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
name|value
operator|=
name|VarParse
argument_list|(
operator|&
name|vp
argument_list|,
name|freeResult
argument_list|)
expr_stmt|;
operator|*
name|consumed
operator|+=
name|vp
operator|.
name|ptr
operator|-
name|vp
operator|.
name|input
expr_stmt|;
return|return
operator|(
name|value
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given the start of a variable invocation, determine the length  * of the specification.  *  * Results:  *	The number of characters in the specification.  For invalid  *	specifications, this is just 2 to skip the '$' and the  *	following letter, or 1 if '$' was the last character in the  *	string.  */
end_comment

begin_function
name|size_t
name|Var_Match
parameter_list|(
specifier|const
name|char
name|input
index|[]
parameter_list|,
name|GNode
modifier|*
name|ctxt
parameter_list|)
block|{
name|VarParser
name|vp
init|=
block|{
name|input
block|,
name|input
block|,
name|ctxt
block|,
name|FALSE
block|,
name|FALSE
block|}
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
name|Boolean
name|freeResult
decl_stmt|;
name|value
operator|=
name|VarParse
argument_list|(
operator|&
name|vp
argument_list|,
operator|&
name|freeResult
argument_list|)
expr_stmt|;
if|if
condition|(
name|freeResult
condition|)
block|{
name|free
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|vp
operator|.
name|ptr
operator|-
name|vp
operator|.
name|input
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|match_var
parameter_list|(
specifier|const
name|char
name|str
index|[]
parameter_list|,
specifier|const
name|char
name|var
index|[]
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|start
init|=
name|str
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|str
operator|++
expr_stmt|;
comment|/* consume '$' */
if|if
condition|(
name|str
index|[
literal|0
index|]
operator|==
name|OPEN_PAREN
operator|||
name|str
index|[
literal|0
index|]
operator|==
name|OPEN_BRACE
condition|)
block|{
name|str
operator|++
expr_stmt|;
comment|/* consume opening paren or brace */
while|while
condition|(
name|str
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|str
index|[
literal|0
index|]
operator|==
literal|'$'
condition|)
block|{
comment|/* 				 * A variable inside the variable. We cannot 				 * expand the external variable yet. 				 */
return|return
operator|(
name|str
operator|-
name|start
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|str
index|[
literal|0
index|]
operator|==
literal|':'
operator|||
name|str
index|[
literal|0
index|]
operator|==
name|CLOSE_PAREN
operator|||
name|str
index|[
literal|0
index|]
operator|==
name|CLOSE_BRACE
condition|)
block|{
name|len
operator|=
name|str
operator|-
operator|(
name|start
operator|+
literal|2
operator|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|var
argument_list|,
name|start
operator|+
literal|2
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|&&
name|var
index|[
name|len
index|]
operator|==
literal|'\0'
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
comment|/* match */
block|}
else|else
block|{
comment|/* 					 * Not the variable we want to 					 * expand. 					 */
return|return
operator|(
name|str
operator|-
name|start
operator|)
return|;
block|}
block|}
else|else
block|{
operator|++
name|str
expr_stmt|;
block|}
block|}
return|return
operator|(
name|str
operator|-
name|start
operator|)
return|;
block|}
else|else
block|{
comment|/* Single letter variable name */
if|if
condition|(
name|var
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|&&
name|var
index|[
literal|0
index|]
operator|==
name|str
index|[
literal|0
index|]
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
comment|/* match */
block|}
else|else
block|{
name|str
operator|++
expr_stmt|;
comment|/* consume variable name */
return|return
operator|(
name|str
operator|-
name|start
operator|)
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/**  * Substitute for all variables in the given string in the given  * context If err is TRUE, Parse_Error will be called when an  * undefined variable is encountered.  *  * Results:  *	The resulting string.  *  * Side Effects:  *	None. The old string must be freed by the caller  */
end_comment

begin_function
name|Buffer
modifier|*
name|Var_Subst
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|GNode
modifier|*
name|ctxt
parameter_list|,
name|Boolean
name|err
parameter_list|)
block|{
name|Boolean
name|errorReported
decl_stmt|;
name|Buffer
modifier|*
name|buf
decl_stmt|;
comment|/* Buffer for forming things */
comment|/* 	 * Set TRUE if an error has already been reported to prevent a 	 * plethora of messages when recursing. XXXHB this comment sounds 	 * wrong. 	 */
name|errorReported
operator|=
name|FALSE
expr_stmt|;
name|buf
operator|=
name|Buf_Init
argument_list|(
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|str
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|(
name|str
index|[
literal|0
index|]
operator|==
literal|'$'
operator|)
operator|&&
operator|(
name|str
index|[
literal|1
index|]
operator|==
literal|'$'
operator|)
condition|)
block|{
comment|/* 			 * A dollar sign may be escaped with another dollar 			 * sign.  In such a case, we skip over the escape 			 * character and store the dollar sign into the 			 * buffer directly. 			 */
name|str
operator|++
expr_stmt|;
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
operator|(
name|Byte
operator|)
name|str
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|str
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|str
index|[
literal|0
index|]
operator|==
literal|'$'
condition|)
block|{
comment|/* Variable invocation. */
name|VarParser
name|subvp
init|=
block|{
name|str
block|,
name|str
block|,
name|ctxt
block|,
name|err
block|,
name|TRUE
block|}
decl_stmt|;
name|char
modifier|*
name|rval
decl_stmt|;
name|Boolean
name|rfree
decl_stmt|;
name|rval
operator|=
name|VarParse
argument_list|(
operator|&
name|subvp
argument_list|,
operator|&
name|rfree
argument_list|)
expr_stmt|;
comment|/* 			 * When we come down here, val should either point to 			 * the value of this variable, suitably modified, or 			 * be NULL. Length should be the total length of the 			 * potential variable invocation (from $ to end 			 * character...) 			 */
if|if
condition|(
name|rval
operator|==
name|var_Error
operator|||
name|rval
operator|==
name|varNoError
condition|)
block|{
comment|/* 				 * If performing old-time variable 				 * substitution, skip over the variable and 				 * continue with the substitution. Otherwise, 				 * store the dollar sign and advance str so 				 * we continue with the string... 				 */
if|if
condition|(
name|oldVars
condition|)
block|{
name|str
operator|=
name|subvp
operator|.
name|ptr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|err
condition|)
block|{
comment|/* 					 * If variable is undefined, complain 					 * and skip the variable. The 					 * complaint will stop us from doing 					 * anything when the file is parsed. 					 */
if|if
condition|(
operator|!
name|errorReported
condition|)
block|{
name|Parse_Error
argument_list|(
name|PARSE_FATAL
argument_list|,
literal|"Undefined variable \"%.*s\""
argument_list|,
name|subvp
operator|.
name|ptr
operator|-
name|subvp
operator|.
name|input
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
name|errorReported
operator|=
name|TRUE
expr_stmt|;
name|str
operator|=
name|subvp
operator|.
name|ptr
expr_stmt|;
block|}
else|else
block|{
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
operator|(
name|Byte
operator|)
name|str
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|str
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 				 * Copy all the characters from the variable 				 * value straight into the new string. 				 */
name|Buf_Append
argument_list|(
name|buf
argument_list|,
name|rval
argument_list|)
expr_stmt|;
if|if
condition|(
name|rfree
condition|)
block|{
name|free
argument_list|(
name|rval
argument_list|)
expr_stmt|;
block|}
name|str
operator|=
name|subvp
operator|.
name|ptr
expr_stmt|;
block|}
block|}
else|else
block|{
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
operator|(
name|Byte
operator|)
name|str
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|str
operator|++
expr_stmt|;
block|}
block|}
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Substitute for all variables except if it is the same as 'var',  * in the given string in the given context.  If err is TRUE,  * Parse_Error will be called when an undefined variable is  * encountered.  *  * Results:  *	The resulting string.  *  * Side Effects:  *	None. The old string must be freed by the caller  */
end_comment

begin_function
name|Buffer
modifier|*
name|Var_SubstOnly
parameter_list|(
specifier|const
name|char
modifier|*
name|var
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|Boolean
name|err
parameter_list|)
block|{
name|GNode
modifier|*
name|ctxt
init|=
name|VAR_GLOBAL
decl_stmt|;
name|Boolean
name|errorReported
decl_stmt|;
name|Buffer
modifier|*
name|buf
decl_stmt|;
comment|/* Buffer for forming things */
comment|/* 	 * Set TRUE if an error has already been reported to prevent a 	 * plethora of messages when recursing. XXXHB this comment sounds 	 * wrong. 	 */
name|errorReported
operator|=
name|FALSE
expr_stmt|;
name|buf
operator|=
name|Buf_Init
argument_list|(
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|str
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|str
index|[
literal|0
index|]
operator|==
literal|'$'
condition|)
block|{
name|int
name|skip
decl_stmt|;
name|skip
operator|=
name|match_var
argument_list|(
name|str
argument_list|,
name|var
argument_list|)
expr_stmt|;
if|if
condition|(
name|skip
operator|>
literal|0
condition|)
block|{
name|Buf_AddBytes
argument_list|(
name|buf
argument_list|,
name|skip
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|str
operator|+=
name|skip
expr_stmt|;
block|}
else|else
block|{
comment|/* Variable invocation. */
name|VarParser
name|subvp
init|=
block|{
name|str
block|,
name|str
block|,
name|ctxt
block|,
name|err
block|,
name|TRUE
block|}
decl_stmt|;
name|char
modifier|*
name|rval
decl_stmt|;
name|Boolean
name|rfree
decl_stmt|;
name|rval
operator|=
name|VarParse
argument_list|(
operator|&
name|subvp
argument_list|,
operator|&
name|rfree
argument_list|)
expr_stmt|;
comment|/* 				 * When we get down here, rval should either 				 * point to the value of this variable, or be 				 * NULL. 				 */
if|if
condition|(
name|rval
operator|==
name|var_Error
operator|||
name|rval
operator|==
name|varNoError
condition|)
block|{
comment|/* 					 * If performing old-time variable 					 * substitution, skip over the 					 * variable and continue with the 					 * substitution. Otherwise, store the 					 * dollar sign and advance str so we 					 * continue with the string... 					 */
if|if
condition|(
name|oldVars
condition|)
block|{
name|str
operator|=
name|subvp
operator|.
name|ptr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|err
condition|)
block|{
comment|/* 						 * If variable is undefined, 						 * complain and skip the 						 * variable. The complaint 						 * will stop us from doing 						 * anything when the file is 						 * parsed. 						 */
if|if
condition|(
operator|!
name|errorReported
condition|)
block|{
name|Parse_Error
argument_list|(
name|PARSE_FATAL
argument_list|,
literal|"Undefined variable \"%.*s\""
argument_list|,
name|subvp
operator|.
name|ptr
operator|-
name|subvp
operator|.
name|input
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
name|errorReported
operator|=
name|TRUE
expr_stmt|;
name|str
operator|=
name|subvp
operator|.
name|ptr
expr_stmt|;
block|}
else|else
block|{
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
operator|(
name|Byte
operator|)
name|str
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|str
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 					 * Copy all the characters from the 					 * variable value straight into the 					 * new string. 					 */
name|Buf_Append
argument_list|(
name|buf
argument_list|,
name|rval
argument_list|)
expr_stmt|;
if|if
condition|(
name|rfree
condition|)
block|{
name|free
argument_list|(
name|rval
argument_list|)
expr_stmt|;
block|}
name|str
operator|=
name|subvp
operator|.
name|ptr
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
operator|(
name|Byte
operator|)
name|str
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|str
operator|++
expr_stmt|;
block|}
block|}
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Initialize the module  *  * Side Effects:  *	The VAR_CMD and VAR_GLOBAL contexts are created  */
end_comment

begin_function
name|void
name|Var_Init
parameter_list|(
name|char
modifier|*
modifier|*
name|env
parameter_list|)
block|{
name|char
modifier|*
modifier|*
name|ptr
decl_stmt|;
name|VAR_CMD
operator|=
name|Targ_NewGN
argument_list|(
literal|"Command"
argument_list|)
expr_stmt|;
name|VAR_ENV
operator|=
name|Targ_NewGN
argument_list|(
literal|"Environment"
argument_list|)
expr_stmt|;
name|VAR_GLOBAL
operator|=
name|Targ_NewGN
argument_list|(
literal|"Global"
argument_list|)
expr_stmt|;
comment|/* 	 * Copy user environment variables into ENV context. 	 */
for|for
control|(
name|ptr
operator|=
name|env
init|;
operator|*
name|ptr
operator|!=
name|NULL
condition|;
operator|++
name|ptr
control|)
block|{
name|char
modifier|*
name|tmp
init|=
name|estrdup
argument_list|(
operator|*
name|ptr
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
init|=
name|tmp
decl_stmt|;
name|char
modifier|*
name|sep
init|=
name|strchr
argument_list|(
name|name
argument_list|,
literal|'='
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|value
init|=
name|sep
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|sep
operator|!=
name|NULL
condition|)
block|{
operator|*
name|sep
operator|=
literal|'\0'
expr_stmt|;
name|VarAdd
argument_list|(
name|name
argument_list|,
name|value
argument_list|,
name|VAR_ENV
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * Print all variables in global and command line contexts.  */
end_comment

begin_function
name|void
name|Var_Dump
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|LstNode
modifier|*
name|ln
decl_stmt|;
specifier|const
name|Var
modifier|*
name|v
decl_stmt|;
name|printf
argument_list|(
literal|"#*** Global Variables:\n"
argument_list|)
expr_stmt|;
name|LST_FOREACH
argument_list|(
argument|ln
argument_list|,
argument|&VAR_GLOBAL->context
argument_list|)
block|{
name|v
operator|=
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%-16s = %s\n"
argument_list|,
name|v
operator|->
name|name
argument_list|,
name|Buf_Data
argument_list|(
name|v
operator|->
name|val
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"#*** Command-line Variables:\n"
argument_list|)
expr_stmt|;
name|LST_FOREACH
argument_list|(
argument|ln
argument_list|,
argument|&VAR_CMD->context
argument_list|)
block|{
name|v
operator|=
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%-16s = %s\n"
argument_list|,
name|v
operator|->
name|name
argument_list|,
name|Buf_Data
argument_list|(
name|v
operator|->
name|val
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * Print the values of any variables requested by  * the user.  */
end_comment

begin_function
name|void
name|Var_Print
parameter_list|(
name|Lst
modifier|*
name|vlist
parameter_list|,
name|Boolean
name|expandVars
parameter_list|)
block|{
name|LstNode
modifier|*
name|n
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|LST_FOREACH
argument_list|(
argument|n
argument_list|,
argument|vlist
argument_list|)
block|{
name|name
operator|=
name|Lst_Datum
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|expandVars
condition|)
block|{
name|char
modifier|*
name|value
decl_stmt|;
name|char
modifier|*
name|v
decl_stmt|;
name|v
operator|=
name|emalloc
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
operator|+
literal|3
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|v
argument_list|,
literal|"${%s}"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|value
operator|=
name|Buf_Peel
argument_list|(
name|Var_Subst
argument_list|(
name|v
argument_list|,
name|VAR_GLOBAL
argument_list|,
name|FALSE
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|value
init|=
name|Var_Value
argument_list|(
name|name
argument_list|,
name|VAR_GLOBAL
argument_list|)
decl_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|value
operator|!=
name|NULL
condition|?
name|value
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

end_unit

