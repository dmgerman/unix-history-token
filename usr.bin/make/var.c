begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1988, 1989, 1990, 1993  *	The Regents of the University of California.  All rights reserved.  * Copyright (c) 1989 by Berkeley Softworks  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Adam de Boor.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	$Id: var.c,v 1.9 1997/02/22 19:27:25 peter Exp $  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)var.c	8.3 (Berkeley) 3/19/94"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/*-  * var.c --  *	Variable-handling functions  *  * Interface:  *	Var_Set	  	    Set the value of a variable in the given  *	    	  	    context. The variable is created if it doesn't  *	    	  	    yet exist. The value and variable name need not  *	    	  	    be preserved.  *  *	Var_Append	    Append more characters to an existing variable  *	    	  	    in the given context. The variable needn't  *	    	  	    exist already -- it will be created if it doesn't.  *	    	  	    A space is placed between the old value and the  *	    	  	    new one.  *  *	Var_Exists	    See if a variable exists.  *  *	Var_Value 	    Return the value of a variable in a context or  *	    	  	    NULL if the variable is undefined.  *  *	Var_Subst 	    Substitute named variable, or all variables if  *			    NULL in a string using  *	    	  	    the given context as the top-most one. If the  *	    	  	    third argument is non-zero, Parse_Error is  *	    	  	    called if any variables are undefined.  *  *	Var_Parse 	    Parse a variable expansion from a string and  *	    	  	    return the result and the number of characters  *	    	  	    consumed.  *  *	Var_Delete	    Delete a variable in a context.  *  *	Var_Init  	    Initialize this module.  *  * Debugging:  *	Var_Dump  	    Print out all variables defined in the given  *	    	  	    context.  *  * XXX: There's a lot of duplication in these functions.  */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|"make.h"
end_include

begin_include
include|#
directive|include
file|"buf.h"
end_include

begin_comment
comment|/*  * This is a harmless return value for Var_Parse that can be used by Var_Subst  * to determine if there was an error in parsing -- easier than returning  * a flag, as things outside this module don't give a hoot.  */
end_comment

begin_decl_stmt
name|char
name|var_Error
index|[]
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Similar to var_Error, but returned when the 'err' flag for Var_Parse is  * set false. Why not just use a constant? Well, gcc likes to condense  * identical string instances...  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|varNoError
index|[]
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Internally, variables are contained in four different contexts.  *	1) the environment. They may not be changed. If an environment  *	    variable is appended-to, the result is placed in the global  *	    context.  *	2) the global context. Variables set in the Makefile are located in  *	    the global context. It is the penultimate context searched when  *	    substituting.  *	3) the command-line context. All variables set on the command line  *	   are placed in this context. They are UNALTERABLE once placed here.  *	4) the local context. Each target has associated with it a context  *	   list. On this list are located the structures describing such  *	   local variables as $(@) and $(*)  * The four contexts are searched in the reverse order from which they are  * listed.  */
end_comment

begin_decl_stmt
name|GNode
modifier|*
name|VAR_GLOBAL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* variables from the makefile */
end_comment

begin_decl_stmt
name|GNode
modifier|*
name|VAR_CMD
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* variables defined on the command-line */
end_comment

begin_decl_stmt
specifier|static
name|Lst
name|allVars
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List of all variables */
end_comment

begin_define
define|#
directive|define
name|FIND_CMD
value|0x1
end_define

begin_comment
comment|/* look in VAR_CMD when searching */
end_comment

begin_define
define|#
directive|define
name|FIND_GLOBAL
value|0x2
end_define

begin_comment
comment|/* look in VAR_GLOBAL as well */
end_comment

begin_define
define|#
directive|define
name|FIND_ENV
value|0x4
end_define

begin_comment
comment|/* look in the environment also */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|Var
block|{
name|char
modifier|*
name|name
decl_stmt|;
comment|/* the variable's name */
name|Buffer
name|val
decl_stmt|;
comment|/* its value */
name|int
name|flags
decl_stmt|;
comment|/* miscellaneous status flags */
define|#
directive|define
name|VAR_IN_USE
value|1
comment|/* Variable's value currently being used. 				     * Used to avoid recursion */
define|#
directive|define
name|VAR_FROM_ENV
value|2
comment|/* Variable comes from the environment */
define|#
directive|define
name|VAR_JUNK
value|4
comment|/* Variable is a junk variable that 				     * should be destroyed when done with 				     * it. Used by Var_Parse for undefined, 				     * modified variables */
block|}
name|Var
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|char
modifier|*
name|lhs
decl_stmt|;
comment|/* String to match */
name|int
name|leftLen
decl_stmt|;
comment|/* Length of string */
name|char
modifier|*
name|rhs
decl_stmt|;
comment|/* Replacement string (w/&'s removed) */
name|int
name|rightLen
decl_stmt|;
comment|/* Length of replacement */
name|int
name|flags
decl_stmt|;
define|#
directive|define
name|VAR_SUB_GLOBAL
value|1
comment|/* Apply substitution globally */
define|#
directive|define
name|VAR_MATCH_START
value|2
comment|/* Match at start of word */
define|#
directive|define
name|VAR_MATCH_END
value|4
comment|/* Match at end of word */
block|}
name|VarPattern
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|int
name|VarCmp
name|__P
argument_list|(
operator|(
name|ClientData
operator|,
name|ClientData
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Var
modifier|*
name|VarFind
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|GNode
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|VarAdd
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|GNode
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|VarDelete
name|__P
argument_list|(
operator|(
name|ClientData
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Boolean
name|VarHead
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|Boolean
operator|,
name|Buffer
operator|,
name|ClientData
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Boolean
name|VarTail
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|Boolean
operator|,
name|Buffer
operator|,
name|ClientData
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Boolean
name|VarSuffix
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|Boolean
operator|,
name|Buffer
operator|,
name|ClientData
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Boolean
name|VarRoot
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|Boolean
operator|,
name|Buffer
operator|,
name|ClientData
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Boolean
name|VarMatch
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|Boolean
operator|,
name|Buffer
operator|,
name|ClientData
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|SYSVVARSUB
end_ifdef

begin_decl_stmt
specifier|static
name|Boolean
name|VarSYSVMatch
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|Boolean
operator|,
name|Buffer
operator|,
name|ClientData
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|Boolean
name|VarNoMatch
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|Boolean
operator|,
name|Buffer
operator|,
name|ClientData
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Boolean
name|VarSubstitute
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|Boolean
operator|,
name|Buffer
operator|,
name|ClientData
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|VarModify
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|Boolean
argument_list|(
operator|*
argument_list|)
argument_list|(
name|char
operator|*
argument_list|,
name|Boolean
argument_list|,
name|Buffer
argument_list|,
name|ClientData
argument_list|)
operator|,
name|ClientData
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|VarPrintVar
name|__P
argument_list|(
operator|(
name|ClientData
operator|,
name|ClientData
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * VarCmp  --  *	See if the given variable matches the named one. Called from  *	Lst_Find when searching for a variable of a given name.  *  * Results:  *	0 if they match. non-zero otherwise.  *  * Side Effects:  *	none  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|VarCmp
parameter_list|(
name|v
parameter_list|,
name|name
parameter_list|)
name|ClientData
name|v
decl_stmt|;
comment|/* VAR structure to compare */
name|ClientData
name|name
decl_stmt|;
comment|/* name to look for */
block|{
return|return
operator|(
name|strcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|name
argument_list|,
operator|(
operator|(
name|Var
operator|*
operator|)
name|v
operator|)
operator|->
name|name
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * VarFind --  *	Find the given variable in the given context and any other contexts  *	indicated.  *  * Results:  *	A pointer to the structure describing the desired variable or  *	NIL if the variable does not exist.  *  * Side Effects:  *	None  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|Var
modifier|*
name|VarFind
parameter_list|(
name|name
parameter_list|,
name|ctxt
parameter_list|,
name|flags
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
comment|/* name to find */
name|GNode
modifier|*
name|ctxt
decl_stmt|;
comment|/* context in which to find it */
name|int
name|flags
decl_stmt|;
comment|/* FIND_GLOBAL set means to look in the 				 * VAR_GLOBAL context as well. 				 * FIND_CMD set means to look in the VAR_CMD 				 * context also. 				 * FIND_ENV set means to look in the 				 * environment */
block|{
name|LstNode
name|var
decl_stmt|;
name|Var
modifier|*
name|v
decl_stmt|;
comment|/* 	 * If the variable name begins with a '.', it could very well be one of 	 * the local ones.  We check the name against all the local variables 	 * and substitute the short version in for 'name' if it matches one of 	 * them. 	 */
if|if
condition|(
operator|*
name|name
operator|==
literal|'.'
operator|&&
name|isupper
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|name
index|[
literal|1
index|]
argument_list|)
condition|)
switch|switch
condition|(
name|name
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'A'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".ALLSRC"
argument_list|)
condition|)
name|name
operator|=
name|ALLSRC
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".ARCHIVE"
argument_list|)
condition|)
name|name
operator|=
name|ARCHIVE
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".IMPSRC"
argument_list|)
condition|)
name|name
operator|=
name|IMPSRC
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".MEMBER"
argument_list|)
condition|)
name|name
operator|=
name|MEMBER
expr_stmt|;
break|break;
case|case
literal|'O'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".OODATE"
argument_list|)
condition|)
name|name
operator|=
name|OODATE
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".PREFIX"
argument_list|)
condition|)
name|name
operator|=
name|PREFIX
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".TARGET"
argument_list|)
condition|)
name|name
operator|=
name|TARGET
expr_stmt|;
break|break;
block|}
comment|/*      * First look for the variable in the given context. If it's not there,      * look for it in VAR_CMD, VAR_GLOBAL and the environment, in that order,      * depending on the FIND_* flags in 'flags'      */
name|var
operator|=
name|Lst_Find
argument_list|(
name|ctxt
operator|->
name|context
argument_list|,
operator|(
name|ClientData
operator|)
name|name
argument_list|,
name|VarCmp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|var
operator|==
name|NILLNODE
operator|)
operator|&&
operator|(
name|flags
operator|&
name|FIND_CMD
operator|)
operator|&&
operator|(
name|ctxt
operator|!=
name|VAR_CMD
operator|)
condition|)
block|{
name|var
operator|=
name|Lst_Find
argument_list|(
name|VAR_CMD
operator|->
name|context
argument_list|,
operator|(
name|ClientData
operator|)
name|name
argument_list|,
name|VarCmp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|checkEnvFirst
operator|&&
operator|(
name|var
operator|==
name|NILLNODE
operator|)
operator|&&
operator|(
name|flags
operator|&
name|FIND_GLOBAL
operator|)
operator|&&
operator|(
name|ctxt
operator|!=
name|VAR_GLOBAL
operator|)
condition|)
block|{
name|var
operator|=
name|Lst_Find
argument_list|(
name|VAR_GLOBAL
operator|->
name|context
argument_list|,
operator|(
name|ClientData
operator|)
name|name
argument_list|,
name|VarCmp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|var
operator|==
name|NILLNODE
operator|)
operator|&&
operator|(
name|flags
operator|&
name|FIND_ENV
operator|)
condition|)
block|{
name|char
modifier|*
name|env
decl_stmt|;
if|if
condition|(
operator|(
name|env
operator|=
name|getenv
argument_list|(
name|name
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|int
name|len
decl_stmt|;
name|v
operator|=
operator|(
name|Var
operator|*
operator|)
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Var
argument_list|)
argument_list|)
expr_stmt|;
name|v
operator|->
name|name
operator|=
name|estrdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|env
argument_list|)
expr_stmt|;
name|v
operator|->
name|val
operator|=
name|Buf_Init
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|Buf_AddBytes
argument_list|(
name|v
operator|->
name|val
argument_list|,
name|len
argument_list|,
operator|(
name|Byte
operator|*
operator|)
name|env
argument_list|)
expr_stmt|;
name|v
operator|->
name|flags
operator|=
name|VAR_FROM_ENV
expr_stmt|;
return|return
operator|(
name|v
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|checkEnvFirst
operator|&&
operator|(
name|flags
operator|&
name|FIND_GLOBAL
operator|)
operator|&&
operator|(
name|ctxt
operator|!=
name|VAR_GLOBAL
operator|)
condition|)
block|{
name|var
operator|=
name|Lst_Find
argument_list|(
name|VAR_GLOBAL
operator|->
name|context
argument_list|,
operator|(
name|ClientData
operator|)
name|name
argument_list|,
name|VarCmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|var
operator|==
name|NILLNODE
condition|)
block|{
return|return
operator|(
operator|(
name|Var
operator|*
operator|)
name|NIL
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|Var
operator|*
operator|)
name|Lst_Datum
argument_list|(
name|var
argument_list|)
operator|)
return|;
block|}
block|}
else|else
block|{
return|return
operator|(
operator|(
name|Var
operator|*
operator|)
name|NIL
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|var
operator|==
name|NILLNODE
condition|)
block|{
return|return
operator|(
operator|(
name|Var
operator|*
operator|)
name|NIL
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|Var
operator|*
operator|)
name|Lst_Datum
argument_list|(
name|var
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * VarAdd  --  *	Add a new variable of name name and value val to the given context  *  * Results:  *	None  *  * Side Effects:  *	The new variable is placed at the front of the given context  *	The name and val arguments are duplicated so they may  *	safely be freed.  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|VarAdd
parameter_list|(
name|name
parameter_list|,
name|val
parameter_list|,
name|ctxt
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
comment|/* name of variable to add */
name|char
modifier|*
name|val
decl_stmt|;
comment|/* value to set it to */
name|GNode
modifier|*
name|ctxt
decl_stmt|;
comment|/* context in which to set it */
block|{
specifier|register
name|Var
modifier|*
name|v
decl_stmt|;
name|int
name|len
decl_stmt|;
name|v
operator|=
operator|(
name|Var
operator|*
operator|)
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Var
argument_list|)
argument_list|)
expr_stmt|;
name|v
operator|->
name|name
operator|=
name|estrdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|len
operator|=
name|val
condition|?
name|strlen
argument_list|(
name|val
argument_list|)
else|:
literal|0
expr_stmt|;
name|v
operator|->
name|val
operator|=
name|Buf_Init
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|Buf_AddBytes
argument_list|(
name|v
operator|->
name|val
argument_list|,
name|len
argument_list|,
operator|(
name|Byte
operator|*
operator|)
name|val
argument_list|)
expr_stmt|;
name|v
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|Lst_AtFront
argument_list|(
name|ctxt
operator|->
name|context
argument_list|,
operator|(
name|ClientData
operator|)
name|v
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Lst_AtEnd
argument_list|(
name|allVars
argument_list|,
operator|(
name|ClientData
operator|)
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEBUG
argument_list|(
name|VAR
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s:%s = %s\n"
argument_list|,
name|ctxt
operator|->
name|name
argument_list|,
name|name
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * VarDelete  --  *	Delete a variable and all the space associated with it.  *  * Results:  *	None  *  * Side Effects:  *	None  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|VarDelete
parameter_list|(
name|vp
parameter_list|)
name|ClientData
name|vp
decl_stmt|;
block|{
name|Var
modifier|*
name|v
init|=
operator|(
name|Var
operator|*
operator|)
name|vp
decl_stmt|;
name|free
argument_list|(
name|v
operator|->
name|name
argument_list|)
expr_stmt|;
name|Buf_Destroy
argument_list|(
name|v
operator|->
name|val
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|Address
operator|)
name|v
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Var_Delete --  *	Remove a variable from a context.  *  * Results:  *	None.  *  * Side Effects:  *	The Var structure is removed and freed.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Var_Delete
parameter_list|(
name|name
parameter_list|,
name|ctxt
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|GNode
modifier|*
name|ctxt
decl_stmt|;
block|{
name|LstNode
name|ln
decl_stmt|;
if|if
condition|(
name|DEBUG
argument_list|(
name|VAR
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s:delete %s\n"
argument_list|,
name|ctxt
operator|->
name|name
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
name|ln
operator|=
name|Lst_Find
argument_list|(
name|ctxt
operator|->
name|context
argument_list|,
operator|(
name|ClientData
operator|)
name|name
argument_list|,
name|VarCmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ln
operator|!=
name|NILLNODE
condition|)
block|{
specifier|register
name|Var
modifier|*
name|v
decl_stmt|;
name|v
operator|=
operator|(
name|Var
operator|*
operator|)
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
expr_stmt|;
name|Lst_Remove
argument_list|(
name|ctxt
operator|->
name|context
argument_list|,
name|ln
argument_list|)
expr_stmt|;
name|ln
operator|=
name|Lst_Member
argument_list|(
name|allVars
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|Lst_Remove
argument_list|(
name|allVars
argument_list|,
name|ln
argument_list|)
expr_stmt|;
name|VarDelete
argument_list|(
operator|(
name|ClientData
operator|)
name|v
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Var_Set --  *	Set the variable name to the value val in the given context.  *  * Results:  *	None.  *  * Side Effects:  *	If the variable doesn't yet exist, a new record is created for it.  *	Else the old value is freed and the new one stuck in its place  *  * Notes:  *	The variable is searched for only in its context before being  *	created in that context. I.e. if the context is VAR_GLOBAL,  *	only VAR_GLOBAL->context is searched. Likewise if it is VAR_CMD, only  *	VAR_CMD->context is searched. This is done to avoid the literally  *	thousands of unnecessary strcmp's that used to be done to  *	set, say, $(@) or $(<).  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Var_Set
parameter_list|(
name|name
parameter_list|,
name|val
parameter_list|,
name|ctxt
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
comment|/* name of variable to set */
name|char
modifier|*
name|val
decl_stmt|;
comment|/* value to give to the variable */
name|GNode
modifier|*
name|ctxt
decl_stmt|;
comment|/* context in which to set it */
block|{
specifier|register
name|Var
modifier|*
name|v
decl_stmt|;
comment|/*      * We only look for a variable in the given context since anything set      * here will override anything in a lower context, so there's not much      * point in searching them all just to save a bit of memory...      */
name|v
operator|=
name|VarFind
argument_list|(
name|name
argument_list|,
name|ctxt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|==
operator|(
name|Var
operator|*
operator|)
name|NIL
condition|)
block|{
name|VarAdd
argument_list|(
name|name
argument_list|,
name|val
argument_list|,
name|ctxt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Buf_Discard
argument_list|(
name|v
operator|->
name|val
argument_list|,
name|Buf_Size
argument_list|(
name|v
operator|->
name|val
argument_list|)
argument_list|)
expr_stmt|;
name|Buf_AddBytes
argument_list|(
name|v
operator|->
name|val
argument_list|,
name|strlen
argument_list|(
name|val
argument_list|)
argument_list|,
operator|(
name|Byte
operator|*
operator|)
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEBUG
argument_list|(
name|VAR
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s:%s = %s\n"
argument_list|,
name|ctxt
operator|->
name|name
argument_list|,
name|name
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*      * Any variables given on the command line are automatically exported      * to the environment (as per POSIX standard)      */
if|if
condition|(
name|ctxt
operator|==
name|VAR_CMD
condition|)
block|{
name|setenv
argument_list|(
name|name
argument_list|,
name|val
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Var_Append --  *	The variable of the given name has the given value appended to it in  *	the given context.  *  * Results:  *	None  *  * Side Effects:  *	If the variable doesn't exist, it is created. Else the strings  *	are concatenated (with a space in between).  *  * Notes:  *	Only if the variable is being sought in the global context is the  *	environment searched.  *	XXX: Knows its calling circumstances in that if called with ctxt  *	an actual target, it will only search that context since only  *	a local variable could be being appended to. This is actually  *	a big win and must be tolerated.  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Var_Append
parameter_list|(
name|name
parameter_list|,
name|val
parameter_list|,
name|ctxt
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Name of variable to modify */
name|char
modifier|*
name|val
decl_stmt|;
comment|/* String to append to it */
name|GNode
modifier|*
name|ctxt
decl_stmt|;
comment|/* Context in which this should occur */
block|{
specifier|register
name|Var
modifier|*
name|v
decl_stmt|;
name|v
operator|=
name|VarFind
argument_list|(
name|name
argument_list|,
name|ctxt
argument_list|,
operator|(
name|ctxt
operator|==
name|VAR_GLOBAL
operator|)
condition|?
name|FIND_ENV
else|:
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|==
operator|(
name|Var
operator|*
operator|)
name|NIL
condition|)
block|{
name|VarAdd
argument_list|(
name|name
argument_list|,
name|val
argument_list|,
name|ctxt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Buf_AddByte
argument_list|(
name|v
operator|->
name|val
argument_list|,
operator|(
name|Byte
operator|)
literal|' '
argument_list|)
expr_stmt|;
name|Buf_AddBytes
argument_list|(
name|v
operator|->
name|val
argument_list|,
name|strlen
argument_list|(
name|val
argument_list|)
argument_list|,
operator|(
name|Byte
operator|*
operator|)
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEBUG
argument_list|(
name|VAR
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s:%s = %s\n"
argument_list|,
name|ctxt
operator|->
name|name
argument_list|,
name|name
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Buf_GetAll
argument_list|(
name|v
operator|->
name|val
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|v
operator|->
name|flags
operator|&
name|VAR_FROM_ENV
condition|)
block|{
comment|/* 	     * If the original variable came from the environment, we 	     * have to install it in the global context (we could place 	     * it in the environment, but then we should provide a way to 	     * export other variables...) 	     */
name|v
operator|->
name|flags
operator|&=
operator|~
name|VAR_FROM_ENV
expr_stmt|;
name|Lst_AtFront
argument_list|(
name|ctxt
operator|->
name|context
argument_list|,
operator|(
name|ClientData
operator|)
name|v
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Var_Exists --  *	See if the given variable exists.  *  * Results:  *	TRUE if it does, FALSE if it doesn't  *  * Side Effects:  *	None.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|Boolean
name|Var_Exists
parameter_list|(
name|name
parameter_list|,
name|ctxt
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Variable to find */
name|GNode
modifier|*
name|ctxt
decl_stmt|;
comment|/* Context in which to start search */
block|{
name|Var
modifier|*
name|v
decl_stmt|;
name|v
operator|=
name|VarFind
argument_list|(
name|name
argument_list|,
name|ctxt
argument_list|,
name|FIND_CMD
operator||
name|FIND_GLOBAL
operator||
name|FIND_ENV
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|==
operator|(
name|Var
operator|*
operator|)
name|NIL
condition|)
block|{
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|v
operator|->
name|flags
operator|&
name|VAR_FROM_ENV
condition|)
block|{
name|free
argument_list|(
name|v
operator|->
name|name
argument_list|)
expr_stmt|;
name|Buf_Destroy
argument_list|(
name|v
operator|->
name|val
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|v
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Var_Value --  *	Return the value of the named variable in the given context  *  * Results:  *	The value if the variable exists, NULL if it doesn't  *  * Side Effects:  *	None  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|char
modifier|*
name|Var_Value
parameter_list|(
name|name
parameter_list|,
name|ctxt
parameter_list|,
name|frp
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
comment|/* name to find */
name|GNode
modifier|*
name|ctxt
decl_stmt|;
comment|/* context in which to search for it */
name|char
modifier|*
modifier|*
name|frp
decl_stmt|;
block|{
name|Var
modifier|*
name|v
decl_stmt|;
name|v
operator|=
name|VarFind
argument_list|(
name|name
argument_list|,
name|ctxt
argument_list|,
name|FIND_ENV
operator||
name|FIND_GLOBAL
operator||
name|FIND_CMD
argument_list|)
expr_stmt|;
operator|*
name|frp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|v
operator|!=
operator|(
name|Var
operator|*
operator|)
name|NIL
condition|)
block|{
name|char
modifier|*
name|p
init|=
operator|(
operator|(
name|char
operator|*
operator|)
name|Buf_GetAll
argument_list|(
name|v
operator|->
name|val
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|v
operator|->
name|flags
operator|&
name|VAR_FROM_ENV
condition|)
block|{
name|Buf_Destroy
argument_list|(
name|v
operator|->
name|val
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|Address
operator|)
name|v
argument_list|)
expr_stmt|;
operator|*
name|frp
operator|=
name|p
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * VarHead --  *	Remove the tail of the given word and place the result in the given  *	buffer.  *  * Results:  *	TRUE if characters were added to the buffer (a space needs to be  *	added to the buffer before the next word).  *  * Side Effects:  *	The trimmed word is added to the buffer.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|Boolean
name|VarHead
parameter_list|(
name|word
parameter_list|,
name|addSpace
parameter_list|,
name|buf
parameter_list|,
name|dummy
parameter_list|)
name|char
modifier|*
name|word
decl_stmt|;
comment|/* Word to trim */
name|Boolean
name|addSpace
decl_stmt|;
comment|/* True if need to add a space to the buffer 				 * before sticking in the head */
name|Buffer
name|buf
decl_stmt|;
comment|/* Buffer in which to store it */
name|ClientData
name|dummy
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|slash
decl_stmt|;
name|slash
operator|=
name|strrchr
argument_list|(
name|word
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|slash
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
if|if
condition|(
name|addSpace
condition|)
block|{
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
operator|(
name|Byte
operator|)
literal|' '
argument_list|)
expr_stmt|;
block|}
operator|*
name|slash
operator|=
literal|'\0'
expr_stmt|;
name|Buf_AddBytes
argument_list|(
name|buf
argument_list|,
name|strlen
argument_list|(
name|word
argument_list|)
argument_list|,
operator|(
name|Byte
operator|*
operator|)
name|word
argument_list|)
expr_stmt|;
operator|*
name|slash
operator|=
literal|'/'
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
else|else
block|{
comment|/* 	 * If no directory part, give . (q.v. the POSIX standard) 	 */
if|if
condition|(
name|addSpace
condition|)
block|{
name|Buf_AddBytes
argument_list|(
name|buf
argument_list|,
literal|2
argument_list|,
operator|(
name|Byte
operator|*
operator|)
literal|" ."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
operator|(
name|Byte
operator|)
literal|'.'
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|dummy
condition|?
name|TRUE
else|:
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * VarTail --  *	Remove the head of the given word and place the result in the given  *	buffer.  *  * Results:  *	TRUE if characters were added to the buffer (a space needs to be  *	added to the buffer before the next word).  *  * Side Effects:  *	The trimmed word is added to the buffer.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|Boolean
name|VarTail
parameter_list|(
name|word
parameter_list|,
name|addSpace
parameter_list|,
name|buf
parameter_list|,
name|dummy
parameter_list|)
name|char
modifier|*
name|word
decl_stmt|;
comment|/* Word to trim */
name|Boolean
name|addSpace
decl_stmt|;
comment|/* TRUE if need to stick a space in the 				 * buffer before adding the tail */
name|Buffer
name|buf
decl_stmt|;
comment|/* Buffer in which to store it */
name|ClientData
name|dummy
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|slash
decl_stmt|;
if|if
condition|(
name|addSpace
condition|)
block|{
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
operator|(
name|Byte
operator|)
literal|' '
argument_list|)
expr_stmt|;
block|}
name|slash
operator|=
name|strrchr
argument_list|(
name|word
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|slash
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
operator|*
name|slash
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|Buf_AddBytes
argument_list|(
name|buf
argument_list|,
name|strlen
argument_list|(
name|slash
argument_list|)
argument_list|,
operator|(
name|Byte
operator|*
operator|)
name|slash
argument_list|)
expr_stmt|;
name|slash
index|[
operator|-
literal|1
index|]
operator|=
literal|'/'
expr_stmt|;
block|}
else|else
block|{
name|Buf_AddBytes
argument_list|(
name|buf
argument_list|,
name|strlen
argument_list|(
name|word
argument_list|)
argument_list|,
operator|(
name|Byte
operator|*
operator|)
name|word
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|dummy
condition|?
name|TRUE
else|:
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * VarSuffix --  *	Place the suffix of the given word in the given buffer.  *  * Results:  *	TRUE if characters were added to the buffer (a space needs to be  *	added to the buffer before the next word).  *  * Side Effects:  *	The suffix from the word is placed in the buffer.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|Boolean
name|VarSuffix
parameter_list|(
name|word
parameter_list|,
name|addSpace
parameter_list|,
name|buf
parameter_list|,
name|dummy
parameter_list|)
name|char
modifier|*
name|word
decl_stmt|;
comment|/* Word to trim */
name|Boolean
name|addSpace
decl_stmt|;
comment|/* TRUE if need to add a space before placing 				 * the suffix in the buffer */
name|Buffer
name|buf
decl_stmt|;
comment|/* Buffer in which to store it */
name|ClientData
name|dummy
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|dot
decl_stmt|;
name|dot
operator|=
name|strrchr
argument_list|(
name|word
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|dot
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
if|if
condition|(
name|addSpace
condition|)
block|{
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
operator|(
name|Byte
operator|)
literal|' '
argument_list|)
expr_stmt|;
block|}
operator|*
name|dot
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|Buf_AddBytes
argument_list|(
name|buf
argument_list|,
name|strlen
argument_list|(
name|dot
argument_list|)
argument_list|,
operator|(
name|Byte
operator|*
operator|)
name|dot
argument_list|)
expr_stmt|;
name|dot
index|[
operator|-
literal|1
index|]
operator|=
literal|'.'
expr_stmt|;
name|addSpace
operator|=
name|TRUE
expr_stmt|;
block|}
return|return
operator|(
name|dummy
condition|?
name|addSpace
else|:
name|addSpace
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * VarRoot --  *	Remove the suffix of the given word and place the result in the  *	buffer.  *  * Results:  *	TRUE if characters were added to the buffer (a space needs to be  *	added to the buffer before the next word).  *  * Side Effects:  *	The trimmed word is added to the buffer.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|Boolean
name|VarRoot
parameter_list|(
name|word
parameter_list|,
name|addSpace
parameter_list|,
name|buf
parameter_list|,
name|dummy
parameter_list|)
name|char
modifier|*
name|word
decl_stmt|;
comment|/* Word to trim */
name|Boolean
name|addSpace
decl_stmt|;
comment|/* TRUE if need to add a space to the buffer 				 * before placing the root in it */
name|Buffer
name|buf
decl_stmt|;
comment|/* Buffer in which to store it */
name|ClientData
name|dummy
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|dot
decl_stmt|;
if|if
condition|(
name|addSpace
condition|)
block|{
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
operator|(
name|Byte
operator|)
literal|' '
argument_list|)
expr_stmt|;
block|}
name|dot
operator|=
name|strrchr
argument_list|(
name|word
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|dot
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
operator|*
name|dot
operator|=
literal|'\0'
expr_stmt|;
name|Buf_AddBytes
argument_list|(
name|buf
argument_list|,
name|strlen
argument_list|(
name|word
argument_list|)
argument_list|,
operator|(
name|Byte
operator|*
operator|)
name|word
argument_list|)
expr_stmt|;
operator|*
name|dot
operator|=
literal|'.'
expr_stmt|;
block|}
else|else
block|{
name|Buf_AddBytes
argument_list|(
name|buf
argument_list|,
name|strlen
argument_list|(
name|word
argument_list|)
argument_list|,
operator|(
name|Byte
operator|*
operator|)
name|word
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|dummy
condition|?
name|TRUE
else|:
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * VarMatch --  *	Place the word in the buffer if it matches the given pattern.  *	Callback function for VarModify to implement the :M modifier.  *  * Results:  *	TRUE if a space should be placed in the buffer before the next  *	word.  *  * Side Effects:  *	The word may be copied to the buffer.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|Boolean
name|VarMatch
parameter_list|(
name|word
parameter_list|,
name|addSpace
parameter_list|,
name|buf
parameter_list|,
name|pattern
parameter_list|)
name|char
modifier|*
name|word
decl_stmt|;
comment|/* Word to examine */
name|Boolean
name|addSpace
decl_stmt|;
comment|/* TRUE if need to add a space to the 				 * buffer before adding the word, if it 				 * matches */
name|Buffer
name|buf
decl_stmt|;
comment|/* Buffer in which to store it */
name|ClientData
name|pattern
decl_stmt|;
comment|/* Pattern the word must match */
block|{
if|if
condition|(
name|Str_Match
argument_list|(
name|word
argument_list|,
operator|(
name|char
operator|*
operator|)
name|pattern
argument_list|)
condition|)
block|{
if|if
condition|(
name|addSpace
condition|)
block|{
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
operator|(
name|Byte
operator|)
literal|' '
argument_list|)
expr_stmt|;
block|}
name|addSpace
operator|=
name|TRUE
expr_stmt|;
name|Buf_AddBytes
argument_list|(
name|buf
argument_list|,
name|strlen
argument_list|(
name|word
argument_list|)
argument_list|,
operator|(
name|Byte
operator|*
operator|)
name|word
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|addSpace
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SYSVVARSUB
end_ifdef

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * VarSYSVMatch --  *	Place the word in the buffer if it matches the given pattern.  *	Callback function for VarModify to implement the System V %  *	modifiers.  *  * Results:  *	TRUE if a space should be placed in the buffer before the next  *	word.  *  * Side Effects:  *	The word may be copied to the buffer.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|Boolean
name|VarSYSVMatch
parameter_list|(
name|word
parameter_list|,
name|addSpace
parameter_list|,
name|buf
parameter_list|,
name|patp
parameter_list|)
name|char
modifier|*
name|word
decl_stmt|;
comment|/* Word to examine */
name|Boolean
name|addSpace
decl_stmt|;
comment|/* TRUE if need to add a space to the 				 * buffer before adding the word, if it 				 * matches */
name|Buffer
name|buf
decl_stmt|;
comment|/* Buffer in which to store it */
name|ClientData
name|patp
decl_stmt|;
comment|/* Pattern the word must match */
block|{
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
name|VarPattern
modifier|*
name|pat
init|=
operator|(
name|VarPattern
operator|*
operator|)
name|patp
decl_stmt|;
if|if
condition|(
name|addSpace
condition|)
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
operator|(
name|Byte
operator|)
literal|' '
argument_list|)
expr_stmt|;
name|addSpace
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|(
name|ptr
operator|=
name|Str_SYSVMatch
argument_list|(
name|word
argument_list|,
name|pat
operator|->
name|lhs
argument_list|,
operator|&
name|len
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|Str_SYSVSubst
argument_list|(
name|buf
argument_list|,
name|pat
operator|->
name|rhs
argument_list|,
name|ptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
else|else
name|Buf_AddBytes
argument_list|(
name|buf
argument_list|,
name|strlen
argument_list|(
name|word
argument_list|)
argument_list|,
operator|(
name|Byte
operator|*
operator|)
name|word
argument_list|)
expr_stmt|;
return|return
operator|(
name|addSpace
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * VarNoMatch --  *	Place the word in the buffer if it doesn't match the given pattern.  *	Callback function for VarModify to implement the :N modifier.  *  * Results:  *	TRUE if a space should be placed in the buffer before the next  *	word.  *  * Side Effects:  *	The word may be copied to the buffer.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|Boolean
name|VarNoMatch
parameter_list|(
name|word
parameter_list|,
name|addSpace
parameter_list|,
name|buf
parameter_list|,
name|pattern
parameter_list|)
name|char
modifier|*
name|word
decl_stmt|;
comment|/* Word to examine */
name|Boolean
name|addSpace
decl_stmt|;
comment|/* TRUE if need to add a space to the 				 * buffer before adding the word, if it 				 * matches */
name|Buffer
name|buf
decl_stmt|;
comment|/* Buffer in which to store it */
name|ClientData
name|pattern
decl_stmt|;
comment|/* Pattern the word must match */
block|{
if|if
condition|(
operator|!
name|Str_Match
argument_list|(
name|word
argument_list|,
operator|(
name|char
operator|*
operator|)
name|pattern
argument_list|)
condition|)
block|{
if|if
condition|(
name|addSpace
condition|)
block|{
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
operator|(
name|Byte
operator|)
literal|' '
argument_list|)
expr_stmt|;
block|}
name|addSpace
operator|=
name|TRUE
expr_stmt|;
name|Buf_AddBytes
argument_list|(
name|buf
argument_list|,
name|strlen
argument_list|(
name|word
argument_list|)
argument_list|,
operator|(
name|Byte
operator|*
operator|)
name|word
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|addSpace
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * VarSubstitute --  *	Perform a string-substitution on the given word, placing the  *	result in the passed buffer.  *  * Results:  *	TRUE if a space is needed before more characters are added.  *  * Side Effects:  *	None.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|Boolean
name|VarSubstitute
parameter_list|(
name|word
parameter_list|,
name|addSpace
parameter_list|,
name|buf
parameter_list|,
name|patternp
parameter_list|)
name|char
modifier|*
name|word
decl_stmt|;
comment|/* Word to modify */
name|Boolean
name|addSpace
decl_stmt|;
comment|/* True if space should be added before 				     * other characters */
name|Buffer
name|buf
decl_stmt|;
comment|/* Buffer for result */
name|ClientData
name|patternp
decl_stmt|;
comment|/* Pattern for substitution */
block|{
specifier|register
name|int
name|wordLen
decl_stmt|;
comment|/* Length of word */
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* General pointer */
name|VarPattern
modifier|*
name|pattern
init|=
operator|(
name|VarPattern
operator|*
operator|)
name|patternp
decl_stmt|;
name|wordLen
operator|=
name|strlen
argument_list|(
name|word
argument_list|)
expr_stmt|;
if|if
condition|(
literal|1
condition|)
block|{
comment|/* substitute in each word of the variable */
comment|/* 	 * Break substitution down into simple anchored cases 	 * and if none of them fits, perform the general substitution case. 	 */
if|if
condition|(
operator|(
name|pattern
operator|->
name|flags
operator|&
name|VAR_MATCH_START
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|word
argument_list|,
name|pattern
operator|->
name|lhs
argument_list|,
name|pattern
operator|->
name|leftLen
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* 		 * Anchored at start and beginning of word matches pattern 		 */
if|if
condition|(
operator|(
name|pattern
operator|->
name|flags
operator|&
name|VAR_MATCH_END
operator|)
operator|&&
operator|(
name|wordLen
operator|==
name|pattern
operator|->
name|leftLen
operator|)
condition|)
block|{
comment|/* 			 * Also anchored at end and matches to the end (word 			 * is same length as pattern) add space and rhs only 			 * if rhs is non-null. 			 */
if|if
condition|(
name|pattern
operator|->
name|rightLen
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|addSpace
condition|)
block|{
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
operator|(
name|Byte
operator|)
literal|' '
argument_list|)
expr_stmt|;
block|}
name|addSpace
operator|=
name|TRUE
expr_stmt|;
name|Buf_AddBytes
argument_list|(
name|buf
argument_list|,
name|pattern
operator|->
name|rightLen
argument_list|,
operator|(
name|Byte
operator|*
operator|)
name|pattern
operator|->
name|rhs
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|pattern
operator|->
name|flags
operator|&
name|VAR_MATCH_END
condition|)
block|{
comment|/* 		     * Doesn't match to end -- copy word wholesale 		     */
goto|goto
name|nosub
goto|;
block|}
else|else
block|{
comment|/* 		     * Matches at start but need to copy in trailing characters 		     */
if|if
condition|(
operator|(
name|pattern
operator|->
name|rightLen
operator|+
name|wordLen
operator|-
name|pattern
operator|->
name|leftLen
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|addSpace
condition|)
block|{
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
operator|(
name|Byte
operator|)
literal|' '
argument_list|)
expr_stmt|;
block|}
name|addSpace
operator|=
name|TRUE
expr_stmt|;
block|}
name|Buf_AddBytes
argument_list|(
name|buf
argument_list|,
name|pattern
operator|->
name|rightLen
argument_list|,
operator|(
name|Byte
operator|*
operator|)
name|pattern
operator|->
name|rhs
argument_list|)
expr_stmt|;
name|Buf_AddBytes
argument_list|(
name|buf
argument_list|,
name|wordLen
operator|-
name|pattern
operator|->
name|leftLen
argument_list|,
operator|(
name|Byte
operator|*
operator|)
operator|(
name|word
operator|+
name|pattern
operator|->
name|leftLen
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|pattern
operator|->
name|flags
operator|&
name|VAR_MATCH_START
condition|)
block|{
comment|/* 	     * Had to match at start of word and didn't -- copy whole word. 	     */
goto|goto
name|nosub
goto|;
block|}
elseif|else
if|if
condition|(
name|pattern
operator|->
name|flags
operator|&
name|VAR_MATCH_END
condition|)
block|{
comment|/* 	     * Anchored at end, Find only place match could occur (leftLen 	     * characters from the end of the word) and see if it does. Note 	     * that because the $ will be left at the end of the lhs, we have 	     * to use strncmp. 	     */
name|cp
operator|=
name|word
operator|+
operator|(
name|wordLen
operator|-
name|pattern
operator|->
name|leftLen
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|>=
name|word
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|cp
argument_list|,
name|pattern
operator|->
name|lhs
argument_list|,
name|pattern
operator|->
name|leftLen
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* 		 * Match found. If we will place characters in the buffer, 		 * add a space before hand as indicated by addSpace, then 		 * stuff in the initial, unmatched part of the word followed 		 * by the right-hand-side. 		 */
if|if
condition|(
operator|(
operator|(
name|cp
operator|-
name|word
operator|)
operator|+
name|pattern
operator|->
name|rightLen
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|addSpace
condition|)
block|{
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
operator|(
name|Byte
operator|)
literal|' '
argument_list|)
expr_stmt|;
block|}
name|addSpace
operator|=
name|TRUE
expr_stmt|;
block|}
name|Buf_AddBytes
argument_list|(
name|buf
argument_list|,
name|cp
operator|-
name|word
argument_list|,
operator|(
name|Byte
operator|*
operator|)
name|word
argument_list|)
expr_stmt|;
name|Buf_AddBytes
argument_list|(
name|buf
argument_list|,
name|pattern
operator|->
name|rightLen
argument_list|,
operator|(
name|Byte
operator|*
operator|)
name|pattern
operator|->
name|rhs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Had to match at end and didn't. Copy entire word. 		 */
goto|goto
name|nosub
goto|;
block|}
block|}
else|else
block|{
comment|/* 	     * Pattern is unanchored: search for the pattern in the word using 	     * String_FindSubstring, copying unmatched portions and the 	     * right-hand-side for each match found, handling non-global 	     * substitutions correctly, etc. When the loop is done, any 	     * remaining part of the word (word and wordLen are adjusted 	     * accordingly through the loop) is copied straight into the 	     * buffer. 	     * addSpace is set FALSE as soon as a space is added to the 	     * buffer. 	     */
specifier|register
name|Boolean
name|done
decl_stmt|;
name|int
name|origSize
decl_stmt|;
name|done
operator|=
name|FALSE
expr_stmt|;
name|origSize
operator|=
name|Buf_Size
argument_list|(
name|buf
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|done
condition|)
block|{
name|cp
operator|=
name|Str_FindSubstring
argument_list|(
name|word
argument_list|,
name|pattern
operator|->
name|lhs
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
if|if
condition|(
name|addSpace
operator|&&
operator|(
operator|(
operator|(
name|cp
operator|-
name|word
operator|)
operator|+
name|pattern
operator|->
name|rightLen
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
operator|(
name|Byte
operator|)
literal|' '
argument_list|)
expr_stmt|;
name|addSpace
operator|=
name|FALSE
expr_stmt|;
block|}
name|Buf_AddBytes
argument_list|(
name|buf
argument_list|,
name|cp
operator|-
name|word
argument_list|,
operator|(
name|Byte
operator|*
operator|)
name|word
argument_list|)
expr_stmt|;
name|Buf_AddBytes
argument_list|(
name|buf
argument_list|,
name|pattern
operator|->
name|rightLen
argument_list|,
operator|(
name|Byte
operator|*
operator|)
name|pattern
operator|->
name|rhs
argument_list|)
expr_stmt|;
name|wordLen
operator|-=
operator|(
name|cp
operator|-
name|word
operator|)
operator|+
name|pattern
operator|->
name|leftLen
expr_stmt|;
name|word
operator|=
name|cp
operator|+
name|pattern
operator|->
name|leftLen
expr_stmt|;
if|if
condition|(
name|wordLen
operator|==
literal|0
operator|||
operator|(
name|pattern
operator|->
name|flags
operator|&
name|VAR_SUB_GLOBAL
operator|)
operator|==
literal|0
condition|)
block|{
name|done
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
else|else
block|{
name|done
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|wordLen
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|addSpace
condition|)
block|{
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
operator|(
name|Byte
operator|)
literal|' '
argument_list|)
expr_stmt|;
block|}
name|Buf_AddBytes
argument_list|(
name|buf
argument_list|,
name|wordLen
argument_list|,
operator|(
name|Byte
operator|*
operator|)
name|word
argument_list|)
expr_stmt|;
block|}
comment|/* 	     * If added characters to the buffer, need to add a space 	     * before we add any more. If we didn't add any, just return 	     * the previous value of addSpace. 	     */
return|return
operator|(
operator|(
name|Buf_Size
argument_list|(
name|buf
argument_list|)
operator|!=
name|origSize
operator|)
operator|||
name|addSpace
operator|)
return|;
block|}
comment|/* 	 * Common code for anchored substitutions: 	 * addSpace was set TRUE if characters were added to the buffer. 	 */
return|return
operator|(
name|addSpace
operator|)
return|;
block|}
name|nosub
label|:
if|if
condition|(
name|addSpace
condition|)
block|{
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
operator|(
name|Byte
operator|)
literal|' '
argument_list|)
expr_stmt|;
block|}
name|Buf_AddBytes
argument_list|(
name|buf
argument_list|,
name|wordLen
argument_list|,
operator|(
name|Byte
operator|*
operator|)
name|word
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * VarModify --  *	Modify each of the words of the passed string using the given  *	function. Used to implement all modifiers.  *  * Results:  *	A string of all the words modified appropriately.  *  * Side Effects:  *	None.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function_decl
specifier|static
name|char
modifier|*
name|VarModify
parameter_list|(
name|str
parameter_list|,
name|modProc
parameter_list|,
name|datum
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
comment|/* String whose words should be trimmed */
comment|/* Function to use to modify them */
function_decl|Boolean
parameter_list|(
function_decl|*modProc
end_function_decl

begin_expr_stmt
unit|)
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|Boolean
operator|,
name|Buffer
operator|,
name|ClientData
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|ClientData
name|datum
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Datum to pass it */
end_comment

begin_block
block|{
name|Buffer
name|buf
decl_stmt|;
comment|/* Buffer for the new string */
name|Boolean
name|addSpace
decl_stmt|;
comment|/* TRUE if need to add a space to the 				     * buffer before adding the trimmed 				     * word */
name|char
modifier|*
modifier|*
name|av
decl_stmt|;
comment|/* word list [first word does not count] */
name|int
name|ac
decl_stmt|,
name|i
decl_stmt|;
name|buf
operator|=
name|Buf_Init
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|addSpace
operator|=
name|FALSE
expr_stmt|;
name|av
operator|=
name|brk_string
argument_list|(
name|str
argument_list|,
operator|&
name|ac
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|ac
condition|;
name|i
operator|++
control|)
name|addSpace
operator|=
call|(
modifier|*
name|modProc
call|)
argument_list|(
name|av
index|[
name|i
index|]
argument_list|,
name|addSpace
argument_list|,
name|buf
argument_list|,
name|datum
argument_list|)
expr_stmt|;
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
name|str
operator|=
operator|(
name|char
operator|*
operator|)
name|Buf_GetAll
argument_list|(
name|buf
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|Buf_Destroy
argument_list|(
name|buf
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
operator|(
name|str
operator|)
return|;
block|}
end_block

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Var_Parse --  *	Given the start of a variable invocation, extract the variable  *	name and find its value, then modify it according to the  *	specification.  *  * Results:  *	The (possibly-modified) value of the variable or var_Error if the  *	specification is invalid. The length of the specification is  *	placed in *lengthPtr (for invalid specifications, this is just  *	2...?).  *	A Boolean in *freePtr telling whether the returned string should  *	be freed by the caller.  *  * Side Effects:  *	None.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|char
modifier|*
name|Var_Parse
parameter_list|(
name|str
parameter_list|,
name|ctxt
parameter_list|,
name|err
parameter_list|,
name|lengthPtr
parameter_list|,
name|freePtr
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
comment|/* The string to parse */
name|GNode
modifier|*
name|ctxt
decl_stmt|;
comment|/* The context for the variable */
name|Boolean
name|err
decl_stmt|;
comment|/* TRUE if undefined variables are an error */
name|int
modifier|*
name|lengthPtr
decl_stmt|;
comment|/* OUT: The length of the specification */
name|Boolean
modifier|*
name|freePtr
decl_stmt|;
comment|/* OUT: TRUE if caller should free result */
block|{
specifier|register
name|char
modifier|*
name|tstr
decl_stmt|;
comment|/* Pointer into str */
name|Var
modifier|*
name|v
decl_stmt|;
comment|/* Variable in invocation */
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* Secondary pointer into str (place marker 				 * for tstr) */
name|Boolean
name|haveModifier
decl_stmt|;
comment|/* TRUE if have modifiers for the variable */
specifier|register
name|char
name|endc
decl_stmt|;
comment|/* Ending character when variable in parens 				 * or braces */
specifier|register
name|char
name|startc
init|=
literal|0
decl_stmt|;
comment|/* Starting character when variable in parens 				 * or braces */
name|int
name|cnt
decl_stmt|;
comment|/* Used to count brace pairs when variable in 				 * in parens or braces */
name|char
modifier|*
name|start
decl_stmt|;
name|Boolean
name|dynamic
decl_stmt|;
comment|/* TRUE if the variable is local and we're 				 * expanding it in a non-local context. This 				 * is done to support dynamic sources. The 				 * result is just the invocation, unaltered */
operator|*
name|freePtr
operator|=
name|FALSE
expr_stmt|;
name|dynamic
operator|=
name|FALSE
expr_stmt|;
name|start
operator|=
name|str
expr_stmt|;
if|if
condition|(
name|str
index|[
literal|1
index|]
operator|!=
literal|'('
operator|&&
name|str
index|[
literal|1
index|]
operator|!=
literal|'{'
condition|)
block|{
comment|/* 	 * If it's not bounded by braces of some sort, life is much simpler. 	 * We just need to check for the first character and return the 	 * value if it exists. 	 */
name|char
name|name
index|[
literal|2
index|]
decl_stmt|;
name|name
index|[
literal|0
index|]
operator|=
name|str
index|[
literal|1
index|]
expr_stmt|;
name|name
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|v
operator|=
name|VarFind
argument_list|(
name|name
argument_list|,
name|ctxt
argument_list|,
name|FIND_ENV
operator||
name|FIND_GLOBAL
operator||
name|FIND_CMD
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|==
operator|(
name|Var
operator|*
operator|)
name|NIL
condition|)
block|{
operator|*
name|lengthPtr
operator|=
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|ctxt
operator|==
name|VAR_CMD
operator|)
operator|||
operator|(
name|ctxt
operator|==
name|VAR_GLOBAL
operator|)
condition|)
block|{
comment|/* 		 * If substituting a local variable in a non-local context, 		 * assume it's for dynamic source stuff. We have to handle 		 * this specially and return the longhand for the variable 		 * with the dollar sign escaped so it makes it back to the 		 * caller. Only four of the local variables are treated 		 * specially as they are the only four that will be set 		 * when dynamic sources are expanded. 		 */
switch|switch
condition|(
name|str
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'@'
case|:
return|return
operator|(
literal|"$(.TARGET)"
operator|)
return|;
case|case
literal|'%'
case|:
return|return
operator|(
literal|"$(.ARCHIVE)"
operator|)
return|;
case|case
literal|'*'
case|:
return|return
operator|(
literal|"$(.PREFIX)"
operator|)
return|;
case|case
literal|'!'
case|:
return|return
operator|(
literal|"$(.MEMBER)"
operator|)
return|;
block|}
block|}
comment|/* 	     * Error 	     */
return|return
operator|(
name|err
condition|?
name|var_Error
else|:
name|varNoError
operator|)
return|;
block|}
else|else
block|{
name|haveModifier
operator|=
name|FALSE
expr_stmt|;
name|tstr
operator|=
operator|&
name|str
index|[
literal|1
index|]
expr_stmt|;
name|endc
operator|=
name|str
index|[
literal|1
index|]
expr_stmt|;
block|}
block|}
else|else
block|{
name|startc
operator|=
name|str
index|[
literal|1
index|]
expr_stmt|;
name|endc
operator|=
name|startc
operator|==
literal|'('
condition|?
literal|')'
else|:
literal|'}'
expr_stmt|;
comment|/* 	 * Skip to the end character or a colon, whichever comes first. 	 */
for|for
control|(
name|tstr
operator|=
name|str
operator|+
literal|2
init|;
operator|*
name|tstr
operator|!=
literal|'\0'
operator|&&
operator|*
name|tstr
operator|!=
name|endc
operator|&&
operator|*
name|tstr
operator|!=
literal|':'
condition|;
name|tstr
operator|++
control|)
block|{
continue|continue;
block|}
if|if
condition|(
operator|*
name|tstr
operator|==
literal|':'
condition|)
block|{
name|haveModifier
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|tstr
operator|!=
literal|'\0'
condition|)
block|{
name|haveModifier
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
comment|/* 	     * If we never did find the end character, return NULL 	     * right now, setting the length to be the distance to 	     * the end of the string, since that's what make does. 	     */
operator|*
name|lengthPtr
operator|=
name|tstr
operator|-
name|str
expr_stmt|;
return|return
operator|(
name|var_Error
operator|)
return|;
block|}
operator|*
name|tstr
operator|=
literal|'\0'
expr_stmt|;
name|v
operator|=
name|VarFind
argument_list|(
name|str
operator|+
literal|2
argument_list|,
name|ctxt
argument_list|,
name|FIND_ENV
operator||
name|FIND_GLOBAL
operator||
name|FIND_CMD
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|v
operator|==
operator|(
name|Var
operator|*
operator|)
name|NIL
operator|)
operator|&&
operator|(
name|ctxt
operator|!=
name|VAR_CMD
operator|)
operator|&&
operator|(
name|ctxt
operator|!=
name|VAR_GLOBAL
operator|)
operator|&&
operator|(
operator|(
name|tstr
operator|-
name|str
operator|)
operator|==
literal|4
operator|)
operator|&&
operator|(
name|str
index|[
literal|3
index|]
operator|==
literal|'F'
operator|||
name|str
index|[
literal|3
index|]
operator|==
literal|'D'
operator|)
condition|)
block|{
comment|/* 	     * Check for bogus D and F forms of local variables since we're 	     * in a local context and the name is the right length. 	     */
switch|switch
condition|(
name|str
index|[
literal|2
index|]
condition|)
block|{
case|case
literal|'@'
case|:
case|case
literal|'%'
case|:
case|case
literal|'*'
case|:
case|case
literal|'!'
case|:
case|case
literal|'>'
case|:
case|case
literal|'<'
case|:
block|{
name|char
name|vname
index|[
literal|2
index|]
decl_stmt|;
name|char
modifier|*
name|val
decl_stmt|;
comment|/* 		     * Well, it's local -- go look for it. 		     */
name|vname
index|[
literal|0
index|]
operator|=
name|str
index|[
literal|2
index|]
expr_stmt|;
name|vname
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|v
operator|=
name|VarFind
argument_list|(
name|vname
argument_list|,
name|ctxt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|!=
operator|(
name|Var
operator|*
operator|)
name|NIL
condition|)
block|{
comment|/* 			 * No need for nested expansion or anything, as we're 			 * the only one who sets these things and we sure don't 			 * but nested invocations in them... 			 */
name|val
operator|=
operator|(
name|char
operator|*
operator|)
name|Buf_GetAll
argument_list|(
name|v
operator|->
name|val
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
index|[
literal|3
index|]
operator|==
literal|'D'
condition|)
block|{
name|val
operator|=
name|VarModify
argument_list|(
name|val
argument_list|,
name|VarHead
argument_list|,
operator|(
name|ClientData
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|val
operator|=
name|VarModify
argument_list|(
name|val
argument_list|,
name|VarTail
argument_list|,
operator|(
name|ClientData
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * Resulting string is dynamically allocated, so 			 * tell caller to free it. 			 */
operator|*
name|freePtr
operator|=
name|TRUE
expr_stmt|;
operator|*
name|lengthPtr
operator|=
name|tstr
operator|-
name|start
operator|+
literal|1
expr_stmt|;
operator|*
name|tstr
operator|=
name|endc
expr_stmt|;
return|return
operator|(
name|val
operator|)
return|;
block|}
break|break;
block|}
block|}
block|}
if|if
condition|(
name|v
operator|==
operator|(
name|Var
operator|*
operator|)
name|NIL
condition|)
block|{
if|if
condition|(
operator|(
operator|(
operator|(
name|tstr
operator|-
name|str
operator|)
operator|==
literal|3
operator|)
operator|||
operator|(
operator|(
operator|(
operator|(
name|tstr
operator|-
name|str
operator|)
operator|==
literal|4
operator|)
operator|&&
operator|(
name|str
index|[
literal|3
index|]
operator|==
literal|'F'
operator|||
name|str
index|[
literal|3
index|]
operator|==
literal|'D'
operator|)
operator|)
operator|)
operator|)
operator|&&
operator|(
operator|(
name|ctxt
operator|==
name|VAR_CMD
operator|)
operator|||
operator|(
name|ctxt
operator|==
name|VAR_GLOBAL
operator|)
operator|)
condition|)
block|{
comment|/* 		 * If substituting a local variable in a non-local context, 		 * assume it's for dynamic source stuff. We have to handle 		 * this specially and return the longhand for the variable 		 * with the dollar sign escaped so it makes it back to the 		 * caller. Only four of the local variables are treated 		 * specially as they are the only four that will be set 		 * when dynamic sources are expanded. 		 */
switch|switch
condition|(
name|str
index|[
literal|2
index|]
condition|)
block|{
case|case
literal|'@'
case|:
case|case
literal|'%'
case|:
case|case
literal|'*'
case|:
case|case
literal|'!'
case|:
name|dynamic
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
name|tstr
operator|-
name|str
operator|)
operator|>
literal|4
operator|)
operator|&&
operator|(
name|str
index|[
literal|2
index|]
operator|==
literal|'.'
operator|)
operator|&&
name|isupper
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|str
index|[
literal|3
index|]
argument_list|)
operator|&&
operator|(
operator|(
name|ctxt
operator|==
name|VAR_CMD
operator|)
operator|||
operator|(
name|ctxt
operator|==
name|VAR_GLOBAL
operator|)
operator|)
condition|)
block|{
name|int
name|len
decl_stmt|;
name|len
operator|=
operator|(
name|tstr
operator|-
name|str
operator|)
operator|-
literal|3
expr_stmt|;
if|if
condition|(
operator|(
name|strncmp
argument_list|(
name|str
operator|+
literal|2
argument_list|,
literal|".TARGET"
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|strncmp
argument_list|(
name|str
operator|+
literal|2
argument_list|,
literal|".ARCHIVE"
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|strncmp
argument_list|(
name|str
operator|+
literal|2
argument_list|,
literal|".PREFIX"
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|strncmp
argument_list|(
name|str
operator|+
literal|2
argument_list|,
literal|".MEMBER"
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|dynamic
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|haveModifier
condition|)
block|{
comment|/* 		 * No modifiers -- have specification length so we can return 		 * now. 		 */
operator|*
name|lengthPtr
operator|=
name|tstr
operator|-
name|start
operator|+
literal|1
expr_stmt|;
operator|*
name|tstr
operator|=
name|endc
expr_stmt|;
if|if
condition|(
name|dynamic
condition|)
block|{
name|str
operator|=
name|emalloc
argument_list|(
operator|*
name|lengthPtr
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|str
argument_list|,
name|start
argument_list|,
operator|*
name|lengthPtr
argument_list|)
expr_stmt|;
name|str
index|[
operator|*
name|lengthPtr
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|freePtr
operator|=
name|TRUE
expr_stmt|;
return|return
operator|(
name|str
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|err
condition|?
name|var_Error
else|:
name|varNoError
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/* 		 * Still need to get to the end of the variable specification, 		 * so kludge up a Var structure for the modifications 		 */
name|v
operator|=
operator|(
name|Var
operator|*
operator|)
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Var
argument_list|)
argument_list|)
expr_stmt|;
name|v
operator|->
name|name
operator|=
operator|&
name|str
index|[
literal|1
index|]
expr_stmt|;
name|v
operator|->
name|val
operator|=
name|Buf_Init
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|v
operator|->
name|flags
operator|=
name|VAR_JUNK
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|v
operator|->
name|flags
operator|&
name|VAR_IN_USE
condition|)
block|{
name|Fatal
argument_list|(
literal|"Variable %s is recursive."
argument_list|,
name|v
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
else|else
block|{
name|v
operator|->
name|flags
operator||=
name|VAR_IN_USE
expr_stmt|;
block|}
comment|/*      * Before doing any modification, we have to make sure the value      * has been fully expanded. If it looks like recursion might be      * necessary (there's a dollar sign somewhere in the variable's value)      * we just call Var_Subst to do any other substitutions that are      * necessary. Note that the value returned by Var_Subst will have      * been dynamically-allocated, so it will need freeing when we      * return.      */
name|str
operator|=
operator|(
name|char
operator|*
operator|)
name|Buf_GetAll
argument_list|(
name|v
operator|->
name|val
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|str
argument_list|,
literal|'$'
argument_list|)
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
name|str
operator|=
name|Var_Subst
argument_list|(
name|NULL
argument_list|,
name|str
argument_list|,
name|ctxt
argument_list|,
name|err
argument_list|)
expr_stmt|;
operator|*
name|freePtr
operator|=
name|TRUE
expr_stmt|;
block|}
name|v
operator|->
name|flags
operator|&=
operator|~
name|VAR_IN_USE
expr_stmt|;
comment|/*      * Now we need to apply any modifiers the user wants applied.      * These are:      *  	  :M<pattern>	words which match the given<pattern>.      *<pattern> is of the standard file      *  	  	    	wildcarding form.      *  	  :S<d><pat1><d><pat2><d>[g]      *  	  	    	Substitute<pat2> for<pat1> in the value      *  	  :H	    	Substitute the head of each word      *  	  :T	    	Substitute the tail of each word      *  	  :E	    	Substitute the extension (minus '.') of      *  	  	    	each word      *  	  :R	    	Substitute the root of each word      *  	  	    	(pathname minus the suffix).      *	    	  :lhs=rhs  	Like :S, but the rhs goes to the end of      *	    	    	    	the invocation.      */
if|if
condition|(
operator|(
name|str
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
operator|&&
name|haveModifier
condition|)
block|{
comment|/* 	 * Skip initial colon while putting it back. 	 */
operator|*
name|tstr
operator|++
operator|=
literal|':'
expr_stmt|;
while|while
condition|(
operator|*
name|tstr
operator|!=
name|endc
condition|)
block|{
name|char
modifier|*
name|newStr
decl_stmt|;
comment|/* New value to return */
name|char
name|termc
decl_stmt|;
comment|/* Character which terminated scan */
if|if
condition|(
name|DEBUG
argument_list|(
name|VAR
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Applying :%c to \"%s\"\n"
argument_list|,
operator|*
name|tstr
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
operator|*
name|tstr
condition|)
block|{
case|case
literal|'N'
case|:
case|case
literal|'M'
case|:
block|{
name|char
modifier|*
name|pattern
decl_stmt|;
name|char
modifier|*
name|cp2
decl_stmt|;
name|Boolean
name|copy
decl_stmt|;
name|copy
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|tstr
operator|+
literal|1
init|;
operator|*
name|cp
operator|!=
literal|'\0'
operator|&&
operator|*
name|cp
operator|!=
literal|':'
operator|&&
operator|*
name|cp
operator|!=
name|endc
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\\'
operator|&&
operator|(
name|cp
index|[
literal|1
index|]
operator|==
literal|':'
operator|||
name|cp
index|[
literal|1
index|]
operator|==
name|endc
operator|)
condition|)
block|{
name|copy
operator|=
name|TRUE
expr_stmt|;
name|cp
operator|++
expr_stmt|;
block|}
block|}
name|termc
operator|=
operator|*
name|cp
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|copy
condition|)
block|{
comment|/* 			 * Need to compress the \:'s out of the pattern, so 			 * allocate enough room to hold the uncompressed 			 * pattern (note that cp started at tstr+1, so 			 * cp - tstr takes the null byte into account) and 			 * compress the pattern into the space. 			 */
name|pattern
operator|=
name|emalloc
argument_list|(
name|cp
operator|-
name|tstr
argument_list|)
expr_stmt|;
for|for
control|(
name|cp2
operator|=
name|pattern
operator|,
name|cp
operator|=
name|tstr
operator|+
literal|1
init|;
operator|*
name|cp
operator|!=
literal|'\0'
condition|;
name|cp
operator|++
operator|,
name|cp2
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|cp
operator|==
literal|'\\'
operator|)
operator|&&
operator|(
name|cp
index|[
literal|1
index|]
operator|==
literal|':'
operator|||
name|cp
index|[
literal|1
index|]
operator|==
name|endc
operator|)
condition|)
block|{
name|cp
operator|++
expr_stmt|;
block|}
operator|*
name|cp2
operator|=
operator|*
name|cp
expr_stmt|;
block|}
operator|*
name|cp2
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
name|pattern
operator|=
operator|&
name|tstr
index|[
literal|1
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|tstr
operator|==
literal|'M'
operator|||
operator|*
name|tstr
operator|==
literal|'m'
condition|)
block|{
name|newStr
operator|=
name|VarModify
argument_list|(
name|str
argument_list|,
name|VarMatch
argument_list|,
operator|(
name|ClientData
operator|)
name|pattern
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|newStr
operator|=
name|VarModify
argument_list|(
name|str
argument_list|,
name|VarNoMatch
argument_list|,
operator|(
name|ClientData
operator|)
name|pattern
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|copy
condition|)
block|{
name|free
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
literal|'S'
case|:
block|{
name|VarPattern
name|pattern
decl_stmt|;
specifier|register
name|char
name|delim
decl_stmt|;
name|Buffer
name|buf
decl_stmt|;
comment|/* Buffer for patterns */
name|pattern
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|delim
operator|=
name|tstr
index|[
literal|1
index|]
expr_stmt|;
name|tstr
operator|+=
literal|2
expr_stmt|;
comment|/* 		     * If pattern begins with '^', it is anchored to the 		     * start of the word -- skip over it and flag pattern. 		     */
if|if
condition|(
operator|*
name|tstr
operator|==
literal|'^'
condition|)
block|{
name|pattern
operator|.
name|flags
operator||=
name|VAR_MATCH_START
expr_stmt|;
name|tstr
operator|+=
literal|1
expr_stmt|;
block|}
name|buf
operator|=
name|Buf_Init
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* 		     * Pass through the lhs looking for 1) escaped delimiters, 		     * '$'s and backslashes (place the escaped character in 		     * uninterpreted) and 2) unescaped $'s that aren't before 		     * the delimiter (expand the variable substitution). 		     * The result is left in the Buffer buf. 		     */
for|for
control|(
name|cp
operator|=
name|tstr
init|;
operator|*
name|cp
operator|!=
literal|'\0'
operator|&&
operator|*
name|cp
operator|!=
name|delim
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|cp
operator|==
literal|'\\'
operator|)
operator|&&
operator|(
operator|(
name|cp
index|[
literal|1
index|]
operator|==
name|delim
operator|)
operator|||
operator|(
name|cp
index|[
literal|1
index|]
operator|==
literal|'$'
operator|)
operator|||
operator|(
name|cp
index|[
literal|1
index|]
operator|==
literal|'\\'
operator|)
operator|)
condition|)
block|{
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
operator|(
name|Byte
operator|)
name|cp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|cp
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|cp
operator|==
literal|'$'
condition|)
block|{
if|if
condition|(
name|cp
index|[
literal|1
index|]
operator|!=
name|delim
condition|)
block|{
comment|/* 				 * If unescaped dollar sign not before the 				 * delimiter, assume it's a variable 				 * substitution and recurse. 				 */
name|char
modifier|*
name|cp2
decl_stmt|;
name|int
name|len
decl_stmt|;
name|Boolean
name|freeIt
decl_stmt|;
name|cp2
operator|=
name|Var_Parse
argument_list|(
name|cp
argument_list|,
name|ctxt
argument_list|,
name|err
argument_list|,
operator|&
name|len
argument_list|,
operator|&
name|freeIt
argument_list|)
expr_stmt|;
name|Buf_AddBytes
argument_list|(
name|buf
argument_list|,
name|strlen
argument_list|(
name|cp2
argument_list|)
argument_list|,
operator|(
name|Byte
operator|*
operator|)
name|cp2
argument_list|)
expr_stmt|;
if|if
condition|(
name|freeIt
condition|)
block|{
name|free
argument_list|(
name|cp2
argument_list|)
expr_stmt|;
block|}
name|cp
operator|+=
name|len
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * Unescaped $ at end of pattern => anchor 				 * pattern at end. 				 */
name|pattern
operator|.
name|flags
operator||=
name|VAR_MATCH_END
expr_stmt|;
block|}
block|}
else|else
block|{
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
operator|(
name|Byte
operator|)
operator|*
name|cp
argument_list|)
expr_stmt|;
block|}
block|}
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
operator|(
name|Byte
operator|)
literal|'\0'
argument_list|)
expr_stmt|;
comment|/* 		     * If lhs didn't end with the delimiter, complain and 		     * return NULL 		     */
if|if
condition|(
operator|*
name|cp
operator|!=
name|delim
condition|)
block|{
operator|*
name|lengthPtr
operator|=
name|cp
operator|-
name|start
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|freePtr
condition|)
block|{
name|free
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
name|Buf_Destroy
argument_list|(
name|buf
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|Error
argument_list|(
literal|"Unclosed substitution for %s (%c missing)"
argument_list|,
name|v
operator|->
name|name
argument_list|,
name|delim
argument_list|)
expr_stmt|;
return|return
operator|(
name|var_Error
operator|)
return|;
block|}
comment|/* 		     * Fetch pattern and destroy buffer, but preserve the data 		     * in it, since that's our lhs. Note that Buf_GetAll 		     * will return the actual number of bytes, which includes 		     * the null byte, so we have to decrement the length by 		     * one. 		     */
name|pattern
operator|.
name|lhs
operator|=
operator|(
name|char
operator|*
operator|)
name|Buf_GetAll
argument_list|(
name|buf
argument_list|,
operator|&
name|pattern
operator|.
name|leftLen
argument_list|)
expr_stmt|;
name|pattern
operator|.
name|leftLen
operator|--
expr_stmt|;
name|Buf_Destroy
argument_list|(
name|buf
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* 		     * Now comes the replacement string. Three things need to 		     * be done here: 1) need to compress escaped delimiters and 		     * ampersands and 2) need to replace unescaped ampersands 		     * with the l.h.s. (since this isn't regexp, we can do 		     * it right here) and 3) expand any variable substitutions. 		     */
name|buf
operator|=
name|Buf_Init
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|tstr
operator|=
name|cp
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|tstr
init|;
operator|*
name|cp
operator|!=
literal|'\0'
operator|&&
operator|*
name|cp
operator|!=
name|delim
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|cp
operator|==
literal|'\\'
operator|)
operator|&&
operator|(
operator|(
name|cp
index|[
literal|1
index|]
operator|==
name|delim
operator|)
operator|||
operator|(
name|cp
index|[
literal|1
index|]
operator|==
literal|'&'
operator|)
operator|||
operator|(
name|cp
index|[
literal|1
index|]
operator|==
literal|'\\'
operator|)
operator|||
operator|(
name|cp
index|[
literal|1
index|]
operator|==
literal|'$'
operator|)
operator|)
condition|)
block|{
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
operator|(
name|Byte
operator|)
name|cp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|cp
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|cp
operator|==
literal|'$'
operator|)
operator|&&
operator|(
name|cp
index|[
literal|1
index|]
operator|!=
name|delim
operator|)
condition|)
block|{
name|char
modifier|*
name|cp2
decl_stmt|;
name|int
name|len
decl_stmt|;
name|Boolean
name|freeIt
decl_stmt|;
name|cp2
operator|=
name|Var_Parse
argument_list|(
name|cp
argument_list|,
name|ctxt
argument_list|,
name|err
argument_list|,
operator|&
name|len
argument_list|,
operator|&
name|freeIt
argument_list|)
expr_stmt|;
name|Buf_AddBytes
argument_list|(
name|buf
argument_list|,
name|strlen
argument_list|(
name|cp2
argument_list|)
argument_list|,
operator|(
name|Byte
operator|*
operator|)
name|cp2
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|len
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|freeIt
condition|)
block|{
name|free
argument_list|(
name|cp2
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|cp
operator|==
literal|'&'
condition|)
block|{
name|Buf_AddBytes
argument_list|(
name|buf
argument_list|,
name|pattern
operator|.
name|leftLen
argument_list|,
operator|(
name|Byte
operator|*
operator|)
name|pattern
operator|.
name|lhs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
operator|(
name|Byte
operator|)
operator|*
name|cp
argument_list|)
expr_stmt|;
block|}
block|}
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
operator|(
name|Byte
operator|)
literal|'\0'
argument_list|)
expr_stmt|;
comment|/* 		     * If didn't end in delimiter character, complain 		     */
if|if
condition|(
operator|*
name|cp
operator|!=
name|delim
condition|)
block|{
operator|*
name|lengthPtr
operator|=
name|cp
operator|-
name|start
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|freePtr
condition|)
block|{
name|free
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
name|Buf_Destroy
argument_list|(
name|buf
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|Error
argument_list|(
literal|"Unclosed substitution for %s (%c missing)"
argument_list|,
name|v
operator|->
name|name
argument_list|,
name|delim
argument_list|)
expr_stmt|;
return|return
operator|(
name|var_Error
operator|)
return|;
block|}
name|pattern
operator|.
name|rhs
operator|=
operator|(
name|char
operator|*
operator|)
name|Buf_GetAll
argument_list|(
name|buf
argument_list|,
operator|&
name|pattern
operator|.
name|rightLen
argument_list|)
expr_stmt|;
name|pattern
operator|.
name|rightLen
operator|--
expr_stmt|;
name|Buf_Destroy
argument_list|(
name|buf
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* 		     * Check for global substitution. If 'g' after the final 		     * delimiter, substitution is global and is marked that 		     * way. 		     */
name|cp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'g'
condition|)
block|{
name|pattern
operator|.
name|flags
operator||=
name|VAR_SUB_GLOBAL
expr_stmt|;
name|cp
operator|++
expr_stmt|;
block|}
name|termc
operator|=
operator|*
name|cp
expr_stmt|;
name|newStr
operator|=
name|VarModify
argument_list|(
name|str
argument_list|,
name|VarSubstitute
argument_list|,
operator|(
name|ClientData
operator|)
operator|&
name|pattern
argument_list|)
expr_stmt|;
comment|/* 		     * Free the two strings. 		     */
name|free
argument_list|(
name|pattern
operator|.
name|lhs
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pattern
operator|.
name|rhs
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|'T'
case|:
if|if
condition|(
name|tstr
index|[
literal|1
index|]
operator|==
name|endc
operator|||
name|tstr
index|[
literal|1
index|]
operator|==
literal|':'
condition|)
block|{
name|newStr
operator|=
name|VarModify
argument_list|(
name|str
argument_list|,
name|VarTail
argument_list|,
operator|(
name|ClientData
operator|)
literal|0
argument_list|)
expr_stmt|;
name|cp
operator|=
name|tstr
operator|+
literal|1
expr_stmt|;
name|termc
operator|=
operator|*
name|cp
expr_stmt|;
break|break;
block|}
comment|/*FALLTHRU*/
case|case
literal|'H'
case|:
if|if
condition|(
name|tstr
index|[
literal|1
index|]
operator|==
name|endc
operator|||
name|tstr
index|[
literal|1
index|]
operator|==
literal|':'
condition|)
block|{
name|newStr
operator|=
name|VarModify
argument_list|(
name|str
argument_list|,
name|VarHead
argument_list|,
operator|(
name|ClientData
operator|)
literal|0
argument_list|)
expr_stmt|;
name|cp
operator|=
name|tstr
operator|+
literal|1
expr_stmt|;
name|termc
operator|=
operator|*
name|cp
expr_stmt|;
break|break;
block|}
comment|/*FALLTHRU*/
case|case
literal|'E'
case|:
if|if
condition|(
name|tstr
index|[
literal|1
index|]
operator|==
name|endc
operator|||
name|tstr
index|[
literal|1
index|]
operator|==
literal|':'
condition|)
block|{
name|newStr
operator|=
name|VarModify
argument_list|(
name|str
argument_list|,
name|VarSuffix
argument_list|,
operator|(
name|ClientData
operator|)
literal|0
argument_list|)
expr_stmt|;
name|cp
operator|=
name|tstr
operator|+
literal|1
expr_stmt|;
name|termc
operator|=
operator|*
name|cp
expr_stmt|;
break|break;
block|}
comment|/*FALLTHRU*/
case|case
literal|'R'
case|:
if|if
condition|(
name|tstr
index|[
literal|1
index|]
operator|==
name|endc
operator|||
name|tstr
index|[
literal|1
index|]
operator|==
literal|':'
condition|)
block|{
name|newStr
operator|=
name|VarModify
argument_list|(
name|str
argument_list|,
name|VarRoot
argument_list|,
operator|(
name|ClientData
operator|)
literal|0
argument_list|)
expr_stmt|;
name|cp
operator|=
name|tstr
operator|+
literal|1
expr_stmt|;
name|termc
operator|=
operator|*
name|cp
expr_stmt|;
break|break;
block|}
comment|/*FALLTHRU*/
ifdef|#
directive|ifdef
name|SUNSHCMD
case|case
literal|'s'
case|:
if|if
condition|(
name|tstr
index|[
literal|1
index|]
operator|==
literal|'h'
operator|&&
operator|(
name|tstr
index|[
literal|2
index|]
operator|==
name|endc
operator|||
name|tstr
index|[
literal|2
index|]
operator|==
literal|':'
operator|)
condition|)
block|{
name|char
modifier|*
name|err
decl_stmt|;
name|newStr
operator|=
name|Cmd_Exec
argument_list|(
name|str
argument_list|,
operator|&
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|Error
argument_list|(
name|err
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|cp
operator|=
name|tstr
operator|+
literal|2
expr_stmt|;
name|termc
operator|=
operator|*
name|cp
expr_stmt|;
break|break;
block|}
comment|/*FALLTHRU*/
endif|#
directive|endif
default|default:
block|{
ifdef|#
directive|ifdef
name|SYSVVARSUB
comment|/* 		     * This can either be a bogus modifier or a System-V 		     * substitution command. 		     */
name|VarPattern
name|pattern
decl_stmt|;
name|Boolean
name|eqFound
decl_stmt|;
name|pattern
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|eqFound
operator|=
name|FALSE
expr_stmt|;
comment|/* 		     * First we make a pass through the string trying 		     * to verify it is a SYSV-make-style translation: 		     * it must be:<string1>=<string2>) 		     */
name|cp
operator|=
name|tstr
expr_stmt|;
name|cnt
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|!=
literal|'\0'
operator|&&
name|cnt
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'='
condition|)
block|{
name|eqFound
operator|=
name|TRUE
expr_stmt|;
comment|/* continue looking for endc */
block|}
elseif|else
if|if
condition|(
operator|*
name|cp
operator|==
name|endc
condition|)
name|cnt
operator|--
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|cp
operator|==
name|startc
condition|)
name|cnt
operator|++
expr_stmt|;
if|if
condition|(
name|cnt
condition|)
name|cp
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|cp
operator|==
name|endc
operator|&&
name|eqFound
condition|)
block|{
comment|/* 			 * Now we break this sucker into the lhs and 			 * rhs. We must null terminate them of course. 			 */
for|for
control|(
name|cp
operator|=
name|tstr
init|;
operator|*
name|cp
operator|!=
literal|'='
condition|;
name|cp
operator|++
control|)
continue|continue;
name|pattern
operator|.
name|lhs
operator|=
name|tstr
expr_stmt|;
name|pattern
operator|.
name|leftLen
operator|=
name|cp
operator|-
name|tstr
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|pattern
operator|.
name|rhs
operator|=
name|cp
expr_stmt|;
name|cnt
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|cnt
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
name|endc
condition|)
name|cnt
operator|--
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|cp
operator|==
name|startc
condition|)
name|cnt
operator|++
expr_stmt|;
if|if
condition|(
name|cnt
condition|)
name|cp
operator|++
expr_stmt|;
block|}
name|pattern
operator|.
name|rightLen
operator|=
name|cp
operator|-
name|pattern
operator|.
name|rhs
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
comment|/* 			 * SYSV modifications happen through the whole 			 * string. Note the pattern is anchored at the end. 			 */
name|newStr
operator|=
name|VarModify
argument_list|(
name|str
argument_list|,
name|VarSYSVMatch
argument_list|,
operator|(
name|ClientData
operator|)
operator|&
name|pattern
argument_list|)
expr_stmt|;
comment|/* 			 * Restore the nulled characters 			 */
name|pattern
operator|.
name|lhs
index|[
name|pattern
operator|.
name|leftLen
index|]
operator|=
literal|'='
expr_stmt|;
name|pattern
operator|.
name|rhs
index|[
name|pattern
operator|.
name|rightLen
index|]
operator|=
name|endc
expr_stmt|;
name|termc
operator|=
name|endc
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|Error
argument_list|(
literal|"Unknown modifier '%c'\n"
argument_list|,
operator|*
name|tstr
argument_list|)
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|tstr
operator|+
literal|1
init|;
operator|*
name|cp
operator|!=
literal|':'
operator|&&
operator|*
name|cp
operator|!=
name|endc
operator|&&
operator|*
name|cp
operator|!=
literal|'\0'
condition|;
name|cp
operator|++
control|)
continue|continue;
name|termc
operator|=
operator|*
name|cp
expr_stmt|;
name|newStr
operator|=
name|var_Error
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|DEBUG
argument_list|(
name|VAR
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Result is \"%s\"\n"
argument_list|,
name|newStr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|freePtr
condition|)
block|{
name|free
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
name|str
operator|=
name|newStr
expr_stmt|;
if|if
condition|(
name|str
operator|!=
name|var_Error
condition|)
block|{
operator|*
name|freePtr
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
operator|*
name|freePtr
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|termc
operator|==
literal|'\0'
condition|)
block|{
name|Error
argument_list|(
literal|"Unclosed variable specification for %s"
argument_list|,
name|v
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|termc
operator|==
literal|':'
condition|)
block|{
operator|*
name|cp
operator|++
operator|=
name|termc
expr_stmt|;
block|}
else|else
block|{
operator|*
name|cp
operator|=
name|termc
expr_stmt|;
block|}
name|tstr
operator|=
name|cp
expr_stmt|;
block|}
operator|*
name|lengthPtr
operator|=
name|tstr
operator|-
name|start
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
operator|*
name|lengthPtr
operator|=
name|tstr
operator|-
name|start
operator|+
literal|1
expr_stmt|;
operator|*
name|tstr
operator|=
name|endc
expr_stmt|;
block|}
if|if
condition|(
name|v
operator|->
name|flags
operator|&
name|VAR_FROM_ENV
condition|)
block|{
name|Boolean
name|destroy
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
name|str
operator|!=
operator|(
name|char
operator|*
operator|)
name|Buf_GetAll
argument_list|(
name|v
operator|->
name|val
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
condition|)
block|{
name|destroy
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
comment|/* 	     * Returning the value unmodified, so tell the caller to free 	     * the thing. 	     */
operator|*
name|freePtr
operator|=
name|TRUE
expr_stmt|;
block|}
name|Buf_Destroy
argument_list|(
name|v
operator|->
name|val
argument_list|,
name|destroy
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|Address
operator|)
name|v
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|v
operator|->
name|flags
operator|&
name|VAR_JUNK
condition|)
block|{
comment|/* 	 * Perform any free'ing needed and set *freePtr to FALSE so the caller 	 * doesn't try to free a static pointer. 	 */
if|if
condition|(
operator|*
name|freePtr
condition|)
block|{
name|free
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
operator|*
name|freePtr
operator|=
name|FALSE
expr_stmt|;
name|Buf_Destroy
argument_list|(
name|v
operator|->
name|val
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|Address
operator|)
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|dynamic
condition|)
block|{
name|str
operator|=
name|emalloc
argument_list|(
operator|*
name|lengthPtr
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|str
argument_list|,
name|start
argument_list|,
operator|*
name|lengthPtr
argument_list|)
expr_stmt|;
name|str
index|[
operator|*
name|lengthPtr
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|freePtr
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|str
operator|=
name|var_Error
expr_stmt|;
block|}
block|}
return|return
operator|(
name|str
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Var_Subst  --  *	Substitute for all variables in the given string in the given context  *	If undefErr is TRUE, Parse_Error will be called when an undefined  *	variable is encountered.  *  * Results:  *	The resulting string.  *  * Side Effects:  *	None. The old string must be freed by the caller  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|char
modifier|*
name|Var_Subst
parameter_list|(
name|var
parameter_list|,
name|str
parameter_list|,
name|ctxt
parameter_list|,
name|undefErr
parameter_list|)
name|char
modifier|*
name|var
decl_stmt|;
comment|/* Named variable || NULL for all */
name|char
modifier|*
name|str
decl_stmt|;
comment|/* the string in which to substitute */
name|GNode
modifier|*
name|ctxt
decl_stmt|;
comment|/* the context wherein to find variables */
name|Boolean
name|undefErr
decl_stmt|;
comment|/* TRUE if undefineds are an error */
block|{
name|Buffer
name|buf
decl_stmt|;
comment|/* Buffer for forming things */
name|char
modifier|*
name|val
decl_stmt|;
comment|/* Value to substitute for a variable */
name|int
name|length
decl_stmt|;
comment|/* Length of the variable invocation */
name|Boolean
name|doFree
decl_stmt|;
comment|/* Set true if val should be freed */
specifier|static
name|Boolean
name|errorReported
decl_stmt|;
comment|/* Set true if an error has already 				     * been reported to prevent a plethora 				     * of messages when recursing */
name|buf
operator|=
name|Buf_Init
argument_list|(
name|MAKE_BSIZE
argument_list|)
expr_stmt|;
name|errorReported
operator|=
name|FALSE
expr_stmt|;
while|while
condition|(
operator|*
name|str
condition|)
block|{
if|if
condition|(
name|var
operator|==
name|NULL
operator|&&
operator|(
operator|*
name|str
operator|==
literal|'$'
operator|)
operator|&&
operator|(
name|str
index|[
literal|1
index|]
operator|==
literal|'$'
operator|)
condition|)
block|{
comment|/* 	     * A dollar sign may be escaped either with another dollar sign. 	     * In such a case, we skip over the escape character and store the 	     * dollar sign into the buffer directly. 	     */
name|str
operator|++
expr_stmt|;
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
operator|(
name|Byte
operator|)
operator|*
name|str
argument_list|)
expr_stmt|;
name|str
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|str
operator|!=
literal|'$'
condition|)
block|{
comment|/* 	     * Skip as many characters as possible -- either to the end of 	     * the string or to the next dollar sign (variable invocation). 	     */
name|char
modifier|*
name|cp
decl_stmt|;
for|for
control|(
name|cp
operator|=
name|str
operator|++
init|;
operator|*
name|str
operator|!=
literal|'$'
operator|&&
operator|*
name|str
operator|!=
literal|'\0'
condition|;
name|str
operator|++
control|)
continue|continue;
name|Buf_AddBytes
argument_list|(
name|buf
argument_list|,
name|str
operator|-
name|cp
argument_list|,
operator|(
name|Byte
operator|*
operator|)
name|cp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|var
operator|!=
name|NULL
condition|)
block|{
name|int
name|expand
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|str
index|[
literal|1
index|]
operator|!=
literal|'('
operator|&&
name|str
index|[
literal|1
index|]
operator|!=
literal|'{'
condition|)
block|{
if|if
condition|(
name|str
index|[
literal|1
index|]
operator|!=
operator|*
name|var
condition|)
block|{
name|Buf_AddBytes
argument_list|(
name|buf
argument_list|,
literal|2
argument_list|,
operator|(
name|Byte
operator|*
operator|)
name|str
argument_list|)
expr_stmt|;
name|str
operator|+=
literal|2
expr_stmt|;
name|expand
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
name|expand
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
else|else
block|{
name|char
modifier|*
name|p
decl_stmt|;
comment|/* 			 * Scan up to the end of the variable name. 			 */
for|for
control|(
name|p
operator|=
operator|&
name|str
index|[
literal|2
index|]
init|;
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|':'
operator|&&
operator|*
name|p
operator|!=
literal|')'
operator|&&
operator|*
name|p
operator|!=
literal|'}'
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|'$'
condition|)
break|break;
comment|/* 			 * A variable inside the variable. We cannot expand 			 * the external variable yet, so we try again with 			 * the nested one 			 */
if|if
condition|(
operator|*
name|p
operator|==
literal|'$'
condition|)
block|{
name|Buf_AddBytes
argument_list|(
name|buf
argument_list|,
name|p
operator|-
name|str
argument_list|,
operator|(
name|Byte
operator|*
operator|)
name|str
argument_list|)
expr_stmt|;
name|str
operator|=
name|p
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|var
argument_list|,
name|str
operator|+
literal|2
argument_list|,
name|p
operator|-
name|str
operator|-
literal|2
argument_list|)
operator|!=
literal|0
operator|||
name|var
index|[
name|p
operator|-
name|str
operator|-
literal|2
index|]
operator|!=
literal|'\0'
condition|)
block|{
comment|/* 			     * Not the variable we want to expand, scan 			     * until the next variable 			     */
for|for
control|(
init|;
operator|*
name|p
operator|!=
literal|'$'
operator|&&
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
continue|continue;
name|Buf_AddBytes
argument_list|(
name|buf
argument_list|,
name|p
operator|-
name|str
argument_list|,
operator|(
name|Byte
operator|*
operator|)
name|str
argument_list|)
expr_stmt|;
name|str
operator|=
name|p
expr_stmt|;
name|expand
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
name|expand
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|expand
condition|)
continue|continue;
block|}
name|val
operator|=
name|Var_Parse
argument_list|(
name|str
argument_list|,
name|ctxt
argument_list|,
name|undefErr
argument_list|,
operator|&
name|length
argument_list|,
operator|&
name|doFree
argument_list|)
expr_stmt|;
comment|/* 	     * When we come down here, val should either point to the 	     * value of this variable, suitably modified, or be NULL. 	     * Length should be the total length of the potential 	     * variable invocation (from $ to end character...) 	     */
if|if
condition|(
name|val
operator|==
name|var_Error
operator|||
name|val
operator|==
name|varNoError
condition|)
block|{
comment|/* 		 * If performing old-time variable substitution, skip over 		 * the variable and continue with the substitution. Otherwise, 		 * store the dollar sign and advance str so we continue with 		 * the string... 		 */
if|if
condition|(
name|oldVars
condition|)
block|{
name|str
operator|+=
name|length
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|undefErr
condition|)
block|{
comment|/* 		     * If variable is undefined, complain and skip the 		     * variable. The complaint will stop us from doing anything 		     * when the file is parsed. 		     */
if|if
condition|(
operator|!
name|errorReported
condition|)
block|{
name|Parse_Error
argument_list|(
name|PARSE_FATAL
argument_list|,
literal|"Undefined variable \"%.*s\""
argument_list|,
name|length
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
name|str
operator|+=
name|length
expr_stmt|;
name|errorReported
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
operator|(
name|Byte
operator|)
operator|*
name|str
argument_list|)
expr_stmt|;
name|str
operator|+=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * We've now got a variable structure to store in. But first, 		 * advance the string pointer. 		 */
name|str
operator|+=
name|length
expr_stmt|;
comment|/* 		 * Copy all the characters from the variable value straight 		 * into the new string. 		 */
name|Buf_AddBytes
argument_list|(
name|buf
argument_list|,
name|strlen
argument_list|(
name|val
argument_list|)
argument_list|,
operator|(
name|Byte
operator|*
operator|)
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|doFree
condition|)
block|{
name|free
argument_list|(
operator|(
name|Address
operator|)
name|val
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
name|str
operator|=
operator|(
name|char
operator|*
operator|)
name|Buf_GetAll
argument_list|(
name|buf
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|Buf_Destroy
argument_list|(
name|buf
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
operator|(
name|str
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Var_GetTail --  *	Return the tail from each of a list of words. Used to set the  *	System V local variables.  *  * Results:  *	The resulting string.  *  * Side Effects:  *	None.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|char
modifier|*
name|Var_GetTail
parameter_list|(
name|file
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
comment|/* Filename to modify */
block|{
return|return
operator|(
name|VarModify
argument_list|(
name|file
argument_list|,
name|VarTail
argument_list|,
operator|(
name|ClientData
operator|)
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Var_GetHead --  *	Find the leading components of a (list of) filename(s).  *	XXX: VarHead does not replace foo by ., as (sun) System V make  *	does.  *  * Results:  *	The leading components.  *  * Side Effects:  *	None.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|char
modifier|*
name|Var_GetHead
parameter_list|(
name|file
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
comment|/* Filename to manipulate */
block|{
return|return
operator|(
name|VarModify
argument_list|(
name|file
argument_list|,
name|VarHead
argument_list|,
operator|(
name|ClientData
operator|)
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Var_Init --  *	Initialize the module  *  * Results:  *	None  *  * Side Effects:  *	The VAR_CMD and VAR_GLOBAL contexts are created  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Var_Init
parameter_list|()
block|{
name|VAR_GLOBAL
operator|=
name|Targ_NewGN
argument_list|(
literal|"Global"
argument_list|)
expr_stmt|;
name|VAR_CMD
operator|=
name|Targ_NewGN
argument_list|(
literal|"Command"
argument_list|)
expr_stmt|;
name|allVars
operator|=
name|Lst_Init
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|Var_End
parameter_list|()
block|{
name|Lst_Destroy
argument_list|(
name|allVars
argument_list|,
name|VarDelete
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************** PRINT DEBUGGING INFO *****************/
end_comment

begin_function
specifier|static
name|int
name|VarPrintVar
parameter_list|(
name|vp
parameter_list|,
name|dummy
parameter_list|)
name|ClientData
name|vp
decl_stmt|;
name|ClientData
name|dummy
decl_stmt|;
block|{
name|Var
modifier|*
name|v
init|=
operator|(
name|Var
operator|*
operator|)
name|vp
decl_stmt|;
name|printf
argument_list|(
literal|"%-16s = %s\n"
argument_list|,
name|v
operator|->
name|name
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Buf_GetAll
argument_list|(
name|v
operator|->
name|val
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|dummy
condition|?
literal|0
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Var_Dump --  *	print all variables in a context  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Var_Dump
parameter_list|(
name|ctxt
parameter_list|)
name|GNode
modifier|*
name|ctxt
decl_stmt|;
block|{
name|Lst_ForEach
argument_list|(
name|ctxt
operator|->
name|context
argument_list|,
name|VarPrintVar
argument_list|,
operator|(
name|ClientData
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

