begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1988, 1989, 1990, 1993  *	The Regents of the University of California.  All rights reserved.  * Copyright (c) 1989 by Berkeley Softworks  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Adam de Boor.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * @(#)arch.c	8.2 (Berkeley) 1/2/94  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*-  * arch.c --  *	Functions to manipulate libraries, archives and their members.  *  *	Once again, cacheing/hashing comes into play in the manipulation  * of archives. The first time an archive is referenced, all of its members'  * headers are read and hashed and the archive closed again. All hashed  * archives are kept on a list which is searched each time an archive member  * is referenced.  *  * The interface to this module is:  *	Arch_ParseArchive	Given an archive specification, return a list  *				of GNode's, one for each member in the spec.  *				FAILURE is returned if the specification is  *				invalid for some reason.  *  *	Arch_Touch		Alter the modification time of the archive  *				member described by the given node to be  *				the current time.  *  *	Arch_TouchLib		Update the modification time of the library  *				described by the given node. This is special  *				because it also updates the modification time  *				of the library's table of contents.  *  *	Arch_MTime		Find the modification time of a member of  *				an archive *in the archive*. The time is also  *				placed in the member's GNode. Returns the  *				modification time.  *  *	Arch_MemTime		Find the modification time of a member of  *				an archive. Called when the member doesn't  *				already exist. Looks in the archive for the  *				modification time. Returns the modification  *				time.  *  *	Arch_FindLib		Search for a library along a path. The  *				library name in the GNode should be in  *				-l<name> format.  *  *	Arch_LibOODate		Special function to decide if a library node  *				is out-of-date.  *  *	Arch_Init		Initialize this module.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<ar.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<regex.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<utime.h>
end_include

begin_include
include|#
directive|include
file|"arch.h"
end_include

begin_include
include|#
directive|include
file|"buf.h"
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"dir.h"
end_include

begin_include
include|#
directive|include
file|"globals.h"
end_include

begin_include
include|#
directive|include
file|"GNode.h"
end_include

begin_include
include|#
directive|include
file|"hash.h"
end_include

begin_include
include|#
directive|include
file|"make.h"
end_include

begin_include
include|#
directive|include
file|"targ.h"
end_include

begin_include
include|#
directive|include
file|"util.h"
end_include

begin_include
include|#
directive|include
file|"var.h"
end_include

begin_comment
comment|/* Lst of archives we've already examined */
end_comment

begin_decl_stmt
specifier|static
name|Lst
name|archives
init|=
name|Lst_Initializer
argument_list|(
name|archives
argument_list|)
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
name|Arch
block|{
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Name of archive */
comment|/* 	 * All the members of the archive described 	 * by<name, struct ar_hdr *> key/value pairs 	 */
name|Hash_Table
name|members
decl_stmt|;
name|char
modifier|*
name|fnametab
decl_stmt|;
comment|/* Extended name table strings */
name|size_t
name|fnamesize
decl_stmt|;
comment|/* Size of the string table */
block|}
name|Arch
typedef|;
end_typedef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__svr4__
argument_list|)
operator|||
name|defined
argument_list|(
name|__SVR4
argument_list|)
operator|||
name|defined
argument_list|(
name|__ELF__
argument_list|)
end_if

begin_define
define|#
directive|define
name|SVR4ARCHIVES
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Arch_ParseArchive --  *	Parse the archive specification in the given line and find/create  *	the nodes for the specified archive members, placing their nodes  *	on the given list, given the pointer to the start of the  *	specification, a Lst on which to place the nodes, and a context  *	in which to expand variables.  *  * Results:  *	SUCCESS if it was a valid specification. The linePtr is updated  *	to point to the first non-space after the archive spec. The  *	nodes for the members are placed on the given list.  *  * Side Effects:  *	Some nodes may be created. The given list is extended.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|ReturnStatus
name|Arch_ParseArchive
parameter_list|(
name|char
modifier|*
modifier|*
name|linePtr
parameter_list|,
name|Lst
modifier|*
name|nodeLst
parameter_list|,
name|GNode
modifier|*
name|ctxt
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* Pointer into line */
name|GNode
modifier|*
name|gn
decl_stmt|;
comment|/* New node */
name|char
modifier|*
name|libName
decl_stmt|;
comment|/* Library-part of specification */
name|char
modifier|*
name|memName
decl_stmt|;
comment|/* Member-part of specification */
name|char
modifier|*
name|nameBuf
decl_stmt|;
comment|/* temporary place for node name */
name|char
name|saveChar
decl_stmt|;
comment|/* Ending delimiter of member-name */
name|Boolean
name|subLibName
decl_stmt|;
comment|/* TRUE if libName should have/had 				 * variable substitution performed on it */
name|libName
operator|=
operator|*
name|linePtr
expr_stmt|;
name|subLibName
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|libName
init|;
operator|*
name|cp
operator|!=
literal|'('
operator|&&
operator|*
name|cp
operator|!=
literal|'\0'
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'$'
condition|)
block|{
comment|/* 			 * Variable spec, so call the Var module to parse the 			 * puppy so we can safely advance beyond it... 			 */
name|size_t
name|length
init|=
literal|0
decl_stmt|;
name|Boolean
name|freeIt
decl_stmt|;
name|char
modifier|*
name|result
decl_stmt|;
name|result
operator|=
name|Var_Parse
argument_list|(
name|cp
argument_list|,
name|ctxt
argument_list|,
name|TRUE
argument_list|,
operator|&
name|length
argument_list|,
operator|&
name|freeIt
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|var_Error
condition|)
block|{
return|return
operator|(
name|FAILURE
operator|)
return|;
block|}
name|subLibName
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|freeIt
condition|)
block|{
name|free
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
name|cp
operator|+=
name|length
operator|-
literal|1
expr_stmt|;
block|}
block|}
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|subLibName
condition|)
block|{
name|libName
operator|=
name|Buf_Peel
argument_list|(
name|Var_Subst
argument_list|(
name|NULL
argument_list|,
name|libName
argument_list|,
name|ctxt
argument_list|,
name|TRUE
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 		 * First skip to the start of the member's name, mark that 		 * place and skip to the end of it (either white-space or 		 * a close paren). 		 */
comment|/* 		 * TRUE if need to substitute in memName 		 */
name|Boolean
name|doSubst
init|=
name|FALSE
decl_stmt|;
while|while
condition|(
operator|*
name|cp
operator|!=
literal|'\0'
operator|&&
operator|*
name|cp
operator|!=
literal|')'
operator|&&
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cp
argument_list|)
condition|)
block|{
name|cp
operator|++
expr_stmt|;
block|}
name|memName
operator|=
name|cp
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|!=
literal|'\0'
operator|&&
operator|*
name|cp
operator|!=
literal|')'
operator|&&
operator|!
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cp
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'$'
condition|)
block|{
comment|/* 				 * Variable spec, so call the Var module to 				 * parse the puppy so we can safely advance 				 * beyond it... 				 */
name|size_t
name|length
init|=
literal|0
decl_stmt|;
name|Boolean
name|freeIt
decl_stmt|;
name|char
modifier|*
name|result
decl_stmt|;
name|result
operator|=
name|Var_Parse
argument_list|(
name|cp
argument_list|,
name|ctxt
argument_list|,
name|TRUE
argument_list|,
operator|&
name|length
argument_list|,
operator|&
name|freeIt
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|var_Error
condition|)
block|{
return|return
operator|(
name|FAILURE
operator|)
return|;
block|}
name|doSubst
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|freeIt
condition|)
block|{
name|free
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
name|cp
operator|+=
name|length
expr_stmt|;
block|}
else|else
block|{
name|cp
operator|++
expr_stmt|;
block|}
block|}
comment|/* 		 * If the specification ends without a closing parenthesis, 		 * chances are there's something wrong (like a missing 		 * backslash), so it's better to return failure than allow 		 * such things to happen 		 */
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
condition|)
block|{
name|printf
argument_list|(
literal|"No closing parenthesis in archive "
literal|"specification\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|FAILURE
operator|)
return|;
block|}
comment|/* 		 * If we didn't move anywhere, we must be done 		 */
if|if
condition|(
name|cp
operator|==
name|memName
condition|)
block|{
break|break;
block|}
name|saveChar
operator|=
operator|*
name|cp
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
comment|/* 		 * XXX: This should be taken care of intelligently by 		 * SuffExpandChildren, both for the archive and the member 		 * portions. 		 */
comment|/* 		 * If member contains variables, try and substitute for them. 		 * This will slow down archive specs with dynamic sources, of 		 * course, since we'll be (non-)substituting them three times, 		 * but them's the breaks -- we need to do this since 		 * SuffExpandChildren calls us, otherwise we could assume the 		 * thing would be taken care of later. 		 */
if|if
condition|(
name|doSubst
condition|)
block|{
name|char
modifier|*
name|buf
decl_stmt|;
name|char
modifier|*
name|sacrifice
decl_stmt|;
name|char
modifier|*
name|oldMemName
init|=
name|memName
decl_stmt|;
name|size_t
name|sz
decl_stmt|;
name|Buffer
modifier|*
name|buf1
decl_stmt|;
comment|/* 			 * Now form an archive spec and recurse to deal with 			 * nested variables and multi-word variable values.... 			 * The results are just placed at the end of the 			 * nodeLst we're returning. 			 */
name|buf1
operator|=
name|Var_Subst
argument_list|(
name|NULL
argument_list|,
name|memName
argument_list|,
name|ctxt
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|memName
operator|=
name|Buf_Data
argument_list|(
name|buf1
argument_list|)
expr_stmt|;
name|sz
operator|=
name|strlen
argument_list|(
name|memName
argument_list|)
operator|+
name|strlen
argument_list|(
name|libName
argument_list|)
operator|+
literal|3
expr_stmt|;
name|buf
operator|=
name|emalloc
argument_list|(
name|sz
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
name|sz
argument_list|,
literal|"%s(%s)"
argument_list|,
name|libName
argument_list|,
name|memName
argument_list|)
expr_stmt|;
name|sacrifice
operator|=
name|buf
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|memName
argument_list|,
literal|'$'
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|memName
argument_list|,
name|oldMemName
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 				 * Must contain dynamic sources, so we can't 				 * deal with it now. 				 * Just create an ARCHV node for the thing and 				 * let SuffExpandChildren handle it... 				 */
name|gn
operator|=
name|Targ_FindNode
argument_list|(
name|buf
argument_list|,
name|TARG_CREATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|gn
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|Buf_Destroy
argument_list|(
name|buf1
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
operator|(
name|FAILURE
operator|)
return|;
block|}
name|gn
operator|->
name|type
operator||=
name|OP_ARCHV
expr_stmt|;
name|Lst_AtEnd
argument_list|(
name|nodeLst
argument_list|,
operator|(
name|void
operator|*
operator|)
name|gn
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Arch_ParseArchive
argument_list|(
operator|&
name|sacrifice
argument_list|,
name|nodeLst
argument_list|,
name|ctxt
argument_list|)
operator|!=
name|SUCCESS
condition|)
block|{
comment|/* 				 * Error in nested call -- free buffer and 				 * return FAILURE ourselves. 				 */
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|Buf_Destroy
argument_list|(
name|buf1
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
operator|(
name|FAILURE
operator|)
return|;
block|}
comment|/* Free buffer and continue with our work. */
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|Buf_Destroy
argument_list|(
name|buf1
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Dir_HasWildcards
argument_list|(
name|memName
argument_list|)
condition|)
block|{
name|Lst
name|members
init|=
name|Lst_Initializer
argument_list|(
name|members
argument_list|)
decl_stmt|;
name|char
modifier|*
name|member
decl_stmt|;
name|size_t
name|sz
init|=
name|MAXPATHLEN
decl_stmt|;
name|size_t
name|nsz
decl_stmt|;
name|nameBuf
operator|=
name|emalloc
argument_list|(
name|sz
argument_list|)
expr_stmt|;
name|Path_Expand
argument_list|(
name|memName
argument_list|,
operator|&
name|dirSearchPath
argument_list|,
operator|&
name|members
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|Lst_IsEmpty
argument_list|(
operator|&
name|members
argument_list|)
condition|)
block|{
name|member
operator|=
name|Lst_DeQueue
argument_list|(
operator|&
name|members
argument_list|)
expr_stmt|;
name|nsz
operator|=
name|strlen
argument_list|(
name|libName
argument_list|)
operator|+
name|strlen
argument_list|(
name|member
argument_list|)
operator|+
literal|3
expr_stmt|;
if|if
condition|(
name|nsz
operator|>
name|sz
condition|)
block|{
name|sz
operator|=
name|nsz
operator|*
literal|2
expr_stmt|;
name|nameBuf
operator|=
name|erealloc
argument_list|(
name|nameBuf
argument_list|,
name|sz
argument_list|)
expr_stmt|;
block|}
name|snprintf
argument_list|(
name|nameBuf
argument_list|,
name|sz
argument_list|,
literal|"%s(%s)"
argument_list|,
name|libName
argument_list|,
name|member
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|member
argument_list|)
expr_stmt|;
name|gn
operator|=
name|Targ_FindNode
argument_list|(
name|nameBuf
argument_list|,
name|TARG_CREATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|gn
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|nameBuf
argument_list|)
expr_stmt|;
comment|/* XXXHB Lst_Destroy(&members) */
return|return
operator|(
name|FAILURE
operator|)
return|;
block|}
comment|/* 				 * We've found the node, but have to make sure 				 * the rest of the world knows it's an archive 				 * member, without having to constantly check 				 * for parentheses, so we type the thing with 				 * the OP_ARCHV bit before we place it on the 				 * end of the provided list. 				 */
name|gn
operator|->
name|type
operator||=
name|OP_ARCHV
expr_stmt|;
name|Lst_AtEnd
argument_list|(
name|nodeLst
argument_list|,
name|gn
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|nameBuf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|size_t
name|sz
init|=
name|strlen
argument_list|(
name|libName
argument_list|)
operator|+
name|strlen
argument_list|(
name|memName
argument_list|)
operator|+
literal|3
decl_stmt|;
name|nameBuf
operator|=
name|emalloc
argument_list|(
name|sz
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|nameBuf
argument_list|,
name|sz
argument_list|,
literal|"%s(%s)"
argument_list|,
name|libName
argument_list|,
name|memName
argument_list|)
expr_stmt|;
name|gn
operator|=
name|Targ_FindNode
argument_list|(
name|nameBuf
argument_list|,
name|TARG_CREATE
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|nameBuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|gn
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|FAILURE
operator|)
return|;
block|}
comment|/* 			 * We've found the node, but have to make sure the 			 * rest of the world knows it's an archive member, 			 * without having to constantly check for parentheses, 			 * so we type the thing with the OP_ARCHV bit before 			 * we place it on the end of the provided list. 			 */
name|gn
operator|->
name|type
operator||=
name|OP_ARCHV
expr_stmt|;
name|Lst_AtEnd
argument_list|(
name|nodeLst
argument_list|,
name|gn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|doSubst
condition|)
block|{
name|free
argument_list|(
name|memName
argument_list|)
expr_stmt|;
block|}
operator|*
name|cp
operator|=
name|saveChar
expr_stmt|;
block|}
comment|/* 	 * If substituted libName, free it now, since we need it no longer. 	 */
if|if
condition|(
name|subLibName
condition|)
block|{
name|free
argument_list|(
name|libName
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * We promised the pointer would be set up at the next non-space, so 	 * we must advance cp there before setting *linePtr... (note that on 	 * entrance to the loop, cp is guaranteed to point at a ')') 	 */
do|do
block|{
name|cp
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|cp
operator|!=
literal|'\0'
operator|&&
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cp
argument_list|)
condition|)
do|;
operator|*
name|linePtr
operator|=
name|cp
expr_stmt|;
return|return
operator|(
name|SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * ArchFindMember --  *	Locate a member of an archive, given the path of the archive and  *	the path of the desired member. If the archive is to be modified,  *	the mode should be "r+", if not, it should be "r".  arhPtr is a  *	poitner to the header structure to fill in.  *  * Results:  *	An FILE *, opened for reading and writing, positioned at the  *	start of the member's struct ar_hdr, or NULL if the member was  *	nonexistent. The current struct ar_hdr for member.  *  * Side Effects:  *	The passed struct ar_hdr structure is filled in.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|FILE
modifier|*
name|ArchFindMember
parameter_list|(
specifier|const
name|char
modifier|*
name|archive
parameter_list|,
specifier|const
name|char
modifier|*
name|member
parameter_list|,
name|struct
name|ar_hdr
modifier|*
name|arhPtr
parameter_list|,
specifier|const
name|char
modifier|*
name|mode
parameter_list|)
block|{
name|FILE
modifier|*
name|arch
decl_stmt|;
comment|/* Stream to archive */
name|int
name|size
decl_stmt|;
comment|/* Size of archive member */
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* Useful character pointer */
name|char
name|magic
index|[
name|SARMAG
index|]
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|size_t
name|tlen
decl_stmt|;
name|arch
operator|=
name|fopen
argument_list|(
name|archive
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|arch
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * We use the ARMAG string to make sure this is an archive we 	 * can handle... 	 */
if|if
condition|(
name|fread
argument_list|(
name|magic
argument_list|,
name|SARMAG
argument_list|,
literal|1
argument_list|,
name|arch
argument_list|)
operator|!=
literal|1
operator|||
name|strncmp
argument_list|(
name|magic
argument_list|,
name|ARMAG
argument_list|,
name|SARMAG
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|fclose
argument_list|(
name|arch
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * Because of space constraints and similar things, files are archived 	 * using their final path components, not the entire thing, so we need 	 * to point 'member' to the final component, if there is one, to make 	 * the comparisons easier... 	 */
name|cp
operator|=
name|strrchr
argument_list|(
name|member
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|member
argument_list|,
name|RANLIBMAG
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|member
operator|=
name|cp
operator|+
literal|1
expr_stmt|;
block|}
name|len
operator|=
name|tlen
operator|=
name|strlen
argument_list|(
name|member
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
sizeof|sizeof
argument_list|(
name|arhPtr
operator|->
name|ar_name
argument_list|)
condition|)
block|{
name|tlen
operator|=
sizeof|sizeof
argument_list|(
name|arhPtr
operator|->
name|ar_name
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|fread
argument_list|(
name|arhPtr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
argument_list|,
literal|1
argument_list|,
name|arch
argument_list|)
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|arhPtr
operator|->
name|ar_fmag
argument_list|,
name|ARFMAG
argument_list|,
sizeof|sizeof
argument_list|(
name|arhPtr
operator|->
name|ar_fmag
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * The header is bogus, so the archive is bad 			 * and there's no way we can recover... 			 */
name|fclose
argument_list|(
name|arch
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|member
argument_list|,
name|arhPtr
operator|->
name|ar_name
argument_list|,
name|tlen
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * If the member's name doesn't take up the entire 			 * 'name' field, we have to be careful of matching 			 * prefixes. Names are space-padded to the right, so if 			 * the character in 'name' at the end of the matched 			 * string is anything but a space, this isn't the 			 * member we sought. Additionally there may be a 			 * slash at the end of the name (System 5 style). 			 */
if|if
condition|(
name|tlen
operator|!=
sizeof|sizeof
argument_list|(
name|arhPtr
operator|->
name|ar_name
argument_list|)
operator|&&
name|arhPtr
operator|->
name|ar_name
index|[
name|tlen
index|]
operator|!=
literal|' '
operator|&&
name|arhPtr
operator|->
name|ar_name
index|[
name|tlen
index|]
operator|!=
literal|'/'
condition|)
block|{
goto|goto
name|skip
goto|;
block|}
comment|/* 			 * To make life easier, we reposition the file at the 			 * start of the header we just read before we return the 			 * stream. In a more general situation, it might be 			 * better to leave the file at the actual member, rather 			 * than its header, but not here... 			 */
name|fseek
argument_list|(
name|arch
argument_list|,
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
argument_list|,
name|SEEK_CUR
argument_list|)
expr_stmt|;
return|return
operator|(
name|arch
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|AR_EFMT1
comment|/* 		 * BSD 4.4 extended AR format: #1/<namelen>, with name as the 		 * first<namelen> bytes of the file 		 */
if|if
condition|(
name|strncmp
argument_list|(
name|arhPtr
operator|->
name|ar_name
argument_list|,
name|AR_EFMT1
argument_list|,
sizeof|sizeof
argument_list|(
name|AR_EFMT1
argument_list|)
operator|-
literal|1
argument_list|)
operator|==
literal|0
operator|&&
name|isdigit
argument_list|(
name|arhPtr
operator|->
name|ar_name
index|[
sizeof|sizeof
argument_list|(
name|AR_EFMT1
argument_list|)
operator|-
literal|1
index|]
argument_list|)
condition|)
block|{
name|unsigned
name|elen
decl_stmt|;
name|char
name|ename
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|elen
operator|=
name|atoi
argument_list|(
operator|&
name|arhPtr
operator|->
name|ar_name
index|[
sizeof|sizeof
argument_list|(
name|AR_EFMT1
argument_list|)
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|elen
operator|>
name|MAXPATHLEN
condition|)
block|{
name|fclose
argument_list|(
name|arch
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|fread
argument_list|(
name|ename
argument_list|,
name|elen
argument_list|,
literal|1
argument_list|,
name|arch
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|fclose
argument_list|(
name|arch
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|ename
index|[
name|elen
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* 			 * XXX choose one. 			 */
if|if
condition|(
name|DEBUG
argument_list|(
name|ARCH
argument_list|)
operator|||
name|DEBUG
argument_list|(
name|MAKE
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"ArchFind: Extended format entry for "
literal|"%s\n"
argument_list|,
name|ename
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|ename
argument_list|,
name|member
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Found as extended name */
name|fseek
argument_list|(
name|arch
argument_list|,
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
operator|-
name|elen
argument_list|,
name|SEEK_CUR
argument_list|)
expr_stmt|;
return|return
operator|(
name|arch
operator|)
return|;
block|}
name|fseek
argument_list|(
name|arch
argument_list|,
operator|-
name|elen
argument_list|,
name|SEEK_CUR
argument_list|)
expr_stmt|;
goto|goto
name|skip
goto|;
block|}
endif|#
directive|endif
name|skip
label|:
comment|/* 		 * This isn't the member we're after, so we need to advance the 		 * stream's pointer to the start of the next header. Files are 		 * padded with newlines to an even-byte boundary, so we need to 		 * extract the size of the file from the 'size' field of the 		 * header and round it up during the seek. 		 */
name|arhPtr
operator|->
name|ar_size
index|[
sizeof|sizeof
argument_list|(
name|arhPtr
operator|->
name|ar_size
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|size
operator|=
operator|(
name|int
operator|)
name|strtol
argument_list|(
name|arhPtr
operator|->
name|ar_size
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|fseek
argument_list|(
name|arch
argument_list|,
operator|(
name|size
operator|+
literal|1
operator|)
operator|&
operator|~
literal|1
argument_list|,
name|SEEK_CUR
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * We've looked everywhere, but the member is not to be found. Close the 	 * archive and return NULL -- an error. 	 */
name|fclose
argument_list|(
name|arch
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SVR4ARCHIVES
end_ifdef

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * ArchSVR4Entry --  *	Parse an SVR4 style entry that begins with a slash.  *	If it is "//", then load the table of filenames  *	If it is "/<offset>", then try to substitute the long file name  *	from offset of a table previously read.  *  * Results:  *	-1: Bad data in archive  *	 0: A table was loaded from the file  *	 1: Name was successfully substituted from table  *	 2: Name was not successfully substituted from table  *  * Side Effects:  *	If a table is read, the file pointer is moved to the next archive  *	member  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|ArchSVR4Entry
parameter_list|(
name|Arch
modifier|*
name|ar
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|size_t
name|size
parameter_list|,
name|FILE
modifier|*
name|arch
parameter_list|)
block|{
define|#
directive|define
name|ARLONGNAMES1
value|"//"
define|#
directive|define
name|ARLONGNAMES2
value|"/ARFILENAMES"
name|size_t
name|entry
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
name|char
modifier|*
name|eptr
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
name|ARLONGNAMES1
argument_list|,
sizeof|sizeof
argument_list|(
name|ARLONGNAMES1
argument_list|)
operator|-
literal|1
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|name
argument_list|,
name|ARLONGNAMES2
argument_list|,
sizeof|sizeof
argument_list|(
name|ARLONGNAMES2
argument_list|)
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ar
operator|->
name|fnametab
operator|!=
name|NULL
condition|)
block|{
name|DEBUGF
argument_list|(
name|ARCH
argument_list|,
operator|(
literal|"Attempted to redefine an SVR4 name "
literal|"table\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 		 * This is a table of archive names, so we build one for 		 * ourselves 		 */
name|ar
operator|->
name|fnametab
operator|=
name|emalloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|ar
operator|->
name|fnamesize
operator|=
name|size
expr_stmt|;
if|if
condition|(
name|fread
argument_list|(
name|ar
operator|->
name|fnametab
argument_list|,
name|size
argument_list|,
literal|1
argument_list|,
name|arch
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|DEBUGF
argument_list|(
name|ARCH
argument_list|,
operator|(
literal|"Reading an SVR4 name table failed\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|eptr
operator|=
name|ar
operator|->
name|fnametab
operator|+
name|size
expr_stmt|;
for|for
control|(
name|entry
operator|=
literal|0
operator|,
name|ptr
operator|=
name|ar
operator|->
name|fnametab
init|;
name|ptr
operator|<
name|eptr
condition|;
name|ptr
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|ptr
condition|)
block|{
case|case
literal|'/'
case|:
name|entry
operator|++
expr_stmt|;
operator|*
name|ptr
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
break|break;
default|default:
break|break;
block|}
block|}
name|DEBUGF
argument_list|(
name|ARCH
argument_list|,
operator|(
literal|"Found svr4 archive name table with %zu "
literal|"entries\n"
operator|,
name|entry
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|name
index|[
literal|1
index|]
operator|==
literal|' '
operator|||
name|name
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
return|return
operator|(
literal|2
operator|)
return|;
name|entry
operator|=
operator|(
name|size_t
operator|)
name|strtol
argument_list|(
operator|&
name|name
index|[
literal|1
index|]
argument_list|,
operator|&
name|eptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|eptr
operator|!=
literal|' '
operator|&&
operator|*
name|eptr
operator|!=
literal|'\0'
operator|)
operator|||
name|eptr
operator|==
operator|&
name|name
index|[
literal|1
index|]
condition|)
block|{
name|DEBUGF
argument_list|(
name|ARCH
argument_list|,
operator|(
literal|"Could not parse SVR4 name %s\n"
operator|,
name|name
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|2
operator|)
return|;
block|}
if|if
condition|(
name|entry
operator|>=
name|ar
operator|->
name|fnamesize
condition|)
block|{
name|DEBUGF
argument_list|(
name|ARCH
argument_list|,
operator|(
literal|"SVR4 entry offset %s is greater than %zu\n"
operator|,
name|name
operator|,
name|ar
operator|->
name|fnamesize
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|2
operator|)
return|;
block|}
name|DEBUGF
argument_list|(
name|ARCH
argument_list|,
operator|(
literal|"Replaced %s with %s\n"
operator|,
name|name
operator|,
operator|&
name|ar
operator|->
name|fnametab
index|[
name|entry
index|]
operator|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|name
argument_list|,
operator|&
name|ar
operator|->
name|fnametab
index|[
name|entry
index|]
argument_list|,
name|MAXPATHLEN
argument_list|)
expr_stmt|;
name|name
index|[
name|MAXPATHLEN
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * ArchStatMember --  *	Locate a member of an archive, given the path of the archive and  *	the path of the desired member, and a boolean representing whether  *	or not the archive should be hashed (if not already hashed).  *  * Results:  *	A pointer to the current struct ar_hdr structure for the member. Note  *	That no position is returned, so this is not useful for touching  *	archive members. This is mostly because we have no assurances that  *	The archive will remain constant after we read all the headers, so  *	there's not much point in remembering the position...  *  * Side Effects:  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|struct
name|ar_hdr
modifier|*
name|ArchStatMember
parameter_list|(
specifier|const
name|char
modifier|*
name|archive
parameter_list|,
specifier|const
name|char
modifier|*
name|member
parameter_list|,
name|Boolean
name|hash
parameter_list|)
block|{
define|#
directive|define
name|AR_MAX_NAME_LEN
value|(sizeof(arh.ar_name) - 1)
name|FILE
modifier|*
name|arch
decl_stmt|;
comment|/* Stream to archive */
name|int
name|size
decl_stmt|;
comment|/* Size of archive member */
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* Useful character pointer */
name|char
name|magic
index|[
name|SARMAG
index|]
decl_stmt|;
name|LstNode
modifier|*
name|ln
decl_stmt|;
comment|/* Lst member containing archive descriptor */
name|Arch
modifier|*
name|ar
decl_stmt|;
comment|/* Archive descriptor */
name|Hash_Entry
modifier|*
name|he
decl_stmt|;
comment|/* Entry containing member's description */
name|struct
name|ar_hdr
name|arh
decl_stmt|;
comment|/* archive-member header for reading archive */
name|char
name|memName
index|[
name|MAXPATHLEN
operator|+
literal|1
index|]
decl_stmt|;
comment|/* Current member name while hashing */
comment|/* 	 * Because of space constraints and similar things, files are archived 	 * using their final path components, not the entire thing, so we need 	 * to point 'member' to the final component, if there is one, to make 	 * the comparisons easier... 	 */
name|cp
operator|=
name|strrchr
argument_list|(
name|member
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|member
argument_list|,
name|RANLIBMAG
argument_list|)
operator|!=
literal|0
condition|)
name|member
operator|=
name|cp
operator|+
literal|1
expr_stmt|;
name|LST_FOREACH
argument_list|(
argument|ln
argument_list|,
argument|&archives
argument_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|archive
argument_list|,
operator|(
operator|(
specifier|const
name|Arch
operator|*
operator|)
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
operator|)
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|ln
operator|!=
name|NULL
condition|)
block|{
name|char
name|copy
index|[
name|AR_MAX_NAME_LEN
operator|+
literal|1
index|]
decl_stmt|;
name|ar
operator|=
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
expr_stmt|;
name|he
operator|=
name|Hash_FindEntry
argument_list|(
operator|&
name|ar
operator|->
name|members
argument_list|,
name|member
argument_list|)
expr_stmt|;
if|if
condition|(
name|he
operator|!=
name|NULL
condition|)
block|{
return|return
operator|(
name|Hash_GetValue
argument_list|(
name|he
argument_list|)
operator|)
return|;
block|}
comment|/* Try truncated name */
name|strncpy
argument_list|(
name|copy
argument_list|,
name|member
argument_list|,
name|AR_MAX_NAME_LEN
argument_list|)
expr_stmt|;
name|copy
index|[
name|AR_MAX_NAME_LEN
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|he
operator|=
name|Hash_FindEntry
argument_list|(
operator|&
name|ar
operator|->
name|members
argument_list|,
name|copy
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
return|return
operator|(
name|Hash_GetValue
argument_list|(
name|he
argument_list|)
operator|)
return|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|hash
condition|)
block|{
comment|/* 		 * Caller doesn't want the thing hashed, just use ArchFindMember 		 * to read the header for the member out and close down the 		 * stream again. Since the archive is not to be hashed, we 		 * assume there's no need to allocate extra room for the header 		 * we're returning, so just declare it static. 		 */
specifier|static
name|struct
name|ar_hdr
name|sarh
decl_stmt|;
name|arch
operator|=
name|ArchFindMember
argument_list|(
name|archive
argument_list|,
name|member
argument_list|,
operator|&
name|sarh
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|arch
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|fclose
argument_list|(
name|arch
argument_list|)
expr_stmt|;
return|return
operator|(
operator|&
name|sarh
operator|)
return|;
block|}
comment|/* 	 * We don't have this archive on the list yet, so we want to find out 	 * everything that's in it and cache it so we can get at it quickly. 	 */
name|arch
operator|=
name|fopen
argument_list|(
name|archive
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|arch
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * We use the ARMAG string to make sure this is an archive we 	 * can handle... 	 */
if|if
condition|(
name|fread
argument_list|(
name|magic
argument_list|,
name|SARMAG
argument_list|,
literal|1
argument_list|,
name|arch
argument_list|)
operator|!=
literal|1
operator|||
name|strncmp
argument_list|(
name|magic
argument_list|,
name|ARMAG
argument_list|,
name|SARMAG
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|fclose
argument_list|(
name|arch
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|ar
operator|=
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Arch
argument_list|)
argument_list|)
expr_stmt|;
name|ar
operator|->
name|name
operator|=
name|estrdup
argument_list|(
name|archive
argument_list|)
expr_stmt|;
name|ar
operator|->
name|fnametab
operator|=
name|NULL
expr_stmt|;
name|ar
operator|->
name|fnamesize
operator|=
literal|0
expr_stmt|;
name|Hash_InitTable
argument_list|(
operator|&
name|ar
operator|->
name|members
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|memName
index|[
name|AR_MAX_NAME_LEN
index|]
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|fread
argument_list|(
operator|&
name|arh
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
argument_list|,
literal|1
argument_list|,
name|arch
argument_list|)
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|arh
operator|.
name|ar_fmag
argument_list|,
name|ARFMAG
argument_list|,
sizeof|sizeof
argument_list|(
name|arh
operator|.
name|ar_fmag
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * The header is bogus, so the archive is bad 			 * and there's no way we can recover... 			 */
goto|goto
name|badarch
goto|;
block|}
comment|/* 		 * We need to advance the stream's pointer to the start of the 		 * next header. Files are padded with newlines to an even-byte 		 * boundary, so we need to extract the size of the file from the 		 * 'size' field of the header and round it up during the seek. 		 */
name|arh
operator|.
name|ar_size
index|[
sizeof|sizeof
argument_list|(
name|arh
operator|.
name|ar_size
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|size
operator|=
operator|(
name|int
operator|)
name|strtol
argument_list|(
name|arh
operator|.
name|ar_size
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|memName
argument_list|,
name|arh
operator|.
name|ar_name
argument_list|,
sizeof|sizeof
argument_list|(
name|arh
operator|.
name|ar_name
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|cp
operator|=
operator|&
name|memName
index|[
name|AR_MAX_NAME_LEN
index|]
init|;
operator|*
name|cp
operator|==
literal|' '
condition|;
name|cp
operator|--
control|)
block|{
empty_stmt|;
block|}
name|cp
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
ifdef|#
directive|ifdef
name|SVR4ARCHIVES
comment|/* 		 * svr4 names are slash terminated. Also svr4 extended AR 		 * format. 		 */
if|if
condition|(
name|memName
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
block|{
comment|/* 			 * svr4 magic mode; handle it 			 */
switch|switch
condition|(
name|ArchSVR4Entry
argument_list|(
name|ar
argument_list|,
name|memName
argument_list|,
name|size
argument_list|,
name|arch
argument_list|)
condition|)
block|{
case|case
operator|-
literal|1
case|:
comment|/* Invalid data */
goto|goto
name|badarch
goto|;
case|case
literal|0
case|:
comment|/* List of files entry */
continue|continue;
default|default:
comment|/* Got the entry */
break|break;
block|}
block|}
else|else
block|{
if|if
condition|(
name|cp
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
name|cp
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|AR_EFMT1
comment|/* 		 * BSD 4.4 extended AR format: #1/<namelen>, with name as the 		 * first<namelen> bytes of the file 		 */
if|if
condition|(
name|strncmp
argument_list|(
name|memName
argument_list|,
name|AR_EFMT1
argument_list|,
sizeof|sizeof
argument_list|(
name|AR_EFMT1
argument_list|)
operator|-
literal|1
argument_list|)
operator|==
literal|0
operator|&&
name|isdigit
argument_list|(
name|memName
index|[
sizeof|sizeof
argument_list|(
name|AR_EFMT1
argument_list|)
operator|-
literal|1
index|]
argument_list|)
condition|)
block|{
name|unsigned
name|elen
init|=
name|atoi
argument_list|(
operator|&
name|memName
index|[
sizeof|sizeof
argument_list|(
name|AR_EFMT1
argument_list|)
operator|-
literal|1
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|elen
operator|>
name|MAXPATHLEN
condition|)
goto|goto
name|badarch
goto|;
if|if
condition|(
name|fread
argument_list|(
name|memName
argument_list|,
name|elen
argument_list|,
literal|1
argument_list|,
name|arch
argument_list|)
operator|!=
literal|1
condition|)
goto|goto
name|badarch
goto|;
name|memName
index|[
name|elen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|fseek
argument_list|(
name|arch
argument_list|,
operator|-
name|elen
argument_list|,
name|SEEK_CUR
argument_list|)
expr_stmt|;
comment|/* 			 * XXX Multiple levels may be asked for, make this 			 * conditional on one, and use DEBUGF. 			 */
if|if
condition|(
name|DEBUG
argument_list|(
name|ARCH
argument_list|)
operator|||
name|DEBUG
argument_list|(
name|MAKE
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ArchStat: Extended format "
literal|"entry for %s\n"
argument_list|,
name|memName
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|he
operator|=
name|Hash_CreateEntry
argument_list|(
operator|&
name|ar
operator|->
name|members
argument_list|,
name|memName
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|Hash_SetValue
argument_list|(
name|he
argument_list|,
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|Hash_GetValue
argument_list|(
name|he
argument_list|)
argument_list|,
operator|&
name|arh
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
argument_list|)
expr_stmt|;
name|fseek
argument_list|(
name|arch
argument_list|,
operator|(
name|size
operator|+
literal|1
operator|)
operator|&
operator|~
literal|1
argument_list|,
name|SEEK_CUR
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|arch
argument_list|)
expr_stmt|;
name|Lst_AtEnd
argument_list|(
operator|&
name|archives
argument_list|,
name|ar
argument_list|)
expr_stmt|;
comment|/* 	 * Now that the archive has been read and cached, we can look into 	 * the hash table to find the desired member's header. 	 */
name|he
operator|=
name|Hash_FindEntry
argument_list|(
operator|&
name|ar
operator|->
name|members
argument_list|,
name|member
argument_list|)
expr_stmt|;
if|if
condition|(
name|he
operator|!=
name|NULL
condition|)
block|{
return|return
operator|(
name|Hash_GetValue
argument_list|(
name|he
argument_list|)
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|badarch
label|:
name|fclose
argument_list|(
name|arch
argument_list|)
expr_stmt|;
name|Hash_DeleteTable
argument_list|(
operator|&
name|ar
operator|->
name|members
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ar
operator|->
name|fnametab
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ar
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Arch_Touch --  *	Touch a member of an archive.  *  * Results:  *	The 'time' field of the member's header is updated.  *  * Side Effects:  *	The modification time of the entire archive is also changed.  *	For a library, this could necessitate the re-ranlib'ing of the  *	whole thing.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Arch_Touch
parameter_list|(
name|GNode
modifier|*
name|gn
parameter_list|)
block|{
name|FILE
modifier|*
name|arch
decl_stmt|;
comment|/* Archive stream, positioned properly */
name|struct
name|ar_hdr
name|arh
decl_stmt|;
comment|/* Current header describing member */
name|char
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
name|arch
operator|=
name|ArchFindMember
argument_list|(
name|Var_Value
argument_list|(
name|ARCHIVE
argument_list|,
name|gn
argument_list|,
operator|&
name|p1
argument_list|)
argument_list|,
name|Var_Value
argument_list|(
name|TARGET
argument_list|,
name|gn
argument_list|,
operator|&
name|p2
argument_list|)
argument_list|,
operator|&
name|arh
argument_list|,
literal|"r+"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p2
argument_list|)
expr_stmt|;
if|if
condition|(
name|arch
operator|!=
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|arh
operator|.
name|ar_date
argument_list|,
sizeof|sizeof
argument_list|(
name|arh
operator|.
name|ar_date
argument_list|)
argument_list|,
literal|"%-12ld"
argument_list|,
operator|(
name|long
operator|)
name|now
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
operator|&
name|arh
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
argument_list|,
literal|1
argument_list|,
name|arch
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|arch
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Arch_TouchLib --  *	Given a node which represents a library, touch the thing, making  *	sure that the table of contents also is touched.  *  * Results:  *	None.  *  * Side Effects:  *	Both the modification time of the library and of the RANLIBMAG  *	member are set to 'now'.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Arch_TouchLib
parameter_list|(
name|GNode
modifier|*
name|gn
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|RANLIBMAG
name|FILE
modifier|*
name|arch
decl_stmt|;
comment|/* Stream open to archive */
name|struct
name|ar_hdr
name|arh
decl_stmt|;
comment|/* Header describing table of contents */
name|struct
name|utimbuf
name|times
decl_stmt|;
comment|/* Times for utime() call */
name|arch
operator|=
name|ArchFindMember
argument_list|(
name|gn
operator|->
name|path
argument_list|,
name|RANLIBMAG
argument_list|,
operator|&
name|arh
argument_list|,
literal|"r+"
argument_list|)
expr_stmt|;
if|if
condition|(
name|arch
operator|!=
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|arh
operator|.
name|ar_date
argument_list|,
sizeof|sizeof
argument_list|(
name|arh
operator|.
name|ar_date
argument_list|)
argument_list|,
literal|"%-12ld"
argument_list|,
operator|(
name|long
operator|)
name|now
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
operator|&
name|arh
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
argument_list|,
literal|1
argument_list|,
name|arch
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|arch
argument_list|)
expr_stmt|;
name|times
operator|.
name|actime
operator|=
name|times
operator|.
name|modtime
operator|=
name|now
expr_stmt|;
name|utime
argument_list|(
name|gn
operator|->
name|path
argument_list|,
operator|&
name|times
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Arch_MTime --  *	Return the modification time of a member of an archive, given its  *	name.  *  * Results:  *	The modification time(seconds).  *	XXXHB this should be a long.  *  * Side Effects:  *	The mtime field of the given node is filled in with the value  *	returned by the function.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Arch_MTime
parameter_list|(
name|GNode
modifier|*
name|gn
parameter_list|)
block|{
name|struct
name|ar_hdr
modifier|*
name|arhPtr
decl_stmt|;
comment|/* Header of desired member */
name|int
name|modTime
decl_stmt|;
comment|/* Modification time as an integer */
name|char
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
name|arhPtr
operator|=
name|ArchStatMember
argument_list|(
name|Var_Value
argument_list|(
name|ARCHIVE
argument_list|,
name|gn
argument_list|,
operator|&
name|p1
argument_list|)
argument_list|,
name|Var_Value
argument_list|(
name|TARGET
argument_list|,
name|gn
argument_list|,
operator|&
name|p2
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p2
argument_list|)
expr_stmt|;
if|if
condition|(
name|arhPtr
operator|!=
name|NULL
condition|)
block|{
name|modTime
operator|=
operator|(
name|int
operator|)
name|strtol
argument_list|(
name|arhPtr
operator|->
name|ar_date
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|modTime
operator|=
literal|0
expr_stmt|;
block|}
name|gn
operator|->
name|mtime
operator|=
name|modTime
expr_stmt|;
return|return
operator|(
name|modTime
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Arch_MemMTime --  *	Given a non-existent archive member's node, get its modification  *	time from its archived form, if it exists.  *  * Results:  *	The modification time.  *  * Side Effects:  *	The mtime field is filled in.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Arch_MemMTime
parameter_list|(
name|GNode
modifier|*
name|gn
parameter_list|)
block|{
name|LstNode
modifier|*
name|ln
decl_stmt|;
name|GNode
modifier|*
name|pgn
decl_stmt|;
name|char
modifier|*
name|nameStart
decl_stmt|;
name|char
modifier|*
name|nameEnd
decl_stmt|;
for|for
control|(
name|ln
operator|=
name|Lst_First
argument_list|(
operator|&
name|gn
operator|->
name|parents
argument_list|)
init|;
name|ln
operator|!=
name|NULL
condition|;
name|ln
operator|=
name|Lst_Succ
argument_list|(
name|ln
argument_list|)
control|)
block|{
name|pgn
operator|=
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
expr_stmt|;
if|if
condition|(
name|pgn
operator|->
name|type
operator|&
name|OP_ARCHV
condition|)
block|{
comment|/* 			 * If the parent is an archive specification and is 			 * being made and its member's name matches the name of 			 * the node we were given, record the modification time 			 * of the parent in the child. We keep searching its 			 * parents in case some other parent requires this 			 * child to exist... 			 */
name|nameStart
operator|=
name|strchr
argument_list|(
name|pgn
operator|->
name|name
argument_list|,
literal|'('
argument_list|)
operator|+
literal|1
expr_stmt|;
name|nameEnd
operator|=
name|strchr
argument_list|(
name|nameStart
argument_list|,
literal|')'
argument_list|)
expr_stmt|;
if|if
condition|(
name|pgn
operator|->
name|make
operator|&&
name|strncmp
argument_list|(
name|nameStart
argument_list|,
name|gn
operator|->
name|name
argument_list|,
name|nameEnd
operator|-
name|nameStart
argument_list|)
operator|==
literal|0
condition|)
block|{
name|gn
operator|->
name|mtime
operator|=
name|Arch_MTime
argument_list|(
name|pgn
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|pgn
operator|->
name|make
condition|)
block|{
comment|/* 			 * Something which isn't a library depends on the 			 * existence of this target, so it needs to exist. 			 */
name|gn
operator|->
name|mtime
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
name|gn
operator|->
name|mtime
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Arch_FindLib --  *	Search for a named library along the given search path.  *  * Results:  *	None.  *  * Side Effects:  *	The node's 'path' field is set to the found path (including the  *	actual file name, not -l...). If the system can handle the -L  *	flag when linking (or we cannot find the library), we assume that  *	the user has placed the .LIBRARIES variable in the final linking  *	command (or the linker will know where to find it) and set the  *	TARGET variable for this node to be the node's name. Otherwise,  *	we set the TARGET variable to be the full path of the library,  *	as returned by Dir_FindFile.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Arch_FindLib
parameter_list|(
name|GNode
modifier|*
name|gn
parameter_list|,
name|struct
name|Path
modifier|*
name|path
parameter_list|)
block|{
name|char
modifier|*
name|libName
decl_stmt|;
comment|/* file name for archive */
name|size_t
name|sz
decl_stmt|;
name|sz
operator|=
name|strlen
argument_list|(
name|gn
operator|->
name|name
argument_list|)
operator|+
literal|4
expr_stmt|;
name|libName
operator|=
name|emalloc
argument_list|(
name|sz
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|libName
argument_list|,
name|sz
argument_list|,
literal|"lib%s.a"
argument_list|,
operator|&
name|gn
operator|->
name|name
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|gn
operator|->
name|path
operator|=
name|Path_FindFile
argument_list|(
name|libName
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|libName
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LIBRARIES
name|Var_Set
argument_list|(
name|TARGET
argument_list|,
name|gn
operator|->
name|name
argument_list|,
name|gn
argument_list|)
expr_stmt|;
else|#
directive|else
name|Var_Set
argument_list|(
name|TARGET
argument_list|,
name|gn
operator|->
name|path
operator|==
name|NULL
condition|?
name|gn
operator|->
name|name
else|:
name|gn
operator|->
name|path
argument_list|,
name|gn
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* LIBRARIES */
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Arch_LibOODate --  *	Decide if a node with the OP_LIB attribute is out-of-date. Called  *	from Make_OODate to make its life easier, with the library's  *	graph node.  *  *	There are several ways for a library to be out-of-date that are  *	not available to ordinary files. In addition, there are ways  *	that are open to regular files that are not available to  *	libraries. A library that is only used as a source is never  *	considered out-of-date by itself. This does not preclude the  *	library's modification time from making its parent be out-of-date.  *	A library will be considered out-of-date for any of these reasons,  *	given that it is a target on a dependency line somewhere:  *	    Its modification time is less than that of one of its  *		  sources (gn->mtime< gn->cmtime).  *	    Its modification time is greater than the time at which the  *		  make began (i.e. it's been modified in the course  *		  of the make, probably by archiving).  *	    The modification time of one of its sources is greater than  *		  the one of its RANLIBMAG member (i.e. its table of contents  *		  is out-of-date). We don't compare of the archive time  *		  vs. TOC time because they can be too close. In my  *		  opinion we should not bother with the TOC at all since  *		  this is used by 'ar' rules that affect the data contents  *		  of the archive, not by ranlib rules, which affect the  *		  TOC.  *  * Results:  *	TRUE if the library is out-of-date. FALSE otherwise.  *  * Side Effects:  *	The library will be hashed if it hasn't been already.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|Boolean
name|Arch_LibOODate
parameter_list|(
name|GNode
modifier|*
name|gn
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|RANLIBMAG
name|struct
name|ar_hdr
modifier|*
name|arhPtr
decl_stmt|;
comment|/* Header for __.SYMDEF */
name|int
name|modTimeTOC
decl_stmt|;
comment|/* The table-of-contents's mod time */
endif|#
directive|endif
if|if
condition|(
name|OP_NOP
argument_list|(
name|gn
operator|->
name|type
argument_list|)
operator|&&
name|Lst_IsEmpty
argument_list|(
operator|&
name|gn
operator|->
name|children
argument_list|)
condition|)
block|{
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
if|if
condition|(
name|gn
operator|->
name|mtime
operator|>
name|now
operator|||
name|gn
operator|->
name|mtime
operator|<
name|gn
operator|->
name|cmtime
condition|)
block|{
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|RANLIBMAG
name|arhPtr
operator|=
name|ArchStatMember
argument_list|(
name|gn
operator|->
name|path
argument_list|,
name|RANLIBMAG
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|arhPtr
operator|!=
name|NULL
condition|)
block|{
name|modTimeTOC
operator|=
operator|(
name|int
operator|)
name|strtol
argument_list|(
name|arhPtr
operator|->
name|ar_date
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
comment|/* XXX choose one. */
if|if
condition|(
name|DEBUG
argument_list|(
name|ARCH
argument_list|)
operator|||
name|DEBUG
argument_list|(
name|MAKE
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s modified %s..."
argument_list|,
name|RANLIBMAG
argument_list|,
name|Targ_FmtTime
argument_list|(
name|modTimeTOC
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|gn
operator|->
name|cmtime
operator|>
name|modTimeTOC
operator|)
return|;
block|}
else|else
block|{
comment|/* 		 * A library w/o a table of contents is out-of-date 		 */
if|if
condition|(
name|DEBUG
argument_list|(
name|ARCH
argument_list|)
operator|||
name|DEBUG
argument_list|(
name|MAKE
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"No t.o.c...."
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
else|#
directive|else
return|return
operator|(
name|gn
operator|->
name|mtime
operator|==
literal|0
operator|)
return|;
comment|/* out-of-date if not present */
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Arch_Init --  *	Initialize things for this module.  *  * Results:  *	None.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Arch_Init
parameter_list|(
name|void
parameter_list|)
block|{ }
end_function

end_unit

