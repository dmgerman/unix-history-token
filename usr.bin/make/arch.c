begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1988, 1989, 1990, 1993  *	The Regents of the University of California.  All rights reserved.  * Copyright (c) 1989 by Berkeley Softworks  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Adam de Boor.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * @(#)arch.c	8.2 (Berkeley) 1/2/94  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*-  * arch.c --  *	Functions to manipulate libraries, archives and their members.  *  *	Once again, cacheing/hashing comes into play in the manipulation  * of archives. The first time an archive is referenced, all of its members'  * headers are read and hashed and the archive closed again. All hashed  * archives are kept on a list which is searched each time an archive member  * is referenced.  *  * The interface to this module is:  *	Arch_ParseArchive	Given an archive specification, return a list  *				of GNode's, one for each member in the spec.  *				FALSE is returned if the specification is  *				invalid for some reason.  *  *	Arch_Touch		Alter the modification time of the archive  *				member described by the given node to be  *				the current time.  *  *	Arch_TouchLib		Update the modification time of the library  *				described by the given node. This is special  *				because it also updates the modification time  *				of the library's table of contents.  *  *	Arch_MTime		Find the modification time of a member of  *				an archive *in the archive*. The time is also  *				placed in the member's GNode. Returns the  *				modification time.  *  *	Arch_MemTime		Find the modification time of a member of  *				an archive. Called when the member doesn't  *				already exist. Looks in the archive for the  *				modification time. Returns the modification  *				time.  *  *	Arch_FindLib		Search for a library along a path. The  *				library name in the GNode should be in  *				-l<name> format.  *  *	Arch_LibOODate		Special function to decide if a library node  *				is out-of-date.  *  *	Arch_Init		Initialize this module.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<ar.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<inttypes.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<regex.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<utime.h>
end_include

begin_include
include|#
directive|include
file|"arch.h"
end_include

begin_include
include|#
directive|include
file|"buf.h"
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"dir.h"
end_include

begin_include
include|#
directive|include
file|"globals.h"
end_include

begin_include
include|#
directive|include
file|"GNode.h"
end_include

begin_include
include|#
directive|include
file|"hash.h"
end_include

begin_include
include|#
directive|include
file|"make.h"
end_include

begin_include
include|#
directive|include
file|"parse.h"
end_include

begin_include
include|#
directive|include
file|"targ.h"
end_include

begin_include
include|#
directive|include
file|"util.h"
end_include

begin_include
include|#
directive|include
file|"var.h"
end_include

begin_typedef
typedef|typedef
struct|struct
name|Arch
block|{
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Name of archive */
comment|/* 	 * All the members of the archive described 	 * by<name, struct ar_hdr *> key/value pairs 	 */
name|Hash_Table
name|members
decl_stmt|;
name|TAILQ_ENTRY
argument_list|(
argument|Arch
argument_list|)
name|link
expr_stmt|;
comment|/* link all cached archives */
block|}
name|Arch
typedef|;
end_typedef

begin_comment
comment|/* Lst of archives we've already examined */
end_comment

begin_expr_stmt
specifier|static
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|Arch
argument_list|)
name|archives
operator|=
name|TAILQ_HEAD_INITIALIZER
argument_list|(
name|archives
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* size of the name field in the archive member header */
end_comment

begin_define
define|#
directive|define
name|AR_NAMSIZ
value|sizeof(((struct ar_hdr *)0)->ar_name)
end_define

begin_comment
comment|/*  * This structure is used while reading/writing an archive  */
end_comment

begin_struct
struct|struct
name|arfile
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
comment|/* archive file */
name|char
modifier|*
name|fname
decl_stmt|;
comment|/* name of the file */
name|struct
name|ar_hdr
name|hdr
decl_stmt|;
comment|/* current header */
name|char
name|sname
index|[
name|AR_NAMSIZ
operator|+
literal|1
index|]
decl_stmt|;
comment|/* short name */
name|char
modifier|*
name|member
decl_stmt|;
comment|/* (long) member name */
name|size_t
name|mlen
decl_stmt|;
comment|/* size of the above */
name|char
modifier|*
name|nametab
decl_stmt|;
comment|/* name table */
name|size_t
name|nametablen
decl_stmt|;
comment|/* size of the table */
name|int64_t
name|time
decl_stmt|;
comment|/* from ar_date */
name|uint64_t
name|size
decl_stmt|;
comment|/* from ar_size */
name|off_t
name|pos
decl_stmt|;
comment|/* header pos of current entry */
block|}
struct|;
end_struct

begin_comment
comment|/*  * Name of the symbol table. The original BSD used "__.SYMDEF". Rumours go  * that this name may have a slash appended sometimes. Actually FreeBSD  * uses "/" which probably came from SVR4.  */
end_comment

begin_define
define|#
directive|define
name|SVR4_RANLIBMAG
value|"/"
end_define

begin_define
define|#
directive|define
name|BSD_RANLIBMAG
value|"__.SYMDEF"
end_define

begin_comment
comment|/*  * Name of the filename table. The 4.4BSD ar format did not use this, but  * puts long filenames directly between the member header and the object  * file.  */
end_comment

begin_define
define|#
directive|define
name|SVR4_NAMEMAG
value|"//"
end_define

begin_define
define|#
directive|define
name|BSD_NAMEMAG
value|"ARFILENAMES/"
end_define

begin_comment
comment|/*  * 44BSD long filename key. Use a local define here instead of relying  * on ar.h because we want this to continue working even when the  * definition is removed from ar.h.  */
end_comment

begin_define
define|#
directive|define
name|BSD_EXT1
value|"#1/"
end_define

begin_define
define|#
directive|define
name|BSD_EXT1LEN
value|3
end_define

begin_comment
comment|/* if this is TRUE make archive errors fatal */
end_comment

begin_decl_stmt
name|Boolean
name|arch_fatal
init|=
name|TRUE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**  * ArchError  *	An error happend while handling an archive. BSDmake traditionally  *	ignored these errors. Now this is dependend on the global arch_fatal  *	which, if true, makes these errors fatal and, if false, just emits an  *	error message.  */
end_comment

begin_define
define|#
directive|define
name|ArchError
parameter_list|(
name|ARGS
parameter_list|)
value|do {					\ 	if (arch_fatal)						\ 		Fatal ARGS;					\ 	else							\ 		Error ARGS;					\     } while (0)
end_define

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Arch_ParseArchive --  *	Parse the archive specification in the given line and find/create  *	the nodes for the specified archive members, placing their nodes  *	on the given list, given the pointer to the start of the  *	specification, a Lst on which to place the nodes, and a context  *	in which to expand variables.  *  * Results:  *	TRUE if it was a valid specification. The linePtr is updated  *	to point to the first non-space after the archive spec. The  *	nodes for the members are placed on the given list.  *  * Side Effects:  *	Some nodes may be created. The given list is extended.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|Boolean
name|Arch_ParseArchive
parameter_list|(
name|char
modifier|*
modifier|*
name|linePtr
parameter_list|,
name|Lst
modifier|*
name|nodeLst
parameter_list|,
name|GNode
modifier|*
name|ctxt
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* Pointer into line */
name|GNode
modifier|*
name|gn
decl_stmt|;
comment|/* New node */
name|char
modifier|*
name|libName
decl_stmt|;
comment|/* Library-part of specification */
name|char
modifier|*
name|memName
decl_stmt|;
comment|/* Member-part of specification */
name|char
modifier|*
name|nameBuf
decl_stmt|;
comment|/* temporary place for node name */
name|char
name|saveChar
decl_stmt|;
comment|/* Ending delimiter of member-name */
name|Boolean
name|subLibName
decl_stmt|;
comment|/* TRUE if libName should have/had 				 * variable substitution performed on it */
name|libName
operator|=
operator|*
name|linePtr
expr_stmt|;
name|subLibName
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|libName
init|;
operator|*
name|cp
operator|!=
literal|'('
operator|&&
operator|*
name|cp
operator|!=
literal|'\0'
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'$'
condition|)
block|{
comment|/* 			 * Variable spec, so call the Var module to parse the 			 * puppy so we can safely advance beyond it... 			 */
name|size_t
name|length
init|=
literal|0
decl_stmt|;
name|Boolean
name|freeIt
decl_stmt|;
name|char
modifier|*
name|result
decl_stmt|;
name|result
operator|=
name|Var_Parse
argument_list|(
name|cp
argument_list|,
name|ctxt
argument_list|,
name|TRUE
argument_list|,
operator|&
name|length
argument_list|,
operator|&
name|freeIt
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|var_Error
condition|)
block|{
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|subLibName
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|freeIt
condition|)
block|{
name|free
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
name|cp
operator|+=
name|length
operator|-
literal|1
expr_stmt|;
block|}
block|}
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|subLibName
condition|)
block|{
name|libName
operator|=
name|Buf_Peel
argument_list|(
name|Var_Subst
argument_list|(
name|libName
argument_list|,
name|ctxt
argument_list|,
name|TRUE
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 		 * First skip to the start of the member's name, mark that 		 * place and skip to the end of it (either white-space or 		 * a close paren). 		 */
comment|/* 		 * TRUE if need to substitute in memName 		 */
name|Boolean
name|doSubst
init|=
name|FALSE
decl_stmt|;
while|while
condition|(
operator|*
name|cp
operator|!=
literal|'\0'
operator|&&
operator|*
name|cp
operator|!=
literal|')'
operator|&&
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cp
argument_list|)
condition|)
block|{
name|cp
operator|++
expr_stmt|;
block|}
name|memName
operator|=
name|cp
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|!=
literal|'\0'
operator|&&
operator|*
name|cp
operator|!=
literal|')'
operator|&&
operator|!
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cp
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'$'
condition|)
block|{
comment|/* 				 * Variable spec, so call the Var module to 				 * parse the puppy so we can safely advance 				 * beyond it... 				 */
name|size_t
name|length
init|=
literal|0
decl_stmt|;
name|Boolean
name|freeIt
decl_stmt|;
name|char
modifier|*
name|result
decl_stmt|;
name|result
operator|=
name|Var_Parse
argument_list|(
name|cp
argument_list|,
name|ctxt
argument_list|,
name|TRUE
argument_list|,
operator|&
name|length
argument_list|,
operator|&
name|freeIt
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|var_Error
condition|)
block|{
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|doSubst
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|freeIt
condition|)
block|{
name|free
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
name|cp
operator|+=
name|length
expr_stmt|;
block|}
else|else
block|{
name|cp
operator|++
expr_stmt|;
block|}
block|}
comment|/* 		 * If the specification ends without a closing parenthesis, 		 * chances are there's something wrong (like a missing 		 * backslash), so it's better to return failure than allow 		 * such things to happen 		 */
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
condition|)
block|{
name|printf
argument_list|(
literal|"No closing parenthesis in archive "
literal|"specification\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
comment|/* 		 * If we didn't move anywhere, we must be done 		 */
if|if
condition|(
name|cp
operator|==
name|memName
condition|)
block|{
break|break;
block|}
name|saveChar
operator|=
operator|*
name|cp
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
comment|/* 		 * XXX: This should be taken care of intelligently by 		 * SuffExpandChildren, both for the archive and the member 		 * portions. 		 */
comment|/* 		 * If member contains variables, try and substitute for them. 		 * This will slow down archive specs with dynamic sources, of 		 * course, since we'll be (non-)substituting them three times, 		 * but them's the breaks -- we need to do this since 		 * SuffExpandChildren calls us, otherwise we could assume the 		 * thing would be taken care of later. 		 */
if|if
condition|(
name|doSubst
condition|)
block|{
name|char
modifier|*
name|buf
decl_stmt|;
name|char
modifier|*
name|sacrifice
decl_stmt|;
name|char
modifier|*
name|oldMemName
init|=
name|memName
decl_stmt|;
name|size_t
name|sz
decl_stmt|;
name|Buffer
modifier|*
name|buf1
decl_stmt|;
comment|/* 			 * Now form an archive spec and recurse to deal with 			 * nested variables and multi-word variable values.... 			 * The results are just placed at the end of the 			 * nodeLst we're returning. 			 */
name|buf1
operator|=
name|Var_Subst
argument_list|(
name|memName
argument_list|,
name|ctxt
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|memName
operator|=
name|Buf_Data
argument_list|(
name|buf1
argument_list|)
expr_stmt|;
name|sz
operator|=
name|strlen
argument_list|(
name|memName
argument_list|)
operator|+
name|strlen
argument_list|(
name|libName
argument_list|)
operator|+
literal|3
expr_stmt|;
name|buf
operator|=
name|emalloc
argument_list|(
name|sz
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
name|sz
argument_list|,
literal|"%s(%s)"
argument_list|,
name|libName
argument_list|,
name|memName
argument_list|)
expr_stmt|;
name|sacrifice
operator|=
name|buf
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|memName
argument_list|,
literal|'$'
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|memName
argument_list|,
name|oldMemName
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 				 * Must contain dynamic sources, so we can't 				 * deal with it now. 				 * Just create an ARCHV node for the thing and 				 * let SuffExpandChildren handle it... 				 */
name|gn
operator|=
name|Targ_FindNode
argument_list|(
name|buf
argument_list|,
name|TARG_CREATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|gn
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|Buf_Destroy
argument_list|(
name|buf1
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|gn
operator|->
name|type
operator||=
name|OP_ARCHV
expr_stmt|;
name|Lst_AtEnd
argument_list|(
name|nodeLst
argument_list|,
operator|(
name|void
operator|*
operator|)
name|gn
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|Arch_ParseArchive
argument_list|(
operator|&
name|sacrifice
argument_list|,
name|nodeLst
argument_list|,
name|ctxt
argument_list|)
condition|)
block|{
comment|/* 				 * Error in nested call -- free buffer and 				 * return FALSE ourselves. 				 */
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|Buf_Destroy
argument_list|(
name|buf1
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
comment|/* Free buffer and continue with our work. */
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|Buf_Destroy
argument_list|(
name|buf1
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Dir_HasWildcards
argument_list|(
name|memName
argument_list|)
condition|)
block|{
name|Lst
name|members
init|=
name|Lst_Initializer
argument_list|(
name|members
argument_list|)
decl_stmt|;
name|char
modifier|*
name|member
decl_stmt|;
name|size_t
name|sz
init|=
name|MAXPATHLEN
decl_stmt|;
name|size_t
name|nsz
decl_stmt|;
name|nameBuf
operator|=
name|emalloc
argument_list|(
name|sz
argument_list|)
expr_stmt|;
name|Path_Expand
argument_list|(
name|memName
argument_list|,
operator|&
name|dirSearchPath
argument_list|,
operator|&
name|members
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|Lst_IsEmpty
argument_list|(
operator|&
name|members
argument_list|)
condition|)
block|{
name|member
operator|=
name|Lst_DeQueue
argument_list|(
operator|&
name|members
argument_list|)
expr_stmt|;
name|nsz
operator|=
name|strlen
argument_list|(
name|libName
argument_list|)
operator|+
name|strlen
argument_list|(
name|member
argument_list|)
operator|+
literal|3
expr_stmt|;
if|if
condition|(
name|nsz
operator|>
name|sz
condition|)
block|{
name|sz
operator|=
name|nsz
operator|*
literal|2
expr_stmt|;
name|nameBuf
operator|=
name|erealloc
argument_list|(
name|nameBuf
argument_list|,
name|sz
argument_list|)
expr_stmt|;
block|}
name|snprintf
argument_list|(
name|nameBuf
argument_list|,
name|sz
argument_list|,
literal|"%s(%s)"
argument_list|,
name|libName
argument_list|,
name|member
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|member
argument_list|)
expr_stmt|;
name|gn
operator|=
name|Targ_FindNode
argument_list|(
name|nameBuf
argument_list|,
name|TARG_CREATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|gn
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|nameBuf
argument_list|)
expr_stmt|;
comment|/* XXXHB Lst_Destroy(&members) */
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
comment|/* 				 * We've found the node, but have to make sure 				 * the rest of the world knows it's an archive 				 * member, without having to constantly check 				 * for parentheses, so we type the thing with 				 * the OP_ARCHV bit before we place it on the 				 * end of the provided list. 				 */
name|gn
operator|->
name|type
operator||=
name|OP_ARCHV
expr_stmt|;
name|Lst_AtEnd
argument_list|(
name|nodeLst
argument_list|,
name|gn
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|nameBuf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|size_t
name|sz
init|=
name|strlen
argument_list|(
name|libName
argument_list|)
operator|+
name|strlen
argument_list|(
name|memName
argument_list|)
operator|+
literal|3
decl_stmt|;
name|nameBuf
operator|=
name|emalloc
argument_list|(
name|sz
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|nameBuf
argument_list|,
name|sz
argument_list|,
literal|"%s(%s)"
argument_list|,
name|libName
argument_list|,
name|memName
argument_list|)
expr_stmt|;
name|gn
operator|=
name|Targ_FindNode
argument_list|(
name|nameBuf
argument_list|,
name|TARG_CREATE
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|nameBuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|gn
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
comment|/* 			 * We've found the node, but have to make sure the 			 * rest of the world knows it's an archive member, 			 * without having to constantly check for parentheses, 			 * so we type the thing with the OP_ARCHV bit before 			 * we place it on the end of the provided list. 			 */
name|gn
operator|->
name|type
operator||=
name|OP_ARCHV
expr_stmt|;
name|Lst_AtEnd
argument_list|(
name|nodeLst
argument_list|,
name|gn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|doSubst
condition|)
block|{
name|free
argument_list|(
name|memName
argument_list|)
expr_stmt|;
block|}
operator|*
name|cp
operator|=
name|saveChar
expr_stmt|;
block|}
comment|/* 	 * If substituted libName, free it now, since we need it no longer. 	 */
if|if
condition|(
name|subLibName
condition|)
block|{
name|free
argument_list|(
name|libName
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * We promised the pointer would be set up at the next non-space, so 	 * we must advance cp there before setting *linePtr... (note that on 	 * entrance to the loop, cp is guaranteed to point at a ')') 	 */
do|do
block|{
name|cp
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|cp
operator|!=
literal|'\0'
operator|&&
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cp
argument_list|)
condition|)
do|;
operator|*
name|linePtr
operator|=
name|cp
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Close an archive file an free all resources  */
end_comment

begin_function
specifier|static
name|void
name|ArchArchiveClose
parameter_list|(
name|struct
name|arfile
modifier|*
name|ar
parameter_list|)
block|{
if|if
condition|(
name|ar
operator|->
name|nametab
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|ar
operator|->
name|nametab
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ar
operator|->
name|member
argument_list|)
expr_stmt|;
if|if
condition|(
name|ar
operator|->
name|fp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|fclose
argument_list|(
name|ar
operator|->
name|fp
argument_list|)
operator|==
name|EOF
condition|)
name|ArchError
argument_list|(
operator|(
literal|"%s: close error"
operator|,
name|ar
operator|->
name|fname
operator|)
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|ar
operator|->
name|fname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ar
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Open an archive file.  */
end_comment

begin_function
specifier|static
name|struct
name|arfile
modifier|*
name|ArchArchiveOpen
parameter_list|(
specifier|const
name|char
modifier|*
name|archive
parameter_list|,
specifier|const
name|char
modifier|*
name|mode
parameter_list|)
block|{
name|struct
name|arfile
modifier|*
name|ar
decl_stmt|;
name|char
name|magic
index|[
name|SARMAG
index|]
decl_stmt|;
name|ar
operator|=
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ar
argument_list|)
argument_list|)
expr_stmt|;
name|ar
operator|->
name|fname
operator|=
name|estrdup
argument_list|(
name|archive
argument_list|)
expr_stmt|;
name|ar
operator|->
name|mlen
operator|=
literal|100
expr_stmt|;
name|ar
operator|->
name|member
operator|=
name|emalloc
argument_list|(
name|ar
operator|->
name|mlen
argument_list|)
expr_stmt|;
name|ar
operator|->
name|nametab
operator|=
name|NULL
expr_stmt|;
name|ar
operator|->
name|nametablen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|ar
operator|->
name|fp
operator|=
name|fopen
argument_list|(
name|ar
operator|->
name|fname
argument_list|,
name|mode
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|DEBUGM
argument_list|(
name|ARCH
argument_list|,
operator|(
literal|"%s"
operator|,
name|ar
operator|->
name|fname
operator|)
argument_list|)
expr_stmt|;
name|ArchArchiveClose
argument_list|(
name|ar
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* read MAGIC */
if|if
condition|(
name|fread
argument_list|(
name|magic
argument_list|,
name|SARMAG
argument_list|,
literal|1
argument_list|,
name|ar
operator|->
name|fp
argument_list|)
operator|!=
literal|1
operator|||
name|strncmp
argument_list|(
name|magic
argument_list|,
name|ARMAG
argument_list|,
name|SARMAG
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ArchError
argument_list|(
operator|(
literal|"%s: bad archive magic\n"
operator|,
name|ar
operator|->
name|fname
operator|)
argument_list|)
expr_stmt|;
name|ArchArchiveClose
argument_list|(
name|ar
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|ar
operator|->
name|pos
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|ar
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read the next header from the archive. The return value will be +1 if  * the header is read successfully, 0 on EOF and -1 if an error happend.  * On a successful return sname contains the truncated member name and  * member the full name. hdr contains the member header. For the symbol table  * names of length 0 are returned. The entry for the file name table is never  * returned.  */
end_comment

begin_function
specifier|static
name|int
name|ArchArchiveNext
parameter_list|(
name|struct
name|arfile
modifier|*
name|ar
parameter_list|)
block|{
name|char
modifier|*
name|end
decl_stmt|;
name|int
name|have_long_name
decl_stmt|;
name|u_long
name|offs
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
name|size_t
name|ret
decl_stmt|;
name|char
name|buf
index|[
name|MAX
argument_list|(
sizeof|sizeof
argument_list|(
name|ar
operator|->
name|hdr
operator|.
name|ar_size
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|ar
operator|->
name|hdr
operator|.
name|ar_date
argument_list|)
argument_list|)
operator|+
literal|1
index|]
decl_stmt|;
name|next
label|:
comment|/* 	 * Seek to the next header. 	 */
if|if
condition|(
name|ar
operator|->
name|pos
operator|==
literal|0
condition|)
block|{
name|ar
operator|->
name|pos
operator|=
name|SARMAG
expr_stmt|;
block|}
else|else
block|{
name|ar
operator|->
name|pos
operator|+=
sizeof|sizeof
argument_list|(
name|ar
operator|->
name|hdr
argument_list|)
operator|+
name|ar
operator|->
name|size
expr_stmt|;
if|if
condition|(
name|ar
operator|->
name|size
operator|%
literal|2
operator|==
literal|1
condition|)
name|ar
operator|->
name|pos
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|fseeko
argument_list|(
name|ar
operator|->
name|fp
argument_list|,
name|ar
operator|->
name|pos
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|ArchError
argument_list|(
operator|(
literal|"%s: cannot seek to %jd: %s"
operator|,
name|ar
operator|->
name|fname
operator|,
operator|(
name|intmax_t
operator|)
name|ar
operator|->
name|pos
operator|,
name|strerror
argument_list|(
name|errno
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * Read next member header 	 */
name|ret
operator|=
name|fread
argument_list|(
operator|&
name|ar
operator|->
name|hdr
argument_list|,
sizeof|sizeof
argument_list|(
name|ar
operator|->
name|hdr
argument_list|)
argument_list|,
literal|1
argument_list|,
name|ar
operator|->
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|1
condition|)
block|{
if|if
condition|(
name|feof
argument_list|(
name|ar
operator|->
name|fp
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|ArchError
argument_list|(
operator|(
literal|"%s: error reading member header: %s"
operator|,
name|ar
operator|->
name|fname
operator|,
name|strerror
argument_list|(
name|errno
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|ar
operator|->
name|hdr
operator|.
name|ar_fmag
argument_list|,
name|ARFMAG
argument_list|,
sizeof|sizeof
argument_list|(
name|ar
operator|->
name|hdr
operator|.
name|ar_fmag
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ArchError
argument_list|(
operator|(
literal|"%s: bad entry magic"
operator|,
name|ar
operator|->
name|fname
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * looks like a member - get name by stripping trailing spaces 	 * and NUL terminating. 	 */
name|strlcpy
argument_list|(
name|ar
operator|->
name|sname
argument_list|,
name|ar
operator|->
name|hdr
operator|.
name|ar_name
argument_list|,
name|AR_NAMSIZ
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|ptr
operator|=
name|ar
operator|->
name|sname
operator|+
name|AR_NAMSIZ
init|;
name|ptr
operator|>
name|ar
operator|->
name|sname
condition|;
name|ptr
operator|--
control|)
if|if
condition|(
name|ptr
index|[
operator|-
literal|1
index|]
operator|!=
literal|' '
condition|)
break|break;
operator|*
name|ptr
operator|=
literal|'\0'
expr_stmt|;
comment|/* 	 * Parse the size. All entries need to have a size. Be careful 	 * to not allow buffer overruns. 	 */
name|strlcpy
argument_list|(
name|buf
argument_list|,
name|ar
operator|->
name|hdr
operator|.
name|ar_size
argument_list|,
sizeof|sizeof
argument_list|(
name|ar
operator|->
name|hdr
operator|.
name|ar_size
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|ar
operator|->
name|size
operator|=
name|strtoumax
argument_list|(
name|buf
argument_list|,
operator|&
name|end
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
literal|0
operator|||
name|strspn
argument_list|(
name|end
argument_list|,
literal|" "
argument_list|)
operator|!=
name|strlen
argument_list|(
name|end
argument_list|)
condition|)
block|{
name|ArchError
argument_list|(
operator|(
literal|"%s: bad size format in archive '%s'"
operator|,
name|ar
operator|->
name|fname
operator|,
name|buf
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * Look for the extended name table. Do this before parsing 	 * the date because this table doesn't need a date. 	 */
if|if
condition|(
name|strcmp
argument_list|(
name|ar
operator|->
name|sname
argument_list|,
name|BSD_NAMEMAG
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|ar
operator|->
name|sname
argument_list|,
name|SVR4_NAMEMAG
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* filename table - read it in */
name|ar
operator|->
name|nametablen
operator|=
name|ar
operator|->
name|size
expr_stmt|;
name|ar
operator|->
name|nametab
operator|=
name|emalloc
argument_list|(
name|ar
operator|->
name|nametablen
argument_list|)
expr_stmt|;
name|ret
operator|=
name|fread
argument_list|(
name|ar
operator|->
name|nametab
argument_list|,
literal|1
argument_list|,
name|ar
operator|->
name|nametablen
argument_list|,
name|ar
operator|->
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|ar
operator|->
name|nametablen
condition|)
block|{
if|if
condition|(
name|ferror
argument_list|(
name|ar
operator|->
name|fp
argument_list|)
condition|)
block|{
name|ArchError
argument_list|(
operator|(
literal|"%s: cannot read nametab: %s"
operator|,
name|ar
operator|->
name|fname
operator|,
name|strerror
argument_list|(
name|errno
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ArchError
argument_list|(
operator|(
literal|"%s: cannot read nametab: "
literal|"short read"
operator|,
name|ar
operator|->
name|fname
operator|,
name|strerror
argument_list|(
name|errno
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 		 * NUL terminate the entries. Entries are \n terminated 		 * and may have a trailing / or \. 		 */
name|ptr
operator|=
name|ar
operator|->
name|nametab
expr_stmt|;
while|while
condition|(
name|ptr
operator|<
name|ar
operator|->
name|nametab
operator|+
name|ar
operator|->
name|nametablen
condition|)
block|{
if|if
condition|(
operator|*
name|ptr
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|ptr
index|[
operator|-
literal|1
index|]
operator|==
literal|'/'
operator|||
name|ptr
index|[
operator|-
literal|1
index|]
operator|==
literal|'\\'
condition|)
name|ptr
index|[
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|ptr
operator|=
literal|'\0'
expr_stmt|;
block|}
name|ptr
operator|++
expr_stmt|;
block|}
comment|/* get next archive entry */
goto|goto
name|next
goto|;
block|}
comment|/* 	 * Now parse the modification date. Be careful to not overrun 	 * buffers. 	 */
name|strlcpy
argument_list|(
name|buf
argument_list|,
name|ar
operator|->
name|hdr
operator|.
name|ar_date
argument_list|,
sizeof|sizeof
argument_list|(
name|ar
operator|->
name|hdr
operator|.
name|ar_date
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|ar
operator|->
name|time
operator|=
operator|(
name|int64_t
operator|)
name|strtoll
argument_list|(
name|buf
argument_list|,
operator|&
name|end
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
literal|0
operator|||
name|strspn
argument_list|(
name|end
argument_list|,
literal|" "
argument_list|)
operator|!=
name|strlen
argument_list|(
name|end
argument_list|)
condition|)
block|{
name|ArchError
argument_list|(
operator|(
literal|"%s: bad date format in archive '%s'"
operator|,
name|ar
operator|->
name|fname
operator|,
name|buf
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * Now check for the symbol table. This should really be the first 	 * entry, but we don't check this. 	 */
if|if
condition|(
name|strcmp
argument_list|(
name|ar
operator|->
name|sname
argument_list|,
name|BSD_RANLIBMAG
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|ar
operator|->
name|sname
argument_list|,
name|SVR4_RANLIBMAG
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* symbol table - return a zero length name */
name|ar
operator|->
name|member
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|ar
operator|->
name|sname
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|have_long_name
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Look whether this is a long name. There are several variants 	 * of long names: 	 *	"#1/12           "	- 12 length of following filename 	 *	"/17             "	- index into name table 	 *	" 17             "	- index into name table 	 * Note that in the last case we must also check that there is no 	 * slash in the name because of filenames with leading spaces: 	 *	" 777.o/           "	- filename 777.o 	 */
if|if
condition|(
name|ar
operator|->
name|sname
index|[
literal|0
index|]
operator|==
literal|'/'
operator|||
operator|(
name|ar
operator|->
name|sname
index|[
literal|0
index|]
operator|==
literal|' '
operator|&&
name|strchr
argument_list|(
name|ar
operator|->
name|sname
argument_list|,
literal|'/'
argument_list|)
operator|==
name|NULL
operator|)
condition|)
block|{
comment|/* SVR4 extended name */
name|errno
operator|=
literal|0
expr_stmt|;
name|offs
operator|=
name|strtoul
argument_list|(
name|ar
operator|->
name|sname
operator|+
literal|1
argument_list|,
operator|&
name|end
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
literal|0
operator|||
operator|*
name|end
operator|!=
literal|'\0'
operator|||
name|offs
operator|>=
name|ar
operator|->
name|nametablen
operator|||
name|end
operator|==
name|ar
operator|->
name|sname
operator|+
literal|1
condition|)
block|{
name|ArchError
argument_list|(
operator|(
literal|"%s: bad extended name '%s'"
operator|,
name|ar
operator|->
name|fname
operator|,
name|ar
operator|->
name|sname
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* fetch the name */
if|if
condition|(
name|ar
operator|->
name|mlen
operator|<=
name|strlen
argument_list|(
name|ar
operator|->
name|nametab
operator|+
name|offs
argument_list|)
condition|)
block|{
name|ar
operator|->
name|mlen
operator|=
name|strlen
argument_list|(
name|ar
operator|->
name|nametab
operator|+
name|offs
argument_list|)
operator|+
literal|1
expr_stmt|;
name|ar
operator|->
name|member
operator|=
name|erealloc
argument_list|(
name|ar
operator|->
name|member
argument_list|,
name|ar
operator|->
name|mlen
argument_list|)
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|ar
operator|->
name|member
argument_list|,
name|ar
operator|->
name|nametab
operator|+
name|offs
argument_list|)
expr_stmt|;
name|have_long_name
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|ar
operator|->
name|sname
argument_list|,
name|BSD_EXT1
argument_list|,
name|BSD_EXT1LEN
argument_list|)
operator|==
literal|0
operator|&&
name|isdigit
argument_list|(
name|ar
operator|->
name|sname
index|[
name|BSD_EXT1LEN
index|]
argument_list|)
condition|)
block|{
comment|/* BSD4.4 extended name */
name|errno
operator|=
literal|0
expr_stmt|;
name|offs
operator|=
name|strtoul
argument_list|(
name|ar
operator|->
name|sname
operator|+
name|BSD_EXT1LEN
argument_list|,
operator|&
name|end
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
literal|0
operator|||
operator|*
name|end
operator|!=
literal|'\0'
operator|||
name|end
operator|==
name|ar
operator|->
name|sname
operator|+
name|BSD_EXT1LEN
condition|)
block|{
name|ArchError
argument_list|(
operator|(
literal|"%s: bad extended name '%s'"
operator|,
name|ar
operator|->
name|fname
operator|,
name|ar
operator|->
name|sname
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* read it from the archive */
if|if
condition|(
name|ar
operator|->
name|mlen
operator|<=
name|offs
condition|)
block|{
name|ar
operator|->
name|mlen
operator|=
name|offs
operator|+
literal|1
expr_stmt|;
name|ar
operator|->
name|member
operator|=
name|erealloc
argument_list|(
name|ar
operator|->
name|member
argument_list|,
name|ar
operator|->
name|mlen
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
name|fread
argument_list|(
name|ar
operator|->
name|member
argument_list|,
literal|1
argument_list|,
name|offs
argument_list|,
name|ar
operator|->
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|offs
condition|)
block|{
if|if
condition|(
name|ferror
argument_list|(
name|ar
operator|->
name|fp
argument_list|)
condition|)
block|{
name|ArchError
argument_list|(
operator|(
literal|"%s: reading extended name: %s"
operator|,
name|ar
operator|->
name|fname
operator|,
name|strerror
argument_list|(
name|errno
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ArchError
argument_list|(
operator|(
literal|"%s: reading extended name: "
literal|"short read"
operator|,
name|ar
operator|->
name|fname
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|ar
operator|->
name|member
index|[
name|offs
index|]
operator|=
literal|'\0'
expr_stmt|;
name|have_long_name
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 	 * Now remove the trailing slash that Svr4 puts at 	 * the end of the member name to support trailing spaces in names. 	 */
if|if
condition|(
name|ptr
operator|>
name|ar
operator|->
name|sname
operator|&&
name|ptr
index|[
operator|-
literal|1
index|]
operator|==
literal|'/'
condition|)
operator|*
operator|--
name|ptr
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
name|have_long_name
condition|)
block|{
if|if
condition|(
name|strlen
argument_list|(
name|ar
operator|->
name|sname
argument_list|)
operator|>=
name|ar
operator|->
name|mlen
condition|)
block|{
name|ar
operator|->
name|mlen
operator|=
name|strlen
argument_list|(
name|ar
operator|->
name|sname
argument_list|)
operator|+
literal|1
expr_stmt|;
name|ar
operator|->
name|member
operator|=
name|erealloc
argument_list|(
name|ar
operator|->
name|member
argument_list|,
name|ar
operator|->
name|mlen
argument_list|)
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|ar
operator|->
name|member
argument_list|,
name|ar
operator|->
name|sname
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Touch the current archive member by writing a new header with an  * updated timestamp. The return value is 0 for success and -1 for errors.  */
end_comment

begin_function
specifier|static
name|int
name|ArchArchiveTouch
parameter_list|(
name|struct
name|arfile
modifier|*
name|ar
parameter_list|,
name|int64_t
name|ts
parameter_list|)
block|{
comment|/* seek to our header */
if|if
condition|(
name|fseeko
argument_list|(
name|ar
operator|->
name|fp
argument_list|,
name|ar
operator|->
name|pos
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|ArchError
argument_list|(
operator|(
literal|"%s: cannot seek to %jd: %s"
operator|,
name|ar
operator|->
name|fname
operator|,
operator|(
name|intmax_t
operator|)
name|ar
operator|->
name|pos
operator|,
name|strerror
argument_list|(
name|errno
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * change timestamp, be sure to not NUL-terminated it, but 	 * to fill with spaces. 	 */
name|snprintf
argument_list|(
name|ar
operator|->
name|hdr
operator|.
name|ar_date
argument_list|,
sizeof|sizeof
argument_list|(
name|ar
operator|->
name|hdr
operator|.
name|ar_date
argument_list|)
argument_list|,
literal|"%jd"
argument_list|,
operator|(
name|intmax_t
operator|)
name|ts
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|ar
operator|->
name|hdr
operator|.
name|ar_date
operator|+
name|strlen
argument_list|(
name|ar
operator|->
name|hdr
operator|.
name|ar_date
argument_list|)
argument_list|,
literal|' '
argument_list|,
sizeof|sizeof
argument_list|(
name|ar
operator|->
name|hdr
operator|.
name|ar_date
argument_list|)
operator|-
name|strlen
argument_list|(
name|ar
operator|->
name|hdr
operator|.
name|ar_date
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fwrite
argument_list|(
operator|&
name|ar
operator|->
name|hdr
argument_list|,
sizeof|sizeof
argument_list|(
name|ar
operator|->
name|hdr
argument_list|)
argument_list|,
literal|1
argument_list|,
name|ar
operator|->
name|fp
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|ArchError
argument_list|(
operator|(
literal|"%s: cannot touch: %s"
operator|,
name|ar
operator|->
name|fname
operator|,
name|strerror
argument_list|(
name|errno
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * ArchFindMember --  *	Locate a member of an archive, given the path of the archive and  *	the path of the desired member. If the archive is to be modified,  *	the mode should be "r+", if not, it should be "r".  The archive  *	file is returned positioned at the correct header.  *  * Results:  *	A struct arfile *, opened for reading and, possibly writing,  *	positioned at the member's header, or NULL if the member was  *	nonexistent.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|struct
name|arfile
modifier|*
name|ArchFindMember
parameter_list|(
specifier|const
name|char
modifier|*
name|archive
parameter_list|,
specifier|const
name|char
modifier|*
name|member
parameter_list|,
specifier|const
name|char
modifier|*
name|mode
parameter_list|)
block|{
name|struct
name|arfile
modifier|*
name|ar
decl_stmt|;
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* Useful character pointer */
if|if
condition|(
operator|(
name|ar
operator|=
name|ArchArchiveOpen
argument_list|(
name|archive
argument_list|,
name|mode
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* 	 * Because of space constraints and similar things, files are archived 	 * using their final path components, not the entire thing, so we need 	 * to point 'member' to the final component, if there is one, to make 	 * the comparisons easier... 	 */
if|if
condition|(
name|member
operator|!=
name|NULL
condition|)
block|{
name|cp
operator|=
name|strrchr
argument_list|(
name|member
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
block|{
name|member
operator|=
name|cp
operator|+
literal|1
expr_stmt|;
block|}
block|}
while|while
condition|(
name|ArchArchiveNext
argument_list|(
name|ar
argument_list|)
operator|>
literal|0
condition|)
block|{
comment|/* 		 * When comparing there are actually three cases: 		 * (1) the name fits into the limit og af_name, 		 * (2) the name is longer and the archive supports long names, 		 * (3) the name is longer and the archive doesn't support long 		 * names. 		 * Because we don't know whether the archive supports long 		 * names or not we need to be carefull. 		 */
if|if
condition|(
name|member
operator|==
name|NULL
condition|)
block|{
comment|/* special case - symbol table */
if|if
condition|(
name|ar
operator|->
name|member
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
return|return
operator|(
name|ar
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|strlen
argument_list|(
name|member
argument_list|)
operator|<=
name|AR_NAMSIZ
condition|)
block|{
comment|/* case (1) */
if|if
condition|(
name|strcmp
argument_list|(
name|ar
operator|->
name|member
argument_list|,
name|member
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ar
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|ar
operator|->
name|member
argument_list|,
name|member
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* case (3) */
return|return
operator|(
name|ar
operator|)
return|;
block|}
else|else
block|{
comment|/* case (2) */
if|if
condition|(
name|strlen
argument_list|(
name|ar
operator|->
name|member
argument_list|)
operator|==
name|AR_NAMSIZ
operator|&&
name|strncmp
argument_list|(
name|member
argument_list|,
name|ar
operator|->
name|member
argument_list|,
name|AR_NAMSIZ
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ar
operator|)
return|;
block|}
block|}
comment|/* not found */
name|ArchArchiveClose
argument_list|(
name|ar
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * ArchStatMember --  *	Locate a member of an archive, given the path of the archive and  *	the path of the desired member, and a boolean representing whether  *	or not the archive should be hashed (if not already hashed).  *  * Results:  *	A pointer to the current struct ar_hdr structure for the member. Note  *	That no position is returned, so this is not useful for touching  *	archive members. This is mostly because we have no assurances that  *	The archive will remain constant after we read all the headers, so  *	there's not much point in remembering the position...  *  * Side Effects:  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int64_t
name|ArchStatMember
parameter_list|(
specifier|const
name|char
modifier|*
name|archive
parameter_list|,
specifier|const
name|char
modifier|*
name|member
parameter_list|,
name|Boolean
name|hash
parameter_list|)
block|{
name|struct
name|arfile
modifier|*
name|arf
decl_stmt|;
name|int64_t
name|ret
decl_stmt|;
name|int
name|t
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* Useful character pointer */
name|Arch
modifier|*
name|ar
decl_stmt|;
comment|/* Archive descriptor */
name|Hash_Entry
modifier|*
name|he
decl_stmt|;
comment|/* Entry containing member's description */
name|char
name|copy
index|[
name|AR_NAMSIZ
operator|+
literal|1
index|]
decl_stmt|;
comment|/* 	 * Because of space constraints and similar things, files are archived 	 * using their final path components, not the entire thing, so we need 	 * to point 'member' to the final component, if there is one, to make 	 * the comparisons easier... 	 */
if|if
condition|(
name|member
operator|!=
name|NULL
condition|)
block|{
name|cp
operator|=
name|strrchr
argument_list|(
name|member
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
name|member
operator|=
name|cp
operator|+
literal|1
expr_stmt|;
block|}
name|TAILQ_FOREACH
argument_list|(
argument|ar
argument_list|,
argument|&archives
argument_list|,
argument|link
argument_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|archive
argument_list|,
name|ar
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|ar
operator|==
name|NULL
condition|)
block|{
comment|/* archive not found */
if|if
condition|(
operator|!
name|hash
condition|)
block|{
comment|/* 			 * Caller doesn't want the thing hashed, just use 			 * ArchFindMember to read the header for the member 			 * out and close down the stream again. 			 */
name|arf
operator|=
name|ArchFindMember
argument_list|(
name|archive
argument_list|,
name|member
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|arf
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|INT64_MIN
operator|)
return|;
block|}
name|ret
operator|=
name|arf
operator|->
name|time
expr_stmt|;
name|ArchArchiveClose
argument_list|(
name|arf
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
comment|/* 		 * We don't have this archive on the list yet, so we want to 		 * find out everything that's in it and cache it so we can get 		 * at it quickly. 		 */
name|arf
operator|=
name|ArchArchiveOpen
argument_list|(
name|archive
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|arf
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|INT64_MIN
operator|)
return|;
block|}
comment|/* create archive data structure */
name|ar
operator|=
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ar
argument_list|)
argument_list|)
expr_stmt|;
name|ar
operator|->
name|name
operator|=
name|estrdup
argument_list|(
name|archive
argument_list|)
expr_stmt|;
name|Hash_InitTable
argument_list|(
operator|&
name|ar
operator|->
name|members
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|t
operator|=
name|ArchArchiveNext
argument_list|(
name|arf
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|he
operator|=
name|Hash_CreateEntry
argument_list|(
operator|&
name|ar
operator|->
name|members
argument_list|,
name|arf
operator|->
name|member
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|Hash_SetValue
argument_list|(
name|he
argument_list|,
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|int64_t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|*
operator|(
name|int64_t
operator|*
operator|)
name|Hash_GetValue
argument_list|(
name|he
argument_list|)
operator|=
name|arf
operator|->
name|time
expr_stmt|;
block|}
name|ArchArchiveClose
argument_list|(
name|arf
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|<
literal|0
condition|)
block|{
comment|/* error happend - throw away everything */
name|Hash_DeleteTable
argument_list|(
operator|&
name|ar
operator|->
name|members
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ar
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ar
argument_list|)
expr_stmt|;
return|return
operator|(
name|INT64_MIN
operator|)
return|;
block|}
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|archives
argument_list|,
name|ar
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Now that the archive has been read and cached, we can look into 	 * the hash table to find the desired member's header. 	 */
name|he
operator|=
name|Hash_FindEntry
argument_list|(
operator|&
name|ar
operator|->
name|members
argument_list|,
name|member
argument_list|)
expr_stmt|;
if|if
condition|(
name|he
operator|!=
name|NULL
condition|)
return|return
operator|(
operator|*
operator|(
name|int64_t
operator|*
operator|)
name|Hash_GetValue
argument_list|(
name|he
argument_list|)
operator|)
return|;
if|if
condition|(
name|member
operator|!=
name|NULL
operator|&&
name|strlen
argument_list|(
name|member
argument_list|)
operator|>
name|AR_NAMSIZ
condition|)
block|{
comment|/* Try truncated name */
name|strlcpy
argument_list|(
name|copy
argument_list|,
name|member
argument_list|,
name|AR_NAMSIZ
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|he
operator|=
name|Hash_FindEntry
argument_list|(
operator|&
name|ar
operator|->
name|members
argument_list|,
name|copy
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
return|return
operator|(
operator|*
operator|(
name|int64_t
operator|*
operator|)
name|Hash_GetValue
argument_list|(
name|he
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
name|INT64_MIN
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Arch_Touch --  *	Touch a member of an archive.  *  * Results:  *	The 'time' field of the member's header is updated.  *  * Side Effects:  *	The modification time of the entire archive is also changed.  *	For a library, this could necessitate the re-ranlib'ing of the  *	whole thing.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Arch_Touch
parameter_list|(
name|GNode
modifier|*
name|gn
parameter_list|)
block|{
name|struct
name|arfile
modifier|*
name|ar
decl_stmt|;
name|ar
operator|=
name|ArchFindMember
argument_list|(
name|Var_Value
argument_list|(
name|ARCHIVE
argument_list|,
name|gn
argument_list|)
argument_list|,
name|Var_Value
argument_list|(
name|TARGET
argument_list|,
name|gn
argument_list|)
argument_list|,
literal|"r+"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ar
operator|!=
name|NULL
condition|)
block|{
name|ArchArchiveTouch
argument_list|(
name|ar
argument_list|,
operator|(
name|int64_t
operator|)
name|now
argument_list|)
expr_stmt|;
name|ArchArchiveClose
argument_list|(
name|ar
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Arch_TouchLib --  *	Given a node which represents a library, touch the thing, making  *	sure that the table of contents also is touched.  *  * Results:  *	None.  *  * Side Effects:  *	Both the modification time of the library and of the RANLIBMAG  *	member are set to 'now'.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Arch_TouchLib
parameter_list|(
name|GNode
modifier|*
name|gn
parameter_list|)
block|{
name|struct
name|arfile
modifier|*
name|ar
decl_stmt|;
comment|/* Open archive */
name|struct
name|utimbuf
name|times
decl_stmt|;
comment|/* Times for utime() call */
name|ar
operator|=
name|ArchFindMember
argument_list|(
name|gn
operator|->
name|path
argument_list|,
name|NULL
argument_list|,
literal|"r+"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ar
operator|!=
name|NULL
condition|)
block|{
name|ArchArchiveTouch
argument_list|(
name|ar
argument_list|,
operator|(
name|int64_t
operator|)
name|now
argument_list|)
expr_stmt|;
name|ArchArchiveClose
argument_list|(
name|ar
argument_list|)
expr_stmt|;
name|times
operator|.
name|actime
operator|=
name|times
operator|.
name|modtime
operator|=
name|now
expr_stmt|;
name|utime
argument_list|(
name|gn
operator|->
name|path
argument_list|,
operator|&
name|times
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Arch_MTime --  *	Return the modification time of a member of an archive, given its  *	name.  *  * Results:  *	The modification time(seconds).  *	XXXHB this should be a long.  *  * Side Effects:  *	The mtime field of the given node is filled in with the value  *	returned by the function.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Arch_MTime
parameter_list|(
name|GNode
modifier|*
name|gn
parameter_list|)
block|{
name|int64_t
name|mtime
decl_stmt|;
name|mtime
operator|=
name|ArchStatMember
argument_list|(
name|Var_Value
argument_list|(
name|ARCHIVE
argument_list|,
name|gn
argument_list|)
argument_list|,
name|Var_Value
argument_list|(
name|TARGET
argument_list|,
name|gn
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtime
operator|==
name|INT_MIN
condition|)
block|{
name|mtime
operator|=
literal|0
expr_stmt|;
block|}
name|gn
operator|->
name|mtime
operator|=
operator|(
name|int
operator|)
name|mtime
expr_stmt|;
comment|/* XXX */
return|return
operator|(
name|gn
operator|->
name|mtime
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Arch_MemMTime --  *	Given a non-existent archive member's node, get its modification  *	time from its archived form, if it exists.  *  * Results:  *	The modification time.  *  * Side Effects:  *	The mtime field is filled in.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Arch_MemMTime
parameter_list|(
name|GNode
modifier|*
name|gn
parameter_list|)
block|{
name|LstNode
modifier|*
name|ln
decl_stmt|;
name|GNode
modifier|*
name|pgn
decl_stmt|;
name|char
modifier|*
name|nameStart
decl_stmt|;
name|char
modifier|*
name|nameEnd
decl_stmt|;
for|for
control|(
name|ln
operator|=
name|Lst_First
argument_list|(
operator|&
name|gn
operator|->
name|parents
argument_list|)
init|;
name|ln
operator|!=
name|NULL
condition|;
name|ln
operator|=
name|Lst_Succ
argument_list|(
name|ln
argument_list|)
control|)
block|{
name|pgn
operator|=
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
expr_stmt|;
if|if
condition|(
name|pgn
operator|->
name|type
operator|&
name|OP_ARCHV
condition|)
block|{
comment|/* 			 * If the parent is an archive specification and is 			 * being made and its member's name matches the name of 			 * the node we were given, record the modification time 			 * of the parent in the child. We keep searching its 			 * parents in case some other parent requires this 			 * child to exist... 			 */
name|nameStart
operator|=
name|strchr
argument_list|(
name|pgn
operator|->
name|name
argument_list|,
literal|'('
argument_list|)
operator|+
literal|1
expr_stmt|;
name|nameEnd
operator|=
name|strchr
argument_list|(
name|nameStart
argument_list|,
literal|')'
argument_list|)
expr_stmt|;
if|if
condition|(
name|pgn
operator|->
name|make
operator|&&
name|strncmp
argument_list|(
name|nameStart
argument_list|,
name|gn
operator|->
name|name
argument_list|,
name|nameEnd
operator|-
name|nameStart
argument_list|)
operator|==
literal|0
condition|)
block|{
name|gn
operator|->
name|mtime
operator|=
name|Arch_MTime
argument_list|(
name|pgn
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|pgn
operator|->
name|make
condition|)
block|{
comment|/* 			 * Something which isn't a library depends on the 			 * existence of this target, so it needs to exist. 			 */
name|gn
operator|->
name|mtime
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
name|gn
operator|->
name|mtime
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Arch_FindLib --  *	Search for a named library along the given search path.  *  * Results:  *	None.  *  * Side Effects:  *	The node's 'path' field is set to the found path (including the  *	actual file name, not -l...). If the system can handle the -L  *	flag when linking (or we cannot find the library), we assume that  *	the user has placed the .LIBRARIES variable in the final linking  *	command (or the linker will know where to find it) and set the  *	TARGET variable for this node to be the node's name. Otherwise,  *	we set the TARGET variable to be the full path of the library,  *	as returned by Dir_FindFile.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Arch_FindLib
parameter_list|(
name|GNode
modifier|*
name|gn
parameter_list|,
name|struct
name|Path
modifier|*
name|path
parameter_list|)
block|{
name|char
modifier|*
name|libName
decl_stmt|;
comment|/* file name for archive */
name|size_t
name|sz
decl_stmt|;
name|sz
operator|=
name|strlen
argument_list|(
name|gn
operator|->
name|name
argument_list|)
operator|+
literal|4
expr_stmt|;
name|libName
operator|=
name|emalloc
argument_list|(
name|sz
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|libName
argument_list|,
name|sz
argument_list|,
literal|"lib%s.a"
argument_list|,
operator|&
name|gn
operator|->
name|name
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|gn
operator|->
name|path
operator|=
name|Path_FindFile
argument_list|(
name|libName
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|libName
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LIBRARIES
name|Var_Set
argument_list|(
name|TARGET
argument_list|,
name|gn
operator|->
name|name
argument_list|,
name|gn
argument_list|)
expr_stmt|;
else|#
directive|else
name|Var_Set
argument_list|(
name|TARGET
argument_list|,
name|gn
operator|->
name|path
operator|==
name|NULL
condition|?
name|gn
operator|->
name|name
else|:
name|gn
operator|->
name|path
argument_list|,
name|gn
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* LIBRARIES */
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Arch_LibOODate --  *	Decide if a node with the OP_LIB attribute is out-of-date. Called  *	from Make_OODate to make its life easier, with the library's  *	graph node.  *  *	There are several ways for a library to be out-of-date that are  *	not available to ordinary files. In addition, there are ways  *	that are open to regular files that are not available to  *	libraries. A library that is only used as a source is never  *	considered out-of-date by itself. This does not preclude the  *	library's modification time from making its parent be out-of-date.  *	A library will be considered out-of-date for any of these reasons,  *	given that it is a target on a dependency line somewhere:  *	    Its modification time is less than that of one of its  *		  sources (gn->mtime< gn->cmtime).  *	    Its modification time is greater than the time at which the  *		  make began (i.e. it's been modified in the course  *		  of the make, probably by archiving).  *	    The modification time of one of its sources is greater than  *		  the one of its RANLIBMAG member (i.e. its table of contents  *		  is out-of-date). We don't compare of the archive time  *		  vs. TOC time because they can be too close. In my  *		  opinion we should not bother with the TOC at all since  *		  this is used by 'ar' rules that affect the data contents  *		  of the archive, not by ranlib rules, which affect the  *		  TOC.  *  * Results:  *	TRUE if the library is out-of-date. FALSE otherwise.  *  * Side Effects:  *	The library will be hashed if it hasn't been already.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|Boolean
name|Arch_LibOODate
parameter_list|(
name|GNode
modifier|*
name|gn
parameter_list|)
block|{
name|int64_t
name|mtime
decl_stmt|;
comment|/* The table-of-contents's mod time */
if|if
condition|(
name|OP_NOP
argument_list|(
name|gn
operator|->
name|type
argument_list|)
operator|&&
name|Lst_IsEmpty
argument_list|(
operator|&
name|gn
operator|->
name|children
argument_list|)
condition|)
block|{
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
if|if
condition|(
name|gn
operator|->
name|mtime
operator|>
name|now
operator|||
name|gn
operator|->
name|mtime
operator|<
name|gn
operator|->
name|cmtime
condition|)
block|{
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
name|mtime
operator|=
name|ArchStatMember
argument_list|(
name|gn
operator|->
name|path
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtime
operator|==
name|INT64_MIN
condition|)
block|{
comment|/* 		 * Not found. A library w/o a table of contents is out-of-date 		 */
if|if
condition|(
name|DEBUG
argument_list|(
name|ARCH
argument_list|)
operator|||
name|DEBUG
argument_list|(
name|MAKE
argument_list|)
condition|)
block|{
name|Debug
argument_list|(
literal|"No TOC..."
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
comment|/* XXX choose one. */
if|if
condition|(
name|DEBUG
argument_list|(
name|ARCH
argument_list|)
operator|||
name|DEBUG
argument_list|(
name|MAKE
argument_list|)
condition|)
block|{
name|Debug
argument_list|(
literal|"TOC modified %s..."
argument_list|,
name|Targ_FmtTime
argument_list|(
name|mtime
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|gn
operator|->
name|cmtime
operator|>
name|mtime
operator|)
return|;
block|}
end_function

end_unit

