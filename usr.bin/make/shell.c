begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1988, 1989, 1990, 1993  *	The Regents of the University of California.  All rights reserved.  * Copyright (c) 1988, 1989 by Adam de Boor  * Copyright (c) 1989 by Berkeley Softworks  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Adam de Boor.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"parse.h"
end_include

begin_include
include|#
directive|include
file|"pathnames.h"
end_include

begin_include
include|#
directive|include
file|"shell.h"
end_include

begin_include
include|#
directive|include
file|"util.h"
end_include

begin_comment
comment|/*  * Descriptions for various shells. What the list of builtins should contain  * is debatable: either all builtins or only those which may specified on  * a single line without use of meta-characters. For correct makefiles that  * contain only correct command lines there is no difference. But if a command  * line, for example, is: 'if -foo bar' and there is an executable named 'if'  * in the path, the first possibility would execute that 'if' while in the  * second case the shell would give an error. Histerically only a small  * subset of the builtins and no reserved words where given in the list which  * corresponds roughly to the first variant. So go with this but add missing  * words.  */
end_comment

begin_define
define|#
directive|define
name|CSH_BUILTINS
define|\
value|"alias cd eval exec exit read set ulimit unalias "	\ 	"umask unset wait"
end_define

begin_define
define|#
directive|define
name|SH_BUILTINS
define|\
value|"alias cd eval exec exit read set ulimit unalias "	\ 	"umask unset wait"
end_define

begin_define
define|#
directive|define
name|CSH_META
value|"#=|^(){};&<>*?[]:$`\\@\n"
end_define

begin_define
define|#
directive|define
name|SH_META
value|"#=|^(){};&<>*?[]:$`\\\n"
end_define

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|shells_init
index|[]
init|=
block|{
comment|/* 	 * CSH description. The csh can do echo control by playing 	 * with the setting of the 'echo' shell variable. Sadly, 	 * however, it is unable to do error control nicely. 	 */
literal|"name=csh path='"
name|PATH_DEFSHELLDIR
literal|"/csh' "
literal|"quiet='unset verbose' echo='set verbose' filter='unset verbose' "
literal|"hasErrCtl=N check='echo \"%s\"\n' ignore='csh -c \"%s || exit 0\"' "
literal|"echoFlag=v errFlag=e "
literal|"meta='"
name|CSH_META
literal|"' builtins='"
name|CSH_BUILTINS
literal|"'"
block|,
comment|/* 	 * SH description. Echo control is also possible and, under 	 * sun UNIX anyway, one can even control error checking. 	 */
literal|"name=sh path='"
name|PATH_DEFSHELLDIR
literal|"/sh' "
literal|"quiet='set -' echo='set -v' filter='set -' "
literal|"hasErrCtl=Y check='set -e' ignore='set +e' "
literal|"echoFlag=v errFlag=e "
literal|"meta='"
name|SH_META
literal|"' builtins='"
name|SH_BUILTINS
literal|"'"
block|,
comment|/* 	 * KSH description. The Korn shell has a superset of 	 * the Bourne shell's functionality. There are probably builtins 	 * missing here. 	 */
literal|"name=ksh path='"
name|PATH_DEFSHELLDIR
literal|"/ksh' "
literal|"quiet='set -' echo='set -v' filter='set -' "
literal|"hasErrCtl=Y check='set -e' ignore='set +e' "
literal|"echoFlag=v errFlag=e "
literal|"meta='"
name|SH_META
literal|"' builtins='"
name|SH_BUILTINS
literal|"' unsetenv=T"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This is the shell to which we pass all commands in the Makefile.  * It is set by the Job_ParseShell function.  */
end_comment

begin_decl_stmt
name|struct
name|Shell
modifier|*
name|commandShell
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This is the list of all known shells.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|Shells
name|shells
init|=
name|TAILQ_HEAD_INITIALIZER
argument_list|(
name|shells
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|ShellDump
argument_list|(
specifier|const
expr|struct
name|Shell
operator|*
argument_list|)
name|__unused
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**  * Helper function for sorting the builtin list alphabetically.  */
end_comment

begin_function
specifier|static
name|int
name|sort_builtins
parameter_list|(
specifier|const
name|void
modifier|*
name|p1
parameter_list|,
specifier|const
name|void
modifier|*
name|p2
parameter_list|)
block|{
return|return
operator|(
name|strcmp
argument_list|(
operator|*
operator|(
specifier|const
name|char
operator|*
specifier|const
operator|*
operator|)
name|p1
argument_list|,
operator|*
operator|(
specifier|const
name|char
operator|*
specifier|const
operator|*
operator|)
name|p2
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Free a shell structure and all associated strings.  */
end_comment

begin_function
specifier|static
name|void
name|ShellFree
parameter_list|(
name|struct
name|Shell
modifier|*
name|sh
parameter_list|)
block|{
if|if
condition|(
name|sh
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|sh
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sh
operator|->
name|path
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sh
operator|->
name|echoOff
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sh
operator|->
name|echoOn
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sh
operator|->
name|noPrint
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sh
operator|->
name|errCheck
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sh
operator|->
name|ignErr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sh
operator|->
name|echo
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sh
operator|->
name|exit
argument_list|)
expr_stmt|;
name|ArgArray_Done
argument_list|(
operator|&
name|sh
operator|->
name|builtins
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sh
operator|->
name|meta
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sh
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * Dump a shell specification to stderr.  */
end_comment

begin_function
name|void
name|ShellDump
parameter_list|(
specifier|const
name|struct
name|Shell
modifier|*
name|sh
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Shell %p:\n"
argument_list|,
name|sh
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  name='%s' path='%s'\n"
argument_list|,
name|sh
operator|->
name|name
argument_list|,
name|sh
operator|->
name|path
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  hasEchoCtl=%d echoOff='%s' echoOn='%s'\n"
argument_list|,
name|sh
operator|->
name|hasEchoCtl
argument_list|,
name|sh
operator|->
name|echoOff
argument_list|,
name|sh
operator|->
name|echoOn
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  noPrint='%s'\n"
argument_list|,
name|sh
operator|->
name|noPrint
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  hasErrCtl=%d errCheck='%s' ignErr='%s'\n"
argument_list|,
name|sh
operator|->
name|hasErrCtl
argument_list|,
name|sh
operator|->
name|errCheck
argument_list|,
name|sh
operator|->
name|ignErr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  echo='%s' exit='%s'\n"
argument_list|,
name|sh
operator|->
name|echo
argument_list|,
name|sh
operator|->
name|exit
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  builtins=%d\n"
argument_list|,
name|sh
operator|->
name|builtins
operator|.
name|argc
operator|-
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|sh
operator|->
name|builtins
operator|.
name|argc
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" '%s'"
argument_list|,
name|sh
operator|->
name|builtins
operator|.
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n  meta='%s'\n"
argument_list|,
name|sh
operator|->
name|meta
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  unsetenv=%d\n"
argument_list|,
name|sh
operator|->
name|unsetenv
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Parse a shell specification line and return the new Shell structure.  * In case of an error a message is printed and NULL is returned.  */
end_comment

begin_function
specifier|static
name|struct
name|Shell
modifier|*
name|ShellParseSpec
parameter_list|(
specifier|const
name|char
modifier|*
name|spec
parameter_list|,
name|Boolean
modifier|*
name|fullSpec
parameter_list|)
block|{
name|ArgArray
name|aa
decl_stmt|;
name|struct
name|Shell
modifier|*
name|sh
decl_stmt|;
name|char
modifier|*
name|eq
decl_stmt|;
name|char
modifier|*
name|keyw
decl_stmt|;
name|int
name|arg
decl_stmt|;
operator|*
name|fullSpec
operator|=
name|FALSE
expr_stmt|;
name|sh
operator|=
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sh
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|sh
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sh
argument_list|)
argument_list|)
expr_stmt|;
name|ArgArray_Init
argument_list|(
operator|&
name|sh
operator|->
name|builtins
argument_list|)
expr_stmt|;
comment|/* 	 * Parse the specification by keyword but skip the first word 	 */
name|brk_string
argument_list|(
operator|&
name|aa
argument_list|,
name|spec
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
for|for
control|(
name|arg
operator|=
literal|1
init|;
name|arg
operator|<
name|aa
operator|.
name|argc
condition|;
name|arg
operator|++
control|)
block|{
comment|/* 		 * Split keyword and value 		 */
name|keyw
operator|=
name|aa
operator|.
name|argv
index|[
name|arg
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|eq
operator|=
name|strchr
argument_list|(
name|keyw
argument_list|,
literal|'='
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|Parse_Error
argument_list|(
name|PARSE_FATAL
argument_list|,
literal|"missing '=' in shell "
literal|"specification keyword '%s'"
argument_list|,
name|keyw
argument_list|)
expr_stmt|;
name|ArgArray_Done
argument_list|(
operator|&
name|aa
argument_list|)
expr_stmt|;
name|ShellFree
argument_list|(
name|sh
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
operator|*
name|eq
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|keyw
argument_list|,
literal|"path"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|sh
operator|->
name|path
argument_list|)
expr_stmt|;
name|sh
operator|->
name|path
operator|=
name|estrdup
argument_list|(
name|eq
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|keyw
argument_list|,
literal|"name"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|sh
operator|->
name|name
argument_list|)
expr_stmt|;
name|sh
operator|->
name|name
operator|=
name|estrdup
argument_list|(
name|eq
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|keyw
argument_list|,
literal|"quiet"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|sh
operator|->
name|echoOff
argument_list|)
expr_stmt|;
name|sh
operator|->
name|echoOff
operator|=
name|estrdup
argument_list|(
name|eq
argument_list|)
expr_stmt|;
operator|*
name|fullSpec
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|keyw
argument_list|,
literal|"echo"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|sh
operator|->
name|echoOn
argument_list|)
expr_stmt|;
name|sh
operator|->
name|echoOn
operator|=
name|estrdup
argument_list|(
name|eq
argument_list|)
expr_stmt|;
operator|*
name|fullSpec
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|keyw
argument_list|,
literal|"filter"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|sh
operator|->
name|noPrint
argument_list|)
expr_stmt|;
name|sh
operator|->
name|noPrint
operator|=
name|estrdup
argument_list|(
name|eq
argument_list|)
expr_stmt|;
operator|*
name|fullSpec
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|keyw
argument_list|,
literal|"echoFlag"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|sh
operator|->
name|echo
argument_list|)
expr_stmt|;
name|sh
operator|->
name|echo
operator|=
name|estrdup
argument_list|(
name|eq
argument_list|)
expr_stmt|;
operator|*
name|fullSpec
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|keyw
argument_list|,
literal|"errFlag"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|sh
operator|->
name|exit
argument_list|)
expr_stmt|;
name|sh
operator|->
name|exit
operator|=
name|estrdup
argument_list|(
name|eq
argument_list|)
expr_stmt|;
operator|*
name|fullSpec
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|keyw
argument_list|,
literal|"hasErrCtl"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sh
operator|->
name|hasErrCtl
operator|=
operator|(
operator|*
name|eq
operator|==
literal|'Y'
operator|||
operator|*
name|eq
operator|==
literal|'y'
operator|||
operator|*
name|eq
operator|==
literal|'T'
operator|||
operator|*
name|eq
operator|==
literal|'t'
operator|)
expr_stmt|;
operator|*
name|fullSpec
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|keyw
argument_list|,
literal|"check"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|sh
operator|->
name|errCheck
argument_list|)
expr_stmt|;
name|sh
operator|->
name|errCheck
operator|=
name|estrdup
argument_list|(
name|eq
argument_list|)
expr_stmt|;
operator|*
name|fullSpec
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|keyw
argument_list|,
literal|"ignore"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|sh
operator|->
name|ignErr
argument_list|)
expr_stmt|;
name|sh
operator|->
name|ignErr
operator|=
name|estrdup
argument_list|(
name|eq
argument_list|)
expr_stmt|;
operator|*
name|fullSpec
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|keyw
argument_list|,
literal|"builtins"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ArgArray_Done
argument_list|(
operator|&
name|sh
operator|->
name|builtins
argument_list|)
expr_stmt|;
name|brk_string
argument_list|(
operator|&
name|sh
operator|->
name|builtins
argument_list|,
name|eq
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|qsort
argument_list|(
name|sh
operator|->
name|builtins
operator|.
name|argv
operator|+
literal|1
argument_list|,
name|sh
operator|->
name|builtins
operator|.
name|argc
operator|-
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|,
name|sort_builtins
argument_list|)
expr_stmt|;
operator|*
name|fullSpec
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|keyw
argument_list|,
literal|"meta"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|sh
operator|->
name|meta
argument_list|)
expr_stmt|;
name|sh
operator|->
name|meta
operator|=
name|estrdup
argument_list|(
name|eq
argument_list|)
expr_stmt|;
operator|*
name|fullSpec
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|keyw
argument_list|,
literal|"unsetenv"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sh
operator|->
name|unsetenv
operator|=
operator|(
operator|*
name|eq
operator|==
literal|'Y'
operator|||
operator|*
name|eq
operator|==
literal|'y'
operator|||
operator|*
name|eq
operator|==
literal|'T'
operator|||
operator|*
name|eq
operator|==
literal|'t'
operator|)
expr_stmt|;
operator|*
name|fullSpec
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|Parse_Error
argument_list|(
name|PARSE_FATAL
argument_list|,
literal|"unknown keyword in shell "
literal|"specification '%s'"
argument_list|,
name|keyw
argument_list|)
expr_stmt|;
name|ArgArray_Done
argument_list|(
operator|&
name|aa
argument_list|)
expr_stmt|;
name|ShellFree
argument_list|(
name|sh
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
name|ArgArray_Done
argument_list|(
operator|&
name|aa
argument_list|)
expr_stmt|;
comment|/* 	 * Some checks (could be more) 	 */
if|if
condition|(
operator|*
name|fullSpec
condition|)
block|{
if|if
condition|(
operator|(
name|sh
operator|->
name|echoOn
operator|!=
name|NULL
operator|)
operator|^
operator|(
name|sh
operator|->
name|echoOff
operator|!=
name|NULL
operator|)
condition|)
block|{
name|Parse_Error
argument_list|(
name|PARSE_FATAL
argument_list|,
literal|"Shell must have either both "
literal|"echoOff and echoOn or none of them"
argument_list|)
expr_stmt|;
name|ShellFree
argument_list|(
name|sh
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|sh
operator|->
name|echoOn
operator|!=
name|NULL
operator|&&
name|sh
operator|->
name|echoOff
operator|!=
name|NULL
condition|)
name|sh
operator|->
name|hasEchoCtl
operator|=
name|TRUE
expr_stmt|;
block|}
return|return
operator|(
name|sh
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Parse the builtin shell specifications and put them into the shell  * list. Then select the default shell to be the current shell. This  * is called from main() before any parsing (including MAKEFLAGS and  * command line) is done.  */
end_comment

begin_function
name|void
name|Shell_Init
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|Shell
modifier|*
name|sh
decl_stmt|;
name|Boolean
name|fullSpec
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|shells_init
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
name|sh
operator|=
name|ShellParseSpec
argument_list|(
name|shells_init
index|[
name|i
index|]
argument_list|,
operator|&
name|fullSpec
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|shells
argument_list|,
name|sh
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|sh
operator|->
name|name
argument_list|,
name|DEFSHELLNAME
argument_list|)
operator|==
literal|0
condition|)
name|commandShell
operator|=
name|sh
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * Find a matching shell in 'shells' given its final component.  *  * Results:  *	A pointer to a freshly allocated Shell structure with the contents  *	from static description or NULL if no shell with the given name  *	is found.  */
end_comment

begin_function
specifier|static
name|struct
name|Shell
modifier|*
name|ShellMatch
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|Shell
modifier|*
name|sh
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|sh
argument_list|,
argument|&shells
argument_list|,
argument|link
argument_list|)
if|if
condition|(
name|strcmp
argument_list|(
name|sh
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|sh
operator|)
return|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Parse a shell specification and set up commandShell appropriately.  *  * Results:  *	TRUE if the specification was correct. FALSE otherwise.  *  * Side Effects:  *	commandShell points to a Shell structure.  *	created from the shell spec).  *  * Notes:  *	A shell specification consists of a .SHELL target, with dependency  *	operator, followed by a series of blank-separated words. Double  *	quotes can be used to use blanks in words. A backslash escapes  *	anything (most notably a double-quote and a space) and  *	provides the functionality it does in C. Each word consists of  *	keyword and value separated by an equal sign. There should be no  *	unnecessary spaces in the word. The keywords are as follows:  *	    name	    Name of shell.  *	    path	    Location of shell. Overrides "name" if given  *	    quiet	    Command to turn off echoing.  *	    echo	    Command to turn echoing on  *	    filter	    Result of turning off echoing that shouldn't be  *			    printed.  *	    echoFlag	    Flag to turn echoing on at the start  *	    errFlag	    Flag to turn error checking on at the start  *	    hasErrCtl	    True if shell has error checking control  *	    check	    Command to turn on error checking if hasErrCtl  *			    is TRUE or template of command to echo a command  *			    for which error checking is off if hasErrCtl is  *			    FALSE.  *	    ignore	    Command to turn off error checking if hasErrCtl  *			    is TRUE or template of command to execute a  *			    command so as to ignore any errors it returns if  *			    hasErrCtl is FALSE.  *	    builtins	    A space separated list of builtins. If one  *			    of these builtins is detected when make wants  *			    to execute a command line, the command line is  *			    handed to the shell. Otherwise make may try to  *			    execute the command directly. If this list is empty  *			    it is assumed, that the command must always be  *			    handed over to the shell.  *	    meta	    The shell meta characters. If this is not specified  *			    or empty, commands are alway passed to the shell.  *			    Otherwise they are not passed when they contain  *			    neither a meta character nor a builtin command.  *	    unsetenv	    Unsetenv("ENV") before executing anything.  */
end_comment

begin_function
name|Boolean
name|Shell_Parse
parameter_list|(
specifier|const
name|char
name|line
index|[]
parameter_list|)
block|{
name|Boolean
name|fullSpec
decl_stmt|;
name|struct
name|Shell
modifier|*
name|sh
decl_stmt|;
name|struct
name|Shell
modifier|*
name|match
decl_stmt|;
comment|/* parse the specification */
if|if
condition|(
operator|(
name|sh
operator|=
name|ShellParseSpec
argument_list|(
name|line
argument_list|,
operator|&
name|fullSpec
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
name|sh
operator|->
name|path
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * If no path was given, the user wants one of the pre-defined 		 * shells, yes? So we find the one s/he wants with the help of 		 * JobMatchShell and set things up the right way. 		 */
if|if
condition|(
name|sh
operator|->
name|name
operator|==
name|NULL
condition|)
block|{
name|Parse_Error
argument_list|(
name|PARSE_FATAL
argument_list|,
literal|"Neither path nor name specified"
argument_list|)
expr_stmt|;
name|ShellFree
argument_list|(
name|sh
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
if|if
condition|(
name|fullSpec
condition|)
block|{
comment|/* 			 * XXX May want to merge sh into match. But this 			 * require ShellParseSpec to return information 			 * which attributes actuall have been specified. 			 */
name|Parse_Error
argument_list|(
name|PARSE_FATAL
argument_list|,
literal|"No path specified"
argument_list|)
expr_stmt|;
name|ShellFree
argument_list|(
name|sh
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|match
operator|=
name|ShellMatch
argument_list|(
name|sh
operator|->
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|Parse_Error
argument_list|(
name|PARSE_FATAL
argument_list|,
literal|"%s: no matching shell"
argument_list|,
name|sh
operator|->
name|name
argument_list|)
expr_stmt|;
name|ShellFree
argument_list|(
name|sh
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|ShellFree
argument_list|(
name|sh
argument_list|)
expr_stmt|;
name|commandShell
operator|=
name|match
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
comment|/* 	 * The user provided a path. If s/he gave nothing else 	 * (fullSpec is FALSE), try and find a matching shell in the 	 * ones we know of. Else we just take the specification at its 	 * word and copy it to a new location. In either case, we need 	 * to record the path the user gave for the shell. 	 */
if|if
condition|(
name|sh
operator|->
name|name
operator|==
name|NULL
condition|)
block|{
comment|/* get the base name as the name */
if|if
condition|(
operator|(
name|sh
operator|->
name|name
operator|=
name|strrchr
argument_list|(
name|sh
operator|->
name|path
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|sh
operator|->
name|name
operator|=
name|estrdup
argument_list|(
name|sh
operator|->
name|path
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sh
operator|->
name|name
operator|=
name|estrdup
argument_list|(
name|sh
operator|->
name|name
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|fullSpec
condition|)
block|{
if|if
condition|(
operator|(
name|match
operator|=
name|ShellMatch
argument_list|(
name|sh
operator|->
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|Parse_Error
argument_list|(
name|PARSE_FATAL
argument_list|,
literal|"%s: no matching shell"
argument_list|,
name|sh
operator|->
name|name
argument_list|)
expr_stmt|;
name|ShellFree
argument_list|(
name|sh
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
comment|/* set the patch on the matching shell */
name|free
argument_list|(
name|match
operator|->
name|path
argument_list|)
expr_stmt|;
name|match
operator|->
name|path
operator|=
name|sh
operator|->
name|path
expr_stmt|;
name|sh
operator|->
name|path
operator|=
name|NULL
expr_stmt|;
name|ShellFree
argument_list|(
name|sh
argument_list|)
expr_stmt|;
name|commandShell
operator|=
name|match
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|shells
argument_list|,
name|sh
argument_list|,
name|link
argument_list|)
expr_stmt|;
comment|/* set the new shell */
name|commandShell
operator|=
name|sh
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

end_unit

