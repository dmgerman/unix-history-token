begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1988, 1989, 1990, 1993  *	The Regents of the University of California.  All rights reserved.  * Copyright (c) 1989 by Berkeley Softworks  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Adam de Boor.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * @(#)suff.c	8.4 (Berkeley) 3/21/94  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*-  * suff.c --  *	Functions to maintain suffix lists and find implicit dependents  *	using suffix transformation rules  *  * Interface:  *	Suff_Init 	    	Initialize all things to do with suffixes.  *  *	Suff_DoPaths	    	This function is used to make life easier  *	    	  	    	when searching for a file according to its  *	    	  	    	suffix. It takes the global search path,  *	    	  	    	as defined using the .PATH: target, and appends  *	    	  	    	its directories to the path of each of the  *	    	  	    	defined suffixes, as specified using  *	    	  	    	.PATH<suffix>: targets. In addition, all  *	    	  	    	directories given for suffixes labeled as  *	    	  	    	include files or libraries, using the .INCLUDES  *	    	  	    	or .LIBS targets, are played with using  *	    	  	    	Dir_MakeFlags to create the .INCLUDES and  *	    	  	    	.LIBS global variables.  *  *	Suff_ClearSuffixes  	Clear out all the suffixes and defined  *	    	  	    	transformations.  *  *	Suff_IsTransform    	Return TRUE if the passed string is the lhs  *	    	  	    	of a transformation rule.  *  *	Suff_AddSuffix	    	Add the passed string as another known suffix.  *  *	Suff_GetPath	    	Return the search path for the given suffix.  *  *	Suff_AddInclude	    	Mark the given suffix as denoting an include  *	    	  	    	file.  *  *	Suff_AddLib	    	Mark the given suffix as denoting a library.  *  *	Suff_AddTransform   	Add another transformation to the suffix  *	    	  	    	graph. Returns  GNode suitable for framing, I  *	    	  	    	mean, tacking commands, attributes, etc. on.  *  *	Suff_SetNull	    	Define the suffix to consider the suffix of  *	    	  	    	any file that doesn't have a known one.  *  *	Suff_FindDeps	    	Find implicit sources for and the location of  *	    	  	    	a target based on its suffix. Returns the  *	    	  	    	bottom-most node added to the graph or NULL  *	    	  	    	if the target had no implicit sources.  */
end_comment

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|"arch.h"
end_include

begin_include
include|#
directive|include
file|"buf.h"
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"dir.h"
end_include

begin_include
include|#
directive|include
file|"globals.h"
end_include

begin_include
include|#
directive|include
file|"GNode.h"
end_include

begin_include
include|#
directive|include
file|"lst.h"
end_include

begin_include
include|#
directive|include
file|"make.h"
end_include

begin_include
include|#
directive|include
file|"parse.h"
end_include

begin_include
include|#
directive|include
file|"str.h"
end_include

begin_include
include|#
directive|include
file|"suff.h"
end_include

begin_include
include|#
directive|include
file|"targ.h"
end_include

begin_include
include|#
directive|include
file|"util.h"
end_include

begin_include
include|#
directive|include
file|"var.h"
end_include

begin_comment
comment|/* Lst of suffixes */
end_comment

begin_decl_stmt
specifier|static
name|Lst
name|sufflist
init|=
name|Lst_Initializer
argument_list|(
name|sufflist
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Lst of suffixes to be cleaned */
end_comment

begin_decl_stmt
specifier|static
name|Lst
name|suffClean
init|=
name|Lst_Initializer
argument_list|(
name|suffClean
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Lst of sources */
end_comment

begin_decl_stmt
specifier|static
name|Lst
name|srclist
init|=
name|Lst_Initializer
argument_list|(
name|srclist
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Lst of transformation rules */
end_comment

begin_decl_stmt
specifier|static
name|Lst
name|transforms
init|=
name|Lst_Initializer
argument_list|(
name|transforms
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Counter for assigning suffix numbers */
end_comment

begin_decl_stmt
specifier|static
name|int
name|sNum
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Structure describing an individual suffix.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|Suff
block|{
name|char
modifier|*
name|name
decl_stmt|;
comment|/* The suffix itself */
name|int
name|nameLen
decl_stmt|;
comment|/* Length of the suffix */
name|short
name|flags
decl_stmt|;
comment|/* Type of suffix */
define|#
directive|define
name|SUFF_INCLUDE
value|0x01
comment|/* One which is #include'd */
define|#
directive|define
name|SUFF_LIBRARY
value|0x02
comment|/* One which contains a library */
define|#
directive|define
name|SUFF_NULL
value|0x04
comment|/* The empty suffix */
name|struct
name|Path
name|searchPath
decl_stmt|;
comment|/* Path for files with this suffix */
name|int
name|sNum
decl_stmt|;
comment|/* The suffix number */
name|int
name|refCount
decl_stmt|;
comment|/* Reference count of list membership */
name|Lst
name|parents
decl_stmt|;
comment|/* Suffixes we have a transformation to */
name|Lst
name|children
decl_stmt|;
comment|/* Suffixes we have a transformation from */
name|Lst
name|ref
decl_stmt|;
comment|/* List of lists this suffix is referenced */
block|}
name|Suff
typedef|;
end_typedef

begin_comment
comment|/*  * Structure used in the search for implied sources.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|Src
block|{
name|char
modifier|*
name|file
decl_stmt|;
comment|/* The file to look for */
name|char
modifier|*
name|pref
decl_stmt|;
comment|/* Prefix from which file was formed */
name|Suff
modifier|*
name|suff
decl_stmt|;
comment|/* The suffix on the file */
name|struct
name|Src
modifier|*
name|parent
decl_stmt|;
comment|/* The Src for which this is a source */
name|GNode
modifier|*
name|node
decl_stmt|;
comment|/* The node describing the file */
name|int
name|children
decl_stmt|;
comment|/* Count of existing children (so we don't free 				 * this thing too early or never nuke it) */
ifdef|#
directive|ifdef
name|DEBUG_SRC
name|Lst
name|cp
decl_stmt|;
comment|/* Debug; children list */
endif|#
directive|endif
block|}
name|Src
typedef|;
end_typedef

begin_comment
comment|/* The NULL suffix for this run */
end_comment

begin_decl_stmt
specifier|static
name|Suff
modifier|*
name|suffNull
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The empty suffix required for POSIX single-suffix transformation rules */
end_comment

begin_decl_stmt
specifier|static
name|Suff
modifier|*
name|emptySuff
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|SuffFindDeps
parameter_list|(
name|GNode
modifier|*
parameter_list|,
name|Lst
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * SuffSuffIsSuffix  --  *	See if suff is a suffix of str.  *  * Results:  *	NULL if it ain't, pointer to character in str before suffix if  *	it is.  *  * Side Effects:  *	None  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|SuffSuffIsSuffix
parameter_list|(
specifier|const
name|Suff
modifier|*
name|s
parameter_list|,
name|char
modifier|*
name|str
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p1
decl_stmt|;
comment|/* Pointer into suffix name */
name|char
modifier|*
name|p2
decl_stmt|;
comment|/* Pointer into string being examined */
name|size_t
name|len
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|p1
operator|=
name|s
operator|->
name|name
operator|+
name|s
operator|->
name|nameLen
expr_stmt|;
name|p2
operator|=
name|str
operator|+
name|len
expr_stmt|;
while|while
condition|(
name|p1
operator|>=
name|s
operator|->
name|name
operator|&&
name|len
operator|>
literal|0
operator|&&
operator|*
name|p1
operator|==
operator|*
name|p2
condition|)
block|{
name|p1
operator|--
expr_stmt|;
name|p2
operator|--
expr_stmt|;
name|len
operator|--
expr_stmt|;
block|}
return|return
operator|(
name|p1
operator|==
name|s
operator|->
name|name
operator|-
literal|1
condition|?
name|p2
else|:
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * SuffSuffFind --  *	Find a suffix given its name.  *  * Results:  *	The suffix or NULL.  *  * Side Effects:  *	None  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|Suff
modifier|*
name|SuffSuffFind
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
name|LstNode
modifier|*
name|ln
decl_stmt|;
name|LST_FOREACH
argument_list|(
argument|ln
argument_list|,
argument|&sufflist
argument_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
operator|(
operator|(
specifier|const
name|Suff
operator|*
operator|)
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
operator|)
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * SuffTransFind  *	Find a transform.  *  * Results:  *	transform or NULL.  *  * Side Effects:  *	None  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|GNode
modifier|*
name|SuffTransFind
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|LstNode
modifier|*
name|ln
decl_stmt|;
name|LST_FOREACH
argument_list|(
argument|ln
argument_list|,
argument|&transforms
argument_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
operator|(
operator|(
specifier|const
name|GNode
operator|*
operator|)
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
operator|)
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********** Maintenance Functions ************/
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/*  * Keep this function for now until it is clear why a .SUFFIXES: doesn't  * actually delete the suffixes but just puts them on the suffClean list.  */
end_comment

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * SuffFree  --  *	Free up all memory associated with the given suffix structure.  *  * Results:  *	none  *  * Side Effects:  *	the suffix entry is detroyed  *-----------------------------------------------------------------------  */
end_comment

begin_endif
unit|static void SuffFree(void *sp) { 	Suff *s = sp;  	if (s == suffNull) 		suffNull = NULL;  	if (s == emptySuff) 		emptySuff = NULL;  	Lst_Destroy(&s->ref, NOFREE); 	Lst_Destroy(&s->children, NOFREE); 	Lst_Destroy(&s->parents, NOFREE); 	Lst_Destroy(&s->searchPath, Dir_Destroy);  	free(s->name); 	free(s); }
endif|#
directive|endif
end_endif

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * SuffRemove  --  *	Remove the suffix into the list  *  * Results:  *	None  *  * Side Effects:  *	The reference count for the suffix is decremented  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|SuffRemove
parameter_list|(
name|Lst
modifier|*
name|l
parameter_list|,
name|Suff
modifier|*
name|s
parameter_list|)
block|{
name|LstNode
modifier|*
name|ln
init|=
name|Lst_Member
argument_list|(
name|l
argument_list|,
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|ln
operator|!=
name|NULL
condition|)
block|{
name|Lst_Remove
argument_list|(
name|l
argument_list|,
name|ln
argument_list|)
expr_stmt|;
name|s
operator|->
name|refCount
operator|--
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * SuffInsert  --  *	Insert the suffix into the list keeping the list ordered by suffix  *	numbers.  *  * Results:  *	None  *  * Side Effects:  *	The reference count of the suffix is incremented  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|SuffInsert
parameter_list|(
name|Lst
modifier|*
name|l
parameter_list|,
name|Suff
modifier|*
name|s
parameter_list|)
block|{
name|LstNode
modifier|*
name|ln
decl_stmt|;
comment|/* current element in l we're examining */
name|Suff
modifier|*
name|s2
decl_stmt|;
comment|/* the suffix descriptor in this element */
name|s2
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|ln
operator|=
name|Lst_First
argument_list|(
name|l
argument_list|)
init|;
name|ln
operator|!=
name|NULL
condition|;
name|ln
operator|=
name|Lst_Succ
argument_list|(
name|ln
argument_list|)
control|)
block|{
name|s2
operator|=
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
expr_stmt|;
if|if
condition|(
name|s2
operator|->
name|sNum
operator|>=
name|s
operator|->
name|sNum
condition|)
break|break;
block|}
if|if
condition|(
name|s2
operator|==
name|NULL
condition|)
block|{
name|DEBUGF
argument_list|(
name|SUFF
argument_list|,
operator|(
literal|"inserting an empty list?..."
operator|)
argument_list|)
expr_stmt|;
block|}
name|DEBUGF
argument_list|(
name|SUFF
argument_list|,
operator|(
literal|"inserting %s(%d)..."
operator|,
name|s
operator|->
name|name
operator|,
name|s
operator|->
name|sNum
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ln
operator|==
name|NULL
condition|)
block|{
name|DEBUGF
argument_list|(
name|SUFF
argument_list|,
operator|(
literal|"at end of list\n"
operator|)
argument_list|)
expr_stmt|;
name|Lst_AtEnd
argument_list|(
name|l
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|s
operator|->
name|refCount
operator|++
expr_stmt|;
name|Lst_AtEnd
argument_list|(
operator|&
name|s
operator|->
name|ref
argument_list|,
name|l
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s2
operator|->
name|sNum
operator|!=
name|s
operator|->
name|sNum
condition|)
block|{
name|DEBUGF
argument_list|(
name|SUFF
argument_list|,
operator|(
literal|"before %s(%d)\n"
operator|,
name|s2
operator|->
name|name
operator|,
name|s2
operator|->
name|sNum
operator|)
argument_list|)
expr_stmt|;
name|Lst_Insert
argument_list|(
name|l
argument_list|,
name|ln
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|s
operator|->
name|refCount
operator|++
expr_stmt|;
name|Lst_AtEnd
argument_list|(
operator|&
name|s
operator|->
name|ref
argument_list|,
name|l
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DEBUGF
argument_list|(
name|SUFF
argument_list|,
operator|(
literal|"already there\n"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Suff_ClearSuffixes --  *	This is gross. Nuke the list of suffixes but keep all transformation  *	rules around. The transformation graph is destroyed in this process,  *	but we leave the list of rules so when a new graph is formed the rules  *	will remain.  *	This function is called from the parse module when a  *	.SUFFIXES:\n line is encountered.  *  * Results:  *	none  *  * Side Effects:  *	the sufflist and its graph nodes are destroyed  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Suff_ClearSuffixes
parameter_list|(
name|void
parameter_list|)
block|{
name|Lst_Concat
argument_list|(
operator|&
name|suffClean
argument_list|,
operator|&
name|sufflist
argument_list|,
name|LST_CONCLINK
argument_list|)
expr_stmt|;
name|sNum
operator|=
literal|1
expr_stmt|;
name|suffNull
operator|=
name|emptySuff
expr_stmt|;
comment|/* 	 * Clear suffNull's children list (the other suffixes are built new, but 	 * suffNull is used as is). 	 * NOFREE is used because all suffixes are are on the suffClean list. 	 * suffNull should not have parents. 	 */
name|Lst_Destroy
argument_list|(
operator|&
name|suffNull
operator|->
name|children
argument_list|,
name|NOFREE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * SuffParseTransform --  *	Parse a transformation string to find its two component suffixes.  *  * Results:  *	TRUE if the string is a valid transformation and FALSE otherwise.  *  * Side Effects:  *	The passed pointers are overwritten.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|Boolean
name|SuffParseTransform
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|Suff
modifier|*
modifier|*
name|srcPtr
parameter_list|,
name|Suff
modifier|*
modifier|*
name|targPtr
parameter_list|)
block|{
name|LstNode
modifier|*
name|srcLn
decl_stmt|;
comment|/* element in suffix list of trans source*/
name|Suff
modifier|*
name|src
decl_stmt|;
comment|/* Source of transformation */
name|char
modifier|*
name|str2
decl_stmt|;
comment|/* Extra pointer (maybe target suffix) */
name|LstNode
modifier|*
name|singleLn
decl_stmt|;
comment|/* element in suffix list of any suffix 				 * that exactly matches str */
name|Suff
modifier|*
name|single
init|=
name|NULL
decl_stmt|;
comment|/* Source of possible transformation to 				 * null suffix */
name|singleLn
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Loop looking first for a suffix that matches the start of the 	 * string and then for one that exactly matches the rest of it. If 	 * we can find two that meet these criteria, we've successfully 	 * parsed the string. 	 */
name|srcLn
operator|=
name|Lst_First
argument_list|(
operator|&
name|sufflist
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* advance to next possible suffix */
while|while
condition|(
name|srcLn
operator|!=
name|NULL
condition|)
block|{
name|src
operator|=
name|Lst_Datum
argument_list|(
name|srcLn
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|str
argument_list|,
name|src
operator|->
name|name
argument_list|,
name|strlen
argument_list|(
name|src
operator|->
name|name
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
break|break;
name|srcLn
operator|=
name|LST_NEXT
argument_list|(
name|srcLn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|srcLn
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * Ran out of source suffixes -- no such rule 			 */
if|if
condition|(
name|singleLn
operator|!=
name|NULL
condition|)
block|{
comment|/* 				 * Not so fast Mr. Smith! There was a suffix 				 * that encompassed the entire string, so we 				 * assume it was a transformation to the null 				 * suffix (thank you POSIX). We still prefer to 				 * find a double rule over a singleton, hence we 				 * leave this check until the end. 				 * 				 * XXX: Use emptySuff over suffNull? 				 */
operator|*
name|srcPtr
operator|=
name|single
expr_stmt|;
operator|*
name|targPtr
operator|=
name|suffNull
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|str2
operator|=
name|str
operator|+
name|src
operator|->
name|nameLen
expr_stmt|;
if|if
condition|(
operator|*
name|str2
operator|==
literal|'\0'
condition|)
block|{
name|single
operator|=
name|src
expr_stmt|;
name|singleLn
operator|=
name|srcLn
expr_stmt|;
block|}
else|else
block|{
operator|*
name|targPtr
operator|=
name|SuffSuffFind
argument_list|(
name|str2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|targPtr
operator|!=
name|NULL
condition|)
block|{
operator|*
name|srcPtr
operator|=
name|src
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
block|}
comment|/* next one */
name|srcLn
operator|=
name|LST_NEXT
argument_list|(
name|srcLn
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Suff_IsTransform  --  *	Return TRUE if the given string is a transformation rule  *  *  * Results:  *	TRUE if the string is a concatenation of two known suffixes.  *	FALSE otherwise  *  * Side Effects:  *	None  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|Boolean
name|Suff_IsTransform
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|Suff
modifier|*
name|src
decl_stmt|,
modifier|*
name|targ
decl_stmt|;
return|return
operator|(
name|SuffParseTransform
argument_list|(
name|str
argument_list|,
operator|&
name|src
argument_list|,
operator|&
name|targ
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Suff_AddTransform --  *	Add the transformation rule described by the line to the  *	list of rules and place the transformation itself in the graph  *  * Results:  *	The node created for the transformation in the transforms list  *  * Side Effects:  *	The node is placed on the end of the transforms Lst and links are  *	made between the two suffixes mentioned in the target name  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|GNode
modifier|*
name|Suff_AddTransform
parameter_list|(
name|char
modifier|*
name|line
parameter_list|)
block|{
name|GNode
modifier|*
name|gn
decl_stmt|;
comment|/* GNode of transformation rule */
name|Suff
modifier|*
name|s
decl_stmt|;
comment|/* source suffix */
name|Suff
modifier|*
name|t
decl_stmt|;
comment|/* target suffix */
name|gn
operator|=
name|SuffTransFind
argument_list|(
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|gn
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * Make a new graph node for the transformation. 		 * It will be filled in by the Parse module. 		 */
name|gn
operator|=
name|Targ_NewGN
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|Lst_AtEnd
argument_list|(
operator|&
name|transforms
argument_list|,
name|gn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * New specification for transformation rule. Just nuke the 		 * old list of commands so they can be filled in again... 		 * We don't actually free the commands themselves, because a 		 * given command can be attached to several different 		 * transformations. 		 */
name|Lst_Destroy
argument_list|(
operator|&
name|gn
operator|->
name|commands
argument_list|,
name|NOFREE
argument_list|)
expr_stmt|;
name|Lst_Destroy
argument_list|(
operator|&
name|gn
operator|->
name|children
argument_list|,
name|NOFREE
argument_list|)
expr_stmt|;
block|}
name|gn
operator|->
name|type
operator|=
name|OP_TRANSFORM
expr_stmt|;
name|SuffParseTransform
argument_list|(
name|line
argument_list|,
operator|&
name|s
argument_list|,
operator|&
name|t
argument_list|)
expr_stmt|;
comment|/* 	 * link the two together in the proper relationship and order 	 */
name|DEBUGF
argument_list|(
name|SUFF
argument_list|,
operator|(
literal|"defining transformation from `%s' to `%s'\n"
operator|,
name|s
operator|->
name|name
operator|,
name|t
operator|->
name|name
operator|)
argument_list|)
expr_stmt|;
name|SuffInsert
argument_list|(
operator|&
name|t
operator|->
name|children
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|SuffInsert
argument_list|(
operator|&
name|s
operator|->
name|parents
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|gn
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Suff_EndTransform --  *	Handle the finish of a transformation definition, removing the  *	transformation from the graph if it has neither commands nor  *	sources. This is called from the Parse module at the end of  *	a dependency block.  *  * Side Effects:  *	If the node has no commands or children, the children and parents  *	lists of the affected suffices are altered.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Suff_EndTransform
parameter_list|(
specifier|const
name|GNode
modifier|*
name|gn
parameter_list|)
block|{
name|Suff
modifier|*
name|s
decl_stmt|,
modifier|*
name|t
decl_stmt|;
if|if
condition|(
operator|!
name|Lst_IsEmpty
argument_list|(
operator|&
name|gn
operator|->
name|commands
argument_list|)
operator|||
operator|!
name|Lst_IsEmpty
argument_list|(
operator|&
name|gn
operator|->
name|children
argument_list|)
condition|)
block|{
name|DEBUGF
argument_list|(
name|SUFF
argument_list|,
operator|(
literal|"transformation %s complete\n"
operator|,
name|gn
operator|->
name|name
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * SuffParseTransform() may fail for special rules which are not 	 * actual transformation rules (e.g., .DEFAULT). 	 */
if|if
condition|(
operator|!
name|SuffParseTransform
argument_list|(
name|gn
operator|->
name|name
argument_list|,
operator|&
name|s
argument_list|,
operator|&
name|t
argument_list|)
condition|)
return|return;
name|DEBUGF
argument_list|(
name|SUFF
argument_list|,
operator|(
literal|"deleting transformation from `%s' to `%s'\n"
operator|,
name|s
operator|->
name|name
operator|,
name|t
operator|->
name|name
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Remove the source from the target's children list. We check 	 * for a NULL return to handle a beanhead saying something like 	 *  .c.o .c.o: 	 * 	 * We'll be called twice when the next target is seen, but .c 	 * and .o are only linked once... 	 */
name|SuffRemove
argument_list|(
operator|&
name|t
operator|->
name|children
argument_list|,
name|s
argument_list|)
expr_stmt|;
comment|/* 	 * Remove the target from the source's parents list 	 */
name|SuffRemove
argument_list|(
operator|&
name|s
operator|->
name|parents
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * SuffRebuildGraph --  *	Called from Suff_AddSuffix via LST_FOREACH to search through the  *	list of existing transformation rules and rebuild the transformation  *	graph when it has been destroyed by Suff_ClearSuffixes. If the  *	given rule is a transformation involving this suffix and another,  *	existing suffix, the proper relationship is established between  *	the two.  *  * Side Effects:  *	The appropriate links will be made between this suffix and  *	others if transformation rules exist for it.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|SuffRebuildGraph
parameter_list|(
specifier|const
name|GNode
modifier|*
name|transform
parameter_list|,
name|Suff
modifier|*
name|s
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|Suff
modifier|*
name|s2
init|=
name|NULL
decl_stmt|;
comment|/* 	 * First see if it is a transformation from this suffix. 	 */
if|if
condition|(
name|strncmp
argument_list|(
name|transform
operator|->
name|name
argument_list|,
name|s
operator|->
name|name
argument_list|,
name|strlen
argument_list|(
name|s
operator|->
name|name
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cp
operator|=
name|transform
operator|->
name|name
operator|+
name|strlen
argument_list|(
name|s
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
comment|/* null rule */
name|s2
operator|=
name|suffNull
expr_stmt|;
else|else
name|s2
operator|=
name|SuffSuffFind
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|s2
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * Found target. Link in and return, since it can't be 			 * anything else. 			 */
name|SuffInsert
argument_list|(
operator|&
name|s2
operator|->
name|children
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|SuffInsert
argument_list|(
operator|&
name|s
operator|->
name|parents
argument_list|,
name|s2
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* 	 * Not from, maybe to? 	 */
name|cp
operator|=
name|SuffSuffIsSuffix
argument_list|(
name|s
argument_list|,
name|transform
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Null-terminate the source suffix in order to find it. 		 */
name|cp
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|s2
operator|=
name|SuffSuffFind
argument_list|(
name|transform
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* 		 * Replace the start of the target suffix 		 */
name|cp
index|[
literal|1
index|]
operator|=
name|s
operator|->
name|name
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|s2
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * Found it -- establish the proper relationship 			 */
name|SuffInsert
argument_list|(
operator|&
name|s
operator|->
name|children
argument_list|,
name|s2
argument_list|)
expr_stmt|;
name|SuffInsert
argument_list|(
operator|&
name|s2
operator|->
name|parents
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Suff_AddSuffix --  *	Add the suffix in string to the end of the list of known suffixes.  *	Should we restructure the suffix graph? Make doesn't...  *  * Results:  *	None  *  * Side Effects:  *	A GNode is created for the suffix and a Suff structure is created and  *	added to the suffixes list unless the suffix was already known.  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Suff_AddSuffix
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|Suff
modifier|*
name|s
decl_stmt|;
comment|/* new suffix descriptor */
name|LstNode
modifier|*
name|ln
decl_stmt|;
if|if
condition|(
name|SuffSuffFind
argument_list|(
name|str
argument_list|)
operator|!=
name|NULL
condition|)
comment|/* 		 * Already known 		 */
return|return;
name|s
operator|=
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Suff
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|->
name|name
operator|=
name|estrdup
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|s
operator|->
name|nameLen
operator|=
name|strlen
argument_list|(
name|s
operator|->
name|name
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|s
operator|->
name|searchPath
argument_list|)
expr_stmt|;
name|Lst_Init
argument_list|(
operator|&
name|s
operator|->
name|children
argument_list|)
expr_stmt|;
name|Lst_Init
argument_list|(
operator|&
name|s
operator|->
name|parents
argument_list|)
expr_stmt|;
name|Lst_Init
argument_list|(
operator|&
name|s
operator|->
name|ref
argument_list|)
expr_stmt|;
name|s
operator|->
name|sNum
operator|=
name|sNum
operator|++
expr_stmt|;
name|s
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|refCount
operator|=
literal|0
expr_stmt|;
name|Lst_AtEnd
argument_list|(
operator|&
name|sufflist
argument_list|,
name|s
argument_list|)
expr_stmt|;
comment|/* 	 * Look for any existing transformations from or to this suffix. 	 * XXX: Only do this after a Suff_ClearSuffixes? 	 */
name|LST_FOREACH
argument_list|(
argument|ln
argument_list|,
argument|&transforms
argument_list|)
name|SuffRebuildGraph
argument_list|(
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Suff_GetPath --  *	Return the search path for the given suffix, if it's defined.  *  * Results:  *	The searchPath for the desired suffix or NULL if the suffix isn't  *	defined.  *  * Side Effects:  *	None  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|struct
name|Path
modifier|*
name|Suff_GetPath
parameter_list|(
name|char
modifier|*
name|sname
parameter_list|)
block|{
name|Suff
modifier|*
name|s
decl_stmt|;
name|s
operator|=
name|SuffSuffFind
argument_list|(
name|sname
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
operator|&
name|s
operator|->
name|searchPath
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Suff_DoPaths --  *	Extend the search paths for all suffixes to include the default  *	search path.  *  * Results:  *	None.  *  * Side Effects:  *	The searchPath field of all the suffixes is extended by the  *	directories in dirSearchPath. If paths were specified for the  *	".h" suffix, the directories are stuffed into a global variable  *	called ".INCLUDES" with each directory preceded by a -I. The same  *	is done for the ".a" suffix, except the variable is called  *	".LIBS" and the flag is -L.  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Suff_DoPaths
parameter_list|(
name|void
parameter_list|)
block|{
name|Suff
modifier|*
name|s
decl_stmt|;
name|LstNode
modifier|*
name|ln
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
name|struct
name|Path
name|inIncludes
decl_stmt|;
comment|/* Cumulative .INCLUDES path */
name|struct
name|Path
name|inLibs
decl_stmt|;
comment|/* Cumulative .LIBS path */
name|TAILQ_INIT
argument_list|(
operator|&
name|inIncludes
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|inLibs
argument_list|)
expr_stmt|;
for|for
control|(
name|ln
operator|=
name|Lst_First
argument_list|(
operator|&
name|sufflist
argument_list|)
init|;
name|ln
operator|!=
name|NULL
condition|;
name|ln
operator|=
name|Lst_Succ
argument_list|(
name|ln
argument_list|)
control|)
block|{
name|s
operator|=
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INCLUDES
if|if
condition|(
name|s
operator|->
name|flags
operator|&
name|SUFF_INCLUDE
condition|)
block|{
name|Path_Concat
argument_list|(
operator|&
name|inIncludes
argument_list|,
operator|&
name|s
operator|->
name|searchPath
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* INCLUDES */
ifdef|#
directive|ifdef
name|LIBRARIES
if|if
condition|(
name|s
operator|->
name|flags
operator|&
name|SUFF_LIBRARY
condition|)
block|{
name|Path_Concat
argument_list|(
operator|&
name|inLibs
argument_list|,
operator|&
name|s
operator|->
name|searchPath
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* LIBRARIES */
name|Path_Concat
argument_list|(
operator|&
name|s
operator|->
name|searchPath
argument_list|,
operator|&
name|dirSearchPath
argument_list|)
expr_stmt|;
block|}
name|ptr
operator|=
name|Path_MakeFlags
argument_list|(
literal|"-I"
argument_list|,
operator|&
name|inIncludes
argument_list|)
expr_stmt|;
name|Var_Set
argument_list|(
literal|".INCLUDES"
argument_list|,
name|ptr
argument_list|,
name|VAR_GLOBAL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|Path_MakeFlags
argument_list|(
literal|"-L"
argument_list|,
operator|&
name|inLibs
argument_list|)
expr_stmt|;
name|Var_Set
argument_list|(
literal|".LIBS"
argument_list|,
name|ptr
argument_list|,
name|VAR_GLOBAL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|Path_Clear
argument_list|(
operator|&
name|inIncludes
argument_list|)
expr_stmt|;
name|Path_Clear
argument_list|(
operator|&
name|inLibs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Suff_AddInclude --  *	Add the given suffix as a type of file which gets included.  *	Called from the parse module when a .INCLUDES line is parsed.  *	The suffix must have already been defined.  *  * Results:  *	None.  *  * Side Effects:  *	The SUFF_INCLUDE bit is set in the suffix's flags field  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Suff_AddInclude
parameter_list|(
name|char
modifier|*
name|sname
parameter_list|)
block|{
name|Suff
modifier|*
name|s
decl_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|SuffSuffFind
argument_list|(
name|sname
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|s
operator|->
name|flags
operator||=
name|SUFF_INCLUDE
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Suff_AddLib --  *	Add the given suffix as a type of file which is a library.  *	Called from the parse module when parsing a .LIBS line. The  *	suffix must have been defined via .SUFFIXES before this is  *	called.  *  * Results:  *	None.  *  * Side Effects:  *	The SUFF_LIBRARY bit is set in the suffix's flags field  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Suff_AddLib
parameter_list|(
name|char
modifier|*
name|sname
parameter_list|)
block|{
name|Suff
modifier|*
name|s
decl_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|SuffSuffFind
argument_list|(
name|sname
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|s
operator|->
name|flags
operator||=
name|SUFF_LIBRARY
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Create a new Src structure  */
end_comment

begin_function
specifier|static
name|Src
modifier|*
name|SuffSrcCreate
parameter_list|(
name|char
modifier|*
name|file
parameter_list|,
name|char
modifier|*
name|prefix
parameter_list|,
name|Suff
modifier|*
name|suff
parameter_list|,
name|Src
modifier|*
name|parent
parameter_list|,
name|GNode
modifier|*
name|node
parameter_list|)
block|{
name|Src
modifier|*
name|s
decl_stmt|;
name|s
operator|=
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|->
name|file
operator|=
name|file
expr_stmt|;
name|s
operator|->
name|pref
operator|=
name|prefix
expr_stmt|;
name|s
operator|->
name|suff
operator|=
name|suff
expr_stmt|;
name|s
operator|->
name|parent
operator|=
name|parent
expr_stmt|;
name|s
operator|->
name|node
operator|=
name|node
expr_stmt|;
name|s
operator|->
name|children
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_SRC
name|Lst_Init
argument_list|(
operator|&
name|s
operator|->
name|cp
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|s
operator|)
return|;
block|}
end_function

begin_comment
comment|/********** Implicit Source Search Functions *********/
end_comment

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * SuffAddLevel  --  *	Add all the children of targ as Src structures to the given list:  *	Add a suffix as a Src structure to the given list with its parent  *	being the given Src structure. If the suffix is the null suffix,  *	the prefix is used unaltered as the file name in the Src structure.  *  * Results:  *	None  *  * Side Effects:  * 	Lots of structures are created and added to the list  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|SuffAddLevel
parameter_list|(
name|Lst
modifier|*
name|l
parameter_list|,
name|Src
modifier|*
name|targ
parameter_list|)
block|{
name|LstNode
modifier|*
name|ln
decl_stmt|;
name|Suff
modifier|*
name|suff
decl_stmt|;
name|Src
modifier|*
name|s2
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_SRC
specifier|const
name|LstNode
modifier|*
name|ln1
decl_stmt|;
endif|#
directive|endif
name|LST_FOREACH
argument_list|(
argument|ln
argument_list|,
argument|&targ->suff->children
argument_list|)
block|{
name|suff
operator|=
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|suff
operator|->
name|flags
operator|&
name|SUFF_NULL
operator|)
operator|&&
operator|*
name|suff
operator|->
name|name
operator|!=
literal|'\0'
condition|)
block|{
comment|/* 			 * If the suffix has been marked as the NULL suffix, 			 * also create a Src structure for a file with no suffix 			 * attached. Two birds, and all that... 			 */
name|s2
operator|=
name|SuffSrcCreate
argument_list|(
name|estrdup
argument_list|(
name|targ
operator|->
name|pref
argument_list|)
argument_list|,
name|targ
operator|->
name|pref
argument_list|,
name|suff
argument_list|,
name|targ
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|suff
operator|->
name|refCount
operator|++
expr_stmt|;
name|targ
operator|->
name|children
operator|+=
literal|1
expr_stmt|;
name|Lst_AtEnd
argument_list|(
name|l
argument_list|,
name|s2
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_SRC
name|Lst_AtEnd
argument_list|(
operator|&
name|targ
operator|->
name|cp
argument_list|,
name|s2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"1 add %p %p to %p:"
argument_list|,
name|targ
argument_list|,
name|s2
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|LST_FOREACH
argument_list|(
argument|ln1
argument_list|,
argument|l
argument_list|)
name|printf
argument_list|(
literal|"%p "
argument_list|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|Lst_Datum
argument_list|(
name|ln1
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|s2
operator|=
name|SuffSrcCreate
argument_list|(
name|str_concat
argument_list|(
name|targ
operator|->
name|pref
argument_list|,
name|suff
operator|->
name|name
argument_list|,
literal|0
argument_list|)
argument_list|,
name|targ
operator|->
name|pref
argument_list|,
name|suff
argument_list|,
name|targ
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|suff
operator|->
name|refCount
operator|++
expr_stmt|;
name|targ
operator|->
name|children
operator|+=
literal|1
expr_stmt|;
name|Lst_AtEnd
argument_list|(
name|l
argument_list|,
name|s2
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_SRC
name|Lst_AtEnd
argument_list|(
operator|&
name|targ
operator|->
name|cp
argument_list|,
name|s2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"2 add %p %p to %p:"
argument_list|,
name|targ
argument_list|,
name|s2
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|LST_FOREACH
argument_list|(
argument|ln1
argument_list|,
argument|l
argument_list|)
name|printf
argument_list|(
literal|"%p "
argument_list|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|Lst_Datum
argument_list|(
name|ln1
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_comment
comment|/*-  *----------------------------------------------------------------------  * SuffRemoveSrc --  *	Free all src structures in list that don't have a reference count  *	XXX this actually frees only the first of these.  *  * Results:  *	True if a src was removed  *  * Side Effects:  *	The memory is free'd.  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|SuffRemoveSrc
parameter_list|(
name|Lst
modifier|*
name|l
parameter_list|)
block|{
name|LstNode
modifier|*
name|ln
decl_stmt|,
modifier|*
name|ln1
decl_stmt|;
name|Src
modifier|*
name|s
decl_stmt|;
name|int
name|t
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_SRC
name|printf
argument_list|(
literal|"cleaning %lx: "
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|l
argument_list|)
expr_stmt|;
name|LST_FOREACH
argument_list|(
argument|ln
argument_list|,
argument|l
argument_list|)
name|printf
argument_list|(
literal|"%p "
argument_list|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|ln
operator|=
name|Lst_First
argument_list|(
name|l
argument_list|)
init|;
name|ln
operator|!=
name|NULL
condition|;
name|ln
operator|=
name|ln1
control|)
block|{
name|ln1
operator|=
name|Lst_Succ
argument_list|(
name|ln
argument_list|)
expr_stmt|;
name|s
operator|=
operator|(
name|Src
operator|*
operator|)
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|children
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|s
operator|->
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
operator|->
name|parent
condition|)
name|free
argument_list|(
name|s
operator|->
name|pref
argument_list|)
expr_stmt|;
else|else
block|{
ifdef|#
directive|ifdef
name|DEBUG_SRC
name|LstNode
modifier|*
name|ln
init|=
name|Lst_Member
argument_list|(
operator|&
name|s
operator|->
name|parent
operator|->
name|cp
argument_list|,
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|ln
operator|!=
name|NULL
condition|)
name|Lst_Remove
argument_list|(
operator|&
name|s
operator|->
name|parent
operator|->
name|cp
argument_list|,
name|ln
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|--
name|s
operator|->
name|parent
operator|->
name|children
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG_SRC
name|printf
argument_list|(
literal|"free: [l=%p] p=%p %d\n"
argument_list|,
name|l
argument_list|,
name|s
argument_list|,
name|s
operator|->
name|children
argument_list|)
expr_stmt|;
name|Lst_Destroy
argument_list|(
operator|&
name|s
operator|->
name|cp
argument_list|,
name|NOFREE
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|Lst_Remove
argument_list|(
name|l
argument_list|,
name|ln
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|t
operator||=
literal|1
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|DEBUG_SRC
else|else
block|{
specifier|const
name|LstNode
modifier|*
name|tln
decl_stmt|;
name|printf
argument_list|(
literal|"keep: [l=%p] p=%p %d: "
argument_list|,
name|l
argument_list|,
name|s
argument_list|,
name|s
operator|->
name|children
argument_list|)
expr_stmt|;
name|LST_FOREACH
argument_list|(
argument|tln
argument_list|,
argument|&s->cp
argument_list|)
name|printf
argument_list|(
literal|"%p "
argument_list|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|Lst_Datum
argument_list|(
name|tln
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
return|return
operator|(
name|t
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * SuffFindThem --  *	Find the first existing file/target in the list srcs  *  * Results:  *	The lowest structure in the chain of transformations  *  * Side Effects:  *	None  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|Src
modifier|*
name|SuffFindThem
parameter_list|(
name|Lst
modifier|*
name|srcs
parameter_list|,
name|Lst
modifier|*
name|slst
parameter_list|)
block|{
name|Src
modifier|*
name|s
decl_stmt|;
comment|/* current Src */
name|Src
modifier|*
name|rs
decl_stmt|;
comment|/* returned Src */
name|char
modifier|*
name|ptr
decl_stmt|;
name|rs
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|!
name|Lst_IsEmpty
argument_list|(
name|srcs
argument_list|)
condition|)
block|{
name|s
operator|=
name|Lst_DeQueue
argument_list|(
name|srcs
argument_list|)
expr_stmt|;
name|DEBUGF
argument_list|(
name|SUFF
argument_list|,
operator|(
literal|"\ttrying %s..."
operator|,
name|s
operator|->
name|file
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * A file is considered to exist if either a node exists in the 		 * graph for it or the file actually exists. 		 */
if|if
condition|(
name|Targ_FindNode
argument_list|(
name|s
operator|->
name|file
argument_list|,
name|TARG_NOCREATE
argument_list|)
operator|!=
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG_SRC
name|printf
argument_list|(
literal|"remove %p from %p\n"
argument_list|,
name|s
argument_list|,
name|srcs
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|rs
operator|=
name|s
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|ptr
operator|=
name|Path_FindFile
argument_list|(
name|s
operator|->
name|file
argument_list|,
operator|&
name|s
operator|->
name|suff
operator|->
name|searchPath
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|rs
operator|=
name|s
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_SRC
name|printf
argument_list|(
literal|"remove %p from %p\n"
argument_list|,
name|s
argument_list|,
name|srcs
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|free
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
break|break;
block|}
name|DEBUGF
argument_list|(
name|SUFF
argument_list|,
operator|(
literal|"not there\n"
operator|)
argument_list|)
expr_stmt|;
name|SuffAddLevel
argument_list|(
name|srcs
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|Lst_AtEnd
argument_list|(
name|slst
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rs
condition|)
block|{
name|DEBUGF
argument_list|(
name|SUFF
argument_list|,
operator|(
literal|"got it\n"
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rs
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * SuffFindCmds --  *	See if any of the children of the target in the Src structure is  *	one from which the target can be transformed. If there is one,  *	a Src structure is put together for it and returned.  *  * Results:  *	The Src structure of the "winning" child, or NULL if no such beast.  *  * Side Effects:  *	A Src structure may be allocated.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|Src
modifier|*
name|SuffFindCmds
parameter_list|(
name|Src
modifier|*
name|targ
parameter_list|,
name|Lst
modifier|*
name|slst
parameter_list|)
block|{
name|LstNode
modifier|*
name|ln
decl_stmt|;
comment|/* General-purpose list node */
name|GNode
modifier|*
name|t
decl_stmt|;
comment|/* Target GNode */
name|GNode
modifier|*
name|s
decl_stmt|;
comment|/* Source GNode */
name|int
name|prefLen
decl_stmt|;
comment|/* The length of the defined prefix */
name|Suff
modifier|*
name|suff
decl_stmt|;
comment|/* Suffix on matching beastie */
name|Src
modifier|*
name|ret
decl_stmt|;
comment|/* Return value */
name|char
modifier|*
name|cp
decl_stmt|;
name|t
operator|=
name|targ
operator|->
name|node
expr_stmt|;
name|prefLen
operator|=
name|strlen
argument_list|(
name|targ
operator|->
name|pref
argument_list|)
expr_stmt|;
for|for
control|(
name|ln
operator|=
name|Lst_First
argument_list|(
operator|&
name|t
operator|->
name|children
argument_list|)
init|;
name|ln
operator|!=
name|NULL
condition|;
name|ln
operator|=
name|Lst_Succ
argument_list|(
name|ln
argument_list|)
control|)
block|{
name|s
operator|=
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
expr_stmt|;
name|cp
operator|=
name|strrchr
argument_list|(
name|s
operator|->
name|name
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
block|{
name|cp
operator|=
name|s
operator|->
name|name
expr_stmt|;
block|}
else|else
block|{
name|cp
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|cp
argument_list|,
name|targ
operator|->
name|pref
argument_list|,
name|prefLen
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * The node matches the prefix ok, see if it has 			 * a known suffix. 			 */
name|suff
operator|=
name|SuffSuffFind
argument_list|(
operator|&
name|cp
index|[
name|prefLen
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|suff
operator|!=
name|NULL
condition|)
block|{
comment|/* 				 * It even has a known suffix, see if there's 				 * a transformation defined between the node's 				 * suffix and the target's suffix. 				 * 				 * XXX: Handle multi-stage transformations 				 * here, too. 				 */
if|if
condition|(
name|Lst_Member
argument_list|(
operator|&
name|suff
operator|->
name|parents
argument_list|,
name|targ
operator|->
name|suff
argument_list|)
operator|!=
name|NULL
condition|)
block|{
comment|/* 					 * Hot Damn! Create a new Src structure 					 * to describe this transformation 					 * (making sure to duplicate the 					 * source node's name so Suff_FindDeps 					 * can free it again (ick)), and return 					 * the new structure. 					 */
name|ret
operator|=
name|SuffSrcCreate
argument_list|(
name|estrdup
argument_list|(
name|s
operator|->
name|name
argument_list|)
argument_list|,
name|targ
operator|->
name|pref
argument_list|,
name|suff
argument_list|,
name|targ
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|suff
operator|->
name|refCount
operator|++
expr_stmt|;
name|targ
operator|->
name|children
operator|+=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_SRC
name|printf
argument_list|(
literal|"3 add %p %p\n"
argument_list|,
operator|&
name|targ
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|Lst_AtEnd
argument_list|(
operator|&
name|targ
operator|->
name|cp
argument_list|,
name|ret
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|Lst_AtEnd
argument_list|(
name|slst
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|DEBUGF
argument_list|(
name|SUFF
argument_list|,
operator|(
literal|"\tusing existing source "
literal|"%s\n"
operator|,
name|s
operator|->
name|name
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
block|}
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  * The child node contains variable references. Expand them and return  * a list of expansions.  */
end_comment

begin_function
specifier|static
name|void
name|SuffExpandVariables
parameter_list|(
name|GNode
modifier|*
name|parent
parameter_list|,
name|GNode
modifier|*
name|child
parameter_list|,
name|Lst
modifier|*
name|members
parameter_list|)
block|{
name|Buffer
modifier|*
name|buf
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|start
decl_stmt|;
name|Lst_Init
argument_list|(
name|members
argument_list|)
expr_stmt|;
name|DEBUGF
argument_list|(
name|SUFF
argument_list|,
operator|(
literal|"Expanding \"%s\"..."
operator|,
name|child
operator|->
name|name
operator|)
argument_list|)
expr_stmt|;
name|buf
operator|=
name|Var_Subst
argument_list|(
name|child
operator|->
name|name
argument_list|,
name|parent
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|cp
operator|=
name|Buf_Data
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|->
name|type
operator|&
name|OP_ARCHV
condition|)
block|{
comment|/* 		 * Node was an archive(member) target, so we 		 * want to call on the Arch module to find the 		 * nodes for us, expanding variables in the 		 * parent's context. 		 */
name|Arch_ParseArchive
argument_list|(
operator|&
name|cp
argument_list|,
name|members
argument_list|,
name|parent
argument_list|)
expr_stmt|;
name|Buf_Destroy
argument_list|(
name|buf
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Break the result into a vector of strings whose nodes we can find, 	 * then add those nodes to the members list. Unfortunately, we can't use 	 * brk_string b/c it doesn't understand about variable specifications 	 * with spaces in them... XXX 	 */
for|for
control|(
name|start
operator|=
name|cp
init|;
operator|*
name|start
operator|==
literal|' '
operator|||
operator|*
name|start
operator|==
literal|'\t'
condition|;
name|start
operator|++
control|)
empty_stmt|;
for|for
control|(
name|cp
operator|=
name|start
init|;
operator|*
name|cp
operator|!=
literal|'\0'
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|' '
operator|||
operator|*
name|cp
operator|==
literal|'\t'
condition|)
block|{
comment|/* 			 * White-space -- terminate element, find the node, 			 * add it, skip any further spaces. 			 */
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|Lst_AtEnd
argument_list|(
name|members
argument_list|,
name|Targ_FindNode
argument_list|(
name|start
argument_list|,
name|TARG_CREATE
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|==
literal|' '
operator|||
operator|*
name|cp
operator|==
literal|'\t'
condition|)
block|{
name|cp
operator|++
expr_stmt|;
block|}
comment|/* 			 * Adjust cp for increment at 			 * start of loop, but set start 			 * to first non-space. 			 */
name|start
operator|=
name|cp
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|cp
operator|==
literal|'$'
condition|)
block|{
comment|/* 			 * Start of a variable spec -- contact variable module 			 * to find the end so we can skip over it. 			 */
name|char
modifier|*
name|junk
decl_stmt|;
name|size_t
name|len
init|=
literal|0
decl_stmt|;
name|Boolean
name|doFree
decl_stmt|;
name|junk
operator|=
name|Var_Parse
argument_list|(
name|cp
argument_list|,
name|parent
argument_list|,
name|TRUE
argument_list|,
operator|&
name|len
argument_list|,
operator|&
name|doFree
argument_list|)
expr_stmt|;
if|if
condition|(
name|junk
operator|!=
name|var_Error
condition|)
block|{
name|cp
operator|+=
name|len
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|doFree
condition|)
block|{
name|free
argument_list|(
name|junk
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\\'
operator|&&
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
block|{
comment|/* 			 * Escaped something -- skip over it 			 */
name|cp
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cp
operator|!=
name|start
condition|)
block|{
comment|/* 		 * Stuff left over -- add it to the 		 * list too 		 */
name|Lst_AtEnd
argument_list|(
name|members
argument_list|,
name|Targ_FindNode
argument_list|(
name|start
argument_list|,
name|TARG_CREATE
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Buf_Destroy
argument_list|(
name|buf
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-  * The child node contains wildcards. Expand them and return a list of  * expansions.  */
end_comment

begin_function
specifier|static
name|void
name|SuffExpandWildcards
parameter_list|(
name|GNode
modifier|*
name|child
parameter_list|,
name|Lst
modifier|*
name|members
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|Lst
name|exp
decl_stmt|;
comment|/* List of expansions */
name|LstNode
modifier|*
name|ln
decl_stmt|;
name|struct
name|Path
modifier|*
name|path
decl_stmt|;
comment|/* Search path along which to expand */
name|Lst_Init
argument_list|(
name|members
argument_list|)
expr_stmt|;
comment|/* 	 * Find a path along which to expand the word. 	 * 	 * If the word has a known suffix, use that path. 	 * If it has no known suffix and we're allowed to use the null 	 *   suffix, use its path. 	 * Else use the default system search path. 	 */
name|LST_FOREACH
argument_list|(
argument|ln
argument_list|,
argument|&sufflist
argument_list|)
block|{
if|if
condition|(
name|SuffSuffIsSuffix
argument_list|(
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
argument_list|,
name|child
operator|->
name|name
argument_list|)
operator|!=
name|NULL
condition|)
break|break;
block|}
name|DEBUGF
argument_list|(
name|SUFF
argument_list|,
operator|(
literal|"Wildcard expanding \"%s\"..."
operator|,
name|child
operator|->
name|name
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ln
operator|!=
name|NULL
condition|)
block|{
name|Suff
modifier|*
name|s
init|=
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
decl_stmt|;
name|DEBUGF
argument_list|(
name|SUFF
argument_list|,
operator|(
literal|"suffix is \"%s\"..."
operator|,
name|s
operator|->
name|name
operator|)
argument_list|)
expr_stmt|;
name|path
operator|=
operator|&
name|s
operator|->
name|searchPath
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Use default search path 		 */
name|path
operator|=
operator|&
name|dirSearchPath
expr_stmt|;
block|}
comment|/* 	 * Expand the word along the chosen path 	 */
name|Lst_Init
argument_list|(
operator|&
name|exp
argument_list|)
expr_stmt|;
name|Path_Expand
argument_list|(
name|child
operator|->
name|name
argument_list|,
name|path
argument_list|,
operator|&
name|exp
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|Lst_IsEmpty
argument_list|(
operator|&
name|exp
argument_list|)
condition|)
block|{
comment|/* 		 * Fetch next expansion off the list and find its GNode 		 */
name|cp
operator|=
name|Lst_DeQueue
argument_list|(
operator|&
name|exp
argument_list|)
expr_stmt|;
name|DEBUGF
argument_list|(
name|SUFF
argument_list|,
operator|(
literal|"%s..."
operator|,
name|cp
operator|)
argument_list|)
expr_stmt|;
name|Lst_AtEnd
argument_list|(
name|members
argument_list|,
name|Targ_FindNode
argument_list|(
name|cp
argument_list|,
name|TARG_CREATE
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * SuffExpandChildren --  *	Expand the names of any children of a given node that contain  *	variable invocations or file wildcards into actual targets.  *  * Results:  *	== 0 (continue)  *  * Side Effects:  *	The expanded node is removed from the parent's list of children,  *	and the parent's unmade counter is decremented, but other nodes  * 	may be added.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|SuffExpandChildren
parameter_list|(
name|GNode
modifier|*
name|parent
parameter_list|,
name|LstNode
modifier|*
name|current
parameter_list|)
block|{
name|GNode
modifier|*
name|cchild
decl_stmt|;
comment|/* current child */
name|GNode
modifier|*
name|gn
decl_stmt|;
name|LstNode
modifier|*
name|prev
decl_stmt|;
comment|/* node after which to append new source */
name|Lst
name|members
decl_stmt|;
comment|/* expanded nodes */
if|if
condition|(
name|current
operator|==
name|NULL
condition|)
block|{
comment|/* start from begin of parent's children list */
name|current
operator|=
name|Lst_First
argument_list|(
operator|&
name|parent
operator|->
name|children
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|current
operator|!=
name|NULL
condition|)
block|{
name|cchild
operator|=
name|Lst_Datum
argument_list|(
name|current
argument_list|)
expr_stmt|;
comment|/* 		 * First do variable expansion -- this takes precedence over 		 * wildcard expansion. If the result contains wildcards, they'll 		 * be gotten to later since the resulting words are tacked 		 * instead of the current child onto the children list. 		 * 		 * XXXHB what if cchild contains lib.a(t1.o t2.o t3.o) but 		 * no $? 		 */
if|if
condition|(
name|strchr
argument_list|(
name|cchild
operator|->
name|name
argument_list|,
literal|'$'
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|SuffExpandVariables
argument_list|(
name|parent
argument_list|,
name|cchild
argument_list|,
operator|&
name|members
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Dir_HasWildcards
argument_list|(
name|cchild
operator|->
name|name
argument_list|)
condition|)
block|{
name|SuffExpandWildcards
argument_list|(
name|cchild
argument_list|,
operator|&
name|members
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* nothing special just advance to next child */
name|current
operator|=
name|LST_NEXT
argument_list|(
name|current
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * New nodes effectively take the place of the child, 		 * so place them after the child 		 */
name|prev
operator|=
name|current
expr_stmt|;
comment|/* 		 * Add all new elements to the parent node if they aren't 		 * already children of it. 		 */
while|while
condition|(
operator|!
name|Lst_IsEmpty
argument_list|(
operator|&
name|members
argument_list|)
condition|)
block|{
name|gn
operator|=
name|Lst_DeQueue
argument_list|(
operator|&
name|members
argument_list|)
expr_stmt|;
name|DEBUGF
argument_list|(
name|SUFF
argument_list|,
operator|(
literal|"%s..."
operator|,
name|gn
operator|->
name|name
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|Lst_Member
argument_list|(
operator|&
name|parent
operator|->
name|children
argument_list|,
name|gn
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|Lst_Append
argument_list|(
operator|&
name|parent
operator|->
name|children
argument_list|,
name|prev
argument_list|,
name|gn
argument_list|)
expr_stmt|;
name|prev
operator|=
name|Lst_Succ
argument_list|(
name|prev
argument_list|)
expr_stmt|;
name|Lst_AtEnd
argument_list|(
operator|&
name|gn
operator|->
name|parents
argument_list|,
name|parent
argument_list|)
expr_stmt|;
name|parent
operator|->
name|unmade
operator|++
expr_stmt|;
block|}
block|}
comment|/* 		 * Now the source is expanded, remove it from the list 		 * of children to keep it from being processed. 		 * Advance to the next child. 		 */
name|prev
operator|=
name|current
expr_stmt|;
name|current
operator|=
name|LST_NEXT
argument_list|(
name|current
argument_list|)
expr_stmt|;
name|parent
operator|->
name|unmade
operator|--
expr_stmt|;
name|Lst_Remove
argument_list|(
operator|&
name|parent
operator|->
name|children
argument_list|,
name|prev
argument_list|)
expr_stmt|;
name|DEBUGF
argument_list|(
name|SUFF
argument_list|,
operator|(
literal|"\n"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * SuffApplyTransform --  *	Apply a transformation rule, given the source and target nodes  *	and suffixes.  *  * Results:  *	TRUE if successful, FALSE if not.  *  * Side Effects:  *	The source and target are linked and the commands from the  *	transformation are added to the target node's commands list.  *	All attributes but OP_DEPMASK and OP_TRANSFORM are applied  *	to the target. The target also inherits all the sources for  *	the transformation rule.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|Boolean
name|SuffApplyTransform
parameter_list|(
name|GNode
modifier|*
name|tGn
parameter_list|,
name|GNode
modifier|*
name|sGn
parameter_list|,
name|Suff
modifier|*
name|t
parameter_list|,
name|Suff
modifier|*
name|s
parameter_list|)
block|{
name|LstNode
modifier|*
name|ln
decl_stmt|;
comment|/* General node */
name|char
modifier|*
name|tname
decl_stmt|;
comment|/* Name of transformation rule */
name|GNode
modifier|*
name|gn
decl_stmt|;
comment|/* Node for same */
if|if
condition|(
name|Lst_Member
argument_list|(
operator|&
name|tGn
operator|->
name|children
argument_list|,
name|sGn
argument_list|)
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * Not already linked, so form the proper links between the 		 * target and source. 		 */
name|Lst_AtEnd
argument_list|(
operator|&
name|tGn
operator|->
name|children
argument_list|,
name|sGn
argument_list|)
expr_stmt|;
name|Lst_AtEnd
argument_list|(
operator|&
name|sGn
operator|->
name|parents
argument_list|,
name|tGn
argument_list|)
expr_stmt|;
name|tGn
operator|->
name|unmade
operator|+=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|sGn
operator|->
name|type
operator|&
name|OP_OPMASK
operator|)
operator|==
name|OP_DOUBLEDEP
condition|)
block|{
comment|/* 		 * When a :: node is used as the implied source of a node, 		 * we have to link all its cohorts in as sources as well. Only 		 * the initial sGn gets the target in its iParents list, however 		 * as that will be sufficient to get the .IMPSRC variable set 		 * for tGn 		 */
for|for
control|(
name|ln
operator|=
name|Lst_First
argument_list|(
operator|&
name|sGn
operator|->
name|cohorts
argument_list|)
init|;
name|ln
operator|!=
name|NULL
condition|;
name|ln
operator|=
name|Lst_Succ
argument_list|(
name|ln
argument_list|)
control|)
block|{
name|gn
operator|=
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
expr_stmt|;
if|if
condition|(
name|Lst_Member
argument_list|(
operator|&
name|tGn
operator|->
name|children
argument_list|,
name|gn
argument_list|)
operator|==
name|NULL
condition|)
block|{
comment|/* 				 * Not already linked, so form the proper 				 * links between the target and source. 				 */
name|Lst_AtEnd
argument_list|(
operator|&
name|tGn
operator|->
name|children
argument_list|,
name|gn
argument_list|)
expr_stmt|;
name|Lst_AtEnd
argument_list|(
operator|&
name|gn
operator|->
name|parents
argument_list|,
name|tGn
argument_list|)
expr_stmt|;
name|tGn
operator|->
name|unmade
operator|+=
literal|1
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * Locate the transformation rule itself 	 */
name|tname
operator|=
name|str_concat
argument_list|(
name|s
operator|->
name|name
argument_list|,
name|t
operator|->
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gn
operator|=
name|SuffTransFind
argument_list|(
name|tname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tname
argument_list|)
expr_stmt|;
if|if
condition|(
name|gn
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * Not really such a transformation rule (can happen when we're 		 * called to link an OP_MEMBER and OP_ARCHV node), so return 		 * FALSE. 		 */
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|DEBUGF
argument_list|(
name|SUFF
argument_list|,
operator|(
literal|"\tapplying %s -> %s to \"%s\"\n"
operator|,
name|s
operator|->
name|name
operator|,
name|t
operator|->
name|name
operator|,
name|tGn
operator|->
name|name
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Record last child for expansion purposes 	 */
name|ln
operator|=
name|Lst_Last
argument_list|(
operator|&
name|tGn
operator|->
name|children
argument_list|)
expr_stmt|;
comment|/* 	 * Pass the buck to Make_HandleUse to apply the rule 	 */
name|Make_HandleUse
argument_list|(
name|gn
argument_list|,
name|tGn
argument_list|)
expr_stmt|;
comment|/* 	 * Deal with wildcards and variables in any acquired sources 	 */
name|ln
operator|=
name|Lst_Succ
argument_list|(
name|ln
argument_list|)
expr_stmt|;
if|if
condition|(
name|ln
operator|!=
name|NULL
condition|)
block|{
name|SuffExpandChildren
argument_list|(
name|tGn
argument_list|,
name|ln
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Keep track of another parent to which this beast is transformed so 	 * the .IMPSRC variable can be set correctly for the parent. 	 */
name|Lst_AtEnd
argument_list|(
operator|&
name|sGn
operator|->
name|iParents
argument_list|,
name|tGn
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * SuffFindArchiveDeps --  *	Locate dependencies for an OP_ARCHV node.  *  * Results:  *	None  *  * Side Effects:  *	Same as Suff_FindDeps  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|SuffFindArchiveDeps
parameter_list|(
name|GNode
modifier|*
name|gn
parameter_list|,
name|Lst
modifier|*
name|slst
parameter_list|)
block|{
name|char
modifier|*
name|eoarch
decl_stmt|;
comment|/* End of archive portion */
name|char
modifier|*
name|eoname
decl_stmt|;
comment|/* End of member portion */
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Start of member's name */
name|GNode
modifier|*
name|mem
decl_stmt|;
comment|/* Node for member */
name|Suff
modifier|*
name|ms
decl_stmt|;
comment|/* Suffix descriptor for member */
specifier|static
specifier|const
name|char
modifier|*
name|copy
index|[]
init|=
block|{
name|TARGET
block|,
comment|/* Must be first */
name|PREFIX
block|,
comment|/* Must be second */
block|}
decl_stmt|;
comment|/* 	 * The node is an archive(member) pair. so we must find a 	 * suffix for both of them. 	 */
name|eoarch
operator|=
name|strchr
argument_list|(
name|gn
operator|->
name|name
argument_list|,
literal|'('
argument_list|)
expr_stmt|;
name|eoname
operator|=
name|strchr
argument_list|(
name|eoarch
argument_list|,
literal|')'
argument_list|)
expr_stmt|;
operator|*
name|eoname
operator|=
literal|'\0'
expr_stmt|;
comment|/* Nuke parentheses during suffix search */
operator|*
name|eoarch
operator|=
literal|'\0'
expr_stmt|;
comment|/* So a suffix can be found */
name|name
operator|=
name|eoarch
operator|+
literal|1
expr_stmt|;
comment|/* 	 * To simplify things, call Suff_FindDeps recursively on the member now, 	 * so we can simply compare the member's .PREFIX and .TARGET variables 	 * to locate its suffix. This allows us to figure out the suffix to 	 * use for the archive without having to do a quadratic search over the 	 * suffix list, backtracking for each one... 	 */
name|mem
operator|=
name|Targ_FindNode
argument_list|(
name|name
argument_list|,
name|TARG_CREATE
argument_list|)
expr_stmt|;
name|SuffFindDeps
argument_list|(
name|mem
argument_list|,
name|slst
argument_list|)
expr_stmt|;
comment|/* 	 * Create the link between the two nodes right off 	 */
if|if
condition|(
name|Lst_Member
argument_list|(
operator|&
name|gn
operator|->
name|children
argument_list|,
name|mem
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|Lst_AtEnd
argument_list|(
operator|&
name|gn
operator|->
name|children
argument_list|,
name|mem
argument_list|)
expr_stmt|;
name|Lst_AtEnd
argument_list|(
operator|&
name|mem
operator|->
name|parents
argument_list|,
name|gn
argument_list|)
expr_stmt|;
name|gn
operator|->
name|unmade
operator|+=
literal|1
expr_stmt|;
block|}
comment|/* 	 * Copy in the variables from the member node to this one. 	 */
name|Var_Set
argument_list|(
name|copy
index|[
literal|1
index|]
argument_list|,
name|Var_Value
argument_list|(
name|copy
index|[
literal|1
index|]
argument_list|,
name|mem
argument_list|)
argument_list|,
name|gn
argument_list|)
expr_stmt|;
name|Var_Set
argument_list|(
name|copy
index|[
literal|0
index|]
argument_list|,
name|Var_Value
argument_list|(
name|copy
index|[
literal|0
index|]
argument_list|,
name|mem
argument_list|)
argument_list|,
name|gn
argument_list|)
expr_stmt|;
name|ms
operator|=
name|mem
operator|->
name|suffix
expr_stmt|;
if|if
condition|(
name|ms
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * Didn't know what it was -- use .NULL suffix if not in 		 * make mode 		 */
name|DEBUGF
argument_list|(
name|SUFF
argument_list|,
operator|(
literal|"using null suffix\n"
operator|)
argument_list|)
expr_stmt|;
name|ms
operator|=
name|suffNull
expr_stmt|;
block|}
comment|/* 	* Set the other two local variables required for this target. 	*/
name|Var_Set
argument_list|(
name|MEMBER
argument_list|,
name|name
argument_list|,
name|gn
argument_list|)
expr_stmt|;
name|Var_Set
argument_list|(
name|ARCHIVE
argument_list|,
name|gn
operator|->
name|name
argument_list|,
name|gn
argument_list|)
expr_stmt|;
if|if
condition|(
name|ms
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Member has a known suffix, so look for a transformation rule 		 * from it to a possible suffix of the archive. Rather than 		 * searching through the entire list, we just look at suffixes 		 * to which the member's suffix may be transformed... 		 */
name|LstNode
modifier|*
name|ln
decl_stmt|;
comment|/* 		 * Use first matching suffix... 		 */
name|LST_FOREACH
argument_list|(
argument|ln
argument_list|,
argument|&ms->parents
argument_list|)
block|{
if|if
condition|(
name|SuffSuffIsSuffix
argument_list|(
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
argument_list|,
name|gn
operator|->
name|name
argument_list|)
operator|!=
name|NULL
condition|)
break|break;
block|}
if|if
condition|(
name|ln
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * Got one -- apply it 			 */
if|if
condition|(
operator|!
name|SuffApplyTransform
argument_list|(
name|gn
argument_list|,
name|mem
argument_list|,
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
argument_list|,
name|ms
argument_list|)
condition|)
block|{
name|DEBUGF
argument_list|(
name|SUFF
argument_list|,
operator|(
literal|"\tNo transformation from "
literal|"%s -> %s\n"
operator|,
name|ms
operator|->
name|name
operator|,
operator|(
operator|(
name|Suff
operator|*
operator|)
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
operator|)
operator|->
name|name
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * Replace the opening and closing parens now we've no need 	 * of the separate pieces. 	 */
operator|*
name|eoarch
operator|=
literal|'('
expr_stmt|;
operator|*
name|eoname
operator|=
literal|')'
expr_stmt|;
comment|/* 	 * Pretend gn appeared to the left of a dependency operator so 	 * the user needn't provide a transformation from the member to the 	 * archive. 	 */
if|if
condition|(
name|OP_NOP
argument_list|(
name|gn
operator|->
name|type
argument_list|)
condition|)
block|{
name|gn
operator|->
name|type
operator||=
name|OP_DEPENDS
expr_stmt|;
block|}
comment|/* 	 * Flag the member as such so we remember to look in the archive for 	 * its modification time. 	 */
name|mem
operator|->
name|type
operator||=
name|OP_MEMBER
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * SuffFindNormalDeps --  *	Locate implicit dependencies for regular targets.  *  * Results:  *	None.  *  * Side Effects:  *	Same as Suff_FindDeps...  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|SuffFindNormalDeps
parameter_list|(
name|GNode
modifier|*
name|gn
parameter_list|,
name|Lst
modifier|*
name|slst
parameter_list|)
block|{
name|char
modifier|*
name|eoname
decl_stmt|;
comment|/* End of name */
name|char
modifier|*
name|sopref
decl_stmt|;
comment|/* Start of prefix */
name|LstNode
modifier|*
name|ln
decl_stmt|;
comment|/* Next suffix node to check */
name|Lst
name|srcs
decl_stmt|;
comment|/* List of sources at which to look */
name|Lst
name|targs
decl_stmt|;
comment|/* List of targets to which things can be 				 * transformed. They all have the same file, 				 * but different suff and pref fields */
name|Src
modifier|*
name|bottom
decl_stmt|;
comment|/* Start of found transformation path */
name|Src
modifier|*
name|src
decl_stmt|;
comment|/* General Src pointer */
name|char
modifier|*
name|pref
decl_stmt|;
comment|/* Prefix to use */
name|Src
modifier|*
name|targ
decl_stmt|;
comment|/* General Src target pointer */
name|eoname
operator|=
name|gn
operator|->
name|name
operator|+
name|strlen
argument_list|(
name|gn
operator|->
name|name
argument_list|)
expr_stmt|;
name|sopref
operator|=
name|gn
operator|->
name|name
expr_stmt|;
comment|/* 	 * Begin at the beginning... 	 */
name|ln
operator|=
name|Lst_First
argument_list|(
operator|&
name|sufflist
argument_list|)
expr_stmt|;
name|Lst_Init
argument_list|(
operator|&
name|srcs
argument_list|)
expr_stmt|;
name|Lst_Init
argument_list|(
operator|&
name|targs
argument_list|)
expr_stmt|;
comment|/* 	 * We're caught in a catch-22 here. On the one hand, we want to use any 	 * transformation implied by the target's sources, but we can't examine 	 * the sources until we've expanded any variables/wildcards they may 	 * hold, and we can't do that until we've set up the target's local 	 * variables and we can't do that until we know what the proper suffix 	 * for the target is (in case there are two suffixes one of which is a 	 * suffix of the other) and we can't know that until we've found its 	 * implied source, which we may not want to use if there's an existing 	 * source that implies a different transformation. 	 * 	 * In an attempt to get around this, which may not work all the time, 	 * but should work most of the time, we look for implied sources first, 	 * checking transformations to all possible suffixes of the target, 	 * use what we find to set the target's local variables, expand the 	 * children, then look for any overriding transformations they imply. 	 * Should we find one, we discard the one we found before. 	 */
while|while
condition|(
name|ln
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Look for next possible suffix... 		 */
while|while
condition|(
name|ln
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|SuffSuffIsSuffix
argument_list|(
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
argument_list|,
name|gn
operator|->
name|name
argument_list|)
operator|!=
name|NULL
condition|)
break|break;
name|ln
operator|=
name|LST_NEXT
argument_list|(
name|ln
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ln
operator|!=
name|NULL
condition|)
block|{
name|int
name|prefLen
decl_stmt|;
comment|/* Length of the prefix */
name|Src
modifier|*
name|target
decl_stmt|;
comment|/* 			 * Allocate a Src structure to which things can be 			 * transformed 			 */
name|target
operator|=
name|SuffSrcCreate
argument_list|(
name|estrdup
argument_list|(
name|gn
operator|->
name|name
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|gn
argument_list|)
expr_stmt|;
name|target
operator|->
name|suff
operator|->
name|refCount
operator|++
expr_stmt|;
comment|/* 			 * Allocate room for the prefix, whose end is found 			 * by subtracting the length of the suffix from 			 * the end of the name. 			 */
name|prefLen
operator|=
operator|(
name|eoname
operator|-
name|target
operator|->
name|suff
operator|->
name|nameLen
operator|)
operator|-
name|sopref
expr_stmt|;
name|assert
argument_list|(
name|prefLen
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|target
operator|->
name|pref
operator|=
name|emalloc
argument_list|(
name|prefLen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|target
operator|->
name|pref
argument_list|,
name|sopref
argument_list|,
name|prefLen
argument_list|)
expr_stmt|;
name|target
operator|->
name|pref
index|[
name|prefLen
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* 			 * Add nodes from which the target can be made 			 */
name|SuffAddLevel
argument_list|(
operator|&
name|srcs
argument_list|,
name|target
argument_list|)
expr_stmt|;
comment|/* 			 * Record the target so we can nuke it 			 */
name|Lst_AtEnd
argument_list|(
operator|&
name|targs
argument_list|,
name|target
argument_list|)
expr_stmt|;
comment|/* 			 * Search from this suffix's successor... 			 */
name|ln
operator|=
name|Lst_Succ
argument_list|(
name|ln
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Handle target of unknown suffix... 	 */
if|if
condition|(
name|Lst_IsEmpty
argument_list|(
operator|&
name|targs
argument_list|)
operator|&&
name|suffNull
operator|!=
name|NULL
condition|)
block|{
name|DEBUGF
argument_list|(
name|SUFF
argument_list|,
operator|(
literal|"\tNo known suffix on %s. Using .NULL suffix\n"
operator|,
name|gn
operator|->
name|name
operator|)
argument_list|)
expr_stmt|;
name|targ
operator|=
name|SuffSrcCreate
argument_list|(
name|estrdup
argument_list|(
name|gn
operator|->
name|name
argument_list|)
argument_list|,
name|estrdup
argument_list|(
name|sopref
argument_list|)
argument_list|,
name|suffNull
argument_list|,
name|NULL
argument_list|,
name|gn
argument_list|)
expr_stmt|;
name|targ
operator|->
name|suff
operator|->
name|refCount
operator|++
expr_stmt|;
comment|/* 		 * Only use the default suffix rules if we don't have commands 		 * or dependencies defined for this gnode 		 */
if|if
condition|(
name|Lst_IsEmpty
argument_list|(
operator|&
name|gn
operator|->
name|commands
argument_list|)
operator|&&
name|Lst_IsEmpty
argument_list|(
operator|&
name|gn
operator|->
name|children
argument_list|)
condition|)
name|SuffAddLevel
argument_list|(
operator|&
name|srcs
argument_list|,
name|targ
argument_list|)
expr_stmt|;
else|else
block|{
name|DEBUGF
argument_list|(
name|SUFF
argument_list|,
operator|(
literal|"not "
operator|)
argument_list|)
expr_stmt|;
block|}
name|DEBUGF
argument_list|(
name|SUFF
argument_list|,
operator|(
literal|"adding suffix rules\n"
operator|)
argument_list|)
expr_stmt|;
name|Lst_AtEnd
argument_list|(
operator|&
name|targs
argument_list|,
name|targ
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Using the list of possible sources built up from the target 	 * suffix(es), try and find an existing file/target that matches. 	 */
name|bottom
operator|=
name|SuffFindThem
argument_list|(
operator|&
name|srcs
argument_list|,
name|slst
argument_list|)
expr_stmt|;
if|if
condition|(
name|bottom
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * No known transformations -- use the first suffix found for 		 * setting the local variables. 		 */
if|if
condition|(
operator|!
name|Lst_IsEmpty
argument_list|(
operator|&
name|targs
argument_list|)
condition|)
block|{
name|targ
operator|=
name|Lst_Datum
argument_list|(
name|Lst_First
argument_list|(
operator|&
name|targs
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|targ
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * Work up the transformation path to find the suffix of the 		 * target to which the transformation was made. 		 */
for|for
control|(
name|targ
operator|=
name|bottom
init|;
name|targ
operator|->
name|parent
operator|!=
name|NULL
condition|;
name|targ
operator|=
name|targ
operator|->
name|parent
control|)
continue|continue;
block|}
comment|/* 	 * The .TARGET variable we always set to be the name at this point, 	 * since it's only set to the path if the thing is only a source and 	 * if it's only a source, it doesn't matter what we put here as far 	 * as expanding sources is concerned, since it has none... 	 */
name|Var_Set
argument_list|(
name|TARGET
argument_list|,
name|gn
operator|->
name|name
argument_list|,
name|gn
argument_list|)
expr_stmt|;
name|pref
operator|=
operator|(
name|targ
operator|!=
name|NULL
operator|)
condition|?
name|targ
operator|->
name|pref
else|:
name|gn
operator|->
name|name
expr_stmt|;
name|Var_Set
argument_list|(
name|PREFIX
argument_list|,
name|pref
argument_list|,
name|gn
argument_list|)
expr_stmt|;
comment|/* 	 * Now we've got the important local variables set, expand any sources 	 * that still contain variables or wildcards in their names. 	 */
name|SuffExpandChildren
argument_list|(
name|gn
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|targ
operator|==
name|NULL
condition|)
block|{
name|DEBUGF
argument_list|(
name|SUFF
argument_list|,
operator|(
literal|"\tNo valid suffix on %s\n"
operator|,
name|gn
operator|->
name|name
operator|)
argument_list|)
expr_stmt|;
name|sfnd_abort
label|:
comment|/* 		 * Deal with finding the thing on the default search path if the 		 * node is only a source (not on the lhs of a dependency 		 * operator or [XXX] it has neither children or commands). 		 */
if|if
condition|(
name|OP_NOP
argument_list|(
name|gn
operator|->
name|type
argument_list|)
operator|||
operator|(
name|Lst_IsEmpty
argument_list|(
operator|&
name|gn
operator|->
name|children
argument_list|)
operator|&&
name|Lst_IsEmpty
argument_list|(
operator|&
name|gn
operator|->
name|commands
argument_list|)
operator|)
condition|)
block|{
name|gn
operator|->
name|path
operator|=
name|Path_FindFile
argument_list|(
name|gn
operator|->
name|name
argument_list|,
operator|(
name|targ
operator|==
name|NULL
condition|?
operator|&
name|dirSearchPath
else|:
operator|&
name|targ
operator|->
name|suff
operator|->
name|searchPath
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|gn
operator|->
name|path
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|ptr
decl_stmt|;
name|Var_Set
argument_list|(
name|TARGET
argument_list|,
name|gn
operator|->
name|path
argument_list|,
name|gn
argument_list|)
expr_stmt|;
if|if
condition|(
name|targ
operator|!=
name|NULL
condition|)
block|{
comment|/* 					 * Suffix known for the thing -- trim 					 * the suffix off the path to form the 					 * proper .PREFIX variable. 					 */
name|int
name|savep
init|=
name|strlen
argument_list|(
name|gn
operator|->
name|path
argument_list|)
operator|-
name|targ
operator|->
name|suff
operator|->
name|nameLen
decl_stmt|;
name|char
name|savec
decl_stmt|;
if|if
condition|(
name|gn
operator|->
name|suffix
condition|)
name|gn
operator|->
name|suffix
operator|->
name|refCount
operator|--
expr_stmt|;
name|gn
operator|->
name|suffix
operator|=
name|targ
operator|->
name|suff
expr_stmt|;
name|gn
operator|->
name|suffix
operator|->
name|refCount
operator|++
expr_stmt|;
name|savec
operator|=
name|gn
operator|->
name|path
index|[
name|savep
index|]
expr_stmt|;
name|gn
operator|->
name|path
index|[
name|savep
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|ptr
operator|=
name|strrchr
argument_list|(
name|gn
operator|->
name|path
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|ptr
operator|++
expr_stmt|;
else|else
name|ptr
operator|=
name|gn
operator|->
name|path
expr_stmt|;
name|Var_Set
argument_list|(
name|PREFIX
argument_list|,
name|ptr
argument_list|,
name|gn
argument_list|)
expr_stmt|;
name|gn
operator|->
name|path
index|[
name|savep
index|]
operator|=
name|savec
expr_stmt|;
block|}
else|else
block|{
comment|/* 					 * The .PREFIX gets the full path if 					 * the target has no known suffix. 					 */
if|if
condition|(
name|gn
operator|->
name|suffix
condition|)
name|gn
operator|->
name|suffix
operator|->
name|refCount
operator|--
expr_stmt|;
name|gn
operator|->
name|suffix
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|ptr
operator|=
name|strrchr
argument_list|(
name|gn
operator|->
name|path
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|ptr
operator|++
expr_stmt|;
else|else
name|ptr
operator|=
name|gn
operator|->
name|path
expr_stmt|;
name|Var_Set
argument_list|(
name|PREFIX
argument_list|,
name|ptr
argument_list|,
name|gn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* 			 * Not appropriate to search for the thing -- set the 			 * path to be the name so Dir_MTime won't go 			 * grovelling for it. 			 */
if|if
condition|(
name|gn
operator|->
name|suffix
condition|)
name|gn
operator|->
name|suffix
operator|->
name|refCount
operator|--
expr_stmt|;
name|gn
operator|->
name|suffix
operator|=
operator|(
name|targ
operator|==
name|NULL
operator|)
condition|?
name|NULL
else|:
name|targ
operator|->
name|suff
expr_stmt|;
if|if
condition|(
name|gn
operator|->
name|suffix
condition|)
name|gn
operator|->
name|suffix
operator|->
name|refCount
operator|++
expr_stmt|;
name|free
argument_list|(
name|gn
operator|->
name|path
argument_list|)
expr_stmt|;
name|gn
operator|->
name|path
operator|=
name|estrdup
argument_list|(
name|gn
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
goto|goto
name|sfnd_return
goto|;
block|}
comment|/* 	 * If the suffix indicates that the target is a library, mark that in 	 * the node's type field. 	 */
if|if
condition|(
name|targ
operator|->
name|suff
operator|->
name|flags
operator|&
name|SUFF_LIBRARY
condition|)
block|{
name|gn
operator|->
name|type
operator||=
name|OP_LIB
expr_stmt|;
block|}
comment|/* 	 * Check for overriding transformation rule implied by sources 	 */
if|if
condition|(
operator|!
name|Lst_IsEmpty
argument_list|(
operator|&
name|gn
operator|->
name|children
argument_list|)
condition|)
block|{
name|src
operator|=
name|SuffFindCmds
argument_list|(
name|targ
argument_list|,
name|slst
argument_list|)
expr_stmt|;
if|if
condition|(
name|src
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * Free up all the Src structures in the 			 * transformation path up to, but not including, 			 * the parent node. 			 */
while|while
condition|(
name|bottom
operator|&&
name|bottom
operator|->
name|parent
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|Lst_Member
argument_list|(
name|slst
argument_list|,
name|bottom
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|Lst_AtEnd
argument_list|(
name|slst
argument_list|,
name|bottom
argument_list|)
expr_stmt|;
block|}
name|bottom
operator|=
name|bottom
operator|->
name|parent
expr_stmt|;
block|}
name|bottom
operator|=
name|src
expr_stmt|;
block|}
block|}
if|if
condition|(
name|bottom
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * No idea from where it can come -- return now. 		 */
goto|goto
name|sfnd_abort
goto|;
block|}
comment|/* 	 * We now have a list of Src structures headed by 'bottom' and linked 	 * via their 'parent' pointers. What we do next is create links between 	 * source and target nodes (which may or may not have been created) 	 * and set the necessary local variables in each target. The 	 * commands for each target are set from the commands of the 	 * transformation rule used to get from the src suffix to the targ 	 * suffix. Note that this causes the commands list of the original 	 * node, gn, to be replaced by the commands of the final 	 * transformation rule. Also, the unmade field of gn is incremented. 	 * Etc. 	 */
if|if
condition|(
name|bottom
operator|->
name|node
operator|==
name|NULL
condition|)
block|{
name|bottom
operator|->
name|node
operator|=
name|Targ_FindNode
argument_list|(
name|bottom
operator|->
name|file
argument_list|,
name|TARG_CREATE
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|src
operator|=
name|bottom
init|;
name|src
operator|->
name|parent
operator|!=
name|NULL
condition|;
name|src
operator|=
name|src
operator|->
name|parent
control|)
block|{
name|targ
operator|=
name|src
operator|->
name|parent
expr_stmt|;
if|if
condition|(
name|src
operator|->
name|node
operator|->
name|suffix
condition|)
name|src
operator|->
name|node
operator|->
name|suffix
operator|->
name|refCount
operator|--
expr_stmt|;
name|src
operator|->
name|node
operator|->
name|suffix
operator|=
name|src
operator|->
name|suff
expr_stmt|;
name|src
operator|->
name|node
operator|->
name|suffix
operator|->
name|refCount
operator|++
expr_stmt|;
if|if
condition|(
name|targ
operator|->
name|node
operator|==
name|NULL
condition|)
block|{
name|targ
operator|->
name|node
operator|=
name|Targ_FindNode
argument_list|(
name|targ
operator|->
name|file
argument_list|,
name|TARG_CREATE
argument_list|)
expr_stmt|;
block|}
name|SuffApplyTransform
argument_list|(
name|targ
operator|->
name|node
argument_list|,
name|src
operator|->
name|node
argument_list|,
name|targ
operator|->
name|suff
argument_list|,
name|src
operator|->
name|suff
argument_list|)
expr_stmt|;
if|if
condition|(
name|targ
operator|->
name|node
operator|!=
name|gn
condition|)
block|{
comment|/* 			 * Finish off the dependency-search process for any 			 * nodes between bottom and gn (no point in questing 			 * around the filesystem for their implicit source 			 * when it's already known). Note that the node can't 			 * have any sources that need expanding, since 			 * SuffFindThem will stop on an existing 			 * node, so all we need to do is set the standard and 			 * System V variables. 			 */
name|targ
operator|->
name|node
operator|->
name|type
operator||=
name|OP_DEPS_FOUND
expr_stmt|;
name|Var_Set
argument_list|(
name|PREFIX
argument_list|,
name|targ
operator|->
name|pref
argument_list|,
name|targ
operator|->
name|node
argument_list|)
expr_stmt|;
name|Var_Set
argument_list|(
name|TARGET
argument_list|,
name|targ
operator|->
name|node
operator|->
name|name
argument_list|,
name|targ
operator|->
name|node
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|gn
operator|->
name|suffix
condition|)
name|gn
operator|->
name|suffix
operator|->
name|refCount
operator|--
expr_stmt|;
name|gn
operator|->
name|suffix
operator|=
name|src
operator|->
name|suff
expr_stmt|;
name|gn
operator|->
name|suffix
operator|->
name|refCount
operator|++
expr_stmt|;
comment|/* 	 * So Dir_MTime doesn't go questing for it... 	 */
name|free
argument_list|(
name|gn
operator|->
name|path
argument_list|)
expr_stmt|;
name|gn
operator|->
name|path
operator|=
name|estrdup
argument_list|(
name|gn
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* 	 * Nuke the transformation path and the Src structures left over in the 	 * two lists. 	 */
name|sfnd_return
label|:
if|if
condition|(
name|bottom
condition|)
if|if
condition|(
name|Lst_Member
argument_list|(
name|slst
argument_list|,
name|bottom
argument_list|)
operator|==
name|NULL
condition|)
name|Lst_AtEnd
argument_list|(
name|slst
argument_list|,
name|bottom
argument_list|)
expr_stmt|;
while|while
condition|(
name|SuffRemoveSrc
argument_list|(
operator|&
name|srcs
argument_list|)
operator|||
name|SuffRemoveSrc
argument_list|(
operator|&
name|targs
argument_list|)
condition|)
continue|continue;
name|Lst_Concat
argument_list|(
name|slst
argument_list|,
operator|&
name|srcs
argument_list|,
name|LST_CONCLINK
argument_list|)
expr_stmt|;
name|Lst_Concat
argument_list|(
name|slst
argument_list|,
operator|&
name|targs
argument_list|,
name|LST_CONCLINK
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Suff_FindDeps  --  *	Find implicit sources for the target described by the graph node  *	gn  *  * Results:  *	Nothing.  *  * Side Effects:  *	Nodes are added to the graph below the passed-in node. The nodes  *	are marked to have their IMPSRC variable filled in. The  *	PREFIX variable is set for the given node and all its  *	implied children.  *  * Notes:  *	The path found by this target is the shortest path in the  *	transformation graph, which may pass through non-existent targets,  *	to an existing target. The search continues on all paths from the  *	root suffix until a file is found. I.e. if there's a path  *	.o -> .c -> .l -> .l,v from the root and the .l,v file exists but  *	the .c and .l files don't, the search will branch out in  *	all directions from .o and again from all the nodes on the  *	next level until the .l,v node is encountered.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Suff_FindDeps
parameter_list|(
name|GNode
modifier|*
name|gn
parameter_list|)
block|{
name|SuffFindDeps
argument_list|(
name|gn
argument_list|,
operator|&
name|srclist
argument_list|)
expr_stmt|;
while|while
condition|(
name|SuffRemoveSrc
argument_list|(
operator|&
name|srclist
argument_list|)
condition|)
continue|continue;
block|}
end_function

begin_function
specifier|static
name|void
name|SuffFindDeps
parameter_list|(
name|GNode
modifier|*
name|gn
parameter_list|,
name|Lst
modifier|*
name|slst
parameter_list|)
block|{
if|if
condition|(
name|gn
operator|->
name|type
operator|&
name|OP_DEPS_FOUND
condition|)
block|{
comment|/* 		 * If dependencies already found, no need to do it again... 		 */
return|return;
block|}
else|else
block|{
name|gn
operator|->
name|type
operator||=
name|OP_DEPS_FOUND
expr_stmt|;
block|}
name|DEBUGF
argument_list|(
name|SUFF
argument_list|,
operator|(
literal|"SuffFindDeps (%s)\n"
operator|,
name|gn
operator|->
name|name
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|gn
operator|->
name|type
operator|&
name|OP_ARCHV
condition|)
block|{
name|SuffFindArchiveDeps
argument_list|(
name|gn
argument_list|,
name|slst
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|gn
operator|->
name|type
operator|&
name|OP_LIB
condition|)
block|{
comment|/* 		* If the node is a library, it is the arch module's job to find 		* it and set the TARGET variable accordingly. We merely provide 		* the search path, assuming all libraries end in ".a" (if the 		* suffix hasn't been defined, there's nothing we can do for it, 		* so we just set the TARGET variable to the node's name in order 		* to give it a value). 		*/
name|Suff
modifier|*
name|s
decl_stmt|;
name|s
operator|=
name|SuffSuffFind
argument_list|(
name|LIBSUFF
argument_list|)
expr_stmt|;
if|if
condition|(
name|gn
operator|->
name|suffix
condition|)
name|gn
operator|->
name|suffix
operator|->
name|refCount
operator|--
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
block|{
name|gn
operator|->
name|suffix
operator|=
name|s
expr_stmt|;
name|gn
operator|->
name|suffix
operator|->
name|refCount
operator|++
expr_stmt|;
name|Arch_FindLib
argument_list|(
name|gn
argument_list|,
operator|&
name|s
operator|->
name|searchPath
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gn
operator|->
name|suffix
operator|=
name|NULL
expr_stmt|;
name|Var_Set
argument_list|(
name|TARGET
argument_list|,
name|gn
operator|->
name|name
argument_list|,
name|gn
argument_list|)
expr_stmt|;
block|}
comment|/* 		* Because a library (-lfoo) target doesn't follow the standard 		* filesystem conventions, we don't set the regular variables for 		* the thing. .PREFIX is simply made empty... 		*/
name|Var_Set
argument_list|(
name|PREFIX
argument_list|,
literal|""
argument_list|,
name|gn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SuffFindNormalDeps
argument_list|(
name|gn
argument_list|,
name|slst
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Suff_SetNull --  *	Define which suffix is the null suffix.  *  * Results:  *	None.  *  * Side Effects:  *	'suffNull' is altered.  *  * Notes:  *	Need to handle the changing of the null suffix gracefully so the  *	old transformation rules don't just go away.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Suff_SetNull
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|Suff
modifier|*
name|s
decl_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|SuffSuffFind
argument_list|(
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|Parse_Error
argument_list|(
name|PARSE_WARNING
argument_list|,
literal|"Desired null suffix %s "
literal|"not defined."
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|suffNull
operator|!=
name|NULL
condition|)
block|{
name|suffNull
operator|->
name|flags
operator|&=
operator|~
name|SUFF_NULL
expr_stmt|;
block|}
name|s
operator|->
name|flags
operator||=
name|SUFF_NULL
expr_stmt|;
comment|/* 	 * XXX: Here's where the transformation mangling 	 * would take place 	 */
name|suffNull
operator|=
name|s
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Suff_Init --  *	Initialize suffixes module  *  * Results:  *	None  *  * Side Effects:  *	Many  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Suff_Init
parameter_list|(
name|void
parameter_list|)
block|{
name|sNum
operator|=
literal|0
expr_stmt|;
comment|/* 	* Create null suffix for single-suffix rules (POSIX). The thing doesn't 	* actually go on the suffix list or everyone will think that's its 	* suffix. 	*/
name|emptySuff
operator|=
name|suffNull
operator|=
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Suff
argument_list|)
argument_list|)
expr_stmt|;
name|suffNull
operator|->
name|name
operator|=
name|estrdup
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|suffNull
operator|->
name|nameLen
operator|=
literal|0
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|suffNull
operator|->
name|searchPath
argument_list|)
expr_stmt|;
name|Path_Concat
argument_list|(
operator|&
name|suffNull
operator|->
name|searchPath
argument_list|,
operator|&
name|dirSearchPath
argument_list|)
expr_stmt|;
name|Lst_Init
argument_list|(
operator|&
name|suffNull
operator|->
name|children
argument_list|)
expr_stmt|;
name|Lst_Init
argument_list|(
operator|&
name|suffNull
operator|->
name|parents
argument_list|)
expr_stmt|;
name|Lst_Init
argument_list|(
operator|&
name|suffNull
operator|->
name|ref
argument_list|)
expr_stmt|;
name|suffNull
operator|->
name|sNum
operator|=
name|sNum
operator|++
expr_stmt|;
name|suffNull
operator|->
name|flags
operator|=
name|SUFF_NULL
expr_stmt|;
name|suffNull
operator|->
name|refCount
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/********************* DEBUGGING FUNCTIONS **********************/
end_comment

begin_function
name|void
name|Suff_PrintAll
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|LstNode
modifier|*
name|ln
decl_stmt|;
specifier|const
name|LstNode
modifier|*
name|tln
decl_stmt|;
specifier|const
name|GNode
modifier|*
name|gn
decl_stmt|;
specifier|const
name|Suff
modifier|*
name|s
decl_stmt|;
specifier|static
specifier|const
name|struct
name|flag2str
name|suff_flags
index|[]
init|=
block|{
block|{
name|SUFF_INCLUDE
block|,
literal|"INCLUDE"
block|}
block|,
block|{
name|SUFF_LIBRARY
block|,
literal|"LIBRARY"
block|}
block|,
block|{
name|SUFF_NULL
block|,
literal|"NULL"
block|}
block|,
block|{
literal|0
block|,
name|NULL
block|}
block|}
decl_stmt|;
name|printf
argument_list|(
literal|"#*** Suffixes:\n"
argument_list|)
expr_stmt|;
name|LST_FOREACH
argument_list|(
argument|ln
argument_list|,
argument|&sufflist
argument_list|)
block|{
name|s
operator|=
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"# `%s' [%d] "
argument_list|,
name|s
operator|->
name|name
argument_list|,
name|s
operator|->
name|refCount
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|flags
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|print_flags
argument_list|(
name|stdout
argument_list|,
name|suff_flags
argument_list|,
name|s
operator|->
name|flags
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n#\tTo: "
argument_list|)
expr_stmt|;
name|LST_FOREACH
argument_list|(
argument|tln
argument_list|,
argument|&s->parents
argument_list|)
name|printf
argument_list|(
literal|"`%s' "
argument_list|,
operator|(
operator|(
specifier|const
name|Suff
operator|*
operator|)
name|Lst_Datum
argument_list|(
name|tln
argument_list|)
operator|)
operator|->
name|name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n#\tFrom: "
argument_list|)
expr_stmt|;
name|LST_FOREACH
argument_list|(
argument|tln
argument_list|,
argument|&s->children
argument_list|)
name|printf
argument_list|(
literal|"`%s' "
argument_list|,
operator|(
operator|(
specifier|const
name|Suff
operator|*
operator|)
name|Lst_Datum
argument_list|(
name|tln
argument_list|)
operator|)
operator|->
name|name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n#\tSearch Path: "
argument_list|)
expr_stmt|;
name|Path_Print
argument_list|(
operator|&
name|s
operator|->
name|searchPath
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"#*** Transformations:\n"
argument_list|)
expr_stmt|;
name|LST_FOREACH
argument_list|(
argument|ln
argument_list|,
argument|&transforms
argument_list|)
block|{
name|gn
operator|=
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%-16s: "
argument_list|,
name|gn
operator|->
name|name
argument_list|)
expr_stmt|;
name|Targ_PrintType
argument_list|(
name|gn
operator|->
name|type
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|LST_FOREACH
argument_list|(
argument|tln
argument_list|,
argument|&gn->commands
argument_list|)
name|printf
argument_list|(
literal|"\t%s\n"
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|Lst_Datum
argument_list|(
name|tln
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

