begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1988, 1989, 1990 The Regents of the University of California.  * Copyright (c) 1988, 1989 by Adam de Boor  * Copyright (c) 1989 by Berkeley Softworks  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Adam de Boor.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * @(#)cond.c	8.2 (Berkeley) 1/2/94  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__RCSID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/*-  * cond.c --  *	Functions to handle conditionals in a makefile.  *  * Interface:  *	Cond_Eval 	Evaluate the conditional in the passed line.  *  */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_include
include|#
directive|include
file|"make.h"
end_include

begin_include
include|#
directive|include
file|"hash.h"
end_include

begin_include
include|#
directive|include
file|"dir.h"
end_include

begin_include
include|#
directive|include
file|"buf.h"
end_include

begin_comment
comment|/*  * The parsing of conditional expressions is based on this grammar:  *	E -> F || E  *	E -> F  *	F -> T&& F  *	F -> T  *	T -> defined(variable)  *	T -> make(target)  *	T -> exists(file)  *	T -> empty(varspec)  *	T -> target(name)  *	T -> symbol  *	T -> $(varspec) op value  *	T -> $(varspec) == "string"  *	T -> $(varspec) != "string"  *	T -> ( E )  *	T -> ! T  *	op -> == | != |> |< |>= |<=  *  * 'symbol' is some other symbol to which the default function (condDefProc)  * is applied.  *  * Tokens are scanned from the 'condExpr' string. The scanner (CondToken)  * will return And for '&' and '&&', Or for '|' and '||', Not for '!',  * LParen for '(', RParen for ')' and will evaluate the other terminal  * symbols, using either the default function or the function given in the  * terminal, and return the result as either True or False.  *  * All Non-Terminal functions (CondE, CondF and CondT) return Err on error.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|And
block|,
name|Or
block|,
name|Not
block|,
name|True
block|,
name|False
block|,
name|LParen
block|,
name|RParen
block|,
name|EndOfFile
block|,
name|None
block|,
name|Err
block|}
name|Token
typedef|;
end_typedef

begin_comment
comment|/*-  * Structures to handle elegantly the different forms of #if's. The  * last two fields are stored in condInvert and condDefProc, respectively.  */
end_comment

begin_function_decl
specifier|static
name|void
name|CondPushBack
parameter_list|(
name|Token
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|CondGetArg
parameter_list|(
name|char
modifier|*
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|Boolean
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|Boolean
name|CondDoDefined
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|CondStrMatch
parameter_list|(
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|Boolean
name|CondDoMake
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|Boolean
name|CondDoExists
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|Boolean
name|CondDoTarget
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|CondCvtArg
parameter_list|(
name|char
modifier|*
parameter_list|,
name|double
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|Token
name|CondToken
parameter_list|(
name|Boolean
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|Token
name|CondT
parameter_list|(
name|Boolean
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|Token
name|CondF
parameter_list|(
name|Boolean
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|Token
name|CondE
parameter_list|(
name|Boolean
parameter_list|)
function_decl|;
end_function_decl

begin_struct
specifier|static
struct|struct
name|If
block|{
name|char
modifier|*
name|form
decl_stmt|;
comment|/* Form of if */
name|int
name|formlen
decl_stmt|;
comment|/* Length of form */
name|Boolean
name|doNot
decl_stmt|;
comment|/* TRUE if default function should be negated */
name|Boolean
function_decl|(
modifier|*
name|defProc
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
comment|/* Default function to apply */
block|}
name|ifs
index|[]
init|=
block|{
block|{
literal|"ifdef"
block|,
literal|5
block|,
name|FALSE
block|,
name|CondDoDefined
block|}
block|,
block|{
literal|"ifndef"
block|,
literal|6
block|,
name|TRUE
block|,
name|CondDoDefined
block|}
block|,
block|{
literal|"ifmake"
block|,
literal|6
block|,
name|FALSE
block|,
name|CondDoMake
block|}
block|,
block|{
literal|"ifnmake"
block|,
literal|7
block|,
name|TRUE
block|,
name|CondDoMake
block|}
block|,
block|{
literal|"if"
block|,
literal|2
block|,
name|FALSE
block|,
name|CondDoDefined
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
name|FALSE
block|,
name|NULL
block|}
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|Boolean
name|condInvert
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Invert the default function */
end_comment

begin_function_decl
specifier|static
name|Boolean
function_decl|(
modifier|*
name|condDefProc
function_decl|)
comment|/* Default function to apply */
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|char
modifier|*
name|condExpr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The expression to parse */
end_comment

begin_decl_stmt
specifier|static
name|Token
name|condPushBack
init|=
name|None
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Single push-back token used in 					 * parsing */
end_comment

begin_define
define|#
directive|define
name|MAXIF
value|30
end_define

begin_comment
comment|/* greatest depth of #if'ing */
end_comment

begin_decl_stmt
specifier|static
name|Boolean
name|condStack
index|[
name|MAXIF
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Stack of conditionals's values */
end_comment

begin_decl_stmt
specifier|static
name|int
name|condTop
init|=
name|MAXIF
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Top-most conditional */
end_comment

begin_decl_stmt
specifier|static
name|int
name|skipIfLevel
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Depth of skipped conditionals */
end_comment

begin_decl_stmt
specifier|static
name|Boolean
name|skipLine
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether the parse module is skipping 					 * lines */
end_comment

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * CondPushBack --  *	Push back the most recent token read. We only need one level of  *	this, so the thing is just stored in 'condPushback'.  *  * Results:  *	None.  *  * Side Effects:  *	condPushback is overwritten.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|CondPushBack
parameter_list|(
name|t
parameter_list|)
name|Token
name|t
decl_stmt|;
comment|/* Token to push back into the "stream" */
block|{
name|condPushBack
operator|=
name|t
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * CondGetArg --  *	Find the argument of a built-in function.  *  * Results:  *	The length of the argument and the address of the argument.  *  * Side Effects:  *	The pointer is set to point to the closing parenthesis of the  *	function call.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|CondGetArg
parameter_list|(
name|linePtr
parameter_list|,
name|argPtr
parameter_list|,
name|func
parameter_list|,
name|parens
parameter_list|)
name|char
modifier|*
modifier|*
name|linePtr
decl_stmt|;
name|char
modifier|*
modifier|*
name|argPtr
decl_stmt|;
name|char
modifier|*
name|func
decl_stmt|;
name|Boolean
name|parens
decl_stmt|;
comment|/* TRUE if arg should be bounded by parens */
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|argLen
decl_stmt|;
specifier|register
name|Buffer
name|buf
decl_stmt|;
name|cp
operator|=
operator|*
name|linePtr
expr_stmt|;
if|if
condition|(
name|parens
condition|)
block|{
while|while
condition|(
operator|*
name|cp
operator|!=
literal|'('
operator|&&
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
block|{
name|cp
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|cp
operator|==
literal|'('
condition|)
block|{
name|cp
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
condition|)
block|{
comment|/* 	 * No arguments whatsoever. Because 'make' and 'defined' aren't really 	 * "reserved words", we don't print a message. I think this is better 	 * than hitting the user with a warning message every time s/he uses 	 * the word 'make' or 'defined' at the beginning of a symbol... 	 */
operator|*
name|argPtr
operator|=
name|cp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
while|while
condition|(
operator|*
name|cp
operator|==
literal|' '
operator|||
operator|*
name|cp
operator|==
literal|'\t'
condition|)
block|{
name|cp
operator|++
expr_stmt|;
block|}
comment|/*      * Create a buffer for the argument and start it out at 16 characters      * long. Why 16? Why not?      */
name|buf
operator|=
name|Buf_Init
argument_list|(
literal|16
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|strchr
argument_list|(
literal|" \t)&|"
argument_list|,
operator|*
name|cp
argument_list|)
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
operator|&&
operator|(
operator|*
name|cp
operator|!=
literal|'\0'
operator|)
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'$'
condition|)
block|{
comment|/* 	     * Parse the variable spec and install it as part of the argument 	     * if it's valid. We tell Var_Parse to complain on an undefined 	     * variable, so we don't do it too. Nor do we return an error, 	     * though perhaps we should... 	     */
name|char
modifier|*
name|cp2
decl_stmt|;
name|int
name|len
decl_stmt|;
name|Boolean
name|doFree
decl_stmt|;
name|cp2
operator|=
name|Var_Parse
argument_list|(
name|cp
argument_list|,
name|VAR_CMD
argument_list|,
name|TRUE
argument_list|,
operator|&
name|len
argument_list|,
operator|&
name|doFree
argument_list|)
expr_stmt|;
name|Buf_AddBytes
argument_list|(
name|buf
argument_list|,
name|strlen
argument_list|(
name|cp2
argument_list|)
argument_list|,
operator|(
name|Byte
operator|*
operator|)
name|cp2
argument_list|)
expr_stmt|;
if|if
condition|(
name|doFree
condition|)
block|{
name|free
argument_list|(
name|cp2
argument_list|)
expr_stmt|;
block|}
name|cp
operator|+=
name|len
expr_stmt|;
block|}
else|else
block|{
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
operator|(
name|Byte
operator|)
operator|*
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|++
expr_stmt|;
block|}
block|}
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
operator|(
name|Byte
operator|)
literal|'\0'
argument_list|)
expr_stmt|;
operator|*
name|argPtr
operator|=
operator|(
name|char
operator|*
operator|)
name|Buf_GetAll
argument_list|(
name|buf
argument_list|,
operator|&
name|argLen
argument_list|)
expr_stmt|;
name|Buf_Destroy
argument_list|(
name|buf
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|==
literal|' '
operator|||
operator|*
name|cp
operator|==
literal|'\t'
condition|)
block|{
name|cp
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|parens
operator|&&
operator|*
name|cp
operator|!=
literal|')'
condition|)
block|{
name|Parse_Error
argument_list|(
name|PARSE_WARNING
argument_list|,
literal|"Missing closing parenthesis for %s()"
argument_list|,
name|func
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|parens
condition|)
block|{
comment|/* 	 * Advance pointer past close parenthesis. 	 */
name|cp
operator|++
expr_stmt|;
block|}
operator|*
name|linePtr
operator|=
name|cp
expr_stmt|;
return|return
operator|(
name|argLen
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * CondDoDefined --  *	Handle the 'defined' function for conditionals.  *  * Results:  *	TRUE if the given variable is defined.  *  * Side Effects:  *	None.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|Boolean
name|CondDoDefined
parameter_list|(
name|argLen
parameter_list|,
name|arg
parameter_list|)
name|int
name|argLen
decl_stmt|;
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|char
name|savec
init|=
name|arg
index|[
name|argLen
index|]
decl_stmt|;
name|char
modifier|*
name|p1
decl_stmt|;
name|Boolean
name|result
decl_stmt|;
name|arg
index|[
name|argLen
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|Var_Value
argument_list|(
name|arg
argument_list|,
name|VAR_CMD
argument_list|,
operator|&
name|p1
argument_list|)
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
name|result
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|FALSE
expr_stmt|;
block|}
name|efree
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|arg
index|[
name|argLen
index|]
operator|=
name|savec
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * CondStrMatch --  *	Front-end for Str_Match so it returns 0 on match and non-zero  *	on mismatch. Callback function for CondDoMake via Lst_Find  *  * Results:  *	0 if string matches pattern  *  * Side Effects:  *	None  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|CondStrMatch
parameter_list|(
name|string
parameter_list|,
name|pattern
parameter_list|)
name|void
modifier|*
name|string
decl_stmt|;
name|void
modifier|*
name|pattern
decl_stmt|;
block|{
return|return
operator|(
operator|!
name|Str_Match
argument_list|(
operator|(
name|char
operator|*
operator|)
name|string
argument_list|,
operator|(
name|char
operator|*
operator|)
name|pattern
argument_list|)
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * CondDoMake --  *	Handle the 'make' function for conditionals.  *  * Results:  *	TRUE if the given target is being made.  *  * Side Effects:  *	None.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|Boolean
name|CondDoMake
parameter_list|(
name|argLen
parameter_list|,
name|arg
parameter_list|)
name|int
name|argLen
decl_stmt|;
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|char
name|savec
init|=
name|arg
index|[
name|argLen
index|]
decl_stmt|;
name|Boolean
name|result
decl_stmt|;
name|arg
index|[
name|argLen
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|Lst_Find
argument_list|(
name|create
argument_list|,
operator|(
name|void
operator|*
operator|)
name|arg
argument_list|,
name|CondStrMatch
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|TRUE
expr_stmt|;
block|}
name|arg
index|[
name|argLen
index|]
operator|=
name|savec
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * CondDoExists --  *	See if the given file exists.  *  * Results:  *	TRUE if the file exists and FALSE if it does not.  *  * Side Effects:  *	None.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|Boolean
name|CondDoExists
parameter_list|(
name|argLen
parameter_list|,
name|arg
parameter_list|)
name|int
name|argLen
decl_stmt|;
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|char
name|savec
init|=
name|arg
index|[
name|argLen
index|]
decl_stmt|;
name|Boolean
name|result
decl_stmt|;
name|char
modifier|*
name|path
decl_stmt|;
name|arg
index|[
name|argLen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|path
operator|=
name|Dir_FindFile
argument_list|(
name|arg
argument_list|,
name|dirSearchPath
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
name|result
operator|=
name|TRUE
expr_stmt|;
name|free
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|FALSE
expr_stmt|;
block|}
name|arg
index|[
name|argLen
index|]
operator|=
name|savec
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * CondDoTarget --  *	See if the given node exists and is an actual target.  *  * Results:  *	TRUE if the node exists as a target and FALSE if it does not.  *  * Side Effects:  *	None.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|Boolean
name|CondDoTarget
parameter_list|(
name|argLen
parameter_list|,
name|arg
parameter_list|)
name|int
name|argLen
decl_stmt|;
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|char
name|savec
init|=
name|arg
index|[
name|argLen
index|]
decl_stmt|;
name|Boolean
name|result
decl_stmt|;
name|GNode
modifier|*
name|gn
decl_stmt|;
name|arg
index|[
name|argLen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|gn
operator|=
name|Targ_FindNode
argument_list|(
name|arg
argument_list|,
name|TARG_NOCREATE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|gn
operator|!=
name|NULL
operator|)
operator|&&
operator|!
name|OP_NOP
argument_list|(
name|gn
operator|->
name|type
argument_list|)
condition|)
block|{
name|result
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|FALSE
expr_stmt|;
block|}
name|arg
index|[
name|argLen
index|]
operator|=
name|savec
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * CondCvtArg --  *	Convert the given number into a double. If the number begins  *	with 0x, it is interpreted as a hexadecimal integer  *	and converted to a double from there. All other strings just have  *	strtod called on them.  *  * Results:  *	Sets 'value' to double value of string.  *	Returns address of the first character after the last valid  *	character of the converted number.  *  * Side Effects:  *	Can change 'value' even if string is not a valid number.  *  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|CondCvtArg
parameter_list|(
name|str
parameter_list|,
name|value
parameter_list|)
specifier|register
name|char
modifier|*
name|str
decl_stmt|;
name|double
modifier|*
name|value
decl_stmt|;
block|{
if|if
condition|(
operator|(
operator|*
name|str
operator|==
literal|'0'
operator|)
operator|&&
operator|(
name|str
index|[
literal|1
index|]
operator|==
literal|'x'
operator|)
condition|)
block|{
specifier|register
name|long
name|i
decl_stmt|;
for|for
control|(
name|str
operator|+=
literal|2
operator|,
name|i
operator|=
literal|0
init|;
condition|;
name|str
operator|++
control|)
block|{
name|int
name|x
decl_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|str
argument_list|)
condition|)
name|x
operator|=
operator|*
name|str
operator|-
literal|'0'
expr_stmt|;
elseif|else
if|if
condition|(
name|isxdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|str
argument_list|)
condition|)
name|x
operator|=
literal|10
operator|+
operator|*
name|str
operator|-
name|isupper
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|str
argument_list|)
condition|?
literal|'A'
else|:
literal|'a'
expr_stmt|;
else|else
block|{
operator|*
name|value
operator|=
operator|(
name|double
operator|)
name|i
expr_stmt|;
return|return
name|str
return|;
block|}
name|i
operator|=
operator|(
name|i
operator|<<
literal|4
operator|)
operator|+
name|x
expr_stmt|;
block|}
block|}
else|else
block|{
name|char
modifier|*
name|eptr
decl_stmt|;
operator|*
name|value
operator|=
name|strtod
argument_list|(
name|str
argument_list|,
operator|&
name|eptr
argument_list|)
expr_stmt|;
return|return
name|eptr
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * CondToken --  *	Return the next token from the input.  *  * Results:  *	A Token for the next lexical token in the stream.  *  * Side Effects:  *	condPushback will be set back to None if it is used.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|Token
name|CondToken
parameter_list|(
name|doEval
parameter_list|)
name|Boolean
name|doEval
decl_stmt|;
block|{
name|Token
name|t
decl_stmt|;
if|if
condition|(
name|condPushBack
operator|==
name|None
condition|)
block|{
while|while
condition|(
operator|*
name|condExpr
operator|==
literal|' '
operator|||
operator|*
name|condExpr
operator|==
literal|'\t'
condition|)
block|{
name|condExpr
operator|++
expr_stmt|;
block|}
switch|switch
condition|(
operator|*
name|condExpr
condition|)
block|{
case|case
literal|'('
case|:
name|t
operator|=
name|LParen
expr_stmt|;
name|condExpr
operator|++
expr_stmt|;
break|break;
case|case
literal|')'
case|:
name|t
operator|=
name|RParen
expr_stmt|;
name|condExpr
operator|++
expr_stmt|;
break|break;
case|case
literal|'|'
case|:
if|if
condition|(
name|condExpr
index|[
literal|1
index|]
operator|==
literal|'|'
condition|)
block|{
name|condExpr
operator|++
expr_stmt|;
block|}
name|condExpr
operator|++
expr_stmt|;
name|t
operator|=
name|Or
expr_stmt|;
break|break;
case|case
literal|'&'
case|:
if|if
condition|(
name|condExpr
index|[
literal|1
index|]
operator|==
literal|'&'
condition|)
block|{
name|condExpr
operator|++
expr_stmt|;
block|}
name|condExpr
operator|++
expr_stmt|;
name|t
operator|=
name|And
expr_stmt|;
break|break;
case|case
literal|'!'
case|:
name|t
operator|=
name|Not
expr_stmt|;
name|condExpr
operator|++
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
case|case
literal|'\0'
case|:
name|t
operator|=
name|EndOfFile
expr_stmt|;
break|break;
case|case
literal|'$'
case|:
block|{
name|char
modifier|*
name|lhs
decl_stmt|;
name|char
modifier|*
name|rhs
decl_stmt|;
name|char
modifier|*
name|op
decl_stmt|;
name|int
name|varSpecLen
decl_stmt|;
name|Boolean
name|doFree
decl_stmt|;
comment|/* 		 * Parse the variable spec and skip over it, saving its 		 * value in lhs. 		 */
name|t
operator|=
name|Err
expr_stmt|;
name|lhs
operator|=
name|Var_Parse
argument_list|(
name|condExpr
argument_list|,
name|VAR_CMD
argument_list|,
name|doEval
argument_list|,
operator|&
name|varSpecLen
argument_list|,
operator|&
name|doFree
argument_list|)
expr_stmt|;
if|if
condition|(
name|lhs
operator|==
name|var_Error
condition|)
block|{
comment|/* 		     * Even if !doEval, we still report syntax errors, which 		     * is what getting var_Error back with !doEval means. 		     */
return|return
operator|(
name|Err
operator|)
return|;
block|}
name|condExpr
operator|+=
name|varSpecLen
expr_stmt|;
if|if
condition|(
operator|!
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|condExpr
argument_list|)
operator|&&
name|strchr
argument_list|(
literal|"!=><"
argument_list|,
operator|*
name|condExpr
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|Buffer
name|buf
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|buf
operator|=
name|Buf_Init
argument_list|(
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|lhs
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
operator|(
name|Byte
operator|)
operator|*
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|doFree
condition|)
name|free
argument_list|(
name|lhs
argument_list|)
expr_stmt|;
for|for
control|(
init|;
operator|*
name|condExpr
operator|&&
operator|!
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|condExpr
argument_list|)
condition|;
name|condExpr
operator|++
control|)
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
operator|(
name|Byte
operator|)
operator|*
name|condExpr
argument_list|)
expr_stmt|;
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
operator|(
name|Byte
operator|)
literal|'\0'
argument_list|)
expr_stmt|;
name|lhs
operator|=
operator|(
name|char
operator|*
operator|)
name|Buf_GetAll
argument_list|(
name|buf
argument_list|,
operator|&
name|varSpecLen
argument_list|)
expr_stmt|;
name|Buf_Destroy
argument_list|(
name|buf
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|doFree
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* 		 * Skip whitespace to get to the operator 		 */
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|condExpr
argument_list|)
condition|)
name|condExpr
operator|++
expr_stmt|;
comment|/* 		 * Make sure the operator is a valid one. If it isn't a 		 * known relational operator, pretend we got a 		 * != 0 comparison. 		 */
name|op
operator|=
name|condExpr
expr_stmt|;
switch|switch
condition|(
operator|*
name|condExpr
condition|)
block|{
case|case
literal|'!'
case|:
case|case
literal|'='
case|:
case|case
literal|'<'
case|:
case|case
literal|'>'
case|:
if|if
condition|(
name|condExpr
index|[
literal|1
index|]
operator|==
literal|'='
condition|)
block|{
name|condExpr
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|condExpr
operator|+=
literal|1
expr_stmt|;
block|}
break|break;
default|default:
name|op
operator|=
literal|"!="
expr_stmt|;
name|rhs
operator|=
literal|"0"
expr_stmt|;
goto|goto
name|do_compare
goto|;
block|}
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|condExpr
argument_list|)
condition|)
block|{
name|condExpr
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|condExpr
operator|==
literal|'\0'
condition|)
block|{
name|Parse_Error
argument_list|(
name|PARSE_WARNING
argument_list|,
literal|"Missing right-hand-side of operator"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|rhs
operator|=
name|condExpr
expr_stmt|;
name|do_compare
label|:
if|if
condition|(
operator|*
name|rhs
operator|==
literal|'"'
condition|)
block|{
comment|/* 		     * Doing a string comparison. Only allow == and != for 		     * operators. 		     */
name|char
modifier|*
name|string
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|cp2
decl_stmt|;
name|int
name|qt
decl_stmt|;
name|Buffer
name|buf
decl_stmt|;
name|do_string_compare
label|:
if|if
condition|(
operator|(
operator|(
operator|*
name|op
operator|!=
literal|'!'
operator|)
operator|&&
operator|(
operator|*
name|op
operator|!=
literal|'='
operator|)
operator|)
operator|||
operator|(
name|op
index|[
literal|1
index|]
operator|!=
literal|'='
operator|)
condition|)
block|{
name|Parse_Error
argument_list|(
name|PARSE_WARNING
argument_list|,
literal|"String comparison operator should be either == or !="
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|buf
operator|=
name|Buf_Init
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|qt
operator|=
operator|*
name|rhs
operator|==
literal|'"'
condition|?
literal|1
else|:
literal|0
expr_stmt|;
for|for
control|(
name|cp
operator|=
operator|&
name|rhs
index|[
name|qt
index|]
init|;
operator|(
operator|(
name|qt
operator|&&
operator|(
operator|*
name|cp
operator|!=
literal|'"'
operator|)
operator|)
operator|||
operator|(
operator|!
name|qt
operator|&&
name|strchr
argument_list|(
literal|" \t)"
argument_list|,
operator|*
name|cp
argument_list|)
operator|==
name|NULL
operator|)
operator|)
operator|&&
operator|(
operator|*
name|cp
operator|!=
literal|'\0'
operator|)
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|cp
operator|==
literal|'\\'
operator|)
operator|&&
operator|(
name|cp
index|[
literal|1
index|]
operator|!=
literal|'\0'
operator|)
condition|)
block|{
comment|/* 			     * Backslash escapes things -- skip over next 			     * character, if it exists. 			     */
name|cp
operator|++
expr_stmt|;
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
operator|(
name|Byte
operator|)
operator|*
name|cp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|cp
operator|==
literal|'$'
condition|)
block|{
name|int
name|len
decl_stmt|;
name|Boolean
name|freeIt
decl_stmt|;
name|cp2
operator|=
name|Var_Parse
argument_list|(
name|cp
argument_list|,
name|VAR_CMD
argument_list|,
name|doEval
argument_list|,
operator|&
name|len
argument_list|,
operator|&
name|freeIt
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp2
operator|!=
name|var_Error
condition|)
block|{
name|Buf_AddBytes
argument_list|(
name|buf
argument_list|,
name|strlen
argument_list|(
name|cp2
argument_list|)
argument_list|,
operator|(
name|Byte
operator|*
operator|)
name|cp2
argument_list|)
expr_stmt|;
if|if
condition|(
name|freeIt
condition|)
block|{
name|free
argument_list|(
name|cp2
argument_list|)
expr_stmt|;
block|}
name|cp
operator|+=
name|len
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
operator|(
name|Byte
operator|)
operator|*
name|cp
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
operator|(
name|Byte
operator|)
operator|*
name|cp
argument_list|)
expr_stmt|;
block|}
block|}
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
operator|(
name|Byte
operator|)
literal|0
argument_list|)
expr_stmt|;
name|string
operator|=
operator|(
name|char
operator|*
operator|)
name|Buf_GetAll
argument_list|(
name|buf
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|Buf_Destroy
argument_list|(
name|buf
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEBUG
argument_list|(
name|COND
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"lhs = \"%s\", rhs = \"%s\", op = %.2s\n"
argument_list|,
name|lhs
argument_list|,
name|string
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
comment|/* 		     * Null-terminate rhs and perform the comparison. 		     * t is set to the result. 		     */
if|if
condition|(
operator|*
name|op
operator|==
literal|'='
condition|)
block|{
name|t
operator|=
name|strcmp
argument_list|(
name|lhs
argument_list|,
name|string
argument_list|)
condition|?
name|False
else|:
name|True
expr_stmt|;
block|}
else|else
block|{
name|t
operator|=
name|strcmp
argument_list|(
name|lhs
argument_list|,
name|string
argument_list|)
condition|?
name|True
else|:
name|False
expr_stmt|;
block|}
name|free
argument_list|(
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|rhs
operator|==
name|condExpr
condition|)
block|{
if|if
condition|(
operator|!
name|qt
operator|&&
operator|*
name|cp
operator|==
literal|')'
condition|)
name|condExpr
operator|=
name|cp
expr_stmt|;
else|else
name|condExpr
operator|=
name|cp
operator|+
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		     * rhs is either a float or an integer. Convert both the 		     * lhs and the rhs to a double and compare the two. 		     */
name|double
name|left
decl_stmt|,
name|right
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
if|if
condition|(
operator|*
name|CondCvtArg
argument_list|(
name|lhs
argument_list|,
operator|&
name|left
argument_list|)
operator|!=
literal|'\0'
condition|)
goto|goto
name|do_string_compare
goto|;
if|if
condition|(
operator|*
name|rhs
operator|==
literal|'$'
condition|)
block|{
name|int
name|len
decl_stmt|;
name|Boolean
name|freeIt
decl_stmt|;
name|string
operator|=
name|Var_Parse
argument_list|(
name|rhs
argument_list|,
name|VAR_CMD
argument_list|,
name|doEval
argument_list|,
operator|&
name|len
argument_list|,
operator|&
name|freeIt
argument_list|)
expr_stmt|;
if|if
condition|(
name|string
operator|==
name|var_Error
condition|)
block|{
name|right
operator|=
literal|0.0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|CondCvtArg
argument_list|(
name|string
argument_list|,
operator|&
name|right
argument_list|)
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|freeIt
condition|)
name|free
argument_list|(
name|string
argument_list|)
expr_stmt|;
goto|goto
name|do_string_compare
goto|;
block|}
if|if
condition|(
name|freeIt
condition|)
name|free
argument_list|(
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|rhs
operator|==
name|condExpr
condition|)
name|condExpr
operator|+=
name|len
expr_stmt|;
block|}
block|}
else|else
block|{
name|char
modifier|*
name|c
init|=
name|CondCvtArg
argument_list|(
name|rhs
argument_list|,
operator|&
name|right
argument_list|)
decl_stmt|;
if|if
condition|(
operator|*
name|c
operator|!=
literal|'\0'
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|c
argument_list|)
condition|)
goto|goto
name|do_string_compare
goto|;
if|if
condition|(
name|rhs
operator|==
name|condExpr
condition|)
block|{
comment|/* 			     * Skip over the right-hand side 			     */
while|while
condition|(
operator|!
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|condExpr
argument_list|)
operator|&&
operator|(
operator|*
name|condExpr
operator|!=
literal|'\0'
operator|)
condition|)
block|{
name|condExpr
operator|++
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|DEBUG
argument_list|(
name|COND
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"left = %f, right = %f, op = %.2s\n"
argument_list|,
name|left
argument_list|,
name|right
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|op
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'!'
case|:
if|if
condition|(
name|op
index|[
literal|1
index|]
operator|!=
literal|'='
condition|)
block|{
name|Parse_Error
argument_list|(
name|PARSE_WARNING
argument_list|,
literal|"Unknown operator"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|t
operator|=
operator|(
name|left
operator|!=
name|right
condition|?
name|True
else|:
name|False
operator|)
expr_stmt|;
break|break;
case|case
literal|'='
case|:
if|if
condition|(
name|op
index|[
literal|1
index|]
operator|!=
literal|'='
condition|)
block|{
name|Parse_Error
argument_list|(
name|PARSE_WARNING
argument_list|,
literal|"Unknown operator"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|t
operator|=
operator|(
name|left
operator|==
name|right
condition|?
name|True
else|:
name|False
operator|)
expr_stmt|;
break|break;
case|case
literal|'<'
case|:
if|if
condition|(
name|op
index|[
literal|1
index|]
operator|==
literal|'='
condition|)
block|{
name|t
operator|=
operator|(
name|left
operator|<=
name|right
condition|?
name|True
else|:
name|False
operator|)
expr_stmt|;
block|}
else|else
block|{
name|t
operator|=
operator|(
name|left
operator|<
name|right
condition|?
name|True
else|:
name|False
operator|)
expr_stmt|;
block|}
break|break;
case|case
literal|'>'
case|:
if|if
condition|(
name|op
index|[
literal|1
index|]
operator|==
literal|'='
condition|)
block|{
name|t
operator|=
operator|(
name|left
operator|>=
name|right
condition|?
name|True
else|:
name|False
operator|)
expr_stmt|;
block|}
else|else
block|{
name|t
operator|=
operator|(
name|left
operator|>
name|right
condition|?
name|True
else|:
name|False
operator|)
expr_stmt|;
block|}
break|break;
block|}
block|}
name|error
label|:
if|if
condition|(
name|doFree
condition|)
name|free
argument_list|(
name|lhs
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
block|{
name|Boolean
function_decl|(
modifier|*
name|evalProc
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
name|Boolean
name|invert
init|=
name|FALSE
decl_stmt|;
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|arglen
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|condExpr
argument_list|,
literal|"defined"
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 		     * Use CondDoDefined to evaluate the argument and 		     * CondGetArg to extract the argument from the 'function 		     * call'. 		     */
name|evalProc
operator|=
name|CondDoDefined
expr_stmt|;
name|condExpr
operator|+=
literal|7
expr_stmt|;
name|arglen
operator|=
name|CondGetArg
argument_list|(
operator|&
name|condExpr
argument_list|,
operator|&
name|arg
argument_list|,
literal|"defined"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|arglen
operator|==
literal|0
condition|)
block|{
name|condExpr
operator|-=
literal|7
expr_stmt|;
goto|goto
name|use_default
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|condExpr
argument_list|,
literal|"make"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 		     * Use CondDoMake to evaluate the argument and 		     * CondGetArg to extract the argument from the 'function 		     * call'. 		     */
name|evalProc
operator|=
name|CondDoMake
expr_stmt|;
name|condExpr
operator|+=
literal|4
expr_stmt|;
name|arglen
operator|=
name|CondGetArg
argument_list|(
operator|&
name|condExpr
argument_list|,
operator|&
name|arg
argument_list|,
literal|"make"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|arglen
operator|==
literal|0
condition|)
block|{
name|condExpr
operator|-=
literal|4
expr_stmt|;
goto|goto
name|use_default
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|condExpr
argument_list|,
literal|"exists"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 		     * Use CondDoExists to evaluate the argument and 		     * CondGetArg to extract the argument from the 		     * 'function call'. 		     */
name|evalProc
operator|=
name|CondDoExists
expr_stmt|;
name|condExpr
operator|+=
literal|6
expr_stmt|;
name|arglen
operator|=
name|CondGetArg
argument_list|(
operator|&
name|condExpr
argument_list|,
operator|&
name|arg
argument_list|,
literal|"exists"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|arglen
operator|==
literal|0
condition|)
block|{
name|condExpr
operator|-=
literal|6
expr_stmt|;
goto|goto
name|use_default
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|condExpr
argument_list|,
literal|"empty"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 		     * Use Var_Parse to parse the spec in parens and return 		     * True if the resulting string is empty. 		     */
name|int
name|length
decl_stmt|;
name|Boolean
name|doFree
decl_stmt|;
name|char
modifier|*
name|val
decl_stmt|;
name|condExpr
operator|+=
literal|5
expr_stmt|;
for|for
control|(
name|arglen
operator|=
literal|0
init|;
name|condExpr
index|[
name|arglen
index|]
operator|!=
literal|'('
operator|&&
name|condExpr
index|[
name|arglen
index|]
operator|!=
literal|'\0'
condition|;
name|arglen
operator|+=
literal|1
control|)
continue|continue;
if|if
condition|(
name|condExpr
index|[
name|arglen
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|val
operator|=
name|Var_Parse
argument_list|(
operator|&
name|condExpr
index|[
name|arglen
operator|-
literal|1
index|]
argument_list|,
name|VAR_CMD
argument_list|,
name|doEval
argument_list|,
operator|&
name|length
argument_list|,
operator|&
name|doFree
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|var_Error
condition|)
block|{
name|t
operator|=
name|Err
expr_stmt|;
block|}
else|else
block|{
comment|/* 			     * A variable is empty when it just contains 			     * spaces... 4/15/92, christos 			     */
name|char
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|val
init|;
operator|*
name|p
operator|&&
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p
argument_list|)
condition|;
name|p
operator|++
control|)
continue|continue;
name|t
operator|=
operator|(
operator|*
name|p
operator|==
literal|'\0'
operator|)
condition|?
name|True
else|:
name|False
expr_stmt|;
block|}
if|if
condition|(
name|doFree
condition|)
block|{
name|free
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * Advance condExpr to beyond the closing ). Note that 			 * we subtract one from arglen + length b/c length 			 * is calculated from condExpr[arglen - 1]. 			 */
name|condExpr
operator|+=
name|arglen
operator|+
name|length
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|condExpr
operator|-=
literal|5
expr_stmt|;
goto|goto
name|use_default
goto|;
block|}
break|break;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|condExpr
argument_list|,
literal|"target"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 		     * Use CondDoTarget to evaluate the argument and 		     * CondGetArg to extract the argument from the 		     * 'function call'. 		     */
name|evalProc
operator|=
name|CondDoTarget
expr_stmt|;
name|condExpr
operator|+=
literal|6
expr_stmt|;
name|arglen
operator|=
name|CondGetArg
argument_list|(
operator|&
name|condExpr
argument_list|,
operator|&
name|arg
argument_list|,
literal|"target"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|arglen
operator|==
literal|0
condition|)
block|{
name|condExpr
operator|-=
literal|6
expr_stmt|;
goto|goto
name|use_default
goto|;
block|}
block|}
else|else
block|{
comment|/* 		     * The symbol is itself the argument to the default 		     * function. We advance condExpr to the end of the symbol 		     * by hand (the next whitespace, closing paren or 		     * binary operator) and set to invert the evaluation 		     * function if condInvert is TRUE. 		     */
name|use_default
label|:
name|invert
operator|=
name|condInvert
expr_stmt|;
name|evalProc
operator|=
name|condDefProc
expr_stmt|;
name|arglen
operator|=
name|CondGetArg
argument_list|(
operator|&
name|condExpr
argument_list|,
operator|&
name|arg
argument_list|,
literal|""
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Evaluate the argument using the set function. If invert 		 * is TRUE, we invert the sense of the function. 		 */
name|t
operator|=
operator|(
operator|!
name|doEval
operator|||
call|(
modifier|*
name|evalProc
call|)
argument_list|(
name|arglen
argument_list|,
name|arg
argument_list|)
condition|?
operator|(
name|invert
condition|?
name|False
else|:
name|True
operator|)
else|:
operator|(
name|invert
condition|?
name|True
else|:
name|False
operator|)
operator|)
expr_stmt|;
name|free
argument_list|(
name|arg
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
else|else
block|{
name|t
operator|=
name|condPushBack
expr_stmt|;
name|condPushBack
operator|=
name|None
expr_stmt|;
block|}
return|return
operator|(
name|t
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * CondT --  *	Parse a single term in the expression. This consists of a terminal  *	symbol or Not and a terminal symbol (not including the binary  *	operators):  *	    T -> defined(variable) | make(target) | exists(file) | symbol  *	    T -> ! T | ( E )  *  * Results:  *	True, False or Err.  *  * Side Effects:  *	Tokens are consumed.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|Token
name|CondT
parameter_list|(
name|doEval
parameter_list|)
name|Boolean
name|doEval
decl_stmt|;
block|{
name|Token
name|t
decl_stmt|;
name|t
operator|=
name|CondToken
argument_list|(
name|doEval
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|EndOfFile
condition|)
block|{
comment|/* 	 * If we reached the end of the expression, the expression 	 * is malformed... 	 */
name|t
operator|=
name|Err
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t
operator|==
name|LParen
condition|)
block|{
comment|/* 	 * T -> ( E ) 	 */
name|t
operator|=
name|CondE
argument_list|(
name|doEval
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|!=
name|Err
condition|)
block|{
if|if
condition|(
name|CondToken
argument_list|(
name|doEval
argument_list|)
operator|!=
name|RParen
condition|)
block|{
name|t
operator|=
name|Err
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|t
operator|==
name|Not
condition|)
block|{
name|t
operator|=
name|CondT
argument_list|(
name|doEval
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|True
condition|)
block|{
name|t
operator|=
name|False
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t
operator|==
name|False
condition|)
block|{
name|t
operator|=
name|True
expr_stmt|;
block|}
block|}
return|return
operator|(
name|t
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * CondF --  *	Parse a conjunctive factor (nice name, wot?)  *	    F -> T&& F | T  *  * Results:  *	True, False or Err  *  * Side Effects:  *	Tokens are consumed.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|Token
name|CondF
parameter_list|(
name|doEval
parameter_list|)
name|Boolean
name|doEval
decl_stmt|;
block|{
name|Token
name|l
decl_stmt|,
name|o
decl_stmt|;
name|l
operator|=
name|CondT
argument_list|(
name|doEval
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|!=
name|Err
condition|)
block|{
name|o
operator|=
name|CondToken
argument_list|(
name|doEval
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
operator|==
name|And
condition|)
block|{
comment|/* 	     * F -> T&& F 	     * 	     * If T is False, the whole thing will be False, but we have to 	     * parse the r.h.s. anyway (to throw it away). 	     * If T is True, the result is the r.h.s., be it an Err or no. 	     */
if|if
condition|(
name|l
operator|==
name|True
condition|)
block|{
name|l
operator|=
name|CondF
argument_list|(
name|doEval
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|CondF
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 	     * F -> T 	     */
name|CondPushBack
argument_list|(
name|o
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|l
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * CondE --  *	Main expression production.  *	    E -> F || E | F  *  * Results:  *	True, False or Err.  *  * Side Effects:  *	Tokens are, of course, consumed.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|Token
name|CondE
parameter_list|(
name|doEval
parameter_list|)
name|Boolean
name|doEval
decl_stmt|;
block|{
name|Token
name|l
decl_stmt|,
name|o
decl_stmt|;
name|l
operator|=
name|CondF
argument_list|(
name|doEval
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|!=
name|Err
condition|)
block|{
name|o
operator|=
name|CondToken
argument_list|(
name|doEval
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
operator|==
name|Or
condition|)
block|{
comment|/* 	     * E -> F || E 	     * 	     * A similar thing occurs for ||, except that here we make sure 	     * the l.h.s. is False before we bother to evaluate the r.h.s. 	     * Once again, if l is False, the result is the r.h.s. and once 	     * again if l is True, we parse the r.h.s. to throw it away. 	     */
if|if
condition|(
name|l
operator|==
name|False
condition|)
block|{
name|l
operator|=
name|CondE
argument_list|(
name|doEval
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|CondE
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 	     * E -> F 	     */
name|CondPushBack
argument_list|(
name|o
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|l
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Cond_Eval --  *	Evaluate the conditional in the passed line. The line  *	looks like this:  *	    #<cond-type><expr>  *	where<cond-type> is any of if, ifmake, ifnmake, ifdef,  *	ifndef, elif, elifmake, elifnmake, elifdef, elifndef  *	and<expr> consists of&&, ||, !, make(target), defined(variable)  *	and parenthetical groupings thereof.  *  * Results:  *	COND_PARSE	if should parse lines after the conditional  *	COND_SKIP	if should skip lines after the conditional  *	COND_INVALID  	if not a valid conditional.  *  * Side Effects:  *	None.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Cond_Eval
parameter_list|(
name|line
parameter_list|)
name|char
modifier|*
name|line
decl_stmt|;
comment|/* Line to parse */
block|{
name|struct
name|If
modifier|*
name|ifp
decl_stmt|;
name|Boolean
name|isElse
decl_stmt|;
name|Boolean
name|value
init|=
name|FALSE
decl_stmt|;
name|int
name|level
decl_stmt|;
comment|/* Level at which to report errors. */
name|level
operator|=
name|PARSE_FATAL
expr_stmt|;
for|for
control|(
name|line
operator|++
init|;
operator|*
name|line
operator|==
literal|' '
operator|||
operator|*
name|line
operator|==
literal|'\t'
condition|;
name|line
operator|++
control|)
block|{
continue|continue;
block|}
comment|/*      * Find what type of if we're dealing with. The result is left      * in ifp and isElse is set TRUE if it's an elif line.      */
if|if
condition|(
name|line
index|[
literal|0
index|]
operator|==
literal|'e'
operator|&&
name|line
index|[
literal|1
index|]
operator|==
literal|'l'
condition|)
block|{
name|line
operator|+=
literal|2
expr_stmt|;
name|isElse
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|line
argument_list|,
literal|"endif"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 	 * End of a conditional section. If skipIfLevel is non-zero, that 	 * conditional was skipped, so lines following it should also be 	 * skipped. Hence, we return COND_SKIP. Otherwise, the conditional 	 * was read so succeeding lines should be parsed (think about it...) 	 * so we return COND_PARSE, unless this endif isn't paired with 	 * a decent if. 	 */
if|if
condition|(
name|skipIfLevel
operator|!=
literal|0
condition|)
block|{
name|skipIfLevel
operator|-=
literal|1
expr_stmt|;
return|return
operator|(
name|COND_SKIP
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|condTop
operator|==
name|MAXIF
condition|)
block|{
name|Parse_Error
argument_list|(
name|level
argument_list|,
literal|"if-less endif"
argument_list|)
expr_stmt|;
return|return
operator|(
name|COND_INVALID
operator|)
return|;
block|}
else|else
block|{
name|skipLine
operator|=
name|FALSE
expr_stmt|;
name|condTop
operator|+=
literal|1
expr_stmt|;
return|return
operator|(
name|COND_PARSE
operator|)
return|;
block|}
block|}
block|}
else|else
block|{
name|isElse
operator|=
name|FALSE
expr_stmt|;
block|}
comment|/*      * Figure out what sort of conditional it is -- what its default      * function is, etc. -- by looking in the table of valid "ifs"      */
for|for
control|(
name|ifp
operator|=
name|ifs
init|;
name|ifp
operator|->
name|form
operator|!=
operator|(
name|char
operator|*
operator|)
literal|0
condition|;
name|ifp
operator|++
control|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|ifp
operator|->
name|form
argument_list|,
name|line
argument_list|,
name|ifp
operator|->
name|formlen
argument_list|)
operator|==
literal|0
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|ifp
operator|->
name|form
operator|==
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
block|{
comment|/* 	 * Nothing fit. If the first word on the line is actually 	 * "else", it's a valid conditional whose value is the inverse 	 * of the previous if we parsed. 	 */
if|if
condition|(
name|isElse
operator|&&
operator|(
name|line
index|[
literal|0
index|]
operator|==
literal|'s'
operator|)
operator|&&
operator|(
name|line
index|[
literal|1
index|]
operator|==
literal|'e'
operator|)
condition|)
block|{
if|if
condition|(
name|condTop
operator|==
name|MAXIF
condition|)
block|{
name|Parse_Error
argument_list|(
name|level
argument_list|,
literal|"if-less else"
argument_list|)
expr_stmt|;
return|return
operator|(
name|COND_INVALID
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|skipIfLevel
operator|==
literal|0
condition|)
block|{
name|value
operator|=
operator|!
name|condStack
index|[
name|condTop
index|]
expr_stmt|;
block|}
else|else
block|{
return|return
operator|(
name|COND_SKIP
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/* 	     * Not a valid conditional type. No error... 	     */
return|return
operator|(
name|COND_INVALID
operator|)
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|isElse
condition|)
block|{
if|if
condition|(
name|condTop
operator|==
name|MAXIF
condition|)
block|{
name|Parse_Error
argument_list|(
name|level
argument_list|,
literal|"if-less elif"
argument_list|)
expr_stmt|;
return|return
operator|(
name|COND_INVALID
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|skipIfLevel
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * If skipping this conditional, just ignore the whole thing. 		 * If we don't, the user might be employing a variable that's 		 * undefined, for which there's an enclosing ifdef that 		 * we're skipping... 		 */
return|return
operator|(
name|COND_SKIP
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|skipLine
condition|)
block|{
comment|/* 	     * Don't even try to evaluate a conditional that's not an else if 	     * we're skipping things... 	     */
name|skipIfLevel
operator|+=
literal|1
expr_stmt|;
return|return
operator|(
name|COND_SKIP
operator|)
return|;
block|}
comment|/* 	 * Initialize file-global variables for parsing 	 */
name|condDefProc
operator|=
name|ifp
operator|->
name|defProc
expr_stmt|;
name|condInvert
operator|=
name|ifp
operator|->
name|doNot
expr_stmt|;
name|line
operator|+=
name|ifp
operator|->
name|formlen
expr_stmt|;
while|while
condition|(
operator|*
name|line
operator|==
literal|' '
operator|||
operator|*
name|line
operator|==
literal|'\t'
condition|)
block|{
name|line
operator|++
expr_stmt|;
block|}
name|condExpr
operator|=
name|line
expr_stmt|;
name|condPushBack
operator|=
name|None
expr_stmt|;
switch|switch
condition|(
name|CondE
argument_list|(
name|TRUE
argument_list|)
condition|)
block|{
case|case
name|True
case|:
if|if
condition|(
name|CondToken
argument_list|(
name|TRUE
argument_list|)
operator|==
name|EndOfFile
condition|)
block|{
name|value
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
goto|goto
name|err
goto|;
comment|/*FALLTHRU*/
case|case
name|False
case|:
if|if
condition|(
name|CondToken
argument_list|(
name|TRUE
argument_list|)
operator|==
name|EndOfFile
condition|)
block|{
name|value
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
comment|/*FALLTHRU*/
case|case
name|Err
case|:
name|err
label|:
name|Parse_Error
argument_list|(
name|level
argument_list|,
literal|"Malformed conditional (%s)"
argument_list|,
name|line
argument_list|)
expr_stmt|;
return|return
operator|(
name|COND_INVALID
operator|)
return|;
default|default:
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|isElse
condition|)
block|{
name|condTop
operator|-=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|skipIfLevel
operator|!=
literal|0
operator|)
operator|||
name|condStack
index|[
name|condTop
index|]
condition|)
block|{
comment|/* 	 * If this is an else-type conditional, it should only take effect 	 * if its corresponding if was evaluated and FALSE. If its if was 	 * TRUE or skipped, we return COND_SKIP (and start skipping in case 	 * we weren't already), leaving the stack unmolested so later elif's 	 * don't screw up... 	 */
name|skipLine
operator|=
name|TRUE
expr_stmt|;
return|return
operator|(
name|COND_SKIP
operator|)
return|;
block|}
if|if
condition|(
name|condTop
operator|<
literal|0
condition|)
block|{
comment|/* 	 * This is the one case where we can definitely proclaim a fatal 	 * error. If we don't, we're hosed. 	 */
name|Parse_Error
argument_list|(
name|PARSE_FATAL
argument_list|,
literal|"Too many nested if's. %d max."
argument_list|,
name|MAXIF
argument_list|)
expr_stmt|;
return|return
operator|(
name|COND_INVALID
operator|)
return|;
block|}
else|else
block|{
name|condStack
index|[
name|condTop
index|]
operator|=
name|value
expr_stmt|;
name|skipLine
operator|=
operator|!
name|value
expr_stmt|;
return|return
operator|(
name|value
condition|?
name|COND_PARSE
else|:
name|COND_SKIP
operator|)
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Cond_End --  *	Make sure everything's clean at the end of a makefile.  *  * Results:  *	None.  *  * Side Effects:  *	Parse_Error will be called if open conditionals are around.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Cond_End
parameter_list|()
block|{
if|if
condition|(
name|condTop
operator|!=
name|MAXIF
condition|)
block|{
name|Parse_Error
argument_list|(
name|PARSE_FATAL
argument_list|,
literal|"%d open conditional%s"
argument_list|,
name|MAXIF
operator|-
name|condTop
argument_list|,
name|MAXIF
operator|-
name|condTop
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|)
expr_stmt|;
block|}
name|condTop
operator|=
name|MAXIF
expr_stmt|;
block|}
end_function

end_unit

