begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1988, 1989, 1990, 1993  *	The Regents of the University of California.  All rights reserved.  * Copyright (c) 1989 by Berkeley Softworks  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Adam de Boor.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_if
if|#
directive|if
literal|0
end_if

begin_else
unit|static char sccsid[] = "@(#)make.c	8.1 (Berkeley) 6/6/93";
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/*-  * make.c --  *	The functions which perform the examination of targets and  *	their suitability for creation  *  * Interface:  *	Make_Run 	    	Initialize things for the module and recreate  *	    	  	    	whatever needs recreating. Returns TRUE if  *	    	    	    	work was (or would have been) done and FALSE  *	    	  	    	otherwise.  *  *	Make_Update	    	Update all parents of a given child. Performs  *	    	  	    	various bookkeeping chores like the updating  *	    	  	    	of the cmtime field of the parent, filling  *	    	  	    	of the IMPSRC context variable, etc. It will  *	    	  	    	place the parent on the toBeMade queue if it  *	    	  	    	should be.  *  *	Make_TimeStamp	    	Function to set the parent's cmtime field  *	    	  	    	based on a child's modification time.  *  *	Make_DoAllVar	    	Set up the various local variables for a  *	    	  	    	target, including the .ALLSRC variable, making  *	    	  	    	sure that any variable that needs to exist  *	    	  	    	at the very least has the empty value.  *  *	Make_OODate 	    	Determine if a target is out-of-date.  *  *	Make_HandleUse		See if a child is a .USE node for a parent  *				and perform the .USE actions if so.  */
end_comment

begin_include
include|#
directive|include
file|"make.h"
end_include

begin_include
include|#
directive|include
file|"hash.h"
end_include

begin_include
include|#
directive|include
file|"dir.h"
end_include

begin_include
include|#
directive|include
file|"job.h"
end_include

begin_decl_stmt
specifier|static
name|Lst
name|toBeMade
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The current fringe of the graph. These 				 * are nodes which await examination by 				 * MakeOODate. It is added to by 				 * Make_Update and subtracted from by 				 * MakeStartJobs */
end_comment

begin_decl_stmt
specifier|static
name|int
name|numNodes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of nodes to be processed. If this 				 * is non-zero when Job_Empty() returns 				 * TRUE, there's a cycle in the graph */
end_comment

begin_decl_stmt
specifier|static
name|int
name|MakeAddChild
name|__P
argument_list|(
operator|(
name|ClientData
operator|,
name|ClientData
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|MakeAddAllSrc
name|__P
argument_list|(
operator|(
name|ClientData
operator|,
name|ClientData
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|MakeTimeStamp
name|__P
argument_list|(
operator|(
name|ClientData
operator|,
name|ClientData
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|MakeHandleUse
name|__P
argument_list|(
operator|(
name|ClientData
operator|,
name|ClientData
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Boolean
name|MakeStartJobs
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|MakePrintStatus
name|__P
argument_list|(
operator|(
name|ClientData
operator|,
name|ClientData
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Make_TimeStamp --  *	Set the cmtime field of a parent node based on the mtime stamp in its  *	child. Called from MakeOODate via Lst_ForEach.  *  * Results:  *	Always returns 0.  *  * Side Effects:  *	The cmtime of the parent node will be changed if the mtime  *	field of the child is greater than it.  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Make_TimeStamp
parameter_list|(
name|pgn
parameter_list|,
name|cgn
parameter_list|)
name|GNode
modifier|*
name|pgn
decl_stmt|;
comment|/* the current parent */
name|GNode
modifier|*
name|cgn
decl_stmt|;
comment|/* the child we've just examined */
block|{
if|if
condition|(
name|cgn
operator|->
name|mtime
operator|>
name|pgn
operator|->
name|cmtime
condition|)
block|{
name|pgn
operator|->
name|cmtime
operator|=
name|cgn
operator|->
name|mtime
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|MakeTimeStamp
parameter_list|(
name|pgn
parameter_list|,
name|cgn
parameter_list|)
name|ClientData
name|pgn
decl_stmt|;
comment|/* the current parent */
name|ClientData
name|cgn
decl_stmt|;
comment|/* the child we've just examined */
block|{
return|return
name|Make_TimeStamp
argument_list|(
operator|(
name|GNode
operator|*
operator|)
name|pgn
argument_list|,
operator|(
name|GNode
operator|*
operator|)
name|cgn
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Make_OODate --  *	See if a given node is out of date with respect to its sources.  *	Used by Make_Run when deciding which nodes to place on the  *	toBeMade queue initially and by Make_Update to screen out USE and  *	EXEC nodes. In the latter case, however, any other sort of node  *	must be considered out-of-date since at least one of its children  *	will have been recreated.  *  * Results:  *	TRUE if the node is out of date. FALSE otherwise.  *  * Side Effects:  *	The mtime field of the node and the cmtime field of its parents  *	will/may be changed.  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|Boolean
name|Make_OODate
parameter_list|(
name|gn
parameter_list|)
specifier|register
name|GNode
modifier|*
name|gn
decl_stmt|;
comment|/* the node to check */
block|{
name|Boolean
name|oodate
decl_stmt|;
comment|/*      * Certain types of targets needn't even be sought as their datedness      * doesn't depend on their modification time...      */
if|if
condition|(
operator|(
name|gn
operator|->
name|type
operator|&
operator|(
name|OP_JOIN
operator||
name|OP_USE
operator||
name|OP_EXEC
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|Dir_MTime
argument_list|(
name|gn
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEBUG
argument_list|(
name|MAKE
argument_list|)
condition|)
block|{
if|if
condition|(
name|gn
operator|->
name|mtime
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"modified %s..."
argument_list|,
name|Targ_FmtTime
argument_list|(
name|gn
operator|->
name|mtime
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"non-existent..."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/*      * A target is remade in one of the following circumstances:      *	its modification time is smaller than that of its youngest child      *	    and it would actually be run (has commands or type OP_NOP)      *	it's the object of a force operator      *	it has no children, was on the lhs of an operator and doesn't exist      *	    already.      *      * Libraries are only considered out-of-date if the archive module says      * they are.      *      * These weird rules are brought to you by Backward-Compatability and      * the strange people who wrote 'Make'.      */
if|if
condition|(
name|gn
operator|->
name|type
operator|&
name|OP_USE
condition|)
block|{
comment|/* 	 * If the node is a USE node it is *never* out of date 	 * no matter *what*. 	 */
if|if
condition|(
name|DEBUG
argument_list|(
name|MAKE
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|".USE node..."
argument_list|)
expr_stmt|;
block|}
name|oodate
operator|=
name|FALSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|gn
operator|->
name|type
operator|&
name|OP_LIB
condition|)
block|{
if|if
condition|(
name|DEBUG
argument_list|(
name|MAKE
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"library..."
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * always out of date if no children and :: target 	 */
name|oodate
operator|=
name|Arch_LibOODate
argument_list|(
name|gn
argument_list|)
operator|||
operator|(
operator|(
name|gn
operator|->
name|cmtime
operator|==
literal|0
operator|)
operator|&&
operator|(
name|gn
operator|->
name|type
operator|&
name|OP_DOUBLEDEP
operator|)
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|gn
operator|->
name|type
operator|&
name|OP_JOIN
condition|)
block|{
comment|/* 	 * A target with the .JOIN attribute is only considered 	 * out-of-date if any of its children was out-of-date. 	 */
if|if
condition|(
name|DEBUG
argument_list|(
name|MAKE
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|".JOIN node..."
argument_list|)
expr_stmt|;
block|}
name|oodate
operator|=
name|gn
operator|->
name|childMade
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|gn
operator|->
name|type
operator|&
operator|(
name|OP_FORCE
operator||
name|OP_EXEC
operator||
name|OP_PHONY
operator|)
condition|)
block|{
comment|/* 	 * A node which is the object of the force (!) operator or which has 	 * the .EXEC attribute is always considered out-of-date. 	 */
if|if
condition|(
name|DEBUG
argument_list|(
name|MAKE
argument_list|)
condition|)
block|{
if|if
condition|(
name|gn
operator|->
name|type
operator|&
name|OP_FORCE
condition|)
block|{
name|printf
argument_list|(
literal|"! operator..."
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|gn
operator|->
name|type
operator|&
name|OP_PHONY
condition|)
block|{
name|printf
argument_list|(
literal|".PHONY node..."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|".EXEC node..."
argument_list|)
expr_stmt|;
block|}
block|}
name|oodate
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|gn
operator|->
name|mtime
operator|<
name|gn
operator|->
name|cmtime
operator|)
operator|||
operator|(
operator|(
name|gn
operator|->
name|cmtime
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|gn
operator|->
name|mtime
operator|==
literal|0
operator|)
operator|||
operator|(
name|gn
operator|->
name|type
operator|&
name|OP_DOUBLEDEP
operator|)
operator|)
operator|)
condition|)
block|{
comment|/* 	 * A node whose modification time is less than that of its 	 * youngest child or that has no children (cmtime == 0) and 	 * either doesn't exist (mtime == 0) or was the object of a 	 * :: operator is out-of-date. Why? Because that's the way Make does 	 * it. 	 */
if|if
condition|(
name|DEBUG
argument_list|(
name|MAKE
argument_list|)
condition|)
block|{
if|if
condition|(
name|gn
operator|->
name|mtime
operator|<
name|gn
operator|->
name|cmtime
condition|)
block|{
name|printf
argument_list|(
literal|"modified before source..."
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|gn
operator|->
name|mtime
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"non-existent and no sources..."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|":: operator and no sources..."
argument_list|)
expr_stmt|;
block|}
block|}
name|oodate
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
if|#
directive|if
literal|0
comment|/* WHY? */
block|if (DEBUG(MAKE)) { 	    printf("source %smade...", gn->childMade ? "" : "not "); 	} 	oodate = gn->childMade;
else|#
directive|else
name|oodate
operator|=
name|FALSE
expr_stmt|;
endif|#
directive|endif
comment|/* 0 */
block|}
comment|/*      * If the target isn't out-of-date, the parents need to know its      * modification time. Note that targets that appear to be out-of-date      * but aren't, because they have no commands and aren't of type OP_NOP,      * have their mtime stay below their children's mtime to keep parents from      * thinking they're out-of-date.      */
if|if
condition|(
operator|!
name|oodate
condition|)
block|{
name|Lst_ForEach
argument_list|(
name|gn
operator|->
name|parents
argument_list|,
name|MakeTimeStamp
argument_list|,
operator|(
name|ClientData
operator|)
name|gn
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|oodate
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * MakeAddChild  --  *	Function used by Make_Run to add a child to the list l.  *	It will only add the child if its make field is FALSE.  *  * Results:  *	Always returns 0  *  * Side Effects:  *	The given list is extended  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|MakeAddChild
parameter_list|(
name|gnp
parameter_list|,
name|lp
parameter_list|)
name|ClientData
name|gnp
decl_stmt|;
comment|/* the node to add */
name|ClientData
name|lp
decl_stmt|;
comment|/* the list to which to add it */
block|{
name|GNode
modifier|*
name|gn
init|=
operator|(
name|GNode
operator|*
operator|)
name|gnp
decl_stmt|;
name|Lst
name|l
init|=
operator|(
name|Lst
operator|)
name|lp
decl_stmt|;
if|if
condition|(
operator|!
name|gn
operator|->
name|make
operator|&&
operator|!
operator|(
name|gn
operator|->
name|type
operator|&
name|OP_USE
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|Lst_EnQueue
argument_list|(
name|l
argument_list|,
operator|(
name|ClientData
operator|)
name|gn
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Make_HandleUse --  *	Function called by Make_Run and SuffApplyTransform on the downward  *	pass to handle .USE and transformation nodes. A callback function  *	for Lst_ForEach, it implements the .USE and transformation  *	functionality by copying the node's commands, type flags  *	and children to the parent node. Should be called before the  *	children are enqueued to be looked at by MakeAddChild.  *  *	A .USE node is much like an explicit transformation rule, except  *	its commands are always added to the target node, even if the  *	target already has commands.  *  * Results:  *	returns 0.  *  * Side Effects:  *	Children and commands may be added to the parent and the parent's  *	type may be changed.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Make_HandleUse
parameter_list|(
name|cgn
parameter_list|,
name|pgn
parameter_list|)
specifier|register
name|GNode
modifier|*
name|cgn
decl_stmt|;
comment|/* The .USE node */
specifier|register
name|GNode
modifier|*
name|pgn
decl_stmt|;
comment|/* The target of the .USE node */
block|{
specifier|register
name|GNode
modifier|*
name|gn
decl_stmt|;
comment|/* A child of the .USE node */
specifier|register
name|LstNode
name|ln
decl_stmt|;
comment|/* An element in the children list */
if|if
condition|(
name|cgn
operator|->
name|type
operator|&
operator|(
name|OP_USE
operator||
name|OP_TRANSFORM
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|cgn
operator|->
name|type
operator|&
name|OP_USE
operator|)
operator|||
name|Lst_IsEmpty
argument_list|(
name|pgn
operator|->
name|commands
argument_list|)
condition|)
block|{
comment|/* 	     * .USE or transformation and target has no commands -- append 	     * the child's commands to the parent. 	     */
operator|(
name|void
operator|)
name|Lst_Concat
argument_list|(
name|pgn
operator|->
name|commands
argument_list|,
name|cgn
operator|->
name|commands
argument_list|,
name|LST_CONCNEW
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Lst_Open
argument_list|(
name|cgn
operator|->
name|children
argument_list|)
operator|==
name|SUCCESS
condition|)
block|{
while|while
condition|(
operator|(
name|ln
operator|=
name|Lst_Next
argument_list|(
name|cgn
operator|->
name|children
argument_list|)
operator|)
operator|!=
name|NILLNODE
condition|)
block|{
name|gn
operator|=
operator|(
name|GNode
operator|*
operator|)
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
expr_stmt|;
if|if
condition|(
name|Lst_Member
argument_list|(
name|pgn
operator|->
name|children
argument_list|,
name|gn
argument_list|)
operator|==
name|NILLNODE
condition|)
block|{
operator|(
name|void
operator|)
name|Lst_AtEnd
argument_list|(
name|pgn
operator|->
name|children
argument_list|,
name|gn
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Lst_AtEnd
argument_list|(
name|gn
operator|->
name|parents
argument_list|,
name|pgn
argument_list|)
expr_stmt|;
name|pgn
operator|->
name|unmade
operator|+=
literal|1
expr_stmt|;
block|}
block|}
name|Lst_Close
argument_list|(
name|cgn
operator|->
name|children
argument_list|)
expr_stmt|;
block|}
name|pgn
operator|->
name|type
operator||=
name|cgn
operator|->
name|type
operator|&
operator|~
operator|(
name|OP_OPMASK
operator||
name|OP_USE
operator||
name|OP_TRANSFORM
operator|)
expr_stmt|;
comment|/* 	 * This child node is now "made", so we decrement the count of 	 * unmade children in the parent... We also remove the child 	 * from the parent's list to accurately reflect the number of decent 	 * children the parent has. This is used by Make_Run to decide 	 * whether to queue the parent or examine its children... 	 */
if|if
condition|(
name|cgn
operator|->
name|type
operator|&
name|OP_USE
condition|)
block|{
name|pgn
operator|->
name|unmade
operator|--
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|MakeHandleUse
parameter_list|(
name|pgn
parameter_list|,
name|cgn
parameter_list|)
name|ClientData
name|pgn
decl_stmt|;
comment|/* the current parent */
name|ClientData
name|cgn
decl_stmt|;
comment|/* the child we've just examined */
block|{
return|return
name|Make_HandleUse
argument_list|(
operator|(
name|GNode
operator|*
operator|)
name|pgn
argument_list|,
operator|(
name|GNode
operator|*
operator|)
name|cgn
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Make_Update  --  *	Perform update on the parents of a node. Used by JobFinish once  *	a node has been dealt with and by MakeStartJobs if it finds an  *	up-to-date node.  *  * Results:  *	Always returns 0  *  * Side Effects:  *	The unmade field of pgn is decremented and pgn may be placed on  *	the toBeMade queue if this field becomes 0.  *  * 	If the child was made, the parent's childMade field will be set true  *	and its cmtime set to now.  *  *	If the child wasn't made, the cmtime field of the parent will be  *	altered if the child's mtime is big enough.  *  *	Finally, if the child is the implied source for the parent, the  *	parent's IMPSRC variable is set appropriately.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Make_Update
parameter_list|(
name|cgn
parameter_list|)
specifier|register
name|GNode
modifier|*
name|cgn
decl_stmt|;
comment|/* the child node */
block|{
specifier|register
name|GNode
modifier|*
name|pgn
decl_stmt|;
comment|/* the parent node */
specifier|register
name|char
modifier|*
name|cname
decl_stmt|;
comment|/* the child's name */
specifier|register
name|LstNode
name|ln
decl_stmt|;
comment|/* Element in parents and iParents lists */
name|char
modifier|*
name|p1
decl_stmt|;
name|cname
operator|=
name|Var_Value
argument_list|(
name|TARGET
argument_list|,
name|cgn
argument_list|,
operator|&
name|p1
argument_list|)
expr_stmt|;
name|efree
argument_list|(
name|p1
argument_list|)
expr_stmt|;
comment|/*      * If the child was actually made, see what its modification time is      * now -- some rules won't actually update the file. If the file still      * doesn't exist, make its mtime now.      */
if|if
condition|(
name|cgn
operator|->
name|made
operator|!=
name|UPTODATE
condition|)
block|{
ifndef|#
directive|ifndef
name|RECHECK
comment|/* 	 * We can't re-stat the thing, but we can at least take care of rules 	 * where a target depends on a source that actually creates the 	 * target, but only if it has changed, e.g. 	 * 	 * parse.h : parse.o 	 * 	 * parse.o : parse.y 	 *  	yacc -d parse.y 	 *  	cc -c y.tab.c 	 *  	mv y.tab.o parse.o 	 *  	cmp -s y.tab.h parse.h || mv y.tab.h parse.h 	 * 	 * In this case, if the definitions produced by yacc haven't changed 	 * from before, parse.h won't have been updated and cgn->mtime will 	 * reflect the current modification time for parse.h. This is 	 * something of a kludge, I admit, but it's a useful one.. 	 * XXX: People like to use a rule like 	 * 	 * FRC: 	 * 	 * To force things that depend on FRC to be made, so we have to 	 * check for gn->children being empty as well... 	 */
if|if
condition|(
operator|!
name|Lst_IsEmpty
argument_list|(
name|cgn
operator|->
name|commands
argument_list|)
operator|||
name|Lst_IsEmpty
argument_list|(
name|cgn
operator|->
name|children
argument_list|)
condition|)
block|{
name|cgn
operator|->
name|mtime
operator|=
name|now
expr_stmt|;
block|}
else|#
directive|else
comment|/* 	 * This is what Make does and it's actually a good thing, as it 	 * allows rules like 	 * 	 *	cmp -s y.tab.h parse.h || cp y.tab.h parse.h 	 * 	 * to function as intended. Unfortunately, thanks to the stateless 	 * nature of NFS (by which I mean the loose coupling of two clients 	 * using the same file from a common server), there are times 	 * when the modification time of a file created on a remote 	 * machine will not be modified before the local stat() implied by 	 * the Dir_MTime occurs, thus leading us to believe that the file 	 * is unchanged, wreaking havoc with files that depend on this one. 	 * 	 * I have decided it is better to make too much than to make too 	 * little, so this stuff is commented out unless you're sure it's ok. 	 * -- ardeb 1/12/88 	 */
comment|/* 	 * Christos, 4/9/92: If we are  saving commands pretend that 	 * the target is made now. Otherwise archives with ... rules 	 * don't work! 	 */
if|if
condition|(
name|noExecute
operator|||
operator|(
name|cgn
operator|->
name|type
operator|&
name|OP_SAVE_CMDS
operator|)
operator|||
name|Dir_MTime
argument_list|(
name|cgn
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cgn
operator|->
name|mtime
operator|=
name|now
expr_stmt|;
block|}
if|if
condition|(
name|DEBUG
argument_list|(
name|MAKE
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"update time: %s\n"
argument_list|,
name|Targ_FmtTime
argument_list|(
name|cgn
operator|->
name|mtime
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
if|if
condition|(
name|Lst_Open
argument_list|(
name|cgn
operator|->
name|parents
argument_list|)
operator|==
name|SUCCESS
condition|)
block|{
while|while
condition|(
operator|(
name|ln
operator|=
name|Lst_Next
argument_list|(
name|cgn
operator|->
name|parents
argument_list|)
operator|)
operator|!=
name|NILLNODE
condition|)
block|{
name|pgn
operator|=
operator|(
name|GNode
operator|*
operator|)
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
expr_stmt|;
if|if
condition|(
name|pgn
operator|->
name|make
condition|)
block|{
name|pgn
operator|->
name|unmade
operator|-=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|cgn
operator|->
name|type
operator|&
operator|(
name|OP_EXEC
operator||
name|OP_USE
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|cgn
operator|->
name|made
operator|==
name|MADE
condition|)
block|{
name|pgn
operator|->
name|childMade
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|pgn
operator|->
name|cmtime
operator|<
name|cgn
operator|->
name|mtime
condition|)
block|{
name|pgn
operator|->
name|cmtime
operator|=
name|cgn
operator|->
name|mtime
expr_stmt|;
block|}
block|}
else|else
block|{
operator|(
name|void
operator|)
name|Make_TimeStamp
argument_list|(
name|pgn
argument_list|,
name|cgn
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|pgn
operator|->
name|unmade
operator|==
literal|0
condition|)
block|{
comment|/* 		     * Queue the node up -- any unmade predecessors will 		     * be dealt with in MakeStartJobs. 		     */
operator|(
name|void
operator|)
name|Lst_EnQueue
argument_list|(
name|toBeMade
argument_list|,
operator|(
name|ClientData
operator|)
name|pgn
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pgn
operator|->
name|unmade
operator|<
literal|0
condition|)
block|{
name|Error
argument_list|(
literal|"Graph cycles through %s"
argument_list|,
name|pgn
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|Lst_Close
argument_list|(
name|cgn
operator|->
name|parents
argument_list|)
expr_stmt|;
block|}
comment|/*      * Deal with successor nodes. If any is marked for making and has an unmade      * count of 0, has not been made and isn't in the examination queue,      * it means we need to place it in the queue as it restrained itself      * before.      */
for|for
control|(
name|ln
operator|=
name|Lst_First
argument_list|(
name|cgn
operator|->
name|successors
argument_list|)
init|;
name|ln
operator|!=
name|NILLNODE
condition|;
name|ln
operator|=
name|Lst_Succ
argument_list|(
name|ln
argument_list|)
control|)
block|{
name|GNode
modifier|*
name|succ
init|=
operator|(
name|GNode
operator|*
operator|)
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
decl_stmt|;
if|if
condition|(
name|succ
operator|->
name|make
operator|&&
name|succ
operator|->
name|unmade
operator|==
literal|0
operator|&&
name|succ
operator|->
name|made
operator|==
name|UNMADE
operator|&&
name|Lst_Member
argument_list|(
name|toBeMade
argument_list|,
operator|(
name|ClientData
operator|)
name|succ
argument_list|)
operator|==
name|NILLNODE
condition|)
block|{
operator|(
name|void
operator|)
name|Lst_EnQueue
argument_list|(
name|toBeMade
argument_list|,
operator|(
name|ClientData
operator|)
name|succ
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*      * Set the .PREFIX and .IMPSRC variables for all the implied parents      * of this node.      */
if|if
condition|(
name|Lst_Open
argument_list|(
name|cgn
operator|->
name|iParents
argument_list|)
operator|==
name|SUCCESS
condition|)
block|{
name|char
modifier|*
name|p1
decl_stmt|;
name|char
modifier|*
name|cpref
init|=
name|Var_Value
argument_list|(
name|PREFIX
argument_list|,
name|cgn
argument_list|,
operator|&
name|p1
argument_list|)
decl_stmt|;
while|while
condition|(
operator|(
name|ln
operator|=
name|Lst_Next
argument_list|(
name|cgn
operator|->
name|iParents
argument_list|)
operator|)
operator|!=
name|NILLNODE
condition|)
block|{
name|pgn
operator|=
operator|(
name|GNode
operator|*
operator|)
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
expr_stmt|;
if|if
condition|(
name|pgn
operator|->
name|make
condition|)
block|{
name|Var_Set
argument_list|(
name|IMPSRC
argument_list|,
name|cname
argument_list|,
name|pgn
argument_list|)
expr_stmt|;
name|Var_Set
argument_list|(
name|PREFIX
argument_list|,
name|cpref
argument_list|,
name|pgn
argument_list|)
expr_stmt|;
block|}
block|}
name|efree
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|Lst_Close
argument_list|(
name|cgn
operator|->
name|iParents
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * MakeAddAllSrc --  *	Add a child's name to the ALLSRC and OODATE variables of the given  *	node. Called from Make_DoAllVar via Lst_ForEach. A child is added only  *	if it has not been given the .EXEC, .USE or .INVISIBLE attributes.  *	.EXEC and .USE children are very rarely going to be files, so...  *	A child is added to the OODATE variable if its modification time is  *	later than that of its parent, as defined by Make, except if the  *	parent is a .JOIN node. In that case, it is only added to the OODATE  *	variable if it was actually made (since .JOIN nodes don't have  *	modification times, the comparison is rather unfair...)..  *  * Results:  *	Always returns 0  *  * Side Effects:  *	The ALLSRC variable for the given node is extended.  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|MakeAddAllSrc
parameter_list|(
name|cgnp
parameter_list|,
name|pgnp
parameter_list|)
name|ClientData
name|cgnp
decl_stmt|;
comment|/* The child to add */
name|ClientData
name|pgnp
decl_stmt|;
comment|/* The parent to whose ALLSRC variable it should be */
comment|/* added */
block|{
name|GNode
modifier|*
name|cgn
init|=
operator|(
name|GNode
operator|*
operator|)
name|cgnp
decl_stmt|;
name|GNode
modifier|*
name|pgn
init|=
operator|(
name|GNode
operator|*
operator|)
name|pgnp
decl_stmt|;
if|if
condition|(
operator|(
name|cgn
operator|->
name|type
operator|&
operator|(
name|OP_EXEC
operator||
name|OP_USE
operator||
name|OP_INVISIBLE
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|child
decl_stmt|;
name|char
modifier|*
name|p1
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|OP_NOP
argument_list|(
name|cgn
operator|->
name|type
argument_list|)
condition|)
block|{
comment|/* 	     * this node is only source; use the specific pathname for it 	     */
name|child
operator|=
name|cgn
operator|->
name|path
condition|?
name|cgn
operator|->
name|path
else|:
name|cgn
operator|->
name|name
expr_stmt|;
block|}
else|else
name|child
operator|=
name|Var_Value
argument_list|(
name|TARGET
argument_list|,
name|cgn
argument_list|,
operator|&
name|p1
argument_list|)
expr_stmt|;
name|Var_Append
argument_list|(
name|ALLSRC
argument_list|,
name|child
argument_list|,
name|pgn
argument_list|)
expr_stmt|;
if|if
condition|(
name|pgn
operator|->
name|type
operator|&
name|OP_JOIN
condition|)
block|{
if|if
condition|(
name|cgn
operator|->
name|made
operator|==
name|MADE
condition|)
block|{
name|Var_Append
argument_list|(
name|OODATE
argument_list|,
name|child
argument_list|,
name|pgn
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|pgn
operator|->
name|mtime
operator|<
name|cgn
operator|->
name|mtime
operator|)
operator|||
operator|(
name|cgn
operator|->
name|mtime
operator|>=
name|now
operator|&&
name|cgn
operator|->
name|made
operator|==
name|MADE
operator|)
condition|)
block|{
comment|/* 	     * It goes in the OODATE variable if the parent is younger than the 	     * child or if the child has been modified more recently than 	     * the start of the make. This is to keep pmake from getting 	     * confused if something else updates the parent after the 	     * make starts (shouldn't happen, I know, but sometimes it 	     * does). In such a case, if we've updated the kid, the parent 	     * is likely to have a modification time later than that of 	     * the kid and anything that relies on the OODATE variable will 	     * be hosed. 	     * 	     * XXX: This will cause all made children to go in the OODATE 	     * variable, even if they're not touched, if RECHECK isn't defined, 	     * since cgn->mtime is set to now in Make_Update. According to 	     * some people, this is good... 	     */
name|Var_Append
argument_list|(
name|OODATE
argument_list|,
name|child
argument_list|,
name|pgn
argument_list|)
expr_stmt|;
block|}
name|efree
argument_list|(
name|p1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Make_DoAllVar --  *	Set up the ALLSRC and OODATE variables. Sad to say, it must be  *	done separately, rather than while traversing the graph. This is  *	because Make defined OODATE to contain all sources whose modification  *	times were later than that of the target, *not* those sources that  *	were out-of-date. Since in both compatibility and native modes,  *	the modification time of the parent isn't found until the child  *	has been dealt with, we have to wait until now to fill in the  *	variable. As for ALLSRC, the ordering is important and not  *	guaranteed when in native mode, so it must be set here, too.  *  * Results:  *	None  *  * Side Effects:  *	The ALLSRC and OODATE variables of the given node is filled in.  *	If the node is a .JOIN node, its TARGET variable will be set to  * 	match its ALLSRC variable.  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Make_DoAllVar
parameter_list|(
name|gn
parameter_list|)
name|GNode
modifier|*
name|gn
decl_stmt|;
block|{
name|Lst_ForEach
argument_list|(
name|gn
operator|->
name|children
argument_list|,
name|MakeAddAllSrc
argument_list|,
operator|(
name|ClientData
operator|)
name|gn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Var_Exists
argument_list|(
name|OODATE
argument_list|,
name|gn
argument_list|)
condition|)
block|{
name|Var_Set
argument_list|(
name|OODATE
argument_list|,
literal|""
argument_list|,
name|gn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|Var_Exists
argument_list|(
name|ALLSRC
argument_list|,
name|gn
argument_list|)
condition|)
block|{
name|Var_Set
argument_list|(
name|ALLSRC
argument_list|,
literal|""
argument_list|,
name|gn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gn
operator|->
name|type
operator|&
name|OP_JOIN
condition|)
block|{
name|char
modifier|*
name|p1
decl_stmt|;
name|Var_Set
argument_list|(
name|TARGET
argument_list|,
name|Var_Value
argument_list|(
name|ALLSRC
argument_list|,
name|gn
argument_list|,
operator|&
name|p1
argument_list|)
argument_list|,
name|gn
argument_list|)
expr_stmt|;
name|efree
argument_list|(
name|p1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * MakeStartJobs --  *	Start as many jobs as possible.  *  * Results:  *	If the query flag was given to pmake, no job will be started,  *	but as soon as an out-of-date target is found, this function  *	returns TRUE. At all other times, this function returns FALSE.  *  * Side Effects:  *	Nodes are removed from the toBeMade queue and job table slots  *	are filled.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|Boolean
name|MakeStartJobs
parameter_list|()
block|{
specifier|register
name|GNode
modifier|*
name|gn
decl_stmt|;
while|while
condition|(
operator|!
name|Job_Full
argument_list|()
operator|&&
operator|!
name|Lst_IsEmpty
argument_list|(
name|toBeMade
argument_list|)
condition|)
block|{
name|gn
operator|=
operator|(
name|GNode
operator|*
operator|)
name|Lst_DeQueue
argument_list|(
name|toBeMade
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEBUG
argument_list|(
name|MAKE
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Examining %s..."
argument_list|,
name|gn
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Make sure any and all predecessors that are going to be made, 	 * have been. 	 */
if|if
condition|(
operator|!
name|Lst_IsEmpty
argument_list|(
name|gn
operator|->
name|preds
argument_list|)
condition|)
block|{
name|LstNode
name|ln
decl_stmt|;
for|for
control|(
name|ln
operator|=
name|Lst_First
argument_list|(
name|gn
operator|->
name|preds
argument_list|)
init|;
name|ln
operator|!=
name|NILLNODE
condition|;
name|ln
operator|=
name|Lst_Succ
argument_list|(
name|ln
argument_list|)
control|)
block|{
name|GNode
modifier|*
name|pgn
init|=
operator|(
name|GNode
operator|*
operator|)
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
decl_stmt|;
if|if
condition|(
name|pgn
operator|->
name|make
operator|&&
name|pgn
operator|->
name|made
operator|==
name|UNMADE
condition|)
block|{
if|if
condition|(
name|DEBUG
argument_list|(
name|MAKE
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"predecessor %s not made yet.\n"
argument_list|,
name|pgn
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
comment|/* 	     * If ln isn't nil, there's a predecessor as yet unmade, so we 	     * just drop this node on the floor. When the node in question 	     * has been made, it will notice this node as being ready to 	     * make but as yet unmade and will place the node on the queue. 	     */
if|if
condition|(
name|ln
operator|!=
name|NILLNODE
condition|)
block|{
continue|continue;
block|}
block|}
name|numNodes
operator|--
expr_stmt|;
if|if
condition|(
name|Make_OODate
argument_list|(
name|gn
argument_list|)
condition|)
block|{
if|if
condition|(
name|DEBUG
argument_list|(
name|MAKE
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"out-of-date\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|queryFlag
condition|)
block|{
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
name|Make_DoAllVar
argument_list|(
name|gn
argument_list|)
expr_stmt|;
name|Job_Make
argument_list|(
name|gn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|DEBUG
argument_list|(
name|MAKE
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"up-to-date\n"
argument_list|)
expr_stmt|;
block|}
name|gn
operator|->
name|made
operator|=
name|UPTODATE
expr_stmt|;
if|if
condition|(
name|gn
operator|->
name|type
operator|&
name|OP_JOIN
condition|)
block|{
comment|/* 		 * Even for an up-to-date .JOIN node, we need it to have its 		 * context variables so references to it get the correct 		 * value for .TARGET when building up the context variables 		 * of its parent(s)... 		 */
name|Make_DoAllVar
argument_list|(
name|gn
argument_list|)
expr_stmt|;
block|}
name|Make_Update
argument_list|(
name|gn
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * MakePrintStatus --  *	Print the status of a top-level node, viz. it being up-to-date  *	already or not created due to an error in a lower level.  *	Callback function for Make_Run via Lst_ForEach.  *  * Results:  *	Always returns 0.  *  * Side Effects:  *	A message may be printed.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|MakePrintStatus
parameter_list|(
name|gnp
parameter_list|,
name|cyclep
parameter_list|)
name|ClientData
name|gnp
decl_stmt|;
comment|/* Node to examine */
name|ClientData
name|cyclep
decl_stmt|;
comment|/* True if gn->unmade being non-zero implies 			     * a cycle in the graph, not an error in an 			     * inferior */
block|{
name|GNode
modifier|*
name|gn
init|=
operator|(
name|GNode
operator|*
operator|)
name|gnp
decl_stmt|;
name|Boolean
name|cycle
init|=
operator|*
operator|(
name|Boolean
operator|*
operator|)
name|cyclep
decl_stmt|;
if|if
condition|(
name|gn
operator|->
name|made
operator|==
name|UPTODATE
condition|)
block|{
name|printf
argument_list|(
literal|"`%s' is up to date.\n"
argument_list|,
name|gn
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|gn
operator|->
name|unmade
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|cycle
condition|)
block|{
name|Boolean
name|t
init|=
name|TRUE
decl_stmt|;
comment|/* 	     * If printing cycles and came to one that has unmade children, 	     * print out the cycle by recursing on its children. Note a 	     * cycle like: 	     *	a : b 	     *	b : c 	     *	c : b 	     * will cause this to erroneously complain about a being in 	     * the cycle, but this is a good approximation. 	     */
if|if
condition|(
name|gn
operator|->
name|made
operator|==
name|CYCLE
condition|)
block|{
name|Error
argument_list|(
literal|"Graph cycles through `%s'"
argument_list|,
name|gn
operator|->
name|name
argument_list|)
expr_stmt|;
name|gn
operator|->
name|made
operator|=
name|ENDCYCLE
expr_stmt|;
name|Lst_ForEach
argument_list|(
name|gn
operator|->
name|children
argument_list|,
name|MakePrintStatus
argument_list|,
operator|(
name|ClientData
operator|)
operator|&
name|t
argument_list|)
expr_stmt|;
name|gn
operator|->
name|made
operator|=
name|UNMADE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|gn
operator|->
name|made
operator|!=
name|ENDCYCLE
condition|)
block|{
name|gn
operator|->
name|made
operator|=
name|CYCLE
expr_stmt|;
name|Lst_ForEach
argument_list|(
name|gn
operator|->
name|children
argument_list|,
name|MakePrintStatus
argument_list|,
operator|(
name|ClientData
operator|)
operator|&
name|t
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|printf
argument_list|(
literal|"`%s' not remade because of errors.\n"
argument_list|,
name|gn
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Make_Run --  *	Initialize the nodes to remake and the list of nodes which are  *	ready to be made by doing a breadth-first traversal of the graph  *	starting from the nodes in the given list. Once this traversal  *	is finished, all the 'leaves' of the graph are in the toBeMade  *	queue.  *	Using this queue and the Job module, work back up the graph,  *	calling on MakeStartJobs to keep the job table as full as  *	possible.  *  * Results:  *	TRUE if work was done. FALSE otherwise.  *  * Side Effects:  *	The make field of all nodes involved in the creation of the given  *	targets is set to 1. The toBeMade list is set to contain all the  *	'leaves' of these subgraphs.  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|Boolean
name|Make_Run
parameter_list|(
name|targs
parameter_list|)
name|Lst
name|targs
decl_stmt|;
comment|/* the initial list of targets */
block|{
specifier|register
name|GNode
modifier|*
name|gn
decl_stmt|;
comment|/* a temporary pointer */
specifier|register
name|Lst
name|examine
decl_stmt|;
comment|/* List of targets to examine */
name|int
name|errors
decl_stmt|;
comment|/* Number of errors the Job module reports */
name|toBeMade
operator|=
name|Lst_Init
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|examine
operator|=
name|Lst_Duplicate
argument_list|(
name|targs
argument_list|,
name|NOCOPY
argument_list|)
expr_stmt|;
name|numNodes
operator|=
literal|0
expr_stmt|;
comment|/*      * Make an initial downward pass over the graph, marking nodes to be made      * as we go down. We call Suff_FindDeps to find where a node is and      * to get some children for it if it has none and also has no commands.      * If the node is a leaf, we stick it on the toBeMade queue to      * be looked at in a minute, otherwise we add its children to our queue      * and go on about our business.      */
while|while
condition|(
operator|!
name|Lst_IsEmpty
argument_list|(
name|examine
argument_list|)
condition|)
block|{
name|gn
operator|=
operator|(
name|GNode
operator|*
operator|)
name|Lst_DeQueue
argument_list|(
name|examine
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|gn
operator|->
name|make
condition|)
block|{
name|gn
operator|->
name|make
operator|=
name|TRUE
expr_stmt|;
name|numNodes
operator|++
expr_stmt|;
comment|/* 	     * Apply any .USE rules before looking for implicit dependencies 	     * to make sure everything has commands that should... 	     */
name|Lst_ForEach
argument_list|(
name|gn
operator|->
name|children
argument_list|,
name|MakeHandleUse
argument_list|,
operator|(
name|ClientData
operator|)
name|gn
argument_list|)
expr_stmt|;
name|Suff_FindDeps
argument_list|(
name|gn
argument_list|)
expr_stmt|;
if|if
condition|(
name|gn
operator|->
name|unmade
operator|!=
literal|0
condition|)
block|{
name|Lst_ForEach
argument_list|(
name|gn
operator|->
name|children
argument_list|,
name|MakeAddChild
argument_list|,
operator|(
name|ClientData
operator|)
name|examine
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|Lst_EnQueue
argument_list|(
name|toBeMade
argument_list|,
operator|(
name|ClientData
operator|)
name|gn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|Lst_Destroy
argument_list|(
name|examine
argument_list|,
name|NOFREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|queryFlag
condition|)
block|{
comment|/* 	 * We wouldn't do any work unless we could start some jobs in the 	 * next loop... (we won't actually start any, of course, this is just 	 * to see if any of the targets was out of date) 	 */
return|return
operator|(
name|MakeStartJobs
argument_list|()
operator|)
return|;
block|}
else|else
block|{
comment|/* 	 * Initialization. At the moment, no jobs are running and until some 	 * get started, nothing will happen since the remaining upward 	 * traversal of the graph is performed by the routines in job.c upon 	 * the finishing of a job. So we fill the Job table as much as we can 	 * before going into our loop. 	 */
operator|(
name|void
operator|)
name|MakeStartJobs
argument_list|()
expr_stmt|;
block|}
comment|/*      * Main Loop: The idea here is that the ending of jobs will take      * care of the maintenance of data structures and the waiting for output      * will cause us to be idle most of the time while our children run as      * much as possible. Because the job table is kept as full as possible,      * the only time when it will be empty is when all the jobs which need      * running have been run, so that is the end condition of this loop.      * Note that the Job module will exit if there were any errors unless the      * keepgoing flag was given.      */
while|while
condition|(
operator|!
name|Job_Empty
argument_list|()
condition|)
block|{
name|Job_CatchOutput
argument_list|()
expr_stmt|;
name|Job_CatchChildren
argument_list|(
operator|!
name|usePipes
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|MakeStartJobs
argument_list|()
expr_stmt|;
block|}
name|errors
operator|=
name|Job_End
argument_list|()
expr_stmt|;
comment|/*      * Print the final status of each target. E.g. if it wasn't made      * because some inferior reported an error.      */
name|errors
operator|=
operator|(
operator|(
name|errors
operator|==
literal|0
operator|)
operator|&&
operator|(
name|numNodes
operator|!=
literal|0
operator|)
operator|)
expr_stmt|;
name|Lst_ForEach
argument_list|(
name|targs
argument_list|,
name|MakePrintStatus
argument_list|,
operator|(
name|ClientData
operator|)
operator|&
name|errors
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

end_unit

