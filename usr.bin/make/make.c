begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1988, 1989, 1990, 1993  *	The Regents of the University of California.  All rights reserved.  * Copyright (c) 1989 by Berkeley Softworks  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Adam de Boor.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * @(#)make.c	8.1 (Berkeley) 6/6/93  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * make.c  *	The functions which perform the examination of targets and  *	their suitability for creation  *  * Interface:  *	Make_Run	Initialize things for the module and recreate  *			whatever needs recreating. Returns TRUE if  *			work was (or would have been) done and FALSE  *			otherwise.  *  *	Make_Update	Update all parents of a given child. Performs  *			various bookkeeping chores like the updating  *			of the cmtime field of the parent, filling  *			of the IMPSRC context variable, etc. It will  *			place the parent on the toBeMade queue if it should be.  *  *	Make_TimeStamp	Function to set the parent's cmtime field  *			based on a child's modification time.  *  *	Make_DoAllVar	Set up the various local variables for a  *			target, including the .ALLSRC variable, making  *			sure that any variable that needs to exist  *			at the very least has the empty value.  *  *	Make_OODate	Determine if a target is out-of-date.  *  *	Make_HandleUse	See if a child is a .USE node for a parent  *			and perform the .USE actions if so.  */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|"arch.h"
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"dir.h"
end_include

begin_include
include|#
directive|include
file|"globals.h"
end_include

begin_include
include|#
directive|include
file|"GNode.h"
end_include

begin_include
include|#
directive|include
file|"job.h"
end_include

begin_include
include|#
directive|include
file|"make.h"
end_include

begin_include
include|#
directive|include
file|"parse.h"
end_include

begin_include
include|#
directive|include
file|"suff.h"
end_include

begin_include
include|#
directive|include
file|"targ.h"
end_include

begin_include
include|#
directive|include
file|"util.h"
end_include

begin_include
include|#
directive|include
file|"var.h"
end_include

begin_comment
comment|/* The current fringe of the graph. These are nodes which await examination  * by MakeOODate. It is added to by Make_Update and subtracted from by  * MakeStartJobs */
end_comment

begin_decl_stmt
specifier|static
name|Lst
name|toBeMade
init|=
name|Lst_Initializer
argument_list|(
name|toBeMade
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Number of nodes to be processed. If this is non-zero when Job_Empty()  * returns TRUE, there's a cycle in the graph.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|numNodes
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|Boolean
name|MakeStartJobs
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * Make_TimeStamp  *	Set the cmtime field of a parent node based on the mtime stamp in its  *	child. Called from MakeOODate via LST_FOREACH.  *  * Results:  *	Always returns 0.  *  * Side Effects:  *	The cmtime of the parent node will be changed if the mtime  *	field of the child is greater than it.  */
end_comment

begin_function
name|int
name|Make_TimeStamp
parameter_list|(
name|GNode
modifier|*
name|pgn
parameter_list|,
name|GNode
modifier|*
name|cgn
parameter_list|)
block|{
if|if
condition|(
name|cgn
operator|->
name|mtime
operator|>
name|pgn
operator|->
name|cmtime
condition|)
block|{
name|pgn
operator|->
name|cmtime
operator|=
name|cgn
operator|->
name|mtime
expr_stmt|;
name|pgn
operator|->
name|cmtime_gn
operator|=
name|cgn
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Make_OODate  *	See if a given node is out of date with respect to its sources.  *	Used by Make_Run when deciding which nodes to place on the  *	toBeMade queue initially and by Make_Update to screen out USE and  *	EXEC nodes. In the latter case, however, any other sort of node  *	must be considered out-of-date since at least one of its children  *	will have been recreated.  *  * Results:  *	TRUE if the node is out of date. FALSE otherwise.  *  * Side Effects:  *	The mtime field of the node and the cmtime field of its parents  *	will/may be changed.  */
end_comment

begin_function
name|Boolean
name|Make_OODate
parameter_list|(
name|GNode
modifier|*
name|gn
parameter_list|)
block|{
name|Boolean
name|oodate
decl_stmt|;
name|LstNode
modifier|*
name|ln
decl_stmt|;
comment|/* 	 * Certain types of targets needn't even be sought as their datedness 	 * doesn't depend on their modification time... 	 */
if|if
condition|(
operator|(
name|gn
operator|->
name|type
operator|&
operator|(
name|OP_JOIN
operator||
name|OP_USE
operator||
name|OP_EXEC
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|Dir_MTime
argument_list|(
name|gn
argument_list|)
expr_stmt|;
if|if
condition|(
name|gn
operator|->
name|mtime
operator|!=
literal|0
condition|)
block|{
name|DEBUGF
argument_list|(
name|MAKE
argument_list|,
operator|(
literal|"modified %s..."
operator|,
name|Targ_FmtTime
argument_list|(
name|gn
operator|->
name|mtime
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DEBUGF
argument_list|(
name|MAKE
argument_list|,
operator|(
literal|"non-existent..."
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * A target is remade in one of the following circumstances: 	 *	its modification time is smaller than that of its youngest child 	 *	    and it would actually be run (has commands or type OP_NOP) 	 *	it's the object of a force operator 	 *	it has no children, was on the lhs of an operator and doesn't 	 *	    exist already. 	 * 	 * Libraries are only considered out-of-date if the archive module says 	 * they are. 	 * 	 * These weird rules are brought to you by Backward-Compatibility and 	 * the strange people who wrote 'Make'. 	 */
if|if
condition|(
name|gn
operator|->
name|type
operator|&
name|OP_USE
condition|)
block|{
comment|/* 		 * If the node is a USE node it is *never* out of date 		 * no matter *what*. 		 */
name|DEBUGF
argument_list|(
name|MAKE
argument_list|,
operator|(
literal|".USE node..."
operator|)
argument_list|)
expr_stmt|;
name|oodate
operator|=
name|FALSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|gn
operator|->
name|type
operator|&
name|OP_LIB
condition|)
block|{
name|DEBUGF
argument_list|(
name|MAKE
argument_list|,
operator|(
literal|"library..."
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * always out of date if no children and :: target 		 */
name|oodate
operator|=
name|Arch_LibOODate
argument_list|(
name|gn
argument_list|)
operator|||
operator|(
operator|(
name|gn
operator|->
name|cmtime
operator|==
literal|0
operator|)
operator|&&
operator|(
name|gn
operator|->
name|type
operator|&
name|OP_DOUBLEDEP
operator|)
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|gn
operator|->
name|type
operator|&
name|OP_JOIN
condition|)
block|{
comment|/* 		 * A target with the .JOIN attribute is only considered 		 * out-of-date if any of its children was out-of-date. 		 */
name|DEBUGF
argument_list|(
name|MAKE
argument_list|,
operator|(
literal|".JOIN node..."
operator|)
argument_list|)
expr_stmt|;
name|oodate
operator|=
name|gn
operator|->
name|childMade
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|gn
operator|->
name|type
operator|&
operator|(
name|OP_FORCE
operator||
name|OP_EXEC
operator||
name|OP_PHONY
operator|)
condition|)
block|{
comment|/* 		 * A node which is the object of the force (!) operator or 		 * which has the .EXEC attribute is always considered 		 * out-of-date. 		 */
if|if
condition|(
name|gn
operator|->
name|type
operator|&
name|OP_FORCE
condition|)
block|{
name|DEBUGF
argument_list|(
name|MAKE
argument_list|,
operator|(
literal|"! operator..."
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|gn
operator|->
name|type
operator|&
name|OP_PHONY
condition|)
block|{
name|DEBUGF
argument_list|(
name|MAKE
argument_list|,
operator|(
literal|".PHONY node..."
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DEBUGF
argument_list|(
name|MAKE
argument_list|,
operator|(
literal|".EXEC node..."
operator|)
argument_list|)
expr_stmt|;
block|}
name|oodate
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|gn
operator|->
name|mtime
operator|<
name|gn
operator|->
name|cmtime
operator|)
operator|||
operator|(
operator|(
name|gn
operator|->
name|cmtime
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|gn
operator|->
name|mtime
operator|==
literal|0
operator|)
operator|||
operator|(
name|gn
operator|->
name|type
operator|&
name|OP_DOUBLEDEP
operator|)
operator|)
operator|)
condition|)
block|{
comment|/* 		 * A node whose modification time is less than that of its 		 * youngest child or that has no children (cmtime == 0) and 		 * either doesn't exist (mtime == 0) or was the object of a 		 * :: operator is out-of-date. Why? Because that's the way 		 * Make does it. 		 */
if|if
condition|(
name|gn
operator|->
name|mtime
operator|<
name|gn
operator|->
name|cmtime
condition|)
block|{
name|DEBUGF
argument_list|(
name|MAKE
argument_list|,
operator|(
literal|"modified before source (%s)..."
operator|,
name|gn
operator|->
name|cmtime_gn
condition|?
name|gn
operator|->
name|cmtime_gn
operator|->
name|path
else|:
literal|"???"
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|gn
operator|->
name|mtime
operator|==
literal|0
condition|)
block|{
name|DEBUGF
argument_list|(
name|MAKE
argument_list|,
operator|(
literal|"non-existent and no sources..."
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DEBUGF
argument_list|(
name|MAKE
argument_list|,
operator|(
literal|":: operator and no sources..."
operator|)
argument_list|)
expr_stmt|;
block|}
name|oodate
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
name|oodate
operator|=
name|FALSE
expr_stmt|;
comment|/* 	 * If the target isn't out-of-date, the parents need to know its 	 * modification time. Note that targets that appear to be out-of-date 	 * but aren't, because they have no commands and aren't of type OP_NOP, 	 * have their mtime stay below their children's mtime to keep parents 	 * from thinking they're out-of-date. 	 */
if|if
condition|(
operator|!
name|oodate
condition|)
block|{
name|LST_FOREACH
argument_list|(
argument|ln
argument_list|,
argument|&gn->parents
argument_list|)
if|if
condition|(
name|Make_TimeStamp
argument_list|(
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
argument_list|,
name|gn
argument_list|)
condition|)
break|break;
block|}
return|return
operator|(
name|oodate
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Make_HandleUse  *	Function called by Make_Run and SuffApplyTransform on the downward  *	pass to handle .USE and transformation nodes. A callback function  *	for LST_FOREACH, it implements the .USE and transformation  *	functionality by copying the node's commands, type flags  *	and children to the parent node. Should be called before the  *	children are enqueued to be looked at.  *  *	A .USE node is much like an explicit transformation rule, except  *	its commands are always added to the target node, even if the  *	target already has commands.  *  * Results:  *	returns 0.  *  * Side Effects:  *	Children and commands may be added to the parent and the parent's  *	type may be changed.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Make_HandleUse
parameter_list|(
name|GNode
modifier|*
name|cgn
parameter_list|,
name|GNode
modifier|*
name|pgn
parameter_list|)
block|{
name|GNode
modifier|*
name|gn
decl_stmt|;
comment|/* A child of the .USE node */
name|LstNode
modifier|*
name|ln
decl_stmt|;
comment|/* An element in the children list */
if|if
condition|(
name|cgn
operator|->
name|type
operator|&
operator|(
name|OP_USE
operator||
name|OP_TRANSFORM
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|cgn
operator|->
name|type
operator|&
name|OP_USE
operator|)
operator|||
name|Lst_IsEmpty
argument_list|(
operator|&
name|pgn
operator|->
name|commands
argument_list|)
condition|)
block|{
comment|/* 			 * .USE or transformation and target has no commands -- 			 * append the child's commands to the parent. 			 */
name|Lst_Concat
argument_list|(
operator|&
name|pgn
operator|->
name|commands
argument_list|,
operator|&
name|cgn
operator|->
name|commands
argument_list|,
name|LST_CONCNEW
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|ln
operator|=
name|Lst_First
argument_list|(
operator|&
name|cgn
operator|->
name|children
argument_list|)
init|;
name|ln
operator|!=
name|NULL
condition|;
name|ln
operator|=
name|Lst_Succ
argument_list|(
name|ln
argument_list|)
control|)
block|{
name|gn
operator|=
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
expr_stmt|;
if|if
condition|(
name|Lst_Member
argument_list|(
operator|&
name|pgn
operator|->
name|children
argument_list|,
name|gn
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|Lst_AtEnd
argument_list|(
operator|&
name|pgn
operator|->
name|children
argument_list|,
name|gn
argument_list|)
expr_stmt|;
name|Lst_AtEnd
argument_list|(
operator|&
name|gn
operator|->
name|parents
argument_list|,
name|pgn
argument_list|)
expr_stmt|;
name|pgn
operator|->
name|unmade
operator|+=
literal|1
expr_stmt|;
block|}
block|}
name|pgn
operator|->
name|type
operator||=
name|cgn
operator|->
name|type
operator|&
operator|~
operator|(
name|OP_OPMASK
operator||
name|OP_USE
operator||
name|OP_TRANSFORM
operator|)
expr_stmt|;
comment|/* 		 * This child node is now "made", so we decrement the count of 		 * unmade children in the parent... We also remove the child 		 * from the parent's list to accurately reflect the number of 		 * decent children the parent has. This is used by Make_Run to 		 * decide whether to queue the parent or examine its children... 		 */
if|if
condition|(
name|cgn
operator|->
name|type
operator|&
name|OP_USE
condition|)
block|{
name|pgn
operator|->
name|unmade
operator|--
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Make_Update  *	Perform update on the parents of a node. Used by JobFinish once  *	a node has been dealt with and by MakeStartJobs if it finds an  *	up-to-date node.  *  * Results:  *	Always returns 0  *  * Side Effects:  *	The unmade field of pgn is decremented and pgn may be placed on  *	the toBeMade queue if this field becomes 0.  *  * 	If the child was made, the parent's childMade field will be set true  *	and its cmtime set to now.  *  *	If the child wasn't made, the cmtime field of the parent will be  *	altered if the child's mtime is big enough.  *  *	Finally, if the child is the implied source for the parent, the  *	parent's IMPSRC variable is set appropriately.  */
end_comment

begin_function
name|void
name|Make_Update
parameter_list|(
name|GNode
modifier|*
name|cgn
parameter_list|)
block|{
name|GNode
modifier|*
name|pgn
decl_stmt|;
comment|/* the parent node */
specifier|const
name|char
modifier|*
name|cname
decl_stmt|;
comment|/* the child's name */
name|LstNode
modifier|*
name|ln
decl_stmt|;
comment|/* Element in parents and iParents lists */
specifier|const
name|char
modifier|*
name|cpref
decl_stmt|;
name|cname
operator|=
name|Var_Value
argument_list|(
name|TARGET
argument_list|,
name|cgn
argument_list|)
expr_stmt|;
comment|/* 	 * If the child was actually made, see what its modification time is 	 * now -- some rules won't actually update the file. If the file still 	 * doesn't exist, make its mtime now. 	 */
if|if
condition|(
name|cgn
operator|->
name|made
operator|!=
name|UPTODATE
condition|)
block|{
ifndef|#
directive|ifndef
name|RECHECK
comment|/* 		 * We can't re-stat the thing, but we can at least take care 		 * of rules where a target depends on a source that actually 		 * creates the target, but only if it has changed, e.g. 		 * 		 * parse.h : parse.o 		 * 		 * parse.o : parse.y 		 *  	yacc -d parse.y 		 *  	cc -c y.tab.c 		 *  	mv y.tab.o parse.o 		 *  	cmp -s y.tab.h parse.h || mv y.tab.h parse.h 		 * 		 * In this case, if the definitions produced by yacc haven't 		 * changed from before, parse.h won't have been updated and 		 * cgn->mtime will reflect the current modification time for 		 * parse.h. This is something of a kludge, I admit, but it's a 		 * useful one.. 		 * XXX: People like to use a rule like 		 * 		 * FRC: 		 * 		 * To force things that depend on FRC to be made, so we have to 		 * check for gn->children being empty as well... 		 */
if|if
condition|(
operator|!
name|Lst_IsEmpty
argument_list|(
operator|&
name|cgn
operator|->
name|commands
argument_list|)
operator|||
name|Lst_IsEmpty
argument_list|(
operator|&
name|cgn
operator|->
name|children
argument_list|)
condition|)
block|{
name|cgn
operator|->
name|mtime
operator|=
name|now
expr_stmt|;
block|}
else|#
directive|else
comment|/* 		 * This is what Make does and it's actually a good thing, as it 		 * allows rules like 		 * 		 *	cmp -s y.tab.h parse.h || cp y.tab.h parse.h 		 * 		 * to function as intended. Unfortunately, thanks to the 		 * stateless nature of NFS (by which I mean the loose coupling 		 * of two clients using the same file from a common server), 		 * there are times when the modification time of a file created 		 * on a remote machine will not be modified before the local 		 * stat() implied by the Dir_MTime occurs, thus leading us to 		 * believe that the file is unchanged, wreaking havoc with 		 * files that depend on this one. 		 * 		 * I have decided it is better to make too much than to make too 		 * little, so this stuff is commented out unless you're sure 		 * it's ok. 		 * -- ardeb 1/12/88 		 */
comment|/* 		 * Christos, 4/9/92: If we are  saving commands pretend that 		 * the target is made now. Otherwise archives with ... rules 		 * don't work! 		 */
if|if
condition|(
name|noExecute
operator|||
operator|(
name|cgn
operator|->
name|type
operator|&
name|OP_SAVE_CMDS
operator|)
operator|||
name|Dir_MTime
argument_list|(
name|cgn
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cgn
operator|->
name|mtime
operator|=
name|now
expr_stmt|;
block|}
name|DEBUGF
argument_list|(
name|MAKE
argument_list|,
operator|(
literal|"update time: %s\n"
operator|,
name|Targ_FmtTime
argument_list|(
name|cgn
operator|->
name|mtime
argument_list|)
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
for|for
control|(
name|ln
operator|=
name|Lst_First
argument_list|(
operator|&
name|cgn
operator|->
name|parents
argument_list|)
init|;
name|ln
operator|!=
name|NULL
condition|;
name|ln
operator|=
name|Lst_Succ
argument_list|(
name|ln
argument_list|)
control|)
block|{
name|pgn
operator|=
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
expr_stmt|;
if|if
condition|(
name|pgn
operator|->
name|make
condition|)
block|{
name|pgn
operator|->
name|unmade
operator|-=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|cgn
operator|->
name|type
operator|&
operator|(
name|OP_EXEC
operator||
name|OP_USE
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|cgn
operator|->
name|made
operator|==
name|MADE
condition|)
name|pgn
operator|->
name|childMade
operator|=
name|TRUE
expr_stmt|;
name|Make_TimeStamp
argument_list|(
name|pgn
argument_list|,
name|cgn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pgn
operator|->
name|unmade
operator|==
literal|0
condition|)
block|{
comment|/* 				 * Queue the node up -- any unmade predecessors 				 * will be dealt with in MakeStartJobs. 				 */
name|Lst_EnQueue
argument_list|(
operator|&
name|toBeMade
argument_list|,
name|pgn
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pgn
operator|->
name|unmade
operator|<
literal|0
condition|)
block|{
name|Error
argument_list|(
literal|"Graph cycles through %s"
argument_list|,
name|pgn
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * Deal with successor nodes. If any is marked for making and has an 	 * unmade count of 0, has not been made and isn't in the examination 	 * queue, it means we need to place it in the queue as it restrained 	 * itself before. 	 */
for|for
control|(
name|ln
operator|=
name|Lst_First
argument_list|(
operator|&
name|cgn
operator|->
name|successors
argument_list|)
init|;
name|ln
operator|!=
name|NULL
condition|;
name|ln
operator|=
name|Lst_Succ
argument_list|(
name|ln
argument_list|)
control|)
block|{
name|GNode
modifier|*
name|succ
init|=
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
decl_stmt|;
if|if
condition|(
name|succ
operator|->
name|make
operator|&&
name|succ
operator|->
name|unmade
operator|==
literal|0
operator|&&
name|succ
operator|->
name|made
operator|==
name|UNMADE
operator|&&
name|Lst_Member
argument_list|(
operator|&
name|toBeMade
argument_list|,
name|succ
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|Lst_EnQueue
argument_list|(
operator|&
name|toBeMade
argument_list|,
name|succ
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Set the .PREFIX and .IMPSRC variables for all the implied parents 	 * of this node. 	 */
name|cpref
operator|=
name|Var_Value
argument_list|(
name|PREFIX
argument_list|,
name|cgn
argument_list|)
expr_stmt|;
for|for
control|(
name|ln
operator|=
name|Lst_First
argument_list|(
operator|&
name|cgn
operator|->
name|iParents
argument_list|)
init|;
name|ln
operator|!=
name|NULL
condition|;
name|ln
operator|=
name|Lst_Succ
argument_list|(
name|ln
argument_list|)
control|)
block|{
name|pgn
operator|=
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
expr_stmt|;
if|if
condition|(
name|pgn
operator|->
name|make
condition|)
block|{
name|Var_Set
argument_list|(
name|IMPSRC
argument_list|,
name|cname
argument_list|,
name|pgn
argument_list|)
expr_stmt|;
name|Var_Set
argument_list|(
name|PREFIX
argument_list|,
name|cpref
argument_list|,
name|pgn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/**  * Make_DoAllVar  *	Set up the ALLSRC and OODATE variables. Sad to say, it must be  *	done separately, rather than while traversing the graph. This is  *	because Make defined OODATE to contain all sources whose modification  *	times were later than that of the target, *not* those sources that  *	were out-of-date. Since in both compatibility and native modes,  *	the modification time of the parent isn't found until the child  *	has been dealt with, we have to wait until now to fill in the  *	variable. As for ALLSRC, the ordering is important and not  *	guaranteed when in native mode, so it must be set here, too.  *  * Side Effects:  *	The ALLSRC and OODATE variables of the given node is filled in.  *	If the node is a .JOIN node, its TARGET variable will be set to  * 	match its ALLSRC variable.  */
end_comment

begin_function
name|void
name|Make_DoAllVar
parameter_list|(
name|GNode
modifier|*
name|gn
parameter_list|)
block|{
name|LstNode
modifier|*
name|ln
decl_stmt|;
name|GNode
modifier|*
name|cgn
decl_stmt|;
specifier|const
name|char
modifier|*
name|child
decl_stmt|;
name|LST_FOREACH
argument_list|(
argument|ln
argument_list|,
argument|&gn->children
argument_list|)
block|{
comment|/* 		 * Add the child's name to the ALLSRC and OODATE variables of 		 * the given node. The child is added only if it has not been 		 * given the .EXEC, .USE or .INVISIBLE attributes. .EXEC and 		 * .USE children are very rarely going to be files, so... 		 * 		 * A child is added to the OODATE variable if its modification 		 * time is later than that of its parent, as defined by Make, 		 * except if the parent is a .JOIN node. In that case, it is 		 * only added to the OODATE variable if it was actually made 		 * (since .JOIN nodes don't have modification times, the 		 * comparison is rather unfair...). 		 */
name|cgn
operator|=
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cgn
operator|->
name|type
operator|&
operator|(
name|OP_EXEC
operator||
name|OP_USE
operator||
name|OP_INVISIBLE
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|OP_NOP
argument_list|(
name|cgn
operator|->
name|type
argument_list|)
condition|)
block|{
comment|/* 				 * this node is only source; use the specific 				 * pathname for it 				 */
name|child
operator|=
name|cgn
operator|->
name|path
condition|?
name|cgn
operator|->
name|path
else|:
name|cgn
operator|->
name|name
expr_stmt|;
block|}
else|else
name|child
operator|=
name|Var_Value
argument_list|(
name|TARGET
argument_list|,
name|cgn
argument_list|)
expr_stmt|;
name|Var_Append
argument_list|(
name|ALLSRC
argument_list|,
name|child
argument_list|,
name|gn
argument_list|)
expr_stmt|;
if|if
condition|(
name|gn
operator|->
name|type
operator|&
name|OP_JOIN
condition|)
block|{
if|if
condition|(
name|cgn
operator|->
name|made
operator|==
name|MADE
condition|)
block|{
name|Var_Append
argument_list|(
name|OODATE
argument_list|,
name|child
argument_list|,
name|gn
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|gn
operator|->
name|mtime
operator|<
name|cgn
operator|->
name|mtime
operator|||
operator|(
name|cgn
operator|->
name|mtime
operator|>=
name|now
operator|&&
name|cgn
operator|->
name|made
operator|==
name|MADE
operator|)
condition|)
block|{
comment|/* 				 * It goes in the OODATE variable if the parent 				 * is younger than the child or if the child has 				 * been modified more recently than the start of 				 * the make. This is to keep pmake from getting 				 * confused if something else updates the parent 				 * after the make starts (shouldn't happen, I 				 * know, but sometimes it does). In such a case, 				 * if we've updated the kid, the parent is 				 * likely to have a modification time later than 				 * that of the kid and anything that relies on 				 * the OODATE variable will be hosed. 				 * 				 * XXX: This will cause all made children to 				 * go in the OODATE variable, even if they're 				 * not touched, if RECHECK isn't defined, since 				 * cgn->mtime is set to now in Make_Update. 				 * According to some people, this is good... 				 */
name|Var_Append
argument_list|(
name|OODATE
argument_list|,
name|child
argument_list|,
name|gn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|Var_Exists
argument_list|(
name|OODATE
argument_list|,
name|gn
argument_list|)
condition|)
block|{
name|Var_Set
argument_list|(
name|OODATE
argument_list|,
literal|""
argument_list|,
name|gn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|Var_Exists
argument_list|(
name|ALLSRC
argument_list|,
name|gn
argument_list|)
condition|)
block|{
name|Var_Set
argument_list|(
name|ALLSRC
argument_list|,
literal|""
argument_list|,
name|gn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gn
operator|->
name|type
operator|&
name|OP_JOIN
condition|)
block|{
name|Var_Set
argument_list|(
name|TARGET
argument_list|,
name|Var_Value
argument_list|(
name|ALLSRC
argument_list|,
name|gn
argument_list|)
argument_list|,
name|gn
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * MakeStartJobs  *	Start as many jobs as possible.  *  * Results:  *	If the query flag was given to pmake, no job will be started,  *	but as soon as an out-of-date target is found, this function  *	returns TRUE. At all other times, this function returns FALSE.  *  * Side Effects:  *	Nodes are removed from the toBeMade queue and job table slots  *	are filled.  */
end_comment

begin_function
specifier|static
name|Boolean
name|MakeStartJobs
parameter_list|(
name|void
parameter_list|)
block|{
name|GNode
modifier|*
name|gn
decl_stmt|;
while|while
condition|(
operator|!
name|Lst_IsEmpty
argument_list|(
operator|&
name|toBeMade
argument_list|)
operator|&&
operator|!
name|Job_Full
argument_list|()
condition|)
block|{
name|gn
operator|=
name|Lst_DeQueue
argument_list|(
operator|&
name|toBeMade
argument_list|)
expr_stmt|;
name|DEBUGF
argument_list|(
name|MAKE
argument_list|,
operator|(
literal|"Examining %s..."
operator|,
name|gn
operator|->
name|name
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * Make sure any and all predecessors that are going to be made, 		 * have been. 		 */
if|if
condition|(
operator|!
name|Lst_IsEmpty
argument_list|(
operator|&
name|gn
operator|->
name|preds
argument_list|)
condition|)
block|{
name|LstNode
modifier|*
name|ln
decl_stmt|;
for|for
control|(
name|ln
operator|=
name|Lst_First
argument_list|(
operator|&
name|gn
operator|->
name|preds
argument_list|)
init|;
name|ln
operator|!=
name|NULL
condition|;
name|ln
operator|=
name|Lst_Succ
argument_list|(
name|ln
argument_list|)
control|)
block|{
name|GNode
modifier|*
name|pgn
init|=
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
decl_stmt|;
if|if
condition|(
name|pgn
operator|->
name|make
operator|&&
name|pgn
operator|->
name|made
operator|==
name|UNMADE
condition|)
block|{
name|DEBUGF
argument_list|(
name|MAKE
argument_list|,
operator|(
literal|"predecessor %s not made "
literal|"yet.\n"
operator|,
name|pgn
operator|->
name|name
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* 			 * If ln isn't NULL, there's a predecessor as yet 			 * unmade, so we just drop this node on the floor. 			 * When the node in question has been made, it will 			 * notice this node as being ready to make but as yet 			 * unmade and will place the node on the queue. 			 */
if|if
condition|(
name|ln
operator|!=
name|NULL
condition|)
block|{
continue|continue;
block|}
block|}
name|numNodes
operator|--
expr_stmt|;
if|if
condition|(
name|Make_OODate
argument_list|(
name|gn
argument_list|)
condition|)
block|{
name|DEBUGF
argument_list|(
name|MAKE
argument_list|,
operator|(
literal|"out-of-date\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|queryFlag
condition|)
block|{
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
name|Make_DoAllVar
argument_list|(
name|gn
argument_list|)
expr_stmt|;
name|Job_Make
argument_list|(
name|gn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DEBUGF
argument_list|(
name|MAKE
argument_list|,
operator|(
literal|"up-to-date\n"
operator|)
argument_list|)
expr_stmt|;
name|gn
operator|->
name|made
operator|=
name|UPTODATE
expr_stmt|;
if|if
condition|(
name|gn
operator|->
name|type
operator|&
name|OP_JOIN
condition|)
block|{
comment|/* 				 * Even for an up-to-date .JOIN node, we need 				 * it to have its context variables so 				 * references to it get the correct value for 				 * .TARGET when building up the context 				 * variables of its parent(s)... 				 */
name|Make_DoAllVar
argument_list|(
name|gn
argument_list|)
expr_stmt|;
block|}
name|Make_Update
argument_list|(
name|gn
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * MakePrintStatus  *	Print the status of a top-level node, viz. it being up-to-date  *	already or not created due to an error in a lower level.  *	Callback function for Make_Run via LST_FOREACH.  If gn->unmade is  *	nonzero and that is meant to imply a cycle in the graph, then  *	cycle is TRUE.  *  * Side Effects:  *	A message may be printed.  */
end_comment

begin_function
specifier|static
name|void
name|MakePrintStatus
parameter_list|(
name|GNode
modifier|*
name|gn
parameter_list|,
name|Boolean
name|cycle
parameter_list|)
block|{
name|LstNode
modifier|*
name|ln
decl_stmt|;
if|if
condition|(
name|gn
operator|->
name|made
operator|==
name|UPTODATE
condition|)
block|{
name|printf
argument_list|(
literal|"`%s' is up to date.\n"
argument_list|,
name|gn
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|gn
operator|->
name|unmade
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|cycle
condition|)
block|{
comment|/* 			 * If printing cycles and came to one that has unmade 			 * children, print out the cycle by recursing on its 			 * children. Note a cycle like: 			 *	a : b 			 *	b : c 			 *	c : b 			 * will cause this to erroneously complain about a 			 * being in the cycle, but this is a good approximation. 			 */
if|if
condition|(
name|gn
operator|->
name|made
operator|==
name|CYCLE
condition|)
block|{
name|Error
argument_list|(
literal|"Graph cycles through `%s'"
argument_list|,
name|gn
operator|->
name|name
argument_list|)
expr_stmt|;
name|gn
operator|->
name|made
operator|=
name|ENDCYCLE
expr_stmt|;
name|LST_FOREACH
argument_list|(
argument|ln
argument_list|,
argument|&gn->children
argument_list|)
name|MakePrintStatus
argument_list|(
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|gn
operator|->
name|made
operator|=
name|UNMADE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|gn
operator|->
name|made
operator|!=
name|ENDCYCLE
condition|)
block|{
name|gn
operator|->
name|made
operator|=
name|CYCLE
expr_stmt|;
name|LST_FOREACH
argument_list|(
argument|ln
argument_list|,
argument|&gn->children
argument_list|)
name|MakePrintStatus
argument_list|(
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|printf
argument_list|(
literal|"`%s' not remade because of errors.\n"
argument_list|,
name|gn
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/**  * Make_Run  *	Initialize the nodes to remake and the list of nodes which are  *	ready to be made by doing a breadth-first traversal of the graph  *	starting from the nodes in the given list. Once this traversal  *	is finished, all the 'leaves' of the graph are in the toBeMade  *	queue.  *	Using this queue and the Job module, work back up the graph,  *	calling on MakeStartJobs to keep the job table as full as  *	possible.  *  * Results:  *	TRUE if work was done. FALSE otherwise.  *  * Side Effects:  *	The make field of all nodes involved in the creation of the given  *	targets is set to 1. The toBeMade list is set to contain all the  *	'leaves' of these subgraphs.  */
end_comment

begin_function
name|Boolean
name|Make_Run
parameter_list|(
name|Lst
modifier|*
name|targs
parameter_list|)
block|{
name|GNode
modifier|*
name|gn
decl_stmt|;
comment|/* a temporary pointer */
name|GNode
modifier|*
name|cgn
decl_stmt|;
name|Lst
name|examine
decl_stmt|;
comment|/* List of targets to examine */
name|int
name|errors
decl_stmt|;
comment|/* Number of errors the Job module reports */
name|LstNode
modifier|*
name|ln
decl_stmt|;
name|Lst_Init
argument_list|(
operator|&
name|examine
argument_list|)
expr_stmt|;
name|Lst_Duplicate
argument_list|(
operator|&
name|examine
argument_list|,
name|targs
argument_list|,
name|NOCOPY
argument_list|)
expr_stmt|;
name|numNodes
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Make an initial downward pass over the graph, marking nodes to be 	 * made as we go down. We call Suff_FindDeps to find where a node is and 	 * to get some children for it if it has none and also has no commands. 	 * If the node is a leaf, we stick it on the toBeMade queue to 	 * be looked at in a minute, otherwise we add its children to our queue 	 * and go on about our business. 	 */
while|while
condition|(
operator|!
name|Lst_IsEmpty
argument_list|(
operator|&
name|examine
argument_list|)
condition|)
block|{
name|gn
operator|=
name|Lst_DeQueue
argument_list|(
operator|&
name|examine
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|gn
operator|->
name|make
condition|)
block|{
name|gn
operator|->
name|make
operator|=
name|TRUE
expr_stmt|;
name|numNodes
operator|++
expr_stmt|;
comment|/* 			 * Apply any .USE rules before looking for implicit 			 * dependencies to make sure everything has commands 			 * that should... 			 */
name|LST_FOREACH
argument_list|(
argument|ln
argument_list|,
argument|&gn->children
argument_list|)
if|if
condition|(
name|Make_HandleUse
argument_list|(
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
argument_list|,
name|gn
argument_list|)
condition|)
break|break;
name|Suff_FindDeps
argument_list|(
name|gn
argument_list|)
expr_stmt|;
if|if
condition|(
name|gn
operator|->
name|unmade
operator|!=
literal|0
condition|)
block|{
name|LST_FOREACH
argument_list|(
argument|ln
argument_list|,
argument|&gn->children
argument_list|)
block|{
name|cgn
operator|=
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cgn
operator|->
name|make
operator|&&
operator|!
operator|(
name|cgn
operator|->
name|type
operator|&
name|OP_USE
operator|)
condition|)
name|Lst_EnQueue
argument_list|(
operator|&
name|examine
argument_list|,
name|cgn
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|Lst_EnQueue
argument_list|(
operator|&
name|toBeMade
argument_list|,
name|gn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|queryFlag
condition|)
block|{
comment|/* 		 * We wouldn't do any work unless we could start some jobs in 		 * the next loop... (we won't actually start any, of course, 		 * this is just to see if any of the targets was out of date) 		 */
return|return
operator|(
name|MakeStartJobs
argument_list|()
operator|)
return|;
block|}
else|else
block|{
comment|/* 		 * Initialization. At the moment, no jobs are running and 		 * until some get started, nothing will happen since the 		 * remaining upward traversal of the graph is performed by the 		 * routines in job.c upon the finishing of a job. So we fill 		 * the Job table as much as we can before going into our loop. 		 */
name|MakeStartJobs
argument_list|()
expr_stmt|;
block|}
comment|/* 	 * Main Loop: The idea here is that the ending of jobs will take 	 * care of the maintenance of data structures and the waiting for output 	 * will cause us to be idle most of the time while our children run as 	 * much as possible. Because the job table is kept as full as possible, 	 * the only time when it will be empty is when all the jobs which need 	 * running have been run, so that is the end condition of this loop. 	 * Note that the Job module will exit if there were any errors unless 	 * the keepgoing flag was given. 	 */
while|while
condition|(
operator|!
name|Job_Empty
argument_list|()
condition|)
block|{
name|Job_CatchOutput
argument_list|(
operator|!
name|Lst_IsEmpty
argument_list|(
operator|&
name|toBeMade
argument_list|)
argument_list|)
expr_stmt|;
name|Job_CatchChildren
argument_list|(
operator|!
name|usePipes
argument_list|)
expr_stmt|;
name|MakeStartJobs
argument_list|()
expr_stmt|;
block|}
name|errors
operator|=
name|Job_Finish
argument_list|()
expr_stmt|;
comment|/* 	 * Print the final status of each target. E.g. if it wasn't made 	 * because some inferior reported an error. 	 */
name|errors
operator|=
operator|(
operator|(
name|errors
operator|==
literal|0
operator|)
operator|&&
operator|(
name|numNodes
operator|!=
literal|0
operator|)
operator|)
expr_stmt|;
name|LST_FOREACH
argument_list|(
argument|ln
argument_list|,
argument|targs
argument_list|)
name|MakePrintStatus
argument_list|(
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
argument_list|,
name|errors
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

end_unit

