begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1988, 1989, 1990, 1993  *	The Regents of the University of California.  All rights reserved.  * Copyright (c) 1989 by Berkeley Softworks  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Adam de Boor.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)parse.c	8.3 (Berkeley) 3/19/94"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/*-  * parse.c --  *	Functions to parse a makefile.  *  *	One function, Parse_Init, must be called before any functions  *	in this module are used. After that, the function Parse_File is the  *	main entry point and controls most of the other functions in this  *	module.  *  *	Most important structures are kept in Lsts. Directories for  *	the #include "..." function are kept in the 'parseIncPath' Lst, while  *	those for the #include<...> are kept in the 'sysIncPath' Lst. The  *	targets currently being defined are kept in the 'targets' Lst.  *  *	The variables 'fname' and 'lineno' are used to track the name  *	of the current file and the line number in that file so that error  *	messages can be more meaningful.  *  * Interface:  *	Parse_Init	    	    Initialization function which must be  *	    	  	    	    called before anything else in this module  *	    	  	    	    is used.  *  *	Parse_End		    Cleanup the module  *  *	Parse_File	    	    Function used to parse a makefile. It must  *	    	  	    	    be given the name of the file, which should  *	    	  	    	    already have been opened, and a function  *	    	  	    	    to call to read a character from the file.  *  *	Parse_IsVar	    	    Returns TRUE if the given line is a  *	    	  	    	    variable assignment. Used by MainParseArgs  *	    	  	    	    to determine if an argument is a target  *	    	  	    	    or a variable assignment. Used internally  *	    	  	    	    for pretty much the same thing...  *  *	Parse_Error	    	    Function called when an error occurs in  *	    	  	    	    parsing. Used by the variable and  *	    	  	    	    conditional modules.  *	Parse_MainName	    	    Returns a Lst of the main target to create.  */
end_comment

begin_if
if|#
directive|if
name|__STDC__
end_if

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|"make.h"
end_include

begin_include
include|#
directive|include
file|"hash.h"
end_include

begin_include
include|#
directive|include
file|"dir.h"
end_include

begin_include
include|#
directive|include
file|"job.h"
end_include

begin_include
include|#
directive|include
file|"buf.h"
end_include

begin_include
include|#
directive|include
file|"pathnames.h"
end_include

begin_comment
comment|/*  * These values are returned by ParseEOF to tell Parse_File whether to  * CONTINUE parsing, i.e. it had only reached the end of an include file,  * or if it's DONE.  */
end_comment

begin_define
define|#
directive|define
name|CONTINUE
value|1
end_define

begin_define
define|#
directive|define
name|DONE
value|0
end_define

begin_decl_stmt
specifier|static
name|Lst
name|targets
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* targets we're working on */
end_comment

begin_decl_stmt
specifier|static
name|Lst
name|targCmds
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* command lines for targets */
end_comment

begin_decl_stmt
specifier|static
name|Boolean
name|inLine
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* true if currently in a dependency 				 * line or its commands */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|char
modifier|*
name|str
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
block|}
name|PTR
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|fname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* name of current file (for errors) */
end_comment

begin_decl_stmt
specifier|static
name|int
name|lineno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* line number in current file */
end_comment

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|curFILE
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current makefile */
end_comment

begin_decl_stmt
specifier|static
name|PTR
modifier|*
name|curPTR
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current makefile */
end_comment

begin_decl_stmt
specifier|static
name|int
name|fatals
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|GNode
modifier|*
name|mainNode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The main target to create. This is the 				 * first target on the first dependency 				 * line in the first makefile */
end_comment

begin_comment
comment|/*  * Definitions for handling #include specifications  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|IFile
block|{
name|char
modifier|*
name|fname
decl_stmt|;
comment|/* name of previous file */
name|int
name|lineno
decl_stmt|;
comment|/* saved line number */
name|FILE
modifier|*
name|F
decl_stmt|;
comment|/* the open stream */
name|PTR
modifier|*
name|p
decl_stmt|;
comment|/* the char pointer */
block|}
name|IFile
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|Lst
name|includes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* stack of IFiles generated by 				 * #includes */
end_comment

begin_decl_stmt
name|Lst
name|parseIncPath
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list of directories for "..." includes */
end_comment

begin_decl_stmt
name|Lst
name|sysIncPath
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list of directories for<...> includes */
end_comment

begin_comment
comment|/*-  * specType contains the SPECial TYPE of the current target. It is  * Not if the target is unspecial. If it *is* special, however, the children  * are linked as children of the parent but not vice versa. This variable is  * set in ParseDoDependency  */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|Begin
block|,
comment|/* .BEGIN */
name|Default
block|,
comment|/* .DEFAULT */
name|End
block|,
comment|/* .END */
name|Ignore
block|,
comment|/* .IGNORE */
name|Includes
block|,
comment|/* .INCLUDES */
name|Interrupt
block|,
comment|/* .INTERRUPT */
name|Libs
block|,
comment|/* .LIBS */
name|MFlags
block|,
comment|/* .MFLAGS or .MAKEFLAGS */
name|Main
block|,
comment|/* .MAIN and we don't have anything user-specified to 		     * make */
name|NoExport
block|,
comment|/* .NOEXPORT */
name|Not
block|,
comment|/* Not special */
name|NotParallel
block|,
comment|/* .NOTPARALELL */
name|Null
block|,
comment|/* .NULL */
name|Order
block|,
comment|/* .ORDER */
name|Parallel
block|,
comment|/* .PARALLEL */
name|ExPath
block|,
comment|/* .PATH */
name|Phony
block|,
comment|/* .PHONY */
name|Precious
block|,
comment|/* .PRECIOUS */
name|ExShell
block|,
comment|/* .SHELL */
name|Silent
block|,
comment|/* .SILENT */
name|SingleShell
block|,
comment|/* .SINGLESHELL */
name|Suffixes
block|,
comment|/* .SUFFIXES */
name|Wait
block|,
comment|/* .WAIT */
name|Attribute
comment|/* Generic attribute */
block|}
name|ParseSpecial
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|ParseSpecial
name|specType
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|waiting
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Predecessor node for handling .ORDER. Initialized to NILGNODE when .ORDER  * seen, then set to each successive source on the line.  */
end_comment

begin_decl_stmt
specifier|static
name|GNode
modifier|*
name|predecessor
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The parseKeywords table is searched using binary search when deciding  * if a target or source is special. The 'spec' field is the ParseSpecial  * type of the keyword ("Not" if the keyword isn't special as a target) while  * the 'op' field is the operator to apply to the list of targets if the  * keyword is used as a source ("0" if the keyword isn't special as a source)  */
end_comment

begin_struct
specifier|static
struct|struct
block|{
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Name of keyword */
name|ParseSpecial
name|spec
decl_stmt|;
comment|/* Type when used as a target */
name|int
name|op
decl_stmt|;
comment|/* Operator when used as a source */
block|}
name|parseKeywords
index|[]
init|=
block|{
block|{
literal|".BEGIN"
block|,
name|Begin
block|,
literal|0
block|}
block|,
block|{
literal|".DEFAULT"
block|,
name|Default
block|,
literal|0
block|}
block|,
block|{
literal|".END"
block|,
name|End
block|,
literal|0
block|}
block|,
block|{
literal|".EXEC"
block|,
name|Attribute
block|,
name|OP_EXEC
block|}
block|,
block|{
literal|".IGNORE"
block|,
name|Ignore
block|,
name|OP_IGNORE
block|}
block|,
block|{
literal|".INCLUDES"
block|,
name|Includes
block|,
literal|0
block|}
block|,
block|{
literal|".INTERRUPT"
block|,
name|Interrupt
block|,
literal|0
block|}
block|,
block|{
literal|".INVISIBLE"
block|,
name|Attribute
block|,
name|OP_INVISIBLE
block|}
block|,
block|{
literal|".JOIN"
block|,
name|Attribute
block|,
name|OP_JOIN
block|}
block|,
block|{
literal|".LIBS"
block|,
name|Libs
block|,
literal|0
block|}
block|,
block|{
literal|".MAIN"
block|,
name|Main
block|,
literal|0
block|}
block|,
block|{
literal|".MAKE"
block|,
name|Attribute
block|,
name|OP_MAKE
block|}
block|,
block|{
literal|".MAKEFLAGS"
block|,
name|MFlags
block|,
literal|0
block|}
block|,
block|{
literal|".MFLAGS"
block|,
name|MFlags
block|,
literal|0
block|}
block|,
block|{
literal|".NOTMAIN"
block|,
name|Attribute
block|,
name|OP_NOTMAIN
block|}
block|,
block|{
literal|".NOTPARALLEL"
block|,
name|NotParallel
block|,
literal|0
block|}
block|,
block|{
literal|".NO_PARALLEL"
block|,
name|NotParallel
block|,
literal|0
block|}
block|,
block|{
literal|".NULL"
block|,
name|Null
block|,
literal|0
block|}
block|,
block|{
literal|".OPTIONAL"
block|,
name|Attribute
block|,
name|OP_OPTIONAL
block|}
block|,
block|{
literal|".ORDER"
block|,
name|Order
block|,
literal|0
block|}
block|,
block|{
literal|".PARALLEL"
block|,
name|Parallel
block|,
literal|0
block|}
block|,
block|{
literal|".PATH"
block|,
name|ExPath
block|,
literal|0
block|}
block|,
block|{
literal|".PHONY"
block|,
name|Phony
block|,
name|OP_PHONY
block|}
block|,
block|{
literal|".PRECIOUS"
block|,
name|Precious
block|,
name|OP_PRECIOUS
block|}
block|,
block|{
literal|".RECURSIVE"
block|,
name|Attribute
block|,
name|OP_MAKE
block|}
block|,
block|{
literal|".SHELL"
block|,
name|ExShell
block|,
literal|0
block|}
block|,
block|{
literal|".SILENT"
block|,
name|Silent
block|,
name|OP_SILENT
block|}
block|,
block|{
literal|".SINGLESHELL"
block|,
name|SingleShell
block|,
literal|0
block|}
block|,
block|{
literal|".SUFFIXES"
block|,
name|Suffixes
block|,
literal|0
block|}
block|,
block|{
literal|".USE"
block|,
name|Attribute
block|,
name|OP_USE
block|}
block|,
block|{
literal|".WAIT"
block|,
name|Wait
block|,
literal|0
block|}
block|, }
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
name|ParseFindKeyword
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ParseLinkSrc
name|__P
argument_list|(
operator|(
name|ClientData
operator|,
name|ClientData
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ParseDoOp
name|__P
argument_list|(
operator|(
name|ClientData
operator|,
name|ClientData
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ParseAddDep
name|__P
argument_list|(
operator|(
name|ClientData
operator|,
name|ClientData
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ParseDoSrc
name|__P
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|,
name|Lst
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ParseFindMain
name|__P
argument_list|(
operator|(
name|ClientData
operator|,
name|ClientData
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ParseAddDir
name|__P
argument_list|(
operator|(
name|ClientData
operator|,
name|ClientData
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ParseClearPath
name|__P
argument_list|(
operator|(
name|ClientData
operator|,
name|ClientData
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ParseDoDependency
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ParseAddCmd
name|__P
argument_list|(
operator|(
name|ClientData
operator|,
name|ClientData
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ParseReadc
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ParseUnreadc
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ParseHasCommands
name|__P
argument_list|(
operator|(
name|ClientData
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ParseDoInclude
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|SYSVINCLUDE
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|ParseTraditionalInclude
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|ParseEOF
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ParseReadLine
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ParseSkipLine
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ParseFinishLine
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*-  *----------------------------------------------------------------------  * ParseFindKeyword --  *	Look in the table of keywords for one matching the given string.  *  * Results:  *	The index of the keyword, or -1 if it isn't there.  *  * Side Effects:  *	None  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|ParseFindKeyword
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
comment|/* String to find */
block|{
specifier|register
name|int
name|start
decl_stmt|,
name|end
decl_stmt|,
name|cur
decl_stmt|;
specifier|register
name|int
name|diff
decl_stmt|;
name|start
operator|=
literal|0
expr_stmt|;
name|end
operator|=
operator|(
sizeof|sizeof
argument_list|(
name|parseKeywords
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|parseKeywords
index|[
literal|0
index|]
argument_list|)
operator|)
operator|-
literal|1
expr_stmt|;
do|do
block|{
name|cur
operator|=
name|start
operator|+
operator|(
operator|(
name|end
operator|-
name|start
operator|)
operator|/
literal|2
operator|)
expr_stmt|;
name|diff
operator|=
name|strcmp
argument_list|(
name|str
argument_list|,
name|parseKeywords
index|[
name|cur
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|diff
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|cur
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|diff
operator|<
literal|0
condition|)
block|{
name|end
operator|=
name|cur
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|start
operator|=
name|cur
operator|+
literal|1
expr_stmt|;
block|}
block|}
do|while
condition|(
name|start
operator|<=
name|end
condition|)
do|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  * Parse_Error  --  *	Error message abort function for parsing. Prints out the context  *	of the error (line number and file) as well as the message with  *	two optional arguments.  *  * Results:  *	None  *  * Side Effects:  *	"fatals" is incremented if the level is PARSE_FATAL.  */
end_comment

begin_comment
comment|/* VARARGS */
end_comment

begin_function
name|void
if|#
directive|if
name|__STDC__
name|Parse_Error
parameter_list|(
name|int
name|type
parameter_list|,
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
else|#
directive|else
function|Parse_Error
parameter_list|(
name|va_alist
parameter_list|)
function|va_dcl
endif|#
directive|endif
block|{
name|va_list
name|ap
decl_stmt|;
if|#
directive|if
name|__STDC__
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
else|#
directive|else
name|int
name|type
decl_stmt|;
comment|/* Error type (PARSE_WARNING, PARSE_FATAL) */
name|char
modifier|*
name|fmt
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|type
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|fmt
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\"%s\", line %d: "
argument_list|,
name|fname
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|PARSE_WARNING
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"warning: "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|PARSE_FATAL
condition|)
name|fatals
operator|+=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-  *---------------------------------------------------------------------  * ParseLinkSrc  --  *	Link the parent node to its new child. Used in a Lst_ForEach by  *	ParseDoDependency. If the specType isn't 'Not', the parent  *	isn't linked as a parent of the child.  *  * Results:  *	Always = 0  *  * Side Effects:  *	New elements are added to the parents list of cgn and the  *	children list of cgn. the unmade field of pgn is updated  *	to reflect the additional child.  *---------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|ParseLinkSrc
parameter_list|(
name|pgnp
parameter_list|,
name|cgnp
parameter_list|)
name|ClientData
name|pgnp
decl_stmt|;
comment|/* The parent node */
name|ClientData
name|cgnp
decl_stmt|;
comment|/* The child node */
block|{
name|GNode
modifier|*
name|pgn
init|=
operator|(
name|GNode
operator|*
operator|)
name|pgnp
decl_stmt|;
name|GNode
modifier|*
name|cgn
init|=
operator|(
name|GNode
operator|*
operator|)
name|cgnp
decl_stmt|;
if|if
condition|(
name|Lst_Member
argument_list|(
name|pgn
operator|->
name|children
argument_list|,
operator|(
name|ClientData
operator|)
name|cgn
argument_list|)
operator|==
name|NILLNODE
condition|)
block|{
operator|(
name|void
operator|)
name|Lst_AtEnd
argument_list|(
name|pgn
operator|->
name|children
argument_list|,
operator|(
name|ClientData
operator|)
name|cgn
argument_list|)
expr_stmt|;
if|if
condition|(
name|specType
operator|==
name|Not
condition|)
block|{
operator|(
name|void
operator|)
name|Lst_AtEnd
argument_list|(
name|cgn
operator|->
name|parents
argument_list|,
operator|(
name|ClientData
operator|)
name|pgn
argument_list|)
expr_stmt|;
block|}
name|pgn
operator|->
name|unmade
operator|+=
literal|1
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *---------------------------------------------------------------------  * ParseDoOp  --  *	Apply the parsed operator to the given target node. Used in a  *	Lst_ForEach call by ParseDoDependency once all targets have  *	been found and their operator parsed. If the previous and new  *	operators are incompatible, a major error is taken.  *  * Results:  *	Always 0  *  * Side Effects:  *	The type field of the node is altered to reflect any new bits in  *	the op.  *---------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|ParseDoOp
parameter_list|(
name|gnp
parameter_list|,
name|opp
parameter_list|)
name|ClientData
name|gnp
decl_stmt|;
comment|/* The node to which the operator is to be 				 * applied */
name|ClientData
name|opp
decl_stmt|;
comment|/* The operator to apply */
block|{
name|GNode
modifier|*
name|gn
init|=
operator|(
name|GNode
operator|*
operator|)
name|gnp
decl_stmt|;
name|int
name|op
init|=
operator|*
operator|(
name|int
operator|*
operator|)
name|opp
decl_stmt|;
comment|/*      * If the dependency mask of the operator and the node don't match and      * the node has actually had an operator applied to it before, and      * the operator actually has some dependency information in it, complain.      */
if|if
condition|(
operator|(
operator|(
name|op
operator|&
name|OP_OPMASK
operator|)
operator|!=
operator|(
name|gn
operator|->
name|type
operator|&
name|OP_OPMASK
operator|)
operator|)
operator|&&
operator|!
name|OP_NOP
argument_list|(
name|gn
operator|->
name|type
argument_list|)
operator|&&
operator|!
name|OP_NOP
argument_list|(
name|op
argument_list|)
condition|)
block|{
name|Parse_Error
argument_list|(
name|PARSE_FATAL
argument_list|,
literal|"Inconsistent operator for %s"
argument_list|,
name|gn
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|op
operator|==
name|OP_DOUBLEDEP
operator|)
operator|&&
operator|(
operator|(
name|gn
operator|->
name|type
operator|&
name|OP_OPMASK
operator|)
operator|==
name|OP_DOUBLEDEP
operator|)
condition|)
block|{
comment|/* 	 * If the node was the object of a :: operator, we need to create a 	 * new instance of it for the children and commands on this dependency 	 * line. The new instance is placed on the 'cohorts' list of the 	 * initial one (note the initial one is not on its own cohorts list) 	 * and the new instance is linked to all parents of the initial 	 * instance. 	 */
specifier|register
name|GNode
modifier|*
name|cohort
decl_stmt|;
name|LstNode
name|ln
decl_stmt|;
name|cohort
operator|=
name|Targ_NewGN
argument_list|(
name|gn
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* 	 * Duplicate links to parents so graph traversal is simple. Perhaps 	 * some type bits should be duplicated? 	 * 	 * Make the cohort invisible as well to avoid duplicating it into 	 * other variables. True, parents of this target won't tend to do 	 * anything with their local variables, but better safe than 	 * sorry. 	 */
name|Lst_ForEach
argument_list|(
name|gn
operator|->
name|parents
argument_list|,
name|ParseLinkSrc
argument_list|,
operator|(
name|ClientData
operator|)
name|cohort
argument_list|)
expr_stmt|;
name|cohort
operator|->
name|type
operator|=
name|OP_DOUBLEDEP
operator||
name|OP_INVISIBLE
expr_stmt|;
operator|(
name|void
operator|)
name|Lst_AtEnd
argument_list|(
name|gn
operator|->
name|cohorts
argument_list|,
operator|(
name|ClientData
operator|)
name|cohort
argument_list|)
expr_stmt|;
comment|/* 	 * Replace the node in the targets list with the new copy 	 */
name|ln
operator|=
name|Lst_Member
argument_list|(
name|targets
argument_list|,
operator|(
name|ClientData
operator|)
name|gn
argument_list|)
expr_stmt|;
name|Lst_Replace
argument_list|(
name|ln
argument_list|,
operator|(
name|ClientData
operator|)
name|cohort
argument_list|)
expr_stmt|;
name|gn
operator|=
name|cohort
expr_stmt|;
block|}
comment|/*      * We don't want to nuke any previous flags (whatever they were) so we      * just OR the new operator into the old      */
name|gn
operator|->
name|type
operator||=
name|op
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *---------------------------------------------------------------------  * ParseAddDep  --  *	Check if the pair of GNodes given needs to be synchronized.  *	This has to be when two nodes are on different sides of a  *	.WAIT directive.  *  * Results:  *	Returns 1 if the two targets need to be ordered, 0 otherwise.  *	If it returns 1, the search can stop  *  * Side Effects:  *	A dependency can be added between the two nodes.  *  *---------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|ParseAddDep
parameter_list|(
name|pp
parameter_list|,
name|sp
parameter_list|)
name|ClientData
name|pp
decl_stmt|;
name|ClientData
name|sp
decl_stmt|;
block|{
name|GNode
modifier|*
name|p
init|=
operator|(
name|GNode
operator|*
operator|)
name|pp
decl_stmt|;
name|GNode
modifier|*
name|s
init|=
operator|(
name|GNode
operator|*
operator|)
name|sp
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|order
operator|<
name|s
operator|->
name|order
condition|)
block|{
comment|/* 	 * XXX: This can cause loops, and loops can cause unmade targets, 	 * but checking is tedious, and the debugging output can show the 	 * problem 	 */
operator|(
name|void
operator|)
name|Lst_AtEnd
argument_list|(
name|p
operator|->
name|successors
argument_list|,
operator|(
name|ClientData
operator|)
name|s
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Lst_AtEnd
argument_list|(
name|s
operator|->
name|preds
argument_list|,
operator|(
name|ClientData
operator|)
name|p
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*-  *---------------------------------------------------------------------  * ParseDoSrc  --  *	Given the name of a source, figure out if it is an attribute  *	and apply it to the targets if it is. Else decide if there is  *	some attribute which should be applied *to* the source because  *	of some special target and apply it if so. Otherwise, make the  *	source be a child of the targets in the list 'targets'  *  * Results:  *	None  *  * Side Effects:  *	Operator bits may be added to the list of targets or to the source.  *	The targets may have a new source added to their lists of children.  *---------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|ParseDoSrc
parameter_list|(
name|tOp
parameter_list|,
name|src
parameter_list|,
name|allsrc
parameter_list|)
name|int
name|tOp
decl_stmt|;
comment|/* operator (if any) from special targets */
name|char
modifier|*
name|src
decl_stmt|;
comment|/* name of the source to handle */
name|Lst
name|allsrc
decl_stmt|;
comment|/* List of all sources to wait for */
block|{
name|GNode
modifier|*
name|gn
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|*
name|src
operator|==
literal|'.'
operator|&&
name|isupper
argument_list|(
name|src
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|int
name|keywd
init|=
name|ParseFindKeyword
argument_list|(
name|src
argument_list|)
decl_stmt|;
if|if
condition|(
name|keywd
operator|!=
operator|-
literal|1
condition|)
block|{
name|int
name|op
init|=
name|parseKeywords
index|[
name|keywd
index|]
operator|.
name|op
decl_stmt|;
if|if
condition|(
name|op
operator|!=
literal|0
condition|)
block|{
name|Lst_ForEach
argument_list|(
name|targets
argument_list|,
name|ParseDoOp
argument_list|,
operator|(
name|ClientData
operator|)
operator|&
name|op
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|parseKeywords
index|[
name|keywd
index|]
operator|.
name|spec
operator|==
name|Wait
condition|)
block|{
name|waiting
operator|++
expr_stmt|;
return|return;
block|}
block|}
block|}
switch|switch
condition|(
name|specType
condition|)
block|{
case|case
name|Main
case|:
comment|/* 	 * If we have noted the existence of a .MAIN, it means we need 	 * to add the sources of said target to the list of things 	 * to create. The string 'src' is likely to be free, so we 	 * must make a new copy of it. Note that this will only be 	 * invoked if the user didn't specify a target on the command 	 * line. This is to allow #ifmake's to succeed, or something... 	 */
operator|(
name|void
operator|)
name|Lst_AtEnd
argument_list|(
name|create
argument_list|,
operator|(
name|ClientData
operator|)
name|estrdup
argument_list|(
name|src
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Add the name to the .TARGETS variable as well, so the user cna 	 * employ that, if desired. 	 */
name|Var_Append
argument_list|(
literal|".TARGETS"
argument_list|,
name|src
argument_list|,
name|VAR_GLOBAL
argument_list|)
expr_stmt|;
return|return;
case|case
name|Order
case|:
comment|/* 	 * Create proper predecessor/successor links between the previous 	 * source and the current one. 	 */
name|gn
operator|=
name|Targ_FindNode
argument_list|(
name|src
argument_list|,
name|TARG_CREATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|predecessor
operator|!=
name|NILGNODE
condition|)
block|{
operator|(
name|void
operator|)
name|Lst_AtEnd
argument_list|(
name|predecessor
operator|->
name|successors
argument_list|,
operator|(
name|ClientData
operator|)
name|gn
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Lst_AtEnd
argument_list|(
name|gn
operator|->
name|preds
argument_list|,
operator|(
name|ClientData
operator|)
name|predecessor
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * The current source now becomes the predecessor for the next one. 	 */
name|predecessor
operator|=
name|gn
expr_stmt|;
break|break;
default|default:
comment|/* 	 * If the source is not an attribute, we need to find/create 	 * a node for it. After that we can apply any operator to it 	 * from a special target or link it to its parents, as 	 * appropriate. 	 * 	 * In the case of a source that was the object of a :: operator, 	 * the attribute is applied to all of its instances (as kept in 	 * the 'cohorts' list of the node) or all the cohorts are linked 	 * to all the targets. 	 */
name|gn
operator|=
name|Targ_FindNode
argument_list|(
name|src
argument_list|,
name|TARG_CREATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|tOp
condition|)
block|{
name|gn
operator|->
name|type
operator||=
name|tOp
expr_stmt|;
block|}
else|else
block|{
name|Lst_ForEach
argument_list|(
name|targets
argument_list|,
name|ParseLinkSrc
argument_list|,
operator|(
name|ClientData
operator|)
name|gn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|gn
operator|->
name|type
operator|&
name|OP_OPMASK
operator|)
operator|==
name|OP_DOUBLEDEP
condition|)
block|{
specifier|register
name|GNode
modifier|*
name|cohort
decl_stmt|;
specifier|register
name|LstNode
name|ln
decl_stmt|;
for|for
control|(
name|ln
operator|=
name|Lst_First
argument_list|(
name|gn
operator|->
name|cohorts
argument_list|)
init|;
name|ln
operator|!=
name|NILLNODE
condition|;
name|ln
operator|=
name|Lst_Succ
argument_list|(
name|ln
argument_list|)
control|)
block|{
name|cohort
operator|=
operator|(
name|GNode
operator|*
operator|)
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
expr_stmt|;
if|if
condition|(
name|tOp
condition|)
block|{
name|cohort
operator|->
name|type
operator||=
name|tOp
expr_stmt|;
block|}
else|else
block|{
name|Lst_ForEach
argument_list|(
name|targets
argument_list|,
name|ParseLinkSrc
argument_list|,
operator|(
name|ClientData
operator|)
name|cohort
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
block|}
name|gn
operator|->
name|order
operator|=
name|waiting
expr_stmt|;
operator|(
name|void
operator|)
name|Lst_AtEnd
argument_list|(
name|allsrc
argument_list|,
operator|(
name|ClientData
operator|)
name|gn
argument_list|)
expr_stmt|;
if|if
condition|(
name|waiting
condition|)
block|{
name|Lst_ForEach
argument_list|(
name|allsrc
argument_list|,
name|ParseAddDep
argument_list|,
operator|(
name|ClientData
operator|)
name|gn
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * ParseFindMain --  *	Find a real target in the list and set it to be the main one.  *	Called by ParseDoDependency when a main target hasn't been found  *	yet.  *  * Results:  *	0 if main not found yet, 1 if it is.  *  * Side Effects:  *	mainNode is changed and Targ_SetMain is called.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|ParseFindMain
parameter_list|(
name|gnp
parameter_list|,
name|dummy
parameter_list|)
name|ClientData
name|gnp
decl_stmt|;
comment|/* Node to examine */
name|ClientData
name|dummy
decl_stmt|;
block|{
name|GNode
modifier|*
name|gn
init|=
operator|(
name|GNode
operator|*
operator|)
name|gnp
decl_stmt|;
if|if
condition|(
operator|(
name|gn
operator|->
name|type
operator|&
operator|(
name|OP_NOTMAIN
operator||
name|OP_USE
operator||
name|OP_EXEC
operator||
name|OP_TRANSFORM
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|mainNode
operator|=
name|gn
expr_stmt|;
name|Targ_SetMain
argument_list|(
name|gn
argument_list|)
expr_stmt|;
return|return
operator|(
name|dummy
condition|?
literal|1
else|:
literal|1
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|dummy
condition|?
literal|0
else|:
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * ParseAddDir --  *	Front-end for Dir_AddDir to make sure Lst_ForEach keeps going  *  * Results:  *	=== 0  *  * Side Effects:  *	See Dir_AddDir.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|ParseAddDir
parameter_list|(
name|path
parameter_list|,
name|name
parameter_list|)
name|ClientData
name|path
decl_stmt|;
name|ClientData
name|name
decl_stmt|;
block|{
name|Dir_AddDir
argument_list|(
operator|(
name|Lst
operator|)
name|path
argument_list|,
operator|(
name|char
operator|*
operator|)
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * ParseClearPath --  *	Front-end for Dir_ClearPath to make sure Lst_ForEach keeps going  *  * Results:  *	=== 0  *  * Side Effects:  *	See Dir_ClearPath  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|ParseClearPath
parameter_list|(
name|path
parameter_list|,
name|dummy
parameter_list|)
name|ClientData
name|path
decl_stmt|;
name|ClientData
name|dummy
decl_stmt|;
block|{
name|Dir_ClearPath
argument_list|(
operator|(
name|Lst
operator|)
name|path
argument_list|)
expr_stmt|;
return|return
operator|(
name|dummy
condition|?
literal|0
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *---------------------------------------------------------------------  * ParseDoDependency  --  *	Parse the dependency line in line.  *  * Results:  *	None  *  * Side Effects:  *	The nodes of the sources are linked as children to the nodes of the  *	targets. Some nodes may be created.  *  *	We parse a dependency line by first extracting words from the line and  * finding nodes in the list of all targets with that name. This is done  * until a character is encountered which is an operator character. Currently  * these are only ! and :. At this point the operator is parsed and the  * pointer into the line advanced until the first source is encountered.  * 	The parsed operator is applied to each node in the 'targets' list,  * which is where the nodes found for the targets are kept, by means of  * the ParseDoOp function.  *	The sources are read in much the same way as the targets were except  * that now they are expanded using the wildcarding scheme of the C-Shell  * and all instances of the resulting words in the list of all targets  * are found. Each of the resulting nodes is then linked to each of the  * targets as one of its children.  *	Certain targets are handled specially. These are the ones detailed  * by the specType variable.  *	The storing of transformation rules is also taken care of here.  * A target is recognized as a transformation rule by calling  * Suff_IsTransform. If it is a transformation rule, its node is gotten  * from the suffix module via Suff_AddTransform rather than the standard  * Targ_FindNode in the target module.  *---------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|ParseDoDependency
parameter_list|(
name|line
parameter_list|)
name|char
modifier|*
name|line
decl_stmt|;
comment|/* the line to parse */
block|{
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* our current position */
name|GNode
modifier|*
name|gn
decl_stmt|;
comment|/* a general purpose temporary node */
name|int
name|op
decl_stmt|;
comment|/* the operator on the line */
name|char
name|savec
decl_stmt|;
comment|/* a place to save a character */
name|Lst
name|paths
decl_stmt|;
comment|/* List of search paths to alter when parsing 				 * a list of .PATH targets */
name|int
name|tOp
decl_stmt|;
comment|/* operator from special target */
name|Lst
name|sources
decl_stmt|;
comment|/* list of archive source names after 				 * expansion */
name|Lst
name|curTargs
decl_stmt|;
comment|/* list of target names to be found and added 				 * to the targets list */
name|Lst
name|curSrcs
decl_stmt|;
comment|/* list of sources in order */
name|tOp
operator|=
literal|0
expr_stmt|;
name|specType
operator|=
name|Not
expr_stmt|;
name|waiting
operator|=
literal|0
expr_stmt|;
name|paths
operator|=
operator|(
name|Lst
operator|)
name|NULL
expr_stmt|;
name|curTargs
operator|=
name|Lst_Init
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|curSrcs
operator|=
name|Lst_Init
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
do|do
block|{
for|for
control|(
name|cp
operator|=
name|line
init|;
operator|*
name|cp
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
operator|&&
operator|(
operator|*
name|cp
operator|!=
literal|'!'
operator|)
operator|&&
operator|(
operator|*
name|cp
operator|!=
literal|':'
operator|)
operator|&&
operator|(
operator|*
name|cp
operator|!=
literal|'('
operator|)
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'$'
condition|)
block|{
comment|/* 		 * Must be a dynamic source (would have been expanded 		 * otherwise), so call the Var module to parse the puppy 		 * so we can safely advance beyond it...There should be 		 * no errors in this, as they would have been discovered 		 * in the initial Var_Subst and we wouldn't be here. 		 */
name|int
name|length
decl_stmt|;
name|Boolean
name|freeIt
decl_stmt|;
name|char
modifier|*
name|result
decl_stmt|;
name|result
operator|=
name|Var_Parse
argument_list|(
name|cp
argument_list|,
name|VAR_CMD
argument_list|,
name|TRUE
argument_list|,
operator|&
name|length
argument_list|,
operator|&
name|freeIt
argument_list|)
expr_stmt|;
if|if
condition|(
name|freeIt
condition|)
block|{
name|free
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
name|cp
operator|+=
name|length
operator|-
literal|1
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
operator|*
name|cp
operator|==
literal|'('
condition|)
block|{
comment|/* 	     * Archives must be handled specially to make sure the OP_ARCHV 	     * flag is set in their 'type' field, for one thing, and because 	     * things like "archive(file1.o file2.o file3.o)" are permissible. 	     * Arch_ParseArchive will set 'line' to be the first non-blank 	     * after the archive-spec. It creates/finds nodes for the members 	     * and places them on the given list, returning SUCCESS if all 	     * went well and FAILURE if there was an error in the 	     * specification. On error, line should remain untouched. 	     */
if|if
condition|(
name|Arch_ParseArchive
argument_list|(
operator|&
name|line
argument_list|,
name|targets
argument_list|,
name|VAR_CMD
argument_list|)
operator|!=
name|SUCCESS
condition|)
block|{
name|Parse_Error
argument_list|(
name|PARSE_FATAL
argument_list|,
literal|"Error in archive specification: \"%s\""
argument_list|,
name|line
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
continue|continue;
block|}
block|}
name|savec
operator|=
operator|*
name|cp
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|cp
condition|)
block|{
comment|/* 	     * Ending a dependency line without an operator is a Bozo 	     * no-no 	     */
name|Parse_Error
argument_list|(
name|PARSE_FATAL
argument_list|,
literal|"Need an operator"
argument_list|)
expr_stmt|;
return|return;
block|}
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
comment|/* 	 * Have a word in line. See if it's a special target and set 	 * specType to match it. 	 */
if|if
condition|(
operator|*
name|line
operator|==
literal|'.'
operator|&&
name|isupper
argument_list|(
name|line
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
comment|/* 	     * See if the target is a special target that must have it 	     * or its sources handled specially. 	     */
name|int
name|keywd
init|=
name|ParseFindKeyword
argument_list|(
name|line
argument_list|)
decl_stmt|;
if|if
condition|(
name|keywd
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|specType
operator|==
name|ExPath
operator|&&
name|parseKeywords
index|[
name|keywd
index|]
operator|.
name|spec
operator|!=
name|ExPath
condition|)
block|{
name|Parse_Error
argument_list|(
name|PARSE_FATAL
argument_list|,
literal|"Mismatched special targets"
argument_list|)
expr_stmt|;
return|return;
block|}
name|specType
operator|=
name|parseKeywords
index|[
name|keywd
index|]
operator|.
name|spec
expr_stmt|;
name|tOp
operator|=
name|parseKeywords
index|[
name|keywd
index|]
operator|.
name|op
expr_stmt|;
comment|/* 		 * Certain special targets have special semantics: 		 *	.PATH		Have to set the dirSearchPath 		 *			variable too 		 *	.MAIN		Its sources are only used if 		 *			nothing has been specified to 		 *			create. 		 *	.DEFAULT    	Need to create a node to hang 		 *			commands on, but we don't want 		 *			it in the graph, nor do we want 		 *			it to be the Main Target, so we 		 *			create it, set OP_NOTMAIN and 		 *			add it to the list, setting 		 *			DEFAULT to the new node for 		 *			later use. We claim the node is 		 *	    	    	A transformation rule to make 		 *	    	    	life easier later, when we'll 		 *	    	    	use Make_HandleUse to actually 		 *	    	    	apply the .DEFAULT commands. 		 *	.PHONY		The list of targets 		 *	.BEGIN 		 *	.END 		 *	.INTERRUPT  	Are not to be considered the 		 *			main target. 		 *  	.NOTPARALLEL	Make only one target at a time. 		 *  	.SINGLESHELL	Create a shell for each command. 		 *  	.ORDER	    	Must set initial predecessor to NIL 		 */
switch|switch
condition|(
name|specType
condition|)
block|{
case|case
name|ExPath
case|:
if|if
condition|(
name|paths
operator|==
name|NULL
condition|)
block|{
name|paths
operator|=
name|Lst_Init
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|Lst_AtEnd
argument_list|(
name|paths
argument_list|,
operator|(
name|ClientData
operator|)
name|dirSearchPath
argument_list|)
expr_stmt|;
break|break;
case|case
name|Main
case|:
if|if
condition|(
operator|!
name|Lst_IsEmpty
argument_list|(
name|create
argument_list|)
condition|)
block|{
name|specType
operator|=
name|Not
expr_stmt|;
block|}
break|break;
case|case
name|Begin
case|:
case|case
name|End
case|:
case|case
name|Interrupt
case|:
name|gn
operator|=
name|Targ_FindNode
argument_list|(
name|line
argument_list|,
name|TARG_CREATE
argument_list|)
expr_stmt|;
name|gn
operator|->
name|type
operator||=
name|OP_NOTMAIN
expr_stmt|;
operator|(
name|void
operator|)
name|Lst_AtEnd
argument_list|(
name|targets
argument_list|,
operator|(
name|ClientData
operator|)
name|gn
argument_list|)
expr_stmt|;
break|break;
case|case
name|Default
case|:
name|gn
operator|=
name|Targ_NewGN
argument_list|(
literal|".DEFAULT"
argument_list|)
expr_stmt|;
name|gn
operator|->
name|type
operator||=
operator|(
name|OP_NOTMAIN
operator||
name|OP_TRANSFORM
operator|)
expr_stmt|;
operator|(
name|void
operator|)
name|Lst_AtEnd
argument_list|(
name|targets
argument_list|,
operator|(
name|ClientData
operator|)
name|gn
argument_list|)
expr_stmt|;
name|DEFAULT
operator|=
name|gn
expr_stmt|;
break|break;
case|case
name|NotParallel
case|:
block|{
specifier|extern
name|int
name|maxJobs
decl_stmt|;
name|maxJobs
operator|=
literal|1
expr_stmt|;
break|break;
block|}
case|case
name|SingleShell
case|:
name|compatMake
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|Order
case|:
name|predecessor
operator|=
name|NILGNODE
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|line
argument_list|,
literal|".PATH"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * .PATH<suffix> has to be handled specially. 		 * Call on the suffix module to give us a path to 		 * modify. 		 */
name|Lst
name|path
decl_stmt|;
name|specType
operator|=
name|ExPath
expr_stmt|;
name|path
operator|=
name|Suff_GetPath
argument_list|(
operator|&
name|line
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
operator|==
name|NILLST
condition|)
block|{
name|Parse_Error
argument_list|(
name|PARSE_FATAL
argument_list|,
literal|"Suffix '%s' not defined (yet)"
argument_list|,
operator|&
name|line
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
if|if
condition|(
name|paths
operator|==
operator|(
name|Lst
operator|)
name|NULL
condition|)
block|{
name|paths
operator|=
name|Lst_Init
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|Lst_AtEnd
argument_list|(
name|paths
argument_list|,
operator|(
name|ClientData
operator|)
name|path
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * Have word in line. Get or create its node and stick it at 	 * the end of the targets list 	 */
if|if
condition|(
operator|(
name|specType
operator|==
name|Not
operator|)
operator|&&
operator|(
operator|*
name|line
operator|!=
literal|'\0'
operator|)
condition|)
block|{
if|if
condition|(
name|Dir_HasWildcards
argument_list|(
name|line
argument_list|)
condition|)
block|{
comment|/* 		 * Targets are to be sought only in the current directory, 		 * so create an empty path for the thing. Note we need to 		 * use Dir_Destroy in the destruction of the path as the 		 * Dir module could have added a directory to the path... 		 */
name|Lst
name|emptyPath
init|=
name|Lst_Init
argument_list|(
name|FALSE
argument_list|)
decl_stmt|;
name|Dir_Expand
argument_list|(
name|line
argument_list|,
name|emptyPath
argument_list|,
name|curTargs
argument_list|)
expr_stmt|;
name|Lst_Destroy
argument_list|(
name|emptyPath
argument_list|,
name|Dir_Destroy
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * No wildcards, but we want to avoid code duplication, 		 * so create a list with the word on it. 		 */
operator|(
name|void
operator|)
name|Lst_AtEnd
argument_list|(
name|curTargs
argument_list|,
operator|(
name|ClientData
operator|)
name|line
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|!
name|Lst_IsEmpty
argument_list|(
name|curTargs
argument_list|)
condition|)
block|{
name|char
modifier|*
name|targName
init|=
operator|(
name|char
operator|*
operator|)
name|Lst_DeQueue
argument_list|(
name|curTargs
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|Suff_IsTransform
argument_list|(
name|targName
argument_list|)
condition|)
block|{
name|gn
operator|=
name|Targ_FindNode
argument_list|(
name|targName
argument_list|,
name|TARG_CREATE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gn
operator|=
name|Suff_AddTransform
argument_list|(
name|targName
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|Lst_AtEnd
argument_list|(
name|targets
argument_list|,
operator|(
name|ClientData
operator|)
name|gn
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|specType
operator|==
name|ExPath
operator|&&
operator|*
name|line
operator|!=
literal|'.'
operator|&&
operator|*
name|line
operator|!=
literal|'\0'
condition|)
block|{
name|Parse_Error
argument_list|(
name|PARSE_WARNING
argument_list|,
literal|"Extra target (%s) ignored"
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
operator|*
name|cp
operator|=
name|savec
expr_stmt|;
comment|/* 	 * If it is a special type and not .PATH, it's the only target we 	 * allow on this line... 	 */
if|if
condition|(
name|specType
operator|!=
name|Not
operator|&&
name|specType
operator|!=
name|ExPath
condition|)
block|{
name|Boolean
name|warn
init|=
name|FALSE
decl_stmt|;
while|while
condition|(
operator|(
operator|*
name|cp
operator|!=
literal|'!'
operator|)
operator|&&
operator|(
operator|*
name|cp
operator|!=
literal|':'
operator|)
operator|&&
operator|*
name|cp
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|!=
literal|' '
operator|&&
operator|*
name|cp
operator|!=
literal|'\t'
condition|)
block|{
name|warn
operator|=
name|TRUE
expr_stmt|;
block|}
name|cp
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|warn
condition|)
block|{
name|Parse_Error
argument_list|(
name|PARSE_WARNING
argument_list|,
literal|"Extra target ignored"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
while|while
condition|(
operator|*
name|cp
operator|&&
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
block|{
name|cp
operator|++
expr_stmt|;
block|}
block|}
name|line
operator|=
name|cp
expr_stmt|;
block|}
do|while
condition|(
operator|(
operator|*
name|line
operator|!=
literal|'!'
operator|)
operator|&&
operator|(
operator|*
name|line
operator|!=
literal|':'
operator|)
operator|&&
operator|*
name|line
condition|)
do|;
comment|/*      * Don't need the list of target names anymore...      */
name|Lst_Destroy
argument_list|(
name|curTargs
argument_list|,
name|NOFREE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Lst_IsEmpty
argument_list|(
name|targets
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|specType
condition|)
block|{
default|default:
name|Parse_Error
argument_list|(
name|PARSE_WARNING
argument_list|,
literal|"Special and mundane targets don't mix. Mundane ones ignored"
argument_list|)
expr_stmt|;
break|break;
case|case
name|Default
case|:
case|case
name|Begin
case|:
case|case
name|End
case|:
case|case
name|Interrupt
case|:
comment|/* 		 * These four create nodes on which to hang commands, so 		 * targets shouldn't be empty... 		 */
case|case
name|Not
case|:
comment|/* 		 * Nothing special here -- targets can be empty if it wants. 		 */
break|break;
block|}
block|}
comment|/*      * Have now parsed all the target names. Must parse the operator next. The      * result is left in  op .      */
if|if
condition|(
operator|*
name|cp
operator|==
literal|'!'
condition|)
block|{
name|op
operator|=
name|OP_FORCE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|cp
operator|==
literal|':'
condition|)
block|{
if|if
condition|(
name|cp
index|[
literal|1
index|]
operator|==
literal|':'
condition|)
block|{
name|op
operator|=
name|OP_DOUBLEDEP
expr_stmt|;
name|cp
operator|++
expr_stmt|;
block|}
else|else
block|{
name|op
operator|=
name|OP_DEPENDS
expr_stmt|;
block|}
block|}
else|else
block|{
name|Parse_Error
argument_list|(
name|PARSE_FATAL
argument_list|,
literal|"Missing dependency operator"
argument_list|)
expr_stmt|;
return|return;
block|}
name|cp
operator|++
expr_stmt|;
comment|/* Advance beyond operator */
name|Lst_ForEach
argument_list|(
name|targets
argument_list|,
name|ParseDoOp
argument_list|,
operator|(
name|ClientData
operator|)
operator|&
name|op
argument_list|)
expr_stmt|;
comment|/*      * Get to the first source      */
while|while
condition|(
operator|*
name|cp
operator|&&
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
block|{
name|cp
operator|++
expr_stmt|;
block|}
name|line
operator|=
name|cp
expr_stmt|;
comment|/*      * Several special targets take different actions if present with no      * sources:      *	a .SUFFIXES line with no sources clears out all old suffixes      *	a .PRECIOUS line makes all targets precious      *	a .IGNORE line ignores errors for all targets      *	a .SILENT line creates silence when making all targets      *	a .PATH removes all directories from the search path(s).      */
if|if
condition|(
operator|!
operator|*
name|line
condition|)
block|{
switch|switch
condition|(
name|specType
condition|)
block|{
case|case
name|Suffixes
case|:
name|Suff_ClearSuffixes
argument_list|()
expr_stmt|;
break|break;
case|case
name|Precious
case|:
name|allPrecious
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|Ignore
case|:
name|ignoreErrors
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|Silent
case|:
name|beSilent
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|ExPath
case|:
name|Lst_ForEach
argument_list|(
name|paths
argument_list|,
name|ParseClearPath
argument_list|,
operator|(
name|ClientData
operator|)
name|NULL
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|specType
operator|==
name|MFlags
condition|)
block|{
comment|/* 	 * Call on functions in main.c to deal with these arguments and 	 * set the initial character to a null-character so the loop to 	 * get sources won't get anything 	 */
name|Main_ParseArgLine
argument_list|(
name|line
argument_list|)
expr_stmt|;
operator|*
name|line
operator|=
literal|'\0'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|specType
operator|==
name|ExShell
condition|)
block|{
if|if
condition|(
name|Job_ParseShell
argument_list|(
name|line
argument_list|)
operator|!=
name|SUCCESS
condition|)
block|{
name|Parse_Error
argument_list|(
name|PARSE_FATAL
argument_list|,
literal|"improper shell specification"
argument_list|)
expr_stmt|;
return|return;
block|}
operator|*
name|line
operator|=
literal|'\0'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|specType
operator|==
name|NotParallel
operator|)
operator|||
operator|(
name|specType
operator|==
name|SingleShell
operator|)
condition|)
block|{
operator|*
name|line
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/*      * NOW GO FOR THE SOURCES      */
if|if
condition|(
operator|(
name|specType
operator|==
name|Suffixes
operator|)
operator|||
operator|(
name|specType
operator|==
name|ExPath
operator|)
operator|||
operator|(
name|specType
operator|==
name|Includes
operator|)
operator|||
operator|(
name|specType
operator|==
name|Libs
operator|)
operator|||
operator|(
name|specType
operator|==
name|Null
operator|)
condition|)
block|{
while|while
condition|(
operator|*
name|line
condition|)
block|{
comment|/* 	     * If the target was one that doesn't take files as its sources 	     * but takes something like suffixes, we take each 	     * space-separated word on the line as a something and deal 	     * with it accordingly. 	     * 	     * If the target was .SUFFIXES, we take each source as a 	     * suffix and add it to the list of suffixes maintained by the 	     * Suff module. 	     * 	     * If the target was a .PATH, we add the source as a directory 	     * to search on the search path. 	     * 	     * If it was .INCLUDES, the source is taken to be the suffix of 	     * files which will be #included and whose search path should 	     * be present in the .INCLUDES variable. 	     * 	     * If it was .LIBS, the source is taken to be the suffix of 	     * files which are considered libraries and whose search path 	     * should be present in the .LIBS variable. 	     * 	     * If it was .NULL, the source is the suffix to use when a file 	     * has no valid suffix. 	     */
name|char
name|savec
decl_stmt|;
while|while
condition|(
operator|*
name|cp
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
block|{
name|cp
operator|++
expr_stmt|;
block|}
name|savec
operator|=
operator|*
name|cp
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
switch|switch
condition|(
name|specType
condition|)
block|{
case|case
name|Suffixes
case|:
name|Suff_AddSuffix
argument_list|(
name|line
argument_list|)
expr_stmt|;
break|break;
case|case
name|ExPath
case|:
name|Lst_ForEach
argument_list|(
name|paths
argument_list|,
name|ParseAddDir
argument_list|,
operator|(
name|ClientData
operator|)
name|line
argument_list|)
expr_stmt|;
break|break;
case|case
name|Includes
case|:
name|Suff_AddInclude
argument_list|(
name|line
argument_list|)
expr_stmt|;
break|break;
case|case
name|Libs
case|:
name|Suff_AddLib
argument_list|(
name|line
argument_list|)
expr_stmt|;
break|break;
case|case
name|Null
case|:
name|Suff_SetNull
argument_list|(
name|line
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
operator|*
name|cp
operator|=
name|savec
expr_stmt|;
if|if
condition|(
name|savec
operator|!=
literal|'\0'
condition|)
block|{
name|cp
operator|++
expr_stmt|;
block|}
while|while
condition|(
operator|*
name|cp
operator|&&
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
block|{
name|cp
operator|++
expr_stmt|;
block|}
name|line
operator|=
name|cp
expr_stmt|;
block|}
if|if
condition|(
name|paths
condition|)
block|{
name|Lst_Destroy
argument_list|(
name|paths
argument_list|,
name|NOFREE
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
while|while
condition|(
operator|*
name|line
condition|)
block|{
comment|/* 	     * The targets take real sources, so we must beware of archive 	     * specifications (i.e. things with left parentheses in them) 	     * and handle them accordingly. 	     */
while|while
condition|(
operator|*
name|cp
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|cp
operator|==
literal|'('
operator|)
operator|&&
operator|(
name|cp
operator|>
name|line
operator|)
operator|&&
operator|(
name|cp
index|[
operator|-
literal|1
index|]
operator|!=
literal|'$'
operator|)
condition|)
block|{
comment|/* 		     * Only stop for a left parenthesis if it isn't at the 		     * start of a word (that'll be for variable changes 		     * later) and isn't preceded by a dollar sign (a dynamic 		     * source). 		     */
break|break;
block|}
else|else
block|{
name|cp
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|*
name|cp
operator|==
literal|'('
condition|)
block|{
name|GNode
modifier|*
name|gn
decl_stmt|;
name|sources
operator|=
name|Lst_Init
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|Arch_ParseArchive
argument_list|(
operator|&
name|line
argument_list|,
name|sources
argument_list|,
name|VAR_CMD
argument_list|)
operator|!=
name|SUCCESS
condition|)
block|{
name|Parse_Error
argument_list|(
name|PARSE_FATAL
argument_list|,
literal|"Error in source archive spec \"%s\""
argument_list|,
name|line
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
operator|!
name|Lst_IsEmpty
argument_list|(
name|sources
argument_list|)
condition|)
block|{
name|gn
operator|=
operator|(
name|GNode
operator|*
operator|)
name|Lst_DeQueue
argument_list|(
name|sources
argument_list|)
expr_stmt|;
name|ParseDoSrc
argument_list|(
name|tOp
argument_list|,
name|gn
operator|->
name|name
argument_list|,
name|curSrcs
argument_list|)
expr_stmt|;
block|}
name|Lst_Destroy
argument_list|(
name|sources
argument_list|,
name|NOFREE
argument_list|)
expr_stmt|;
name|cp
operator|=
name|line
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|cp
condition|)
block|{
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|cp
operator|+=
literal|1
expr_stmt|;
block|}
name|ParseDoSrc
argument_list|(
name|tOp
argument_list|,
name|line
argument_list|,
name|curSrcs
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|*
name|cp
operator|&&
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
block|{
name|cp
operator|++
expr_stmt|;
block|}
name|line
operator|=
name|cp
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mainNode
operator|==
name|NILGNODE
condition|)
block|{
comment|/* 	 * If we have yet to decide on a main target to make, in the 	 * absence of any user input, we want the first target on 	 * the first dependency line that is actually a real target 	 * (i.e. isn't a .USE or .EXEC rule) to be made. 	 */
name|Lst_ForEach
argument_list|(
name|targets
argument_list|,
name|ParseFindMain
argument_list|,
operator|(
name|ClientData
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/*      * Finally, destroy the list of sources      */
name|Lst_Destroy
argument_list|(
name|curSrcs
argument_list|,
name|NOFREE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-  *---------------------------------------------------------------------  * Parse_IsVar  --  *	Return TRUE if the passed line is a variable assignment. A variable  *	assignment consists of a single word followed by optional whitespace  *	followed by either a += or an = operator.  *	This function is used both by the Parse_File function and main when  *	parsing the command-line arguments.  *  * Results:  *	TRUE if it is. FALSE if it ain't  *  * Side Effects:  *	none  *---------------------------------------------------------------------  */
end_comment

begin_function
name|Boolean
name|Parse_IsVar
parameter_list|(
name|line
parameter_list|)
specifier|register
name|char
modifier|*
name|line
decl_stmt|;
comment|/* the line to check */
block|{
specifier|register
name|Boolean
name|wasSpace
init|=
name|FALSE
decl_stmt|;
comment|/* set TRUE if found a space */
specifier|register
name|Boolean
name|haveName
init|=
name|FALSE
decl_stmt|;
comment|/* Set TRUE if have a variable name */
name|int
name|level
init|=
literal|0
decl_stmt|;
define|#
directive|define
name|ISEQOPERATOR
parameter_list|(
name|c
parameter_list|)
define|\
value|(((c) == '+') || ((c) == ':') || ((c) == '?') || ((c) == '!'))
comment|/*      * Skip to variable name      */
for|for
control|(
init|;
operator|(
operator|*
name|line
operator|==
literal|' '
operator|)
operator|||
operator|(
operator|*
name|line
operator|==
literal|'\t'
operator|)
condition|;
name|line
operator|++
control|)
continue|continue;
for|for
control|(
init|;
operator|*
name|line
operator|!=
literal|'='
operator|||
name|level
operator|!=
literal|0
condition|;
name|line
operator|++
control|)
switch|switch
condition|(
operator|*
name|line
condition|)
block|{
case|case
literal|'\0'
case|:
comment|/* 	     * end-of-line -- can't be a variable assignment. 	     */
return|return
name|FALSE
return|;
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
comment|/* 	     * there can be as much white space as desired so long as there is 	     * only one word before the operator 	     */
name|wasSpace
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'('
case|:
case|case
literal|'{'
case|:
name|level
operator|++
expr_stmt|;
break|break;
case|case
literal|'}'
case|:
case|case
literal|')'
case|:
name|level
operator|--
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|wasSpace
operator|&&
name|haveName
condition|)
block|{
if|if
condition|(
name|ISEQOPERATOR
argument_list|(
operator|*
name|line
argument_list|)
condition|)
block|{
comment|/* 			 * We must have a finished word 			 */
if|if
condition|(
name|level
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
comment|/* 			 * When an = operator [+?!:] is found, the next 			 * character must be an = or it ain't a valid 			 * assignment. 			 */
if|if
condition|(
name|line
index|[
literal|1
index|]
operator|==
literal|'='
condition|)
return|return
name|haveName
return|;
ifdef|#
directive|ifdef
name|SUNSHCMD
comment|/* 			 * This is a shell command 			 */
if|if
condition|(
name|strncmp
argument_list|(
name|line
argument_list|,
literal|":sh"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
return|return
name|haveName
return|;
endif|#
directive|endif
block|}
comment|/* 		     * This is the start of another word, so not assignment. 		     */
return|return
name|FALSE
return|;
block|}
else|else
block|{
name|haveName
operator|=
name|TRUE
expr_stmt|;
name|wasSpace
operator|=
name|FALSE
expr_stmt|;
block|}
break|break;
block|}
return|return
name|haveName
return|;
block|}
end_function

begin_comment
comment|/*-  *---------------------------------------------------------------------  * Parse_DoVar  --  *	Take the variable assignment in the passed line and do it in the  *	global context.  *  *	Note: There is a lexical ambiguity with assignment modifier characters  *	in variable names. This routine interprets the character before the =  *	as a modifier. Therefore, an assignment like  *	    C++=/usr/bin/CC  *	is interpreted as "C+ +=" instead of "C++ =".  *  * Results:  *	none  *  * Side Effects:  *	the variable structure of the given variable name is altered in the  *	global context.  *---------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Parse_DoVar
parameter_list|(
name|line
parameter_list|,
name|ctxt
parameter_list|)
name|char
modifier|*
name|line
decl_stmt|;
comment|/* a line guaranteed to be a variable 				 * assignment. This reduces error checks */
name|GNode
modifier|*
name|ctxt
decl_stmt|;
comment|/* Context in which to do the assignment */
block|{
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* pointer into line */
enum|enum
block|{
name|VAR_SUBST
block|,
name|VAR_APPEND
block|,
name|VAR_SHELL
block|,
name|VAR_NORMAL
block|}
name|type
enum|;
comment|/* Type of assignment */
name|char
modifier|*
name|opc
decl_stmt|;
comment|/* ptr to operator character to 				 * null-terminate the variable name */
comment|/*      * Avoid clobbered variable warnings by forcing the compiler      * to ``unregister'' variables      */
if|#
directive|if
name|__GNUC__
operator|(
name|void
operator|)
operator|&
name|cp
expr_stmt|;
operator|(
name|void
operator|)
operator|&
name|line
expr_stmt|;
endif|#
directive|endif
comment|/*      * Skip to variable name      */
while|while
condition|(
operator|(
operator|*
name|line
operator|==
literal|' '
operator|)
operator|||
operator|(
operator|*
name|line
operator|==
literal|'\t'
operator|)
condition|)
block|{
name|line
operator|++
expr_stmt|;
block|}
comment|/*      * Skip to operator character, nulling out whitespace as we go      */
for|for
control|(
name|cp
operator|=
name|line
operator|+
literal|1
init|;
operator|*
name|cp
operator|!=
literal|'='
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
block|{
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
name|opc
operator|=
name|cp
operator|-
literal|1
expr_stmt|;
comment|/* operator is the previous character */
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* nuke the = */
comment|/*      * Check operator type      */
switch|switch
condition|(
operator|*
name|opc
condition|)
block|{
case|case
literal|'+'
case|:
name|type
operator|=
name|VAR_APPEND
expr_stmt|;
operator|*
name|opc
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
comment|/* 	     * If the variable already has a value, we don't do anything. 	     */
operator|*
name|opc
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|Var_Exists
argument_list|(
name|line
argument_list|,
name|ctxt
argument_list|)
condition|)
block|{
return|return;
block|}
else|else
block|{
name|type
operator|=
name|VAR_NORMAL
expr_stmt|;
block|}
break|break;
case|case
literal|':'
case|:
name|type
operator|=
name|VAR_SUBST
expr_stmt|;
operator|*
name|opc
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
literal|'!'
case|:
name|type
operator|=
name|VAR_SHELL
expr_stmt|;
operator|*
name|opc
operator|=
literal|'\0'
expr_stmt|;
break|break;
default|default:
ifdef|#
directive|ifdef
name|SUNSHCMD
while|while
condition|(
operator|*
name|opc
operator|!=
literal|':'
condition|)
if|if
condition|(
operator|--
name|opc
operator|<
name|line
condition|)
break|break;
if|if
condition|(
name|strncmp
argument_list|(
name|opc
argument_list|,
literal|":sh"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|type
operator|=
name|VAR_SHELL
expr_stmt|;
operator|*
name|opc
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
name|type
operator|=
name|VAR_NORMAL
expr_stmt|;
break|break;
block|}
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
block|{
name|cp
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|==
name|VAR_APPEND
condition|)
block|{
name|Var_Append
argument_list|(
name|line
argument_list|,
name|cp
argument_list|,
name|ctxt
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|VAR_SUBST
condition|)
block|{
comment|/* 	 * Allow variables in the old value to be undefined, but leave their 	 * invocation alone -- this is done by forcing oldVars to be false. 	 * XXX: This can cause recursive variables, but that's not hard to do, 	 * and this allows someone to do something like 	 * 	 *  CFLAGS = $(.INCLUDES) 	 *  CFLAGS := -I.. $(CFLAGS) 	 * 	 * And not get an error. 	 */
name|Boolean
name|oldOldVars
init|=
name|oldVars
decl_stmt|;
name|oldVars
operator|=
name|FALSE
expr_stmt|;
name|cp
operator|=
name|Var_Subst
argument_list|(
name|NULL
argument_list|,
name|cp
argument_list|,
name|ctxt
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|oldVars
operator|=
name|oldOldVars
expr_stmt|;
name|Var_Set
argument_list|(
name|line
argument_list|,
name|cp
argument_list|,
name|ctxt
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|VAR_SHELL
condition|)
block|{
name|Boolean
name|freeCmd
init|=
name|FALSE
decl_stmt|;
comment|/* TRUE if the command needs to be freed, i.e. 				  * if any variable expansion was performed */
name|char
modifier|*
name|res
decl_stmt|,
modifier|*
name|err
decl_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|cp
argument_list|,
literal|'$'
argument_list|)
operator|!=
name|NULL
condition|)
block|{
comment|/* 	     * There's a dollar sign in the command, so perform variable 	     * expansion on the whole thing. The resulting string will need 	     * freeing when we're done, so set freeCmd to TRUE. 	     */
name|cp
operator|=
name|Var_Subst
argument_list|(
name|NULL
argument_list|,
name|cp
argument_list|,
name|VAR_CMD
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|freeCmd
operator|=
name|TRUE
expr_stmt|;
block|}
name|res
operator|=
name|Cmd_Exec
argument_list|(
name|cp
argument_list|,
operator|&
name|err
argument_list|)
expr_stmt|;
name|Var_Set
argument_list|(
name|line
argument_list|,
name|res
argument_list|,
name|ctxt
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|Parse_Error
argument_list|(
name|PARSE_WARNING
argument_list|,
name|err
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|freeCmd
condition|)
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 	 * Normal assignment -- just do it. 	 */
name|Var_Set
argument_list|(
name|line
argument_list|,
name|cp
argument_list|,
name|ctxt
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*-  * ParseAddCmd  --  *	Lst_ForEach function to add a command line to all targets  *  * Results:  *	Always 0  *  * Side Effects:  *	A new element is added to the commands list of the node.  */
end_comment

begin_function
specifier|static
name|int
name|ParseAddCmd
parameter_list|(
name|gnp
parameter_list|,
name|cmd
parameter_list|)
name|ClientData
name|gnp
decl_stmt|;
comment|/* the node to which the command is to be added */
name|ClientData
name|cmd
decl_stmt|;
comment|/* the command to add */
block|{
name|GNode
modifier|*
name|gn
init|=
operator|(
name|GNode
operator|*
operator|)
name|gnp
decl_stmt|;
comment|/* if target already supplied, ignore commands */
if|if
condition|(
operator|!
operator|(
name|gn
operator|->
name|type
operator|&
name|OP_HAS_COMMANDS
operator|)
condition|)
operator|(
name|void
operator|)
name|Lst_AtEnd
argument_list|(
name|gn
operator|->
name|commands
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * ParseHasCommands --  *	Callback procedure for Parse_File when destroying the list of  *	targets on the last dependency line. Marks a target as already  *	having commands if it does, to keep from having shell commands  *	on multiple dependency lines.  *  * Results:  *	None  *  * Side Effects:  *	OP_HAS_COMMANDS may be set for the target.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|ParseHasCommands
parameter_list|(
name|gnp
parameter_list|)
name|ClientData
name|gnp
decl_stmt|;
comment|/* Node to examine */
block|{
name|GNode
modifier|*
name|gn
init|=
operator|(
name|GNode
operator|*
operator|)
name|gnp
decl_stmt|;
if|if
condition|(
operator|!
name|Lst_IsEmpty
argument_list|(
name|gn
operator|->
name|commands
argument_list|)
condition|)
block|{
name|gn
operator|->
name|type
operator||=
name|OP_HAS_COMMANDS
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Parse_AddIncludeDir --  *	Add a directory to the path searched for included makefiles  *	bracketed by double-quotes. Used by functions in main.c  *  * Results:  *	None.  *  * Side Effects:  *	The directory is appended to the list.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Parse_AddIncludeDir
parameter_list|(
name|dir
parameter_list|)
name|char
modifier|*
name|dir
decl_stmt|;
comment|/* The name of the directory to add */
block|{
name|Dir_AddDir
argument_list|(
name|parseIncPath
argument_list|,
name|dir
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-  *---------------------------------------------------------------------  * ParseDoInclude  --  *	Push to another file.  *  *	The input is the line minus the #include. A file spec is a string  *	enclosed in<> or "". The former is looked for only in sysIncPath.  *	The latter in . and the directories specified by -I command line  *	options  *  * Results:  *	None  *  * Side Effects:  *	A structure is added to the includes Lst and readProc, lineno,  *	fname and curFILE are altered for the new file  *---------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|ParseDoInclude
parameter_list|(
name|file
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
comment|/* file specification */
block|{
name|char
modifier|*
name|fullname
decl_stmt|;
comment|/* full pathname of file */
name|IFile
modifier|*
name|oldFile
decl_stmt|;
comment|/* state associated with current file */
name|char
name|endc
decl_stmt|;
comment|/* the character which ends the file spec */
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* current position in file spec */
name|Boolean
name|isSystem
decl_stmt|;
comment|/* TRUE if makefile is a system makefile */
comment|/*      * Skip to delimiter character so we know where to look      */
while|while
condition|(
operator|(
operator|*
name|file
operator|==
literal|' '
operator|)
operator|||
operator|(
operator|*
name|file
operator|==
literal|'\t'
operator|)
condition|)
block|{
name|file
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|*
name|file
operator|!=
literal|'"'
operator|)
operator|&&
operator|(
operator|*
name|file
operator|!=
literal|'<'
operator|)
condition|)
block|{
name|Parse_Error
argument_list|(
name|PARSE_FATAL
argument_list|,
literal|".include filename must be delimited by '\"' or '<'"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*      * Set the search path on which to find the include file based on the      * characters which bracket its name. Angle-brackets imply it's      * a system Makefile while double-quotes imply it's a user makefile      */
if|if
condition|(
operator|*
name|file
operator|==
literal|'<'
condition|)
block|{
name|isSystem
operator|=
name|TRUE
expr_stmt|;
name|endc
operator|=
literal|'>'
expr_stmt|;
block|}
else|else
block|{
name|isSystem
operator|=
name|FALSE
expr_stmt|;
name|endc
operator|=
literal|'"'
expr_stmt|;
block|}
comment|/*      * Skip to matching delimiter      */
for|for
control|(
name|cp
operator|=
operator|++
name|file
init|;
operator|*
name|cp
operator|&&
operator|*
name|cp
operator|!=
name|endc
condition|;
name|cp
operator|++
control|)
block|{
continue|continue;
block|}
if|if
condition|(
operator|*
name|cp
operator|!=
name|endc
condition|)
block|{
name|Parse_Error
argument_list|(
name|PARSE_FATAL
argument_list|,
literal|"Unclosed %cinclude filename. '%c' expected"
argument_list|,
literal|'.'
argument_list|,
name|endc
argument_list|)
expr_stmt|;
return|return;
block|}
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
comment|/*      * Substitute for any variables in the file name before trying to      * find the thing.      */
name|file
operator|=
name|Var_Subst
argument_list|(
name|NULL
argument_list|,
name|file
argument_list|,
name|VAR_CMD
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/*      * Now we know the file's name and its search path, we attempt to      * find the durn thing. A return of NULL indicates the file don't      * exist.      */
if|if
condition|(
operator|!
name|isSystem
condition|)
block|{
comment|/* 	 * Include files contained in double-quotes are first searched for 	 * relative to the including file's location. We don't want to 	 * cd there, of course, so we just tack on the old file's 	 * leading path components and call Dir_FindFile to see if 	 * we can locate the beast. 	 */
name|char
modifier|*
name|prefEnd
decl_stmt|,
modifier|*
name|Fname
decl_stmt|;
comment|/* Make a temporary copy of this, to be safe. */
name|Fname
operator|=
name|estrdup
argument_list|(
name|fname
argument_list|)
expr_stmt|;
name|prefEnd
operator|=
name|strrchr
argument_list|(
name|Fname
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|prefEnd
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
name|char
modifier|*
name|newName
decl_stmt|;
operator|*
name|prefEnd
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|file
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
name|newName
operator|=
name|estrdup
argument_list|(
name|file
argument_list|)
expr_stmt|;
else|else
name|newName
operator|=
name|str_concat
argument_list|(
name|Fname
argument_list|,
name|file
argument_list|,
name|STR_ADDSLASH
argument_list|)
expr_stmt|;
name|fullname
operator|=
name|Dir_FindFile
argument_list|(
name|newName
argument_list|,
name|parseIncPath
argument_list|)
expr_stmt|;
if|if
condition|(
name|fullname
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
name|fullname
operator|=
name|Dir_FindFile
argument_list|(
name|newName
argument_list|,
name|dirSearchPath
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|newName
argument_list|)
expr_stmt|;
operator|*
name|prefEnd
operator|=
literal|'/'
expr_stmt|;
block|}
else|else
block|{
name|fullname
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
name|free
argument_list|(
name|Fname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fullname
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|fullname
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
comment|/* 	 * System makefile or makefile wasn't found in same directory as 	 * included makefile. Search for it first on the -I search path, 	 * then on the .PATH search path, if not found in a -I directory. 	 * XXX: Suffix specific? 	 */
name|fullname
operator|=
name|Dir_FindFile
argument_list|(
name|file
argument_list|,
name|parseIncPath
argument_list|)
expr_stmt|;
if|if
condition|(
name|fullname
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
name|fullname
operator|=
name|Dir_FindFile
argument_list|(
name|file
argument_list|,
name|dirSearchPath
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fullname
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
comment|/* 	 * Still haven't found the makefile. Look for it on the system 	 * path as a last resort. 	 */
name|fullname
operator|=
name|Dir_FindFile
argument_list|(
name|file
argument_list|,
name|sysIncPath
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fullname
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
operator|*
name|cp
operator|=
name|endc
expr_stmt|;
name|Parse_Error
argument_list|(
name|PARSE_FATAL
argument_list|,
literal|"Could not find %s"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
block|}
name|free
argument_list|(
name|file
argument_list|)
expr_stmt|;
comment|/*      * Once we find the absolute path to the file, we get to save all the      * state from the current file before we can start reading this      * include file. The state is stored in an IFile structure which      * is placed on a list with other IFile structures. The list makes      * a very nice stack to track how we got here...      */
name|oldFile
operator|=
operator|(
name|IFile
operator|*
operator|)
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|IFile
argument_list|)
argument_list|)
expr_stmt|;
name|oldFile
operator|->
name|fname
operator|=
name|fname
expr_stmt|;
name|oldFile
operator|->
name|F
operator|=
name|curFILE
expr_stmt|;
name|oldFile
operator|->
name|p
operator|=
name|curPTR
expr_stmt|;
name|oldFile
operator|->
name|lineno
operator|=
name|lineno
expr_stmt|;
operator|(
name|void
operator|)
name|Lst_AtFront
argument_list|(
name|includes
argument_list|,
operator|(
name|ClientData
operator|)
name|oldFile
argument_list|)
expr_stmt|;
comment|/*      * Once the previous state has been saved, we can get down to reading      * the new file. We set up the name of the file to be the absolute      * name of the include file so error messages refer to the right      * place. Naturally enough, we start reading at line number 0.      */
name|fname
operator|=
name|fullname
expr_stmt|;
name|lineno
operator|=
literal|0
expr_stmt|;
name|curFILE
operator|=
name|fopen
argument_list|(
name|fullname
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|curPTR
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|curFILE
operator|==
operator|(
name|FILE
operator|*
operator|)
name|NULL
condition|)
block|{
name|Parse_Error
argument_list|(
name|PARSE_FATAL
argument_list|,
literal|"Cannot open %s"
argument_list|,
name|fullname
argument_list|)
expr_stmt|;
comment|/* 	 * Pop to previous file 	 */
operator|(
name|void
operator|)
name|ParseEOF
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*-  *---------------------------------------------------------------------  * Parse_FromString  --  *	Start Parsing from the given string  *  * Results:  *	None  *  * Side Effects:  *	A structure is added to the includes Lst and readProc, lineno,  *	fname and curFILE are altered for the new file  *---------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Parse_FromString
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|IFile
modifier|*
name|oldFile
decl_stmt|;
comment|/* state associated with this file */
if|if
condition|(
name|DEBUG
argument_list|(
name|FOR
argument_list|)
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n----\n"
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|oldFile
operator|=
operator|(
name|IFile
operator|*
operator|)
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|IFile
argument_list|)
argument_list|)
expr_stmt|;
name|oldFile
operator|->
name|lineno
operator|=
name|lineno
expr_stmt|;
name|oldFile
operator|->
name|fname
operator|=
name|fname
expr_stmt|;
name|oldFile
operator|->
name|F
operator|=
name|curFILE
expr_stmt|;
name|oldFile
operator|->
name|p
operator|=
name|curPTR
expr_stmt|;
operator|(
name|void
operator|)
name|Lst_AtFront
argument_list|(
name|includes
argument_list|,
operator|(
name|ClientData
operator|)
name|oldFile
argument_list|)
expr_stmt|;
name|curFILE
operator|=
name|NULL
expr_stmt|;
name|curPTR
operator|=
operator|(
name|PTR
operator|*
operator|)
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|PTR
argument_list|)
argument_list|)
expr_stmt|;
name|curPTR
operator|->
name|str
operator|=
name|curPTR
operator|->
name|ptr
operator|=
name|str
expr_stmt|;
name|lineno
operator|=
literal|0
expr_stmt|;
name|fname
operator|=
name|estrdup
argument_list|(
name|fname
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SYSVINCLUDE
end_ifdef

begin_comment
comment|/*-  *---------------------------------------------------------------------  * ParseTraditionalInclude  --  *	Push to another file.  *  *	The input is the line minus the "include".  The file name is  *	the string following the "include".  *  * Results:  *	None  *  * Side Effects:  *	A structure is added to the includes Lst and readProc, lineno,  *	fname and curFILE are altered for the new file  *---------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|ParseTraditionalInclude
parameter_list|(
name|file
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
comment|/* file specification */
block|{
name|char
modifier|*
name|fullname
decl_stmt|;
comment|/* full pathname of file */
name|IFile
modifier|*
name|oldFile
decl_stmt|;
comment|/* state associated with current file */
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* current position in file spec */
name|char
modifier|*
name|prefEnd
decl_stmt|;
comment|/*      * Skip over whitespace      */
while|while
condition|(
operator|(
operator|*
name|file
operator|==
literal|' '
operator|)
operator|||
operator|(
operator|*
name|file
operator|==
literal|'\t'
operator|)
condition|)
block|{
name|file
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|file
operator|==
literal|'\0'
condition|)
block|{
name|Parse_Error
argument_list|(
name|PARSE_FATAL
argument_list|,
literal|"Filename missing from \"include\""
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*      * Skip to end of line or next whitespace      */
for|for
control|(
name|cp
operator|=
name|file
init|;
operator|*
name|cp
operator|&&
operator|*
name|cp
operator|!=
literal|'\n'
operator|&&
operator|*
name|cp
operator|!=
literal|'\t'
operator|&&
operator|*
name|cp
operator|!=
literal|' '
condition|;
name|cp
operator|++
control|)
block|{
continue|continue;
block|}
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
comment|/*      * Substitute for any variables in the file name before trying to      * find the thing.      */
name|file
operator|=
name|Var_Subst
argument_list|(
name|NULL
argument_list|,
name|file
argument_list|,
name|VAR_CMD
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/*      * Now we know the file's name, we attempt to find the durn thing.      * A return of NULL indicates the file don't exist.      *      * Include files are first searched for relative to the including      * file's location. We don't want to cd there, of course, so we      * just tack on the old file's leading path components and call      * Dir_FindFile to see if we can locate the beast.      * XXX - this *does* search in the current directory, right?      */
name|prefEnd
operator|=
name|strrchr
argument_list|(
name|fname
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|prefEnd
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
name|char
modifier|*
name|newName
decl_stmt|;
operator|*
name|prefEnd
operator|=
literal|'\0'
expr_stmt|;
name|newName
operator|=
name|str_concat
argument_list|(
name|fname
argument_list|,
name|file
argument_list|,
name|STR_ADDSLASH
argument_list|)
expr_stmt|;
name|fullname
operator|=
name|Dir_FindFile
argument_list|(
name|newName
argument_list|,
name|parseIncPath
argument_list|)
expr_stmt|;
if|if
condition|(
name|fullname
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
name|fullname
operator|=
name|Dir_FindFile
argument_list|(
name|newName
argument_list|,
name|dirSearchPath
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|newName
argument_list|)
expr_stmt|;
operator|*
name|prefEnd
operator|=
literal|'/'
expr_stmt|;
block|}
else|else
block|{
name|fullname
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|fullname
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
comment|/* 	 * System makefile or makefile wasn't found in same directory as 	 * included makefile. Search for it first on the -I search path, 	 * then on the .PATH search path, if not found in a -I directory. 	 * XXX: Suffix specific? 	 */
name|fullname
operator|=
name|Dir_FindFile
argument_list|(
name|file
argument_list|,
name|parseIncPath
argument_list|)
expr_stmt|;
if|if
condition|(
name|fullname
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
name|fullname
operator|=
name|Dir_FindFile
argument_list|(
name|file
argument_list|,
name|dirSearchPath
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fullname
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
comment|/* 	 * Still haven't found the makefile. Look for it on the system 	 * path as a last resort. 	 */
name|fullname
operator|=
name|Dir_FindFile
argument_list|(
name|file
argument_list|,
name|sysIncPath
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fullname
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
name|Parse_Error
argument_list|(
name|PARSE_FATAL
argument_list|,
literal|"Could not find %s"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*      * Once we find the absolute path to the file, we get to save all the      * state from the current file before we can start reading this      * include file. The state is stored in an IFile structure which      * is placed on a list with other IFile structures. The list makes      * a very nice stack to track how we got here...      */
name|oldFile
operator|=
operator|(
name|IFile
operator|*
operator|)
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|IFile
argument_list|)
argument_list|)
expr_stmt|;
name|oldFile
operator|->
name|fname
operator|=
name|fname
expr_stmt|;
name|oldFile
operator|->
name|F
operator|=
name|curFILE
expr_stmt|;
name|oldFile
operator|->
name|p
operator|=
name|curPTR
expr_stmt|;
name|oldFile
operator|->
name|lineno
operator|=
name|lineno
expr_stmt|;
operator|(
name|void
operator|)
name|Lst_AtFront
argument_list|(
name|includes
argument_list|,
operator|(
name|ClientData
operator|)
name|oldFile
argument_list|)
expr_stmt|;
comment|/*      * Once the previous state has been saved, we can get down to reading      * the new file. We set up the name of the file to be the absolute      * name of the include file so error messages refer to the right      * place. Naturally enough, we start reading at line number 0.      */
name|fname
operator|=
name|fullname
expr_stmt|;
name|lineno
operator|=
literal|0
expr_stmt|;
name|curFILE
operator|=
name|fopen
argument_list|(
name|fullname
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|curPTR
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|curFILE
operator|==
operator|(
name|FILE
operator|*
operator|)
name|NULL
condition|)
block|{
name|Parse_Error
argument_list|(
name|PARSE_FATAL
argument_list|,
literal|"Cannot open %s"
argument_list|,
name|fullname
argument_list|)
expr_stmt|;
comment|/* 	 * Pop to previous file 	 */
operator|(
name|void
operator|)
name|ParseEOF
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*-  *---------------------------------------------------------------------  * ParseEOF  --  *	Called when EOF is reached in the current file. If we were reading  *	an include file, the includes stack is popped and things set up  *	to go back to reading the previous file at the previous location.  *  * Results:  *	CONTINUE if there's more to do. DONE if not.  *  * Side Effects:  *	The old curFILE, is closed. The includes list is shortened.  *	lineno, curFILE, and fname are changed if CONTINUE is returned.  *---------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|ParseEOF
parameter_list|(
name|opened
parameter_list|)
name|int
name|opened
decl_stmt|;
block|{
name|IFile
modifier|*
name|ifile
decl_stmt|;
comment|/* the state on the top of the includes stack */
if|if
condition|(
name|Lst_IsEmpty
argument_list|(
name|includes
argument_list|)
condition|)
block|{
return|return
operator|(
name|DONE
operator|)
return|;
block|}
name|ifile
operator|=
operator|(
name|IFile
operator|*
operator|)
name|Lst_DeQueue
argument_list|(
name|includes
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|Address
operator|)
name|fname
argument_list|)
expr_stmt|;
name|fname
operator|=
name|ifile
operator|->
name|fname
expr_stmt|;
name|lineno
operator|=
name|ifile
operator|->
name|lineno
expr_stmt|;
if|if
condition|(
name|opened
operator|&&
name|curFILE
condition|)
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|curFILE
argument_list|)
expr_stmt|;
if|if
condition|(
name|curPTR
condition|)
block|{
name|free
argument_list|(
operator|(
name|Address
operator|)
name|curPTR
operator|->
name|str
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|Address
operator|)
name|curPTR
argument_list|)
expr_stmt|;
block|}
name|curFILE
operator|=
name|ifile
operator|->
name|F
expr_stmt|;
name|curPTR
operator|=
name|ifile
operator|->
name|p
expr_stmt|;
name|free
argument_list|(
operator|(
name|Address
operator|)
name|ifile
argument_list|)
expr_stmt|;
return|return
operator|(
name|CONTINUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *---------------------------------------------------------------------  * ParseReadc  --  *	Read a character from the current file  *  * Results:  *	The character that was read  *  * Side Effects:  *---------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|ParseReadc
parameter_list|()
block|{
if|if
condition|(
name|curFILE
condition|)
return|return
name|fgetc
argument_list|(
name|curFILE
argument_list|)
return|;
if|if
condition|(
name|curPTR
operator|&&
operator|*
name|curPTR
operator|->
name|ptr
condition|)
return|return
operator|*
name|curPTR
operator|->
name|ptr
operator|++
return|;
return|return
name|EOF
return|;
block|}
end_function

begin_comment
comment|/*-  *---------------------------------------------------------------------  * ParseUnreadc  --  *	Put back a character to the current file  *  * Results:  *	None.  *  * Side Effects:  *---------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|ParseUnreadc
parameter_list|(
name|c
parameter_list|)
name|int
name|c
decl_stmt|;
block|{
if|if
condition|(
name|curFILE
condition|)
block|{
name|ungetc
argument_list|(
name|c
argument_list|,
name|curFILE
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|curPTR
condition|)
block|{
operator|*
operator|--
operator|(
name|curPTR
operator|->
name|ptr
operator|)
operator|=
name|c
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_comment
comment|/* ParseSkipLine():  *	Grab the next line  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|ParseSkipLine
parameter_list|(
name|skip
parameter_list|)
name|int
name|skip
decl_stmt|;
comment|/* Skip lines that don't start with . */
block|{
name|char
modifier|*
name|line
decl_stmt|;
name|int
name|c
decl_stmt|,
name|lastc
decl_stmt|,
name|lineLength
init|=
literal|0
decl_stmt|;
name|Buffer
name|buf
decl_stmt|;
name|buf
operator|=
name|Buf_Init
argument_list|(
name|MAKE_BSIZE
argument_list|)
expr_stmt|;
do|do
block|{
name|Buf_Discard
argument_list|(
name|buf
argument_list|,
name|lineLength
argument_list|)
expr_stmt|;
name|lastc
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
operator|(
operator|(
name|c
operator|=
name|ParseReadc
argument_list|()
operator|)
operator|!=
literal|'\n'
operator|||
name|lastc
operator|==
literal|'\\'
operator|)
operator|&&
name|c
operator|!=
name|EOF
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
name|Buf_ReplaceLastByte
argument_list|(
name|buf
argument_list|,
operator|(
name|Byte
operator|)
literal|' '
argument_list|)
expr_stmt|;
name|lineno
operator|++
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|ParseReadc
argument_list|()
operator|)
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
condition|)
empty_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
break|break;
block|}
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
operator|(
name|Byte
operator|)
name|c
argument_list|)
expr_stmt|;
name|lastc
operator|=
name|c
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
name|Parse_Error
argument_list|(
name|PARSE_FATAL
argument_list|,
literal|"Unclosed conditional/for loop"
argument_list|)
expr_stmt|;
name|Buf_Destroy
argument_list|(
name|buf
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
name|lineno
operator|++
expr_stmt|;
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
operator|(
name|Byte
operator|)
literal|'\0'
argument_list|)
expr_stmt|;
name|line
operator|=
operator|(
name|char
operator|*
operator|)
name|Buf_GetAll
argument_list|(
name|buf
argument_list|,
operator|&
name|lineLength
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|skip
operator|==
literal|1
operator|&&
name|line
index|[
literal|0
index|]
operator|!=
literal|'.'
condition|)
do|;
name|Buf_Destroy
argument_list|(
name|buf
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|line
return|;
block|}
end_function

begin_comment
comment|/*-  *---------------------------------------------------------------------  * ParseReadLine --  *	Read an entire line from the input file. Called only by Parse_File.  *	To facilitate escaped newlines and what have you, a character is  *	buffered in 'lastc', which is '\0' when no characters have been  *	read. When we break out of the loop, c holds the terminating  *	character and lastc holds a character that should be added to  *	the line (unless we don't read anything but a terminator).  *  * Results:  *	A line w/o its newline  *  * Side Effects:  *	Only those associated with reading a character  *---------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|ParseReadLine
parameter_list|()
block|{
name|Buffer
name|buf
decl_stmt|;
comment|/* Buffer for current line */
specifier|register
name|int
name|c
decl_stmt|;
comment|/* the current character */
specifier|register
name|int
name|lastc
decl_stmt|;
comment|/* The most-recent character */
name|Boolean
name|semiNL
decl_stmt|;
comment|/* treat semi-colons as newlines */
name|Boolean
name|ignDepOp
decl_stmt|;
comment|/* TRUE if should ignore dependency operators 				 * for the purposes of setting semiNL */
name|Boolean
name|ignComment
decl_stmt|;
comment|/* TRUE if should ignore comments (in a 				 * shell command */
name|char
modifier|*
name|line
decl_stmt|;
comment|/* Result */
name|char
modifier|*
name|ep
decl_stmt|;
comment|/* to strip trailing blanks */
name|int
name|lineLength
decl_stmt|;
comment|/* Length of result */
name|semiNL
operator|=
name|FALSE
expr_stmt|;
name|ignDepOp
operator|=
name|FALSE
expr_stmt|;
name|ignComment
operator|=
name|FALSE
expr_stmt|;
comment|/*      * Handle special-characters at the beginning of the line. Either a      * leading tab (shell command) or pound-sign (possible conditional)      * forces us to ignore comments and dependency operators and treat      * semi-colons as semi-colons (by leaving semiNL FALSE). This also      * discards completely blank lines.      */
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
name|ParseReadc
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\t'
condition|)
block|{
name|ignComment
operator|=
name|ignDepOp
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
name|lineno
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'#'
condition|)
block|{
name|ParseUnreadc
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
comment|/* 	     * Anything else breaks out without doing anything 	     */
break|break;
block|}
block|}
if|if
condition|(
name|c
operator|!=
name|EOF
condition|)
block|{
name|lastc
operator|=
name|c
expr_stmt|;
name|buf
operator|=
name|Buf_Init
argument_list|(
name|MAKE_BSIZE
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
operator|(
name|c
operator|=
name|ParseReadc
argument_list|()
operator|)
operator|!=
literal|'\n'
operator|||
operator|(
name|lastc
operator|==
literal|'\\'
operator|)
operator|)
operator|&&
operator|(
name|c
operator|!=
name|EOF
operator|)
condition|)
block|{
name|test_char
label|:
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\n'
case|:
comment|/* 		 * Escaped newline: read characters until a non-space or an 		 * unescaped newline and replace them all by a single space. 		 * This is done by storing the space over the backslash and 		 * dropping through with the next nonspace. If it is a 		 * semi-colon and semiNL is TRUE, it will be recognized as a 		 * newline in the code below this... 		 */
name|lineno
operator|++
expr_stmt|;
name|lastc
operator|=
literal|' '
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|ParseReadc
argument_list|()
operator|)
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|c
operator|==
name|EOF
operator|||
name|c
operator|==
literal|'\n'
condition|)
block|{
goto|goto
name|line_read
goto|;
block|}
else|else
block|{
comment|/* 		     * Check for comments, semiNL's, etc. -- easier than 		     * ParseUnreadc(c); continue; 		     */
goto|goto
name|test_char
goto|;
block|}
comment|/*NOTREACHED*/
break|break;
case|case
literal|';'
case|:
comment|/* 		 * Semi-colon: Need to see if it should be interpreted as a 		 * newline 		 */
if|if
condition|(
name|semiNL
condition|)
block|{
comment|/* 		     * To make sure the command that may be following this 		     * semi-colon begins with a tab, we push one back into the 		     * input stream. This will overwrite the semi-colon in the 		     * buffer. If there is no command following, this does no 		     * harm, since the newline remains in the buffer and the 		     * whole line is ignored. 		     */
name|ParseUnreadc
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
goto|goto
name|line_read
goto|;
block|}
break|break;
case|case
literal|'='
case|:
if|if
condition|(
operator|!
name|semiNL
condition|)
block|{
comment|/* 		     * Haven't seen a dependency operator before this, so this 		     * must be a variable assignment -- don't pay attention to 		     * dependency operators after this. 		     */
name|ignDepOp
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lastc
operator|==
literal|':'
operator|||
name|lastc
operator|==
literal|'!'
condition|)
block|{
comment|/* 		     * Well, we've seen a dependency operator already, but it 		     * was the previous character, so this is really just an 		     * expanded variable assignment. Revert semi-colons to 		     * being just semi-colons again and ignore any more 		     * dependency operators. 		     * 		     * XXX: Note that a line like "foo : a:=b" will blow up, 		     * but who'd write a line like that anyway? 		     */
name|ignDepOp
operator|=
name|TRUE
expr_stmt|;
name|semiNL
operator|=
name|FALSE
expr_stmt|;
block|}
break|break;
case|case
literal|'#'
case|:
if|if
condition|(
operator|!
name|ignComment
condition|)
block|{
if|if
condition|(
if|#
directive|if
literal|0
condition|compatMake&&
endif|#
directive|endif
operator|(
name|lastc
operator|!=
literal|'\\'
operator|)
condition|)
block|{
comment|/* 			 * If the character is a hash mark and it isn't escaped 			 * (or we're being compatible), the thing is a comment. 			 * Skip to the end of the line. 			 */
do|do
block|{
name|c
operator|=
name|ParseReadc
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|c
operator|!=
literal|'\n'
operator|)
operator|&&
operator|(
name|c
operator|!=
name|EOF
operator|)
condition|)
do|;
goto|goto
name|line_read
goto|;
block|}
else|else
block|{
comment|/* 			 * Don't add the backslash. Just let the # get copied 			 * over. 			 */
name|lastc
operator|=
name|c
expr_stmt|;
continue|continue;
block|}
block|}
break|break;
case|case
literal|':'
case|:
case|case
literal|'!'
case|:
if|if
condition|(
operator|!
name|ignDepOp
operator|&&
operator|(
name|c
operator|==
literal|':'
operator|||
name|c
operator|==
literal|'!'
operator|)
condition|)
block|{
comment|/* 		     * A semi-colon is recognized as a newline only on 		     * dependency lines. Dependency lines are lines with a 		     * colon or an exclamation point. Ergo... 		     */
name|semiNL
operator|=
name|TRUE
expr_stmt|;
block|}
break|break;
block|}
comment|/* 	     * Copy in the previous character and save this one in lastc. 	     */
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
operator|(
name|Byte
operator|)
name|lastc
argument_list|)
expr_stmt|;
name|lastc
operator|=
name|c
expr_stmt|;
block|}
name|line_read
label|:
name|lineno
operator|++
expr_stmt|;
if|if
condition|(
name|lastc
operator|!=
literal|'\0'
condition|)
block|{
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
operator|(
name|Byte
operator|)
name|lastc
argument_list|)
expr_stmt|;
block|}
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
operator|(
name|Byte
operator|)
literal|'\0'
argument_list|)
expr_stmt|;
name|line
operator|=
operator|(
name|char
operator|*
operator|)
name|Buf_GetAll
argument_list|(
name|buf
argument_list|,
operator|&
name|lineLength
argument_list|)
expr_stmt|;
name|Buf_Destroy
argument_list|(
name|buf
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* 	 * Strip trailing blanks and tabs from the line. 	 * Do not strip a blank or tab that is preceeded by 	 * a '\' 	 */
name|ep
operator|=
name|line
expr_stmt|;
while|while
condition|(
operator|*
name|ep
condition|)
operator|++
name|ep
expr_stmt|;
while|while
condition|(
name|ep
operator|>
name|line
operator|+
literal|1
operator|&&
operator|(
name|ep
index|[
operator|-
literal|1
index|]
operator|==
literal|' '
operator|||
name|ep
index|[
operator|-
literal|1
index|]
operator|==
literal|'\t'
operator|)
condition|)
block|{
if|if
condition|(
name|ep
operator|>
name|line
operator|+
literal|1
operator|&&
name|ep
index|[
operator|-
literal|2
index|]
operator|==
literal|'\\'
condition|)
break|break;
operator|--
name|ep
expr_stmt|;
block|}
operator|*
name|ep
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|line
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
block|{
comment|/* 	     * The line might be a conditional. Ask the conditional module 	     * about it and act accordingly 	     */
switch|switch
condition|(
name|Cond_Eval
argument_list|(
name|line
argument_list|)
condition|)
block|{
case|case
name|COND_SKIP
case|:
comment|/* 		 * Skip to next conditional that evaluates to COND_PARSE. 		 */
do|do
block|{
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|line
operator|=
name|ParseSkipLine
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|line
operator|&&
name|Cond_Eval
argument_list|(
name|line
argument_list|)
operator|!=
name|COND_PARSE
condition|)
do|;
if|if
condition|(
name|line
operator|==
name|NULL
condition|)
break|break;
comment|/*FALLTHRU*/
case|case
name|COND_PARSE
case|:
name|free
argument_list|(
operator|(
name|Address
operator|)
name|line
argument_list|)
expr_stmt|;
name|line
operator|=
name|ParseReadLine
argument_list|()
expr_stmt|;
break|break;
case|case
name|COND_INVALID
case|:
if|if
condition|(
name|For_Eval
argument_list|(
name|line
argument_list|)
condition|)
block|{
name|int
name|ok
decl_stmt|;
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
do|do
block|{
comment|/* 			 * Skip after the matching end 			 */
name|line
operator|=
name|ParseSkipLine
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|==
name|NULL
condition|)
block|{
name|Parse_Error
argument_list|(
name|PARSE_FATAL
argument_list|,
literal|"Unexpected end of file in for loop.\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|ok
operator|=
name|For_Eval
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|ok
condition|)
do|;
if|if
condition|(
name|line
operator|!=
name|NULL
condition|)
name|For_Run
argument_list|()
expr_stmt|;
name|line
operator|=
name|ParseReadLine
argument_list|()
expr_stmt|;
block|}
break|break;
block|}
block|}
return|return
operator|(
name|line
operator|)
return|;
block|}
else|else
block|{
comment|/* 	 * Hit end-of-file, so return a NULL line to indicate this. 	 */
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * ParseFinishLine --  *	Handle the end of a dependency group.  *  * Results:  *	Nothing.  *  * Side Effects:  *	inLine set FALSE. 'targets' list destroyed.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|ParseFinishLine
parameter_list|()
block|{
if|if
condition|(
name|inLine
condition|)
block|{
name|Lst_ForEach
argument_list|(
name|targets
argument_list|,
name|Suff_EndTransform
argument_list|,
operator|(
name|ClientData
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|Lst_Destroy
argument_list|(
name|targets
argument_list|,
name|ParseHasCommands
argument_list|)
expr_stmt|;
name|targets
operator|=
name|NULL
expr_stmt|;
name|inLine
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*-  *---------------------------------------------------------------------  * Parse_File --  *	Parse a file into its component parts, incorporating it into the  *	current dependency graph. This is the main function and controls  *	almost every other function in this module  *  * Results:  *	None  *  * Side Effects:  *	Loads. Nodes are added to the list of all targets, nodes and links  *	are added to the dependency graph. etc. etc. etc.  *---------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Parse_File
parameter_list|(
name|name
parameter_list|,
name|stream
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
comment|/* the name of the file being read */
name|FILE
modifier|*
name|stream
decl_stmt|;
comment|/* Stream open to makefile to parse */
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
comment|/* pointer into the line */
modifier|*
name|line
decl_stmt|;
comment|/* the line we're working on */
name|inLine
operator|=
name|FALSE
expr_stmt|;
name|fname
operator|=
name|name
expr_stmt|;
name|curFILE
operator|=
name|stream
expr_stmt|;
name|lineno
operator|=
literal|0
expr_stmt|;
name|fatals
operator|=
literal|0
expr_stmt|;
do|do
block|{
while|while
condition|(
operator|(
name|line
operator|=
name|ParseReadLine
argument_list|()
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|*
name|line
operator|==
literal|'.'
condition|)
block|{
comment|/* 		 * Lines that begin with the special character are either 		 * include or undef directives. 		 */
for|for
control|(
name|cp
operator|=
name|line
operator|+
literal|1
init|;
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
condition|;
name|cp
operator|++
control|)
block|{
continue|continue;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|cp
argument_list|,
literal|"include"
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ParseDoInclude
argument_list|(
name|cp
operator|+
literal|7
argument_list|)
expr_stmt|;
goto|goto
name|nextLine
goto|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|cp
argument_list|,
literal|"undef"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|cp2
decl_stmt|;
for|for
control|(
name|cp
operator|+=
literal|5
init|;
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cp
argument_list|)
condition|;
name|cp
operator|++
control|)
block|{
continue|continue;
block|}
for|for
control|(
name|cp2
operator|=
name|cp
init|;
operator|!
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cp2
argument_list|)
operator|&&
operator|(
operator|*
name|cp2
operator|!=
literal|'\0'
operator|)
condition|;
name|cp2
operator|++
control|)
block|{
continue|continue;
block|}
operator|*
name|cp2
operator|=
literal|'\0'
expr_stmt|;
name|Var_Delete
argument_list|(
name|cp
argument_list|,
name|VAR_GLOBAL
argument_list|)
expr_stmt|;
goto|goto
name|nextLine
goto|;
block|}
block|}
if|if
condition|(
operator|*
name|line
operator|==
literal|'#'
condition|)
block|{
comment|/* If we're this far, the line must be a comment. */
goto|goto
name|nextLine
goto|;
block|}
if|if
condition|(
operator|*
name|line
operator|==
literal|'\t'
condition|)
block|{
comment|/* 		 * If a line starts with a tab, it can only hope to be 		 * a creation command. 		 */
ifndef|#
directive|ifndef
name|POSIX
name|shellCommand
label|:
endif|#
directive|endif
for|for
control|(
name|cp
operator|=
name|line
operator|+
literal|1
init|;
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
condition|;
name|cp
operator|++
control|)
block|{
continue|continue;
block|}
if|if
condition|(
operator|*
name|cp
condition|)
block|{
if|if
condition|(
name|inLine
condition|)
block|{
comment|/* 			 * So long as it's not a blank line and we're actually 			 * in a dependency spec, add the command to the list of 			 * commands of all targets in the dependency spec 			 */
name|Lst_ForEach
argument_list|(
name|targets
argument_list|,
name|ParseAddCmd
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|Lst_AtEnd
argument_list|(
name|targCmds
argument_list|,
operator|(
name|ClientData
operator|)
name|line
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
block|{
name|Parse_Error
argument_list|(
name|PARSE_FATAL
argument_list|,
literal|"Unassociated shell command \"%s\""
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|SYSVINCLUDE
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|line
argument_list|,
literal|"include"
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
operator|&&
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|line
index|[
literal|7
index|]
argument_list|)
operator|&&
name|strchr
argument_list|(
name|line
argument_list|,
literal|':'
argument_list|)
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * It's an S3/S5-style "include". 		 */
name|ParseTraditionalInclude
argument_list|(
name|line
operator|+
literal|7
argument_list|)
expr_stmt|;
goto|goto
name|nextLine
goto|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|Parse_IsVar
argument_list|(
name|line
argument_list|)
condition|)
block|{
name|ParseFinishLine
argument_list|()
expr_stmt|;
name|Parse_DoVar
argument_list|(
name|line
argument_list|,
name|VAR_GLOBAL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * We now know it's a dependency line so it needs to have all 		 * variables expanded before being parsed. Tell the variable 		 * module to complain if some variable is undefined... 		 * To make life easier on novices, if the line is indented we 		 * first make sure the line has a dependency operator in it. 		 * If it doesn't have an operator and we're in a dependency 		 * line's script, we assume it's actually a shell command 		 * and add it to the current list of targets. 		 */
ifndef|#
directive|ifndef
name|POSIX
name|Boolean
name|nonSpace
init|=
name|FALSE
decl_stmt|;
endif|#
directive|endif
name|cp
operator|=
name|line
expr_stmt|;
if|if
condition|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|line
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
while|while
condition|(
operator|(
operator|*
name|cp
operator|!=
literal|'\0'
operator|)
operator|&&
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cp
argument_list|)
condition|)
block|{
name|cp
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
condition|)
block|{
goto|goto
name|nextLine
goto|;
block|}
ifndef|#
directive|ifndef
name|POSIX
while|while
condition|(
operator|(
operator|*
name|cp
operator|!=
literal|':'
operator|)
operator|&&
operator|(
operator|*
name|cp
operator|!=
literal|'!'
operator|)
operator|&&
operator|(
operator|*
name|cp
operator|!=
literal|'\0'
operator|)
condition|)
block|{
name|nonSpace
operator|=
name|TRUE
expr_stmt|;
name|cp
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
block|}
ifndef|#
directive|ifndef
name|POSIX
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|inLine
condition|)
block|{
name|Parse_Error
argument_list|(
name|PARSE_WARNING
argument_list|,
literal|"Shell command needs a leading tab"
argument_list|)
expr_stmt|;
goto|goto
name|shellCommand
goto|;
block|}
elseif|else
if|if
condition|(
name|nonSpace
condition|)
block|{
name|Parse_Error
argument_list|(
name|PARSE_FATAL
argument_list|,
literal|"Missing operator"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
endif|#
directive|endif
name|ParseFinishLine
argument_list|()
expr_stmt|;
name|cp
operator|=
name|Var_Subst
argument_list|(
name|NULL
argument_list|,
name|line
argument_list|,
name|VAR_CMD
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|line
operator|=
name|cp
expr_stmt|;
comment|/* 		     * Need a non-circular list for the target nodes 		     */
if|if
condition|(
name|targets
condition|)
name|Lst_Destroy
argument_list|(
name|targets
argument_list|,
name|NOFREE
argument_list|)
expr_stmt|;
name|targets
operator|=
name|Lst_Init
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|inLine
operator|=
name|TRUE
expr_stmt|;
name|ParseDoDependency
argument_list|(
name|line
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|POSIX
block|}
endif|#
directive|endif
block|}
name|nextLine
label|:
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Reached EOF, but it may be just EOF of an include file... 	 */
block|}
do|while
condition|(
name|ParseEOF
argument_list|(
literal|1
argument_list|)
operator|==
name|CONTINUE
condition|)
do|;
comment|/*      * Make sure conditionals are clean      */
name|Cond_End
argument_list|()
expr_stmt|;
if|if
condition|(
name|fatals
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Fatal errors encountered -- cannot continue\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*-  *---------------------------------------------------------------------  * Parse_Init --  *	initialize the parsing module  *  * Results:  *	none  *  * Side Effects:  *	the parseIncPath list is initialized...  *---------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Parse_Init
parameter_list|()
block|{
name|mainNode
operator|=
name|NILGNODE
expr_stmt|;
name|parseIncPath
operator|=
name|Lst_Init
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|sysIncPath
operator|=
name|Lst_Init
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|includes
operator|=
name|Lst_Init
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|targCmds
operator|=
name|Lst_Init
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|Parse_End
parameter_list|()
block|{
name|Lst_Destroy
argument_list|(
name|targCmds
argument_list|,
operator|(
name|void
argument_list|(
argument|*
argument_list|)
name|__P
argument_list|(
operator|(
name|ClientData
operator|)
argument_list|)
operator|)
name|free
argument_list|)
expr_stmt|;
if|if
condition|(
name|targets
condition|)
name|Lst_Destroy
argument_list|(
name|targets
argument_list|,
name|NOFREE
argument_list|)
expr_stmt|;
name|Lst_Destroy
argument_list|(
name|sysIncPath
argument_list|,
name|Dir_Destroy
argument_list|)
expr_stmt|;
name|Lst_Destroy
argument_list|(
name|parseIncPath
argument_list|,
name|Dir_Destroy
argument_list|)
expr_stmt|;
name|Lst_Destroy
argument_list|(
name|includes
argument_list|,
name|NOFREE
argument_list|)
expr_stmt|;
comment|/* Should be empty now */
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Parse_MainName --  *	Return a Lst of the main target to create for main()'s sake. If  *	no such target exists, we Punt with an obnoxious error message.  *  * Results:  *	A Lst of the single node to create.  *  * Side Effects:  *	None.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|Lst
name|Parse_MainName
parameter_list|()
block|{
name|Lst
decl|main
decl_stmt|;
comment|/* result list */
expr|main
operator|=
name|Lst_Init
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|mainNode
operator|==
name|NILGNODE
condition|)
block|{
name|Punt
argument_list|(
literal|"no target to make."
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
elseif|else
if|if
condition|(
name|mainNode
operator|->
name|type
operator|&
name|OP_DOUBLEDEP
condition|)
block|{
operator|(
name|void
operator|)
name|Lst_AtEnd
argument_list|(
expr|main
argument_list|,
operator|(
name|ClientData
operator|)
name|mainNode
argument_list|)
expr_stmt|;
name|Lst_Concat
argument_list|(
expr|main
argument_list|,
name|mainNode
operator|->
name|cohorts
argument_list|,
name|LST_CONCNEW
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|Lst_AtEnd
argument_list|(
expr|main
argument_list|,
operator|(
name|ClientData
operator|)
name|mainNode
argument_list|)
expr_stmt|;
return|return
operator|(
expr|main
operator|)
return|;
block|}
end_function

end_unit

