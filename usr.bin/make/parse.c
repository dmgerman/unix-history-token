begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1988, 1989, 1990, 1993  *	The Regents of the University of California.  All rights reserved.  * Copyright (c) 1989 by Berkeley Softworks  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Adam de Boor.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * @(#)parse.c	8.3 (Berkeley) 3/19/94  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*-  * parse.c --  *	Functions to parse a makefile.  *  *	Most important structures are kept in Lsts. Directories for  *	the #include "..." function are kept in the 'parseIncPath' Lst, while  *	those for the #include<...> are kept in the 'sysIncPath' Lst. The  *	targets currently being defined are kept in the 'targets' Lst.  *  * Interface:  *  *	Parse_File	Function used to parse a makefile. It must  *			be given the name of the file, which should  *			already have been opened, and a function  *			to call to read a character from the file.  *  *	Parse_IsVar	Returns TRUE if the given line is a  *			variable assignment. Used by MainParseArgs  *			to determine if an argument is a target  *			or a variable assignment. Used internally  *			for pretty much the same thing...  *  *	Parse_Error	Function called when an error occurs in  *			parsing. Used by the variable and  *			conditional modules.  *  *	Parse_MainName	Returns a Lst of the main target to create.  */
end_comment

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|"arch.h"
end_include

begin_include
include|#
directive|include
file|"buf.h"
end_include

begin_include
include|#
directive|include
file|"cond.h"
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"dir.h"
end_include

begin_include
include|#
directive|include
file|"for.h"
end_include

begin_include
include|#
directive|include
file|"globals.h"
end_include

begin_include
include|#
directive|include
file|"GNode.h"
end_include

begin_include
include|#
directive|include
file|"hash_tables.h"
end_include

begin_include
include|#
directive|include
file|"job.h"
end_include

begin_include
include|#
directive|include
file|"make.h"
end_include

begin_include
include|#
directive|include
file|"parse.h"
end_include

begin_include
include|#
directive|include
file|"pathnames.h"
end_include

begin_include
include|#
directive|include
file|"shell.h"
end_include

begin_include
include|#
directive|include
file|"str.h"
end_include

begin_include
include|#
directive|include
file|"suff.h"
end_include

begin_include
include|#
directive|include
file|"targ.h"
end_include

begin_include
include|#
directive|include
file|"util.h"
end_include

begin_include
include|#
directive|include
file|"var.h"
end_include

begin_comment
comment|/*  * These values are returned by ParsePopInput to tell Parse_File whether to  * CONTINUE parsing, i.e. it had only reached the end of an include file,  * or if it's DONE.  */
end_comment

begin_define
define|#
directive|define
name|CONTINUE
value|1
end_define

begin_define
define|#
directive|define
name|DONE
value|0
end_define

begin_comment
comment|/* targets we're working on */
end_comment

begin_decl_stmt
specifier|static
name|Lst
name|targets
init|=
name|Lst_Initializer
argument_list|(
name|targets
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* true if currently in a dependency line or its commands */
end_comment

begin_decl_stmt
specifier|static
name|Boolean
name|inLine
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fatals
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The main target to create. This is the first target on the  * first dependency line in the first makefile.  */
end_comment

begin_decl_stmt
specifier|static
name|GNode
modifier|*
name|mainNode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Definitions for handling #include specifications  */
end_comment

begin_struct
struct|struct
name|IFile
block|{
name|char
modifier|*
name|fname
decl_stmt|;
comment|/* name of previous file */
name|int
name|lineno
decl_stmt|;
comment|/* saved line number */
name|FILE
modifier|*
name|F
decl_stmt|;
comment|/* the open stream */
name|char
modifier|*
name|str
decl_stmt|;
comment|/* the string when parsing a string */
name|char
modifier|*
name|ptr
decl_stmt|;
comment|/* the current pointer when parsing a string */
name|TAILQ_ENTRY
argument_list|(
argument|IFile
argument_list|)
name|link
expr_stmt|;
comment|/* stack the files */
block|}
struct|;
end_struct

begin_comment
comment|/* stack of IFiles generated by * #includes */
end_comment

begin_expr_stmt
specifier|static
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|IFile
argument_list|)
name|includes
operator|=
name|TAILQ_HEAD_INITIALIZER
argument_list|(
name|includes
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* access current file */
end_comment

begin_define
define|#
directive|define
name|CURFILE
value|(TAILQ_FIRST(&includes))
end_define

begin_comment
comment|/* list of directories for "..." includes */
end_comment

begin_decl_stmt
name|struct
name|Path
name|parseIncPath
init|=
name|TAILQ_HEAD_INITIALIZER
argument_list|(
name|parseIncPath
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list of directories for<...> includes */
end_comment

begin_decl_stmt
name|struct
name|Path
name|sysIncPath
init|=
name|TAILQ_HEAD_INITIALIZER
argument_list|(
name|sysIncPath
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * specType contains the SPECial TYPE of the current target. It is  * Not if the target is unspecial. If it *is* special, however, the children  * are linked as children of the parent but not vice versa. This variable is  * set in ParseDoDependency  */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|Begin
block|,
comment|/* .BEGIN */
name|Default
block|,
comment|/* .DEFAULT */
name|End
block|,
comment|/* .END */
name|ExportVar
block|,
comment|/* .EXPORTVAR */
name|Ignore
block|,
comment|/* .IGNORE */
name|Includes
block|,
comment|/* .INCLUDES */
name|Interrupt
block|,
comment|/* .INTERRUPT */
name|Libs
block|,
comment|/* .LIBS */
name|MFlags
block|,
comment|/* .MFLAGS or .MAKEFLAGS */
name|Main
block|,
comment|/* .MAIN and we don't have anyth. user-spec. to make */
name|Not
block|,
comment|/* Not special */
name|NotParallel
block|,
comment|/* .NOTPARALELL */
name|Null
block|,
comment|/* .NULL */
name|Order
block|,
comment|/* .ORDER */
name|Parallel
block|,
comment|/* .PARALLEL */
name|ExPath
block|,
comment|/* .PATH */
name|Phony
block|,
comment|/* .PHONY */
name|Posix
block|,
comment|/* .POSIX */
name|Precious
block|,
comment|/* .PRECIOUS */
name|ExShell
block|,
comment|/* .SHELL */
name|Silent
block|,
comment|/* .SILENT */
name|SingleShell
block|,
comment|/* .SINGLESHELL */
name|Suffixes
block|,
comment|/* .SUFFIXES */
name|Wait
block|,
comment|/* .WAIT */
name|Warn
block|,
comment|/* .WARN */
name|Attribute
comment|/* Generic attribute */
block|}
name|ParseSpecial
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|ParseSpecial
name|specType
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|waiting
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Predecessor node for handling .ORDER. Initialized to NULL when .ORDER  * seen, then set to each successive source on the line.  */
end_comment

begin_decl_stmt
specifier|static
name|GNode
modifier|*
name|predecessor
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The parseKeywords table is searched using binary search when deciding  * if a target or source is special. The 'spec' field is the ParseSpecial  * type of the keyword ("Not" if the keyword isn't special as a target) while  * the 'op' field is the operator to apply to the list of targets if the  * keyword is used as a source ("0" if the keyword isn't special as a source)  */
end_comment

begin_struct
specifier|static
specifier|const
struct|struct
name|keyword
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Name of keyword */
name|ParseSpecial
name|spec
decl_stmt|;
comment|/* Type when used as a target */
name|int
name|op
decl_stmt|;
comment|/* Operator when used as a source */
block|}
name|parseKeywords
index|[]
init|=
block|{
comment|/* KEYWORD-START-TAG */
block|{
literal|".BEGIN"
block|,
name|Begin
block|,
literal|0
block|}
block|,
block|{
literal|".DEFAULT"
block|,
name|Default
block|,
literal|0
block|}
block|,
block|{
literal|".END"
block|,
name|End
block|,
literal|0
block|}
block|,
block|{
literal|".EXEC"
block|,
name|Attribute
block|,
name|OP_EXEC
block|}
block|,
block|{
literal|".EXPORTVAR"
block|,
name|ExportVar
block|,
literal|0
block|}
block|,
block|{
literal|".IGNORE"
block|,
name|Ignore
block|,
name|OP_IGNORE
block|}
block|,
block|{
literal|".INCLUDES"
block|,
name|Includes
block|,
literal|0
block|}
block|,
block|{
literal|".INTERRUPT"
block|,
name|Interrupt
block|,
literal|0
block|}
block|,
block|{
literal|".INVISIBLE"
block|,
name|Attribute
block|,
name|OP_INVISIBLE
block|}
block|,
block|{
literal|".JOIN"
block|,
name|Attribute
block|,
name|OP_JOIN
block|}
block|,
block|{
literal|".LIBS"
block|,
name|Libs
block|,
literal|0
block|}
block|,
block|{
literal|".MAIN"
block|,
name|Main
block|,
literal|0
block|}
block|,
block|{
literal|".MAKE"
block|,
name|Attribute
block|,
name|OP_MAKE
block|}
block|,
block|{
literal|".MAKEFLAGS"
block|,
name|MFlags
block|,
literal|0
block|}
block|,
block|{
literal|".MFLAGS"
block|,
name|MFlags
block|,
literal|0
block|}
block|,
block|{
literal|".NOTMAIN"
block|,
name|Attribute
block|,
name|OP_NOTMAIN
block|}
block|,
block|{
literal|".NOTPARALLEL"
block|,
name|NotParallel
block|,
literal|0
block|}
block|,
block|{
literal|".NO_PARALLEL"
block|,
name|NotParallel
block|,
literal|0
block|}
block|,
block|{
literal|".NULL"
block|,
name|Null
block|,
literal|0
block|}
block|,
block|{
literal|".OPTIONAL"
block|,
name|Attribute
block|,
name|OP_OPTIONAL
block|}
block|,
block|{
literal|".ORDER"
block|,
name|Order
block|,
literal|0
block|}
block|,
block|{
literal|".PARALLEL"
block|,
name|Parallel
block|,
literal|0
block|}
block|,
block|{
literal|".PATH"
block|,
name|ExPath
block|,
literal|0
block|}
block|,
block|{
literal|".PHONY"
block|,
name|Phony
block|,
name|OP_PHONY
block|}
block|,
block|{
literal|".POSIX"
block|,
name|Posix
block|,
literal|0
block|}
block|,
block|{
literal|".PRECIOUS"
block|,
name|Precious
block|,
name|OP_PRECIOUS
block|}
block|,
block|{
literal|".RECURSIVE"
block|,
name|Attribute
block|,
name|OP_MAKE
block|}
block|,
block|{
literal|".SHELL"
block|,
name|ExShell
block|,
literal|0
block|}
block|,
block|{
literal|".SILENT"
block|,
name|Silent
block|,
name|OP_SILENT
block|}
block|,
block|{
literal|".SINGLESHELL"
block|,
name|SingleShell
block|,
literal|0
block|}
block|,
block|{
literal|".SUFFIXES"
block|,
name|Suffixes
block|,
literal|0
block|}
block|,
block|{
literal|".USE"
block|,
name|Attribute
block|,
name|OP_USE
block|}
block|,
block|{
literal|".WAIT"
block|,
name|Wait
block|,
literal|0
block|}
block|,
block|{
literal|".WARN"
block|,
name|Warn
block|,
literal|0
block|}
block|,
comment|/* KEYWORD-END-TAG */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|NKEYWORDS
value|(sizeof(parseKeywords) / sizeof(parseKeywords[0]))
end_define

begin_function_decl
specifier|static
name|void
name|parse_include
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|parse_sinclude
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|parse_message
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|parse_undef
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|parse_for
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|parse_endfor
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_struct
specifier|static
specifier|const
struct|struct
name|directive
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|code
decl_stmt|;
name|Boolean
name|skip_flag
decl_stmt|;
comment|/* execute even when skipped */
name|void
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
block|}
name|directives
index|[]
init|=
block|{
comment|/* DIRECTIVES-START-TAG */
block|{
literal|"elif"
block|,
name|COND_ELIF
block|,
name|TRUE
block|,
name|Cond_If
block|}
block|,
block|{
literal|"elifdef"
block|,
name|COND_ELIFDEF
block|,
name|TRUE
block|,
name|Cond_If
block|}
block|,
block|{
literal|"elifmake"
block|,
name|COND_ELIFMAKE
block|,
name|TRUE
block|,
name|Cond_If
block|}
block|,
block|{
literal|"elifndef"
block|,
name|COND_ELIFNDEF
block|,
name|TRUE
block|,
name|Cond_If
block|}
block|,
block|{
literal|"elifnmake"
block|,
name|COND_ELIFNMAKE
block|,
name|TRUE
block|,
name|Cond_If
block|}
block|,
block|{
literal|"else"
block|,
name|COND_ELSE
block|,
name|TRUE
block|,
name|Cond_Else
block|}
block|,
block|{
literal|"endfor"
block|,
literal|0
block|,
name|FALSE
block|,
name|parse_endfor
block|}
block|,
block|{
literal|"endif"
block|,
name|COND_ENDIF
block|,
name|TRUE
block|,
name|Cond_Endif
block|}
block|,
block|{
literal|"error"
block|,
literal|1
block|,
name|FALSE
block|,
name|parse_message
block|}
block|,
block|{
literal|"for"
block|,
literal|0
block|,
name|FALSE
block|,
name|parse_for
block|}
block|,
block|{
literal|"if"
block|,
name|COND_IF
block|,
name|TRUE
block|,
name|Cond_If
block|}
block|,
block|{
literal|"ifdef"
block|,
name|COND_IFDEF
block|,
name|TRUE
block|,
name|Cond_If
block|}
block|,
block|{
literal|"ifmake"
block|,
name|COND_IFMAKE
block|,
name|TRUE
block|,
name|Cond_If
block|}
block|,
block|{
literal|"ifndef"
block|,
name|COND_IFNDEF
block|,
name|TRUE
block|,
name|Cond_If
block|}
block|,
block|{
literal|"ifnmake"
block|,
name|COND_IFNMAKE
block|,
name|TRUE
block|,
name|Cond_If
block|}
block|,
block|{
literal|"include"
block|,
literal|0
block|,
name|FALSE
block|,
name|parse_include
block|}
block|,
block|{
literal|"sinclude"
block|,
literal|0
block|,
name|FALSE
block|,
name|parse_sinclude
block|}
block|,
block|{
literal|"undef"
block|,
literal|0
block|,
name|FALSE
block|,
name|parse_undef
block|}
block|,
block|{
literal|"warning"
block|,
literal|0
block|,
name|FALSE
block|,
name|parse_message
block|}
block|,
comment|/* DIRECTIVES-END-TAG */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|NDIRECTS
value|(sizeof(directives) / sizeof(directives[0]))
end_define

begin_comment
comment|/*-  * ParseFindKeyword  *	Look in the table of keywords for one matching the given string.  *  * Results:  *	The pointer to keyword table entry or NULL.  */
end_comment

begin_function
specifier|static
specifier|const
name|struct
name|keyword
modifier|*
name|ParseFindKeyword
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
name|int
name|kw
decl_stmt|;
name|kw
operator|=
name|keyword_hash
argument_list|(
name|str
argument_list|,
name|strlen
argument_list|(
name|str
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kw
operator|<
literal|0
operator|||
name|kw
operator|>=
operator|(
name|int
operator|)
name|NKEYWORDS
operator|||
name|strcmp
argument_list|(
name|str
argument_list|,
name|parseKeywords
index|[
name|kw
index|]
operator|.
name|name
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
operator|&
name|parseKeywords
index|[
name|kw
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  * Parse_Error  --  *	Error message abort function for parsing. Prints out the context  *	of the error (line number and file) as well as the message with  *	two optional arguments.  *  * Results:  *	None  *  * Side Effects:  *	"fatals" is incremented if the level is PARSE_FATAL.  */
end_comment

begin_comment
comment|/* VARARGS */
end_comment

begin_function
name|void
name|Parse_Error
parameter_list|(
name|int
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|CURFILE
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\"%s\", line %d: "
argument_list|,
name|CURFILE
operator|->
name|fname
argument_list|,
name|CURFILE
operator|->
name|lineno
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|PARSE_WARNING
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"warning: "
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|PARSE_FATAL
condition|)
name|fatals
operator|+=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * ParsePushInput  *  * Push a new input source onto the input stack. If ptr is NULL  * the fullname is used to fopen the file. If it is not NULL,  * ptr is assumed to point to the string to be parsed. If opening the  * file fails, the fullname is freed.  */
end_comment

begin_function
specifier|static
name|void
name|ParsePushInput
parameter_list|(
name|char
modifier|*
name|fullname
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
name|char
modifier|*
name|ptr
parameter_list|,
name|int
name|lineno
parameter_list|)
block|{
name|struct
name|IFile
modifier|*
name|nf
decl_stmt|;
name|nf
operator|=
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|nf
argument_list|)
argument_list|)
expr_stmt|;
name|nf
operator|->
name|fname
operator|=
name|fullname
expr_stmt|;
name|nf
operator|->
name|lineno
operator|=
name|lineno
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|NULL
condition|)
block|{
comment|/* the input source is a file */
if|if
condition|(
operator|(
name|nf
operator|->
name|F
operator|=
name|fp
operator|)
operator|==
name|NULL
condition|)
block|{
name|nf
operator|->
name|F
operator|=
name|fopen
argument_list|(
name|fullname
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|nf
operator|->
name|F
operator|==
name|NULL
condition|)
block|{
name|Parse_Error
argument_list|(
name|PARSE_FATAL
argument_list|,
literal|"Cannot open %s"
argument_list|,
name|fullname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fullname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|nf
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|nf
operator|->
name|str
operator|=
name|nf
operator|->
name|ptr
operator|=
name|NULL
expr_stmt|;
name|Var_Append
argument_list|(
literal|".MAKEFILE_LIST"
argument_list|,
name|fullname
argument_list|,
name|VAR_GLOBAL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nf
operator|->
name|str
operator|=
name|nf
operator|->
name|ptr
operator|=
name|ptr
expr_stmt|;
name|nf
operator|->
name|F
operator|=
name|NULL
expr_stmt|;
block|}
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|includes
argument_list|,
name|nf
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * ParsePopInput  *	Called when EOF is reached in the current file. If we were reading  *	an include file, the includes stack is popped and things set up  *	to go back to reading the previous file at the previous location.  *  * Results:  *	CONTINUE if there's more to do. DONE if not.  *  * Side Effects:  *	The old curFile.F is closed. The includes list is shortened.  *	curFile.lineno, curFile.F, and curFile.fname are changed if  *	CONTINUE is returned.  */
end_comment

begin_function
specifier|static
name|int
name|ParsePopInput
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|IFile
modifier|*
name|ifile
decl_stmt|;
comment|/* the state on the top of the includes stack */
name|assert
argument_list|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|includes
argument_list|)
argument_list|)
expr_stmt|;
name|ifile
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|includes
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|includes
argument_list|,
name|ifile
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ifile
operator|->
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifile
operator|->
name|F
operator|!=
name|NULL
condition|)
block|{
name|fclose
argument_list|(
name|ifile
operator|->
name|F
argument_list|)
expr_stmt|;
name|Var_Append
argument_list|(
literal|".MAKEFILE_LIST"
argument_list|,
literal|".."
argument_list|,
name|VAR_GLOBAL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ifile
operator|->
name|str
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|ifile
operator|->
name|str
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|ifile
argument_list|)
expr_stmt|;
return|return
operator|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|includes
argument_list|)
condition|?
name|DONE
else|:
name|CONTINUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * parse_warn  *	Parse the .WARN pseudo-target.  */
end_comment

begin_function
specifier|static
name|void
name|parse_warn
parameter_list|(
name|char
modifier|*
name|line
parameter_list|)
block|{
name|ArgArray
name|aa
decl_stmt|;
name|int
name|i
decl_stmt|;
name|brk_string
argument_list|(
operator|&
name|aa
argument_list|,
name|line
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|aa
operator|.
name|argc
condition|;
name|i
operator|++
control|)
name|Main_ParseWarn
argument_list|(
name|aa
operator|.
name|argv
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-  *---------------------------------------------------------------------  * ParseLinkSrc  --  *	Link the parent nodes to their new child. Used by  *	ParseDoDependency. If the specType isn't 'Not', the parent  *	isn't linked as a parent of the child.  *  * Side Effects:  *	New elements are added to the parents lists of cgn and the  *	children list of cgn. the unmade field of pgn is updated  *	to reflect the additional child.  *---------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|ParseLinkSrc
parameter_list|(
name|Lst
modifier|*
name|parents
parameter_list|,
name|GNode
modifier|*
name|cgn
parameter_list|)
block|{
name|LstNode
modifier|*
name|ln
decl_stmt|;
name|GNode
modifier|*
name|pgn
decl_stmt|;
name|LST_FOREACH
argument_list|(
argument|ln
argument_list|,
argument|parents
argument_list|)
block|{
name|pgn
operator|=
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
expr_stmt|;
if|if
condition|(
name|Lst_Member
argument_list|(
operator|&
name|pgn
operator|->
name|children
argument_list|,
name|cgn
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|Lst_AtEnd
argument_list|(
operator|&
name|pgn
operator|->
name|children
argument_list|,
name|cgn
argument_list|)
expr_stmt|;
if|if
condition|(
name|specType
operator|==
name|Not
condition|)
block|{
name|Lst_AtEnd
argument_list|(
operator|&
name|cgn
operator|->
name|parents
argument_list|,
name|pgn
argument_list|)
expr_stmt|;
block|}
name|pgn
operator|->
name|unmade
operator|+=
literal|1
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*-  *---------------------------------------------------------------------  * ParseDoOp  --  *	Apply the parsed operator to all target nodes. Used in  *	ParseDoDependency once all targets have been found and their  *	operator parsed. If the previous and new operators are incompatible,  *	a major error is taken.  *  * Side Effects:  *	The type field of the node is altered to reflect any new bits in  *	the op.  *---------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|ParseDoOp
parameter_list|(
name|int
name|op
parameter_list|)
block|{
name|GNode
modifier|*
name|cohort
decl_stmt|;
name|LstNode
modifier|*
name|ln
decl_stmt|;
name|GNode
modifier|*
name|gn
decl_stmt|;
name|LST_FOREACH
argument_list|(
argument|ln
argument_list|,
argument|&targets
argument_list|)
block|{
name|gn
operator|=
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
expr_stmt|;
comment|/* 		 * If the dependency mask of the operator and the node don't 		 * match and the node has actually had an operator applied to 		 * it before, and the operator actually has some dependency 		 * information in it, complain. 		 */
if|if
condition|(
operator|(
name|op
operator|&
name|OP_OPMASK
operator|)
operator|!=
operator|(
name|gn
operator|->
name|type
operator|&
name|OP_OPMASK
operator|)
operator|&&
operator|!
name|OP_NOP
argument_list|(
name|gn
operator|->
name|type
argument_list|)
operator|&&
operator|!
name|OP_NOP
argument_list|(
name|op
argument_list|)
condition|)
block|{
name|Parse_Error
argument_list|(
name|PARSE_FATAL
argument_list|,
literal|"Inconsistent operator for %s"
argument_list|,
name|gn
operator|->
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|op
operator|==
name|OP_DOUBLEDEP
operator|&&
operator|(
name|gn
operator|->
name|type
operator|&
name|OP_OPMASK
operator|)
operator|==
name|OP_DOUBLEDEP
condition|)
block|{
comment|/* 			 * If the node was the object of a :: operator, we need 			 * to create a new instance of it for the children and 			 * commands on this dependency line. The new instance 			 * is placed on the 'cohorts' list of the initial one 			 * (note the initial one is not on its own cohorts list) 			 * and the new instance is linked to all parents of the 			 * initial instance. 			 */
name|cohort
operator|=
name|Targ_NewGN
argument_list|(
name|gn
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* 			 * Duplicate links to parents so graph traversal is 			 * simple. Perhaps some type bits should be duplicated? 			 * 			 * Make the cohort invisible as well to avoid 			 * duplicating it into other variables. True, parents 			 * of this target won't tend to do anything with their 			 * local variables, but better safe than sorry. 			 */
name|ParseLinkSrc
argument_list|(
operator|&
name|gn
operator|->
name|parents
argument_list|,
name|cohort
argument_list|)
expr_stmt|;
name|cohort
operator|->
name|type
operator|=
name|OP_DOUBLEDEP
operator||
name|OP_INVISIBLE
expr_stmt|;
name|Lst_AtEnd
argument_list|(
operator|&
name|gn
operator|->
name|cohorts
argument_list|,
name|cohort
argument_list|)
expr_stmt|;
comment|/* 			 * Replace the node in the targets list with the 			 * new copy 			 */
name|Lst_Replace
argument_list|(
name|ln
argument_list|,
name|cohort
argument_list|)
expr_stmt|;
name|gn
operator|=
name|cohort
expr_stmt|;
block|}
comment|/* 		 * We don't want to nuke any previous flags (whatever they were) 		 * so we just OR the new operator into the old 		 */
name|gn
operator|->
name|type
operator||=
name|op
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*-  *---------------------------------------------------------------------  * ParseDoSrc  --  *	Given the name of a source, figure out if it is an attribute  *	and apply it to the targets if it is. Else decide if there is  *	some attribute which should be applied *to* the source because  *	of some special target and apply it if so. Otherwise, make the  *	source be a child of the targets in the list 'targets'  *  * Results:  *	None  *  * Side Effects:  *	Operator bits may be added to the list of targets or to the source.  *	The targets may have a new source added to their lists of children.  *---------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|ParseDoSrc
parameter_list|(
name|int
name|tOp
parameter_list|,
name|char
modifier|*
name|src
parameter_list|,
name|Lst
modifier|*
name|allsrc
parameter_list|)
block|{
name|GNode
modifier|*
name|gn
init|=
name|NULL
decl_stmt|;
specifier|const
name|struct
name|keyword
modifier|*
name|kw
decl_stmt|;
if|if
condition|(
name|src
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|isupper
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|src
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|kw
operator|=
name|ParseFindKeyword
argument_list|(
name|src
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|kw
operator|->
name|op
operator|!=
literal|0
condition|)
block|{
name|ParseDoOp
argument_list|(
name|kw
operator|->
name|op
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|kw
operator|->
name|spec
operator|==
name|Wait
condition|)
block|{
name|waiting
operator|++
expr_stmt|;
return|return;
block|}
block|}
block|}
switch|switch
condition|(
name|specType
condition|)
block|{
case|case
name|Main
case|:
comment|/* 		 * If we have noted the existence of a .MAIN, it means we need 		 * to add the sources of said target to the list of things 		 * to create. The string 'src' is likely to be free, so we 		 * must make a new copy of it. Note that this will only be 		 * invoked if the user didn't specify a target on the command 		 * line. This is to allow #ifmake's to succeed, or something... 		 */
name|Lst_AtEnd
argument_list|(
operator|&
name|create
argument_list|,
name|estrdup
argument_list|(
name|src
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * Add the name to the .TARGETS variable as well, so the user 		 * can employ that, if desired. 		 */
name|Var_Append
argument_list|(
literal|".TARGETS"
argument_list|,
name|src
argument_list|,
name|VAR_GLOBAL
argument_list|)
expr_stmt|;
return|return;
case|case
name|Order
case|:
comment|/* 		 * Create proper predecessor/successor links between the 		 * previous source and the current one. 		 */
name|gn
operator|=
name|Targ_FindNode
argument_list|(
name|src
argument_list|,
name|TARG_CREATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|predecessor
operator|!=
name|NULL
condition|)
block|{
name|Lst_AtEnd
argument_list|(
operator|&
name|predecessor
operator|->
name|successors
argument_list|,
name|gn
argument_list|)
expr_stmt|;
name|Lst_AtEnd
argument_list|(
operator|&
name|gn
operator|->
name|preds
argument_list|,
name|predecessor
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * The current source now becomes the predecessor for the next 		 * one. 		 */
name|predecessor
operator|=
name|gn
expr_stmt|;
break|break;
default|default:
comment|/* 		 * If the source is not an attribute, we need to find/create 		 * a node for it. After that we can apply any operator to it 		 * from a special target or link it to its parents, as 		 * appropriate. 		 * 		 * In the case of a source that was the object of a :: operator, 		 * the attribute is applied to all of its instances (as kept in 		 * the 'cohorts' list of the node) or all the cohorts are linked 		 * to all the targets. 		 */
name|gn
operator|=
name|Targ_FindNode
argument_list|(
name|src
argument_list|,
name|TARG_CREATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|tOp
condition|)
block|{
name|gn
operator|->
name|type
operator||=
name|tOp
expr_stmt|;
block|}
else|else
block|{
name|ParseLinkSrc
argument_list|(
operator|&
name|targets
argument_list|,
name|gn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|gn
operator|->
name|type
operator|&
name|OP_OPMASK
operator|)
operator|==
name|OP_DOUBLEDEP
condition|)
block|{
name|GNode
modifier|*
name|cohort
decl_stmt|;
name|LstNode
modifier|*
name|ln
decl_stmt|;
for|for
control|(
name|ln
operator|=
name|Lst_First
argument_list|(
operator|&
name|gn
operator|->
name|cohorts
argument_list|)
init|;
name|ln
operator|!=
name|NULL
condition|;
name|ln
operator|=
name|Lst_Succ
argument_list|(
name|ln
argument_list|)
control|)
block|{
name|cohort
operator|=
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
expr_stmt|;
if|if
condition|(
name|tOp
condition|)
block|{
name|cohort
operator|->
name|type
operator||=
name|tOp
expr_stmt|;
block|}
else|else
block|{
name|ParseLinkSrc
argument_list|(
operator|&
name|targets
argument_list|,
name|cohort
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
block|}
name|gn
operator|->
name|order
operator|=
name|waiting
expr_stmt|;
name|Lst_AtEnd
argument_list|(
name|allsrc
argument_list|,
name|gn
argument_list|)
expr_stmt|;
if|if
condition|(
name|waiting
condition|)
block|{
name|LstNode
modifier|*
name|ln
decl_stmt|;
name|GNode
modifier|*
name|p
decl_stmt|;
comment|/* 		 * Check if GNodes needs to be synchronized. 		 * This has to be when two nodes are on different sides of a 		 * .WAIT directive. 		 */
name|LST_FOREACH
argument_list|(
argument|ln
argument_list|,
argument|allsrc
argument_list|)
block|{
name|p
operator|=
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|order
operator|>=
name|gn
operator|->
name|order
condition|)
break|break;
comment|/* 			 * XXX: This can cause loops, and loops can cause 			 * unmade targets, but checking is tedious, and the 			 * debugging output can show the problem 			 */
name|Lst_AtEnd
argument_list|(
operator|&
name|p
operator|->
name|successors
argument_list|,
name|gn
argument_list|)
expr_stmt|;
name|Lst_AtEnd
argument_list|(
operator|&
name|gn
operator|->
name|preds
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*-  *---------------------------------------------------------------------  * ParseDoDependency  --  *	Parse the dependency line in line.  *  * Results:  *	None  *  * Side Effects:  *	The nodes of the sources are linked as children to the nodes of the  *	targets. Some nodes may be created.  *  *	We parse a dependency line by first extracting words from the line and  * finding nodes in the list of all targets with that name. This is done  * until a character is encountered which is an operator character. Currently  * these are only ! and :. At this point the operator is parsed and the  * pointer into the line advanced until the first source is encountered.  *	The parsed operator is applied to each node in the 'targets' list,  * which is where the nodes found for the targets are kept, by means of  * the ParseDoOp function.  *	The sources are read in much the same way as the targets were except  * that now they are expanded using the wildcarding scheme of the C-Shell  * and all instances of the resulting words in the list of all targets  * are found. Each of the resulting nodes is then linked to each of the  * targets as one of its children.  *	Certain targets are handled specially. These are the ones detailed  * by the specType variable.  *	The storing of transformation rules is also taken care of here.  * A target is recognized as a transformation rule by calling  * Suff_IsTransform. If it is a transformation rule, its node is gotten  * from the suffix module via Suff_AddTransform rather than the standard  * Targ_FindNode in the target module.  *---------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|ParseDoDependency
parameter_list|(
name|char
modifier|*
name|line
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* our current position */
name|GNode
modifier|*
name|gn
decl_stmt|;
comment|/* a general purpose temporary node */
name|int
name|op
decl_stmt|;
comment|/* the operator on the line */
name|char
name|savec
decl_stmt|;
comment|/* a place to save a character */
name|Lst
name|paths
decl_stmt|;
comment|/* Search paths to alter when parsing .PATH targets */
name|int
name|tOp
decl_stmt|;
comment|/* operator from special target */
name|LstNode
modifier|*
name|ln
decl_stmt|;
specifier|const
name|struct
name|keyword
modifier|*
name|kw
decl_stmt|;
name|tOp
operator|=
literal|0
expr_stmt|;
name|specType
operator|=
name|Not
expr_stmt|;
name|waiting
operator|=
literal|0
expr_stmt|;
name|Lst_Init
argument_list|(
operator|&
name|paths
argument_list|)
expr_stmt|;
do|do
block|{
for|for
control|(
name|cp
operator|=
name|line
init|;
operator|*
name|cp
operator|&&
operator|!
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cp
argument_list|)
operator|&&
operator|*
name|cp
operator|!=
literal|'('
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'$'
condition|)
block|{
comment|/* 				 * Must be a dynamic source (would have been 				 * expanded otherwise), so call the Var module 				 * to parse the puppy so we can safely advance 				 * beyond it...There should be no errors in this 				 * as they would have been discovered in the 				 * initial Var_Subst and we wouldn't be here. 				 */
name|size_t
name|length
init|=
literal|0
decl_stmt|;
name|Boolean
name|freeIt
decl_stmt|;
name|char
modifier|*
name|result
decl_stmt|;
name|result
operator|=
name|Var_Parse
argument_list|(
name|cp
argument_list|,
name|VAR_CMD
argument_list|,
name|TRUE
argument_list|,
operator|&
name|length
argument_list|,
operator|&
name|freeIt
argument_list|)
expr_stmt|;
if|if
condition|(
name|freeIt
condition|)
block|{
name|free
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
name|cp
operator|+=
name|length
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|cp
operator|==
literal|'!'
operator|||
operator|*
name|cp
operator|==
literal|':'
condition|)
block|{
comment|/* 				 * We don't want to end a word on ':' or '!' if 				 * there is a better match later on in the 				 * string (greedy matching). 				 * This allows the user to have targets like: 				 *    fie::fi:fo: fum 				 *    foo::bar: 				 * where "fie::fi:fo" and "foo::bar" are the 				 * targets. In real life this is used for perl5 				 * library man pages where "::" separates an 				 * object from its class. Ie: 				 * "File::Spec::Unix". This behaviour is also 				 * consistent with other versions of make. 				 */
name|char
modifier|*
name|p
init|=
name|cp
operator|+
literal|1
decl_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|':'
operator|&&
operator|*
name|p
operator|==
literal|':'
condition|)
name|p
operator|++
expr_stmt|;
comment|/* Found the best match already. */
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
operator|||
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
break|break;
name|p
operator|+=
name|strcspn
argument_list|(
name|p
argument_list|,
literal|"!:"
argument_list|)
expr_stmt|;
comment|/* No better match later on... */
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
break|break;
block|}
continue|continue;
block|}
if|if
condition|(
operator|*
name|cp
operator|==
literal|'('
condition|)
block|{
comment|/* 			 * Archives must be handled specially to make sure the 			 * OP_ARCHV flag is set in their 'type' field, for one 			 * thing, and because things like "archive(file1.o 			 * file2.o file3.o)" are permissible. Arch_ParseArchive 			 * will set 'line' to be the first non-blank after the 			 * archive-spec. It creates/finds nodes for the members 			 * and places them on the given list, returning TRUE 			 * if all went well and FALSE if there was an error in 			 * the specification. On error, line should remain 			 * untouched. 			 */
if|if
condition|(
operator|!
name|Arch_ParseArchive
argument_list|(
operator|&
name|line
argument_list|,
operator|&
name|targets
argument_list|,
name|VAR_CMD
argument_list|)
condition|)
block|{
name|Parse_Error
argument_list|(
name|PARSE_FATAL
argument_list|,
literal|"Error in archive specification: \"%s\""
argument_list|,
name|line
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|cp
operator|=
name|line
expr_stmt|;
continue|continue;
block|}
block|}
name|savec
operator|=
operator|*
name|cp
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|cp
condition|)
block|{
comment|/* 			 * Ending a dependency line without an operator is a				 * Bozo no-no. As a heuristic, this is also often 			 * triggered by undetected conflicts from cvs/rcs 			 * merges. 			 */
if|if
condition|(
name|strncmp
argument_list|(
name|line
argument_list|,
literal|"<<<<<<"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|line
argument_list|,
literal|"======"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|line
argument_list|,
literal|">>>>>>"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
block|{
name|Parse_Error
argument_list|(
name|PARSE_FATAL
argument_list|,
literal|"Makefile appears to "
literal|"contain unresolved cvs/rcs/??? merge "
literal|"conflicts"
argument_list|)
expr_stmt|;
block|}
else|else
name|Parse_Error
argument_list|(
name|PARSE_FATAL
argument_list|,
literal|"Need an operator"
argument_list|)
expr_stmt|;
return|return;
block|}
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
comment|/* 		 * Have a word in line. See if it's a special target and set 		 * specType to match it. 		 */
if|if
condition|(
operator|*
name|line
operator|==
literal|'.'
operator|&&
name|isupper
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|line
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
comment|/* 			 * See if the target is a special target that must have 			 * it or its sources handled specially. 			 */
if|if
condition|(
operator|(
name|kw
operator|=
name|ParseFindKeyword
argument_list|(
name|line
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|specType
operator|==
name|ExPath
operator|&&
name|kw
operator|->
name|spec
operator|!=
name|ExPath
condition|)
block|{
name|Parse_Error
argument_list|(
name|PARSE_FATAL
argument_list|,
literal|"Mismatched special targets"
argument_list|)
expr_stmt|;
return|return;
block|}
name|specType
operator|=
name|kw
operator|->
name|spec
expr_stmt|;
name|tOp
operator|=
name|kw
operator|->
name|op
expr_stmt|;
comment|/* 				 * Certain special targets have special 				 * semantics: 				 *  .PATH	Have to set the dirSearchPath 				 *		variable too 				 *  .MAIN	Its sources are only used if 				 *		nothing has been specified to 				 *		create. 				 *  .DEFAULT    Need to create a node to hang 				 *		commands on, but we don't want 				 *		it in the graph, nor do we want 				 *		it to be the Main Target, so we 				 *		create it, set OP_NOTMAIN and 				 *		add it to the list, setting 				 *		DEFAULT to the new node for 				 *		later use. We claim the node is 				 *		A transformation rule to make 				 *		life easier later, when we'll 				 *		use Make_HandleUse to actually 				 *		apply the .DEFAULT commands. 				 *  .PHONY	The list of targets 				 *  .BEGIN 				 *  .END 				 *  .INTERRUPT	Are not to be considered the 				 *		main target. 				 *  .NOTPARALLEL Make only one target at a time. 				 *  .SINGLESHELL Create a shell for each 				 *		command. 				 *  .ORDER	Must set initial predecessor 				 *		to NULL 				 */
switch|switch
condition|(
name|specType
condition|)
block|{
case|case
name|ExPath
case|:
name|Lst_AtEnd
argument_list|(
operator|&
name|paths
argument_list|,
operator|&
name|dirSearchPath
argument_list|)
expr_stmt|;
break|break;
case|case
name|Main
case|:
if|if
condition|(
operator|!
name|Lst_IsEmpty
argument_list|(
operator|&
name|create
argument_list|)
condition|)
block|{
name|specType
operator|=
name|Not
expr_stmt|;
block|}
break|break;
case|case
name|Begin
case|:
case|case
name|End
case|:
case|case
name|Interrupt
case|:
name|gn
operator|=
name|Targ_FindNode
argument_list|(
name|line
argument_list|,
name|TARG_CREATE
argument_list|)
expr_stmt|;
name|gn
operator|->
name|type
operator||=
name|OP_NOTMAIN
expr_stmt|;
name|Lst_AtEnd
argument_list|(
operator|&
name|targets
argument_list|,
name|gn
argument_list|)
expr_stmt|;
break|break;
case|case
name|Default
case|:
name|gn
operator|=
name|Targ_NewGN
argument_list|(
literal|".DEFAULT"
argument_list|)
expr_stmt|;
name|gn
operator|->
name|type
operator||=
operator|(
name|OP_NOTMAIN
operator||
name|OP_TRANSFORM
operator|)
expr_stmt|;
name|Lst_AtEnd
argument_list|(
operator|&
name|targets
argument_list|,
name|gn
argument_list|)
expr_stmt|;
name|DEFAULT
operator|=
name|gn
expr_stmt|;
break|break;
case|case
name|NotParallel
case|:
name|jobLimit
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|SingleShell
case|:
name|compatMake
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|Order
case|:
name|predecessor
operator|=
name|NULL
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|line
argument_list|,
literal|".PATH"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 				 * .PATH<suffix> has to be handled specially. 				 * Call on the suffix module to give us a path 				 * to modify. 				 */
name|struct
name|Path
modifier|*
name|path
decl_stmt|;
name|specType
operator|=
name|ExPath
expr_stmt|;
name|path
operator|=
name|Suff_GetPath
argument_list|(
operator|&
name|line
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
operator|==
name|NULL
condition|)
block|{
name|Parse_Error
argument_list|(
name|PARSE_FATAL
argument_list|,
literal|"Suffix '%s' "
literal|"not defined (yet)"
argument_list|,
operator|&
name|line
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
name|Lst_AtEnd
argument_list|(
operator|&
name|paths
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 		 * Have word in line. Get or create its node and stick it at 		 * the end of the targets list 		 */
if|if
condition|(
name|specType
operator|==
name|Not
operator|&&
operator|*
name|line
operator|!=
literal|'\0'
condition|)
block|{
comment|/* target names to be found and added to targets list */
name|Lst
name|curTargs
init|=
name|Lst_Initializer
argument_list|(
name|curTargs
argument_list|)
decl_stmt|;
if|if
condition|(
name|Dir_HasWildcards
argument_list|(
name|line
argument_list|)
condition|)
block|{
comment|/* 				 * Targets are to be sought only in the current 				 * directory, so create an empty path for the 				 * thing. Note we need to use Path_Clear in the 				 * destruction of the path as the Dir module 				 * could have added a directory to the path... 				 */
name|struct
name|Path
name|emptyPath
init|=
name|TAILQ_HEAD_INITIALIZER
argument_list|(
name|emptyPath
argument_list|)
decl_stmt|;
name|Path_Expand
argument_list|(
name|line
argument_list|,
operator|&
name|emptyPath
argument_list|,
operator|&
name|curTargs
argument_list|)
expr_stmt|;
name|Path_Clear
argument_list|(
operator|&
name|emptyPath
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * No wildcards, but we want to avoid code 				 * duplication, so create a list with the word 				 * on it. 				 */
name|Lst_AtEnd
argument_list|(
operator|&
name|curTargs
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|!
name|Lst_IsEmpty
argument_list|(
operator|&
name|curTargs
argument_list|)
condition|)
block|{
name|char
modifier|*
name|targName
init|=
name|Lst_DeQueue
argument_list|(
operator|&
name|curTargs
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|Suff_IsTransform
argument_list|(
name|targName
argument_list|)
condition|)
block|{
name|gn
operator|=
name|Targ_FindNode
argument_list|(
name|targName
argument_list|,
name|TARG_CREATE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gn
operator|=
name|Suff_AddTransform
argument_list|(
name|targName
argument_list|)
expr_stmt|;
block|}
name|Lst_AtEnd
argument_list|(
operator|&
name|targets
argument_list|,
name|gn
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|specType
operator|==
name|ExPath
operator|&&
operator|*
name|line
operator|!=
literal|'.'
operator|&&
operator|*
name|line
operator|!=
literal|'\0'
condition|)
block|{
name|Parse_Error
argument_list|(
name|PARSE_WARNING
argument_list|,
literal|"Extra target (%s) ignored"
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
operator|*
name|cp
operator|=
name|savec
expr_stmt|;
comment|/* 		 * If it is a special type and not .PATH, it's the only 		 * target we allow on this line... 		 */
if|if
condition|(
name|specType
operator|!=
name|Not
operator|&&
name|specType
operator|!=
name|ExPath
condition|)
block|{
name|Boolean
name|warnFlag
init|=
name|FALSE
decl_stmt|;
while|while
condition|(
operator|*
name|cp
operator|!=
literal|'!'
operator|&&
operator|*
name|cp
operator|!=
literal|':'
operator|&&
operator|*
name|cp
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|!=
literal|' '
operator|&&
operator|*
name|cp
operator|!=
literal|'\t'
condition|)
block|{
name|warnFlag
operator|=
name|TRUE
expr_stmt|;
block|}
name|cp
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|warnFlag
condition|)
block|{
name|Parse_Error
argument_list|(
name|PARSE_WARNING
argument_list|,
literal|"Extra target ignored"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
while|while
condition|(
operator|*
name|cp
operator|&&
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cp
argument_list|)
condition|)
block|{
name|cp
operator|++
expr_stmt|;
block|}
block|}
name|line
operator|=
name|cp
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|line
operator|!=
literal|'!'
operator|&&
operator|*
name|line
operator|!=
literal|':'
operator|&&
operator|*
name|line
condition|)
do|;
if|if
condition|(
operator|!
name|Lst_IsEmpty
argument_list|(
operator|&
name|targets
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|specType
condition|)
block|{
default|default:
name|Parse_Error
argument_list|(
name|PARSE_WARNING
argument_list|,
literal|"Special and mundane "
literal|"targets don't mix. Mundane ones ignored"
argument_list|)
expr_stmt|;
break|break;
case|case
name|Default
case|:
case|case
name|Begin
case|:
case|case
name|End
case|:
case|case
name|Interrupt
case|:
comment|/* 			 * These four create nodes on which to hang commands, so 			 * targets shouldn't be empty... 			 */
case|case
name|Not
case|:
comment|/* 			 * Nothing special here -- targets can be empty if it 			 * wants. 			 */
break|break;
block|}
block|}
comment|/* 	 * Have now parsed all the target names. Must parse the operator next. 	 * The result is left in op. 	 */
if|if
condition|(
operator|*
name|cp
operator|==
literal|'!'
condition|)
block|{
name|op
operator|=
name|OP_FORCE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|cp
operator|==
literal|':'
condition|)
block|{
if|if
condition|(
name|cp
index|[
literal|1
index|]
operator|==
literal|':'
condition|)
block|{
name|op
operator|=
name|OP_DOUBLEDEP
expr_stmt|;
name|cp
operator|++
expr_stmt|;
block|}
else|else
block|{
name|op
operator|=
name|OP_DEPENDS
expr_stmt|;
block|}
block|}
else|else
block|{
name|Parse_Error
argument_list|(
name|PARSE_FATAL
argument_list|,
literal|"Missing dependency operator"
argument_list|)
expr_stmt|;
return|return;
block|}
name|cp
operator|++
expr_stmt|;
comment|/* Advance beyond operator */
name|ParseDoOp
argument_list|(
name|op
argument_list|)
expr_stmt|;
comment|/* 	 * Get to the first source 	 */
while|while
condition|(
operator|*
name|cp
operator|&&
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cp
argument_list|)
condition|)
block|{
name|cp
operator|++
expr_stmt|;
block|}
name|line
operator|=
name|cp
expr_stmt|;
comment|/* 	 * Several special targets take different actions if present with no 	 * sources: 	 *	a .SUFFIXES line with no sources clears out all old suffixes 	 *	a .PRECIOUS line makes all targets precious 	 *	a .IGNORE line ignores errors for all targets 	 *	a .SILENT line creates silence when making all targets 	 *	a .PATH removes all directories from the search path(s). 	 */
if|if
condition|(
operator|!
operator|*
name|line
condition|)
block|{
switch|switch
condition|(
name|specType
condition|)
block|{
case|case
name|Suffixes
case|:
name|Suff_ClearSuffixes
argument_list|()
expr_stmt|;
break|break;
case|case
name|Precious
case|:
name|allPrecious
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|Ignore
case|:
name|ignoreErrors
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|Silent
case|:
name|beSilent
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|ExPath
case|:
name|LST_FOREACH
argument_list|(
argument|ln
argument_list|,
argument|&paths
argument_list|)
name|Path_Clear
argument_list|(
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|Posix
case|:
name|is_posix
operator|=
name|TRUE
expr_stmt|;
name|Var_Set
argument_list|(
literal|"%POSIX"
argument_list|,
literal|"1003.2"
argument_list|,
name|VAR_GLOBAL
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|specType
operator|==
name|MFlags
condition|)
block|{
comment|/* 		 * Call on functions in main.c to deal with these arguments and 		 * set the initial character to a null-character so the loop to 		 * get sources won't get anything 		 */
name|Main_ParseArgLine
argument_list|(
name|line
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|line
operator|=
literal|'\0'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|specType
operator|==
name|Warn
condition|)
block|{
name|parse_warn
argument_list|(
name|line
argument_list|)
expr_stmt|;
operator|*
name|line
operator|=
literal|'\0'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|specType
operator|==
name|ExShell
condition|)
block|{
if|if
condition|(
operator|!
name|Shell_Parse
argument_list|(
name|line
argument_list|)
condition|)
block|{
name|Parse_Error
argument_list|(
name|PARSE_FATAL
argument_list|,
literal|"improper shell specification"
argument_list|)
expr_stmt|;
return|return;
block|}
operator|*
name|line
operator|=
literal|'\0'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|specType
operator|==
name|NotParallel
operator|||
name|specType
operator|==
name|SingleShell
condition|)
block|{
operator|*
name|line
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/* 	* NOW GO FOR THE SOURCES 	*/
if|if
condition|(
name|specType
operator|==
name|Suffixes
operator|||
name|specType
operator|==
name|ExPath
operator|||
name|specType
operator|==
name|Includes
operator|||
name|specType
operator|==
name|Libs
operator|||
name|specType
operator|==
name|Null
condition|)
block|{
while|while
condition|(
operator|*
name|line
condition|)
block|{
comment|/* 			 * If the target was one that doesn't take files as its 			 * sources but takes something like suffixes, we take 			 * each space-separated word on the line as a something 			 * and deal with it accordingly. 			 * 			 * If the target was .SUFFIXES, we take each source as 			 * a suffix and add it to the list of suffixes 			 * maintained by the Suff module. 			 * 			 * If the target was a .PATH, we add the source as a 			 * directory to search on the search path. 			 * 			 * If it was .INCLUDES, the source is taken to be the 			 * suffix of files which will be #included and whose 			 * search path should be present in the .INCLUDES 			 * variable. 			 * 			 * If it was .LIBS, the source is taken to be the 			 * suffix of files which are considered libraries and 			 * whose search path should be present in the .LIBS 			 * variable. 			 * 			 * If it was .NULL, the source is the suffix to use 			 * when a file has no valid suffix. 			 */
name|char
name|savech
decl_stmt|;
while|while
condition|(
operator|*
name|cp
operator|&&
operator|!
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cp
argument_list|)
condition|)
block|{
name|cp
operator|++
expr_stmt|;
block|}
name|savech
operator|=
operator|*
name|cp
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
switch|switch
condition|(
name|specType
condition|)
block|{
case|case
name|Suffixes
case|:
name|Suff_AddSuffix
argument_list|(
name|line
argument_list|)
expr_stmt|;
break|break;
case|case
name|ExPath
case|:
name|LST_FOREACH
argument_list|(
argument|ln
argument_list|,
argument|&paths
argument_list|)
name|Path_AddDir
argument_list|(
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
argument_list|,
name|line
argument_list|)
expr_stmt|;
break|break;
case|case
name|Includes
case|:
name|Suff_AddInclude
argument_list|(
name|line
argument_list|)
expr_stmt|;
break|break;
case|case
name|Libs
case|:
name|Suff_AddLib
argument_list|(
name|line
argument_list|)
expr_stmt|;
break|break;
case|case
name|Null
case|:
name|Suff_SetNull
argument_list|(
name|line
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
operator|*
name|cp
operator|=
name|savech
expr_stmt|;
if|if
condition|(
name|savech
operator|!=
literal|'\0'
condition|)
block|{
name|cp
operator|++
expr_stmt|;
block|}
while|while
condition|(
operator|*
name|cp
operator|&&
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cp
argument_list|)
condition|)
block|{
name|cp
operator|++
expr_stmt|;
block|}
name|line
operator|=
name|cp
expr_stmt|;
block|}
name|Lst_Destroy
argument_list|(
operator|&
name|paths
argument_list|,
name|NOFREE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|specType
operator|==
name|ExportVar
condition|)
block|{
name|Var_SetEnv
argument_list|(
name|line
argument_list|,
name|VAR_GLOBAL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* list of sources in order */
name|Lst
name|curSrcs
init|=
name|Lst_Initializer
argument_list|(
name|curSrc
argument_list|)
decl_stmt|;
while|while
condition|(
operator|*
name|line
condition|)
block|{
comment|/* 			 * The targets take real sources, so we must beware of 			 * archive specifications (i.e. things with left 			 * parentheses in them) and handle them accordingly. 			 */
while|while
condition|(
operator|*
name|cp
operator|&&
operator|!
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cp
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'('
operator|&&
name|cp
operator|>
name|line
operator|&&
name|cp
index|[
operator|-
literal|1
index|]
operator|!=
literal|'$'
condition|)
block|{
comment|/* 					 * Only stop for a left parenthesis if 					 * it isn't at the start of a word 					 * (that'll be for variable changes 					 * later) and isn't preceded by a dollar 					 * sign (a dynamic source). 					 */
break|break;
block|}
else|else
block|{
name|cp
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|*
name|cp
operator|==
literal|'('
condition|)
block|{
name|GNode
modifier|*
name|gnp
decl_stmt|;
comment|/* list of archive source names after exp. */
name|Lst
name|sources
init|=
name|Lst_Initializer
argument_list|(
name|sources
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|Arch_ParseArchive
argument_list|(
operator|&
name|line
argument_list|,
operator|&
name|sources
argument_list|,
name|VAR_CMD
argument_list|)
condition|)
block|{
name|Parse_Error
argument_list|(
name|PARSE_FATAL
argument_list|,
literal|"Error in "
literal|"source archive spec \"%s\""
argument_list|,
name|line
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
operator|!
name|Lst_IsEmpty
argument_list|(
operator|&
name|sources
argument_list|)
condition|)
block|{
name|gnp
operator|=
name|Lst_DeQueue
argument_list|(
operator|&
name|sources
argument_list|)
expr_stmt|;
name|ParseDoSrc
argument_list|(
name|tOp
argument_list|,
name|gnp
operator|->
name|name
argument_list|,
operator|&
name|curSrcs
argument_list|)
expr_stmt|;
block|}
name|cp
operator|=
name|line
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|cp
condition|)
block|{
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|cp
operator|+=
literal|1
expr_stmt|;
block|}
name|ParseDoSrc
argument_list|(
name|tOp
argument_list|,
name|line
argument_list|,
operator|&
name|curSrcs
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|*
name|cp
operator|&&
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cp
argument_list|)
condition|)
block|{
name|cp
operator|++
expr_stmt|;
block|}
name|line
operator|=
name|cp
expr_stmt|;
block|}
name|Lst_Destroy
argument_list|(
operator|&
name|curSrcs
argument_list|,
name|NOFREE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mainNode
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * If we have yet to decide on a main target to make, in the 		 * absence of any user input, we want the first target on 		 * the first dependency line that is actually a real target 		 * (i.e. isn't a .USE or .EXEC rule) to be made. 		 */
name|LST_FOREACH
argument_list|(
argument|ln
argument_list|,
argument|&targets
argument_list|)
block|{
name|gn
operator|=
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|gn
operator|->
name|type
operator|&
operator|(
name|OP_NOTMAIN
operator||
name|OP_USE
operator||
name|OP_EXEC
operator||
name|OP_TRANSFORM
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|mainNode
operator|=
name|gn
expr_stmt|;
name|Targ_SetMain
argument_list|(
name|gn
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*-  *---------------------------------------------------------------------  * Parse_IsVar  --  *	Return TRUE if the passed line is a variable assignment. A variable  *	assignment consists of a single word followed by optional whitespace  *	followed by either a += or an = operator.  *	This function is used both by the Parse_File function and main when  *	parsing the command-line arguments.  *  * Results:  *	TRUE if it is. FALSE if it ain't  *  * Side Effects:  *	none  *---------------------------------------------------------------------  */
end_comment

begin_function
name|Boolean
name|Parse_IsVar
parameter_list|(
name|char
modifier|*
name|line
parameter_list|)
block|{
name|Boolean
name|wasSpace
init|=
name|FALSE
decl_stmt|;
comment|/* set TRUE if found a space */
name|Boolean
name|haveName
init|=
name|FALSE
decl_stmt|;
comment|/* Set TRUE if have a variable name */
name|int
name|level
init|=
literal|0
decl_stmt|;
define|#
directive|define
name|ISEQOPERATOR
parameter_list|(
name|c
parameter_list|)
define|\
value|((c) == '+' || (c) == ':' || (c) == '?' || (c) == '!')
comment|/* 	 * Skip to variable name 	 */
for|for
control|(
init|;
operator|*
name|line
operator|==
literal|' '
operator|||
operator|*
name|line
operator|==
literal|'\t'
condition|;
name|line
operator|++
control|)
continue|continue;
for|for
control|(
init|;
operator|*
name|line
operator|!=
literal|'='
operator|||
name|level
operator|!=
literal|0
condition|;
name|line
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|line
condition|)
block|{
case|case
literal|'\0'
case|:
comment|/* 			 * end-of-line -- can't be a variable assignment. 			 */
return|return
operator|(
name|FALSE
operator|)
return|;
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
comment|/* 			 * there can be as much white space as desired so long 			 * as there is only one word before the operator 			*/
name|wasSpace
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'('
case|:
case|case
literal|'{'
case|:
name|level
operator|++
expr_stmt|;
break|break;
case|case
literal|'}'
case|:
case|case
literal|')'
case|:
name|level
operator|--
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|wasSpace
operator|&&
name|haveName
condition|)
block|{
if|if
condition|(
name|ISEQOPERATOR
argument_list|(
operator|*
name|line
argument_list|)
condition|)
block|{
comment|/* 					 * We must have a finished word 					 */
if|if
condition|(
name|level
operator|!=
literal|0
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* 					 * When an = operator [+?!:] is found, 					 * the next character must be an = or 					 * it ain't a valid assignment. 					 */
if|if
condition|(
name|line
index|[
literal|1
index|]
operator|==
literal|'='
condition|)
return|return
operator|(
name|haveName
operator|)
return|;
ifdef|#
directive|ifdef
name|SUNSHCMD
comment|/* 					 * This is a shell command 					 */
if|if
condition|(
name|strncmp
argument_list|(
name|line
argument_list|,
literal|":sh"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|haveName
operator|)
return|;
endif|#
directive|endif
block|}
comment|/* 				 * This is the start of another word, so not 				 * assignment. 				 */
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
else|else
block|{
name|haveName
operator|=
name|TRUE
expr_stmt|;
name|wasSpace
operator|=
name|FALSE
expr_stmt|;
block|}
break|break;
block|}
block|}
return|return
operator|(
name|haveName
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *---------------------------------------------------------------------  * Parse_DoVar  --  *	Take the variable assignment in the passed line and do it in the  *	global context.  *  *	Note: There is a lexical ambiguity with assignment modifier characters  *	in variable names. This routine interprets the character before the =  *	as a modifier. Therefore, an assignment like  *	    C++=/usr/bin/CC  *	is interpreted as "C+ +=" instead of "C++ =".  *  * Results:  *	none  *  * Side Effects:  *	the variable structure of the given variable name is altered in the  *	global context.  *---------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Parse_DoVar
parameter_list|(
name|char
modifier|*
name|line
parameter_list|,
name|GNode
modifier|*
name|ctxt
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* pointer into line */
enum|enum
block|{
name|VAR_SUBST
block|,
name|VAR_APPEND
block|,
name|VAR_SHELL
block|,
name|VAR_NORMAL
block|}
name|type
enum|;
comment|/* Type of assignment */
name|char
modifier|*
name|opc
decl_stmt|;
comment|/* ptr to operator character to 			 * null-terminate the variable name */
comment|/* 	 * Skip to variable name 	 */
while|while
condition|(
operator|*
name|line
operator|==
literal|' '
operator|||
operator|*
name|line
operator|==
literal|'\t'
condition|)
block|{
name|line
operator|++
expr_stmt|;
block|}
comment|/* 	 * Skip to operator character, nulling out whitespace as we go 	 */
for|for
control|(
name|cp
operator|=
name|line
operator|+
literal|1
init|;
operator|*
name|cp
operator|!=
literal|'='
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cp
argument_list|)
condition|)
block|{
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
name|opc
operator|=
name|cp
operator|-
literal|1
expr_stmt|;
comment|/* operator is the previous character */
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* nuke the = */
comment|/* 	 * Check operator type 	 */
switch|switch
condition|(
operator|*
name|opc
condition|)
block|{
case|case
literal|'+'
case|:
name|type
operator|=
name|VAR_APPEND
expr_stmt|;
operator|*
name|opc
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
comment|/* 		 * If the variable already has a value, we don't do anything. 		 */
operator|*
name|opc
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|Var_Exists
argument_list|(
name|line
argument_list|,
name|ctxt
argument_list|)
condition|)
block|{
return|return;
block|}
else|else
block|{
name|type
operator|=
name|VAR_NORMAL
expr_stmt|;
block|}
break|break;
case|case
literal|':'
case|:
name|type
operator|=
name|VAR_SUBST
expr_stmt|;
operator|*
name|opc
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
literal|'!'
case|:
name|type
operator|=
name|VAR_SHELL
expr_stmt|;
operator|*
name|opc
operator|=
literal|'\0'
expr_stmt|;
break|break;
default|default:
ifdef|#
directive|ifdef
name|SUNSHCMD
while|while
condition|(
operator|*
name|opc
operator|!=
literal|':'
condition|)
block|{
if|if
condition|(
name|opc
operator|==
name|line
condition|)
break|break;
else|else
operator|--
name|opc
expr_stmt|;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|opc
argument_list|,
literal|":sh"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|type
operator|=
name|VAR_SHELL
expr_stmt|;
operator|*
name|opc
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
name|type
operator|=
name|VAR_NORMAL
expr_stmt|;
break|break;
block|}
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cp
argument_list|)
condition|)
block|{
name|cp
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|==
name|VAR_APPEND
condition|)
block|{
name|Var_Append
argument_list|(
name|line
argument_list|,
name|cp
argument_list|,
name|ctxt
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|VAR_SUBST
condition|)
block|{
comment|/* 		 * Allow variables in the old value to be undefined, but leave 		 * their invocation alone -- this is done by forcing oldVars 		 * to be false. 		 * XXX: This can cause recursive variables, but that's not 		 * hard to do, and this allows someone to do something like 		 * 		 *  CFLAGS = $(.INCLUDES) 		 *  CFLAGS := -I.. $(CFLAGS) 		 * 		 * And not get an error. 		 */
name|Boolean
name|oldOldVars
init|=
name|oldVars
decl_stmt|;
name|oldVars
operator|=
name|FALSE
expr_stmt|;
comment|/* 		 * make sure that we set the variable the first time to nothing 		 * so that it gets substituted! 		 */
if|if
condition|(
operator|!
name|Var_Exists
argument_list|(
name|line
argument_list|,
name|ctxt
argument_list|)
condition|)
name|Var_Set
argument_list|(
name|line
argument_list|,
literal|""
argument_list|,
name|ctxt
argument_list|)
expr_stmt|;
name|cp
operator|=
name|Buf_Peel
argument_list|(
name|Var_Subst
argument_list|(
name|cp
argument_list|,
name|ctxt
argument_list|,
name|FALSE
argument_list|)
argument_list|)
expr_stmt|;
name|oldVars
operator|=
name|oldOldVars
expr_stmt|;
name|Var_Set
argument_list|(
name|line
argument_list|,
name|cp
argument_list|,
name|ctxt
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|VAR_SHELL
condition|)
block|{
comment|/* 		 * TRUE if the command needs to be freed, i.e. 		 * if any variable expansion was performed 		 */
name|Boolean
name|freeCmd
init|=
name|FALSE
decl_stmt|;
name|Buffer
modifier|*
name|buf
decl_stmt|;
specifier|const
name|char
modifier|*
name|error
decl_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|cp
argument_list|,
literal|'$'
argument_list|)
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * There's a dollar sign in the command, so perform 			 * variable expansion on the whole thing. The 			 * resulting string will need freeing when we're done, 			 * so set freeCmd to TRUE. 			 */
name|cp
operator|=
name|Buf_Peel
argument_list|(
name|Var_Subst
argument_list|(
name|cp
argument_list|,
name|VAR_CMD
argument_list|,
name|TRUE
argument_list|)
argument_list|)
expr_stmt|;
name|freeCmd
operator|=
name|TRUE
expr_stmt|;
block|}
name|buf
operator|=
name|Cmd_Exec
argument_list|(
name|cp
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
name|Var_Set
argument_list|(
name|line
argument_list|,
name|Buf_Data
argument_list|(
name|buf
argument_list|)
argument_list|,
name|ctxt
argument_list|)
expr_stmt|;
name|Buf_Destroy
argument_list|(
name|buf
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|Parse_Error
argument_list|(
name|PARSE_WARNING
argument_list|,
name|error
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|freeCmd
condition|)
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Normal assignment -- just do it. 		 */
name|Var_Set
argument_list|(
name|line
argument_list|,
name|cp
argument_list|,
name|ctxt
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * ParseHasCommands --  *	Callback procedure for Parse_File when destroying the list of  *	targets on the last dependency line. Marks a target as already  *	having commands if it does, to keep from having shell commands  *	on multiple dependency lines.  *  * Results:  *	None  *  * Side Effects:  *	OP_HAS_COMMANDS may be set for the target.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|ParseHasCommands
parameter_list|(
name|void
modifier|*
name|gnp
parameter_list|)
block|{
name|GNode
modifier|*
name|gn
init|=
name|gnp
decl_stmt|;
if|if
condition|(
operator|!
name|Lst_IsEmpty
argument_list|(
operator|&
name|gn
operator|->
name|commands
argument_list|)
condition|)
block|{
name|gn
operator|->
name|type
operator||=
name|OP_HAS_COMMANDS
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Parse_AddIncludeDir --  *	Add a directory to the path searched for included makefiles  *	bracketed by double-quotes. Used by functions in main.c  *  * Results:  *	None.  *  * Side Effects:  *	The directory is appended to the list.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Parse_AddIncludeDir
parameter_list|(
name|char
modifier|*
name|dir
parameter_list|)
block|{
name|Path_AddDir
argument_list|(
operator|&
name|parseIncPath
argument_list|,
name|dir
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-  *---------------------------------------------------------------------  * Parse_FromString  --  *	Start Parsing from the given string  *  * Results:  *	None  *  * Side Effects:  *	A structure is added to the includes Lst and readProc, curFile.lineno,  *	curFile.fname and curFile.F are altered for the new file  *---------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Parse_FromString
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|int
name|lineno
parameter_list|)
block|{
name|DEBUGF
argument_list|(
name|FOR
argument_list|,
operator|(
literal|"%s\n---- at line %d\n"
operator|,
name|str
operator|,
name|lineno
operator|)
argument_list|)
expr_stmt|;
name|ParsePushInput
argument_list|(
name|estrdup
argument_list|(
name|CURFILE
operator|->
name|fname
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|str
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SYSVINCLUDE
end_ifdef

begin_comment
comment|/*-  *---------------------------------------------------------------------  * ParseTraditionalInclude  --  *	Push to another file.  *  *	The input is the line minus the "include".  The file name is  *	the string following the "include".  *  * Results:  *	None  *  * Side Effects:  *	A structure is added to the includes Lst and readProc, curFile.lineno,  *	curFile.fname and curFile.F are altered for the new file  *---------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|ParseTraditionalInclude
parameter_list|(
name|char
modifier|*
name|file
parameter_list|)
block|{
name|char
modifier|*
name|fullname
decl_stmt|;
comment|/* full pathname of file */
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* current position in file spec */
comment|/* 	 * Skip over whitespace 	 */
while|while
condition|(
operator|*
name|file
operator|==
literal|' '
operator|||
operator|*
name|file
operator|==
literal|'\t'
condition|)
block|{
name|file
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|file
operator|==
literal|'\0'
condition|)
block|{
name|Parse_Error
argument_list|(
name|PARSE_FATAL
argument_list|,
literal|"Filename missing from \"include\""
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	* Skip to end of line or next whitespace 	*/
for|for
control|(
name|cp
operator|=
name|file
init|;
operator|*
name|cp
operator|&&
operator|*
name|cp
operator|!=
literal|'\n'
operator|&&
operator|*
name|cp
operator|!=
literal|'\t'
operator|&&
operator|*
name|cp
operator|!=
literal|' '
condition|;
name|cp
operator|++
control|)
block|{
continue|continue;
block|}
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
comment|/* 	 * Substitute for any variables in the file name before trying to 	 * find the thing. 	 */
name|file
operator|=
name|Buf_Peel
argument_list|(
name|Var_Subst
argument_list|(
name|file
argument_list|,
name|VAR_CMD
argument_list|,
name|FALSE
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Now we know the file's name, we attempt to find the durn thing. 	 * Search for it first on the -I search path, then on the .PATH 	 * search path, if not found in a -I directory. 	 */
name|fullname
operator|=
name|Path_FindFile
argument_list|(
name|file
argument_list|,
operator|&
name|parseIncPath
argument_list|)
expr_stmt|;
if|if
condition|(
name|fullname
operator|==
name|NULL
condition|)
block|{
name|fullname
operator|=
name|Path_FindFile
argument_list|(
name|file
argument_list|,
operator|&
name|dirSearchPath
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fullname
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * Still haven't found the makefile. Look for it on the system 		 * path as a last resort. 		 */
name|fullname
operator|=
name|Path_FindFile
argument_list|(
name|file
argument_list|,
operator|&
name|sysIncPath
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fullname
operator|==
name|NULL
condition|)
block|{
name|Parse_Error
argument_list|(
name|PARSE_FATAL
argument_list|,
literal|"Could not find %s"
argument_list|,
name|file
argument_list|)
expr_stmt|;
comment|/* XXXHB free(file) */
return|return;
block|}
comment|/* XXXHB free(file) */
comment|/* 	 * We set up the name of the file to be the absolute 	 * name of the include file so error messages refer to the right 	 * place. 	 */
name|ParsePushInput
argument_list|(
name|fullname
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*-  *---------------------------------------------------------------------  * ParseReadc  --  *	Read a character from the current file  *  * Results:  *	The character that was read  *  * Side Effects:  *---------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|ParseReadc
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|CURFILE
operator|->
name|F
operator|!=
name|NULL
condition|)
return|return
operator|(
name|fgetc
argument_list|(
name|CURFILE
operator|->
name|F
argument_list|)
operator|)
return|;
if|if
condition|(
name|CURFILE
operator|->
name|str
operator|!=
name|NULL
operator|&&
operator|*
name|CURFILE
operator|->
name|ptr
operator|!=
literal|'\0'
condition|)
return|return
operator|(
operator|*
name|CURFILE
operator|->
name|ptr
operator|++
operator|)
return|;
return|return
operator|(
name|EOF
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *---------------------------------------------------------------------  * ParseUnreadc  --  *	Put back a character to the current file  *  * Results:  *	None.  *  * Side Effects:  *---------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|ParseUnreadc
parameter_list|(
name|int
name|c
parameter_list|)
block|{
if|if
condition|(
name|CURFILE
operator|->
name|F
operator|!=
name|NULL
condition|)
block|{
name|ungetc
argument_list|(
name|c
argument_list|,
name|CURFILE
operator|->
name|F
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|CURFILE
operator|->
name|str
operator|!=
name|NULL
condition|)
block|{
operator|*
operator|--
operator|(
name|CURFILE
operator|->
name|ptr
operator|)
operator|=
name|c
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_comment
comment|/* ParseSkipLine():  *	Grab the next line unless it begins with a dot (`.') and we're told to  *	ignore such lines.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|ParseSkipLine
parameter_list|(
name|int
name|skip
parameter_list|,
name|int
name|keep_newline
parameter_list|)
block|{
name|char
modifier|*
name|line
decl_stmt|;
name|int
name|c
decl_stmt|,
name|lastc
decl_stmt|;
name|Buffer
modifier|*
name|buf
decl_stmt|;
name|buf
operator|=
name|Buf_Init
argument_list|(
name|MAKE_BSIZE
argument_list|)
expr_stmt|;
do|do
block|{
name|Buf_Clear
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|lastc
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
operator|(
operator|(
name|c
operator|=
name|ParseReadc
argument_list|()
operator|)
operator|!=
literal|'\n'
operator|||
name|lastc
operator|==
literal|'\\'
operator|)
operator|&&
name|c
operator|!=
name|EOF
condition|)
block|{
if|if
condition|(
name|skip
operator|&&
name|c
operator|==
literal|'#'
operator|&&
name|lastc
operator|!=
literal|'\\'
condition|)
block|{
comment|/* 				 * let a comment be terminated even by an 				 * escaped \n. This is consistent to comment 				 * handling in ParseReadLine 				 */
while|while
condition|(
operator|(
name|c
operator|=
name|ParseReadc
argument_list|()
operator|)
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
name|EOF
condition|)
empty_stmt|;
break|break;
block|}
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|keep_newline
condition|)
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
operator|(
name|Byte
operator|)
name|c
argument_list|)
expr_stmt|;
else|else
name|Buf_ReplaceLastByte
argument_list|(
name|buf
argument_list|,
operator|(
name|Byte
operator|)
literal|' '
argument_list|)
expr_stmt|;
name|CURFILE
operator|->
name|lineno
operator|++
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|ParseReadc
argument_list|()
operator|)
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
condition|)
continue|continue;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
break|break;
block|}
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
operator|(
name|Byte
operator|)
name|c
argument_list|)
expr_stmt|;
name|lastc
operator|=
name|c
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
name|Parse_Error
argument_list|(
name|PARSE_FATAL
argument_list|,
literal|"Unclosed conditional/for loop"
argument_list|)
expr_stmt|;
name|Buf_Destroy
argument_list|(
name|buf
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|CURFILE
operator|->
name|lineno
operator|++
expr_stmt|;
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
operator|(
name|Byte
operator|)
literal|'\0'
argument_list|)
expr_stmt|;
name|line
operator|=
name|Buf_Data
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|skip
operator|==
literal|1
operator|&&
name|line
index|[
literal|0
index|]
operator|!=
literal|'.'
condition|)
do|;
name|Buf_Destroy
argument_list|(
name|buf
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
operator|(
name|line
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *---------------------------------------------------------------------  * ParseReadLine --  *	Read an entire line from the input file. Called only by Parse_File.  *	To facilitate escaped newlines and what have you, a character is  *	buffered in 'lastc', which is '\0' when no characters have been  *	read. When we break out of the loop, c holds the terminating  *	character and lastc holds a character that should be added to  *	the line (unless we don't read anything but a terminator).  *  * Results:  *	A line w/o its newline  *  * Side Effects:  *	Only those associated with reading a character  *---------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|ParseReadLine
parameter_list|(
name|void
parameter_list|)
block|{
name|Buffer
modifier|*
name|buf
decl_stmt|;
comment|/* Buffer for current line */
name|int
name|c
decl_stmt|;
comment|/* the current character */
name|int
name|lastc
decl_stmt|;
comment|/* The most-recent character */
name|Boolean
name|semiNL
decl_stmt|;
comment|/* treat semi-colons as newlines */
name|Boolean
name|ignDepOp
decl_stmt|;
comment|/* TRUE if should ignore dependency operators 				 * for the purposes of setting semiNL */
name|Boolean
name|ignComment
decl_stmt|;
comment|/* TRUE if should ignore comments (in a 				 * shell command */
name|char
modifier|*
name|line
decl_stmt|;
comment|/* Result */
name|char
modifier|*
name|ep
decl_stmt|;
comment|/* to strip trailing blanks */
name|again
label|:
name|semiNL
operator|=
name|FALSE
expr_stmt|;
name|ignDepOp
operator|=
name|FALSE
expr_stmt|;
name|ignComment
operator|=
name|FALSE
expr_stmt|;
name|lastc
operator|=
literal|'\0'
expr_stmt|;
comment|/* 	 * Handle tab at the beginning of the line. A leading tab (shell 	 * command) forces us to ignore comments and dependency operators and 	 * treat semi-colons as semi-colons (by leaving semiNL FALSE). 	 * This also discards completely blank lines. 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
name|ParseReadc
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
if|if
condition|(
name|ParsePopInput
argument_list|()
operator|==
name|DONE
condition|)
block|{
comment|/* End of all inputs - return NULL */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
continue|continue;
block|}
if|if
condition|(
name|c
operator|==
literal|'\t'
condition|)
block|{
name|ignComment
operator|=
name|ignDepOp
operator|=
name|TRUE
expr_stmt|;
name|lastc
operator|=
name|c
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|c
operator|!=
literal|'\n'
condition|)
block|{
name|ParseUnreadc
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
block|}
name|CURFILE
operator|->
name|lineno
operator|++
expr_stmt|;
block|}
name|buf
operator|=
name|Buf_Init
argument_list|(
name|MAKE_BSIZE
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
operator|(
name|c
operator|=
name|ParseReadc
argument_list|()
operator|)
operator|!=
literal|'\n'
operator|||
name|lastc
operator|==
literal|'\\'
operator|)
operator|&&
name|c
operator|!=
name|EOF
condition|)
block|{
name|test_char
label|:
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\n'
case|:
comment|/* 			 * Escaped newline: read characters until a 			 * non-space or an unescaped newline and 			 * replace them all by a single space. This is 			 * done by storing the space over the backslash 			 * and dropping through with the next nonspace. 			 * If it is a semi-colon and semiNL is TRUE, 			 * it will be recognized as a newline in the 			 * code below this... 			 */
name|CURFILE
operator|->
name|lineno
operator|++
expr_stmt|;
name|lastc
operator|=
literal|' '
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|ParseReadc
argument_list|()
operator|)
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|c
operator|==
name|EOF
operator|||
name|c
operator|==
literal|'\n'
condition|)
block|{
goto|goto
name|line_read
goto|;
block|}
else|else
block|{
comment|/* 				 * Check for comments, semiNL's, etc. -- 				 * easier than ParseUnreadc(c); 				 * continue; 				 */
goto|goto
name|test_char
goto|;
block|}
comment|/*NOTREACHED*/
break|break;
case|case
literal|';'
case|:
comment|/* 			 * Semi-colon: Need to see if it should be 			 * interpreted as a newline 			 */
if|if
condition|(
name|semiNL
condition|)
block|{
comment|/* 				 * To make sure the command that may 				 * be following this semi-colon begins 				 * with a tab, we push one back into the 				 * input stream. This will overwrite the 				 * semi-colon in the buffer. If there is 				 * no command following, this does no 				 * harm, since the newline remains in 				 * the buffer and the 				 * whole line is ignored. 				 */
name|ParseUnreadc
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
goto|goto
name|line_read
goto|;
block|}
break|break;
case|case
literal|'='
case|:
if|if
condition|(
operator|!
name|semiNL
condition|)
block|{
comment|/* 				 * Haven't seen a dependency operator 				 * before this, so this must be a 				 * variable assignment -- don't pay 				 * attention to dependency operators 				 * after this. 				 */
name|ignDepOp
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lastc
operator|==
literal|':'
operator|||
name|lastc
operator|==
literal|'!'
condition|)
block|{
comment|/* 				 * Well, we've seen a dependency 				 * operator already, but it was the 				 * previous character, so this is really 				 * just an expanded variable assignment. 				 * Revert semi-colons to being just 				 * semi-colons again and ignore any more 				 * dependency operators. 				 * 				 * XXX: Note that a line like 				 * "foo : a:=b" will blow up, but who'd 				 * write a line like that anyway? 				 */
name|ignDepOp
operator|=
name|TRUE
expr_stmt|;
name|semiNL
operator|=
name|FALSE
expr_stmt|;
block|}
break|break;
case|case
literal|'#'
case|:
if|if
condition|(
operator|!
name|ignComment
condition|)
block|{
if|if
condition|(
name|lastc
operator|!=
literal|'\\'
condition|)
block|{
comment|/* 					 * If the character is a hash 					 * mark and it isn't escaped 					 * (or we're being compatible), 					 * the thing is a comment. 					 * Skip to the end of the line. 					 */
do|do
block|{
name|c
operator|=
name|ParseReadc
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|c
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
name|EOF
condition|)
do|;
goto|goto
name|line_read
goto|;
block|}
else|else
block|{
comment|/* 					 * Don't add the backslash. 					 * Just let the # get copied 					 * over. 					 */
name|lastc
operator|=
name|c
expr_stmt|;
continue|continue;
block|}
block|}
break|break;
case|case
literal|':'
case|:
case|case
literal|'!'
case|:
if|if
condition|(
operator|!
name|ignDepOp
condition|)
block|{
comment|/* 				 * A semi-colon is recognized as a 				 * newline only on dependency lines. 				 * Dependency lines are lines with a 				 * colon or an exclamation point. 				 * Ergo... 				 */
name|semiNL
operator|=
name|TRUE
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
comment|/* 		 * Copy in the previous character (there may be none if this 		 * was the first character) and save this one in 		 * lastc. 		 */
if|if
condition|(
name|lastc
operator|!=
literal|'\0'
condition|)
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
operator|(
name|Byte
operator|)
name|lastc
argument_list|)
expr_stmt|;
name|lastc
operator|=
name|c
expr_stmt|;
block|}
name|line_read
label|:
name|CURFILE
operator|->
name|lineno
operator|++
expr_stmt|;
if|if
condition|(
name|lastc
operator|!=
literal|'\0'
condition|)
block|{
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
operator|(
name|Byte
operator|)
name|lastc
argument_list|)
expr_stmt|;
block|}
name|Buf_AddByte
argument_list|(
name|buf
argument_list|,
operator|(
name|Byte
operator|)
literal|'\0'
argument_list|)
expr_stmt|;
name|line
operator|=
name|Buf_Peel
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|/* 	 * Strip trailing blanks and tabs from the line. 	 * Do not strip a blank or tab that is preceded by 	 * a '\' 	 */
name|ep
operator|=
name|line
expr_stmt|;
while|while
condition|(
operator|*
name|ep
condition|)
operator|++
name|ep
expr_stmt|;
while|while
condition|(
name|ep
operator|>
name|line
operator|+
literal|1
operator|&&
operator|(
name|ep
index|[
operator|-
literal|1
index|]
operator|==
literal|' '
operator|||
name|ep
index|[
operator|-
literal|1
index|]
operator|==
literal|'\t'
operator|)
condition|)
block|{
if|if
condition|(
name|ep
operator|>
name|line
operator|+
literal|1
operator|&&
name|ep
index|[
operator|-
literal|2
index|]
operator|==
literal|'\\'
condition|)
break|break;
operator|--
name|ep
expr_stmt|;
block|}
operator|*
name|ep
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|line
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
comment|/* empty line - just ignore */
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
return|return
operator|(
name|line
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * ParseFinishLine --  *	Handle the end of a dependency group.  *  * Results:  *	Nothing.  *  * Side Effects:  *	inLine set FALSE. 'targets' list destroyed.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|ParseFinishLine
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|LstNode
modifier|*
name|ln
decl_stmt|;
if|if
condition|(
name|inLine
condition|)
block|{
name|LST_FOREACH
argument_list|(
argument|ln
argument_list|,
argument|&targets
argument_list|)
block|{
if|if
condition|(
operator|(
operator|(
specifier|const
name|GNode
operator|*
operator|)
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
operator|)
operator|->
name|type
operator|&
name|OP_TRANSFORM
condition|)
name|Suff_EndTransform
argument_list|(
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Lst_Destroy
argument_list|(
operator|&
name|targets
argument_list|,
name|ParseHasCommands
argument_list|)
expr_stmt|;
name|inLine
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * xparse_include  *	Parse an .include directive and push the file onto the input stack.  *	The input is the line minus the .include. A file spec is a string  *	enclosed in<> or "". The former is looked for only in sysIncPath.  *	The latter in . and the directories specified by -I command line  *	options  */
end_comment

begin_function
specifier|static
name|void
name|xparse_include
parameter_list|(
name|char
modifier|*
name|file
parameter_list|,
name|int
name|sinclude
parameter_list|)
block|{
name|char
modifier|*
name|fullname
decl_stmt|;
comment|/* full pathname of file */
name|char
name|endc
decl_stmt|;
comment|/* the character which ends the file spec */
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* current position in file spec */
name|Boolean
name|isSystem
decl_stmt|;
comment|/* TRUE if makefile is a system makefile */
name|char
modifier|*
name|prefEnd
decl_stmt|,
modifier|*
name|Fname
decl_stmt|;
name|char
modifier|*
name|newName
decl_stmt|;
comment|/* 	 * Skip to delimiter character so we know where to look 	 */
while|while
condition|(
operator|*
name|file
operator|==
literal|' '
operator|||
operator|*
name|file
operator|==
literal|'\t'
condition|)
block|{
name|file
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|file
operator|!=
literal|'"'
operator|&&
operator|*
name|file
operator|!=
literal|'<'
condition|)
block|{
name|Parse_Error
argument_list|(
name|PARSE_FATAL
argument_list|,
literal|".include filename must be delimited by '\"' or '<'"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Set the search path on which to find the include file based on the 	 * characters which bracket its name. Angle-brackets imply it's 	 * a system Makefile while double-quotes imply it's a user makefile 	 */
if|if
condition|(
operator|*
name|file
operator|==
literal|'<'
condition|)
block|{
name|isSystem
operator|=
name|TRUE
expr_stmt|;
name|endc
operator|=
literal|'>'
expr_stmt|;
block|}
else|else
block|{
name|isSystem
operator|=
name|FALSE
expr_stmt|;
name|endc
operator|=
literal|'"'
expr_stmt|;
block|}
comment|/* 	* Skip to matching delimiter 	*/
for|for
control|(
name|cp
operator|=
operator|++
name|file
init|;
operator|*
name|cp
operator|!=
name|endc
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
condition|)
block|{
name|Parse_Error
argument_list|(
name|PARSE_FATAL
argument_list|,
literal|"Unclosed .include filename. '%c' expected"
argument_list|,
name|endc
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
comment|/* 	 * Substitute for any variables in the file name before trying to 	 * find the thing. 	 */
name|file
operator|=
name|Buf_Peel
argument_list|(
name|Var_Subst
argument_list|(
name|file
argument_list|,
name|VAR_CMD
argument_list|,
name|FALSE
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Now we know the file's name and its search path, we attempt to 	 * find the durn thing. A return of NULL indicates the file don't 	 * exist. 	 */
if|if
condition|(
operator|!
name|isSystem
condition|)
block|{
comment|/* 		 * Include files contained in double-quotes are first searched 		 * for relative to the including file's location. We don't want 		 * to cd there, of course, so we just tack on the old file's 		 * leading path components and call Path_FindFile to see if 		 * we can locate the beast. 		 */
comment|/* Make a temporary copy of this, to be safe. */
name|Fname
operator|=
name|estrdup
argument_list|(
name|CURFILE
operator|->
name|fname
argument_list|)
expr_stmt|;
name|prefEnd
operator|=
name|strrchr
argument_list|(
name|Fname
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|prefEnd
operator|!=
name|NULL
condition|)
block|{
operator|*
name|prefEnd
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|file
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
name|newName
operator|=
name|estrdup
argument_list|(
name|file
argument_list|)
expr_stmt|;
else|else
name|newName
operator|=
name|str_concat
argument_list|(
name|Fname
argument_list|,
name|file
argument_list|,
name|STR_ADDSLASH
argument_list|)
expr_stmt|;
name|fullname
operator|=
name|Path_FindFile
argument_list|(
name|newName
argument_list|,
operator|&
name|parseIncPath
argument_list|)
expr_stmt|;
if|if
condition|(
name|fullname
operator|==
name|NULL
condition|)
block|{
name|fullname
operator|=
name|Path_FindFile
argument_list|(
name|newName
argument_list|,
operator|&
name|dirSearchPath
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|newName
argument_list|)
expr_stmt|;
operator|*
name|prefEnd
operator|=
literal|'/'
expr_stmt|;
block|}
else|else
block|{
name|fullname
operator|=
name|NULL
expr_stmt|;
block|}
name|free
argument_list|(
name|Fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|fullname
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * Makefile wasn't found in same directory as included 			 * makefile. Search for it first on the -I search path, 			 * then on the .PATH search path, if not found in a -I 			 * directory. 			 * XXX: Suffix specific? 			 */
name|fullname
operator|=
name|Path_FindFile
argument_list|(
name|file
argument_list|,
operator|&
name|parseIncPath
argument_list|)
expr_stmt|;
if|if
condition|(
name|fullname
operator|==
name|NULL
condition|)
block|{
name|fullname
operator|=
name|Path_FindFile
argument_list|(
name|file
argument_list|,
operator|&
name|dirSearchPath
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|fullname
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|fullname
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * System makefile or still haven't found the makefile. 		 * Look for it on the system path. 		 */
name|fullname
operator|=
name|Path_FindFile
argument_list|(
name|file
argument_list|,
operator|&
name|sysIncPath
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fullname
operator|==
name|NULL
condition|)
block|{
operator|*
name|cp
operator|=
name|endc
expr_stmt|;
if|if
condition|(
operator|!
name|sinclude
condition|)
name|Parse_Error
argument_list|(
name|PARSE_FATAL
argument_list|,
literal|"Could not find %s"
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|Main_AddSourceMakefile
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|file
argument_list|)
expr_stmt|;
return|return;
block|}
name|Main_AddSourceMakefile
argument_list|(
name|fullname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|file
argument_list|)
expr_stmt|;
comment|/* 	 * We set up the name of the file to be the absolute 	 * name of the include file so error messages refer to the right 	 * place. 	 */
name|ParsePushInput
argument_list|(
name|fullname
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DEBUGF
argument_list|(
name|DIR
argument_list|,
operator|(
literal|".include %s\n"
operator|,
name|fullname
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|parse_include
parameter_list|(
name|char
modifier|*
name|file
parameter_list|,
name|int
name|code
name|__unused
parameter_list|,
name|int
name|lineno
name|__unused
parameter_list|)
block|{
name|xparse_include
argument_list|(
name|file
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|parse_sinclude
parameter_list|(
name|char
modifier|*
name|file
parameter_list|,
name|int
name|code
name|__unused
parameter_list|,
name|int
name|lineno
name|__unused
parameter_list|)
block|{
name|xparse_include
argument_list|(
name|file
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * parse_message  *	Parse a .warning or .error directive  *  *	The input is the line minus the ".error"/".warning".  We substitute  *	variables, print the message and exit(1) (for .error) or just print  *	a warning if the directive is malformed.  */
end_comment

begin_function
specifier|static
name|void
name|parse_message
parameter_list|(
name|char
modifier|*
name|line
parameter_list|,
name|int
name|iserror
parameter_list|,
name|int
name|lineno
name|__unused
parameter_list|)
block|{
if|if
condition|(
operator|!
name|isspace
argument_list|(
operator|(
name|u_char
operator|)
operator|*
name|line
argument_list|)
condition|)
block|{
name|Parse_Error
argument_list|(
name|PARSE_WARNING
argument_list|,
literal|"invalid syntax: .%s%s"
argument_list|,
name|iserror
condition|?
literal|"error"
else|:
literal|"warning"
argument_list|,
name|line
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|u_char
operator|)
operator|*
name|line
argument_list|)
condition|)
name|line
operator|++
expr_stmt|;
name|line
operator|=
name|Buf_Peel
argument_list|(
name|Var_Subst
argument_list|(
name|line
argument_list|,
name|VAR_CMD
argument_list|,
name|FALSE
argument_list|)
argument_list|)
expr_stmt|;
name|Parse_Error
argument_list|(
name|iserror
condition|?
name|PARSE_FATAL
else|:
name|PARSE_WARNING
argument_list|,
literal|"%s"
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|iserror
condition|)
block|{
comment|/* Terminate immediately. */
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * parse_undef  *	Parse an .undef directive.  */
end_comment

begin_function
specifier|static
name|void
name|parse_undef
parameter_list|(
name|char
modifier|*
name|line
parameter_list|,
name|int
name|code
name|__unused
parameter_list|,
name|int
name|lineno
name|__unused
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|u_char
operator|)
operator|*
name|line
argument_list|)
condition|)
name|line
operator|++
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|line
init|;
operator|!
name|isspace
argument_list|(
operator|(
name|u_char
operator|)
operator|*
name|cp
argument_list|)
operator|&&
operator|*
name|cp
operator|!=
literal|'\0'
condition|;
name|cp
operator|++
control|)
block|{
empty_stmt|;
block|}
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|cp
operator|=
name|Buf_Peel
argument_list|(
name|Var_Subst
argument_list|(
name|line
argument_list|,
name|VAR_CMD
argument_list|,
name|FALSE
argument_list|)
argument_list|)
expr_stmt|;
name|Var_Delete
argument_list|(
name|cp
argument_list|,
name|VAR_GLOBAL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * parse_for  *	Parse a .for directive.  */
end_comment

begin_function
specifier|static
name|void
name|parse_for
parameter_list|(
name|char
modifier|*
name|line
parameter_list|,
name|int
name|code
name|__unused
parameter_list|,
name|int
name|lineno
parameter_list|)
block|{
if|if
condition|(
operator|!
name|For_For
argument_list|(
name|line
argument_list|)
condition|)
block|{
comment|/* syntax error */
return|return;
block|}
name|line
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Skip after the matching endfor. 	 */
do|do
block|{
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|line
operator|=
name|ParseSkipLine
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|==
name|NULL
condition|)
block|{
name|Parse_Error
argument_list|(
name|PARSE_FATAL
argument_list|,
literal|"Unexpected end of file in for loop.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
do|while
condition|(
name|For_Eval
argument_list|(
name|line
argument_list|)
condition|)
do|;
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
comment|/* execute */
name|For_Run
argument_list|(
name|lineno
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * parse_endfor  *	Parse endfor. This may only happen if there was no matching .for.  */
end_comment

begin_function
specifier|static
name|void
name|parse_endfor
parameter_list|(
name|char
modifier|*
name|line
name|__unused
parameter_list|,
name|int
name|code
name|__unused
parameter_list|,
name|int
name|lineno
name|__unused
parameter_list|)
block|{
name|Parse_Error
argument_list|(
name|PARSE_FATAL
argument_list|,
literal|"for-less endfor"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * parse_directive  *	Got a line starting with a '.'. Check if this is a directive  *	and parse it.  *  * return:  *	TRUE if line was a directive, FALSE otherwise.  */
end_comment

begin_function
specifier|static
name|Boolean
name|parse_directive
parameter_list|(
name|char
modifier|*
name|line
parameter_list|)
block|{
name|char
modifier|*
name|start
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|dir
decl_stmt|;
comment|/* 	 * Get the keyword: 	 *	.[[:space:]]*\([[:alpha:]][[:alnum:]_]*\).* 	 * \1 is the keyword. 	 */
for|for
control|(
name|start
operator|=
name|line
init|;
name|isspace
argument_list|(
operator|(
name|u_char
operator|)
operator|*
name|start
argument_list|)
condition|;
name|start
operator|++
control|)
block|{
empty_stmt|;
block|}
if|if
condition|(
operator|!
name|isalpha
argument_list|(
operator|(
name|u_char
operator|)
operator|*
name|start
argument_list|)
condition|)
block|{
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|cp
operator|=
name|start
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|isalnum
argument_list|(
operator|(
name|u_char
operator|)
operator|*
name|cp
argument_list|)
operator|||
operator|*
name|cp
operator|==
literal|'_'
condition|)
block|{
name|cp
operator|++
expr_stmt|;
block|}
name|dir
operator|=
name|directive_hash
argument_list|(
name|start
argument_list|,
name|cp
operator|-
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
name|dir
operator|<
literal|0
operator|||
name|dir
operator|>=
operator|(
name|int
operator|)
name|NDIRECTS
operator|||
call|(
name|size_t
call|)
argument_list|(
name|cp
operator|-
name|start
argument_list|)
operator|!=
name|strlen
argument_list|(
name|directives
index|[
name|dir
index|]
operator|.
name|name
argument_list|)
operator|||
name|strncmp
argument_list|(
name|start
argument_list|,
name|directives
index|[
name|dir
index|]
operator|.
name|name
argument_list|,
name|cp
operator|-
name|start
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* not actually matched */
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|skipLine
operator|||
name|directives
index|[
name|dir
index|]
operator|.
name|skip_flag
condition|)
operator|(
operator|*
name|directives
index|[
name|dir
index|]
operator|.
name|func
operator|)
operator|(
name|cp
operator|,
name|directives
index|[
name|dir
index|]
operator|.
name|code
operator|,
name|CURFILE
operator|->
name|lineno
operator|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *---------------------------------------------------------------------  * Parse_File --  *	Parse a file into its component parts, incorporating it into the  *	current dependency graph. This is the main function and controls  *	almost every other function in this module  *  * Results:  *	None  *  * Side Effects:  *	Loads. Nodes are added to the list of all targets, nodes and links  *	are added to the dependency graph. etc. etc. etc.  *---------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Parse_File
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|FILE
modifier|*
name|stream
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* pointer into the line */
name|char
modifier|*
name|line
decl_stmt|;
comment|/* the line we're working on */
name|inLine
operator|=
name|FALSE
expr_stmt|;
name|fatals
operator|=
literal|0
expr_stmt|;
name|ParsePushInput
argument_list|(
name|estrdup
argument_list|(
name|name
argument_list|)
argument_list|,
name|stream
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|line
operator|=
name|ParseReadLine
argument_list|()
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|*
name|line
operator|==
literal|'.'
operator|&&
name|parse_directive
argument_list|(
name|line
operator|+
literal|1
argument_list|)
condition|)
block|{
comment|/* directive consumed */
goto|goto
name|nextLine
goto|;
block|}
if|if
condition|(
name|skipLine
operator|||
operator|*
name|line
operator|==
literal|'#'
condition|)
block|{
comment|/* Skipping .if block or comment. */
goto|goto
name|nextLine
goto|;
block|}
if|if
condition|(
operator|*
name|line
operator|==
literal|'\t'
condition|)
block|{
comment|/* 			 * If a line starts with a tab, it can only 			 * hope to be a creation command. 			 */
for|for
control|(
name|cp
operator|=
name|line
operator|+
literal|1
init|;
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cp
argument_list|)
condition|;
name|cp
operator|++
control|)
block|{
continue|continue;
block|}
if|if
condition|(
operator|*
name|cp
condition|)
block|{
if|if
condition|(
name|inLine
condition|)
block|{
name|LstNode
modifier|*
name|ln
decl_stmt|;
name|GNode
modifier|*
name|gn
decl_stmt|;
comment|/* 					 * So long as it's not a blank 					 * line and we're actually in a 					 * dependency spec, add the 					 * command to the list of 					 * commands of all targets in 					 * the dependency spec. 					 */
name|LST_FOREACH
argument_list|(
argument|ln
argument_list|,
argument|&targets
argument_list|)
block|{
name|gn
operator|=
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
expr_stmt|;
comment|/* 						 * if target already 						 * supplied, ignore 						 * commands 						 */
if|if
condition|(
operator|!
operator|(
name|gn
operator|->
name|type
operator|&
name|OP_HAS_COMMANDS
operator|)
condition|)
name|Lst_AtEnd
argument_list|(
operator|&
name|gn
operator|->
name|commands
argument_list|,
name|cp
argument_list|)
expr_stmt|;
else|else
name|Parse_Error
argument_list|(
name|PARSE_WARNING
argument_list|,
literal|"duplicate script "
literal|"for target \"%s\" ignored"
argument_list|,
name|gn
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
else|else
block|{
name|Parse_Error
argument_list|(
name|PARSE_FATAL
argument_list|,
literal|"Unassociated shell command \"%s\""
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|SYSVINCLUDE
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|line
argument_list|,
literal|"include"
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
operator|&&
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|line
index|[
literal|7
index|]
argument_list|)
operator|&&
name|strchr
argument_list|(
name|line
argument_list|,
literal|':'
argument_list|)
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * It's an S3/S5-style "include". 			 */
name|ParseTraditionalInclude
argument_list|(
name|line
operator|+
literal|7
argument_list|)
expr_stmt|;
goto|goto
name|nextLine
goto|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|Parse_IsVar
argument_list|(
name|line
argument_list|)
condition|)
block|{
name|ParseFinishLine
argument_list|()
expr_stmt|;
name|Parse_DoVar
argument_list|(
name|line
argument_list|,
name|VAR_GLOBAL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * We now know it's a dependency line so it 			 * needs to have all variables expanded before 			 * being parsed. Tell the variable module to 			 * complain if some variable is undefined... 			 * To make life easier on novices, if the line 			 * is indented we first make sure the line has 			 * a dependency operator in it. If it doesn't 			 * have an operator and we're in a dependency 			 * line's script, we assume it's actually a 			 * shell command and add it to the current 			 * list of targets. XXX this comment seems wrong. 			 */
name|cp
operator|=
name|line
expr_stmt|;
if|if
condition|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|line
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
while|while
condition|(
operator|*
name|cp
operator|!=
literal|'\0'
operator|&&
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cp
argument_list|)
condition|)
block|{
name|cp
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
condition|)
block|{
goto|goto
name|nextLine
goto|;
block|}
block|}
name|ParseFinishLine
argument_list|()
expr_stmt|;
name|cp
operator|=
name|Buf_Peel
argument_list|(
name|Var_Subst
argument_list|(
name|line
argument_list|,
name|VAR_CMD
argument_list|,
name|TRUE
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|line
operator|=
name|cp
expr_stmt|;
comment|/* 			 * Need a non-circular list for the target nodes 			 */
name|Lst_Destroy
argument_list|(
operator|&
name|targets
argument_list|,
name|NOFREE
argument_list|)
expr_stmt|;
name|inLine
operator|=
name|TRUE
expr_stmt|;
name|ParseDoDependency
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
name|nextLine
label|:
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
name|ParseFinishLine
argument_list|()
expr_stmt|;
comment|/* 	 * Make sure conditionals are clean 	 */
name|Cond_End
argument_list|()
expr_stmt|;
if|if
condition|(
name|fatals
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"fatal errors encountered -- cannot continue"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Parse_MainName --  *	Return a Lst of the main target to create for main()'s sake. If  *	no such target exists, we Punt with an obnoxious error message.  *  * Results:  *	A Lst of the single node to create.  *  * Side Effects:  *	None.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Parse_MainName
parameter_list|(
name|Lst
modifier|*
name|listmain
parameter_list|)
block|{
if|if
condition|(
name|mainNode
operator|==
name|NULL
condition|)
block|{
name|Punt
argument_list|(
literal|"no target to make."
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
elseif|else
if|if
condition|(
name|mainNode
operator|->
name|type
operator|&
name|OP_DOUBLEDEP
condition|)
block|{
name|Lst_AtEnd
argument_list|(
name|listmain
argument_list|,
name|mainNode
argument_list|)
expr_stmt|;
name|Lst_Concat
argument_list|(
name|listmain
argument_list|,
operator|&
name|mainNode
operator|->
name|cohorts
argument_list|,
name|LST_CONCNEW
argument_list|)
expr_stmt|;
block|}
else|else
name|Lst_AtEnd
argument_list|(
name|listmain
argument_list|,
name|mainNode
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

