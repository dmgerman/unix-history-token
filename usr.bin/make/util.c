begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Missing stuff from OS's  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|"make.h"
end_include

begin_if
if|#
directive|if
operator|!
name|__STDC__
end_if

begin_ifndef
ifndef|#
directive|ifndef
name|const
end_ifndef

begin_define
define|#
directive|define
name|const
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|sun
end_ifdef

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|,
name|sys_nerr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|sys_errlist
index|[]
decl_stmt|;
end_decl_stmt

begin_function
name|char
modifier|*
name|strerror
parameter_list|(
name|e
parameter_list|)
name|int
name|e
decl_stmt|;
block|{
specifier|static
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
if|if
condition|(
name|e
operator|<
literal|0
operator|||
name|e
operator|>=
name|sys_nerr
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"Unknown error %d"
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
else|else
return|return
name|sys_errlist
index|[
name|e
index|]
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|ultrix
end_ifdef

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_comment
comment|/* strdup  *  * Make a duplicate of a string.  * For systems which lack this function.  */
end_comment

begin_function
name|char
modifier|*
name|strdup
parameter_list|(
name|str
parameter_list|)
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|size_t
name|len
decl_stmt|;
if|if
condition|(
name|str
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|len
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|malloc
argument_list|(
name|len
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
return|return
name|memcpy
argument_list|(
name|p
argument_list|,
name|str
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
operator|||
name|defined
argument_list|(
name|__hpux
argument_list|)
operator|||
name|defined
argument_list|(
name|__sgi
argument_list|)
end_if

begin_function
name|int
name|setenv
parameter_list|(
name|name
parameter_list|,
name|value
parameter_list|,
name|dum
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
name|value
decl_stmt|;
name|int
name|dum
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|len
init|=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
name|strlen
argument_list|(
name|value
argument_list|)
operator|+
literal|2
decl_stmt|;
comment|/* = \0 */
name|char
modifier|*
name|ptr
init|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|len
argument_list|)
decl_stmt|;
operator|(
name|void
operator|)
name|dum
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|p
operator|=
name|ptr
expr_stmt|;
while|while
condition|(
operator|*
name|name
condition|)
operator|*
name|p
operator|++
operator|=
operator|*
name|name
operator|++
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'='
expr_stmt|;
while|while
condition|(
operator|*
name|value
condition|)
operator|*
name|p
operator|++
operator|=
operator|*
name|value
operator|++
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|len
operator|=
name|putenv
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
comment|/*    free(ptr); */
return|return
name|len
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__hpux
end_ifdef

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/syscall.h>
end_include

begin_include
include|#
directive|include
file|<sys/signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<dirent.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_function
name|int
name|killpg
parameter_list|(
name|pid
parameter_list|,
name|sig
parameter_list|)
name|int
name|pid
decl_stmt|,
name|sig
decl_stmt|;
block|{
return|return
name|kill
argument_list|(
operator|-
name|pid
argument_list|,
name|sig
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|srandom
parameter_list|(
name|seed
parameter_list|)
name|long
name|seed
decl_stmt|;
block|{
name|srand48
argument_list|(
name|seed
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|long
name|random
parameter_list|()
block|{
return|return
name|lrand48
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/* turn into bsd signals */
end_comment

begin_macro
name|void
argument_list|(
argument|* signal(s, a)
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
name|int
name|s
expr_stmt|;
end_expr_stmt

begin_function_decl
name|void
function_decl|(
modifier|*
name|a
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
name|struct
name|sigvec
name|osv
decl_stmt|,
name|sv
decl_stmt|;
operator|(
name|void
operator|)
name|sigvector
argument_list|(
name|s
argument_list|,
operator|(
expr|struct
name|sigvec
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|osv
argument_list|)
expr_stmt|;
name|sv
operator|=
name|osv
expr_stmt|;
name|sv
operator|.
name|sv_handler
operator|=
name|a
expr_stmt|;
ifdef|#
directive|ifdef
name|SV_BSDSIG
name|sv
operator|.
name|sv_flags
operator|=
name|SV_BSDSIG
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sigvector
argument_list|(
name|s
argument_list|,
operator|&
name|sv
argument_list|,
operator|(
expr|struct
name|sigvec
operator|*
operator|)
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|BADSIG
operator|)
return|;
return|return
operator|(
name|osv
operator|.
name|sv_handler
operator|)
return|;
block|}
end_block

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|BSD
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|d_fileno
argument_list|)
end_if

begin_define
define|#
directive|define
name|d_fileno
value|d_ino
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DEV_DEV_COMPARE
end_ifndef

begin_define
define|#
directive|define
name|DEV_DEV_COMPARE
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a) == (b))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* strrcpy():  *	Like strcpy, going backwards and returning the new pointer  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|strrcpy
parameter_list|(
name|ptr
parameter_list|,
name|str
parameter_list|)
specifier|register
name|char
modifier|*
name|ptr
decl_stmt|,
decl|*
name|str
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|int
name|len
init|=
name|strlen
argument_list|(
name|str
argument_list|)
decl_stmt|;
while|while
condition|(
name|len
condition|)
operator|*
operator|--
name|ptr
operator|=
name|str
index|[
operator|--
name|len
index|]
expr_stmt|;
return|return
operator|(
name|ptr
operator|)
return|;
block|}
end_block

begin_comment
comment|/* end strrcpy */
end_comment

begin_function
name|char
modifier|*
name|getwd
parameter_list|(
name|pathname
parameter_list|)
name|char
modifier|*
name|pathname
decl_stmt|;
block|{
name|DIR
modifier|*
name|dp
decl_stmt|;
name|struct
name|dirent
modifier|*
name|d
decl_stmt|;
name|struct
name|stat
name|st_root
decl_stmt|,
name|st_cur
decl_stmt|,
name|st_next
decl_stmt|,
name|st_dotdot
decl_stmt|;
name|char
name|pathbuf
index|[
name|MAXPATHLEN
index|]
decl_stmt|,
name|nextpathbuf
index|[
name|MAXPATHLEN
operator|*
literal|2
index|]
decl_stmt|;
name|char
modifier|*
name|pathptr
decl_stmt|,
modifier|*
name|nextpathptr
decl_stmt|,
modifier|*
name|cur_name_add
decl_stmt|;
comment|/* find the inode of root */
if|if
condition|(
name|stat
argument_list|(
literal|"/"
argument_list|,
operator|&
name|st_root
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|pathname
argument_list|,
literal|"getwd: Cannot stat \"/\" (%s)"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|pathbuf
index|[
name|MAXPATHLEN
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|pathptr
operator|=
operator|&
name|pathbuf
index|[
name|MAXPATHLEN
operator|-
literal|1
index|]
expr_stmt|;
name|nextpathbuf
index|[
name|MAXPATHLEN
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|cur_name_add
operator|=
name|nextpathptr
operator|=
operator|&
name|nextpathbuf
index|[
name|MAXPATHLEN
operator|-
literal|1
index|]
expr_stmt|;
comment|/* find the inode of the current directory */
if|if
condition|(
name|lstat
argument_list|(
literal|"."
argument_list|,
operator|&
name|st_cur
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|pathname
argument_list|,
literal|"getwd: Cannot stat \".\" (%s)"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|nextpathptr
operator|=
name|strrcpy
argument_list|(
name|nextpathptr
argument_list|,
literal|"../"
argument_list|)
expr_stmt|;
comment|/* Descend to root */
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* look if we found root yet */
if|if
condition|(
name|st_cur
operator|.
name|st_ino
operator|==
name|st_root
operator|.
name|st_ino
operator|&&
name|DEV_DEV_COMPARE
argument_list|(
name|st_cur
operator|.
name|st_dev
argument_list|,
name|st_root
operator|.
name|st_dev
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|pathname
argument_list|,
operator|*
name|pathptr
operator|!=
literal|'/'
condition|?
literal|"/"
else|:
name|pathptr
argument_list|)
expr_stmt|;
return|return
operator|(
name|pathname
operator|)
return|;
block|}
comment|/* open the parent directory */
if|if
condition|(
name|stat
argument_list|(
name|nextpathptr
argument_list|,
operator|&
name|st_dotdot
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|snprintf
argument_list|(
name|pathname
argument_list|,
sizeof|sizeof
argument_list|(
name|pathname
argument_list|)
argument_list|,
literal|"getwd: Cannot stat directory \"%s\" (%s)"
argument_list|,
name|nextpathptr
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|dp
operator|=
name|opendir
argument_list|(
name|nextpathptr
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|pathname
argument_list|,
sizeof|sizeof
argument_list|(
name|pathname
argument_list|)
argument_list|,
literal|"getwd: Cannot open directory \"%s\" (%s)"
argument_list|,
name|nextpathptr
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* look in the parent for the entry with the same inode */
if|if
condition|(
name|DEV_DEV_COMPARE
argument_list|(
name|st_dotdot
operator|.
name|st_dev
argument_list|,
name|st_cur
operator|.
name|st_dev
argument_list|)
condition|)
block|{
comment|/* Parent has same device. No need to stat every member */
for|for
control|(
name|d
operator|=
name|readdir
argument_list|(
name|dp
argument_list|)
init|;
name|d
operator|!=
name|NULL
condition|;
name|d
operator|=
name|readdir
argument_list|(
name|dp
argument_list|)
control|)
if|if
condition|(
name|d
operator|->
name|d_fileno
operator|==
name|st_cur
operator|.
name|st_ino
condition|)
break|break;
block|}
else|else
block|{
comment|/* 	     * Parent has a different device. This is a mount point so we 	     * need to stat every member 	     */
for|for
control|(
name|d
operator|=
name|readdir
argument_list|(
name|dp
argument_list|)
init|;
name|d
operator|!=
name|NULL
condition|;
name|d
operator|=
name|readdir
argument_list|(
name|dp
argument_list|)
control|)
block|{
if|if
condition|(
name|ISDOT
argument_list|(
name|d
operator|->
name|d_name
argument_list|)
operator|||
name|ISDOTDOT
argument_list|(
name|d
operator|->
name|d_name
argument_list|)
condition|)
continue|continue;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|cur_name_add
argument_list|,
name|d
operator|->
name|d_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|lstat
argument_list|(
name|nextpathptr
argument_list|,
operator|&
name|st_next
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|snprintf
argument_list|(
name|pathname
argument_list|,
sizeof|sizeof
argument_list|(
name|pathname
argument_list|)
argument_list|,
literal|"getwd: Cannot stat \"%s\" (%s)"
argument_list|,
name|d
operator|->
name|d_name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|closedir
argument_list|(
name|dp
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* check if we found it yet */
if|if
condition|(
name|st_next
operator|.
name|st_ino
operator|==
name|st_cur
operator|.
name|st_ino
operator|&&
name|DEV_DEV_COMPARE
argument_list|(
name|st_next
operator|.
name|st_dev
argument_list|,
name|st_cur
operator|.
name|st_dev
argument_list|)
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|d
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|pathname
argument_list|,
literal|"getwd: Cannot find \".\" in \"..\""
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|closedir
argument_list|(
name|dp
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|st_cur
operator|=
name|st_dotdot
expr_stmt|;
name|pathptr
operator|=
name|strrcpy
argument_list|(
name|pathptr
argument_list|,
name|d
operator|->
name|d_name
argument_list|)
expr_stmt|;
name|pathptr
operator|=
name|strrcpy
argument_list|(
name|pathptr
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|nextpathptr
operator|=
name|strrcpy
argument_list|(
name|nextpathptr
argument_list|,
literal|"../"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|closedir
argument_list|(
name|dp
argument_list|)
expr_stmt|;
operator|*
name|cur_name_add
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* end getwd */
end_comment

begin_decl_stmt
name|char
modifier|*
name|sys_siglist
index|[]
init|=
block|{
literal|"Signal 0"
block|,
literal|"Hangup"
block|,
comment|/* SIGHUP    */
literal|"Interrupt"
block|,
comment|/* SIGINT    */
literal|"Quit"
block|,
comment|/* SIGQUIT   */
literal|"Illegal instruction"
block|,
comment|/* SIGILL    */
literal|"Trace/BPT trap"
block|,
comment|/* SIGTRAP   */
literal|"IOT trap"
block|,
comment|/* SIGIOT    */
literal|"EMT trap"
block|,
comment|/* SIGEMT    */
literal|"Floating point exception"
block|,
comment|/* SIGFPE    */
literal|"Killed"
block|,
comment|/* SIGKILL   */
literal|"Bus error"
block|,
comment|/* SIGBUS    */
literal|"Segmentation fault"
block|,
comment|/* SIGSEGV   */
literal|"Bad system call"
block|,
comment|/* SIGSYS    */
literal|"Broken pipe"
block|,
comment|/* SIGPIPE   */
literal|"Alarm clock"
block|,
comment|/* SIGALRM   */
literal|"Terminated"
block|,
comment|/* SIGTERM   */
literal|"User defined signal 1"
block|,
comment|/* SIGUSR1   */
literal|"User defined signal 2"
block|,
comment|/* SIGUSR2   */
literal|"Child exited"
block|,
comment|/* SIGCLD    */
literal|"Power-fail restart"
block|,
comment|/* SIGPWR    */
literal|"Virtual timer expired"
block|,
comment|/* SIGVTALRM */
literal|"Profiling timer expired"
block|,
comment|/* SIGPROF   */
literal|"I/O possible"
block|,
comment|/* SIGIO     */
literal|"Window size changes"
block|,
comment|/* SIGWINDOW */
literal|"Stopped (signal)"
block|,
comment|/* SIGSTOP   */
literal|"Stopped"
block|,
comment|/* SIGTSTP   */
literal|"Continued"
block|,
comment|/* SIGCONT   */
literal|"Stopped (tty input)"
block|,
comment|/* SIGTTIN   */
literal|"Stopped (tty output)"
block|,
comment|/* SIGTTOU   */
literal|"Urgent I/O condition"
block|,
comment|/* SIGURG    */
literal|"Remote lock lost (NFS)"
block|,
comment|/* SIGLOST   */
literal|"Signal 31"
block|,
comment|/* reserved  */
literal|"DIL signal"
comment|/* SIGDIL    */
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|utimes
parameter_list|(
name|file
parameter_list|,
name|tvp
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|struct
name|timeval
name|tvp
index|[
literal|2
index|]
decl_stmt|;
block|{
name|struct
name|utimbuf
name|t
decl_stmt|;
name|t
operator|.
name|actime
operator|=
name|tvp
index|[
literal|0
index|]
operator|.
name|tv_sec
expr_stmt|;
name|t
operator|.
name|modtime
operator|=
name|tvp
index|[
literal|1
index|]
operator|.
name|tv_sec
expr_stmt|;
return|return
operator|(
name|utime
argument_list|(
name|file
argument_list|,
operator|&
name|t
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __hpux */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
operator|&&
name|defined
argument_list|(
name|__svr4__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_comment
comment|/* turn into bsd signals */
end_comment

begin_macro
name|void
argument_list|(
argument|* signal(s, a)
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
name|int
name|s
expr_stmt|;
end_expr_stmt

begin_function_decl
name|void
function_decl|(
modifier|*
name|a
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
name|struct
name|sigaction
name|sa
decl_stmt|,
name|osa
decl_stmt|;
name|sa
operator|.
name|sa_handler
operator|=
name|a
expr_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|sa
operator|.
name|sa_mask
argument_list|)
expr_stmt|;
name|sa
operator|.
name|sa_flags
operator|=
name|SA_RESTART
expr_stmt|;
if|if
condition|(
name|sigaction
argument_list|(
name|s
argument_list|,
operator|&
name|sa
argument_list|,
operator|&
name|osa
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
name|SIG_ERR
return|;
else|else
return|return
name|osa
operator|.
name|sa_handler
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

