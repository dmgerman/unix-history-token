begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1988, 1989, 1990, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Adam de Boor.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_comment
comment|/*-  * lst.c --  *	Routines to maintain a linked list of objects.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|"lst.h"
end_include

begin_include
include|#
directive|include
file|"util.h"
end_include

begin_comment
comment|/**  * Lst_Append  *	Create a new node and add it to the given list after the given node.  *  * Arguments:  *	l	affected list  *	ln	node after which to append the datum  *	d	said datum  *  * Side Effects:  *	A new LstNode is created and linked in to the List. The lastPtr  *	field of the List will be altered if ln is the last node in the  *	list. lastPtr and firstPtr will alter if the list was empty and  *	ln was NULL.  */
end_comment

begin_function
name|void
name|Lst_Append
parameter_list|(
name|Lst
modifier|*
name|list
parameter_list|,
name|LstNode
modifier|*
name|ln
parameter_list|,
name|void
modifier|*
name|d
parameter_list|)
block|{
name|LstNode
modifier|*
name|nLNode
decl_stmt|;
name|nLNode
operator|=
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|nLNode
argument_list|)
argument_list|)
expr_stmt|;
name|nLNode
operator|->
name|datum
operator|=
name|d
expr_stmt|;
if|if
condition|(
name|ln
operator|==
name|NULL
condition|)
block|{
name|nLNode
operator|->
name|nextPtr
operator|=
name|nLNode
operator|->
name|prevPtr
operator|=
name|NULL
expr_stmt|;
name|list
operator|->
name|firstPtr
operator|=
name|list
operator|->
name|lastPtr
operator|=
name|nLNode
expr_stmt|;
block|}
else|else
block|{
name|nLNode
operator|->
name|prevPtr
operator|=
name|ln
expr_stmt|;
name|nLNode
operator|->
name|nextPtr
operator|=
name|ln
operator|->
name|nextPtr
expr_stmt|;
name|ln
operator|->
name|nextPtr
operator|=
name|nLNode
expr_stmt|;
if|if
condition|(
name|nLNode
operator|->
name|nextPtr
operator|!=
name|NULL
condition|)
block|{
name|nLNode
operator|->
name|nextPtr
operator|->
name|prevPtr
operator|=
name|nLNode
expr_stmt|;
block|}
if|if
condition|(
name|ln
operator|==
name|list
operator|->
name|lastPtr
condition|)
block|{
name|list
operator|->
name|lastPtr
operator|=
name|nLNode
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/**  * Lst_Concat  *	Concatenate two lists. New elements are created to hold the data  *	elements, if specified, but the elements themselves are not copied.  *	If the elements should be duplicated to avoid confusion with another  *	list, the Lst_Duplicate function should be called first.  *  * Arguments:  *	list1	The list to which list2 is to be appended  *	list2	The list to append to list1  *	flags	LST_CONCNEW if LstNode's should be duplicated  *		LST_CONCLINK if should just be relinked  *  * Side Effects:  *	New elements are created and appended the the first list.  */
end_comment

begin_function
name|void
name|Lst_Concat
parameter_list|(
name|Lst
modifier|*
name|list1
parameter_list|,
name|Lst
modifier|*
name|list2
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|LstNode
modifier|*
name|ln
decl_stmt|;
comment|/* original LstNode */
name|LstNode
modifier|*
name|nln
decl_stmt|;
comment|/* new LstNode */
name|LstNode
modifier|*
name|last
decl_stmt|;
comment|/* the last element in the list. Keeps 			 * bookkeeping until the end */
if|if
condition|(
name|list2
operator|->
name|firstPtr
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|flags
operator|==
name|LST_CONCLINK
condition|)
block|{
comment|/* 		 * Link the first element of the second list to the last 		 * element of the first list. If the first list isn't empty, 		 * we then link the last element of the list to the first 		 * element of the second list. The last element of the second 		 * list, if it exists, then becomes the last element of the 		 * first list. 		 */
name|list2
operator|->
name|firstPtr
operator|->
name|prevPtr
operator|=
name|list1
operator|->
name|lastPtr
expr_stmt|;
if|if
condition|(
name|list1
operator|->
name|lastPtr
operator|!=
name|NULL
condition|)
name|list1
operator|->
name|lastPtr
operator|->
name|nextPtr
operator|=
name|list2
operator|->
name|firstPtr
expr_stmt|;
else|else
name|list1
operator|->
name|firstPtr
operator|=
name|list2
operator|->
name|firstPtr
expr_stmt|;
name|list1
operator|->
name|lastPtr
operator|=
name|list2
operator|->
name|lastPtr
expr_stmt|;
name|Lst_Init
argument_list|(
name|list2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * The loop simply goes through the entire second list creating 		 * new LstNodes and filling in the nextPtr, and prevPtr to fit 		 * into list1 and its datum field from the datum field of the 		 * corresponding element in list2. The 'last' node follows the 		 * last of the new nodes along until the entire list2 has been 		 * appended. Only then does the bookkeeping catch up with the 		 * changes. During the first iteration of the loop, if 'last' 		 * is NULL, the first list must have been empty so the 		 * newly-created node is made the first node of the list. 		 */
for|for
control|(
name|last
operator|=
name|list1
operator|->
name|lastPtr
operator|,
name|ln
operator|=
name|list2
operator|->
name|firstPtr
init|;
name|ln
operator|!=
name|NULL
condition|;
name|ln
operator|=
name|ln
operator|->
name|nextPtr
control|)
block|{
name|nln
operator|=
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|nln
argument_list|)
argument_list|)
expr_stmt|;
name|nln
operator|->
name|datum
operator|=
name|ln
operator|->
name|datum
expr_stmt|;
if|if
condition|(
name|last
operator|!=
name|NULL
condition|)
block|{
name|last
operator|->
name|nextPtr
operator|=
name|nln
expr_stmt|;
block|}
else|else
block|{
name|list1
operator|->
name|firstPtr
operator|=
name|nln
expr_stmt|;
block|}
name|nln
operator|->
name|prevPtr
operator|=
name|last
expr_stmt|;
name|last
operator|=
name|nln
expr_stmt|;
block|}
comment|/* 		 * Finish bookkeeping. The last new element becomes the last 		 * element of list one. 		 */
name|list1
operator|->
name|lastPtr
operator|=
name|last
expr_stmt|;
name|last
operator|->
name|nextPtr
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * Lst_DeQueue  *	Remove and return the datum at the head of the given list.  *  * Results:  *	The datum in the node at the head or (ick) NULL if the list  *	is empty.  *  * Side Effects:  *	The head node is removed from the list.  */
end_comment

begin_function
name|void
modifier|*
name|Lst_DeQueue
parameter_list|(
name|Lst
modifier|*
name|l
parameter_list|)
block|{
name|void
modifier|*
name|rd
decl_stmt|;
name|LstNode
modifier|*
name|tln
decl_stmt|;
name|tln
operator|=
name|Lst_First
argument_list|(
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|tln
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|rd
operator|=
name|tln
operator|->
name|datum
expr_stmt|;
name|Lst_Remove
argument_list|(
name|l
argument_list|,
name|tln
argument_list|)
expr_stmt|;
return|return
operator|(
name|rd
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Lst_Destroy  *	Destroy a list and free all its resources. If the freeProc is  *	given, it is called with the datum from each node in turn before  *	the node is freed.  *  * Side Effects:  *	The given list is freed in its entirety.  */
end_comment

begin_function
name|void
name|Lst_Destroy
parameter_list|(
name|Lst
modifier|*
name|list
parameter_list|,
name|FreeProc
modifier|*
name|freeProc
parameter_list|)
block|{
name|LstNode
modifier|*
name|ln
decl_stmt|;
if|if
condition|(
name|list
operator|->
name|firstPtr
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|freeProc
operator|!=
name|NOFREE
condition|)
block|{
while|while
condition|(
operator|(
name|ln
operator|=
name|list
operator|->
name|firstPtr
operator|)
operator|!=
name|NULL
condition|)
block|{
name|list
operator|->
name|firstPtr
operator|=
name|ln
operator|->
name|nextPtr
expr_stmt|;
call|(
modifier|*
name|freeProc
call|)
argument_list|(
name|ln
operator|->
name|datum
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ln
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
while|while
condition|(
operator|(
name|ln
operator|=
name|list
operator|->
name|firstPtr
operator|)
operator|!=
name|NULL
condition|)
block|{
name|list
operator|->
name|firstPtr
operator|=
name|ln
operator|->
name|nextPtr
expr_stmt|;
name|free
argument_list|(
name|ln
argument_list|)
expr_stmt|;
block|}
block|}
name|list
operator|->
name|lastPtr
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Lst_Duplicate  *	Duplicate an entire list. If a function to copy a void * is  *	given, the individual client elements will be duplicated as well.  *  * Arguments:  *	dst	the destination list (initialized)  *	src	the list to duplicate  *	copyProc A function to duplicate each void  */
end_comment

begin_function
name|void
name|Lst_Duplicate
parameter_list|(
name|Lst
modifier|*
name|dst
parameter_list|,
name|Lst
modifier|*
name|src
parameter_list|,
name|DuplicateProc
modifier|*
name|copyProc
parameter_list|)
block|{
name|LstNode
modifier|*
name|ln
decl_stmt|;
name|ln
operator|=
name|src
operator|->
name|firstPtr
expr_stmt|;
while|while
condition|(
name|ln
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|copyProc
operator|!=
name|NOCOPY
condition|)
name|Lst_AtEnd
argument_list|(
name|dst
argument_list|,
call|(
modifier|*
name|copyProc
call|)
argument_list|(
name|ln
operator|->
name|datum
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|Lst_AtEnd
argument_list|(
name|dst
argument_list|,
name|ln
operator|->
name|datum
argument_list|)
expr_stmt|;
name|ln
operator|=
name|ln
operator|->
name|nextPtr
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * Lst_Insert  *	Insert a new node with the given piece of data before the given  *	node in the given list.  *  * Parameters:  *	l	list to manipulate  *	ln	node before which to insert d  *	d	datum to be inserted  *  * Side Effects:  *	the firstPtr field will be changed if ln is the first node in the  *	list.  */
end_comment

begin_function
name|void
name|Lst_Insert
parameter_list|(
name|Lst
modifier|*
name|list
parameter_list|,
name|LstNode
modifier|*
name|ln
parameter_list|,
name|void
modifier|*
name|d
parameter_list|)
block|{
name|LstNode
modifier|*
name|nLNode
decl_stmt|;
comment|/* new lnode for d */
name|nLNode
operator|=
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|nLNode
argument_list|)
argument_list|)
expr_stmt|;
name|nLNode
operator|->
name|datum
operator|=
name|d
expr_stmt|;
if|if
condition|(
name|ln
operator|==
name|NULL
condition|)
block|{
name|nLNode
operator|->
name|prevPtr
operator|=
name|nLNode
operator|->
name|nextPtr
operator|=
name|NULL
expr_stmt|;
name|list
operator|->
name|firstPtr
operator|=
name|list
operator|->
name|lastPtr
operator|=
name|nLNode
expr_stmt|;
block|}
else|else
block|{
name|nLNode
operator|->
name|prevPtr
operator|=
name|ln
operator|->
name|prevPtr
expr_stmt|;
name|nLNode
operator|->
name|nextPtr
operator|=
name|ln
expr_stmt|;
if|if
condition|(
name|nLNode
operator|->
name|prevPtr
operator|!=
name|NULL
condition|)
block|{
name|nLNode
operator|->
name|prevPtr
operator|->
name|nextPtr
operator|=
name|nLNode
expr_stmt|;
block|}
name|ln
operator|->
name|prevPtr
operator|=
name|nLNode
expr_stmt|;
if|if
condition|(
name|ln
operator|==
name|list
operator|->
name|firstPtr
condition|)
block|{
name|list
operator|->
name|firstPtr
operator|=
name|nLNode
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|LstNode
modifier|*
name|Lst_Member
parameter_list|(
name|Lst
modifier|*
name|list
parameter_list|,
name|void
modifier|*
name|d
parameter_list|)
block|{
name|LstNode
modifier|*
name|lNode
decl_stmt|;
name|lNode
operator|=
name|list
operator|->
name|firstPtr
expr_stmt|;
if|if
condition|(
name|lNode
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
do|do
block|{
if|if
condition|(
name|lNode
operator|->
name|datum
operator|==
name|d
condition|)
block|{
return|return
operator|(
name|lNode
operator|)
return|;
block|}
name|lNode
operator|=
name|lNode
operator|->
name|nextPtr
expr_stmt|;
block|}
do|while
condition|(
name|lNode
operator|!=
name|NULL
operator|&&
name|lNode
operator|!=
name|list
operator|->
name|firstPtr
condition|)
do|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Lst_Remove  *	Remove the given node from the given list.  *  * Side Effects:  *	The list's firstPtr will be set to NULL if ln is the last  *	node on the list. firsPtr and lastPtr will be altered if ln is  *	either the first or last node, respectively, on the list.  */
end_comment

begin_function
name|void
name|Lst_Remove
parameter_list|(
name|Lst
modifier|*
name|list
parameter_list|,
name|LstNode
modifier|*
name|ln
parameter_list|)
block|{
comment|/* 	 * unlink it from the list 	 */
if|if
condition|(
name|ln
operator|->
name|nextPtr
operator|!=
name|NULL
condition|)
comment|/* unlink from the backward chain */
name|ln
operator|->
name|nextPtr
operator|->
name|prevPtr
operator|=
name|ln
operator|->
name|prevPtr
expr_stmt|;
else|else
comment|/* this was the last element */
name|list
operator|->
name|lastPtr
operator|=
name|ln
operator|->
name|prevPtr
expr_stmt|;
if|if
condition|(
name|ln
operator|->
name|prevPtr
operator|!=
name|NULL
condition|)
comment|/* unlink from the forward chain */
name|ln
operator|->
name|prevPtr
operator|->
name|nextPtr
operator|=
name|ln
operator|->
name|nextPtr
expr_stmt|;
else|else
comment|/* this was the first element */
name|list
operator|->
name|firstPtr
operator|=
name|ln
operator|->
name|nextPtr
expr_stmt|;
comment|/* 	 * note that the datum is unmolested. The caller must free it as 	 * necessary and as expected. 	 */
name|free
argument_list|(
name|ln
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

