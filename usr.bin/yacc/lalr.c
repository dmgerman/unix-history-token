begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1989 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Robert Paul Corbett.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	$FreeBSD$  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
specifier|const
name|sccsid
index|[]
init|=
literal|"@(#)lalr.c	5.3 (Berkeley) 6/1/90"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_typedef
typedef|typedef
struct|struct
name|shorts
block|{
name|struct
name|shorts
modifier|*
name|next
decl_stmt|;
name|short
name|value
decl_stmt|;
block|}
name|shorts
typedef|;
end_typedef

begin_decl_stmt
name|int
name|tokensetsize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
modifier|*
name|lookaheads
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
modifier|*
name|LAruleno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
modifier|*
name|LA
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
modifier|*
name|accessing_symbol
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|core
modifier|*
modifier|*
name|state_table
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|shifts
modifier|*
modifier|*
name|shift_table
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|reductions
modifier|*
modifier|*
name|reduction_table
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
modifier|*
name|goto_map
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
modifier|*
name|from_state
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
modifier|*
name|to_state
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_lookback_edge
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|build_relations
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|compute_FOLLOWS
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|compute_lookaheads
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|digraph
name|__P
argument_list|(
operator|(
name|short
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|initialize_F
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|initialize_LA
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|map_goto
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_accessing_symbol
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_goto_map
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_maxrhs
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_reduction_table
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_shift_table
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_state_table
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
modifier|*
modifier|*
name|transpose
name|__P
argument_list|(
operator|(
name|short
operator|*
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|traverse
name|__P
argument_list|(
operator|(
specifier|register
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|infinity
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|maxrhs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ngotos
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
modifier|*
name|F
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
modifier|*
modifier|*
name|includes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|shorts
modifier|*
modifier|*
name|lookback
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
modifier|*
modifier|*
name|R
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
modifier|*
name|INDEX
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
modifier|*
name|VERTICES
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|top
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|lalr
parameter_list|()
block|{
name|tokensetsize
operator|=
name|WORDSIZE
argument_list|(
name|ntokens
argument_list|)
expr_stmt|;
name|set_state_table
argument_list|()
expr_stmt|;
name|set_accessing_symbol
argument_list|()
expr_stmt|;
name|set_shift_table
argument_list|()
expr_stmt|;
name|set_reduction_table
argument_list|()
expr_stmt|;
name|set_maxrhs
argument_list|()
expr_stmt|;
name|initialize_LA
argument_list|()
expr_stmt|;
name|set_goto_map
argument_list|()
expr_stmt|;
name|initialize_F
argument_list|()
expr_stmt|;
name|build_relations
argument_list|()
expr_stmt|;
name|compute_FOLLOWS
argument_list|()
expr_stmt|;
name|compute_lookaheads
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_state_table
parameter_list|()
block|{
specifier|register
name|core
modifier|*
name|sp
decl_stmt|;
name|state_table
operator|=
name|NEW2
argument_list|(
name|nstates
argument_list|,
name|core
operator|*
argument_list|)
expr_stmt|;
for|for
control|(
name|sp
operator|=
name|first_state
init|;
name|sp
condition|;
name|sp
operator|=
name|sp
operator|->
name|next
control|)
name|state_table
index|[
name|sp
operator|->
name|number
index|]
operator|=
name|sp
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_accessing_symbol
parameter_list|()
block|{
specifier|register
name|core
modifier|*
name|sp
decl_stmt|;
name|accessing_symbol
operator|=
name|NEW2
argument_list|(
name|nstates
argument_list|,
name|short
argument_list|)
expr_stmt|;
for|for
control|(
name|sp
operator|=
name|first_state
init|;
name|sp
condition|;
name|sp
operator|=
name|sp
operator|->
name|next
control|)
name|accessing_symbol
index|[
name|sp
operator|->
name|number
index|]
operator|=
name|sp
operator|->
name|accessing_symbol
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_shift_table
parameter_list|()
block|{
specifier|register
name|shifts
modifier|*
name|sp
decl_stmt|;
name|shift_table
operator|=
name|NEW2
argument_list|(
name|nstates
argument_list|,
name|shifts
operator|*
argument_list|)
expr_stmt|;
for|for
control|(
name|sp
operator|=
name|first_shift
init|;
name|sp
condition|;
name|sp
operator|=
name|sp
operator|->
name|next
control|)
name|shift_table
index|[
name|sp
operator|->
name|number
index|]
operator|=
name|sp
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_reduction_table
parameter_list|()
block|{
specifier|register
name|reductions
modifier|*
name|rp
decl_stmt|;
name|reduction_table
operator|=
name|NEW2
argument_list|(
name|nstates
argument_list|,
name|reductions
operator|*
argument_list|)
expr_stmt|;
for|for
control|(
name|rp
operator|=
name|first_reduction
init|;
name|rp
condition|;
name|rp
operator|=
name|rp
operator|->
name|next
control|)
name|reduction_table
index|[
name|rp
operator|->
name|number
index|]
operator|=
name|rp
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_maxrhs
parameter_list|()
block|{
specifier|register
name|short
modifier|*
name|itemp
decl_stmt|;
specifier|register
name|short
modifier|*
name|item_end
decl_stmt|;
specifier|register
name|int
name|length
decl_stmt|;
specifier|register
name|int
name|max
decl_stmt|;
name|length
operator|=
literal|0
expr_stmt|;
name|max
operator|=
literal|0
expr_stmt|;
name|item_end
operator|=
name|ritem
operator|+
name|nitems
expr_stmt|;
for|for
control|(
name|itemp
operator|=
name|ritem
init|;
name|itemp
operator|<
name|item_end
condition|;
name|itemp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|itemp
operator|>=
literal|0
condition|)
block|{
name|length
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|length
operator|>
name|max
condition|)
name|max
operator|=
name|length
expr_stmt|;
name|length
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|maxrhs
operator|=
name|max
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|initialize_LA
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
specifier|register
name|reductions
modifier|*
name|rp
decl_stmt|;
name|lookaheads
operator|=
name|NEW2
argument_list|(
name|nstates
operator|+
literal|1
argument_list|,
name|short
argument_list|)
expr_stmt|;
name|k
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nstates
condition|;
name|i
operator|++
control|)
block|{
name|lookaheads
index|[
name|i
index|]
operator|=
name|k
expr_stmt|;
name|rp
operator|=
name|reduction_table
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|rp
condition|)
name|k
operator|+=
name|rp
operator|->
name|nreds
expr_stmt|;
block|}
name|lookaheads
index|[
name|nstates
index|]
operator|=
name|k
expr_stmt|;
name|LA
operator|=
name|NEW2
argument_list|(
name|k
operator|*
name|tokensetsize
argument_list|,
name|unsigned
argument_list|)
expr_stmt|;
name|LAruleno
operator|=
name|NEW2
argument_list|(
name|k
argument_list|,
name|short
argument_list|)
expr_stmt|;
name|lookback
operator|=
name|NEW2
argument_list|(
name|k
argument_list|,
name|shorts
operator|*
argument_list|)
expr_stmt|;
name|k
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nstates
condition|;
name|i
operator|++
control|)
block|{
name|rp
operator|=
name|reduction_table
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|rp
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|rp
operator|->
name|nreds
condition|;
name|j
operator|++
control|)
block|{
name|LAruleno
index|[
name|k
index|]
operator|=
name|rp
operator|->
name|rules
index|[
name|j
index|]
expr_stmt|;
name|k
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|set_goto_map
parameter_list|()
block|{
specifier|register
name|shifts
modifier|*
name|sp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|symbol
decl_stmt|;
specifier|register
name|int
name|k
decl_stmt|;
specifier|register
name|short
modifier|*
name|temp_map
decl_stmt|;
specifier|register
name|int
name|state2
decl_stmt|;
specifier|register
name|int
name|state1
decl_stmt|;
name|goto_map
operator|=
name|NEW2
argument_list|(
name|nvars
operator|+
literal|1
argument_list|,
name|short
argument_list|)
operator|-
name|ntokens
expr_stmt|;
name|temp_map
operator|=
name|NEW2
argument_list|(
name|nvars
operator|+
literal|1
argument_list|,
name|short
argument_list|)
operator|-
name|ntokens
expr_stmt|;
name|ngotos
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|sp
operator|=
name|first_shift
init|;
name|sp
condition|;
name|sp
operator|=
name|sp
operator|->
name|next
control|)
block|{
for|for
control|(
name|i
operator|=
name|sp
operator|->
name|nshifts
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|symbol
operator|=
name|accessing_symbol
index|[
name|sp
operator|->
name|shift
index|[
name|i
index|]
index|]
expr_stmt|;
if|if
condition|(
name|ISTOKEN
argument_list|(
name|symbol
argument_list|)
condition|)
break|break;
if|if
condition|(
name|ngotos
operator|==
name|MAXSHORT
condition|)
name|fatal
argument_list|(
literal|"too many gotos"
argument_list|)
expr_stmt|;
name|ngotos
operator|++
expr_stmt|;
name|goto_map
index|[
name|symbol
index|]
operator|++
expr_stmt|;
block|}
block|}
name|k
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|ntokens
init|;
name|i
operator|<
name|nsyms
condition|;
name|i
operator|++
control|)
block|{
name|temp_map
index|[
name|i
index|]
operator|=
name|k
expr_stmt|;
name|k
operator|+=
name|goto_map
index|[
name|i
index|]
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|ntokens
init|;
name|i
operator|<
name|nsyms
condition|;
name|i
operator|++
control|)
name|goto_map
index|[
name|i
index|]
operator|=
name|temp_map
index|[
name|i
index|]
expr_stmt|;
name|goto_map
index|[
name|nsyms
index|]
operator|=
name|ngotos
expr_stmt|;
name|temp_map
index|[
name|nsyms
index|]
operator|=
name|ngotos
expr_stmt|;
name|from_state
operator|=
name|NEW2
argument_list|(
name|ngotos
argument_list|,
name|short
argument_list|)
expr_stmt|;
name|to_state
operator|=
name|NEW2
argument_list|(
name|ngotos
argument_list|,
name|short
argument_list|)
expr_stmt|;
for|for
control|(
name|sp
operator|=
name|first_shift
init|;
name|sp
condition|;
name|sp
operator|=
name|sp
operator|->
name|next
control|)
block|{
name|state1
operator|=
name|sp
operator|->
name|number
expr_stmt|;
for|for
control|(
name|i
operator|=
name|sp
operator|->
name|nshifts
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|state2
operator|=
name|sp
operator|->
name|shift
index|[
name|i
index|]
expr_stmt|;
name|symbol
operator|=
name|accessing_symbol
index|[
name|state2
index|]
expr_stmt|;
if|if
condition|(
name|ISTOKEN
argument_list|(
name|symbol
argument_list|)
condition|)
break|break;
name|k
operator|=
name|temp_map
index|[
name|symbol
index|]
operator|++
expr_stmt|;
name|from_state
index|[
name|k
index|]
operator|=
name|state1
expr_stmt|;
name|to_state
index|[
name|k
index|]
operator|=
name|state2
expr_stmt|;
block|}
block|}
name|FREE
argument_list|(
name|temp_map
operator|+
name|ntokens
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  Map_goto maps a state/symbol pair into its numeric representation.	*/
end_comment

begin_function
specifier|static
name|int
name|map_goto
parameter_list|(
name|state
parameter_list|,
name|symbol
parameter_list|)
name|int
name|state
decl_stmt|;
name|int
name|symbol
decl_stmt|;
block|{
specifier|register
name|int
name|high
decl_stmt|;
specifier|register
name|int
name|low
decl_stmt|;
specifier|register
name|int
name|middle
decl_stmt|;
specifier|register
name|int
name|s
decl_stmt|;
name|low
operator|=
name|goto_map
index|[
name|symbol
index|]
expr_stmt|;
name|high
operator|=
name|goto_map
index|[
name|symbol
operator|+
literal|1
index|]
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|assert
argument_list|(
name|low
operator|<=
name|high
argument_list|)
expr_stmt|;
name|middle
operator|=
operator|(
name|low
operator|+
name|high
operator|)
operator|>>
literal|1
expr_stmt|;
name|s
operator|=
name|from_state
index|[
name|middle
index|]
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|state
condition|)
return|return
operator|(
name|middle
operator|)
return|;
elseif|else
if|if
condition|(
name|s
operator|<
name|state
condition|)
name|low
operator|=
name|middle
operator|+
literal|1
expr_stmt|;
else|else
name|high
operator|=
name|middle
operator|-
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|initialize_F
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
specifier|register
name|int
name|k
decl_stmt|;
specifier|register
name|shifts
modifier|*
name|sp
decl_stmt|;
specifier|register
name|short
modifier|*
name|edge
decl_stmt|;
specifier|register
name|unsigned
modifier|*
name|rowp
decl_stmt|;
specifier|register
name|short
modifier|*
name|rp
decl_stmt|;
specifier|register
name|short
modifier|*
modifier|*
name|reads
decl_stmt|;
specifier|register
name|int
name|nedges
decl_stmt|;
specifier|register
name|int
name|stateno
decl_stmt|;
specifier|register
name|int
name|symbol
decl_stmt|;
specifier|register
name|int
name|nwords
decl_stmt|;
name|nwords
operator|=
name|ngotos
operator|*
name|tokensetsize
expr_stmt|;
name|F
operator|=
name|NEW2
argument_list|(
name|nwords
argument_list|,
name|unsigned
argument_list|)
expr_stmt|;
name|reads
operator|=
name|NEW2
argument_list|(
name|ngotos
argument_list|,
name|short
operator|*
argument_list|)
expr_stmt|;
name|edge
operator|=
name|NEW2
argument_list|(
name|ngotos
operator|+
literal|1
argument_list|,
name|short
argument_list|)
expr_stmt|;
name|nedges
operator|=
literal|0
expr_stmt|;
name|rowp
operator|=
name|F
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ngotos
condition|;
name|i
operator|++
control|)
block|{
name|stateno
operator|=
name|to_state
index|[
name|i
index|]
expr_stmt|;
name|sp
operator|=
name|shift_table
index|[
name|stateno
index|]
expr_stmt|;
if|if
condition|(
name|sp
condition|)
block|{
name|k
operator|=
name|sp
operator|->
name|nshifts
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|k
condition|;
name|j
operator|++
control|)
block|{
name|symbol
operator|=
name|accessing_symbol
index|[
name|sp
operator|->
name|shift
index|[
name|j
index|]
index|]
expr_stmt|;
if|if
condition|(
name|ISVAR
argument_list|(
name|symbol
argument_list|)
condition|)
break|break;
name|SETBIT
argument_list|(
name|rowp
argument_list|,
name|symbol
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
name|j
operator|<
name|k
condition|;
name|j
operator|++
control|)
block|{
name|symbol
operator|=
name|accessing_symbol
index|[
name|sp
operator|->
name|shift
index|[
name|j
index|]
index|]
expr_stmt|;
if|if
condition|(
name|nullable
index|[
name|symbol
index|]
condition|)
name|edge
index|[
name|nedges
operator|++
index|]
operator|=
name|map_goto
argument_list|(
name|stateno
argument_list|,
name|symbol
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nedges
condition|)
block|{
name|reads
index|[
name|i
index|]
operator|=
name|rp
operator|=
name|NEW2
argument_list|(
name|nedges
operator|+
literal|1
argument_list|,
name|short
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nedges
condition|;
name|j
operator|++
control|)
name|rp
index|[
name|j
index|]
operator|=
name|edge
index|[
name|j
index|]
expr_stmt|;
name|rp
index|[
name|nedges
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|nedges
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|rowp
operator|+=
name|tokensetsize
expr_stmt|;
block|}
name|SETBIT
argument_list|(
name|F
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|digraph
argument_list|(
name|reads
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ngotos
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|reads
index|[
name|i
index|]
condition|)
name|FREE
argument_list|(
name|reads
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|FREE
argument_list|(
name|reads
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|edge
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|build_relations
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
specifier|register
name|int
name|k
decl_stmt|;
specifier|register
name|short
modifier|*
name|rulep
decl_stmt|;
specifier|register
name|short
modifier|*
name|rp
decl_stmt|;
specifier|register
name|shifts
modifier|*
name|sp
decl_stmt|;
specifier|register
name|int
name|length
decl_stmt|;
specifier|register
name|int
name|nedges
decl_stmt|;
specifier|register
name|int
name|done
decl_stmt|;
specifier|register
name|int
name|state1
decl_stmt|;
specifier|register
name|int
name|stateno
decl_stmt|;
specifier|register
name|int
name|symbol1
decl_stmt|;
specifier|register
name|int
name|symbol2
decl_stmt|;
specifier|register
name|short
modifier|*
name|shortp
decl_stmt|;
specifier|register
name|short
modifier|*
name|edge
decl_stmt|;
specifier|register
name|short
modifier|*
name|states
decl_stmt|;
specifier|register
name|short
modifier|*
modifier|*
name|new_includes
decl_stmt|;
name|includes
operator|=
name|NEW2
argument_list|(
name|ngotos
argument_list|,
name|short
operator|*
argument_list|)
expr_stmt|;
name|edge
operator|=
name|NEW2
argument_list|(
name|ngotos
operator|+
literal|1
argument_list|,
name|short
argument_list|)
expr_stmt|;
name|states
operator|=
name|NEW2
argument_list|(
name|maxrhs
operator|+
literal|1
argument_list|,
name|short
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ngotos
condition|;
name|i
operator|++
control|)
block|{
name|nedges
operator|=
literal|0
expr_stmt|;
name|state1
operator|=
name|from_state
index|[
name|i
index|]
expr_stmt|;
name|symbol1
operator|=
name|accessing_symbol
index|[
name|to_state
index|[
name|i
index|]
index|]
expr_stmt|;
for|for
control|(
name|rulep
operator|=
name|derives
index|[
name|symbol1
index|]
init|;
operator|*
name|rulep
operator|>=
literal|0
condition|;
name|rulep
operator|++
control|)
block|{
name|length
operator|=
literal|1
expr_stmt|;
name|states
index|[
literal|0
index|]
operator|=
name|state1
expr_stmt|;
name|stateno
operator|=
name|state1
expr_stmt|;
for|for
control|(
name|rp
operator|=
name|ritem
operator|+
name|rrhs
index|[
operator|*
name|rulep
index|]
init|;
operator|*
name|rp
operator|>=
literal|0
condition|;
name|rp
operator|++
control|)
block|{
name|symbol2
operator|=
operator|*
name|rp
expr_stmt|;
name|sp
operator|=
name|shift_table
index|[
name|stateno
index|]
expr_stmt|;
name|k
operator|=
name|sp
operator|->
name|nshifts
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|k
condition|;
name|j
operator|++
control|)
block|{
name|stateno
operator|=
name|sp
operator|->
name|shift
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|accessing_symbol
index|[
name|stateno
index|]
operator|==
name|symbol2
condition|)
break|break;
block|}
name|states
index|[
name|length
operator|++
index|]
operator|=
name|stateno
expr_stmt|;
block|}
name|add_lookback_edge
argument_list|(
name|stateno
argument_list|,
operator|*
name|rulep
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|length
operator|--
expr_stmt|;
name|done
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|done
condition|)
block|{
name|done
operator|=
literal|1
expr_stmt|;
name|rp
operator|--
expr_stmt|;
if|if
condition|(
name|ISVAR
argument_list|(
operator|*
name|rp
argument_list|)
condition|)
block|{
name|stateno
operator|=
name|states
index|[
operator|--
name|length
index|]
expr_stmt|;
name|edge
index|[
name|nedges
operator|++
index|]
operator|=
name|map_goto
argument_list|(
name|stateno
argument_list|,
operator|*
name|rp
argument_list|)
expr_stmt|;
if|if
condition|(
name|nullable
index|[
operator|*
name|rp
index|]
operator|&&
name|length
operator|>
literal|0
condition|)
name|done
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|nedges
condition|)
block|{
name|includes
index|[
name|i
index|]
operator|=
name|shortp
operator|=
name|NEW2
argument_list|(
name|nedges
operator|+
literal|1
argument_list|,
name|short
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nedges
condition|;
name|j
operator|++
control|)
name|shortp
index|[
name|j
index|]
operator|=
name|edge
index|[
name|j
index|]
expr_stmt|;
name|shortp
index|[
name|nedges
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
name|new_includes
operator|=
name|transpose
argument_list|(
name|includes
argument_list|,
name|ngotos
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ngotos
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|includes
index|[
name|i
index|]
condition|)
name|FREE
argument_list|(
name|includes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|includes
argument_list|)
expr_stmt|;
name|includes
operator|=
name|new_includes
expr_stmt|;
name|FREE
argument_list|(
name|edge
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|states
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|add_lookback_edge
parameter_list|(
name|stateno
parameter_list|,
name|ruleno
parameter_list|,
name|gotono
parameter_list|)
name|int
name|stateno
decl_stmt|,
name|ruleno
decl_stmt|,
name|gotono
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|k
decl_stmt|;
specifier|register
name|int
name|found
decl_stmt|;
specifier|register
name|shorts
modifier|*
name|sp
decl_stmt|;
name|i
operator|=
name|lookaheads
index|[
name|stateno
index|]
expr_stmt|;
name|k
operator|=
name|lookaheads
index|[
name|stateno
operator|+
literal|1
index|]
expr_stmt|;
name|found
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|found
operator|&&
name|i
operator|<
name|k
condition|)
block|{
if|if
condition|(
name|LAruleno
index|[
name|i
index|]
operator|==
name|ruleno
condition|)
name|found
operator|=
literal|1
expr_stmt|;
else|else
operator|++
name|i
expr_stmt|;
block|}
name|assert
argument_list|(
name|found
argument_list|)
expr_stmt|;
name|sp
operator|=
name|NEW
argument_list|(
name|shorts
argument_list|)
expr_stmt|;
name|sp
operator|->
name|next
operator|=
name|lookback
index|[
name|i
index|]
expr_stmt|;
name|sp
operator|->
name|value
operator|=
name|gotono
expr_stmt|;
name|lookback
index|[
name|i
index|]
operator|=
name|sp
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|short
modifier|*
modifier|*
name|transpose
parameter_list|(
name|R
parameter_list|,
name|n
parameter_list|)
name|short
modifier|*
modifier|*
name|R
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
specifier|register
name|short
modifier|*
modifier|*
name|new_R
decl_stmt|;
specifier|register
name|short
modifier|*
modifier|*
name|temp_R
decl_stmt|;
specifier|register
name|short
modifier|*
name|nedges
decl_stmt|;
specifier|register
name|short
modifier|*
name|sp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|k
decl_stmt|;
name|nedges
operator|=
name|NEW2
argument_list|(
name|n
argument_list|,
name|short
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|sp
operator|=
name|R
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|sp
condition|)
block|{
while|while
condition|(
operator|*
name|sp
operator|>=
literal|0
condition|)
name|nedges
index|[
operator|*
name|sp
operator|++
index|]
operator|++
expr_stmt|;
block|}
block|}
name|new_R
operator|=
name|NEW2
argument_list|(
name|n
argument_list|,
name|short
operator|*
argument_list|)
expr_stmt|;
name|temp_R
operator|=
name|NEW2
argument_list|(
name|n
argument_list|,
name|short
operator|*
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|k
operator|=
name|nedges
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|k
operator|>
literal|0
condition|)
block|{
name|sp
operator|=
name|NEW2
argument_list|(
name|k
operator|+
literal|1
argument_list|,
name|short
argument_list|)
expr_stmt|;
name|new_R
index|[
name|i
index|]
operator|=
name|sp
expr_stmt|;
name|temp_R
index|[
name|i
index|]
operator|=
name|sp
expr_stmt|;
name|sp
index|[
name|k
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
name|FREE
argument_list|(
name|nedges
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|sp
operator|=
name|R
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|sp
condition|)
block|{
while|while
condition|(
operator|*
name|sp
operator|>=
literal|0
condition|)
operator|*
name|temp_R
index|[
operator|*
name|sp
operator|++
index|]
operator|++
operator|=
name|i
expr_stmt|;
block|}
block|}
name|FREE
argument_list|(
name|temp_R
argument_list|)
expr_stmt|;
return|return
operator|(
name|new_R
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|compute_FOLLOWS
parameter_list|()
block|{
name|digraph
argument_list|(
name|includes
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|compute_lookaheads
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
specifier|register
name|unsigned
modifier|*
name|fp1
decl_stmt|,
modifier|*
name|fp2
decl_stmt|,
modifier|*
name|fp3
decl_stmt|;
specifier|register
name|shorts
modifier|*
name|sp
decl_stmt|,
modifier|*
name|next
decl_stmt|;
specifier|register
name|unsigned
modifier|*
name|rowp
decl_stmt|;
name|rowp
operator|=
name|LA
expr_stmt|;
name|n
operator|=
name|lookaheads
index|[
name|nstates
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|fp3
operator|=
name|rowp
operator|+
name|tokensetsize
expr_stmt|;
for|for
control|(
name|sp
operator|=
name|lookback
index|[
name|i
index|]
init|;
name|sp
condition|;
name|sp
operator|=
name|sp
operator|->
name|next
control|)
block|{
name|fp1
operator|=
name|rowp
expr_stmt|;
name|fp2
operator|=
name|F
operator|+
name|tokensetsize
operator|*
name|sp
operator|->
name|value
expr_stmt|;
while|while
condition|(
name|fp1
operator|<
name|fp3
condition|)
operator|*
name|fp1
operator|++
operator||=
operator|*
name|fp2
operator|++
expr_stmt|;
block|}
name|rowp
operator|=
name|fp3
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
for|for
control|(
name|sp
operator|=
name|lookback
index|[
name|i
index|]
init|;
name|sp
condition|;
name|sp
operator|=
name|next
control|)
block|{
name|next
operator|=
name|sp
operator|->
name|next
expr_stmt|;
name|FREE
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|}
name|FREE
argument_list|(
name|lookback
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|F
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|digraph
parameter_list|(
name|relation
parameter_list|)
name|short
modifier|*
modifier|*
name|relation
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|infinity
operator|=
name|ngotos
operator|+
literal|2
expr_stmt|;
name|INDEX
operator|=
name|NEW2
argument_list|(
name|ngotos
operator|+
literal|1
argument_list|,
name|short
argument_list|)
expr_stmt|;
name|VERTICES
operator|=
name|NEW2
argument_list|(
name|ngotos
operator|+
literal|1
argument_list|,
name|short
argument_list|)
expr_stmt|;
name|top
operator|=
literal|0
expr_stmt|;
name|R
operator|=
name|relation
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ngotos
condition|;
name|i
operator|++
control|)
name|INDEX
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ngotos
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|INDEX
index|[
name|i
index|]
operator|==
literal|0
operator|&&
name|R
index|[
name|i
index|]
condition|)
name|traverse
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
name|FREE
argument_list|(
name|INDEX
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|VERTICES
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|traverse
parameter_list|(
name|i
parameter_list|)
specifier|register
name|int
name|i
decl_stmt|;
block|{
specifier|register
name|unsigned
modifier|*
name|fp1
decl_stmt|;
specifier|register
name|unsigned
modifier|*
name|fp2
decl_stmt|;
specifier|register
name|unsigned
modifier|*
name|fp3
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
specifier|register
name|short
modifier|*
name|rp
decl_stmt|;
name|int
name|height
decl_stmt|;
name|unsigned
modifier|*
name|base
decl_stmt|;
name|VERTICES
index|[
operator|++
name|top
index|]
operator|=
name|i
expr_stmt|;
name|INDEX
index|[
name|i
index|]
operator|=
name|height
operator|=
name|top
expr_stmt|;
name|base
operator|=
name|F
operator|+
name|i
operator|*
name|tokensetsize
expr_stmt|;
name|fp3
operator|=
name|base
operator|+
name|tokensetsize
expr_stmt|;
name|rp
operator|=
name|R
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|rp
condition|)
block|{
while|while
condition|(
operator|(
name|j
operator|=
operator|*
name|rp
operator|++
operator|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|INDEX
index|[
name|j
index|]
operator|==
literal|0
condition|)
name|traverse
argument_list|(
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|INDEX
index|[
name|i
index|]
operator|>
name|INDEX
index|[
name|j
index|]
condition|)
name|INDEX
index|[
name|i
index|]
operator|=
name|INDEX
index|[
name|j
index|]
expr_stmt|;
name|fp1
operator|=
name|base
expr_stmt|;
name|fp2
operator|=
name|F
operator|+
name|j
operator|*
name|tokensetsize
expr_stmt|;
while|while
condition|(
name|fp1
operator|<
name|fp3
condition|)
operator|*
name|fp1
operator|++
operator||=
operator|*
name|fp2
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|INDEX
index|[
name|i
index|]
operator|==
name|height
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|j
operator|=
name|VERTICES
index|[
name|top
operator|--
index|]
expr_stmt|;
name|INDEX
index|[
name|j
index|]
operator|=
name|infinity
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|j
condition|)
break|break;
name|fp1
operator|=
name|base
expr_stmt|;
name|fp2
operator|=
name|F
operator|+
name|j
operator|*
name|tokensetsize
expr_stmt|;
while|while
condition|(
name|fp1
operator|<
name|fp3
condition|)
operator|*
name|fp2
operator|++
operator|=
operator|*
name|fp1
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

end_unit

