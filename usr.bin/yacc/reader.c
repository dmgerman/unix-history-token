begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1989 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Robert Paul Corbett.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_endif
unit|static char sccsid[] = "@(#)reader.c	5.7 (Berkeley) 1/20/91";
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_comment
comment|/*  The line size must be a positive integer.  One hundred was chosen	*/
end_comment

begin_comment
comment|/*  because few lines in Yacc input grammars exceed 100 characters.	*/
end_comment

begin_comment
comment|/*  Note that if a line exceeds LINESIZE characters, the line buffer	*/
end_comment

begin_comment
comment|/*  will be expanded to accomodate it.					*/
end_comment

begin_define
define|#
directive|define
name|LINESIZE
value|100
end_define

begin_decl_stmt
name|char
modifier|*
name|cache
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cinc
decl_stmt|,
name|cache_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ntags
decl_stmt|,
name|tagmax
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|tag_table
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|saw_eof
decl_stmt|,
name|unionized
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|cptr
decl_stmt|,
modifier|*
name|line
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|linesize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bucket
modifier|*
name|goal
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|prec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|gensym
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|last_was_action
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|maxitems
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bucket
modifier|*
modifier|*
name|pitem
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|maxrules
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bucket
modifier|*
modifier|*
name|plhs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|name_pool_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|name_pool
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|line_format
index|[]
init|=
literal|"#line %d \"%s\"\n"
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|add_symbol
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|advance_to_start
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cachec
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|check_symbols
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|copy_action
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|copy_ident
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|copy_text
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|copy_union
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|declare_expect
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|declare_start
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|declare_tokens
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|declare_types
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|dup_line
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|end_rule
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|expand_items
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|expand_rules
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_tags
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|get_line
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bucket
modifier|*
name|get_literal
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bucket
modifier|*
name|get_name
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_number
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|get_tag
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hexval
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|initialize_grammar
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|insert_empty_rule
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|is_reserved
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|keyword
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mark_symbol
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nextc
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pack_grammar
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pack_names
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pack_symbols
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_grammar
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|read_declarations
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|read_grammar
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|skip_comment
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|start_rule
parameter_list|(
name|bucket
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|cachec
parameter_list|(
name|c
parameter_list|)
name|int
name|c
decl_stmt|;
block|{
name|assert
argument_list|(
name|cinc
operator|>=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cinc
operator|>=
name|cache_size
condition|)
block|{
name|cache_size
operator|+=
literal|256
expr_stmt|;
name|cache
operator|=
name|REALLOC
argument_list|(
name|cache
argument_list|,
name|cache_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|cache
operator|==
literal|0
condition|)
name|no_space
argument_list|()
expr_stmt|;
block|}
name|cache
index|[
name|cinc
index|]
operator|=
name|c
expr_stmt|;
operator|++
name|cinc
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|get_line
parameter_list|()
block|{
name|FILE
modifier|*
name|f
init|=
name|input_file
decl_stmt|;
name|int
name|c
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|saw_eof
operator|||
operator|(
name|c
operator|=
name|getc
argument_list|(
name|f
argument_list|)
operator|)
operator|==
name|EOF
condition|)
block|{
if|if
condition|(
name|line
condition|)
block|{
name|FREE
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|line
operator|=
literal|0
expr_stmt|;
block|}
name|cptr
operator|=
literal|0
expr_stmt|;
name|saw_eof
operator|=
literal|1
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|line
operator|==
literal|0
operator|||
name|linesize
operator|!=
operator|(
name|LINESIZE
operator|+
literal|1
operator|)
condition|)
block|{
if|if
condition|(
name|line
condition|)
name|FREE
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|linesize
operator|=
name|LINESIZE
operator|+
literal|1
expr_stmt|;
name|line
operator|=
name|MALLOC
argument_list|(
name|linesize
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|==
literal|0
condition|)
name|no_space
argument_list|()
expr_stmt|;
block|}
name|i
operator|=
literal|0
expr_stmt|;
operator|++
name|lineno
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|line
index|[
name|i
index|]
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
name|cptr
operator|=
name|line
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|++
name|i
operator|>=
name|linesize
condition|)
block|{
name|linesize
operator|+=
name|LINESIZE
expr_stmt|;
name|line
operator|=
name|REALLOC
argument_list|(
name|line
argument_list|,
name|linesize
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|==
literal|0
condition|)
name|no_space
argument_list|()
expr_stmt|;
block|}
name|c
operator|=
name|getc
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
name|line
index|[
name|i
index|]
operator|=
literal|'\n'
expr_stmt|;
name|saw_eof
operator|=
literal|1
expr_stmt|;
name|cptr
operator|=
name|line
expr_stmt|;
return|return;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|dup_line
parameter_list|()
block|{
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|s
decl_stmt|,
modifier|*
name|t
decl_stmt|;
if|if
condition|(
name|line
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|s
operator|=
name|line
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|!=
literal|'\n'
condition|)
operator|++
name|s
expr_stmt|;
name|p
operator|=
name|MALLOC
argument_list|(
name|s
operator|-
name|line
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
condition|)
name|no_space
argument_list|()
expr_stmt|;
name|s
operator|=
name|line
expr_stmt|;
name|t
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|t
operator|++
operator|=
operator|*
name|s
operator|++
operator|)
operator|!=
literal|'\n'
condition|)
continue|continue;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|skip_comment
parameter_list|()
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|st_lineno
init|=
name|lineno
decl_stmt|;
name|char
modifier|*
name|st_line
init|=
name|dup_line
argument_list|()
decl_stmt|;
name|char
modifier|*
name|st_cptr
init|=
name|st_line
operator|+
operator|(
name|cptr
operator|-
name|line
operator|)
decl_stmt|;
name|s
operator|=
name|cptr
operator|+
literal|2
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'*'
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|'/'
condition|)
block|{
name|cptr
operator|=
name|s
operator|+
literal|2
expr_stmt|;
name|FREE
argument_list|(
name|st_line
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|*
name|s
operator|==
literal|'\n'
condition|)
block|{
name|get_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|line
operator|==
literal|0
condition|)
name|unterminated_comment
argument_list|(
name|st_lineno
argument_list|,
name|st_line
argument_list|,
name|st_cptr
argument_list|)
expr_stmt|;
name|s
operator|=
name|cptr
expr_stmt|;
block|}
else|else
operator|++
name|s
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|nextc
parameter_list|()
block|{
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|line
operator|==
literal|0
condition|)
block|{
name|get_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|line
operator|==
literal|0
condition|)
return|return
operator|(
name|EOF
operator|)
return|;
block|}
name|s
operator|=
name|cptr
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|'\n'
case|:
name|get_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|line
operator|==
literal|0
condition|)
return|return
operator|(
name|EOF
operator|)
return|;
name|s
operator|=
name|cptr
expr_stmt|;
break|break;
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
case|case
literal|'\f'
case|:
case|case
literal|'\r'
case|:
case|case
literal|'\v'
case|:
case|case
literal|','
case|:
case|case
literal|';'
case|:
operator|++
name|s
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
name|cptr
operator|=
name|s
expr_stmt|;
return|return
operator|(
literal|'%'
operator|)
return|;
case|case
literal|'/'
case|:
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'*'
condition|)
block|{
name|cptr
operator|=
name|s
expr_stmt|;
name|skip_comment
argument_list|()
expr_stmt|;
name|s
operator|=
name|cptr
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'/'
condition|)
block|{
name|get_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|line
operator|==
literal|0
condition|)
return|return
operator|(
name|EOF
operator|)
return|;
name|s
operator|=
name|cptr
expr_stmt|;
break|break;
block|}
comment|/* fall through */
default|default:
name|cptr
operator|=
name|s
expr_stmt|;
return|return
operator|(
operator|*
name|s
operator|)
return|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|keyword
parameter_list|()
block|{
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|t_cptr
init|=
name|cptr
decl_stmt|;
name|c
operator|=
operator|*
operator|++
name|cptr
expr_stmt|;
if|if
condition|(
name|isalpha
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|cinc
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|isalpha
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|isupper
argument_list|(
name|c
argument_list|)
condition|)
name|c
operator|=
name|tolower
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|cachec
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isdigit
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'_'
operator|||
name|c
operator|==
literal|'.'
operator|||
name|c
operator|==
literal|'$'
condition|)
name|cachec
argument_list|(
name|c
argument_list|)
expr_stmt|;
else|else
break|break;
name|c
operator|=
operator|*
operator|++
name|cptr
expr_stmt|;
block|}
name|cachec
argument_list|(
name|NUL
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|cache
argument_list|,
literal|"token"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|cache
argument_list|,
literal|"term"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|TOKEN
operator|)
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|cache
argument_list|,
literal|"type"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|TYPE
operator|)
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|cache
argument_list|,
literal|"left"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|LEFT
operator|)
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|cache
argument_list|,
literal|"right"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|RIGHT
operator|)
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|cache
argument_list|,
literal|"nonassoc"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|cache
argument_list|,
literal|"binary"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|NONASSOC
operator|)
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|cache
argument_list|,
literal|"start"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|START
operator|)
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|cache
argument_list|,
literal|"union"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|UNION
operator|)
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|cache
argument_list|,
literal|"ident"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|IDENT
operator|)
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|cache
argument_list|,
literal|"expect"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EXPECT
operator|)
return|;
block|}
else|else
block|{
operator|++
name|cptr
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'{'
condition|)
return|return
operator|(
name|TEXT
operator|)
return|;
if|if
condition|(
name|c
operator|==
literal|'%'
operator|||
name|c
operator|==
literal|'\\'
condition|)
return|return
operator|(
name|MARK
operator|)
return|;
if|if
condition|(
name|c
operator|==
literal|'<'
condition|)
return|return
operator|(
name|LEFT
operator|)
return|;
if|if
condition|(
name|c
operator|==
literal|'>'
condition|)
return|return
operator|(
name|RIGHT
operator|)
return|;
if|if
condition|(
name|c
operator|==
literal|'0'
condition|)
return|return
operator|(
name|TOKEN
operator|)
return|;
if|if
condition|(
name|c
operator|==
literal|'2'
condition|)
return|return
operator|(
name|NONASSOC
operator|)
return|;
block|}
name|syntax_error
argument_list|(
name|lineno
argument_list|,
name|line
argument_list|,
name|t_cptr
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|copy_ident
parameter_list|()
block|{
name|int
name|c
decl_stmt|;
name|FILE
modifier|*
name|f
init|=
name|output_file
decl_stmt|;
name|c
operator|=
name|nextc
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
name|unexpected_EOF
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'"'
condition|)
name|syntax_error
argument_list|(
name|lineno
argument_list|,
name|line
argument_list|,
name|cptr
argument_list|)
expr_stmt|;
operator|++
name|outline
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"#ident \""
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
operator|*
operator|++
name|cptr
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\"\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|putc
argument_list|(
name|c
argument_list|,
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'"'
condition|)
block|{
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|f
argument_list|)
expr_stmt|;
operator|++
name|cptr
expr_stmt|;
return|return;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|copy_text
parameter_list|()
block|{
name|int
name|c
decl_stmt|;
name|int
name|quote
decl_stmt|;
name|FILE
modifier|*
name|f
init|=
name|text_file
decl_stmt|;
name|int
name|need_newline
init|=
literal|0
decl_stmt|;
name|int
name|t_lineno
init|=
name|lineno
decl_stmt|;
name|char
modifier|*
name|t_line
init|=
name|dup_line
argument_list|()
decl_stmt|;
name|char
modifier|*
name|t_cptr
init|=
name|t_line
operator|+
operator|(
name|cptr
operator|-
name|line
operator|-
literal|2
operator|)
decl_stmt|;
if|if
condition|(
operator|*
name|cptr
operator|==
literal|'\n'
condition|)
block|{
name|get_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|line
operator|==
literal|0
condition|)
name|unterminated_text
argument_list|(
name|t_lineno
argument_list|,
name|t_line
argument_list|,
name|t_cptr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|lflag
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
name|line_format
argument_list|,
name|lineno
argument_list|,
name|input_file_name
argument_list|)
expr_stmt|;
name|loop
label|:
name|c
operator|=
operator|*
name|cptr
operator|++
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\n'
case|:
name|next_line
label|:
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|need_newline
operator|=
literal|0
expr_stmt|;
name|get_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|line
condition|)
goto|goto
name|loop
goto|;
name|unterminated_text
argument_list|(
name|t_lineno
argument_list|,
name|t_line
argument_list|,
name|t_cptr
argument_list|)
expr_stmt|;
case|case
literal|'\''
case|:
case|case
literal|'"'
case|:
block|{
name|int
name|s_lineno
init|=
name|lineno
decl_stmt|;
name|char
modifier|*
name|s_line
init|=
name|dup_line
argument_list|()
decl_stmt|;
name|char
modifier|*
name|s_cptr
init|=
name|s_line
operator|+
operator|(
name|cptr
operator|-
name|line
operator|-
literal|1
operator|)
decl_stmt|;
name|quote
operator|=
name|c
expr_stmt|;
name|putc
argument_list|(
name|c
argument_list|,
name|f
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
operator|*
name|cptr
operator|++
expr_stmt|;
name|putc
argument_list|(
name|c
argument_list|,
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|quote
condition|)
block|{
name|need_newline
operator|=
literal|1
expr_stmt|;
name|FREE
argument_list|(
name|s_line
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
name|unterminated_string
argument_list|(
name|s_lineno
argument_list|,
name|s_line
argument_list|,
name|s_cptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
name|c
operator|=
operator|*
name|cptr
operator|++
expr_stmt|;
name|putc
argument_list|(
name|c
argument_list|,
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
name|get_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|line
operator|==
literal|0
condition|)
name|unterminated_string
argument_list|(
name|s_lineno
argument_list|,
name|s_line
argument_list|,
name|s_cptr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
case|case
literal|'/'
case|:
name|putc
argument_list|(
name|c
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|need_newline
operator|=
literal|1
expr_stmt|;
name|c
operator|=
operator|*
name|cptr
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'/'
condition|)
block|{
name|putc
argument_list|(
literal|'*'
argument_list|,
name|f
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
operator|++
name|cptr
operator|)
operator|!=
literal|'\n'
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'*'
operator|&&
name|cptr
index|[
literal|1
index|]
operator|==
literal|'/'
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"* "
argument_list|)
expr_stmt|;
else|else
name|putc
argument_list|(
name|c
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"*/"
argument_list|)
expr_stmt|;
goto|goto
name|next_line
goto|;
block|}
if|if
condition|(
name|c
operator|==
literal|'*'
condition|)
block|{
name|int
name|c_lineno
init|=
name|lineno
decl_stmt|;
name|char
modifier|*
name|c_line
init|=
name|dup_line
argument_list|()
decl_stmt|;
name|char
modifier|*
name|c_cptr
init|=
name|c_line
operator|+
operator|(
name|cptr
operator|-
name|line
operator|-
literal|1
operator|)
decl_stmt|;
name|putc
argument_list|(
literal|'*'
argument_list|,
name|f
argument_list|)
expr_stmt|;
operator|++
name|cptr
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
operator|*
name|cptr
operator|++
expr_stmt|;
name|putc
argument_list|(
name|c
argument_list|,
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'*'
operator|&&
operator|*
name|cptr
operator|==
literal|'/'
condition|)
block|{
name|putc
argument_list|(
literal|'/'
argument_list|,
name|f
argument_list|)
expr_stmt|;
operator|++
name|cptr
expr_stmt|;
name|FREE
argument_list|(
name|c_line
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
name|get_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|line
operator|==
literal|0
condition|)
name|unterminated_comment
argument_list|(
name|c_lineno
argument_list|,
name|c_line
argument_list|,
name|c_cptr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|need_newline
operator|=
literal|1
expr_stmt|;
goto|goto
name|loop
goto|;
case|case
literal|'%'
case|:
case|case
literal|'\\'
case|:
if|if
condition|(
operator|*
name|cptr
operator|==
literal|'}'
condition|)
block|{
if|if
condition|(
name|need_newline
condition|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|f
argument_list|)
expr_stmt|;
operator|++
name|cptr
expr_stmt|;
name|FREE
argument_list|(
name|t_line
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* fall through */
default|default:
name|putc
argument_list|(
name|c
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|need_newline
operator|=
literal|1
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|copy_union
parameter_list|()
block|{
name|int
name|c
decl_stmt|;
name|int
name|quote
decl_stmt|;
name|int
name|depth
decl_stmt|;
name|int
name|u_lineno
init|=
name|lineno
decl_stmt|;
name|char
modifier|*
name|u_line
init|=
name|dup_line
argument_list|()
decl_stmt|;
name|char
modifier|*
name|u_cptr
init|=
name|u_line
operator|+
operator|(
name|cptr
operator|-
name|line
operator|-
literal|6
operator|)
decl_stmt|;
if|if
condition|(
name|unionized
condition|)
name|over_unionized
argument_list|(
name|cptr
operator|-
literal|6
argument_list|)
expr_stmt|;
name|unionized
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|lflag
condition|)
name|fprintf
argument_list|(
name|text_file
argument_list|,
name|line_format
argument_list|,
name|lineno
argument_list|,
name|input_file_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|text_file
argument_list|,
literal|"typedef union"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dflag
condition|)
name|fprintf
argument_list|(
name|union_file
argument_list|,
literal|"typedef union"
argument_list|)
expr_stmt|;
name|depth
operator|=
literal|0
expr_stmt|;
name|loop
label|:
name|c
operator|=
operator|*
name|cptr
operator|++
expr_stmt|;
name|putc
argument_list|(
name|c
argument_list|,
name|text_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|dflag
condition|)
name|putc
argument_list|(
name|c
argument_list|,
name|union_file
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\n'
case|:
name|next_line
label|:
name|get_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|line
operator|==
literal|0
condition|)
name|unterminated_union
argument_list|(
name|u_lineno
argument_list|,
name|u_line
argument_list|,
name|u_cptr
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
case|case
literal|'{'
case|:
operator|++
name|depth
expr_stmt|;
goto|goto
name|loop
goto|;
case|case
literal|'}'
case|:
if|if
condition|(
operator|--
name|depth
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|text_file
argument_list|,
literal|" YYSTYPE;\n"
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|u_line
argument_list|)
expr_stmt|;
return|return;
block|}
goto|goto
name|loop
goto|;
case|case
literal|'\''
case|:
case|case
literal|'"'
case|:
block|{
name|int
name|s_lineno
init|=
name|lineno
decl_stmt|;
name|char
modifier|*
name|s_line
init|=
name|dup_line
argument_list|()
decl_stmt|;
name|char
modifier|*
name|s_cptr
init|=
name|s_line
operator|+
operator|(
name|cptr
operator|-
name|line
operator|-
literal|1
operator|)
decl_stmt|;
name|quote
operator|=
name|c
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
operator|*
name|cptr
operator|++
expr_stmt|;
name|putc
argument_list|(
name|c
argument_list|,
name|text_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|dflag
condition|)
name|putc
argument_list|(
name|c
argument_list|,
name|union_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|quote
condition|)
block|{
name|FREE
argument_list|(
name|s_line
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
name|unterminated_string
argument_list|(
name|s_lineno
argument_list|,
name|s_line
argument_list|,
name|s_cptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
name|c
operator|=
operator|*
name|cptr
operator|++
expr_stmt|;
name|putc
argument_list|(
name|c
argument_list|,
name|text_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|dflag
condition|)
name|putc
argument_list|(
name|c
argument_list|,
name|union_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
name|get_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|line
operator|==
literal|0
condition|)
name|unterminated_string
argument_list|(
name|s_lineno
argument_list|,
name|s_line
argument_list|,
name|s_cptr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
case|case
literal|'/'
case|:
name|c
operator|=
operator|*
name|cptr
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'/'
condition|)
block|{
name|putc
argument_list|(
literal|'*'
argument_list|,
name|text_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|dflag
condition|)
name|putc
argument_list|(
literal|'*'
argument_list|,
name|union_file
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
operator|++
name|cptr
operator|)
operator|!=
literal|'\n'
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'*'
operator|&&
name|cptr
index|[
literal|1
index|]
operator|==
literal|'/'
condition|)
block|{
name|fprintf
argument_list|(
name|text_file
argument_list|,
literal|"* "
argument_list|)
expr_stmt|;
if|if
condition|(
name|dflag
condition|)
name|fprintf
argument_list|(
name|union_file
argument_list|,
literal|"* "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|putc
argument_list|(
name|c
argument_list|,
name|text_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|dflag
condition|)
name|putc
argument_list|(
name|c
argument_list|,
name|union_file
argument_list|)
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|text_file
argument_list|,
literal|"*/\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dflag
condition|)
name|fprintf
argument_list|(
name|union_file
argument_list|,
literal|"*/\n"
argument_list|)
expr_stmt|;
goto|goto
name|next_line
goto|;
block|}
if|if
condition|(
name|c
operator|==
literal|'*'
condition|)
block|{
name|int
name|c_lineno
init|=
name|lineno
decl_stmt|;
name|char
modifier|*
name|c_line
init|=
name|dup_line
argument_list|()
decl_stmt|;
name|char
modifier|*
name|c_cptr
init|=
name|c_line
operator|+
operator|(
name|cptr
operator|-
name|line
operator|-
literal|1
operator|)
decl_stmt|;
name|putc
argument_list|(
literal|'*'
argument_list|,
name|text_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|dflag
condition|)
name|putc
argument_list|(
literal|'*'
argument_list|,
name|union_file
argument_list|)
expr_stmt|;
operator|++
name|cptr
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
operator|*
name|cptr
operator|++
expr_stmt|;
name|putc
argument_list|(
name|c
argument_list|,
name|text_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|dflag
condition|)
name|putc
argument_list|(
name|c
argument_list|,
name|union_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'*'
operator|&&
operator|*
name|cptr
operator|==
literal|'/'
condition|)
block|{
name|putc
argument_list|(
literal|'/'
argument_list|,
name|text_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|dflag
condition|)
name|putc
argument_list|(
literal|'/'
argument_list|,
name|union_file
argument_list|)
expr_stmt|;
operator|++
name|cptr
expr_stmt|;
name|FREE
argument_list|(
name|c_line
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
name|get_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|line
operator|==
literal|0
condition|)
name|unterminated_comment
argument_list|(
name|c_lineno
argument_list|,
name|c_line
argument_list|,
name|c_cptr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
goto|goto
name|loop
goto|;
default|default:
goto|goto
name|loop
goto|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|hexval
parameter_list|(
name|c
parameter_list|)
name|int
name|c
decl_stmt|;
block|{
if|if
condition|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
return|return
operator|(
name|c
operator|-
literal|'0'
operator|)
return|;
if|if
condition|(
name|c
operator|>=
literal|'A'
operator|&&
name|c
operator|<=
literal|'F'
condition|)
return|return
operator|(
name|c
operator|-
literal|'A'
operator|+
literal|10
operator|)
return|;
if|if
condition|(
name|c
operator|>=
literal|'a'
operator|&&
name|c
operator|<=
literal|'f'
condition|)
return|return
operator|(
name|c
operator|-
literal|'a'
operator|+
literal|10
operator|)
return|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bucket
modifier|*
name|get_literal
parameter_list|()
block|{
name|int
name|c
decl_stmt|,
name|quote
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|n
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|bucket
modifier|*
name|bp
decl_stmt|;
name|int
name|s_lineno
init|=
name|lineno
decl_stmt|;
name|char
modifier|*
name|s_line
init|=
name|dup_line
argument_list|()
decl_stmt|;
name|char
modifier|*
name|s_cptr
init|=
name|s_line
operator|+
operator|(
name|cptr
operator|-
name|line
operator|)
decl_stmt|;
name|quote
operator|=
operator|*
name|cptr
operator|++
expr_stmt|;
name|cinc
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
operator|*
name|cptr
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|quote
condition|)
break|break;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
name|unterminated_string
argument_list|(
name|s_lineno
argument_list|,
name|s_line
argument_list|,
name|s_cptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
name|char
modifier|*
name|c_cptr
init|=
name|cptr
operator|-
literal|1
decl_stmt|;
name|c
operator|=
operator|*
name|cptr
operator|++
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\n'
case|:
name|get_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|line
operator|==
literal|0
condition|)
name|unterminated_string
argument_list|(
name|s_lineno
argument_list|,
name|s_line
argument_list|,
name|s_cptr
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
name|n
operator|=
name|c
operator|-
literal|'0'
expr_stmt|;
name|c
operator|=
operator|*
name|cptr
expr_stmt|;
if|if
condition|(
name|IS_OCTAL
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|n
operator|=
operator|(
name|n
operator|<<
literal|3
operator|)
operator|+
operator|(
name|c
operator|-
literal|'0'
operator|)
expr_stmt|;
name|c
operator|=
operator|*
operator|++
name|cptr
expr_stmt|;
if|if
condition|(
name|IS_OCTAL
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|n
operator|=
operator|(
name|n
operator|<<
literal|3
operator|)
operator|+
operator|(
name|c
operator|-
literal|'0'
operator|)
expr_stmt|;
operator|++
name|cptr
expr_stmt|;
block|}
block|}
if|if
condition|(
name|n
operator|>
name|MAXCHAR
condition|)
name|illegal_character
argument_list|(
name|c_cptr
argument_list|)
expr_stmt|;
name|c
operator|=
name|n
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|c
operator|=
operator|*
name|cptr
operator|++
expr_stmt|;
name|n
operator|=
name|hexval
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
operator|||
name|n
operator|>=
literal|16
condition|)
name|illegal_character
argument_list|(
name|c_cptr
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
operator|*
name|cptr
expr_stmt|;
name|i
operator|=
name|hexval
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
operator|||
name|i
operator|>=
literal|16
condition|)
break|break;
operator|++
name|cptr
expr_stmt|;
name|n
operator|=
operator|(
name|n
operator|<<
literal|4
operator|)
operator|+
name|i
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|MAXCHAR
condition|)
name|illegal_character
argument_list|(
name|c_cptr
argument_list|)
expr_stmt|;
block|}
name|c
operator|=
name|n
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|c
operator|=
literal|7
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|c
operator|=
literal|'\b'
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|c
operator|=
literal|'\f'
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|c
operator|=
literal|'\n'
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|c
operator|=
literal|'\r'
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|c
operator|=
literal|'\t'
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|c
operator|=
literal|'\v'
expr_stmt|;
break|break;
block|}
block|}
name|cachec
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
name|FREE
argument_list|(
name|s_line
argument_list|)
expr_stmt|;
name|n
operator|=
name|cinc
expr_stmt|;
name|s
operator|=
name|MALLOC
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
literal|0
condition|)
name|no_space
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
name|s
index|[
name|i
index|]
operator|=
name|cache
index|[
name|i
index|]
expr_stmt|;
name|cinc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|1
condition|)
name|cachec
argument_list|(
literal|'\''
argument_list|)
expr_stmt|;
else|else
name|cachec
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
name|c
operator|=
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s
operator|)
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\\'
operator|||
name|c
operator|==
name|cache
index|[
literal|0
index|]
condition|)
block|{
name|cachec
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
name|cachec
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isprint
argument_list|(
name|c
argument_list|)
condition|)
name|cachec
argument_list|(
name|c
argument_list|)
expr_stmt|;
else|else
block|{
name|cachec
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|7
case|:
name|cachec
argument_list|(
literal|'a'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\b'
case|:
name|cachec
argument_list|(
literal|'b'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\f'
case|:
name|cachec
argument_list|(
literal|'f'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
name|cachec
argument_list|(
literal|'n'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\r'
case|:
name|cachec
argument_list|(
literal|'r'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\t'
case|:
name|cachec
argument_list|(
literal|'t'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\v'
case|:
name|cachec
argument_list|(
literal|'v'
argument_list|)
expr_stmt|;
break|break;
default|default:
name|cachec
argument_list|(
operator|(
operator|(
name|c
operator|>>
literal|6
operator|)
operator|&
literal|7
operator|)
operator|+
literal|'0'
argument_list|)
expr_stmt|;
name|cachec
argument_list|(
operator|(
operator|(
name|c
operator|>>
literal|3
operator|)
operator|&
literal|7
operator|)
operator|+
literal|'0'
argument_list|)
expr_stmt|;
name|cachec
argument_list|(
operator|(
name|c
operator|&
literal|7
operator|)
operator|+
literal|'0'
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|n
operator|==
literal|1
condition|)
name|cachec
argument_list|(
literal|'\''
argument_list|)
expr_stmt|;
else|else
name|cachec
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
name|cachec
argument_list|(
name|NUL
argument_list|)
expr_stmt|;
name|bp
operator|=
name|lookup
argument_list|(
name|cache
argument_list|)
expr_stmt|;
name|bp
operator|->
name|class
operator|=
name|TERM
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|1
operator|&&
name|bp
operator|->
name|value
operator|==
name|UNDEFINED
condition|)
name|bp
operator|->
name|value
operator|=
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s
expr_stmt|;
name|FREE
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|bp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|is_reserved
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"."
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"$accept"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"$end"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'$'
operator|&&
name|name
index|[
literal|1
index|]
operator|==
literal|'$'
operator|&&
name|isdigit
argument_list|(
name|name
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
name|s
operator|=
name|name
operator|+
literal|3
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|s
argument_list|)
condition|)
operator|++
name|s
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
name|NUL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bucket
modifier|*
name|get_name
parameter_list|()
block|{
name|int
name|c
decl_stmt|;
name|cinc
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|c
operator|=
operator|*
name|cptr
init|;
name|IS_IDENT
argument_list|(
name|c
argument_list|)
condition|;
name|c
operator|=
operator|*
operator|++
name|cptr
control|)
name|cachec
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|cachec
argument_list|(
name|NUL
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_reserved
argument_list|(
name|cache
argument_list|)
condition|)
name|used_reserved
argument_list|(
name|cache
argument_list|)
expr_stmt|;
return|return
operator|(
name|lookup
argument_list|(
name|cache
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_number
parameter_list|()
block|{
name|int
name|c
decl_stmt|;
name|int
name|n
decl_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|c
operator|=
operator|*
name|cptr
init|;
name|isdigit
argument_list|(
name|c
argument_list|)
condition|;
name|c
operator|=
operator|*
operator|++
name|cptr
control|)
name|n
operator|=
literal|10
operator|*
name|n
operator|+
operator|(
name|c
operator|-
literal|'0'
operator|)
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|get_tag
parameter_list|()
block|{
name|int
name|c
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|t_lineno
init|=
name|lineno
decl_stmt|;
name|char
modifier|*
name|t_line
init|=
name|dup_line
argument_list|()
decl_stmt|;
name|char
modifier|*
name|t_cptr
init|=
name|t_line
operator|+
operator|(
name|cptr
operator|-
name|line
operator|)
decl_stmt|;
operator|++
name|cptr
expr_stmt|;
name|c
operator|=
name|nextc
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
name|unexpected_EOF
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|isalpha
argument_list|(
name|c
argument_list|)
operator|&&
name|c
operator|!=
literal|'_'
operator|&&
name|c
operator|!=
literal|'$'
condition|)
name|illegal_tag
argument_list|(
name|t_lineno
argument_list|,
name|t_line
argument_list|,
name|t_cptr
argument_list|)
expr_stmt|;
name|cinc
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|cachec
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|c
operator|=
operator|*
operator|++
name|cptr
expr_stmt|;
block|}
do|while
condition|(
name|IS_IDENT
argument_list|(
name|c
argument_list|)
condition|)
do|;
name|cachec
argument_list|(
name|NUL
argument_list|)
expr_stmt|;
name|c
operator|=
name|nextc
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
name|unexpected_EOF
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'>'
condition|)
name|illegal_tag
argument_list|(
name|t_lineno
argument_list|,
name|t_line
argument_list|,
name|t_cptr
argument_list|)
expr_stmt|;
operator|++
name|cptr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ntags
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|cache
argument_list|,
name|tag_table
index|[
name|i
index|]
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|tag_table
index|[
name|i
index|]
operator|)
return|;
block|}
if|if
condition|(
name|ntags
operator|>=
name|tagmax
condition|)
block|{
name|tagmax
operator|+=
literal|16
expr_stmt|;
name|tag_table
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
operator|(
name|tag_table
condition|?
name|REALLOC
argument_list|(
name|tag_table
argument_list|,
name|tagmax
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
else|:
name|MALLOC
argument_list|(
name|tagmax
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|tag_table
operator|==
literal|0
condition|)
name|no_space
argument_list|()
expr_stmt|;
block|}
name|s
operator|=
name|MALLOC
argument_list|(
name|cinc
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
literal|0
condition|)
name|no_space
argument_list|()
expr_stmt|;
name|strcpy
argument_list|(
name|s
argument_list|,
name|cache
argument_list|)
expr_stmt|;
name|tag_table
index|[
name|ntags
index|]
operator|=
name|s
expr_stmt|;
operator|++
name|ntags
expr_stmt|;
name|FREE
argument_list|(
name|t_line
argument_list|)
expr_stmt|;
return|return
operator|(
name|s
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|declare_tokens
parameter_list|(
name|assoc
parameter_list|)
name|int
name|assoc
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
name|bucket
modifier|*
name|bp
decl_stmt|;
name|int
name|value
decl_stmt|;
name|char
modifier|*
name|tag
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|assoc
operator|!=
name|TOKEN
condition|)
operator|++
name|prec
expr_stmt|;
name|c
operator|=
name|nextc
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
name|unexpected_EOF
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'<'
condition|)
block|{
name|tag
operator|=
name|get_tag
argument_list|()
expr_stmt|;
name|c
operator|=
name|nextc
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
name|unexpected_EOF
argument_list|()
expr_stmt|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|isalpha
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'_'
operator|||
name|c
operator|==
literal|'.'
operator|||
name|c
operator|==
literal|'$'
condition|)
name|bp
operator|=
name|get_name
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\''
operator|||
name|c
operator|==
literal|'"'
condition|)
name|bp
operator|=
name|get_literal
argument_list|()
expr_stmt|;
else|else
return|return;
if|if
condition|(
name|bp
operator|==
name|goal
condition|)
name|tokenized_start
argument_list|(
name|bp
operator|->
name|name
argument_list|)
expr_stmt|;
name|bp
operator|->
name|class
operator|=
name|TERM
expr_stmt|;
if|if
condition|(
name|tag
condition|)
block|{
if|if
condition|(
name|bp
operator|->
name|tag
operator|&&
name|tag
operator|!=
name|bp
operator|->
name|tag
condition|)
name|retyped_warning
argument_list|(
name|bp
operator|->
name|name
argument_list|)
expr_stmt|;
name|bp
operator|->
name|tag
operator|=
name|tag
expr_stmt|;
block|}
if|if
condition|(
name|assoc
operator|!=
name|TOKEN
condition|)
block|{
if|if
condition|(
name|bp
operator|->
name|prec
operator|&&
name|prec
operator|!=
name|bp
operator|->
name|prec
condition|)
name|reprec_warning
argument_list|(
name|bp
operator|->
name|name
argument_list|)
expr_stmt|;
name|bp
operator|->
name|assoc
operator|=
name|assoc
expr_stmt|;
name|bp
operator|->
name|prec
operator|=
name|prec
expr_stmt|;
block|}
name|c
operator|=
name|nextc
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
name|unexpected_EOF
argument_list|()
expr_stmt|;
name|value
operator|=
name|UNDEFINED
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|value
operator|=
name|get_number
argument_list|()
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|value
operator|!=
name|UNDEFINED
operator|&&
name|value
operator|!=
name|bp
operator|->
name|value
condition|)
name|revalued_warning
argument_list|(
name|bp
operator|->
name|name
argument_list|)
expr_stmt|;
name|bp
operator|->
name|value
operator|=
name|value
expr_stmt|;
name|c
operator|=
name|nextc
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
name|unexpected_EOF
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * %expect requires special handling  * as it really isn't part of the yacc  * grammar only a flag for yacc proper.  */
end_comment

begin_function
specifier|static
name|void
name|declare_expect
parameter_list|(
name|assoc
parameter_list|)
name|int
name|assoc
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
if|if
condition|(
name|assoc
operator|!=
name|EXPECT
condition|)
operator|++
name|prec
expr_stmt|;
comment|/*      * Stay away from nextc - doesn't      * detect EOL and will read to EOF.      */
name|c
operator|=
operator|*
operator|++
name|cptr
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
name|unexpected_EOF
argument_list|()
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|SRexpect
operator|=
name|get_number
argument_list|()
expr_stmt|;
break|break;
block|}
comment|/* 	 * Looking for number before EOL. 	 * Spaces, tabs, and numbers are ok, 	 * words, punc., etc. are syntax errors. 	 */
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\n'
operator|||
name|isalpha
argument_list|(
name|c
argument_list|)
operator|||
operator|!
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|syntax_error
argument_list|(
name|lineno
argument_list|,
name|line
argument_list|,
name|cptr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|c
operator|=
operator|*
operator|++
name|cptr
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
name|unexpected_EOF
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|declare_types
parameter_list|()
block|{
name|int
name|c
decl_stmt|;
name|bucket
modifier|*
name|bp
decl_stmt|;
name|char
modifier|*
name|tag
decl_stmt|;
name|c
operator|=
name|nextc
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
name|unexpected_EOF
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'<'
condition|)
name|syntax_error
argument_list|(
name|lineno
argument_list|,
name|line
argument_list|,
name|cptr
argument_list|)
expr_stmt|;
name|tag
operator|=
name|get_tag
argument_list|()
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
name|nextc
argument_list|()
expr_stmt|;
if|if
condition|(
name|isalpha
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'_'
operator|||
name|c
operator|==
literal|'.'
operator|||
name|c
operator|==
literal|'$'
condition|)
name|bp
operator|=
name|get_name
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\''
operator|||
name|c
operator|==
literal|'"'
condition|)
name|bp
operator|=
name|get_literal
argument_list|()
expr_stmt|;
else|else
return|return;
if|if
condition|(
name|bp
operator|->
name|tag
operator|&&
name|tag
operator|!=
name|bp
operator|->
name|tag
condition|)
name|retyped_warning
argument_list|(
name|bp
operator|->
name|name
argument_list|)
expr_stmt|;
name|bp
operator|->
name|tag
operator|=
name|tag
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|declare_start
parameter_list|()
block|{
name|int
name|c
decl_stmt|;
name|bucket
modifier|*
name|bp
decl_stmt|;
name|c
operator|=
name|nextc
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
name|unexpected_EOF
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|isalpha
argument_list|(
name|c
argument_list|)
operator|&&
name|c
operator|!=
literal|'_'
operator|&&
name|c
operator|!=
literal|'.'
operator|&&
name|c
operator|!=
literal|'$'
condition|)
name|syntax_error
argument_list|(
name|lineno
argument_list|,
name|line
argument_list|,
name|cptr
argument_list|)
expr_stmt|;
name|bp
operator|=
name|get_name
argument_list|()
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|class
operator|==
name|TERM
condition|)
name|terminal_start
argument_list|(
name|bp
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|goal
operator|&&
name|goal
operator|!=
name|bp
condition|)
name|restarted_warning
argument_list|()
expr_stmt|;
name|goal
operator|=
name|bp
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|read_declarations
parameter_list|()
block|{
name|int
name|c
decl_stmt|,
name|k
decl_stmt|;
name|cache_size
operator|=
literal|256
expr_stmt|;
name|cache
operator|=
name|MALLOC
argument_list|(
name|cache_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|cache
operator|==
literal|0
condition|)
name|no_space
argument_list|()
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
name|nextc
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
name|unexpected_EOF
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'%'
condition|)
name|syntax_error
argument_list|(
name|lineno
argument_list|,
name|line
argument_list|,
name|cptr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|k
operator|=
name|keyword
argument_list|()
condition|)
block|{
case|case
name|MARK
case|:
return|return;
case|case
name|IDENT
case|:
name|copy_ident
argument_list|()
expr_stmt|;
break|break;
case|case
name|TEXT
case|:
name|copy_text
argument_list|()
expr_stmt|;
break|break;
case|case
name|UNION
case|:
name|copy_union
argument_list|()
expr_stmt|;
break|break;
case|case
name|TOKEN
case|:
case|case
name|LEFT
case|:
case|case
name|RIGHT
case|:
case|case
name|NONASSOC
case|:
name|declare_tokens
argument_list|(
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
name|EXPECT
case|:
name|declare_expect
argument_list|(
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE
case|:
name|declare_types
argument_list|()
expr_stmt|;
break|break;
case|case
name|START
case|:
name|declare_start
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|initialize_grammar
parameter_list|()
block|{
name|nitems
operator|=
literal|4
expr_stmt|;
name|maxitems
operator|=
literal|300
expr_stmt|;
name|pitem
operator|=
operator|(
name|bucket
operator|*
operator|*
operator|)
name|MALLOC
argument_list|(
name|maxitems
operator|*
sizeof|sizeof
argument_list|(
name|bucket
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pitem
operator|==
literal|0
condition|)
name|no_space
argument_list|()
expr_stmt|;
name|pitem
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|pitem
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|pitem
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|pitem
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|nrules
operator|=
literal|3
expr_stmt|;
name|maxrules
operator|=
literal|100
expr_stmt|;
name|plhs
operator|=
operator|(
name|bucket
operator|*
operator|*
operator|)
name|MALLOC
argument_list|(
name|maxrules
operator|*
sizeof|sizeof
argument_list|(
name|bucket
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|plhs
operator|==
literal|0
condition|)
name|no_space
argument_list|()
expr_stmt|;
name|plhs
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|plhs
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|plhs
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|rprec
operator|=
operator|(
name|short
operator|*
operator|)
name|MALLOC
argument_list|(
name|maxrules
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rprec
operator|==
literal|0
condition|)
name|no_space
argument_list|()
expr_stmt|;
name|rprec
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|rprec
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|rprec
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|rassoc
operator|=
operator|(
name|char
operator|*
operator|)
name|MALLOC
argument_list|(
name|maxrules
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rassoc
operator|==
literal|0
condition|)
name|no_space
argument_list|()
expr_stmt|;
name|rassoc
index|[
literal|0
index|]
operator|=
name|TOKEN
expr_stmt|;
name|rassoc
index|[
literal|1
index|]
operator|=
name|TOKEN
expr_stmt|;
name|rassoc
index|[
literal|2
index|]
operator|=
name|TOKEN
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|expand_items
parameter_list|()
block|{
name|maxitems
operator|+=
literal|300
expr_stmt|;
name|pitem
operator|=
operator|(
name|bucket
operator|*
operator|*
operator|)
name|REALLOC
argument_list|(
name|pitem
argument_list|,
name|maxitems
operator|*
sizeof|sizeof
argument_list|(
name|bucket
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pitem
operator|==
literal|0
condition|)
name|no_space
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|expand_rules
parameter_list|()
block|{
name|maxrules
operator|+=
literal|100
expr_stmt|;
name|plhs
operator|=
operator|(
name|bucket
operator|*
operator|*
operator|)
name|REALLOC
argument_list|(
name|plhs
argument_list|,
name|maxrules
operator|*
sizeof|sizeof
argument_list|(
name|bucket
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|plhs
operator|==
literal|0
condition|)
name|no_space
argument_list|()
expr_stmt|;
name|rprec
operator|=
operator|(
name|short
operator|*
operator|)
name|REALLOC
argument_list|(
name|rprec
argument_list|,
name|maxrules
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rprec
operator|==
literal|0
condition|)
name|no_space
argument_list|()
expr_stmt|;
name|rassoc
operator|=
operator|(
name|char
operator|*
operator|)
name|REALLOC
argument_list|(
name|rassoc
argument_list|,
name|maxrules
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rassoc
operator|==
literal|0
condition|)
name|no_space
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|advance_to_start
parameter_list|()
block|{
name|int
name|c
decl_stmt|;
name|bucket
modifier|*
name|bp
decl_stmt|;
name|char
modifier|*
name|s_cptr
decl_stmt|;
name|int
name|s_lineno
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
name|nextc
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'%'
condition|)
break|break;
name|s_cptr
operator|=
name|cptr
expr_stmt|;
switch|switch
condition|(
name|keyword
argument_list|()
condition|)
block|{
case|case
name|MARK
case|:
name|no_grammar
argument_list|()
expr_stmt|;
case|case
name|TEXT
case|:
name|copy_text
argument_list|()
expr_stmt|;
break|break;
case|case
name|START
case|:
name|declare_start
argument_list|()
expr_stmt|;
break|break;
default|default:
name|syntax_error
argument_list|(
name|lineno
argument_list|,
name|line
argument_list|,
name|s_cptr
argument_list|)
expr_stmt|;
block|}
block|}
name|c
operator|=
name|nextc
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|isalpha
argument_list|(
name|c
argument_list|)
operator|&&
name|c
operator|!=
literal|'_'
operator|&&
name|c
operator|!=
literal|'.'
operator|&&
name|c
operator|!=
literal|'_'
condition|)
name|syntax_error
argument_list|(
name|lineno
argument_list|,
name|line
argument_list|,
name|cptr
argument_list|)
expr_stmt|;
name|bp
operator|=
name|get_name
argument_list|()
expr_stmt|;
if|if
condition|(
name|goal
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|bp
operator|->
name|class
operator|==
name|TERM
condition|)
name|terminal_start
argument_list|(
name|bp
operator|->
name|name
argument_list|)
expr_stmt|;
name|goal
operator|=
name|bp
expr_stmt|;
block|}
name|s_lineno
operator|=
name|lineno
expr_stmt|;
name|c
operator|=
name|nextc
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
name|unexpected_EOF
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|':'
condition|)
name|syntax_error
argument_list|(
name|lineno
argument_list|,
name|line
argument_list|,
name|cptr
argument_list|)
expr_stmt|;
name|start_rule
argument_list|(
name|bp
argument_list|,
name|s_lineno
argument_list|)
expr_stmt|;
operator|++
name|cptr
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|start_rule
parameter_list|(
name|bp
parameter_list|,
name|s_lineno
parameter_list|)
name|bucket
modifier|*
name|bp
decl_stmt|;
name|int
name|s_lineno
decl_stmt|;
block|{
if|if
condition|(
name|bp
operator|->
name|class
operator|==
name|TERM
condition|)
name|terminal_lhs
argument_list|(
name|s_lineno
argument_list|)
expr_stmt|;
name|bp
operator|->
name|class
operator|=
name|NONTERM
expr_stmt|;
if|if
condition|(
name|nrules
operator|>=
name|maxrules
condition|)
name|expand_rules
argument_list|()
expr_stmt|;
name|plhs
index|[
name|nrules
index|]
operator|=
name|bp
expr_stmt|;
name|rprec
index|[
name|nrules
index|]
operator|=
name|UNDEFINED
expr_stmt|;
name|rassoc
index|[
name|nrules
index|]
operator|=
name|TOKEN
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|end_rule
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|last_was_action
operator|&&
name|plhs
index|[
name|nrules
index|]
operator|->
name|tag
condition|)
block|{
for|for
control|(
name|i
operator|=
name|nitems
operator|-
literal|1
init|;
name|pitem
index|[
name|i
index|]
condition|;
operator|--
name|i
control|)
continue|continue;
if|if
condition|(
name|pitem
index|[
name|i
operator|+
literal|1
index|]
operator|==
literal|0
operator|||
name|pitem
index|[
name|i
operator|+
literal|1
index|]
operator|->
name|tag
operator|!=
name|plhs
index|[
name|nrules
index|]
operator|->
name|tag
condition|)
name|default_action_warning
argument_list|()
expr_stmt|;
block|}
name|last_was_action
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nitems
operator|>=
name|maxitems
condition|)
name|expand_items
argument_list|()
expr_stmt|;
name|pitem
index|[
name|nitems
index|]
operator|=
literal|0
expr_stmt|;
operator|++
name|nitems
expr_stmt|;
operator|++
name|nrules
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|insert_empty_rule
parameter_list|()
block|{
name|bucket
modifier|*
name|bp
decl_stmt|,
modifier|*
modifier|*
name|bpp
decl_stmt|;
name|assert
argument_list|(
name|cache
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|cache
argument_list|,
literal|"$$%d"
argument_list|,
operator|++
name|gensym
argument_list|)
expr_stmt|;
name|bp
operator|=
name|make_bucket
argument_list|(
name|cache
argument_list|)
expr_stmt|;
name|last_symbol
operator|->
name|next
operator|=
name|bp
expr_stmt|;
name|last_symbol
operator|=
name|bp
expr_stmt|;
name|bp
operator|->
name|tag
operator|=
name|plhs
index|[
name|nrules
index|]
operator|->
name|tag
expr_stmt|;
name|bp
operator|->
name|class
operator|=
name|NONTERM
expr_stmt|;
if|if
condition|(
operator|(
name|nitems
operator|+=
literal|2
operator|)
operator|>
name|maxitems
condition|)
name|expand_items
argument_list|()
expr_stmt|;
name|bpp
operator|=
name|pitem
operator|+
name|nitems
operator|-
literal|1
expr_stmt|;
operator|*
name|bpp
operator|--
operator|=
name|bp
expr_stmt|;
while|while
condition|(
operator|(
name|bpp
index|[
literal|0
index|]
operator|=
name|bpp
index|[
operator|-
literal|1
index|]
operator|)
condition|)
operator|--
name|bpp
expr_stmt|;
if|if
condition|(
operator|++
name|nrules
operator|>=
name|maxrules
condition|)
name|expand_rules
argument_list|()
expr_stmt|;
name|plhs
index|[
name|nrules
index|]
operator|=
name|plhs
index|[
name|nrules
operator|-
literal|1
index|]
expr_stmt|;
name|plhs
index|[
name|nrules
operator|-
literal|1
index|]
operator|=
name|bp
expr_stmt|;
name|rprec
index|[
name|nrules
index|]
operator|=
name|rprec
index|[
name|nrules
operator|-
literal|1
index|]
expr_stmt|;
name|rprec
index|[
name|nrules
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|rassoc
index|[
name|nrules
index|]
operator|=
name|rassoc
index|[
name|nrules
operator|-
literal|1
index|]
expr_stmt|;
name|rassoc
index|[
name|nrules
operator|-
literal|1
index|]
operator|=
name|TOKEN
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|add_symbol
parameter_list|()
block|{
name|int
name|c
decl_stmt|;
name|bucket
modifier|*
name|bp
decl_stmt|;
name|int
name|s_lineno
init|=
name|lineno
decl_stmt|;
name|c
operator|=
operator|*
name|cptr
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\''
operator|||
name|c
operator|==
literal|'"'
condition|)
name|bp
operator|=
name|get_literal
argument_list|()
expr_stmt|;
else|else
name|bp
operator|=
name|get_name
argument_list|()
expr_stmt|;
name|c
operator|=
name|nextc
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|':'
condition|)
block|{
name|end_rule
argument_list|()
expr_stmt|;
name|start_rule
argument_list|(
name|bp
argument_list|,
name|s_lineno
argument_list|)
expr_stmt|;
operator|++
name|cptr
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|last_was_action
condition|)
name|insert_empty_rule
argument_list|()
expr_stmt|;
name|last_was_action
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|++
name|nitems
operator|>
name|maxitems
condition|)
name|expand_items
argument_list|()
expr_stmt|;
name|pitem
index|[
name|nitems
operator|-
literal|1
index|]
operator|=
name|bp
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|copy_action
parameter_list|()
block|{
name|int
name|c
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
name|int
name|depth
decl_stmt|;
name|int
name|quote
decl_stmt|;
name|char
modifier|*
name|tag
decl_stmt|;
name|FILE
modifier|*
name|f
init|=
name|action_file
decl_stmt|;
name|int
name|a_lineno
init|=
name|lineno
decl_stmt|;
name|char
modifier|*
name|a_line
init|=
name|dup_line
argument_list|()
decl_stmt|;
name|char
modifier|*
name|a_cptr
init|=
name|a_line
operator|+
operator|(
name|cptr
operator|-
name|line
operator|)
decl_stmt|;
if|if
condition|(
name|last_was_action
condition|)
name|insert_empty_rule
argument_list|()
expr_stmt|;
name|last_was_action
operator|=
literal|1
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"case %d:\n"
argument_list|,
name|nrules
operator|-
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lflag
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
name|line_format
argument_list|,
name|lineno
argument_list|,
name|input_file_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cptr
operator|==
literal|'='
condition|)
operator|++
name|cptr
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|nitems
operator|-
literal|1
init|;
name|pitem
index|[
name|i
index|]
condition|;
operator|--
name|i
control|)
operator|++
name|n
expr_stmt|;
name|depth
operator|=
literal|0
expr_stmt|;
name|loop
label|:
name|c
operator|=
operator|*
name|cptr
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'$'
condition|)
block|{
if|if
condition|(
name|cptr
index|[
literal|1
index|]
operator|==
literal|'<'
condition|)
block|{
name|int
name|d_lineno
init|=
name|lineno
decl_stmt|;
name|char
modifier|*
name|d_line
init|=
name|dup_line
argument_list|()
decl_stmt|;
name|char
modifier|*
name|d_cptr
init|=
name|d_line
operator|+
operator|(
name|cptr
operator|-
name|line
operator|)
decl_stmt|;
operator|++
name|cptr
expr_stmt|;
name|tag
operator|=
name|get_tag
argument_list|()
expr_stmt|;
name|c
operator|=
operator|*
name|cptr
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'$'
condition|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"yyval.%s"
argument_list|,
name|tag
argument_list|)
expr_stmt|;
operator|++
name|cptr
expr_stmt|;
name|FREE
argument_list|(
name|d_line
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
elseif|else
if|if
condition|(
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|i
operator|=
name|get_number
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|n
condition|)
name|dollar_warning
argument_list|(
name|d_lineno
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"yyvsp[%d].%s"
argument_list|,
name|i
operator|-
name|n
argument_list|,
name|tag
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|d_line
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'-'
operator|&&
name|isdigit
argument_list|(
name|cptr
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
operator|++
name|cptr
expr_stmt|;
name|i
operator|=
operator|-
name|get_number
argument_list|()
operator|-
name|n
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"yyvsp[%d].%s"
argument_list|,
name|i
argument_list|,
name|tag
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|d_line
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
else|else
name|dollar_error
argument_list|(
name|d_lineno
argument_list|,
name|d_line
argument_list|,
name|d_cptr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cptr
index|[
literal|1
index|]
operator|==
literal|'$'
condition|)
block|{
if|if
condition|(
name|ntags
condition|)
block|{
name|tag
operator|=
name|plhs
index|[
name|nrules
index|]
operator|->
name|tag
expr_stmt|;
if|if
condition|(
name|tag
operator|==
literal|0
condition|)
name|untyped_lhs
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"yyval.%s"
argument_list|,
name|tag
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"yyval"
argument_list|)
expr_stmt|;
name|cptr
operator|+=
literal|2
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
elseif|else
if|if
condition|(
name|isdigit
argument_list|(
name|cptr
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
operator|++
name|cptr
expr_stmt|;
name|i
operator|=
name|get_number
argument_list|()
expr_stmt|;
if|if
condition|(
name|ntags
condition|)
block|{
if|if
condition|(
name|i
operator|<=
literal|0
operator|||
name|i
operator|>
name|n
condition|)
name|unknown_rhs
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|tag
operator|=
name|pitem
index|[
name|nitems
operator|+
name|i
operator|-
name|n
operator|-
literal|1
index|]
operator|->
name|tag
expr_stmt|;
if|if
condition|(
name|tag
operator|==
literal|0
condition|)
name|untyped_rhs
argument_list|(
name|i
argument_list|,
name|pitem
index|[
name|nitems
operator|+
name|i
operator|-
name|n
operator|-
literal|1
index|]
operator|->
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"yyvsp[%d].%s"
argument_list|,
name|i
operator|-
name|n
argument_list|,
name|tag
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|i
operator|>
name|n
condition|)
name|dollar_warning
argument_list|(
name|lineno
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"yyvsp[%d]"
argument_list|,
name|i
operator|-
name|n
argument_list|)
expr_stmt|;
block|}
goto|goto
name|loop
goto|;
block|}
elseif|else
if|if
condition|(
name|cptr
index|[
literal|1
index|]
operator|==
literal|'-'
condition|)
block|{
name|cptr
operator|+=
literal|2
expr_stmt|;
name|i
operator|=
name|get_number
argument_list|()
expr_stmt|;
if|if
condition|(
name|ntags
condition|)
name|unknown_rhs
argument_list|(
operator|-
name|i
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"yyvsp[%d]"
argument_list|,
operator|-
name|i
operator|-
name|n
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
block|}
if|if
condition|(
name|isalpha
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'_'
operator|||
name|c
operator|==
literal|'$'
condition|)
block|{
do|do
block|{
name|putc
argument_list|(
name|c
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|c
operator|=
operator|*
operator|++
name|cptr
expr_stmt|;
block|}
do|while
condition|(
name|isalnum
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'_'
operator|||
name|c
operator|==
literal|'$'
condition|)
do|;
goto|goto
name|loop
goto|;
block|}
name|putc
argument_list|(
name|c
argument_list|,
name|f
argument_list|)
expr_stmt|;
operator|++
name|cptr
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\n'
case|:
name|next_line
label|:
name|get_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|line
condition|)
goto|goto
name|loop
goto|;
name|unterminated_action
argument_list|(
name|a_lineno
argument_list|,
name|a_line
argument_list|,
name|a_cptr
argument_list|)
expr_stmt|;
case|case
literal|';'
case|:
if|if
condition|(
name|depth
operator|>
literal|0
condition|)
goto|goto
name|loop
goto|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\nbreak;\n"
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'{'
case|:
operator|++
name|depth
expr_stmt|;
goto|goto
name|loop
goto|;
case|case
literal|'}'
case|:
if|if
condition|(
operator|--
name|depth
operator|>
literal|0
condition|)
goto|goto
name|loop
goto|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\nbreak;\n"
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'\''
case|:
case|case
literal|'"'
case|:
block|{
name|int
name|s_lineno
init|=
name|lineno
decl_stmt|;
name|char
modifier|*
name|s_line
init|=
name|dup_line
argument_list|()
decl_stmt|;
name|char
modifier|*
name|s_cptr
init|=
name|s_line
operator|+
operator|(
name|cptr
operator|-
name|line
operator|-
literal|1
operator|)
decl_stmt|;
name|quote
operator|=
name|c
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
operator|*
name|cptr
operator|++
expr_stmt|;
name|putc
argument_list|(
name|c
argument_list|,
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|quote
condition|)
block|{
name|FREE
argument_list|(
name|s_line
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
name|unterminated_string
argument_list|(
name|s_lineno
argument_list|,
name|s_line
argument_list|,
name|s_cptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
name|c
operator|=
operator|*
name|cptr
operator|++
expr_stmt|;
name|putc
argument_list|(
name|c
argument_list|,
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
name|get_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|line
operator|==
literal|0
condition|)
name|unterminated_string
argument_list|(
name|s_lineno
argument_list|,
name|s_line
argument_list|,
name|s_cptr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
case|case
literal|'/'
case|:
name|c
operator|=
operator|*
name|cptr
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'/'
condition|)
block|{
name|putc
argument_list|(
literal|'*'
argument_list|,
name|f
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
operator|++
name|cptr
operator|)
operator|!=
literal|'\n'
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'*'
operator|&&
name|cptr
index|[
literal|1
index|]
operator|==
literal|'/'
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"* "
argument_list|)
expr_stmt|;
else|else
name|putc
argument_list|(
name|c
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"*/\n"
argument_list|)
expr_stmt|;
goto|goto
name|next_line
goto|;
block|}
if|if
condition|(
name|c
operator|==
literal|'*'
condition|)
block|{
name|int
name|c_lineno
init|=
name|lineno
decl_stmt|;
name|char
modifier|*
name|c_line
init|=
name|dup_line
argument_list|()
decl_stmt|;
name|char
modifier|*
name|c_cptr
init|=
name|c_line
operator|+
operator|(
name|cptr
operator|-
name|line
operator|-
literal|1
operator|)
decl_stmt|;
name|putc
argument_list|(
literal|'*'
argument_list|,
name|f
argument_list|)
expr_stmt|;
operator|++
name|cptr
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
operator|*
name|cptr
operator|++
expr_stmt|;
name|putc
argument_list|(
name|c
argument_list|,
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'*'
operator|&&
operator|*
name|cptr
operator|==
literal|'/'
condition|)
block|{
name|putc
argument_list|(
literal|'/'
argument_list|,
name|f
argument_list|)
expr_stmt|;
operator|++
name|cptr
expr_stmt|;
name|FREE
argument_list|(
name|c_line
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
name|get_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|line
operator|==
literal|0
condition|)
name|unterminated_comment
argument_list|(
name|c_lineno
argument_list|,
name|c_line
argument_list|,
name|c_cptr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
goto|goto
name|loop
goto|;
default|default:
goto|goto
name|loop
goto|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|mark_symbol
parameter_list|()
block|{
name|int
name|c
decl_stmt|;
name|bucket
modifier|*
name|bp
init|=
name|NULL
decl_stmt|;
name|c
operator|=
name|cptr
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'%'
operator|||
name|c
operator|==
literal|'\\'
condition|)
block|{
name|cptr
operator|+=
literal|2
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|c
operator|==
literal|'='
condition|)
name|cptr
operator|+=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'p'
operator|||
name|c
operator|==
literal|'P'
operator|)
operator|&&
operator|(
operator|(
name|c
operator|=
name|cptr
index|[
literal|2
index|]
operator|)
operator|==
literal|'r'
operator|||
name|c
operator|==
literal|'R'
operator|)
operator|&&
operator|(
operator|(
name|c
operator|=
name|cptr
index|[
literal|3
index|]
operator|)
operator|==
literal|'e'
operator|||
name|c
operator|==
literal|'E'
operator|)
operator|&&
operator|(
operator|(
name|c
operator|=
name|cptr
index|[
literal|4
index|]
operator|)
operator|==
literal|'c'
operator|||
name|c
operator|==
literal|'C'
operator|)
operator|&&
operator|(
operator|(
name|c
operator|=
name|cptr
index|[
literal|5
index|]
operator|,
operator|!
name|IS_IDENT
argument_list|(
name|c
argument_list|)
operator|)
operator|)
condition|)
name|cptr
operator|+=
literal|5
expr_stmt|;
else|else
name|syntax_error
argument_list|(
name|lineno
argument_list|,
name|line
argument_list|,
name|cptr
argument_list|)
expr_stmt|;
name|c
operator|=
name|nextc
argument_list|()
expr_stmt|;
if|if
condition|(
name|isalpha
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'_'
operator|||
name|c
operator|==
literal|'.'
operator|||
name|c
operator|==
literal|'$'
condition|)
name|bp
operator|=
name|get_name
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\''
operator|||
name|c
operator|==
literal|'"'
condition|)
name|bp
operator|=
name|get_literal
argument_list|()
expr_stmt|;
else|else
block|{
name|syntax_error
argument_list|(
name|lineno
argument_list|,
name|line
argument_list|,
name|cptr
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
if|if
condition|(
name|rprec
index|[
name|nrules
index|]
operator|!=
name|UNDEFINED
operator|&&
name|bp
operator|->
name|prec
operator|!=
name|rprec
index|[
name|nrules
index|]
condition|)
name|prec_redeclared
argument_list|()
expr_stmt|;
name|rprec
index|[
name|nrules
index|]
operator|=
name|bp
operator|->
name|prec
expr_stmt|;
name|rassoc
index|[
name|nrules
index|]
operator|=
name|bp
operator|->
name|assoc
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|read_grammar
parameter_list|()
block|{
name|int
name|c
decl_stmt|;
name|initialize_grammar
argument_list|()
expr_stmt|;
name|advance_to_start
argument_list|()
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
name|nextc
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
break|break;
if|if
condition|(
name|isalpha
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'_'
operator|||
name|c
operator|==
literal|'.'
operator|||
name|c
operator|==
literal|'$'
operator|||
name|c
operator|==
literal|'\''
operator|||
name|c
operator|==
literal|'"'
condition|)
name|add_symbol
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'{'
operator|||
name|c
operator|==
literal|'='
condition|)
name|copy_action
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'|'
condition|)
block|{
name|end_rule
argument_list|()
expr_stmt|;
name|start_rule
argument_list|(
name|plhs
index|[
name|nrules
operator|-
literal|1
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|++
name|cptr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'%'
condition|)
block|{
if|if
condition|(
name|mark_symbol
argument_list|()
condition|)
break|break;
block|}
else|else
name|syntax_error
argument_list|(
name|lineno
argument_list|,
name|line
argument_list|,
name|cptr
argument_list|)
expr_stmt|;
block|}
name|end_rule
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_tags
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|tag_table
operator|==
literal|0
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ntags
condition|;
operator|++
name|i
control|)
block|{
name|assert
argument_list|(
name|tag_table
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|tag_table
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|FREE
argument_list|(
name|tag_table
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pack_names
parameter_list|()
block|{
name|bucket
modifier|*
name|bp
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|s
decl_stmt|,
modifier|*
name|t
decl_stmt|;
name|name_pool_size
operator|=
literal|13
expr_stmt|;
comment|/* 13 == sizeof("$end") + sizeof("$accept") */
for|for
control|(
name|bp
operator|=
name|first_symbol
init|;
name|bp
condition|;
name|bp
operator|=
name|bp
operator|->
name|next
control|)
name|name_pool_size
operator|+=
name|strlen
argument_list|(
name|bp
operator|->
name|name
argument_list|)
operator|+
literal|1
expr_stmt|;
name|name_pool
operator|=
name|MALLOC
argument_list|(
name|name_pool_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|name_pool
operator|==
literal|0
condition|)
name|no_space
argument_list|()
expr_stmt|;
name|strcpy
argument_list|(
name|name_pool
argument_list|,
literal|"$accept"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|name_pool
operator|+
literal|8
argument_list|,
literal|"$end"
argument_list|)
expr_stmt|;
name|t
operator|=
name|name_pool
operator|+
literal|13
expr_stmt|;
for|for
control|(
name|bp
operator|=
name|first_symbol
init|;
name|bp
condition|;
name|bp
operator|=
name|bp
operator|->
name|next
control|)
block|{
name|p
operator|=
name|t
expr_stmt|;
name|s
operator|=
name|bp
operator|->
name|name
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|t
operator|++
operator|=
operator|*
name|s
operator|++
operator|)
condition|)
continue|continue;
name|FREE
argument_list|(
name|bp
operator|->
name|name
argument_list|)
expr_stmt|;
name|bp
operator|->
name|name
operator|=
name|p
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|check_symbols
parameter_list|()
block|{
name|bucket
modifier|*
name|bp
decl_stmt|;
if|if
condition|(
name|goal
operator|->
name|class
operator|==
name|UNKNOWN
condition|)
name|undefined_goal
argument_list|(
name|goal
operator|->
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|bp
operator|=
name|first_symbol
init|;
name|bp
condition|;
name|bp
operator|=
name|bp
operator|->
name|next
control|)
block|{
if|if
condition|(
name|bp
operator|->
name|class
operator|==
name|UNKNOWN
condition|)
block|{
name|undefined_symbol_warning
argument_list|(
name|bp
operator|->
name|name
argument_list|)
expr_stmt|;
name|bp
operator|->
name|class
operator|=
name|TERM
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|pack_symbols
parameter_list|()
block|{
name|bucket
modifier|*
name|bp
decl_stmt|;
name|bucket
modifier|*
modifier|*
name|v
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|n
decl_stmt|;
name|nsyms
operator|=
literal|2
expr_stmt|;
name|ntokens
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|bp
operator|=
name|first_symbol
init|;
name|bp
condition|;
name|bp
operator|=
name|bp
operator|->
name|next
control|)
block|{
operator|++
name|nsyms
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|class
operator|==
name|TERM
condition|)
operator|++
name|ntokens
expr_stmt|;
block|}
name|start_symbol
operator|=
name|ntokens
expr_stmt|;
name|nvars
operator|=
name|nsyms
operator|-
name|ntokens
expr_stmt|;
name|symbol_name
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|MALLOC
argument_list|(
name|nsyms
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|symbol_name
operator|==
literal|0
condition|)
name|no_space
argument_list|()
expr_stmt|;
name|symbol_value
operator|=
operator|(
name|short
operator|*
operator|)
name|MALLOC
argument_list|(
name|nsyms
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|symbol_value
operator|==
literal|0
condition|)
name|no_space
argument_list|()
expr_stmt|;
name|symbol_prec
operator|=
operator|(
name|short
operator|*
operator|)
name|MALLOC
argument_list|(
name|nsyms
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|symbol_prec
operator|==
literal|0
condition|)
name|no_space
argument_list|()
expr_stmt|;
name|symbol_assoc
operator|=
name|MALLOC
argument_list|(
name|nsyms
argument_list|)
expr_stmt|;
if|if
condition|(
name|symbol_assoc
operator|==
literal|0
condition|)
name|no_space
argument_list|()
expr_stmt|;
name|v
operator|=
operator|(
name|bucket
operator|*
operator|*
operator|)
name|MALLOC
argument_list|(
name|nsyms
operator|*
sizeof|sizeof
argument_list|(
name|bucket
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|==
literal|0
condition|)
name|no_space
argument_list|()
expr_stmt|;
name|v
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|v
index|[
name|start_symbol
index|]
operator|=
literal|0
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
name|j
operator|=
name|start_symbol
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|bp
operator|=
name|first_symbol
init|;
name|bp
condition|;
name|bp
operator|=
name|bp
operator|->
name|next
control|)
block|{
if|if
condition|(
name|bp
operator|->
name|class
operator|==
name|TERM
condition|)
name|v
index|[
name|i
operator|++
index|]
operator|=
name|bp
expr_stmt|;
else|else
name|v
index|[
name|j
operator|++
index|]
operator|=
name|bp
expr_stmt|;
block|}
name|assert
argument_list|(
name|i
operator|==
name|ntokens
operator|&&
name|j
operator|==
name|nsyms
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|ntokens
condition|;
operator|++
name|i
control|)
name|v
index|[
name|i
index|]
operator|->
name|index
operator|=
name|i
expr_stmt|;
name|goal
operator|->
name|index
operator|=
name|start_symbol
operator|+
literal|1
expr_stmt|;
name|k
operator|=
name|start_symbol
operator|+
literal|2
expr_stmt|;
while|while
condition|(
operator|++
name|i
operator|<
name|nsyms
condition|)
if|if
condition|(
name|v
index|[
name|i
index|]
operator|!=
name|goal
condition|)
block|{
name|v
index|[
name|i
index|]
operator|->
name|index
operator|=
name|k
expr_stmt|;
operator|++
name|k
expr_stmt|;
block|}
name|goal
operator|->
name|value
operator|=
literal|0
expr_stmt|;
name|k
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
name|start_symbol
operator|+
literal|1
init|;
name|i
operator|<
name|nsyms
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|v
index|[
name|i
index|]
operator|!=
name|goal
condition|)
block|{
name|v
index|[
name|i
index|]
operator|->
name|value
operator|=
name|k
expr_stmt|;
operator|++
name|k
expr_stmt|;
block|}
block|}
name|k
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|ntokens
condition|;
operator|++
name|i
control|)
block|{
name|n
operator|=
name|v
index|[
name|i
index|]
operator|->
name|value
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|256
condition|)
block|{
for|for
control|(
name|j
operator|=
name|k
operator|++
init|;
name|j
operator|>
literal|0
operator|&&
name|symbol_value
index|[
name|j
operator|-
literal|1
index|]
operator|>
name|n
condition|;
operator|--
name|j
control|)
name|symbol_value
index|[
name|j
index|]
operator|=
name|symbol_value
index|[
name|j
operator|-
literal|1
index|]
expr_stmt|;
name|symbol_value
index|[
name|j
index|]
operator|=
name|n
expr_stmt|;
block|}
block|}
if|if
condition|(
name|v
index|[
literal|1
index|]
operator|->
name|value
operator|==
name|UNDEFINED
condition|)
name|v
index|[
literal|1
index|]
operator|->
name|value
operator|=
literal|256
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
name|n
operator|=
literal|257
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|ntokens
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|v
index|[
name|i
index|]
operator|->
name|value
operator|==
name|UNDEFINED
condition|)
block|{
while|while
condition|(
name|j
operator|<
name|k
operator|&&
name|n
operator|==
name|symbol_value
index|[
name|j
index|]
condition|)
block|{
while|while
condition|(
operator|++
name|j
operator|<
name|k
operator|&&
name|n
operator|==
name|symbol_value
index|[
name|j
index|]
condition|)
continue|continue;
operator|++
name|n
expr_stmt|;
block|}
name|v
index|[
name|i
index|]
operator|->
name|value
operator|=
name|n
expr_stmt|;
operator|++
name|n
expr_stmt|;
block|}
block|}
name|symbol_name
index|[
literal|0
index|]
operator|=
name|name_pool
operator|+
literal|8
expr_stmt|;
name|symbol_value
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|symbol_prec
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|symbol_assoc
index|[
literal|0
index|]
operator|=
name|TOKEN
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|ntokens
condition|;
operator|++
name|i
control|)
block|{
name|symbol_name
index|[
name|i
index|]
operator|=
name|v
index|[
name|i
index|]
operator|->
name|name
expr_stmt|;
name|symbol_value
index|[
name|i
index|]
operator|=
name|v
index|[
name|i
index|]
operator|->
name|value
expr_stmt|;
name|symbol_prec
index|[
name|i
index|]
operator|=
name|v
index|[
name|i
index|]
operator|->
name|prec
expr_stmt|;
name|symbol_assoc
index|[
name|i
index|]
operator|=
name|v
index|[
name|i
index|]
operator|->
name|assoc
expr_stmt|;
block|}
name|symbol_name
index|[
name|start_symbol
index|]
operator|=
name|name_pool
expr_stmt|;
name|symbol_value
index|[
name|start_symbol
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|symbol_prec
index|[
name|start_symbol
index|]
operator|=
literal|0
expr_stmt|;
name|symbol_assoc
index|[
name|start_symbol
index|]
operator|=
name|TOKEN
expr_stmt|;
for|for
control|(
operator|++
name|i
init|;
name|i
operator|<
name|nsyms
condition|;
operator|++
name|i
control|)
block|{
name|k
operator|=
name|v
index|[
name|i
index|]
operator|->
name|index
expr_stmt|;
name|symbol_name
index|[
name|k
index|]
operator|=
name|v
index|[
name|i
index|]
operator|->
name|name
expr_stmt|;
name|symbol_value
index|[
name|k
index|]
operator|=
name|v
index|[
name|i
index|]
operator|->
name|value
expr_stmt|;
name|symbol_prec
index|[
name|k
index|]
operator|=
name|v
index|[
name|i
index|]
operator|->
name|prec
expr_stmt|;
name|symbol_assoc
index|[
name|k
index|]
operator|=
name|v
index|[
name|i
index|]
operator|->
name|assoc
expr_stmt|;
block|}
name|FREE
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pack_grammar
parameter_list|()
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|assoc
decl_stmt|,
name|preced
decl_stmt|;
name|ritem
operator|=
operator|(
name|short
operator|*
operator|)
name|MALLOC
argument_list|(
name|nitems
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ritem
operator|==
literal|0
condition|)
name|no_space
argument_list|()
expr_stmt|;
name|rlhs
operator|=
operator|(
name|short
operator|*
operator|)
name|MALLOC
argument_list|(
name|nrules
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rlhs
operator|==
literal|0
condition|)
name|no_space
argument_list|()
expr_stmt|;
name|rrhs
operator|=
operator|(
name|short
operator|*
operator|)
name|MALLOC
argument_list|(
operator|(
name|nrules
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rrhs
operator|==
literal|0
condition|)
name|no_space
argument_list|()
expr_stmt|;
name|rprec
operator|=
operator|(
name|short
operator|*
operator|)
name|REALLOC
argument_list|(
name|rprec
argument_list|,
name|nrules
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rprec
operator|==
literal|0
condition|)
name|no_space
argument_list|()
expr_stmt|;
name|rassoc
operator|=
name|REALLOC
argument_list|(
name|rassoc
argument_list|,
name|nrules
argument_list|)
expr_stmt|;
if|if
condition|(
name|rassoc
operator|==
literal|0
condition|)
name|no_space
argument_list|()
expr_stmt|;
name|ritem
index|[
literal|0
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|ritem
index|[
literal|1
index|]
operator|=
name|goal
operator|->
name|index
expr_stmt|;
name|ritem
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|ritem
index|[
literal|3
index|]
operator|=
operator|-
literal|2
expr_stmt|;
name|rlhs
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|rlhs
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|rlhs
index|[
literal|2
index|]
operator|=
name|start_symbol
expr_stmt|;
name|rrhs
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|rrhs
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|rrhs
index|[
literal|2
index|]
operator|=
literal|1
expr_stmt|;
name|j
operator|=
literal|4
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|3
init|;
name|i
operator|<
name|nrules
condition|;
operator|++
name|i
control|)
block|{
name|rlhs
index|[
name|i
index|]
operator|=
name|plhs
index|[
name|i
index|]
operator|->
name|index
expr_stmt|;
name|rrhs
index|[
name|i
index|]
operator|=
name|j
expr_stmt|;
name|assoc
operator|=
name|TOKEN
expr_stmt|;
name|preced
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|pitem
index|[
name|j
index|]
condition|)
block|{
name|ritem
index|[
name|j
index|]
operator|=
name|pitem
index|[
name|j
index|]
operator|->
name|index
expr_stmt|;
if|if
condition|(
name|pitem
index|[
name|j
index|]
operator|->
name|class
operator|==
name|TERM
condition|)
block|{
name|preced
operator|=
name|pitem
index|[
name|j
index|]
operator|->
name|prec
expr_stmt|;
name|assoc
operator|=
name|pitem
index|[
name|j
index|]
operator|->
name|assoc
expr_stmt|;
block|}
operator|++
name|j
expr_stmt|;
block|}
name|ritem
index|[
name|j
index|]
operator|=
operator|-
name|i
expr_stmt|;
operator|++
name|j
expr_stmt|;
if|if
condition|(
name|rprec
index|[
name|i
index|]
operator|==
name|UNDEFINED
condition|)
block|{
name|rprec
index|[
name|i
index|]
operator|=
name|preced
expr_stmt|;
name|rassoc
index|[
name|i
index|]
operator|=
name|assoc
expr_stmt|;
block|}
block|}
name|rrhs
index|[
name|i
index|]
operator|=
name|j
expr_stmt|;
name|FREE
argument_list|(
name|plhs
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|pitem
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_grammar
parameter_list|()
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|int
name|spacing
decl_stmt|;
name|FILE
modifier|*
name|f
init|=
name|verbose_file
decl_stmt|;
if|if
condition|(
operator|!
name|vflag
condition|)
return|return;
name|k
operator|=
literal|1
expr_stmt|;
name|spacing
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|nrules
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|rlhs
index|[
name|i
index|]
operator|!=
name|rlhs
index|[
name|i
operator|-
literal|1
index|]
condition|)
block|{
if|if
condition|(
name|i
operator|!=
literal|2
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%4d  %s :"
argument_list|,
name|i
operator|-
literal|2
argument_list|,
name|symbol_name
index|[
name|rlhs
index|[
name|i
index|]
index|]
argument_list|)
expr_stmt|;
name|spacing
operator|=
name|strlen
argument_list|(
name|symbol_name
index|[
name|rlhs
index|[
name|i
index|]
index|]
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%4d  "
argument_list|,
name|i
operator|-
literal|2
argument_list|)
expr_stmt|;
name|j
operator|=
name|spacing
expr_stmt|;
while|while
condition|(
operator|--
name|j
operator|>=
literal|0
condition|)
name|putc
argument_list|(
literal|' '
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'|'
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|ritem
index|[
name|k
index|]
operator|>=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|" %s"
argument_list|,
name|symbol_name
index|[
name|ritem
index|[
name|k
index|]
index|]
argument_list|)
expr_stmt|;
operator|++
name|k
expr_stmt|;
block|}
operator|++
name|k
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|reader
parameter_list|()
block|{
name|write_section
argument_list|(
name|banner
argument_list|)
expr_stmt|;
name|create_symbol_table
argument_list|()
expr_stmt|;
name|read_declarations
argument_list|()
expr_stmt|;
name|read_grammar
argument_list|()
expr_stmt|;
name|free_symbol_table
argument_list|()
expr_stmt|;
name|free_tags
argument_list|()
expr_stmt|;
name|pack_names
argument_list|()
expr_stmt|;
name|check_symbols
argument_list|()
expr_stmt|;
name|pack_symbols
argument_list|()
expr_stmt|;
name|pack_grammar
argument_list|()
expr_stmt|;
name|free_symbols
argument_list|()
expr_stmt|;
name|print_grammar
argument_list|()
expr_stmt|;
block|}
end_function

end_unit

