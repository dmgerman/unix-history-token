begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright 1997 Massachusetts Institute of Technology  *  * Permission to use, copy, modify, and distribute this software and  * its documentation for any purpose and without fee is hereby  * granted, provided that both the above copyright notice and this  * permission notice appear in all copies, that both the above  * copyright notice and this permission notice appear in all  * supporting documentation, and that the name of M.I.T. not be used  * in advertising or publicity pertaining to distribution of the  * software without specific, written prior permission.  M.I.T. makes  * no representations about the suitability of this software for any  * purpose.  It is provided "as is" without express or implied  * warranty.  *   * THIS SOFTWARE IS PROVIDED BY M.I.T. ``AS IS''.  M.I.T. DISCLAIMS  * ALL EXPRESS OR IMPLIED WARRANTIES WITH REGARD TO THIS SOFTWARE,  * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT  * SHALL M.I.T. BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF  * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	$Id: http.c,v 1.11 1997/08/05 20:18:38 ache Exp $  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<md5.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<sysexits.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_comment
comment|/* for MAXHOSTNAMELEN */
end_comment

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|"fetch.h"
end_include

begin_struct
struct|struct
name|http_state
block|{
name|char
modifier|*
name|http_hostname
decl_stmt|;
name|char
modifier|*
name|http_remote_request
decl_stmt|;
name|char
modifier|*
name|http_decoded_file
decl_stmt|;
name|char
modifier|*
name|http_host_header
decl_stmt|;
name|char
modifier|*
name|http_authentication
decl_stmt|;
name|char
modifier|*
name|http_proxy_authentication
decl_stmt|;
name|unsigned
name|http_port
decl_stmt|;
name|int
name|http_redirected
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|http_auth
block|{
name|TAILQ_ENTRY
argument_list|(
argument|http_auth
argument_list|)
name|ha_link
expr_stmt|;
name|char
modifier|*
name|ha_scheme
decl_stmt|;
name|char
modifier|*
name|ha_realm
decl_stmt|;
name|char
modifier|*
name|ha_params
decl_stmt|;
specifier|const
name|struct
name|http_auth_method
modifier|*
name|ha_ham
decl_stmt|;
block|}
struct|;
end_struct

begin_expr_stmt
name|TAILQ_HEAD
argument_list|(
name|http_auth_head
argument_list|,
name|http_auth
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|int
name|http_parse
parameter_list|(
name|struct
name|fetch_state
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|uri
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|http_proxy_parse
parameter_list|(
name|struct
name|fetch_state
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|uri
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|http_close
parameter_list|(
name|struct
name|fetch_state
modifier|*
name|fs
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|http_retrieve
parameter_list|(
name|struct
name|fetch_state
modifier|*
name|fs
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|basic_doauth
parameter_list|(
name|struct
name|fetch_state
modifier|*
name|fs
parameter_list|,
name|struct
name|http_auth
modifier|*
name|ha
parameter_list|,
name|int
name|prx
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|uri_scheme
name|http_scheme
init|=
block|{
literal|"http"
block|,
name|http_parse
block|,
name|http_proxy_parse
block|,
literal|"HTTP_PROXY"
block|,
literal|"http"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|http_auth_head
name|http_auth
decl_stmt|,
name|http_proxy_auth
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|http_auth_method
block|{
specifier|const
name|char
modifier|*
name|ham_scheme
decl_stmt|;
name|int
function_decl|(
modifier|*
name|ham_doauth
function_decl|)
parameter_list|(
name|struct
name|fetch_state
modifier|*
parameter_list|,
name|struct
name|http_auth
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
block|}
name|http_auth_methods
index|[]
init|=
block|{
block|{
literal|"basic"
block|,
name|basic_doauth
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
struct|;
end_struct

begin_comment
comment|/* We are only concerned with headers we might receive. */
end_comment

begin_enum
enum|enum
name|http_header
block|{
name|ht_accept_ranges
block|,
name|ht_age
block|,
name|ht_allow
block|,
name|ht_cache_control
block|,
name|ht_connection
block|,
name|ht_content_base
block|,
name|ht_content_encoding
block|,
name|ht_content_language
block|,
name|ht_content_length
block|,
name|ht_content_location
block|,
name|ht_content_md5
block|,
name|ht_content_range
block|,
name|ht_content_type
block|,
name|ht_date
block|,
name|ht_etag
block|,
name|ht_expires
block|,
name|ht_last_modified
block|,
name|ht_location
block|,
name|ht_pragma
block|,
name|ht_proxy_authenticate
block|,
name|ht_public
block|,
name|ht_retry_after
block|,
name|ht_server
block|,
name|ht_transfer_encoding
block|,
name|ht_upgrade
block|,
name|ht_vary
block|,
name|ht_via
block|,
name|ht_www_authenticate
block|,
name|ht_warning
block|,
comment|/* unusual cases */
name|ht_syntax_error
block|,
name|ht_unknown
block|,
name|ht_end_of_header
block|}
enum|;
end_enum

begin_function_decl
specifier|static
name|char
modifier|*
name|format_http_date
parameter_list|(
name|time_t
name|when
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|format_http_user_agent
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|http_header
name|http_parse_header
parameter_list|(
name|char
modifier|*
name|line
parameter_list|,
name|char
modifier|*
modifier|*
name|valuep
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|check_md5
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|char
modifier|*
name|base64ofmd5
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|http_first_line
parameter_list|(
specifier|const
name|char
modifier|*
name|line
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|http_suck
parameter_list|(
name|struct
name|fetch_state
modifier|*
name|fs
parameter_list|,
name|FILE
modifier|*
name|remote
parameter_list|,
name|FILE
modifier|*
name|local
parameter_list|,
name|off_t
name|total_length
parameter_list|,
name|int
name|timo
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|http_suck_chunked
parameter_list|(
name|struct
name|fetch_state
modifier|*
name|fs
parameter_list|,
name|FILE
modifier|*
name|remote
parameter_list|,
name|FILE
modifier|*
name|local
parameter_list|,
name|off_t
name|total_length
parameter_list|,
name|int
name|timo
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|parse_http_content_range
parameter_list|(
name|char
modifier|*
name|orig
parameter_list|,
name|off_t
modifier|*
name|first
parameter_list|,
name|off_t
modifier|*
name|total
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|process_http_auth
parameter_list|(
name|struct
name|fetch_state
modifier|*
name|fs
parameter_list|,
name|char
modifier|*
name|hdr
parameter_list|,
name|int
name|autherr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|http_auth
modifier|*
name|find_http_auth
parameter_list|(
name|struct
name|http_auth_head
modifier|*
name|list
parameter_list|,
specifier|const
name|char
modifier|*
name|scheme
parameter_list|,
specifier|const
name|char
modifier|*
name|realm
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|time_t
name|parse_http_date
parameter_list|(
name|char
modifier|*
name|datestring
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|setup_http_auth
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|http_parse
parameter_list|(
name|struct
name|fetch_state
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|uri
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|colon
decl_stmt|,
modifier|*
name|slash
decl_stmt|,
modifier|*
name|ques
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|char
modifier|*
name|hostname
decl_stmt|,
modifier|*
name|hosthdr
decl_stmt|,
modifier|*
name|trimmed_name
decl_stmt|;
name|unsigned
name|port
decl_stmt|;
name|struct
name|http_state
modifier|*
name|https
decl_stmt|;
name|p
operator|=
name|uri
operator|+
literal|5
expr_stmt|;
name|port
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|!=
literal|'/'
operator|||
name|p
index|[
literal|1
index|]
operator|!=
literal|'/'
condition|)
block|{
name|warnx
argument_list|(
literal|"`%s': malformed `http' URL"
argument_list|,
name|uri
argument_list|)
expr_stmt|;
return|return
name|EX_USAGE
return|;
block|}
name|p
operator|+=
literal|2
expr_stmt|;
name|colon
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
name|slash
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|colon
operator|&&
name|slash
operator|&&
name|colon
operator|<
name|slash
condition|)
name|q
operator|=
name|colon
expr_stmt|;
else|else
name|q
operator|=
name|slash
expr_stmt|;
if|if
condition|(
name|q
operator|==
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"`%s': malformed `http' URL"
argument_list|,
name|uri
argument_list|)
expr_stmt|;
return|return
name|EX_USAGE
return|;
block|}
name|hostname
operator|=
name|alloca
argument_list|(
name|q
operator|-
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
name|hostname
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|strncat
argument_list|(
name|hostname
argument_list|,
name|p
argument_list|,
name|q
operator|-
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|slash
expr_stmt|;
if|if
condition|(
name|colon
operator|&&
name|colon
operator|+
literal|1
operator|!=
name|slash
condition|)
block|{
name|unsigned
name|long
name|ul
decl_stmt|;
name|char
modifier|*
name|ep
decl_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|ul
operator|=
name|strtoul
argument_list|(
name|colon
operator|+
literal|1
argument_list|,
operator|&
name|ep
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|!=
name|slash
operator|||
name|ep
operator|==
name|colon
operator|+
literal|1
operator|||
name|errno
operator|!=
literal|0
operator|||
name|ul
operator|<
literal|1
operator|||
name|ul
operator|>
literal|65534
condition|)
block|{
name|warn
argument_list|(
literal|"`%s': invalid port in URL"
argument_list|,
name|uri
argument_list|)
expr_stmt|;
return|return
name|EX_USAGE
return|;
block|}
name|port
operator|=
name|ul
expr_stmt|;
block|}
else|else
block|{
name|port
operator|=
literal|80
expr_stmt|;
block|}
name|p
operator|=
name|slash
expr_stmt|;
name|https
operator|=
name|safe_malloc
argument_list|(
sizeof|sizeof
expr|*
name|https
argument_list|)
expr_stmt|;
comment|/* 	 * Now, we have a copy of the hostname in hostname, the specified port 	 * (or the default value) in port, and p points to the filename part 	 * of the URI. 	 */
name|https
operator|->
name|http_hostname
operator|=
name|safe_strdup
argument_list|(
name|hostname
argument_list|)
expr_stmt|;
name|https
operator|->
name|http_port
operator|=
name|port
expr_stmt|;
name|hosthdr
operator|=
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
literal|"Host: :\r\n"
argument_list|)
operator|+
literal|5
operator|+
name|strlen
argument_list|(
name|hostname
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|hosthdr
argument_list|,
literal|"Host: %s:%d\r\n"
argument_list|,
name|hostname
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|https
operator|->
name|http_host_header
operator|=
name|safe_strdup
argument_list|(
name|hosthdr
argument_list|)
expr_stmt|;
comment|/* 	 * NB: HTTP/1.1 servers MUST also accept a full URI. 	 * However, HTTP/1.0 servers will ONLY accept a trimmed URI. 	 */
name|https
operator|->
name|http_remote_request
operator|=
name|safe_strdup
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
name|ques
operator|=
name|strpbrk
argument_list|(
name|p
argument_list|,
literal|"?#"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ques
condition|)
block|{
name|trimmed_name
operator|=
name|safe_strndup
argument_list|(
name|p
argument_list|,
name|ques
operator|-
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|trimmed_name
operator|=
name|safe_strdup
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|https
operator|->
name|http_decoded_file
operator|=
name|percent_decode
argument_list|(
name|trimmed_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|trimmed_name
argument_list|)
expr_stmt|;
name|p
operator|=
name|https
operator|->
name|http_decoded_file
expr_stmt|;
comment|/* now p is the decoded version, so we can extract the basename */
if|if
condition|(
name|fs
operator|->
name|fs_outputfile
operator|==
literal|0
condition|)
block|{
name|slash
operator|=
name|strrchr
argument_list|(
name|p
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|slash
condition|)
name|fs
operator|->
name|fs_outputfile
operator|=
name|slash
operator|+
literal|1
expr_stmt|;
else|else
name|fs
operator|->
name|fs_outputfile
operator|=
name|p
expr_stmt|;
block|}
name|https
operator|->
name|http_redirected
operator|=
literal|0
expr_stmt|;
name|https
operator|->
name|http_authentication
operator|=
name|https
operator|->
name|http_proxy_authentication
operator|=
literal|0
expr_stmt|;
name|fs
operator|->
name|fs_proto
operator|=
name|https
expr_stmt|;
name|fs
operator|->
name|fs_close
operator|=
name|http_close
expr_stmt|;
name|fs
operator|->
name|fs_retrieve
operator|=
name|http_retrieve
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * An HTTP proxy works by accepting a complete URI in a GET request,  * retrieving that object, and then forwarding it back to us.  Because  * it can conceivably handle any URI, we have to do a bit more work  * in the parsing of it.  */
end_comment

begin_function
specifier|static
name|int
name|http_proxy_parse
parameter_list|(
name|struct
name|fetch_state
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|uri
parameter_list|)
block|{
name|struct
name|http_state
modifier|*
name|https
decl_stmt|;
specifier|const
name|char
modifier|*
name|env
decl_stmt|,
modifier|*
name|slash
decl_stmt|,
modifier|*
name|ques
decl_stmt|;
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|https
operator|=
name|safe_malloc
argument_list|(
sizeof|sizeof
expr|*
name|https
argument_list|)
expr_stmt|;
name|https
operator|->
name|http_remote_request
operator|=
name|safe_strdup
argument_list|(
name|uri
argument_list|)
expr_stmt|;
name|env
operator|=
name|getenv
argument_list|(
literal|"HTTP_PROXY"
argument_list|)
expr_stmt|;
name|rv
operator|=
name|parse_host_port
argument_list|(
name|env
argument_list|,
operator|&
name|https
operator|->
name|http_hostname
argument_list|,
operator|&
name|https
operator|->
name|http_port
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
condition|)
block|{
name|out
label|:
name|free
argument_list|(
name|https
operator|->
name|http_remote_request
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|https
argument_list|)
expr_stmt|;
return|return
name|rv
return|;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|uri
argument_list|,
literal|"http://"
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|uri
argument_list|,
literal|"ftp://"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|hosthdr
decl_stmt|;
name|slash
operator|=
name|strchr
argument_list|(
name|uri
operator|+
literal|7
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|slash
operator|==
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"`%s': malformed `http' URL"
argument_list|,
name|uri
argument_list|)
expr_stmt|;
name|rv
operator|=
name|EX_USAGE
expr_stmt|;
name|free
argument_list|(
name|https
operator|->
name|http_hostname
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ques
operator|=
name|strpbrk
argument_list|(
name|slash
argument_list|,
literal|"?#"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ques
operator|==
literal|0
condition|)
name|file
operator|=
name|safe_strdup
argument_list|(
name|slash
argument_list|)
expr_stmt|;
else|else
name|file
operator|=
name|safe_strndup
argument_list|(
name|slash
argument_list|,
name|ques
operator|-
name|slash
argument_list|)
expr_stmt|;
name|hosthdr
operator|=
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
literal|"Host: \r\n"
argument_list|)
operator|+
name|slash
operator|-
name|uri
operator|-
literal|7
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|hosthdr
argument_list|,
literal|"Host: "
argument_list|)
expr_stmt|;
name|strncat
argument_list|(
name|hosthdr
argument_list|,
name|uri
operator|+
literal|7
argument_list|,
name|slash
operator|-
name|uri
operator|-
literal|7
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|hosthdr
argument_list|,
literal|"\r\n"
argument_list|)
expr_stmt|;
name|https
operator|->
name|http_host_header
operator|=
name|safe_strdup
argument_list|(
name|hosthdr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|slash
operator|=
name|uri
expr_stmt|;
while|while
condition|(
operator|*
name|slash
operator|&&
operator|*
name|slash
operator|!=
literal|':'
condition|)
name|slash
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|slash
condition|)
name|slash
operator|++
expr_stmt|;
if|if
condition|(
name|slash
index|[
literal|0
index|]
operator|==
literal|'/'
operator|&&
name|slash
index|[
literal|1
index|]
operator|==
literal|'/'
condition|)
block|{
name|slash
operator|+=
literal|2
expr_stmt|;
while|while
condition|(
operator|*
name|slash
operator|&&
operator|*
name|slash
operator|!=
literal|'/'
condition|)
name|slash
operator|++
expr_stmt|;
block|}
name|file
operator|=
name|safe_strdup
argument_list|(
name|slash
argument_list|)
expr_stmt|;
name|https
operator|->
name|http_host_header
operator|=
name|safe_strdup
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
name|https
operator|->
name|http_decoded_file
operator|=
name|percent_decode
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|https
operator|->
name|http_redirected
operator|=
literal|0
expr_stmt|;
name|https
operator|->
name|http_authentication
operator|=
name|https
operator|->
name|http_proxy_authentication
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|fs
operator|->
name|fs_outputfile
operator|==
literal|0
condition|)
block|{
name|slash
operator|=
name|strrchr
argument_list|(
name|https
operator|->
name|http_decoded_file
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
comment|/* NB: we are not guaranteed to find one... */
name|fs
operator|->
name|fs_outputfile
operator|=
name|slash
condition|?
name|slash
operator|+
literal|1
else|:
name|https
operator|->
name|http_decoded_file
expr_stmt|;
block|}
name|fs
operator|->
name|fs_proto
operator|=
name|https
expr_stmt|;
name|fs
operator|->
name|fs_close
operator|=
name|http_close
expr_stmt|;
name|fs
operator|->
name|fs_retrieve
operator|=
name|http_retrieve
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|http_close
parameter_list|(
name|struct
name|fetch_state
modifier|*
name|fs
parameter_list|)
block|{
name|struct
name|http_state
modifier|*
name|https
init|=
name|fs
operator|->
name|fs_proto
decl_stmt|;
name|free
argument_list|(
name|https
operator|->
name|http_hostname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|https
operator|->
name|http_remote_request
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|https
operator|->
name|http_decoded_file
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|https
operator|->
name|http_host_header
argument_list|)
expr_stmt|;
if|if
condition|(
name|https
operator|->
name|http_authentication
condition|)
name|free
argument_list|(
name|https
operator|->
name|http_authentication
argument_list|)
expr_stmt|;
if|if
condition|(
name|https
operator|->
name|http_proxy_authentication
condition|)
name|free
argument_list|(
name|https
operator|->
name|http_proxy_authentication
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|https
argument_list|)
expr_stmt|;
name|fs
operator|->
name|fs_outputfile
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nullclose
parameter_list|(
name|struct
name|fetch_state
modifier|*
name|fs
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Process a redirection.  This has a small memory leak.  */
end_comment

begin_function
specifier|static
name|int
name|http_redirect
parameter_list|(
name|struct
name|fetch_state
modifier|*
name|fs
parameter_list|,
name|char
modifier|*
name|new
parameter_list|,
name|int
name|permanent
parameter_list|)
block|{
name|struct
name|http_state
modifier|*
name|https
init|=
name|fs
operator|->
name|fs_proto
decl_stmt|;
name|int
name|num_redirects
init|=
name|https
operator|->
name|http_redirected
operator|+
literal|1
decl_stmt|;
name|char
modifier|*
name|out
init|=
name|safe_strdup
argument_list|(
name|fs
operator|->
name|fs_outputfile
argument_list|)
decl_stmt|;
name|int
name|rv
decl_stmt|;
if|if
condition|(
name|num_redirects
operator|>
literal|5
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: HTTP redirection limit exceeded"
argument_list|)
expr_stmt|;
return|return
name|EX_PROTOCOL
return|;
block|}
name|free
argument_list|(
name|https
operator|->
name|http_hostname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|https
operator|->
name|http_remote_request
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|https
operator|->
name|http_decoded_file
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|https
argument_list|)
expr_stmt|;
name|warnx
argument_list|(
literal|"%s: resource has moved %s to `%s'"
argument_list|,
name|out
argument_list|,
name|permanent
condition|?
literal|"permanently"
else|:
literal|"temporarily"
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|rv
operator|=
name|http_parse
argument_list|(
name|fs
argument_list|,
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
block|{
name|fs
operator|->
name|fs_close
operator|=
name|nullclose
expr_stmt|;
comment|/* XXX rethink interface? */
return|return
name|rv
return|;
block|}
name|https
operator|=
name|fs
operator|->
name|fs_proto
expr_stmt|;
name|https
operator|->
name|http_redirected
operator|=
name|num_redirects
expr_stmt|;
comment|/* 	 * This ensures that the output file name doesn't suddenly change 	 * under the user's feet.  Unfortunately, this results in a small 	 * memory leak.  I wish C had garbage collection... 	 */
name|fs
operator|->
name|fs_outputfile
operator|=
name|out
expr_stmt|;
name|rv
operator|=
name|http_retrieve
argument_list|(
name|fs
argument_list|)
expr_stmt|;
return|return
name|rv
return|;
block|}
end_function

begin_comment
comment|/*  * Read HTML-formatted data from remote and display it on stderr.  * This is extremely incomplete, as all it does is delete anything  * between angle brackets.  However, this is usually good enough for  * error messages.  */
end_comment

begin_function
specifier|static
name|void
name|html_display
parameter_list|(
name|FILE
modifier|*
name|remote
parameter_list|)
block|{
name|char
modifier|*
name|line
decl_stmt|;
name|int
name|linelen
decl_stmt|;
name|int
name|inbracket
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|line
operator|=
name|fgetln
argument_list|(
name|remote
argument_list|,
operator|&
name|linelen
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|char
modifier|*
name|end
init|=
name|line
operator|+
name|linelen
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|content
init|=
literal|0
decl_stmt|;
for|for
control|(
name|p
operator|=
name|line
init|;
name|p
operator|<
name|end
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'<'
operator|&&
operator|!
name|inbracket
condition|)
block|{
name|fwrite
argument_list|(
name|line
argument_list|,
literal|1
argument_list|,
operator|(
name|p
operator|-
name|line
operator|)
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|inbracket
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|inbracket
operator|&&
operator|!
name|content
operator|&&
operator|*
name|p
operator|!=
literal|'\n'
operator|&&
operator|*
name|p
operator|!=
literal|'\r'
condition|)
name|content
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'>'
operator|&&
name|inbracket
condition|)
block|{
name|line
operator|=
name|p
operator|+
literal|1
expr_stmt|;
name|inbracket
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|content
operator|&&
name|line
operator|<
name|end
condition|)
name|fwrite
argument_list|(
name|line
argument_list|,
literal|1
argument_list|,
operator|(
name|end
operator|-
name|line
operator|)
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Get a file using HTTP.  We will try to implement HTTP/1.1 eventually.  * This subroutine makes heavy use of the 4.4-Lite standard I/O library,  * in particular the `fgetln' which allows us to slurp an entire `line'  * (an arbitrary string of non-NUL characters ending in a newline) directly  * out of the stdio buffer.  This makes interpreting the HTTP headers much  * easier, since they are all guaranteed to end in `\r\n' and we can just  * ignore the `\r'.  */
end_comment

begin_function
specifier|static
name|int
name|http_retrieve
parameter_list|(
name|struct
name|fetch_state
modifier|*
name|fs
parameter_list|)
block|{
name|struct
name|http_state
modifier|*
name|https
decl_stmt|;
name|FILE
modifier|*
name|remote
decl_stmt|,
modifier|*
name|local
decl_stmt|;
name|int
name|s
decl_stmt|;
name|struct
name|sockaddr_in
name|sin
decl_stmt|;
name|struct
name|msghdr
name|msg
decl_stmt|;
define|#
directive|define
name|NIOV
value|16
comment|/* max is currently 14 */
name|struct
name|iovec
name|iov
index|[
name|NIOV
index|]
decl_stmt|;
name|int
name|n
decl_stmt|,
name|status
decl_stmt|;
specifier|const
name|char
modifier|*
name|env
decl_stmt|;
name|int
name|timo
decl_stmt|;
name|char
modifier|*
name|line
decl_stmt|,
modifier|*
name|new_location
decl_stmt|;
name|char
modifier|*
name|errstr
init|=
literal|0
decl_stmt|;
name|size_t
name|linelen
decl_stmt|,
name|writeresult
decl_stmt|;
name|off_t
name|total_length
decl_stmt|,
name|restart_from
decl_stmt|;
name|time_t
name|last_modified
decl_stmt|,
name|when_to_retry
decl_stmt|;
name|char
modifier|*
name|base64ofmd5
decl_stmt|;
name|int
name|to_stdout
decl_stmt|,
name|restarting
decl_stmt|,
name|redirection
decl_stmt|,
name|retrying
decl_stmt|,
name|autherror
decl_stmt|,
name|chunked
decl_stmt|;
name|char
name|rangebuf
index|[
sizeof|sizeof
argument_list|(
literal|"Range: bytes=18446744073709551616-\r\n"
argument_list|)
index|]
decl_stmt|;
name|setup_http_auth
argument_list|()
expr_stmt|;
name|https
operator|=
name|fs
operator|->
name|fs_proto
expr_stmt|;
name|to_stdout
operator|=
operator|(
name|strcmp
argument_list|(
name|fs
operator|->
name|fs_outputfile
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
name|restarting
operator|=
name|fs
operator|->
name|fs_restart
expr_stmt|;
name|redirection
operator|=
literal|0
expr_stmt|;
name|retrying
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Figure out the timeout.  Prefer the -T command-line value, 	 * otherwise the HTTP_TIMEOUT envar, or else don't time out at all. 	 */
if|if
condition|(
name|fs
operator|->
name|fs_timeout
condition|)
block|{
name|timo
operator|=
name|fs
operator|->
name|fs_timeout
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|env
operator|=
name|getenv
argument_list|(
literal|"HTTP_TIMEOUT"
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|char
modifier|*
name|ep
decl_stmt|;
name|unsigned
name|long
name|ul
decl_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|ul
operator|=
name|strtoul
argument_list|(
name|env
argument_list|,
operator|&
name|ep
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ep
operator|!=
literal|'\0'
operator|||
operator|*
name|env
operator|==
literal|'\0'
operator|||
name|errno
operator|!=
literal|0
operator|||
name|ul
operator|>
name|INT_MAX
condition|)
block|{
name|warnx
argument_list|(
literal|"`%s': invalid timeout"
argument_list|,
name|env
argument_list|)
expr_stmt|;
return|return
name|EX_USAGE
return|;
block|}
name|timo
operator|=
name|ul
expr_stmt|;
block|}
else|else
block|{
name|timo
operator|=
literal|0
expr_stmt|;
block|}
name|memset
argument_list|(
operator|&
name|sin
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|sin
argument_list|)
expr_stmt|;
name|sin
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin
operator|.
name|sin_len
operator|=
sizeof|sizeof
name|sin
expr_stmt|;
name|sin
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
name|https
operator|->
name|http_port
argument_list|)
expr_stmt|;
name|fs
operator|->
name|fs_status
operator|=
literal|"looking up hostname"
expr_stmt|;
if|if
condition|(
name|inet_aton
argument_list|(
name|https
operator|->
name|http_hostname
argument_list|,
operator|&
name|sin
operator|.
name|sin_addr
argument_list|)
operator|==
literal|0
condition|)
block|{
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
comment|/* XXX - do timeouts for name resolution? */
name|hp
operator|=
name|gethostbyname2
argument_list|(
name|https
operator|->
name|http_hostname
argument_list|,
name|AF_INET
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|==
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"`%s': cannot resolve: %s"
argument_list|,
name|https
operator|->
name|http_hostname
argument_list|,
name|hstrerror
argument_list|(
name|h_errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|EX_NOHOST
return|;
block|}
name|memcpy
argument_list|(
operator|&
name|sin
operator|.
name|sin_addr
argument_list|,
name|hp
operator|->
name|h_addr_list
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
name|sin
operator|.
name|sin_addr
argument_list|)
expr_stmt|;
block|}
name|fs
operator|->
name|fs_status
operator|=
literal|"creating request message"
expr_stmt|;
name|msg
operator|.
name|msg_name
operator|=
operator|(
name|caddr_t
operator|)
operator|&
name|sin
expr_stmt|;
name|msg
operator|.
name|msg_namelen
operator|=
sizeof|sizeof
name|sin
expr_stmt|;
name|msg
operator|.
name|msg_iov
operator|=
name|iov
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
name|msg
operator|.
name|msg_control
operator|=
literal|0
expr_stmt|;
name|msg
operator|.
name|msg_controllen
operator|=
literal|0
expr_stmt|;
name|msg
operator|.
name|msg_flags
operator|=
name|fs
operator|->
name|fs_linux_bug
condition|?
literal|0
else|:
name|MSG_EOF
expr_stmt|;
define|#
directive|define
name|addstr
parameter_list|(
name|Iov
parameter_list|,
name|N
parameter_list|,
name|Str
parameter_list|)
define|\
value|do { \ 		    Iov[N].iov_base = (void *)Str; \ 		     Iov[N].iov_len = strlen(Iov[n].iov_base); \ 		     N++; \         } while(0)
name|retry
label|:
name|addstr
argument_list|(
name|iov
argument_list|,
name|n
argument_list|,
literal|"GET "
argument_list|)
expr_stmt|;
name|addstr
argument_list|(
name|iov
argument_list|,
name|n
argument_list|,
name|https
operator|->
name|http_remote_request
argument_list|)
expr_stmt|;
name|addstr
argument_list|(
name|iov
argument_list|,
name|n
argument_list|,
literal|" HTTP/1.1\r\n"
argument_list|)
expr_stmt|;
comment|/* 	 * The choice of HTTP/1.1 may be a bit controversial.  The  	 * specification says that implementations which are not at 	 * least conditionally compliant MUST NOT call themselves 	 * HTTP/1.1.  We choose not to comply with that requirement. 	 * (Eventually we will support the full HTTP/1.1, at which 	 * time this comment will not apply.  But it's amusing how 	 * specifications attempt to define behavior for implementations 	 * which aren't obeying the spec in the first place...) 	 */
name|addstr
argument_list|(
name|iov
argument_list|,
name|n
argument_list|,
name|format_http_user_agent
argument_list|()
argument_list|)
expr_stmt|;
comment|/* do content negotiation here */
name|addstr
argument_list|(
name|iov
argument_list|,
name|n
argument_list|,
literal|"Accept: */*\r\n"
argument_list|)
expr_stmt|;
name|addstr
argument_list|(
name|iov
argument_list|,
name|n
argument_list|,
name|https
operator|->
name|http_host_header
argument_list|)
expr_stmt|;
name|addstr
argument_list|(
name|iov
argument_list|,
name|n
argument_list|,
literal|"Connection: close\r\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|https
operator|->
name|http_proxy_authentication
condition|)
name|addstr
argument_list|(
name|iov
argument_list|,
name|n
argument_list|,
name|https
operator|->
name|http_proxy_authentication
argument_list|)
expr_stmt|;
if|if
condition|(
name|https
operator|->
name|http_authentication
condition|)
name|addstr
argument_list|(
name|iov
argument_list|,
name|n
argument_list|,
name|https
operator|->
name|http_authentication
argument_list|)
expr_stmt|;
if|if
condition|(
name|fs
operator|->
name|fs_mirror
condition|)
block|{
name|struct
name|stat
name|stab
decl_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
operator|(
operator|!
name|to_stdout
operator|&&
name|stat
argument_list|(
name|fs
operator|->
name|fs_outputfile
argument_list|,
operator|&
name|stab
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|to_stdout
operator|&&
name|fstat
argument_list|(
name|STDOUT_FILENO
argument_list|,
operator|&
name|stab
argument_list|)
operator|==
literal|0
operator|)
operator|)
operator|&&
name|S_ISREG
argument_list|(
name|stab
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|addstr
argument_list|(
name|iov
argument_list|,
name|n
argument_list|,
literal|"If-Modified-Since: "
argument_list|)
expr_stmt|;
name|addstr
argument_list|(
name|iov
argument_list|,
name|n
argument_list|,
name|format_http_date
argument_list|(
name|stab
operator|.
name|st_mtime
argument_list|)
argument_list|)
expr_stmt|;
name|addstr
argument_list|(
name|iov
argument_list|,
name|n
argument_list|,
literal|"\r\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|errno
operator|!=
literal|0
operator|||
operator|!
name|S_ISREG
argument_list|(
name|stab
operator|.
name|st_mode
argument_list|)
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
literal|0
condition|)
name|warn
argument_list|(
literal|"%s"
argument_list|,
name|fs
operator|->
name|fs_outputfile
argument_list|)
expr_stmt|;
else|else
name|warnx
argument_list|(
literal|"%s: not a regular file"
argument_list|,
name|fs
operator|->
name|fs_outputfile
argument_list|)
expr_stmt|;
name|warnx
argument_list|(
literal|"cannot mirror; will retrieve anew"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|restarting
condition|)
block|{
name|struct
name|stat
name|stab
decl_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
operator|(
operator|!
name|to_stdout
operator|&&
name|stat
argument_list|(
name|fs
operator|->
name|fs_outputfile
argument_list|,
operator|&
name|stab
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|to_stdout
operator|&&
name|fstat
argument_list|(
name|STDOUT_FILENO
argument_list|,
operator|&
name|stab
argument_list|)
operator|==
literal|0
operator|)
operator|)
operator|&&
name|S_ISREG
argument_list|(
name|stab
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|addstr
argument_list|(
name|iov
argument_list|,
name|n
argument_list|,
literal|"If-Range: "
argument_list|)
expr_stmt|;
name|addstr
argument_list|(
name|iov
argument_list|,
name|n
argument_list|,
name|format_http_date
argument_list|(
name|stab
operator|.
name|st_mtime
argument_list|)
argument_list|)
expr_stmt|;
name|addstr
argument_list|(
name|iov
argument_list|,
name|n
argument_list|,
literal|"\r\n"
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|rangebuf
argument_list|,
literal|"Range: bytes=%qd-\r\n"
argument_list|,
operator|(
name|quad_t
operator|)
name|stab
operator|.
name|st_size
argument_list|)
expr_stmt|;
name|addstr
argument_list|(
name|iov
argument_list|,
name|n
argument_list|,
name|rangebuf
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|errno
operator|!=
literal|0
operator|||
operator|!
name|S_ISREG
argument_list|(
name|stab
operator|.
name|st_mode
argument_list|)
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
literal|0
condition|)
name|warn
argument_list|(
literal|"%s"
argument_list|,
name|fs
operator|->
name|fs_outputfile
argument_list|)
expr_stmt|;
else|else
name|warnx
argument_list|(
literal|"%s: not a regular file"
argument_list|,
name|fs
operator|->
name|fs_outputfile
argument_list|)
expr_stmt|;
name|restarting
operator|=
literal|0
expr_stmt|;
name|warnx
argument_list|(
literal|"cannot restart; will retrieve anew"
argument_list|)
expr_stmt|;
block|}
block|}
name|addstr
argument_list|(
name|iov
argument_list|,
name|n
argument_list|,
literal|"\r\n"
argument_list|)
expr_stmt|;
name|msg
operator|.
name|msg_iovlen
operator|=
name|n
expr_stmt|;
if|if
condition|(
name|n
operator|>=
name|NIOV
condition|)
name|err
argument_list|(
name|EX_SOFTWARE
argument_list|,
literal|"request vector length exceeded: %d"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|s
operator|=
name|socket
argument_list|(
name|PF_INET
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"socket"
argument_list|)
expr_stmt|;
return|return
name|EX_OSERR
return|;
block|}
name|remote
operator|=
name|fdopen
argument_list|(
name|s
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|remote
operator|==
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"fdopen"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|EX_OSERR
return|;
block|}
name|fs
operator|->
name|fs_status
operator|=
literal|"sending request message"
expr_stmt|;
name|setup_sigalrm
argument_list|()
expr_stmt|;
name|alarm
argument_list|(
name|timo
argument_list|)
expr_stmt|;
comment|/* some hosts do not properly handle T/TCP connections.  If 	 * sendmsg() is used to establish the connection, the OS may 	 * choose to try to use one which could cause the transfer 	 * to fail.  Doing a connect() first ensures that the OS 	 * does not attempt T/TCP. 	 */
if|if
condition|(
name|fs
operator|->
name|fs_use_connect
operator|&&
operator|(
name|connect
argument_list|(
name|s
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
argument_list|)
operator|<
literal|0
operator|)
condition|)
block|{
name|warn
argument_list|(
literal|"connect: %s"
argument_list|,
name|https
operator|->
name|http_hostname
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|remote
argument_list|)
expr_stmt|;
return|return
name|EX_OSERR
return|;
block|}
if|if
condition|(
name|sendmsg
argument_list|(
name|s
argument_list|,
operator|&
name|msg
argument_list|,
name|fs
operator|->
name|fs_linux_bug
condition|?
literal|0
else|:
name|MSG_EOF
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"sendmsg: %s"
argument_list|,
name|https
operator|->
name|http_hostname
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|remote
argument_list|)
expr_stmt|;
return|return
name|EX_OSERR
return|;
block|}
name|got100reply
label|:
name|fs
operator|->
name|fs_status
operator|=
literal|"reading reply status"
expr_stmt|;
name|alarm
argument_list|(
name|timo
argument_list|)
expr_stmt|;
name|line
operator|=
name|fgetln
argument_list|(
name|remote
argument_list|,
operator|&
name|linelen
argument_list|)
expr_stmt|;
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ferror
argument_list|(
name|remote
argument_list|)
condition|)
block|{
name|warn
argument_list|(
literal|"reading reply from %s"
argument_list|,
name|https
operator|->
name|http_hostname
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|remote
argument_list|)
expr_stmt|;
name|unsetup_sigalrm
argument_list|()
expr_stmt|;
return|return
name|EX_OSERR
return|;
block|}
else|else
block|{
name|warnx
argument_list|(
literal|"empty reply from %s"
argument_list|,
name|https
operator|->
name|http_hostname
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|remote
argument_list|)
expr_stmt|;
name|unsetup_sigalrm
argument_list|()
expr_stmt|;
return|return
name|EX_PROTOCOL
return|;
block|}
block|}
comment|/* 	 * If the other end is HTTP 0.9, then we just suck their 	 * response over; can't do anything fancy.  We assume that 	 * the file is a text file, so it is safe to use fgetln() 	 * to suck the entire file.  (It had better be, since 	 * we used it to grab the first line.) 	 */
if|if
condition|(
name|linelen
operator|<
literal|5
operator|||
name|strncasecmp
argument_list|(
name|line
argument_list|,
literal|"http"
argument_list|,
literal|4
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|to_stdout
condition|)
name|local
operator|=
name|fopen
argument_list|(
literal|"/dev/stdout"
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
else|else
name|local
operator|=
name|fopen
argument_list|(
name|fs
operator|->
name|fs_outputfile
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|local
operator|==
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"%s: fopen"
argument_list|,
name|fs
operator|->
name|fs_outputfile
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|remote
argument_list|)
expr_stmt|;
name|unsetup_sigalrm
argument_list|()
expr_stmt|;
return|return
name|EX_OSERR
return|;
block|}
name|fs
operator|->
name|fs_status
operator|=
literal|"retrieving from HTTP/0.9 server"
expr_stmt|;
name|display
argument_list|(
name|fs
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
do|do
block|{
name|writeresult
operator|=
name|fwrite
argument_list|(
name|line
argument_list|,
literal|1
argument_list|,
name|linelen
argument_list|,
name|local
argument_list|)
expr_stmt|;
name|display
argument_list|(
name|fs
argument_list|,
operator|-
literal|1
argument_list|,
name|writeresult
argument_list|)
expr_stmt|;
if|if
condition|(
name|writeresult
operator|!=
name|linelen
condition|)
break|break;
name|alarm
argument_list|(
name|timo
argument_list|)
expr_stmt|;
name|line
operator|=
name|fgetln
argument_list|(
name|remote
argument_list|,
operator|&
name|linelen
argument_list|)
expr_stmt|;
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|line
operator|!=
literal|0
condition|)
do|;
name|unsetup_sigalrm
argument_list|()
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|local
argument_list|)
condition|)
block|{
name|warn
argument_list|(
literal|"%s"
argument_list|,
name|fs
operator|->
name|fs_outputfile
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|local
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|remote
argument_list|)
expr_stmt|;
name|rm
argument_list|(
name|fs
argument_list|)
expr_stmt|;
return|return
name|EX_OSERR
return|;
block|}
elseif|else
if|if
condition|(
name|ferror
argument_list|(
name|remote
argument_list|)
condition|)
block|{
name|warn
argument_list|(
literal|"%s"
argument_list|,
name|https
operator|->
name|http_hostname
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|local
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|remote
argument_list|)
expr_stmt|;
name|rm
argument_list|(
name|fs
argument_list|)
expr_stmt|;
return|return
name|EX_OSERR
return|;
block|}
name|fclose
argument_list|(
name|local
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|remote
argument_list|)
expr_stmt|;
name|display
argument_list|(
name|fs
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * OK.  The other end is doing HTTP 1.0 at the very least. 	 * This means that some of the fancy stuff is at least possible. 	 */
name|autherror
operator|=
literal|0
expr_stmt|;
name|line
index|[
name|linelen
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* turn line into a string */
name|status
operator|=
name|http_first_line
argument_list|(
name|line
argument_list|)
expr_stmt|;
comment|/* In the future, we might handle redirection and other responses. */
switch|switch
condition|(
name|status
condition|)
block|{
case|case
literal|100
case|:
comment|/* Continue */
goto|goto
name|got100reply
goto|;
case|case
literal|200
case|:
comment|/* Here come results */
case|case
literal|203
case|:
comment|/* Non-Authoritative Information */
name|restarting
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|206
case|:
comment|/* Here come partial results */
comment|/* can only happen when restarting */
break|break;
case|case
literal|301
case|:
comment|/* Resource has moved permanently */
if|if
condition|(
operator|!
name|fs
operator|->
name|fs_auto_retry
condition|)
name|errstr
operator|=
name|safe_strdup
argument_list|(
name|line
argument_list|)
expr_stmt|;
else|else
name|redirection
operator|=
literal|301
expr_stmt|;
break|break;
case|case
literal|302
case|:
comment|/* Resource has moved temporarily */
comment|/* 		 * We don't test fs->fs_auto_retry here so that this 		 * sort of redirection is transparent to the user. 		 */
name|redirection
operator|=
literal|302
expr_stmt|;
break|break;
case|case
literal|304
case|:
comment|/* Object is unmodified */
if|if
condition|(
name|fs
operator|->
name|fs_mirror
condition|)
block|{
name|fclose
argument_list|(
name|remote
argument_list|)
expr_stmt|;
name|unsetup_sigalrm
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
name|errstr
operator|=
name|safe_strdup
argument_list|(
name|line
argument_list|)
expr_stmt|;
break|break;
case|case
literal|401
case|:
comment|/* Unauthorized */
if|if
condition|(
name|https
operator|->
name|http_authentication
condition|)
name|errstr
operator|=
name|safe_strdup
argument_list|(
name|line
argument_list|)
expr_stmt|;
else|else
name|autherror
operator|=
literal|401
expr_stmt|;
break|break;
case|case
literal|407
case|:
comment|/* Proxy Authentication Required */
if|if
condition|(
name|https
operator|->
name|http_proxy_authentication
condition|)
name|errstr
operator|=
name|safe_strdup
argument_list|(
name|line
argument_list|)
expr_stmt|;
else|else
name|autherror
operator|=
literal|407
expr_stmt|;
break|break;
case|case
literal|503
case|:
comment|/* Service Unavailable */
if|if
condition|(
operator|!
name|fs
operator|->
name|fs_auto_retry
condition|)
name|errstr
operator|=
name|safe_strdup
argument_list|(
name|line
argument_list|)
expr_stmt|;
else|else
name|retrying
operator|=
literal|503
expr_stmt|;
break|break;
default|default:
name|errstr
operator|=
name|safe_strdup
argument_list|(
name|line
argument_list|)
expr_stmt|;
break|break;
block|}
name|total_length
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* -1 means ``don't know'' */
name|last_modified
operator|=
name|when_to_retry
operator|=
operator|-
literal|1
expr_stmt|;
name|base64ofmd5
operator|=
literal|0
expr_stmt|;
name|new_location
operator|=
literal|0
expr_stmt|;
name|restart_from
operator|=
literal|0
expr_stmt|;
name|chunked
operator|=
literal|0
expr_stmt|;
name|fs
operator|->
name|fs_status
operator|=
literal|"parsing reply headers"
expr_stmt|;
while|while
condition|(
operator|(
name|line
operator|=
name|fgetln
argument_list|(
name|remote
argument_list|,
operator|&
name|linelen
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|char
modifier|*
name|value
decl_stmt|,
modifier|*
name|ep
decl_stmt|;
name|enum
name|http_header
name|header
decl_stmt|;
name|unsigned
name|long
name|ul
decl_stmt|;
name|line
index|[
name|linelen
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|header
operator|=
name|http_parse_header
argument_list|(
name|line
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|header
operator|==
name|ht_end_of_header
condition|)
break|break;
switch|switch
condition|(
name|header
condition|)
block|{
case|case
name|ht_content_length
case|:
name|errno
operator|=
literal|0
expr_stmt|;
name|ul
operator|=
name|strtoul
argument_list|(
name|value
argument_list|,
operator|&
name|ep
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
literal|0
operator|||
operator|*
name|ep
condition|)
name|warnx
argument_list|(
literal|"invalid Content-Length: `%s'"
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|restarting
condition|)
name|total_length
operator|=
name|ul
expr_stmt|;
break|break;
case|case
name|ht_last_modified
case|:
name|last_modified
operator|=
name|parse_http_date
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_modified
operator|==
operator|-
literal|1
operator|&&
name|fs
operator|->
name|fs_verbose
operator|>
literal|0
condition|)
name|warnx
argument_list|(
literal|"invalid Last-Modified: `%s'"
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|ht_content_md5
case|:
name|base64ofmd5
operator|=
name|safe_strdup
argument_list|(
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|ht_content_range
case|:
if|if
condition|(
operator|!
name|restarting
condition|)
comment|/* XXX protocol error */
break|break;
comment|/* NB: we might have to restart from farther back 			   than we asked. */
name|status
operator|=
name|parse_http_content_range
argument_list|(
name|value
argument_list|,
operator|&
name|restart_from
argument_list|,
operator|&
name|total_length
argument_list|)
expr_stmt|;
comment|/* If we couldn't understand the reply, get the whole 			   thing. */
if|if
condition|(
name|status
condition|)
block|{
name|restarting
operator|=
literal|0
expr_stmt|;
name|doretry
label|:
name|fclose
argument_list|(
name|remote
argument_list|)
expr_stmt|;
if|if
condition|(
name|base64ofmd5
condition|)
name|free
argument_list|(
name|base64ofmd5
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_location
condition|)
name|free
argument_list|(
name|new_location
argument_list|)
expr_stmt|;
name|restart_from
operator|=
literal|0
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
break|break;
case|case
name|ht_location
case|:
if|if
condition|(
name|redirection
condition|)
block|{
name|char
modifier|*
name|s
init|=
name|value
decl_stmt|;
while|while
condition|(
operator|*
name|s
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
name|new_location
operator|=
name|safe_strndup
argument_list|(
name|value
argument_list|,
name|s
operator|-
name|value
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ht_transfer_encoding
case|:
if|if
condition|(
name|strncasecmp
argument_list|(
name|value
argument_list|,
literal|"chunked"
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
condition|)
block|{
name|chunked
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|warnx
argument_list|(
literal|"%s: %s specified Transfer-Encoding `%s'"
argument_list|,
name|fs
operator|->
name|fs_outputfile
argument_list|,
name|https
operator|->
name|http_hostname
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|warnx
argument_list|(
literal|"%s: output file may be uninterpretable"
argument_list|,
name|fs
operator|->
name|fs_outputfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|ht_retry_after
case|:
if|if
condition|(
operator|!
name|retrying
condition|)
break|break;
name|errno
operator|=
literal|0
expr_stmt|;
name|ul
operator|=
name|strtoul
argument_list|(
name|value
argument_list|,
operator|&
name|ep
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
literal|0
operator|||
operator|(
operator|*
name|ep
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|ep
argument_list|)
operator|)
condition|)
block|{
name|time_t
name|when
decl_stmt|;
name|when
operator|=
name|parse_http_date
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|when
operator|==
operator|-
literal|1
condition|)
break|break;
name|when_to_retry
operator|=
name|when
expr_stmt|;
block|}
else|else
block|{
name|when_to_retry
operator|=
name|time
argument_list|(
literal|0
argument_list|)
operator|+
name|ul
expr_stmt|;
block|}
break|break;
case|case
name|ht_www_authenticate
case|:
if|if
condition|(
name|autherror
operator|!=
literal|401
condition|)
break|break;
name|status
operator|=
name|process_http_auth
argument_list|(
name|fs
argument_list|,
name|value
argument_list|,
name|autherror
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
goto|goto
name|cantauth
goto|;
break|break;
case|case
name|ht_proxy_authenticate
case|:
if|if
condition|(
name|autherror
operator|!=
literal|407
condition|)
break|break;
name|status
operator|=
name|process_http_auth
argument_list|(
name|fs
argument_list|,
name|value
argument_list|,
name|autherror
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
goto|goto
name|cantauth
goto|;
break|break;
default|default:
break|break;
block|}
block|}
if|if
condition|(
name|autherror
operator|==
literal|401
operator|&&
name|https
operator|->
name|http_authentication
condition|)
goto|goto
name|doretry
goto|;
if|if
condition|(
name|autherror
operator|==
literal|407
operator|&&
name|https
operator|->
name|http_proxy_authentication
condition|)
goto|goto
name|doretry
goto|;
if|if
condition|(
name|autherror
condition|)
block|{
goto|goto
name|spewerror
goto|;
block|}
if|if
condition|(
name|retrying
condition|)
block|{
name|int
name|howlong
decl_stmt|;
if|if
condition|(
name|when_to_retry
operator|==
operator|-
literal|1
condition|)
block|{
name|errstr
operator|=
name|safe_strdup
argument_list|(
literal|"HTTP/1.1 503 Service Unavailable"
argument_list|)
expr_stmt|;
goto|goto
name|spewerror
goto|;
block|}
name|howlong
operator|=
name|when_to_retry
operator|-
name|time
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|howlong
operator|<
literal|30
condition|)
name|howlong
operator|=
literal|30
expr_stmt|;
name|warnx
argument_list|(
literal|"%s: service unavailable; retrying in %d seconds"
argument_list|,
name|https
operator|->
name|http_hostname
argument_list|,
name|howlong
argument_list|)
expr_stmt|;
name|fs
operator|->
name|fs_status
operator|=
literal|"waiting to retry"
expr_stmt|;
name|sleep
argument_list|(
name|howlong
argument_list|)
expr_stmt|;
goto|goto
name|doretry
goto|;
block|}
if|if
condition|(
name|errstr
operator|!=
literal|0
condition|)
block|{
name|spewerror
label|:
name|warnx
argument_list|(
literal|"%s: %s: HTTP server returned error code %d"
argument_list|,
name|fs
operator|->
name|fs_outputfile
argument_list|,
name|https
operator|->
name|http_hostname
argument_list|,
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|fs
operator|->
name|fs_verbose
operator|>
literal|1
condition|)
block|{
name|fputs
argument_list|(
name|errstr
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|html_display
argument_list|(
name|remote
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|errstr
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|remote
argument_list|)
expr_stmt|;
name|unsetup_sigalrm
argument_list|()
expr_stmt|;
return|return
name|EX_UNAVAILABLE
return|;
block|}
if|if
condition|(
name|redirection
operator|&&
name|new_location
condition|)
block|{
name|fclose
argument_list|(
name|remote
argument_list|)
expr_stmt|;
if|if
condition|(
name|base64ofmd5
condition|)
name|free
argument_list|(
name|base64ofmd5
argument_list|)
expr_stmt|;
name|fs
operator|->
name|fs_status
operator|=
literal|"processing redirection"
expr_stmt|;
name|status
operator|=
name|http_redirect
argument_list|(
name|fs
argument_list|,
name|new_location
argument_list|,
name|redirection
operator|==
literal|301
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|new_location
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
elseif|else
if|if
condition|(
name|redirection
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: redirection but no new location"
argument_list|,
name|fs
operator|->
name|fs_outputfile
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|remote
argument_list|)
expr_stmt|;
if|if
condition|(
name|base64ofmd5
condition|)
name|free
argument_list|(
name|base64ofmd5
argument_list|)
expr_stmt|;
return|return
name|EX_PROTOCOL
return|;
block|}
name|fs
operator|->
name|fs_status
operator|=
literal|"retrieving file from HTTP/1.x server"
expr_stmt|;
comment|/* 	 * OK, if we got here, then we have finished parsing the header 	 * and have read the `\r\n' line which denotes the end of same. 	 * We may or may not have a good idea of the length of the file 	 * or its modtime.  At this point we will have to deal with 	 * any special byte-range, content-negotiation, redirection, 	 * or authentication, and probably jump back up to the top, 	 * once we implement those features.  So, all we have left to 	 * do is open up the output file and copy data from input to 	 * output until EOF. 	 */
if|if
condition|(
name|to_stdout
condition|)
name|local
operator|=
name|fopen
argument_list|(
literal|"/dev/stdout"
argument_list|,
name|restarting
condition|?
literal|"a"
else|:
literal|"w"
argument_list|)
expr_stmt|;
else|else
name|local
operator|=
name|fopen
argument_list|(
name|fs
operator|->
name|fs_outputfile
argument_list|,
name|restarting
condition|?
literal|"a"
else|:
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|local
operator|==
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"%s: fopen"
argument_list|,
name|fs
operator|->
name|fs_outputfile
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|remote
argument_list|)
expr_stmt|;
name|unsetup_sigalrm
argument_list|()
expr_stmt|;
return|return
name|EX_OSERR
return|;
block|}
name|fs
operator|->
name|fs_modtime
operator|=
name|last_modified
expr_stmt|;
name|fseek
argument_list|(
name|local
argument_list|,
name|restart_from
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
comment|/* XXX truncation off_t->long */
name|display
argument_list|(
name|fs
argument_list|,
name|total_length
argument_list|,
name|restart_from
argument_list|)
expr_stmt|;
comment|/* XXX truncation */
if|if
condition|(
name|chunked
condition|)
name|status
operator|=
name|http_suck_chunked
argument_list|(
name|fs
argument_list|,
name|remote
argument_list|,
name|local
argument_list|,
name|total_length
argument_list|,
name|timo
argument_list|)
expr_stmt|;
else|else
name|status
operator|=
name|http_suck
argument_list|(
name|fs
argument_list|,
name|remote
argument_list|,
name|local
argument_list|,
name|total_length
argument_list|,
name|timo
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
goto|goto
name|out
goto|;
name|status
operator|=
name|errno
expr_stmt|;
comment|/* save errno for warn(), below, if needed */
name|display
argument_list|(
name|fs
argument_list|,
name|total_length
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* do here in case we have to warn */
name|errno
operator|=
name|status
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|remote
argument_list|)
condition|)
block|{
name|warn
argument_list|(
literal|"reading remote file from %s"
argument_list|,
name|https
operator|->
name|http_hostname
argument_list|)
expr_stmt|;
name|status
operator|=
name|EX_OSERR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ferror
argument_list|(
name|local
argument_list|)
condition|)
block|{
name|warn
argument_list|(
literal|"`%s': fwrite"
argument_list|,
name|fs
operator|->
name|fs_outputfile
argument_list|)
expr_stmt|;
name|status
operator|=
name|EX_OSERR
expr_stmt|;
block|}
else|else
block|{
name|status
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|base64ofmd5
condition|)
block|{
comment|/* 		 * Ack.  When restarting, the MD5 only covers the parts 		 * we are getting, not the whole thing. 		 */
name|fseek
argument_list|(
name|local
argument_list|,
name|restart_from
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|fs
operator|->
name|fs_status
operator|=
literal|"computing MD5 message digest"
expr_stmt|;
name|status
operator|=
name|check_md5
argument_list|(
name|local
argument_list|,
name|base64ofmd5
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|base64ofmd5
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|local
argument_list|)
expr_stmt|;
name|out
label|:
name|unsetup_sigalrm
argument_list|()
expr_stmt|;
name|fclose
argument_list|(
name|remote
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
name|rm
argument_list|(
name|fs
argument_list|)
expr_stmt|;
else|else
name|adjmodtime
argument_list|(
name|fs
argument_list|)
expr_stmt|;
return|return
name|status
return|;
undef|#
directive|undef
name|addstr
name|cantauth
label|:
name|warnx
argument_list|(
literal|"%s: cannot authenticate with %s %s"
argument_list|,
name|fs
operator|->
name|fs_outputfile
argument_list|,
operator|(
name|autherror
operator|==
literal|401
operator|)
condition|?
literal|"server"
else|:
literal|"proxy"
argument_list|,
name|https
operator|->
name|http_hostname
argument_list|)
expr_stmt|;
name|status
operator|=
name|EX_NOPERM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
end_function

begin_comment
comment|/*  * Suck over an HTTP body in standard form.  */
end_comment

begin_function
specifier|static
name|int
name|http_suck
parameter_list|(
name|struct
name|fetch_state
modifier|*
name|fs
parameter_list|,
name|FILE
modifier|*
name|remote
parameter_list|,
name|FILE
modifier|*
name|local
parameter_list|,
name|off_t
name|total_length
parameter_list|,
name|int
name|timo
parameter_list|)
block|{
specifier|static
name|char
name|buf
index|[
name|BUFFER_SIZE
index|]
decl_stmt|;
name|ssize_t
name|readresult
decl_stmt|,
name|writeresult
decl_stmt|;
do|do
block|{
name|alarm
argument_list|(
name|timo
argument_list|)
expr_stmt|;
name|readresult
operator|=
name|fread
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|remote
argument_list|)
expr_stmt|;
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|readresult
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|display
argument_list|(
name|fs
argument_list|,
name|total_length
argument_list|,
name|readresult
argument_list|)
expr_stmt|;
name|writeresult
operator|=
name|fwrite
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
name|readresult
argument_list|,
name|local
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|writeresult
operator|==
name|readresult
condition|)
do|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Suck over an HTTP body in chunked form.  Ick.  * Note that the return value convention here is a bit strange.  * A zero return does not necessarily mean success; rather, it means  * that this routine has already taken care of error reporting and  * just wants to exit.  */
end_comment

begin_function
specifier|static
name|int
name|http_suck_chunked
parameter_list|(
name|struct
name|fetch_state
modifier|*
name|fs
parameter_list|,
name|FILE
modifier|*
name|remote
parameter_list|,
name|FILE
modifier|*
name|local
parameter_list|,
name|off_t
name|total_length
parameter_list|,
name|int
name|timo
parameter_list|)
block|{
specifier|static
name|char
name|buf
index|[
name|BUFFER_SIZE
index|]
decl_stmt|;
name|ssize_t
name|readresult
decl_stmt|,
name|writeresult
decl_stmt|;
name|size_t
name|linelen
decl_stmt|;
name|u_long
name|chunklen
decl_stmt|;
name|char
modifier|*
name|line
decl_stmt|,
modifier|*
name|ep
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|alarm
argument_list|(
name|timo
argument_list|)
expr_stmt|;
name|line
operator|=
name|fgetln
argument_list|(
name|remote
argument_list|,
operator|&
name|linelen
argument_list|)
expr_stmt|;
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|==
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: error processing chunked encoding: "
literal|"missing length"
argument_list|,
name|fs
operator|->
name|fs_outputfile
argument_list|)
expr_stmt|;
return|return
name|EX_PROTOCOL
return|;
block|}
name|line
index|[
operator|--
name|linelen
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
init|;
name|linelen
operator|>
literal|0
condition|;
name|linelen
operator|--
control|)
block|{
if|if
condition|(
name|isspace
argument_list|(
name|line
index|[
name|linelen
operator|-
literal|1
index|]
argument_list|)
condition|)
name|line
index|[
name|linelen
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|errno
operator|=
literal|0
expr_stmt|;
name|chunklen
operator|=
name|strtoul
argument_list|(
name|line
argument_list|,
operator|&
name|ep
argument_list|,
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|||
operator|*
name|line
operator|==
literal|0
operator|||
operator|(
operator|*
name|ep
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|ep
argument_list|)
operator|&&
operator|*
name|ep
operator|!=
literal|';'
operator|)
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: error processing chunked encoding: "
literal|"uninterpretable length: %s"
argument_list|,
name|line
argument_list|)
expr_stmt|;
return|return
name|EX_PROTOCOL
return|;
block|}
if|if
condition|(
name|chunklen
operator|==
literal|0
condition|)
break|break;
ifndef|#
directive|ifndef
name|MIN
define|#
directive|define
name|MIN
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)>(b)?(b):(a))
endif|#
directive|endif
while|while
condition|(
name|chunklen
operator|>
literal|0
condition|)
block|{
name|alarm
argument_list|(
name|timo
argument_list|)
expr_stmt|;
name|readresult
operator|=
name|fread
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
name|MIN
argument_list|(
sizeof|sizeof
name|buf
argument_list|,
name|chunklen
argument_list|)
argument_list|,
name|remote
argument_list|)
expr_stmt|;
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|readresult
operator|==
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: EOF with %lu left in chunk"
argument_list|,
name|fs
operator|->
name|fs_outputfile
argument_list|,
name|chunklen
argument_list|)
expr_stmt|;
return|return
name|EX_PROTOCOL
return|;
block|}
name|display
argument_list|(
name|fs
argument_list|,
name|total_length
argument_list|,
name|readresult
argument_list|)
expr_stmt|;
name|chunklen
operator|-=
name|readresult
expr_stmt|;
name|writeresult
operator|=
name|fwrite
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
name|readresult
argument_list|,
name|local
argument_list|)
expr_stmt|;
if|if
condition|(
name|writeresult
operator|!=
name|readresult
condition|)
return|return
literal|0
return|;
comment|/* main code will diagnose */
block|}
comment|/* 		 * Read the bogus CRLF after the chunk's body. 		 */
name|alarm
argument_list|(
name|timo
argument_list|)
expr_stmt|;
name|fread
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
name|remote
argument_list|)
expr_stmt|;
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If we got here, then we successfully read every chunk and got 	 * the end-of-chunks indicator.  Now we have to ignore any trailer 	 * lines which come across---or we would if we cared about keeping 	 * the connection open.  Since we are just going to close it anyway, 	 * we won't bother with that here.  If ever something important is 	 * defined for the trailer, we will have to revisit that decision. 	 */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * The format of the response line for an HTTP request is:  *	HTTP/V.vv{WS}999{WS}Explanatory text for humans to read\r\n  * Old pre-HTTP/1.0 servers can return  *	HTTP{WS}999{WS}Explanatory text for humans to read\r\n  * Where {WS} represents whitespace (spaces and/or tabs) and 999  * is a machine-interprable result code.  We return the integer value  * of that result code, or the impossible value `0' if we are unable to  * parse the result.  */
end_comment

begin_function
specifier|static
name|int
name|http_first_line
parameter_list|(
specifier|const
name|char
modifier|*
name|line
parameter_list|)
block|{
name|char
modifier|*
name|ep
decl_stmt|;
name|unsigned
name|long
name|ul
decl_stmt|;
if|if
condition|(
name|strncasecmp
argument_list|(
name|line
argument_list|,
literal|"http"
argument_list|,
literal|4
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
name|line
operator|+=
literal|4
expr_stmt|;
while|while
condition|(
operator|*
name|line
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|line
argument_list|)
condition|)
comment|/* skip non-whitespace */
name|line
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|line
operator|&&
name|isspace
argument_list|(
operator|*
name|line
argument_list|)
condition|)
comment|/* skip first whitespace */
name|line
operator|++
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|ul
operator|=
name|strtoul
argument_list|(
name|line
argument_list|,
operator|&
name|ep
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
literal|0
operator|||
name|ul
operator|>
literal|999
operator|||
name|ul
operator|<
literal|100
operator|||
operator|!
name|isspace
argument_list|(
operator|*
name|ep
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|ul
return|;
block|}
end_function

begin_comment
comment|/*  * The format of a header line for an HTTP request is:  *	Header-Name: header-value (with comments in parens)\r\n  * This would be a nice application for gperf(1), except that the  * names are case-insensitive and gperf can't handle that.  */
end_comment

begin_function
specifier|static
name|enum
name|http_header
name|http_parse_header
parameter_list|(
name|char
modifier|*
name|line
parameter_list|,
name|char
modifier|*
modifier|*
name|valuep
parameter_list|)
block|{
name|char
modifier|*
name|colon
decl_stmt|,
modifier|*
name|value
decl_stmt|;
if|if
condition|(
operator|*
name|line
operator|==
literal|'\0'
comment|/* protocol error! */
operator|||
operator|(
name|line
index|[
literal|0
index|]
operator|==
literal|'\r'
operator|&&
name|line
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|)
condition|)
return|return
name|ht_end_of_header
return|;
name|colon
operator|=
name|strchr
argument_list|(
name|line
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|colon
operator|==
literal|0
condition|)
return|return
name|ht_syntax_error
return|;
operator|*
name|colon
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|value
operator|=
name|colon
operator|+
literal|1
init|;
operator|*
name|value
operator|&&
name|isspace
argument_list|(
operator|*
name|value
argument_list|)
condition|;
name|value
operator|++
control|)
empty_stmt|;
comment|/* do nothing */
comment|/* Trim trailing whitespace (including \r). */
operator|*
name|valuep
operator|=
name|value
expr_stmt|;
name|value
operator|+=
name|strlen
argument_list|(
name|value
argument_list|)
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|value
operator|>
operator|*
name|valuep
operator|&&
name|isspace
argument_list|(
operator|*
name|value
argument_list|)
condition|)
name|value
operator|--
expr_stmt|;
operator|*
operator|++
name|value
operator|=
literal|'\0'
expr_stmt|;
define|#
directive|define
name|cmp
parameter_list|(
name|name
parameter_list|,
name|num
parameter_list|)
value|do { if (!strcasecmp(line, name)) return num; } while(0)
name|cmp
argument_list|(
literal|"Accept-Ranges"
argument_list|,
name|ht_accept_ranges
argument_list|)
expr_stmt|;
name|cmp
argument_list|(
literal|"Age"
argument_list|,
name|ht_age
argument_list|)
expr_stmt|;
name|cmp
argument_list|(
literal|"Allow"
argument_list|,
name|ht_allow
argument_list|)
expr_stmt|;
name|cmp
argument_list|(
literal|"Cache-Control"
argument_list|,
name|ht_cache_control
argument_list|)
expr_stmt|;
name|cmp
argument_list|(
literal|"Connection"
argument_list|,
name|ht_connection
argument_list|)
expr_stmt|;
name|cmp
argument_list|(
literal|"Content-Base"
argument_list|,
name|ht_content_base
argument_list|)
expr_stmt|;
name|cmp
argument_list|(
literal|"Content-Encoding"
argument_list|,
name|ht_content_encoding
argument_list|)
expr_stmt|;
name|cmp
argument_list|(
literal|"Content-Language"
argument_list|,
name|ht_content_language
argument_list|)
expr_stmt|;
name|cmp
argument_list|(
literal|"Content-Length"
argument_list|,
name|ht_content_length
argument_list|)
expr_stmt|;
name|cmp
argument_list|(
literal|"Content-Location"
argument_list|,
name|ht_content_location
argument_list|)
expr_stmt|;
name|cmp
argument_list|(
literal|"Content-MD5"
argument_list|,
name|ht_content_md5
argument_list|)
expr_stmt|;
name|cmp
argument_list|(
literal|"Content-Range"
argument_list|,
name|ht_content_range
argument_list|)
expr_stmt|;
name|cmp
argument_list|(
literal|"Content-Type"
argument_list|,
name|ht_content_type
argument_list|)
expr_stmt|;
name|cmp
argument_list|(
literal|"Date"
argument_list|,
name|ht_date
argument_list|)
expr_stmt|;
name|cmp
argument_list|(
literal|"ETag"
argument_list|,
name|ht_etag
argument_list|)
expr_stmt|;
name|cmp
argument_list|(
literal|"Expires"
argument_list|,
name|ht_expires
argument_list|)
expr_stmt|;
name|cmp
argument_list|(
literal|"Last-Modified"
argument_list|,
name|ht_last_modified
argument_list|)
expr_stmt|;
name|cmp
argument_list|(
literal|"Location"
argument_list|,
name|ht_location
argument_list|)
expr_stmt|;
name|cmp
argument_list|(
literal|"Pragma"
argument_list|,
name|ht_pragma
argument_list|)
expr_stmt|;
name|cmp
argument_list|(
literal|"Proxy-Authenticate"
argument_list|,
name|ht_proxy_authenticate
argument_list|)
expr_stmt|;
name|cmp
argument_list|(
literal|"Public"
argument_list|,
name|ht_public
argument_list|)
expr_stmt|;
name|cmp
argument_list|(
literal|"Retry-After"
argument_list|,
name|ht_retry_after
argument_list|)
expr_stmt|;
name|cmp
argument_list|(
literal|"Server"
argument_list|,
name|ht_server
argument_list|)
expr_stmt|;
name|cmp
argument_list|(
literal|"Transfer-Encoding"
argument_list|,
name|ht_transfer_encoding
argument_list|)
expr_stmt|;
name|cmp
argument_list|(
literal|"Upgrade"
argument_list|,
name|ht_upgrade
argument_list|)
expr_stmt|;
name|cmp
argument_list|(
literal|"Vary"
argument_list|,
name|ht_vary
argument_list|)
expr_stmt|;
name|cmp
argument_list|(
literal|"Via"
argument_list|,
name|ht_via
argument_list|)
expr_stmt|;
name|cmp
argument_list|(
literal|"WWW-Authenticate"
argument_list|,
name|ht_www_authenticate
argument_list|)
expr_stmt|;
name|cmp
argument_list|(
literal|"Warning"
argument_list|,
name|ht_warning
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|cmp
return|return
name|ht_unknown
return|;
block|}
end_function

begin_comment
comment|/*  * Compute the RSA Data Security, Inc., MD5 Message Digest of the file  * given in `fp', see if it matches the one given in base64 encoding by  * `base64ofmd5'.  Warn and return an error if it doesn't.  */
end_comment

begin_function
specifier|static
name|int
name|check_md5
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|char
modifier|*
name|base64ofmd5
parameter_list|)
block|{
name|MD5_CTX
name|ctx
decl_stmt|;
name|unsigned
name|char
name|digest
index|[
literal|16
index|]
decl_stmt|;
name|char
name|buf
index|[
literal|512
index|]
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|char
modifier|*
name|ourval
decl_stmt|;
name|MD5Init
argument_list|(
operator|&
name|ctx
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|len
operator|=
name|fread
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|fp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|MD5Update
argument_list|(
operator|&
name|ctx
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
name|MD5Final
argument_list|(
name|digest
argument_list|,
operator|&
name|ctx
argument_list|)
expr_stmt|;
name|ourval
operator|=
name|to_base64
argument_list|(
name|digest
argument_list|,
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|ourval
argument_list|,
name|base64ofmd5
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"MD5 digest mismatch: %s, should be %s"
argument_list|,
name|ourval
argument_list|,
name|base64ofmd5
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ourval
argument_list|)
expr_stmt|;
return|return
name|EX_DATAERR
return|;
block|}
name|free
argument_list|(
name|ourval
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|wkdays
index|[]
init|=
block|{
literal|"Sun"
block|,
literal|"Mon"
block|,
literal|"Tue"
block|,
literal|"Wed"
block|,
literal|"Thu"
block|,
literal|"Fri"
block|,
literal|"Sat"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|months
index|[]
init|=
block|{
literal|"Jan"
block|,
literal|"Feb"
block|,
literal|"Mar"
block|,
literal|"Apr"
block|,
literal|"May"
block|,
literal|"Jun"
block|,
literal|"Jul"
block|,
literal|"Aug"
block|,
literal|"Sep"
block|,
literal|"Oct"
block|,
literal|"Nov"
block|,
literal|"Dec"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Interpret one of the three possible formats for an HTTP date.  * All of them are really bogus; HTTP should use either ISO 8601  * or NTP timestamps.  We make some attempt to accept a subset of 8601  * format.  The three standard formats are all fixed-length subsets of their  * respective standards (except 8601, which puts all of the stuff we  * care about up front).  */
end_comment

begin_function
specifier|static
name|time_t
name|parse_http_date
parameter_list|(
name|char
modifier|*
name|string
parameter_list|)
block|{
specifier|static
name|struct
name|tm
name|tm
decl_stmt|;
comment|/* get good initialization */
name|time_t
name|rv
decl_stmt|;
specifier|const
name|char
modifier|*
name|tz
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 8601 has the shortest minimum length */
if|if
condition|(
name|strlen
argument_list|(
name|string
argument_list|)
operator|<
literal|15
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|string
argument_list|)
condition|)
block|{
comment|/* ISO 8601: 19970127T134551stuffwedon'tcareabout */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|15
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|!=
literal|8
operator|&&
operator|!
name|isdigit
argument_list|(
name|string
index|[
name|i
index|]
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|<
literal|15
condition|)
return|return
operator|-
literal|1
return|;
define|#
directive|define
name|digit
parameter_list|(
name|x
parameter_list|)
value|(string[x] - '0')
name|tm
operator|.
name|tm_year
operator|=
operator|(
name|digit
argument_list|(
literal|0
argument_list|)
operator|*
literal|1000
operator|+
name|digit
argument_list|(
literal|1
argument_list|)
operator|*
literal|100
operator|+
name|digit
argument_list|(
literal|2
argument_list|)
operator|*
literal|10
operator|+
name|digit
argument_list|(
literal|3
argument_list|)
operator|)
operator|-
literal|1900
expr_stmt|;
name|tm
operator|.
name|tm_mon
operator|=
name|digit
argument_list|(
literal|4
argument_list|)
operator|*
literal|10
operator|+
name|digit
argument_list|(
literal|5
argument_list|)
operator|-
literal|1
expr_stmt|;
name|tm
operator|.
name|tm_mday
operator|=
name|digit
argument_list|(
literal|6
argument_list|)
operator|*
literal|10
operator|+
name|digit
argument_list|(
literal|7
argument_list|)
expr_stmt|;
if|if
condition|(
name|string
index|[
literal|8
index|]
operator|!=
literal|'T'
operator|&&
name|string
index|[
literal|8
index|]
operator|!=
literal|'t'
operator|&&
name|string
index|[
literal|8
index|]
operator|!=
literal|' '
condition|)
return|return
operator|-
literal|1
return|;
name|tm
operator|.
name|tm_hour
operator|=
name|digit
argument_list|(
literal|9
argument_list|)
operator|*
literal|10
operator|+
name|digit
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|tm
operator|.
name|tm_min
operator|=
name|digit
argument_list|(
literal|11
argument_list|)
operator|*
literal|10
operator|+
name|digit
argument_list|(
literal|12
argument_list|)
expr_stmt|;
name|tm
operator|.
name|tm_sec
operator|=
name|digit
argument_list|(
literal|13
argument_list|)
operator|*
literal|10
operator|+
name|digit
argument_list|(
literal|14
argument_list|)
expr_stmt|;
comment|/* We don't care about the rest of the stuff after the secs. */
block|}
elseif|else
if|if
condition|(
name|string
index|[
literal|3
index|]
operator|==
literal|','
condition|)
block|{
comment|/* Mon, 27 Jan 1997 14:24:35 stuffwedon'tcareabout */
if|if
condition|(
name|strlen
argument_list|(
name|string
argument_list|)
operator|<
literal|25
condition|)
return|return
operator|-
literal|1
return|;
name|string
operator|+=
literal|5
expr_stmt|;
comment|/* skip over day-of-week */
if|if
condition|(
operator|!
operator|(
name|isdigit
argument_list|(
name|string
index|[
literal|0
index|]
argument_list|)
operator|&&
name|isdigit
argument_list|(
name|string
index|[
literal|1
index|]
argument_list|)
operator|)
condition|)
return|return
operator|-
literal|1
return|;
name|tm
operator|.
name|tm_mday
operator|=
name|digit
argument_list|(
literal|0
argument_list|)
operator|*
literal|10
operator|+
name|digit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|12
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strncasecmp
argument_list|(
name|months
index|[
name|i
index|]
argument_list|,
operator|&
name|string
index|[
literal|3
index|]
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|>=
literal|12
condition|)
return|return
operator|-
literal|1
return|;
name|tm
operator|.
name|tm_mon
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|sscanf
argument_list|(
operator|&
name|string
index|[
literal|7
index|]
argument_list|,
literal|"%d %d:%d:%d"
argument_list|,
operator|&
name|i
argument_list|,
operator|&
name|tm
operator|.
name|tm_hour
argument_list|,
operator|&
name|tm
operator|.
name|tm_min
argument_list|,
operator|&
name|tm
operator|.
name|tm_sec
argument_list|)
operator|!=
literal|4
condition|)
return|return
operator|-
literal|1
return|;
name|tm
operator|.
name|tm_year
operator|=
name|i
operator|-
literal|1900
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|string
index|[
literal|3
index|]
operator|==
literal|' '
condition|)
block|{
comment|/* Mon Jan 27 14:25:20 1997 */
if|if
condition|(
name|strlen
argument_list|(
name|string
argument_list|)
operator|<
literal|24
condition|)
return|return
operator|-
literal|1
return|;
name|string
operator|+=
literal|4
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|12
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strncasecmp
argument_list|(
name|string
argument_list|,
name|months
index|[
name|i
index|]
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|>=
literal|12
condition|)
return|return
operator|-
literal|1
return|;
name|tm
operator|.
name|tm_mon
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|sscanf
argument_list|(
operator|&
name|string
index|[
literal|4
index|]
argument_list|,
literal|"%d %d:%d:%d %u"
argument_list|,
operator|&
name|tm
operator|.
name|tm_mday
argument_list|,
operator|&
name|tm
operator|.
name|tm_hour
argument_list|,
operator|&
name|tm
operator|.
name|tm_min
argument_list|,
operator|&
name|tm
operator|.
name|tm_sec
argument_list|,
operator|&
name|i
argument_list|)
operator|!=
literal|5
condition|)
return|return
operator|-
literal|1
return|;
name|tm
operator|.
name|tm_year
operator|=
name|i
operator|-
literal|1900
expr_stmt|;
block|}
else|else
block|{
comment|/* Monday, 27-Jan-97 14:31:09 stuffwedon'tcareabout */
name|char
modifier|*
name|comma
init|=
name|strchr
argument_list|(
name|string
argument_list|,
literal|','
argument_list|)
decl_stmt|;
name|char
name|mname
index|[
literal|4
index|]
decl_stmt|;
if|if
condition|(
name|comma
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|string
operator|=
name|comma
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|string
argument_list|)
operator|<
literal|19
condition|)
return|return
operator|-
literal|1
return|;
name|string
operator|++
expr_stmt|;
name|mname
index|[
literal|4
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|sscanf
argument_list|(
name|string
argument_list|,
literal|"%d-%c%c%c-%d %d:%d:%d"
argument_list|,
operator|&
name|tm
operator|.
name|tm_mday
argument_list|,
name|mname
argument_list|,
name|mname
operator|+
literal|1
argument_list|,
name|mname
operator|+
literal|2
argument_list|,
operator|&
name|tm
operator|.
name|tm_year
argument_list|,
operator|&
name|tm
operator|.
name|tm_hour
argument_list|,
operator|&
name|tm
operator|.
name|tm_min
argument_list|,
operator|&
name|tm
operator|.
name|tm_sec
argument_list|)
operator|!=
literal|8
condition|)
return|return
operator|-
literal|1
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|12
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcasecmp
argument_list|(
name|months
index|[
name|i
index|]
argument_list|,
name|mname
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|>=
literal|12
condition|)
return|return
operator|-
literal|1
return|;
name|tm
operator|.
name|tm_mon
operator|=
name|i
expr_stmt|;
block|}
undef|#
directive|undef
name|digit
if|if
condition|(
name|tm
operator|.
name|tm_sec
operator|>
literal|60
operator|||
name|tm
operator|.
name|tm_min
operator|>
literal|59
operator|||
name|tm
operator|.
name|tm_hour
operator|>
literal|23
operator|||
name|tm
operator|.
name|tm_mday
operator|>
literal|31
operator|||
name|tm
operator|.
name|tm_mon
operator|>
literal|11
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|tm
operator|.
name|tm_sec
operator|<
literal|0
operator|||
name|tm
operator|.
name|tm_min
operator|<
literal|0
operator|||
name|tm
operator|.
name|tm_hour
operator|<
literal|0
operator|||
name|tm
operator|.
name|tm_mday
operator|<
literal|0
operator|||
name|tm
operator|.
name|tm_mon
operator|<
literal|0
operator|||
name|tm
operator|.
name|tm_year
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|tz
operator|=
name|getenv
argument_list|(
literal|"TZ"
argument_list|)
expr_stmt|;
name|setenv
argument_list|(
literal|"TZ"
argument_list|,
literal|"UTC0"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tzset
argument_list|()
expr_stmt|;
name|rv
operator|=
name|mktime
argument_list|(
operator|&
name|tm
argument_list|)
expr_stmt|;
if|if
condition|(
name|tz
condition|)
name|setenv
argument_list|(
literal|"TZ"
argument_list|,
name|tz
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|unsetenv
argument_list|(
literal|"TZ"
argument_list|)
expr_stmt|;
return|return
name|rv
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|format_http_date
parameter_list|(
name|time_t
name|when
parameter_list|)
block|{
name|struct
name|tm
modifier|*
name|tm
decl_stmt|;
specifier|static
name|char
name|buf
index|[
literal|30
index|]
decl_stmt|;
name|tm
operator|=
name|gmtime
argument_list|(
operator|&
name|when
argument_list|)
expr_stmt|;
if|if
condition|(
name|tm
operator|==
literal|0
condition|)
return|return
literal|0
return|;
ifndef|#
directive|ifndef
name|HTTP_DATE_ISO_8601
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s, %02d %s %04d %02d:%02d:%02d GMT"
argument_list|,
name|wkdays
index|[
name|tm
operator|->
name|tm_wday
index|]
argument_list|,
name|tm
operator|->
name|tm_mday
argument_list|,
name|months
index|[
name|tm
operator|->
name|tm_mon
index|]
argument_list|,
name|tm
operator|->
name|tm_year
operator|+
literal|1900
argument_list|,
name|tm
operator|->
name|tm_hour
argument_list|,
name|tm
operator|->
name|tm_min
argument_list|,
name|tm
operator|->
name|tm_sec
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* ISO 8601 */
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%04d%02d%02dT%02d%02d%02d+0000"
argument_list|,
name|tm
operator|->
name|tm_year
operator|+
literal|1900
argument_list|,
name|tm
operator|->
name|tm_mon
operator|+
literal|1
argument_list|,
name|tm
operator|->
name|tm_mday
argument_list|,
name|tm
operator|->
name|tm_hour
argument_list|,
name|tm
operator|->
name|tm_min
argument_list|,
name|tm
operator|->
name|tm_sec
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|buf
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|format_http_user_agent
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|;
specifier|static
name|int
name|inited
decl_stmt|;
if|if
condition|(
operator|!
name|inited
condition|)
block|{
name|int
name|mib
index|[
literal|2
index|]
decl_stmt|;
name|char
name|ostype
index|[
literal|128
index|]
decl_stmt|,
name|osrelease
index|[
literal|128
index|]
decl_stmt|,
name|machine
index|[
literal|128
index|]
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|mib
index|[
literal|0
index|]
operator|=
name|CTL_KERN
expr_stmt|;
name|mib
index|[
literal|1
index|]
operator|=
name|KERN_OSTYPE
expr_stmt|;
name|len
operator|=
sizeof|sizeof
name|ostype
expr_stmt|;
if|if
condition|(
name|sysctl
argument_list|(
name|mib
argument_list|,
literal|2
argument_list|,
name|ostype
argument_list|,
operator|&
name|len
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"sysctl"
argument_list|)
expr_stmt|;
name|ostype
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|mib
index|[
literal|1
index|]
operator|=
name|KERN_OSRELEASE
expr_stmt|;
name|len
operator|=
sizeof|sizeof
name|osrelease
expr_stmt|;
if|if
condition|(
name|sysctl
argument_list|(
name|mib
argument_list|,
literal|2
argument_list|,
name|osrelease
argument_list|,
operator|&
name|len
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"sysctl"
argument_list|)
expr_stmt|;
name|osrelease
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|mib
index|[
literal|0
index|]
operator|=
name|CTL_HW
expr_stmt|;
name|mib
index|[
literal|1
index|]
operator|=
name|HW_MACHINE
expr_stmt|;
name|len
operator|=
sizeof|sizeof
name|machine
expr_stmt|;
if|if
condition|(
name|sysctl
argument_list|(
name|mib
argument_list|,
literal|2
argument_list|,
name|machine
argument_list|,
operator|&
name|len
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"sysctl"
argument_list|)
expr_stmt|;
name|machine
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
literal|"User-Agent: "
name|FETCH_VERSION
literal|" %s/%s (%s)\r\n"
argument_list|,
name|ostype
argument_list|,
name|osrelease
argument_list|,
name|machine
argument_list|)
expr_stmt|;
block|}
return|return
name|buf
return|;
block|}
end_function

begin_comment
comment|/*  * Parse a Content-Range return header from the server.  RFC 2066 defines  * this header to have the format:  *	Content-Range: bytes 12345-67890/123456  * Since we always ask for the whole rest of the file, we consider it an  * error if the reply doesn't claim to give it to us.  */
end_comment

begin_function
specifier|static
name|int
name|parse_http_content_range
parameter_list|(
name|char
modifier|*
name|orig
parameter_list|,
name|off_t
modifier|*
name|restart_from
parameter_list|,
name|off_t
modifier|*
name|total_length
parameter_list|)
block|{
name|u_quad_t
name|first
decl_stmt|,
name|last
decl_stmt|,
name|total
decl_stmt|;
name|char
modifier|*
name|ep
decl_stmt|;
if|if
condition|(
name|strncasecmp
argument_list|(
name|orig
argument_list|,
literal|"bytes"
argument_list|,
literal|5
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"unknown Content-Range unit: `%s'"
argument_list|,
name|orig
argument_list|)
expr_stmt|;
return|return
name|EX_PROTOCOL
return|;
block|}
name|orig
operator|+=
literal|5
expr_stmt|;
while|while
condition|(
operator|*
name|orig
operator|&&
name|isspace
argument_list|(
operator|*
name|orig
argument_list|)
condition|)
name|orig
operator|++
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|first
operator|=
name|strtouq
argument_list|(
name|orig
argument_list|,
operator|&
name|ep
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
literal|0
operator|||
operator|*
name|ep
operator|!=
literal|'-'
condition|)
block|{
name|warnx
argument_list|(
literal|"invalid Content-Range: `%s'"
argument_list|,
name|orig
argument_list|)
expr_stmt|;
return|return
name|EX_PROTOCOL
return|;
block|}
name|last
operator|=
name|strtouq
argument_list|(
name|ep
operator|+
literal|1
argument_list|,
operator|&
name|ep
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
literal|0
operator|||
operator|*
name|ep
operator|!=
literal|'/'
operator|||
name|last
operator|<
name|first
condition|)
block|{
name|warnx
argument_list|(
literal|"invalid Content-Range: `%s'"
argument_list|,
name|orig
argument_list|)
expr_stmt|;
return|return
name|EX_PROTOCOL
return|;
block|}
name|total
operator|=
name|strtouq
argument_list|(
name|ep
operator|+
literal|1
argument_list|,
operator|&
name|ep
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
literal|0
operator|||
operator|!
operator|(
operator|*
name|ep
operator|==
literal|'\0'
operator|||
name|isspace
argument_list|(
operator|*
name|ep
argument_list|)
operator|)
condition|)
block|{
name|warnx
argument_list|(
literal|"invalid Content-Range: `%s'"
argument_list|,
name|orig
argument_list|)
expr_stmt|;
return|return
name|EX_PROTOCOL
return|;
block|}
if|if
condition|(
name|last
operator|+
literal|1
operator|!=
name|total
condition|)
block|{
name|warnx
argument_list|(
literal|"HTTP server did not return requested Content-Range"
argument_list|)
expr_stmt|;
return|return
name|EX_PROTOCOL
return|;
block|}
operator|*
name|restart_from
operator|=
name|first
expr_stmt|;
operator|*
name|total_length
operator|=
name|last
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Do HTTP authentication.  We only do ``basic'' right now, but  * MD5 ought to be fairly easy.  The hard part is actually teasing  * apart the header, which is fairly badly designed (so what else is  * new?).  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|getauthparam
parameter_list|(
name|char
modifier|*
name|params
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|char
modifier|*
name|rv
decl_stmt|;
enum|enum
name|state
block|{
name|normal
block|,
name|quoted
block|}
name|state
enum|;
while|while
condition|(
operator|*
name|params
condition|)
block|{
if|if
condition|(
name|strncasecmp
argument_list|(
name|params
argument_list|,
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|)
operator|==
literal|0
operator|&&
name|params
index|[
name|strlen
argument_list|(
name|name
argument_list|)
index|]
operator|==
literal|'='
condition|)
break|break;
name|state
operator|=
name|normal
expr_stmt|;
while|while
condition|(
operator|*
name|params
condition|)
block|{
if|if
condition|(
name|state
operator|==
name|normal
operator|&&
operator|*
name|params
operator|==
literal|','
condition|)
break|break;
if|if
condition|(
operator|*
name|params
operator|==
literal|'\"'
condition|)
name|state
operator|=
operator|(
name|state
operator|==
name|quoted
operator|)
condition|?
name|normal
else|:
name|quoted
expr_stmt|;
if|if
condition|(
operator|*
name|params
operator|==
literal|'\\'
operator|&&
name|params
index|[
literal|1
index|]
operator|!=
literal|'\0'
condition|)
name|params
operator|++
expr_stmt|;
name|params
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|*
name|params
operator|==
literal|'\0'
condition|)
return|return
literal|0
return|;
name|params
operator|+=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
expr_stmt|;
name|rv
operator|=
name|params
expr_stmt|;
name|state
operator|=
name|normal
expr_stmt|;
while|while
condition|(
operator|*
name|params
condition|)
block|{
if|if
condition|(
name|state
operator|==
name|normal
operator|&&
operator|*
name|params
operator|==
literal|','
condition|)
break|break;
if|if
condition|(
operator|*
name|params
operator|==
literal|'\"'
condition|)
name|state
operator|=
operator|(
name|state
operator|==
name|quoted
operator|)
condition|?
name|normal
else|:
name|quoted
expr_stmt|;
if|if
condition|(
operator|*
name|params
operator|==
literal|'\\'
operator|&&
name|params
index|[
literal|1
index|]
operator|!=
literal|'\0'
condition|)
name|params
operator|++
expr_stmt|;
name|params
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|params
index|[
operator|-
literal|1
index|]
operator|==
literal|'\"'
condition|)
name|params
index|[
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
else|else
name|params
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|*
name|rv
operator|==
literal|'\"'
condition|)
name|rv
operator|++
expr_stmt|;
return|return
name|rv
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|process_http_auth
parameter_list|(
name|struct
name|fetch_state
modifier|*
name|fs
parameter_list|,
name|char
modifier|*
name|hdr
parameter_list|,
name|int
name|autherr
parameter_list|)
block|{
enum|enum
name|state
block|{
name|normal
block|,
name|quoted
block|}
name|state
enum|;
name|char
modifier|*
name|scheme
decl_stmt|,
modifier|*
name|params
decl_stmt|,
modifier|*
name|nscheme
decl_stmt|,
modifier|*
name|realm
decl_stmt|;
name|struct
name|http_auth
modifier|*
name|ha
decl_stmt|;
do|do
block|{
name|scheme
operator|=
name|params
operator|=
name|hdr
expr_stmt|;
comment|/* Look for end of scheme name. */
while|while
condition|(
operator|*
name|params
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|params
argument_list|)
condition|)
name|params
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|params
operator|==
literal|'\0'
condition|)
return|return
name|EX_PROTOCOL
return|;
comment|/* Null-terminate scheme and skip whitespace. */
while|while
condition|(
operator|*
name|params
operator|&&
name|isspace
argument_list|(
operator|*
name|params
argument_list|)
condition|)
operator|*
name|params
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* Semi-parse parameters to find their end. */
name|nscheme
operator|=
name|params
expr_stmt|;
name|state
operator|=
name|normal
expr_stmt|;
while|while
condition|(
operator|*
name|nscheme
condition|)
block|{
if|if
condition|(
name|state
operator|==
name|normal
operator|&&
name|isspace
argument_list|(
operator|*
name|nscheme
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|*
name|nscheme
operator|==
literal|'\"'
condition|)
name|state
operator|=
operator|(
name|state
operator|==
name|quoted
operator|)
condition|?
name|normal
else|:
name|quoted
expr_stmt|;
if|if
condition|(
operator|*
name|nscheme
operator|==
literal|'\\'
operator|&&
name|nscheme
index|[
literal|1
index|]
operator|!=
literal|'\0'
condition|)
name|nscheme
operator|++
expr_stmt|;
name|nscheme
operator|++
expr_stmt|;
block|}
comment|/* Null-terminate parameters and skip whitespace. */
while|while
condition|(
operator|*
name|nscheme
operator|&&
name|isspace
argument_list|(
operator|*
name|nscheme
argument_list|)
condition|)
operator|*
name|nscheme
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|realm
operator|=
name|getauthparam
argument_list|(
name|params
argument_list|,
literal|"realm"
argument_list|)
expr_stmt|;
if|if
condition|(
name|realm
operator|==
literal|0
condition|)
block|{
name|scheme
operator|=
name|nscheme
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|autherr
operator|==
literal|401
condition|)
name|ha
operator|=
name|find_http_auth
argument_list|(
operator|&
name|http_auth
argument_list|,
name|scheme
argument_list|,
name|realm
argument_list|)
expr_stmt|;
else|else
name|ha
operator|=
name|find_http_auth
argument_list|(
operator|&
name|http_proxy_auth
argument_list|,
name|scheme
argument_list|,
name|realm
argument_list|)
expr_stmt|;
if|if
condition|(
name|ha
condition|)
return|return
name|ha
operator|->
name|ha_ham
operator|->
name|ham_doauth
argument_list|(
name|fs
argument_list|,
name|ha
argument_list|,
name|autherr
operator|==
literal|407
argument_list|)
return|;
block|}
do|while
condition|(
operator|*
name|scheme
condition|)
do|;
return|return
name|EX_NOPERM
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|parse_http_auth_env
parameter_list|(
specifier|const
name|char
modifier|*
name|env
parameter_list|,
name|struct
name|http_auth_head
modifier|*
name|ha_tqh
parameter_list|)
block|{
name|char
modifier|*
name|nenv
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|scheme
decl_stmt|,
modifier|*
name|realm
decl_stmt|,
modifier|*
name|params
decl_stmt|;
name|struct
name|http_auth
modifier|*
name|ha
decl_stmt|;
name|struct
name|http_auth_method
modifier|*
name|ham
decl_stmt|;
name|nenv
operator|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|env
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|nenv
argument_list|,
name|env
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|p
operator|=
name|strsep
argument_list|(
operator|&
name|nenv
argument_list|,
literal|" \t"
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|scheme
operator|=
name|strsep
argument_list|(
operator|&
name|p
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
if|if
condition|(
name|scheme
operator|==
literal|0
operator|||
operator|*
name|scheme
operator|==
literal|'\0'
condition|)
continue|continue;
name|realm
operator|=
name|strsep
argument_list|(
operator|&
name|p
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
if|if
condition|(
name|realm
operator|==
literal|0
operator|||
operator|*
name|realm
operator|==
literal|'\0'
condition|)
continue|continue;
name|params
operator|=
operator|(
name|p
operator|&&
operator|*
name|p
operator|)
condition|?
name|p
else|:
literal|0
expr_stmt|;
for|for
control|(
name|ham
operator|=
name|http_auth_methods
init|;
name|ham
operator|->
name|ham_scheme
condition|;
name|ham
operator|++
control|)
block|{
if|if
condition|(
name|strcasecmp
argument_list|(
name|scheme
argument_list|,
name|ham
operator|->
name|ham_scheme
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|ham
operator|==
literal|0
condition|)
continue|continue;
name|ha
operator|=
name|safe_malloc
argument_list|(
sizeof|sizeof
expr|*
name|ha
argument_list|)
expr_stmt|;
name|ha
operator|->
name|ha_scheme
operator|=
name|safe_strdup
argument_list|(
name|scheme
argument_list|)
expr_stmt|;
name|ha
operator|->
name|ha_realm
operator|=
name|safe_strdup
argument_list|(
name|realm
argument_list|)
expr_stmt|;
name|ha
operator|->
name|ha_params
operator|=
name|params
condition|?
name|safe_strdup
argument_list|(
name|params
argument_list|)
else|:
literal|0
expr_stmt|;
name|ha
operator|->
name|ha_ham
operator|=
name|ham
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
name|ha_tqh
argument_list|,
name|ha
argument_list|,
name|ha_link
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Look up an authentication method.  Automatically clone wildcards  * into fully-specified entries.  */
end_comment

begin_function
specifier|static
name|struct
name|http_auth
modifier|*
name|find_http_auth
parameter_list|(
name|struct
name|http_auth_head
modifier|*
name|tqh
parameter_list|,
specifier|const
name|char
modifier|*
name|scm
parameter_list|,
specifier|const
name|char
modifier|*
name|realm
parameter_list|)
block|{
name|struct
name|http_auth
modifier|*
name|ha
decl_stmt|;
for|for
control|(
name|ha
operator|=
name|tqh
operator|->
name|tqh_first
init|;
name|ha
condition|;
name|ha
operator|=
name|ha
operator|->
name|ha_link
operator|.
name|tqe_next
control|)
block|{
if|if
condition|(
name|strcasecmp
argument_list|(
name|ha
operator|->
name|ha_scheme
argument_list|,
name|scm
argument_list|)
operator|==
literal|0
operator|&&
name|strcasecmp
argument_list|(
name|ha
operator|->
name|ha_realm
argument_list|,
name|realm
argument_list|)
operator|==
literal|0
condition|)
return|return
name|ha
return|;
block|}
for|for
control|(
name|ha
operator|=
name|tqh
operator|->
name|tqh_first
init|;
name|ha
condition|;
name|ha
operator|=
name|ha
operator|->
name|ha_link
operator|.
name|tqe_next
control|)
block|{
if|if
condition|(
name|strcasecmp
argument_list|(
name|ha
operator|->
name|ha_scheme
argument_list|,
name|scm
argument_list|)
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|ha
operator|->
name|ha_realm
argument_list|,
literal|"*"
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|ha
operator|!=
literal|0
condition|)
block|{
name|struct
name|http_auth
modifier|*
name|ha2
decl_stmt|;
name|ha2
operator|=
name|safe_malloc
argument_list|(
sizeof|sizeof
expr|*
name|ha2
argument_list|)
expr_stmt|;
name|ha2
operator|->
name|ha_scheme
operator|=
name|safe_strdup
argument_list|(
name|scm
argument_list|)
expr_stmt|;
name|ha2
operator|->
name|ha_realm
operator|=
name|safe_strdup
argument_list|(
name|realm
argument_list|)
expr_stmt|;
name|ha2
operator|->
name|ha_params
operator|=
name|ha
operator|->
name|ha_params
condition|?
name|safe_strdup
argument_list|(
name|ha
operator|->
name|ha_params
argument_list|)
else|:
literal|0
expr_stmt|;
name|ha2
operator|->
name|ha_ham
operator|=
name|ha
operator|->
name|ha_ham
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
name|tqh
argument_list|,
name|ha2
argument_list|,
name|ha_link
argument_list|)
expr_stmt|;
name|ha
operator|=
name|ha2
expr_stmt|;
block|}
return|return
name|ha
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|setup_http_auth
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|envar
decl_stmt|;
specifier|static
name|int
name|once
decl_stmt|;
if|if
condition|(
name|once
condition|)
return|return;
name|once
operator|=
literal|1
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|http_auth
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|http_proxy_auth
argument_list|)
expr_stmt|;
name|envar
operator|=
name|getenv
argument_list|(
literal|"HTTP_AUTH"
argument_list|)
expr_stmt|;
if|if
condition|(
name|envar
condition|)
name|parse_http_auth_env
argument_list|(
name|envar
argument_list|,
operator|&
name|http_auth
argument_list|)
expr_stmt|;
name|envar
operator|=
name|getenv
argument_list|(
literal|"HTTP_PROXY_AUTH"
argument_list|)
expr_stmt|;
if|if
condition|(
name|envar
condition|)
name|parse_http_auth_env
argument_list|(
name|envar
argument_list|,
operator|&
name|http_proxy_auth
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|basic_doauth
parameter_list|(
name|struct
name|fetch_state
modifier|*
name|fs
parameter_list|,
name|struct
name|http_auth
modifier|*
name|ha
parameter_list|,
name|int
name|isproxy
parameter_list|)
block|{
name|struct
name|http_state
modifier|*
name|https
init|=
name|fs
operator|->
name|fs_proto
decl_stmt|;
name|char
modifier|*
name|user
decl_stmt|;
name|char
modifier|*
name|pass
decl_stmt|;
name|char
modifier|*
name|enc
decl_stmt|;
name|char
modifier|*
modifier|*
name|hdr
decl_stmt|;
name|size_t
name|userlen
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
if|if
condition|(
operator|!
name|isatty
argument_list|(
literal|0
argument_list|)
operator|&&
operator|(
name|ha
operator|->
name|ha_params
operator|==
literal|0
operator|||
name|strchr
argument_list|(
name|ha
operator|->
name|ha_params
argument_list|,
literal|':'
argument_list|)
operator|==
literal|0
operator|)
condition|)
return|return
name|EX_NOPERM
return|;
name|fp
operator|=
name|fopen
argument_list|(
literal|"/dev/tty"
argument_list|,
literal|"r+"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"opening /dev/tty"
argument_list|)
expr_stmt|;
return|return
name|EX_OSERR
return|;
block|}
if|if
condition|(
name|ha
operator|->
name|ha_params
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Enter `basic' user name for realm `%s': "
argument_list|,
name|ha
operator|->
name|ha_realm
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|user
operator|=
name|fgetln
argument_list|(
name|stdin
argument_list|,
operator|&
name|userlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|user
operator|==
literal|0
operator|||
name|userlen
operator|<
literal|1
condition|)
block|{
comment|/* longer name? */
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
name|EX_NOPERM
return|;
block|}
if|if
condition|(
name|user
index|[
name|userlen
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|user
index|[
name|userlen
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
else|else
name|user
index|[
name|userlen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|user
operator|=
name|safe_strdup
argument_list|(
name|user
argument_list|)
expr_stmt|;
name|pass
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|pass
operator|=
name|strchr
argument_list|(
name|ha
operator|->
name|ha_params
argument_list|,
literal|':'
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|user
operator|=
name|safe_strdup
argument_list|(
name|ha
operator|->
name|ha_params
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ha
operator|->
name|ha_params
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pass
operator|==
literal|0
condition|)
block|{
name|pass
operator|=
name|getpass
argument_list|(
literal|"Password: "
argument_list|)
expr_stmt|;
name|ha
operator|->
name|ha_params
operator|=
name|safe_malloc
argument_list|(
name|strlen
argument_list|(
name|user
argument_list|)
operator|+
literal|2
operator|+
name|strlen
argument_list|(
name|pass
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|ha
operator|->
name|ha_params
argument_list|,
name|user
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|ha
operator|->
name|ha_params
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|ha
operator|->
name|ha_params
argument_list|,
name|pass
argument_list|)
expr_stmt|;
block|}
name|enc
operator|=
name|to_base64
argument_list|(
name|ha
operator|->
name|ha_params
argument_list|,
name|strlen
argument_list|(
name|ha
operator|->
name|ha_params
argument_list|)
argument_list|)
expr_stmt|;
name|hdr
operator|=
name|isproxy
condition|?
operator|&
name|https
operator|->
name|http_proxy_authentication
else|:
operator|&
name|https
operator|->
name|http_authentication
expr_stmt|;
if|if
condition|(
operator|*
name|hdr
condition|)
name|free
argument_list|(
operator|*
name|hdr
argument_list|)
expr_stmt|;
operator|*
name|hdr
operator|=
name|safe_malloc
argument_list|(
sizeof|sizeof
argument_list|(
literal|"Proxy-Authorization: basic \r\n"
argument_list|)
operator|+
name|strlen
argument_list|(
name|enc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|isproxy
condition|)
name|strcpy
argument_list|(
operator|*
name|hdr
argument_list|,
literal|"Proxy-Authorization"
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
operator|*
name|hdr
argument_list|,
literal|"Authorization"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
operator|*
name|hdr
argument_list|,
literal|": Basic "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
operator|*
name|hdr
argument_list|,
name|enc
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
operator|*
name|hdr
argument_list|,
literal|"\r\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|enc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

