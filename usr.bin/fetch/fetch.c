begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2000 Dag-Erling Coïdan Smørgrav  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer  *    in this position and unchanged.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  *	$FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<sysexits.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<fetch.h>
end_include

begin_define
define|#
directive|define
name|MINBUFSIZE
value|4096
end_define

begin_comment
comment|/* Option flags */
end_comment

begin_decl_stmt
name|int
name|A_flag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*    -A: do not follow 302 redirects */
end_comment

begin_decl_stmt
name|int
name|a_flag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*    -a: auto retry */
end_comment

begin_decl_stmt
name|size_t
name|B_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*    -B: buffer size */
end_comment

begin_decl_stmt
name|int
name|b_flag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*!   -b: workaround TCP bug */
end_comment

begin_decl_stmt
name|char
modifier|*
name|c_dirname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*    -c: remote directory */
end_comment

begin_decl_stmt
name|int
name|d_flag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*    -d: direct connection */
end_comment

begin_decl_stmt
name|int
name|F_flag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*    -F: restart without checking mtime  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|f_filename
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*    -f: file to fetch */
end_comment

begin_decl_stmt
name|char
modifier|*
name|h_hostname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*    -h: host to fetch from */
end_comment

begin_decl_stmt
name|int
name|l_flag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*    -l: link rather than copy file: URLs */
end_comment

begin_decl_stmt
name|int
name|m_flag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -[Mm]: mirror mode */
end_comment

begin_decl_stmt
name|int
name|n_flag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*    -n: do not preserve modification time */
end_comment

begin_decl_stmt
name|int
name|o_flag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*    -o: specify output file */
end_comment

begin_decl_stmt
name|int
name|o_directory
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*        output file is a directory */
end_comment

begin_decl_stmt
name|char
modifier|*
name|o_filename
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*        name of output file */
end_comment

begin_decl_stmt
name|int
name|o_stdout
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*        output file is stdout */
end_comment

begin_decl_stmt
name|int
name|once_flag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*    -1: stop at first successful file */
end_comment

begin_decl_stmt
name|int
name|p_flag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -[Pp]: use passive FTP */
end_comment

begin_decl_stmt
name|int
name|R_flag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*    -R: don't delete partially transferred files */
end_comment

begin_decl_stmt
name|int
name|r_flag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*    -r: restart previously interrupted transfer */
end_comment

begin_decl_stmt
name|off_t
name|S_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*    -S: require size to match */
end_comment

begin_decl_stmt
name|int
name|s_flag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*    -s: show size, don't fetch */
end_comment

begin_decl_stmt
name|u_int
name|T_secs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*    -T: transfer timeout in seconds */
end_comment

begin_decl_stmt
name|int
name|t_flag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*!   -t: workaround TCP bug */
end_comment

begin_decl_stmt
name|int
name|U_flag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*    -U: do not use high ports */
end_comment

begin_decl_stmt
name|int
name|v_level
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*    -v: verbosity level */
end_comment

begin_decl_stmt
name|int
name|v_tty
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*        stdout is a tty */
end_comment

begin_decl_stmt
name|u_int
name|w_secs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*    -w: retry delay */
end_comment

begin_decl_stmt
name|int
name|family
init|=
name|PF_UNSPEC
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -[46]: address family to use */
end_comment

begin_decl_stmt
name|int
name|sigalrm
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* SIGALRM received */
end_comment

begin_decl_stmt
name|int
name|siginfo
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* SIGINFO received */
end_comment

begin_decl_stmt
name|int
name|sigint
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* SIGINT received */
end_comment

begin_decl_stmt
name|u_int
name|ftp_timeout
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* default timeout for FTP transfers */
end_comment

begin_decl_stmt
name|u_int
name|http_timeout
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* default timeout for HTTP transfers */
end_comment

begin_decl_stmt
name|u_char
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* transfer buffer */
end_comment

begin_function
name|void
name|sig_handler
parameter_list|(
name|int
name|sig
parameter_list|)
block|{
switch|switch
condition|(
name|sig
condition|)
block|{
case|case
name|SIGALRM
case|:
name|sigalrm
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|SIGINFO
case|:
name|siginfo
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|SIGINT
case|:
name|sigint
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_struct
struct|struct
name|xferstat
block|{
name|char
name|name
index|[
literal|40
index|]
decl_stmt|;
name|struct
name|timeval
name|start
decl_stmt|;
name|struct
name|timeval
name|end
decl_stmt|;
name|struct
name|timeval
name|last
decl_stmt|;
name|off_t
name|size
decl_stmt|;
name|off_t
name|offset
decl_stmt|;
name|off_t
name|rcvd
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|void
name|stat_display
parameter_list|(
name|struct
name|xferstat
modifier|*
name|xs
parameter_list|,
name|int
name|force
parameter_list|)
block|{
name|struct
name|timeval
name|now
decl_stmt|;
if|if
condition|(
operator|!
name|v_tty
operator|||
operator|!
name|v_level
condition|)
return|return;
name|gettimeofday
argument_list|(
operator|&
name|now
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|force
operator|&&
name|now
operator|.
name|tv_sec
operator|<=
name|xs
operator|->
name|last
operator|.
name|tv_sec
condition|)
return|return;
name|xs
operator|->
name|last
operator|=
name|now
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\rReceiving %s"
argument_list|,
name|xs
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|xs
operator|->
name|size
operator|<=
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|": %lld bytes"
argument_list|,
name|xs
operator|->
name|rcvd
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" (%lld bytes): %d%%"
argument_list|,
name|xs
operator|->
name|size
argument_list|,
call|(
name|int
call|)
argument_list|(
operator|(
literal|100.0
operator|*
name|xs
operator|->
name|rcvd
operator|)
operator|/
name|xs
operator|->
name|size
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|stat_start
parameter_list|(
name|struct
name|xferstat
modifier|*
name|xs
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|off_t
name|size
parameter_list|,
name|off_t
name|offset
parameter_list|)
block|{
name|snprintf
argument_list|(
name|xs
operator|->
name|name
argument_list|,
sizeof|sizeof
name|xs
operator|->
name|name
argument_list|,
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|gettimeofday
argument_list|(
operator|&
name|xs
operator|->
name|start
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|xs
operator|->
name|last
operator|.
name|tv_sec
operator|=
name|xs
operator|->
name|last
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|xs
operator|->
name|end
operator|=
name|xs
operator|->
name|last
expr_stmt|;
name|xs
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|xs
operator|->
name|offset
operator|=
name|offset
expr_stmt|;
name|xs
operator|->
name|rcvd
operator|=
name|offset
expr_stmt|;
name|stat_display
argument_list|(
name|xs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|stat_update
parameter_list|(
name|struct
name|xferstat
modifier|*
name|xs
parameter_list|,
name|off_t
name|rcvd
parameter_list|,
name|int
name|force
parameter_list|)
block|{
name|xs
operator|->
name|rcvd
operator|=
name|rcvd
expr_stmt|;
name|stat_display
argument_list|(
name|xs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|stat_end
parameter_list|(
name|struct
name|xferstat
modifier|*
name|xs
parameter_list|)
block|{
name|double
name|delta
decl_stmt|;
name|double
name|bps
decl_stmt|;
if|if
condition|(
operator|!
name|v_level
condition|)
return|return;
name|gettimeofday
argument_list|(
operator|&
name|xs
operator|->
name|end
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|stat_display
argument_list|(
name|xs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|delta
operator|=
operator|(
name|xs
operator|->
name|end
operator|.
name|tv_sec
operator|+
operator|(
name|xs
operator|->
name|end
operator|.
name|tv_usec
operator|/
literal|1.e6
operator|)
operator|)
operator|-
operator|(
name|xs
operator|->
name|start
operator|.
name|tv_sec
operator|+
operator|(
name|xs
operator|->
name|start
operator|.
name|tv_usec
operator|/
literal|1.e6
operator|)
operator|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%lld bytes transferred in %.1f seconds "
argument_list|,
name|xs
operator|->
name|rcvd
operator|-
name|xs
operator|->
name|offset
argument_list|,
name|delta
argument_list|)
expr_stmt|;
name|bps
operator|=
operator|(
name|xs
operator|->
name|rcvd
operator|-
name|xs
operator|->
name|offset
operator|)
operator|/
name|delta
expr_stmt|;
if|if
condition|(
name|bps
operator|>
literal|1024
operator|*
literal|1024
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"(%.2f MBps)\n"
argument_list|,
name|bps
operator|/
operator|(
literal|1024
operator|*
literal|1024
operator|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|bps
operator|>
literal|1024
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"(%.2f kBps)\n"
argument_list|,
name|bps
operator|/
literal|1024
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"(%.2f Bps)\n"
argument_list|,
name|bps
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|fetch
parameter_list|(
name|char
modifier|*
name|URL
parameter_list|,
name|char
modifier|*
name|path
parameter_list|)
block|{
name|struct
name|url
modifier|*
name|url
decl_stmt|;
name|struct
name|url_stat
name|us
decl_stmt|;
name|struct
name|stat
name|sb
decl_stmt|;
name|struct
name|xferstat
name|xs
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|,
modifier|*
name|of
decl_stmt|;
name|size_t
name|size
decl_stmt|,
name|wr
decl_stmt|;
name|off_t
name|count
decl_stmt|;
name|char
name|flags
index|[
literal|8
index|]
decl_stmt|;
name|int
name|r
decl_stmt|;
name|u_int
name|timeout
decl_stmt|;
name|u_char
modifier|*
name|ptr
decl_stmt|;
name|f
operator|=
name|of
operator|=
name|NULL
expr_stmt|;
comment|/* parse URL */
if|if
condition|(
operator|(
name|url
operator|=
name|fetchParseURL
argument_list|(
name|URL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: parse error"
argument_list|,
name|URL
argument_list|)
expr_stmt|;
goto|goto
name|failure
goto|;
block|}
comment|/* if no scheme was specified, take a guess */
if|if
condition|(
operator|!
operator|*
name|url
operator|->
name|scheme
condition|)
block|{
if|if
condition|(
operator|!
operator|*
name|url
operator|->
name|host
condition|)
name|strcpy
argument_list|(
name|url
operator|->
name|scheme
argument_list|,
name|SCHEME_FILE
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strncasecmp
argument_list|(
name|url
operator|->
name|host
argument_list|,
literal|"ftp."
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
name|strcpy
argument_list|(
name|url
operator|->
name|scheme
argument_list|,
name|SCHEME_FTP
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strncasecmp
argument_list|(
name|url
operator|->
name|host
argument_list|,
literal|"www."
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
name|strcpy
argument_list|(
name|url
operator|->
name|scheme
argument_list|,
name|SCHEME_HTTP
argument_list|)
expr_stmt|;
block|}
name|timeout
operator|=
literal|0
expr_stmt|;
operator|*
name|flags
operator|=
literal|0
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
comment|/* common flags */
if|if
condition|(
name|v_level
operator|>
literal|1
condition|)
name|strcat
argument_list|(
name|flags
argument_list|,
literal|"v"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|family
condition|)
block|{
case|case
name|PF_INET
case|:
name|strcat
argument_list|(
name|flags
argument_list|,
literal|"4"
argument_list|)
expr_stmt|;
break|break;
case|case
name|PF_INET6
case|:
name|strcat
argument_list|(
name|flags
argument_list|,
literal|"6"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* FTP specific flags */
if|if
condition|(
name|strcmp
argument_list|(
name|url
operator|->
name|scheme
argument_list|,
literal|"ftp"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|p_flag
condition|)
name|strcat
argument_list|(
name|flags
argument_list|,
literal|"p"
argument_list|)
expr_stmt|;
if|if
condition|(
name|d_flag
condition|)
name|strcat
argument_list|(
name|flags
argument_list|,
literal|"d"
argument_list|)
expr_stmt|;
if|if
condition|(
name|U_flag
condition|)
name|strcat
argument_list|(
name|flags
argument_list|,
literal|"l"
argument_list|)
expr_stmt|;
name|timeout
operator|=
name|T_secs
condition|?
name|T_secs
else|:
name|ftp_timeout
expr_stmt|;
block|}
comment|/* HTTP specific flags */
if|if
condition|(
name|strcmp
argument_list|(
name|url
operator|->
name|scheme
argument_list|,
literal|"http"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|d_flag
condition|)
name|strcat
argument_list|(
name|flags
argument_list|,
literal|"d"
argument_list|)
expr_stmt|;
if|if
condition|(
name|A_flag
condition|)
name|strcat
argument_list|(
name|flags
argument_list|,
literal|"A"
argument_list|)
expr_stmt|;
name|timeout
operator|=
name|T_secs
condition|?
name|T_secs
else|:
name|http_timeout
expr_stmt|;
block|}
comment|/* set the protocol timeout. */
name|fetchTimeout
operator|=
name|timeout
expr_stmt|;
comment|/* just print size */
if|if
condition|(
name|s_flag
condition|)
block|{
if|if
condition|(
name|fetchStat
argument_list|(
name|url
argument_list|,
operator|&
name|us
argument_list|,
name|flags
argument_list|)
operator|==
operator|-
literal|1
condition|)
goto|goto
name|failure
goto|;
if|if
condition|(
name|us
operator|.
name|size
operator|==
operator|-
literal|1
condition|)
name|printf
argument_list|(
literal|"Unknown\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%lld\n"
argument_list|,
name|us
operator|.
name|size
argument_list|)
expr_stmt|;
goto|goto
name|success
goto|;
block|}
comment|/*      * If the -r flag was specified, we have to compare the local and      * remote files, so we should really do a fetchStat() first, but I      * know of at least one HTTP server that only sends the content      * size in response to GET requests, and leaves it out of replies      * to HEAD requests. Also, in the (frequent) case that the local      * and remote files match but the local file is truncated, we have      * sufficient information *before* the compare to issue a correct      * request. Therefore, we always issue a GET request as if we were      * sure the local file was a truncated copy of the remote file; we      * can drop the connection later if we change our minds.      */
if|if
condition|(
operator|(
name|r_flag
operator|||
name|m_flag
operator|)
operator|&&
operator|!
name|o_stdout
operator|&&
name|stat
argument_list|(
name|path
argument_list|,
operator|&
name|sb
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|r_flag
condition|)
name|url
operator|->
name|offset
operator|=
name|sb
operator|.
name|st_size
expr_stmt|;
block|}
else|else
block|{
name|sb
operator|.
name|st_size
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* start the transfer */
if|if
condition|(
operator|(
name|f
operator|=
name|fetchXGet
argument_list|(
name|url
argument_list|,
operator|&
name|us
argument_list|,
name|flags
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: %s"
argument_list|,
name|path
argument_list|,
name|fetchLastErrString
argument_list|)
expr_stmt|;
goto|goto
name|failure
goto|;
block|}
if|if
condition|(
name|sigint
condition|)
goto|goto
name|signal
goto|;
comment|/* check that size is as expected */
if|if
condition|(
name|S_size
condition|)
block|{
if|if
condition|(
name|us
operator|.
name|size
operator|==
operator|-
literal|1
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: size unknown"
argument_list|,
name|path
argument_list|)
expr_stmt|;
goto|goto
name|failure
goto|;
block|}
elseif|else
if|if
condition|(
name|us
operator|.
name|size
operator|!=
name|S_size
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: size mismatch: expected %lld, actual %lld"
argument_list|,
name|path
argument_list|,
name|S_size
argument_list|,
name|us
operator|.
name|size
argument_list|)
expr_stmt|;
goto|goto
name|failure
goto|;
block|}
block|}
comment|/* symlink instead of copy */
if|if
condition|(
name|l_flag
operator|&&
name|strcmp
argument_list|(
name|url
operator|->
name|scheme
argument_list|,
literal|"file"
argument_list|)
operator|==
literal|0
operator|&&
operator|!
name|o_stdout
condition|)
block|{
if|if
condition|(
name|symlink
argument_list|(
name|url
operator|->
name|doc
argument_list|,
name|path
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|warn
argument_list|(
literal|"%s: symlink()"
argument_list|,
name|path
argument_list|)
expr_stmt|;
goto|goto
name|failure
goto|;
block|}
goto|goto
name|success
goto|;
block|}
if|if
condition|(
name|us
operator|.
name|size
operator|==
operator|-
literal|1
condition|)
name|warnx
argument_list|(
literal|"%s: size of remote file is not known"
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|v_level
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|sb
operator|.
name|st_size
operator|!=
operator|-
literal|1
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"local size / mtime: %lld / %ld\n"
argument_list|,
name|sb
operator|.
name|st_size
argument_list|,
operator|(
name|long
operator|)
name|sb
operator|.
name|st_mtime
argument_list|)
expr_stmt|;
if|if
condition|(
name|us
operator|.
name|size
operator|!=
operator|-
literal|1
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"remote size / mtime: %lld / %ld\n"
argument_list|,
name|us
operator|.
name|size
argument_list|,
operator|(
name|long
operator|)
name|us
operator|.
name|mtime
argument_list|)
expr_stmt|;
block|}
comment|/* open output file */
if|if
condition|(
name|o_stdout
condition|)
block|{
comment|/* output to stdout */
name|of
operator|=
name|stdout
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sb
operator|.
name|st_size
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* resume mode, local file exists */
if|if
condition|(
operator|!
name|F_flag
operator|&&
name|us
operator|.
name|mtime
operator|&&
name|sb
operator|.
name|st_mtime
operator|!=
name|us
operator|.
name|mtime
condition|)
block|{
comment|/* no match! have to refetch */
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
comment|/* if precious, warn the user and give up */
if|if
condition|(
name|R_flag
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: local modification time does not match remote"
argument_list|,
name|path
argument_list|)
expr_stmt|;
goto|goto
name|failure_keep
goto|;
block|}
name|url
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|f
operator|=
name|fetchXGet
argument_list|(
name|url
argument_list|,
operator|&
name|us
argument_list|,
name|flags
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: %s"
argument_list|,
name|path
argument_list|,
name|fetchLastErrString
argument_list|)
expr_stmt|;
goto|goto
name|failure
goto|;
block|}
if|if
condition|(
name|sigint
condition|)
goto|goto
name|signal
goto|;
block|}
else|else
block|{
if|if
condition|(
name|us
operator|.
name|size
operator|==
name|sb
operator|.
name|st_size
condition|)
comment|/* nothing to do */
goto|goto
name|success
goto|;
if|if
condition|(
name|sb
operator|.
name|st_size
operator|>
name|us
operator|.
name|size
condition|)
block|{
comment|/* local file too long! */
name|warnx
argument_list|(
literal|"%s: local file (%lld bytes) is longer "
literal|"than remote file (%lld bytes)"
argument_list|,
name|path
argument_list|,
name|sb
operator|.
name|st_size
argument_list|,
name|us
operator|.
name|size
argument_list|)
expr_stmt|;
goto|goto
name|failure
goto|;
block|}
comment|/* we got through, open local file and seek to offset */
comment|/* 	     * XXX there's a race condition here - the file we open is not 	     * necessarily the same as the one we stat()'ed earlier... 	     */
if|if
condition|(
operator|(
name|of
operator|=
name|fopen
argument_list|(
name|path
argument_list|,
literal|"a"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|warn
argument_list|(
literal|"%s: fopen()"
argument_list|,
name|path
argument_list|)
expr_stmt|;
goto|goto
name|failure
goto|;
block|}
if|if
condition|(
name|fseek
argument_list|(
name|of
argument_list|,
name|url
operator|->
name|offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|warn
argument_list|(
literal|"%s: fseek()"
argument_list|,
name|path
argument_list|)
expr_stmt|;
goto|goto
name|failure
goto|;
block|}
block|}
block|}
if|if
condition|(
name|m_flag
operator|&&
name|sb
operator|.
name|st_size
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* mirror mode, local file exists */
if|if
condition|(
name|sb
operator|.
name|st_size
operator|==
name|us
operator|.
name|size
operator|&&
name|sb
operator|.
name|st_mtime
operator|==
name|us
operator|.
name|mtime
condition|)
goto|goto
name|success
goto|;
block|}
if|if
condition|(
operator|!
name|of
condition|)
block|{
comment|/* 	 * We don't yet have an output file; either this is a vanilla 	 * run with no special flags, or the local and remote files 	 * didn't match. 	 */
if|if
condition|(
operator|(
name|of
operator|=
name|fopen
argument_list|(
name|path
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|warn
argument_list|(
literal|"%s: open()"
argument_list|,
name|path
argument_list|)
expr_stmt|;
goto|goto
name|failure
goto|;
block|}
block|}
name|count
operator|=
name|url
operator|->
name|offset
expr_stmt|;
comment|/* start the counter */
name|stat_start
argument_list|(
operator|&
name|xs
argument_list|,
name|path
argument_list|,
name|us
operator|.
name|size
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|sigalrm
operator|=
name|siginfo
operator|=
name|sigint
operator|=
literal|0
expr_stmt|;
comment|/* suck in the data */
name|signal
argument_list|(
name|SIGINFO
argument_list|,
name|sig_handler
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|sigint
operator|&&
operator|!
name|sigalrm
condition|)
block|{
if|if
condition|(
name|us
operator|.
name|size
operator|!=
operator|-
literal|1
operator|&&
name|us
operator|.
name|size
operator|-
name|count
operator|<
name|B_size
condition|)
name|size
operator|=
name|us
operator|.
name|size
operator|-
name|count
expr_stmt|;
else|else
name|size
operator|=
name|B_size
expr_stmt|;
if|if
condition|(
name|timeout
condition|)
name|alarm
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|siginfo
condition|)
block|{
name|stat_end
argument_list|(
operator|&
name|xs
argument_list|)
expr_stmt|;
name|siginfo
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|size
operator|=
name|fread
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
name|size
argument_list|,
name|f
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ferror
argument_list|(
name|f
argument_list|)
operator|&&
name|errno
operator|==
name|EINTR
operator|&&
operator|!
name|sigalrm
operator|&&
operator|!
name|sigint
condition|)
name|clearerr
argument_list|(
name|f
argument_list|)
expr_stmt|;
else|else
break|break;
block|}
if|if
condition|(
name|timeout
condition|)
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|stat_update
argument_list|(
operator|&
name|xs
argument_list|,
name|count
operator|+=
name|size
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|ptr
operator|=
name|buf
init|;
name|size
operator|>
literal|0
condition|;
name|ptr
operator|+=
name|wr
operator|,
name|size
operator|-=
name|wr
control|)
if|if
condition|(
operator|(
name|wr
operator|=
name|fwrite
argument_list|(
name|ptr
argument_list|,
literal|1
argument_list|,
name|size
argument_list|,
name|of
argument_list|)
operator|)
operator|<
name|size
condition|)
block|{
if|if
condition|(
name|ferror
argument_list|(
name|of
argument_list|)
operator|&&
name|errno
operator|==
name|EINTR
operator|&&
operator|!
name|sigalrm
operator|&&
operator|!
name|sigint
condition|)
name|clearerr
argument_list|(
name|of
argument_list|)
expr_stmt|;
else|else
break|break;
block|}
if|if
condition|(
name|size
operator|!=
literal|0
condition|)
break|break;
block|}
name|signal
argument_list|(
name|SIGINFO
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
if|if
condition|(
name|timeout
condition|)
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|stat_end
argument_list|(
operator|&
name|xs
argument_list|)
expr_stmt|;
comment|/* set mtime of local file */
if|if
condition|(
operator|!
name|n_flag
operator|&&
name|us
operator|.
name|mtime
operator|&&
operator|!
name|o_stdout
operator|&&
operator|(
name|stat
argument_list|(
name|path
argument_list|,
operator|&
name|sb
argument_list|)
operator|!=
operator|-
literal|1
operator|)
operator|&&
name|sb
operator|.
name|st_mode
operator|&
name|S_IFREG
condition|)
block|{
name|struct
name|timeval
name|tv
index|[
literal|2
index|]
decl_stmt|;
name|fflush
argument_list|(
name|of
argument_list|)
expr_stmt|;
name|tv
index|[
literal|0
index|]
operator|.
name|tv_sec
operator|=
call|(
name|long
call|)
argument_list|(
name|us
operator|.
name|atime
condition|?
name|us
operator|.
name|atime
else|:
name|us
operator|.
name|mtime
argument_list|)
expr_stmt|;
name|tv
index|[
literal|1
index|]
operator|.
name|tv_sec
operator|=
operator|(
name|long
operator|)
name|us
operator|.
name|mtime
expr_stmt|;
name|tv
index|[
literal|0
index|]
operator|.
name|tv_usec
operator|=
name|tv
index|[
literal|1
index|]
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|utimes
argument_list|(
name|path
argument_list|,
name|tv
argument_list|)
condition|)
name|warn
argument_list|(
literal|"%s: utimes()"
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
comment|/* timed out or interrupted? */
name|signal
label|:
if|if
condition|(
name|sigalrm
condition|)
name|warnx
argument_list|(
literal|"transfer timed out"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigint
condition|)
block|{
name|warnx
argument_list|(
literal|"transfer interrupted"
argument_list|)
expr_stmt|;
goto|goto
name|failure
goto|;
block|}
if|if
condition|(
operator|!
name|sigalrm
condition|)
block|{
comment|/* check the status of our files */
if|if
condition|(
name|ferror
argument_list|(
name|f
argument_list|)
condition|)
name|warn
argument_list|(
literal|"%s"
argument_list|,
name|URL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|of
argument_list|)
condition|)
name|warn
argument_list|(
literal|"%s"
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|f
argument_list|)
operator|||
name|ferror
argument_list|(
name|of
argument_list|)
condition|)
goto|goto
name|failure
goto|;
block|}
comment|/* did the transfer complete normally? */
if|if
condition|(
name|us
operator|.
name|size
operator|!=
operator|-
literal|1
operator|&&
name|count
operator|<
name|us
operator|.
name|size
condition|)
block|{
name|warnx
argument_list|(
literal|"%s appears to be truncated: %lld/%lld bytes"
argument_list|,
name|path
argument_list|,
name|count
argument_list|,
name|us
operator|.
name|size
argument_list|)
expr_stmt|;
goto|goto
name|failure_keep
goto|;
block|}
comment|/*      * If the transfer timed out and we didn't know how much to      * expect, assume the worst (i.e. we didn't get all of it)      */
if|if
condition|(
name|sigalrm
operator|&&
name|us
operator|.
name|size
operator|==
operator|-
literal|1
condition|)
block|{
name|warnx
argument_list|(
literal|"%s may be truncated"
argument_list|,
name|path
argument_list|)
expr_stmt|;
goto|goto
name|failure_keep
goto|;
block|}
name|success
label|:
name|r
operator|=
literal|0
expr_stmt|;
goto|goto
name|done
goto|;
name|failure
label|:
if|if
condition|(
name|of
operator|&&
name|of
operator|!=
name|stdout
operator|&&
operator|!
name|R_flag
operator|&&
operator|!
name|r_flag
condition|)
if|if
condition|(
name|stat
argument_list|(
name|path
argument_list|,
operator|&
name|sb
argument_list|)
operator|!=
operator|-
literal|1
operator|&&
operator|(
name|sb
operator|.
name|st_mode
operator|&
name|S_IFREG
operator|)
condition|)
name|unlink
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|failure_keep
label|:
name|r
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|done
goto|;
name|done
label|:
if|if
condition|(
name|f
condition|)
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|of
operator|&&
name|of
operator|!=
name|stdout
condition|)
name|fclose
argument_list|(
name|of
argument_list|)
expr_stmt|;
if|if
condition|(
name|url
condition|)
name|fetchFreeURL
argument_list|(
name|url
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: fetch [-146AFMPRUadlmnpqrsv] [-o outputfile] [-S bytes]\n"
literal|"             [-B bytes] [-T seconds] [-w seconds]\n"
literal|"             [-h host -f file [-c dir] | URL ...]\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|PARSENUM
parameter_list|(
name|NAME
parameter_list|,
name|TYPE
parameter_list|)
define|\
value|int					\ NAME(char *s, TYPE *v)			\ {					\     *v = 0;				\     for (*v = 0; *s; s++)		\ 	if (isdigit(*s))		\ 	    *v = *v * 10 + *s - '0';	\ 	else				\ 	    return -1;			\     return 0;				\ }
end_define

begin_macro
name|PARSENUM
argument_list|(
argument|parseint
argument_list|,
argument|u_int
argument_list|)
end_macro

begin_macro
name|PARSENUM
argument_list|(
argument|parsesize
argument_list|,
argument|size_t
argument_list|)
end_macro

begin_macro
name|PARSENUM
argument_list|(
argument|parseoff
argument_list|,
argument|off_t
argument_list|)
end_macro

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|struct
name|stat
name|sb
decl_stmt|;
name|struct
name|sigaction
name|sa
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|,
modifier|*
name|s
decl_stmt|;
name|int
name|c
decl_stmt|,
name|e
decl_stmt|,
name|r
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"146AaB:bc:dFf:Hh:lMmnPpo:qRrS:sT:tUvw:"
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'1'
case|:
name|once_flag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'4'
case|:
name|family
operator|=
name|PF_INET
expr_stmt|;
break|break;
case|case
literal|'6'
case|:
name|family
operator|=
name|PF_INET6
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
name|A_flag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|a_flag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
if|if
condition|(
name|parsesize
argument_list|(
name|optarg
argument_list|,
operator|&
name|B_size
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"invalid buffer size"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|warnx
argument_list|(
literal|"warning: the -b option is deprecated"
argument_list|)
expr_stmt|;
name|b_flag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|c_dirname
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|d_flag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
name|F_flag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|f_filename
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
name|warnx
argument_list|(
literal|"The -H option is now implicit, use -U to disable\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|h_hostname
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|l_flag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|o_flag
operator|=
literal|1
expr_stmt|;
name|o_filename
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
case|case
literal|'m'
case|:
if|if
condition|(
name|r_flag
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"the -m and -r flags are mutually exclusive"
argument_list|)
expr_stmt|;
name|m_flag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|n_flag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
case|case
literal|'p'
case|:
name|p_flag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|v_level
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|R_flag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
if|if
condition|(
name|m_flag
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"the -m and -r flags are mutually exclusive"
argument_list|)
expr_stmt|;
name|r_flag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
if|if
condition|(
name|parseoff
argument_list|(
name|optarg
argument_list|,
operator|&
name|S_size
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"invalid size"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|s_flag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
if|if
condition|(
name|parseint
argument_list|(
name|optarg
argument_list|,
operator|&
name|T_secs
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"invalid timeout"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|t_flag
operator|=
literal|1
expr_stmt|;
name|warnx
argument_list|(
literal|"warning: the -t option is deprecated"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'U'
case|:
name|U_flag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|v_level
operator|++
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|a_flag
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|parseint
argument_list|(
name|optarg
argument_list|,
operator|&
name|w_secs
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"invalid delay"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|()
expr_stmt|;
name|exit
argument_list|(
name|EX_USAGE
argument_list|)
expr_stmt|;
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|h_hostname
operator|||
name|f_filename
operator|||
name|c_dirname
condition|)
block|{
if|if
condition|(
operator|!
name|h_hostname
operator|||
operator|!
name|f_filename
operator|||
name|argc
condition|)
block|{
name|usage
argument_list|()
expr_stmt|;
name|exit
argument_list|(
name|EX_USAGE
argument_list|)
expr_stmt|;
block|}
comment|/* XXX this is a hack. */
if|if
condition|(
name|strcspn
argument_list|(
name|h_hostname
argument_list|,
literal|"@:/"
argument_list|)
operator|!=
name|strlen
argument_list|(
name|h_hostname
argument_list|)
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"invalid hostname"
argument_list|)
expr_stmt|;
if|if
condition|(
name|asprintf
argument_list|(
name|argv
argument_list|,
literal|"ftp://%s/%s/%s"
argument_list|,
name|h_hostname
argument_list|,
name|c_dirname
condition|?
name|c_dirname
else|:
literal|""
argument_list|,
name|f_filename
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s"
argument_list|,
name|strerror
argument_list|(
name|ENOMEM
argument_list|)
argument_list|)
expr_stmt|;
name|argc
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|argc
condition|)
block|{
name|usage
argument_list|()
expr_stmt|;
name|exit
argument_list|(
name|EX_USAGE
argument_list|)
expr_stmt|;
block|}
comment|/* allocate buffer */
if|if
condition|(
name|B_size
operator|<
name|MINBUFSIZE
condition|)
name|B_size
operator|=
name|MINBUFSIZE
expr_stmt|;
if|if
condition|(
operator|(
name|buf
operator|=
name|malloc
argument_list|(
name|B_size
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s"
argument_list|,
name|strerror
argument_list|(
name|ENOMEM
argument_list|)
argument_list|)
expr_stmt|;
comment|/* timeouts */
if|if
condition|(
operator|(
name|s
operator|=
name|getenv
argument_list|(
literal|"FTP_TIMEOUT"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|parseint
argument_list|(
name|s
argument_list|,
operator|&
name|ftp_timeout
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|warnx
argument_list|(
literal|"FTP_TIMEOUT is not a positive integer"
argument_list|)
expr_stmt|;
name|ftp_timeout
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|s
operator|=
name|getenv
argument_list|(
literal|"HTTP_TIMEOUT"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|parseint
argument_list|(
name|s
argument_list|,
operator|&
name|http_timeout
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|warnx
argument_list|(
literal|"HTTP_TIMEOUT is not a positive integer"
argument_list|)
expr_stmt|;
name|http_timeout
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* signal handling */
name|sa
operator|.
name|sa_flags
operator|=
literal|0
expr_stmt|;
name|sa
operator|.
name|sa_handler
operator|=
name|sig_handler
expr_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|sa
operator|.
name|sa_mask
argument_list|)
expr_stmt|;
name|sigaction
argument_list|(
name|SIGALRM
argument_list|,
operator|&
name|sa
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|sa
operator|.
name|sa_flags
operator|=
name|SA_RESETHAND
expr_stmt|;
name|sigaction
argument_list|(
name|SIGINT
argument_list|,
operator|&
name|sa
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|fetchRestartCalls
operator|=
literal|0
expr_stmt|;
comment|/* output file */
if|if
condition|(
name|o_flag
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|o_filename
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|o_stdout
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|stat
argument_list|(
name|o_filename
argument_list|,
operator|&
name|sb
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOENT
condition|)
block|{
if|if
condition|(
name|argc
operator|>
literal|1
condition|)
name|errx
argument_list|(
name|EX_USAGE
argument_list|,
literal|"%s is not a directory"
argument_list|,
name|o_filename
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|err
argument_list|(
name|EX_IOERR
argument_list|,
literal|"%s"
argument_list|,
name|o_filename
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|sb
operator|.
name|st_mode
operator|&
name|S_IFDIR
condition|)
name|o_directory
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* check if output is to a tty (for progress report) */
name|v_tty
operator|=
name|isatty
argument_list|(
name|STDERR_FILENO
argument_list|)
expr_stmt|;
name|r
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|argc
condition|)
block|{
if|if
condition|(
operator|(
name|p
operator|=
name|strrchr
argument_list|(
operator|*
name|argv
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|p
operator|=
operator|*
name|argv
expr_stmt|;
else|else
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|p
condition|)
name|p
operator|=
literal|"fetch.out"
expr_stmt|;
name|fetchLastErrCode
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|o_flag
condition|)
block|{
if|if
condition|(
name|o_stdout
condition|)
block|{
name|e
operator|=
name|fetch
argument_list|(
operator|*
name|argv
argument_list|,
literal|"-"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|o_directory
condition|)
block|{
name|asprintf
argument_list|(
operator|&
name|q
argument_list|,
literal|"%s/%s"
argument_list|,
name|o_filename
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|e
operator|=
name|fetch
argument_list|(
operator|*
name|argv
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|e
operator|=
name|fetch
argument_list|(
operator|*
name|argv
argument_list|,
name|o_filename
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|e
operator|=
name|fetch
argument_list|(
operator|*
name|argv
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sigint
condition|)
name|kill
argument_list|(
name|getpid
argument_list|()
argument_list|,
name|SIGINT
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|==
literal|0
operator|&&
name|once_flag
condition|)
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
condition|)
block|{
name|r
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|fetchLastErrCode
operator|&&
name|fetchLastErrCode
operator|!=
name|FETCH_UNAVAIL
operator|&&
name|fetchLastErrCode
operator|!=
name|FETCH_MOVED
operator|&&
name|fetchLastErrCode
operator|!=
name|FETCH_URL
operator|&&
name|fetchLastErrCode
operator|!=
name|FETCH_RESOLV
operator|&&
name|fetchLastErrCode
operator|!=
name|FETCH_UNKNOWN
operator|)
condition|)
block|{
if|if
condition|(
name|w_secs
condition|)
block|{
if|if
condition|(
name|v_level
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Waiting %d seconds before retrying\n"
argument_list|,
name|w_secs
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
name|w_secs
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|a_flag
condition|)
continue|continue;
block|}
block|}
name|argc
operator|--
operator|,
name|argv
operator|++
expr_stmt|;
block|}
name|exit
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

