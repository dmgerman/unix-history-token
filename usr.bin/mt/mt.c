begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1980, 1993  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*-  * Copyright (c) 2013, 2014, 2015 Spectra Logic Corporation  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions, and the following disclaimer,  *    without modification.  * 2. Redistributions in binary form must reproduce at minimum a disclaimer  *    substantially similar to the "NO WARRANTY" disclaimer below  *    ("Disclaimer") and any redistribution must be conditioned upon  *    including a substantially similar Disclaimer requirement for further  *    binary redistribution.  *  * NO WARRANTY  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGES.  *  * Authors: Ken Merry           (Spectra Logic Corporation)  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|copyright
index|[]
init|=
literal|"@(#) Copyright (c) 1980, 1993\n\ 	The Regents of the University of California.  All rights reserved.\n"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static char sccsid[] = "@(#)mt.c	8.2 (Berkeley) 5/4/95";
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * mt --  *   magnetic tape manipulation program  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/mtio.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/sbuf.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<bsdxml.h>
end_include

begin_include
include|#
directive|include
file|<mtlib.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_ccb.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_periph.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_all.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_sa.h>
end_include

begin_comment
comment|/* the appropriate sections of<sys/mtio.h> are also #ifdef'd for FreeBSD */
end_comment

begin_comment
comment|/* c_flags */
end_comment

begin_define
define|#
directive|define
name|NEED_2ARGS
value|0x01
end_define

begin_define
define|#
directive|define
name|ZERO_ALLOWED
value|0x02
end_define

begin_define
define|#
directive|define
name|IS_DENSITY
value|0x04
end_define

begin_define
define|#
directive|define
name|DISABLE_THIS
value|0x08
end_define

begin_define
define|#
directive|define
name|IS_COMP
value|0x10
end_define

begin_define
define|#
directive|define
name|USE_GETOPT
value|0x20
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|TRUE
end_ifndef

begin_define
define|#
directive|define
name|TRUE
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|FALSE
end_ifndef

begin_define
define|#
directive|define
name|FALSE
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MAX
end_ifndef

begin_define
define|#
directive|define
name|MAX
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(a> b) ? a : b
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_typedef
typedef|typedef
enum|enum
block|{
name|MT_CMD_NONE
init|=
name|MTLOAD
operator|+
literal|1
block|,
name|MT_CMD_PROTECT
block|,
name|MT_CMD_GETDENSITY
block|}
name|mt_commands
typedef|;
end_typedef

begin_struct
specifier|static
specifier|const
struct|struct
name|commands
block|{
specifier|const
name|char
modifier|*
name|c_name
decl_stmt|;
name|unsigned
name|long
name|c_code
decl_stmt|;
name|int
name|c_ronly
decl_stmt|;
name|int
name|c_flags
decl_stmt|;
block|}
name|com
index|[]
init|=
block|{
block|{
literal|"bsf"
block|,
name|MTBSF
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"bsr"
block|,
name|MTBSR
block|,
literal|1
block|,
literal|0
block|}
block|,
comment|/* XXX FreeBSD considered "eof" dangerous, since it's being 	   confused with "eom" (and is an alias for "weof" anyway) */
block|{
literal|"eof"
block|,
name|MTWEOF
block|,
literal|0
block|,
name|DISABLE_THIS
block|}
block|,
block|{
literal|"fsf"
block|,
name|MTFSF
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"fsr"
block|,
name|MTFSR
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"offline"
block|,
name|MTOFFL
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"load"
block|,
name|MTLOAD
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"rewind"
block|,
name|MTREW
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"rewoffl"
block|,
name|MTOFFL
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"ostatus"
block|,
name|MTNOP
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"weof"
block|,
name|MTWEOF
block|,
literal|0
block|,
name|ZERO_ALLOWED
block|}
block|,
block|{
literal|"weofi"
block|,
name|MTWEOFI
block|,
literal|0
block|,
name|ZERO_ALLOWED
block|}
block|,
block|{
literal|"erase"
block|,
name|MTERASE
block|,
literal|0
block|,
name|ZERO_ALLOWED
block|}
block|,
block|{
literal|"blocksize"
block|,
name|MTSETBSIZ
block|,
literal|0
block|,
name|NEED_2ARGS
operator||
name|ZERO_ALLOWED
block|}
block|,
block|{
literal|"density"
block|,
name|MTSETDNSTY
block|,
literal|0
block|,
name|NEED_2ARGS
operator||
name|ZERO_ALLOWED
operator||
name|IS_DENSITY
block|}
block|,
block|{
literal|"eom"
block|,
name|MTEOD
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"eod"
block|,
name|MTEOD
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"smk"
block|,
name|MTWSS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"wss"
block|,
name|MTWSS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"fss"
block|,
name|MTFSS
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"bss"
block|,
name|MTBSS
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"comp"
block|,
name|MTCOMP
block|,
literal|0
block|,
name|NEED_2ARGS
operator||
name|ZERO_ALLOWED
operator||
name|IS_COMP
block|}
block|,
block|{
literal|"retension"
block|,
name|MTRETENS
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"rdhpos"
block|,
name|MTIOCRDHPOS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"rdspos"
block|,
name|MTIOCRDSPOS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"sethpos"
block|,
name|MTIOCHLOCATE
block|,
literal|0
block|,
name|NEED_2ARGS
operator||
name|ZERO_ALLOWED
block|}
block|,
block|{
literal|"setspos"
block|,
name|MTIOCSLOCATE
block|,
literal|0
block|,
name|NEED_2ARGS
operator||
name|ZERO_ALLOWED
block|}
block|,
block|{
literal|"errstat"
block|,
name|MTIOCERRSTAT
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"setmodel"
block|,
name|MTIOCSETEOTMODEL
block|,
literal|0
block|,
name|NEED_2ARGS
operator||
name|ZERO_ALLOWED
block|}
block|,
block|{
literal|"seteotmodel"
block|,
name|MTIOCSETEOTMODEL
block|,
literal|0
block|,
name|NEED_2ARGS
operator||
name|ZERO_ALLOWED
block|}
block|,
block|{
literal|"getmodel"
block|,
name|MTIOCGETEOTMODEL
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"geteotmodel"
block|,
name|MTIOCGETEOTMODEL
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"rblim"
block|,
name|MTIOCRBLIM
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"getdensity"
block|,
name|MT_CMD_GETDENSITY
block|,
literal|0
block|,
name|USE_GETOPT
block|}
block|,
block|{
literal|"status"
block|,
name|MTIOCEXTGET
block|,
literal|0
block|,
name|USE_GETOPT
block|}
block|,
block|{
literal|"locate"
block|,
name|MTIOCEXTLOCATE
block|,
literal|0
block|,
name|USE_GETOPT
block|}
block|,
block|{
literal|"param"
block|,
name|MTIOCPARAMGET
block|,
literal|0
block|,
name|USE_GETOPT
block|}
block|,
block|{
literal|"protect"
block|,
name|MT_CMD_PROTECT
block|,
literal|0
block|,
name|USE_GETOPT
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
struct|;
end_struct

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|getblksiz
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|printreg
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|u_int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|status
parameter_list|(
name|struct
name|mtget
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|const
name|char
modifier|*
name|get_driver_state_str
parameter_list|(
name|int
name|dsreg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|st_status
parameter_list|(
name|struct
name|mtget
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mt_locate
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|int
name|mtfd
parameter_list|,
specifier|const
name|char
modifier|*
name|tape
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nstatus_print
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|char
modifier|*
name|xml_str
parameter_list|,
name|struct
name|mt_status_data
modifier|*
name|status_data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mt_xml_cmd
parameter_list|(
name|unsigned
name|long
name|cmd
parameter_list|,
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|int
name|mtfd
parameter_list|,
specifier|const
name|char
modifier|*
name|tape
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mt_print_density_entry
parameter_list|(
name|struct
name|mt_status_entry
modifier|*
name|density_root
parameter_list|,
name|int
name|indent
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mt_print_density_report
parameter_list|(
name|struct
name|mt_status_entry
modifier|*
name|report_root
parameter_list|,
name|int
name|indent
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mt_print_density
parameter_list|(
name|struct
name|mt_status_entry
modifier|*
name|density_root
parameter_list|,
name|int
name|indent
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mt_getdensity
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|char
modifier|*
name|xml_str
parameter_list|,
name|struct
name|mt_status_data
modifier|*
name|status_data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mt_set_param
parameter_list|(
name|int
name|mtfd
parameter_list|,
name|struct
name|mt_status_data
modifier|*
name|status_data
parameter_list|,
name|char
modifier|*
name|param_name
parameter_list|,
name|char
modifier|*
name|param_value
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mt_protect
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|int
name|mtfd
parameter_list|,
name|struct
name|mt_status_data
modifier|*
name|status_data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mt_param
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|int
name|mtfd
parameter_list|,
name|char
modifier|*
name|xml_str
parameter_list|,
name|struct
name|mt_status_data
modifier|*
name|status_data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|denstostring
parameter_list|(
name|int
name|d
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int32_t
name|stringtocomp
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|comptostring
parameter_list|(
name|u_int32_t
name|comp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|warn_eof
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
specifier|const
name|struct
name|commands
modifier|*
name|comp
decl_stmt|;
name|struct
name|mtget
name|mt_status
decl_stmt|;
name|struct
name|mtop
name|mt_com
decl_stmt|;
name|int
name|ch
decl_stmt|,
name|len
decl_stmt|,
name|mtfd
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|tape
decl_stmt|;
if|if
condition|(
operator|(
name|tape
operator|=
name|getenv
argument_list|(
literal|"TAPE"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|tape
operator|=
name|DEFTAPE
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"f:t:"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'f'
case|:
case|case
literal|'t'
case|:
name|tape
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
name|usage
argument_list|()
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|argc
operator|<
literal|1
condition|)
name|usage
argument_list|()
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|p
operator|=
operator|*
name|argv
operator|++
argument_list|)
expr_stmt|;
for|for
control|(
name|comp
operator|=
name|com
init|;
condition|;
name|comp
operator|++
control|)
block|{
if|if
condition|(
name|comp
operator|->
name|c_name
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s: unknown command"
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|p
argument_list|,
name|comp
operator|->
name|c_name
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
operator|(
name|comp
operator|->
name|c_flags
operator|&
name|NEED_2ARGS
operator|)
operator|&&
name|argc
operator|!=
literal|2
condition|)
name|usage
argument_list|()
expr_stmt|;
if|if
condition|(
name|comp
operator|->
name|c_flags
operator|&
name|DISABLE_THIS
condition|)
block|{
name|warn_eof
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|comp
operator|->
name|c_flags
operator|&
name|USE_GETOPT
condition|)
block|{
name|argc
operator|--
expr_stmt|;
name|optind
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|mtfd
operator|=
name|open
argument_list|(
name|tape
argument_list|,
name|comp
operator|->
name|c_ronly
condition|?
name|O_RDONLY
else|:
name|O_RDWR
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"%s"
argument_list|,
name|tape
argument_list|)
expr_stmt|;
if|if
condition|(
name|comp
operator|->
name|c_code
operator|!=
name|MTNOP
condition|)
block|{
name|mt_com
operator|.
name|mt_op
operator|=
name|comp
operator|->
name|c_code
expr_stmt|;
if|if
condition|(
operator|*
name|argv
condition|)
block|{
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
operator|*
name|argv
argument_list|)
operator|&&
operator|(
name|comp
operator|->
name|c_flags
operator|&
name|IS_DENSITY
operator|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|dcanon
decl_stmt|;
name|mt_com
operator|.
name|mt_count
operator|=
name|mt_density_num
argument_list|(
operator|*
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|mt_com
operator|.
name|mt_count
operator|==
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s: unknown density"
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
name|dcanon
operator|=
name|denstostring
argument_list|(
name|mt_com
operator|.
name|mt_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|dcanon
argument_list|,
operator|*
name|argv
argument_list|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"Using \"%s\" as an alias for %s\n"
argument_list|,
operator|*
name|argv
argument_list|,
name|dcanon
argument_list|)
expr_stmt|;
name|p
operator|=
literal|""
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
operator|*
name|argv
argument_list|)
operator|&&
operator|(
name|comp
operator|->
name|c_flags
operator|&
name|IS_COMP
operator|)
condition|)
block|{
name|mt_com
operator|.
name|mt_count
operator|=
name|stringtocomp
argument_list|(
operator|*
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|u_int32_t
operator|)
name|mt_com
operator|.
name|mt_count
operator|==
literal|0xf0f0f0f0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s: unknown compression"
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
name|p
operator|=
literal|""
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|comp
operator|->
name|c_flags
operator|&
name|USE_GETOPT
operator|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|q
decl_stmt|;
comment|/* allow for hex numbers; useful for density */
name|mt_com
operator|.
name|mt_count
operator|=
name|strtol
argument_list|(
operator|*
name|argv
argument_list|,
operator|&
name|q
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p
operator|=
name|q
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|(
name|comp
operator|->
name|c_flags
operator|&
name|USE_GETOPT
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
operator|(
name|mt_com
operator|.
name|mt_count
operator|<=
operator|(
operator|(
name|comp
operator|->
name|c_flags
operator|&
name|ZERO_ALLOWED
operator|)
condition|?
operator|-
literal|1
else|:
literal|0
operator|)
operator|)
operator|&&
operator|(
operator|(
name|comp
operator|->
name|c_flags
operator|&
name|IS_COMP
operator|)
operator|==
literal|0
operator|)
operator|)
operator|||
operator|*
name|p
operator|)
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s: illegal count"
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
block|}
else|else
name|mt_com
operator|.
name|mt_count
operator|=
literal|1
expr_stmt|;
switch|switch
condition|(
name|comp
operator|->
name|c_code
condition|)
block|{
case|case
name|MTIOCERRSTAT
case|:
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|union
name|mterrstat
name|umn
decl_stmt|;
name|struct
name|scsi_tape_errors
modifier|*
name|s
init|=
operator|&
name|umn
operator|.
name|scsi_errstat
decl_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|mtfd
argument_list|,
name|comp
operator|->
name|c_code
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|umn
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|2
argument_list|,
literal|"%s"
argument_list|,
name|tape
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"Last I/O Residual: %u\n"
argument_list|,
name|s
operator|->
name|io_resid
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|" Last I/O Command:"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|s
operator|->
name|io_cdb
argument_list|)
condition|;
name|i
operator|++
control|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|" %02X"
argument_list|,
name|s
operator|->
name|io_cdb
index|[
name|i
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"   Last I/O Sense:\n\n\t"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|s
operator|->
name|io_sense
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|" %02X"
argument_list|,
name|s
operator|->
name|io_sense
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|&
literal|0xf
operator|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n\t"
argument_list|)
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"Last Control Residual: %u\n"
argument_list|,
name|s
operator|->
name|ctl_resid
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|" Last Control Command:"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|s
operator|->
name|ctl_cdb
argument_list|)
condition|;
name|i
operator|++
control|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|" %02X"
argument_list|,
name|s
operator|->
name|ctl_cdb
index|[
name|i
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"   Last Control Sense:\n\n\t"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|s
operator|->
name|ctl_sense
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|" %02X"
argument_list|,
name|s
operator|->
name|ctl_sense
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|&
literal|0xf
operator|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n\t"
argument_list|)
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
case|case
name|MTIOCRDHPOS
case|:
case|case
name|MTIOCRDSPOS
case|:
block|{
name|u_int32_t
name|block
decl_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|mtfd
argument_list|,
name|comp
operator|->
name|c_code
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|block
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|2
argument_list|,
literal|"%s"
argument_list|,
name|tape
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: %s block location %u\n"
argument_list|,
name|tape
argument_list|,
operator|(
name|comp
operator|->
name|c_code
operator|==
name|MTIOCRDHPOS
operator|)
condition|?
literal|"hardware"
else|:
literal|"logical"
argument_list|,
name|block
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
case|case
name|MTIOCSLOCATE
case|:
case|case
name|MTIOCHLOCATE
case|:
block|{
name|u_int32_t
name|block
init|=
operator|(
name|u_int32_t
operator|)
name|mt_com
operator|.
name|mt_count
decl_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|mtfd
argument_list|,
name|comp
operator|->
name|c_code
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|block
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|2
argument_list|,
literal|"%s"
argument_list|,
name|tape
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
case|case
name|MTIOCGETEOTMODEL
case|:
block|{
name|u_int32_t
name|om
decl_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|mtfd
argument_list|,
name|MTIOCGETEOTMODEL
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|om
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|2
argument_list|,
literal|"%s"
argument_list|,
name|tape
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: the model is %u filemar%s at EOT\n"
argument_list|,
name|tape
argument_list|,
name|om
argument_list|,
operator|(
name|om
operator|>
literal|1
operator|)
condition|?
literal|"ks"
else|:
literal|"k"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
case|case
name|MTIOCSETEOTMODEL
case|:
block|{
name|u_int32_t
name|om
decl_stmt|,
name|nm
init|=
operator|(
name|u_int32_t
operator|)
name|mt_com
operator|.
name|mt_count
decl_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|mtfd
argument_list|,
name|MTIOCGETEOTMODEL
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|om
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|2
argument_list|,
literal|"%s"
argument_list|,
name|tape
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|mtfd
argument_list|,
name|comp
operator|->
name|c_code
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|nm
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|2
argument_list|,
literal|"%s"
argument_list|,
name|tape
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: old model was %u filemar%s at EOT\n"
argument_list|,
name|tape
argument_list|,
name|om
argument_list|,
operator|(
name|om
operator|>
literal|1
operator|)
condition|?
literal|"ks"
else|:
literal|"k"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: new model  is %u filemar%s at EOT\n"
argument_list|,
name|tape
argument_list|,
name|nm
argument_list|,
operator|(
name|nm
operator|>
literal|1
operator|)
condition|?
literal|"ks"
else|:
literal|"k"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
case|case
name|MTIOCRBLIM
case|:
block|{
name|struct
name|mtrblim
name|rblim
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|rblim
argument_list|,
sizeof|sizeof
argument_list|(
name|rblim
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|mtfd
argument_list|,
name|MTIOCRBLIM
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|rblim
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|2
argument_list|,
literal|"%s"
argument_list|,
name|tape
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: min blocksize %u bytes, "
literal|"max blocksize %u bytes, granularity %u bytes\n"
argument_list|,
name|tape
argument_list|,
name|rblim
operator|.
name|min_block_length
argument_list|,
name|rblim
operator|.
name|max_block_length
argument_list|,
name|rblim
operator|.
name|granularity
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
case|case
name|MTIOCPARAMGET
case|:
case|case
name|MTIOCEXTGET
case|:
case|case
name|MT_CMD_PROTECT
case|:
case|case
name|MT_CMD_GETDENSITY
case|:
block|{
name|int
name|retval
init|=
literal|0
decl_stmt|;
name|retval
operator|=
name|mt_xml_cmd
argument_list|(
name|comp
operator|->
name|c_code
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|mtfd
argument_list|,
name|tape
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|retval
argument_list|)
expr_stmt|;
block|}
case|case
name|MTIOCEXTLOCATE
case|:
block|{
name|int
name|retval
init|=
literal|0
decl_stmt|;
name|retval
operator|=
name|mt_locate
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|mtfd
argument_list|,
name|tape
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|retval
argument_list|)
expr_stmt|;
block|}
default|default:
break|break;
block|}
if|if
condition|(
name|ioctl
argument_list|(
name|mtfd
argument_list|,
name|MTIOCTOP
argument_list|,
operator|&
name|mt_com
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"%s: %s"
argument_list|,
name|tape
argument_list|,
name|comp
operator|->
name|c_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ioctl
argument_list|(
name|mtfd
argument_list|,
name|MTIOCGET
argument_list|,
operator|&
name|mt_status
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|status
argument_list|(
operator|&
name|mt_status
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

begin_struct
specifier|static
specifier|const
struct|struct
name|tape_desc
block|{
name|short
name|t_type
decl_stmt|;
comment|/* type of magtape device */
specifier|const
name|char
modifier|*
name|t_name
decl_stmt|;
comment|/* printing name */
specifier|const
name|char
modifier|*
name|t_dsbits
decl_stmt|;
comment|/* "drive status" register */
specifier|const
name|char
modifier|*
name|t_erbits
decl_stmt|;
comment|/* "error" register */
block|}
name|tapes
index|[]
init|=
block|{
block|{
name|MT_ISAR
block|,
literal|"SCSI tape drive"
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|}
struct|;
end_struct

begin_comment
comment|/*  * Interpret the status buffer returned  */
end_comment

begin_function
specifier|static
name|void
name|status
parameter_list|(
name|struct
name|mtget
modifier|*
name|bp
parameter_list|)
block|{
specifier|const
name|struct
name|tape_desc
modifier|*
name|mt
decl_stmt|;
for|for
control|(
name|mt
operator|=
name|tapes
init|;
condition|;
name|mt
operator|++
control|)
block|{
if|if
condition|(
name|mt
operator|->
name|t_type
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%d: unknown tape drive type\n"
argument_list|,
name|bp
operator|->
name|mt_type
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|mt
operator|->
name|t_type
operator|==
name|bp
operator|->
name|mt_type
condition|)
break|break;
block|}
if|if
condition|(
name|mt
operator|->
name|t_type
operator|==
name|MT_ISAR
condition|)
name|st_status
argument_list|(
name|bp
argument_list|)
expr_stmt|;
else|else
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s tape drive, residual=%d\n"
argument_list|,
name|mt
operator|->
name|t_name
argument_list|,
name|bp
operator|->
name|mt_resid
argument_list|)
expr_stmt|;
name|printreg
argument_list|(
literal|"ds"
argument_list|,
operator|(
name|unsigned
name|short
operator|)
name|bp
operator|->
name|mt_dsreg
argument_list|,
name|mt
operator|->
name|t_dsbits
argument_list|)
expr_stmt|;
name|printreg
argument_list|(
literal|"\ner"
argument_list|,
operator|(
name|unsigned
name|short
operator|)
name|bp
operator|->
name|mt_erreg
argument_list|,
name|mt
operator|->
name|t_erbits
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Print a register a la the %b format of the kernel's printf.  */
end_comment

begin_function
specifier|static
name|void
name|printreg
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|u_int
name|v
parameter_list|,
specifier|const
name|char
modifier|*
name|bits
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|any
init|=
literal|0
decl_stmt|;
name|char
name|c
decl_stmt|;
if|if
condition|(
name|bits
operator|&&
operator|*
name|bits
operator|==
literal|8
condition|)
name|printf
argument_list|(
literal|"%s=%o"
argument_list|,
name|s
argument_list|,
name|v
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%s=%x"
argument_list|,
name|s
argument_list|,
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bits
condition|)
return|return;
name|bits
operator|++
expr_stmt|;
if|if
condition|(
name|v
operator|&&
name|bits
condition|)
block|{
name|putchar
argument_list|(
literal|'<'
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|i
operator|=
operator|*
name|bits
operator|++
operator|)
condition|)
block|{
if|if
condition|(
name|v
operator|&
operator|(
literal|1
operator|<<
operator|(
name|i
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|any
condition|)
name|putchar
argument_list|(
literal|','
argument_list|)
expr_stmt|;
name|any
operator|=
literal|1
expr_stmt|;
for|for
control|(
init|;
operator|(
name|c
operator|=
operator|*
name|bits
operator|)
operator|>
literal|32
condition|;
name|bits
operator|++
control|)
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
else|else
for|for
control|(
init|;
operator|*
name|bits
operator|>
literal|32
condition|;
name|bits
operator|++
control|)
empty_stmt|;
block|}
name|putchar
argument_list|(
literal|'>'
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: mt [-f device] command [count]\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_struct
specifier|static
specifier|const
struct|struct
name|compression_types
block|{
name|u_int32_t
name|comp_number
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|}
name|comp_types
index|[]
init|=
block|{
block|{
literal|0x00
block|,
literal|"none"
block|}
block|,
block|{
literal|0x00
block|,
literal|"off"
block|}
block|,
block|{
literal|0x10
block|,
literal|"IDRC"
block|}
block|,
block|{
literal|0x20
block|,
literal|"DCLZ"
block|}
block|,
block|{
literal|0xffffffff
block|,
literal|"enable"
block|}
block|,
block|{
literal|0xffffffff
block|,
literal|"on"
block|}
block|,
block|{
literal|0xf0f0f0f0
block|,
name|NULL
block|}
block|}
struct|;
end_struct

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|denstostring
parameter_list|(
name|int
name|d
parameter_list|)
block|{
specifier|static
name|char
name|buf
index|[
literal|20
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
init|=
name|mt_density_name
argument_list|(
name|d
argument_list|)
decl_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"0x%02x"
argument_list|,
name|d
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"0x%02x:%s"
argument_list|,
name|d
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|getblksiz
parameter_list|(
name|int
name|bs
parameter_list|)
block|{
specifier|static
name|char
name|buf
index|[
literal|25
index|]
decl_stmt|;
if|if
condition|(
name|bs
operator|==
literal|0
condition|)
return|return
literal|"variable"
return|;
else|else
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d bytes"
argument_list|,
name|bs
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|comptostring
parameter_list|(
name|u_int32_t
name|comp
parameter_list|)
block|{
specifier|static
name|char
name|buf
index|[
literal|20
index|]
decl_stmt|;
specifier|const
name|struct
name|compression_types
modifier|*
name|ct
decl_stmt|;
if|if
condition|(
name|comp
operator|==
name|MT_COMP_DISABLED
condition|)
return|return
literal|"disabled"
return|;
elseif|else
if|if
condition|(
name|comp
operator|==
name|MT_COMP_UNSUPP
condition|)
return|return
literal|"unsupported"
return|;
for|for
control|(
name|ct
operator|=
name|comp_types
init|;
name|ct
operator|->
name|name
condition|;
name|ct
operator|++
control|)
if|if
condition|(
name|ct
operator|->
name|comp_number
operator|==
name|comp
condition|)
break|break;
if|if
condition|(
name|ct
operator|->
name|comp_number
operator|==
literal|0xf0f0f0f0
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"0x%x"
argument_list|,
name|comp
argument_list|)
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
else|else
return|return
operator|(
name|ct
operator|->
name|name
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|u_int32_t
name|stringtocomp
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
specifier|const
name|struct
name|compression_types
modifier|*
name|ct
decl_stmt|;
name|size_t
name|l
init|=
name|strlen
argument_list|(
name|s
argument_list|)
decl_stmt|;
for|for
control|(
name|ct
operator|=
name|comp_types
init|;
name|ct
operator|->
name|name
condition|;
name|ct
operator|++
control|)
if|if
condition|(
name|strncasecmp
argument_list|(
name|ct
operator|->
name|name
argument_list|,
name|s
argument_list|,
name|l
argument_list|)
operator|==
literal|0
condition|)
break|break;
return|return
operator|(
name|ct
operator|->
name|comp_number
operator|)
return|;
block|}
end_function

begin_struct
specifier|static
struct|struct
name|driver_state
block|{
name|int
name|dsreg
decl_stmt|;
specifier|const
name|char
modifier|*
name|desc
decl_stmt|;
block|}
name|driver_states
index|[]
init|=
block|{
block|{
name|MTIO_DSREG_REST
block|,
literal|"at rest"
block|}
block|,
block|{
name|MTIO_DSREG_RBSY
block|,
literal|"Communicating with drive"
block|}
block|,
block|{
name|MTIO_DSREG_WR
block|,
literal|"Writing"
block|}
block|,
block|{
name|MTIO_DSREG_FMK
block|,
literal|"Writing Filemarks"
block|}
block|,
block|{
name|MTIO_DSREG_ZER
block|,
literal|"Erasing"
block|}
block|,
block|{
name|MTIO_DSREG_RD
block|,
literal|"Reading"
block|}
block|,
block|{
name|MTIO_DSREG_FWD
block|,
literal|"Spacing Forward"
block|}
block|,
block|{
name|MTIO_DSREG_REV
block|,
literal|"Spacing Reverse"
block|}
block|,
block|{
name|MTIO_DSREG_POS
block|,
literal|"Hardware Positioning (direction unknown)"
block|}
block|,
block|{
name|MTIO_DSREG_REW
block|,
literal|"Rewinding"
block|}
block|,
block|{
name|MTIO_DSREG_TEN
block|,
literal|"Retensioning"
block|}
block|,
block|{
name|MTIO_DSREG_UNL
block|,
literal|"Unloading"
block|}
block|,
block|{
name|MTIO_DSREG_LD
block|,
literal|"Loading"
block|}
block|, }
struct|;
end_struct

begin_function
specifier|const
name|char
modifier|*
name|get_driver_state_str
parameter_list|(
name|int
name|dsreg
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
sizeof|sizeof
argument_list|(
name|driver_states
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|driver_states
index|[
literal|0
index|]
argument_list|)
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|driver_states
index|[
name|i
index|]
operator|.
name|dsreg
operator|==
name|dsreg
condition|)
return|return
operator|(
name|driver_states
index|[
name|i
index|]
operator|.
name|desc
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|st_status
parameter_list|(
name|struct
name|mtget
modifier|*
name|bp
parameter_list|)
block|{
name|printf
argument_list|(
literal|"Mode      Density              Blocksize      bpi      "
literal|"Compression\n"
literal|"Current:  %-17s    %-12s   %-7d  %s\n"
literal|"---------available modes---------\n"
literal|"0:        %-17s    %-12s   %-7d  %s\n"
literal|"1:        %-17s    %-12s   %-7d  %s\n"
literal|"2:        %-17s    %-12s   %-7d  %s\n"
literal|"3:        %-17s    %-12s   %-7d  %s\n"
argument_list|,
name|denstostring
argument_list|(
name|bp
operator|->
name|mt_density
argument_list|)
argument_list|,
name|getblksiz
argument_list|(
name|bp
operator|->
name|mt_blksiz
argument_list|)
argument_list|,
name|mt_density_bp
argument_list|(
name|bp
operator|->
name|mt_density
argument_list|,
name|TRUE
argument_list|)
argument_list|,
name|comptostring
argument_list|(
name|bp
operator|->
name|mt_comp
argument_list|)
argument_list|,
name|denstostring
argument_list|(
name|bp
operator|->
name|mt_density0
argument_list|)
argument_list|,
name|getblksiz
argument_list|(
name|bp
operator|->
name|mt_blksiz0
argument_list|)
argument_list|,
name|mt_density_bp
argument_list|(
name|bp
operator|->
name|mt_density0
argument_list|,
name|TRUE
argument_list|)
argument_list|,
name|comptostring
argument_list|(
name|bp
operator|->
name|mt_comp0
argument_list|)
argument_list|,
name|denstostring
argument_list|(
name|bp
operator|->
name|mt_density1
argument_list|)
argument_list|,
name|getblksiz
argument_list|(
name|bp
operator|->
name|mt_blksiz1
argument_list|)
argument_list|,
name|mt_density_bp
argument_list|(
name|bp
operator|->
name|mt_density1
argument_list|,
name|TRUE
argument_list|)
argument_list|,
name|comptostring
argument_list|(
name|bp
operator|->
name|mt_comp1
argument_list|)
argument_list|,
name|denstostring
argument_list|(
name|bp
operator|->
name|mt_density2
argument_list|)
argument_list|,
name|getblksiz
argument_list|(
name|bp
operator|->
name|mt_blksiz2
argument_list|)
argument_list|,
name|mt_density_bp
argument_list|(
name|bp
operator|->
name|mt_density2
argument_list|,
name|TRUE
argument_list|)
argument_list|,
name|comptostring
argument_list|(
name|bp
operator|->
name|mt_comp2
argument_list|)
argument_list|,
name|denstostring
argument_list|(
name|bp
operator|->
name|mt_density3
argument_list|)
argument_list|,
name|getblksiz
argument_list|(
name|bp
operator|->
name|mt_blksiz3
argument_list|)
argument_list|,
name|mt_density_bp
argument_list|(
name|bp
operator|->
name|mt_density3
argument_list|,
name|TRUE
argument_list|)
argument_list|,
name|comptostring
argument_list|(
name|bp
operator|->
name|mt_comp3
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|mt_dsreg
operator|!=
name|MTIO_DSREG_NIL
condition|)
block|{
specifier|const
name|char
name|sfmt
index|[]
init|=
literal|"Current Driver State: %s.\n"
decl_stmt|;
name|printf
argument_list|(
literal|"---------------------------------\n"
argument_list|)
expr_stmt|;
specifier|const
name|char
modifier|*
name|state_str
decl_stmt|;
name|state_str
operator|=
name|get_driver_state_str
argument_list|(
name|bp
operator|->
name|mt_dsreg
argument_list|)
expr_stmt|;
if|if
condition|(
name|state_str
operator|==
name|NULL
condition|)
block|{
name|char
name|foo
index|[
literal|32
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|foo
argument_list|,
literal|"Unknown state 0x%x"
argument_list|,
name|bp
operator|->
name|mt_dsreg
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|sfmt
argument_list|,
name|foo
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
name|sfmt
argument_list|,
name|state_str
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|bp
operator|->
name|mt_resid
operator|==
literal|0
operator|&&
name|bp
operator|->
name|mt_fileno
operator|==
operator|(
name|daddr_t
operator|)
operator|-
literal|1
operator|&&
name|bp
operator|->
name|mt_blkno
operator|==
operator|(
name|daddr_t
operator|)
operator|-
literal|1
condition|)
return|return;
name|printf
argument_list|(
literal|"---------------------------------\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"File Number: %d\tRecord Number: %d\tResidual Count %d\n"
argument_list|,
name|bp
operator|->
name|mt_fileno
argument_list|,
name|bp
operator|->
name|mt_blkno
argument_list|,
name|bp
operator|->
name|mt_resid
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|mt_locate
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|int
name|mtfd
parameter_list|,
specifier|const
name|char
modifier|*
name|tape
parameter_list|)
block|{
name|struct
name|mtlocate
name|mtl
decl_stmt|;
name|uint64_t
name|logical_id
init|=
literal|0
decl_stmt|;
name|mt_locate_dest_type
name|dest_type
init|=
name|MT_LOCATE_DEST_FILE
decl_stmt|;
name|int
name|eod
init|=
literal|0
decl_stmt|,
name|explicit
init|=
literal|0
decl_stmt|,
name|immediate
init|=
literal|0
decl_stmt|;
name|int64_t
name|partition
init|=
literal|0
decl_stmt|;
name|int
name|block_addr_set
init|=
literal|0
decl_stmt|,
name|partition_set
init|=
literal|0
decl_stmt|,
name|file_set
init|=
literal|0
decl_stmt|,
name|set_set
init|=
literal|0
decl_stmt|;
name|int
name|c
decl_stmt|,
name|retval
decl_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|mtl
argument_list|,
sizeof|sizeof
argument_list|(
name|mtl
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"b:eEf:ip:s:"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'b'
case|:
comment|/* Block address */
name|logical_id
operator|=
name|strtoull
argument_list|(
name|optarg
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dest_type
operator|=
name|MT_LOCATE_DEST_OBJECT
expr_stmt|;
name|block_addr_set
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
comment|/* end of data */
name|eod
operator|=
literal|1
expr_stmt|;
name|dest_type
operator|=
name|MT_LOCATE_DEST_EOD
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
comment|/* 			 * XXX KDM explicit address mode.  Should we even 			 * allow this, since the driver doesn't operate in 			 * explicit address mode? 			 */
name|explicit
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
comment|/* file number */
name|logical_id
operator|=
name|strtoull
argument_list|(
name|optarg
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dest_type
operator|=
name|MT_LOCATE_DEST_FILE
expr_stmt|;
name|file_set
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
comment|/* 			 * Immediate address mode.  XXX KDM do we want to 			 * implement this?  The other commands in the 			 * tape driver will need to be able to handle this. 			 */
name|immediate
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
comment|/* 			 * Change partition to the given partition. 			 */
name|partition
operator|=
name|strtol
argument_list|(
name|optarg
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|partition_set
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* Go to the given set mark */
name|logical_id
operator|=
name|strtoull
argument_list|(
name|optarg
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dest_type
operator|=
name|MT_LOCATE_DEST_SET
expr_stmt|;
name|set_set
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
comment|/* 	 * These options are mutually exclusive.  The user may only specify 	 * one. 	 */
if|if
condition|(
operator|(
name|block_addr_set
operator|+
name|file_set
operator|+
name|eod
operator|+
name|set_set
operator|)
operator|!=
literal|1
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"You must specify only one of -b, -f, -e, or -s"
argument_list|)
expr_stmt|;
name|mtl
operator|.
name|dest_type
operator|=
name|dest_type
expr_stmt|;
switch|switch
condition|(
name|dest_type
condition|)
block|{
case|case
name|MT_LOCATE_DEST_OBJECT
case|:
case|case
name|MT_LOCATE_DEST_FILE
case|:
case|case
name|MT_LOCATE_DEST_SET
case|:
name|mtl
operator|.
name|logical_id
operator|=
name|logical_id
expr_stmt|;
break|break;
case|case
name|MT_LOCATE_DEST_EOD
case|:
break|break;
block|}
if|if
condition|(
name|immediate
operator|!=
literal|0
condition|)
name|mtl
operator|.
name|flags
operator||=
name|MT_LOCATE_FLAG_IMMED
expr_stmt|;
if|if
condition|(
name|partition_set
operator|!=
literal|0
condition|)
block|{
name|mtl
operator|.
name|flags
operator||=
name|MT_LOCATE_FLAG_CHANGE_PART
expr_stmt|;
name|mtl
operator|.
name|partition
operator|=
name|partition
expr_stmt|;
block|}
if|if
condition|(
name|explicit
operator|!=
literal|0
condition|)
name|mtl
operator|.
name|block_address_mode
operator|=
name|MT_LOCATE_BAM_EXPLICIT
expr_stmt|;
else|else
name|mtl
operator|.
name|block_address_mode
operator|=
name|MT_LOCATE_BAM_IMPLICIT
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|mtfd
argument_list|,
name|MTIOCEXTLOCATE
argument_list|,
operator|&
name|mtl
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"MTIOCEXTLOCATE ioctl failed on %s"
argument_list|,
name|tape
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_typedef
typedef|typedef
enum|enum
block|{
name|MT_PERIPH_NAME
init|=
literal|0
block|,
name|MT_UNIT_NUMBER
init|=
literal|1
block|,
name|MT_VENDOR
init|=
literal|2
block|,
name|MT_PRODUCT
init|=
literal|3
block|,
name|MT_REVISION
init|=
literal|4
block|,
name|MT_COMPRESSION_SUPPORTED
init|=
literal|5
block|,
name|MT_COMPRESSION_ENABLED
init|=
literal|6
block|,
name|MT_COMPRESSION_ALGORITHM
init|=
literal|7
block|,
name|MT_MEDIA_DENSITY
init|=
literal|8
block|,
name|MT_MEDIA_BLOCKSIZE
init|=
literal|9
block|,
name|MT_CALCULATED_FILENO
init|=
literal|10
block|,
name|MT_CALCULATED_REL_BLKNO
init|=
literal|11
block|,
name|MT_REPORTED_FILENO
init|=
literal|12
block|,
name|MT_REPORTED_BLKNO
init|=
literal|13
block|,
name|MT_PARTITION
init|=
literal|14
block|,
name|MT_BOP
init|=
literal|15
block|,
name|MT_EOP
init|=
literal|16
block|,
name|MT_BPEW
init|=
literal|17
block|,
name|MT_DSREG
init|=
literal|18
block|,
name|MT_RESID
init|=
literal|19
block|,
name|MT_FIXED_MODE
init|=
literal|20
block|,
name|MT_SERIAL_NUM
init|=
literal|21
block|,
name|MT_MAXIO
init|=
literal|22
block|,
name|MT_CPI_MAXIO
init|=
literal|23
block|,
name|MT_MAX_BLK
init|=
literal|24
block|,
name|MT_MIN_BLK
init|=
literal|25
block|,
name|MT_BLK_GRAN
init|=
literal|26
block|,
name|MT_MAX_EFF_IOSIZE
init|=
literal|27
block|}
name|status_item_index
typedef|;
end_typedef

begin_struct
specifier|static
struct|struct
name|mt_status_items
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|mt_status_entry
modifier|*
name|entry
decl_stmt|;
block|}
name|req_status_items
index|[]
init|=
block|{
block|{
literal|"periph_name"
block|,
name|NULL
block|}
block|,
block|{
literal|"unit_number"
block|,
name|NULL
block|}
block|,
block|{
literal|"vendor"
block|,
name|NULL
block|}
block|,
block|{
literal|"product"
block|,
name|NULL
block|}
block|,
block|{
literal|"revision"
block|,
name|NULL
block|}
block|,
block|{
literal|"compression_supported"
block|,
name|NULL
block|}
block|,
block|{
literal|"compression_enabled"
block|,
name|NULL
block|}
block|,
block|{
literal|"compression_algorithm"
block|,
name|NULL
block|}
block|,
block|{
literal|"media_density"
block|,
name|NULL
block|}
block|,
block|{
literal|"media_blocksize"
block|,
name|NULL
block|}
block|,
block|{
literal|"calculated_fileno"
block|,
name|NULL
block|}
block|,
block|{
literal|"calculated_rel_blkno"
block|,
name|NULL
block|}
block|,
block|{
literal|"reported_fileno"
block|,
name|NULL
block|}
block|,
block|{
literal|"reported_blkno"
block|,
name|NULL
block|}
block|,
block|{
literal|"partition"
block|,
name|NULL
block|}
block|,
block|{
literal|"bop"
block|,
name|NULL
block|}
block|,
block|{
literal|"eop"
block|,
name|NULL
block|}
block|,
block|{
literal|"bpew"
block|,
name|NULL
block|}
block|,
block|{
literal|"dsreg"
block|,
name|NULL
block|}
block|,
block|{
literal|"residual"
block|,
name|NULL
block|}
block|,
block|{
literal|"fixed_mode"
block|,
name|NULL
block|}
block|,
block|{
literal|"serial_num"
block|,
name|NULL
block|}
block|,
block|{
literal|"maxio"
block|,
name|NULL
block|}
block|,
block|{
literal|"cpi_maxio"
block|,
name|NULL
block|}
block|,
block|{
literal|"max_blk"
block|,
name|NULL
block|}
block|,
block|{
literal|"min_blk"
block|,
name|NULL
block|}
block|,
block|{
literal|"blk_gran"
block|,
name|NULL
block|}
block|,
block|{
literal|"max_effective_iosize"
block|,
name|NULL
block|}
block|}
struct|;
end_struct

begin_function
name|int
name|nstatus_print
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|char
modifier|*
name|xml_str
parameter_list|,
name|struct
name|mt_status_data
modifier|*
name|status_data
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|int64_t
name|calculated_fileno
decl_stmt|,
name|calculated_rel_blkno
decl_stmt|;
name|int64_t
name|rep_fileno
decl_stmt|,
name|rep_blkno
decl_stmt|,
name|partition
decl_stmt|,
name|resid
decl_stmt|;
name|char
name|block_str
index|[
literal|32
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|dens_str
decl_stmt|;
name|int
name|dsreg
decl_stmt|,
name|bop
decl_stmt|,
name|eop
decl_stmt|,
name|bpew
decl_stmt|;
name|int
name|xml_dump
init|=
literal|0
decl_stmt|;
name|size_t
name|dens_len
decl_stmt|;
name|unsigned
name|int
name|field_width
decl_stmt|;
name|int
name|verbose
init|=
literal|0
decl_stmt|;
name|int
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"xv"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'x'
case|:
name|xml_dump
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|verbose
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
if|if
condition|(
name|xml_dump
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|xml_str
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
sizeof|sizeof
argument_list|(
name|req_status_items
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|req_status_items
index|[
literal|0
index|]
argument_list|)
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
name|__DECONST
argument_list|(
name|char
operator|*
argument_list|,
name|req_status_items
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|req_status_items
index|[
name|i
index|]
operator|.
name|entry
operator|=
name|mt_status_entry_find
argument_list|(
name|status_data
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|req_status_items
index|[
name|i
index|]
operator|.
name|entry
operator|==
name|NULL
condition|)
block|{
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Cannot find status entry %s"
argument_list|,
name|req_status_items
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"Drive: %s%ju:<%s %s %s> Serial Number: %s\n"
argument_list|,
name|req_status_items
index|[
name|MT_PERIPH_NAME
index|]
operator|.
name|entry
operator|->
name|value
argument_list|,
operator|(
name|uintmax_t
operator|)
name|req_status_items
index|[
name|MT_UNIT_NUMBER
index|]
operator|.
name|entry
operator|->
name|value_unsigned
argument_list|,
name|req_status_items
index|[
name|MT_VENDOR
index|]
operator|.
name|entry
operator|->
name|value
argument_list|,
name|req_status_items
index|[
name|MT_PRODUCT
index|]
operator|.
name|entry
operator|->
name|value
argument_list|,
name|req_status_items
index|[
name|MT_REVISION
index|]
operator|.
name|entry
operator|->
name|value
argument_list|,
operator|(
name|req_status_items
index|[
name|MT_SERIAL_NUM
index|]
operator|.
name|entry
operator|->
name|value
operator|)
condition|?
name|req_status_items
index|[
name|MT_SERIAL_NUM
index|]
operator|.
name|entry
operator|->
name|value
else|:
literal|"none"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"---------------------------------\n"
argument_list|)
expr_stmt|;
comment|/* 	 * We check to see whether we're in fixed mode or not, and don't 	 * just believe the blocksize.  If the SILI bit is turned on, the 	 * blocksize will be set to 4, even though we're doing variable 	 * length (well, multiples of 4) blocks. 	 */
if|if
condition|(
name|req_status_items
index|[
name|MT_FIXED_MODE
index|]
operator|.
name|entry
operator|->
name|value_signed
operator|==
literal|0
condition|)
name|snprintf
argument_list|(
name|block_str
argument_list|,
sizeof|sizeof
argument_list|(
name|block_str
argument_list|)
argument_list|,
literal|"variable"
argument_list|)
expr_stmt|;
else|else
name|snprintf
argument_list|(
name|block_str
argument_list|,
sizeof|sizeof
argument_list|(
name|block_str
argument_list|)
argument_list|,
literal|"%s"
argument_list|,
name|getblksiz
argument_list|(
name|req_status_items
index|[
name|MT_MEDIA_BLOCKSIZE
index|]
operator|.
name|entry
operator|->
name|value_unsigned
argument_list|)
argument_list|)
expr_stmt|;
name|dens_str
operator|=
name|denstostring
argument_list|(
name|req_status_items
index|[
name|MT_MEDIA_DENSITY
index|]
operator|.
name|entry
operator|->
name|value_unsigned
argument_list|)
expr_stmt|;
if|if
condition|(
name|dens_str
operator|==
name|NULL
condition|)
name|dens_len
operator|=
literal|0
expr_stmt|;
else|else
name|dens_len
operator|=
name|strlen
argument_list|(
name|dens_str
argument_list|)
expr_stmt|;
name|field_width
operator|=
name|MAX
argument_list|(
name|dens_len
argument_list|,
literal|17
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Mode      %-*s    Blocksize      bpi      Compression\n"
literal|"Current:  %-*s    %-12s   %-7d  "
argument_list|,
name|field_width
argument_list|,
literal|"Density"
argument_list|,
name|field_width
argument_list|,
name|dens_str
argument_list|,
name|block_str
argument_list|,
name|mt_density_bp
argument_list|(
name|req_status_items
index|[
name|MT_MEDIA_DENSITY
index|]
operator|.
name|entry
operator|->
name|value_unsigned
argument_list|,
name|TRUE
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|req_status_items
index|[
name|MT_COMPRESSION_SUPPORTED
index|]
operator|.
name|entry
operator|->
name|value_signed
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"unsupported\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|req_status_items
index|[
name|MT_COMPRESSION_ENABLED
index|]
operator|.
name|entry
operator|->
name|value_signed
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"disabled\n"
argument_list|)
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
literal|"enabled (%s)\n"
argument_list|,
name|comptostring
argument_list|(
name|req_status_items
index|[
name|MT_COMPRESSION_ALGORITHM
index|]
operator|.
name|entry
operator|->
name|value_unsigned
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dsreg
operator|=
name|req_status_items
index|[
name|MT_DSREG
index|]
operator|.
name|entry
operator|->
name|value_signed
expr_stmt|;
if|if
condition|(
name|dsreg
operator|!=
name|MTIO_DSREG_NIL
condition|)
block|{
specifier|const
name|char
name|sfmt
index|[]
init|=
literal|"Current Driver State: %s.\n"
decl_stmt|;
name|printf
argument_list|(
literal|"---------------------------------\n"
argument_list|)
expr_stmt|;
specifier|const
name|char
modifier|*
name|state_str
decl_stmt|;
name|state_str
operator|=
name|get_driver_state_str
argument_list|(
name|dsreg
argument_list|)
expr_stmt|;
if|if
condition|(
name|state_str
operator|==
name|NULL
condition|)
block|{
name|char
name|foo
index|[
literal|32
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|foo
argument_list|,
literal|"Unknown state 0x%x"
argument_list|,
name|dsreg
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|sfmt
argument_list|,
name|foo
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
name|sfmt
argument_list|,
name|state_str
argument_list|)
expr_stmt|;
block|}
block|}
name|resid
operator|=
name|req_status_items
index|[
name|MT_RESID
index|]
operator|.
name|entry
operator|->
name|value_signed
expr_stmt|;
name|calculated_fileno
operator|=
name|req_status_items
index|[
name|MT_CALCULATED_FILENO
index|]
operator|.
name|entry
operator|->
name|value_signed
expr_stmt|;
name|calculated_rel_blkno
operator|=
name|req_status_items
index|[
name|MT_CALCULATED_REL_BLKNO
index|]
operator|.
name|entry
operator|->
name|value_signed
expr_stmt|;
name|rep_fileno
operator|=
name|req_status_items
index|[
name|MT_REPORTED_FILENO
index|]
operator|.
name|entry
operator|->
name|value_signed
expr_stmt|;
name|rep_blkno
operator|=
name|req_status_items
index|[
name|MT_REPORTED_BLKNO
index|]
operator|.
name|entry
operator|->
name|value_signed
expr_stmt|;
name|bop
operator|=
name|req_status_items
index|[
name|MT_BOP
index|]
operator|.
name|entry
operator|->
name|value_signed
expr_stmt|;
name|eop
operator|=
name|req_status_items
index|[
name|MT_EOP
index|]
operator|.
name|entry
operator|->
name|value_signed
expr_stmt|;
name|bpew
operator|=
name|req_status_items
index|[
name|MT_BPEW
index|]
operator|.
name|entry
operator|->
name|value_signed
expr_stmt|;
name|partition
operator|=
name|req_status_items
index|[
name|MT_PARTITION
index|]
operator|.
name|entry
operator|->
name|value_signed
expr_stmt|;
name|printf
argument_list|(
literal|"---------------------------------\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Partition: %3jd      Calc File Number: %3jd "
literal|"    Calc Record Number: %jd\n"
literal|"Residual:  %3jd  Reported File Number: %3jd "
literal|"Reported Record Number: %jd\n"
argument_list|,
name|partition
argument_list|,
name|calculated_fileno
argument_list|,
name|calculated_rel_blkno
argument_list|,
name|resid
argument_list|,
name|rep_fileno
argument_list|,
name|rep_blkno
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Flags: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|bop
operator|>
literal|0
operator|||
name|eop
operator|>
literal|0
operator|||
name|bpew
operator|>
literal|0
condition|)
block|{
name|int
name|need_comma
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|bop
operator|>
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"BOP"
argument_list|)
expr_stmt|;
name|need_comma
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|eop
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|need_comma
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|","
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"EOP"
argument_list|)
expr_stmt|;
name|need_comma
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|bpew
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|need_comma
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|","
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"BPEW"
argument_list|)
expr_stmt|;
name|need_comma
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|printf
argument_list|(
literal|"None"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"---------------------------------\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Tape I/O parameters:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|MT_MAXIO
init|;
name|i
operator|<=
name|MT_MAX_EFF_IOSIZE
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"  %s (%s): %ju bytes\n"
argument_list|,
name|req_status_items
index|[
name|i
index|]
operator|.
name|entry
operator|->
name|desc
argument_list|,
name|req_status_items
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|req_status_items
index|[
name|i
index|]
operator|.
name|entry
operator|->
name|value_unsigned
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|mt_xml_cmd
parameter_list|(
name|unsigned
name|long
name|cmd
parameter_list|,
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|int
name|mtfd
parameter_list|,
specifier|const
name|char
modifier|*
name|tape
parameter_list|)
block|{
name|struct
name|mt_status_data
name|status_data
decl_stmt|;
if|#
directive|if
literal|0
block|struct mt_status_entry *entry;
endif|#
directive|endif
name|char
modifier|*
name|xml_str
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|unsigned
name|long
name|ioctl_cmd
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|MT_CMD_PROTECT
case|:
case|case
name|MTIOCPARAMGET
case|:
name|ioctl_cmd
operator|=
name|MTIOCPARAMGET
expr_stmt|;
break|break;
default|default:
name|ioctl_cmd
operator|=
name|MTIOCEXTGET
expr_stmt|;
break|break;
block|}
name|retval
operator|=
name|mt_get_xml_str
argument_list|(
name|mtfd
argument_list|,
name|ioctl_cmd
argument_list|,
operator|&
name|xml_str
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"Couldn't get mt XML string"
argument_list|)
expr_stmt|;
name|retval
operator|=
name|mt_get_status
argument_list|(
name|xml_str
argument_list|,
operator|&
name|status_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
name|XML_STATUS_OK
condition|)
block|{
name|warn
argument_list|(
literal|"Couldn't get mt status for %s"
argument_list|,
name|tape
argument_list|)
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
comment|/* 	 * This gets set if there are memory allocation or other errors in 	 * our parsing of the XML.  	 */
if|if
condition|(
name|status_data
operator|.
name|error
operator|!=
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"%s"
argument_list|,
name|status_data
operator|.
name|error_str
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
if|#
directive|if
literal|0
block|STAILQ_FOREACH(entry,&status_data.entries, links) 		mt_status_tree_print(entry, 0, NULL);
endif|#
directive|endif
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|MTIOCEXTGET
case|:
name|retval
operator|=
name|nstatus_print
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|xml_str
argument_list|,
operator|&
name|status_data
argument_list|)
expr_stmt|;
break|break;
case|case
name|MTIOCPARAMGET
case|:
name|retval
operator|=
name|mt_param
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|mtfd
argument_list|,
name|xml_str
argument_list|,
operator|&
name|status_data
argument_list|)
expr_stmt|;
break|break;
case|case
name|MT_CMD_PROTECT
case|:
name|retval
operator|=
name|mt_protect
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|mtfd
argument_list|,
operator|&
name|status_data
argument_list|)
expr_stmt|;
break|break;
case|case
name|MT_CMD_GETDENSITY
case|:
name|retval
operator|=
name|mt_getdensity
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|xml_str
argument_list|,
operator|&
name|status_data
argument_list|)
expr_stmt|;
break|break;
block|}
name|bailout
label|:
if|if
condition|(
name|xml_str
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|xml_str
argument_list|)
expr_stmt|;
name|mt_status_free
argument_list|(
operator|&
name|status_data
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mt_set_param
parameter_list|(
name|int
name|mtfd
parameter_list|,
name|struct
name|mt_status_data
modifier|*
name|status_data
parameter_list|,
name|char
modifier|*
name|param_name
parameter_list|,
name|char
modifier|*
name|param_value
parameter_list|)
block|{
name|struct
name|mt_status_entry
modifier|*
name|entry
decl_stmt|;
name|struct
name|mtparamset
name|param_set
decl_stmt|;
name|entry
operator|=
name|mt_status_entry_find
argument_list|(
name|status_data
argument_list|,
name|__DECONST
argument_list|(
name|char
operator|*
argument_list|,
literal|"mtparamget"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Cannot find parameter root node"
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|param_set
argument_list|,
sizeof|sizeof
argument_list|(
name|param_set
argument_list|)
argument_list|)
expr_stmt|;
name|entry
operator|=
name|mt_entry_find
argument_list|(
name|entry
argument_list|,
name|param_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Unknown parameter name \"%s\""
argument_list|,
name|param_name
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|param_set
operator|.
name|value_name
argument_list|,
name|param_name
argument_list|,
sizeof|sizeof
argument_list|(
name|param_set
operator|.
name|value_name
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|entry
operator|->
name|var_type
condition|)
block|{
case|case
name|MT_TYPE_INT
case|:
name|param_set
operator|.
name|value
operator|.
name|value_signed
operator|=
name|strtoll
argument_list|(
name|param_value
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|param_set
operator|.
name|value_type
operator|=
name|MT_PARAM_SET_SIGNED
expr_stmt|;
name|param_set
operator|.
name|value_len
operator|=
name|entry
operator|->
name|size
expr_stmt|;
break|break;
case|case
name|MT_TYPE_UINT
case|:
name|param_set
operator|.
name|value
operator|.
name|value_unsigned
operator|=
name|strtoull
argument_list|(
name|param_value
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|param_set
operator|.
name|value_type
operator|=
name|MT_PARAM_SET_UNSIGNED
expr_stmt|;
name|param_set
operator|.
name|value_len
operator|=
name|entry
operator|->
name|size
expr_stmt|;
break|break;
case|case
name|MT_TYPE_STRING
case|:
block|{
name|size_t
name|param_len
decl_stmt|;
name|param_len
operator|=
name|strlen
argument_list|(
name|param_value
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|param_len
operator|>
sizeof|sizeof
argument_list|(
name|param_set
operator|.
name|value
operator|.
name|value_fixed_str
argument_list|)
condition|)
block|{
name|param_set
operator|.
name|value_type
operator|=
name|MT_PARAM_SET_VAR_STR
expr_stmt|;
name|param_set
operator|.
name|value
operator|.
name|value_var_str
operator|=
name|param_value
expr_stmt|;
block|}
else|else
block|{
name|param_set
operator|.
name|value_type
operator|=
name|MT_PARAM_SET_FIXED_STR
expr_stmt|;
name|strlcpy
argument_list|(
name|param_set
operator|.
name|value
operator|.
name|value_fixed_str
argument_list|,
name|param_value
argument_list|,
sizeof|sizeof
argument_list|(
name|param_set
operator|.
name|value
operator|.
name|value_fixed_str
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|param_set
operator|.
name|value_len
operator|=
name|param_len
expr_stmt|;
break|break;
block|}
default|default:
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Unknown parameter type %d for %s"
argument_list|,
name|entry
operator|->
name|var_type
argument_list|,
name|param_name
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ioctl
argument_list|(
name|mtfd
argument_list|,
name|MTIOCPARAMSET
argument_list|,
operator|&
name|param_set
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"MTIOCPARAMSET"
argument_list|)
expr_stmt|;
if|if
condition|(
name|param_set
operator|.
name|status
operator|!=
name|MT_PARAM_STATUS_OK
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Failed to set %s: %s"
argument_list|,
name|param_name
argument_list|,
name|param_set
operator|.
name|error_str
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_typedef
typedef|typedef
enum|enum
block|{
name|MT_PP_LBP_R
block|,
name|MT_PP_LBP_W
block|,
name|MT_PP_RBDP
block|,
name|MT_PP_PI_LENGTH
block|,
name|MT_PP_PROT_METHOD
block|}
name|mt_protect_param
typedef|;
end_typedef

begin_struct
specifier|static
struct|struct
name|mt_protect_info
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|mt_status_entry
modifier|*
name|entry
decl_stmt|;
name|uint32_t
name|value
decl_stmt|;
block|}
name|mt_protect_list
index|[]
init|=
block|{
block|{
literal|"lbp_r"
block|,
name|NULL
block|,
literal|0
block|}
block|,
block|{
literal|"lbp_w"
block|,
name|NULL
block|,
literal|0
block|}
block|,
block|{
literal|"rbdp"
block|,
name|NULL
block|,
literal|0
block|}
block|,
block|{
literal|"pi_length"
block|,
name|NULL
block|,
literal|0
block|}
block|,
block|{
literal|"prot_method"
block|,
name|NULL
block|,
literal|0
block|}
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|MT_NUM_PROTECT_PARAMS
value|(sizeof(mt_protect_list)/sizeof(mt_protect_list[0]))
end_define

begin_define
define|#
directive|define
name|MT_PROT_NAME
value|"protection"
end_define

begin_function
specifier|static
name|int
name|mt_protect
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|int
name|mtfd
parameter_list|,
name|struct
name|mt_status_data
modifier|*
name|status_data
parameter_list|)
block|{
name|int
name|retval
init|=
literal|0
decl_stmt|;
name|int
name|do_enable
init|=
literal|0
decl_stmt|,
name|do_disable
init|=
literal|0
decl_stmt|,
name|do_list
init|=
literal|0
decl_stmt|;
name|int
name|rbdp_set
init|=
literal|0
decl_stmt|,
name|lbp_w_set
init|=
literal|0
decl_stmt|,
name|lbp_r_set
init|=
literal|0
decl_stmt|;
name|int
name|prot_method_set
init|=
literal|0
decl_stmt|,
name|pi_length_set
init|=
literal|0
decl_stmt|;
name|int
name|verbose
init|=
literal|0
decl_stmt|;
name|uint32_t
name|rbdp
init|=
literal|0
decl_stmt|,
name|lbp_w
init|=
literal|0
decl_stmt|,
name|lbp_r
init|=
literal|0
decl_stmt|;
name|uint32_t
name|prot_method
init|=
literal|0
decl_stmt|,
name|pi_length
init|=
literal|0
decl_stmt|;
name|struct
name|mt_status_entry
modifier|*
name|prot_entry
decl_stmt|,
modifier|*
name|supported_entry
decl_stmt|;
name|struct
name|mt_status_entry
modifier|*
name|entry
decl_stmt|;
name|struct
name|mtparamset
name|params
index|[
name|MT_NUM_PROTECT_PARAMS
index|]
decl_stmt|;
name|struct
name|mtsetlist
name|param_list
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|int
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"b:delL:m:r:vw:"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'b'
case|:
name|rbdp_set
operator|=
literal|1
expr_stmt|;
name|rbdp
operator|=
name|strtoul
argument_list|(
name|optarg
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rbdp
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|rbdp
operator|!=
literal|1
operator|)
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"valid values for -b are 0 and 1"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|do_disable
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|do_enable
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|do_list
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
name|pi_length_set
operator|=
literal|1
expr_stmt|;
name|pi_length
operator|=
name|strtoul
argument_list|(
name|optarg
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pi_length
operator|>
name|SA_CTRL_DP_PI_LENGTH_MASK
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"PI length %u> maximum %u"
argument_list|,
name|pi_length
argument_list|,
name|SA_CTRL_DP_PI_LENGTH_MASK
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|prot_method_set
operator|=
literal|1
expr_stmt|;
name|prot_method
operator|=
name|strtoul
argument_list|(
name|optarg
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|prot_method
operator|>
name|SA_CTRL_DP_METHOD_MAX
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Method %u> maximum %u"
argument_list|,
name|prot_method
argument_list|,
name|SA_CTRL_DP_METHOD_MAX
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|lbp_r_set
operator|=
literal|1
expr_stmt|;
name|lbp_r
operator|=
name|strtoul
argument_list|(
name|optarg
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lbp_r
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|lbp_r
operator|!=
literal|1
operator|)
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"valid values for -r are 0 and 1"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|verbose
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|lbp_w_set
operator|=
literal|1
expr_stmt|;
name|lbp_w
operator|=
name|strtoul
argument_list|(
name|optarg
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lbp_w
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|lbp_r
operator|!=
literal|1
operator|)
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"valid values for -r are 0 and 1"
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
if|if
condition|(
operator|(
name|rbdp_set
operator|+
name|do_disable
operator|+
name|do_enable
operator|+
name|do_list
operator|+
name|pi_length_set
operator|+
name|prot_method_set
operator|+
name|lbp_r_set
operator|+
name|lbp_w_set
operator|)
operator|==
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Need an argument for protect"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|do_disable
operator|+
name|do_enable
operator|+
name|do_list
operator|)
operator|!=
literal|1
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"You must specify only one of -e, -d or -l"
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_list
operator|!=
literal|0
condition|)
block|{
name|retval
operator|=
name|mt_protect_print
argument_list|(
name|status_data
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
if|if
condition|(
name|do_enable
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Enable protection, but allow the user to override 		 * settings if he doesn't want everything turned on. 		 */
if|if
condition|(
name|rbdp_set
operator|==
literal|0
condition|)
name|rbdp
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|lbp_w_set
operator|==
literal|0
condition|)
name|lbp_w
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|lbp_r_set
operator|==
literal|0
condition|)
name|lbp_r
operator|=
literal|1
expr_stmt|;
comment|/* 		 * If the user doesn't override it, we default to enabling 		 * Reed-Solomon checkums. 		 */
if|if
condition|(
name|prot_method_set
operator|==
literal|0
condition|)
name|prot_method
operator|=
name|SA_CTRL_DP_REED_SOLOMON
expr_stmt|;
if|if
condition|(
name|pi_length_set
operator|==
literal|0
condition|)
name|pi_length
operator|=
name|SA_CTRL_DP_RS_LENGTH
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|do_disable
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * If the user wants to disable protection, we ignore any 		 * other parameters he has set.  Everything gets set to 0. 		 */
name|rbdp
operator|=
name|lbp_w
operator|=
name|lbp_r
operator|=
literal|0
expr_stmt|;
name|prot_method
operator|=
name|pi_length
operator|=
literal|0
expr_stmt|;
block|}
name|prot_entry
operator|=
name|mt_status_entry_find
argument_list|(
name|status_data
argument_list|,
name|__DECONST
argument_list|(
name|char
operator|*
argument_list|,
name|MT_PROT_NAME
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|prot_entry
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Unable to find protection information status"
argument_list|)
expr_stmt|;
name|supported_entry
operator|=
name|mt_entry_find
argument_list|(
name|prot_entry
argument_list|,
name|__DECONST
argument_list|(
name|char
operator|*
argument_list|,
literal|"protection_supported"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|supported_entry
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Unable to find protection support information"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|supported_entry
operator|->
name|var_type
operator|==
name|MT_TYPE_INT
operator|)
operator|&&
operator|(
name|supported_entry
operator|->
name|value_signed
operator|==
literal|0
operator|)
operator|)
operator|||
operator|(
operator|(
name|supported_entry
operator|->
name|var_type
operator|==
name|MT_TYPE_UINT
operator|)
operator|&&
operator|(
name|supported_entry
operator|->
name|value_unsigned
operator|==
literal|0
operator|)
operator|)
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"This device does not support protection information"
argument_list|)
expr_stmt|;
name|mt_protect_list
index|[
name|MT_PP_LBP_R
index|]
operator|.
name|value
operator|=
name|lbp_r
expr_stmt|;
name|mt_protect_list
index|[
name|MT_PP_LBP_W
index|]
operator|.
name|value
operator|=
name|lbp_w
expr_stmt|;
name|mt_protect_list
index|[
name|MT_PP_RBDP
index|]
operator|.
name|value
operator|=
name|rbdp
expr_stmt|;
name|mt_protect_list
index|[
name|MT_PP_PI_LENGTH
index|]
operator|.
name|value
operator|=
name|pi_length
expr_stmt|;
name|mt_protect_list
index|[
name|MT_PP_PROT_METHOD
index|]
operator|.
name|value
operator|=
name|prot_method
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|params
argument_list|,
sizeof|sizeof
argument_list|(
name|params
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|param_list
argument_list|,
sizeof|sizeof
argument_list|(
name|param_list
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Go through the list and make sure that we have this parameter, 	 * and that it is still an unsigned integer.  If not, we've got a 	 * problem. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MT_NUM_PROTECT_PARAMS
condition|;
name|i
operator|++
control|)
block|{
name|entry
operator|=
name|mt_entry_find
argument_list|(
name|prot_entry
argument_list|,
name|__DECONST
argument_list|(
name|char
operator|*
argument_list|,
name|mt_protect_list
index|[
name|i
index|]
operator|.
name|name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
block|{
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Unable to find parameter %s"
argument_list|,
name|mt_protect_list
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
name|mt_protect_list
index|[
name|i
index|]
operator|.
name|entry
operator|=
name|entry
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|var_type
operator|!=
name|MT_TYPE_UINT
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Parameter %s is type %d, not unsigned, "
literal|"cannot proceed"
argument_list|,
name|mt_protect_list
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|entry
operator|->
name|var_type
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|params
index|[
name|i
index|]
operator|.
name|value_name
argument_list|,
sizeof|sizeof
argument_list|(
name|params
index|[
name|i
index|]
operator|.
name|value_name
argument_list|)
argument_list|,
literal|"%s.%s"
argument_list|,
name|MT_PROT_NAME
argument_list|,
name|mt_protect_list
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
comment|/* XXX KDM unify types here */
name|params
index|[
name|i
index|]
operator|.
name|value_type
operator|=
name|MT_PARAM_SET_UNSIGNED
expr_stmt|;
name|params
index|[
name|i
index|]
operator|.
name|value_len
operator|=
sizeof|sizeof
argument_list|(
name|mt_protect_list
index|[
name|i
index|]
operator|.
name|value
argument_list|)
expr_stmt|;
name|params
index|[
name|i
index|]
operator|.
name|value
operator|.
name|value_unsigned
operator|=
name|mt_protect_list
index|[
name|i
index|]
operator|.
name|value
expr_stmt|;
block|}
name|param_list
operator|.
name|num_params
operator|=
name|MT_NUM_PROTECT_PARAMS
expr_stmt|;
name|param_list
operator|.
name|param_len
operator|=
sizeof|sizeof
argument_list|(
name|params
argument_list|)
expr_stmt|;
name|param_list
operator|.
name|params
operator|=
name|params
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|mtfd
argument_list|,
name|MTIOCSETLIST
argument_list|,
operator|&
name|param_list
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"error issuing MTIOCSETLIST ioctl"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MT_NUM_PROTECT_PARAMS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|params
index|[
name|i
index|]
operator|.
name|status
operator|!=
name|MT_PARAM_STATUS_OK
condition|)
block|{
name|warnx
argument_list|(
literal|"%s"
argument_list|,
name|params
index|[
name|i
index|]
operator|.
name|error_str
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|bailout
label|:
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mt_param
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|int
name|mtfd
parameter_list|,
name|char
modifier|*
name|xml_str
parameter_list|,
name|struct
name|mt_status_data
modifier|*
name|status_data
parameter_list|)
block|{
name|int
name|list
init|=
literal|0
decl_stmt|,
name|do_set
init|=
literal|0
decl_stmt|,
name|xml_dump
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|param_name
init|=
name|NULL
decl_stmt|,
modifier|*
name|param_value
init|=
name|NULL
decl_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|,
name|quiet
init|=
literal|0
decl_stmt|;
name|int
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"lp:qs:x"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'l'
case|:
name|list
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|param_name
operator|=
name|strdup
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|quiet
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|param_value
operator|=
name|strdup
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
name|do_set
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|xml_dump
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
if|if
condition|(
operator|(
name|list
operator|+
name|do_set
operator|+
name|xml_dump
operator|)
operator|!=
literal|1
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"You must specify only one of -s, -l or -x"
argument_list|)
expr_stmt|;
if|if
condition|(
name|xml_dump
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|xml_str
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|do_set
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|param_name
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"You must specify -p with -s"
argument_list|)
expr_stmt|;
name|retval
operator|=
name|mt_set_param
argument_list|(
name|mtfd
argument_list|,
name|status_data
argument_list|,
name|param_name
argument_list|,
name|param_value
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|list
operator|!=
literal|0
condition|)
name|retval
operator|=
name|mt_param_list
argument_list|(
name|status_data
argument_list|,
name|param_name
argument_list|,
name|quiet
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
name|int
name|mt_print_density_entry
parameter_list|(
name|struct
name|mt_status_entry
modifier|*
name|density_root
parameter_list|,
name|int
name|indent
parameter_list|)
block|{
name|struct
name|mt_status_entry
modifier|*
name|entry
decl_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|entry
argument_list|,
argument|&density_root->child_entries
argument_list|,
argument|links
argument_list|)
block|{
if|if
condition|(
name|entry
operator|->
name|var_type
operator|==
name|MT_TYPE_NODE
condition|)
block|{
name|retval
operator|=
name|mt_print_density_entry
argument_list|(
name|entry
argument_list|,
name|indent
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
break|break;
else|else
continue|continue;
block|}
if|if
condition|(
operator|(
name|strcmp
argument_list|(
name|entry
operator|->
name|entry_name
argument_list|,
literal|"primary_density_code"
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|strcmp
argument_list|(
name|entry
operator|->
name|entry_name
argument_list|,
literal|"secondary_density_code"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* XXX KDM this should really be unsigned */
name|printf
argument_list|(
literal|"%*s%s (%s): %s\n"
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|,
name|entry
operator|->
name|desc
condition|?
name|entry
operator|->
name|desc
else|:
literal|""
argument_list|,
name|entry
operator|->
name|entry_name
argument_list|,
name|denstostring
argument_list|(
name|entry
operator|->
name|value_unsigned
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|entry
operator|->
name|entry_name
argument_list|,
literal|"density_flags"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%*sMedium Access: "
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|value_unsigned
operator|&
name|MT_DENS_WRITE_OK
condition|)
block|{
name|printf
argument_list|(
literal|"Read and Write\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"Read Only\n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%*sDefault Density: %s\n"
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|,
operator|(
name|entry
operator|->
name|value_unsigned
operator|&
name|MT_DENS_DEFLT
operator|)
condition|?
literal|"Yes"
else|:
literal|"No"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%*sDuplicate Density: %s\n"
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|,
operator|(
name|entry
operator|->
name|value_unsigned
operator|&
name|MT_DENS_DUP
operator|)
condition|?
literal|"Yes"
else|:
literal|"No"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|entry
operator|->
name|entry_name
argument_list|,
literal|"media_width"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%*s%s (%s): %.1f mm\n"
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|,
name|entry
operator|->
name|desc
condition|?
name|entry
operator|->
name|desc
else|:
literal|""
argument_list|,
name|entry
operator|->
name|entry_name
argument_list|,
call|(
name|double
call|)
argument_list|(
operator|(
name|double
operator|)
name|entry
operator|->
name|value_unsigned
operator|/
literal|10
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|entry
operator|->
name|entry_name
argument_list|,
literal|"medium_length"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%*s%s (%s): %ju m\n"
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|,
name|entry
operator|->
name|desc
condition|?
name|entry
operator|->
name|desc
else|:
literal|""
argument_list|,
name|entry
operator|->
name|entry_name
argument_list|,
operator|(
name|uintmax_t
operator|)
name|entry
operator|->
name|value_unsigned
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|entry
operator|->
name|entry_name
argument_list|,
literal|"capacity"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%*s%s (%s): %ju MB\n"
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|,
name|entry
operator|->
name|desc
condition|?
name|entry
operator|->
name|desc
else|:
literal|""
argument_list|,
name|entry
operator|->
name|entry_name
argument_list|,
operator|(
name|uintmax_t
operator|)
name|entry
operator|->
name|value_unsigned
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"%*s%s (%s): %s\n"
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|,
name|entry
operator|->
name|desc
condition|?
name|entry
operator|->
name|desc
else|:
literal|""
argument_list|,
name|entry
operator|->
name|entry_name
argument_list|,
name|entry
operator|->
name|value
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
name|int
name|mt_print_density_report
parameter_list|(
name|struct
name|mt_status_entry
modifier|*
name|report_root
parameter_list|,
name|int
name|indent
parameter_list|)
block|{
name|struct
name|mt_status_entry
modifier|*
name|mt_report
decl_stmt|,
modifier|*
name|media_report
decl_stmt|;
name|struct
name|mt_status_entry
modifier|*
name|entry
decl_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|;
name|mt_report
operator|=
name|mt_entry_find
argument_list|(
name|report_root
argument_list|,
name|__DECONST
argument_list|(
name|char
operator|*
argument_list|,
name|MT_MEDIUM_TYPE_REPORT_NAME
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mt_report
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|media_report
operator|=
name|mt_entry_find
argument_list|(
name|report_root
argument_list|,
name|__DECONST
argument_list|(
name|char
operator|*
argument_list|,
name|MT_MEDIA_REPORT_NAME
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|media_report
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
operator|(
name|mt_report
operator|->
name|value_signed
operator|==
literal|0
operator|)
operator|&&
operator|(
name|media_report
operator|->
name|value_signed
operator|==
literal|0
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"%*sThis tape drive supports the following "
literal|"media densities:\n"
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|mt_report
operator|->
name|value_signed
operator|==
literal|0
operator|)
operator|&&
operator|(
name|media_report
operator|->
name|value_signed
operator|!=
literal|0
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"%*sThe tape currently in this drive supports "
literal|"the following media densities:\n"
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|mt_report
operator|->
name|value_signed
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|media_report
operator|->
name|value_signed
operator|==
literal|0
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"%*sThis tape drive supports the following "
literal|"media types:\n"
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"%*sThis tape currently in this drive supports "
literal|"the following media types:\n"
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
name|STAILQ_FOREACH
argument_list|(
argument|entry
argument_list|,
argument|&report_root->child_entries
argument_list|,
argument|links
argument_list|)
block|{
name|struct
name|mt_status_nv
modifier|*
name|nv
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|entry
operator|->
name|entry_name
argument_list|,
name|MT_DENSITY_ENTRY_NAME
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
name|STAILQ_FOREACH
argument_list|(
argument|nv
argument_list|,
argument|&entry->nv_list
argument_list|,
argument|links
argument_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|nv
operator|->
name|name
argument_list|,
literal|"num"
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
break|break;
block|}
name|indent
operator|+=
literal|2
expr_stmt|;
name|printf
argument_list|(
literal|"%*sDensity Entry"
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|nv
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|" %s"
argument_list|,
name|nv
operator|->
name|value
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|":\n"
argument_list|)
expr_stmt|;
name|retval
operator|=
name|mt_print_density_entry
argument_list|(
name|entry
argument_list|,
name|indent
operator|+
literal|2
argument_list|)
expr_stmt|;
name|indent
operator|-=
literal|2
expr_stmt|;
block|}
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
name|int
name|mt_print_density
parameter_list|(
name|struct
name|mt_status_entry
modifier|*
name|density_root
parameter_list|,
name|int
name|indent
parameter_list|)
block|{
name|struct
name|mt_status_entry
modifier|*
name|entry
decl_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|;
comment|/* 	 * We should have this entry for every tape drive.  This particular 	 * value is reported via the mode page block header, not the 	 * SCSI REPORT DENSITY SUPPORT command. 	 */
name|entry
operator|=
name|mt_entry_find
argument_list|(
name|density_root
argument_list|,
name|__DECONST
argument_list|(
name|char
operator|*
argument_list|,
name|MT_MEDIA_DENSITY_NAME
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Unable to find node %s"
argument_list|,
name|MT_MEDIA_DENSITY_NAME
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%*sCurrent density: %s\n"
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|,
name|denstostring
argument_list|(
name|entry
operator|->
name|value_unsigned
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * It isn't an error if we don't have any density reports.  Tape 	 * drives that don't support the REPORT DENSITY SUPPORT command 	 * won't have any; they will only have the current density entry 	 * above. 	 */
name|STAILQ_FOREACH
argument_list|(
argument|entry
argument_list|,
argument|&density_root->child_entries
argument_list|,
argument|links
argument_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|entry
operator|->
name|entry_name
argument_list|,
name|MT_DENSITY_REPORT_NAME
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
name|retval
operator|=
name|mt_print_density_report
argument_list|(
name|entry
argument_list|,
name|indent
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
name|int
name|mt_getdensity
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|char
modifier|*
name|xml_str
parameter_list|,
name|struct
name|mt_status_data
modifier|*
name|status_data
parameter_list|)
block|{
name|int
name|retval
init|=
literal|0
decl_stmt|;
name|int
name|verbose
init|=
literal|0
decl_stmt|,
name|xml_dump
init|=
literal|0
decl_stmt|;
name|struct
name|mt_status_entry
modifier|*
name|density_root
init|=
name|NULL
decl_stmt|;
name|int
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"vx"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'v'
case|:
name|verbose
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|xml_dump
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|xml_dump
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|xml_str
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|density_root
operator|=
name|mt_status_entry_find
argument_list|(
name|status_data
argument_list|,
name|__DECONST
argument_list|(
name|char
operator|*
argument_list|,
name|MT_DENSITY_ROOT_NAME
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|density_root
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Cannot find density root node %s"
argument_list|,
name|MT_DENSITY_ROOT_NAME
argument_list|)
expr_stmt|;
name|retval
operator|=
name|mt_print_density
argument_list|(
name|density_root
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|warn_eof
parameter_list|(
name|void
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"The \"eof\" command has been disabled.\n"
literal|"Use \"weof\" if you really want to write end-of-file marks,\n"
literal|"or \"eom\" if you rather want to skip to the end of "
literal|"recorded medium.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

