begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright 1997 Sean Eric Fagan  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by Sean Eric Fagan  * 4. Neither the name of the author may be used to endorse or promote  *    products derived from this software without specific prior written  *    permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Various setup functions for truss.  Not the cleanest-written code,  * I'm afraid.  */
end_comment

begin_include
include|#
directive|include
file|<sys/ptrace.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"truss.h"
end_include

begin_include
include|#
directive|include
file|"syscall.h"
end_include

begin_include
include|#
directive|include
file|"extern.h"
end_include

begin_expr_stmt
name|SET_DECLARE
argument_list|(
name|procabi
argument_list|,
expr|struct
name|procabi
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|sig_atomic_t
name|detaching
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|new_proc
parameter_list|(
name|struct
name|trussinfo
modifier|*
parameter_list|,
name|pid_t
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * setup_and_wait() is called to start a process.  All it really does  * is fork(), enable tracing in the child, and then exec the given  * command.  At that point, the child process stops, and the parent  * can wake up and deal with it.  */
end_comment

begin_function
name|void
name|setup_and_wait
parameter_list|(
name|struct
name|trussinfo
modifier|*
name|info
parameter_list|,
name|char
modifier|*
name|command
index|[]
parameter_list|)
block|{
name|pid_t
name|pid
decl_stmt|;
name|pid
operator|=
name|vfork
argument_list|()
expr_stmt|;
if|if
condition|(
name|pid
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"fork failed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
block|{
comment|/* Child */
name|ptrace
argument_list|(
name|PT_TRACE_ME
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|execvp
argument_list|(
name|command
index|[
literal|0
index|]
argument_list|,
name|command
argument_list|)
expr_stmt|;
name|err
argument_list|(
literal|1
argument_list|,
literal|"execvp %s"
argument_list|,
name|command
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Only in the parent here */
if|if
condition|(
name|waitpid
argument_list|(
name|pid
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"unexpect stop in waitpid"
argument_list|)
expr_stmt|;
name|new_proc
argument_list|(
name|info
argument_list|,
name|pid
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * start_tracing is called to attach to an existing process.  */
end_comment

begin_function
name|void
name|start_tracing
parameter_list|(
name|struct
name|trussinfo
modifier|*
name|info
parameter_list|,
name|pid_t
name|pid
parameter_list|)
block|{
name|int
name|ret
decl_stmt|,
name|retry
decl_stmt|;
name|retry
operator|=
literal|10
expr_stmt|;
do|do
block|{
name|ret
operator|=
name|ptrace
argument_list|(
name|PT_ATTACH
argument_list|,
name|pid
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|usleep
argument_list|(
literal|200
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|ret
operator|&&
name|retry
operator|--
operator|>
literal|0
condition|)
do|;
if|if
condition|(
name|ret
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"can not attach to target process"
argument_list|)
expr_stmt|;
if|if
condition|(
name|waitpid
argument_list|(
name|pid
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"Unexpect stop in waitpid"
argument_list|)
expr_stmt|;
name|new_proc
argument_list|(
name|info
argument_list|,
name|pid
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Restore a process back to it's pre-truss state.  * Called for SIGINT, SIGTERM, SIGQUIT.  This only  * applies if truss was told to monitor an already-existing  * process.  */
end_comment

begin_function
name|void
name|restore_proc
parameter_list|(
name|int
name|signo
name|__unused
parameter_list|)
block|{
name|detaching
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|detach_proc
parameter_list|(
name|pid_t
name|pid
parameter_list|)
block|{
comment|/* stop the child so that we can detach */
name|kill
argument_list|(
name|pid
argument_list|,
name|SIGSTOP
argument_list|)
expr_stmt|;
if|if
condition|(
name|waitpid
argument_list|(
name|pid
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"Unexpected stop in waitpid"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptrace
argument_list|(
name|PT_DETACH
argument_list|,
name|pid
argument_list|,
operator|(
name|caddr_t
operator|)
literal|1
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"Can not detach the process"
argument_list|)
expr_stmt|;
name|kill
argument_list|(
name|pid
argument_list|,
name|SIGCONT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Determine the ABI.  This is called after every exec, and when  * a process is first monitored.  */
end_comment

begin_function
specifier|static
name|struct
name|procabi
modifier|*
name|find_abi
parameter_list|(
name|pid_t
name|pid
parameter_list|)
block|{
name|struct
name|procabi
modifier|*
modifier|*
name|pabi
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|mib
index|[
literal|4
index|]
decl_stmt|;
name|char
name|progt
index|[
literal|32
index|]
decl_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
name|progt
argument_list|)
expr_stmt|;
name|mib
index|[
literal|0
index|]
operator|=
name|CTL_KERN
expr_stmt|;
name|mib
index|[
literal|1
index|]
operator|=
name|KERN_PROC
expr_stmt|;
name|mib
index|[
literal|2
index|]
operator|=
name|KERN_PROC_SV_NAME
expr_stmt|;
name|mib
index|[
literal|3
index|]
operator|=
name|pid
expr_stmt|;
name|error
operator|=
name|sysctl
argument_list|(
name|mib
argument_list|,
literal|4
argument_list|,
name|progt
argument_list|,
operator|&
name|len
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|err
argument_list|(
literal|2
argument_list|,
literal|"can not get sysvec name"
argument_list|)
expr_stmt|;
name|SET_FOREACH
argument_list|(
argument|pabi
argument_list|,
argument|procabi
argument_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
operator|(
operator|*
name|pabi
operator|)
operator|->
name|type
argument_list|,
name|progt
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
operator|*
name|pabi
operator|)
return|;
block|}
name|warnx
argument_list|(
literal|"ABI %s for pid %ld is not supported"
argument_list|,
name|progt
argument_list|,
operator|(
name|long
operator|)
name|pid
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|new_proc
parameter_list|(
name|struct
name|trussinfo
modifier|*
name|info
parameter_list|,
name|pid_t
name|pid
parameter_list|)
block|{
name|struct
name|procinfo
modifier|*
name|np
decl_stmt|;
comment|/* 	 * If this happens it means there is a bug in truss.  Unfortunately 	 * this will kill any processes are attached to. 	 */
name|LIST_FOREACH
argument_list|(
argument|np
argument_list|,
argument|&info->proclist
argument_list|,
argument|entries
argument_list|)
block|{
if|if
condition|(
name|np
operator|->
name|pid
operator|==
name|pid
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Duplicate process for pid %ld"
argument_list|,
operator|(
name|long
operator|)
name|pid
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|info
operator|->
name|flags
operator|&
name|FOLLOWFORKS
condition|)
if|if
condition|(
name|ptrace
argument_list|(
name|PT_FOLLOW_FORK
argument_list|,
name|pid
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"Unable to follow forks for pid %ld"
argument_list|,
operator|(
name|long
operator|)
name|pid
argument_list|)
expr_stmt|;
name|np
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|procinfo
argument_list|)
argument_list|)
expr_stmt|;
name|np
operator|->
name|pid
operator|=
name|pid
expr_stmt|;
name|np
operator|->
name|abi
operator|=
name|find_abi
argument_list|(
name|pid
argument_list|)
expr_stmt|;
name|SLIST_INIT
argument_list|(
operator|&
name|np
operator|->
name|threadlist
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|info
operator|->
name|proclist
argument_list|,
name|np
argument_list|,
name|entries
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_proc
parameter_list|(
name|struct
name|procinfo
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|threadinfo
modifier|*
name|t
decl_stmt|,
modifier|*
name|t2
decl_stmt|;
name|SLIST_FOREACH_SAFE
argument_list|(
argument|t
argument_list|,
argument|&p->threadlist
argument_list|,
argument|entries
argument_list|,
argument|t2
argument_list|)
block|{
name|free
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
name|LIST_REMOVE
argument_list|(
name|p
argument_list|,
name|entries
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|detach_all_procs
parameter_list|(
name|struct
name|trussinfo
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|procinfo
modifier|*
name|p
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
name|LIST_FOREACH_SAFE
argument_list|(
argument|p
argument_list|,
argument|&info->proclist
argument_list|,
argument|entries
argument_list|,
argument|p2
argument_list|)
block|{
name|detach_proc
argument_list|(
name|p
operator|->
name|pid
argument_list|)
expr_stmt|;
name|free_proc
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|struct
name|procinfo
modifier|*
name|find_proc
parameter_list|(
name|struct
name|trussinfo
modifier|*
name|info
parameter_list|,
name|pid_t
name|pid
parameter_list|)
block|{
name|struct
name|procinfo
modifier|*
name|np
decl_stmt|;
name|LIST_FOREACH
argument_list|(
argument|np
argument_list|,
argument|&info->proclist
argument_list|,
argument|entries
argument_list|)
block|{
if|if
condition|(
name|np
operator|->
name|pid
operator|==
name|pid
condition|)
return|return
operator|(
name|np
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Change curthread member based on (pid, lwpid).  * If it is a new thread, create a threadinfo structure.  */
end_comment

begin_function
specifier|static
name|void
name|find_thread
parameter_list|(
name|struct
name|trussinfo
modifier|*
name|info
parameter_list|,
name|pid_t
name|pid
parameter_list|,
name|lwpid_t
name|lwpid
parameter_list|)
block|{
name|struct
name|procinfo
modifier|*
name|np
decl_stmt|;
name|struct
name|threadinfo
modifier|*
name|nt
decl_stmt|;
name|np
operator|=
name|find_proc
argument_list|(
name|info
argument_list|,
name|pid
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|np
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|nt
argument_list|,
argument|&np->threadlist
argument_list|,
argument|entries
argument_list|)
block|{
if|if
condition|(
name|nt
operator|->
name|tid
operator|==
name|lwpid
condition|)
block|{
name|info
operator|->
name|curthread
operator|=
name|nt
expr_stmt|;
return|return;
block|}
block|}
name|nt
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|threadinfo
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nt
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"calloc() failed"
argument_list|)
expr_stmt|;
name|nt
operator|->
name|proc
operator|=
name|np
expr_stmt|;
name|nt
operator|->
name|tid
operator|=
name|lwpid
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|np
operator|->
name|threadlist
argument_list|,
name|nt
argument_list|,
name|entries
argument_list|)
expr_stmt|;
name|info
operator|->
name|curthread
operator|=
name|nt
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * When a process exits, it no longer has any threads left.  However,  * the main loop expects a valid curthread.  In cases when a thread  * triggers the termination (e.g. calling exit or triggering a fault)  * we would ideally use that thread.  However, if a process is killed  * by a signal sent from another process then there is no "correct"  * thread.  We just punt and use the first thread.  */
end_comment

begin_function
specifier|static
name|void
name|find_exit_thread
parameter_list|(
name|struct
name|trussinfo
modifier|*
name|info
parameter_list|,
name|pid_t
name|pid
parameter_list|)
block|{
name|struct
name|procinfo
modifier|*
name|np
decl_stmt|;
name|struct
name|threadinfo
modifier|*
name|nt
decl_stmt|;
name|np
operator|=
name|find_proc
argument_list|(
name|info
argument_list|,
name|pid
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|np
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|SLIST_EMPTY
argument_list|(
operator|&
name|np
operator|->
name|threadlist
argument_list|)
condition|)
block|{
comment|/* 		 * If an existing process exits right after we attach 		 * to it but before it posts any events, there won't 		 * be any threads.  Create a dummy thread and set its 		 * "before" time to the global start time. 		 */
name|nt
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|threadinfo
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nt
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"calloc() failed"
argument_list|)
expr_stmt|;
name|nt
operator|->
name|proc
operator|=
name|np
expr_stmt|;
name|nt
operator|->
name|tid
operator|=
literal|0
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|np
operator|->
name|threadlist
argument_list|,
name|nt
argument_list|,
name|entries
argument_list|)
expr_stmt|;
name|nt
operator|->
name|before
operator|=
name|info
operator|->
name|start_time
expr_stmt|;
block|}
name|info
operator|->
name|curthread
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|np
operator|->
name|threadlist
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|alloc_syscall
parameter_list|(
name|struct
name|threadinfo
modifier|*
name|t
parameter_list|,
name|struct
name|ptrace_lwpinfo
modifier|*
name|pl
parameter_list|)
block|{
name|u_int
name|i
decl_stmt|;
name|assert
argument_list|(
name|t
operator|->
name|in_syscall
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|t
operator|->
name|cs
operator|.
name|number
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|t
operator|->
name|cs
operator|.
name|name
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|t
operator|->
name|cs
operator|.
name|nargs
operator|==
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|t
operator|->
name|cs
operator|.
name|s_args
argument_list|)
condition|;
name|i
operator|++
control|)
name|assert
argument_list|(
name|t
operator|->
name|cs
operator|.
name|s_args
index|[
name|i
index|]
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|t
operator|->
name|cs
operator|.
name|args
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t
operator|->
name|cs
operator|.
name|args
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|->
name|cs
operator|.
name|number
operator|=
name|pl
operator|->
name|pl_syscall_code
expr_stmt|;
name|t
operator|->
name|in_syscall
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_syscall
parameter_list|(
name|struct
name|threadinfo
modifier|*
name|t
parameter_list|)
block|{
name|u_int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|t
operator|->
name|cs
operator|.
name|nargs
condition|;
name|i
operator|++
control|)
name|free
argument_list|(
name|t
operator|->
name|cs
operator|.
name|s_args
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|t
operator|->
name|cs
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t
operator|->
name|cs
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|->
name|in_syscall
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|enter_syscall
parameter_list|(
name|struct
name|trussinfo
modifier|*
name|info
parameter_list|,
name|struct
name|ptrace_lwpinfo
modifier|*
name|pl
parameter_list|)
block|{
name|struct
name|threadinfo
modifier|*
name|t
decl_stmt|;
name|struct
name|syscall
modifier|*
name|sc
decl_stmt|;
name|u_int
name|i
decl_stmt|,
name|narg
decl_stmt|;
name|t
operator|=
name|info
operator|->
name|curthread
expr_stmt|;
name|alloc_syscall
argument_list|(
name|t
argument_list|,
name|pl
argument_list|)
expr_stmt|;
name|narg
operator|=
name|MIN
argument_list|(
name|pl
operator|->
name|pl_syscall_narg
argument_list|,
name|nitems
argument_list|(
name|t
operator|->
name|cs
operator|.
name|args
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|narg
operator|!=
literal|0
operator|&&
name|t
operator|->
name|proc
operator|->
name|abi
operator|->
name|fetch_args
argument_list|(
name|info
argument_list|,
name|narg
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|free_syscall
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|t
operator|->
name|cs
operator|.
name|number
operator|>=
literal|0
operator|&&
name|t
operator|->
name|cs
operator|.
name|number
operator|<
name|t
operator|->
name|proc
operator|->
name|abi
operator|->
name|nsyscalls
condition|)
name|t
operator|->
name|cs
operator|.
name|name
operator|=
name|t
operator|->
name|proc
operator|->
name|abi
operator|->
name|syscallnames
index|[
name|t
operator|->
name|cs
operator|.
name|number
index|]
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|cs
operator|.
name|name
operator|==
name|NULL
condition|)
name|fprintf
argument_list|(
name|info
operator|->
name|outfile
argument_list|,
literal|"-- UNKNOWN %s SYSCALL %d --\n"
argument_list|,
name|t
operator|->
name|proc
operator|->
name|abi
operator|->
name|type
argument_list|,
name|t
operator|->
name|cs
operator|.
name|number
argument_list|)
expr_stmt|;
name|sc
operator|=
name|get_syscall
argument_list|(
name|t
operator|->
name|cs
operator|.
name|name
argument_list|,
name|narg
argument_list|)
expr_stmt|;
name|t
operator|->
name|cs
operator|.
name|nargs
operator|=
name|sc
operator|->
name|nargs
expr_stmt|;
name|assert
argument_list|(
name|sc
operator|->
name|nargs
operator|<=
name|nitems
argument_list|(
name|t
operator|->
name|cs
operator|.
name|s_args
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|->
name|cs
operator|.
name|sc
operator|=
name|sc
expr_stmt|;
comment|/* 	 * At this point, we set up the system call arguments. 	 * We ignore any OUT ones, however -- those are arguments that 	 * are set by the system call, and so are probably meaningless 	 * now.	This doesn't currently support arguments that are 	 * passed in *and* out, however. 	 */
if|if
condition|(
name|t
operator|->
name|cs
operator|.
name|name
operator|!=
name|NULL
condition|)
block|{
if|#
directive|if
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"syscall %s("
argument_list|,
name|t
operator|->
name|cs
operator|.
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|t
operator|->
name|cs
operator|.
name|nargs
condition|;
name|i
operator|++
control|)
block|{
if|#
directive|if
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"0x%lx%s"
argument_list|,
name|sc
condition|?
name|t
operator|->
name|cs
operator|.
name|args
index|[
name|sc
operator|->
name|args
index|[
name|i
index|]
operator|.
name|offset
index|]
else|:
name|t
operator|->
name|cs
operator|.
name|args
index|[
name|i
index|]
argument_list|,
name|i
operator|<
operator|(
name|t
operator|->
name|cs
operator|.
name|nargs
operator|-
literal|1
operator|)
condition|?
literal|","
else|:
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|args
index|[
name|i
index|]
operator|.
name|type
operator|&
name|OUT
operator|)
condition|)
block|{
name|t
operator|->
name|cs
operator|.
name|s_args
index|[
name|i
index|]
operator|=
name|print_arg
argument_list|(
operator|&
name|sc
operator|->
name|args
index|[
name|i
index|]
argument_list|,
name|t
operator|->
name|cs
operator|.
name|args
argument_list|,
literal|0
argument_list|,
name|info
argument_list|)
expr_stmt|;
block|}
block|}
if|#
directive|if
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|")\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|clock_gettime
argument_list|(
name|CLOCK_REALTIME
argument_list|,
operator|&
name|t
operator|->
name|before
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|exit_syscall
parameter_list|(
name|struct
name|trussinfo
modifier|*
name|info
parameter_list|,
name|struct
name|ptrace_lwpinfo
modifier|*
name|pl
parameter_list|)
block|{
name|struct
name|threadinfo
modifier|*
name|t
decl_stmt|;
name|struct
name|procinfo
modifier|*
name|p
decl_stmt|;
name|struct
name|syscall
modifier|*
name|sc
decl_stmt|;
name|long
name|retval
index|[
literal|2
index|]
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|int
name|errorp
decl_stmt|;
name|t
operator|=
name|info
operator|->
name|curthread
expr_stmt|;
if|if
condition|(
operator|!
name|t
operator|->
name|in_syscall
condition|)
return|return;
name|clock_gettime
argument_list|(
name|CLOCK_REALTIME
argument_list|,
operator|&
name|t
operator|->
name|after
argument_list|)
expr_stmt|;
name|p
operator|=
name|t
operator|->
name|proc
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|abi
operator|->
name|fetch_retval
argument_list|(
name|info
argument_list|,
name|retval
argument_list|,
operator|&
name|errorp
argument_list|)
operator|<
literal|0
condition|)
block|{
name|free_syscall
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return;
block|}
name|sc
operator|=
name|t
operator|->
name|cs
operator|.
name|sc
expr_stmt|;
comment|/* 	 * Here, we only look for arguments that have OUT masked in -- 	 * otherwise, they were handled in enter_syscall(). 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|nargs
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|temp
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|args
index|[
name|i
index|]
operator|.
name|type
operator|&
name|OUT
condition|)
block|{
comment|/* 			 * If an error occurred, then don't bother 			 * getting the data; it may not be valid. 			 */
if|if
condition|(
name|errorp
condition|)
block|{
name|asprintf
argument_list|(
operator|&
name|temp
argument_list|,
literal|"0x%lx"
argument_list|,
name|t
operator|->
name|cs
operator|.
name|args
index|[
name|sc
operator|->
name|args
index|[
name|i
index|]
operator|.
name|offset
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|temp
operator|=
name|print_arg
argument_list|(
operator|&
name|sc
operator|->
name|args
index|[
name|i
index|]
argument_list|,
name|t
operator|->
name|cs
operator|.
name|args
argument_list|,
name|retval
argument_list|,
name|info
argument_list|)
expr_stmt|;
block|}
name|t
operator|->
name|cs
operator|.
name|s_args
index|[
name|i
index|]
operator|=
name|temp
expr_stmt|;
block|}
block|}
name|print_syscall_ret
argument_list|(
name|info
argument_list|,
name|t
operator|->
name|cs
operator|.
name|name
argument_list|,
name|t
operator|->
name|cs
operator|.
name|nargs
argument_list|,
name|t
operator|->
name|cs
operator|.
name|s_args
argument_list|,
name|errorp
argument_list|,
name|retval
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|free_syscall
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* 	 * If the process executed a new image, check the ABI.  If the 	 * new ABI isn't supported, stop tracing this process. 	 */
if|if
condition|(
name|pl
operator|->
name|pl_flags
operator|&
name|PL_FLAG_EXEC
condition|)
block|{
name|p
operator|->
name|abi
operator|=
name|find_abi
argument_list|(
name|p
operator|->
name|pid
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|abi
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|ptrace
argument_list|(
name|PT_DETACH
argument_list|,
name|p
operator|->
name|pid
argument_list|,
operator|(
name|caddr_t
operator|)
literal|1
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"Can not detach the process"
argument_list|)
expr_stmt|;
name|free_proc
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|report_exit
parameter_list|(
name|struct
name|trussinfo
modifier|*
name|info
parameter_list|,
name|siginfo_t
modifier|*
name|si
parameter_list|)
block|{
name|struct
name|timespec
name|timediff
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|flags
operator|&
name|FOLLOWFORKS
condition|)
name|fprintf
argument_list|(
name|info
operator|->
name|outfile
argument_list|,
literal|"%5d: "
argument_list|,
name|si
operator|->
name|si_pid
argument_list|)
expr_stmt|;
name|clock_gettime
argument_list|(
name|CLOCK_REALTIME
argument_list|,
operator|&
name|info
operator|->
name|curthread
operator|->
name|after
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|flags
operator|&
name|ABSOLUTETIMESTAMPS
condition|)
block|{
name|timespecsubt
argument_list|(
operator|&
name|info
operator|->
name|curthread
operator|->
name|after
argument_list|,
operator|&
name|info
operator|->
name|start_time
argument_list|,
operator|&
name|timediff
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|info
operator|->
name|outfile
argument_list|,
literal|"%jd.%09ld "
argument_list|,
operator|(
name|intmax_t
operator|)
name|timediff
operator|.
name|tv_sec
argument_list|,
name|timediff
operator|.
name|tv_nsec
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|info
operator|->
name|flags
operator|&
name|RELATIVETIMESTAMPS
condition|)
block|{
name|timespecsubt
argument_list|(
operator|&
name|info
operator|->
name|curthread
operator|->
name|after
argument_list|,
operator|&
name|info
operator|->
name|curthread
operator|->
name|before
argument_list|,
operator|&
name|timediff
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|info
operator|->
name|outfile
argument_list|,
literal|"%jd.%09ld "
argument_list|,
operator|(
name|intmax_t
operator|)
name|timediff
operator|.
name|tv_sec
argument_list|,
name|timediff
operator|.
name|tv_nsec
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|si
operator|->
name|si_code
operator|==
name|CLD_EXITED
condition|)
name|fprintf
argument_list|(
name|info
operator|->
name|outfile
argument_list|,
literal|"process exit, rval = %u\n"
argument_list|,
name|si
operator|->
name|si_status
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|info
operator|->
name|outfile
argument_list|,
literal|"process killed, signal = %u%s\n"
argument_list|,
name|si
operator|->
name|si_status
argument_list|,
name|si
operator|->
name|si_code
operator|==
name|CLD_DUMPED
condition|?
literal|" (core dumped)"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|report_new_child
parameter_list|(
name|struct
name|trussinfo
modifier|*
name|info
parameter_list|,
name|pid_t
name|pid
parameter_list|)
block|{
name|struct
name|timespec
name|timediff
decl_stmt|;
name|clock_gettime
argument_list|(
name|CLOCK_REALTIME
argument_list|,
operator|&
name|info
operator|->
name|curthread
operator|->
name|after
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|info
operator|->
name|flags
operator|&
name|FOLLOWFORKS
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|info
operator|->
name|outfile
argument_list|,
literal|"%5d: "
argument_list|,
name|pid
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|flags
operator|&
name|ABSOLUTETIMESTAMPS
condition|)
block|{
name|timespecsubt
argument_list|(
operator|&
name|info
operator|->
name|curthread
operator|->
name|after
argument_list|,
operator|&
name|info
operator|->
name|start_time
argument_list|,
operator|&
name|timediff
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|info
operator|->
name|outfile
argument_list|,
literal|"%jd.%09ld "
argument_list|,
operator|(
name|intmax_t
operator|)
name|timediff
operator|.
name|tv_sec
argument_list|,
name|timediff
operator|.
name|tv_nsec
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|info
operator|->
name|flags
operator|&
name|RELATIVETIMESTAMPS
condition|)
block|{
name|timediff
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|timediff
operator|.
name|tv_nsec
operator|=
literal|0
expr_stmt|;
name|fprintf
argument_list|(
name|info
operator|->
name|outfile
argument_list|,
literal|"%jd.%09ld "
argument_list|,
operator|(
name|intmax_t
operator|)
name|timediff
operator|.
name|tv_sec
argument_list|,
name|timediff
operator|.
name|tv_nsec
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|info
operator|->
name|outfile
argument_list|,
literal|"<new process>\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|report_signal
parameter_list|(
name|struct
name|trussinfo
modifier|*
name|info
parameter_list|,
name|siginfo_t
modifier|*
name|si
parameter_list|)
block|{
name|struct
name|timespec
name|timediff
decl_stmt|;
name|char
modifier|*
name|signame
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|flags
operator|&
name|FOLLOWFORKS
condition|)
name|fprintf
argument_list|(
name|info
operator|->
name|outfile
argument_list|,
literal|"%5d: "
argument_list|,
name|si
operator|->
name|si_pid
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|flags
operator|&
name|ABSOLUTETIMESTAMPS
condition|)
block|{
name|timespecsubt
argument_list|(
operator|&
name|info
operator|->
name|curthread
operator|->
name|after
argument_list|,
operator|&
name|info
operator|->
name|start_time
argument_list|,
operator|&
name|timediff
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|info
operator|->
name|outfile
argument_list|,
literal|"%jd.%09ld "
argument_list|,
operator|(
name|intmax_t
operator|)
name|timediff
operator|.
name|tv_sec
argument_list|,
name|timediff
operator|.
name|tv_nsec
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|info
operator|->
name|flags
operator|&
name|RELATIVETIMESTAMPS
condition|)
block|{
name|timespecsubt
argument_list|(
operator|&
name|info
operator|->
name|curthread
operator|->
name|after
argument_list|,
operator|&
name|info
operator|->
name|curthread
operator|->
name|before
argument_list|,
operator|&
name|timediff
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|info
operator|->
name|outfile
argument_list|,
literal|"%jd.%09ld "
argument_list|,
operator|(
name|intmax_t
operator|)
name|timediff
operator|.
name|tv_sec
argument_list|,
name|timediff
operator|.
name|tv_nsec
argument_list|)
expr_stmt|;
block|}
name|signame
operator|=
name|strsig
argument_list|(
name|si
operator|->
name|si_status
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|info
operator|->
name|outfile
argument_list|,
literal|"SIGNAL %u (%s)\n"
argument_list|,
name|si
operator|->
name|si_status
argument_list|,
name|signame
operator|==
name|NULL
condition|?
literal|"?"
else|:
name|signame
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Wait for events until all the processes have exited or truss has been  * asked to stop.  */
end_comment

begin_function
name|void
name|eventloop
parameter_list|(
name|struct
name|trussinfo
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|ptrace_lwpinfo
name|pl
decl_stmt|;
name|siginfo_t
name|si
decl_stmt|;
name|int
name|pending_signal
decl_stmt|;
while|while
condition|(
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|info
operator|->
name|proclist
argument_list|)
condition|)
block|{
if|if
condition|(
name|detaching
condition|)
block|{
name|detach_all_procs
argument_list|(
name|info
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|waitid
argument_list|(
name|P_ALL
argument_list|,
literal|0
argument_list|,
operator|&
name|si
argument_list|,
name|WTRAPPED
operator||
name|WEXITED
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EINTR
condition|)
continue|continue;
name|err
argument_list|(
literal|1
argument_list|,
literal|"Unexpected error from waitid"
argument_list|)
expr_stmt|;
block|}
name|assert
argument_list|(
name|si
operator|.
name|si_signo
operator|==
name|SIGCHLD
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|si
operator|.
name|si_code
condition|)
block|{
case|case
name|CLD_EXITED
case|:
case|case
name|CLD_KILLED
case|:
case|case
name|CLD_DUMPED
case|:
name|find_exit_thread
argument_list|(
name|info
argument_list|,
name|si
operator|.
name|si_pid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|info
operator|->
name|flags
operator|&
name|COUNTONLY
operator|)
operator|==
literal|0
condition|)
name|report_exit
argument_list|(
name|info
argument_list|,
operator|&
name|si
argument_list|)
expr_stmt|;
name|free_proc
argument_list|(
name|info
operator|->
name|curthread
operator|->
name|proc
argument_list|)
expr_stmt|;
name|info
operator|->
name|curthread
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|CLD_TRAPPED
case|:
if|if
condition|(
name|ptrace
argument_list|(
name|PT_LWPINFO
argument_list|,
name|si
operator|.
name|si_pid
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|pl
argument_list|,
sizeof|sizeof
argument_list|(
name|pl
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"ptrace(PT_LWPINFO)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pl
operator|.
name|pl_flags
operator|&
name|PL_FLAG_CHILD
condition|)
block|{
name|new_proc
argument_list|(
name|info
argument_list|,
name|si
operator|.
name|si_pid
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|LIST_FIRST
argument_list|(
operator|&
name|info
operator|->
name|proclist
argument_list|)
operator|->
name|abi
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
name|find_thread
argument_list|(
name|info
argument_list|,
name|si
operator|.
name|si_pid
argument_list|,
name|pl
operator|.
name|pl_lwpid
argument_list|)
expr_stmt|;
if|if
condition|(
name|si
operator|.
name|si_status
operator|==
name|SIGTRAP
operator|&&
operator|(
name|pl
operator|.
name|pl_flags
operator|&
operator|(
name|PL_FLAG_SCE
operator||
name|PL_FLAG_SCX
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|pl
operator|.
name|pl_flags
operator|&
name|PL_FLAG_SCE
condition|)
name|enter_syscall
argument_list|(
name|info
argument_list|,
operator|&
name|pl
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pl
operator|.
name|pl_flags
operator|&
name|PL_FLAG_SCX
condition|)
name|exit_syscall
argument_list|(
name|info
argument_list|,
operator|&
name|pl
argument_list|)
expr_stmt|;
name|pending_signal
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pl
operator|.
name|pl_flags
operator|&
name|PL_FLAG_CHILD
condition|)
block|{
if|if
condition|(
operator|(
name|info
operator|->
name|flags
operator|&
name|COUNTONLY
operator|)
operator|==
literal|0
condition|)
name|report_new_child
argument_list|(
name|info
argument_list|,
name|si
operator|.
name|si_pid
argument_list|)
expr_stmt|;
name|pending_signal
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|info
operator|->
name|flags
operator|&
name|NOSIGS
operator|)
operator|==
literal|0
condition|)
name|report_signal
argument_list|(
name|info
argument_list|,
operator|&
name|si
argument_list|)
expr_stmt|;
name|pending_signal
operator|=
name|si
operator|.
name|si_status
expr_stmt|;
block|}
name|ptrace
argument_list|(
name|PT_SYSCALL
argument_list|,
name|si
operator|.
name|si_pid
argument_list|,
operator|(
name|caddr_t
operator|)
literal|1
argument_list|,
name|pending_signal
argument_list|)
expr_stmt|;
break|break;
case|case
name|CLD_STOPPED
case|:
name|errx
argument_list|(
literal|1
argument_list|,
literal|"waitid reported CLD_STOPPED"
argument_list|)
expr_stmt|;
case|case
name|CLD_CONTINUED
case|:
break|break;
block|}
block|}
block|}
end_function

end_unit

