begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright 1997 Sean Eric Fagan  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by Sean Eric Fagan  * 4. Neither the name of the author may be used to endorse or promote  *    products derived from this software without specific prior written  *    permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Various setup functions for truss.  Not the cleanest-written code,  * I'm afraid.  */
end_comment

begin_include
include|#
directive|include
file|<sys/ptrace.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdbool.h>
end_include

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<sysdecode.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"truss.h"
end_include

begin_include
include|#
directive|include
file|"syscall.h"
end_include

begin_include
include|#
directive|include
file|"extern.h"
end_include

begin_expr_stmt
name|SET_DECLARE
argument_list|(
name|procabi
argument_list|,
expr|struct
name|procabi
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|sig_atomic_t
name|detaching
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|enter_syscall
parameter_list|(
name|struct
name|trussinfo
modifier|*
parameter_list|,
name|struct
name|threadinfo
modifier|*
parameter_list|,
name|struct
name|ptrace_lwpinfo
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|new_proc
parameter_list|(
name|struct
name|trussinfo
modifier|*
parameter_list|,
name|pid_t
parameter_list|,
name|lwpid_t
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * setup_and_wait() is called to start a process.  All it really does  * is fork(), enable tracing in the child, and then exec the given  * command.  At that point, the child process stops, and the parent  * can wake up and deal with it.  */
end_comment

begin_function
name|void
name|setup_and_wait
parameter_list|(
name|struct
name|trussinfo
modifier|*
name|info
parameter_list|,
name|char
modifier|*
name|command
index|[]
parameter_list|)
block|{
name|pid_t
name|pid
decl_stmt|;
name|pid
operator|=
name|vfork
argument_list|()
expr_stmt|;
if|if
condition|(
name|pid
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"fork failed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
block|{
comment|/* Child */
name|ptrace
argument_list|(
name|PT_TRACE_ME
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|execvp
argument_list|(
name|command
index|[
literal|0
index|]
argument_list|,
name|command
argument_list|)
expr_stmt|;
name|err
argument_list|(
literal|1
argument_list|,
literal|"execvp %s"
argument_list|,
name|command
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Only in the parent here */
if|if
condition|(
name|waitpid
argument_list|(
name|pid
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"unexpect stop in waitpid"
argument_list|)
expr_stmt|;
name|new_proc
argument_list|(
name|info
argument_list|,
name|pid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * start_tracing is called to attach to an existing process.  */
end_comment

begin_function
name|void
name|start_tracing
parameter_list|(
name|struct
name|trussinfo
modifier|*
name|info
parameter_list|,
name|pid_t
name|pid
parameter_list|)
block|{
name|int
name|ret
decl_stmt|,
name|retry
decl_stmt|;
name|retry
operator|=
literal|10
expr_stmt|;
do|do
block|{
name|ret
operator|=
name|ptrace
argument_list|(
name|PT_ATTACH
argument_list|,
name|pid
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|usleep
argument_list|(
literal|200
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|ret
operator|&&
name|retry
operator|--
operator|>
literal|0
condition|)
do|;
if|if
condition|(
name|ret
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"can not attach to target process"
argument_list|)
expr_stmt|;
if|if
condition|(
name|waitpid
argument_list|(
name|pid
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"Unexpect stop in waitpid"
argument_list|)
expr_stmt|;
name|new_proc
argument_list|(
name|info
argument_list|,
name|pid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Restore a process back to it's pre-truss state.  * Called for SIGINT, SIGTERM, SIGQUIT.  This only  * applies if truss was told to monitor an already-existing  * process.  */
end_comment

begin_function
name|void
name|restore_proc
parameter_list|(
name|int
name|signo
name|__unused
parameter_list|)
block|{
name|detaching
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|detach_proc
parameter_list|(
name|pid_t
name|pid
parameter_list|)
block|{
comment|/* stop the child so that we can detach */
name|kill
argument_list|(
name|pid
argument_list|,
name|SIGSTOP
argument_list|)
expr_stmt|;
if|if
condition|(
name|waitpid
argument_list|(
name|pid
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"Unexpected stop in waitpid"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptrace
argument_list|(
name|PT_DETACH
argument_list|,
name|pid
argument_list|,
operator|(
name|caddr_t
operator|)
literal|1
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"Can not detach the process"
argument_list|)
expr_stmt|;
name|kill
argument_list|(
name|pid
argument_list|,
name|SIGCONT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Determine the ABI.  This is called after every exec, and when  * a process is first monitored.  */
end_comment

begin_function
specifier|static
name|struct
name|procabi
modifier|*
name|find_abi
parameter_list|(
name|pid_t
name|pid
parameter_list|)
block|{
name|struct
name|procabi
modifier|*
modifier|*
name|pabi
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|mib
index|[
literal|4
index|]
decl_stmt|;
name|char
name|progt
index|[
literal|32
index|]
decl_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
name|progt
argument_list|)
expr_stmt|;
name|mib
index|[
literal|0
index|]
operator|=
name|CTL_KERN
expr_stmt|;
name|mib
index|[
literal|1
index|]
operator|=
name|KERN_PROC
expr_stmt|;
name|mib
index|[
literal|2
index|]
operator|=
name|KERN_PROC_SV_NAME
expr_stmt|;
name|mib
index|[
literal|3
index|]
operator|=
name|pid
expr_stmt|;
name|error
operator|=
name|sysctl
argument_list|(
name|mib
argument_list|,
literal|4
argument_list|,
name|progt
argument_list|,
operator|&
name|len
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|err
argument_list|(
literal|2
argument_list|,
literal|"can not get sysvec name"
argument_list|)
expr_stmt|;
name|SET_FOREACH
argument_list|(
argument|pabi
argument_list|,
argument|procabi
argument_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
operator|(
operator|*
name|pabi
operator|)
operator|->
name|type
argument_list|,
name|progt
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
operator|*
name|pabi
operator|)
return|;
block|}
name|warnx
argument_list|(
literal|"ABI %s for pid %ld is not supported"
argument_list|,
name|progt
argument_list|,
operator|(
name|long
operator|)
name|pid
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|threadinfo
modifier|*
name|new_thread
parameter_list|(
name|struct
name|procinfo
modifier|*
name|p
parameter_list|,
name|lwpid_t
name|lwpid
parameter_list|)
block|{
name|struct
name|threadinfo
modifier|*
name|nt
decl_stmt|;
comment|/* 	 * If this happens it means there is a bug in truss.  Unfortunately 	 * this will kill any processes truss is attached to. 	 */
name|LIST_FOREACH
argument_list|(
argument|nt
argument_list|,
argument|&p->threadlist
argument_list|,
argument|entries
argument_list|)
block|{
if|if
condition|(
name|nt
operator|->
name|tid
operator|==
name|lwpid
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Duplicate thread for LWP %ld"
argument_list|,
operator|(
name|long
operator|)
name|lwpid
argument_list|)
expr_stmt|;
block|}
name|nt
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|threadinfo
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nt
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"calloc() failed"
argument_list|)
expr_stmt|;
name|nt
operator|->
name|proc
operator|=
name|p
expr_stmt|;
name|nt
operator|->
name|tid
operator|=
name|lwpid
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|p
operator|->
name|threadlist
argument_list|,
name|nt
argument_list|,
name|entries
argument_list|)
expr_stmt|;
return|return
operator|(
name|nt
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_thread
parameter_list|(
name|struct
name|threadinfo
modifier|*
name|t
parameter_list|)
block|{
name|LIST_REMOVE
argument_list|(
name|t
argument_list|,
name|entries
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|add_threads
parameter_list|(
name|struct
name|trussinfo
modifier|*
name|info
parameter_list|,
name|struct
name|procinfo
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|ptrace_lwpinfo
name|pl
decl_stmt|;
name|struct
name|threadinfo
modifier|*
name|t
decl_stmt|;
name|lwpid_t
modifier|*
name|lwps
decl_stmt|;
name|int
name|i
decl_stmt|,
name|nlwps
decl_stmt|;
name|nlwps
operator|=
name|ptrace
argument_list|(
name|PT_GETNUMLWPS
argument_list|,
name|p
operator|->
name|pid
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nlwps
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"Unable to fetch number of LWPs"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|nlwps
operator|>
literal|0
argument_list|)
expr_stmt|;
name|lwps
operator|=
name|calloc
argument_list|(
name|nlwps
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lwps
argument_list|)
argument_list|)
expr_stmt|;
name|nlwps
operator|=
name|ptrace
argument_list|(
name|PT_GETLWPLIST
argument_list|,
name|p
operator|->
name|pid
argument_list|,
operator|(
name|caddr_t
operator|)
name|lwps
argument_list|,
name|nlwps
argument_list|)
expr_stmt|;
if|if
condition|(
name|nlwps
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"Unable to fetch LWP list"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nlwps
condition|;
name|i
operator|++
control|)
block|{
name|t
operator|=
name|new_thread
argument_list|(
name|p
argument_list|,
name|lwps
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptrace
argument_list|(
name|PT_LWPINFO
argument_list|,
name|lwps
index|[
name|i
index|]
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|pl
argument_list|,
sizeof|sizeof
argument_list|(
name|pl
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"ptrace(PT_LWPINFO)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pl
operator|.
name|pl_flags
operator|&
name|PL_FLAG_SCE
condition|)
block|{
name|info
operator|->
name|curthread
operator|=
name|t
expr_stmt|;
name|enter_syscall
argument_list|(
name|info
argument_list|,
name|t
argument_list|,
operator|&
name|pl
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|lwps
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|new_proc
parameter_list|(
name|struct
name|trussinfo
modifier|*
name|info
parameter_list|,
name|pid_t
name|pid
parameter_list|,
name|lwpid_t
name|lwpid
parameter_list|)
block|{
name|struct
name|procinfo
modifier|*
name|np
decl_stmt|;
comment|/* 	 * If this happens it means there is a bug in truss.  Unfortunately 	 * this will kill any processes truss is attached to. 	 */
name|LIST_FOREACH
argument_list|(
argument|np
argument_list|,
argument|&info->proclist
argument_list|,
argument|entries
argument_list|)
block|{
if|if
condition|(
name|np
operator|->
name|pid
operator|==
name|pid
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Duplicate process for pid %ld"
argument_list|,
operator|(
name|long
operator|)
name|pid
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|info
operator|->
name|flags
operator|&
name|FOLLOWFORKS
condition|)
if|if
condition|(
name|ptrace
argument_list|(
name|PT_FOLLOW_FORK
argument_list|,
name|pid
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"Unable to follow forks for pid %ld"
argument_list|,
operator|(
name|long
operator|)
name|pid
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptrace
argument_list|(
name|PT_LWP_EVENTS
argument_list|,
name|pid
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"Unable to enable LWP events for pid %ld"
argument_list|,
operator|(
name|long
operator|)
name|pid
argument_list|)
expr_stmt|;
name|np
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|procinfo
argument_list|)
argument_list|)
expr_stmt|;
name|np
operator|->
name|pid
operator|=
name|pid
expr_stmt|;
name|np
operator|->
name|abi
operator|=
name|find_abi
argument_list|(
name|pid
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|np
operator|->
name|threadlist
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|info
operator|->
name|proclist
argument_list|,
name|np
argument_list|,
name|entries
argument_list|)
expr_stmt|;
if|if
condition|(
name|lwpid
operator|!=
literal|0
condition|)
name|new_thread
argument_list|(
name|np
argument_list|,
name|lwpid
argument_list|)
expr_stmt|;
else|else
name|add_threads
argument_list|(
name|info
argument_list|,
name|np
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_proc
parameter_list|(
name|struct
name|procinfo
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|threadinfo
modifier|*
name|t
decl_stmt|,
modifier|*
name|t2
decl_stmt|;
name|LIST_FOREACH_SAFE
argument_list|(
argument|t
argument_list|,
argument|&p->threadlist
argument_list|,
argument|entries
argument_list|,
argument|t2
argument_list|)
block|{
name|free
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
name|LIST_REMOVE
argument_list|(
name|p
argument_list|,
name|entries
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|detach_all_procs
parameter_list|(
name|struct
name|trussinfo
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|procinfo
modifier|*
name|p
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
name|LIST_FOREACH_SAFE
argument_list|(
argument|p
argument_list|,
argument|&info->proclist
argument_list|,
argument|entries
argument_list|,
argument|p2
argument_list|)
block|{
name|detach_proc
argument_list|(
name|p
operator|->
name|pid
argument_list|)
expr_stmt|;
name|free_proc
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|struct
name|procinfo
modifier|*
name|find_proc
parameter_list|(
name|struct
name|trussinfo
modifier|*
name|info
parameter_list|,
name|pid_t
name|pid
parameter_list|)
block|{
name|struct
name|procinfo
modifier|*
name|np
decl_stmt|;
name|LIST_FOREACH
argument_list|(
argument|np
argument_list|,
argument|&info->proclist
argument_list|,
argument|entries
argument_list|)
block|{
if|if
condition|(
name|np
operator|->
name|pid
operator|==
name|pid
condition|)
return|return
operator|(
name|np
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Change curthread member based on (pid, lwpid).  */
end_comment

begin_function
specifier|static
name|void
name|find_thread
parameter_list|(
name|struct
name|trussinfo
modifier|*
name|info
parameter_list|,
name|pid_t
name|pid
parameter_list|,
name|lwpid_t
name|lwpid
parameter_list|)
block|{
name|struct
name|procinfo
modifier|*
name|np
decl_stmt|;
name|struct
name|threadinfo
modifier|*
name|nt
decl_stmt|;
name|np
operator|=
name|find_proc
argument_list|(
name|info
argument_list|,
name|pid
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|np
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|nt
argument_list|,
argument|&np->threadlist
argument_list|,
argument|entries
argument_list|)
block|{
if|if
condition|(
name|nt
operator|->
name|tid
operator|==
name|lwpid
condition|)
block|{
name|info
operator|->
name|curthread
operator|=
name|nt
expr_stmt|;
return|return;
block|}
block|}
name|errx
argument_list|(
literal|1
argument_list|,
literal|"could not find thread"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * When a process exits, it should have exactly one thread left.  * All of the other threads should have reported thread exit events.  */
end_comment

begin_function
specifier|static
name|void
name|find_exit_thread
parameter_list|(
name|struct
name|trussinfo
modifier|*
name|info
parameter_list|,
name|pid_t
name|pid
parameter_list|)
block|{
name|struct
name|procinfo
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|find_proc
argument_list|(
name|info
argument_list|,
name|pid
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|p
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|info
operator|->
name|curthread
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|p
operator|->
name|threadlist
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|info
operator|->
name|curthread
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|LIST_NEXT
argument_list|(
name|info
operator|->
name|curthread
argument_list|,
name|entries
argument_list|)
operator|==
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|alloc_syscall
parameter_list|(
name|struct
name|threadinfo
modifier|*
name|t
parameter_list|,
name|struct
name|ptrace_lwpinfo
modifier|*
name|pl
parameter_list|)
block|{
name|u_int
name|i
decl_stmt|;
name|assert
argument_list|(
name|t
operator|->
name|in_syscall
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|t
operator|->
name|cs
operator|.
name|number
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|t
operator|->
name|cs
operator|.
name|sc
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|t
operator|->
name|cs
operator|.
name|nargs
operator|==
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|t
operator|->
name|cs
operator|.
name|s_args
argument_list|)
condition|;
name|i
operator|++
control|)
name|assert
argument_list|(
name|t
operator|->
name|cs
operator|.
name|s_args
index|[
name|i
index|]
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|t
operator|->
name|cs
operator|.
name|args
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t
operator|->
name|cs
operator|.
name|args
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|->
name|cs
operator|.
name|number
operator|=
name|pl
operator|->
name|pl_syscall_code
expr_stmt|;
name|t
operator|->
name|in_syscall
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_syscall
parameter_list|(
name|struct
name|threadinfo
modifier|*
name|t
parameter_list|)
block|{
name|u_int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|t
operator|->
name|cs
operator|.
name|nargs
condition|;
name|i
operator|++
control|)
name|free
argument_list|(
name|t
operator|->
name|cs
operator|.
name|s_args
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|t
operator|->
name|cs
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t
operator|->
name|cs
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|->
name|in_syscall
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|enter_syscall
parameter_list|(
name|struct
name|trussinfo
modifier|*
name|info
parameter_list|,
name|struct
name|threadinfo
modifier|*
name|t
parameter_list|,
name|struct
name|ptrace_lwpinfo
modifier|*
name|pl
parameter_list|)
block|{
name|struct
name|syscall
modifier|*
name|sc
decl_stmt|;
name|u_int
name|i
decl_stmt|,
name|narg
decl_stmt|;
name|alloc_syscall
argument_list|(
name|t
argument_list|,
name|pl
argument_list|)
expr_stmt|;
name|narg
operator|=
name|MIN
argument_list|(
name|pl
operator|->
name|pl_syscall_narg
argument_list|,
name|nitems
argument_list|(
name|t
operator|->
name|cs
operator|.
name|args
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|narg
operator|!=
literal|0
operator|&&
name|t
operator|->
name|proc
operator|->
name|abi
operator|->
name|fetch_args
argument_list|(
name|info
argument_list|,
name|narg
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|free_syscall
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return;
block|}
name|sc
operator|=
name|get_syscall
argument_list|(
name|t
argument_list|,
name|t
operator|->
name|cs
operator|.
name|number
argument_list|,
name|narg
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|unknown
condition|)
name|fprintf
argument_list|(
name|info
operator|->
name|outfile
argument_list|,
literal|"-- UNKNOWN %s SYSCALL %d --\n"
argument_list|,
name|t
operator|->
name|proc
operator|->
name|abi
operator|->
name|type
argument_list|,
name|t
operator|->
name|cs
operator|.
name|number
argument_list|)
expr_stmt|;
name|t
operator|->
name|cs
operator|.
name|nargs
operator|=
name|sc
operator|->
name|nargs
expr_stmt|;
name|assert
argument_list|(
name|sc
operator|->
name|nargs
operator|<=
name|nitems
argument_list|(
name|t
operator|->
name|cs
operator|.
name|s_args
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|->
name|cs
operator|.
name|sc
operator|=
name|sc
expr_stmt|;
comment|/* 	 * At this point, we set up the system call arguments. 	 * We ignore any OUT ones, however -- those are arguments that 	 * are set by the system call, and so are probably meaningless 	 * now.	This doesn't currently support arguments that are 	 * passed in *and* out, however. 	 */
if|#
directive|if
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"syscall %s("
argument_list|,
name|sc
operator|->
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|t
operator|->
name|cs
operator|.
name|nargs
condition|;
name|i
operator|++
control|)
block|{
if|#
directive|if
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"0x%lx%s"
argument_list|,
name|t
operator|->
name|cs
operator|.
name|args
index|[
name|sc
operator|->
name|args
index|[
name|i
index|]
operator|.
name|offset
index|]
argument_list|,
name|i
operator|<
operator|(
name|t
operator|->
name|cs
operator|.
name|nargs
operator|-
literal|1
operator|)
condition|?
literal|","
else|:
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|args
index|[
name|i
index|]
operator|.
name|type
operator|&
name|OUT
operator|)
condition|)
block|{
name|t
operator|->
name|cs
operator|.
name|s_args
index|[
name|i
index|]
operator|=
name|print_arg
argument_list|(
operator|&
name|sc
operator|->
name|args
index|[
name|i
index|]
argument_list|,
name|t
operator|->
name|cs
operator|.
name|args
argument_list|,
literal|0
argument_list|,
name|info
argument_list|)
expr_stmt|;
block|}
block|}
if|#
directive|if
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|")\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|clock_gettime
argument_list|(
name|CLOCK_REALTIME
argument_list|,
operator|&
name|t
operator|->
name|before
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * When a thread exits voluntarily (including when a thread calls  * exit() to trigger a process exit), the thread's internal state  * holds the arguments passed to the exit system call.  When the  * thread's exit is reported, log that system call without a return  * value.  */
end_comment

begin_function
specifier|static
name|void
name|thread_exit_syscall
parameter_list|(
name|struct
name|trussinfo
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|threadinfo
modifier|*
name|t
decl_stmt|;
name|t
operator|=
name|info
operator|->
name|curthread
expr_stmt|;
if|if
condition|(
operator|!
name|t
operator|->
name|in_syscall
condition|)
return|return;
name|clock_gettime
argument_list|(
name|CLOCK_REALTIME
argument_list|,
operator|&
name|t
operator|->
name|after
argument_list|)
expr_stmt|;
name|print_syscall_ret
argument_list|(
name|info
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|free_syscall
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|exit_syscall
parameter_list|(
name|struct
name|trussinfo
modifier|*
name|info
parameter_list|,
name|struct
name|ptrace_lwpinfo
modifier|*
name|pl
parameter_list|)
block|{
name|struct
name|threadinfo
modifier|*
name|t
decl_stmt|;
name|struct
name|procinfo
modifier|*
name|p
decl_stmt|;
name|struct
name|syscall
modifier|*
name|sc
decl_stmt|;
name|long
name|retval
index|[
literal|2
index|]
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|int
name|errorp
decl_stmt|;
name|t
operator|=
name|info
operator|->
name|curthread
expr_stmt|;
if|if
condition|(
operator|!
name|t
operator|->
name|in_syscall
condition|)
return|return;
name|clock_gettime
argument_list|(
name|CLOCK_REALTIME
argument_list|,
operator|&
name|t
operator|->
name|after
argument_list|)
expr_stmt|;
name|p
operator|=
name|t
operator|->
name|proc
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|abi
operator|->
name|fetch_retval
argument_list|(
name|info
argument_list|,
name|retval
argument_list|,
operator|&
name|errorp
argument_list|)
operator|<
literal|0
condition|)
block|{
name|free_syscall
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return;
block|}
name|sc
operator|=
name|t
operator|->
name|cs
operator|.
name|sc
expr_stmt|;
comment|/* 	 * Here, we only look for arguments that have OUT masked in -- 	 * otherwise, they were handled in enter_syscall(). 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|nargs
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|temp
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|args
index|[
name|i
index|]
operator|.
name|type
operator|&
name|OUT
condition|)
block|{
comment|/* 			 * If an error occurred, then don't bother 			 * getting the data; it may not be valid. 			 */
if|if
condition|(
name|errorp
condition|)
block|{
name|asprintf
argument_list|(
operator|&
name|temp
argument_list|,
literal|"0x%lx"
argument_list|,
name|t
operator|->
name|cs
operator|.
name|args
index|[
name|sc
operator|->
name|args
index|[
name|i
index|]
operator|.
name|offset
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|temp
operator|=
name|print_arg
argument_list|(
operator|&
name|sc
operator|->
name|args
index|[
name|i
index|]
argument_list|,
name|t
operator|->
name|cs
operator|.
name|args
argument_list|,
name|retval
argument_list|,
name|info
argument_list|)
expr_stmt|;
block|}
name|t
operator|->
name|cs
operator|.
name|s_args
index|[
name|i
index|]
operator|=
name|temp
expr_stmt|;
block|}
block|}
name|print_syscall_ret
argument_list|(
name|info
argument_list|,
name|errorp
argument_list|,
name|retval
argument_list|)
expr_stmt|;
name|free_syscall
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* 	 * If the process executed a new image, check the ABI.  If the 	 * new ABI isn't supported, stop tracing this process. 	 */
if|if
condition|(
name|pl
operator|->
name|pl_flags
operator|&
name|PL_FLAG_EXEC
condition|)
block|{
name|assert
argument_list|(
name|LIST_NEXT
argument_list|(
name|LIST_FIRST
argument_list|(
operator|&
name|p
operator|->
name|threadlist
argument_list|)
argument_list|,
name|entries
argument_list|)
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|p
operator|->
name|abi
operator|=
name|find_abi
argument_list|(
name|p
operator|->
name|pid
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|abi
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|ptrace
argument_list|(
name|PT_DETACH
argument_list|,
name|p
operator|->
name|pid
argument_list|,
operator|(
name|caddr_t
operator|)
literal|1
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"Can not detach the process"
argument_list|)
expr_stmt|;
name|free_proc
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|int
name|print_line_prefix
parameter_list|(
name|struct
name|trussinfo
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|timespec
name|timediff
decl_stmt|;
name|struct
name|threadinfo
modifier|*
name|t
decl_stmt|;
name|int
name|len
decl_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
name|t
operator|=
name|info
operator|->
name|curthread
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|flags
operator|&
operator|(
name|FOLLOWFORKS
operator||
name|DISPLAYTIDS
operator|)
condition|)
block|{
if|if
condition|(
name|info
operator|->
name|flags
operator|&
name|FOLLOWFORKS
condition|)
name|len
operator|+=
name|fprintf
argument_list|(
name|info
operator|->
name|outfile
argument_list|,
literal|"%5d"
argument_list|,
name|t
operator|->
name|proc
operator|->
name|pid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|info
operator|->
name|flags
operator|&
operator|(
name|FOLLOWFORKS
operator||
name|DISPLAYTIDS
operator|)
operator|)
operator|==
operator|(
name|FOLLOWFORKS
operator||
name|DISPLAYTIDS
operator|)
condition|)
name|len
operator|+=
name|fprintf
argument_list|(
name|info
operator|->
name|outfile
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|flags
operator|&
name|DISPLAYTIDS
condition|)
name|len
operator|+=
name|fprintf
argument_list|(
name|info
operator|->
name|outfile
argument_list|,
literal|"%6d"
argument_list|,
name|t
operator|->
name|tid
argument_list|)
expr_stmt|;
name|len
operator|+=
name|fprintf
argument_list|(
name|info
operator|->
name|outfile
argument_list|,
literal|": "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|info
operator|->
name|flags
operator|&
name|ABSOLUTETIMESTAMPS
condition|)
block|{
name|timespecsubt
argument_list|(
operator|&
name|t
operator|->
name|after
argument_list|,
operator|&
name|info
operator|->
name|start_time
argument_list|,
operator|&
name|timediff
argument_list|)
expr_stmt|;
name|len
operator|+=
name|fprintf
argument_list|(
name|info
operator|->
name|outfile
argument_list|,
literal|"%jd.%09ld "
argument_list|,
operator|(
name|intmax_t
operator|)
name|timediff
operator|.
name|tv_sec
argument_list|,
name|timediff
operator|.
name|tv_nsec
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|info
operator|->
name|flags
operator|&
name|RELATIVETIMESTAMPS
condition|)
block|{
name|timespecsubt
argument_list|(
operator|&
name|t
operator|->
name|after
argument_list|,
operator|&
name|t
operator|->
name|before
argument_list|,
operator|&
name|timediff
argument_list|)
expr_stmt|;
name|len
operator|+=
name|fprintf
argument_list|(
name|info
operator|->
name|outfile
argument_list|,
literal|"%jd.%09ld "
argument_list|,
operator|(
name|intmax_t
operator|)
name|timediff
operator|.
name|tv_sec
argument_list|,
name|timediff
operator|.
name|tv_nsec
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|len
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|report_thread_death
parameter_list|(
name|struct
name|trussinfo
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|threadinfo
modifier|*
name|t
decl_stmt|;
name|t
operator|=
name|info
operator|->
name|curthread
expr_stmt|;
name|clock_gettime
argument_list|(
name|CLOCK_REALTIME
argument_list|,
operator|&
name|t
operator|->
name|after
argument_list|)
expr_stmt|;
name|print_line_prefix
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|info
operator|->
name|outfile
argument_list|,
literal|"<thread %ld exited>\n"
argument_list|,
operator|(
name|long
operator|)
name|t
operator|->
name|tid
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|report_thread_birth
parameter_list|(
name|struct
name|trussinfo
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|threadinfo
modifier|*
name|t
decl_stmt|;
name|t
operator|=
name|info
operator|->
name|curthread
expr_stmt|;
name|clock_gettime
argument_list|(
name|CLOCK_REALTIME
argument_list|,
operator|&
name|t
operator|->
name|after
argument_list|)
expr_stmt|;
name|t
operator|->
name|before
operator|=
name|t
operator|->
name|after
expr_stmt|;
name|print_line_prefix
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|info
operator|->
name|outfile
argument_list|,
literal|"<new thread %ld>\n"
argument_list|,
operator|(
name|long
operator|)
name|t
operator|->
name|tid
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|report_exit
parameter_list|(
name|struct
name|trussinfo
modifier|*
name|info
parameter_list|,
name|siginfo_t
modifier|*
name|si
parameter_list|)
block|{
name|struct
name|threadinfo
modifier|*
name|t
decl_stmt|;
name|t
operator|=
name|info
operator|->
name|curthread
expr_stmt|;
name|clock_gettime
argument_list|(
name|CLOCK_REALTIME
argument_list|,
operator|&
name|t
operator|->
name|after
argument_list|)
expr_stmt|;
name|print_line_prefix
argument_list|(
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|si
operator|->
name|si_code
operator|==
name|CLD_EXITED
condition|)
name|fprintf
argument_list|(
name|info
operator|->
name|outfile
argument_list|,
literal|"process exit, rval = %u\n"
argument_list|,
name|si
operator|->
name|si_status
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|info
operator|->
name|outfile
argument_list|,
literal|"process killed, signal = %u%s\n"
argument_list|,
name|si
operator|->
name|si_status
argument_list|,
name|si
operator|->
name|si_code
operator|==
name|CLD_DUMPED
condition|?
literal|" (core dumped)"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|report_new_child
parameter_list|(
name|struct
name|trussinfo
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|threadinfo
modifier|*
name|t
decl_stmt|;
name|t
operator|=
name|info
operator|->
name|curthread
expr_stmt|;
name|clock_gettime
argument_list|(
name|CLOCK_REALTIME
argument_list|,
operator|&
name|t
operator|->
name|after
argument_list|)
expr_stmt|;
name|t
operator|->
name|before
operator|=
name|t
operator|->
name|after
expr_stmt|;
name|print_line_prefix
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|info
operator|->
name|outfile
argument_list|,
literal|"<new process>\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|decode_siginfo
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|siginfo_t
modifier|*
name|si
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" code="
argument_list|)
expr_stmt|;
name|str
operator|=
name|sysdecode_sigcode
argument_list|(
name|si
operator|->
name|si_signo
argument_list|,
name|si
operator|->
name|si_code
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
operator|==
name|NULL
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%d"
argument_list|,
name|si
operator|->
name|si_code
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s"
argument_list|,
name|str
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|si
operator|->
name|si_code
condition|)
block|{
case|case
name|SI_NOINFO
case|:
break|break;
case|case
name|SI_QUEUE
case|:
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" value=%p"
argument_list|,
name|si
operator|->
name|si_value
operator|.
name|sival_ptr
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|SI_USER
case|:
case|case
name|SI_LWP
case|:
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" pid=%jd uid=%jd"
argument_list|,
operator|(
name|intmax_t
operator|)
name|si
operator|->
name|si_pid
argument_list|,
operator|(
name|intmax_t
operator|)
name|si
operator|->
name|si_uid
argument_list|)
expr_stmt|;
break|break;
case|case
name|SI_TIMER
case|:
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" value=%p"
argument_list|,
name|si
operator|->
name|si_value
operator|.
name|sival_ptr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" timerid=%d"
argument_list|,
name|si
operator|->
name|si_timerid
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" overrun=%d"
argument_list|,
name|si
operator|->
name|si_overrun
argument_list|)
expr_stmt|;
if|if
condition|(
name|si
operator|->
name|si_errno
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" errno=%d"
argument_list|,
name|si
operator|->
name|si_errno
argument_list|)
expr_stmt|;
break|break;
case|case
name|SI_ASYNCIO
case|:
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" value=%p"
argument_list|,
name|si
operator|->
name|si_value
operator|.
name|sival_ptr
argument_list|)
expr_stmt|;
break|break;
case|case
name|SI_MESGQ
case|:
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" value=%p"
argument_list|,
name|si
operator|->
name|si_value
operator|.
name|sival_ptr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" mqd=%d"
argument_list|,
name|si
operator|->
name|si_mqd
argument_list|)
expr_stmt|;
break|break;
default|default:
switch|switch
condition|(
name|si
operator|->
name|si_signo
condition|)
block|{
case|case
name|SIGILL
case|:
case|case
name|SIGFPE
case|:
case|case
name|SIGSEGV
case|:
case|case
name|SIGBUS
case|:
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" trapno=%d"
argument_list|,
name|si
operator|->
name|si_trapno
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" addr=%p"
argument_list|,
name|si
operator|->
name|si_addr
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIGCHLD
case|:
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" pid=%jd uid=%jd"
argument_list|,
operator|(
name|intmax_t
operator|)
name|si
operator|->
name|si_pid
argument_list|,
operator|(
name|intmax_t
operator|)
name|si
operator|->
name|si_uid
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" status=%d"
argument_list|,
name|si
operator|->
name|si_status
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|report_signal
parameter_list|(
name|struct
name|trussinfo
modifier|*
name|info
parameter_list|,
name|siginfo_t
modifier|*
name|si
parameter_list|,
name|struct
name|ptrace_lwpinfo
modifier|*
name|pl
parameter_list|)
block|{
name|struct
name|threadinfo
modifier|*
name|t
decl_stmt|;
specifier|const
name|char
modifier|*
name|signame
decl_stmt|;
name|t
operator|=
name|info
operator|->
name|curthread
expr_stmt|;
name|clock_gettime
argument_list|(
name|CLOCK_REALTIME
argument_list|,
operator|&
name|t
operator|->
name|after
argument_list|)
expr_stmt|;
name|print_line_prefix
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|signame
operator|=
name|sysdecode_signal
argument_list|(
name|si
operator|->
name|si_status
argument_list|)
expr_stmt|;
if|if
condition|(
name|signame
operator|==
name|NULL
condition|)
name|signame
operator|=
literal|"?"
expr_stmt|;
name|fprintf
argument_list|(
name|info
operator|->
name|outfile
argument_list|,
literal|"SIGNAL %u (%s)"
argument_list|,
name|si
operator|->
name|si_status
argument_list|,
name|signame
argument_list|)
expr_stmt|;
if|if
condition|(
name|pl
operator|->
name|pl_event
operator|==
name|PL_EVENT_SIGNAL
operator|&&
name|pl
operator|->
name|pl_flags
operator|&
name|PL_FLAG_SI
condition|)
name|decode_siginfo
argument_list|(
name|info
operator|->
name|outfile
argument_list|,
operator|&
name|pl
operator|->
name|pl_siginfo
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|info
operator|->
name|outfile
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Wait for events until all the processes have exited or truss has been  * asked to stop.  */
end_comment

begin_function
name|void
name|eventloop
parameter_list|(
name|struct
name|trussinfo
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|ptrace_lwpinfo
name|pl
decl_stmt|;
name|siginfo_t
name|si
decl_stmt|;
name|int
name|pending_signal
decl_stmt|;
while|while
condition|(
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|info
operator|->
name|proclist
argument_list|)
condition|)
block|{
if|if
condition|(
name|detaching
condition|)
block|{
name|detach_all_procs
argument_list|(
name|info
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|waitid
argument_list|(
name|P_ALL
argument_list|,
literal|0
argument_list|,
operator|&
name|si
argument_list|,
name|WTRAPPED
operator||
name|WEXITED
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EINTR
condition|)
continue|continue;
name|err
argument_list|(
literal|1
argument_list|,
literal|"Unexpected error from waitid"
argument_list|)
expr_stmt|;
block|}
name|assert
argument_list|(
name|si
operator|.
name|si_signo
operator|==
name|SIGCHLD
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|si
operator|.
name|si_code
condition|)
block|{
case|case
name|CLD_EXITED
case|:
case|case
name|CLD_KILLED
case|:
case|case
name|CLD_DUMPED
case|:
name|find_exit_thread
argument_list|(
name|info
argument_list|,
name|si
operator|.
name|si_pid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|info
operator|->
name|flags
operator|&
name|COUNTONLY
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|si
operator|.
name|si_code
operator|==
name|CLD_EXITED
condition|)
name|thread_exit_syscall
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|report_exit
argument_list|(
name|info
argument_list|,
operator|&
name|si
argument_list|)
expr_stmt|;
block|}
name|free_proc
argument_list|(
name|info
operator|->
name|curthread
operator|->
name|proc
argument_list|)
expr_stmt|;
name|info
operator|->
name|curthread
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|CLD_TRAPPED
case|:
if|if
condition|(
name|ptrace
argument_list|(
name|PT_LWPINFO
argument_list|,
name|si
operator|.
name|si_pid
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|pl
argument_list|,
sizeof|sizeof
argument_list|(
name|pl
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"ptrace(PT_LWPINFO)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pl
operator|.
name|pl_flags
operator|&
name|PL_FLAG_CHILD
condition|)
block|{
name|new_proc
argument_list|(
name|info
argument_list|,
name|si
operator|.
name|si_pid
argument_list|,
name|pl
operator|.
name|pl_lwpid
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|LIST_FIRST
argument_list|(
operator|&
name|info
operator|->
name|proclist
argument_list|)
operator|->
name|abi
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pl
operator|.
name|pl_flags
operator|&
name|PL_FLAG_BORN
condition|)
name|new_thread
argument_list|(
name|find_proc
argument_list|(
name|info
argument_list|,
name|si
operator|.
name|si_pid
argument_list|)
argument_list|,
name|pl
operator|.
name|pl_lwpid
argument_list|)
expr_stmt|;
name|find_thread
argument_list|(
name|info
argument_list|,
name|si
operator|.
name|si_pid
argument_list|,
name|pl
operator|.
name|pl_lwpid
argument_list|)
expr_stmt|;
if|if
condition|(
name|si
operator|.
name|si_status
operator|==
name|SIGTRAP
operator|&&
operator|(
name|pl
operator|.
name|pl_flags
operator|&
operator|(
name|PL_FLAG_BORN
operator||
name|PL_FLAG_EXITED
operator||
name|PL_FLAG_SCE
operator||
name|PL_FLAG_SCX
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|pl
operator|.
name|pl_flags
operator|&
name|PL_FLAG_BORN
condition|)
block|{
if|if
condition|(
operator|(
name|info
operator|->
name|flags
operator|&
name|COUNTONLY
operator|)
operator|==
literal|0
condition|)
name|report_thread_birth
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pl
operator|.
name|pl_flags
operator|&
name|PL_FLAG_EXITED
condition|)
block|{
if|if
condition|(
operator|(
name|info
operator|->
name|flags
operator|&
name|COUNTONLY
operator|)
operator|==
literal|0
condition|)
name|report_thread_death
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|free_thread
argument_list|(
name|info
operator|->
name|curthread
argument_list|)
expr_stmt|;
name|info
operator|->
name|curthread
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pl
operator|.
name|pl_flags
operator|&
name|PL_FLAG_SCE
condition|)
name|enter_syscall
argument_list|(
name|info
argument_list|,
name|info
operator|->
name|curthread
argument_list|,
operator|&
name|pl
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pl
operator|.
name|pl_flags
operator|&
name|PL_FLAG_SCX
condition|)
name|exit_syscall
argument_list|(
name|info
argument_list|,
operator|&
name|pl
argument_list|)
expr_stmt|;
name|pending_signal
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pl
operator|.
name|pl_flags
operator|&
name|PL_FLAG_CHILD
condition|)
block|{
if|if
condition|(
operator|(
name|info
operator|->
name|flags
operator|&
name|COUNTONLY
operator|)
operator|==
literal|0
condition|)
name|report_new_child
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|pending_signal
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|info
operator|->
name|flags
operator|&
name|NOSIGS
operator|)
operator|==
literal|0
condition|)
name|report_signal
argument_list|(
name|info
argument_list|,
operator|&
name|si
argument_list|,
operator|&
name|pl
argument_list|)
expr_stmt|;
name|pending_signal
operator|=
name|si
operator|.
name|si_status
expr_stmt|;
block|}
name|ptrace
argument_list|(
name|PT_SYSCALL
argument_list|,
name|si
operator|.
name|si_pid
argument_list|,
operator|(
name|caddr_t
operator|)
literal|1
argument_list|,
name|pending_signal
argument_list|)
expr_stmt|;
break|break;
case|case
name|CLD_STOPPED
case|:
name|errx
argument_list|(
literal|1
argument_list|,
literal|"waitid reported CLD_STOPPED"
argument_list|)
expr_stmt|;
case|case
name|CLD_CONTINUED
case|:
break|break;
block|}
block|}
block|}
end_function

end_unit

