begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copryight 1997 Sean Eric Fagan  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by Sean Eric Fagan  * 4. Neither the name of the author may be used to endorse or promote  *    products derived from this software without specific prior written  *    permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Various setup functions for truss.  Not the cleanest-written code,  * I'm afraid.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/ptrace.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<machine/reg.h>
end_include

begin_include
include|#
directive|include
file|"truss.h"
end_include

begin_include
include|#
directive|include
file|"extern.h"
end_include

begin_decl_stmt
specifier|static
name|int
name|child_pid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * setup_and_wait() is called to start a process.  All it really does  * is fork(), set itself up to stop on exec or exit, and then exec  * the given command.  At that point, the child process stops, and  * the parent can wake up and deal with it.  */
end_comment

begin_function
name|int
name|setup_and_wait
parameter_list|(
name|char
modifier|*
name|command
index|[]
parameter_list|)
block|{
name|int
name|pid
decl_stmt|;
name|int
name|waitval
decl_stmt|;
name|pid
operator|=
name|vfork
argument_list|()
expr_stmt|;
if|if
condition|(
name|pid
operator|==
operator|-
literal|1
condition|)
block|{
name|err
argument_list|(
literal|1
argument_list|,
literal|"fork failed"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
block|{
comment|/* Child */
name|ptrace
argument_list|(
name|PT_TRACE_ME
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|execvp
argument_list|(
name|command
index|[
literal|0
index|]
argument_list|,
name|command
argument_list|)
expr_stmt|;
name|err
argument_list|(
literal|1
argument_list|,
literal|"execvp %s"
argument_list|,
name|command
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Only in the parent here */
if|if
condition|(
name|waitpid
argument_list|(
name|pid
argument_list|,
operator|&
name|waitval
argument_list|,
literal|0
argument_list|)
operator|<
operator|-
literal|1
condition|)
block|{
name|err
argument_list|(
literal|1
argument_list|,
literal|"unexpect stop in waitpid"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|child_pid
operator|=
name|pid
expr_stmt|;
return|return
operator|(
name|pid
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * start_tracing picks up where setup_and_wait() dropped off -- namely,  * it sets the event mask for the given process id.  Called for both  * monitoring an existing process and when we create our own.  */
end_comment

begin_function
name|int
name|start_tracing
parameter_list|(
name|int
name|pid
parameter_list|)
block|{
name|int
name|waitval
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|int
name|retry
init|=
literal|10
decl_stmt|;
do|do
block|{
name|ret
operator|=
name|ptrace
argument_list|(
name|PT_ATTACH
argument_list|,
name|pid
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|usleep
argument_list|(
literal|200
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|ret
operator|&&
name|retry
operator|--
operator|>
literal|0
condition|)
do|;
if|if
condition|(
name|ret
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"can not attach to target process"
argument_list|)
expr_stmt|;
name|child_pid
operator|=
name|pid
expr_stmt|;
if|if
condition|(
name|waitpid
argument_list|(
name|pid
argument_list|,
operator|&
name|waitval
argument_list|,
literal|0
argument_list|)
operator|<
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"Unexpect stop in waitpid"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Restore a process back to it's pre-truss state.  * Called for SIGINT, SIGTERM, SIGQUIT.  This only  * applies if truss was told to monitor an already-existing  * process.  */
end_comment

begin_function
name|void
name|restore_proc
parameter_list|(
name|int
name|signo
name|__unused
parameter_list|)
block|{
name|int
name|waitval
decl_stmt|;
comment|/* stop the child so that we can detach */
name|kill
argument_list|(
name|child_pid
argument_list|,
name|SIGSTOP
argument_list|)
expr_stmt|;
if|if
condition|(
name|waitpid
argument_list|(
name|child_pid
argument_list|,
operator|&
name|waitval
argument_list|,
literal|0
argument_list|)
operator|<
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"Unexpected stop in waitpid"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptrace
argument_list|(
name|PT_DETACH
argument_list|,
name|child_pid
argument_list|,
operator|(
name|caddr_t
operator|)
literal|1
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"Can not detach the process"
argument_list|)
expr_stmt|;
name|kill
argument_list|(
name|child_pid
argument_list|,
name|SIGCONT
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Change curthread member based on lwpid.  * If it is a new thread, create a threadinfo structure  */
end_comment

begin_function
specifier|static
name|void
name|find_thread
parameter_list|(
name|struct
name|trussinfo
modifier|*
name|info
parameter_list|,
name|lwpid_t
name|lwpid
parameter_list|)
block|{
name|info
operator|->
name|curthread
operator|=
name|NULL
expr_stmt|;
name|struct
name|threadinfo
modifier|*
name|np
decl_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|np
argument_list|,
argument|&info->threadlist
argument_list|,
argument|entries
argument_list|)
block|{
if|if
condition|(
name|np
operator|->
name|tid
operator|==
name|lwpid
condition|)
block|{
name|info
operator|->
name|curthread
operator|=
name|np
expr_stmt|;
return|return;
block|}
block|}
name|np
operator|=
operator|(
expr|struct
name|threadinfo
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|threadinfo
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"malloc() failed"
argument_list|)
expr_stmt|;
name|np
operator|->
name|tid
operator|=
name|lwpid
expr_stmt|;
name|np
operator|->
name|in_fork
operator|=
literal|0
expr_stmt|;
name|np
operator|->
name|in_syscall
operator|=
literal|0
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|info
operator|->
name|threadlist
argument_list|,
name|np
argument_list|,
name|entries
argument_list|)
expr_stmt|;
name|info
operator|->
name|curthread
operator|=
name|np
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Start the traced process and wait until it stoped.  * Fill trussinfo structure.  * When this even returns, the traced process is in stop state.  */
end_comment

begin_function
name|void
name|waitevent
parameter_list|(
name|struct
name|trussinfo
modifier|*
name|info
parameter_list|)
block|{
name|int
name|waitval
decl_stmt|;
specifier|static
name|int
name|pending_signal
init|=
literal|0
decl_stmt|;
name|ptrace
argument_list|(
name|PT_SYSCALL
argument_list|,
name|info
operator|->
name|pid
argument_list|,
operator|(
name|caddr_t
operator|)
literal|1
argument_list|,
name|pending_signal
argument_list|)
expr_stmt|;
name|pending_signal
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|waitpid
argument_list|(
name|info
operator|->
name|pid
argument_list|,
operator|&
name|waitval
argument_list|,
literal|0
argument_list|)
operator|<
operator|-
literal|1
condition|)
block|{
name|err
argument_list|(
literal|1
argument_list|,
literal|"Unexpected stop in waitpid"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|WIFCONTINUED
argument_list|(
name|waitval
argument_list|)
condition|)
block|{
name|info
operator|->
name|pr_why
operator|=
name|S_NONE
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|WIFEXITED
argument_list|(
name|waitval
argument_list|)
condition|)
block|{
name|info
operator|->
name|pr_why
operator|=
name|S_EXIT
expr_stmt|;
name|info
operator|->
name|pr_data
operator|=
name|WEXITSTATUS
argument_list|(
name|waitval
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|WIFSTOPPED
argument_list|(
name|waitval
argument_list|)
condition|)
block|{
name|struct
name|ptrace_lwpinfo
name|lwpinfo
decl_stmt|;
name|ptrace
argument_list|(
name|PT_LWPINFO
argument_list|,
name|info
operator|->
name|pid
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|lwpinfo
argument_list|,
sizeof|sizeof
argument_list|(
name|lwpinfo
argument_list|)
argument_list|)
expr_stmt|;
name|find_thread
argument_list|(
name|info
argument_list|,
name|lwpinfo
operator|.
name|pl_lwpid
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|WSTOPSIG
argument_list|(
name|waitval
argument_list|)
condition|)
block|{
case|case
name|SIGTRAP
case|:
name|info
operator|->
name|pr_why
operator|=
name|info
operator|->
name|curthread
operator|->
name|in_syscall
condition|?
name|S_SCX
else|:
name|S_SCE
expr_stmt|;
name|info
operator|->
name|curthread
operator|->
name|in_syscall
operator|=
literal|1
operator|-
name|info
operator|->
name|curthread
operator|->
name|in_syscall
expr_stmt|;
break|break;
default|default:
name|info
operator|->
name|pr_why
operator|=
name|S_SIG
expr_stmt|;
name|info
operator|->
name|pr_data
operator|=
name|WSTOPSIG
argument_list|(
name|waitval
argument_list|)
expr_stmt|;
name|pending_signal
operator|=
name|info
operator|->
name|pr_data
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|WIFSIGNALED
argument_list|(
name|waitval
argument_list|)
condition|)
block|{
name|info
operator|->
name|pr_why
operator|=
name|S_EXIT
expr_stmt|;
name|info
operator|->
name|pr_data
operator|=
literal|0
expr_stmt|;
return|return;
block|}
block|}
end_function

end_unit

