begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2002 John Rochester  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer,  *    in this position and unchanged.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/utsname.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<dirent.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stringlist.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<zlib.h>
end_include

begin_define
define|#
directive|define
name|DEFAULT_MANPATH
value|"/usr/share/man"
end_define

begin_define
define|#
directive|define
name|LINE_ALLOC
value|4096
end_define

begin_decl_stmt
specifier|static
name|char
name|blank
index|[]
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Information collected about each man page in a section.  */
end_comment

begin_struct
struct|struct
name|page_info
block|{
name|char
modifier|*
name|filename
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|suffix
decl_stmt|;
name|int
name|gzipped
decl_stmt|;
name|ino_t
name|inode
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * An entry kept for each visited directory.  */
end_comment

begin_struct
struct|struct
name|visited_dir
block|{
name|dev_t
name|device
decl_stmt|;
name|ino_t
name|inode
decl_stmt|;
name|SLIST_ENTRY
argument_list|(
argument|visited_dir
argument_list|)
name|next
expr_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * an expanding string  */
end_comment

begin_struct
struct|struct
name|sbuf
block|{
name|char
modifier|*
name|content
decl_stmt|;
comment|/* the start of the buffer */
name|char
modifier|*
name|end
decl_stmt|;
comment|/* just past the end of the content */
name|char
modifier|*
name|last
decl_stmt|;
comment|/* the last allocated character */
block|}
struct|;
end_struct

begin_comment
comment|/*  * Removes the last amount characters from the sbuf.  */
end_comment

begin_define
define|#
directive|define
name|sbuf_retract
parameter_list|(
name|sbuf
parameter_list|,
name|amount
parameter_list|)
define|\
value|((sbuf)->end -= (amount))
end_define

begin_comment
comment|/*  * Returns the length of the sbuf content.  */
end_comment

begin_define
define|#
directive|define
name|sbuf_length
parameter_list|(
name|sbuf
parameter_list|)
define|\
value|((sbuf)->end - (sbuf)->content)
end_define

begin_typedef
typedef|typedef
name|char
modifier|*
name|edited_copy
parameter_list|(
name|char
modifier|*
name|from
parameter_list|,
name|char
modifier|*
name|to
parameter_list|,
name|int
name|length
parameter_list|)
function_decl|;
end_typedef

begin_decl_stmt
specifier|static
name|int
name|append
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -a flag: append to existing whatis */
end_comment

begin_decl_stmt
specifier|static
name|int
name|verbose
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -v flag: be verbose with warnings */
end_comment

begin_decl_stmt
specifier|static
name|int
name|indent
init|=
literal|24
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -i option: description indentation */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|whatis_name
init|=
literal|"whatis"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -n option: the name */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|common_output
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -o option: the single output file */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|locale
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* user's locale if -L is used */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|lang_locale
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* short form of locale */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|machine
decl_stmt|,
modifier|*
name|machine_arch
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|exit_code
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* exit code to use when finished */
end_comment

begin_expr_stmt
specifier|static
name|SLIST_HEAD
argument_list|(
argument_list|,
argument|visited_dir
argument_list|)
name|visited_dirs
operator|=
name|SLIST_HEAD_INITIALIZER
argument_list|(
name|visited_dirs
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * While the whatis line is being formed, it is stored in whatis_proto.  * When finished, it is reformatted into whatis_final and then appended  * to whatis_lines.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|sbuf
modifier|*
name|whatis_proto
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|sbuf
modifier|*
name|whatis_final
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|StringList
modifier|*
name|whatis_lines
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* collected output lines */
end_comment

begin_decl_stmt
specifier|static
name|char
name|tmp_file
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* path of temporary file, if any */
end_comment

begin_comment
comment|/* A set of possible names for the NAME man page section */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|name_section_titles
index|[]
init|=
block|{
literal|"NAME"
block|,
literal|"Name"
block|,
literal|"NAMN"
block|,
literal|"BEZEICHNUNG"
block|,
literal|"\xcc\xbe\xbe\xce"
block|,
literal|"\xee\xe1\xfa\xf7\xe1\xee\xe9\xe5"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A subset of the mdoc(7) commands to ignore */
end_comment

begin_decl_stmt
specifier|static
name|char
name|mdoc_commands
index|[]
init|=
literal|"ArDvErEvFlLiNmPa"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Frees a struct page_info and its content.  */
end_comment

begin_function
specifier|static
name|void
name|free_page_info
parameter_list|(
name|struct
name|page_info
modifier|*
name|info
parameter_list|)
block|{
name|free
argument_list|(
name|info
operator|->
name|filename
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|info
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|info
operator|->
name|suffix
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allocates and fills in a new struct page_info given the  * name of the man section directory and the dirent of the file.  * If the file is not a man page, returns NULL.  */
end_comment

begin_function
specifier|static
name|struct
name|page_info
modifier|*
name|new_page_info
parameter_list|(
name|char
modifier|*
name|dir
parameter_list|,
name|struct
name|dirent
modifier|*
name|dirent
parameter_list|)
block|{
name|struct
name|page_info
modifier|*
name|info
decl_stmt|;
name|int
name|basename_length
decl_stmt|;
name|char
modifier|*
name|suffix
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
name|info
operator|=
operator|(
expr|struct
name|page_info
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|page_info
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"malloc"
argument_list|)
expr_stmt|;
name|basename_length
operator|=
name|strlen
argument_list|(
name|dirent
operator|->
name|d_name
argument_list|)
expr_stmt|;
name|suffix
operator|=
operator|&
name|dirent
operator|->
name|d_name
index|[
name|basename_length
index|]
expr_stmt|;
name|asprintf
argument_list|(
operator|&
name|info
operator|->
name|filename
argument_list|,
literal|"%s/%s"
argument_list|,
name|dir
argument_list|,
name|dirent
operator|->
name|d_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|info
operator|->
name|gzipped
operator|=
name|basename_length
operator|>=
literal|4
operator|&&
name|strcmp
argument_list|(
operator|&
name|dirent
operator|->
name|d_name
index|[
name|basename_length
operator|-
literal|3
index|]
argument_list|,
literal|".gz"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|suffix
operator|-=
literal|3
expr_stmt|;
operator|*
name|suffix
operator|=
literal|'\0'
expr_stmt|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|--
name|suffix
operator|==
name|dirent
operator|->
name|d_name
operator|||
operator|!
name|isalnum
argument_list|(
operator|*
name|suffix
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|suffix
operator|==
literal|'.'
condition|)
break|break;
if|if
condition|(
name|verbose
condition|)
name|warnx
argument_list|(
literal|"%s: invalid man page name"
argument_list|,
name|info
operator|->
name|filename
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|info
operator|->
name|filename
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|info
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
operator|*
name|suffix
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|info
operator|->
name|name
operator|=
name|strdup
argument_list|(
name|dirent
operator|->
name|d_name
argument_list|)
expr_stmt|;
name|info
operator|->
name|suffix
operator|=
name|strdup
argument_list|(
name|suffix
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|info
operator|->
name|filename
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"%s"
argument_list|,
name|info
operator|->
name|filename
argument_list|)
expr_stmt|;
name|free_page_info
argument_list|(
name|info
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|!
name|S_ISREG
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
block|{
if|if
condition|(
name|verbose
operator|&&
operator|!
name|S_ISDIR
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
name|warnx
argument_list|(
literal|"%s: not a regular file"
argument_list|,
name|info
operator|->
name|filename
argument_list|)
expr_stmt|;
name|free_page_info
argument_list|(
name|info
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|info
operator|->
name|inode
operator|=
name|st
operator|.
name|st_ino
expr_stmt|;
return|return
name|info
return|;
block|}
end_function

begin_comment
comment|/*  * Reset an sbuf's length to 0.  */
end_comment

begin_function
specifier|static
name|void
name|sbuf_clear
parameter_list|(
name|struct
name|sbuf
modifier|*
name|sbuf
parameter_list|)
block|{
name|sbuf
operator|->
name|end
operator|=
name|sbuf
operator|->
name|content
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allocate a new sbuf.  */
end_comment

begin_function
specifier|static
name|struct
name|sbuf
modifier|*
name|new_sbuf
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|sbuf
modifier|*
name|sbuf
init|=
operator|(
expr|struct
name|sbuf
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sbuf
argument_list|)
argument_list|)
decl_stmt|;
name|sbuf
operator|->
name|content
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|LINE_ALLOC
argument_list|)
expr_stmt|;
name|sbuf
operator|->
name|last
operator|=
name|sbuf
operator|->
name|content
operator|+
name|LINE_ALLOC
operator|-
literal|1
expr_stmt|;
name|sbuf_clear
argument_list|(
name|sbuf
argument_list|)
expr_stmt|;
return|return
name|sbuf
return|;
block|}
end_function

begin_comment
comment|/*  * Ensure that there is enough room in the sbuf for nchars more characters.  */
end_comment

begin_function
specifier|static
name|void
name|sbuf_need
parameter_list|(
name|struct
name|sbuf
modifier|*
name|sbuf
parameter_list|,
name|int
name|nchars
parameter_list|)
block|{
name|char
modifier|*
name|new_content
decl_stmt|;
name|size_t
name|size
decl_stmt|,
name|cntsize
decl_stmt|;
comment|/* double the size of the allocation until the buffer is big enough */
while|while
condition|(
name|sbuf
operator|->
name|end
operator|+
name|nchars
operator|>
name|sbuf
operator|->
name|last
condition|)
block|{
name|size
operator|=
name|sbuf
operator|->
name|last
operator|+
literal|1
operator|-
name|sbuf
operator|->
name|content
expr_stmt|;
name|size
operator|*=
literal|2
expr_stmt|;
name|cntsize
operator|=
name|sbuf
operator|->
name|end
operator|-
name|sbuf
operator|->
name|content
expr_stmt|;
name|new_content
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|new_content
argument_list|,
name|sbuf
operator|->
name|content
argument_list|,
name|cntsize
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sbuf
operator|->
name|content
argument_list|)
expr_stmt|;
name|sbuf
operator|->
name|content
operator|=
name|new_content
expr_stmt|;
name|sbuf
operator|->
name|end
operator|=
name|new_content
operator|+
name|cntsize
expr_stmt|;
name|sbuf
operator|->
name|last
operator|=
name|new_content
operator|+
name|size
operator|-
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Appends a string of a given length to the sbuf.  */
end_comment

begin_function
specifier|static
name|void
name|sbuf_append
parameter_list|(
name|struct
name|sbuf
modifier|*
name|sbuf
parameter_list|,
specifier|const
name|char
modifier|*
name|text
parameter_list|,
name|int
name|length
parameter_list|)
block|{
if|if
condition|(
name|length
operator|>
literal|0
condition|)
block|{
name|sbuf_need
argument_list|(
name|sbuf
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|sbuf
operator|->
name|end
argument_list|,
name|text
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|sbuf
operator|->
name|end
operator|+=
name|length
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Appends a null-terminated string to the sbuf.  */
end_comment

begin_function
specifier|static
name|void
name|sbuf_append_str
parameter_list|(
name|struct
name|sbuf
modifier|*
name|sbuf
parameter_list|,
name|char
modifier|*
name|text
parameter_list|)
block|{
name|sbuf_append
argument_list|(
name|sbuf
argument_list|,
name|text
argument_list|,
name|strlen
argument_list|(
name|text
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Appends an edited null-terminated string to the sbuf.  */
end_comment

begin_function
specifier|static
name|void
name|sbuf_append_edited
parameter_list|(
name|struct
name|sbuf
modifier|*
name|sbuf
parameter_list|,
name|char
modifier|*
name|text
parameter_list|,
name|edited_copy
name|copy
parameter_list|)
block|{
name|int
name|length
init|=
name|strlen
argument_list|(
name|text
argument_list|)
decl_stmt|;
if|if
condition|(
name|length
operator|>
literal|0
condition|)
block|{
name|sbuf_need
argument_list|(
name|sbuf
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|sbuf
operator|->
name|end
operator|=
name|copy
argument_list|(
name|text
argument_list|,
name|sbuf
operator|->
name|end
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Strips any of a set of chars from the end of the sbuf.  */
end_comment

begin_function
specifier|static
name|void
name|sbuf_strip
parameter_list|(
name|struct
name|sbuf
modifier|*
name|sbuf
parameter_list|,
specifier|const
name|char
modifier|*
name|set
parameter_list|)
block|{
while|while
condition|(
name|sbuf
operator|->
name|end
operator|>
name|sbuf
operator|->
name|content
operator|&&
name|strchr
argument_list|(
name|set
argument_list|,
name|sbuf
operator|->
name|end
index|[
operator|-
literal|1
index|]
argument_list|)
operator|!=
name|NULL
condition|)
name|sbuf
operator|->
name|end
operator|--
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Returns the null-terminated string built by the sbuf.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|sbuf_content
parameter_list|(
name|struct
name|sbuf
modifier|*
name|sbuf
parameter_list|)
block|{
operator|*
name|sbuf
operator|->
name|end
operator|=
literal|'\0'
expr_stmt|;
return|return
name|sbuf
operator|->
name|content
return|;
block|}
end_function

begin_comment
comment|/*  * Returns true if no man page exists in the directory with  * any of the names in the StringList.  */
end_comment

begin_function
specifier|static
name|int
name|no_page_exists
parameter_list|(
name|char
modifier|*
name|dir
parameter_list|,
name|StringList
modifier|*
name|names
parameter_list|,
name|char
modifier|*
name|suffix
parameter_list|)
block|{
name|char
name|path
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|names
operator|->
name|sl_cur
condition|;
name|i
operator|++
control|)
block|{
name|snprintf
argument_list|(
name|path
argument_list|,
sizeof|sizeof
name|path
argument_list|,
literal|"%s/%s.%s.gz"
argument_list|,
name|dir
argument_list|,
name|names
operator|->
name|sl_str
index|[
name|i
index|]
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|path
argument_list|,
name|F_OK
argument_list|)
operator|<
literal|0
condition|)
block|{
name|path
index|[
name|strlen
argument_list|(
name|path
argument_list|)
operator|-
literal|3
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|path
argument_list|,
name|F_OK
argument_list|)
operator|<
literal|0
condition|)
continue|continue;
block|}
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|trap_signal
parameter_list|(
name|int
name|sig
name|__unused
parameter_list|)
block|{
if|if
condition|(
name|tmp_file
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|unlink
argument_list|(
name|tmp_file
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Attempts to open an output file.  Returns NULL if unsuccessful.  */
end_comment

begin_function
specifier|static
name|FILE
modifier|*
name|open_output
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|FILE
modifier|*
name|output
decl_stmt|;
name|whatis_lines
operator|=
name|sl_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|append
condition|)
block|{
name|char
name|line
index|[
name|LINE_ALLOC
index|]
decl_stmt|;
name|output
operator|=
name|fopen
argument_list|(
name|name
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|output
operator|==
name|NULL
condition|)
block|{
name|warn
argument_list|(
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|exit_code
operator|=
literal|1
expr_stmt|;
return|return
name|NULL
return|;
block|}
while|while
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
sizeof|sizeof
name|line
argument_list|,
name|output
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|line
index|[
name|strlen
argument_list|(
name|line
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|sl_add
argument_list|(
name|whatis_lines
argument_list|,
name|strdup
argument_list|(
name|line
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|common_output
operator|==
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|tmp_file
argument_list|,
sizeof|sizeof
name|tmp_file
argument_list|,
literal|"%s.tmp"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|name
operator|=
name|tmp_file
expr_stmt|;
block|}
name|output
operator|=
name|fopen
argument_list|(
name|name
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|output
operator|==
name|NULL
condition|)
block|{
name|warn
argument_list|(
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|exit_code
operator|=
literal|1
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|output
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|linesort
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
block|{
return|return
name|strcmp
argument_list|(
operator|(
operator|*
operator|(
specifier|const
name|char
operator|*
specifier|const
operator|*
operator|)
name|a
operator|)
argument_list|,
operator|(
operator|*
operator|(
specifier|const
name|char
operator|*
specifier|const
operator|*
operator|)
name|b
operator|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Writes the unique sorted lines to the output file.  */
end_comment

begin_function
specifier|static
name|void
name|finish_output
parameter_list|(
name|FILE
modifier|*
name|output
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
name|char
modifier|*
name|prev
init|=
name|NULL
decl_stmt|;
name|qsort
argument_list|(
name|whatis_lines
operator|->
name|sl_str
argument_list|,
name|whatis_lines
operator|->
name|sl_cur
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|,
name|linesort
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|whatis_lines
operator|->
name|sl_cur
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|line
init|=
name|whatis_lines
operator|->
name|sl_str
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
operator|&&
name|strcmp
argument_list|(
name|line
argument_list|,
name|prev
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
name|prev
operator|=
name|line
expr_stmt|;
name|fputs
argument_list|(
name|line
argument_list|,
name|output
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|output
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|output
argument_list|)
expr_stmt|;
name|sl_free
argument_list|(
name|whatis_lines
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|common_output
operator|==
name|NULL
condition|)
block|{
name|rename
argument_list|(
name|tmp_file
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|tmp_file
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|FILE
modifier|*
name|open_whatis
parameter_list|(
name|char
modifier|*
name|mandir
parameter_list|)
block|{
name|char
name|filename
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|filename
argument_list|,
sizeof|sizeof
name|filename
argument_list|,
literal|"%s/%s"
argument_list|,
name|mandir
argument_list|,
name|whatis_name
argument_list|)
expr_stmt|;
return|return
name|open_output
argument_list|(
name|filename
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|finish_whatis
parameter_list|(
name|FILE
modifier|*
name|output
parameter_list|,
name|char
modifier|*
name|mandir
parameter_list|)
block|{
name|char
name|filename
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|filename
argument_list|,
sizeof|sizeof
name|filename
argument_list|,
literal|"%s/%s"
argument_list|,
name|mandir
argument_list|,
name|whatis_name
argument_list|)
expr_stmt|;
name|finish_output
argument_list|(
name|output
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Tests to see if the given directory has already been visited.  */
end_comment

begin_function
specifier|static
name|int
name|already_visited
parameter_list|(
name|char
modifier|*
name|dir
parameter_list|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
name|struct
name|visited_dir
modifier|*
name|visit
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|dir
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"%s"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|exit_code
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
name|SLIST_FOREACH
argument_list|(
argument|visit
argument_list|,
argument|&visited_dirs
argument_list|,
argument|next
argument_list|)
block|{
if|if
condition|(
name|visit
operator|->
name|inode
operator|==
name|st
operator|.
name|st_ino
operator|&&
name|visit
operator|->
name|device
operator|==
name|st
operator|.
name|st_dev
condition|)
block|{
name|warnx
argument_list|(
literal|"already visited %s"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
name|visit
operator|=
operator|(
expr|struct
name|visited_dir
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|visited_dir
argument_list|)
argument_list|)
expr_stmt|;
name|visit
operator|->
name|device
operator|=
name|st
operator|.
name|st_dev
expr_stmt|;
name|visit
operator|->
name|inode
operator|=
name|st
operator|.
name|st_ino
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|visited_dirs
argument_list|,
name|visit
argument_list|,
name|next
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Removes trailing spaces from a string, returning a pointer to just  * beyond the new last character.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|trim_rhs
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|char
modifier|*
name|rhs
init|=
operator|&
name|str
index|[
name|strlen
argument_list|(
name|str
argument_list|)
index|]
decl_stmt|;
while|while
condition|(
operator|--
name|rhs
operator|>
name|str
operator|&&
name|isspace
argument_list|(
operator|*
name|rhs
argument_list|)
condition|)
empty_stmt|;
operator|*
operator|++
name|rhs
operator|=
literal|'\0'
expr_stmt|;
return|return
name|rhs
return|;
block|}
end_function

begin_comment
comment|/*  * Returns a pointer to the next non-space character in the string.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|skip_spaces
parameter_list|(
name|char
modifier|*
name|s
parameter_list|)
block|{
while|while
condition|(
operator|*
name|s
operator|!=
literal|'\0'
operator|&&
name|isspace
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/*  * Returns whether the string contains only digits.  */
end_comment

begin_function
specifier|static
name|int
name|only_digits
parameter_list|(
name|char
modifier|*
name|line
parameter_list|)
block|{
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
name|line
operator|++
argument_list|)
condition|)
return|return
literal|0
return|;
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|line
argument_list|)
condition|)
name|line
operator|++
expr_stmt|;
return|return
operator|*
name|line
operator|==
literal|'\0'
return|;
block|}
end_function

begin_comment
comment|/*  * Returns whether the line is of one of the forms:  *	.Sh NAME  *	.Sh "NAME"  *	etc.  * assuming that section_start is ".Sh".  */
end_comment

begin_function
specifier|static
name|int
name|name_section_line
parameter_list|(
name|char
modifier|*
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|section_start
parameter_list|)
block|{
name|char
modifier|*
name|rhs
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|title
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|line
argument_list|,
name|section_start
argument_list|,
literal|3
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
name|line
operator|=
name|skip_spaces
argument_list|(
name|line
operator|+
literal|3
argument_list|)
expr_stmt|;
name|rhs
operator|=
name|trim_rhs
argument_list|(
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|line
operator|==
literal|'"'
condition|)
block|{
name|line
operator|++
expr_stmt|;
if|if
condition|(
operator|*
operator|--
name|rhs
operator|==
literal|'"'
condition|)
operator|*
name|rhs
operator|=
literal|'\0'
expr_stmt|;
block|}
for|for
control|(
name|title
operator|=
name|name_section_titles
init|;
operator|*
name|title
operator|!=
name|NULL
condition|;
name|title
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|title
argument_list|,
name|line
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Copies characters while removing the most common nroff/troff  * markup:  *	\(em, \(mi, \s[+-N], \&  *	\fF, \f(fo, \f[font]  *	\*s, \*(st, \*[stringvar]  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|de_nroff_copy
parameter_list|(
name|char
modifier|*
name|from
parameter_list|,
name|char
modifier|*
name|to
parameter_list|,
name|int
name|fromlen
parameter_list|)
block|{
name|char
modifier|*
name|from_end
init|=
operator|&
name|from
index|[
name|fromlen
index|]
decl_stmt|;
while|while
condition|(
name|from
operator|<
name|from_end
condition|)
block|{
switch|switch
condition|(
operator|*
name|from
condition|)
block|{
case|case
literal|'\\'
case|:
switch|switch
condition|(
operator|*
operator|++
name|from
condition|)
block|{
case|case
literal|'('
case|:
if|if
condition|(
name|strncmp
argument_list|(
operator|&
name|from
index|[
literal|1
index|]
argument_list|,
literal|"em"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
operator|&
name|from
index|[
literal|1
index|]
argument_list|,
literal|"mi"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|from
operator|+=
literal|3
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
literal|'s'
case|:
if|if
condition|(
operator|*
operator|++
name|from
operator|==
literal|'-'
condition|)
name|from
operator|++
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|from
argument_list|)
condition|)
name|from
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'f'
case|:
case|case
literal|'*'
case|:
if|if
condition|(
operator|*
operator|++
name|from
operator|==
literal|'('
condition|)
name|from
operator|+=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|from
operator|==
literal|'['
condition|)
block|{
while|while
condition|(
operator|*
operator|++
name|from
operator|!=
literal|']'
operator|&&
name|from
operator|<
name|from_end
condition|)
empty_stmt|;
name|from
operator|++
expr_stmt|;
block|}
else|else
name|from
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'&'
case|:
name|from
operator|++
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
operator|*
name|to
operator|++
operator|=
operator|*
name|from
operator|++
expr_stmt|;
block|}
return|return
name|to
return|;
block|}
end_function

begin_comment
comment|/*  * Appends a string with the nroff formatting removed.  */
end_comment

begin_function
specifier|static
name|void
name|add_nroff
parameter_list|(
name|char
modifier|*
name|text
parameter_list|)
block|{
name|sbuf_append_edited
argument_list|(
name|whatis_proto
argument_list|,
name|text
argument_list|,
name|de_nroff_copy
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Appends "name(suffix), " to whatis_final.  */
end_comment

begin_function
specifier|static
name|void
name|add_whatis_name
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|char
modifier|*
name|suffix
parameter_list|)
block|{
if|if
condition|(
operator|*
name|name
operator|!=
literal|'\0'
condition|)
block|{
name|sbuf_append_str
argument_list|(
name|whatis_final
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|sbuf_append
argument_list|(
name|whatis_final
argument_list|,
literal|"("
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sbuf_append_str
argument_list|(
name|whatis_final
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
name|sbuf_append
argument_list|(
name|whatis_final
argument_list|,
literal|"), "
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Processes an old-style man(7) line.  This ignores commands with only  * a single number argument.  */
end_comment

begin_function
specifier|static
name|void
name|process_man_line
parameter_list|(
name|char
modifier|*
name|line
parameter_list|)
block|{
if|if
condition|(
operator|*
name|line
operator|==
literal|'.'
condition|)
block|{
while|while
condition|(
name|isalpha
argument_list|(
operator|*
operator|++
name|line
argument_list|)
condition|)
empty_stmt|;
name|line
operator|=
name|skip_spaces
argument_list|(
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|only_digits
argument_list|(
name|line
argument_list|)
condition|)
return|return;
block|}
else|else
name|line
operator|=
name|skip_spaces
argument_list|(
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|line
operator|!=
literal|'\0'
condition|)
block|{
name|add_nroff
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|sbuf_append
argument_list|(
name|whatis_proto
argument_list|,
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Processes a new-style mdoc(7) line.  */
end_comment

begin_function
specifier|static
name|void
name|process_mdoc_line
parameter_list|(
name|char
modifier|*
name|line
parameter_list|)
block|{
name|int
name|xref
decl_stmt|;
name|int
name|arg
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|line_end
init|=
operator|&
name|line
index|[
name|strlen
argument_list|(
name|line
argument_list|)
index|]
decl_stmt|;
name|int
name|orig_length
init|=
name|sbuf_length
argument_list|(
name|whatis_proto
argument_list|)
decl_stmt|;
name|char
modifier|*
name|next
decl_stmt|;
if|if
condition|(
operator|*
name|line
operator|==
literal|'\0'
condition|)
return|return;
if|if
condition|(
name|line
index|[
literal|0
index|]
operator|!=
literal|'.'
operator|||
operator|!
name|isupper
argument_list|(
name|line
index|[
literal|1
index|]
argument_list|)
operator|||
operator|!
name|islower
argument_list|(
name|line
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
name|add_nroff
argument_list|(
name|skip_spaces
argument_list|(
name|line
argument_list|)
argument_list|)
expr_stmt|;
name|sbuf_append
argument_list|(
name|whatis_proto
argument_list|,
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
name|xref
operator|=
name|strncmp
argument_list|(
name|line
argument_list|,
literal|".Xr"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
expr_stmt|;
name|line
operator|+=
literal|3
expr_stmt|;
while|while
condition|(
operator|(
name|line
operator|=
name|skip_spaces
argument_list|(
name|line
argument_list|)
operator|)
operator|<
name|line_end
condition|)
block|{
if|if
condition|(
operator|*
name|line
operator|==
literal|'"'
condition|)
block|{
name|next
operator|=
operator|++
name|line
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|next
operator|=
name|strchr
argument_list|(
name|next
argument_list|,
literal|'"'
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|==
name|NULL
condition|)
break|break;
name|memmove
argument_list|(
name|next
argument_list|,
name|next
operator|+
literal|1
argument_list|,
name|strlen
argument_list|(
name|next
argument_list|)
argument_list|)
expr_stmt|;
name|line_end
operator|--
expr_stmt|;
if|if
condition|(
operator|*
name|next
operator|!=
literal|'"'
condition|)
break|break;
name|next
operator|++
expr_stmt|;
block|}
block|}
else|else
name|next
operator|=
name|strpbrk
argument_list|(
name|line
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|!=
name|NULL
condition|)
operator|*
name|next
operator|++
operator|=
literal|'\0'
expr_stmt|;
else|else
name|next
operator|=
name|line_end
expr_stmt|;
if|if
condition|(
name|isupper
argument_list|(
operator|*
name|line
argument_list|)
operator|&&
name|islower
argument_list|(
name|line
index|[
literal|1
index|]
argument_list|)
operator|&&
name|line
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|line
argument_list|,
literal|"Ns"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|arg
operator|=
literal|0
expr_stmt|;
name|line
operator|=
name|next
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strstr
argument_list|(
name|mdoc_commands
argument_list|,
name|line
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|line
operator|=
name|next
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|arg
operator|>
literal|0
operator|&&
name|strchr
argument_list|(
literal|",.:;?!)]"
argument_list|,
operator|*
name|line
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|xref
condition|)
block|{
name|sbuf_append
argument_list|(
name|whatis_proto
argument_list|,
literal|"("
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_nroff
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|sbuf_append
argument_list|(
name|whatis_proto
argument_list|,
literal|")"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xref
operator|=
literal|0
expr_stmt|;
name|line
operator|=
name|blank
expr_stmt|;
block|}
else|else
name|sbuf_append
argument_list|(
name|whatis_proto
argument_list|,
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|add_nroff
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|arg
operator|++
expr_stmt|;
name|line
operator|=
name|next
expr_stmt|;
block|}
if|if
condition|(
name|sbuf_length
argument_list|(
name|whatis_proto
argument_list|)
operator|>
name|orig_length
condition|)
name|sbuf_append
argument_list|(
name|whatis_proto
argument_list|,
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Collects a list of comma-separated names from the text.  */
end_comment

begin_function
specifier|static
name|void
name|collect_names
parameter_list|(
name|StringList
modifier|*
name|names
parameter_list|,
name|char
modifier|*
name|text
parameter_list|)
block|{
name|char
modifier|*
name|arg
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|arg
operator|=
name|text
expr_stmt|;
name|text
operator|=
name|strchr
argument_list|(
name|text
argument_list|,
literal|','
argument_list|)
expr_stmt|;
if|if
condition|(
name|text
operator|!=
name|NULL
condition|)
operator|*
name|text
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|sl_add
argument_list|(
name|names
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|text
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
operator|*
name|text
operator|==
literal|' '
condition|)
name|text
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_enum
enum|enum
block|{
name|STATE_UNKNOWN
block|,
name|STATE_MANSTYLE
block|,
name|STATE_MDOCNAME
block|,
name|STATE_MDOCDESC
block|}
enum|;
end_enum

begin_comment
comment|/*  * Processes a man page source into a single whatis line and adds it  * to whatis_lines.  */
end_comment

begin_function
specifier|static
name|void
name|process_page
parameter_list|(
name|struct
name|page_info
modifier|*
name|page
parameter_list|,
name|char
modifier|*
name|section_dir
parameter_list|)
block|{
name|gzFile
modifier|*
name|in
decl_stmt|;
name|char
name|buffer
index|[
literal|4096
index|]
decl_stmt|;
name|char
modifier|*
name|line
decl_stmt|;
name|StringList
modifier|*
name|names
decl_stmt|;
name|char
modifier|*
name|descr
decl_stmt|;
name|int
name|state
init|=
name|STATE_UNKNOWN
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|sbuf_clear
argument_list|(
name|whatis_proto
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|in
operator|=
name|gzopen
argument_list|(
name|page
operator|->
name|filename
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|warn
argument_list|(
literal|"%s"
argument_list|,
name|page
operator|->
name|filename
argument_list|)
expr_stmt|;
name|exit_code
operator|=
literal|1
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|gzgets
argument_list|(
name|in
argument_list|,
name|buffer
argument_list|,
sizeof|sizeof
name|buffer
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|line
operator|=
name|buffer
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|line
argument_list|,
literal|".\\\""
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
comment|/* ignore comments */
continue|continue;
switch|switch
condition|(
name|state
condition|)
block|{
comment|/* 		 * haven't reached the NAME section yet. 		 */
case|case
name|STATE_UNKNOWN
case|:
if|if
condition|(
name|name_section_line
argument_list|(
name|line
argument_list|,
literal|".SH"
argument_list|)
condition|)
name|state
operator|=
name|STATE_MANSTYLE
expr_stmt|;
elseif|else
if|if
condition|(
name|name_section_line
argument_list|(
name|line
argument_list|,
literal|".Sh"
argument_list|)
condition|)
name|state
operator|=
name|STATE_MDOCNAME
expr_stmt|;
continue|continue;
comment|/* 		 * Inside an old-style .SH NAME section. 		 */
case|case
name|STATE_MANSTYLE
case|:
if|if
condition|(
name|strncmp
argument_list|(
name|line
argument_list|,
literal|".SH"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|strncmp
argument_list|(
name|line
argument_list|,
literal|".SS"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
break|break;
name|trim_rhs
argument_list|(
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|line
argument_list|,
literal|"."
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|strncmp
argument_list|(
name|line
argument_list|,
literal|".IX"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|line
operator|+=
literal|3
expr_stmt|;
name|line
operator|=
name|skip_spaces
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
name|process_man_line
argument_list|(
name|line
argument_list|)
expr_stmt|;
continue|continue;
comment|/* 		 * Inside a new-style .Sh NAME section (the .Nm part). 		 */
case|case
name|STATE_MDOCNAME
case|:
name|trim_rhs
argument_list|(
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|line
argument_list|,
literal|".Nm"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|process_mdoc_line
argument_list|(
name|line
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|line
argument_list|,
literal|"."
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
name|sbuf_append
argument_list|(
name|whatis_proto
argument_list|,
literal|"- "
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|state
operator|=
name|STATE_MDOCDESC
expr_stmt|;
block|}
comment|/* fall through */
comment|/* 		 * Inside a new-style .Sh NAME section (after the .Nm-s). 		 */
case|case
name|STATE_MDOCDESC
case|:
if|if
condition|(
name|strncmp
argument_list|(
name|line
argument_list|,
literal|".Sh"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
break|break;
name|trim_rhs
argument_list|(
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|line
argument_list|,
literal|"."
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
name|process_mdoc_line
argument_list|(
name|line
argument_list|)
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
name|gzclose
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|sbuf_strip
argument_list|(
name|whatis_proto
argument_list|,
literal|" \t.-"
argument_list|)
expr_stmt|;
name|line
operator|=
name|sbuf_content
argument_list|(
name|whatis_proto
argument_list|)
expr_stmt|;
comment|/* 	 * line now contains the appropriate data, but without 	 * the proper indentation or the section appended to each name. 	 */
name|descr
operator|=
name|strstr
argument_list|(
name|line
argument_list|,
literal|" - "
argument_list|)
expr_stmt|;
if|if
condition|(
name|descr
operator|==
name|NULL
condition|)
block|{
name|descr
operator|=
name|strchr
argument_list|(
name|line
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|descr
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"	ignoring junk description \"%s\"\n"
argument_list|,
name|line
argument_list|)
expr_stmt|;
return|return;
block|}
operator|*
name|descr
operator|++
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
operator|*
name|descr
operator|=
literal|'\0'
expr_stmt|;
name|descr
operator|+=
literal|3
expr_stmt|;
block|}
name|names
operator|=
name|sl_init
argument_list|()
expr_stmt|;
name|collect_names
argument_list|(
name|names
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|sbuf_clear
argument_list|(
name|whatis_final
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sl_find
argument_list|(
name|names
argument_list|,
name|page
operator|->
name|name
argument_list|)
operator|&&
name|no_page_exists
argument_list|(
name|section_dir
argument_list|,
name|names
argument_list|,
name|page
operator|->
name|suffix
argument_list|)
condition|)
block|{
comment|/* 		 * Add the page name since that's the only thing that 		 * man(1) will find. 		 */
name|add_whatis_name
argument_list|(
name|page
operator|->
name|name
argument_list|,
name|page
operator|->
name|suffix
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|names
operator|->
name|sl_cur
condition|;
name|i
operator|++
control|)
name|add_whatis_name
argument_list|(
name|names
operator|->
name|sl_str
index|[
name|i
index|]
argument_list|,
name|page
operator|->
name|suffix
argument_list|)
expr_stmt|;
name|sl_free
argument_list|(
name|names
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sbuf_retract
argument_list|(
name|whatis_final
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* remove last ", " */
while|while
condition|(
name|sbuf_length
argument_list|(
name|whatis_final
argument_list|)
operator|<
name|indent
condition|)
name|sbuf_append
argument_list|(
name|whatis_final
argument_list|,
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sbuf_append
argument_list|(
name|whatis_final
argument_list|,
literal|" - "
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|sbuf_append_str
argument_list|(
name|whatis_final
argument_list|,
name|skip_spaces
argument_list|(
name|descr
argument_list|)
argument_list|)
expr_stmt|;
name|sl_add
argument_list|(
name|whatis_lines
argument_list|,
name|strdup
argument_list|(
name|sbuf_content
argument_list|(
name|whatis_final
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Sorts pages first by inode number, then by name.  */
end_comment

begin_function
specifier|static
name|int
name|pagesort
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
block|{
specifier|const
name|struct
name|page_info
modifier|*
name|p1
init|=
operator|*
operator|(
expr|struct
name|page_info
operator|*
specifier|const
operator|*
operator|)
name|a
decl_stmt|;
specifier|const
name|struct
name|page_info
modifier|*
name|p2
init|=
operator|*
operator|(
expr|struct
name|page_info
operator|*
specifier|const
operator|*
operator|)
name|b
decl_stmt|;
if|if
condition|(
name|p1
operator|->
name|inode
operator|==
name|p2
operator|->
name|inode
condition|)
return|return
name|strcmp
argument_list|(
name|p1
operator|->
name|name
argument_list|,
name|p2
operator|->
name|name
argument_list|)
return|;
return|return
name|p1
operator|->
name|inode
operator|-
name|p2
operator|->
name|inode
return|;
block|}
end_function

begin_comment
comment|/*  * Processes a single man section.  */
end_comment

begin_function
specifier|static
name|void
name|process_section
parameter_list|(
name|char
modifier|*
name|section_dir
parameter_list|)
block|{
name|struct
name|dirent
modifier|*
modifier|*
name|entries
decl_stmt|;
name|int
name|nentries
decl_stmt|;
name|struct
name|page_info
modifier|*
modifier|*
name|pages
decl_stmt|;
name|int
name|npages
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ino_t
name|prev_inode
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|verbose
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  %s\n"
argument_list|,
name|section_dir
argument_list|)
expr_stmt|;
comment|/* 	 * scan the man section directory for pages 	 */
name|nentries
operator|=
name|scandir
argument_list|(
name|section_dir
argument_list|,
operator|&
name|entries
argument_list|,
name|NULL
argument_list|,
name|alphasort
argument_list|)
expr_stmt|;
if|if
condition|(
name|nentries
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"%s"
argument_list|,
name|section_dir
argument_list|)
expr_stmt|;
name|exit_code
operator|=
literal|1
expr_stmt|;
return|return;
block|}
comment|/* 	 * collect information about man pages 	 */
name|pages
operator|=
operator|(
expr|struct
name|page_info
operator|*
operator|*
operator|)
name|calloc
argument_list|(
name|nentries
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|page_info
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nentries
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|page_info
modifier|*
name|info
init|=
name|new_page_info
argument_list|(
name|section_dir
argument_list|,
name|entries
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
operator|!=
name|NULL
condition|)
name|pages
index|[
name|npages
operator|++
index|]
operator|=
name|info
expr_stmt|;
name|free
argument_list|(
name|entries
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|entries
argument_list|)
expr_stmt|;
name|qsort
argument_list|(
name|pages
argument_list|,
name|npages
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|page_info
operator|*
argument_list|)
argument_list|,
name|pagesort
argument_list|)
expr_stmt|;
comment|/* 	 * process each unique page 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|npages
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|page_info
modifier|*
name|page
init|=
name|pages
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|page
operator|->
name|inode
operator|!=
name|prev_inode
condition|)
block|{
name|prev_inode
operator|=
name|page
operator|->
name|inode
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"	reading %s\n"
argument_list|,
name|page
operator|->
name|filename
argument_list|)
expr_stmt|;
name|process_page
argument_list|(
name|page
argument_list|,
name|section_dir
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|verbose
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"	skipping %s, duplicate\n"
argument_list|,
name|page
operator|->
name|filename
argument_list|)
expr_stmt|;
name|free_page_info
argument_list|(
name|page
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|pages
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Returns whether the directory entry is a man page section.  */
end_comment

begin_function
specifier|static
name|int
name|select_sections
parameter_list|(
specifier|const
name|struct
name|dirent
modifier|*
name|entry
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
init|=
operator|&
name|entry
operator|->
name|d_name
index|[
literal|3
index|]
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|entry
operator|->
name|d_name
argument_list|,
literal|"man"
argument_list|,
literal|3
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|!
name|isalnum
argument_list|(
operator|*
name|p
operator|++
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Processes a single top-level man directory by finding all the  * sub-directories named man* and processing each one in turn.  */
end_comment

begin_function
specifier|static
name|void
name|process_mandir
parameter_list|(
name|char
modifier|*
name|dir_name
parameter_list|)
block|{
name|struct
name|dirent
modifier|*
modifier|*
name|entries
decl_stmt|;
name|int
name|nsections
decl_stmt|;
name|FILE
modifier|*
name|fp
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
if|if
condition|(
name|already_visited
argument_list|(
name|dir_name
argument_list|)
condition|)
return|return;
if|if
condition|(
name|verbose
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"man directory %s\n"
argument_list|,
name|dir_name
argument_list|)
expr_stmt|;
name|nsections
operator|=
name|scandir
argument_list|(
name|dir_name
argument_list|,
operator|&
name|entries
argument_list|,
name|select_sections
argument_list|,
name|alphasort
argument_list|)
expr_stmt|;
if|if
condition|(
name|nsections
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"%s"
argument_list|,
name|dir_name
argument_list|)
expr_stmt|;
name|exit_code
operator|=
literal|1
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|common_output
operator|==
name|NULL
operator|&&
operator|(
name|fp
operator|=
name|open_whatis
argument_list|(
name|dir_name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsections
condition|;
name|i
operator|++
control|)
block|{
name|char
name|section_dir
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|section_dir
argument_list|,
sizeof|sizeof
name|section_dir
argument_list|,
literal|"%s/%s"
argument_list|,
name|dir_name
argument_list|,
name|entries
index|[
name|i
index|]
operator|->
name|d_name
argument_list|)
expr_stmt|;
name|process_section
argument_list|(
name|section_dir
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|section_dir
argument_list|,
sizeof|sizeof
name|section_dir
argument_list|,
literal|"%s/%s/%s"
argument_list|,
name|dir_name
argument_list|,
name|entries
index|[
name|i
index|]
operator|->
name|d_name
argument_list|,
name|machine
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|section_dir
argument_list|,
operator|&
name|st
argument_list|)
operator|==
literal|0
operator|&&
name|S_ISDIR
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
name|process_section
argument_list|(
name|section_dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|machine_arch
argument_list|,
name|machine
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|section_dir
argument_list|,
sizeof|sizeof
name|section_dir
argument_list|,
literal|"%s/%s/%s"
argument_list|,
name|dir_name
argument_list|,
name|entries
index|[
name|i
index|]
operator|->
name|d_name
argument_list|,
name|machine_arch
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|section_dir
argument_list|,
operator|&
name|st
argument_list|)
operator|==
literal|0
operator|&&
name|S_ISDIR
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
name|process_section
argument_list|(
name|section_dir
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|entries
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|entries
argument_list|)
expr_stmt|;
if|if
condition|(
name|common_output
operator|==
name|NULL
condition|)
name|finish_whatis
argument_list|(
name|fp
argument_list|,
name|dir_name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Processes one argument, which may be a colon-separated list of  * directories.  */
end_comment

begin_function
specifier|static
name|void
name|process_argument
parameter_list|(
specifier|const
name|char
modifier|*
name|arg
parameter_list|)
block|{
name|char
modifier|*
name|dir
decl_stmt|;
name|char
modifier|*
name|mandir
decl_stmt|;
name|char
modifier|*
name|parg
decl_stmt|;
name|parg
operator|=
name|strdup
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|parg
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|dir
operator|=
name|strsep
argument_list|(
operator|&
name|parg
argument_list|,
literal|":"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|locale
operator|!=
name|NULL
condition|)
block|{
name|asprintf
argument_list|(
operator|&
name|mandir
argument_list|,
literal|"%s/%s"
argument_list|,
name|dir
argument_list|,
name|locale
argument_list|)
expr_stmt|;
name|process_mandir
argument_list|(
name|mandir
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mandir
argument_list|)
expr_stmt|;
if|if
condition|(
name|lang_locale
operator|!=
name|NULL
condition|)
block|{
name|asprintf
argument_list|(
operator|&
name|mandir
argument_list|,
literal|"%s/%s"
argument_list|,
name|dir
argument_list|,
name|lang_locale
argument_list|)
expr_stmt|;
name|process_mandir
argument_list|(
name|mandir
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mandir
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|process_mandir
argument_list|(
name|dir
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|parg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|opt
decl_stmt|;
name|FILE
modifier|*
name|fp
init|=
name|NULL
decl_stmt|;
while|while
condition|(
operator|(
name|opt
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"ai:n:o:vL"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|opt
condition|)
block|{
case|case
literal|'a'
case|:
name|append
operator|++
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|indent
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|whatis_name
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|common_output
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|verbose
operator|++
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
name|locale
operator|=
name|getenv
argument_list|(
literal|"LC_ALL"
argument_list|)
expr_stmt|;
if|if
condition|(
name|locale
operator|==
name|NULL
condition|)
name|locale
operator|=
name|getenv
argument_list|(
literal|"LC_CTYPE"
argument_list|)
expr_stmt|;
if|if
condition|(
name|locale
operator|==
name|NULL
condition|)
name|locale
operator|=
name|getenv
argument_list|(
literal|"LANG"
argument_list|)
expr_stmt|;
if|if
condition|(
name|locale
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|sep
init|=
name|strchr
argument_list|(
name|locale
argument_list|,
literal|'_'
argument_list|)
decl_stmt|;
if|if
condition|(
name|sep
operator|!=
name|NULL
operator|&&
name|isupper
argument_list|(
name|sep
index|[
literal|1
index|]
argument_list|)
operator|&&
name|isupper
argument_list|(
name|sep
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
name|asprintf
argument_list|(
operator|&
name|lang_locale
argument_list|,
literal|"%.*s%s"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|ptrdiff_t
argument_list|)
argument_list|(
name|sep
operator|-
name|locale
argument_list|)
argument_list|,
name|locale
argument_list|,
operator|&
name|sep
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: %s [-a] [-i indent] [-n name] [-o output_file] [-v] [-L] [directories...]\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|trap_signal
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|trap_signal
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|trap_signal
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|trap_signal
argument_list|)
expr_stmt|;
name|SLIST_INIT
argument_list|(
operator|&
name|visited_dirs
argument_list|)
expr_stmt|;
name|whatis_proto
operator|=
name|new_sbuf
argument_list|()
expr_stmt|;
name|whatis_final
operator|=
name|new_sbuf
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|machine
operator|=
name|getenv
argument_list|(
literal|"MACHINE"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
specifier|static
name|struct
name|utsname
name|utsname
decl_stmt|;
if|if
condition|(
name|uname
argument_list|(
operator|&
name|utsname
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"uname"
argument_list|)
expr_stmt|;
name|machine
operator|=
name|utsname
operator|.
name|machine
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|machine_arch
operator|=
name|getenv
argument_list|(
literal|"MACHINE_ARCH"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|machine_arch
operator|=
name|MACHINE_ARCH
expr_stmt|;
if|if
condition|(
name|common_output
operator|!=
name|NULL
operator|&&
operator|(
name|fp
operator|=
name|open_output
argument_list|(
name|common_output
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"%s"
argument_list|,
name|common_output
argument_list|)
expr_stmt|;
if|if
condition|(
name|optind
operator|==
name|argc
condition|)
block|{
specifier|const
name|char
modifier|*
name|manpath
init|=
name|getenv
argument_list|(
literal|"MANPATH"
argument_list|)
decl_stmt|;
if|if
condition|(
name|manpath
operator|==
name|NULL
condition|)
name|manpath
operator|=
name|DEFAULT_MANPATH
expr_stmt|;
name|process_argument
argument_list|(
name|manpath
argument_list|)
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|optind
operator|<
name|argc
condition|)
name|process_argument
argument_list|(
name|argv
index|[
name|optind
operator|++
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|common_output
operator|!=
name|NULL
condition|)
name|finish_output
argument_list|(
name|fp
argument_list|,
name|common_output
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|exit_code
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

