begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/****************************************************************************  * Copyright (c) 1998-2012,2013 Free Software Foundation, Inc.              *  *                                                                          *  * Permission is hereby granted, free of charge, to any person obtaining a  *  * copy of this software and associated documentation files (the            *  * "Software"), to deal in the Software without restriction, including      *  * without limitation the rights to use, copy, modify, merge, publish,      *  * distribute, distribute with modifications, sublicense, and/or sell       *  * copies of the Software, and to permit persons to whom the Software is    *  * furnished to do so, subject to the following conditions:                 *  *                                                                          *  * The above copyright notice and this permission notice shall be included  *  * in all copies or substantial portions of the Software.                   *  *                                                                          *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *  * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *  * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *  * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *  * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *  * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *  *                                                                          *  * Except as contained in this notice, the name(s) of the above copyright   *  * holders shall not be used in advertising or otherwise to promote the     *  * sale, use or other dealings in this Software without prior written       *  * authorization.                                                           *  ****************************************************************************/
end_comment

begin_comment
comment|/****************************************************************************  *  Author: Zeyd M. Ben-Halim<zmbenhal@netcom.com> 1992,1995               *  *     and: Eric S. Raymond<esr@snark.thyrsus.com>                         *  *     and: Thomas E. Dickey                        1996 on                 *  ****************************************************************************/
end_comment

begin_comment
comment|/*  *	tic.c --- Main program for terminfo compiler  *			by Eric S. Raymond  *			and Thomas E Dickey  *  */
end_comment

begin_include
include|#
directive|include
file|<progs.priv.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<dump_entry.h>
end_include

begin_include
include|#
directive|include
file|<hashed_db.h>
end_include

begin_include
include|#
directive|include
file|<transform.h>
end_include

begin_macro
name|MODULE_ID
argument_list|(
literal|"$Id: tic.c,v 1.189 2013/11/16 19:58:09 tom Exp $"
argument_list|)
end_macro

begin_define
define|#
directive|define
name|STDIN_NAME
value|"<stdin>"
end_define

begin_decl_stmt
specifier|const
name|char
modifier|*
name|_nc_progname
init|=
literal|"tic"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|log_fp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|tmp_fp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|capdump
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* running as infotocap? */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|infodump
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* running as captoinfo? */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|showsummary
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|namelst
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|to_remove
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
function_decl|(
modifier|*
name|save_check_termtype
function_decl|)
parameter_list|(
name|TERMTYPE
modifier|*
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|check_termtype
parameter_list|(
name|TERMTYPE
modifier|*
name|tt
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
specifier|const
name|char
name|usage_string
index|[]
init|=
literal|"\ [-e names] \ [-o dir] \ [-R name] \ [-v[n]] \ [-V] \ [-w[n]] \ [-\ 1\ a\ C\ D\ c\ f\ G\ g\ I\ K\ L\ N\ r\ s\ T\ t\ U\ x\ ] \ source-file\n"
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|NO_LEAKS
end_if

begin_function
specifier|static
name|void
name|free_namelist
parameter_list|(
name|char
modifier|*
modifier|*
name|src
parameter_list|)
block|{
if|if
condition|(
name|src
operator|!=
literal|0
condition|)
block|{
name|int
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|src
index|[
name|n
index|]
operator|!=
literal|0
condition|;
operator|++
name|n
control|)
name|free
argument_list|(
name|src
index|[
name|n
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|src
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|cleanup
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
if|#
directive|if
name|NO_LEAKS
name|free_namelist
argument_list|(
name|namelst
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|tmp_fp
operator|!=
literal|0
condition|)
name|fclose
argument_list|(
name|tmp_fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|to_remove
operator|!=
literal|0
condition|)
block|{
if|#
directive|if
name|HAVE_REMOVE
name|rc
operator|=
name|remove
argument_list|(
name|to_remove
argument_list|)
expr_stmt|;
else|#
directive|else
name|rc
operator|=
name|unlink
argument_list|(
name|to_remove
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
name|perror
argument_list|(
name|to_remove
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|failed
parameter_list|(
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
name|perror
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|ExitProgram
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|tbl
index|[]
init|=
block|{
literal|"Options:"
block|,
literal|"  -1         format translation output one capability per line"
block|,
if|#
directive|if
name|NCURSES_XNAMES
literal|"  -a         retain commented-out capabilities (sets -x also)"
block|,
endif|#
directive|endif
literal|"  -K         translate entries to termcap source form with BSD syntax"
block|,
literal|"  -C         translate entries to termcap source form"
block|,
literal|"  -D         print list of tic's database locations (first must be writable)"
block|,
literal|"  -c         check only, validate input without compiling or translating"
block|,
literal|"  -e<names>  translate/compile only entries named by comma-separated list"
block|,
literal|"  -f         format complex strings for readability"
block|,
literal|"  -G         format %{number} to %'char'"
block|,
literal|"  -g         format %'char' to %{number}"
block|,
literal|"  -I         translate entries to terminfo source form"
block|,
literal|"  -L         translate entries to full terminfo source form"
block|,
literal|"  -N         disable smart defaults for source translation"
block|,
literal|"  -o<dir>    set output directory for compiled entry writes"
block|,
literal|"  -R<name>   restrict translation to given terminfo/termcap version"
block|,
literal|"  -r         force resolution of all use entries in source translation"
block|,
literal|"  -s         print summary statistics"
block|,
literal|"  -T         remove size-restrictions on compiled description"
block|,
if|#
directive|if
name|NCURSES_XNAMES
literal|"  -t         suppress commented-out capabilities"
block|,
endif|#
directive|endif
literal|"  -U         suppress post-processing of entries"
block|,
literal|"  -V         print version"
block|,
literal|"  -v[n]      set verbosity level"
block|,
literal|"  -w[n]      set format width for translation output"
block|,
if|#
directive|if
name|NCURSES_XNAMES
literal|"  -x         treat unknown capabilities as user-defined"
block|,
endif|#
directive|endif
literal|""
block|,
literal|"Parameters:"
block|,
literal|"<file>     file to translate or compile"
block|}
decl_stmt|;
name|size_t
name|j
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: %s %s\n"
argument_list|,
name|_nc_progname
argument_list|,
name|usage_string
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|SIZEOF
argument_list|(
name|tbl
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
name|fputs
argument_list|(
name|tbl
index|[
name|j
index|]
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
name|ExitProgram
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|L_BRACE
value|'{'
end_define

begin_define
define|#
directive|define
name|R_BRACE
value|'}'
end_define

begin_define
define|#
directive|define
name|S_QUOTE
value|'\''
end_define

begin_function
specifier|static
name|void
name|write_it
parameter_list|(
name|ENTRY
modifier|*
name|ep
parameter_list|)
block|{
name|unsigned
name|n
decl_stmt|;
name|int
name|ch
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|d
decl_stmt|,
modifier|*
name|t
decl_stmt|;
name|char
name|result
index|[
name|MAX_ENTRY_SIZE
index|]
decl_stmt|;
comment|/*      * Look for strings that contain %{number}, convert them to %'char',      * which is shorter and runs a little faster.      */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|STRCOUNT
condition|;
name|n
operator|++
control|)
block|{
name|s
operator|=
name|ep
operator|->
name|tterm
operator|.
name|Strings
index|[
name|n
index|]
expr_stmt|;
if|if
condition|(
name|VALID_STRING
argument_list|(
name|s
argument_list|)
operator|&&
name|strchr
argument_list|(
name|s
argument_list|,
name|L_BRACE
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|d
operator|=
name|result
expr_stmt|;
name|t
operator|=
name|s
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
operator|*
name|t
operator|++
operator|)
operator|!=
literal|0
condition|)
block|{
operator|*
name|d
operator|++
operator|=
operator|(
name|char
operator|)
name|ch
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'\\'
condition|)
block|{
operator|*
name|d
operator|++
operator|=
operator|*
name|t
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ch
operator|==
literal|'%'
operator|)
operator|&&
operator|(
operator|*
name|t
operator|==
name|L_BRACE
operator|)
condition|)
block|{
name|char
modifier|*
name|v
init|=
literal|0
decl_stmt|;
name|long
name|value
init|=
name|strtol
argument_list|(
name|t
operator|+
literal|1
argument_list|,
operator|&
name|v
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|v
operator|!=
literal|0
operator|&&
operator|*
name|v
operator|==
name|R_BRACE
operator|&&
name|value
operator|>
literal|0
operator|&&
name|value
operator|!=
literal|'\\'
comment|/* FIXME */
operator|&&
name|value
operator|<
literal|127
operator|&&
name|isprint
argument_list|(
operator|(
name|int
operator|)
name|value
argument_list|)
condition|)
block|{
operator|*
name|d
operator|++
operator|=
name|S_QUOTE
expr_stmt|;
operator|*
name|d
operator|++
operator|=
operator|(
name|char
operator|)
name|value
expr_stmt|;
operator|*
name|d
operator|++
operator|=
name|S_QUOTE
expr_stmt|;
name|t
operator|=
operator|(
name|v
operator|+
literal|1
operator|)
expr_stmt|;
block|}
block|}
block|}
operator|*
name|d
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|result
argument_list|)
operator|<
name|strlen
argument_list|(
name|s
argument_list|)
condition|)
name|_nc_STRCPY
argument_list|(
name|s
argument_list|,
name|result
argument_list|,
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|_nc_set_type
argument_list|(
name|_nc_first_name
argument_list|(
name|ep
operator|->
name|tterm
operator|.
name|term_names
argument_list|)
argument_list|)
expr_stmt|;
name|_nc_curr_line
operator|=
operator|(
name|int
operator|)
name|ep
operator|->
name|startline
expr_stmt|;
name|_nc_write_entry
argument_list|(
operator|&
name|ep
operator|->
name|tterm
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bool
name|immedhook
parameter_list|(
name|ENTRY
modifier|*
name|ep
name|GCC_UNUSED
parameter_list|)
comment|/* write out entries with no use capabilities immediately to save storage */
block|{
if|#
directive|if
operator|!
name|HAVE_BIG_CORE
comment|/*      * This is strictly a core-economy kluge.  The really clean way to handle      * compilation is to slurp the whole file into core and then do all the      * name-collision checks and entry writes in one swell foop.  But the      * terminfo master file is large enough that some core-poor systems swap      * like crazy when you compile it this way...there have been reports of      * this process taking *three hours*, rather than the twenty seconds or      * less typical on my development box.      *      * So.  This hook *immediately* writes out the referenced entry if it      * has no use capabilities.  The compiler main loop refrains from      * adding the entry to the in-core list when this hook fires.  If some      * other entry later needs to reference an entry that got written      * immediately, that's OK; the resolution code will fetch it off disk      * when it can't find it in core.      *      * Name collisions will still be detected, just not as cleanly.  The      * write_entry() code complains before overwriting an entry that      * postdates the time of tic's first call to write_entry().  Thus      * it will complain about overwriting entries newly made during the      * tic run, but not about overwriting ones that predate it.      *      * The reason this is a hook, and not in line with the rest of the      * compiler code, is that the support for termcap fallback cannot assume      * it has anywhere to spool out these entries!      *      * The _nc_set_type() call here requires a compensating one in      * _nc_parse_entry().      *      * If you define HAVE_BIG_CORE, you'll disable this kluge.  This will      * make tic a bit faster (because the resolution code won't have to do      * disk I/O nearly as often).      */
if|if
condition|(
name|ep
operator|->
name|nuses
operator|==
literal|0
condition|)
block|{
name|int
name|oldline
init|=
name|_nc_curr_line
decl_stmt|;
name|write_it
argument_list|(
name|ep
argument_list|)
expr_stmt|;
name|_nc_curr_line
operator|=
name|oldline
expr_stmt|;
name|free
argument_list|(
name|ep
operator|->
name|tterm
operator|.
name|str_table
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* HAVE_BIG_CORE */
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|put_translate
parameter_list|(
name|int
name|c
parameter_list|)
comment|/* emit a comment char, translating terminfo names to termcap names */
block|{
specifier|static
name|bool
name|in_name
init|=
name|FALSE
decl_stmt|;
specifier|static
name|size_t
name|have
decl_stmt|,
name|used
decl_stmt|;
specifier|static
name|char
modifier|*
name|namebuf
decl_stmt|,
modifier|*
name|suffix
decl_stmt|;
if|if
condition|(
name|in_name
condition|)
block|{
if|if
condition|(
name|used
operator|+
literal|1
operator|>=
name|have
condition|)
block|{
name|have
operator|+=
literal|132
expr_stmt|;
if|if
condition|(
operator|(
name|namebuf
operator|=
name|typeRealloc
argument_list|(
name|char
argument_list|,
name|have
argument_list|,
name|namebuf
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|failed
argument_list|(
literal|"put_translate namebuf"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|suffix
operator|=
name|typeRealloc
argument_list|(
name|char
argument_list|,
name|have
argument_list|,
name|suffix
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|failed
argument_list|(
literal|"put_translate suffix"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
literal|'@'
condition|)
block|{
name|namebuf
index|[
name|used
operator|++
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|putchar
argument_list|(
literal|'<'
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fputs
argument_list|(
name|namebuf
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|in_name
operator|=
name|FALSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|!=
literal|'>'
condition|)
block|{
name|namebuf
index|[
name|used
operator|++
index|]
operator|=
operator|(
name|char
operator|)
name|c
expr_stmt|;
block|}
else|else
block|{
comment|/* ah! candidate name! */
name|char
modifier|*
name|up
decl_stmt|;
name|NCURSES_CONST
name|char
modifier|*
name|tp
decl_stmt|;
name|namebuf
index|[
name|used
operator|++
index|]
operator|=
literal|'\0'
expr_stmt|;
name|in_name
operator|=
name|FALSE
expr_stmt|;
name|suffix
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|up
operator|=
name|strchr
argument_list|(
name|namebuf
argument_list|,
literal|'#'
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|up
operator|=
name|strchr
argument_list|(
name|namebuf
argument_list|,
literal|'='
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
operator|(
name|up
operator|=
name|strchr
argument_list|(
name|namebuf
argument_list|,
literal|'@'
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|up
index|[
literal|1
index|]
operator|==
literal|'>'
operator|)
condition|)
block|{
name|_nc_STRCPY
argument_list|(
name|suffix
argument_list|,
name|up
argument_list|,
name|have
argument_list|)
expr_stmt|;
operator|*
name|up
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|tp
operator|=
name|nametrans
argument_list|(
name|namebuf
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|putchar
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fputs
argument_list|(
name|tp
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fputs
argument_list|(
name|suffix
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putchar
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* couldn't find a translation, just dump the name */
operator|(
name|void
operator|)
name|putchar
argument_list|(
literal|'<'
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fputs
argument_list|(
name|namebuf
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fputs
argument_list|(
name|suffix
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putchar
argument_list|(
literal|'>'
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|used
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'<'
condition|)
block|{
name|in_name
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Returns a string, stripped of leading/trailing whitespace */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|stripped
parameter_list|(
name|char
modifier|*
name|src
parameter_list|)
block|{
name|char
modifier|*
name|dst
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|isspace
argument_list|(
name|UChar
argument_list|(
operator|*
name|src
argument_list|)
argument_list|)
condition|)
name|src
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|src
operator|!=
literal|'\0'
condition|)
block|{
name|size_t
name|len
decl_stmt|;
if|if
condition|(
operator|(
name|dst
operator|=
name|strdup
argument_list|(
name|src
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|failed
argument_list|(
literal|"strdup"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|len
operator|=
name|strlen
argument_list|(
name|dst
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|len
operator|!=
literal|0
operator|&&
name|isspace
argument_list|(
name|UChar
argument_list|(
name|dst
index|[
name|len
index|]
argument_list|)
argument_list|)
condition|)
name|dst
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
return|return
name|dst
return|;
block|}
end_function

begin_function
specifier|static
name|FILE
modifier|*
name|open_tempfile
parameter_list|(
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|FILE
modifier|*
name|result
init|=
literal|0
decl_stmt|;
name|_nc_STRCPY
argument_list|(
name|filename
argument_list|,
literal|"/tmp/XXXXXX"
argument_list|,
name|PATH_MAX
argument_list|)
expr_stmt|;
if|#
directive|if
name|HAVE_MKSTEMP
block|{
name|int
name|oldmask
init|=
operator|(
name|int
operator|)
name|umask
argument_list|(
literal|077
argument_list|)
decl_stmt|;
name|int
name|fd
init|=
name|mkstemp
argument_list|(
name|filename
argument_list|)
decl_stmt|;
if|if
condition|(
name|fd
operator|>=
literal|0
condition|)
name|result
operator|=
name|fdopen
argument_list|(
name|fd
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
name|umask
argument_list|(
operator|(
name|mode_t
operator|)
name|oldmask
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
name|tmpnam
argument_list|(
name|filename
argument_list|)
operator|!=
literal|0
condition|)
name|result
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|FILE
modifier|*
name|copy_input
parameter_list|(
name|FILE
modifier|*
name|source
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|char
modifier|*
name|alt_file
parameter_list|)
block|{
name|char
name|my_altfile
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|FILE
modifier|*
name|result
init|=
literal|0
decl_stmt|;
name|FILE
modifier|*
name|target
init|=
literal|0
decl_stmt|;
name|int
name|ch
decl_stmt|;
if|if
condition|(
name|alt_file
operator|==
literal|0
condition|)
name|alt_file
operator|=
name|my_altfile
expr_stmt|;
if|if
condition|(
name|source
operator|==
literal|0
condition|)
block|{
name|failed
argument_list|(
literal|"copy_input (source)"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|target
operator|=
name|open_tempfile
argument_list|(
name|alt_file
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|failed
argument_list|(
literal|"copy_input (target)"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|clearerr
argument_list|(
name|source
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|ch
operator|=
name|fgetc
argument_list|(
name|source
argument_list|)
expr_stmt|;
if|if
condition|(
name|feof
argument_list|(
name|source
argument_list|)
condition|)
block|{
break|break;
block|}
elseif|else
if|if
condition|(
name|ferror
argument_list|(
name|source
argument_list|)
condition|)
block|{
name|failed
argument_list|(
name|filename
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|0
condition|)
block|{
comment|/* don't loop in case someone wants to convert /dev/zero */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s is not a text-file\n"
argument_list|,
name|_nc_progname
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|ExitProgram
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
name|fputc
argument_list|(
name|ch
argument_list|,
name|target
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|source
argument_list|)
expr_stmt|;
comment|/* 	 * rewind() does not force the target file's data to disk (not does 	 * fflush()...).  So open a second stream on the data and then close 	 * the one that we were writing on before starting to read from the 	 * second stream. 	 */
name|result
operator|=
name|fopen
argument_list|(
name|alt_file
argument_list|,
literal|"r+"
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|to_remove
operator|=
name|strdup
argument_list|(
name|alt_file
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|FILE
modifier|*
name|open_input
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|char
modifier|*
name|alt_file
parameter_list|)
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|struct
name|stat
name|sb
decl_stmt|;
name|int
name|mode
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|filename
argument_list|,
literal|"-"
argument_list|)
condition|)
block|{
name|fp
operator|=
name|copy_input
argument_list|(
name|stdin
argument_list|,
name|STDIN_NAME
argument_list|,
name|alt_file
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|stat
argument_list|(
name|filename
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s %s\n"
argument_list|,
name|_nc_progname
argument_list|,
name|filename
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|ExitProgram
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|mode
operator|=
operator|(
name|sb
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|)
operator|==
name|S_IFDIR
operator|||
operator|(
name|mode
operator|!=
name|S_IFREG
operator|&&
name|mode
operator|!=
name|S_IFCHR
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s is not a file\n"
argument_list|,
name|_nc_progname
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|ExitProgram
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fp
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Can't open %s\n"
argument_list|,
name|_nc_progname
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|ExitProgram
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mode
operator|!=
name|S_IFREG
condition|)
block|{
if|if
condition|(
name|alt_file
operator|!=
literal|0
condition|)
block|{
name|FILE
modifier|*
name|fp2
init|=
name|copy_input
argument_list|(
name|fp
argument_list|,
name|filename
argument_list|,
name|alt_file
argument_list|)
decl_stmt|;
name|fp
operator|=
name|fp2
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s is not a file\n"
argument_list|,
name|_nc_progname
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|ExitProgram
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|fp
return|;
block|}
end_function

begin_comment
comment|/* Parse the "-e" option-value into a list of names */
end_comment

begin_function
specifier|static
name|char
modifier|*
modifier|*
name|make_namelist
parameter_list|(
name|char
modifier|*
name|src
parameter_list|)
block|{
name|char
modifier|*
modifier|*
name|dst
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|base
decl_stmt|;
name|unsigned
name|pass
decl_stmt|,
name|n
decl_stmt|,
name|nn
decl_stmt|;
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
if|if
condition|(
name|src
operator|==
literal|0
condition|)
block|{
comment|/* EMPTY */
empty_stmt|;
block|}
elseif|else
if|if
condition|(
name|strchr
argument_list|(
name|src
argument_list|,
literal|'/'
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* a filename */
name|FILE
modifier|*
name|fp
init|=
name|open_input
argument_list|(
name|src
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
decl_stmt|;
for|for
control|(
name|pass
operator|=
literal|1
init|;
name|pass
operator|<=
literal|2
condition|;
name|pass
operator|++
control|)
block|{
name|nn
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
name|fp
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|s
operator|=
name|stripped
argument_list|(
name|buffer
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|dst
operator|!=
literal|0
condition|)
name|dst
index|[
name|nn
index|]
operator|=
name|s
expr_stmt|;
else|else
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|nn
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|pass
operator|==
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|dst
operator|=
name|typeCalloc
argument_list|(
name|char
operator|*
argument_list|,
name|nn
operator|+
literal|1
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|failed
argument_list|(
literal|"make_namelist"
argument_list|)
expr_stmt|;
name|rewind
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* literal list of names */
for|for
control|(
name|pass
operator|=
literal|1
init|;
name|pass
operator|<=
literal|2
condition|;
name|pass
operator|++
control|)
block|{
for|for
control|(
name|n
operator|=
name|nn
operator|=
literal|0
operator|,
name|base
operator|=
name|src
init|;
condition|;
name|n
operator|++
control|)
block|{
name|int
name|mark
init|=
name|src
index|[
name|n
index|]
decl_stmt|;
if|if
condition|(
name|mark
operator|==
literal|','
operator|||
name|mark
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|pass
operator|==
literal|1
condition|)
block|{
name|nn
operator|++
expr_stmt|;
block|}
else|else
block|{
name|src
index|[
name|n
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|stripped
argument_list|(
name|base
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|dst
index|[
name|nn
operator|++
index|]
operator|=
name|s
expr_stmt|;
name|base
operator|=
operator|&
name|src
index|[
name|n
operator|+
literal|1
index|]
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mark
operator|==
literal|'\0'
condition|)
break|break;
block|}
if|if
condition|(
name|pass
operator|==
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|dst
operator|=
name|typeCalloc
argument_list|(
name|char
operator|*
argument_list|,
name|nn
operator|+
literal|1
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|failed
argument_list|(
literal|"make_namelist"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|showsummary
operator|&&
operator|(
name|dst
operator|!=
literal|0
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|log_fp
argument_list|,
literal|"Entries that will be compiled:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|dst
index|[
name|n
index|]
operator|!=
literal|0
condition|;
name|n
operator|++
control|)
name|fprintf
argument_list|(
name|log_fp
argument_list|,
literal|"%u:%s\n"
argument_list|,
name|n
operator|+
literal|1
argument_list|,
name|dst
index|[
name|n
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|dst
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|matches
parameter_list|(
name|char
modifier|*
modifier|*
name|needle
parameter_list|,
specifier|const
name|char
modifier|*
name|haystack
parameter_list|)
comment|/* does entry in needle list match |-separated field in haystack? */
block|{
name|bool
name|code
init|=
name|FALSE
decl_stmt|;
name|size_t
name|n
decl_stmt|;
if|if
condition|(
name|needle
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|n
operator|=
literal|0
init|;
name|needle
index|[
name|n
index|]
operator|!=
literal|0
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|_nc_name_match
argument_list|(
name|haystack
argument_list|,
name|needle
index|[
name|n
index|]
argument_list|,
literal|"|"
argument_list|)
condition|)
block|{
name|code
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
block|}
else|else
name|code
operator|=
name|TRUE
expr_stmt|;
return|return
operator|(
name|code
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|valid_db_path
parameter_list|(
specifier|const
name|char
modifier|*
name|nominal
parameter_list|)
block|{
name|struct
name|stat
name|sb
decl_stmt|;
if|#
directive|if
name|USE_HASHED_DB
name|char
name|suffix
index|[]
init|=
name|DBM_SUFFIX
decl_stmt|;
name|size_t
name|need
init|=
name|strlen
argument_list|(
name|nominal
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|suffix
argument_list|)
decl_stmt|;
name|char
modifier|*
name|result
init|=
name|malloc
argument_list|(
name|need
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|==
literal|0
condition|)
name|failed
argument_list|(
literal|"valid_db_path"
argument_list|)
expr_stmt|;
name|_nc_STRCPY
argument_list|(
name|result
argument_list|,
name|nominal
argument_list|,
name|need
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|result
operator|+
name|need
operator|-
sizeof|sizeof
argument_list|(
name|suffix
argument_list|)
argument_list|,
name|suffix
argument_list|)
condition|)
block|{
name|_nc_STRCAT
argument_list|(
name|result
argument_list|,
name|suffix
argument_list|,
name|need
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|char
modifier|*
name|result
init|=
name|strdup
argument_list|(
name|nominal
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|DEBUG
argument_list|(
literal|1
argument_list|,
operator|(
literal|"** stat(%s)"
operator|,
name|result
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|result
argument_list|,
operator|&
name|sb
argument_list|)
operator|>=
literal|0
condition|)
block|{
if|#
directive|if
name|USE_HASHED_DB
if|if
condition|(
operator|!
name|S_ISREG
argument_list|(
name|sb
operator|.
name|st_mode
argument_list|)
operator|||
name|access
argument_list|(
name|result
argument_list|,
name|R_OK
operator||
name|W_OK
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|DEBUG
argument_list|(
literal|1
argument_list|,
operator|(
literal|"...not a writable file"
operator|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|result
operator|=
literal|0
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
operator|!
name|S_ISDIR
argument_list|(
name|sb
operator|.
name|st_mode
argument_list|)
operator|||
name|access
argument_list|(
name|result
argument_list|,
name|R_OK
operator||
name|W_OK
operator||
name|X_OK
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|DEBUG
argument_list|(
literal|1
argument_list|,
operator|(
literal|"...not a writable directory"
operator|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|result
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
block|}
else|else
block|{
comment|/* check if parent is directory and is writable */
name|unsigned
name|leaf
init|=
name|_nc_pathlast
argument_list|(
name|result
argument_list|)
decl_stmt|;
name|DEBUG
argument_list|(
literal|1
argument_list|,
operator|(
literal|"...not found"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|leaf
condition|)
block|{
name|char
name|save
init|=
name|result
index|[
name|leaf
index|]
decl_stmt|;
name|result
index|[
name|leaf
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|result
argument_list|,
operator|&
name|sb
argument_list|)
operator|>=
literal|0
operator|&&
name|S_ISDIR
argument_list|(
name|sb
operator|.
name|st_mode
argument_list|)
operator|&&
name|access
argument_list|(
name|result
argument_list|,
name|R_OK
operator||
name|W_OK
operator||
name|X_OK
argument_list|)
operator|==
literal|0
condition|)
block|{
name|result
index|[
name|leaf
index|]
operator|=
name|save
expr_stmt|;
block|}
else|else
block|{
name|DEBUG
argument_list|(
literal|1
argument_list|,
operator|(
literal|"...parent directory %s is not writable"
operator|,
name|result
operator|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|result
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|DEBUG
argument_list|(
literal|1
argument_list|,
operator|(
literal|"... no parent directory"
operator|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|result
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/*  * Show the databases to which tic could write.  The location to which it  * writes is always the first one.  If none are writable, print an error  * message.  */
end_comment

begin_function
specifier|static
name|void
name|show_databases
parameter_list|(
specifier|const
name|char
modifier|*
name|outdir
parameter_list|)
block|{
name|bool
name|specific
init|=
operator|(
name|outdir
operator|!=
literal|0
operator|)
operator|||
name|getenv
argument_list|(
literal|"TERMINFO"
argument_list|)
operator|!=
literal|0
decl_stmt|;
name|char
modifier|*
name|result
decl_stmt|;
specifier|const
name|char
modifier|*
name|tried
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|outdir
operator|==
literal|0
condition|)
block|{
name|outdir
operator|=
name|_nc_tic_dir
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|result
operator|=
name|valid_db_path
argument_list|(
name|outdir
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tried
operator|=
name|outdir
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|outdir
operator|=
name|_nc_home_terminfo
argument_list|()
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|result
operator|=
name|valid_db_path
argument_list|(
name|outdir
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|specific
condition|)
block|{
name|tried
operator|=
name|outdir
expr_stmt|;
block|}
block|}
comment|/*      * If we can write in neither location, give an error message.      */
if|if
condition|(
name|tried
condition|)
block|{
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s (no permission)\n"
argument_list|,
name|_nc_progname
argument_list|,
name|tried
argument_list|)
expr_stmt|;
name|ExitProgram
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|VtoTrace
parameter_list|(
name|opt
parameter_list|)
value|(unsigned) ((opt> 0) ? opt : (opt == 0))
end_define

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|char
name|my_tmpname
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|char
name|my_altfile
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|int
name|v_opt
init|=
operator|-
literal|1
decl_stmt|;
name|unsigned
name|debug_level
decl_stmt|;
name|int
name|smart_defaults
init|=
name|TRUE
decl_stmt|;
name|char
modifier|*
name|termcap
decl_stmt|;
name|ENTRY
modifier|*
name|qp
decl_stmt|;
name|int
name|this_opt
decl_stmt|,
name|last_opt
init|=
literal|'?'
decl_stmt|;
name|int
name|outform
init|=
name|F_TERMINFO
decl_stmt|;
comment|/* output format */
name|int
name|sortmode
init|=
name|S_TERMINFO
decl_stmt|;
comment|/* sort_mode */
name|int
name|width
init|=
literal|60
decl_stmt|;
name|int
name|height
init|=
literal|65535
decl_stmt|;
name|bool
name|formatted
init|=
name|FALSE
decl_stmt|;
comment|/* reformat complex strings? */
name|bool
name|literal
init|=
name|FALSE
decl_stmt|;
comment|/* suppress post-processing? */
name|int
name|numbers
init|=
literal|0
decl_stmt|;
comment|/* format "%'char'" to/from "%{number}" */
name|bool
name|forceresolve
init|=
name|FALSE
decl_stmt|;
comment|/* force resolution */
name|bool
name|limited
init|=
name|TRUE
decl_stmt|;
name|char
modifier|*
name|tversion
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|source_file
init|=
literal|"terminfo"
decl_stmt|;
name|char
modifier|*
name|outdir
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
name|bool
name|check_only
init|=
name|FALSE
decl_stmt|;
name|bool
name|suppress_untranslatable
init|=
name|FALSE
decl_stmt|;
name|log_fp
operator|=
name|stderr
expr_stmt|;
name|_nc_progname
operator|=
name|_nc_rootname
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|atexit
argument_list|(
name|cleanup
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|infodump
operator|=
name|same_program
argument_list|(
name|_nc_progname
argument_list|,
name|PROG_CAPTOINFO
argument_list|)
operator|)
operator|!=
name|FALSE
condition|)
block|{
name|outform
operator|=
name|F_TERMINFO
expr_stmt|;
name|sortmode
operator|=
name|S_TERMINFO
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|capdump
operator|=
name|same_program
argument_list|(
name|_nc_progname
argument_list|,
name|PROG_INFOTOCAP
argument_list|)
operator|)
operator|!=
name|FALSE
condition|)
block|{
name|outform
operator|=
name|F_TERMCAP
expr_stmt|;
name|sortmode
operator|=
name|S_TERMCAP
expr_stmt|;
block|}
if|#
directive|if
name|NCURSES_XNAMES
name|use_extended_names
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|_nc_strict_bsd
operator|=
literal|0
expr_stmt|;
comment|/*      * Processing arguments is a little complicated, since someone made a      * design decision to allow the numeric values for -w, -v options to      * be optional.      */
while|while
condition|(
operator|(
name|this_opt
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"0123456789CDIKLNR:TUVace:fGgo:rstvwx"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|isdigit
argument_list|(
name|this_opt
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|last_opt
condition|)
block|{
case|case
literal|'v'
case|:
name|v_opt
operator|=
operator|(
name|v_opt
operator|*
literal|10
operator|)
operator|+
operator|(
name|this_opt
operator|-
literal|'0'
operator|)
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|width
operator|=
operator|(
name|width
operator|*
literal|10
operator|)
operator|+
operator|(
name|this_opt
operator|-
literal|'0'
operator|)
expr_stmt|;
break|break;
default|default:
switch|switch
condition|(
name|this_opt
condition|)
block|{
case|case
literal|'0'
case|:
name|last_opt
operator|=
name|this_opt
expr_stmt|;
name|width
operator|=
literal|65535
expr_stmt|;
name|height
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'1'
case|:
name|last_opt
operator|=
name|this_opt
expr_stmt|;
name|width
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|()
expr_stmt|;
block|}
block|}
continue|continue;
block|}
switch|switch
condition|(
name|this_opt
condition|)
block|{
case|case
literal|'K'
case|:
name|_nc_strict_bsd
operator|=
literal|1
expr_stmt|;
comment|/* the initial version of -K in 20110730 fell-thru here, but the 	     * same flag is useful when reading sources -TD 	     */
break|break;
case|case
literal|'C'
case|:
name|capdump
operator|=
name|TRUE
expr_stmt|;
name|outform
operator|=
name|F_TERMCAP
expr_stmt|;
name|sortmode
operator|=
name|S_TERMCAP
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|debug_level
operator|=
name|VtoTrace
argument_list|(
name|v_opt
argument_list|)
expr_stmt|;
name|set_trace_level
argument_list|(
name|debug_level
argument_list|)
expr_stmt|;
name|show_databases
argument_list|(
name|outdir
argument_list|)
expr_stmt|;
name|ExitProgram
argument_list|(
name|EXIT_SUCCESS
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
name|infodump
operator|=
name|TRUE
expr_stmt|;
name|outform
operator|=
name|F_TERMINFO
expr_stmt|;
name|sortmode
operator|=
name|S_TERMINFO
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
name|infodump
operator|=
name|TRUE
expr_stmt|;
name|outform
operator|=
name|F_VARIABLE
expr_stmt|;
name|sortmode
operator|=
name|S_VARIABLE
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
name|smart_defaults
operator|=
name|FALSE
expr_stmt|;
name|literal
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|tversion
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
name|limited
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
literal|'U'
case|:
name|literal
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
name|puts
argument_list|(
name|curses_version
argument_list|()
argument_list|)
expr_stmt|;
name|ExitProgram
argument_list|(
name|EXIT_SUCCESS
argument_list|)
expr_stmt|;
case|case
literal|'c'
case|:
name|check_only
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|namelst
operator|=
name|make_namelist
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|formatted
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'G'
case|:
name|numbers
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|numbers
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|outdir
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|forceresolve
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|showsummary
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|v_opt
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|width
operator|=
literal|0
expr_stmt|;
break|break;
if|#
directive|if
name|NCURSES_XNAMES
case|case
literal|'t'
case|:
name|_nc_disable_period
operator|=
name|FALSE
expr_stmt|;
name|suppress_untranslatable
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|_nc_disable_period
operator|=
name|TRUE
expr_stmt|;
comment|/* FALLTHRU */
case|case
literal|'x'
case|:
name|use_extended_names
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|usage
argument_list|()
expr_stmt|;
block|}
name|last_opt
operator|=
name|this_opt
expr_stmt|;
block|}
name|debug_level
operator|=
name|VtoTrace
argument_list|(
name|v_opt
argument_list|)
expr_stmt|;
name|set_trace_level
argument_list|(
name|debug_level
argument_list|)
expr_stmt|;
if|if
condition|(
name|_nc_tracing
condition|)
block|{
name|save_check_termtype
operator|=
name|_nc_check_termtype2
expr_stmt|;
name|_nc_check_termtype2
operator|=
name|check_termtype
expr_stmt|;
block|}
if|#
directive|if
operator|!
name|HAVE_BIG_CORE
comment|/*      * Aaargh! immedhook seriously hoses us!      *      * One problem with immedhook is it means we can't do -e.  Problem      * is that we can't guarantee that for each terminal listed, all the      * terminals it depends on will have been kept in core for reference      * resolution -- in fact it's certain the primitive types at the end      * of reference chains *won't* be in core unless they were explicitly      * in the select list themselves.      */
if|if
condition|(
name|namelst
operator|&&
operator|(
operator|!
name|infodump
operator|&&
operator|!
name|capdump
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Sorry, -e can't be used without -I or -C\n"
argument_list|,
name|_nc_progname
argument_list|)
expr_stmt|;
name|ExitProgram
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* HAVE_BIG_CORE */
if|if
condition|(
name|optind
operator|<
name|argc
condition|)
block|{
name|source_file
operator|=
name|argv
index|[
name|optind
operator|++
index|]
expr_stmt|;
if|if
condition|(
name|optind
operator|<
name|argc
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Too many file names.  Usage:\n\t%s %s"
argument_list|,
name|_nc_progname
argument_list|,
name|_nc_progname
argument_list|,
name|usage_string
argument_list|)
expr_stmt|;
name|ExitProgram
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|infodump
operator|==
name|TRUE
condition|)
block|{
comment|/* captoinfo's no-argument case */
name|source_file
operator|=
literal|"/etc/termcap"
expr_stmt|;
if|if
condition|(
operator|(
name|termcap
operator|=
name|getenv
argument_list|(
literal|"TERMCAP"
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|namelst
operator|=
name|make_namelist
argument_list|(
name|getenv
argument_list|(
literal|"TERM"
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|access
argument_list|(
name|termcap
argument_list|,
name|F_OK
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* file exists */
name|source_file
operator|=
name|termcap
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|tmp_fp
operator|=
name|open_tempfile
argument_list|(
name|my_tmpname
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|source_file
operator|=
name|my_tmpname
expr_stmt|;
name|fprintf
argument_list|(
name|tmp_fp
argument_list|,
literal|"%s\n"
argument_list|,
name|termcap
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|tmp_fp
argument_list|)
expr_stmt|;
name|tmp_fp
operator|=
name|open_input
argument_list|(
name|source_file
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|to_remove
operator|=
name|source_file
expr_stmt|;
block|}
else|else
block|{
name|failed
argument_list|(
literal|"tmpnam"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
comment|/* tic */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: File name needed.  Usage:\n\t%s %s"
argument_list|,
name|_nc_progname
argument_list|,
name|_nc_progname
argument_list|,
name|usage_string
argument_list|)
expr_stmt|;
name|ExitProgram
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tmp_fp
operator|==
literal|0
condition|)
block|{
name|tmp_fp
operator|=
name|open_input
argument_list|(
name|source_file
argument_list|,
name|my_altfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|source_file
argument_list|,
literal|"-"
argument_list|)
condition|)
block|{
name|source_file
operator|=
name|STDIN_NAME
expr_stmt|;
block|}
block|}
if|if
condition|(
name|infodump
condition|)
block|{
name|dump_init
argument_list|(
name|tversion
argument_list|,
name|smart_defaults
condition|?
name|outform
else|:
name|F_LITERAL
argument_list|,
name|sortmode
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|debug_level
argument_list|,
name|formatted
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|capdump
condition|)
block|{
name|dump_init
argument_list|(
name|tversion
argument_list|,
name|outform
argument_list|,
name|sortmode
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|debug_level
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
comment|/* parse entries out of the source file */
name|_nc_set_source
argument_list|(
name|source_file
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|HAVE_BIG_CORE
if|if
condition|(
operator|!
operator|(
name|check_only
operator|||
name|infodump
operator|||
name|capdump
operator|)
condition|)
name|_nc_set_writedir
argument_list|(
name|outdir
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_BIG_CORE */
name|_nc_read_entry_source
argument_list|(
name|tmp_fp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|!
name|smart_defaults
operator|||
name|literal
argument_list|,
name|FALSE
argument_list|,
operator|(
operator|(
name|check_only
operator|||
name|infodump
operator|||
name|capdump
operator|)
condition|?
name|NULLHOOK
else|:
name|immedhook
operator|)
argument_list|)
expr_stmt|;
comment|/* do use resolution */
if|if
condition|(
name|check_only
operator|||
operator|(
operator|!
name|infodump
operator|&&
operator|!
name|capdump
operator|)
operator|||
name|forceresolve
condition|)
block|{
if|if
condition|(
operator|!
name|_nc_resolve_uses2
argument_list|(
name|TRUE
argument_list|,
name|literal
argument_list|)
operator|&&
operator|!
name|check_only
condition|)
block|{
name|ExitProgram
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* length check */
if|if
condition|(
name|check_only
operator|&&
operator|(
name|capdump
operator|||
name|infodump
operator|)
condition|)
block|{
name|for_entry_list
argument_list|(
argument|qp
argument_list|)
block|{
if|if
condition|(
name|matches
argument_list|(
name|namelst
argument_list|,
name|qp
operator|->
name|tterm
operator|.
name|term_names
argument_list|)
condition|)
block|{
name|int
name|len
init|=
name|fmt_entry
argument_list|(
operator|&
name|qp
operator|->
name|tterm
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|,
name|infodump
argument_list|,
name|numbers
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|>
operator|(
name|infodump
condition|?
name|MAX_TERMINFO_LENGTH
else|:
name|MAX_TERMCAP_LENGTH
operator|)
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"warning: resolved %s entry is %d bytes long\n"
argument_list|,
name|_nc_first_name
argument_list|(
name|qp
operator|->
name|tterm
operator|.
name|term_names
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* write or dump all entries */
if|if
condition|(
operator|!
name|check_only
condition|)
block|{
if|if
condition|(
operator|!
name|infodump
operator|&&
operator|!
name|capdump
condition|)
block|{
name|_nc_set_writedir
argument_list|(
name|outdir
argument_list|)
expr_stmt|;
name|for_entry_list
argument_list|(
argument|qp
argument_list|)
block|{
if|if
condition|(
name|matches
argument_list|(
name|namelst
argument_list|,
name|qp
operator|->
name|tterm
operator|.
name|term_names
argument_list|)
condition|)
name|write_it
argument_list|(
name|qp
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* this is in case infotocap() generates warnings */
name|_nc_curr_col
operator|=
name|_nc_curr_line
operator|=
operator|-
literal|1
expr_stmt|;
name|for_entry_list
argument_list|(
argument|qp
argument_list|)
block|{
if|if
condition|(
name|matches
argument_list|(
name|namelst
argument_list|,
name|qp
operator|->
name|tterm
operator|.
name|term_names
argument_list|)
condition|)
block|{
name|long
name|j
init|=
name|qp
operator|->
name|cend
operator|-
name|qp
operator|->
name|cstart
decl_stmt|;
name|int
name|len
init|=
literal|0
decl_stmt|;
comment|/* this is in case infotocap() generates warnings */
name|_nc_set_type
argument_list|(
name|_nc_first_name
argument_list|(
name|qp
operator|->
name|tterm
operator|.
name|term_names
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fseek
argument_list|(
name|tmp_fp
argument_list|,
name|qp
operator|->
name|cstart
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
while|while
condition|(
name|j
operator|--
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|infodump
condition|)
operator|(
name|void
operator|)
name|putchar
argument_list|(
name|fgetc
argument_list|(
name|tmp_fp
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|put_translate
argument_list|(
name|fgetc
argument_list|(
name|tmp_fp
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|repair_acsc
argument_list|(
operator|&
name|qp
operator|->
name|tterm
argument_list|)
expr_stmt|;
name|dump_entry
argument_list|(
operator|&
name|qp
operator|->
name|tterm
argument_list|,
name|suppress_untranslatable
argument_list|,
name|limited
argument_list|,
name|numbers
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
operator|(
name|long
operator|)
name|qp
operator|->
name|nuses
condition|;
name|j
operator|++
control|)
name|dump_uses
argument_list|(
name|qp
operator|->
name|uses
index|[
name|j
index|]
operator|.
name|name
argument_list|,
operator|!
name|capdump
argument_list|)
expr_stmt|;
name|len
operator|=
name|show_entry
argument_list|()
expr_stmt|;
if|if
condition|(
name|debug_level
operator|!=
literal|0
operator|&&
operator|!
name|limited
condition|)
name|printf
argument_list|(
literal|"# length=%d\n"
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|namelst
operator|&&
name|_nc_tail
condition|)
block|{
name|int
name|c
decl_stmt|,
name|oldc
init|=
literal|'\0'
decl_stmt|;
name|bool
name|in_comment
init|=
name|FALSE
decl_stmt|;
name|bool
name|trailing_comment
init|=
name|FALSE
decl_stmt|;
operator|(
name|void
operator|)
name|fseek
argument_list|(
name|tmp_fp
argument_list|,
name|_nc_tail
operator|->
name|cend
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|fgetc
argument_list|(
name|tmp_fp
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
if|if
condition|(
name|oldc
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'#'
condition|)
block|{
name|trailing_comment
operator|=
name|TRUE
expr_stmt|;
name|in_comment
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|in_comment
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|trailing_comment
operator|&&
operator|(
name|in_comment
operator|||
operator|(
name|oldc
operator|==
literal|'\n'
operator|&&
name|c
operator|==
literal|'\n'
operator|)
operator|)
condition|)
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|oldc
operator|=
name|c
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* Show the directory into which entries were written, and the total      * number of entries      */
if|if
condition|(
name|showsummary
operator|&&
operator|(
operator|!
operator|(
name|check_only
operator|||
name|infodump
operator|||
name|capdump
operator|)
operator|)
condition|)
block|{
name|int
name|total
init|=
name|_nc_tic_written
argument_list|()
decl_stmt|;
if|if
condition|(
name|total
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|log_fp
argument_list|,
literal|"%d entries written to %s\n"
argument_list|,
name|total
argument_list|,
name|_nc_tic_dir
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|log_fp
argument_list|,
literal|"No entries written\n"
argument_list|)
expr_stmt|;
block|}
name|ExitProgram
argument_list|(
name|EXIT_SUCCESS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This bit of legerdemain turns all the terminfo variable names into  * references to locations in the arrays Booleans, Numbers, and Strings ---  * precisely what's needed (see comp_parse.c).  */
end_comment

begin_undef
undef|#
directive|undef
name|CUR
end_undef

begin_define
define|#
directive|define
name|CUR
value|tp->
end_define

begin_comment
comment|/*  * Check if the alternate character-set capabilities are consistent.  */
end_comment

begin_function
specifier|static
name|void
name|check_acs
parameter_list|(
name|TERMTYPE
modifier|*
name|tp
parameter_list|)
block|{
if|if
condition|(
name|VALID_STRING
argument_list|(
name|acs_chars
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|boxes
init|=
literal|"lmkjtuvwqxn"
decl_stmt|;
name|char
name|mapped
index|[
literal|256
index|]
decl_stmt|;
name|char
name|missing
index|[
literal|256
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|q
decl_stmt|;
name|memset
argument_list|(
name|mapped
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|mapped
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|acs_chars
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|+=
literal|2
control|)
block|{
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
name|_nc_warning
argument_list|(
literal|"acsc has odd number of characters"
argument_list|)
expr_stmt|;
break|break;
block|}
name|mapped
index|[
name|UChar
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|)
index|]
operator|=
name|p
index|[
literal|1
index|]
expr_stmt|;
block|}
if|if
condition|(
name|mapped
index|[
name|UChar
argument_list|(
literal|'I'
argument_list|)
index|]
operator|&&
operator|!
name|mapped
index|[
name|UChar
argument_list|(
literal|'i'
argument_list|)
index|]
condition|)
block|{
name|_nc_warning
argument_list|(
literal|"acsc refers to 'I', which is probably an error"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|p
operator|=
name|boxes
operator|,
name|q
operator|=
name|missing
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
operator|++
name|p
control|)
block|{
if|if
condition|(
operator|!
name|mapped
index|[
name|UChar
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|)
index|]
condition|)
block|{
operator|*
name|q
operator|++
operator|=
name|p
index|[
literal|0
index|]
expr_stmt|;
block|}
block|}
operator|*
name|q
operator|=
literal|'\0'
expr_stmt|;
name|assert
argument_list|(
name|strlen
argument_list|(
name|missing
argument_list|)
operator|<=
name|strlen
argument_list|(
name|boxes
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|missing
operator|!=
literal|'\0'
operator|&&
name|strcmp
argument_list|(
name|missing
argument_list|,
name|boxes
argument_list|)
condition|)
block|{
name|_nc_warning
argument_list|(
literal|"acsc is missing some line-drawing mapping: %s"
argument_list|,
name|missing
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Check if the color capabilities are consistent  */
end_comment

begin_function
specifier|static
name|void
name|check_colors
parameter_list|(
name|TERMTYPE
modifier|*
name|tp
parameter_list|)
block|{
if|if
condition|(
operator|(
name|max_colors
operator|>
literal|0
operator|)
operator|!=
operator|(
name|max_pairs
operator|>
literal|0
operator|)
operator|||
operator|(
operator|(
name|max_colors
operator|>
name|max_pairs
operator|)
operator|&&
operator|(
name|initialize_pair
operator|==
literal|0
operator|)
operator|)
condition|)
name|_nc_warning
argument_list|(
literal|"inconsistent values for max_colors (%d) and max_pairs (%d)"
argument_list|,
name|max_colors
argument_list|,
name|max_pairs
argument_list|)
expr_stmt|;
name|PAIRED
argument_list|(
name|set_foreground
argument_list|,
name|set_background
argument_list|)
expr_stmt|;
name|PAIRED
argument_list|(
name|set_a_foreground
argument_list|,
name|set_a_background
argument_list|)
expr_stmt|;
name|PAIRED
argument_list|(
name|set_color_pair
argument_list|,
name|initialize_pair
argument_list|)
expr_stmt|;
if|if
condition|(
name|VALID_STRING
argument_list|(
name|set_foreground
argument_list|)
operator|&&
name|VALID_STRING
argument_list|(
name|set_a_foreground
argument_list|)
operator|&&
operator|!
name|_nc_capcmp
argument_list|(
name|set_foreground
argument_list|,
name|set_a_foreground
argument_list|)
condition|)
name|_nc_warning
argument_list|(
literal|"expected setf/setaf to be different"
argument_list|)
expr_stmt|;
if|if
condition|(
name|VALID_STRING
argument_list|(
name|set_background
argument_list|)
operator|&&
name|VALID_STRING
argument_list|(
name|set_a_background
argument_list|)
operator|&&
operator|!
name|_nc_capcmp
argument_list|(
name|set_background
argument_list|,
name|set_a_background
argument_list|)
condition|)
name|_nc_warning
argument_list|(
literal|"expected setb/setab to be different"
argument_list|)
expr_stmt|;
comment|/* see: has_colors() */
if|if
condition|(
name|VALID_NUMERIC
argument_list|(
name|max_colors
argument_list|)
operator|&&
name|VALID_NUMERIC
argument_list|(
name|max_pairs
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|set_foreground
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|set_background
operator|!=
name|NULL
operator|)
operator|)
operator|||
operator|(
operator|(
name|set_a_foreground
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|set_a_background
operator|!=
name|NULL
operator|)
operator|)
operator|||
name|set_color_pair
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|VALID_STRING
argument_list|(
name|orig_pair
argument_list|)
operator|&&
operator|!
name|VALID_STRING
argument_list|(
name|orig_colors
argument_list|)
condition|)
name|_nc_warning
argument_list|(
literal|"expected either op/oc string for resetting colors"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|char
name|keypad_final
parameter_list|(
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
name|char
name|result
init|=
literal|'\0'
decl_stmt|;
if|if
condition|(
name|VALID_STRING
argument_list|(
name|string
argument_list|)
operator|&&
operator|*
name|string
operator|++
operator|==
literal|'\033'
operator|&&
operator|*
name|string
operator|++
operator|==
literal|'O'
operator|&&
name|strlen
argument_list|(
name|string
argument_list|)
operator|==
literal|1
condition|)
block|{
name|result
operator|=
operator|*
name|string
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|long
name|keypad_index
parameter_list|(
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
name|char
modifier|*
name|test
decl_stmt|;
specifier|const
name|char
modifier|*
name|list
init|=
literal|"PQRSwxymtuvlqrsPpn"
decl_stmt|;
comment|/* app-keypad except "Enter" */
name|int
name|ch
decl_stmt|;
name|long
name|result
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
operator|(
name|ch
operator|=
name|keypad_final
argument_list|(
name|string
argument_list|)
operator|)
operator|!=
literal|'\0'
condition|)
block|{
name|test
operator|=
call|(
name|strchr
call|)
argument_list|(
name|list
argument_list|,
name|ch
argument_list|)
expr_stmt|;
if|if
condition|(
name|test
operator|!=
literal|0
condition|)
name|result
operator|=
call|(
name|long
call|)
argument_list|(
name|test
operator|-
name|list
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/*  * list[] is down, up, left, right  * "left" may be ^H rather than \E[D  * "down" may be ^J rather than \E[B  * But up/right are generally consistently escape sequences for ANSI terminals.  */
end_comment

begin_function
specifier|static
name|void
name|check_ansi_cursor
parameter_list|(
name|char
modifier|*
name|list
index|[
literal|4
index|]
parameter_list|)
block|{
name|int
name|j
decl_stmt|,
name|k
decl_stmt|;
name|int
name|want
decl_stmt|;
name|size_t
name|prefix
init|=
literal|0
decl_stmt|;
name|size_t
name|suffix
decl_stmt|;
name|bool
name|skip
index|[
literal|4
index|]
decl_stmt|;
name|bool
name|repeated
init|=
name|FALSE
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|4
condition|;
operator|++
name|j
control|)
block|{
name|skip
index|[
name|j
index|]
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|j
condition|;
operator|++
name|k
control|)
block|{
if|if
condition|(
name|j
operator|!=
name|k
operator|&&
operator|!
name|strcmp
argument_list|(
name|list
index|[
name|j
index|]
argument_list|,
name|list
index|[
name|k
index|]
argument_list|)
condition|)
block|{
name|char
modifier|*
name|value
init|=
name|_nc_tic_expand
argument_list|(
name|list
index|[
name|k
index|]
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|_nc_warning
argument_list|(
literal|"repeated cursor control %s\n"
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|repeated
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|repeated
condition|)
block|{
name|char
modifier|*
name|up
init|=
name|list
index|[
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|UChar
argument_list|(
name|up
index|[
literal|0
index|]
argument_list|)
operator|==
literal|'\033'
condition|)
block|{
if|if
condition|(
name|up
index|[
literal|1
index|]
operator|==
literal|'['
condition|)
block|{
name|prefix
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|prefix
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|UChar
argument_list|(
name|up
index|[
literal|0
index|]
argument_list|)
operator|==
name|UChar
argument_list|(
literal|'\233'
argument_list|)
condition|)
block|{
name|prefix
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|prefix
condition|)
block|{
name|suffix
operator|=
name|prefix
expr_stmt|;
while|while
condition|(
name|up
index|[
name|suffix
index|]
operator|&&
name|isdigit
argument_list|(
name|UChar
argument_list|(
name|up
index|[
name|suffix
index|]
argument_list|)
argument_list|)
condition|)
operator|++
name|suffix
expr_stmt|;
block|}
if|if
condition|(
name|prefix
operator|&&
name|up
index|[
name|suffix
index|]
operator|==
literal|'A'
condition|)
block|{
name|skip
index|[
literal|1
index|]
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|list
index|[
literal|0
index|]
argument_list|,
literal|"\n"
argument_list|)
condition|)
name|skip
index|[
literal|0
index|]
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|list
index|[
literal|2
index|]
argument_list|,
literal|"\b"
argument_list|)
condition|)
name|skip
index|[
literal|2
index|]
operator|=
name|TRUE
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|4
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
name|skip
index|[
name|j
index|]
operator|||
name|strlen
argument_list|(
name|list
index|[
name|j
index|]
argument_list|)
operator|==
literal|1
condition|)
continue|continue;
if|if
condition|(
name|memcmp
argument_list|(
name|list
index|[
name|j
index|]
argument_list|,
name|up
argument_list|,
name|prefix
argument_list|)
condition|)
block|{
name|char
modifier|*
name|value
init|=
name|_nc_tic_expand
argument_list|(
name|list
index|[
name|j
index|]
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|_nc_warning
argument_list|(
literal|"inconsistent prefix for %s\n"
argument_list|,
name|value
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strlen
argument_list|(
name|list
index|[
name|j
index|]
argument_list|)
operator|<
name|suffix
condition|)
block|{
name|char
modifier|*
name|value
init|=
name|_nc_tic_expand
argument_list|(
name|list
index|[
name|j
index|]
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|_nc_warning
argument_list|(
literal|"inconsistent length for %s, expected %d\n"
argument_list|,
name|value
argument_list|,
operator|(
name|int
operator|)
name|suffix
operator|+
literal|1
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|want
operator|=
literal|"BADC"
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|list
index|[
name|j
index|]
index|[
name|suffix
index|]
operator|!=
name|want
condition|)
block|{
name|char
modifier|*
name|value
init|=
name|_nc_tic_expand
argument_list|(
name|list
index|[
name|j
index|]
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|_nc_warning
argument_list|(
literal|"inconsistent suffix for %s, expected %c, have %c\n"
argument_list|,
name|value
argument_list|,
name|want
argument_list|,
name|list
index|[
name|j
index|]
index|[
name|suffix
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function

begin_define
define|#
directive|define
name|EXPECTED
parameter_list|(
name|name
parameter_list|)
value|if (!PRESENT(name)) _nc_warning("expected " #name)
end_define

begin_define
define|#
directive|define
name|UNEXPECTED
parameter_list|(
name|name
parameter_list|)
value|if (PRESENT(name)) _nc_warning("unexpected " #name ", for %s", why)
end_define

begin_function
specifier|static
name|void
name|check_noaddress
parameter_list|(
name|TERMTYPE
modifier|*
name|tp
parameter_list|,
specifier|const
name|char
modifier|*
name|why
parameter_list|)
block|{
name|UNEXPECTED
argument_list|(
name|column_address
argument_list|)
expr_stmt|;
name|UNEXPECTED
argument_list|(
name|cursor_address
argument_list|)
expr_stmt|;
name|UNEXPECTED
argument_list|(
name|cursor_home
argument_list|)
expr_stmt|;
name|UNEXPECTED
argument_list|(
name|cursor_mem_address
argument_list|)
expr_stmt|;
name|UNEXPECTED
argument_list|(
name|cursor_to_ll
argument_list|)
expr_stmt|;
name|UNEXPECTED
argument_list|(
name|row_address
argument_list|)
expr_stmt|;
name|UNEXPECTED
argument_list|(
name|row_address
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|check_cursor
parameter_list|(
name|TERMTYPE
modifier|*
name|tp
parameter_list|)
block|{
name|int
name|count
decl_stmt|;
name|char
modifier|*
name|list
index|[
literal|4
index|]
decl_stmt|;
if|if
condition|(
name|hard_copy
condition|)
block|{
name|check_noaddress
argument_list|(
name|tp
argument_list|,
literal|"hard_copy"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|generic_type
condition|)
block|{
name|check_noaddress
argument_list|(
name|tp
argument_list|,
literal|"generic_type"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strchr
argument_list|(
name|tp
operator|->
name|term_names
argument_list|,
literal|'+'
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|y
init|=
literal|0
decl_stmt|;
name|int
name|x
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|PRESENT
argument_list|(
name|column_address
argument_list|)
condition|)
operator|++
name|y
expr_stmt|;
if|if
condition|(
name|PRESENT
argument_list|(
name|cursor_address
argument_list|)
condition|)
name|y
operator|=
name|x
operator|=
literal|10
expr_stmt|;
if|if
condition|(
name|PRESENT
argument_list|(
name|cursor_home
argument_list|)
condition|)
operator|++
name|y
operator|,
operator|++
name|x
expr_stmt|;
if|if
condition|(
name|PRESENT
argument_list|(
name|cursor_mem_address
argument_list|)
condition|)
name|y
operator|=
name|x
operator|=
literal|10
expr_stmt|;
if|if
condition|(
name|PRESENT
argument_list|(
name|cursor_to_ll
argument_list|)
condition|)
operator|++
name|y
operator|,
operator|++
name|x
expr_stmt|;
if|if
condition|(
name|PRESENT
argument_list|(
name|row_address
argument_list|)
condition|)
operator|++
name|x
expr_stmt|;
if|if
condition|(
name|PRESENT
argument_list|(
name|cursor_down
argument_list|)
condition|)
operator|++
name|y
expr_stmt|;
if|if
condition|(
name|PRESENT
argument_list|(
name|cursor_up
argument_list|)
condition|)
operator|++
name|y
expr_stmt|;
if|if
condition|(
name|PRESENT
argument_list|(
name|cursor_left
argument_list|)
condition|)
operator|++
name|x
expr_stmt|;
if|if
condition|(
name|PRESENT
argument_list|(
name|cursor_right
argument_list|)
condition|)
operator|++
name|x
expr_stmt|;
if|if
condition|(
name|x
operator|<
literal|2
operator|&&
name|y
operator|<
literal|2
condition|)
block|{
name|_nc_warning
argument_list|(
literal|"terminal lacks cursor addressing"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|x
operator|<
literal|2
condition|)
name|_nc_warning
argument_list|(
literal|"terminal lacks cursor column-addressing"
argument_list|)
expr_stmt|;
if|if
condition|(
name|y
operator|<
literal|2
condition|)
name|_nc_warning
argument_list|(
literal|"terminal lacks cursor row-addressing"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* it is rare to have an insert-line feature without a matching delete */
name|ANDMISSING
argument_list|(
name|parm_insert_line
argument_list|,
name|insert_line
argument_list|)
expr_stmt|;
name|ANDMISSING
argument_list|(
name|parm_delete_line
argument_list|,
name|delete_line
argument_list|)
expr_stmt|;
name|ANDMISSING
argument_list|(
name|parm_insert_line
argument_list|,
name|parm_delete_line
argument_list|)
expr_stmt|;
comment|/* if we have a parameterized form, then the non-parameterized is easy */
name|ANDMISSING
argument_list|(
name|parm_down_cursor
argument_list|,
name|cursor_down
argument_list|)
expr_stmt|;
name|ANDMISSING
argument_list|(
name|parm_up_cursor
argument_list|,
name|cursor_up
argument_list|)
expr_stmt|;
name|ANDMISSING
argument_list|(
name|parm_left_cursor
argument_list|,
name|cursor_left
argument_list|)
expr_stmt|;
name|ANDMISSING
argument_list|(
name|parm_right_cursor
argument_list|,
name|cursor_right
argument_list|)
expr_stmt|;
comment|/* Given any of a set of cursor movement, the whole set should be present.      * Technically this is not true (we could use cursor_address to fill in      * unsupported controls), but it is likely.      */
name|count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|PRESENT
argument_list|(
name|parm_down_cursor
argument_list|)
condition|)
block|{
name|list
index|[
name|count
operator|++
index|]
operator|=
name|parm_down_cursor
expr_stmt|;
block|}
if|if
condition|(
name|PRESENT
argument_list|(
name|parm_up_cursor
argument_list|)
condition|)
block|{
name|list
index|[
name|count
operator|++
index|]
operator|=
name|parm_up_cursor
expr_stmt|;
block|}
if|if
condition|(
name|PRESENT
argument_list|(
name|parm_left_cursor
argument_list|)
condition|)
block|{
name|list
index|[
name|count
operator|++
index|]
operator|=
name|parm_left_cursor
expr_stmt|;
block|}
if|if
condition|(
name|PRESENT
argument_list|(
name|parm_right_cursor
argument_list|)
condition|)
block|{
name|list
index|[
name|count
operator|++
index|]
operator|=
name|parm_right_cursor
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|==
literal|4
condition|)
block|{
name|check_ansi_cursor
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|count
operator|!=
literal|0
condition|)
block|{
name|EXPECTED
argument_list|(
name|parm_down_cursor
argument_list|)
expr_stmt|;
name|EXPECTED
argument_list|(
name|parm_up_cursor
argument_list|)
expr_stmt|;
name|EXPECTED
argument_list|(
name|parm_left_cursor
argument_list|)
expr_stmt|;
name|EXPECTED
argument_list|(
name|parm_right_cursor
argument_list|)
expr_stmt|;
block|}
name|count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|PRESENT
argument_list|(
name|cursor_down
argument_list|)
condition|)
block|{
name|list
index|[
name|count
operator|++
index|]
operator|=
name|cursor_down
expr_stmt|;
block|}
if|if
condition|(
name|PRESENT
argument_list|(
name|cursor_up
argument_list|)
condition|)
block|{
name|list
index|[
name|count
operator|++
index|]
operator|=
name|cursor_up
expr_stmt|;
block|}
if|if
condition|(
name|PRESENT
argument_list|(
name|cursor_left
argument_list|)
condition|)
block|{
name|list
index|[
name|count
operator|++
index|]
operator|=
name|cursor_left
expr_stmt|;
block|}
if|if
condition|(
name|PRESENT
argument_list|(
name|cursor_right
argument_list|)
condition|)
block|{
name|list
index|[
name|count
operator|++
index|]
operator|=
name|cursor_right
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|==
literal|4
condition|)
block|{
name|check_ansi_cursor
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|count
operator|!=
literal|0
condition|)
block|{
name|count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|PRESENT
argument_list|(
name|cursor_down
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|cursor_down
argument_list|,
literal|"\n"
argument_list|)
condition|)
operator|++
name|count
expr_stmt|;
if|if
condition|(
name|PRESENT
argument_list|(
name|cursor_left
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|cursor_left
argument_list|,
literal|"\b"
argument_list|)
condition|)
operator|++
name|count
expr_stmt|;
if|if
condition|(
name|PRESENT
argument_list|(
name|cursor_up
argument_list|)
operator|&&
name|strlen
argument_list|(
name|cursor_up
argument_list|)
operator|>
literal|1
condition|)
operator|++
name|count
expr_stmt|;
if|if
condition|(
name|PRESENT
argument_list|(
name|cursor_right
argument_list|)
operator|&&
name|strlen
argument_list|(
name|cursor_right
argument_list|)
operator|>
literal|1
condition|)
operator|++
name|count
expr_stmt|;
if|if
condition|(
name|count
condition|)
block|{
name|EXPECTED
argument_list|(
name|cursor_down
argument_list|)
expr_stmt|;
name|EXPECTED
argument_list|(
name|cursor_up
argument_list|)
expr_stmt|;
name|EXPECTED
argument_list|(
name|cursor_left
argument_list|)
expr_stmt|;
name|EXPECTED
argument_list|(
name|cursor_right
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_define
define|#
directive|define
name|MAX_KP
value|5
end_define

begin_comment
comment|/*  * Do a quick sanity-check for vt100-style keypads to see if the 5-key keypad  * is mapped inconsistently.  */
end_comment

begin_function
specifier|static
name|void
name|check_keypad
parameter_list|(
name|TERMTYPE
modifier|*
name|tp
parameter_list|)
block|{
name|char
name|show
index|[
literal|80
index|]
decl_stmt|;
if|if
condition|(
name|VALID_STRING
argument_list|(
name|key_a1
argument_list|)
operator|&&
name|VALID_STRING
argument_list|(
name|key_a3
argument_list|)
operator|&&
name|VALID_STRING
argument_list|(
name|key_b2
argument_list|)
operator|&&
name|VALID_STRING
argument_list|(
name|key_c1
argument_list|)
operator|&&
name|VALID_STRING
argument_list|(
name|key_c3
argument_list|)
condition|)
block|{
name|char
name|final
index|[
name|MAX_KP
operator|+
literal|1
index|]
decl_stmt|;
name|long
name|list
index|[
name|MAX_KP
index|]
decl_stmt|;
name|int
name|increase
init|=
literal|0
decl_stmt|;
name|int
name|j
decl_stmt|,
name|k
decl_stmt|,
name|kk
decl_stmt|;
name|long
name|last
decl_stmt|;
name|long
name|test
decl_stmt|;
name|final
index|[
literal|0
index|]
operator|=
name|keypad_final
argument_list|(
name|key_a1
argument_list|)
expr_stmt|;
name|final
index|[
literal|1
index|]
operator|=
name|keypad_final
argument_list|(
name|key_a3
argument_list|)
expr_stmt|;
name|final
index|[
literal|2
index|]
operator|=
name|keypad_final
argument_list|(
name|key_b2
argument_list|)
expr_stmt|;
name|final
index|[
literal|3
index|]
operator|=
name|keypad_final
argument_list|(
name|key_c1
argument_list|)
expr_stmt|;
name|final
index|[
literal|4
index|]
operator|=
name|keypad_final
argument_list|(
name|key_c3
argument_list|)
expr_stmt|;
name|final
index|[
literal|5
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* special case: legacy coding using 1,2,3,0,. on the bottom */
name|assert
argument_list|(
name|strlen
argument_list|(
name|final
argument_list|)
operator|<=
name|MAX_KP
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|final
argument_list|,
literal|"qsrpn"
argument_list|)
condition|)
return|return;
name|list
index|[
literal|0
index|]
operator|=
name|keypad_index
argument_list|(
name|key_a1
argument_list|)
expr_stmt|;
name|list
index|[
literal|1
index|]
operator|=
name|keypad_index
argument_list|(
name|key_a3
argument_list|)
expr_stmt|;
name|list
index|[
literal|2
index|]
operator|=
name|keypad_index
argument_list|(
name|key_b2
argument_list|)
expr_stmt|;
name|list
index|[
literal|3
index|]
operator|=
name|keypad_index
argument_list|(
name|key_c1
argument_list|)
expr_stmt|;
name|list
index|[
literal|4
index|]
operator|=
name|keypad_index
argument_list|(
name|key_c3
argument_list|)
expr_stmt|;
comment|/* check that they're all vt100 keys */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|MAX_KP
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
name|list
index|[
name|j
index|]
operator|<
literal|0
condition|)
block|{
return|return;
block|}
block|}
comment|/* check if they're all in increasing order */
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|MAX_KP
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
name|list
index|[
name|j
index|]
operator|>
name|list
index|[
name|j
operator|-
literal|1
index|]
condition|)
block|{
operator|++
name|increase
expr_stmt|;
block|}
block|}
if|if
condition|(
name|increase
operator|!=
operator|(
name|MAX_KP
operator|-
literal|1
operator|)
condition|)
block|{
name|show
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|last
operator|=
operator|-
literal|1
init|;
name|j
operator|<
name|MAX_KP
condition|;
operator|++
name|j
control|)
block|{
for|for
control|(
name|k
operator|=
literal|0
operator|,
name|kk
operator|=
operator|-
literal|1
operator|,
name|test
operator|=
literal|100
init|;
name|k
operator|<
literal|5
condition|;
operator|++
name|k
control|)
block|{
if|if
condition|(
name|list
index|[
name|k
index|]
operator|>
name|last
operator|&&
name|list
index|[
name|k
index|]
operator|<
name|test
condition|)
block|{
name|test
operator|=
name|list
index|[
name|k
index|]
expr_stmt|;
name|kk
operator|=
name|k
expr_stmt|;
block|}
block|}
name|last
operator|=
name|test
expr_stmt|;
name|assert
argument_list|(
name|strlen
argument_list|(
name|show
argument_list|)
operator|<
operator|(
name|MAX_KP
operator|*
literal|4
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|kk
condition|)
block|{
case|case
literal|0
case|:
name|_nc_STRCAT
argument_list|(
name|show
argument_list|,
literal|" ka1"
argument_list|,
sizeof|sizeof
argument_list|(
name|show
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|_nc_STRCAT
argument_list|(
name|show
argument_list|,
literal|" ka3"
argument_list|,
sizeof|sizeof
argument_list|(
name|show
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|_nc_STRCAT
argument_list|(
name|show
argument_list|,
literal|" kb2"
argument_list|,
sizeof|sizeof
argument_list|(
name|show
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|_nc_STRCAT
argument_list|(
name|show
argument_list|,
literal|" kc1"
argument_list|,
sizeof|sizeof
argument_list|(
name|show
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|_nc_STRCAT
argument_list|(
name|show
argument_list|,
literal|" kc3"
argument_list|,
sizeof|sizeof
argument_list|(
name|show
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|_nc_warning
argument_list|(
literal|"vt100 keypad order inconsistent: %s"
argument_list|,
name|show
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|VALID_STRING
argument_list|(
name|key_a1
argument_list|)
operator|||
name|VALID_STRING
argument_list|(
name|key_a3
argument_list|)
operator|||
name|VALID_STRING
argument_list|(
name|key_b2
argument_list|)
operator|||
name|VALID_STRING
argument_list|(
name|key_c1
argument_list|)
operator|||
name|VALID_STRING
argument_list|(
name|key_c3
argument_list|)
condition|)
block|{
name|show
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|keypad_index
argument_list|(
name|key_a1
argument_list|)
operator|>=
literal|0
condition|)
name|_nc_STRCAT
argument_list|(
name|show
argument_list|,
literal|" ka1"
argument_list|,
sizeof|sizeof
argument_list|(
name|show
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|keypad_index
argument_list|(
name|key_a3
argument_list|)
operator|>=
literal|0
condition|)
name|_nc_STRCAT
argument_list|(
name|show
argument_list|,
literal|" ka3"
argument_list|,
sizeof|sizeof
argument_list|(
name|show
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|keypad_index
argument_list|(
name|key_b2
argument_list|)
operator|>=
literal|0
condition|)
name|_nc_STRCAT
argument_list|(
name|show
argument_list|,
literal|" kb2"
argument_list|,
sizeof|sizeof
argument_list|(
name|show
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|keypad_index
argument_list|(
name|key_c1
argument_list|)
operator|>=
literal|0
condition|)
name|_nc_STRCAT
argument_list|(
name|show
argument_list|,
literal|" kc1"
argument_list|,
sizeof|sizeof
argument_list|(
name|show
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|keypad_index
argument_list|(
name|key_c3
argument_list|)
operator|>=
literal|0
condition|)
name|_nc_STRCAT
argument_list|(
name|show
argument_list|,
literal|" kc3"
argument_list|,
sizeof|sizeof
argument_list|(
name|show
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|show
operator|!=
literal|'\0'
condition|)
name|_nc_warning
argument_list|(
literal|"vt100 keypad map incomplete:%s"
argument_list|,
name|show
argument_list|)
expr_stmt|;
block|}
comment|/*      * These warnings are useful for consistency checks - it is possible that      * there are real terminals with mismatches in these      */
name|ANDMISSING
argument_list|(
name|key_ic
argument_list|,
name|key_dc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|check_printer
parameter_list|(
name|TERMTYPE
modifier|*
name|tp
parameter_list|)
block|{
name|PAIRED
argument_list|(
name|enter_doublewide_mode
argument_list|,
name|exit_doublewide_mode
argument_list|)
expr_stmt|;
name|PAIRED
argument_list|(
name|enter_italics_mode
argument_list|,
name|exit_italics_mode
argument_list|)
expr_stmt|;
name|PAIRED
argument_list|(
name|enter_leftward_mode
argument_list|,
name|exit_leftward_mode
argument_list|)
expr_stmt|;
name|PAIRED
argument_list|(
name|enter_micro_mode
argument_list|,
name|exit_micro_mode
argument_list|)
expr_stmt|;
name|PAIRED
argument_list|(
name|enter_shadow_mode
argument_list|,
name|exit_shadow_mode
argument_list|)
expr_stmt|;
name|PAIRED
argument_list|(
name|enter_subscript_mode
argument_list|,
name|exit_subscript_mode
argument_list|)
expr_stmt|;
name|PAIRED
argument_list|(
name|enter_superscript_mode
argument_list|,
name|exit_superscript_mode
argument_list|)
expr_stmt|;
name|PAIRED
argument_list|(
name|enter_upward_mode
argument_list|,
name|exit_upward_mode
argument_list|)
expr_stmt|;
name|ANDMISSING
argument_list|(
name|start_char_set_def
argument_list|,
name|stop_char_set_def
argument_list|)
expr_stmt|;
comment|/* if we have a parameterized form, then the non-parameterized is easy */
name|ANDMISSING
argument_list|(
name|set_bottom_margin_parm
argument_list|,
name|set_bottom_margin
argument_list|)
expr_stmt|;
name|ANDMISSING
argument_list|(
name|set_left_margin_parm
argument_list|,
name|set_left_margin
argument_list|)
expr_stmt|;
name|ANDMISSING
argument_list|(
name|set_right_margin_parm
argument_list|,
name|set_right_margin
argument_list|)
expr_stmt|;
name|ANDMISSING
argument_list|(
name|set_top_margin_parm
argument_list|,
name|set_top_margin
argument_list|)
expr_stmt|;
name|ANDMISSING
argument_list|(
name|parm_down_micro
argument_list|,
name|micro_down
argument_list|)
expr_stmt|;
name|ANDMISSING
argument_list|(
name|parm_left_micro
argument_list|,
name|micro_left
argument_list|)
expr_stmt|;
name|ANDMISSING
argument_list|(
name|parm_right_micro
argument_list|,
name|micro_right
argument_list|)
expr_stmt|;
name|ANDMISSING
argument_list|(
name|parm_up_micro
argument_list|,
name|micro_up
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bool
name|uses_SGR_39_49
parameter_list|(
specifier|const
name|char
modifier|*
name|value
parameter_list|)
block|{
return|return
operator|(
name|strstr
argument_list|(
name|value
argument_list|,
literal|"39;49"
argument_list|)
operator|!=
literal|0
operator|||
name|strstr
argument_list|(
name|value
argument_list|,
literal|"49;39"
argument_list|)
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check consistency of termcap extensions related to "screen".  */
end_comment

begin_function
specifier|static
name|void
name|check_screen
parameter_list|(
name|TERMTYPE
modifier|*
name|tp
parameter_list|)
block|{
if|#
directive|if
name|NCURSES_XNAMES
if|if
condition|(
name|_nc_user_definable
condition|)
block|{
name|int
name|have_XT
init|=
name|tigetflag
argument_list|(
literal|"XT"
argument_list|)
decl_stmt|;
name|int
name|have_XM
init|=
name|tigetflag
argument_list|(
literal|"XM"
argument_list|)
decl_stmt|;
name|int
name|have_bce
init|=
name|back_color_erase
decl_stmt|;
name|bool
name|have_kmouse
init|=
name|FALSE
decl_stmt|;
name|bool
name|use_sgr_39_49
init|=
name|FALSE
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|_nc_first_name
argument_list|(
name|tp
operator|->
name|term_names
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|VALID_BOOLEAN
argument_list|(
name|have_bce
argument_list|)
condition|)
block|{
name|have_bce
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|VALID_BOOLEAN
argument_list|(
name|have_XM
argument_list|)
condition|)
block|{
name|have_XM
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|VALID_BOOLEAN
argument_list|(
name|have_XT
argument_list|)
condition|)
block|{
name|have_XT
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|VALID_STRING
argument_list|(
name|key_mouse
argument_list|)
condition|)
block|{
name|have_kmouse
operator|=
operator|!
name|strcmp
argument_list|(
literal|"\033[M"
argument_list|,
name|key_mouse
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|VALID_STRING
argument_list|(
name|orig_colors
argument_list|)
condition|)
block|{
name|use_sgr_39_49
operator|=
name|uses_SGR_39_49
argument_list|(
name|orig_colors
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|VALID_STRING
argument_list|(
name|orig_pair
argument_list|)
condition|)
block|{
name|use_sgr_39_49
operator|=
name|uses_SGR_39_49
argument_list|(
name|orig_pair
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|have_XM
operator|&&
name|have_XT
condition|)
block|{
name|_nc_warning
argument_list|(
literal|"Screen's XT capability conflicts with XM"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|have_XT
operator|&&
name|strstr
argument_list|(
name|name
argument_list|,
literal|"screen"
argument_list|)
operator|!=
literal|0
operator|&&
name|strchr
argument_list|(
name|name
argument_list|,
literal|'.'
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|_nc_warning
argument_list|(
literal|"Screen's \"screen\" entries should not have XT set"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|have_XT
condition|)
block|{
if|if
condition|(
operator|!
name|have_kmouse
operator|&&
name|have_bce
condition|)
block|{
if|if
condition|(
name|VALID_STRING
argument_list|(
name|key_mouse
argument_list|)
condition|)
block|{
name|_nc_warning
argument_list|(
literal|"Value of kmous inconsistent with screen's usage"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|_nc_warning
argument_list|(
literal|"Expected kmous capability with XT"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|have_bce
operator|&&
name|max_colors
operator|>
literal|0
condition|)
name|_nc_warning
argument_list|(
literal|"Expected bce capability with XT"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|use_sgr_39_49
operator|&&
name|have_bce
operator|&&
name|max_colors
operator|>
literal|0
condition|)
name|_nc_warning
argument_list|(
literal|"Expected orig_colors capability with XT to have 39/49 parameters"
argument_list|)
expr_stmt|;
if|if
condition|(
name|VALID_STRING
argument_list|(
name|to_status_line
argument_list|)
condition|)
name|_nc_warning
argument_list|(
literal|"\"tsl\" capability is redundant, given XT"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|have_kmouse
operator|&&
operator|!
name|have_XM
condition|)
name|_nc_warning
argument_list|(
literal|"Expected XT to be set, given kmous"
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Returns the expected number of parameters for the given capability.  */
end_comment

begin_function
specifier|static
name|int
name|expected_params
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
comment|/* *INDENT-OFF* */
specifier|static
specifier|const
struct|struct
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|count
decl_stmt|;
block|}
name|table
index|[]
init|=
block|{
block|{
literal|"S0"
block|,
literal|1
block|}
block|,
comment|/* 'screen' extension */
block|{
literal|"birep"
block|,
literal|2
block|}
block|,
block|{
literal|"chr"
block|,
literal|1
block|}
block|,
block|{
literal|"colornm"
block|,
literal|1
block|}
block|,
block|{
literal|"cpi"
block|,
literal|1
block|}
block|,
block|{
literal|"csnm"
block|,
literal|1
block|}
block|,
block|{
literal|"csr"
block|,
literal|2
block|}
block|,
block|{
literal|"cub"
block|,
literal|1
block|}
block|,
block|{
literal|"cud"
block|,
literal|1
block|}
block|,
block|{
literal|"cuf"
block|,
literal|1
block|}
block|,
block|{
literal|"cup"
block|,
literal|2
block|}
block|,
block|{
literal|"cuu"
block|,
literal|1
block|}
block|,
block|{
literal|"cvr"
block|,
literal|1
block|}
block|,
block|{
literal|"cwin"
block|,
literal|5
block|}
block|,
block|{
literal|"dch"
block|,
literal|1
block|}
block|,
block|{
literal|"defc"
block|,
literal|3
block|}
block|,
block|{
literal|"dial"
block|,
literal|1
block|}
block|,
block|{
literal|"dispc"
block|,
literal|1
block|}
block|,
block|{
literal|"dl"
block|,
literal|1
block|}
block|,
block|{
literal|"ech"
block|,
literal|1
block|}
block|,
block|{
literal|"getm"
block|,
literal|1
block|}
block|,
block|{
literal|"hpa"
block|,
literal|1
block|}
block|,
block|{
literal|"ich"
block|,
literal|1
block|}
block|,
block|{
literal|"il"
block|,
literal|1
block|}
block|,
block|{
literal|"indn"
block|,
literal|1
block|}
block|,
block|{
literal|"initc"
block|,
literal|4
block|}
block|,
block|{
literal|"initp"
block|,
literal|7
block|}
block|,
block|{
literal|"lpi"
block|,
literal|1
block|}
block|,
block|{
literal|"mc5p"
block|,
literal|1
block|}
block|,
block|{
literal|"mrcup"
block|,
literal|2
block|}
block|,
block|{
literal|"mvpa"
block|,
literal|1
block|}
block|,
block|{
literal|"pfkey"
block|,
literal|2
block|}
block|,
block|{
literal|"pfloc"
block|,
literal|2
block|}
block|,
block|{
literal|"pfx"
block|,
literal|2
block|}
block|,
block|{
literal|"pfxl"
block|,
literal|3
block|}
block|,
block|{
literal|"pln"
block|,
literal|2
block|}
block|,
block|{
literal|"qdial"
block|,
literal|1
block|}
block|,
block|{
literal|"rcsd"
block|,
literal|1
block|}
block|,
block|{
literal|"rep"
block|,
literal|2
block|}
block|,
block|{
literal|"rin"
block|,
literal|1
block|}
block|,
block|{
literal|"sclk"
block|,
literal|3
block|}
block|,
block|{
literal|"scp"
block|,
literal|1
block|}
block|,
block|{
literal|"scs"
block|,
literal|1
block|}
block|,
block|{
literal|"scsd"
block|,
literal|2
block|}
block|,
block|{
literal|"setab"
block|,
literal|1
block|}
block|,
block|{
literal|"setaf"
block|,
literal|1
block|}
block|,
block|{
literal|"setb"
block|,
literal|1
block|}
block|,
block|{
literal|"setcolor"
block|,
literal|1
block|}
block|,
block|{
literal|"setf"
block|,
literal|1
block|}
block|,
block|{
literal|"sgr"
block|,
literal|9
block|}
block|,
block|{
literal|"sgr1"
block|,
literal|6
block|}
block|,
block|{
literal|"slength"
block|,
literal|1
block|}
block|,
block|{
literal|"slines"
block|,
literal|1
block|}
block|,
block|{
literal|"smgbp"
block|,
literal|1
block|}
block|,
comment|/* 2 if smgtp is not given */
block|{
literal|"smglp"
block|,
literal|1
block|}
block|,
block|{
literal|"smglr"
block|,
literal|2
block|}
block|,
block|{
literal|"smgrp"
block|,
literal|1
block|}
block|,
block|{
literal|"smgtb"
block|,
literal|2
block|}
block|,
block|{
literal|"smgtp"
block|,
literal|1
block|}
block|,
block|{
literal|"tsl"
block|,
literal|1
block|}
block|,
block|{
literal|"u6"
block|,
operator|-
literal|1
block|}
block|,
block|{
literal|"vpa"
block|,
literal|1
block|}
block|,
block|{
literal|"wind"
block|,
literal|4
block|}
block|,
block|{
literal|"wingo"
block|,
literal|1
block|}
block|,     }
struct|;
comment|/* *INDENT-ON* */
name|unsigned
name|n
decl_stmt|;
name|int
name|result
init|=
literal|0
decl_stmt|;
comment|/* function-keys, etc., use none */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|SIZEOF
argument_list|(
name|table
argument_list|)
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
name|table
index|[
name|n
index|]
operator|.
name|name
argument_list|)
condition|)
block|{
name|result
operator|=
name|table
index|[
name|n
index|]
operator|.
name|count
expr_stmt|;
break|break;
block|}
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/*  * Make a quick sanity check for the parameters which are used in the given  * strings.  If there are no "%p" tokens, then there should be no other "%"  * markers.  */
end_comment

begin_function
specifier|static
name|void
name|check_params
parameter_list|(
name|TERMTYPE
modifier|*
name|tp
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|char
modifier|*
name|value
parameter_list|)
block|{
name|int
name|expected
init|=
name|expected_params
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|int
name|actual
init|=
literal|0
decl_stmt|;
name|int
name|n
decl_stmt|;
name|bool
name|params
index|[
literal|10
index|]
decl_stmt|;
name|char
modifier|*
name|s
init|=
name|value
decl_stmt|;
ifdef|#
directive|ifdef
name|set_top_margin_parm
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"smgbp"
argument_list|)
operator|&&
name|set_top_margin_parm
operator|==
literal|0
condition|)
name|expected
operator|=
literal|2
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
literal|10
condition|;
name|n
operator|++
control|)
name|params
index|[
name|n
index|]
operator|=
name|FALSE
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'%'
condition|)
block|{
if|if
condition|(
operator|*
operator|++
name|s
operator|==
literal|'\0'
condition|)
block|{
name|_nc_warning
argument_list|(
literal|"expected character after %% in %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'p'
condition|)
block|{
if|if
condition|(
operator|*
operator|++
name|s
operator|==
literal|'\0'
operator|||
operator|!
name|isdigit
argument_list|(
operator|(
name|int
operator|)
operator|*
name|s
argument_list|)
condition|)
block|{
name|_nc_warning
argument_list|(
literal|"expected digit after %%p in %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|n
operator|=
operator|(
operator|*
name|s
operator|-
literal|'0'
operator|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|actual
condition|)
name|actual
operator|=
name|n
expr_stmt|;
name|params
index|[
name|n
index|]
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
block|}
name|s
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|params
index|[
literal|0
index|]
condition|)
block|{
name|_nc_warning
argument_list|(
literal|"%s refers to parameter 0 (%%p0), which is not allowed"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|value
operator|==
name|set_attributes
operator|||
name|expected
operator|<
literal|0
condition|)
block|{
empty_stmt|;
block|}
elseif|else
if|if
condition|(
name|expected
operator|!=
name|actual
condition|)
block|{
name|_nc_warning
argument_list|(
literal|"%s uses %d parameters, expected %d"
argument_list|,
name|name
argument_list|,
name|actual
argument_list|,
name|expected
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|1
init|;
name|n
operator|<
name|actual
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|params
index|[
name|n
index|]
condition|)
name|_nc_warning
argument_list|(
literal|"%s omits parameter %d"
argument_list|,
name|name
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|skip_delay
parameter_list|(
name|char
modifier|*
name|s
parameter_list|)
block|{
while|while
condition|(
operator|*
name|s
operator|==
literal|'/'
operator|||
name|isdigit
argument_list|(
name|UChar
argument_list|(
operator|*
name|s
argument_list|)
argument_list|)
condition|)
operator|++
name|s
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/*  * Skip a delay altogether, e.g., when comparing a simple string to sgr,  * the latter may have a worst-case delay on the end.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|ignore_delays
parameter_list|(
name|char
modifier|*
name|s
parameter_list|)
block|{
name|int
name|delaying
init|=
literal|0
decl_stmt|;
do|do
block|{
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|'$'
case|:
if|if
condition|(
name|delaying
operator|==
literal|0
condition|)
name|delaying
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'<'
case|:
if|if
condition|(
name|delaying
operator|==
literal|1
condition|)
name|delaying
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'\0'
case|:
name|delaying
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|delaying
condition|)
block|{
name|s
operator|=
name|skip_delay
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'>'
condition|)
operator|++
name|s
expr_stmt|;
name|delaying
operator|=
literal|0
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|delaying
condition|)
operator|++
name|s
expr_stmt|;
block|}
do|while
condition|(
name|delaying
condition|)
do|;
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/*  * An sgr string may contain several settings other than the one we're  * interested in, essentially sgr0 + rmacs + whatever.  As long as the  * "whatever" is contained in the sgr string, that is close enough for our  * sanity check.  */
end_comment

begin_function
specifier|static
name|bool
name|similar_sgr
parameter_list|(
name|int
name|num
parameter_list|,
name|char
modifier|*
name|a
parameter_list|,
name|char
modifier|*
name|b
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|names
index|[]
init|=
block|{
literal|"none"
block|,
literal|"standout"
block|,
literal|"underline"
block|,
literal|"reverse"
block|,
literal|"blink"
block|,
literal|"dim"
block|,
literal|"bold"
block|,
literal|"invis"
block|,
literal|"protect"
block|,
literal|"altcharset"
block|}
decl_stmt|;
name|char
modifier|*
name|base_a
init|=
name|a
decl_stmt|;
name|char
modifier|*
name|base_b
init|=
name|b
decl_stmt|;
name|int
name|delaying
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|b
operator|!=
literal|0
condition|)
block|{
while|while
condition|(
operator|*
name|a
operator|!=
operator|*
name|b
condition|)
block|{
if|if
condition|(
operator|*
name|a
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|b
index|[
literal|0
index|]
operator|==
literal|'$'
operator|&&
name|b
index|[
literal|1
index|]
operator|==
literal|'<'
condition|)
block|{
name|_nc_warning
argument_list|(
literal|"Did not find delay %s"
argument_list|,
name|_nc_visbuf
argument_list|(
name|b
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|_nc_warning
argument_list|(
literal|"checking sgr(%s) %s\n\tcompare to %s\n\tunmatched %s"
argument_list|,
name|names
index|[
name|num
index|]
argument_list|,
name|_nc_visbuf2
argument_list|(
literal|1
argument_list|,
name|base_a
argument_list|)
argument_list|,
name|_nc_visbuf2
argument_list|(
literal|2
argument_list|,
name|base_b
argument_list|)
argument_list|,
name|_nc_visbuf2
argument_list|(
literal|3
argument_list|,
name|b
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|FALSE
return|;
block|}
elseif|else
if|if
condition|(
name|delaying
condition|)
block|{
name|a
operator|=
name|skip_delay
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|b
operator|=
name|skip_delay
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|b
operator|==
literal|'0'
operator|||
operator|(
operator|*
name|b
operator|==
literal|';'
operator|)
operator|)
operator|&&
operator|*
name|a
operator|==
literal|'m'
condition|)
block|{
name|b
operator|++
expr_stmt|;
block|}
else|else
block|{
name|a
operator|++
expr_stmt|;
block|}
block|}
switch|switch
condition|(
operator|*
name|a
condition|)
block|{
case|case
literal|'$'
case|:
if|if
condition|(
name|delaying
operator|==
literal|0
condition|)
name|delaying
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'<'
case|:
if|if
condition|(
name|delaying
operator|==
literal|1
condition|)
name|delaying
operator|=
literal|2
expr_stmt|;
break|break;
default|default:
name|delaying
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|a
operator|++
expr_stmt|;
name|b
operator|++
expr_stmt|;
block|}
comment|/* ignore delays on the end of the string */
name|a
operator|=
name|ignore_delays
argument_list|(
name|a
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|num
operator|!=
literal|0
operator|)
operator|||
operator|(
operator|*
name|a
operator|==
literal|0
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|check_sgr
parameter_list|(
name|TERMTYPE
modifier|*
name|tp
parameter_list|,
name|char
modifier|*
name|zero
parameter_list|,
name|int
name|num
parameter_list|,
name|char
modifier|*
name|cap
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|char
modifier|*
name|test
decl_stmt|;
name|_nc_tparm_err
operator|=
literal|0
expr_stmt|;
name|test
operator|=
name|TPARM_9
argument_list|(
name|set_attributes
argument_list|,
name|num
operator|==
literal|1
argument_list|,
name|num
operator|==
literal|2
argument_list|,
name|num
operator|==
literal|3
argument_list|,
name|num
operator|==
literal|4
argument_list|,
name|num
operator|==
literal|5
argument_list|,
name|num
operator|==
literal|6
argument_list|,
name|num
operator|==
literal|7
argument_list|,
name|num
operator|==
literal|8
argument_list|,
name|num
operator|==
literal|9
argument_list|)
expr_stmt|;
if|if
condition|(
name|test
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|PRESENT
argument_list|(
name|cap
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|similar_sgr
argument_list|(
name|num
argument_list|,
name|test
argument_list|,
name|cap
argument_list|)
condition|)
block|{
name|_nc_warning
argument_list|(
literal|"%s differs from sgr(%d)\n\t%s=%s\n\tsgr(%d)=%s"
argument_list|,
name|name
argument_list|,
name|num
argument_list|,
name|name
argument_list|,
name|_nc_visbuf2
argument_list|(
literal|1
argument_list|,
name|cap
argument_list|)
argument_list|,
name|num
argument_list|,
name|_nc_visbuf2
argument_list|(
literal|2
argument_list|,
name|test
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|_nc_capcmp
argument_list|(
name|test
argument_list|,
name|zero
argument_list|)
condition|)
block|{
name|_nc_warning
argument_list|(
literal|"sgr(%d) present, but not %s"
argument_list|,
name|num
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|PRESENT
argument_list|(
name|cap
argument_list|)
condition|)
block|{
name|_nc_warning
argument_list|(
literal|"sgr(%d) missing, but %s present"
argument_list|,
name|num
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|_nc_tparm_err
condition|)
name|_nc_warning
argument_list|(
literal|"stack error in sgr(%d) string"
argument_list|,
name|num
argument_list|)
expr_stmt|;
return|return
name|test
return|;
block|}
end_function

begin_define
define|#
directive|define
name|CHECK_SGR
parameter_list|(
name|num
parameter_list|,
name|name
parameter_list|)
value|check_sgr(tp, zero, num, name, #name)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|TRACE
end_ifdef

begin_comment
comment|/*  * If tic is compiled with TRACE, we'll be able to see the output from the  * DEBUG() macro.  But since it doesn't use traceon(), it always goes to  * the standard error.  Use this function to make it simpler to follow the  * resulting debug traces.  */
end_comment

begin_function
specifier|static
name|void
name|show_where
parameter_list|(
name|unsigned
name|level
parameter_list|)
block|{
if|if
condition|(
name|_nc_tracing
operator|>=
name|DEBUG_LEVEL
argument_list|(
name|level
argument_list|)
condition|)
block|{
name|char
name|my_name
index|[
name|MAX_NAME_SIZE
index|]
decl_stmt|;
name|_nc_get_type
argument_list|(
name|my_name
argument_list|)
expr_stmt|;
name|_tracef
argument_list|(
literal|"\"%s\", line %d, '%s'"
argument_list|,
name|_nc_get_source
argument_list|()
argument_list|,
name|_nc_curr_line
argument_list|,
name|my_name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|show_where
parameter_list|(
name|level
parameter_list|)
end_define

begin_comment
comment|/* nothing */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_typedef
typedef|typedef
struct|struct
block|{
name|int
name|keycode
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
name|value
decl_stmt|;
block|}
name|NAME_VALUE
typedef|;
end_typedef

begin_function
specifier|static
name|NAME_VALUE
modifier|*
name|get_fkey_list
parameter_list|(
name|TERMTYPE
modifier|*
name|tp
parameter_list|)
block|{
name|NAME_VALUE
modifier|*
name|result
init|=
name|typeMalloc
argument_list|(
name|NAME_VALUE
argument_list|,
name|NUM_STRINGS
argument_list|(
name|tp
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
specifier|const
name|struct
name|tinfo_fkeys
modifier|*
name|all_fkeys
init|=
name|_nc_tinfo_fkeys
decl_stmt|;
name|int
name|used
init|=
literal|0
decl_stmt|;
name|int
name|j
decl_stmt|;
if|if
condition|(
name|result
operator|==
literal|0
condition|)
name|failed
argument_list|(
literal|"get_fkey_list"
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|all_fkeys
index|[
name|j
index|]
operator|.
name|code
condition|;
name|j
operator|++
control|)
block|{
name|char
modifier|*
name|a
init|=
name|tp
operator|->
name|Strings
index|[
name|all_fkeys
index|[
name|j
index|]
operator|.
name|offset
index|]
decl_stmt|;
if|if
condition|(
name|VALID_STRING
argument_list|(
name|a
argument_list|)
condition|)
block|{
name|result
index|[
name|used
index|]
operator|.
name|keycode
operator|=
operator|(
name|int
operator|)
name|all_fkeys
index|[
name|j
index|]
operator|.
name|code
expr_stmt|;
name|result
index|[
name|used
index|]
operator|.
name|name
operator|=
name|strnames
index|[
name|all_fkeys
index|[
name|j
index|]
operator|.
name|offset
index|]
expr_stmt|;
name|result
index|[
name|used
index|]
operator|.
name|value
operator|=
name|a
expr_stmt|;
operator|++
name|used
expr_stmt|;
block|}
block|}
if|#
directive|if
name|NCURSES_XNAMES
for|for
control|(
name|j
operator|=
name|STRCOUNT
init|;
name|j
operator|<
name|NUM_STRINGS
argument_list|(
name|tp
argument_list|)
condition|;
operator|++
name|j
control|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|ExtStrname
argument_list|(
name|tp
argument_list|,
name|j
argument_list|,
name|strnames
argument_list|)
decl_stmt|;
if|if
condition|(
operator|*
name|name
operator|==
literal|'k'
condition|)
block|{
name|result
index|[
name|used
index|]
operator|.
name|keycode
operator|=
operator|-
literal|1
expr_stmt|;
name|result
index|[
name|used
index|]
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|result
index|[
name|used
index|]
operator|.
name|value
operator|=
name|tp
operator|->
name|Strings
index|[
name|j
index|]
expr_stmt|;
operator|++
name|used
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|result
index|[
name|used
index|]
operator|.
name|keycode
operator|=
literal|0
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|show_fkey_name
parameter_list|(
name|NAME_VALUE
modifier|*
name|data
parameter_list|)
block|{
if|if
condition|(
name|data
operator|->
name|keycode
operator|>
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %s"
argument_list|,
name|keyname
argument_list|(
name|data
operator|->
name|keycode
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" (capability \"%s\")"
argument_list|,
name|data
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" capability \"%s\""
argument_list|,
name|data
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* other sanity-checks (things that we don't want in the normal  * logic that reads a terminfo entry)  */
end_comment

begin_function
specifier|static
name|void
name|check_termtype
parameter_list|(
name|TERMTYPE
modifier|*
name|tp
parameter_list|,
name|bool
name|literal
parameter_list|)
block|{
name|bool
name|conflict
init|=
name|FALSE
decl_stmt|;
name|unsigned
name|j
decl_stmt|,
name|k
decl_stmt|;
comment|/*      * A terminal entry may contain more than one keycode assigned to      * a given string (e.g., KEY_END and KEY_LL).  But curses will only      * return one (the last one assigned).      */
if|if
condition|(
operator|!
operator|(
name|_nc_syntax
operator|==
name|SYN_TERMCAP
operator|&&
name|capdump
operator|)
condition|)
block|{
name|char
modifier|*
name|check
init|=
name|calloc
argument_list|(
call|(
name|size_t
call|)
argument_list|(
name|NUM_STRINGS
argument_list|(
name|tp
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
decl_stmt|;
name|NAME_VALUE
modifier|*
name|given
init|=
name|get_fkey_list
argument_list|(
name|tp
argument_list|)
decl_stmt|;
if|if
condition|(
name|check
operator|==
literal|0
condition|)
name|failed
argument_list|(
literal|"check_termtype"
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|given
index|[
name|j
index|]
operator|.
name|keycode
condition|;
operator|++
name|j
control|)
block|{
specifier|const
name|char
modifier|*
name|a
init|=
name|given
index|[
name|j
index|]
operator|.
name|value
decl_stmt|;
name|bool
name|first
init|=
name|TRUE
decl_stmt|;
for|for
control|(
name|k
operator|=
name|j
operator|+
literal|1
init|;
name|given
index|[
name|k
index|]
operator|.
name|keycode
condition|;
name|k
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|b
init|=
name|given
index|[
name|k
index|]
operator|.
name|value
decl_stmt|;
if|if
condition|(
name|check
index|[
name|k
index|]
condition|)
continue|continue;
if|if
condition|(
operator|!
name|_nc_capcmp
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
condition|)
block|{
name|check
index|[
name|j
index|]
operator|=
literal|1
expr_stmt|;
name|check
index|[
name|k
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|first
condition|)
block|{
if|if
condition|(
operator|!
name|conflict
condition|)
block|{
name|_nc_warning
argument_list|(
literal|"Conflicting key definitions (using the last)"
argument_list|)
expr_stmt|;
name|conflict
operator|=
name|TRUE
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"..."
argument_list|)
expr_stmt|;
name|show_fkey_name
argument_list|(
name|given
operator|+
name|j
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" is the same as"
argument_list|)
expr_stmt|;
name|show_fkey_name
argument_list|(
name|given
operator|+
name|k
argument_list|)
expr_stmt|;
name|first
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|show_fkey_name
argument_list|(
name|given
operator|+
name|k
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|first
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|given
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|check
argument_list|)
expr_stmt|;
block|}
name|for_each_string
argument_list|(
argument|j
argument_list|,
argument|tp
argument_list|)
block|{
name|char
modifier|*
name|a
init|=
name|tp
operator|->
name|Strings
index|[
name|j
index|]
decl_stmt|;
if|if
condition|(
name|VALID_STRING
argument_list|(
name|a
argument_list|)
condition|)
name|check_params
argument_list|(
name|tp
argument_list|,
name|ExtStrname
argument_list|(
name|tp
argument_list|,
operator|(
name|int
operator|)
name|j
argument_list|,
name|strnames
argument_list|)
argument_list|,
name|a
argument_list|)
expr_stmt|;
block|}
name|check_acs
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|check_colors
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|check_cursor
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|check_keypad
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|check_printer
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|check_screen
argument_list|(
name|tp
argument_list|)
expr_stmt|;
comment|/*      * These may be mismatched because the terminal description relies on      * restoring the cursor visibility by resetting it.      */
name|ANDMISSING
argument_list|(
name|cursor_invisible
argument_list|,
name|cursor_normal
argument_list|)
expr_stmt|;
name|ANDMISSING
argument_list|(
name|cursor_visible
argument_list|,
name|cursor_normal
argument_list|)
expr_stmt|;
if|if
condition|(
name|PRESENT
argument_list|(
name|cursor_visible
argument_list|)
operator|&&
name|PRESENT
argument_list|(
name|cursor_normal
argument_list|)
operator|&&
operator|!
name|_nc_capcmp
argument_list|(
name|cursor_visible
argument_list|,
name|cursor_normal
argument_list|)
condition|)
name|_nc_warning
argument_list|(
literal|"cursor_visible is same as cursor_normal"
argument_list|)
expr_stmt|;
comment|/*      * From XSI& O'Reilly, we gather that sc/rc are required if csr is      * given, because the cursor position after the scrolling operation is      * performed is undefined.      */
name|ANDMISSING
argument_list|(
name|change_scroll_region
argument_list|,
name|save_cursor
argument_list|)
expr_stmt|;
name|ANDMISSING
argument_list|(
name|change_scroll_region
argument_list|,
name|restore_cursor
argument_list|)
expr_stmt|;
comment|/*      * If we can clear tabs, we should be able to initialize them.      */
name|ANDMISSING
argument_list|(
name|clear_all_tabs
argument_list|,
name|set_tab
argument_list|)
expr_stmt|;
if|if
condition|(
name|PRESENT
argument_list|(
name|set_attributes
argument_list|)
condition|)
block|{
name|char
modifier|*
name|zero
init|=
literal|0
decl_stmt|;
name|_nc_tparm_err
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|PRESENT
argument_list|(
name|exit_attribute_mode
argument_list|)
condition|)
block|{
name|zero
operator|=
name|strdup
argument_list|(
name|CHECK_SGR
argument_list|(
literal|0
argument_list|,
name|exit_attribute_mode
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|zero
operator|=
name|strdup
argument_list|(
name|TPARM_9
argument_list|(
name|set_attributes
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|_nc_tparm_err
condition|)
name|_nc_warning
argument_list|(
literal|"stack error in sgr(0) string"
argument_list|)
expr_stmt|;
if|if
condition|(
name|zero
operator|!=
literal|0
condition|)
block|{
name|CHECK_SGR
argument_list|(
literal|1
argument_list|,
name|enter_standout_mode
argument_list|)
expr_stmt|;
name|CHECK_SGR
argument_list|(
literal|2
argument_list|,
name|enter_underline_mode
argument_list|)
expr_stmt|;
name|CHECK_SGR
argument_list|(
literal|3
argument_list|,
name|enter_reverse_mode
argument_list|)
expr_stmt|;
name|CHECK_SGR
argument_list|(
literal|4
argument_list|,
name|enter_blink_mode
argument_list|)
expr_stmt|;
name|CHECK_SGR
argument_list|(
literal|5
argument_list|,
name|enter_dim_mode
argument_list|)
expr_stmt|;
name|CHECK_SGR
argument_list|(
literal|6
argument_list|,
name|enter_bold_mode
argument_list|)
expr_stmt|;
name|CHECK_SGR
argument_list|(
literal|7
argument_list|,
name|enter_secure_mode
argument_list|)
expr_stmt|;
name|CHECK_SGR
argument_list|(
literal|8
argument_list|,
name|enter_protected_mode
argument_list|)
expr_stmt|;
name|CHECK_SGR
argument_list|(
literal|9
argument_list|,
name|enter_alt_charset_mode
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|zero
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|_nc_warning
argument_list|(
literal|"sgr(0) did not return a value"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|PRESENT
argument_list|(
name|exit_attribute_mode
argument_list|)
operator|&&
name|set_attributes
operator|!=
name|CANCELLED_STRING
condition|)
block|{
if|if
condition|(
name|_nc_syntax
operator|==
name|SYN_TERMINFO
condition|)
name|_nc_warning
argument_list|(
literal|"missing sgr string"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|PRESENT
argument_list|(
name|exit_attribute_mode
argument_list|)
condition|)
block|{
name|char
modifier|*
name|check_sgr0
init|=
name|_nc_trim_sgr0
argument_list|(
name|tp
argument_list|)
decl_stmt|;
if|if
condition|(
name|check_sgr0
operator|==
literal|0
operator|||
operator|*
name|check_sgr0
operator|==
literal|'\0'
condition|)
block|{
name|_nc_warning
argument_list|(
literal|"trimmed sgr0 is empty"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|show_where
argument_list|(
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|check_sgr0
operator|!=
name|exit_attribute_mode
condition|)
block|{
name|DEBUG
argument_list|(
literal|2
argument_list|,
operator|(
literal|"will trim sgr0\n\toriginal sgr0=%s\n\ttrimmed  sgr0=%s"
operator|,
name|_nc_visbuf2
argument_list|(
literal|1
argument_list|,
name|exit_attribute_mode
argument_list|)
operator|,
name|_nc_visbuf2
argument_list|(
literal|2
argument_list|,
name|check_sgr0
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|check_sgr0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DEBUG
argument_list|(
literal|2
argument_list|,
operator|(
literal|"will not trim sgr0\n\toriginal sgr0=%s"
operator|,
name|_nc_visbuf
argument_list|(
name|exit_attribute_mode
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
ifdef|#
directive|ifdef
name|TRACE
name|show_where
argument_list|(
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|auto_right_margin
condition|)
block|{
name|DEBUG
argument_list|(
literal|2
argument_list|,
operator|(
literal|"can write to lower-right directly"
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|PRESENT
argument_list|(
name|enter_am_mode
argument_list|)
operator|&&
name|PRESENT
argument_list|(
name|exit_am_mode
argument_list|)
condition|)
block|{
name|DEBUG
argument_list|(
literal|2
argument_list|,
operator|(
literal|"can write to lower-right by suppressing automargin"
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|PRESENT
argument_list|(
name|enter_insert_mode
argument_list|)
operator|&&
name|PRESENT
argument_list|(
name|exit_insert_mode
argument_list|)
operator|)
operator|||
name|PRESENT
argument_list|(
name|insert_character
argument_list|)
operator|||
name|PRESENT
argument_list|(
name|parm_ich
argument_list|)
condition|)
block|{
name|DEBUG
argument_list|(
literal|2
argument_list|,
operator|(
literal|"can write to lower-right by using inserts"
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DEBUG
argument_list|(
literal|2
argument_list|,
operator|(
literal|"cannot write to lower-right"
operator|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/*      * Some standard applications (e.g., vi) and some non-curses      * applications (e.g., jove) get confused if we have both ich1 and      * smir/rmir.  Let's be nice and warn about that, too, even though      * ncurses handles it.      */
if|if
condition|(
operator|(
name|PRESENT
argument_list|(
name|enter_insert_mode
argument_list|)
operator|||
name|PRESENT
argument_list|(
name|exit_insert_mode
argument_list|)
operator|)
operator|&&
name|PRESENT
argument_list|(
name|parm_ich
argument_list|)
condition|)
block|{
name|_nc_warning
argument_list|(
literal|"non-curses applications may be confused by ich1 with smir/rmir"
argument_list|)
expr_stmt|;
block|}
comment|/*      * Finally, do the non-verbose checks      */
if|if
condition|(
name|save_check_termtype
operator|!=
literal|0
condition|)
name|save_check_termtype
argument_list|(
name|tp
argument_list|,
name|literal
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

