begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/****************************************************************************  * Copyright (c) 1998-2005,2006 Free Software Foundation, Inc.              *  *                                                                          *  * Permission is hereby granted, free of charge, to any person obtaining a  *  * copy of this software and associated documentation files (the            *  * "Software"), to deal in the Software without restriction, including      *  * without limitation the rights to use, copy, modify, merge, publish,      *  * distribute, distribute with modifications, sublicense, and/or sell       *  * copies of the Software, and to permit persons to whom the Software is    *  * furnished to do so, subject to the following conditions:                 *  *                                                                          *  * The above copyright notice and this permission notice shall be included  *  * in all copies or substantial portions of the Software.                   *  *                                                                          *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *  * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *  * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *  * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *  * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *  * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *  *                                                                          *  * Except as contained in this notice, the name(s) of the above copyright   *  * holders shall not be used in advertising or otherwise to promote the     *  * sale, use or other dealings in this Software without prior written       *  * authorization.                                                           *  ****************************************************************************/
end_comment

begin_comment
comment|/****************************************************************************  *  Author: Zeyd M. Ben-Halim<zmbenhal@netcom.com> 1992,1995               *  *     and: Eric S. Raymond<esr@snark.thyrsus.com>                         *  *     and: Thomas E. Dickey                        1996-on                 *  ****************************************************************************/
end_comment

begin_comment
comment|/*  *	infocmp.c -- decompile an entry, or compare two entries  *		written by Eric S. Raymond  */
end_comment

begin_include
include|#
directive|include
file|<progs.priv.h>
end_include

begin_include
include|#
directive|include
file|<dump_entry.h>
end_include

begin_macro
name|MODULE_ID
argument_list|(
literal|"$Id: infocmp.c,v 1.85 2006/08/19 21:20:37 tom Exp $"
argument_list|)
end_macro

begin_define
define|#
directive|define
name|L_CURL
value|"{"
end_define

begin_define
define|#
directive|define
name|R_CURL
value|"}"
end_define

begin_define
define|#
directive|define
name|MAXTERMS
value|32
end_define

begin_comment
comment|/* max # terminal arguments we can handle */
end_comment

begin_define
define|#
directive|define
name|MAX_STRING
value|1024
end_define

begin_comment
comment|/* maximum formatted string */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|_nc_progname
init|=
literal|"infocmp"
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
name|char
name|path
index|[
name|PATH_MAX
index|]
typedef|;
end_typedef

begin_comment
comment|/***************************************************************************  *  * The following control variables, together with the contents of the  * terminfo entries, completely determine the actions of the program.  *  ***************************************************************************/
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|tname
index|[
name|MAXTERMS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* terminal type names */
end_comment

begin_decl_stmt
specifier|static
name|ENTRY
name|entries
index|[
name|MAXTERMS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* terminfo entries */
end_comment

begin_decl_stmt
specifier|static
name|int
name|termcount
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* count of terminal entries */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|limited
init|=
name|TRUE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* "-r" option is not set */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|quiet
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|literal
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|bool_sep
init|=
literal|":"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|s_absent
init|=
literal|"NULL"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|s_cancel
init|=
literal|"NULL"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|tversion
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* terminfo version selected */
end_comment

begin_decl_stmt
specifier|static
name|int
name|itrace
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* trace flag for debugging */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mwidth
init|=
literal|60
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|numbers
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* format "%'char'" to/from "%{number}" */
end_comment

begin_decl_stmt
specifier|static
name|int
name|outform
init|=
name|F_TERMINFO
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* output format */
end_comment

begin_decl_stmt
specifier|static
name|int
name|sortmode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* sort_mode */
end_comment

begin_comment
comment|/* main comparison mode */
end_comment

begin_decl_stmt
specifier|static
name|int
name|compare
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|C_DEFAULT
value|0
end_define

begin_comment
comment|/* don't force comparison mode */
end_comment

begin_define
define|#
directive|define
name|C_DIFFERENCE
value|1
end_define

begin_comment
comment|/* list differences between two terminals */
end_comment

begin_define
define|#
directive|define
name|C_COMMON
value|2
end_define

begin_comment
comment|/* list common capabilities */
end_comment

begin_define
define|#
directive|define
name|C_NAND
value|3
end_define

begin_comment
comment|/* list capabilities in neither terminal */
end_comment

begin_define
define|#
directive|define
name|C_USEALL
value|4
end_define

begin_comment
comment|/* generate relative use-form entry */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|ignorepads
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ignore pad prefixes when diffing */
end_comment

begin_if
if|#
directive|if
name|NO_LEAKS
end_if

begin_undef
undef|#
directive|undef
name|ExitProgram
end_undef

begin_decl_stmt
specifier|static
name|void
name|ExitProgram
argument_list|(
name|int
name|code
argument_list|)
name|GCC_NORETURN
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* prototype is to get gcc to accept the noreturn attribute */
end_comment

begin_function
specifier|static
name|void
name|ExitProgram
parameter_list|(
name|int
name|code
parameter_list|)
block|{
while|while
condition|(
name|termcount
operator|--
operator|>
literal|0
condition|)
name|_nc_free_termtype
argument_list|(
operator|&
name|entries
index|[
name|termcount
index|]
operator|.
name|tterm
argument_list|)
expr_stmt|;
name|_nc_leaks_dump_entry
argument_list|()
expr_stmt|;
name|_nc_free_and_exit
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|char
modifier|*
name|canonical_name
parameter_list|(
name|char
modifier|*
name|ptr
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|)
comment|/* extract the terminal type's primary name */
block|{
name|char
modifier|*
name|bp
decl_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buf
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bp
operator|=
name|strchr
argument_list|(
name|buf
argument_list|,
literal|'|'
argument_list|)
operator|)
operator|!=
literal|0
condition|)
operator|*
name|bp
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_comment
comment|/***************************************************************************  *  * Predicates for dump function  *  ***************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|capcmp
parameter_list|(
name|PredIdx
name|idx
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|,
specifier|const
name|char
modifier|*
name|t
parameter_list|)
comment|/* capability comparison function */
block|{
if|if
condition|(
operator|!
name|VALID_STRING
argument_list|(
name|s
argument_list|)
operator|&&
operator|!
name|VALID_STRING
argument_list|(
name|t
argument_list|)
condition|)
return|return
operator|(
name|s
operator|!=
name|t
operator|)
return|;
elseif|else
if|if
condition|(
operator|!
name|VALID_STRING
argument_list|(
name|s
argument_list|)
operator|||
operator|!
name|VALID_STRING
argument_list|(
name|t
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
operator|(
name|idx
operator|==
name|acs_chars_index
operator|)
operator|||
operator|!
name|ignorepads
condition|)
return|return
operator|(
name|strcmp
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|_nc_capcmp
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|use_predicate
parameter_list|(
name|unsigned
name|type
parameter_list|,
name|PredIdx
name|idx
parameter_list|)
comment|/* predicate function to use for use decompilation */
block|{
name|ENTRY
modifier|*
name|ep
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|BOOLEAN
case|:
block|{
name|int
name|is_set
init|=
name|FALSE
decl_stmt|;
comment|/* 	     * This assumes that multiple use entries are supposed 	     * to contribute the logical or of their boolean capabilities. 	     * This is true if we take the semantics of multiple uses to 	     * be 'each capability gets the first non-default value found 	     * in the sequence of use entries'. 	     * 	     * Note that cancelled or absent booleans are stored as FALSE, 	     * unlike numbers and strings, whose cancelled/absent state is 	     * recorded in the terminfo database. 	     */
for|for
control|(
name|ep
operator|=
operator|&
name|entries
index|[
literal|1
index|]
init|;
name|ep
operator|<
name|entries
operator|+
name|termcount
condition|;
name|ep
operator|++
control|)
if|if
condition|(
name|ep
operator|->
name|tterm
operator|.
name|Booleans
index|[
name|idx
index|]
operator|==
name|TRUE
condition|)
block|{
name|is_set
operator|=
name|entries
index|[
literal|0
index|]
operator|.
name|tterm
operator|.
name|Booleans
index|[
name|idx
index|]
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|is_set
operator|!=
name|entries
index|[
literal|0
index|]
operator|.
name|tterm
operator|.
name|Booleans
index|[
name|idx
index|]
condition|)
return|return
operator|(
operator|!
name|is_set
operator|)
return|;
else|else
return|return
operator|(
name|FAIL
operator|)
return|;
block|}
case|case
name|NUMBER
case|:
block|{
name|int
name|value
init|=
name|ABSENT_NUMERIC
decl_stmt|;
comment|/* 	     * We take the semantics of multiple uses to be 'each 	     * capability gets the first non-default value found 	     * in the sequence of use entries'. 	     */
for|for
control|(
name|ep
operator|=
operator|&
name|entries
index|[
literal|1
index|]
init|;
name|ep
operator|<
name|entries
operator|+
name|termcount
condition|;
name|ep
operator|++
control|)
if|if
condition|(
name|VALID_NUMERIC
argument_list|(
name|ep
operator|->
name|tterm
operator|.
name|Numbers
index|[
name|idx
index|]
argument_list|)
condition|)
block|{
name|value
operator|=
name|ep
operator|->
name|tterm
operator|.
name|Numbers
index|[
name|idx
index|]
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|value
operator|!=
name|entries
index|[
literal|0
index|]
operator|.
name|tterm
operator|.
name|Numbers
index|[
name|idx
index|]
condition|)
return|return
operator|(
name|value
operator|!=
name|ABSENT_NUMERIC
operator|)
return|;
else|else
return|return
operator|(
name|FAIL
operator|)
return|;
block|}
case|case
name|STRING
case|:
block|{
name|char
modifier|*
name|termstr
decl_stmt|,
modifier|*
name|usestr
init|=
name|ABSENT_STRING
decl_stmt|;
name|termstr
operator|=
name|entries
index|[
literal|0
index|]
operator|.
name|tterm
operator|.
name|Strings
index|[
name|idx
index|]
expr_stmt|;
comment|/* 	     * We take the semantics of multiple uses to be 'each 	     * capability gets the first non-default value found 	     * in the sequence of use entries'. 	     */
for|for
control|(
name|ep
operator|=
operator|&
name|entries
index|[
literal|1
index|]
init|;
name|ep
operator|<
name|entries
operator|+
name|termcount
condition|;
name|ep
operator|++
control|)
if|if
condition|(
name|ep
operator|->
name|tterm
operator|.
name|Strings
index|[
name|idx
index|]
condition|)
block|{
name|usestr
operator|=
name|ep
operator|->
name|tterm
operator|.
name|Strings
index|[
name|idx
index|]
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|usestr
operator|==
name|ABSENT_STRING
operator|&&
name|termstr
operator|==
name|ABSENT_STRING
condition|)
return|return
operator|(
name|FAIL
operator|)
return|;
elseif|else
if|if
condition|(
operator|!
name|usestr
operator|||
operator|!
name|termstr
operator|||
name|capcmp
argument_list|(
name|idx
argument_list|,
name|usestr
argument_list|,
name|termstr
argument_list|)
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
else|else
return|return
operator|(
name|FAIL
operator|)
return|;
block|}
block|}
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* pacify compiler */
block|}
end_function

begin_function
specifier|static
name|bool
name|useeq
parameter_list|(
name|ENTRY
modifier|*
name|e1
parameter_list|,
name|ENTRY
modifier|*
name|e2
parameter_list|)
comment|/* are the use references in two entries equivalent? */
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|e1
operator|->
name|nuses
operator|!=
name|e2
operator|->
name|nuses
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* Ugh...this is quadratic again */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|e1
operator|->
name|nuses
condition|;
name|i
operator|++
control|)
block|{
name|bool
name|foundmatch
init|=
name|FALSE
decl_stmt|;
comment|/* search second entry for given use reference */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|e2
operator|->
name|nuses
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|e1
operator|->
name|uses
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|e2
operator|->
name|uses
index|[
name|j
index|]
operator|.
name|name
argument_list|)
condition|)
block|{
name|foundmatch
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|foundmatch
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|entryeq
parameter_list|(
name|TERMTYPE
modifier|*
name|t1
parameter_list|,
name|TERMTYPE
modifier|*
name|t2
parameter_list|)
comment|/* are two entries equivalent? */
block|{
name|unsigned
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_BOOLEANS
argument_list|(
name|t1
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|t1
operator|->
name|Booleans
index|[
name|i
index|]
operator|!=
name|t2
operator|->
name|Booleans
index|[
name|i
index|]
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_NUMBERS
argument_list|(
name|t1
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|t1
operator|->
name|Numbers
index|[
name|i
index|]
operator|!=
name|t2
operator|->
name|Numbers
index|[
name|i
index|]
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_STRINGS
argument_list|(
name|t1
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|capcmp
argument_list|(
operator|(
name|PredIdx
operator|)
name|i
argument_list|,
name|t1
operator|->
name|Strings
index|[
name|i
index|]
argument_list|,
name|t2
operator|->
name|Strings
index|[
name|i
index|]
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|TIC_EXPAND
parameter_list|(
name|result
parameter_list|)
value|_nc_tic_expand(result, outform==F_TERMINFO, numbers)
end_define

begin_function
specifier|static
name|void
name|print_uses
parameter_list|(
name|ENTRY
modifier|*
name|ep
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
comment|/* print an entry's use references */
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|ep
operator|->
name|nuses
condition|)
name|fputs
argument_list|(
literal|"NULL"
argument_list|,
name|fp
argument_list|)
expr_stmt|;
else|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ep
operator|->
name|nuses
condition|;
name|i
operator|++
control|)
block|{
name|fputs
argument_list|(
name|ep
operator|->
name|uses
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|ep
operator|->
name|nuses
operator|-
literal|1
condition|)
name|fputs
argument_list|(
literal|" "
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|dump_boolean
parameter_list|(
name|int
name|val
parameter_list|)
comment|/* display the value of a boolean capability */
block|{
switch|switch
condition|(
name|val
condition|)
block|{
case|case
name|ABSENT_BOOLEAN
case|:
return|return
operator|(
name|s_absent
operator|)
return|;
case|case
name|CANCELLED_BOOLEAN
case|:
return|return
operator|(
name|s_cancel
operator|)
return|;
case|case
name|FALSE
case|:
return|return
operator|(
literal|"F"
operator|)
return|;
case|case
name|TRUE
case|:
return|return
operator|(
literal|"T"
operator|)
return|;
default|default:
return|return
operator|(
literal|"?"
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dump_numeric
parameter_list|(
name|int
name|val
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|)
comment|/* display the value of a boolean capability */
block|{
switch|switch
condition|(
name|val
condition|)
block|{
case|case
name|ABSENT_NUMERIC
case|:
name|strcpy
argument_list|(
name|buf
argument_list|,
name|s_absent
argument_list|)
expr_stmt|;
break|break;
case|case
name|CANCELLED_NUMERIC
case|:
name|strcpy
argument_list|(
name|buf
argument_list|,
name|s_cancel
argument_list|)
expr_stmt|;
break|break;
default|default:
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d"
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dump_string
parameter_list|(
name|char
modifier|*
name|val
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|)
comment|/* display the value of a string capability */
block|{
if|if
condition|(
name|val
operator|==
name|ABSENT_STRING
condition|)
name|strcpy
argument_list|(
name|buf
argument_list|,
name|s_absent
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|val
operator|==
name|CANCELLED_STRING
condition|)
name|strcpy
argument_list|(
name|buf
argument_list|,
name|s_cancel
argument_list|)
expr_stmt|;
else|else
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"'%.*s'"
argument_list|,
name|MAX_STRING
operator|-
literal|3
argument_list|,
name|TIC_EXPAND
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|compare_predicate
parameter_list|(
name|PredType
name|type
parameter_list|,
name|PredIdx
name|idx
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
comment|/* predicate function to use for entry difference reports */
block|{
specifier|register
name|ENTRY
modifier|*
name|e1
init|=
operator|&
name|entries
index|[
literal|0
index|]
decl_stmt|;
specifier|register
name|ENTRY
modifier|*
name|e2
init|=
operator|&
name|entries
index|[
literal|1
index|]
decl_stmt|;
name|char
name|buf1
index|[
name|MAX_STRING
index|]
decl_stmt|,
name|buf2
index|[
name|MAX_STRING
index|]
decl_stmt|;
name|int
name|b1
decl_stmt|,
name|b2
decl_stmt|;
name|int
name|n1
decl_stmt|,
name|n2
decl_stmt|;
name|char
modifier|*
name|s1
decl_stmt|,
modifier|*
name|s2
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|CMP_BOOLEAN
case|:
name|b1
operator|=
name|e1
operator|->
name|tterm
operator|.
name|Booleans
index|[
name|idx
index|]
expr_stmt|;
name|b2
operator|=
name|e2
operator|->
name|tterm
operator|.
name|Booleans
index|[
name|idx
index|]
expr_stmt|;
switch|switch
condition|(
name|compare
condition|)
block|{
case|case
name|C_DIFFERENCE
case|:
if|if
condition|(
operator|!
operator|(
name|b1
operator|==
name|ABSENT_BOOLEAN
operator|&&
name|b2
operator|==
name|ABSENT_BOOLEAN
operator|)
operator|&&
name|b1
operator|!=
name|b2
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\t%s: %s%s%s.\n"
argument_list|,
name|name
argument_list|,
name|dump_boolean
argument_list|(
name|b1
argument_list|)
argument_list|,
name|bool_sep
argument_list|,
name|dump_boolean
argument_list|(
name|b2
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|C_COMMON
case|:
if|if
condition|(
name|b1
operator|==
name|b2
operator|&&
name|b1
operator|!=
name|ABSENT_BOOLEAN
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\t%s= %s.\n"
argument_list|,
name|name
argument_list|,
name|dump_boolean
argument_list|(
name|b1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|C_NAND
case|:
if|if
condition|(
name|b1
operator|==
name|ABSENT_BOOLEAN
operator|&&
name|b2
operator|==
name|ABSENT_BOOLEAN
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\t!%s.\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|CMP_NUMBER
case|:
name|n1
operator|=
name|e1
operator|->
name|tterm
operator|.
name|Numbers
index|[
name|idx
index|]
expr_stmt|;
name|n2
operator|=
name|e2
operator|->
name|tterm
operator|.
name|Numbers
index|[
name|idx
index|]
expr_stmt|;
name|dump_numeric
argument_list|(
name|n1
argument_list|,
name|buf1
argument_list|)
expr_stmt|;
name|dump_numeric
argument_list|(
name|n2
argument_list|,
name|buf2
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|compare
condition|)
block|{
case|case
name|C_DIFFERENCE
case|:
if|if
condition|(
operator|!
operator|(
operator|(
name|n1
operator|==
name|ABSENT_NUMERIC
operator|&&
name|n2
operator|==
name|ABSENT_NUMERIC
operator|)
operator|)
operator|&&
name|n1
operator|!=
name|n2
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\t%s: %s, %s.\n"
argument_list|,
name|name
argument_list|,
name|buf1
argument_list|,
name|buf2
argument_list|)
expr_stmt|;
break|break;
case|case
name|C_COMMON
case|:
if|if
condition|(
name|n1
operator|!=
name|ABSENT_NUMERIC
operator|&&
name|n2
operator|!=
name|ABSENT_NUMERIC
operator|&&
name|n1
operator|==
name|n2
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\t%s= %s.\n"
argument_list|,
name|name
argument_list|,
name|buf1
argument_list|)
expr_stmt|;
break|break;
case|case
name|C_NAND
case|:
if|if
condition|(
name|n1
operator|==
name|ABSENT_NUMERIC
operator|&&
name|n2
operator|==
name|ABSENT_NUMERIC
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\t!%s.\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|CMP_STRING
case|:
name|s1
operator|=
name|e1
operator|->
name|tterm
operator|.
name|Strings
index|[
name|idx
index|]
expr_stmt|;
name|s2
operator|=
name|e2
operator|->
name|tterm
operator|.
name|Strings
index|[
name|idx
index|]
expr_stmt|;
switch|switch
condition|(
name|compare
condition|)
block|{
case|case
name|C_DIFFERENCE
case|:
if|if
condition|(
name|capcmp
argument_list|(
name|idx
argument_list|,
name|s1
argument_list|,
name|s2
argument_list|)
condition|)
block|{
name|dump_string
argument_list|(
name|s1
argument_list|,
name|buf1
argument_list|)
expr_stmt|;
name|dump_string
argument_list|(
name|s2
argument_list|,
name|buf2
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|buf1
argument_list|,
name|buf2
argument_list|)
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\t%s: %s, %s.\n"
argument_list|,
name|name
argument_list|,
name|buf1
argument_list|,
name|buf2
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|C_COMMON
case|:
if|if
condition|(
name|s1
operator|&&
name|s2
operator|&&
operator|!
name|capcmp
argument_list|(
name|idx
argument_list|,
name|s1
argument_list|,
name|s2
argument_list|)
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\t%s= '%s'.\n"
argument_list|,
name|name
argument_list|,
name|TIC_EXPAND
argument_list|(
name|s1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|C_NAND
case|:
if|if
condition|(
operator|!
name|s1
operator|&&
operator|!
name|s2
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\t!%s.\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|CMP_USE
case|:
comment|/* unlike the other modes, this compares *all* use entries */
switch|switch
condition|(
name|compare
condition|)
block|{
case|case
name|C_DIFFERENCE
case|:
if|if
condition|(
operator|!
name|useeq
argument_list|(
name|e1
argument_list|,
name|e2
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fputs
argument_list|(
literal|"\tuse: "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|print_uses
argument_list|(
name|e1
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|", "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|print_uses
argument_list|(
name|e2
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|".\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|C_COMMON
case|:
if|if
condition|(
name|e1
operator|->
name|nuses
operator|&&
name|e2
operator|->
name|nuses
operator|&&
name|useeq
argument_list|(
name|e1
argument_list|,
name|e2
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fputs
argument_list|(
literal|"\tuse: "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|print_uses
argument_list|(
name|e1
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|".\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|C_NAND
case|:
if|if
condition|(
operator|!
name|e1
operator|->
name|nuses
operator|&&
operator|!
name|e2
operator|->
name|nuses
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\t!use.\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/***************************************************************************  *  * Init string analysis  *  ***************************************************************************/
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
specifier|const
name|char
modifier|*
name|from
decl_stmt|;
specifier|const
name|char
modifier|*
name|to
decl_stmt|;
block|}
name|assoc
typedef|;
end_typedef

begin_decl_stmt
specifier|static
specifier|const
name|assoc
name|std_caps
index|[]
init|=
block|{
comment|/* these are specified by X.364 and iBCS2 */
block|{
literal|"\033c"
block|,
literal|"RIS"
block|}
block|,
comment|/* full reset */
block|{
literal|"\0337"
block|,
literal|"SC"
block|}
block|,
comment|/* save cursor */
block|{
literal|"\0338"
block|,
literal|"RC"
block|}
block|,
comment|/* restore cursor */
block|{
literal|"\033[r"
block|,
literal|"RSR"
block|}
block|,
comment|/* not an X.364 mnemonic */
block|{
literal|"\033[m"
block|,
literal|"SGR0"
block|}
block|,
comment|/* not an X.364 mnemonic */
block|{
literal|"\033[2J"
block|,
literal|"ED2"
block|}
block|,
comment|/* clear page */
comment|/* this group is specified by ISO 2022 */
block|{
literal|"\033(0"
block|,
literal|"ISO DEC G0"
block|}
block|,
comment|/* enable DEC graphics for G0 */
block|{
literal|"\033(A"
block|,
literal|"ISO UK G0"
block|}
block|,
comment|/* enable UK chars for G0 */
block|{
literal|"\033(B"
block|,
literal|"ISO US G0"
block|}
block|,
comment|/* enable US chars for G0 */
block|{
literal|"\033)0"
block|,
literal|"ISO DEC G1"
block|}
block|,
comment|/* enable DEC graphics for G1 */
block|{
literal|"\033)A"
block|,
literal|"ISO UK G1"
block|}
block|,
comment|/* enable UK chars for G1 */
block|{
literal|"\033)B"
block|,
literal|"ISO US G1"
block|}
block|,
comment|/* enable US chars for G1 */
comment|/* these are DEC private controls widely supported by emulators */
block|{
literal|"\033="
block|,
literal|"DECPAM"
block|}
block|,
comment|/* application keypad mode */
block|{
literal|"\033>"
block|,
literal|"DECPNM"
block|}
block|,
comment|/* normal keypad mode */
block|{
literal|"\033<"
block|,
literal|"DECANSI"
block|}
block|,
comment|/* enter ANSI mode */
block|{
literal|"\033[!p"
block|,
literal|"DECSTR"
block|}
block|,
comment|/* soft reset */
block|{
literal|"\033 F"
block|,
literal|"S7C1T"
block|}
block|,
comment|/* 7-bit controls */
block|{
operator|(
name|char
operator|*
operator|)
literal|0
block|,
operator|(
name|char
operator|*
operator|)
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|assoc
name|std_modes
index|[]
init|=
comment|/* ECMA \E[ ... [hl] modes recognized by many emulators */
block|{
block|{
literal|"2"
block|,
literal|"AM"
block|}
block|,
comment|/* keyboard action mode */
block|{
literal|"4"
block|,
literal|"IRM"
block|}
block|,
comment|/* insert/replace mode */
block|{
literal|"12"
block|,
literal|"SRM"
block|}
block|,
comment|/* send/receive mode */
block|{
literal|"20"
block|,
literal|"LNM"
block|}
block|,
comment|/* linefeed mode */
block|{
operator|(
name|char
operator|*
operator|)
literal|0
block|,
operator|(
name|char
operator|*
operator|)
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|assoc
name|private_modes
index|[]
init|=
comment|/* DEC \E[ ... [hl] modes recognized by many emulators */
block|{
block|{
literal|"1"
block|,
literal|"CKM"
block|}
block|,
comment|/* application cursor keys */
block|{
literal|"2"
block|,
literal|"ANM"
block|}
block|,
comment|/* set VT52 mode */
block|{
literal|"3"
block|,
literal|"COLM"
block|}
block|,
comment|/* 132-column mode */
block|{
literal|"4"
block|,
literal|"SCLM"
block|}
block|,
comment|/* smooth scroll */
block|{
literal|"5"
block|,
literal|"SCNM"
block|}
block|,
comment|/* reverse video mode */
block|{
literal|"6"
block|,
literal|"OM"
block|}
block|,
comment|/* origin mode */
block|{
literal|"7"
block|,
literal|"AWM"
block|}
block|,
comment|/* wraparound mode */
block|{
literal|"8"
block|,
literal|"ARM"
block|}
block|,
comment|/* auto-repeat mode */
block|{
operator|(
name|char
operator|*
operator|)
literal|0
block|,
operator|(
name|char
operator|*
operator|)
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|assoc
name|ecma_highlights
index|[]
init|=
comment|/* recognize ECMA attribute sequences */
block|{
block|{
literal|"0"
block|,
literal|"NORMAL"
block|}
block|,
comment|/* normal */
block|{
literal|"1"
block|,
literal|"+BOLD"
block|}
block|,
comment|/* bold on */
block|{
literal|"2"
block|,
literal|"+DIM"
block|}
block|,
comment|/* dim on */
block|{
literal|"3"
block|,
literal|"+ITALIC"
block|}
block|,
comment|/* italic on */
block|{
literal|"4"
block|,
literal|"+UNDERLINE"
block|}
block|,
comment|/* underline on */
block|{
literal|"5"
block|,
literal|"+BLINK"
block|}
block|,
comment|/* blink on */
block|{
literal|"6"
block|,
literal|"+FASTBLINK"
block|}
block|,
comment|/* fastblink on */
block|{
literal|"7"
block|,
literal|"+REVERSE"
block|}
block|,
comment|/* reverse on */
block|{
literal|"8"
block|,
literal|"+INVISIBLE"
block|}
block|,
comment|/* invisible on */
block|{
literal|"9"
block|,
literal|"+DELETED"
block|}
block|,
comment|/* deleted on */
block|{
literal|"10"
block|,
literal|"MAIN-FONT"
block|}
block|,
comment|/* select primary font */
block|{
literal|"11"
block|,
literal|"ALT-FONT-1"
block|}
block|,
comment|/* select alternate font 1 */
block|{
literal|"12"
block|,
literal|"ALT-FONT-2"
block|}
block|,
comment|/* select alternate font 2 */
block|{
literal|"13"
block|,
literal|"ALT-FONT-3"
block|}
block|,
comment|/* select alternate font 3 */
block|{
literal|"14"
block|,
literal|"ALT-FONT-4"
block|}
block|,
comment|/* select alternate font 4 */
block|{
literal|"15"
block|,
literal|"ALT-FONT-5"
block|}
block|,
comment|/* select alternate font 5 */
block|{
literal|"16"
block|,
literal|"ALT-FONT-6"
block|}
block|,
comment|/* select alternate font 6 */
block|{
literal|"17"
block|,
literal|"ALT-FONT-7"
block|}
block|,
comment|/* select alternate font 7 */
block|{
literal|"18"
block|,
literal|"ALT-FONT-1"
block|}
block|,
comment|/* select alternate font 1 */
block|{
literal|"19"
block|,
literal|"ALT-FONT-1"
block|}
block|,
comment|/* select alternate font 1 */
block|{
literal|"20"
block|,
literal|"FRAKTUR"
block|}
block|,
comment|/* Fraktur font */
block|{
literal|"21"
block|,
literal|"DOUBLEUNDER"
block|}
block|,
comment|/* double underline */
block|{
literal|"22"
block|,
literal|"-DIM"
block|}
block|,
comment|/* dim off */
block|{
literal|"23"
block|,
literal|"-ITALIC"
block|}
block|,
comment|/* italic off */
block|{
literal|"24"
block|,
literal|"-UNDERLINE"
block|}
block|,
comment|/* underline off */
block|{
literal|"25"
block|,
literal|"-BLINK"
block|}
block|,
comment|/* blink off */
block|{
literal|"26"
block|,
literal|"-FASTBLINK"
block|}
block|,
comment|/* fastblink off */
block|{
literal|"27"
block|,
literal|"-REVERSE"
block|}
block|,
comment|/* reverse off */
block|{
literal|"28"
block|,
literal|"-INVISIBLE"
block|}
block|,
comment|/* invisible off */
block|{
literal|"29"
block|,
literal|"-DELETED"
block|}
block|,
comment|/* deleted off */
block|{
operator|(
name|char
operator|*
operator|)
literal|0
block|,
operator|(
name|char
operator|*
operator|)
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|skip_csi
parameter_list|(
specifier|const
name|char
modifier|*
name|cap
parameter_list|)
block|{
name|int
name|result
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|cap
index|[
literal|0
index|]
operator|==
literal|'\033'
operator|&&
name|cap
index|[
literal|1
index|]
operator|==
literal|'['
condition|)
name|result
operator|=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|UChar
argument_list|(
name|cap
index|[
literal|0
index|]
argument_list|)
operator|==
literal|0233
condition|)
name|result
operator|=
literal|1
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|same_param
parameter_list|(
specifier|const
name|char
modifier|*
name|table
parameter_list|,
specifier|const
name|char
modifier|*
name|param
parameter_list|,
name|unsigned
name|length
parameter_list|)
block|{
name|bool
name|result
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|table
argument_list|,
name|param
argument_list|,
name|length
argument_list|)
operator|==
literal|0
condition|)
block|{
name|result
operator|=
operator|!
name|isdigit
argument_list|(
name|UChar
argument_list|(
name|param
index|[
name|length
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|lookup_params
parameter_list|(
specifier|const
name|assoc
modifier|*
name|table
parameter_list|,
name|char
modifier|*
name|dst
parameter_list|,
name|char
modifier|*
name|src
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|ep
init|=
name|strtok
argument_list|(
name|src
argument_list|,
literal|";"
argument_list|)
decl_stmt|;
specifier|const
name|assoc
modifier|*
name|ap
decl_stmt|;
do|do
block|{
name|bool
name|found
init|=
name|FALSE
decl_stmt|;
for|for
control|(
name|ap
operator|=
name|table
init|;
name|ap
operator|->
name|from
condition|;
name|ap
operator|++
control|)
block|{
name|size_t
name|tlen
init|=
name|strlen
argument_list|(
name|ap
operator|->
name|from
argument_list|)
decl_stmt|;
if|if
condition|(
name|same_param
argument_list|(
name|ap
operator|->
name|from
argument_list|,
name|ep
argument_list|,
name|tlen
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|dst
argument_list|,
name|ap
operator|->
name|to
argument_list|)
expr_stmt|;
name|found
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|dst
argument_list|,
name|ep
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|dst
argument_list|,
literal|";"
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|ep
operator|=
name|strtok
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
literal|";"
argument_list|)
operator|)
condition|)
do|;
name|dst
index|[
name|strlen
argument_list|(
name|dst
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|dst
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|analyze_string
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|cap
parameter_list|,
name|TERMTYPE
modifier|*
name|tp
parameter_list|)
block|{
name|char
name|buf
index|[
name|MAX_TERMINFO_LENGTH
index|]
decl_stmt|;
name|char
name|buf2
index|[
name|MAX_TERMINFO_LENGTH
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|sp
decl_stmt|;
specifier|const
name|assoc
modifier|*
name|ap
decl_stmt|;
name|int
name|tp_lines
init|=
name|tp
operator|->
name|Numbers
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|cap
operator|==
name|ABSENT_STRING
operator|||
name|cap
operator|==
name|CANCELLED_STRING
condition|)
return|return;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: "
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|sp
operator|=
name|cap
init|;
operator|*
name|sp
condition|;
name|sp
operator|++
control|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|csi
decl_stmt|;
name|size_t
name|len
init|=
literal|0
decl_stmt|;
name|size_t
name|next
decl_stmt|;
specifier|const
name|char
modifier|*
name|expansion
init|=
literal|0
decl_stmt|;
name|char
name|buf3
index|[
name|MAX_TERMINFO_LENGTH
index|]
decl_stmt|;
comment|/* first, check other capabilities in this entry */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|STRCOUNT
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|cp
init|=
name|tp
operator|->
name|Strings
index|[
name|i
index|]
decl_stmt|;
comment|/* don't use soft-key capabilities */
if|if
condition|(
name|strnames
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'k'
operator|&&
name|strnames
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'f'
condition|)
continue|continue;
if|if
condition|(
name|cp
operator|!=
name|ABSENT_STRING
operator|&&
name|cp
operator|!=
name|CANCELLED_STRING
operator|&&
name|cp
index|[
literal|0
index|]
operator|&&
name|cp
operator|!=
name|cap
condition|)
block|{
name|len
operator|=
name|strlen
argument_list|(
name|cp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|buf2
argument_list|,
name|sp
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|buf2
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|_nc_capcmp
argument_list|(
name|cp
argument_list|,
name|buf2
argument_list|)
condition|)
continue|continue;
define|#
directive|define
name|ISRS
parameter_list|(
name|s
parameter_list|)
value|(!strncmp((s), "is", 2) || !strncmp((s), "rs", 2))
comment|/* 		 * Theoretically we just passed the test for translation 		 * (equality once the padding is stripped).  However, there 		 * are a few more hoops that need to be jumped so that 		 * identical pairs of initialization and reset strings 		 * don't just refer to each other. 		 */
if|if
condition|(
name|ISRS
argument_list|(
name|name
argument_list|)
operator|||
name|ISRS
argument_list|(
name|strnames
index|[
name|i
index|]
argument_list|)
condition|)
if|if
condition|(
name|cap
operator|<
name|cp
condition|)
continue|continue;
undef|#
directive|undef
name|ISRS
name|expansion
operator|=
name|strnames
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
block|}
comment|/* now check the standard capabilities */
if|if
condition|(
operator|!
name|expansion
condition|)
block|{
name|csi
operator|=
name|skip_csi
argument_list|(
name|sp
argument_list|)
expr_stmt|;
for|for
control|(
name|ap
operator|=
name|std_caps
init|;
name|ap
operator|->
name|from
condition|;
name|ap
operator|++
control|)
block|{
name|size_t
name|adj
init|=
name|csi
condition|?
literal|2
else|:
literal|0
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|ap
operator|->
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|csi
operator|&&
name|skip_csi
argument_list|(
name|ap
operator|->
name|from
argument_list|)
operator|!=
name|csi
condition|)
continue|continue;
if|if
condition|(
name|len
operator|>
name|adj
operator|&&
name|strncmp
argument_list|(
name|ap
operator|->
name|from
operator|+
name|adj
argument_list|,
name|sp
operator|+
name|csi
argument_list|,
name|len
operator|-
name|adj
argument_list|)
operator|==
literal|0
condition|)
block|{
name|expansion
operator|=
name|ap
operator|->
name|to
expr_stmt|;
name|len
operator|-=
name|adj
expr_stmt|;
name|len
operator|+=
name|csi
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* now check for standard-mode sequences */
if|if
condition|(
operator|!
name|expansion
operator|&&
operator|(
name|csi
operator|=
name|skip_csi
argument_list|(
name|sp
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|len
operator|=
name|strspn
argument_list|(
name|sp
operator|+
name|csi
argument_list|,
literal|"0123456789;"
argument_list|)
operator|)
operator|&&
operator|(
name|next
operator|=
name|csi
operator|+
name|len
operator|)
operator|&&
operator|(
operator|(
name|sp
index|[
name|next
index|]
operator|==
literal|'h'
operator|)
operator|||
operator|(
name|sp
index|[
name|next
index|]
operator|==
literal|'l'
operator|)
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buf2
argument_list|,
operator|(
name|sp
index|[
name|next
index|]
operator|==
literal|'h'
operator|)
condition|?
literal|"ECMA+"
else|:
literal|"ECMA-"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|buf3
argument_list|,
name|sp
operator|+
name|csi
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|buf3
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|len
operator|+=
name|csi
operator|+
literal|1
expr_stmt|;
name|expansion
operator|=
name|lookup_params
argument_list|(
name|std_modes
argument_list|,
name|buf2
argument_list|,
name|buf3
argument_list|)
expr_stmt|;
block|}
comment|/* now check for private-mode sequences */
if|if
condition|(
operator|!
name|expansion
operator|&&
operator|(
name|csi
operator|=
name|skip_csi
argument_list|(
name|sp
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|sp
index|[
name|csi
index|]
operator|==
literal|'?'
operator|&&
operator|(
name|len
operator|=
name|strspn
argument_list|(
name|sp
operator|+
name|csi
operator|+
literal|1
argument_list|,
literal|"0123456789;"
argument_list|)
operator|)
operator|&&
operator|(
name|next
operator|=
name|csi
operator|+
literal|1
operator|+
name|len
operator|)
operator|&&
operator|(
operator|(
name|sp
index|[
name|next
index|]
operator|==
literal|'h'
operator|)
operator|||
operator|(
name|sp
index|[
name|next
index|]
operator|==
literal|'l'
operator|)
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buf2
argument_list|,
operator|(
name|sp
index|[
name|next
index|]
operator|==
literal|'h'
operator|)
condition|?
literal|"DEC+"
else|:
literal|"DEC-"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|buf3
argument_list|,
name|sp
operator|+
name|csi
operator|+
literal|1
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|buf3
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|len
operator|+=
name|csi
operator|+
literal|2
expr_stmt|;
name|expansion
operator|=
name|lookup_params
argument_list|(
name|private_modes
argument_list|,
name|buf2
argument_list|,
name|buf3
argument_list|)
expr_stmt|;
block|}
comment|/* now check for ECMA highlight sequences */
if|if
condition|(
operator|!
name|expansion
operator|&&
operator|(
name|csi
operator|=
name|skip_csi
argument_list|(
name|sp
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|len
operator|=
name|strspn
argument_list|(
name|sp
operator|+
name|csi
argument_list|,
literal|"0123456789;"
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|next
operator|=
name|csi
operator|+
name|len
operator|)
operator|&&
name|sp
index|[
name|next
index|]
operator|==
literal|'m'
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buf2
argument_list|,
literal|"SGR:"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|buf3
argument_list|,
name|sp
operator|+
name|csi
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|buf3
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|len
operator|+=
name|csi
operator|+
literal|1
expr_stmt|;
name|expansion
operator|=
name|lookup_params
argument_list|(
name|ecma_highlights
argument_list|,
name|buf2
argument_list|,
name|buf3
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|expansion
operator|&&
operator|(
name|csi
operator|=
name|skip_csi
argument_list|(
name|sp
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|sp
index|[
name|csi
index|]
operator|==
literal|'m'
condition|)
block|{
name|len
operator|=
name|csi
operator|+
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buf2
argument_list|,
literal|"SGR:"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buf2
argument_list|,
name|ecma_highlights
index|[
literal|0
index|]
operator|.
name|to
argument_list|)
expr_stmt|;
name|expansion
operator|=
name|buf2
expr_stmt|;
block|}
comment|/* now check for scroll region reset */
if|if
condition|(
operator|!
name|expansion
operator|&&
operator|(
name|csi
operator|=
name|skip_csi
argument_list|(
name|sp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|sp
index|[
name|csi
index|]
operator|==
literal|'r'
condition|)
block|{
name|expansion
operator|=
literal|"RSR"
expr_stmt|;
name|len
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf2
argument_list|,
literal|"1;%dr"
argument_list|,
name|tp_lines
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|buf2
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|buf2
argument_list|,
name|sp
operator|+
name|csi
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
name|expansion
operator|=
literal|"RSR"
expr_stmt|;
block|}
name|len
operator|+=
name|csi
expr_stmt|;
block|}
comment|/* now check for home-down */
if|if
condition|(
operator|!
name|expansion
operator|&&
operator|(
name|csi
operator|=
name|skip_csi
argument_list|(
name|sp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf2
argument_list|,
literal|"%d;1H"
argument_list|,
name|tp_lines
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|buf2
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|buf2
argument_list|,
name|sp
operator|+
name|csi
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
block|{
name|expansion
operator|=
literal|"LL"
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf2
argument_list|,
literal|"%dH"
argument_list|,
name|tp_lines
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|buf2
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|buf2
argument_list|,
name|sp
operator|+
name|csi
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
block|{
name|expansion
operator|=
literal|"LL"
expr_stmt|;
block|}
block|}
name|len
operator|+=
name|csi
expr_stmt|;
block|}
comment|/* now look at the expansion we got, if any */
if|if
condition|(
name|expansion
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
operator|+
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"{%s}"
argument_list|,
name|expansion
argument_list|)
expr_stmt|;
name|sp
operator|+=
name|len
operator|-
literal|1
expr_stmt|;
continue|continue;
block|}
else|else
block|{
comment|/* couldn't match anything */
name|buf2
index|[
literal|0
index|]
operator|=
operator|*
name|sp
expr_stmt|;
name|buf2
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|buf
argument_list|,
name|TIC_EXPAND
argument_list|(
name|buf2
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/***************************************************************************  *  * File comparison  *  ***************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|file_comparison
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
define|#
directive|define
name|MAXCOMPARE
value|2
comment|/* someday we may allow comparisons on more files */
name|int
name|filecount
init|=
literal|0
decl_stmt|;
name|ENTRY
modifier|*
name|heads
index|[
name|MAXCOMPARE
index|]
decl_stmt|;
name|ENTRY
modifier|*
name|qp
decl_stmt|,
modifier|*
name|rp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
name|dump_init
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|F_LITERAL
argument_list|,
name|S_TERMINFO
argument_list|,
literal|0
argument_list|,
name|itrace
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|argc
operator|&&
name|n
operator|<
name|MAXCOMPARE
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|freopen
argument_list|(
name|argv
index|[
name|n
index|]
argument_list|,
literal|"r"
argument_list|,
name|stdin
argument_list|)
operator|==
literal|0
condition|)
name|_nc_err_abort
argument_list|(
literal|"Can't open %s"
argument_list|,
name|argv
index|[
name|n
index|]
argument_list|)
expr_stmt|;
name|_nc_head
operator|=
name|_nc_tail
operator|=
literal|0
expr_stmt|;
comment|/* parse entries out of the source file */
name|_nc_set_source
argument_list|(
name|argv
index|[
name|n
index|]
argument_list|)
expr_stmt|;
name|_nc_read_entry_source
argument_list|(
name|stdin
argument_list|,
name|NULL
argument_list|,
name|TRUE
argument_list|,
name|literal
argument_list|,
name|NULLHOOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|itrace
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Resolving file %d...\n"
argument_list|,
name|n
operator|-
literal|0
argument_list|)
expr_stmt|;
comment|/* maybe do use resolution */
if|if
condition|(
operator|!
name|_nc_resolve_uses2
argument_list|(
operator|!
name|limited
argument_list|,
name|literal
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"There are unresolved use entries in %s:\n"
argument_list|,
name|argv
index|[
name|n
index|]
argument_list|)
expr_stmt|;
name|for_entry_list
argument_list|(
argument|qp
argument_list|)
block|{
if|if
condition|(
name|qp
operator|->
name|nuses
condition|)
block|{
operator|(
name|void
operator|)
name|fputs
argument_list|(
name|qp
operator|->
name|tterm
operator|.
name|term_names
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
block|}
name|ExitProgram
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
name|heads
index|[
name|filecount
index|]
operator|=
name|_nc_head
expr_stmt|;
name|filecount
operator|++
expr_stmt|;
block|}
comment|/* OK, all entries are in core.  Ready to do the comparison */
if|if
condition|(
name|itrace
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Entries are now in core...\n"
argument_list|)
expr_stmt|;
comment|/* The entry-matching loop. Sigh, this is intrinsically quadratic. */
for|for
control|(
name|qp
operator|=
name|heads
index|[
literal|0
index|]
init|;
name|qp
condition|;
name|qp
operator|=
name|qp
operator|->
name|next
control|)
block|{
for|for
control|(
name|rp
operator|=
name|heads
index|[
literal|1
index|]
init|;
name|rp
condition|;
name|rp
operator|=
name|rp
operator|->
name|next
control|)
if|if
condition|(
name|_nc_entry_match
argument_list|(
name|qp
operator|->
name|tterm
operator|.
name|term_names
argument_list|,
name|rp
operator|->
name|tterm
operator|.
name|term_names
argument_list|)
condition|)
block|{
if|if
condition|(
name|qp
operator|->
name|ncrosslinks
operator|<
name|MAX_CROSSLINKS
condition|)
name|qp
operator|->
name|crosslinks
index|[
name|qp
operator|->
name|ncrosslinks
index|]
operator|=
name|rp
expr_stmt|;
name|qp
operator|->
name|ncrosslinks
operator|++
expr_stmt|;
if|if
condition|(
name|rp
operator|->
name|ncrosslinks
operator|<
name|MAX_CROSSLINKS
condition|)
name|rp
operator|->
name|crosslinks
index|[
name|rp
operator|->
name|ncrosslinks
index|]
operator|=
name|qp
expr_stmt|;
name|rp
operator|->
name|ncrosslinks
operator|++
expr_stmt|;
block|}
block|}
comment|/* now we have two circular lists with crosslinks */
if|if
condition|(
name|itrace
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Name matches are done...\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|qp
operator|=
name|heads
index|[
literal|0
index|]
init|;
name|qp
condition|;
name|qp
operator|=
name|qp
operator|->
name|next
control|)
block|{
if|if
condition|(
name|qp
operator|->
name|ncrosslinks
operator|>
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s in file 1 (%s) has %d matches in file 2 (%s):\n"
argument_list|,
name|_nc_first_name
argument_list|(
name|qp
operator|->
name|tterm
operator|.
name|term_names
argument_list|)
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|qp
operator|->
name|ncrosslinks
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|qp
operator|->
name|ncrosslinks
condition|;
name|i
operator|++
control|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t%s\n"
argument_list|,
name|_nc_first_name
argument_list|(
operator|(
name|qp
operator|->
name|crosslinks
index|[
name|i
index|]
operator|)
operator|->
name|tterm
operator|.
name|term_names
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|rp
operator|=
name|heads
index|[
literal|1
index|]
init|;
name|rp
condition|;
name|rp
operator|=
name|rp
operator|->
name|next
control|)
block|{
if|if
condition|(
name|rp
operator|->
name|ncrosslinks
operator|>
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s in file 2 (%s) has %d matches in file 1 (%s):\n"
argument_list|,
name|_nc_first_name
argument_list|(
name|rp
operator|->
name|tterm
operator|.
name|term_names
argument_list|)
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
name|rp
operator|->
name|ncrosslinks
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rp
operator|->
name|ncrosslinks
condition|;
name|i
operator|++
control|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t%s\n"
argument_list|,
name|_nc_first_name
argument_list|(
operator|(
name|rp
operator|->
name|crosslinks
index|[
name|i
index|]
operator|)
operator|->
name|tterm
operator|.
name|term_names
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"In file 1 (%s) only:\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|qp
operator|=
name|heads
index|[
literal|0
index|]
init|;
name|qp
condition|;
name|qp
operator|=
name|qp
operator|->
name|next
control|)
if|if
condition|(
name|qp
operator|->
name|ncrosslinks
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\t%s\n"
argument_list|,
name|_nc_first_name
argument_list|(
name|qp
operator|->
name|tterm
operator|.
name|term_names
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"In file 2 (%s) only:\n"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|rp
operator|=
name|heads
index|[
literal|1
index|]
init|;
name|rp
condition|;
name|rp
operator|=
name|rp
operator|->
name|next
control|)
if|if
condition|(
name|rp
operator|->
name|ncrosslinks
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\t%s\n"
argument_list|,
name|_nc_first_name
argument_list|(
name|rp
operator|->
name|tterm
operator|.
name|term_names
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"The following entries are equivalent:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|qp
operator|=
name|heads
index|[
literal|0
index|]
init|;
name|qp
condition|;
name|qp
operator|=
name|qp
operator|->
name|next
control|)
block|{
name|rp
operator|=
name|qp
operator|->
name|crosslinks
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|ncrosslinks
operator|==
literal|1
condition|)
block|{
name|rp
operator|=
name|qp
operator|->
name|crosslinks
index|[
literal|0
index|]
expr_stmt|;
name|repair_acsc
argument_list|(
operator|&
name|qp
operator|->
name|tterm
argument_list|)
expr_stmt|;
name|repair_acsc
argument_list|(
operator|&
name|rp
operator|->
name|tterm
argument_list|)
expr_stmt|;
if|#
directive|if
name|NCURSES_XNAMES
name|_nc_align_termtype
argument_list|(
operator|&
name|qp
operator|->
name|tterm
argument_list|,
operator|&
name|rp
operator|->
name|tterm
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|entryeq
argument_list|(
operator|&
name|qp
operator|->
name|tterm
argument_list|,
operator|&
name|rp
operator|->
name|tterm
argument_list|)
operator|&&
name|useeq
argument_list|(
name|qp
argument_list|,
name|rp
argument_list|)
condition|)
block|{
name|char
name|name1
index|[
name|NAMESIZE
index|]
decl_stmt|,
name|name2
index|[
name|NAMESIZE
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|canonical_name
argument_list|(
name|qp
operator|->
name|tterm
operator|.
name|term_names
argument_list|,
name|name1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|canonical_name
argument_list|(
name|rp
operator|->
name|tterm
operator|.
name|term_names
argument_list|,
name|name2
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s = %s\n"
argument_list|,
name|name1
argument_list|,
name|name2
argument_list|)
expr_stmt|;
block|}
block|}
block|}
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"Differing entries:\n"
argument_list|)
expr_stmt|;
name|termcount
operator|=
literal|2
expr_stmt|;
for|for
control|(
name|qp
operator|=
name|heads
index|[
literal|0
index|]
init|;
name|qp
condition|;
name|qp
operator|=
name|qp
operator|->
name|next
control|)
block|{
if|if
condition|(
name|qp
operator|->
name|ncrosslinks
operator|==
literal|1
condition|)
block|{
name|rp
operator|=
name|qp
operator|->
name|crosslinks
index|[
literal|0
index|]
expr_stmt|;
if|#
directive|if
name|NCURSES_XNAMES
comment|/* sorry - we have to do this on each pass */
name|_nc_align_termtype
argument_list|(
operator|&
name|qp
operator|->
name|tterm
argument_list|,
operator|&
name|rp
operator|->
name|tterm
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
operator|(
name|entryeq
argument_list|(
operator|&
name|qp
operator|->
name|tterm
argument_list|,
operator|&
name|rp
operator|->
name|tterm
argument_list|)
operator|&&
name|useeq
argument_list|(
name|qp
argument_list|,
name|rp
argument_list|)
operator|)
condition|)
block|{
name|char
name|name1
index|[
name|NAMESIZE
index|]
decl_stmt|,
name|name2
index|[
name|NAMESIZE
index|]
decl_stmt|;
name|entries
index|[
literal|0
index|]
operator|=
operator|*
name|qp
expr_stmt|;
name|entries
index|[
literal|1
index|]
operator|=
operator|*
name|rp
expr_stmt|;
operator|(
name|void
operator|)
name|canonical_name
argument_list|(
name|qp
operator|->
name|tterm
operator|.
name|term_names
argument_list|,
name|name1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|canonical_name
argument_list|(
name|rp
operator|->
name|tterm
operator|.
name|term_names
argument_list|,
name|name2
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|compare
condition|)
block|{
case|case
name|C_DIFFERENCE
case|:
if|if
condition|(
name|itrace
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"infocmp: dumping differences\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"comparing %s to %s.\n"
argument_list|,
name|name1
argument_list|,
name|name2
argument_list|)
expr_stmt|;
name|compare_entry
argument_list|(
name|compare_predicate
argument_list|,
operator|&
name|entries
operator|->
name|tterm
argument_list|,
name|quiet
argument_list|)
expr_stmt|;
break|break;
case|case
name|C_COMMON
case|:
if|if
condition|(
name|itrace
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"infocmp: dumping common capabilities\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"comparing %s to %s.\n"
argument_list|,
name|name1
argument_list|,
name|name2
argument_list|)
expr_stmt|;
name|compare_entry
argument_list|(
name|compare_predicate
argument_list|,
operator|&
name|entries
operator|->
name|tterm
argument_list|,
name|quiet
argument_list|)
expr_stmt|;
break|break;
case|case
name|C_NAND
case|:
if|if
condition|(
name|itrace
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"infocmp: dumping differences\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"comparing %s to %s.\n"
argument_list|,
name|name1
argument_list|,
name|name2
argument_list|)
expr_stmt|;
name|compare_entry
argument_list|(
name|compare_predicate
argument_list|,
operator|&
name|entries
operator|->
name|tterm
argument_list|,
name|quiet
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|tbl
index|[]
init|=
block|{
literal|"Usage: infocmp [options] [-A directory] [-B directory] [termname...]"
block|,
literal|""
block|,
literal|"Options:"
block|,
literal|"  -1    print single-column"
block|,
literal|"  -C    use termcap-names"
block|,
literal|"  -F    compare terminfo-files"
block|,
literal|"  -I    use terminfo-names"
block|,
literal|"  -L    use long names"
block|,
literal|"  -R subset (see manpage)"
block|,
literal|"  -T    eliminate size limits (test)"
block|,
literal|"  -U    eliminate post-processing of entries"
block|,
literal|"  -V    print version"
if|#
directive|if
name|NCURSES_XNAMES
block|,
literal|"  -a    with -F, list commented-out caps"
endif|#
directive|endif
block|,
literal|"  -c    list common capabilities"
block|,
literal|"  -d    list different capabilities"
block|,
literal|"  -e    format output for C initializer"
block|,
literal|"  -E    format output as C tables"
block|,
literal|"  -f    with -1, format complex strings"
block|,
literal|"  -G    format %{number} to %'char'"
block|,
literal|"  -g    format %'char' to %{number}"
block|,
literal|"  -i    analyze initialization/reset"
block|,
literal|"  -l    output terminfo names"
block|,
literal|"  -n    list capabilities in neither"
block|,
literal|"  -p    ignore padding specifiers"
block|,
literal|"  -q    brief listing, removes headers"
block|,
literal|"  -r    with -C, output in termcap form"
block|,
literal|"  -r    with -F, resolve use-references"
block|,
literal|"  -s [d|i|l|c] sort fields"
if|#
directive|if
name|NCURSES_XNAMES
block|,
literal|"  -t    suppress commented-out capabilities"
endif|#
directive|endif
block|,
literal|"  -u    produce source with 'use='"
block|,
literal|"  -v number  (verbose)"
block|,
literal|"  -w number  (width)"
if|#
directive|if
name|NCURSES_XNAMES
block|,
literal|"  -x    treat unknown capabilities as user-defined"
endif|#
directive|endif
block|}
decl_stmt|;
specifier|const
name|size_t
name|first
init|=
literal|3
decl_stmt|;
specifier|const
name|size_t
name|last
init|=
name|SIZEOF
argument_list|(
name|tbl
argument_list|)
decl_stmt|;
specifier|const
name|size_t
name|left
init|=
operator|(
name|last
operator|-
name|first
operator|+
literal|1
operator|)
operator|/
literal|2
operator|+
name|first
decl_stmt|;
name|size_t
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|left
condition|;
name|n
operator|++
control|)
block|{
name|size_t
name|m
init|=
operator|(
name|n
operator|<
name|first
operator|)
condition|?
name|last
else|:
name|n
operator|+
name|left
operator|-
name|first
decl_stmt|;
if|if
condition|(
name|m
operator|<
name|last
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%-40.40s%s\n"
argument_list|,
name|tbl
index|[
name|n
index|]
argument_list|,
name|tbl
index|[
name|m
index|]
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|tbl
index|[
name|n
index|]
argument_list|)
expr_stmt|;
block|}
name|ExitProgram
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|any_initializer
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
specifier|const
name|char
modifier|*
name|type
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|initializer
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|initializer
operator|==
literal|0
condition|)
name|initializer
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|entries
operator|->
name|tterm
operator|.
name|term_names
argument_list|)
operator|+
name|strlen
argument_list|(
name|type
argument_list|)
operator|+
name|strlen
argument_list|(
name|fmt
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|initializer
argument_list|,
name|entries
operator|->
name|tterm
operator|.
name|term_names
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|=
name|initializer
init|;
operator|*
name|s
operator|!=
literal|0
operator|&&
operator|*
name|s
operator|!=
literal|'|'
condition|;
name|s
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|isalnum
argument_list|(
name|UChar
argument_list|(
operator|*
name|s
argument_list|)
argument_list|)
condition|)
operator|*
name|s
operator|=
literal|'_'
expr_stmt|;
block|}
operator|*
name|s
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|s
argument_list|,
name|fmt
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|initializer
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|name_initializer
parameter_list|(
specifier|const
name|char
modifier|*
name|type
parameter_list|)
block|{
return|return
name|any_initializer
argument_list|(
literal|"_%s_data"
argument_list|,
name|type
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|string_variable
parameter_list|(
specifier|const
name|char
modifier|*
name|type
parameter_list|)
block|{
return|return
name|any_initializer
argument_list|(
literal|"_s_%s"
argument_list|,
name|type
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* dump C initializers for the terminal type */
end_comment

begin_function
specifier|static
name|void
name|dump_initializers
parameter_list|(
name|TERMTYPE
modifier|*
name|term
parameter_list|)
block|{
name|unsigned
name|n
decl_stmt|;
name|int
name|size
decl_stmt|;
specifier|const
name|char
modifier|*
name|str
init|=
literal|0
decl_stmt|;
name|printf
argument_list|(
literal|"\nstatic char %s[] = \"%s\";\n\n"
argument_list|,
name|name_initializer
argument_list|(
literal|"alias"
argument_list|)
argument_list|,
name|entries
operator|->
name|tterm
operator|.
name|term_names
argument_list|)
expr_stmt|;
name|for_each_string
argument_list|(
argument|n
argument_list|,
argument|term
argument_list|)
block|{
name|char
name|buf
index|[
name|MAX_STRING
index|]
decl_stmt|,
modifier|*
name|sp
decl_stmt|,
modifier|*
name|tp
decl_stmt|;
if|if
condition|(
name|VALID_STRING
argument_list|(
name|term
operator|->
name|Strings
index|[
name|n
index|]
argument_list|)
condition|)
block|{
name|tp
operator|=
name|buf
expr_stmt|;
operator|*
name|tp
operator|++
operator|=
literal|'"'
expr_stmt|;
for|for
control|(
name|sp
operator|=
name|term
operator|->
name|Strings
index|[
name|n
index|]
init|;
operator|*
name|sp
operator|!=
literal|0
operator|&&
operator|(
name|tp
operator|-
name|buf
operator|)
operator|<
name|MAX_STRING
operator|-
literal|6
condition|;
name|sp
operator|++
control|)
block|{
if|if
condition|(
name|isascii
argument_list|(
name|UChar
argument_list|(
operator|*
name|sp
argument_list|)
argument_list|)
operator|&&
name|isprint
argument_list|(
name|UChar
argument_list|(
operator|*
name|sp
argument_list|)
argument_list|)
operator|&&
operator|*
name|sp
operator|!=
literal|'\\'
operator|&&
operator|*
name|sp
operator|!=
literal|'"'
condition|)
operator|*
name|tp
operator|++
operator|=
operator|*
name|sp
expr_stmt|;
else|else
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|tp
argument_list|,
literal|"\\%03o"
argument_list|,
name|UChar
argument_list|(
operator|*
name|sp
argument_list|)
argument_list|)
expr_stmt|;
name|tp
operator|+=
literal|4
expr_stmt|;
block|}
block|}
operator|*
name|tp
operator|++
operator|=
literal|'"'
expr_stmt|;
operator|*
name|tp
operator|=
literal|'\0'
expr_stmt|;
name|size
operator|+=
operator|(
name|strlen
argument_list|(
name|term
operator|->
name|Strings
index|[
name|n
index|]
argument_list|)
operator|+
literal|1
operator|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"static char %-20s[] = %s;\n"
argument_list|,
name|string_variable
argument_list|(
name|ExtStrname
argument_list|(
name|term
argument_list|,
name|n
argument_list|,
name|strnames
argument_list|)
argument_list|)
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"static char %s[] = %s\n"
argument_list|,
name|name_initializer
argument_list|(
literal|"bool"
argument_list|)
argument_list|,
name|L_CURL
argument_list|)
expr_stmt|;
name|for_each_boolean
argument_list|(
argument|n
argument_list|,
argument|term
argument_list|)
block|{
switch|switch
condition|(
call|(
name|int
call|)
argument_list|(
name|term
operator|->
name|Booleans
index|[
name|n
index|]
argument_list|)
condition|)
block|{
case|case
name|TRUE
case|:
name|str
operator|=
literal|"TRUE"
expr_stmt|;
break|break;
case|case
name|FALSE
case|:
name|str
operator|=
literal|"FALSE"
expr_stmt|;
break|break;
case|case
name|ABSENT_BOOLEAN
case|:
name|str
operator|=
literal|"ABSENT_BOOLEAN"
expr_stmt|;
break|break;
case|case
name|CANCELLED_BOOLEAN
case|:
name|str
operator|=
literal|"CANCELLED_BOOLEAN"
expr_stmt|;
break|break;
block|}
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\t/* %3u: %-8s */\t%s,\n"
argument_list|,
name|n
argument_list|,
name|ExtBoolname
argument_list|(
name|term
argument_list|,
name|n
argument_list|,
name|boolnames
argument_list|)
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s;\n"
argument_list|,
name|R_CURL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"static short %s[] = %s\n"
argument_list|,
name|name_initializer
argument_list|(
literal|"number"
argument_list|)
argument_list|,
name|L_CURL
argument_list|)
expr_stmt|;
name|for_each_number
argument_list|(
argument|n
argument_list|,
argument|term
argument_list|)
block|{
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
switch|switch
condition|(
name|term
operator|->
name|Numbers
index|[
name|n
index|]
condition|)
block|{
case|case
name|ABSENT_NUMERIC
case|:
name|str
operator|=
literal|"ABSENT_NUMERIC"
expr_stmt|;
break|break;
case|case
name|CANCELLED_NUMERIC
case|:
name|str
operator|=
literal|"CANCELLED_NUMERIC"
expr_stmt|;
break|break;
default|default:
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d"
argument_list|,
name|term
operator|->
name|Numbers
index|[
name|n
index|]
argument_list|)
expr_stmt|;
name|str
operator|=
name|buf
expr_stmt|;
break|break;
block|}
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\t/* %3u: %-8s */\t%s,\n"
argument_list|,
name|n
argument_list|,
name|ExtNumname
argument_list|(
name|term
argument_list|,
name|n
argument_list|,
name|numnames
argument_list|)
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s;\n"
argument_list|,
name|R_CURL
argument_list|)
expr_stmt|;
name|size
operator|=
operator|(
sizeof|sizeof
argument_list|(
name|TERMTYPE
argument_list|)
operator|+
operator|(
name|NUM_BOOLEANS
argument_list|(
name|term
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|term
operator|->
name|Booleans
index|[
literal|0
index|]
argument_list|)
operator|)
operator|+
operator|(
name|NUM_NUMBERS
argument_list|(
name|term
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|term
operator|->
name|Numbers
index|[
literal|0
index|]
argument_list|)
operator|)
operator|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"static char * %s[] = %s\n"
argument_list|,
name|name_initializer
argument_list|(
literal|"string"
argument_list|)
argument_list|,
name|L_CURL
argument_list|)
expr_stmt|;
name|for_each_string
argument_list|(
argument|n
argument_list|,
argument|term
argument_list|)
block|{
if|if
condition|(
name|term
operator|->
name|Strings
index|[
name|n
index|]
operator|==
name|ABSENT_STRING
condition|)
name|str
operator|=
literal|"ABSENT_STRING"
expr_stmt|;
elseif|else
if|if
condition|(
name|term
operator|->
name|Strings
index|[
name|n
index|]
operator|==
name|CANCELLED_STRING
condition|)
name|str
operator|=
literal|"CANCELLED_STRING"
expr_stmt|;
else|else
block|{
name|str
operator|=
name|string_variable
argument_list|(
name|ExtStrname
argument_list|(
name|term
argument_list|,
name|n
argument_list|,
name|strnames
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\t/* %3u: %-8s */\t%s,\n"
argument_list|,
name|n
argument_list|,
name|ExtStrname
argument_list|(
name|term
argument_list|,
name|n
argument_list|,
name|strnames
argument_list|)
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s;\n"
argument_list|,
name|R_CURL
argument_list|)
expr_stmt|;
if|#
directive|if
name|NCURSES_XNAMES
if|if
condition|(
operator|(
name|NUM_BOOLEANS
argument_list|(
name|term
argument_list|)
operator|!=
name|BOOLCOUNT
operator|)
operator|||
operator|(
name|NUM_NUMBERS
argument_list|(
name|term
argument_list|)
operator|!=
name|NUMCOUNT
operator|)
operator|||
operator|(
name|NUM_STRINGS
argument_list|(
name|term
argument_list|)
operator|!=
name|STRCOUNT
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"static char * %s[] = %s\n"
argument_list|,
name|name_initializer
argument_list|(
literal|"string_ext"
argument_list|)
argument_list|,
name|L_CURL
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
name|BOOLCOUNT
init|;
name|n
operator|<
name|NUM_BOOLEANS
argument_list|(
name|term
argument_list|)
condition|;
operator|++
name|n
control|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\t/* %3u: bool */\t\"%s\",\n"
argument_list|,
name|n
argument_list|,
name|ExtBoolname
argument_list|(
name|term
argument_list|,
name|n
argument_list|,
name|boolnames
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|n
operator|=
name|NUMCOUNT
init|;
name|n
operator|<
name|NUM_NUMBERS
argument_list|(
name|term
argument_list|)
condition|;
operator|++
name|n
control|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\t/* %3u: num */\t\"%s\",\n"
argument_list|,
name|n
argument_list|,
name|ExtNumname
argument_list|(
name|term
argument_list|,
name|n
argument_list|,
name|numnames
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|n
operator|=
name|STRCOUNT
init|;
name|n
operator|<
name|NUM_STRINGS
argument_list|(
name|term
argument_list|)
condition|;
operator|++
name|n
control|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\t/* %3u: str */\t\"%s\",\n"
argument_list|,
name|n
argument_list|,
name|ExtStrname
argument_list|(
name|term
argument_list|,
name|n
argument_list|,
name|strnames
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s;\n"
argument_list|,
name|R_CURL
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* dump C initializers for the terminal type */
end_comment

begin_function
specifier|static
name|void
name|dump_termtype
parameter_list|(
name|TERMTYPE
modifier|*
name|term
parameter_list|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\t%s\n\t\t%s,\n"
argument_list|,
name|L_CURL
argument_list|,
name|name_initializer
argument_list|(
literal|"alias"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\t\t(char *)0,\t/* pointer to string table */\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\t\t%s,\n"
argument_list|,
name|name_initializer
argument_list|(
literal|"bool"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\t\t%s,\n"
argument_list|,
name|name_initializer
argument_list|(
literal|"number"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\t\t%s,\n"
argument_list|,
name|name_initializer
argument_list|(
literal|"string"
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|NCURSES_XNAMES
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"#if NCURSES_XNAMES\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\t\t(char *)0,\t/* pointer to extended string table */\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\t\t%s,\t/* ...corresponding names */\n"
argument_list|,
operator|(
operator|(
name|NUM_BOOLEANS
argument_list|(
name|term
argument_list|)
operator|!=
name|BOOLCOUNT
operator|)
operator|||
operator|(
name|NUM_NUMBERS
argument_list|(
name|term
argument_list|)
operator|!=
name|NUMCOUNT
operator|)
operator|||
operator|(
name|NUM_STRINGS
argument_list|(
name|term
argument_list|)
operator|!=
name|STRCOUNT
operator|)
operator|)
condition|?
name|name_initializer
argument_list|(
literal|"string_ext"
argument_list|)
else|:
literal|"(char **)0"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\t\t%d,\t\t/* count total Booleans */\n"
argument_list|,
name|NUM_BOOLEANS
argument_list|(
name|term
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\t\t%d,\t\t/* count total Numbers */\n"
argument_list|,
name|NUM_NUMBERS
argument_list|(
name|term
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\t\t%d,\t\t/* count total Strings */\n"
argument_list|,
name|NUM_STRINGS
argument_list|(
name|term
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\t\t%d,\t\t/* count extensions to Booleans */\n"
argument_list|,
name|NUM_BOOLEANS
argument_list|(
name|term
argument_list|)
operator|-
name|BOOLCOUNT
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\t\t%d,\t\t/* count extensions to Numbers */\n"
argument_list|,
name|NUM_NUMBERS
argument_list|(
name|term
argument_list|)
operator|-
name|NUMCOUNT
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\t\t%d,\t\t/* count extensions to Strings */\n"
argument_list|,
name|NUM_STRINGS
argument_list|(
name|term
argument_list|)
operator|-
name|STRCOUNT
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"#endif /* NCURSES_XNAMES */\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* NCURSES_XNAMES */
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\t%s\n"
argument_list|,
name|R_CURL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|optarg_to_number
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|temp
init|=
literal|0
decl_stmt|;
name|long
name|value
init|=
name|strtol
argument_list|(
name|optarg
argument_list|,
operator|&
name|temp
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|temp
operator|==
literal|0
operator|||
name|temp
operator|==
name|optarg
operator|||
operator|*
name|temp
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Expected a number, not \"%s\"\n"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|ExitProgram
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|int
operator|)
name|value
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|terminal_env
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|terminal
decl_stmt|;
if|if
condition|(
operator|(
name|terminal
operator|=
name|getenv
argument_list|(
literal|"TERM"
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"infocmp: environment variable TERM not set\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
return|return
name|terminal
return|;
block|}
end_function

begin_comment
comment|/***************************************************************************  *  * Main sequence  *  ***************************************************************************/
end_comment

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|char
modifier|*
name|firstdir
decl_stmt|,
modifier|*
name|restdir
decl_stmt|;
comment|/* Avoid "local data>32k" error with mwcc */
comment|/* Also avoid overflowing smaller stacks on systems like AmigaOS */
name|path
modifier|*
name|tfile
init|=
operator|(
name|path
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|path
argument_list|)
operator|*
name|MAXTERMS
argument_list|)
decl_stmt|;
name|int
name|c
decl_stmt|,
name|i
decl_stmt|,
name|len
decl_stmt|;
name|bool
name|formatted
init|=
name|FALSE
decl_stmt|;
name|bool
name|filecompare
init|=
name|FALSE
decl_stmt|;
name|int
name|initdump
init|=
literal|0
decl_stmt|;
name|bool
name|init_analyze
init|=
name|FALSE
decl_stmt|;
name|bool
name|suppress_untranslatable
init|=
name|FALSE
decl_stmt|;
comment|/* where is the terminfo database location going to default to? */
name|restdir
operator|=
name|firstdir
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|NCURSES_XNAMES
name|use_extended_names
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"1A:aB:CcdEeFfGgIiLlnpqR:rs:TtUuVv:w:x"
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'1'
case|:
name|mwidth
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
name|firstdir
operator|=
name|optarg
expr_stmt|;
break|break;
if|#
directive|if
name|NCURSES_XNAMES
case|case
literal|'a'
case|:
name|_nc_disable_period
operator|=
name|TRUE
expr_stmt|;
name|use_extended_names
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'B'
case|:
name|restdir
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
name|outform
operator|=
name|F_TERMCAP
expr_stmt|;
name|tversion
operator|=
literal|"BSD"
expr_stmt|;
if|if
condition|(
name|sortmode
operator|==
name|S_DEFAULT
condition|)
name|sortmode
operator|=
name|S_TERMCAP
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|compare
operator|=
name|C_COMMON
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|compare
operator|=
name|C_DIFFERENCE
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
name|initdump
operator||=
literal|2
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|initdump
operator||=
literal|1
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
name|filecompare
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|formatted
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'G'
case|:
name|numbers
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|numbers
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
name|outform
operator|=
name|F_TERMINFO
expr_stmt|;
if|if
condition|(
name|sortmode
operator|==
name|S_DEFAULT
condition|)
name|sortmode
operator|=
name|S_VARIABLE
expr_stmt|;
name|tversion
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|init_analyze
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
name|outform
operator|=
name|F_VARIABLE
expr_stmt|;
if|if
condition|(
name|sortmode
operator|==
name|S_DEFAULT
condition|)
name|sortmode
operator|=
name|S_VARIABLE
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|outform
operator|=
name|F_TERMINFO
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|compare
operator|=
name|C_NAND
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|ignorepads
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|quiet
operator|=
name|TRUE
expr_stmt|;
name|s_absent
operator|=
literal|"-"
expr_stmt|;
name|s_cancel
operator|=
literal|"@"
expr_stmt|;
name|bool_sep
operator|=
literal|", "
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|tversion
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|tversion
operator|=
literal|0
expr_stmt|;
name|limited
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
if|if
condition|(
operator|*
name|optarg
operator|==
literal|'d'
condition|)
name|sortmode
operator|=
name|S_NOSORT
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|optarg
operator|==
literal|'i'
condition|)
name|sortmode
operator|=
name|S_TERMINFO
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|optarg
operator|==
literal|'l'
condition|)
name|sortmode
operator|=
name|S_VARIABLE
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|optarg
operator|==
literal|'c'
condition|)
name|sortmode
operator|=
name|S_TERMCAP
expr_stmt|;
else|else
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"infocmp: unknown sort mode\n"
argument_list|)
expr_stmt|;
name|ExitProgram
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'T'
case|:
name|limited
operator|=
name|FALSE
expr_stmt|;
break|break;
if|#
directive|if
name|NCURSES_XNAMES
case|case
literal|'t'
case|:
name|_nc_disable_period
operator|=
name|FALSE
expr_stmt|;
name|suppress_untranslatable
operator|=
name|TRUE
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'U'
case|:
name|literal
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|compare
operator|=
name|C_USEALL
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
name|puts
argument_list|(
name|curses_version
argument_list|()
argument_list|)
expr_stmt|;
name|ExitProgram
argument_list|(
name|EXIT_SUCCESS
argument_list|)
expr_stmt|;
case|case
literal|'v'
case|:
name|itrace
operator|=
name|optarg_to_number
argument_list|()
expr_stmt|;
name|set_trace_level
argument_list|(
name|itrace
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|mwidth
operator|=
name|optarg_to_number
argument_list|()
expr_stmt|;
break|break;
if|#
directive|if
name|NCURSES_XNAMES
case|case
literal|'x'
case|:
name|use_extended_names
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|usage
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* by default, sort by terminfo name */
if|if
condition|(
name|sortmode
operator|==
name|S_DEFAULT
condition|)
name|sortmode
operator|=
name|S_TERMINFO
expr_stmt|;
comment|/* set up for display */
name|dump_init
argument_list|(
name|tversion
argument_list|,
name|outform
argument_list|,
name|sortmode
argument_list|,
name|mwidth
argument_list|,
name|itrace
argument_list|,
name|formatted
argument_list|)
expr_stmt|;
comment|/* make sure we have at least one terminal name to work with */
if|if
condition|(
name|optind
operator|>=
name|argc
condition|)
name|argv
index|[
name|argc
operator|++
index|]
operator|=
name|terminal_env
argument_list|()
expr_stmt|;
comment|/* if user is after a comparison, make sure we have two entries */
if|if
condition|(
name|compare
operator|!=
name|C_DEFAULT
operator|&&
name|optind
operator|>=
name|argc
operator|-
literal|1
condition|)
name|argv
index|[
name|argc
operator|++
index|]
operator|=
name|terminal_env
argument_list|()
expr_stmt|;
comment|/* exactly two terminal names with no options means do -d */
if|if
condition|(
name|argc
operator|-
name|optind
operator|==
literal|2
operator|&&
name|compare
operator|==
name|C_DEFAULT
condition|)
name|compare
operator|=
name|C_DIFFERENCE
expr_stmt|;
if|if
condition|(
operator|!
name|filecompare
condition|)
block|{
comment|/* grab the entries */
name|termcount
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|optind
operator|<
name|argc
condition|;
name|optind
operator|++
control|)
block|{
if|if
condition|(
name|termcount
operator|>=
name|MAXTERMS
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"infocmp: too many terminal type arguments\n"
argument_list|)
expr_stmt|;
name|ExitProgram
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|directory
init|=
name|termcount
condition|?
name|restdir
else|:
name|firstdir
decl_stmt|;
name|int
name|status
decl_stmt|;
name|tname
index|[
name|termcount
index|]
operator|=
name|argv
index|[
name|optind
index|]
expr_stmt|;
if|if
condition|(
name|directory
condition|)
block|{
if|#
directive|if
name|USE_DATABASE
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|tfile
index|[
name|termcount
index|]
argument_list|,
literal|"%s/%c/%s"
argument_list|,
name|directory
argument_list|,
operator|*
name|argv
index|[
name|optind
index|]
argument_list|,
name|argv
index|[
name|optind
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|itrace
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"infocmp: reading entry %s from file %s\n"
argument_list|,
name|argv
index|[
name|optind
index|]
argument_list|,
name|tfile
index|[
name|termcount
index|]
argument_list|)
expr_stmt|;
name|status
operator|=
name|_nc_read_file_entry
argument_list|(
name|tfile
index|[
name|termcount
index|]
argument_list|,
operator|&
name|entries
index|[
name|termcount
index|]
operator|.
name|tterm
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"terminfo files not supported\n"
argument_list|)
expr_stmt|;
name|ExitProgram
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
if|if
condition|(
name|itrace
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"infocmp: reading entry %s from database\n"
argument_list|,
name|tname
index|[
name|termcount
index|]
argument_list|)
expr_stmt|;
name|status
operator|=
name|_nc_read_entry
argument_list|(
name|tname
index|[
name|termcount
index|]
argument_list|,
name|tfile
index|[
name|termcount
index|]
argument_list|,
operator|&
name|entries
index|[
name|termcount
index|]
operator|.
name|tterm
argument_list|)
expr_stmt|;
name|directory
operator|=
name|TERMINFO
expr_stmt|;
comment|/* for error message */
block|}
if|if
condition|(
name|status
operator|<=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"infocmp: couldn't open terminfo file %s.\n"
argument_list|,
name|tfile
index|[
name|termcount
index|]
argument_list|)
expr_stmt|;
name|ExitProgram
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
name|repair_acsc
argument_list|(
operator|&
name|entries
index|[
name|termcount
index|]
operator|.
name|tterm
argument_list|)
expr_stmt|;
name|termcount
operator|++
expr_stmt|;
block|}
block|}
if|#
directive|if
name|NCURSES_XNAMES
if|if
condition|(
name|termcount
operator|>
literal|1
condition|)
name|_nc_align_termtype
argument_list|(
operator|&
name|entries
index|[
literal|0
index|]
operator|.
name|tterm
argument_list|,
operator|&
name|entries
index|[
literal|1
index|]
operator|.
name|tterm
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* dump as C initializer for the terminal type */
if|if
condition|(
name|initdump
condition|)
block|{
if|if
condition|(
name|initdump
operator|&
literal|1
condition|)
name|dump_termtype
argument_list|(
operator|&
name|entries
index|[
literal|0
index|]
operator|.
name|tterm
argument_list|)
expr_stmt|;
if|if
condition|(
name|initdump
operator|&
literal|2
condition|)
name|dump_initializers
argument_list|(
operator|&
name|entries
index|[
literal|0
index|]
operator|.
name|tterm
argument_list|)
expr_stmt|;
block|}
comment|/* analyze the init strings */
elseif|else
if|if
condition|(
name|init_analyze
condition|)
block|{
undef|#
directive|undef
name|CUR
define|#
directive|define
name|CUR
value|entries[0].tterm.
name|analyze_string
argument_list|(
literal|"is1"
argument_list|,
name|init_1string
argument_list|,
operator|&
name|entries
index|[
literal|0
index|]
operator|.
name|tterm
argument_list|)
expr_stmt|;
name|analyze_string
argument_list|(
literal|"is2"
argument_list|,
name|init_2string
argument_list|,
operator|&
name|entries
index|[
literal|0
index|]
operator|.
name|tterm
argument_list|)
expr_stmt|;
name|analyze_string
argument_list|(
literal|"is3"
argument_list|,
name|init_3string
argument_list|,
operator|&
name|entries
index|[
literal|0
index|]
operator|.
name|tterm
argument_list|)
expr_stmt|;
name|analyze_string
argument_list|(
literal|"rs1"
argument_list|,
name|reset_1string
argument_list|,
operator|&
name|entries
index|[
literal|0
index|]
operator|.
name|tterm
argument_list|)
expr_stmt|;
name|analyze_string
argument_list|(
literal|"rs2"
argument_list|,
name|reset_2string
argument_list|,
operator|&
name|entries
index|[
literal|0
index|]
operator|.
name|tterm
argument_list|)
expr_stmt|;
name|analyze_string
argument_list|(
literal|"rs3"
argument_list|,
name|reset_3string
argument_list|,
operator|&
name|entries
index|[
literal|0
index|]
operator|.
name|tterm
argument_list|)
expr_stmt|;
name|analyze_string
argument_list|(
literal|"smcup"
argument_list|,
name|enter_ca_mode
argument_list|,
operator|&
name|entries
index|[
literal|0
index|]
operator|.
name|tterm
argument_list|)
expr_stmt|;
name|analyze_string
argument_list|(
literal|"rmcup"
argument_list|,
name|exit_ca_mode
argument_list|,
operator|&
name|entries
index|[
literal|0
index|]
operator|.
name|tterm
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|CUR
block|}
else|else
block|{
comment|/* 	     * Here's where the real work gets done 	     */
switch|switch
condition|(
name|compare
condition|)
block|{
case|case
name|C_DEFAULT
case|:
if|if
condition|(
name|itrace
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"infocmp: about to dump %s\n"
argument_list|,
name|tname
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"#\tReconstructed via infocmp from file: %s\n"
argument_list|,
name|tfile
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|dump_entry
argument_list|(
operator|&
name|entries
index|[
literal|0
index|]
operator|.
name|tterm
argument_list|,
name|suppress_untranslatable
argument_list|,
name|limited
argument_list|,
name|numbers
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|len
operator|=
name|show_entry
argument_list|()
expr_stmt|;
if|if
condition|(
name|itrace
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"infocmp: length %d\n"
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|C_DIFFERENCE
case|:
if|if
condition|(
name|itrace
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"infocmp: dumping differences\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"comparing %s to %s.\n"
argument_list|,
name|tname
index|[
literal|0
index|]
argument_list|,
name|tname
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|compare_entry
argument_list|(
name|compare_predicate
argument_list|,
operator|&
name|entries
operator|->
name|tterm
argument_list|,
name|quiet
argument_list|)
expr_stmt|;
break|break;
case|case
name|C_COMMON
case|:
if|if
condition|(
name|itrace
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"infocmp: dumping common capabilities\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"comparing %s to %s.\n"
argument_list|,
name|tname
index|[
literal|0
index|]
argument_list|,
name|tname
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|compare_entry
argument_list|(
name|compare_predicate
argument_list|,
operator|&
name|entries
operator|->
name|tterm
argument_list|,
name|quiet
argument_list|)
expr_stmt|;
break|break;
case|case
name|C_NAND
case|:
if|if
condition|(
name|itrace
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"infocmp: dumping differences\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"comparing %s to %s.\n"
argument_list|,
name|tname
index|[
literal|0
index|]
argument_list|,
name|tname
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|compare_entry
argument_list|(
name|compare_predicate
argument_list|,
operator|&
name|entries
operator|->
name|tterm
argument_list|,
name|quiet
argument_list|)
expr_stmt|;
break|break;
case|case
name|C_USEALL
case|:
if|if
condition|(
name|itrace
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"infocmp: dumping use entry\n"
argument_list|)
expr_stmt|;
name|dump_entry
argument_list|(
operator|&
name|entries
index|[
literal|0
index|]
operator|.
name|tterm
argument_list|,
name|suppress_untranslatable
argument_list|,
name|limited
argument_list|,
name|numbers
argument_list|,
name|use_predicate
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|termcount
condition|;
name|i
operator|++
control|)
name|dump_uses
argument_list|(
name|tname
index|[
name|i
index|]
argument_list|,
operator|!
operator|(
name|outform
operator|==
name|F_TERMCAP
operator|||
name|outform
operator|==
name|F_TCONVERR
operator|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|show_entry
argument_list|()
expr_stmt|;
if|if
condition|(
name|itrace
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"infocmp: length %d\n"
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|compare
operator|==
name|C_USEALL
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Sorry, -u doesn't work with -F\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|compare
operator|==
name|C_DEFAULT
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Use `tic -[CI]<file>' for this.\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|argc
operator|-
name|optind
operator|!=
literal|2
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"File comparison needs exactly two file arguments.\n"
argument_list|)
expr_stmt|;
else|else
name|file_comparison
argument_list|(
name|argc
operator|-
name|optind
argument_list|,
name|argv
operator|+
name|optind
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tfile
argument_list|)
expr_stmt|;
name|ExitProgram
argument_list|(
name|EXIT_SUCCESS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* infocmp.c ends here */
end_comment

end_unit

