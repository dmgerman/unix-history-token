begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ** Copyright (C) 1991, 1997 Free Software Foundation, Inc. ** ** This file is part of TACK. ** ** TACK is free software; you can redistribute it and/or modify ** it under the terms of the GNU General Public License as published by ** the Free Software Foundation; either version 2, or (at your option) ** any later version. ** ** TACK is distributed in the hope that it will be useful, ** but WITHOUT ANY WARRANTY; without even the implied warranty of ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ** GNU General Public License for more details. ** ** You should have received a copy of the GNU General Public License ** along with TACK; see the file COPYING.  If not, write to ** the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, ** Boston, MA 02110-1301, USA */
end_comment

begin_include
include|#
directive|include
file|<tack.h>
end_include

begin_macro
name|MODULE_ID
argument_list|(
literal|"$Id: color.c,v 1.7 2006/11/26 00:14:25 tom Exp $"
argument_list|)
end_macro

begin_comment
comment|/*  * Color terminal tests.  Has only one entry point: test_color().  */
end_comment

begin_function_decl
specifier|static
name|void
name|color_check
parameter_list|(
name|struct
name|test_list
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|color_setf
parameter_list|(
name|struct
name|test_list
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|color_matrix
parameter_list|(
name|struct
name|test_list
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|color_ncv
parameter_list|(
name|struct
name|test_list
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|color_ccc
parameter_list|(
name|struct
name|test_list
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|color_bce
parameter_list|(
name|struct
name|test_list
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|test_list
name|color_test_list
index|[]
init|=
block|{
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|"e) edit terminfo"
block|,
literal|0
block|,
operator|&
name|edit_menu
block|}
block|,
block|{
name|MENU_NEXT
block|,
literal|2
block|,
literal|"colors) (pairs"
block|,
literal|0
block|,
literal|0
block|,
name|color_check
block|,
literal|0
block|}
block|,
block|{
name|MENU_NEXT
block|,
literal|12
block|,
literal|"setf) (setb) (scp"
block|,
literal|0
block|,
literal|0
block|,
name|color_setf
block|,
literal|0
block|}
block|,
block|{
name|MENU_NEXT
block|,
literal|24
block|,
literal|"op"
block|,
literal|0
block|,
literal|0
block|,
name|color_matrix
block|,
literal|0
block|}
block|,
block|{
name|MENU_NEXT
block|,
literal|16
block|,
literal|"ncv"
block|,
literal|0
block|,
literal|0
block|,
name|color_ncv
block|,
literal|0
block|}
block|,
block|{
name|MENU_NEXT
block|,
literal|0
block|,
literal|"bce"
block|,
literal|0
block|,
literal|0
block|,
name|color_bce
block|,
literal|0
block|}
block|,
block|{
name|MENU_NEXT
operator||
name|MENU_CLEAR
block|,
literal|0
block|,
literal|"ccc) (initc) (initp"
block|,
literal|"hls op oc"
block|,
literal|0
block|,
name|color_ccc
block|,
literal|0
block|}
block|,
block|{
name|MENU_LAST
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|COLOR_BLACK
end_ifndef

begin_define
define|#
directive|define
name|COLOR_BLACK
value|0
end_define

begin_define
define|#
directive|define
name|COLOR_BLUE
value|1
end_define

begin_define
define|#
directive|define
name|COLOR_GREEN
value|2
end_define

begin_define
define|#
directive|define
name|COLOR_CYAN
value|3
end_define

begin_define
define|#
directive|define
name|COLOR_RED
value|4
end_define

begin_define
define|#
directive|define
name|COLOR_MAGENTA
value|5
end_define

begin_define
define|#
directive|define
name|COLOR_YELLOW
value|6
end_define

begin_define
define|#
directive|define
name|COLOR_WHITE
value|7
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|color_table
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|index
decl_stmt|;
name|int
name|r
decl_stmt|,
name|g
decl_stmt|,
name|b
decl_stmt|;
name|int
name|h
decl_stmt|,
name|l
decl_stmt|,
name|s
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|color_table
name|def_colors
index|[
literal|8
index|]
init|=
block|{
block|{
literal|"black  "
block|,
name|COLOR_BLACK
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"blue   "
block|,
name|COLOR_BLUE
block|,
literal|0
block|,
literal|0
block|,
literal|1000
block|,
literal|330
block|,
literal|50
block|,
literal|100
block|}
block|,
block|{
literal|"green  "
block|,
name|COLOR_GREEN
block|,
literal|0
block|,
literal|1000
block|,
literal|0
block|,
literal|240
block|,
literal|50
block|,
literal|100
block|}
block|,
block|{
literal|"cyan   "
block|,
name|COLOR_CYAN
block|,
literal|0
block|,
literal|1000
block|,
literal|1000
block|,
literal|300
block|,
literal|50
block|,
literal|100
block|}
block|,
block|{
literal|"red    "
block|,
name|COLOR_RED
block|,
literal|1000
block|,
literal|0
block|,
literal|0
block|,
literal|120
block|,
literal|50
block|,
literal|100
block|}
block|,
block|{
literal|"magenta"
block|,
name|COLOR_MAGENTA
block|,
literal|1000
block|,
literal|0
block|,
literal|1000
block|,
literal|60
block|,
literal|50
block|,
literal|100
block|}
block|,
block|{
literal|"yellow "
block|,
name|COLOR_YELLOW
block|,
literal|1000
block|,
literal|1000
block|,
literal|0
block|,
literal|180
block|,
literal|50
block|,
literal|100
block|}
block|,
block|{
literal|"white  "
block|,
name|COLOR_WHITE
block|,
literal|1000
block|,
literal|1000
block|,
literal|1000
block|,
literal|0
block|,
literal|100
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|MAX_PAIR
value|256
end_define

begin_decl_stmt
specifier|static
name|int
name|fg_color
index|[
name|MAX_PAIR
index|]
init|=
block|{
name|COLOR_BLACK
block|,
name|COLOR_BLUE
block|,
name|COLOR_GREEN
block|,
name|COLOR_CYAN
block|,
name|COLOR_RED
block|,
name|COLOR_MAGENTA
block|,
name|COLOR_YELLOW
block|,
name|COLOR_WHITE
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|bg_color
index|[
name|MAX_PAIR
index|]
init|=
block|{
name|COLOR_BLACK
block|,
name|COLOR_BLACK
block|,
name|COLOR_BLACK
block|,
name|COLOR_BLACK
block|,
name|COLOR_BLACK
block|,
name|COLOR_BLACK
block|,
name|COLOR_BLACK
block|,
name|COLOR_BLACK
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pairs_used
init|=
literal|8
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|a_bright_color
decl_stmt|,
name|bright_value
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cookie_monster
decl_stmt|,
name|color_step
decl_stmt|,
name|colors_per_line
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|R
decl_stmt|,
name|G
decl_stmt|,
name|B
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|reset_colors
parameter_list|(
name|void
parameter_list|)
block|{
name|tc_putp
argument_list|(
name|orig_colors
argument_list|)
expr_stmt|;
name|tc_putp
argument_list|(
name|TPARM_0
argument_list|(
name|orig_pair
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|color_trans
parameter_list|(
name|int
name|c
parameter_list|)
block|{
comment|/* translate or load the color */
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pairs_used
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fg_color
index|[
name|i
index|]
operator|==
name|c
condition|)
block|{
return|return
name|i
return|;
block|}
block|}
if|if
condition|(
operator|!
name|can_change
condition|)
block|{
return|return
literal|0
return|;
block|}
if|if
condition|(
name|pairs_used
operator|>
name|max_colors
operator|||
name|pairs_used
operator|>=
name|MAX_PAIR
condition|)
block|{
name|pairs_used
operator|=
literal|0
expr_stmt|;
name|ptextln
argument_list|(
literal|"Ran out of colors"
argument_list|)
expr_stmt|;
block|}
name|fg_color
index|[
name|pairs_used
index|]
operator|=
name|c
expr_stmt|;
name|bg_color
index|[
name|pairs_used
index|]
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|hue_lightness_saturation
condition|)
block|{
name|tc_putp
argument_list|(
name|TPARM_4
argument_list|(
name|initialize_color
argument_list|,
name|pairs_used
argument_list|,
name|def_colors
index|[
name|c
index|]
operator|.
name|h
argument_list|,
name|def_colors
index|[
name|c
index|]
operator|.
name|l
argument_list|,
name|def_colors
index|[
name|c
index|]
operator|.
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tc_putp
argument_list|(
name|TPARM_4
argument_list|(
name|initialize_color
argument_list|,
name|pairs_used
argument_list|,
name|def_colors
index|[
name|c
index|]
operator|.
name|r
argument_list|,
name|def_colors
index|[
name|c
index|]
operator|.
name|g
argument_list|,
name|def_colors
index|[
name|c
index|]
operator|.
name|b
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|pairs_used
operator|++
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|new_color
parameter_list|(
name|int
name|fg
parameter_list|,
name|int
name|bg
parameter_list|,
name|int
name|hungry
parameter_list|)
block|{
comment|/* change the color to fg and bg. */
name|int
name|i
decl_stmt|;
if|if
condition|(
name|hungry
condition|)
block|{
name|eat_cookie
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|set_a_foreground
condition|)
block|{
comment|/* set ANSI color (setaf) (setab) */
name|tc_putp
argument_list|(
name|TPARM_1
argument_list|(
name|set_a_foreground
argument_list|,
name|fg
argument_list|)
argument_list|)
expr_stmt|;
name|tc_putp
argument_list|(
name|TPARM_1
argument_list|(
name|set_a_background
argument_list|,
name|bg
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|set_foreground
condition|)
block|{
comment|/* make sure black is zero */
operator|(
name|void
operator|)
name|color_trans
argument_list|(
name|COLOR_BLACK
argument_list|)
expr_stmt|;
name|tc_putp
argument_list|(
name|TPARM_1
argument_list|(
name|set_foreground
argument_list|,
name|color_trans
argument_list|(
name|fg
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|tc_putp
argument_list|(
name|TPARM_1
argument_list|(
name|set_background
argument_list|,
name|color_trans
argument_list|(
name|bg
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* set color pair */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pairs_used
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fg_color
index|[
name|i
index|]
operator|==
name|fg
operator|&&
name|bg_color
index|[
name|i
index|]
operator|==
name|bg
condition|)
block|{
name|tc_putp
argument_list|(
name|TPARM_1
argument_list|(
name|set_color_pair
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hungry
condition|)
block|{
name|eat_cookie
argument_list|()
expr_stmt|;
block|}
return|return;
block|}
block|}
if|if
condition|(
operator|!
name|can_change
condition|)
block|{
comment|/* try to set just the foreground */
for|for
control|(
name|i
operator|=
name|pairs_used
operator|-
literal|1
init|;
name|i
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fg_color
index|[
name|i
index|]
operator|==
name|fg
condition|)
break|break;
block|}
name|tc_putp
argument_list|(
name|TPARM_1
argument_list|(
name|set_color_pair
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hungry
condition|)
block|{
name|eat_cookie
argument_list|()
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|pairs_used
operator|>
name|max_pairs
operator|||
name|pairs_used
operator|>=
name|MAX_PAIR
condition|)
block|{
name|pairs_used
operator|=
literal|0
expr_stmt|;
name|ptextln
argument_list|(
literal|"Ran out of color pairs"
argument_list|)
expr_stmt|;
block|}
name|fg_color
index|[
name|pairs_used
index|]
operator|=
name|fg
expr_stmt|;
name|bg_color
index|[
name|pairs_used
index|]
operator|=
name|bg
expr_stmt|;
if|if
condition|(
name|hue_lightness_saturation
condition|)
block|{
name|tc_putp
argument_list|(
name|TPARM_7
argument_list|(
name|initialize_pair
argument_list|,
name|pairs_used
argument_list|,
name|def_colors
index|[
name|fg
index|]
operator|.
name|h
argument_list|,
name|def_colors
index|[
name|fg
index|]
operator|.
name|l
argument_list|,
name|def_colors
index|[
name|fg
index|]
operator|.
name|s
argument_list|,
name|def_colors
index|[
name|bg
index|]
operator|.
name|h
argument_list|,
name|def_colors
index|[
name|bg
index|]
operator|.
name|l
argument_list|,
name|def_colors
index|[
name|bg
index|]
operator|.
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tc_putp
argument_list|(
name|TPARM_7
argument_list|(
name|initialize_pair
argument_list|,
name|pairs_used
argument_list|,
name|def_colors
index|[
name|fg
index|]
operator|.
name|r
argument_list|,
name|def_colors
index|[
name|fg
index|]
operator|.
name|g
argument_list|,
name|def_colors
index|[
name|fg
index|]
operator|.
name|b
argument_list|,
name|def_colors
index|[
name|bg
index|]
operator|.
name|r
argument_list|,
name|def_colors
index|[
name|bg
index|]
operator|.
name|g
argument_list|,
name|def_colors
index|[
name|bg
index|]
operator|.
name|b
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|tc_putp
argument_list|(
name|TPARM_1
argument_list|(
name|set_color_pair
argument_list|,
name|pairs_used
argument_list|)
argument_list|)
expr_stmt|;
name|pairs_used
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|hungry
condition|)
block|{
name|eat_cookie
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|set_color_step
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* set the color_step for the (ccc) display */
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
literal|1000
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|i
operator|*
name|i
operator|*
name|i
operator|)
operator|>=
name|max_colors
condition|)
block|{
break|break;
block|}
block|}
name|color_step
operator|=
literal|1000
operator|/
operator|(
name|i
operator|-
literal|1
operator|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|rgb_2_hls
parameter_list|(
name|int
name|r
parameter_list|,
name|int
name|g
parameter_list|,
name|int
name|b
parameter_list|,
name|int
modifier|*
name|h
parameter_list|,
name|int
modifier|*
name|l
parameter_list|,
name|int
modifier|*
name|s
parameter_list|)
block|{
comment|/* convert RGB to HLS system */
name|int
name|min
decl_stmt|,
name|max
decl_stmt|,
name|t
decl_stmt|;
if|if
condition|(
operator|(
name|min
operator|=
name|g
operator|<
name|r
condition|?
name|g
else|:
name|r
operator|)
operator|>
name|b
condition|)
block|{
name|min
operator|=
name|b
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|max
operator|=
name|g
operator|>
name|r
condition|?
name|g
else|:
name|r
operator|)
operator|<
name|b
condition|)
block|{
name|max
operator|=
name|b
expr_stmt|;
block|}
comment|/* calculate lightness */
operator|*
name|l
operator|=
operator|(
name|min
operator|+
name|max
operator|)
operator|/
literal|20
expr_stmt|;
if|if
condition|(
name|min
operator|==
name|max
condition|)
block|{
comment|/* black, white and all shades of gray */
operator|*
name|h
operator|=
literal|0
expr_stmt|;
operator|*
name|s
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/* calculate saturation */
if|if
condition|(
operator|*
name|l
operator|<
literal|50
condition|)
block|{
operator|*
name|s
operator|=
operator|(
operator|(
name|max
operator|-
name|min
operator|)
operator|*
literal|100
operator|)
operator|/
operator|(
name|max
operator|+
name|min
operator|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|s
operator|=
operator|(
operator|(
name|max
operator|-
name|min
operator|)
operator|*
literal|100
operator|)
operator|/
operator|(
literal|2000
operator|-
name|max
operator|-
name|min
operator|)
expr_stmt|;
block|}
comment|/* calculate hue */
if|if
condition|(
name|r
operator|==
name|max
condition|)
block|{
name|t
operator|=
literal|120
operator|+
operator|(
operator|(
name|g
operator|-
name|b
operator|)
operator|*
literal|60
operator|)
operator|/
operator|(
name|max
operator|-
name|min
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|g
operator|==
name|max
condition|)
block|{
name|t
operator|=
literal|240
operator|+
operator|(
operator|(
name|b
operator|-
name|r
operator|)
operator|*
literal|60
operator|)
operator|/
operator|(
name|max
operator|-
name|min
operator|)
expr_stmt|;
block|}
else|else
block|{
name|t
operator|=
literal|360
operator|+
operator|(
operator|(
name|r
operator|-
name|g
operator|)
operator|*
literal|60
operator|)
operator|/
operator|(
name|max
operator|-
name|min
operator|)
expr_stmt|;
block|}
operator|*
name|h
operator|=
name|t
operator|%
literal|360
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|send_color
parameter_list|(
name|int
name|p
parameter_list|,
name|int
name|r
parameter_list|,
name|int
name|g
parameter_list|,
name|int
name|b
parameter_list|)
block|{
comment|/* send the initialize_color (initc) command */
name|int
name|h
decl_stmt|,
name|l
decl_stmt|,
name|s
decl_stmt|;
if|if
condition|(
name|hue_lightness_saturation
condition|)
block|{
name|rgb_2_hls
argument_list|(
name|r
argument_list|,
name|g
argument_list|,
name|b
argument_list|,
operator|&
name|h
argument_list|,
operator|&
name|l
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
name|tc_putp
argument_list|(
name|TPARM_4
argument_list|(
name|initialize_color
argument_list|,
name|p
argument_list|,
name|h
argument_list|,
name|l
argument_list|,
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tc_putp
argument_list|(
name|TPARM_4
argument_list|(
name|initialize_color
argument_list|,
name|p
argument_list|,
name|r
argument_list|,
name|g
argument_list|,
name|b
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|send_pair
parameter_list|(
name|int
name|p
parameter_list|,
name|int
name|fr
parameter_list|,
name|int
name|fg
parameter_list|,
name|int
name|fb
parameter_list|,
name|int
name|br
parameter_list|,
name|int
name|bg
parameter_list|,
name|int
name|bb
parameter_list|)
block|{
comment|/* send the initialize_pair (initp) command */
name|int
name|fh
decl_stmt|,
name|fl
decl_stmt|,
name|fs
decl_stmt|,
name|bh
decl_stmt|,
name|bl
decl_stmt|,
name|bs
decl_stmt|;
if|if
condition|(
name|hue_lightness_saturation
condition|)
block|{
name|rgb_2_hls
argument_list|(
name|fr
argument_list|,
name|fg
argument_list|,
name|fb
argument_list|,
operator|&
name|fh
argument_list|,
operator|&
name|fl
argument_list|,
operator|&
name|fs
argument_list|)
expr_stmt|;
name|rgb_2_hls
argument_list|(
name|br
argument_list|,
name|bg
argument_list|,
name|bb
argument_list|,
operator|&
name|bh
argument_list|,
operator|&
name|bl
argument_list|,
operator|&
name|bs
argument_list|)
expr_stmt|;
name|tc_putp
argument_list|(
name|TPARM_7
argument_list|(
name|initialize_pair
argument_list|,
name|p
argument_list|,
name|fh
argument_list|,
name|fl
argument_list|,
name|fs
argument_list|,
name|bh
argument_list|,
name|bl
argument_list|,
name|bs
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tc_putp
argument_list|(
name|TPARM_7
argument_list|(
name|initialize_pair
argument_list|,
name|p
argument_list|,
name|fr
argument_list|,
name|fg
argument_list|,
name|fb
argument_list|,
name|bb
argument_list|,
name|bg
argument_list|,
name|bb
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|load_palette
parameter_list|(
name|int
name|n
parameter_list|)
block|{
comment|/* load the color palette */
name|int
name|rgb
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|pairs_used
operator|>=
name|n
condition|)
block|{
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|set_a_foreground
operator|||
name|set_foreground
condition|)
block|{
if|if
condition|(
name|pairs_used
operator|>=
name|max_colors
condition|)
block|{
return|return
name|FALSE
return|;
block|}
name|send_color
argument_list|(
name|pairs_used
argument_list|,
name|R
argument_list|,
name|G
argument_list|,
name|B
argument_list|)
expr_stmt|;
name|rgb
operator|=
name|R
operator|+
name|G
operator|+
name|B
expr_stmt|;
if|if
condition|(
name|rgb
operator|>
name|bright_value
condition|)
block|{
name|bright_value
operator|=
name|rgb
expr_stmt|;
name|a_bright_color
operator|=
name|pairs_used
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|pairs_used
operator|>=
name|max_pairs
condition|)
block|{
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|pairs_used
operator|==
literal|0
condition|)
block|{
name|send_pair
argument_list|(
name|pairs_used
argument_list|,
literal|1000
argument_list|,
literal|1000
argument_list|,
literal|1000
argument_list|,
name|R
argument_list|,
name|G
argument_list|,
name|B
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|send_pair
argument_list|(
name|pairs_used
argument_list|,
name|R
argument_list|,
name|G
argument_list|,
name|B
argument_list|,
name|R
argument_list|,
name|G
argument_list|,
name|B
argument_list|)
expr_stmt|;
block|}
block|}
name|pairs_used
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|B
operator|+=
name|color_step
operator|)
operator|>
literal|1000
condition|)
block|{
name|B
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|G
operator|+=
name|color_step
operator|)
operator|>
literal|1000
condition|)
block|{
name|G
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|R
operator|+=
name|color_step
operator|)
operator|>
literal|1000
condition|)
block|{
return|return
name|TRUE
return|;
block|}
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|rainbow
parameter_list|(
name|int
name|n
parameter_list|)
block|{
comment|/* print the programmable color display */
name|int
name|i
decl_stmt|,
name|c
decl_stmt|,
name|d
decl_stmt|,
name|palette_full
decl_stmt|,
name|initial_pair
decl_stmt|;
specifier|static
specifier|const
struct|struct
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|char
name|ch
decl_stmt|;
block|}
name|splat
index|[]
init|=
block|{
block|{
literal|"Bg normal"
block|,
literal|' '
block|}
block|,
block|{
literal|"Fg normal"
block|,
literal|' '
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
struct|;
if|if
condition|(
operator|(
name|set_a_foreground
operator|||
name|set_foreground
operator|)
condition|?
name|pairs_used
operator|>=
name|max_colors
else|:
name|pairs_used
operator|>=
name|max_pairs
condition|)
block|{
name|ptext
argument_list|(
literal|"New palette: "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|wait_here
argument_list|()
expr_stmt|;
name|initial_pair
operator|=
name|pairs_used
operator|=
literal|1
expr_stmt|;
name|bright_value
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|line_count
operator|+
literal|3
operator|>=
name|lines
condition|)
block|{
name|ptext
argument_list|(
literal|"Go: "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|wait_here
argument_list|()
expr_stmt|;
name|put_clear
argument_list|()
expr_stmt|;
name|initial_pair
operator|=
name|pairs_used
operator|=
literal|1
expr_stmt|;
name|bright_value
operator|=
literal|0
expr_stmt|;
name|n
operator|++
expr_stmt|;
block|}
else|else
block|{
name|initial_pair
operator|=
name|pairs_used
expr_stmt|;
name|n
operator|+=
name|initial_pair
expr_stmt|;
block|}
name|palette_full
operator|=
name|load_palette
argument_list|(
name|n
argument_list|)
expr_stmt|;
for|for
control|(
name|d
operator|=
literal|0
init|;
name|splat
index|[
name|d
index|]
operator|.
name|name
condition|;
name|d
operator|++
control|)
block|{
name|c
operator|=
name|splat
index|[
name|d
index|]
operator|.
name|ch
expr_stmt|;
if|if
condition|(
name|d
operator|==
literal|1
condition|)
block|{
name|put_mode
argument_list|(
name|enter_reverse_mode
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|initial_pair
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>=
name|pairs_used
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|set_a_foreground
condition|)
block|{
if|if
condition|(
name|i
operator|>=
name|max_colors
condition|)
block|{
break|break;
block|}
name|tc_putp
argument_list|(
name|TPARM_1
argument_list|(
name|set_a_foreground
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|tc_putp
argument_list|(
name|TPARM_1
argument_list|(
name|set_a_background
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|set_foreground
condition|)
block|{
if|if
condition|(
name|i
operator|>=
name|max_colors
condition|)
block|{
break|break;
block|}
name|tc_putp
argument_list|(
name|TPARM_1
argument_list|(
name|set_foreground
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|tc_putp
argument_list|(
name|TPARM_1
argument_list|(
name|set_background
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|i
operator|>=
name|max_pairs
condition|)
block|{
break|break;
block|}
name|tc_putp
argument_list|(
name|TPARM_1
argument_list|(
name|set_color_pair
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|putchp
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|d
operator|==
literal|1
condition|)
block|{
name|put_mode
argument_list|(
name|exit_attribute_mode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|set_a_foreground
condition|)
block|{
name|tc_putp
argument_list|(
name|TPARM_1
argument_list|(
name|set_a_foreground
argument_list|,
name|a_bright_color
argument_list|)
argument_list|)
expr_stmt|;
name|tc_putp
argument_list|(
name|TPARM_1
argument_list|(
name|set_a_background
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|set_foreground
condition|)
block|{
name|tc_putp
argument_list|(
name|TPARM_1
argument_list|(
name|set_foreground
argument_list|,
name|a_bright_color
argument_list|)
argument_list|)
expr_stmt|;
name|tc_putp
argument_list|(
name|TPARM_1
argument_list|(
name|set_background
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tc_putp
argument_list|(
name|TPARM_1
argument_list|(
name|set_color_pair
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|put_str
argument_list|(
literal|"   "
argument_list|)
expr_stmt|;
name|put_str
argument_list|(
name|splat
index|[
name|d
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|put_crlf
argument_list|()
expr_stmt|;
block|}
return|return
name|palette_full
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ncv_display
parameter_list|(
name|int
name|m
parameter_list|)
block|{
comment|/* print the no_color_video (ncv) test line */
name|putchp
argument_list|(
literal|'0'
operator|+
name|m
argument_list|)
expr_stmt|;
name|putchp
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|eat_cookie
argument_list|()
expr_stmt|;
name|set_attr
argument_list|(
literal|1
operator|<<
name|m
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"%-11s"
argument_list|,
name|alt_modes
index|[
name|m
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|put_str
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|new_color
argument_list|(
name|COLOR_BLUE
argument_list|,
name|COLOR_BLACK
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|put_str
argument_list|(
literal|"blue"
argument_list|)
expr_stmt|;
name|new_color
argument_list|(
name|COLOR_BLACK
argument_list|,
name|COLOR_GREEN
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|put_str
argument_list|(
literal|"green"
argument_list|)
expr_stmt|;
name|new_color
argument_list|(
name|COLOR_WHITE
argument_list|,
name|COLOR_BLACK
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|put_str
argument_list|(
name|alt_modes
index|[
name|m
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|eat_cookie
argument_list|()
expr_stmt|;
name|set_attr
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|reset_colors
argument_list|()
expr_stmt|;
name|put_crlf
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dump_colors
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* display the colors in some esthetic 				   pattern */
specifier|static
name|int
name|xmap
index|[
literal|8
index|]
init|=
block|{
literal|0
block|,
literal|3
block|,
literal|4
block|,
literal|7
block|,
literal|1
block|,
literal|2
block|,
literal|5
block|,
literal|6
block|}
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|xi
decl_stmt|,
name|xj
decl_stmt|,
name|width
decl_stmt|,
name|p
decl_stmt|,
name|cs
decl_stmt|;
name|int
name|found_one
decl_stmt|;
name|cs
operator|=
name|color_step
operator|<=
literal|125
condition|?
literal|125
else|:
name|color_step
expr_stmt|;
name|width
operator|=
operator|(
literal|1000
operator|/
name|cs
operator|)
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|xi
operator|=
literal|0
init|;
name|xi
operator|<
literal|16
condition|;
name|xi
operator|++
control|)
block|{
name|i
operator|=
operator|(
name|xi
operator|&
literal|8
operator|)
condition|?
name|xi
operator|^
literal|15
else|:
name|xi
expr_stmt|;
name|R
operator|=
name|i
operator|*
name|cs
expr_stmt|;
if|if
condition|(
name|R
operator|<=
literal|1000
condition|)
block|{
name|found_one
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|xj
operator|=
literal|0
init|;
name|xj
operator|<
literal|32
condition|;
name|xj
operator|++
control|)
block|{
name|j
operator|=
operator|(
operator|(
name|xj
operator|&
literal|8
operator|)
condition|?
name|xj
operator|^
literal|15
else|:
name|xj
operator|)
operator|&
literal|7
expr_stmt|;
name|k
operator|=
name|xmap
index|[
operator|(
operator|(
name|xi
operator|>>
literal|1
operator|)
operator|&
literal|4
operator|)
operator|+
operator|(
name|xj
operator|>>
literal|3
operator|)
index|]
expr_stmt|;
name|G
operator|=
name|j
operator|*
name|cs
expr_stmt|;
name|B
operator|=
name|k
operator|*
name|cs
expr_stmt|;
if|if
condition|(
name|G
operator|<=
literal|1000
operator|&&
name|B
operator|<=
literal|1000
condition|)
block|{
name|p
operator|=
operator|(
name|k
operator|*
name|width
operator|+
name|j
operator|)
operator|*
name|width
operator|+
name|i
expr_stmt|;
if|if
condition|(
name|set_a_background
condition|)
block|{
if|if
condition|(
name|p
operator|>=
name|max_colors
condition|)
block|{
continue|continue;
block|}
name|send_color
argument_list|(
name|p
argument_list|,
name|R
argument_list|,
name|G
argument_list|,
name|B
argument_list|)
expr_stmt|;
name|tc_putp
argument_list|(
name|TPARM_1
argument_list|(
name|set_a_background
argument_list|,
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|set_background
condition|)
block|{
if|if
condition|(
name|p
operator|>=
name|max_colors
condition|)
block|{
continue|continue;
block|}
name|send_color
argument_list|(
name|p
argument_list|,
name|R
argument_list|,
name|G
argument_list|,
name|B
argument_list|)
expr_stmt|;
name|tc_putp
argument_list|(
name|TPARM_1
argument_list|(
name|set_background
argument_list|,
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|p
operator|>=
name|max_pairs
condition|)
block|{
continue|continue;
block|}
name|send_pair
argument_list|(
name|p
argument_list|,
name|R
argument_list|,
name|G
argument_list|,
name|B
argument_list|,
name|R
argument_list|,
name|G
argument_list|,
name|B
argument_list|)
expr_stmt|;
name|tc_putp
argument_list|(
name|TPARM_1
argument_list|(
name|set_color_pair
argument_list|,
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|found_one
operator|=
name|TRUE
expr_stmt|;
name|putchp
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|putchp
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|found_one
condition|)
block|{
name|put_crlf
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* **	color_check(test_list, status, ch) ** **	test (colors) and (pairs) */
end_comment

begin_function
specifier|static
name|void
name|color_check
parameter_list|(
name|struct
name|test_list
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|state
parameter_list|,
name|int
modifier|*
name|ch
parameter_list|)
block|{
if|if
condition|(
name|max_colors
operator|<=
literal|0
operator|&&
name|max_pairs
operator|<=
literal|0
condition|)
block|{
name|ptext
argument_list|(
literal|"This is not a color terminal; (colors) and (pairs) are missing.  "
argument_list|)
expr_stmt|;
operator|*
name|state
operator||=
name|MENU_STOP
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"This terminal can display %d colors and %d color pairs.  (colors) (pairs)"
argument_list|,
name|max_colors
argument_list|,
name|max_pairs
argument_list|)
expr_stmt|;
name|ptextln
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
name|generic_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **	color_setf(test_list, status, ch) ** **	test (setf) (setb) and (scp) */
end_comment

begin_function
specifier|static
name|void
name|color_setf
parameter_list|(
name|struct
name|test_list
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|state
parameter_list|,
name|int
modifier|*
name|ch
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|max_colors
operator|<=
literal|0
operator|&&
name|max_pairs
operator|<=
literal|0
condition|)
block|{
name|ptext
argument_list|(
literal|"This is not a color terminal; (colors) and (pairs) are missing.  "
argument_list|)
expr_stmt|;
name|generic_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
operator|*
name|state
operator||=
name|MENU_STOP
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|set_a_foreground
operator|==
name|NULL
operator|||
name|set_a_background
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|set_foreground
operator|==
name|NULL
operator|||
name|set_background
operator|==
name|NULL
operator|)
operator|&&
name|set_color_pair
operator|==
name|NULL
condition|)
block|{
name|ptextln
argument_list|(
literal|"Both set foreground (setaf/setf) and set color pair (scp) are not present."
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|set_a_background
operator|||
operator|!
name|set_background
condition|)
block|{
name|ptextln
argument_list|(
literal|"(setab/setb) set background not present"
argument_list|)
expr_stmt|;
block|}
name|ptext
argument_list|(
literal|"These must be defined for color testing.  "
argument_list|)
expr_stmt|;
name|generic_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
operator|*
name|state
operator||=
name|MENU_STOP
expr_stmt|;
return|return;
block|}
comment|/* initialize the color palette */
name|pairs_used
operator|=
name|max_colors
operator|>=
literal|8
condition|?
literal|8
else|:
name|max_colors
expr_stmt|;
name|reset_colors
argument_list|()
expr_stmt|;
name|new_color
argument_list|(
name|COLOR_WHITE
argument_list|,
name|COLOR_BLACK
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|ptextln
argument_list|(
literal|"(setf) (setb) (scp) The following colors are predefined:"
argument_list|)
expr_stmt|;
name|ptextln
argument_list|(
literal|"\n   Foreground     Background"
argument_list|)
expr_stmt|;
name|put_crlf
argument_list|()
expr_stmt|;
name|j
operator|=
name|max_colors
operator|>
literal|8
condition|?
literal|8
else|:
name|max_colors
expr_stmt|;
comment|/* 	 * the black on white test is the same as the white on black test. 	 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|j
condition|;
name|i
operator|++
control|)
block|{
name|putchp
argument_list|(
literal|'0'
operator|+
name|def_colors
index|[
name|i
index|]
operator|.
name|index
argument_list|)
expr_stmt|;
name|putchp
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|" %s "
argument_list|,
name|def_colors
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|new_color
argument_list|(
name|def_colors
index|[
name|i
index|]
operator|.
name|index
argument_list|,
name|COLOR_BLACK
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|put_str
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|new_color
argument_list|(
name|COLOR_BLACK
argument_list|,
name|COLOR_BLACK
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|put_str
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
name|new_color
argument_list|(
name|COLOR_BLACK
argument_list|,
name|def_colors
index|[
name|i
index|]
operator|.
name|index
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|put_str
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|new_color
argument_list|(
name|COLOR_WHITE
argument_list|,
name|COLOR_BLACK
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|put_crlf
argument_list|()
expr_stmt|;
block|}
name|reset_colors
argument_list|()
expr_stmt|;
name|put_crlf
argument_list|()
expr_stmt|;
name|generic_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **	color_matrix(test_list, status, ch) ** **	test (pairs) (op) */
end_comment

begin_function
specifier|static
name|void
name|color_matrix
parameter_list|(
name|struct
name|test_list
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|state
parameter_list|,
name|int
modifier|*
name|ch
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|matrix_size
decl_stmt|,
name|matrix_area
decl_stmt|,
name|brightness
decl_stmt|;
name|matrix_size
operator|=
name|max_colors
operator|>
literal|8
condition|?
literal|8
else|:
name|max_colors
expr_stmt|;
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"(pairs) There are %d color pairs."
argument_list|,
name|max_pairs
argument_list|)
expr_stmt|;
name|ptextln
argument_list|(
name|temp
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|matrix_size
condition|;
name|matrix_size
operator|--
control|)
block|{
if|if
condition|(
name|matrix_size
operator|*
name|matrix_size
operator|<=
name|max_pairs
condition|)
block|{
break|break;
block|}
block|}
name|matrix_area
operator|=
name|matrix_size
operator|*
name|matrix_size
expr_stmt|;
for|for
control|(
name|brightness
operator|=
literal|0
init|;
name|brightness
operator|<
literal|2
condition|;
name|brightness
operator|++
control|)
block|{
name|put_crlf
argument_list|()
expr_stmt|;
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"%dx%d matrix of foreground/background colors, bright *o%s*"
argument_list|,
name|matrix_size
argument_list|,
name|matrix_size
argument_list|,
name|brightness
condition|?
literal|"n"
else|:
literal|"ff"
argument_list|)
expr_stmt|;
name|put_str
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|put_str
argument_list|(
literal|"\n          "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|matrix_size
condition|;
name|i
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"%-8s"
argument_list|,
name|def_colors
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|put_str
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|matrix_area
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|j
operator|%
name|matrix_size
operator|==
literal|0
condition|)
block|{
name|reset_colors
argument_list|()
expr_stmt|;
name|put_crlf
argument_list|()
expr_stmt|;
if|if
condition|(
name|brightness
condition|)
block|{
name|tc_putp
argument_list|(
name|exit_attribute_mode
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"%-8s"
argument_list|,
name|def_colors
index|[
name|j
operator|/
name|matrix_size
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|put_str
argument_list|(
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|brightness
condition|)
block|{
name|put_mode
argument_list|(
name|enter_bold_mode
argument_list|)
expr_stmt|;
block|}
block|}
name|new_color
argument_list|(
name|def_colors
index|[
name|j
operator|%
name|matrix_size
index|]
operator|.
name|index
argument_list|,
name|def_colors
index|[
name|j
operator|/
name|matrix_size
index|]
operator|.
name|index
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|put_str
argument_list|(
literal|"  Hello "
argument_list|)
expr_stmt|;
block|}
name|reset_colors
argument_list|()
expr_stmt|;
if|if
condition|(
name|brightness
condition|)
block|{
name|tc_putp
argument_list|(
name|exit_attribute_mode
argument_list|)
expr_stmt|;
block|}
name|put_crlf
argument_list|()
expr_stmt|;
block|}
name|generic_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **	color_ncv(test_list, status, ch) ** **	test (ncv) */
end_comment

begin_function
specifier|static
name|void
name|color_ncv
parameter_list|(
name|struct
name|test_list
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|state
parameter_list|,
name|int
modifier|*
name|ch
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|no_color_video
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* I have no idea what this means */
return|return;
block|}
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"According to no_color_video (ncv) which is %d, the following attributes should work correctly with color."
argument_list|,
name|no_color_video
argument_list|)
expr_stmt|;
name|ptextln
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|put_crlf
argument_list|()
expr_stmt|;
name|set_attr
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|ncv_display
argument_list|(
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
literal|9
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|no_color_video
operator|>>
operator|(
name|mode_map
index|[
name|i
index|]
operator|-
literal|1
operator|)
operator|)
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
name|ncv_display
argument_list|(
name|mode_map
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|no_color_video
operator|&
literal|0x3ff
condition|)
block|{
name|ptextln
argument_list|(
literal|"\nThe following attributes should not work correctly with color. (ncv)\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
literal|9
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|no_color_video
operator|>>
operator|(
name|mode_map
index|[
name|i
index|]
operator|-
literal|1
operator|)
operator|)
operator|&
literal|1
condition|)
block|{
name|ncv_display
argument_list|(
name|mode_map
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|reset_colors
argument_list|()
expr_stmt|;
name|put_crlf
argument_list|()
expr_stmt|;
name|generic_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **	color_bce(test_list, status, ch) ** **	test (bce) background color erase */
end_comment

begin_function
specifier|static
name|void
name|color_bce
parameter_list|(
name|struct
name|test_list
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|state
parameter_list|,
name|int
modifier|*
name|ch
parameter_list|)
block|{
name|new_color
argument_list|(
name|COLOR_CYAN
argument_list|,
name|COLOR_BLUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|put_clear
argument_list|()
expr_stmt|;
name|put_newlines
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|reset_colors
argument_list|()
expr_stmt|;
name|ptextln
argument_list|(
literal|"If the two lines above are blue then back_color_erase (bce) should be true."
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"(bce) is %s in the data base."
argument_list|,
name|back_color_erase
condition|?
literal|"true"
else|:
literal|"false"
argument_list|)
expr_stmt|;
name|ptextln
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|generic_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **	color_ccc(test_list, status, ch) ** **	test (ccc) color palette test (oc) (op) (initc) (initp) */
end_comment

begin_function
specifier|static
name|void
name|color_ccc
parameter_list|(
name|struct
name|test_list
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|state
parameter_list|,
name|int
modifier|*
name|ch
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
operator|!
name|can_change
condition|)
block|{
name|ptextln
argument_list|(
literal|"Terminal can not change colors (ccc)"
argument_list|)
expr_stmt|;
name|generic_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
return|return;
block|}
name|reset_colors
argument_list|()
expr_stmt|;
name|pairs_used
operator|=
literal|0
expr_stmt|;
name|new_color
argument_list|(
name|COLOR_WHITE
argument_list|,
name|COLOR_BLACK
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"Reloading colors (init%c) using %s method"
argument_list|,
name|set_foreground
condition|?
literal|'c'
else|:
literal|'p'
argument_list|,
name|hue_lightness_saturation
condition|?
literal|"HLS"
else|:
literal|"RGB"
argument_list|)
expr_stmt|;
name|ptextln
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|put_crlf
argument_list|()
expr_stmt|;
name|j
operator|=
name|max_colors
operator|>
literal|7
condition|?
literal|7
else|:
name|max_colors
expr_stmt|;
comment|/* redisplay the above test with reinitialized colors */
comment|/* If these colors don't look right to you... */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|j
condition|;
name|i
operator|++
control|)
block|{
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|" %s "
argument_list|,
name|def_colors
index|[
name|i
operator|^
literal|7
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|new_color
argument_list|(
name|i
operator|^
literal|7
argument_list|,
name|COLOR_BLACK
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|put_str
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|new_color
argument_list|(
name|COLOR_BLACK
argument_list|,
name|COLOR_BLACK
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|put_str
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
name|new_color
argument_list|(
name|COLOR_BLACK
argument_list|,
name|i
operator|^
literal|7
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|put_str
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|new_color
argument_list|(
name|COLOR_WHITE
argument_list|,
name|COLOR_BLACK
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|put_crlf
argument_list|()
expr_stmt|;
block|}
name|generic_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ch
operator|!=
literal|0
operator|&&
operator|*
name|ch
operator|!=
literal|'n'
condition|)
block|{
name|reset_colors
argument_list|()
expr_stmt|;
return|return;
block|}
name|pairs_used
operator|=
literal|0
expr_stmt|;
name|cookie_monster
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|magic_cookie_glitch
operator|>
literal|0
condition|)
block|{
name|cookie_monster
operator|=
operator|(
operator|(
name|set_a_foreground
operator|||
name|set_foreground
operator|)
condition|?
name|magic_cookie_glitch
else|:
literal|0
operator|)
operator|+
operator|(
operator|(
name|set_a_background
operator|||
name|set_background
operator|)
condition|?
name|magic_cookie_glitch
else|:
literal|0
operator|)
operator|+
operator|(
name|set_color_pair
condition|?
name|magic_cookie_glitch
else|:
literal|0
operator|)
expr_stmt|;
block|}
name|set_color_step
argument_list|()
expr_stmt|;
name|colors_per_line
operator|=
name|max_colors
operator|>
name|max_pairs
condition|?
name|max_pairs
else|:
name|max_colors
expr_stmt|;
name|j
operator|=
operator|(
name|columns
operator|-
literal|14
operator|)
operator|/
operator|(
name|cookie_monster
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|colors_per_line
operator|>
name|j
condition|)
block|{
name|colors_per_line
operator|=
operator|(
name|j
operator|/
name|i
operator|)
operator|*
name|i
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"RGB color step %d, cookies %d"
argument_list|,
name|color_step
argument_list|,
name|cookie_monster
argument_list|)
expr_stmt|;
name|ptextln
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|R
operator|=
name|G
operator|=
name|B
operator|=
literal|0
expr_stmt|;
name|pairs_used
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|rainbow
argument_list|(
name|colors_per_line
argument_list|)
condition|)
block|{
break|break;
block|}
block|}
name|generic_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ch
operator|!=
literal|0
operator|&&
operator|*
name|ch
operator|!=
literal|'n'
condition|)
block|{
name|reset_colors
argument_list|()
expr_stmt|;
return|return;
block|}
name|dump_colors
argument_list|()
expr_stmt|;
name|reset_colors
argument_list|()
expr_stmt|;
name|generic_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

