begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ** Copyright (C) 1991, 1997-2000 Free Software Foundation, Inc. ** ** This file is part of TACK. ** ** TACK is free software; you can redistribute it and/or modify ** it under the terms of the GNU General Public License as published by ** the Free Software Foundation; either version 2, or (at your option) ** any later version. ** ** TACK is distributed in the hope that it will be useful, ** but WITHOUT ANY WARRANTY; without even the implied warranty of ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ** GNU General Public License for more details. ** ** You should have received a copy of the GNU General Public License ** along with TACK; see the file COPYING.  If not, write to ** the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, ** Boston, MA 02110-1301, USA */
end_comment

begin_include
include|#
directive|include
file|<tack.h>
end_include

begin_macro
name|MODULE_ID
argument_list|(
literal|"$Id: charset.c,v 1.11 2006/11/26 00:13:36 tom Exp $"
argument_list|)
end_macro

begin_comment
comment|/* 	Menu definitions for alternate character set and SGR tests. */
end_comment

begin_function_decl
specifier|static
name|void
name|charset_bel
parameter_list|(
name|struct
name|test_list
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|state
parameter_list|,
name|int
modifier|*
name|ch
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|charset_flash
parameter_list|(
name|struct
name|test_list
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|state
parameter_list|,
name|int
modifier|*
name|ch
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|charset_civis
parameter_list|(
name|struct
name|test_list
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|state
parameter_list|,
name|int
modifier|*
name|ch
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|charset_cvvis
parameter_list|(
name|struct
name|test_list
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|state
parameter_list|,
name|int
modifier|*
name|ch
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|charset_cnorm
parameter_list|(
name|struct
name|test_list
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|state
parameter_list|,
name|int
modifier|*
name|ch
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|charset_hs
parameter_list|(
name|struct
name|test_list
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|state
parameter_list|,
name|int
modifier|*
name|ch
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|charset_status
parameter_list|(
name|struct
name|test_list
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|state
parameter_list|,
name|int
modifier|*
name|ch
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|charset_dsl
parameter_list|(
name|struct
name|test_list
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|state
parameter_list|,
name|int
modifier|*
name|ch
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|charset_enacs
parameter_list|(
name|struct
name|test_list
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|state
parameter_list|,
name|int
modifier|*
name|ch
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|charset_smacs
parameter_list|(
name|struct
name|test_list
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|state
parameter_list|,
name|int
modifier|*
name|ch
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|charset_attributes
parameter_list|(
name|struct
name|test_list
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|state
parameter_list|,
name|int
modifier|*
name|ch
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|charset_sgr
parameter_list|(
name|struct
name|test_list
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|state
parameter_list|,
name|int
modifier|*
name|ch
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|test_list
name|acs_test_list
index|[]
init|=
block|{
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|"e) edit terminfo"
block|,
literal|0
block|,
operator|&
name|edit_menu
block|}
block|,
block|{
name|MENU_NEXT
block|,
literal|3
block|,
literal|"bel"
block|,
literal|0
block|,
literal|0
block|,
name|charset_bel
block|,
literal|0
block|}
block|,
block|{
name|MENU_NEXT
block|,
literal|3
block|,
literal|"flash"
block|,
literal|0
block|,
literal|0
block|,
name|charset_flash
block|,
literal|0
block|}
block|,
block|{
name|MENU_NEXT
block|,
literal|3
block|,
literal|"civis"
block|,
literal|0
block|,
literal|0
block|,
name|charset_civis
block|,
literal|0
block|}
block|,
block|{
name|MENU_NEXT
block|,
literal|3
block|,
literal|"cvvis"
block|,
literal|0
block|,
literal|0
block|,
name|charset_cvvis
block|,
literal|0
block|}
block|,
block|{
name|MENU_NEXT
block|,
literal|3
block|,
literal|"cnorm"
block|,
literal|0
block|,
literal|0
block|,
name|charset_cnorm
block|,
literal|0
block|}
block|,
block|{
name|MENU_NEXT
block|,
literal|3
block|,
literal|"hs"
block|,
literal|0
block|,
literal|0
block|,
name|charset_hs
block|,
literal|0
block|}
block|,
block|{
name|MENU_NEXT
block|,
literal|3
block|,
literal|"tsl) (fsl) (wsl"
block|,
literal|"hs"
block|,
literal|0
block|,
name|charset_status
block|,
literal|0
block|}
block|,
block|{
name|MENU_NEXT
block|,
literal|3
block|,
literal|"dsl"
block|,
literal|"hs"
block|,
literal|0
block|,
name|charset_dsl
block|,
literal|0
block|}
block|,
block|{
name|MENU_NEXT
block|,
literal|0
block|,
literal|"acsc) (enacs) (smacs) (rmacs"
block|,
literal|0
block|,
literal|0
block|,
name|charset_enacs
block|,
literal|0
block|}
block|,
block|{
name|MENU_NEXT
block|,
literal|0
block|,
literal|"smacs) (rmacs"
block|,
literal|0
block|,
literal|0
block|,
name|charset_smacs
block|,
literal|0
block|}
block|,
block|{
name|MENU_NEXT
block|,
literal|11
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|charset_attributes
block|,
literal|0
block|}
block|,
block|{
name|MENU_NEXT
block|,
literal|11
block|,
literal|"sgr) (sgr0"
block|,
literal|"ma"
block|,
literal|0
block|,
name|charset_sgr
block|,
literal|0
block|}
block|,
block|{
name|MENU_LAST
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|struct
name|mode_list
name|alt_modes
index|[]
init|=
block|{
block|{
literal|"normal"
block|,
literal|"(sgr0)"
block|,
literal|"(sgr0)"
block|,
literal|1
block|}
block|,
block|{
literal|"standout"
block|,
literal|"(smso)"
block|,
literal|"(rmso)"
block|,
literal|2
block|}
block|,
block|{
literal|"underline"
block|,
literal|"(smul)"
block|,
literal|"(rmul)"
block|,
literal|4
block|}
block|,
block|{
literal|"reverse"
block|,
literal|"(rev)"
block|,
literal|"(sgr0)"
block|,
literal|8
block|}
block|,
block|{
literal|"blink"
block|,
literal|"(blink)"
block|,
literal|"(sgr0)"
block|,
literal|16
block|}
block|,
block|{
literal|"dim"
block|,
literal|"(dim)"
block|,
literal|"(sgr0)"
block|,
literal|32
block|}
block|,
block|{
literal|"bold"
block|,
literal|"(bold)"
block|,
literal|"(sgr0)"
block|,
literal|64
block|}
block|,
block|{
literal|"invis"
block|,
literal|"(invis)"
block|,
literal|"(sgr0)"
block|,
literal|128
block|}
block|,
block|{
literal|"protect"
block|,
literal|"(prot)"
block|,
literal|"(sgr0)"
block|,
literal|256
block|}
block|,
block|{
literal|"altcharset"
block|,
literal|"(smacs)"
block|,
literal|"(rmacs)"
block|,
literal|512
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* On many terminals the underline attribute is the last scan line.    This is OK unless the following line is reverse video.    Then the underline attribute does not show up.  The following map    will reorder the display so that the underline attribute will    show up. */
end_comment

begin_decl_stmt
specifier|const
name|int
name|mode_map
index|[
literal|10
index|]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|2
block|}
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|graphics_pair
block|{
name|unsigned
name|char
name|c
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|graphics_pair
name|glyph
index|[]
init|=
block|{
block|{
literal|'+'
block|,
literal|"arrow pointing right"
block|}
block|,
block|{
literal|','
block|,
literal|"arrow pointing left"
block|}
block|,
block|{
literal|'.'
block|,
literal|"arrow pointing down"
block|}
block|,
block|{
literal|'0'
block|,
literal|"solid square block"
block|}
block|,
block|{
literal|'i'
block|,
literal|"lantern symbol"
block|}
block|,
block|{
literal|'-'
block|,
literal|"arrow pointing up"
block|}
block|,
block|{
literal|'`'
block|,
literal|"diamond"
block|}
block|,
block|{
literal|'a'
block|,
literal|"checker board (stipple)"
block|}
block|,
block|{
literal|'f'
block|,
literal|"degree symbol"
block|}
block|,
block|{
literal|'g'
block|,
literal|"plus/minus"
block|}
block|,
block|{
literal|'h'
block|,
literal|"board of squares"
block|}
block|,
block|{
literal|'j'
block|,
literal|"lower right corner"
block|}
block|,
block|{
literal|'k'
block|,
literal|"upper right corner"
block|}
block|,
block|{
literal|'l'
block|,
literal|"upper left corner"
block|}
block|,
block|{
literal|'m'
block|,
literal|"lower left corner"
block|}
block|,
block|{
literal|'n'
block|,
literal|"plus"
block|}
block|,
block|{
literal|'o'
block|,
literal|"scan line 1"
block|}
block|,
block|{
literal|'p'
block|,
literal|"scan line 3"
block|}
block|,
block|{
literal|'q'
block|,
literal|"horizontal line"
block|}
block|,
block|{
literal|'r'
block|,
literal|"scan line 7"
block|}
block|,
block|{
literal|'s'
block|,
literal|"scan line 9"
block|}
block|,
block|{
literal|'t'
block|,
literal|"left tee (|-)"
block|}
block|,
block|{
literal|'u'
block|,
literal|"right tee (-|)"
block|}
block|,
block|{
literal|'v'
block|,
literal|"bottom tee(_|_)"
block|}
block|,
block|{
literal|'w'
block|,
literal|"top tee (T)"
block|}
block|,
block|{
literal|'x'
block|,
literal|"vertical line"
block|}
block|,
block|{
literal|'y'
block|,
literal|"less/equal"
block|}
block|,
block|{
literal|'z'
block|,
literal|"greater/equal"
block|}
block|,
block|{
literal|'{'
block|,
literal|"Pi"
block|}
block|,
block|{
literal|'|'
block|,
literal|"not equal"
block|}
block|,
block|{
literal|'}'
block|,
literal|"UK pound sign"
block|}
block|,
block|{
literal|'~'
block|,
literal|"bullet"
block|}
block|,
block|{
literal|'\0'
block|,
literal|"\0"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* **	charset_hs(test_list, status, ch) ** **	(hs) test Has status line */
end_comment

begin_function
specifier|static
name|void
name|charset_hs
parameter_list|(
name|struct
name|test_list
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|state
parameter_list|,
name|int
modifier|*
name|ch
parameter_list|)
block|{
if|if
condition|(
name|has_status_line
operator|!=
literal|1
condition|)
block|{
name|ptext
argument_list|(
literal|"(hs) Has-status line is not defined.  "
argument_list|)
expr_stmt|;
name|generic_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* **	charset_status(test_list, status, ch) ** **	(tsl) (fsl) (wsl) test Status line */
end_comment

begin_function
specifier|static
name|void
name|charset_status
parameter_list|(
name|struct
name|test_list
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|state
parameter_list|,
name|int
modifier|*
name|ch
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|max
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
specifier|static
name|char
name|m
index|[]
init|=
literal|"*** status line *** 123456789.123456789.123456789.123456789.123456789.123456789.123456789.123456789.123456789.123456789.123456789.123456789.123456789.123456789.123456789.123456789.123456789."
decl_stmt|;
if|if
condition|(
name|has_status_line
operator|!=
literal|1
condition|)
block|{
return|return;
block|}
name|put_clear
argument_list|()
expr_stmt|;
name|max
operator|=
name|width_status_line
operator|==
operator|-
literal|1
condition|?
name|columns
else|:
name|width_status_line
expr_stmt|;
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"Terminal has status line of %d characters"
argument_list|,
name|max
argument_list|)
expr_stmt|;
name|ptextln
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|put_str
argument_list|(
literal|"This line s"
argument_list|)
expr_stmt|;
name|s
operator|=
name|TPARM_1
argument_list|(
name|to_status_line
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tc_putp
argument_list|(
name|s
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max
condition|;
name|i
operator|++
control|)
name|putchp
argument_list|(
name|m
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|tc_putp
argument_list|(
name|from_status_line
argument_list|)
expr_stmt|;
name|putln
argument_list|(
literal|"hould not be broken."
argument_list|)
expr_stmt|;
name|ptextln
argument_list|(
literal|"If the previous line is not a complete sentence then (tsl) to-status-line, (fsl) from-status-line, or (wsl) width-of-status-line is incorrect."
argument_list|)
expr_stmt|;
name|generic_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **	charset_dsl(test_list, status, ch) ** **	(dsl) test Disable status line */
end_comment

begin_function
specifier|static
name|void
name|charset_dsl
parameter_list|(
name|struct
name|test_list
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|state
parameter_list|,
name|int
modifier|*
name|ch
parameter_list|)
block|{
if|if
condition|(
name|has_status_line
operator|!=
literal|1
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|dis_status_line
condition|)
block|{
name|ptextln
argument_list|(
literal|"Disable status line (dsl)"
argument_list|)
expr_stmt|;
name|tc_putp
argument_list|(
name|dis_status_line
argument_list|)
expr_stmt|;
name|ptext
argument_list|(
literal|"If you can still see the status line then (dsl) disable-status-line has failed.  "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ptext
argument_list|(
literal|"(dsl) Disable-status-line is not defined.  "
argument_list|)
expr_stmt|;
block|}
name|generic_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|eat_cookie
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* put a blank if this is not a magic cookie 				   terminal */
if|if
condition|(
name|magic_cookie_glitch
operator|<
literal|1
condition|)
name|putchp
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|put_mode
parameter_list|(
name|char
modifier|*
name|s
parameter_list|)
block|{
comment|/* send the attribute string (with or without 				   % execution) */
name|tc_putp
argument_list|(
name|TPARM_0
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
comment|/* allow % execution */
block|}
end_function

begin_function
name|void
name|set_attr
parameter_list|(
name|int
name|a
parameter_list|)
block|{
comment|/* set the attribute from the bits in a */
name|int
name|i
decl_stmt|,
name|b
index|[
literal|32
index|]
decl_stmt|;
if|if
condition|(
name|magic_cookie_glitch
operator|>
literal|0
condition|)
block|{
name|char_count
operator|+=
name|magic_cookie_glitch
expr_stmt|;
block|}
if|if
condition|(
name|a
operator|==
literal|0
operator|&&
name|exit_attribute_mode
condition|)
block|{
name|put_mode
argument_list|(
name|exit_attribute_mode
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|31
condition|;
name|i
operator|++
control|)
block|{
name|b
index|[
name|i
index|]
operator|=
operator|(
name|a
operator|>>
name|i
operator|)
operator|&
literal|1
expr_stmt|;
block|}
name|tc_putp
argument_list|(
name|TPARM_9
argument_list|(
name|set_attributes
argument_list|,
name|b
index|[
literal|1
index|]
argument_list|,
name|b
index|[
literal|2
index|]
argument_list|,
name|b
index|[
literal|3
index|]
argument_list|,
name|b
index|[
literal|4
index|]
argument_list|,
name|b
index|[
literal|5
index|]
argument_list|,
name|b
index|[
literal|6
index|]
argument_list|,
name|b
index|[
literal|7
index|]
argument_list|,
name|b
index|[
literal|8
index|]
argument_list|,
name|b
index|[
literal|9
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **	charset_sgr(test_list, status, ch) ** **	(sgr) test Set Graphics Rendition */
end_comment

begin_function
specifier|static
name|void
name|charset_sgr
parameter_list|(
name|struct
name|test_list
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|state
parameter_list|,
name|int
modifier|*
name|ch
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
operator|!
name|set_attributes
condition|)
block|{
name|ptext
argument_list|(
literal|"(sgr) Set-graphics-rendition is not defined.  "
argument_list|)
expr_stmt|;
name|generic_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|exit_attribute_mode
condition|)
block|{
name|ptextln
argument_list|(
literal|"(sgr0) Set-graphics-rendition-zero is not defined."
argument_list|)
expr_stmt|;
comment|/* go ahead and test anyway */
block|}
name|ptext
argument_list|(
literal|"Test video attributes (sgr)"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
call|(
name|int
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|alt_modes
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|mode_list
argument_list|)
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|put_crlf
argument_list|()
expr_stmt|;
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"%d %-20s"
argument_list|,
name|i
argument_list|,
name|alt_modes
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|put_str
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|set_attr
argument_list|(
name|alt_modes
index|[
name|i
index|]
operator|.
name|number
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"%s"
argument_list|,
name|alt_modes
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|put_str
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|set_attr
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|putln
argument_list|(
literal|"\n\nDouble mode test"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
literal|9
condition|;
name|i
operator|++
control|)
block|{
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|" %2d "
argument_list|,
name|mode_map
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|put_str
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
literal|9
condition|;
name|i
operator|++
control|)
block|{
name|put_crlf
argument_list|()
expr_stmt|;
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"%d"
argument_list|,
name|mode_map
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|put_str
argument_list|(
name|temp
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
literal|9
condition|;
name|j
operator|++
control|)
block|{
name|eat_cookie
argument_list|()
expr_stmt|;
name|set_attr
argument_list|(
operator|(
literal|1
operator|<<
name|mode_map
index|[
name|i
index|]
operator|)
operator||
operator|(
literal|1
operator|<<
name|mode_map
index|[
name|j
index|]
operator|)
argument_list|)
expr_stmt|;
name|put_str
argument_list|(
literal|"Aa"
argument_list|)
expr_stmt|;
name|set_attr
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|<
literal|9
condition|)
name|eat_cookie
argument_list|()
expr_stmt|;
block|}
block|}
name|put_crlf
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|max_attributes
if|if
condition|(
name|max_attributes
operator|>=
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"(ma) Maximum attributes %d  "
argument_list|,
name|max_attributes
argument_list|)
expr_stmt|;
name|ptext
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|generic_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **	test_one_attr(mode-number, begin-string, end-string) ** **	Display one attribute line. */
end_comment

begin_function
specifier|static
name|void
name|test_one_attr
parameter_list|(
name|int
name|n
parameter_list|,
name|char
modifier|*
name|begin_mode
parameter_list|,
name|char
modifier|*
name|end_mode
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"%-10s %s "
argument_list|,
name|alt_modes
index|[
name|n
index|]
operator|.
name|name
argument_list|,
name|alt_modes
index|[
name|n
index|]
operator|.
name|begin_mode
argument_list|)
expr_stmt|;
name|ptext
argument_list|(
name|temp
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|char_count
operator|<
literal|19
condition|;
control|)
block|{
name|putchp
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|begin_mode
condition|)
block|{
name|putchp
argument_list|(
literal|'.'
argument_list|)
expr_stmt|;
name|put_mode
argument_list|(
name|begin_mode
argument_list|)
expr_stmt|;
name|put_str
argument_list|(
name|alt_modes
index|[
name|n
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|strlen
argument_list|(
name|alt_modes
index|[
name|n
index|]
operator|.
name|name
argument_list|)
init|;
name|i
operator|<
literal|13
condition|;
name|i
operator|++
control|)
block|{
name|putchp
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|end_mode
condition|)
block|{
name|put_mode
argument_list|(
name|end_mode
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|". %s"
argument_list|,
name|alt_modes
index|[
name|n
index|]
operator|.
name|end_mode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|set_attr
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|temp
argument_list|,
literal|". (sgr)"
argument_list|)
expr_stmt|;
block|}
name|ptextln
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|magic_cookie_glitch
condition|;
name|i
operator|++
control|)
name|putchp
argument_list|(
literal|'*'
argument_list|)
expr_stmt|;
name|put_str
argument_list|(
literal|"*** missing ***"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|magic_cookie_glitch
condition|;
name|i
operator|++
control|)
name|putchp
argument_list|(
literal|'*'
argument_list|)
expr_stmt|;
name|put_crlf
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* **	charset_attributes(test_list, status, ch) ** **	Test SGR */
end_comment

begin_function
specifier|static
name|void
name|charset_attributes
parameter_list|(
name|struct
name|test_list
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|state
parameter_list|,
name|int
modifier|*
name|ch
parameter_list|)
block|{
name|putln
argument_list|(
literal|"Test video attributes"
argument_list|)
expr_stmt|;
name|test_one_attr
argument_list|(
literal|1
argument_list|,
name|enter_standout_mode
argument_list|,
name|exit_standout_mode
argument_list|)
expr_stmt|;
name|test_one_attr
argument_list|(
literal|2
argument_list|,
name|enter_underline_mode
argument_list|,
name|exit_underline_mode
argument_list|)
expr_stmt|;
name|test_one_attr
argument_list|(
literal|9
argument_list|,
name|enter_alt_charset_mode
argument_list|,
name|exit_alt_charset_mode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|exit_attribute_mode
operator|&&
operator|!
name|set_attributes
condition|)
block|{
name|ptextln
argument_list|(
literal|"(sgr0) exit attribute mode is not defined."
argument_list|)
expr_stmt|;
name|generic_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
return|return;
block|}
name|test_one_attr
argument_list|(
literal|3
argument_list|,
name|enter_reverse_mode
argument_list|,
name|exit_attribute_mode
argument_list|)
expr_stmt|;
name|test_one_attr
argument_list|(
literal|4
argument_list|,
name|enter_blink_mode
argument_list|,
name|exit_attribute_mode
argument_list|)
expr_stmt|;
name|test_one_attr
argument_list|(
literal|5
argument_list|,
name|enter_dim_mode
argument_list|,
name|exit_attribute_mode
argument_list|)
expr_stmt|;
name|test_one_attr
argument_list|(
literal|6
argument_list|,
name|enter_bold_mode
argument_list|,
name|exit_attribute_mode
argument_list|)
expr_stmt|;
name|test_one_attr
argument_list|(
literal|7
argument_list|,
name|enter_secure_mode
argument_list|,
name|exit_attribute_mode
argument_list|)
expr_stmt|;
name|test_one_attr
argument_list|(
literal|8
argument_list|,
name|enter_protected_mode
argument_list|,
name|exit_attribute_mode
argument_list|)
expr_stmt|;
name|generic_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|GLYPHS
value|256
end_define

begin_comment
comment|/* **	charset_smacs(test_list, status, ch) ** **	display all possible acs characters **	(smacs) (rmacs) */
end_comment

begin_function
specifier|static
name|void
name|charset_smacs
parameter_list|(
name|struct
name|test_list
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|state
parameter_list|,
name|int
modifier|*
name|ch
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|c
decl_stmt|;
if|if
condition|(
name|enter_alt_charset_mode
condition|)
block|{
name|put_clear
argument_list|()
expr_stmt|;
name|ptextln
argument_list|(
literal|"The following characters are available. (smacs) (rmacs)"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|' '
init|;
name|i
operator|<=
literal|'`'
condition|;
name|i
operator|+=
literal|32
control|)
block|{
name|put_crlf
argument_list|()
expr_stmt|;
name|put_mode
argument_list|(
name|exit_alt_charset_mode
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
literal|32
condition|;
name|c
operator|++
control|)
block|{
name|putchp
argument_list|(
name|c
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
name|put_crlf
argument_list|()
expr_stmt|;
name|put_mode
argument_list|(
name|enter_alt_charset_mode
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
literal|32
condition|;
name|c
operator|++
control|)
block|{
name|putchp
argument_list|(
name|c
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
name|put_mode
argument_list|(
name|exit_alt_charset_mode
argument_list|)
expr_stmt|;
name|put_crlf
argument_list|()
expr_stmt|;
block|}
name|put_mode
argument_list|(
name|exit_alt_charset_mode
argument_list|)
expr_stmt|;
name|put_crlf
argument_list|()
expr_stmt|;
name|generic_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|test_acs
parameter_list|(
name|int
name|attr
parameter_list|)
block|{
comment|/* alternate character set */
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|char
name|valid_glyph
index|[
name|GLYPHS
index|]
decl_stmt|;
name|char
name|acs_table
index|[
name|GLYPHS
index|]
decl_stmt|;
specifier|static
name|unsigned
name|char
name|vt100
index|[]
init|=
literal|"`afgjklmnopqrstuvwxyz{|}~"
decl_stmt|;
name|line_count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GLYPHS
condition|;
name|i
operator|++
control|)
block|{
name|valid_glyph
index|[
name|i
index|]
operator|=
name|FALSE
expr_stmt|;
name|acs_table
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|acs_chars
condition|)
block|{
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"Alternate character set map: %s"
argument_list|,
name|expand
argument_list|(
name|acs_chars
argument_list|)
argument_list|)
expr_stmt|;
name|putln
argument_list|(
name|temp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|acs_chars
index|[
name|i
index|]
condition|;
name|i
operator|+=
literal|2
control|)
block|{
if|if
condition|(
name|acs_chars
index|[
name|i
operator|+
literal|1
index|]
operator|==
literal|0
condition|)
block|{
break|break;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|glyph
index|[
name|j
index|]
operator|.
name|c
operator|==
operator|(
name|unsigned
name|char
operator|)
name|acs_chars
index|[
name|i
index|]
condition|)
block|{
name|acs_table
index|[
name|glyph
index|[
name|j
index|]
operator|.
name|c
index|]
operator|=
name|acs_chars
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|valid_glyph
index|[
name|glyph
index|[
name|j
index|]
operator|.
name|c
index|]
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|glyph
index|[
name|j
index|]
operator|.
name|name
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|isgraph
argument_list|(
name|UChar
argument_list|(
name|acs_chars
index|[
name|i
index|]
argument_list|)
argument_list|)
condition|)
block|{
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"    %c"
argument_list|,
name|acs_chars
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|" 0x%02x"
argument_list|,
name|UChar
argument_list|(
name|acs_chars
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|strcpy
argument_list|(
operator|&
name|temp
index|[
literal|5
index|]
argument_list|,
literal|" *** has no mapping ***"
argument_list|)
expr_stmt|;
name|putln
argument_list|(
name|temp
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
else|else
block|{
name|ptextln
argument_list|(
literal|"acs_chars not defined (acsc)"
argument_list|)
expr_stmt|;
comment|/* enable the VT-100 graphics characters (default) */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|vt100
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|valid_glyph
index|[
name|vt100
index|[
name|i
index|]
index|]
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|attr
condition|)
block|{
name|set_attr
argument_list|(
name|attr
argument_list|)
expr_stmt|;
block|}
name|_nc_init_acs
argument_list|()
expr_stmt|;
comment|/* puts 'ena_acs' and incidentally links acs_map[] */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|glyph
index|[
name|i
index|]
operator|.
name|name
index|[
literal|0
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|valid_glyph
index|[
name|glyph
index|[
name|i
index|]
operator|.
name|c
index|]
condition|)
block|{
name|put_mode
argument_list|(
name|enter_alt_charset_mode
argument_list|)
expr_stmt|;
name|put_this
argument_list|(
name|acs_table
index|[
name|glyph
index|[
name|i
index|]
operator|.
name|c
index|]
argument_list|)
expr_stmt|;
name|char_count
operator|++
expr_stmt|;
name|put_mode
argument_list|(
name|exit_alt_charset_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|magic_cookie_glitch
operator|>=
literal|1
condition|)
block|{
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|" %-30.30s"
argument_list|,
name|glyph
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|put_str
argument_list|(
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|char_count
operator|+
literal|33
operator|>=
name|columns
condition|)
name|put_crlf
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|" %-24.24s"
argument_list|,
name|glyph
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|put_str
argument_list|(
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|char_count
operator|+
literal|26
operator|>=
name|columns
condition|)
name|put_crlf
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|line_count
operator|>=
name|lines
condition|)
block|{
operator|(
name|void
operator|)
name|wait_here
argument_list|()
expr_stmt|;
name|put_clear
argument_list|()
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|char_count
operator|>
literal|1
condition|)
block|{
name|put_crlf
argument_list|()
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ACS_ULCORNER
name|maybe_wait
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|put_mode
argument_list|(
name|enter_alt_charset_mode
argument_list|)
expr_stmt|;
name|put_that
argument_list|(
name|ACS_ULCORNER
argument_list|)
expr_stmt|;
name|put_that
argument_list|(
name|ACS_TTEE
argument_list|)
expr_stmt|;
name|put_that
argument_list|(
name|ACS_URCORNER
argument_list|)
expr_stmt|;
name|put_that
argument_list|(
name|ACS_ULCORNER
argument_list|)
expr_stmt|;
name|put_that
argument_list|(
name|ACS_HLINE
argument_list|)
expr_stmt|;
name|put_that
argument_list|(
name|ACS_URCORNER
argument_list|)
expr_stmt|;
name|char_count
operator|+=
literal|6
expr_stmt|;
name|put_mode
argument_list|(
name|exit_alt_charset_mode
argument_list|)
expr_stmt|;
name|put_crlf
argument_list|()
expr_stmt|;
name|put_mode
argument_list|(
name|enter_alt_charset_mode
argument_list|)
expr_stmt|;
name|put_that
argument_list|(
name|ACS_LTEE
argument_list|)
expr_stmt|;
name|put_that
argument_list|(
name|ACS_PLUS
argument_list|)
expr_stmt|;
name|put_that
argument_list|(
name|ACS_RTEE
argument_list|)
expr_stmt|;
name|put_that
argument_list|(
name|ACS_VLINE
argument_list|)
expr_stmt|;
if|if
condition|(
name|magic_cookie_glitch
operator|>=
literal|1
condition|)
name|put_this
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
else|else
block|{
name|put_mode
argument_list|(
name|exit_alt_charset_mode
argument_list|)
expr_stmt|;
name|put_this
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|put_mode
argument_list|(
name|enter_alt_charset_mode
argument_list|)
expr_stmt|;
block|}
name|put_that
argument_list|(
name|ACS_VLINE
argument_list|)
expr_stmt|;
name|char_count
operator|+=
literal|6
expr_stmt|;
name|put_mode
argument_list|(
name|exit_alt_charset_mode
argument_list|)
expr_stmt|;
name|put_str
argument_list|(
literal|"   Here are 2 boxes"
argument_list|)
expr_stmt|;
name|put_crlf
argument_list|()
expr_stmt|;
name|put_mode
argument_list|(
name|enter_alt_charset_mode
argument_list|)
expr_stmt|;
name|put_that
argument_list|(
name|ACS_LLCORNER
argument_list|)
expr_stmt|;
name|put_that
argument_list|(
name|ACS_BTEE
argument_list|)
expr_stmt|;
name|put_that
argument_list|(
name|ACS_LRCORNER
argument_list|)
expr_stmt|;
name|put_that
argument_list|(
name|ACS_LLCORNER
argument_list|)
expr_stmt|;
name|put_that
argument_list|(
name|ACS_HLINE
argument_list|)
expr_stmt|;
name|put_that
argument_list|(
name|ACS_LRCORNER
argument_list|)
expr_stmt|;
name|char_count
operator|+=
literal|6
expr_stmt|;
name|put_mode
argument_list|(
name|exit_alt_charset_mode
argument_list|)
expr_stmt|;
name|put_crlf
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* **	charset_bel(test_list, status, ch) ** **	(bel) test Bell */
end_comment

begin_function
specifier|static
name|void
name|charset_bel
parameter_list|(
name|struct
name|test_list
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|state
parameter_list|,
name|int
modifier|*
name|ch
parameter_list|)
block|{
if|if
condition|(
name|bell
condition|)
block|{
name|ptextln
argument_list|(
literal|"Testing bell (bel)"
argument_list|)
expr_stmt|;
name|tc_putp
argument_list|(
name|bell
argument_list|)
expr_stmt|;
name|ptext
argument_list|(
literal|"If you did not hear the Bell then (bel) has failed.  "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ptext
argument_list|(
literal|"(bel) Bell is not defined.  "
argument_list|)
expr_stmt|;
block|}
name|generic_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **	charset_flash(test_list, status, ch) ** **	(flash) test Visual bell */
end_comment

begin_function
specifier|static
name|void
name|charset_flash
parameter_list|(
name|struct
name|test_list
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|state
parameter_list|,
name|int
modifier|*
name|ch
parameter_list|)
block|{
if|if
condition|(
name|flash_screen
condition|)
block|{
name|ptextln
argument_list|(
literal|"Testing visual bell (flash)"
argument_list|)
expr_stmt|;
name|tc_putp
argument_list|(
name|flash_screen
argument_list|)
expr_stmt|;
name|ptext
argument_list|(
literal|"If you did not see the screen flash then (flash) has failed.  "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ptext
argument_list|(
literal|"(flash) Flash is not defined.  "
argument_list|)
expr_stmt|;
block|}
name|generic_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **	charset_civis(test_list, status, ch) ** **	(civis) test Cursor invisible */
end_comment

begin_function
specifier|static
name|void
name|charset_civis
parameter_list|(
name|struct
name|test_list
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|state
parameter_list|,
name|int
modifier|*
name|ch
parameter_list|)
block|{
if|if
condition|(
name|cursor_normal
condition|)
block|{
if|if
condition|(
name|cursor_invisible
condition|)
block|{
name|ptext
argument_list|(
literal|"(civis) Turn off the cursor.  "
argument_list|)
expr_stmt|;
name|tc_putp
argument_list|(
name|cursor_invisible
argument_list|)
expr_stmt|;
name|ptext
argument_list|(
literal|"If you can still see the cursor then (civis) has failed.  "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ptext
argument_list|(
literal|"(civis) Cursor-invisible is not defined.  "
argument_list|)
expr_stmt|;
block|}
name|generic_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
name|tc_putp
argument_list|(
name|cursor_normal
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* **	charset_cvvis(test_list, status, ch) ** **	(cvvis) test Cursor very visible */
end_comment

begin_function
specifier|static
name|void
name|charset_cvvis
parameter_list|(
name|struct
name|test_list
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|state
parameter_list|,
name|int
modifier|*
name|ch
parameter_list|)
block|{
if|if
condition|(
name|cursor_normal
condition|)
block|{
if|if
condition|(
name|cursor_visible
condition|)
block|{
name|ptext
argument_list|(
literal|"(cvvis) Make cursor very visible.  "
argument_list|)
expr_stmt|;
name|tc_putp
argument_list|(
name|cursor_visible
argument_list|)
expr_stmt|;
name|ptext
argument_list|(
literal|"If the cursor is not very visible then (cvvis) has failed.  "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ptext
argument_list|(
literal|"(cvvis) Cursor-very-visible is not defined.  "
argument_list|)
expr_stmt|;
block|}
name|generic_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
name|tc_putp
argument_list|(
name|cursor_normal
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* **	charset_cnorm(test_list, status, ch) ** **	(cnorm) test Cursor normal */
end_comment

begin_function
specifier|static
name|void
name|charset_cnorm
parameter_list|(
name|struct
name|test_list
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|state
parameter_list|,
name|int
modifier|*
name|ch
parameter_list|)
block|{
if|if
condition|(
name|cursor_normal
condition|)
block|{
name|ptext
argument_list|(
literal|"(cnorm) Normal cursor.  "
argument_list|)
expr_stmt|;
name|tc_putp
argument_list|(
name|cursor_normal
argument_list|)
expr_stmt|;
name|ptext
argument_list|(
literal|"If the cursor is not normal then (cnorm) has failed.  "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ptext
argument_list|(
literal|"(cnorm) Cursor-normal is not defined.  "
argument_list|)
expr_stmt|;
block|}
name|generic_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **	charset_enacs(test_list, status, ch) ** **	test Alternate character set mode and alternate characters **	(acsc) (enacs) (smacs) (rmacs) */
end_comment

begin_function
specifier|static
name|void
name|charset_enacs
parameter_list|(
name|struct
name|test_list
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|state
parameter_list|,
name|int
modifier|*
name|ch
parameter_list|)
block|{
name|int
name|c
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|enter_alt_charset_mode
operator|||
name|acs_chars
condition|)
block|{
name|c
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|put_clear
argument_list|()
expr_stmt|;
comment|/* 			   for terminals that use separate fonts for 			   attributes (such as X windows) the line 			   drawing characters must be checked for 			   each font. 			*/
if|if
condition|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
block|{
name|test_acs
argument_list|(
name|alt_modes
index|[
name|c
operator|-
literal|'0'
index|]
operator|.
name|number
argument_list|)
expr_stmt|;
name|set_attr
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|test_acs
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
literal|1
condition|)
block|{
name|ptextln
argument_list|(
literal|"[r] to repeat, [012345789] to test with attributes on, [?] for a list of attributes, anything else to go to next test.  "
argument_list|)
expr_stmt|;
name|generic_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ch
operator|!=
literal|'?'
condition|)
block|{
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
literal|9
condition|;
name|i
operator|++
control|)
block|{
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|" %d %s %s"
argument_list|,
name|i
argument_list|,
name|alt_modes
index|[
name|i
index|]
operator|.
name|begin_mode
argument_list|,
name|alt_modes
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|ptextln
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|*
name|ch
operator|>=
literal|'0'
operator|&&
operator|*
name|ch
operator|<=
literal|'9'
condition|)
block|{
name|c
operator|=
operator|*
name|ch
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|ch
operator|!=
literal|'r'
condition|)
block|{
break|break;
block|}
block|}
block|}
else|else
block|{
name|ptext
argument_list|(
literal|"(smacs) Enter-alt-char-set-mode and (acsc) Alternate-char-set are not defined.  "
argument_list|)
expr_stmt|;
name|generic_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* **	charset_can_test() ** **	Initialize the can_test data base */
end_comment

begin_function
name|void
name|charset_can_test
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|9
condition|;
name|i
operator|++
control|)
block|{
name|can_test
argument_list|(
name|alt_modes
index|[
name|i
index|]
operator|.
name|begin_mode
argument_list|,
name|FLAG_CAN_TEST
argument_list|)
expr_stmt|;
name|can_test
argument_list|(
name|alt_modes
index|[
name|i
index|]
operator|.
name|end_mode
argument_list|,
name|FLAG_CAN_TEST
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

