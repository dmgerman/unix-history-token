begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ** Copyright (C) 1991, 1997 Free Software Foundation, Inc. **  ** This file is part of TACK. **  ** TACK is free software; you can redistribute it and/or modify ** it under the terms of the GNU General Public License as published by ** the Free Software Foundation; either version 2, or (at your option) ** any later version. **  ** TACK is distributed in the hope that it will be useful, ** but WITHOUT ANY WARRANTY; without even the implied warranty of ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ** GNU General Public License for more details. **  ** You should have received a copy of the GNU General Public License ** along with TACK; see the file COPYING.  If not, write to ** the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, ** Boston, MA 02110-1301, USA */
end_comment

begin_include
include|#
directive|include
file|<tack.h>
end_include

begin_macro
name|MODULE_ID
argument_list|(
literal|"$Id: pad.c,v 1.6 2005/09/17 19:49:16 tom Exp $"
argument_list|)
end_macro

begin_comment
comment|/* test the pad counts on the terminal */
end_comment

begin_function_decl
specifier|static
name|void
name|pad_standard
parameter_list|(
name|struct
name|test_list
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|init_xon_xoff
parameter_list|(
name|struct
name|test_list
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|init_cup
parameter_list|(
name|struct
name|test_list
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pad_rmxon
parameter_list|(
name|struct
name|test_list
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pad_home1
parameter_list|(
name|struct
name|test_list
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pad_home2
parameter_list|(
name|struct
name|test_list
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pad_clear
parameter_list|(
name|struct
name|test_list
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pad_ech
parameter_list|(
name|struct
name|test_list
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pad_el1
parameter_list|(
name|struct
name|test_list
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pad_el
parameter_list|(
name|struct
name|test_list
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pad_smdc
parameter_list|(
name|struct
name|test_list
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pad_dch
parameter_list|(
name|struct
name|test_list
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pad_dch1
parameter_list|(
name|struct
name|test_list
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pad_smir
parameter_list|(
name|struct
name|test_list
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pad_ich
parameter_list|(
name|struct
name|test_list
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pad_ich1
parameter_list|(
name|struct
name|test_list
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pad_xch1
parameter_list|(
name|struct
name|test_list
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pad_rep
parameter_list|(
name|struct
name|test_list
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pad_cup
parameter_list|(
name|struct
name|test_list
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pad_hd
parameter_list|(
name|struct
name|test_list
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pad_hu
parameter_list|(
name|struct
name|test_list
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pad_rin
parameter_list|(
name|struct
name|test_list
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pad_il
parameter_list|(
name|struct
name|test_list
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pad_indn
parameter_list|(
name|struct
name|test_list
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pad_dl
parameter_list|(
name|struct
name|test_list
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pad_xl
parameter_list|(
name|struct
name|test_list
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pad_scrc
parameter_list|(
name|struct
name|test_list
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pad_csrind
parameter_list|(
name|struct
name|test_list
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pad_sccsrrc
parameter_list|(
name|struct
name|test_list
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pad_csr_nel
parameter_list|(
name|struct
name|test_list
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pad_csr_cup
parameter_list|(
name|struct
name|test_list
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pad_ht
parameter_list|(
name|struct
name|test_list
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pad_smso
parameter_list|(
name|struct
name|test_list
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pad_smacs
parameter_list|(
name|struct
name|test_list
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pad_crash
parameter_list|(
name|struct
name|test_list
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*    Any command found in this list, executed from a "Done" prompt    will force the default action to repeat rather than next. */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|pad_repeat_test
init|=
block|{
literal|"ep-+<>"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|test_list
name|pad_test_list
index|[]
init|=
block|{
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|"e) edit terminfo"
block|,
literal|0
block|,
operator|&
name|edit_menu
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|"p) change padding"
block|,
literal|0
block|,
operator|&
name|change_pad_menu
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|"@) display statistics about the last test"
block|,
name|dump_test_stats
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|"c) clear screen"
block|,
name|menu_clear_screen
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|"i) send reset and init"
block|,
name|menu_reset_init
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|txt_longer_test_time
block|,
name|longer_test_time
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|txt_shorter_test_time
block|,
name|shorter_test_time
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|txt_longer_augment
block|,
name|longer_augment
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|txt_shorter_augment
block|,
name|shorter_augment
block|,
literal|0
block|}
block|,
comment|/*** 	   Phase 1: Test initialization and reset strings. 	 	   (rs1) (rs2) (rs3) (is1) (is2) (is3) are very difficult to test. 	   They have no defined output.  To make matters worse, the cap 	   builder could partition (rs1) (rs2) (rs3) by length, leaving the 	   terminal in some unknown state between (rs1) and (rs2) or between 	   (r2) and (rs3).  Some reset strings clear the screen when done. 	 	   We have no control over this.  The only thing we can do for 	   certain is to test the pad times by checking for overruns. 	***/
block|{
name|MENU_NEXT
block|,
literal|3
block|,
literal|"rs1"
block|,
literal|0
block|,
literal|0
block|,
name|pad_standard
block|,
literal|0
block|}
block|,
block|{
name|MENU_NEXT
block|,
literal|3
block|,
literal|"rs2"
block|,
literal|0
block|,
literal|0
block|,
name|pad_standard
block|,
literal|0
block|}
block|,
block|{
name|MENU_NEXT
block|,
literal|3
block|,
literal|"rs3"
block|,
literal|0
block|,
literal|0
block|,
name|pad_standard
block|,
literal|0
block|}
block|,
block|{
name|MENU_NEXT
operator||
name|MENU_INIT
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|init_xon_xoff
block|,
literal|0
block|}
block|,
block|{
name|MENU_NEXT
block|,
literal|3
block|,
literal|"is1"
block|,
literal|0
block|,
literal|0
block|,
name|pad_standard
block|,
literal|0
block|}
block|,
block|{
name|MENU_NEXT
block|,
literal|3
block|,
literal|"is2"
block|,
literal|0
block|,
literal|0
block|,
name|pad_standard
block|,
literal|0
block|}
block|,
block|{
name|MENU_NEXT
block|,
literal|3
block|,
literal|"is3"
block|,
literal|0
block|,
literal|0
block|,
name|pad_standard
block|,
literal|0
block|}
block|,
block|{
name|MENU_NEXT
block|,
literal|3
block|,
literal|"rmxon"
block|,
literal|"smxon"
block|,
literal|0
block|,
name|pad_rmxon
block|,
literal|0
block|}
block|,
block|{
name|MENU_NEXT
operator||
name|MENU_INIT
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|init_cup
block|,
literal|0
block|}
block|,
comment|/* 	   Phase 2: Test home, screen clears and erases. 	*/
block|{
name|MENU_NEXT
block|,
literal|0
block|,
literal|"home"
block|,
literal|0
block|,
literal|0
block|,
name|pad_home1
block|,
literal|0
block|}
block|,
block|{
name|MENU_NEXT
block|,
literal|0
block|,
literal|"home) (nel"
block|,
literal|0
block|,
literal|0
block|,
name|pad_home2
block|,
literal|0
block|}
block|,
block|{
name|MENU_NEXT
operator||
literal|1
block|,
literal|0
block|,
literal|"clear"
block|,
literal|0
block|,
literal|0
block|,
name|pad_clear
block|,
literal|0
block|}
block|,
block|{
name|MENU_NEXT
operator||
name|MENU_LM1
block|,
literal|0
block|,
literal|"ed"
block|,
literal|0
block|,
literal|0
block|,
name|pad_clear
block|,
literal|0
block|}
block|,
block|{
name|MENU_NEXT
operator||
name|MENU_80c
block|,
literal|0
block|,
literal|"ech"
block|,
literal|0
block|,
literal|0
block|,
name|pad_ech
block|,
literal|0
block|}
block|,
block|{
name|MENU_NEXT
operator||
name|MENU_80c
block|,
literal|0
block|,
literal|"el1"
block|,
literal|"cub1 nel"
block|,
literal|0
block|,
name|pad_el1
block|,
literal|0
block|}
block|,
block|{
name|MENU_NEXT
operator||
name|MENU_10c
block|,
literal|0
block|,
literal|"el"
block|,
literal|"nel"
block|,
literal|0
block|,
name|pad_el
block|,
literal|0
block|}
block|,
comment|/* 	   Phase 3: Character deletions and insertions 	*/
block|{
name|MENU_NEXT
block|,
literal|0
block|,
literal|"smdc) (rmdc"
block|,
literal|0
block|,
literal|0
block|,
name|pad_smdc
block|,
literal|0
block|}
block|,
block|{
name|MENU_NEXT
operator||
name|MENU_80c
block|,
literal|0
block|,
literal|"dch"
block|,
literal|"smdc rmdc"
block|,
literal|0
block|,
name|pad_dch
block|,
literal|0
block|}
block|,
block|{
name|MENU_NEXT
operator||
name|MENU_80c
block|,
literal|0
block|,
literal|"dch1"
block|,
literal|"smdc rmdc"
block|,
literal|0
block|,
name|pad_dch1
block|,
literal|0
block|}
block|,
block|{
name|MENU_NEXT
block|,
literal|0
block|,
literal|"smir) (rmir"
block|,
literal|0
block|,
literal|0
block|,
name|pad_smir
block|,
literal|0
block|}
block|,
block|{
name|MENU_NEXT
operator||
name|MENU_90c
block|,
literal|0
block|,
literal|"ich) (ip"
block|,
literal|"smir rmir"
block|,
literal|0
block|,
name|pad_ich
block|,
literal|0
block|}
block|,
block|{
name|MENU_NEXT
operator||
name|MENU_90c
block|,
literal|0
block|,
literal|"ich1) (ip"
block|,
literal|"smir rmir"
block|,
literal|0
block|,
name|pad_ich1
block|,
literal|0
block|}
block|,
block|{
name|MENU_NEXT
block|,
literal|4
block|,
literal|"ich1) (dch1"
block|,
literal|"smir rmir"
block|,
literal|0
block|,
name|pad_xch1
block|,
literal|0
block|}
block|,
block|{
name|MENU_NEXT
operator||
name|MENU_90c
block|,
literal|0
block|,
literal|"rep"
block|,
literal|0
block|,
literal|0
block|,
name|pad_rep
block|,
literal|0
block|}
block|,
comment|/* 	   Phase 4: Test cursor addressing pads. 	*/
block|{
name|MENU_NEXT
block|,
literal|0
block|,
literal|"cup"
block|,
literal|0
block|,
literal|0
block|,
name|pad_cup
block|,
literal|0
block|}
block|,
comment|/* 	   Phase 5: Test scrolling and cursor save/restore. 	*/
block|{
name|MENU_NEXT
block|,
literal|0
block|,
literal|"hd"
block|,
literal|0
block|,
literal|0
block|,
name|pad_hd
block|,
literal|0
block|}
block|,
block|{
name|MENU_NEXT
block|,
literal|0
block|,
literal|"hu"
block|,
literal|0
block|,
literal|0
block|,
name|pad_hu
block|,
literal|0
block|}
block|,
block|{
name|MENU_NEXT
operator||
name|MENU_LM1
operator||
literal|1
block|,
literal|0
block|,
literal|"rin"
block|,
literal|0
block|,
literal|0
block|,
name|pad_rin
block|,
literal|0
block|}
block|,
block|{
name|MENU_NEXT
block|,
literal|0
block|,
literal|"ri"
block|,
literal|0
block|,
literal|0
block|,
name|pad_rin
block|,
literal|0
block|}
block|,
block|{
name|MENU_NEXT
operator||
name|MENU_LM1
operator||
literal|1
block|,
literal|0
block|,
literal|"il"
block|,
literal|0
block|,
literal|0
block|,
name|pad_il
block|,
literal|0
block|}
block|,
block|{
name|MENU_NEXT
block|,
literal|0
block|,
literal|"il1"
block|,
literal|0
block|,
literal|0
block|,
name|pad_il
block|,
literal|0
block|}
block|,
block|{
name|MENU_NEXT
operator||
name|MENU_LM1
operator||
literal|1
block|,
literal|0
block|,
literal|"indn"
block|,
literal|0
block|,
literal|0
block|,
name|pad_indn
block|,
literal|0
block|}
block|,
block|{
name|MENU_NEXT
block|,
literal|0
block|,
literal|"ind"
block|,
literal|0
block|,
literal|0
block|,
name|pad_indn
block|,
literal|0
block|}
block|,
block|{
name|MENU_NEXT
operator||
name|MENU_LM1
operator||
literal|1
block|,
literal|0
block|,
literal|"dl"
block|,
literal|0
block|,
literal|0
block|,
name|pad_dl
block|,
literal|0
block|}
block|,
block|{
name|MENU_NEXT
block|,
literal|0
block|,
literal|"dl1"
block|,
literal|0
block|,
literal|0
block|,
name|pad_dl
block|,
literal|0
block|}
block|,
block|{
name|MENU_NEXT
block|,
literal|0
block|,
literal|"il1) (dl1"
block|,
literal|0
block|,
literal|0
block|,
name|pad_xl
block|,
literal|0
block|}
block|,
block|{
name|MENU_NEXT
block|,
literal|0
block|,
literal|"sc) (rc"
block|,
literal|0
block|,
literal|0
block|,
name|pad_scrc
block|,
literal|0
block|}
block|,
block|{
name|MENU_NEXT
operator||
name|MENU_50l
block|,
literal|0
block|,
literal|"csr) (ind"
block|,
literal|0
block|,
literal|0
block|,
name|pad_csrind
block|,
literal|0
block|}
block|,
block|{
name|MENU_NEXT
block|,
literal|0
block|,
literal|"sc) (csr) (rc"
block|,
literal|0
block|,
literal|0
block|,
name|pad_sccsrrc
block|,
literal|0
block|}
block|,
block|{
name|MENU_NEXT
block|,
literal|0
block|,
literal|"csr) (nel"
block|,
literal|"sc rc"
block|,
literal|0
block|,
name|pad_csr_nel
block|,
literal|0
block|}
block|,
block|{
name|MENU_NEXT
block|,
literal|0
block|,
literal|"csr) (cup"
block|,
literal|0
block|,
literal|0
block|,
name|pad_csr_cup
block|,
literal|0
block|}
block|,
comment|/* 	   Phase 6: Test tabs. 	*/
block|{
name|MENU_NEXT
block|,
literal|0
block|,
literal|"ht"
block|,
literal|0
block|,
literal|0
block|,
name|pad_ht
block|,
literal|0
block|}
block|,
comment|/* 	   Phase 7: Test character-set-switch pads. 	*/
block|{
name|MENU_NEXT
block|,
literal|0
block|,
literal|"smso) (rmso"
block|,
literal|0
block|,
literal|0
block|,
name|pad_smso
block|,
literal|0
block|}
block|,
block|{
name|MENU_NEXT
block|,
literal|0
block|,
literal|"smacs) (rmacs"
block|,
literal|0
block|,
literal|0
block|,
name|pad_smacs
block|,
literal|0
block|}
block|,
comment|/* 	   Phase 8: Tests for miscellaneous mode-switch pads. 	*/
block|{
name|MENU_NEXT
block|,
literal|3
block|,
literal|"flash"
block|,
literal|0
block|,
literal|0
block|,
name|pad_standard
block|,
literal|0
block|}
block|,
block|{
name|MENU_NEXT
block|,
literal|3
block|,
literal|"smkx"
block|,
literal|0
block|,
literal|0
block|,
name|pad_standard
block|,
literal|0
block|}
block|,
block|{
name|MENU_NEXT
block|,
literal|3
block|,
literal|"rmkx"
block|,
literal|0
block|,
literal|0
block|,
name|pad_standard
block|,
literal|0
block|}
block|,
block|{
name|MENU_NEXT
block|,
literal|3
block|,
literal|"smm"
block|,
literal|0
block|,
literal|0
block|,
name|pad_standard
block|,
literal|0
block|}
block|,
block|{
name|MENU_NEXT
block|,
literal|3
block|,
literal|"rmm"
block|,
literal|0
block|,
literal|0
block|,
name|pad_standard
block|,
literal|0
block|}
block|,
comment|/* 	   Phase 9: Test crash-and-burn properties of unpadded (clear). 	*/
block|{
literal|0
block|,
literal|0
block|,
literal|"clear"
block|,
literal|"xon"
block|,
literal|"k) run clear test with no padding"
block|,
name|pad_crash
block|,
literal|0
block|}
block|,
block|{
name|MENU_LAST
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* globals */
end_comment

begin_decl_stmt
specifier|static
name|int
name|hzcc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* horizontal character count */
end_comment

begin_decl_stmt
name|char
name|letter
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current character being displayed */
end_comment

begin_decl_stmt
name|int
name|letter_number
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* points into letters[] */
end_comment

begin_decl_stmt
name|int
name|augment
decl_stmt|,
name|repeats
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of characters (or lines) effected */
end_comment

begin_decl_stmt
name|char
name|letters
index|[]
init|=
literal|"AbCdefghiJklmNopQrStuVwXyZ"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|every_line
index|[]
init|=
literal|"This text should be on every line."
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|all_lines
index|[]
init|=
literal|"Each char on any line should be the same.  "
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|above_line
index|[]
init|=
literal|"The above lines should be all Xs.  "
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|no_visual
index|[]
init|=
literal|"This loop test has no visual failure indicator.  "
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* **	pad_standard(test_list, status, ch) ** **	Run a single cap pad test. */
end_comment

begin_function
specifier|static
name|void
name|pad_standard
parameter_list|(
name|struct
name|test_list
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|state
parameter_list|,
name|int
modifier|*
name|ch
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|long_name
decl_stmt|;
name|char
modifier|*
name|cap
decl_stmt|;
name|int
name|l
init|=
literal|2
decl_stmt|,
name|i
decl_stmt|;
name|char
name|tbuf
index|[
literal|128
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|cap
operator|=
name|get_string_cap_byname
argument_list|(
name|t
operator|->
name|caps_done
argument_list|,
operator|&
name|long_name
argument_list|)
operator|)
condition|)
block|{
name|sprintf
argument_list|(
name|tbuf
argument_list|,
literal|"(%s) %s, start testing"
argument_list|,
name|t
operator|->
name|caps_done
argument_list|,
name|long_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|skip_pad_test
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|,
name|tbuf
argument_list|)
condition|)
block|{
return|return;
block|}
name|i
operator|=
literal|1
expr_stmt|;
name|pad_test_startup
argument_list|(
literal|1
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
name|i
operator|>=
name|columns
condition|)
block|{
name|page_loop
argument_list|()
expr_stmt|;
name|l
operator|++
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
block|}
name|tt_putp
argument_list|(
name|cap
argument_list|)
expr_stmt|;
name|putchp
argument_list|(
name|letter
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|still_testing
argument_list|()
condition|)
do|;
name|pad_test_shutdown
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|>=
name|lines
condition|)
block|{
name|home_down
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|put_crlf
argument_list|()
expr_stmt|;
block|}
name|ptextln
argument_list|(
name|no_visual
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|CAP_NOT_FOUND
expr_stmt|;
comment|/* Note: get_string_cap_byname() always sets long_name */
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"(%s) %s, not present.  "
argument_list|,
name|t
operator|->
name|caps_done
argument_list|,
name|long_name
argument_list|)
expr_stmt|;
name|ptext
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
name|pad_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **	init_xon_xoff(test_list, status, ch) ** **	Initialize the xon_xoff values */
end_comment

begin_function
specifier|static
name|void
name|init_xon_xoff
parameter_list|(
name|struct
name|test_list
modifier|*
name|t
name|GCC_UNUSED
parameter_list|,
name|int
modifier|*
name|state
name|GCC_UNUSED
parameter_list|,
name|int
modifier|*
name|ch
name|GCC_UNUSED
parameter_list|)
block|{
comment|/* the reset strings may dink with the XON/XOFF modes */
if|if
condition|(
name|select_xon_xoff
operator|==
literal|0
operator|&&
name|exit_xon_mode
condition|)
block|{
name|tc_putp
argument_list|(
name|exit_xon_mode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|select_xon_xoff
operator|==
literal|1
operator|&&
name|enter_xon_mode
condition|)
block|{
name|tc_putp
argument_list|(
name|enter_xon_mode
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* **	pad_rmxon(test_list, status, ch) ** **	Test (rmxon) exit XON/XOFF mode */
end_comment

begin_function
specifier|static
name|void
name|pad_rmxon
parameter_list|(
name|struct
name|test_list
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|state
parameter_list|,
name|int
modifier|*
name|ch
parameter_list|)
block|{
if|if
condition|(
name|select_xon_xoff
operator|==
literal|0
operator|&&
name|exit_xon_mode
condition|)
block|{
name|pad_standard
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* **	init_cup(test_list, status, ch) ** **	Send the initialization strings for XON/XOFF and (smcup) **	Stop pad testing if clear screen is missing. */
end_comment

begin_function
specifier|static
name|void
name|init_cup
parameter_list|(
name|struct
name|test_list
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|state
parameter_list|,
name|int
modifier|*
name|ch
parameter_list|)
block|{
name|init_xon_xoff
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
if|if
condition|(
name|enter_ca_mode
condition|)
block|{
name|tc_putp
argument_list|(
name|enter_ca_mode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|can_clear_screen
condition|)
block|{
name|ptext
argument_list|(
literal|"(clear) clear screen not present,"
argument_list|)
expr_stmt|;
name|ptext
argument_list|(
literal|" pad processing terminated.  "
argument_list|)
expr_stmt|;
name|pad_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ch
operator|==
literal|0
operator|||
operator|*
name|ch
operator|==
literal|'n'
operator|||
operator|*
name|ch
operator|==
literal|'s'
operator|||
operator|*
name|ch
operator|==
literal|'r'
condition|)
block|{
operator|*
name|ch
operator|=
literal|'?'
expr_stmt|;
block|}
return|return;
block|}
block|}
end_function

begin_comment
comment|/* **	pad_home1(test_list, status, ch) ** **	Test (home) when (am) is set. */
end_comment

begin_function
specifier|static
name|void
name|pad_home1
parameter_list|(
name|struct
name|test_list
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|state
parameter_list|,
name|int
modifier|*
name|ch
parameter_list|)
block|{
name|int
name|j
decl_stmt|,
name|k
decl_stmt|;
if|if
condition|(
name|can_go_home
operator|&&
name|auto_right_margin
condition|)
block|{
comment|/* 		   truly brain damaged terminals will fail this test because 		   they cannot accept data at full rate 		*/
if|if
condition|(
name|skip_pad_test
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|,
literal|"(home) Home start testing"
argument_list|)
condition|)
block|{
return|return;
block|}
name|pad_test_startup
argument_list|(
literal|1
argument_list|)
expr_stmt|;
do|do
block|{
name|go_home
argument_list|()
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|lines
condition|;
name|j
operator|++
control|)
block|{
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|columns
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|k
operator|&
literal|0xF
condition|)
block|{
name|put_this
argument_list|(
name|letter
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|put_this
argument_list|(
literal|'.'
argument_list|)
expr_stmt|;
block|}
block|}
name|SLOW_TERMINAL_EXIT
expr_stmt|;
block|}
name|NEXT_LETTER
expr_stmt|;
block|}
do|while
condition|(
name|still_testing
argument_list|()
condition|)
do|;
name|pad_test_shutdown
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ptext
argument_list|(
literal|"All the dots should line up.  "
argument_list|)
expr_stmt|;
name|pad_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
name|put_clear
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* **	pad_home2(test_list, status, ch) ** **	Test (home) and (nel).  (am) is reset. */
end_comment

begin_function
specifier|static
name|void
name|pad_home2
parameter_list|(
name|struct
name|test_list
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|state
parameter_list|,
name|int
modifier|*
name|ch
parameter_list|)
block|{
name|int
name|j
decl_stmt|,
name|k
decl_stmt|;
if|if
condition|(
name|can_go_home
condition|)
block|{
if|if
condition|(
name|skip_pad_test
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|,
literal|"(home) Home, (nel) newline start testing"
argument_list|)
condition|)
block|{
return|return;
block|}
name|pad_test_startup
argument_list|(
literal|1
argument_list|)
expr_stmt|;
do|do
block|{
name|go_home
argument_list|()
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|lines
condition|;
name|j
operator|++
control|)
block|{
for|for
control|(
name|k
operator|=
literal|2
init|;
name|k
operator|<
name|columns
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|k
operator|&
literal|0xF
condition|)
block|{
name|put_this
argument_list|(
name|letter
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|put_this
argument_list|(
literal|'.'
argument_list|)
expr_stmt|;
block|}
block|}
name|put_crlf
argument_list|()
expr_stmt|;
comment|/* this does the (nel) */
name|SLOW_TERMINAL_EXIT
expr_stmt|;
block|}
name|NEXT_LETTER
expr_stmt|;
block|}
do|while
condition|(
name|still_testing
argument_list|()
condition|)
do|;
name|pad_test_shutdown
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ptext
argument_list|(
literal|"All the dots should line up.  "
argument_list|)
expr_stmt|;
name|pad_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
name|put_clear
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* **	pad_clear(test_list, status, ch) ** **	Test (clear) and (ed) **	run the clear screen tests (also clear-to-end-of-screen) ** **	0) full page **	1) sparse page **	2) short lines **	3) one full line **	4) one short line */
end_comment

begin_function
specifier|static
name|void
name|pad_clear
parameter_list|(
name|struct
name|test_list
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|state
parameter_list|,
name|int
modifier|*
name|ch
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|end_message
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|txt
decl_stmt|;
name|int
name|j
decl_stmt|,
name|k
decl_stmt|,
name|is_clear
decl_stmt|;
name|int
name|clear_select
decl_stmt|;
comment|/* select the test number */
name|is_clear
operator|=
name|t
operator|->
name|flags
operator|&
literal|1
expr_stmt|;
name|clear_select
operator|=
name|auto_right_margin
condition|?
literal|0
else|:
literal|1
expr_stmt|;
if|if
condition|(
name|is_clear
condition|)
block|{
name|txt
operator|=
literal|"(clear) clear-screen start testing"
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|clr_eos
condition|)
block|{
name|CAP_NOT_FOUND
expr_stmt|;
name|ptext
argument_list|(
literal|"(ed) erase-to-end-of-display, not present.  "
argument_list|)
expr_stmt|;
name|pad_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
return|return;
block|}
name|txt
operator|=
literal|"(ed) erase-to-end-of-display start testing"
expr_stmt|;
block|}
if|if
condition|(
name|skip_pad_test
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|,
name|txt
argument_list|)
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|enter_am_mode
condition|)
block|{
name|tc_putp
argument_list|(
name|enter_am_mode
argument_list|)
expr_stmt|;
name|clear_select
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
init|;
name|clear_select
operator|<
literal|5
condition|;
name|clear_select
operator|++
control|)
block|{
if|if
condition|(
name|augment
operator|>
name|lines
operator|||
name|is_clear
operator|||
operator|!
name|cursor_address
condition|)
block|{
name|augment
operator|=
name|lines
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|augment
operator|<=
literal|1
condition|)
block|{
name|augment
operator|=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|augment
operator|<
name|lines
condition|)
block|{
name|put_clear
argument_list|()
expr_stmt|;
name|tt_putparm
argument_list|(
name|cursor_address
argument_list|,
literal|1
argument_list|,
name|lines
operator|-
name|augment
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ptextln
argument_list|(
literal|"This line should not be erased (ed)"
argument_list|)
expr_stmt|;
block|}
block|}
name|repeats
operator|=
name|augment
expr_stmt|;
switch|switch
condition|(
name|clear_select
condition|)
block|{
case|case
literal|0
case|:
name|end_message
operator|=
literal|"Clear full screen.  "
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|end_message
operator|=
literal|"Clear sparse screen.  "
expr_stmt|;
if|if
condition|(
name|cursor_down
condition|)
block|{
break|break;
block|}
name|clear_select
operator|++
expr_stmt|;
comment|/* FALLTHRU */
case|case
literal|2
case|:
name|end_message
operator|=
literal|"Clear one character per line.  "
expr_stmt|;
if|if
condition|(
name|newline
condition|)
block|{
break|break;
block|}
name|clear_select
operator|++
expr_stmt|;
comment|/* FALLTHRU */
case|case
literal|3
case|:
name|end_message
operator|=
literal|"Clear one full line.  "
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|end_message
operator|=
literal|"Clear single short line.  "
expr_stmt|;
break|break;
block|}
name|pad_test_startup
argument_list|(
literal|0
argument_list|)
expr_stmt|;
do|do
block|{
switch|switch
condition|(
name|clear_select
condition|)
block|{
case|case
literal|0
case|:
comment|/* full screen test */
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|repeats
condition|;
name|j
operator|++
control|)
block|{
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|columns
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|k
operator|&
literal|0xF
condition|)
block|{
name|put_this
argument_list|(
name|letter
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|put_this
argument_list|(
literal|'.'
argument_list|)
expr_stmt|;
block|}
block|}
name|SLOW_TERMINAL_EXIT
expr_stmt|;
block|}
break|break;
case|case
literal|1
case|:
comment|/* sparse screen test */
for|for
control|(
name|j
operator|=
name|columns
operator|-
name|repeats
init|;
name|j
operator|>
literal|2
condition|;
name|j
operator|--
control|)
block|{
name|put_this
argument_list|(
name|letter
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
literal|2
init|;
name|j
operator|<
name|repeats
condition|;
name|j
operator|++
control|)
block|{
name|tt_putp
argument_list|(
name|cursor_down
argument_list|)
expr_stmt|;
name|put_this
argument_list|(
name|letter
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|2
case|:
comment|/* short lines */
for|for
control|(
name|j
operator|=
literal|2
init|;
name|j
operator|<
name|repeats
condition|;
name|j
operator|++
control|)
block|{
name|put_this
argument_list|(
name|letter
argument_list|)
expr_stmt|;
name|tt_putp
argument_list|(
name|newline
argument_list|)
expr_stmt|;
block|}
name|put_this
argument_list|(
name|letter
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* one full line */
for|for
control|(
name|j
operator|=
name|columns
operator|-
literal|5
init|;
name|j
operator|>
literal|1
condition|;
name|j
operator|--
control|)
block|{
name|put_this
argument_list|(
name|letter
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|4
case|:
comment|/* one short line */
name|put_str
argument_list|(
literal|"Erase this!"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|is_clear
condition|)
block|{
name|put_clear
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|augment
operator|==
name|lines
condition|)
block|{
name|go_home
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|tt_putparm
argument_list|(
name|cursor_address
argument_list|,
literal|1
argument_list|,
name|lines
operator|-
name|repeats
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|tt_tputs
argument_list|(
name|clr_eos
argument_list|,
name|repeats
argument_list|)
expr_stmt|;
block|}
name|NEXT_LETTER
expr_stmt|;
block|}
do|while
condition|(
name|still_testing
argument_list|()
condition|)
do|;
name|pad_test_shutdown
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ptext
argument_list|(
name|end_message
argument_list|)
expr_stmt|;
name|pad_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ch
operator|!=
literal|0
operator|&&
operator|*
name|ch
operator|!=
literal|'n'
condition|)
block|{
return|return;
block|}
block|}
block|}
end_function

begin_comment
comment|/* **	pad_ech(test_list, status, ch) ** **	Test (ech) erase characters */
end_comment

begin_function
specifier|static
name|void
name|pad_ech
parameter_list|(
name|struct
name|test_list
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|state
parameter_list|,
name|int
modifier|*
name|ch
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
operator|!
name|erase_chars
condition|)
block|{
name|CAP_NOT_FOUND
expr_stmt|;
name|ptext
argument_list|(
literal|"(ech) Erase-characters, not present.  "
argument_list|)
expr_stmt|;
name|pad_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|skip_pad_test
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|,
literal|"(ech) Erase-characters start testing"
argument_list|)
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|augment
operator|>
name|columns
operator|-
literal|2
condition|)
block|{
name|augment
operator|=
name|columns
operator|-
literal|2
expr_stmt|;
block|}
name|pad_test_startup
argument_list|(
literal|1
argument_list|)
expr_stmt|;
do|do
block|{
name|go_home
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|lines
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
name|repeats
condition|;
name|j
operator|++
control|)
block|{
name|putchp
argument_list|(
name|letter
argument_list|)
expr_stmt|;
block|}
name|put_cr
argument_list|()
expr_stmt|;
name|tt_putparm
argument_list|(
name|erase_chars
argument_list|,
name|repeats
argument_list|,
name|repeats
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|put_crlf
argument_list|()
expr_stmt|;
name|SLOW_TERMINAL_EXIT
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|repeats
condition|;
name|i
operator|++
control|)
block|{
name|putchp
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
name|putchp
argument_list|(
name|letter
argument_list|)
expr_stmt|;
name|put_crlf
argument_list|()
expr_stmt|;
name|NEXT_LETTER
expr_stmt|;
block|}
do|while
condition|(
name|still_testing
argument_list|()
condition|)
do|;
name|pad_test_shutdown
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ptext
argument_list|(
name|all_lines
argument_list|)
expr_stmt|;
name|pad_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
name|put_clear
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **	pad_el1(test_list, status, ch) ** **	Test (el1) erase to start of line also (cub1) and (nel) */
end_comment

begin_function
specifier|static
name|void
name|pad_el1
parameter_list|(
name|struct
name|test_list
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|state
parameter_list|,
name|int
modifier|*
name|ch
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
operator|!
name|clr_bol
condition|)
block|{
name|CAP_NOT_FOUND
expr_stmt|;
name|ptext
argument_list|(
literal|"(el1) Erase-to-beginning-of-line, not present.  "
argument_list|)
expr_stmt|;
name|pad_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|skip_pad_test
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|,
literal|"(el1) Erase-to-beginning-of-line start testing"
argument_list|)
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|augment
operator|>
name|columns
operator|-
literal|2
condition|)
block|{
name|augment
operator|=
name|columns
operator|-
literal|2
expr_stmt|;
block|}
name|pad_test_startup
argument_list|(
literal|1
argument_list|)
expr_stmt|;
do|do
block|{
name|go_home
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|lines
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
name|repeats
condition|;
name|j
operator|++
control|)
block|{
name|putchp
argument_list|(
name|letter
argument_list|)
expr_stmt|;
block|}
name|tt_putp
argument_list|(
name|cursor_left
argument_list|)
expr_stmt|;
name|tt_putp
argument_list|(
name|cursor_left
argument_list|)
expr_stmt|;
name|tt_tputs
argument_list|(
name|clr_bol
argument_list|,
name|repeats
argument_list|)
expr_stmt|;
name|put_crlf
argument_list|()
expr_stmt|;
name|SLOW_TERMINAL_EXIT
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|repeats
condition|;
name|i
operator|++
control|)
block|{
name|putchp
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
name|putchp
argument_list|(
name|letter
argument_list|)
expr_stmt|;
name|put_crlf
argument_list|()
expr_stmt|;
name|NEXT_LETTER
expr_stmt|;
block|}
do|while
condition|(
name|still_testing
argument_list|()
condition|)
do|;
name|pad_test_shutdown
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ptext
argument_list|(
name|all_lines
argument_list|)
expr_stmt|;
name|pad_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
name|put_clear
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **	pad_el(test_list, status, ch) ** **	Test (el) clear to end of line also (nel) */
end_comment

begin_function
specifier|static
name|void
name|pad_el
parameter_list|(
name|struct
name|test_list
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|state
parameter_list|,
name|int
modifier|*
name|ch
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
operator|!
name|clr_eol
condition|)
block|{
name|CAP_NOT_FOUND
expr_stmt|;
name|ptext
argument_list|(
literal|"(el) Clear-to-end-of-line, not present.  "
argument_list|)
expr_stmt|;
name|pad_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|skip_pad_test
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|,
literal|"(el) Clear-to-end-of-line start testing"
argument_list|)
condition|)
block|{
return|return;
block|}
name|hzcc
operator|=
name|columns
operator|*
literal|8
operator|/
literal|10
expr_stmt|;
comment|/* horizontal character count */
if|if
condition|(
name|augment
operator|>
name|hzcc
condition|)
block|{
name|augment
operator|=
name|hzcc
expr_stmt|;
block|}
name|pad_test_startup
argument_list|(
literal|1
argument_list|)
expr_stmt|;
do|do
block|{
name|go_home
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|lines
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
operator|-
literal|1
init|;
name|j
operator|<
name|augment
condition|;
name|j
operator|++
control|)
block|{
name|putchp
argument_list|(
name|letter
argument_list|)
expr_stmt|;
block|}
name|put_cr
argument_list|()
expr_stmt|;
name|putchp
argument_list|(
name|letter
argument_list|)
expr_stmt|;
name|tt_putp
argument_list|(
name|clr_eol
argument_list|)
expr_stmt|;
name|put_crlf
argument_list|()
expr_stmt|;
name|SLOW_TERMINAL_EXIT
expr_stmt|;
block|}
name|putchp
argument_list|(
name|letter
argument_list|)
expr_stmt|;
name|put_crlf
argument_list|()
expr_stmt|;
name|NEXT_LETTER
expr_stmt|;
block|}
do|while
condition|(
name|still_testing
argument_list|()
condition|)
do|;
name|pad_test_shutdown
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ptext
argument_list|(
name|all_lines
argument_list|)
expr_stmt|;
name|pad_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
name|put_clear
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **	pad_smdc(test_list, status, ch) ** **	Test (smdc) (rmdc) Delete mode */
end_comment

begin_function
specifier|static
name|void
name|pad_smdc
parameter_list|(
name|struct
name|test_list
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|state
parameter_list|,
name|int
modifier|*
name|ch
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|enter_delete_mode
condition|)
block|{
name|CAP_NOT_FOUND
expr_stmt|;
name|ptext
argument_list|(
literal|"(smdc) Enter-delete-mode"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|exit_delete_mode
condition|)
block|{
name|ptext
argument_list|(
literal|", (rmdc) Exit-delete-mode"
argument_list|)
expr_stmt|;
block|}
name|ptext
argument_list|(
literal|", not present.  "
argument_list|)
expr_stmt|;
name|pad_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|skip_pad_test
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|,
literal|"(smdc) (rmdc) Enter/Exit-delete-mode start testing"
argument_list|)
condition|)
block|{
return|return;
block|}
name|pad_test_startup
argument_list|(
literal|1
argument_list|)
expr_stmt|;
do|do
block|{
name|page_loop
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|columns
condition|;
name|i
operator|++
control|)
block|{
name|tt_putp
argument_list|(
name|enter_delete_mode
argument_list|)
expr_stmt|;
name|tt_putp
argument_list|(
name|exit_delete_mode
argument_list|)
expr_stmt|;
name|putchp
argument_list|(
name|letter
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|still_testing
argument_list|()
condition|)
do|;
name|pad_test_shutdown
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|home_down
argument_list|()
expr_stmt|;
name|ptext
argument_list|(
name|no_visual
argument_list|)
expr_stmt|;
name|pad_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
name|put_clear
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **	pad_dch(test_list, status, ch) ** **	Test (smdc) (rmdc) Delete mode and (dch) */
end_comment

begin_function
specifier|static
name|void
name|pad_dch
parameter_list|(
name|struct
name|test_list
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|state
parameter_list|,
name|int
modifier|*
name|ch
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
operator|!
name|parm_dch
condition|)
block|{
name|CAP_NOT_FOUND
expr_stmt|;
name|ptext
argument_list|(
literal|"(dch) Delete-characters, not present.  "
argument_list|)
expr_stmt|;
name|pad_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|skip_pad_test
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|,
literal|"(dch) Delete-characters start testing"
argument_list|)
condition|)
block|{
return|return;
block|}
name|hzcc
operator|=
name|columns
operator|*
literal|8
operator|/
literal|10
expr_stmt|;
comment|/* horizontal character count */
if|if
condition|(
name|augment
operator|>
name|hzcc
condition|)
block|{
name|augment
operator|=
name|hzcc
expr_stmt|;
block|}
name|pad_test_startup
argument_list|(
literal|1
argument_list|)
expr_stmt|;
do|do
block|{
name|go_home
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|lines
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
name|repeats
condition|;
name|j
operator|++
control|)
block|{
name|putchp
argument_list|(
name|letter
argument_list|)
expr_stmt|;
block|}
name|put_cr
argument_list|()
expr_stmt|;
name|tt_putp
argument_list|(
name|enter_delete_mode
argument_list|)
expr_stmt|;
name|tt_putparm
argument_list|(
name|parm_dch
argument_list|,
name|repeats
argument_list|,
name|repeats
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_putp
argument_list|(
name|exit_delete_mode
argument_list|)
expr_stmt|;
name|put_crlf
argument_list|()
expr_stmt|;
name|SLOW_TERMINAL_EXIT
expr_stmt|;
block|}
name|putchp
argument_list|(
name|letter
argument_list|)
expr_stmt|;
name|put_crlf
argument_list|()
expr_stmt|;
name|NEXT_LETTER
expr_stmt|;
block|}
do|while
condition|(
name|still_testing
argument_list|()
condition|)
do|;
name|pad_test_shutdown
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|home_down
argument_list|()
expr_stmt|;
name|ptext
argument_list|(
name|all_lines
argument_list|)
expr_stmt|;
name|pad_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
name|put_clear
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **	pad_dch1(test_list, status, ch) ** **	Test (smdc) (rmdc) Delete mode and (dch1) */
end_comment

begin_function
specifier|static
name|void
name|pad_dch1
parameter_list|(
name|struct
name|test_list
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|state
parameter_list|,
name|int
modifier|*
name|ch
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
operator|!
name|delete_character
condition|)
block|{
if|if
condition|(
name|parm_dch
condition|)
block|{
comment|/* if the other one is defined then its OK */
return|return;
block|}
name|CAP_NOT_FOUND
expr_stmt|;
name|ptext
argument_list|(
literal|"(dch1) Delete-character, not present.  "
argument_list|)
expr_stmt|;
name|pad_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|skip_pad_test
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|,
literal|"(dch1) Delete-character start testing"
argument_list|)
condition|)
block|{
return|return;
block|}
name|hzcc
operator|=
name|columns
operator|*
literal|8
operator|/
literal|10
expr_stmt|;
comment|/* horizontal character count */
if|if
condition|(
name|augment
operator|>
name|hzcc
condition|)
block|{
name|augment
operator|=
name|hzcc
expr_stmt|;
block|}
name|pad_test_startup
argument_list|(
literal|1
argument_list|)
expr_stmt|;
do|do
block|{
name|go_home
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|lines
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
operator|-
literal|1
init|;
name|j
operator|<
name|augment
condition|;
name|j
operator|++
control|)
block|{
name|putchp
argument_list|(
name|letter
argument_list|)
expr_stmt|;
block|}
name|put_cr
argument_list|()
expr_stmt|;
name|tt_putp
argument_list|(
name|enter_delete_mode
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|augment
condition|;
name|j
operator|++
control|)
block|{
name|tt_putp
argument_list|(
name|delete_character
argument_list|)
expr_stmt|;
block|}
name|tt_putp
argument_list|(
name|exit_delete_mode
argument_list|)
expr_stmt|;
name|put_crlf
argument_list|()
expr_stmt|;
name|SLOW_TERMINAL_EXIT
expr_stmt|;
block|}
name|putchp
argument_list|(
name|letter
argument_list|)
expr_stmt|;
name|put_crlf
argument_list|()
expr_stmt|;
name|NEXT_LETTER
expr_stmt|;
block|}
do|while
condition|(
name|still_testing
argument_list|()
condition|)
do|;
name|pad_test_shutdown
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ptext
argument_list|(
name|all_lines
argument_list|)
expr_stmt|;
name|pad_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
name|put_clear
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **	pad_smir(test_list, status, ch) ** **	Test (smir) (rmir) Insert mode */
end_comment

begin_function
specifier|static
name|void
name|pad_smir
parameter_list|(
name|struct
name|test_list
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|state
parameter_list|,
name|int
modifier|*
name|ch
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|enter_insert_mode
condition|)
block|{
name|CAP_NOT_FOUND
expr_stmt|;
name|ptext
argument_list|(
literal|"(smir) Enter-insert-mode"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|exit_insert_mode
condition|)
block|{
name|ptext
argument_list|(
literal|", (rmir) Exit-insert-mode"
argument_list|)
expr_stmt|;
block|}
name|ptext
argument_list|(
literal|", not present.  "
argument_list|)
expr_stmt|;
name|pad_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|skip_pad_test
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|,
literal|"(smir) (rmir) Enter/Exit-insert-mode start testing"
argument_list|)
condition|)
block|{
return|return;
block|}
name|pad_test_startup
argument_list|(
literal|1
argument_list|)
expr_stmt|;
do|do
block|{
name|page_loop
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|columns
condition|;
name|i
operator|++
control|)
block|{
name|tt_putp
argument_list|(
name|enter_insert_mode
argument_list|)
expr_stmt|;
name|tt_putp
argument_list|(
name|exit_insert_mode
argument_list|)
expr_stmt|;
name|putchp
argument_list|(
name|letter
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|still_testing
argument_list|()
condition|)
do|;
name|pad_test_shutdown
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|home_down
argument_list|()
expr_stmt|;
name|ptext
argument_list|(
name|no_visual
argument_list|)
expr_stmt|;
name|pad_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
name|put_clear
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **	pad_ich(test_list, status, ch) ** **	Test (smir) (rmir) Insert mode and (ich) and (ip) */
end_comment

begin_function
specifier|static
name|void
name|pad_ich
parameter_list|(
name|struct
name|test_list
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|state
parameter_list|,
name|int
modifier|*
name|ch
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
operator|!
name|parm_ich
condition|)
block|{
name|CAP_NOT_FOUND
expr_stmt|;
name|ptext
argument_list|(
literal|"(ich) Insert-characters, not present.  "
argument_list|)
expr_stmt|;
name|pad_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|skip_pad_test
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|,
literal|"(ich) Insert-characters, (ip) Insert-padding start testing"
argument_list|)
condition|)
block|{
return|return;
block|}
name|j
operator|=
name|columns
operator|*
literal|9
operator|/
literal|10
expr_stmt|;
if|if
condition|(
name|augment
operator|>
name|j
condition|)
block|{
name|augment
operator|=
name|j
expr_stmt|;
block|}
name|pad_test_startup
argument_list|(
literal|1
argument_list|)
expr_stmt|;
do|do
block|{
name|go_home
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|lines
condition|;
name|i
operator|++
control|)
block|{
name|putchp
argument_list|(
name|letter
argument_list|)
expr_stmt|;
name|put_cr
argument_list|()
expr_stmt|;
name|tt_putp
argument_list|(
name|enter_insert_mode
argument_list|)
expr_stmt|;
name|replace_mode
operator|=
literal|0
expr_stmt|;
name|tt_putparm
argument_list|(
name|parm_ich
argument_list|,
name|repeats
argument_list|,
name|repeats
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_putp
argument_list|(
name|exit_insert_mode
argument_list|)
expr_stmt|;
name|replace_mode
operator|=
literal|1
expr_stmt|;
name|put_crlf
argument_list|()
expr_stmt|;
name|SLOW_TERMINAL_EXIT
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|repeats
condition|;
name|i
operator|++
control|)
block|{
name|putchp
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
name|putchp
argument_list|(
name|letter
argument_list|)
expr_stmt|;
name|NEXT_LETTER
expr_stmt|;
name|put_crlf
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|still_testing
argument_list|()
condition|)
do|;
name|pad_test_shutdown
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ptext
argument_list|(
name|all_lines
argument_list|)
expr_stmt|;
name|pad_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
name|tc_putp
argument_list|(
name|exit_insert_mode
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **	pad_ich1(test_list, status, ch) ** **	Test (smir) (rmir) Insert mode and (ich1) and (ip) */
end_comment

begin_function
specifier|static
name|void
name|pad_ich1
parameter_list|(
name|struct
name|test_list
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|state
parameter_list|,
name|int
modifier|*
name|ch
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
operator|!
name|insert_character
condition|)
block|{
name|CAP_NOT_FOUND
expr_stmt|;
name|ptext
argument_list|(
literal|"(ich1) Insert-character, not present.  "
argument_list|)
expr_stmt|;
name|pad_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|skip_pad_test
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|,
literal|"(ich1) Insert-character, (ip) Insert-padding start testing"
argument_list|)
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|augment
operator|>
name|columns
operator|-
literal|2
condition|)
block|{
name|augment
operator|=
name|columns
operator|-
literal|2
expr_stmt|;
block|}
name|pad_test_startup
argument_list|(
literal|1
argument_list|)
expr_stmt|;
do|do
block|{
name|put_clear
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|lines
condition|;
name|i
operator|++
control|)
block|{
name|putchp
argument_list|(
name|letter
argument_list|)
expr_stmt|;
name|put_cr
argument_list|()
expr_stmt|;
name|tt_putp
argument_list|(
name|enter_insert_mode
argument_list|)
expr_stmt|;
name|replace_mode
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|insert_padding
operator|&&
operator|!
name|insert_character
condition|)
block|{
comment|/* only enter/exit is needed */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|augment
condition|;
name|j
operator|++
control|)
block|{
name|putchp
argument_list|(
literal|'.'
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|augment
condition|;
name|j
operator|++
control|)
block|{
name|tt_putp
argument_list|(
name|insert_character
argument_list|)
expr_stmt|;
name|putchp
argument_list|(
literal|'.'
argument_list|)
expr_stmt|;
name|tt_putp
argument_list|(
name|insert_padding
argument_list|)
expr_stmt|;
block|}
block|}
name|tt_putp
argument_list|(
name|exit_insert_mode
argument_list|)
expr_stmt|;
name|replace_mode
operator|=
literal|1
expr_stmt|;
name|put_crlf
argument_list|()
expr_stmt|;
name|SLOW_TERMINAL_EXIT
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|augment
condition|;
name|j
operator|++
control|)
block|{
name|putchp
argument_list|(
literal|'.'
argument_list|)
expr_stmt|;
block|}
name|putchp
argument_list|(
name|letter
argument_list|)
expr_stmt|;
name|NEXT_LETTER
expr_stmt|;
name|put_crlf
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|still_testing
argument_list|()
condition|)
do|;
name|pad_test_shutdown
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ptext
argument_list|(
name|all_lines
argument_list|)
expr_stmt|;
name|pad_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
name|tc_putp
argument_list|(
name|exit_insert_mode
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **	pad_xch1(test_list, status, ch) ** **	Test (ich1) (ip) (dch1) */
end_comment

begin_function
specifier|static
name|void
name|pad_xch1
parameter_list|(
name|struct
name|test_list
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|state
parameter_list|,
name|int
modifier|*
name|ch
parameter_list|)
block|{
specifier|static
name|char
name|xch1
index|[]
init|=
literal|"This line should not be garbled. It should be left justified."
decl_stmt|;
if|if
condition|(
name|enter_insert_mode
operator|||
name|exit_insert_mode
operator|||
name|enter_delete_mode
operator|||
name|exit_delete_mode
operator|||
operator|!
name|insert_character
operator|||
operator|!
name|delete_character
condition|)
block|{
comment|/* this test is quietly ignored */
return|return;
block|}
if|if
condition|(
name|skip_pad_test
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|,
literal|"(ich1) Insert-character, (dch1) Delete-character start testing"
argument_list|)
condition|)
block|{
return|return;
block|}
name|put_crlf
argument_list|()
expr_stmt|;
name|ptext
argument_list|(
name|xch1
argument_list|)
expr_stmt|;
name|put_cr
argument_list|()
expr_stmt|;
name|pad_test_startup
argument_list|(
literal|0
argument_list|)
expr_stmt|;
do|do
block|{
name|tt_putp
argument_list|(
name|insert_character
argument_list|)
expr_stmt|;
name|tt_putp
argument_list|(
name|delete_character
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|still_testing
argument_list|()
condition|)
do|;
name|pad_test_shutdown
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ptextln
argument_list|(
name|xch1
argument_list|)
expr_stmt|;
name|ptext
argument_list|(
literal|"The preceding two lines should be the same.  "
argument_list|)
expr_stmt|;
name|pad_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **	pad_rep(test_list, status, ch) ** **	Test (rep) repeat character */
end_comment

begin_function
specifier|static
name|void
name|pad_rep
parameter_list|(
name|struct
name|test_list
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|state
parameter_list|,
name|int
modifier|*
name|ch
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
operator|!
name|repeat_char
condition|)
block|{
name|CAP_NOT_FOUND
expr_stmt|;
name|ptext
argument_list|(
literal|"(rep) Repeat-character, not present.  "
argument_list|)
expr_stmt|;
name|pad_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|skip_pad_test
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|,
literal|"(rep) Repeat-character start testing"
argument_list|)
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|augment
operator|>
name|columns
operator|-
literal|2
condition|)
block|{
name|augment
operator|=
name|columns
operator|-
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|augment
operator|<
literal|2
condition|)
block|{
name|augment
operator|=
literal|2
expr_stmt|;
block|}
name|pad_test_startup
argument_list|(
literal|1
argument_list|)
expr_stmt|;
do|do
block|{
name|go_home
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|lines
condition|;
name|i
operator|++
control|)
block|{
name|tt_putparm
argument_list|(
name|repeat_char
argument_list|,
name|repeats
argument_list|,
name|letter
argument_list|,
name|repeats
argument_list|)
expr_stmt|;
name|put_crlf
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|repeats
condition|;
name|j
operator|++
control|)
block|{
name|putchp
argument_list|(
name|letter
argument_list|)
expr_stmt|;
block|}
name|put_crlf
argument_list|()
expr_stmt|;
name|NEXT_LETTER
expr_stmt|;
block|}
do|while
condition|(
name|still_testing
argument_list|()
condition|)
do|;
name|pad_test_shutdown
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ptextln
argument_list|(
name|all_lines
argument_list|)
expr_stmt|;
name|pad_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **	pad_cup(test_list, status, ch) ** **	Test (cup) Cursor address */
end_comment

begin_function
specifier|static
name|void
name|pad_cup
parameter_list|(
name|struct
name|test_list
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|state
parameter_list|,
name|int
modifier|*
name|ch
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|l
decl_stmt|,
name|r
decl_stmt|,
name|c
decl_stmt|;
if|if
condition|(
operator|!
name|cursor_address
condition|)
block|{
name|CAP_NOT_FOUND
expr_stmt|;
name|ptext
argument_list|(
literal|"(cup) Cursor-address not present.  "
argument_list|)
expr_stmt|;
name|pad_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|skip_pad_test
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|,
literal|"(cup) Cursor-address start testing"
argument_list|)
condition|)
block|{
return|return;
block|}
name|put_clear
argument_list|()
expr_stmt|;
name|ptext
argument_list|(
literal|"Each line should be filled with the same letter.  There should"
argument_list|)
expr_stmt|;
name|ptext
argument_list|(
literal|" be no gaps, or single letters scattered over the screen.  "
argument_list|)
expr_stmt|;
if|if
condition|(
name|char_count
operator|+
literal|15
operator|>
name|columns
condition|)
block|{
name|put_crlf
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|(
name|lines
operator|-
name|line_count
operator|)
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* this removes the gap in the middle of the test when the 		number of lines is odd.  */
name|put_crlf
argument_list|()
expr_stmt|;
block|}
name|r
operator|=
name|line_count
expr_stmt|;
name|c
operator|=
name|char_count
expr_stmt|;
name|l
operator|=
operator|(
name|columns
operator|-
literal|4
operator|)
operator|>>
literal|1
expr_stmt|;
name|pad_test_startup
argument_list|(
literal|0
argument_list|)
expr_stmt|;
do|do
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|+
name|i
operator|+
name|r
operator|<
name|lines
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
name|l
condition|;
name|j
operator|++
control|)
block|{
name|tt_putparm
argument_list|(
name|cursor_address
argument_list|,
literal|1
argument_list|,
name|r
operator|+
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|putchp
argument_list|(
name|letter
argument_list|)
expr_stmt|;
name|tt_putparm
argument_list|(
name|cursor_address
argument_list|,
literal|1
argument_list|,
name|r
operator|+
name|i
argument_list|,
name|l
operator|+
name|l
operator|+
literal|1
operator|-
name|j
argument_list|)
expr_stmt|;
name|putchp
argument_list|(
name|letter
argument_list|)
expr_stmt|;
name|tt_putparm
argument_list|(
name|cursor_address
argument_list|,
literal|1
argument_list|,
name|lines
operator|-
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|putchp
argument_list|(
name|letter
argument_list|)
expr_stmt|;
name|tt_putparm
argument_list|(
name|cursor_address
argument_list|,
literal|1
argument_list|,
name|lines
operator|-
name|i
argument_list|,
name|l
operator|+
name|l
operator|+
literal|1
operator|-
name|j
argument_list|)
expr_stmt|;
name|putchp
argument_list|(
name|letter
argument_list|)
expr_stmt|;
block|}
name|SLOW_TERMINAL_EXIT
expr_stmt|;
block|}
name|NEXT_LETTER
expr_stmt|;
block|}
do|while
condition|(
name|still_testing
argument_list|()
condition|)
do|;
name|pad_test_shutdown
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tt_putparm
argument_list|(
name|cursor_address
argument_list|,
literal|1
argument_list|,
name|line_count
operator|=
name|r
argument_list|,
name|char_count
operator|=
name|c
argument_list|)
expr_stmt|;
name|pad_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
name|put_clear
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **	pad_hd(test_list, status, ch) ** **	Test (hd) Half down */
end_comment

begin_function
specifier|static
name|void
name|pad_hd
parameter_list|(
name|struct
name|test_list
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|state
parameter_list|,
name|int
modifier|*
name|ch
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
if|if
condition|(
operator|!
name|down_half_line
condition|)
block|{
name|CAP_NOT_FOUND
expr_stmt|;
name|ptext
argument_list|(
literal|"(hd) Half-line-down not present.  "
argument_list|)
expr_stmt|;
name|pad_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|skip_pad_test
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|,
literal|"(hd) Half-line-down start testing"
argument_list|)
condition|)
block|{
return|return;
block|}
name|pad_test_startup
argument_list|(
literal|1
argument_list|)
expr_stmt|;
do|do
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|columns
condition|;
name|i
operator|+=
literal|2
control|)
block|{
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|i
condition|;
operator|++
name|j
control|)
block|{
name|putchp
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
name|tt_putp
argument_list|(
name|down_half_line
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
name|lines
operator|+
name|lines
init|;
name|k
operator|>
literal|4
condition|;
name|k
operator|--
control|)
block|{
if|if
condition|(
name|j
operator|++
operator|>=
name|columns
condition|)
block|{
break|break;
block|}
name|tt_putp
argument_list|(
name|down_half_line
argument_list|)
expr_stmt|;
name|putchp
argument_list|(
name|letter
argument_list|)
expr_stmt|;
block|}
name|go_home
argument_list|()
expr_stmt|;
name|SLOW_TERMINAL_EXIT
expr_stmt|;
block|}
name|NEXT_LETTER
expr_stmt|;
block|}
do|while
condition|(
name|still_testing
argument_list|()
condition|)
do|;
name|pad_test_shutdown
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pad_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
name|put_clear
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **	pad_hu(test_list, status, ch) ** **	Test (hu) Half line up */
end_comment

begin_function
specifier|static
name|void
name|pad_hu
parameter_list|(
name|struct
name|test_list
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|state
parameter_list|,
name|int
modifier|*
name|ch
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
if|if
condition|(
operator|!
name|up_half_line
condition|)
block|{
name|CAP_NOT_FOUND
expr_stmt|;
name|ptext
argument_list|(
literal|"(hu) Half-line-up not present.  "
argument_list|)
expr_stmt|;
name|pad_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|skip_pad_test
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|,
literal|"(hu) Half-line-up start testing"
argument_list|)
condition|)
block|{
return|return;
block|}
name|pad_test_startup
argument_list|(
literal|1
argument_list|)
expr_stmt|;
do|do
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|columns
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|home_down
argument_list|()
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|i
condition|;
operator|++
name|j
control|)
block|{
name|putchp
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
name|tt_putp
argument_list|(
name|up_half_line
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
name|lines
operator|+
name|lines
init|;
name|k
operator|>
literal|4
condition|;
name|k
operator|--
control|)
block|{
if|if
condition|(
name|j
operator|++
operator|>=
name|columns
condition|)
block|{
break|break;
block|}
name|tt_putp
argument_list|(
name|up_half_line
argument_list|)
expr_stmt|;
name|putchp
argument_list|(
name|letter
argument_list|)
expr_stmt|;
block|}
name|SLOW_TERMINAL_EXIT
expr_stmt|;
block|}
name|go_home
argument_list|()
expr_stmt|;
name|NEXT_LETTER
expr_stmt|;
block|}
do|while
condition|(
name|still_testing
argument_list|()
condition|)
do|;
name|pad_test_shutdown
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pad_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
name|put_clear
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **	pad_rin(test_list, status, ch) ** **	Test (rin) and (ri) Reverse index */
end_comment

begin_function
specifier|static
name|void
name|pad_rin
parameter_list|(
name|struct
name|test_list
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|state
parameter_list|,
name|int
modifier|*
name|ch
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|start_message
decl_stmt|;
if|if
condition|(
name|t
operator|->
name|flags
operator|&
literal|1
condition|)
block|{
comment|/* rin */
if|if
condition|(
operator|!
name|parm_rindex
condition|)
block|{
name|CAP_NOT_FOUND
expr_stmt|;
name|ptext
argument_list|(
literal|"(rin) Scroll-reverse-n-lines not present.  "
argument_list|)
expr_stmt|;
name|pad_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
return|return;
block|}
name|start_message
operator|=
literal|"(rin) Scroll-reverse-n-lines start testing"
expr_stmt|;
block|}
else|else
block|{
comment|/* ri */
if|if
condition|(
operator|!
name|scroll_reverse
condition|)
block|{
name|CAP_NOT_FOUND
expr_stmt|;
name|ptext
argument_list|(
literal|"(ri) Scroll-reverse not present.  "
argument_list|)
expr_stmt|;
name|pad_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
return|return;
block|}
name|start_message
operator|=
literal|"(ri) Scroll-reverse start testing"
expr_stmt|;
name|augment
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|skip_pad_test
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|,
name|start_message
argument_list|)
condition|)
block|{
return|return;
block|}
name|pad_test_startup
argument_list|(
literal|1
argument_list|)
expr_stmt|;
do|do
block|{
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"%d\r"
argument_list|,
name|test_complete
argument_list|)
expr_stmt|;
name|put_str
argument_list|(
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|scroll_reverse
operator|&&
name|repeats
operator|==
literal|1
condition|)
block|{
name|tt_putp
argument_list|(
name|scroll_reverse
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tt_putparm
argument_list|(
name|parm_rindex
argument_list|,
name|repeats
argument_list|,
name|repeats
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|still_testing
argument_list|()
condition|)
do|;
name|put_str
argument_list|(
literal|"This line should be on the bottom.\r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|scroll_reverse
operator|&&
name|augment
operator|==
literal|1
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|lines
condition|;
name|i
operator|++
control|)
block|{
name|tt_putp
argument_list|(
name|scroll_reverse
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|tt_putparm
argument_list|(
name|parm_rindex
argument_list|,
name|lines
operator|-
literal|1
argument_list|,
name|lines
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|putln
argument_list|(
literal|"The screen should have text on the bottom line."
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"Scroll reverse %d line%s.  "
argument_list|,
name|augment
argument_list|,
name|augment
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|)
expr_stmt|;
name|put_str
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|pad_test_shutdown
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pad_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
name|put_clear
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **	pad_il(test_list, status, ch) ** **	Test (il) and (il1) Insert line */
end_comment

begin_function
specifier|static
name|void
name|pad_il
parameter_list|(
name|struct
name|test_list
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|state
parameter_list|,
name|int
modifier|*
name|ch
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|start_message
decl_stmt|;
if|if
condition|(
name|t
operator|->
name|flags
operator|&
literal|1
condition|)
block|{
comment|/* il */
if|if
condition|(
operator|!
name|parm_insert_line
condition|)
block|{
name|CAP_NOT_FOUND
expr_stmt|;
name|ptext
argument_list|(
literal|"(il) Insert-lines not present.  "
argument_list|)
expr_stmt|;
name|pad_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
return|return;
block|}
name|start_message
operator|=
literal|"(il) Insert-lines start testing"
expr_stmt|;
block|}
else|else
block|{
comment|/* il1 */
if|if
condition|(
operator|!
name|insert_line
condition|)
block|{
name|CAP_NOT_FOUND
expr_stmt|;
name|ptext
argument_list|(
literal|"(il1) Insert-line not present.  "
argument_list|)
expr_stmt|;
name|pad_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
return|return;
block|}
name|start_message
operator|=
literal|"(il1) Insert-line start testing"
expr_stmt|;
name|augment
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|skip_pad_test
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|,
name|start_message
argument_list|)
condition|)
block|{
return|return;
block|}
name|pad_test_startup
argument_list|(
literal|1
argument_list|)
expr_stmt|;
do|do
block|{
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"%d\r"
argument_list|,
name|test_complete
argument_list|)
expr_stmt|;
name|put_str
argument_list|(
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|insert_line
operator|&&
name|repeats
operator|==
literal|1
condition|)
block|{
name|tt_putp
argument_list|(
name|insert_line
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tt_putparm
argument_list|(
name|parm_insert_line
argument_list|,
name|repeats
argument_list|,
name|repeats
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|still_testing
argument_list|()
condition|)
do|;
name|put_str
argument_list|(
literal|"This line should be on the bottom.\r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|insert_line
operator|&&
name|augment
operator|==
literal|1
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|lines
condition|;
name|i
operator|++
control|)
block|{
name|tt_putp
argument_list|(
name|insert_line
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|tt_putparm
argument_list|(
name|parm_insert_line
argument_list|,
name|lines
operator|-
literal|1
argument_list|,
name|lines
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|putln
argument_list|(
literal|"The screen should have text on the bottom line."
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"Insert %d line%s.  "
argument_list|,
name|augment
argument_list|,
name|augment
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|)
expr_stmt|;
name|put_str
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|pad_test_shutdown
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pad_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
name|put_clear
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **	pad_indn(test_list, status, ch) ** **	Test (indn) and (ind) Scroll forward */
end_comment

begin_function
specifier|static
name|void
name|pad_indn
parameter_list|(
name|struct
name|test_list
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|state
parameter_list|,
name|int
modifier|*
name|ch
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|start_message
decl_stmt|;
if|if
condition|(
name|t
operator|->
name|flags
operator|&
literal|1
condition|)
block|{
comment|/* indn */
if|if
condition|(
operator|!
name|parm_index
condition|)
block|{
name|CAP_NOT_FOUND
expr_stmt|;
name|ptext
argument_list|(
literal|"(indn) Scroll-forward-n-lines not present.  "
argument_list|)
expr_stmt|;
name|pad_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
return|return;
block|}
name|start_message
operator|=
literal|"(indn) Scroll-forward-n-lines start testing"
expr_stmt|;
block|}
else|else
block|{
comment|/* ind */
if|if
condition|(
operator|!
name|scroll_forward
condition|)
block|{
name|CAP_NOT_FOUND
expr_stmt|;
name|ptext
argument_list|(
literal|"(ind) Scroll-forward not present.  "
argument_list|)
expr_stmt|;
name|pad_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|over_strike
condition|)
block|{
name|ptext
argument_list|(
literal|"(ind) Scroll-forward not tested on overstrike terminals.  "
argument_list|)
expr_stmt|;
name|pad_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
return|return;
block|}
name|start_message
operator|=
literal|"(ind) Scroll-forward start testing"
expr_stmt|;
name|augment
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|skip_pad_test
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|,
name|start_message
argument_list|)
condition|)
block|{
return|return;
block|}
name|pad_test_startup
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* go to the bottom of the screen */
name|home_down
argument_list|()
expr_stmt|;
do|do
block|{
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"%d\r"
argument_list|,
name|test_complete
argument_list|)
expr_stmt|;
name|put_str
argument_list|(
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|scroll_forward
operator|&&
name|repeats
operator|==
literal|1
condition|)
block|{
name|put_ind
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|tt_putparm
argument_list|(
name|parm_index
argument_list|,
name|repeats
argument_list|,
name|repeats
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|still_testing
argument_list|()
condition|)
do|;
name|put_str
argument_list|(
literal|"This line should be on the top.\r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|scroll_forward
operator|&&
name|augment
operator|==
literal|1
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|lines
condition|;
name|i
operator|++
control|)
block|{
name|put_ind
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|tt_putparm
argument_list|(
name|parm_index
argument_list|,
name|lines
operator|-
literal|1
argument_list|,
name|lines
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|go_home
argument_list|()
expr_stmt|;
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"\nScroll forward %d line%s.  "
argument_list|,
name|augment
argument_list|,
name|augment
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|)
expr_stmt|;
name|put_str
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|pad_test_shutdown
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pad_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **	pad_dl(test_list, status, ch) ** **	Test (dl) and (dl1) Delete lines */
end_comment

begin_function
specifier|static
name|void
name|pad_dl
parameter_list|(
name|struct
name|test_list
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|state
parameter_list|,
name|int
modifier|*
name|ch
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|start_message
decl_stmt|;
if|if
condition|(
name|t
operator|->
name|flags
operator|&
literal|1
condition|)
block|{
comment|/* dl */
if|if
condition|(
operator|!
name|parm_delete_line
condition|)
block|{
name|CAP_NOT_FOUND
expr_stmt|;
name|ptext
argument_list|(
literal|"(dl) Delete-lines not present.  "
argument_list|)
expr_stmt|;
name|pad_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
return|return;
block|}
name|start_message
operator|=
literal|"(dl) Delete-lines start testing"
expr_stmt|;
block|}
else|else
block|{
comment|/* dl1 */
if|if
condition|(
operator|!
name|delete_line
condition|)
block|{
name|CAP_NOT_FOUND
expr_stmt|;
name|ptext
argument_list|(
literal|"(dl1) Delete-line not present.  "
argument_list|)
expr_stmt|;
name|pad_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
return|return;
block|}
name|start_message
operator|=
literal|"(dl1) Delete-line start testing"
expr_stmt|;
name|augment
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|skip_pad_test
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|,
name|start_message
argument_list|)
condition|)
block|{
return|return;
block|}
name|pad_test_startup
argument_list|(
literal|1
argument_list|)
expr_stmt|;
do|do
block|{
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"%d\r"
argument_list|,
name|test_complete
argument_list|)
expr_stmt|;
if|if
condition|(
name|augment
operator|<
name|lines
operator|-
literal|1
condition|)
block|{
name|go_home
argument_list|()
expr_stmt|;
name|putln
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
name|put_str
argument_list|(
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|delete_line
operator|&&
name|repeats
operator|==
literal|1
condition|)
block|{
name|tt_putp
argument_list|(
name|delete_line
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tt_putparm
argument_list|(
name|parm_delete_line
argument_list|,
name|repeats
argument_list|,
name|repeats
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|still_testing
argument_list|()
condition|)
do|;
name|home_down
argument_list|()
expr_stmt|;
name|put_str
argument_list|(
literal|"This line should be on the top."
argument_list|)
expr_stmt|;
name|go_home
argument_list|()
expr_stmt|;
if|if
condition|(
name|delete_line
operator|&&
name|augment
operator|==
literal|1
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|lines
condition|;
name|i
operator|++
control|)
block|{
name|tt_putp
argument_list|(
name|delete_line
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|tt_putparm
argument_list|(
name|parm_delete_line
argument_list|,
name|lines
operator|-
literal|1
argument_list|,
name|lines
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"\nDelete %d line%s.  "
argument_list|,
name|augment
argument_list|,
name|augment
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|)
expr_stmt|;
name|put_str
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|pad_test_shutdown
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pad_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **	pad_xl(test_list, status, ch) ** **	Test (il1) Insert and (dl1) Delete lines */
end_comment

begin_function
specifier|static
name|void
name|pad_xl
parameter_list|(
name|struct
name|test_list
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|state
parameter_list|,
name|int
modifier|*
name|ch
parameter_list|)
block|{
if|if
condition|(
operator|!
name|insert_line
operator|&&
operator|!
name|delete_line
condition|)
block|{
comment|/* quietly skip this test */
return|return;
block|}
if|if
condition|(
name|skip_pad_test
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|,
literal|"(il1) Insert-line, (dl1) Delete-line start testing"
argument_list|)
condition|)
block|{
return|return;
block|}
name|put_clear
argument_list|()
expr_stmt|;
name|putln
argument_list|(
literal|"\rThis text is written on the first line."
argument_list|)
expr_stmt|;
name|ptext
argument_list|(
literal|"This sentence begins on the second line.  As this"
argument_list|)
expr_stmt|;
name|ptext
argument_list|(
literal|" test runs the bottom part of this paragraph will"
argument_list|)
expr_stmt|;
name|ptext
argument_list|(
literal|" jump up and down.  Don't worry, that's normal.  When"
argument_list|)
expr_stmt|;
name|ptext
argument_list|(
literal|" the jumping stops, the entire paragraph should"
argument_list|)
expr_stmt|;
name|ptext
argument_list|(
literal|" still be on the screen and in the same place as when"
argument_list|)
expr_stmt|;
name|ptext
argument_list|(
literal|" the test started.  If this paragraph has scrolled"
argument_list|)
expr_stmt|;
name|ptext
argument_list|(
literal|" off the top or bottom of the screen then the test"
argument_list|)
expr_stmt|;
name|ptext
argument_list|(
literal|" has failed.  Scrolling off the top of the screen"
argument_list|)
expr_stmt|;
name|ptext
argument_list|(
literal|" usually means that the delete line capability is"
argument_list|)
expr_stmt|;
name|ptext
argument_list|(
literal|" working better than the insert line capability.  If"
argument_list|)
expr_stmt|;
name|ptext
argument_list|(
literal|" the text scrolls off the bottom then delete line may"
argument_list|)
expr_stmt|;
name|ptext
argument_list|(
literal|" be broken.  If parts of the text are missing then"
argument_list|)
expr_stmt|;
name|ptext
argument_list|(
literal|" you should get professional help."
argument_list|)
expr_stmt|;
name|put_crlf
argument_list|()
expr_stmt|;
name|go_home
argument_list|()
expr_stmt|;
name|put_newlines
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|pad_test_startup
argument_list|(
literal|0
argument_list|)
expr_stmt|;
do|do
block|{
name|tt_putp
argument_list|(
name|insert_line
argument_list|)
expr_stmt|;
name|put_cr
argument_list|()
expr_stmt|;
name|tt_putp
argument_list|(
name|delete_line
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|still_testing
argument_list|()
condition|)
do|;
name|pad_test_shutdown
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|home_down
argument_list|()
expr_stmt|;
name|ptext
argument_list|(
literal|"The top of the screen should have a paragraph of text.  "
argument_list|)
expr_stmt|;
name|pad_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **	pad_scrc(test_list, status, ch) ** **	Test (sc) (rc) Save/restore cursor */
end_comment

begin_function
specifier|static
name|void
name|pad_scrc
parameter_list|(
name|struct
name|test_list
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|state
parameter_list|,
name|int
modifier|*
name|ch
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|save_cursor
operator|||
operator|!
name|restore_cursor
condition|)
block|{
name|CAP_NOT_FOUND
expr_stmt|;
if|if
condition|(
name|save_cursor
condition|)
block|{
name|ptext
argument_list|(
literal|"(rc) Restore-cursor"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|restore_cursor
condition|)
block|{
name|ptext
argument_list|(
literal|"(sc) Save-cursor"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ptext
argument_list|(
literal|"(sc) Save-cursor, (rc) Restore-cursor"
argument_list|)
expr_stmt|;
block|}
name|ptext
argument_list|(
literal|" not present.  "
argument_list|)
expr_stmt|;
name|pad_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|skip_pad_test
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|,
literal|"(sc) (rc) Save/Restore-cursor start testing"
argument_list|)
condition|)
block|{
return|return;
block|}
name|pad_test_startup
argument_list|(
literal|1
argument_list|)
expr_stmt|;
do|do
block|{
name|page_loop
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|columns
condition|;
name|i
operator|++
control|)
block|{
name|tt_putp
argument_list|(
name|save_cursor
argument_list|)
expr_stmt|;
name|putchp
argument_list|(
name|letter
argument_list|)
expr_stmt|;
name|tt_putp
argument_list|(
name|restore_cursor
argument_list|)
expr_stmt|;
name|putchp
argument_list|(
literal|'X'
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|still_testing
argument_list|()
condition|)
do|;
name|pad_test_shutdown
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|home_down
argument_list|()
expr_stmt|;
name|ptext
argument_list|(
name|above_line
argument_list|)
expr_stmt|;
name|pad_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **	pad_csrind(test_list, status, ch) ** **	Test (csr) and (ind) Change scroll region and index. */
end_comment

begin_function
specifier|static
name|void
name|pad_csrind
parameter_list|(
name|struct
name|test_list
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|state
parameter_list|,
name|int
modifier|*
name|ch
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|change_scroll_region
condition|)
block|{
name|CAP_NOT_FOUND
expr_stmt|;
name|ptext
argument_list|(
literal|"(csr) Change-scroll-region not present.  "
argument_list|)
expr_stmt|;
name|pad_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|skip_pad_test
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|,
literal|"(csr) Save/Restore-cursor, (ind) index start testing"
argument_list|)
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|augment
operator|<
literal|2
condition|)
block|{
name|augment
operator|=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|augment
operator|>
name|lines
operator|-
literal|1
condition|)
block|{
name|augment
operator|=
name|lines
operator|-
literal|1
expr_stmt|;
block|}
name|put_clear
argument_list|()
expr_stmt|;
name|ptext
argument_list|(
literal|"This text is on the top line."
argument_list|)
expr_stmt|;
name|tt_putparm
argument_list|(
name|change_scroll_region
argument_list|,
literal|1
argument_list|,
name|lines
operator|-
name|augment
argument_list|,
name|lines
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* go to the bottom of the screen */
name|home_down
argument_list|()
expr_stmt|;
name|pad_test_startup
argument_list|(
literal|0
argument_list|)
expr_stmt|;
do|do
block|{
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"%d\r"
argument_list|,
name|test_complete
argument_list|)
expr_stmt|;
name|put_str
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|put_ind
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|still_testing
argument_list|()
condition|)
do|;
name|ptextln
argument_list|(
literal|"(csr) is broken."
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|augment
init|;
name|i
operator|>
literal|1
condition|;
name|i
operator|--
control|)
block|{
name|put_ind
argument_list|()
expr_stmt|;
block|}
name|pad_test_shutdown
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ptext
argument_list|(
literal|"All but top and bottom lines should be blank.  "
argument_list|)
expr_stmt|;
name|pad_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
name|tt_putparm
argument_list|(
name|change_scroll_region
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|lines
operator|-
literal|1
argument_list|)
expr_stmt|;
name|put_clear
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **	pad_sccsrrc(test_list, status, ch) ** **	Test (sc) (csr) and (rc) Save/Change/Restore scroll region */
end_comment

begin_function
specifier|static
name|void
name|pad_sccsrrc
parameter_list|(
name|struct
name|test_list
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|state
parameter_list|,
name|int
modifier|*
name|ch
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|save_cursor
operator|||
operator|!
name|change_scroll_region
operator|||
operator|!
name|restore_cursor
condition|)
block|{
comment|/* quietly ignore this test */
return|return;
block|}
if|if
condition|(
name|skip_pad_test
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|,
literal|"(sc) (csr) (rc) Save/Change/Restore-cursor, start testing"
argument_list|)
condition|)
block|{
return|return;
block|}
name|pad_test_startup
argument_list|(
literal|1
argument_list|)
expr_stmt|;
do|do
block|{
name|page_loop
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|columns
condition|;
name|i
operator|++
control|)
block|{
name|tt_putp
argument_list|(
name|save_cursor
argument_list|)
expr_stmt|;
name|putchp
argument_list|(
name|letter
argument_list|)
expr_stmt|;
name|tt_putparm
argument_list|(
name|change_scroll_region
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|lines
operator|-
literal|1
argument_list|)
expr_stmt|;
name|tt_putp
argument_list|(
name|restore_cursor
argument_list|)
expr_stmt|;
name|putchp
argument_list|(
literal|'X'
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|still_testing
argument_list|()
condition|)
do|;
name|pad_test_shutdown
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|home_down
argument_list|()
expr_stmt|;
name|ptext
argument_list|(
name|above_line
argument_list|)
expr_stmt|;
name|pad_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
name|tt_putparm
argument_list|(
name|change_scroll_region
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|lines
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **	pad_csr_nel(test_list, status, ch) ** **	Test (sc) (csr) (nel) and (rc) Save/Change/Restore scroll region */
end_comment

begin_function
specifier|static
name|void
name|pad_csr_nel
parameter_list|(
name|struct
name|test_list
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|state
parameter_list|,
name|int
modifier|*
name|ch
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
operator|!
name|save_cursor
operator|||
operator|!
name|change_scroll_region
operator|||
operator|!
name|restore_cursor
condition|)
block|{
comment|/* quietly ignore this test */
return|return;
block|}
if|if
condition|(
name|skip_pad_test
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|,
literal|"(csr) Change-scroll-region, (nel) newline start testing"
argument_list|)
condition|)
block|{
return|return;
block|}
name|pad_test_startup
argument_list|(
literal|1
argument_list|)
expr_stmt|;
do|do
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lines
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
name|lines
operator|-
name|i
init|;
name|j
operator|>
literal|0
condition|;
name|j
operator|--
control|)
block|{
name|put_crlf
argument_list|()
expr_stmt|;
block|}
name|tt_putp
argument_list|(
name|save_cursor
argument_list|)
expr_stmt|;
name|tt_putparm
argument_list|(
name|change_scroll_region
argument_list|,
literal|1
argument_list|,
name|i
argument_list|,
name|lines
operator|-
literal|1
argument_list|)
expr_stmt|;
name|tt_putp
argument_list|(
name|restore_cursor
argument_list|)
expr_stmt|;
name|put_str
argument_list|(
name|every_line
argument_list|)
expr_stmt|;
block|}
name|tt_putp
argument_list|(
name|save_cursor
argument_list|)
expr_stmt|;
name|tt_putparm
argument_list|(
name|change_scroll_region
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|lines
operator|-
literal|1
argument_list|)
expr_stmt|;
name|tt_putp
argument_list|(
name|restore_cursor
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|still_testing
argument_list|()
condition|)
do|;
name|pad_test_shutdown
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|put_str
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
name|pad_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
name|tt_putparm
argument_list|(
name|change_scroll_region
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|lines
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **	pad_csr_cup(test_list, status, ch) ** **	Test (csr) (cup) Change scroll region and cursor address */
end_comment

begin_function
specifier|static
name|void
name|pad_csr_cup
parameter_list|(
name|struct
name|test_list
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|state
parameter_list|,
name|int
modifier|*
name|ch
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
operator|!
name|change_scroll_region
operator|||
operator|!
name|cursor_address
condition|)
block|{
comment|/* quietly ignore this test */
return|return;
block|}
if|if
condition|(
name|skip_pad_test
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|,
literal|"(csr) Change-scroll-region, (cup) cursor-address start testing"
argument_list|)
condition|)
block|{
return|return;
block|}
name|pad_test_startup
argument_list|(
literal|1
argument_list|)
expr_stmt|;
do|do
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lines
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
name|lines
operator|-
name|i
init|;
name|j
operator|>
literal|0
condition|;
name|j
operator|--
control|)
block|{
name|put_crlf
argument_list|()
expr_stmt|;
block|}
name|tt_putparm
argument_list|(
name|change_scroll_region
argument_list|,
literal|1
argument_list|,
name|i
argument_list|,
name|lines
operator|-
literal|1
argument_list|)
expr_stmt|;
name|tt_putparm
argument_list|(
name|cursor_address
argument_list|,
literal|1
argument_list|,
name|lines
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|put_str
argument_list|(
name|every_line
argument_list|)
expr_stmt|;
block|}
name|tt_putparm
argument_list|(
name|change_scroll_region
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|lines
operator|-
literal|1
argument_list|)
expr_stmt|;
name|tt_putparm
argument_list|(
name|cursor_address
argument_list|,
literal|1
argument_list|,
name|lines
operator|-
literal|1
argument_list|,
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|every_line
argument_list|)
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|still_testing
argument_list|()
condition|)
do|;
name|pad_test_shutdown
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|put_str
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
name|pad_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
name|tt_putparm
argument_list|(
name|change_scroll_region
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|lines
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **	pad_ht(test_list, status, ch) ** **	Test (ht) Tabs */
end_comment

begin_function
specifier|static
name|void
name|pad_ht
parameter_list|(
name|struct
name|test_list
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|state
parameter_list|,
name|int
modifier|*
name|ch
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
operator|!
name|set_tab
operator|&&
name|init_tabs
operator|<=
literal|0
condition|)
block|{
name|CAP_NOT_FOUND
expr_stmt|;
name|ptext
argument_list|(
literal|"(ht) Tab not tested.  (hts) Set-tabs and (it) initial-tabs not present.  "
argument_list|)
expr_stmt|;
name|pad_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|skip_pad_test
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|,
literal|"(ht) Tab start testing"
argument_list|)
condition|)
block|{
return|return;
block|}
name|pad_test_startup
argument_list|(
literal|1
argument_list|)
expr_stmt|;
do|do
block|{
comment|/* 		   it is not always possible to test tabs with caps 		   that do not already have padding. The following 		   test uses a mixed bag of tests in order to avoid 		   this problem. Note: I do not scroll 		*/
if|if
condition|(
name|auto_right_margin
operator|&&
name|can_go_home
condition|)
for|for
control|(
name|i
operator|=
literal|1
operator|,
name|go_home
argument_list|()
init|;
name|i
operator|<
name|lines
operator|-
literal|2
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|8
init|;
name|j
operator|<
name|columns
condition|;
name|j
operator|+=
literal|8
control|)
block|{
name|putchp
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
block|}
name|put_str
argument_list|(
literal|"A        "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cursor_down
operator|&&
name|can_go_home
condition|)
for|for
control|(
name|i
operator|=
literal|1
operator|,
name|go_home
argument_list|()
init|;
name|i
operator|<
name|lines
operator|-
literal|2
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|8
init|;
name|j
operator|<
name|columns
condition|;
name|j
operator|+=
literal|8
control|)
block|{
name|putchp
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
block|}
name|put_str
argument_list|(
literal|"D\r"
argument_list|)
expr_stmt|;
name|tt_putp
argument_list|(
name|cursor_down
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cursor_address
condition|)
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|lines
operator|-
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|tt_putparm
argument_list|(
name|cursor_address
argument_list|,
literal|1
argument_list|,
name|i
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|8
init|;
name|j
operator|<
name|columns
condition|;
name|j
operator|+=
literal|8
control|)
block|{
name|putchp
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
block|}
name|put_str
argument_list|(
literal|"C"
argument_list|)
expr_stmt|;
block|}
name|go_home
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|lines
operator|-
literal|2
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|8
init|;
name|j
operator|<
name|columns
condition|;
name|j
operator|+=
literal|8
control|)
block|{
name|putchp
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
block|}
name|putln
argument_list|(
literal|"N"
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|still_testing
argument_list|()
condition|)
do|;
name|pad_test_shutdown
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ptextln
argument_list|(
literal|"Letters on the screen other than Ns at the right margin indicate failure."
argument_list|)
expr_stmt|;
name|ptext
argument_list|(
literal|"A-(am) D-(cud1) C-(cup) N-(nel)  "
argument_list|)
expr_stmt|;
name|pad_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **	pad_smso(test_list, status, ch) ** **	Test (smso) (rmso) Enter/exit mode */
end_comment

begin_function
specifier|static
name|void
name|pad_smso
parameter_list|(
name|struct
name|test_list
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|state
parameter_list|,
name|int
modifier|*
name|ch
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
operator|!
name|enter_standout_mode
operator|||
operator|!
name|exit_standout_mode
condition|)
block|{
name|CAP_NOT_FOUND
expr_stmt|;
name|ptext
argument_list|(
literal|"(smso) (rmso) Enter/Exit-standout-mode not present.  "
argument_list|)
expr_stmt|;
name|pad_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|skip_pad_test
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|,
literal|"(smso) (rmso) Enter/Exit-standout-mode start testing"
argument_list|)
condition|)
block|{
return|return;
block|}
comment|/* 	   In terminals that emulate non-hidden attributes with hidden 	   attributes, the amount of time that it takes to fill the screen 	   with an attribute is nontrivial. The following test is designed to 	   catch those delays 	*/
name|pad_test_startup
argument_list|(
literal|1
argument_list|)
expr_stmt|;
do|do
block|{
name|page_loop
argument_list|()
expr_stmt|;
name|j
operator|=
name|magic_cookie_glitch
operator|>
literal|0
condition|?
name|magic_cookie_glitch
else|:
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|2
operator|+
name|j
operator|+
name|j
init|;
name|i
operator|<
name|columns
condition|;
control|)
block|{
name|put_mode
argument_list|(
name|enter_standout_mode
argument_list|)
expr_stmt|;
name|i
operator|+=
name|j
operator|+
name|j
operator|+
literal|2
expr_stmt|;
name|putchp
argument_list|(
literal|'X'
argument_list|)
expr_stmt|;
name|put_mode
argument_list|(
name|exit_standout_mode
argument_list|)
expr_stmt|;
name|putchp
argument_list|(
literal|'X'
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|still_testing
argument_list|()
condition|)
do|;
name|pad_test_shutdown
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|home_down
argument_list|()
expr_stmt|;
name|ptext
argument_list|(
name|above_line
argument_list|)
expr_stmt|;
name|pad_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
name|put_mode
argument_list|(
name|exit_standout_mode
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **	pad_smacs(test_list, status, ch) ** **	Test (smacs) (rmacs) Enter/exit altcharset mode */
end_comment

begin_function
specifier|static
name|void
name|pad_smacs
parameter_list|(
name|struct
name|test_list
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|state
parameter_list|,
name|int
modifier|*
name|ch
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* test enter even if exit is missing */
if|if
condition|(
operator|!
name|enter_alt_charset_mode
condition|)
block|{
name|CAP_NOT_FOUND
expr_stmt|;
name|ptext
argument_list|(
literal|"(smacs) Enter-altcharset-mode not present.  "
argument_list|)
expr_stmt|;
name|pad_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|skip_pad_test
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|,
literal|"(smacs) (rmacs) Enter/Exit-altcharset-mode start testing"
argument_list|)
condition|)
block|{
return|return;
block|}
name|pad_test_startup
argument_list|(
literal|1
argument_list|)
expr_stmt|;
do|do
block|{
name|page_loop
argument_list|()
expr_stmt|;
name|j
operator|=
name|magic_cookie_glitch
operator|>
literal|0
condition|?
name|magic_cookie_glitch
else|:
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|2
operator|+
name|j
operator|+
name|j
init|;
name|i
operator|<
name|columns
condition|;
control|)
block|{
name|put_mode
argument_list|(
name|enter_alt_charset_mode
argument_list|)
expr_stmt|;
name|i
operator|+=
name|j
operator|+
name|j
operator|+
literal|2
expr_stmt|;
name|putchp
argument_list|(
name|letter
argument_list|)
expr_stmt|;
name|put_mode
argument_list|(
name|exit_alt_charset_mode
argument_list|)
expr_stmt|;
name|putchp
argument_list|(
name|letter
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|still_testing
argument_list|()
condition|)
do|;
name|pad_test_shutdown
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|home_down
argument_list|()
expr_stmt|;
name|ptext
argument_list|(
literal|"Every other character is from the alternate character set.  "
argument_list|)
expr_stmt|;
name|pad_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
name|put_mode
argument_list|(
name|exit_alt_charset_mode
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **	pad_crash(test_list, status, ch) ** **	Test (clear) without padding */
end_comment

begin_function
specifier|static
name|void
name|pad_crash
parameter_list|(
name|struct
name|test_list
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|state
parameter_list|,
name|int
modifier|*
name|ch
parameter_list|)
block|{
name|int
name|save_xon_xoff
decl_stmt|;
if|if
condition|(
operator|!
name|clear_screen
condition|)
block|{
name|ptext
argument_list|(
literal|"(clear) Clear-screen not present.  "
argument_list|)
expr_stmt|;
name|pad_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
return|return;
block|}
name|ptext
argument_list|(
literal|"If you would like to see if the terminal will really lock up."
argument_list|)
expr_stmt|;
name|ptextln
argument_list|(
literal|"  I will send the clear screen sequence without the pads."
argument_list|)
expr_stmt|;
if|if
condition|(
name|skip_pad_test
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|,
literal|"(clear) Clear-screen start crash testing"
argument_list|)
condition|)
block|{
return|return;
block|}
name|save_xon_xoff
operator|=
name|xon_xoff
expr_stmt|;
name|xon_xoff
operator|=
literal|1
expr_stmt|;
name|pad_test_startup
argument_list|(
literal|0
argument_list|)
expr_stmt|;
do|do
block|{
name|put_str
argument_list|(
literal|"Erase this!"
argument_list|)
expr_stmt|;
name|tt_putp
argument_list|(
name|clear_screen
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|still_testing
argument_list|()
condition|)
do|;
name|xon_xoff
operator|=
name|save_xon_xoff
expr_stmt|;
name|pad_test_shutdown
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pad_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

