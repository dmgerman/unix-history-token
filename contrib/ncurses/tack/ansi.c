begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ** Copyright (C) 1991, 1997 Free Software Foundation, Inc. **  ** This file is part of TACK. **  ** TACK is free software; you can redistribute it and/or modify ** it under the terms of the GNU General Public License as published by ** the Free Software Foundation; either version 2, or (at your option) ** any later version. **  ** TACK is distributed in the hope that it will be useful, ** but WITHOUT ANY WARRANTY; without even the implied warranty of ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ** GNU General Public License for more details. **  ** You should have received a copy of the GNU General Public License ** along with TACK; see the file COPYING.  If not, write to ** the Free Software Foundation, Inc., 59 Temple Place - Suite 330, ** Boston, MA 02111-1307, USA. */
end_comment

begin_include
include|#
directive|include
file|<tack.h>
end_include

begin_macro
name|MODULE_ID
argument_list|(
literal|"$Id: ansi.c,v 1.2 1999/08/21 23:11:57 tom Exp $"
argument_list|)
end_macro

begin_comment
comment|/*  * Standalone tests for ANSI terminals.  Three entry points:  * test_ansi_graphics(), test_ansi_reports() and test_ansi_sgr().  */
end_comment

begin_comment
comment|/*****************************************************************************  *  * Test ANSI status reports  *  *****************************************************************************/
end_comment

begin_comment
comment|/* ASCII control characters */
end_comment

begin_define
define|#
directive|define
name|A_DC1
value|0x11
end_define

begin_comment
comment|/* Control Q */
end_comment

begin_define
define|#
directive|define
name|A_DC3
value|0x13
end_define

begin_comment
comment|/* Control S */
end_comment

begin_define
define|#
directive|define
name|A_ESC
value|0x1b
end_define

begin_define
define|#
directive|define
name|A_DCS
value|0x90
end_define

begin_define
define|#
directive|define
name|A_CSI
value|0x9b
end_define

begin_define
define|#
directive|define
name|A_ST
value|0x9c
end_define

begin_define
define|#
directive|define
name|MAX_MODES
value|256
end_define

begin_decl_stmt
specifier|static
name|char
name|default_bank
index|[]
init|=
literal|"\033(B\017"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|private_use
decl_stmt|,
name|ape
decl_stmt|,
name|terminal_class
decl_stmt|,
name|got_escape
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
name|ansi_value
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|ansi_buf
index|[
literal|512
index|]
decl_stmt|,
name|pack_buf
index|[
literal|512
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ach
decl_stmt|,
modifier|*
name|pch
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|ansi_reports
block|{
name|int
name|lvl
decl_stmt|,
name|final
decl_stmt|;
specifier|const
name|char
modifier|*
name|text
decl_stmt|;
specifier|const
name|char
modifier|*
name|request
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|ansi_reports
name|report_list
index|[]
init|=
block|{
block|{
literal|0
block|,
literal|'c'
block|,
literal|"(DA) Primary device attributes"
block|,
literal|"\033[0c"
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|"(DSR) Terminal status"
block|,
literal|"\033[5n"
block|}
block|,
block|{
literal|1
block|,
literal|'R'
block|,
literal|"(DSR) Cursor position"
block|,
literal|"\033[6n"
block|}
block|,
block|{
literal|62
block|,
literal|0
block|,
literal|"(DA) Secondary device attributes"
block|,
literal|"\033[>0c"
block|}
block|,
block|{
literal|62
block|,
literal|0
block|,
literal|"(DSR) Printer status"
block|,
literal|"\033[?15n"
block|}
block|,
block|{
literal|62
block|,
literal|0
block|,
literal|"(DSR) Function key definition"
block|,
literal|"\033[?25n"
block|}
block|,
block|{
literal|62
block|,
literal|0
block|,
literal|"(DSR) Keyboard language"
block|,
literal|"\033[?26n"
block|}
block|,
block|{
literal|63
block|,
literal|0
block|,
literal|"(DECRQSS) Data destination"
block|,
literal|"\033P$q$}\033\\"
block|}
block|,
block|{
literal|63
block|,
literal|0
block|,
literal|"(DECRQSS) Status line type"
block|,
literal|"\033P$q$~\033\\"
block|}
block|,
block|{
literal|63
block|,
literal|0
block|,
literal|"(DECRQSS) Erase attribute"
block|,
literal|"\033P$q\"q\033\\"
block|}
block|,
block|{
literal|63
block|,
literal|0
block|,
literal|"(DECRQSS) Personality"
block|,
literal|"\033P$q\"p\033\\"
block|}
block|,
block|{
literal|63
block|,
literal|0
block|,
literal|"(DECRQSS) Top and bottom margins"
block|,
literal|"\033P$qr\033\\"
block|}
block|,
block|{
literal|63
block|,
literal|0
block|,
literal|"(DECRQSS) Character attributes"
block|,
literal|"\033P$qm\033\\"
block|}
block|,
block|{
literal|63
block|,
literal|0
block|,
literal|"(DECRQSS) Illegal request"
block|,
literal|"\033P$q@\033\\"
block|}
block|,
block|{
literal|63
block|,
literal|0
block|,
literal|"(DECRQUPSS) User pref suplemental set"
block|,
literal|"\033[&u"
block|}
block|,
block|{
literal|63
block|,
literal|0
block|,
literal|"(DECRQPSR) Cursor information"
block|,
literal|"\033[1$w"
block|}
block|,
block|{
literal|63
block|,
literal|0
block|,
literal|"(DECRQPSR) Tab stop information"
block|,
literal|"\033[2$w"
block|}
block|,
block|{
literal|64
block|,
literal|0
block|,
literal|"(DA) Tertiary device attributes"
block|,
literal|"\033[=0c"
block|}
block|,
block|{
literal|64
block|,
literal|0
block|,
literal|"(DSR) Extended cursor position"
block|,
literal|"\033[?6n"
block|}
block|,
block|{
literal|64
block|,
literal|0
block|,
literal|"(DSR) Macro space"
block|,
literal|"\033[?62n"
block|}
block|,
block|{
literal|64
block|,
literal|0
block|,
literal|"(DSR) Memory checksum"
block|,
literal|"\033[?63n"
block|}
block|,
block|{
literal|64
block|,
literal|0
block|,
literal|"(DSR) Data integrity"
block|,
literal|"\033[?75n"
block|}
block|,
block|{
literal|64
block|,
literal|0
block|,
literal|"(DSR) Multiple session status"
block|,
literal|"\033[?85n"
block|}
block|,
block|{
literal|64
block|,
literal|0
block|,
literal|"(DECRQSS) Attribute change extent"
block|,
literal|"\033P$q*x\033\\"
block|}
block|,
block|{
literal|64
block|,
literal|0
block|,
literal|"(DECRQSS) Columns per page"
block|,
literal|"\033P$q$|\033\\"
block|}
block|,
block|{
literal|64
block|,
literal|0
block|,
literal|"(DECRQSS) Lines per page"
block|,
literal|"\033P$qt\033\\"
block|}
block|,
block|{
literal|64
block|,
literal|0
block|,
literal|"(DECRQSS) Lines per screen"
block|,
literal|"\033P$q*|\033\\"
block|}
block|,
block|{
literal|64
block|,
literal|0
block|,
literal|"(DECRQSS) Left and right margins"
block|,
literal|"\033P$qs\033\\"
block|}
block|,
block|{
literal|64
block|,
literal|0
block|,
literal|"(DECRQSS) Local functions"
block|,
literal|"\033P$q+q\033\\"
block|}
block|,
block|{
literal|64
block|,
literal|0
block|,
literal|"(DECRQSS) Local function key control"
block|,
literal|"\033P$q=}\033\\"
block|}
block|,
block|{
literal|64
block|,
literal|0
block|,
literal|"(DECRQSS) Select modifier key reporting"
block|,
literal|"\033P$q+r\033\\"
block|}
block|,
block|{
literal|64
block|,
literal|0
block|,
literal|"(DECRQDE) Window report"
block|,
literal|"\033[\"v"
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|request_control
block|{
specifier|const
name|char
modifier|*
name|text
decl_stmt|;
specifier|const
name|char
modifier|*
name|expect
decl_stmt|;
specifier|const
name|char
modifier|*
name|request
decl_stmt|;
specifier|const
name|char
modifier|*
name|set_mode
decl_stmt|;
specifier|const
name|char
modifier|*
name|reset_mode
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Request control function selection or setting */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|request_control
name|rqss
index|[]
init|=
block|{
block|{
literal|"Data sent to screen"
block|,
literal|"0"
block|,
literal|"$}"
block|,
literal|"\033[0$}"
block|,
literal|0
block|}
block|,
block|{
literal|"Data sent to disabled status line"
block|,
literal|"0"
block|,
literal|"$}"
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"\033[0$~\033[1$}"
block|,
literal|"\033[0$}"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"Data sent to enabled status line"
block|,
literal|"1"
block|,
literal|"$}"
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"\033[2$~\033[1$}"
block|,
literal|"\033[0$}"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"Disbale status line"
block|,
literal|"0"
block|,
literal|"$~"
block|,
literal|"\033[0$~"
block|,
literal|0
block|}
block|,
block|{
literal|"Top status line"
block|,
literal|"1"
block|,
literal|"$~"
block|,
literal|"\033[1$~"
block|,
literal|0
block|}
block|,
block|{
literal|"Bottom status line"
block|,
literal|"2"
block|,
literal|"$~"
block|,
literal|"\033[2$~"
block|,
literal|0
block|}
block|,
block|{
literal|"Eraseable character"
block|,
literal|"0"
block|,
literal|"\"q"
block|,
literal|"\033[0\"q"
block|,
literal|0
block|}
block|,
block|{
literal|"Noneraseable character"
block|,
literal|"1"
block|,
literal|"\"q"
block|,
literal|"\033[1\"q"
block|,
literal|"\033[0\"q"
block|}
block|,
block|{
literal|"Top and bottom margins"
block|,
literal|"3;10"
block|,
literal|"r"
block|,
literal|"\0337\033[3;10r"
block|,
literal|0
block|}
block|,
block|{
literal|"\033[r\0338"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"Top and bottom margins"
block|,
literal|"default"
block|,
literal|"r"
block|,
literal|"\0337\033[r"
block|,
literal|"\0338"
block|}
block|,
block|{
literal|"Character attributes, dim, bold"
block|,
literal|"1"
block|,
literal|"m"
block|,
literal|"\033[2;1m"
block|,
literal|"\033[m"
block|}
block|,
block|{
literal|"Character attributes, bold, dim"
block|,
literal|"2"
block|,
literal|"m"
block|,
literal|"\033[1;2m"
block|,
literal|"\033[m"
block|}
block|,
block|{
literal|"Character attributes, under, rev"
block|,
literal|"4;7"
block|,
literal|"m"
block|,
literal|"\033[4;7m"
block|,
literal|"\033[m"
block|}
block|,
block|{
literal|"Character attributes, color"
block|,
literal|"35;42"
block|,
literal|"m"
block|,
literal|"\033[35;42m"
block|,
literal|"\033[m"
block|}
block|,
block|{
literal|"All character attributes"
block|,
literal|""
block|,
literal|"m"
block|,
literal|"\033[1;2;3;4;5;6;7;8;9m"
block|,
literal|0
block|}
block|,
block|{
literal|"\033[m"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* **	pack_ansi() ** **	read and pack an ANSI character */
end_comment

begin_function
specifier|static
name|int
name|pack_ansi
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|ch
decl_stmt|;
if|if
condition|(
operator|*
name|pch
condition|)
return|return
operator|*
name|pch
operator|++
return|;
while|while
condition|(
literal|1
condition|)
block|{
name|ch
operator|=
name|getchp
argument_list|(
name|char_mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|EOF
condition|)
return|return
name|EOF
return|;
if|if
condition|(
name|ch
operator|==
name|A_DC1
operator|||
name|ch
operator|==
name|A_DC3
condition|)
continue|continue;
operator|*
name|ach
operator|++
operator|=
name|ch
expr_stmt|;
operator|*
name|ach
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|got_escape
operator|&&
name|ch
operator|>=
literal|' '
condition|)
block|{
name|got_escape
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ch
operator|<
literal|'@'
operator|||
name|ch
operator|>
literal|'_'
condition|)
block|{
operator|*
name|pch
operator|++
operator|=
name|A_ESC
expr_stmt|;
operator|*
name|pch
operator|=
name|ch
expr_stmt|;
name|pch
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|A_ESC
return|;
block|}
name|ch
operator|+=
literal|0x40
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
name|A_ESC
condition|)
block|{
name|got_escape
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
operator|*
name|pch
operator|++
operator|=
name|ch
expr_stmt|;
operator|*
name|pch
operator|=
literal|'\0'
expr_stmt|;
return|return
name|ch
return|;
block|}
end_function

begin_comment
comment|/* **	read_ansi() ** **	read an ANSI status report from terminal */
end_comment

begin_function
specifier|static
name|void
name|read_ansi
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|ch
decl_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|ach
operator|=
name|ansi_buf
expr_stmt|;
name|pch
operator|=
name|pack_buf
expr_stmt|;
name|ansi_buf
index|[
literal|0
index|]
operator|=
name|pack_buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|got_escape
operator|=
literal|0
expr_stmt|;
name|ch
operator|=
name|pack_ansi
argument_list|()
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|A_ESC
condition|)
do|do
block|{
name|ch
operator|=
name|pack_ansi
argument_list|()
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|EOF
condition|)
return|return;
block|}
do|while
condition|(
name|ch
operator|<
literal|'0'
operator|||
name|ch
operator|>
literal|'~'
condition|)
do|;
elseif|else
if|if
condition|(
name|ch
operator|==
name|A_CSI
condition|)
do|do
block|{
name|ch
operator|=
name|pack_ansi
argument_list|()
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|EOF
condition|)
return|return;
block|}
do|while
condition|(
name|ch
operator|<
literal|'@'
operator|||
name|ch
operator|>
literal|'~'
condition|)
do|;
elseif|else
if|if
condition|(
name|ch
operator|==
name|A_DCS
condition|)
do|do
block|{
name|ch
operator|=
name|pack_ansi
argument_list|()
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|EOF
condition|)
return|return;
block|}
do|while
condition|(
name|ch
operator|!=
name|A_ST
condition|)
do|;
return|return;
block|}
end_function

begin_comment
comment|/* **	valid_mode(expected) ** **	read a terminal mode status report and parse the result **	Return TRUE if we got the expected terminating character. */
end_comment

begin_function
specifier|static
name|int
name|valid_mode
parameter_list|(
name|int
name|expected
parameter_list|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|ch
decl_stmt|,
name|terminator
decl_stmt|;
name|read_ansi
argument_list|()
expr_stmt|;
name|ape
operator|=
literal|0
expr_stmt|;
name|ch
operator|=
name|pack_buf
index|[
literal|0
index|]
operator|&
literal|0xff
expr_stmt|;
name|ansi_value
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ch
operator|!=
name|A_CSI
operator|&&
name|ch
operator|!=
name|A_DCS
condition|)
return|return
name|FALSE
return|;
name|s
operator|=
name|pack_buf
operator|+
literal|1
expr_stmt|;
name|private_use
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|s
operator|>=
literal|'<'
operator|)
operator|&
operator|(
operator|*
name|s
operator|<=
literal|'?'
operator|)
condition|)
block|{
name|private_use
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
name|terminator
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
operator|(
name|ch
operator|=
operator|*
name|s
operator|)
condition|;
name|s
operator|++
control|)
block|{
if|if
condition|(
name|ch
operator|>=
literal|'0'
operator|&&
name|ch
operator|<=
literal|'9'
condition|)
name|ansi_value
index|[
name|ape
index|]
operator|=
name|ansi_value
index|[
name|ape
index|]
operator|*
literal|10
operator|+
name|ch
operator|-
literal|'0'
expr_stmt|;
elseif|else
if|if
condition|(
name|ch
operator|==
literal|';'
operator|||
name|ch
operator|==
literal|':'
condition|)
name|ansi_value
index|[
operator|++
name|ape
index|]
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|ch
operator|>=
literal|'<'
operator|&&
name|ch
operator|<=
literal|'?'
condition|)
name|private_use
operator|=
name|ch
expr_stmt|;
elseif|else
if|if
condition|(
name|ch
operator|>=
literal|' '
condition|)
name|terminator
operator|=
operator|(
name|terminator
operator|<<
literal|8
operator|)
operator||
name|ch
expr_stmt|;
else|else
break|break;
block|}
return|return
name|terminator
operator|==
name|expected
return|;
block|}
end_function

begin_comment
comment|/* **	read_reports() ** **	read all the reports in the ANSI report structure */
end_comment

begin_function
specifier|static
name|int
name|read_reports
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|tc
decl_stmt|,
name|vcr
decl_stmt|,
name|lc
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|lc
operator|=
literal|5
expr_stmt|;
name|terminal_class
operator|=
name|tc
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|report_list
index|[
name|i
index|]
operator|.
name|text
condition|;
name|i
operator|++
operator|,
name|lc
operator|++
control|)
block|{
if|if
condition|(
name|terminal_class
operator|<
name|report_list
index|[
name|i
index|]
operator|.
name|lvl
operator|&&
name|tc
operator|<
name|report_list
index|[
name|i
index|]
operator|.
name|lvl
condition|)
block|{
name|put_crlf
argument_list|()
expr_stmt|;
name|menu_prompt
argument_list|()
expr_stmt|;
name|ptext
argument_list|(
literal|"<return> to continue> "
argument_list|)
expr_stmt|;
name|j
operator|=
name|wait_here
argument_list|()
expr_stmt|;
if|if
condition|(
name|j
operator|!=
literal|'c'
operator|&&
name|j
operator|!=
literal|'C'
condition|)
return|return
name|j
return|;
name|tc
operator|=
name|report_list
index|[
name|i
index|]
operator|.
name|lvl
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lc
operator|+
literal|2
operator|>=
name|lines
condition|)
block|{
name|put_crlf
argument_list|()
expr_stmt|;
name|ptext
argument_list|(
literal|"Hit any key to continue "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|wait_here
argument_list|()
expr_stmt|;
name|lc
operator|=
literal|1
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"%s (%s) "
argument_list|,
name|report_list
index|[
name|i
index|]
operator|.
name|text
argument_list|,
name|expand_command
argument_list|(
name|report_list
index|[
name|i
index|]
operator|.
name|request
argument_list|)
argument_list|)
expr_stmt|;
name|ptext
argument_list|(
name|temp
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|strlen
argument_list|(
name|temp
argument_list|)
init|;
name|j
operator|<
literal|49
condition|;
name|j
operator|++
control|)
name|putchp
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|tc_putp
argument_list|(
name|report_list
index|[
name|i
index|]
operator|.
name|request
argument_list|)
expr_stmt|;
name|vcr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|report_list
index|[
name|i
index|]
operator|.
name|final
operator|==
literal|0
condition|)
block|{
name|read_ansi
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|valid_mode
argument_list|(
name|report_list
index|[
name|i
index|]
operator|.
name|final
argument_list|)
condition|)
switch|switch
condition|(
name|report_list
index|[
name|i
index|]
operator|.
name|final
condition|)
block|{
case|case
literal|'c'
case|:
name|terminal_class
operator|=
name|ansi_value
index|[
literal|0
index|]
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|vcr
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
name|j
operator|=
name|pack_buf
index|[
literal|0
index|]
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|j
operator|==
name|A_CSI
operator|||
name|j
operator|==
name|A_DCS
condition|)
block|{
name|s
operator|=
name|expand
argument_list|(
name|ansi_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|char_count
operator|+
name|expand_chars
operator|>=
name|columns
condition|)
block|{
name|put_str
argument_list|(
literal|"\r\n        "
argument_list|)
expr_stmt|;
name|lc
operator|++
expr_stmt|;
block|}
name|put_str
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|put_crlf
argument_list|()
expr_stmt|;
if|if
condition|(
name|vcr
condition|)
block|{
comment|/* find out how big the screen is */
name|tc_putp
argument_list|(
name|report_list
index|[
name|i
index|]
operator|.
name|request
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|valid_mode
argument_list|(
literal|'R'
argument_list|)
condition|)
continue|continue;
name|j
operator|=
name|ansi_value
index|[
literal|0
index|]
expr_stmt|;
name|k
operator|=
name|ansi_value
index|[
literal|1
index|]
expr_stmt|;
name|tc_putp
argument_list|(
literal|"\033[255B\033[255C\033[6n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|valid_mode
argument_list|(
literal|'R'
argument_list|)
condition|)
continue|continue;
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"\033[%d;%dH"
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
name|tc_putp
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|ptext
argument_list|(
literal|"(DSR) Screen size (CSI 6 n)"
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|char_count
init|;
name|j
operator|<
literal|50
condition|;
name|j
operator|++
control|)
name|putchp
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"%d x %d"
argument_list|,
name|ansi_value
index|[
literal|1
index|]
argument_list|,
name|ansi_value
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ptextln
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
block|}
name|menu_prompt
argument_list|()
expr_stmt|;
name|ptext
argument_list|(
literal|" r->repeat test,<return> to continue> "
argument_list|)
expr_stmt|;
return|return
name|wait_here
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/* **	request_cfss() ** **	Request Control function selection or settings */
end_comment

begin_function
specifier|static
name|int
name|request_cfss
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|l
decl_stmt|,
name|ch
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|put_clear
argument_list|()
expr_stmt|;
name|ptextln
argument_list|(
literal|"Request                         Expected  Received"
argument_list|)
expr_stmt|;
name|put_crlf
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|rqss
index|[
name|i
index|]
operator|.
name|text
condition|;
name|i
operator|++
control|)
block|{
name|ptext
argument_list|(
name|rqss
index|[
name|i
index|]
operator|.
name|text
argument_list|)
expr_stmt|;
name|j
operator|=
name|strlen
argument_list|(
name|rqss
index|[
name|i
index|]
operator|.
name|text
argument_list|)
operator|+
name|strlen
argument_list|(
name|rqss
index|[
name|i
index|]
operator|.
name|expect
argument_list|)
expr_stmt|;
name|putchp
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|++
init|;
name|j
operator|<
literal|40
condition|;
name|j
operator|++
control|)
name|putchp
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|ptext
argument_list|(
name|rqss
index|[
name|i
index|]
operator|.
name|expect
argument_list|)
expr_stmt|;
name|putchp
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|tc_putp
argument_list|(
name|rqss
index|[
name|i
index|]
operator|.
name|set_mode
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"\033P$q%s\033\\"
argument_list|,
name|rqss
index|[
name|i
index|]
operator|.
name|request
argument_list|)
expr_stmt|;
name|tc_putp
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|read_ansi
argument_list|()
expr_stmt|;
name|tc_putp
argument_list|(
name|rqss
index|[
name|i
index|]
operator|.
name|reset_mode
argument_list|)
expr_stmt|;
name|putchp
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|ansi_buf
index|[
name|j
index|]
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|ansi_buf
index|[
name|j
index|]
operator|==
literal|'r'
condition|)
block|{
for|for
control|(
name|k
operator|=
name|j
operator|++
init|;
operator|(
name|ch
operator|=
operator|(
name|ansi_buf
index|[
name|k
index|]
operator|&
literal|0xff
operator|)
operator|)
condition|;
name|k
operator|++
control|)
if|if
condition|(
name|ch
operator|==
name|A_ESC
condition|)
block|{
break|break;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
name|A_ST
condition|)
block|{
break|break;
block|}
name|ansi_buf
index|[
name|k
index|]
operator|=
literal|'\0'
expr_stmt|;
name|s
operator|=
name|expand
argument_list|(
operator|&
name|ansi_buf
index|[
name|j
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|char_count
operator|+
name|expand_chars
operator|>=
name|columns
condition|)
name|put_str
argument_list|(
literal|"\r\n        "
argument_list|)
expr_stmt|;
name|put_str
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
name|put_crlf
argument_list|()
expr_stmt|;
block|}
comment|/* calculate the valid attributes */
name|ptext
argument_list|(
literal|"Valid attributes:         0"
argument_list|)
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|20
condition|;
name|i
operator|++
control|)
block|{
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"\033[0;%dm\033P$qm\033\\"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|tc_putp
argument_list|(
name|temp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|valid_mode
argument_list|(
literal|'m'
argument_list|)
expr_stmt|;
if|if
condition|(
name|ape
operator|>
literal|0
condition|)
block|{
name|j
operator|=
name|i
expr_stmt|;
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"\033[0m; %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|tc_putp
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
block|}
name|put_crlf
argument_list|()
expr_stmt|;
comment|/* calculate how many parameters can be sent */
name|ptext
argument_list|(
literal|"Max number of parameters: "
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"%dm\033P$qm\033\\"
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|l
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|j
operator|>
literal|0
condition|)
for|for
control|(
name|l
operator|=
literal|1
init|;
name|l
operator|<
literal|33
condition|;
name|l
operator|++
control|)
block|{
name|tc_putp
argument_list|(
literal|"\033[0"
argument_list|)
expr_stmt|;
for|for
control|(
name|ch
operator|=
literal|1
init|;
name|ch
operator|<=
name|l
condition|;
name|ch
operator|++
control|)
name|put_this
argument_list|(
literal|';'
argument_list|)
expr_stmt|;
name|tc_putp
argument_list|(
name|temp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|valid_mode
argument_list|(
literal|'m'
argument_list|)
expr_stmt|;
if|if
condition|(
name|ape
operator|==
literal|0
condition|)
break|break;
block|}
name|tc_putp
argument_list|(
literal|"\033[m"
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|>=
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"%d"
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|ptext
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
else|else
name|ptext
argument_list|(
literal|"unknown"
argument_list|)
expr_stmt|;
name|put_crlf
argument_list|()
expr_stmt|;
return|return
name|wait_here
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/* **	mode_display(puc, mode, initial, set, reset) ** **	print the mode display entry */
end_comment

begin_function
specifier|static
name|void
name|mode_display
parameter_list|(
specifier|const
name|char
modifier|*
name|p
parameter_list|,
name|int
name|n
parameter_list|,
name|int
name|c
parameter_list|,
name|char
name|s
parameter_list|,
name|char
name|r
parameter_list|)
block|{
name|int
name|k
decl_stmt|;
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"%s%d (%c, %c, %c)"
argument_list|,
name|p
argument_list|,
name|n
argument_list|,
name|c
argument_list|,
name|s
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|k
operator|=
name|strlen
argument_list|(
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|char_count
operator|+
name|k
operator|>=
name|columns
condition|)
name|put_crlf
argument_list|()
expr_stmt|;
for|for
control|(
init|;
name|k
operator|<
literal|14
condition|;
name|k
operator|++
control|)
name|putchp
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|put_str
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **	terminal_state() ** **	test DECRQM status reports */
end_comment

begin_function
specifier|static
name|void
name|terminal_state
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|puc
index|[]
init|=
block|{
literal|""
block|,
literal|"<"
block|,
literal|"="
block|,
literal|">"
block|,
literal|"?"
block|,
literal|0
block|}
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|l
decl_stmt|,
name|modes_found
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|,
name|tms
index|[
literal|256
index|]
decl_stmt|;
name|int
name|mode_puc
index|[
name|MAX_MODES
index|]
decl_stmt|,
name|mode_number
index|[
name|MAX_MODES
index|]
decl_stmt|;
name|char
name|set_value
index|[
name|MAX_MODES
index|]
decl_stmt|,
name|reset_value
index|[
name|MAX_MODES
index|]
decl_stmt|;
name|char
name|current_value
index|[
name|MAX_MODES
index|]
decl_stmt|;
name|ptext
argument_list|(
literal|"Testing terminal mode status. (CSI 0 $ p)"
argument_list|)
expr_stmt|;
name|tc_putp
argument_list|(
literal|"\033[0$p"
argument_list|)
expr_stmt|;
name|modes_found
operator|=
literal|0
expr_stmt|;
name|tms
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|valid_mode
argument_list|(
operator|(
literal|'$'
operator|<<
literal|8
operator|)
operator||
literal|'y'
argument_list|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|puc
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|put_crlf
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
condition|)
block|{
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"Private use: %c"
argument_list|,
name|puc
index|[
name|i
index|]
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strcpy
argument_list|(
name|temp
argument_list|,
literal|"Standard modes:"
argument_list|)
expr_stmt|;
block|}
name|k
operator|=
name|strlen
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|ptext
argument_list|(
name|temp
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
condition|;
name|buf
index|[
name|j
operator|++
index|]
operator|=
literal|' '
control|)
empty_stmt|;
for|for
control|(
name|j
operator|=
name|l
operator|=
literal|0
init|;
name|j
operator|<
literal|255
operator|&&
name|j
operator|-
name|l
operator|<
literal|50
condition|;
name|j
operator|++
control|)
block|{
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"\033[%s%d$p"
argument_list|,
name|puc
index|[
name|i
index|]
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|tc_putp
argument_list|(
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|valid_mode
argument_list|(
operator|(
literal|'$'
operator|<<
literal|8
operator|)
operator||
literal|'y'
argument_list|)
condition|)
block|{
comment|/* not valid, save terminating value */
name|s
operator|=
name|expand
argument_list|(
name|ansi_buf
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|tms
argument_list|,
literal|"%s%s%d %s  "
argument_list|,
name|tms
argument_list|,
name|puc
index|[
name|i
index|]
argument_list|,
name|j
argument_list|,
name|s
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|private_use
operator|!=
name|puc
index|[
name|i
index|]
index|[
literal|0
index|]
condition|)
break|break;
if|if
condition|(
name|ansi_value
index|[
literal|0
index|]
operator|!=
name|j
condition|)
break|break;
if|if
condition|(
name|ansi_value
index|[
literal|1
index|]
condition|)
block|{
name|l
operator|=
name|j
expr_stmt|;
if|if
condition|(
name|k
operator|>
literal|70
condition|)
block|{
name|buf
index|[
name|k
index|]
operator|=
literal|'\0'
expr_stmt|;
name|put_crlf
argument_list|()
expr_stmt|;
name|ptextln
argument_list|(
name|buf
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
condition|;
control|)
block|{
name|buf
index|[
name|k
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
block|}
name|k
operator|=
literal|0
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|" %d"
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|ptext
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|k
operator|+=
name|strlen
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|buf
index|[
name|k
operator|-
literal|1
index|]
operator|=
name|ansi_value
index|[
literal|1
index|]
operator|+
literal|'0'
expr_stmt|;
if|if
condition|(
name|modes_found
operator|>=
name|MAX_MODES
condition|)
continue|continue;
name|current_value
index|[
name|modes_found
index|]
operator|=
name|ansi_value
index|[
literal|1
index|]
operator|+
literal|'0'
expr_stmt|;
comment|/* some modes never return */
if|if
condition|(
operator|(
name|i
operator|==
literal|0
operator|&&
name|j
operator|==
literal|13
operator|)
comment|/* control execution */
operator|||
operator|(
name|puc
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'?'
operator|&&
name|j
operator|==
literal|2
operator|)
condition|)
comment|/* VT52 */
name|set_value
index|[
name|modes_found
index|]
operator|=
name|reset_value
index|[
name|modes_found
index|]
operator|=
literal|'-'
expr_stmt|;
else|else
name|set_value
index|[
name|modes_found
index|]
operator|=
name|reset_value
index|[
name|modes_found
index|]
operator|=
literal|' '
expr_stmt|;
name|mode_puc
index|[
name|modes_found
index|]
operator|=
name|i
expr_stmt|;
name|mode_number
index|[
name|modes_found
operator|++
index|]
operator|=
name|j
expr_stmt|;
block|}
block|}
name|buf
index|[
name|k
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|buf
index|[
name|k
operator|-
literal|1
index|]
operator|!=
literal|' '
condition|)
block|{
name|put_crlf
argument_list|()
expr_stmt|;
name|ptext
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|i
operator|=
name|modes_found
operator|)
operator|!=
literal|0
condition|)
block|{
name|put_crlf
argument_list|()
expr_stmt|;
name|put_crlf
argument_list|()
expr_stmt|;
if|if
condition|(
name|tms
index|[
literal|0
index|]
condition|)
block|{
name|ptextln
argument_list|(
name|tms
argument_list|)
expr_stmt|;
block|}
name|ptext
argument_list|(
literal|"Hit 'Y' to test mode set/reset states: "
argument_list|)
expr_stmt|;
name|i
operator|=
name|wait_here
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
literal|'y'
operator|||
name|i
operator|==
literal|'Y'
condition|)
while|while
condition|(
literal|1
condition|)
block|{
ifdef|#
directive|ifdef
name|STATUSFIX
name|FILE
modifier|*
name|fp
decl_stmt|;
ifdef|#
directive|ifdef
name|TEDANSI
name|fp
operator|=
name|fopen
argument_list|(
literal|"ted.ansi"
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
else|#
directive|else
name|fp
operator|=
name|fopen
argument_list|(
literal|"/dev/console"
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
for|for
control|(
name|i
operator|=
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|modes_found
condition|;
name|j
operator|=
operator|++
name|i
operator|>>
literal|1
control|)
block|{
if|if
condition|(
name|set_value
index|[
name|j
index|]
operator|==
literal|'-'
condition|)
continue|continue;
name|k
operator|=
operator|(
name|current_value
index|[
name|j
index|]
operator|^
name|i
operator|)
operator|&
literal|1
expr_stmt|;
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"\033[%s%d%c\033[%s%d$p"
argument_list|,
name|puc
index|[
name|mode_puc
index|[
name|j
index|]
index|]
argument_list|,
name|mode_number
index|[
name|j
index|]
argument_list|,
name|k
condition|?
literal|'l'
else|:
literal|'h'
argument_list|,
name|puc
index|[
name|mode_puc
index|[
name|j
index|]
index|]
argument_list|,
name|mode_number
index|[
name|j
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|STATUSFIX
if|if
condition|(
name|fp
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s\n"
argument_list|,
name|expand
argument_list|(
name|temp
argument_list|)
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|tc_putp
argument_list|(
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|valid_mode
argument_list|(
operator|(
literal|'$'
operator|<<
literal|8
operator|)
operator||
literal|'y'
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|k
condition|)
block|{
name|reset_value
index|[
name|j
index|]
operator|=
name|ansi_value
index|[
literal|1
index|]
operator|+
literal|'0'
expr_stmt|;
block|}
else|else
block|{
name|set_value
index|[
name|j
index|]
operator|=
name|ansi_value
index|[
literal|1
index|]
operator|+
literal|'0'
expr_stmt|;
block|}
block|}
name|put_str
argument_list|(
literal|"\033[30l"
argument_list|)
expr_stmt|;
comment|/* added for GORT bug 						   (WY-185) */
ifdef|#
directive|ifdef
name|STATUSFIX
if|if
condition|(
name|fp
condition|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tty_set
argument_list|()
expr_stmt|;
comment|/* print the results */
name|put_clear
argument_list|()
expr_stmt|;
name|putln
argument_list|(
literal|"mode (initial, set, reset)"
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|modes_found
condition|;
name|j
operator|++
control|)
block|{
name|mode_display
argument_list|(
name|puc
index|[
name|mode_puc
index|[
name|j
index|]
index|]
argument_list|,
name|mode_number
index|[
name|j
index|]
argument_list|,
name|current_value
index|[
name|j
index|]
argument_list|,
name|set_value
index|[
name|j
index|]
argument_list|,
name|reset_value
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
name|ptext
argument_list|(
literal|"\n\nHit 'R' to repeat test.  'S' to sort results: "
argument_list|)
expr_stmt|;
name|i
operator|=
name|wait_here
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|'s'
operator|||
name|i
operator|==
literal|'S'
condition|)
block|{
comment|/* print the same stuff, 							   sorted by 							   current_value */
name|put_crlf
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|'1'
init|;
name|i
operator|<=
literal|'4'
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|modes_found
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|current_value
index|[
name|j
index|]
operator|==
name|i
condition|)
name|mode_display
argument_list|(
name|puc
index|[
name|mode_puc
index|[
name|j
index|]
index|]
argument_list|,
name|mode_number
index|[
name|j
index|]
argument_list|,
name|current_value
index|[
name|j
index|]
argument_list|,
name|set_value
index|[
name|j
index|]
argument_list|,
name|reset_value
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|ptext
argument_list|(
literal|"\n\nHit 'R' to repeat test: "
argument_list|)
expr_stmt|;
name|i
operator|=
name|wait_here
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|!=
literal|'r'
operator|&&
name|i
operator|!=
literal|'R'
condition|)
break|break;
name|tty_raw
argument_list|(
literal|1
argument_list|,
name|char_mask
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|tty_set
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* **	ansi_report_help() ** **	Display the informational data for the ANSI report test. */
end_comment

begin_function
specifier|static
name|void
name|ansi_report_help
parameter_list|(
name|void
parameter_list|)
block|{
name|ptext
argument_list|(
literal|"Begin ANSI status report testing. "
argument_list|)
expr_stmt|;
name|ptext
argument_list|(
literal|" Parity bit set will be displayed in reverse video. "
argument_list|)
expr_stmt|;
name|ptext
argument_list|(
literal|" If the terminal hangs, hit any alphabetic key. "
argument_list|)
expr_stmt|;
name|ptextln
argument_list|(
literal|" Use c to continue testing.  Use any other letter to quit."
argument_list|)
expr_stmt|;
name|put_crlf
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **	test_ansi_reports() ** **	Test the ANSI status report functions */
end_comment

begin_function
name|void
name|tools_status
parameter_list|(
name|struct
name|test_list
modifier|*
name|t
name|GCC_UNUSED
parameter_list|,
name|int
modifier|*
name|state
name|GCC_UNUSED
parameter_list|,
name|int
modifier|*
name|ch
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|put_clear
argument_list|()
expr_stmt|;
name|ansi_report_help
argument_list|()
expr_stmt|;
name|tty_raw
argument_list|(
literal|1
argument_list|,
name|char_mask
argument_list|)
expr_stmt|;
do|do
block|{
name|i
operator|=
name|read_reports
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|'r'
operator|&&
name|i
operator|!=
literal|'R'
condition|)
block|{
operator|*
name|ch
operator|=
name|i
expr_stmt|;
return|return;
block|}
block|}
do|while
condition|(
name|i
condition|)
do|;
if|if
condition|(
name|terminal_class
operator|>=
literal|63
condition|)
block|{
do|do
block|{
name|i
operator|=
name|request_cfss
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|i
operator|==
literal|'r'
operator|||
name|i
operator|==
literal|'R'
condition|)
do|;
operator|*
name|ch
operator|=
name|i
expr_stmt|;
name|terminal_state
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|tty_set
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* **	display_sgr() ** **	Test a range of ANSI sgr attributes **	puc -> Private Use Character */
end_comment

begin_function
specifier|static
name|void
name|display_sgr
parameter_list|(
name|int
name|puc
parameter_list|)
block|{
name|int
name|k
decl_stmt|;
name|temp
index|[
literal|0
index|]
operator|=
name|puc
expr_stmt|;
name|temp
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
literal|80
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|char_count
operator|+
literal|8
operator|>
literal|80
condition|)
name|put_crlf
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|char_count
operator|+
literal|8
operator|>
name|columns
condition|)
name|put_crlf
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|k
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\033[%s%dmMode %2d\033[0m"
argument_list|,
name|temp
argument_list|,
name|k
argument_list|,
name|k
argument_list|)
expr_stmt|;
name|char_count
operator|+=
literal|8
expr_stmt|;
if|if
condition|(
name|puc
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|k
operator|==
literal|19
condition|)
name|printf
argument_list|(
literal|"\033[10m"
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|==
literal|39
condition|)
name|printf
argument_list|(
literal|"\033[37m"
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|==
literal|49
condition|)
name|printf
argument_list|(
literal|"\033[40m"
argument_list|)
expr_stmt|;
block|}
block|}
name|put_crlf
argument_list|()
expr_stmt|;
if|if
condition|(
name|puc
operator|==
literal|'<'
condition|)
name|printf
argument_list|(
literal|"\033[<1m"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|puc
condition|)
name|printf
argument_list|(
literal|"\033[%s0m"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|set_attr
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **	print_sgr20(on, off) ** **	print the sgr line for sgr20() */
end_comment

begin_function
specifier|static
name|void
name|print_sgr20
parameter_list|(
name|int
name|on
parameter_list|,
name|int
name|off
parameter_list|)
block|{
if|if
condition|(
name|char_count
operator|>
name|columns
operator|-
literal|13
condition|)
block|{
name|put_crlf
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|char_count
condition|)
block|{
name|put_str
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
block|}
name|char_count
operator|+=
literal|11
expr_stmt|;
name|printf
argument_list|(
literal|"%d/%d \033[%dmon\033[%dm off\033[0m"
argument_list|,
name|on
argument_list|,
name|off
argument_list|,
name|on
argument_list|,
name|off
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **	sgr20(void) ** **	display the enter/exit attributes 1-9 and 20-29 */
end_comment

begin_function
specifier|static
name|void
name|sgr20
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|k
decl_stmt|;
name|put_crlf
argument_list|()
expr_stmt|;
name|ptextln
argument_list|(
literal|"Test enter/exit attributes 1-9 and 21-29."
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|1
init|;
name|k
operator|<
literal|10
condition|;
name|k
operator|++
control|)
block|{
name|print_sgr20
argument_list|(
name|k
argument_list|,
name|k
operator|+
literal|20
argument_list|)
expr_stmt|;
block|}
name|print_sgr20
argument_list|(
literal|1
argument_list|,
literal|22
argument_list|)
expr_stmt|;
comment|/* bold */
name|print_sgr20
argument_list|(
literal|2
argument_list|,
literal|22
argument_list|)
expr_stmt|;
comment|/* dim */
name|print_sgr20
argument_list|(
literal|8
argument_list|,
literal|22
argument_list|)
expr_stmt|;
comment|/* blank */
name|printf
argument_list|(
literal|"\033[0m"
argument_list|)
expr_stmt|;
name|set_attr
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **	tools_sgr(testlist, state, ch) ** **	Run the ANSI graphics rendition mode tool **	Return the last character typed. */
end_comment

begin_function
name|void
name|tools_sgr
parameter_list|(
name|struct
name|test_list
modifier|*
name|t
name|GCC_UNUSED
parameter_list|,
name|int
modifier|*
name|state
name|GCC_UNUSED
parameter_list|,
name|int
modifier|*
name|ch
parameter_list|)
block|{
name|int
name|k
decl_stmt|;
name|put_clear
argument_list|()
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
condition|;
control|)
block|{
name|display_sgr
argument_list|(
name|k
argument_list|)
expr_stmt|;
name|put_crlf
argument_list|()
expr_stmt|;
name|menu_prompt
argument_list|()
expr_stmt|;
name|ptext
argument_list|(
literal|"/sgr Enter =><?r [<cr>]> "
argument_list|)
expr_stmt|;
name|k
operator|=
name|wait_here
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|k
operator|==
literal|'r'
operator|)
operator|||
operator|(
name|k
operator|==
literal|'R'
operator|)
condition|)
block|{
name|k
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|k
operator|<
literal|'<'
operator|)
operator|||
operator|(
name|k
operator|>
literal|'?'
operator|)
condition|)
block|{
break|break;
block|}
block|}
name|sgr20
argument_list|()
expr_stmt|;
name|put_newlines
argument_list|(
literal|2
argument_list|)
expr_stmt|;
operator|*
name|ch
operator|=
name|REQUEST_PROMPT
expr_stmt|;
block|}
end_function

begin_comment
comment|/*****************************************************************************  *  * Test ANSI graphics  *  *****************************************************************************/
end_comment

begin_comment
comment|/* **	select_bank(bank) ** **	select a graphics character set for ANSI terminals */
end_comment

begin_function
specifier|static
name|void
name|select_bank
parameter_list|(
name|char
modifier|*
name|bank
parameter_list|)
block|{
name|tc_putp
argument_list|(
name|bank
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|bank
index|[
literal|1
index|]
operator|&
literal|3
condition|)
block|{
case|case
literal|0
case|:
name|putchp
argument_list|(
literal|'O'
operator|&
literal|0x1f
argument_list|)
expr_stmt|;
comment|/* control O */
break|break;
case|case
literal|1
case|:
name|putchp
argument_list|(
literal|'N'
operator|&
literal|0x1f
argument_list|)
expr_stmt|;
comment|/* control N */
name|tc_putp
argument_list|(
literal|"\033~"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|tc_putp
argument_list|(
literal|"\033n\033}"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|tc_putp
argument_list|(
literal|"\033o\033|"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* **	show_characters(bank, bias) ** **	print the ANSI graphics characters */
end_comment

begin_function
specifier|static
name|void
name|show_characters
parameter_list|(
name|char
modifier|*
name|bank
parameter_list|,
name|int
name|bias
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"G%d GL   "
argument_list|,
name|bank
index|[
literal|1
index|]
operator|&
literal|3
argument_list|)
expr_stmt|;
name|ptext
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|select_bank
argument_list|(
name|bank
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|' '
init|;
name|i
operator|<
literal|0x80
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|char_count
operator|>=
name|columns
operator|||
operator|(
name|i
operator|!=
literal|' '
operator|&&
operator|(
name|i
operator|&
literal|31
operator|)
operator|==
literal|0
operator|)
condition|)
name|put_str
argument_list|(
literal|"\n        "
argument_list|)
expr_stmt|;
name|putchp
argument_list|(
name|i
operator|+
name|bias
argument_list|)
expr_stmt|;
block|}
name|select_bank
argument_list|(
name|default_bank
argument_list|)
expr_stmt|;
name|put_str
argument_list|(
literal|"   DEL<"
argument_list|)
expr_stmt|;
name|select_bank
argument_list|(
name|bank
argument_list|)
expr_stmt|;
name|putchp
argument_list|(
literal|0x7f
operator|+
name|bias
argument_list|)
expr_stmt|;
name|select_bank
argument_list|(
name|default_bank
argument_list|)
expr_stmt|;
name|putchp
argument_list|(
literal|'>'
argument_list|)
expr_stmt|;
name|put_crlf
argument_list|()
expr_stmt|;
name|put_crlf
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ANSI graphics test         94     96   character sets    G0   (      ,    G1   )      -    G2   *      .    G3   +      /  Standard Definitions    A    UK    B    US ASCII  Dec extended definitions    0    Special graphics   */
end_comment

begin_comment
comment|/* **	tools_charset(testlist, state, ch) ** **	Run the ANSI alt-charset mode tool */
end_comment

begin_function
name|void
name|tools_charset
parameter_list|(
name|struct
name|test_list
modifier|*
name|t
name|GCC_UNUSED
parameter_list|,
name|int
modifier|*
name|state
name|GCC_UNUSED
parameter_list|,
name|int
modifier|*
name|chp
name|GCC_UNUSED
parameter_list|)
block|{
name|int
name|j
decl_stmt|,
name|ch
decl_stmt|;
name|char
name|bank
index|[
literal|32
index|]
decl_stmt|;
name|put_clear
argument_list|()
expr_stmt|;
name|ptext
argument_list|(
literal|"Enter the bank ()*+,-./ followed by the character set"
argument_list|)
expr_stmt|;
name|ptext
argument_list|(
literal|" 0123456789:;<=>? for private use, and"
argument_list|)
expr_stmt|;
name|ptextln
argument_list|(
literal|" @A...Z[\\]^_`a...z{|}~ for standard sets."
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|bank
argument_list|,
literal|"\033)0"
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|bank
index|[
literal|0
index|]
condition|;
control|)
block|{
name|put_crlf
argument_list|()
expr_stmt|;
name|show_characters
argument_list|(
name|bank
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* G0 will not print in GR */
if|if
condition|(
name|bank
index|[
literal|1
index|]
operator|&
literal|3
condition|)
block|{
name|show_characters
argument_list|(
name|bank
argument_list|,
literal|0x80
argument_list|)
expr_stmt|;
block|}
name|ptext
argument_list|(
literal|"bank+set> "
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
operator|(
name|ch
operator|=
name|getchp
argument_list|(
name|char_mask
argument_list|)
operator|)
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|ch
operator|==
name|EOF
condition|)
break|break;
name|putchp
argument_list|(
name|ch
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|==
literal|1
operator|&&
name|ch
operator|>
literal|'/'
condition|)
name|j
operator|++
expr_stmt|;
name|bank
index|[
name|j
index|]
operator|=
name|ch
expr_stmt|;
if|if
condition|(
name|ch
operator|<
literal|' '
operator|||
name|ch
operator|>
literal|'/'
condition|)
break|break;
if|if
condition|(
name|j
operator|+
literal|1
operator|>=
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|bank
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|j
operator|==
literal|1
condition|)
break|break;
if|if
condition|(
name|bank
index|[
name|j
index|]
operator|<
literal|'0'
operator|||
name|bank
index|[
name|j
index|]
operator|>
literal|'~'
condition|)
break|break;
name|bank
index|[
name|j
operator|+
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|put_crlf
argument_list|()
expr_stmt|;
block|}
end_function

end_unit

