begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ** Copyright (C) 1991, 1997 Free Software Foundation, Inc. **  ** This file is part of TACK. **  ** TACK is free software; you can redistribute it and/or modify ** it under the terms of the GNU General Public License as published by ** the Free Software Foundation; either version 2, or (at your option) ** any later version. **  ** TACK is distributed in the hope that it will be useful, ** but WITHOUT ANY WARRANTY; without even the implied warranty of ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ** GNU General Public License for more details. **  ** You should have received a copy of the GNU General Public License ** along with TACK; see the file COPYING.  If not, write to ** the Free Software Foundation, Inc., 59 Temple Place - Suite 330, ** Boston, MA 02111-1307, USA. */
end_comment

begin_comment
comment|/* screen formatting and I/O utility functions */
end_comment

begin_include
include|#
directive|include
file|<tack.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_macro
name|MODULE_ID
argument_list|(
literal|"$Id: output.c,v 1.5 2000/03/04 21:06:57 tom Exp $"
argument_list|)
end_macro

begin_comment
comment|/* globals */
end_comment

begin_decl_stmt
name|long
name|char_sent
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of characters sent */
end_comment

begin_decl_stmt
name|int
name|char_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* counts characters */
end_comment

begin_decl_stmt
name|int
name|line_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* counts line feeds */
end_comment

begin_decl_stmt
name|int
name|expand_chars
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* length of expand() string */
end_comment

begin_decl_stmt
name|int
name|replace_mode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* used to output replace mode padding */
end_comment

begin_decl_stmt
name|int
name|can_go_home
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* TRUE if we can fashion a home command */
end_comment

begin_decl_stmt
name|int
name|can_clear_screen
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* TRUE if we can somehow clear the screen */
end_comment

begin_decl_stmt
name|int
name|raw_characters_sent
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Total output characters */
end_comment

begin_decl_stmt
name|int
name|log_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of characters on a log line */
end_comment

begin_comment
comment|/* translate mode default strings */
end_comment

begin_define
define|#
directive|define
name|TM_carriage_return
value|TM_string[0].value
end_define

begin_define
define|#
directive|define
name|TM_cursor_down
value|TM_string[1].value
end_define

begin_define
define|#
directive|define
name|TM_scroll_forward
value|TM_string[2].value
end_define

begin_define
define|#
directive|define
name|TM_newline
value|TM_string[3].value
end_define

begin_define
define|#
directive|define
name|TM_cursor_left
value|TM_string[4].value
end_define

begin_define
define|#
directive|define
name|TM_bell
value|TM_string[5].value
end_define

begin_define
define|#
directive|define
name|TM_form_feed
value|TM_string[6].value
end_define

begin_define
define|#
directive|define
name|TM_tab
value|TM_string[7].value
end_define

begin_decl_stmt
name|struct
name|default_string_list
name|TM_string
index|[
name|TM_last
index|]
init|=
block|{
block|{
literal|"cr"
block|,
literal|"\r"
block|,
literal|0
block|}
block|,
block|{
literal|"cud1"
block|,
literal|"\n"
block|,
literal|0
block|}
block|,
block|{
literal|"ind"
block|,
literal|"\n"
block|,
literal|0
block|}
block|,
block|{
literal|"nel"
block|,
literal|"\r\n"
block|,
literal|0
block|}
block|,
block|{
literal|"cub1"
block|,
literal|"\b"
block|,
literal|0
block|}
block|,
block|{
literal|"bel"
block|,
literal|"\007"
block|,
literal|0
block|}
block|,
block|{
literal|"ff"
block|,
literal|"\f"
block|,
literal|0
block|}
block|,
block|{
literal|"ht"
block|,
literal|"\t"
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|c0
index|[
literal|32
index|]
init|=
block|{
literal|"NUL"
block|,
literal|"SOH"
block|,
literal|"STX"
block|,
literal|"ETX"
block|,
literal|"EOT"
block|,
literal|"ENQ"
block|,
literal|"ACK"
block|,
literal|"BEL"
block|,
literal|"BS"
block|,
literal|"HT"
block|,
literal|"LF"
block|,
literal|"VT"
block|,
literal|"FF"
block|,
literal|"CR"
block|,
literal|"SO"
block|,
literal|"SI"
block|,
literal|"DLE"
block|,
literal|"DC1"
block|,
literal|"DC2"
block|,
literal|"DC3"
block|,
literal|"DC4"
block|,
literal|"NAK"
block|,
literal|"SYN"
block|,
literal|"ETB"
block|,
literal|"CAN"
block|,
literal|"EM"
block|,
literal|"SUB"
block|,
literal|"ESC"
block|,
literal|"FS"
block|,
literal|"GS"
block|,
literal|"RS"
block|,
literal|"US"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|c1
index|[
literal|32
index|]
init|=
block|{
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|"IND"
block|,
literal|"NEL"
block|,
literal|"SSA"
block|,
literal|"ESA"
block|,
literal|"HTS"
block|,
literal|"HTJ"
block|,
literal|"VTS"
block|,
literal|"PLD"
block|,
literal|"PLU"
block|,
literal|"RI"
block|,
literal|"SS2"
block|,
literal|"SS3"
block|,
literal|"DCS"
block|,
literal|"PU1"
block|,
literal|"PU2"
block|,
literal|"STS"
block|,
literal|"CCH"
block|,
literal|"MW"
block|,
literal|"SPA"
block|,
literal|"EPA"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|"CSI"
block|,
literal|"ST"
block|,
literal|"OSC"
block|,
literal|"PM"
block|,
literal|"APC"
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|getnext
parameter_list|(
name|int
name|mask
parameter_list|)
block|{
comment|/* get the next character without scan mode 				   conversion */
name|int
name|ch
decl_stmt|;
name|unsigned
name|char
name|buf
decl_stmt|;
name|tc_putp
argument_list|(
name|req_for_input
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|nodelay_read
condition|)
while|while
condition|(
literal|1
condition|)
block|{
name|ch
operator|=
name|read
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
operator|&
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
operator|-
literal|1
condition|)
return|return
name|EOF
return|;
if|if
condition|(
name|ch
operator|==
literal|1
condition|)
return|return
name|buf
return|;
block|}
name|ch
operator|=
name|getchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|EOF
condition|)
return|return
name|EOF
return|;
return|return
name|ch
operator|&
name|mask
return|;
block|}
end_function

begin_function
name|int
name|getchp
parameter_list|(
name|int
name|mask
parameter_list|)
block|{
comment|/* read a character with scan mode conversion */
if|if
condition|(
name|scan_mode
condition|)
block|{
name|tc_putp
argument_list|(
name|req_for_input
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
return|return
name|scan_key
argument_list|()
return|;
block|}
else|else
return|return
name|getnext
argument_list|(
name|mask
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* **	tc_putch(c) ** **	Output one character */
end_comment

begin_function
name|int
name|tc_putch
parameter_list|(
name|int
name|c
parameter_list|)
block|{
name|char_sent
operator|++
expr_stmt|;
name|raw_characters_sent
operator|++
expr_stmt|;
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|raw_characters_sent
operator|&
literal|31
operator|)
operator|==
literal|31
condition|)
block|{
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|log_fp
condition|)
block|{
comment|/* terminal output logging */
name|c
operator|&=
literal|0xff
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|32
condition|)
block|{
name|fprintf
argument_list|(
name|log_fp
argument_list|,
literal|"<%s>"
argument_list|,
name|c0
index|[
name|c
index|]
argument_list|)
expr_stmt|;
name|log_count
operator|+=
literal|5
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|<
literal|127
condition|)
block|{
name|fprintf
argument_list|(
name|log_fp
argument_list|,
literal|"%c"
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|log_count
operator|+=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|log_fp
argument_list|,
literal|"<%02x>"
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|log_count
operator|+=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|'\n'
operator|||
name|log_count
operator|>=
literal|80
condition|)
block|{
name|fprintf
argument_list|(
name|log_fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|log_count
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
operator|(
name|c
operator|)
return|;
block|}
end_function

begin_comment
comment|/* **	tt_tputs(string, reps) ** **	Output a string with tputs() translation. **	Use this function inside timing tests. */
end_comment

begin_function
name|void
name|tt_tputs
parameter_list|(
specifier|const
name|char
modifier|*
name|string
parameter_list|,
name|int
name|reps
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|string
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TT_MAX
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>=
name|ttp
condition|)
block|{
name|tt_cap
index|[
name|i
index|]
operator|=
name|string
expr_stmt|;
name|tt_affected
index|[
name|i
index|]
operator|=
name|reps
expr_stmt|;
name|tt_count
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|tt_delay
index|[
name|i
index|]
operator|=
name|msec_cost
argument_list|(
name|string
argument_list|,
name|reps
argument_list|)
expr_stmt|;
name|ttp
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|string
operator|==
name|tt_cap
index|[
name|i
index|]
operator|&&
name|reps
operator|==
name|tt_affected
index|[
name|i
index|]
condition|)
block|{
name|tt_count
index|[
name|i
index|]
operator|++
expr_stmt|;
name|tt_delay_used
operator|+=
name|tt_delay
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
block|}
operator|(
name|void
operator|)
name|tputs
argument_list|(
name|string
argument_list|,
name|reps
argument_list|,
name|tc_putch
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* **	tt_putp(string) ** **	Output a string with tputs() translation. **	Use this function inside timing tests. */
end_comment

begin_function
name|void
name|tt_putp
parameter_list|(
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
name|tt_tputs
argument_list|(
name|string
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **	tt_putparm(string, reps, arg1, arg2, ...) ** **	Send tt_tputs(tparm(string, args...), reps) **	Use this function inside timing tests. */
end_comment

begin_function
name|void
name|tt_putparm
parameter_list|(
name|NCURSES_CONST
name|char
modifier|*
name|string
parameter_list|,
name|int
name|reps
parameter_list|,
name|int
name|arg1
parameter_list|,
name|int
name|arg2
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|string
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TT_MAX
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>=
name|ttp
condition|)
block|{
name|tt_cap
index|[
name|i
index|]
operator|=
name|string
expr_stmt|;
name|tt_affected
index|[
name|i
index|]
operator|=
name|reps
expr_stmt|;
name|tt_count
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|tt_delay
index|[
name|i
index|]
operator|=
name|msec_cost
argument_list|(
name|string
argument_list|,
name|reps
argument_list|)
expr_stmt|;
name|ttp
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|string
operator|==
name|tt_cap
index|[
name|i
index|]
operator|&&
name|reps
operator|==
name|tt_affected
index|[
name|i
index|]
condition|)
block|{
name|tt_count
index|[
name|i
index|]
operator|++
expr_stmt|;
name|tt_delay_used
operator|+=
name|tt_delay
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
block|}
operator|(
name|void
operator|)
name|tputs
argument_list|(
name|tparm
argument_list|(
operator|(
name|NCURSES_CONST
name|char
operator|*
operator|)
name|string
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
argument_list|,
name|reps
argument_list|,
name|tc_putch
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* **	tc_putp(string) ** **	Output a string with tputs() translation. **	Use this function instead of putp() so we can track **	the actual number of characters sent. */
end_comment

begin_function
name|int
name|tc_putp
parameter_list|(
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
return|return
name|tputs
argument_list|(
name|string
argument_list|,
literal|1
argument_list|,
name|tc_putch
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|put_this
parameter_list|(
name|int
name|c
parameter_list|)
block|{
comment|/* output one character (with padding) */
name|tc_putch
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|char_padding
operator|&&
name|replace_mode
condition|)
name|tt_putp
argument_list|(
name|char_padding
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|put_cr
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|translate_mode
operator|&&
name|carriage_return
condition|)
block|{
name|tt_putp
argument_list|(
name|carriage_return
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tt_putp
argument_list|(
name|TM_carriage_return
argument_list|)
expr_stmt|;
block|}
name|char_count
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|put_lf
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* send a linefeed (only works in RAW or 				   CBREAK mode) */
if|if
condition|(
name|translate_mode
operator|&&
name|cursor_down
condition|)
block|{
name|tt_putp
argument_list|(
name|cursor_down
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tt_putp
argument_list|(
name|TM_cursor_down
argument_list|)
expr_stmt|;
block|}
name|line_count
operator|++
expr_stmt|;
block|}
end_function

begin_function
name|void
name|put_ind
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* scroll forward (only works in RAW or 				   CBREAK mode) */
if|if
condition|(
name|translate_mode
operator|&&
name|scroll_forward
condition|)
block|{
name|tt_putp
argument_list|(
name|scroll_forward
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tt_putp
argument_list|(
name|TM_scroll_forward
argument_list|)
expr_stmt|;
block|}
name|line_count
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **	put_crlf() ** **	Send (nel)  or<cr><lf> */
end_comment

begin_function
name|void
name|put_crlf
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|translate_mode
operator|&&
name|newline
condition|)
block|{
name|tt_putp
argument_list|(
name|newline
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tt_putp
argument_list|(
name|TM_newline
argument_list|)
expr_stmt|;
block|}
name|char_count
operator|=
literal|0
expr_stmt|;
name|line_count
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **	put_new_lines(count) ** **	Send a number of newlines. (nel) */
end_comment

begin_function
name|void
name|put_newlines
parameter_list|(
name|int
name|n
parameter_list|)
block|{
while|while
condition|(
name|n
operator|--
operator|>
literal|0
condition|)
block|{
name|put_crlf
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* **	putchp(character) ** **	Send one character to the terminal. **	This function does translation of control characters. */
end_comment

begin_function
name|void
name|putchp
parameter_list|(
name|int
name|c
parameter_list|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\b'
case|:
if|if
condition|(
name|translate_mode
operator|&&
name|cursor_left
condition|)
block|{
name|tt_putp
argument_list|(
name|cursor_left
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tt_putp
argument_list|(
name|TM_cursor_left
argument_list|)
expr_stmt|;
block|}
name|char_count
operator|--
expr_stmt|;
break|break;
case|case
literal|7
case|:
if|if
condition|(
name|translate_mode
operator|&&
name|bell
condition|)
block|{
name|tt_putp
argument_list|(
name|bell
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tt_putp
argument_list|(
name|TM_bell
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'\f'
case|:
if|if
condition|(
name|translate_mode
operator|&&
name|form_feed
condition|)
block|{
name|tt_putp
argument_list|(
name|form_feed
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tt_putp
argument_list|(
name|TM_form_feed
argument_list|)
expr_stmt|;
block|}
name|char_count
operator|=
literal|0
expr_stmt|;
name|line_count
operator|++
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
name|put_crlf
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'\r'
case|:
name|put_cr
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'\t'
case|:
if|if
condition|(
name|translate_mode
operator|&&
name|tab
condition|)
block|{
name|tt_putp
argument_list|(
name|tab
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tt_putp
argument_list|(
name|TM_tab
argument_list|)
expr_stmt|;
block|}
name|char_count
operator|=
operator|(
operator|(
name|char_count
operator|/
literal|8
operator|)
operator|+
literal|1
operator|)
operator|*
literal|8
expr_stmt|;
break|break;
default|default:
name|put_this
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|char_count
operator|++
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
name|void
name|put_str
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
comment|/* send the string to the terminal */
for|for
control|(
init|;
operator|*
name|s
condition|;
name|putchp
argument_list|(
operator|*
name|s
operator|++
argument_list|)
control|)
empty_stmt|;
block|}
end_function

begin_function
name|void
name|putln
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
comment|/* output a string followed by a CR LF */
for|for
control|(
init|;
operator|*
name|s
condition|;
name|putchp
argument_list|(
operator|*
name|s
operator|++
argument_list|)
control|)
empty_stmt|;
name|put_crlf
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|put_columns
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|w
parameter_list|)
block|{
comment|/* put out s in column format */
name|int
name|l
decl_stmt|;
if|if
condition|(
name|char_count
operator|+
name|w
operator|>
name|columns
condition|)
block|{
name|put_crlf
argument_list|()
expr_stmt|;
block|}
name|l
operator|=
name|char_count
operator|%
name|w
expr_stmt|;
if|if
condition|(
name|l
condition|)
block|{
while|while
condition|(
name|l
operator|<
name|w
condition|)
block|{
name|putchp
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|l
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|char_count
operator|&&
name|char_count
operator|+
name|len
operator|>=
name|columns
condition|)
block|{
name|put_crlf
argument_list|()
expr_stmt|;
block|}
name|l
operator|=
name|char_count
expr_stmt|;
name|put_str
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|char_count
operator|=
name|l
operator|+
name|len
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **	ptext(string) ** **	Output a string but do not assume the terminal will wrap to a **	new line.  Break the line at a word boundary then send a CR LF. **	This is more esthetic on 40 column terminals. */
end_comment

begin_function
name|void
name|ptext
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|t
decl_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
block|{
for|for
control|(
name|t
operator|=
name|s
operator|+
literal|1
init|;
operator|*
name|t
operator|>
literal|' '
condition|;
name|t
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|(
name|char_count
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|t
operator|-
name|s
operator|)
operator|+
name|char_count
operator|>=
name|columns
operator|)
condition|)
block|{
name|put_crlf
argument_list|()
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|==
literal|' '
condition|)
name|s
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|s
operator|<
name|t
condition|)
block|{
name|putchp
argument_list|(
operator|*
name|s
operator|++
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|put_dec
parameter_list|(
name|char
modifier|*
name|f
parameter_list|,
name|int
name|i
parameter_list|)
block|{
comment|/* print a line with a decimal number in it */
name|char
name|tm
index|[
literal|128
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|tm
argument_list|,
name|f
argument_list|,
name|i
operator|/
literal|10
argument_list|,
name|i
operator|%
literal|10
argument_list|)
expr_stmt|;
name|ptext
argument_list|(
name|tm
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|three_digit
parameter_list|(
name|char
modifier|*
name|tx
parameter_list|,
name|int
name|i
parameter_list|)
block|{
comment|/* convert the decimal number to a string of 				   at least 3 digits */
if|if
condition|(
name|i
operator|<
literal|1000
condition|)
name|sprintf
argument_list|(
name|tx
argument_list|,
literal|"%d.%d"
argument_list|,
name|i
operator|/
literal|10
argument_list|,
name|i
operator|%
literal|10
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|tx
argument_list|,
literal|"%d"
argument_list|,
name|i
operator|/
literal|10
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ptextln
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
comment|/* print the text using ptext() then add a CR 				   LF */
name|ptext
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|put_crlf
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|expand_one
parameter_list|(
name|int
name|ch
parameter_list|,
name|char
modifier|*
modifier|*
name|v
parameter_list|)
block|{
comment|/* expand one character */
name|char
modifier|*
name|t
init|=
operator|*
name|v
decl_stmt|;
if|if
condition|(
name|ch
operator|&
literal|0x80
condition|)
block|{
comment|/* dump it in octal (yuck) */
operator|*
name|t
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|t
operator|++
operator|=
literal|'0'
operator|+
operator|(
operator|(
name|ch
operator|>>
literal|6
operator|)
operator|&
literal|3
operator|)
expr_stmt|;
operator|*
name|t
operator|++
operator|=
literal|'0'
operator|+
operator|(
operator|(
name|ch
operator|>>
literal|3
operator|)
operator|&
literal|7
operator|)
expr_stmt|;
operator|*
name|t
operator|++
operator|=
literal|'0'
operator|+
operator|(
name|ch
operator|&
literal|7
operator|)
expr_stmt|;
name|expand_chars
operator|+=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|127
condition|)
block|{
comment|/* DEL */
operator|*
name|t
operator|++
operator|=
literal|'^'
expr_stmt|;
operator|*
name|t
operator|++
operator|=
literal|'?'
expr_stmt|;
name|expand_chars
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|>=
literal|' '
condition|)
block|{
operator|*
name|t
operator|++
operator|=
name|ch
expr_stmt|;
name|expand_chars
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* control characters */
operator|*
name|t
operator|++
operator|=
literal|'^'
expr_stmt|;
operator|*
name|t
operator|++
operator|=
name|ch
operator|+
literal|'@'
expr_stmt|;
name|expand_chars
operator|+=
literal|2
expr_stmt|;
block|}
operator|*
name|v
operator|=
name|t
expr_stmt|;
block|}
end_function

begin_function
name|char
modifier|*
name|expand
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
comment|/* convert the string to printable form */
specifier|static
name|char
name|buf
index|[
literal|4096
index|]
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|,
modifier|*
name|v
decl_stmt|;
name|int
name|ch
decl_stmt|;
if|if
condition|(
name|magic_cookie_glitch
operator|<=
literal|0
operator|&&
name|exit_attribute_mode
condition|)
block|{
name|v
operator|=
name|enter_reverse_mode
expr_stmt|;
block|}
else|else
block|{
name|v
operator|=
name|NULL
expr_stmt|;
block|}
name|expand_chars
operator|=
literal|0
expr_stmt|;
name|t
operator|=
name|buf
expr_stmt|;
if|if
condition|(
name|s
condition|)
block|{
for|for
control|(
init|;
operator|(
name|ch
operator|=
operator|*
name|s
operator|)
condition|;
name|s
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|ch
operator|&
literal|0x80
operator|)
operator|&&
name|v
condition|)
block|{
comment|/* print it in reverse video 						   mode */
name|strcpy
argument_list|(
name|t
argument_list|,
name|liberated
argument_list|(
name|tparm
argument_list|(
name|v
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
operator|*
name|t
condition|;
name|t
operator|++
control|)
empty_stmt|;
name|expand_one
argument_list|(
name|ch
operator|&
literal|0x7f
argument_list|,
operator|&
name|t
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|t
argument_list|,
name|liberated
argument_list|(
name|tparm
argument_list|(
name|exit_attribute_mode
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
operator|*
name|t
condition|;
name|t
operator|++
control|)
empty_stmt|;
block|}
else|else
block|{
name|expand_one
argument_list|(
name|ch
argument_list|,
operator|&
name|t
argument_list|)
expr_stmt|;
block|}
block|}
block|}
operator|*
name|t
operator|=
literal|'\0'
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|print_expand
parameter_list|(
name|char
modifier|*
name|s
parameter_list|)
block|{
comment|/* convert the string to 7-bit printable form */
specifier|static
name|char
name|buf
index|[
literal|4096
index|]
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
name|int
name|ch
decl_stmt|;
name|expand_chars
operator|=
literal|0
expr_stmt|;
name|t
operator|=
name|buf
expr_stmt|;
if|if
condition|(
name|s
condition|)
block|{
for|for
control|(
init|;
operator|(
name|ch
operator|=
operator|*
name|s
operator|)
condition|;
name|s
operator|++
control|)
block|{
name|expand_one
argument_list|(
name|ch
argument_list|,
operator|&
name|t
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|t
operator|=
literal|'\0'
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|expand_to
parameter_list|(
name|char
modifier|*
name|s
parameter_list|,
name|int
name|l
parameter_list|)
block|{
comment|/* expand s to length l */
name|char
modifier|*
name|t
decl_stmt|;
for|for
control|(
name|s
operator|=
name|t
operator|=
name|expand
argument_list|(
name|s
argument_list|)
init|;
operator|*
name|t
condition|;
name|t
operator|++
control|)
empty_stmt|;
for|for
control|(
init|;
name|expand_chars
operator|<
name|l
condition|;
name|expand_chars
operator|++
control|)
block|{
operator|*
name|t
operator|++
operator|=
literal|' '
expr_stmt|;
block|}
operator|*
name|t
operator|=
literal|'\0'
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|hex_expand_to
parameter_list|(
name|char
modifier|*
name|s
parameter_list|,
name|int
name|l
parameter_list|)
block|{
comment|/* expand s to length l in hex */
specifier|static
name|char
name|buf
index|[
literal|4096
index|]
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
for|for
control|(
name|t
operator|=
name|buf
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
block|{
name|sprintf
argument_list|(
name|t
argument_list|,
literal|"%02X "
argument_list|,
operator|*
name|s
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|t
operator|+=
literal|3
expr_stmt|;
if|if
condition|(
name|t
operator|-
name|buf
operator|>
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
literal|4
condition|)
block|{
break|break;
block|}
block|}
for|for
control|(
init|;
name|t
operator|-
name|buf
operator|<
name|l
condition|;
control|)
block|{
operator|*
name|t
operator|++
operator|=
literal|' '
expr_stmt|;
block|}
operator|*
name|t
operator|=
literal|'\0'
expr_stmt|;
name|expand_chars
operator|=
name|t
operator|-
name|buf
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|expand_command
parameter_list|(
specifier|const
name|char
modifier|*
name|c
parameter_list|)
block|{
comment|/* expand an ANSI escape sequence */
specifier|static
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|ch
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|s
operator|=
name|buf
expr_stmt|;
for|for
control|(
name|i
operator|=
name|FALSE
init|;
operator|(
name|ch
operator|=
operator|(
operator|*
name|c
operator|&
literal|0xff
operator|)
operator|)
condition|;
name|c
operator|++
control|)
block|{
if|if
condition|(
name|i
condition|)
block|{
operator|*
name|s
operator|++
operator|=
literal|' '
expr_stmt|;
block|}
name|i
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|ch
operator|<
literal|32
condition|)
block|{
name|j
operator|=
name|c
index|[
literal|1
index|]
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'\033'
operator|&&
name|j
operator|>=
literal|'@'
operator|&&
name|j
operator|<=
literal|'_'
condition|)
block|{
name|ch
operator|=
name|j
operator|-
literal|'@'
expr_stmt|;
name|c
operator|++
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
operator|(
operator|*
name|s
operator|=
name|c1
index|[
name|ch
index|]
index|[
name|j
operator|++
index|]
operator|)
condition|;
name|s
operator|++
control|)
empty_stmt|;
block|}
else|else
for|for
control|(
name|j
operator|=
literal|0
init|;
operator|(
operator|*
name|s
operator|=
name|c0
index|[
name|ch
index|]
index|[
name|j
operator|++
index|]
operator|)
condition|;
name|s
operator|++
control|)
empty_stmt|;
block|}
else|else
block|{
operator|*
name|s
operator|++
operator|=
name|ch
expr_stmt|;
name|j
operator|=
name|c
index|[
literal|1
index|]
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|ch
operator|>=
literal|'0'
operator|&&
name|ch
operator|<=
literal|'9'
operator|&&
name|j
operator|>=
literal|'0'
operator|&&
name|j
operator|<=
literal|'9'
condition|)
block|{
name|i
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
block|}
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_comment
comment|/* **	go_home() ** **	Move the cursor to the home position */
end_comment

begin_function
name|void
name|go_home
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|cursor_home
condition|)
name|tt_putp
argument_list|(
name|cursor_home
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cursor_address
condition|)
name|tt_putparm
argument_list|(
name|cursor_address
argument_list|,
name|lines
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|row_address
condition|)
block|{
comment|/* use (vpa) */
name|put_cr
argument_list|()
expr_stmt|;
name|tt_putparm
argument_list|(
name|row_address
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cursor_up
operator|&&
name|cursor_to_ll
condition|)
block|{
name|tt_putp
argument_list|(
name|cursor_to_ll
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|lines
condition|;
name|i
operator|++
control|)
block|{
name|tt_putp
argument_list|(
name|cursor_up
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|can_go_home
operator|=
name|FALSE
expr_stmt|;
return|return;
block|}
name|char_count
operator|=
name|line_count
operator|=
literal|0
expr_stmt|;
name|can_go_home
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_function
name|void
name|home_down
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* move the cursor to the lower left hand 				   corner */
name|int
name|i
decl_stmt|;
if|if
condition|(
name|cursor_to_ll
condition|)
name|tt_putp
argument_list|(
name|cursor_to_ll
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cursor_address
condition|)
name|tt_putparm
argument_list|(
name|cursor_address
argument_list|,
name|lines
argument_list|,
name|lines
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|row_address
condition|)
block|{
comment|/* use (vpa) */
name|put_cr
argument_list|()
expr_stmt|;
name|tt_putparm
argument_list|(
name|row_address
argument_list|,
literal|1
argument_list|,
name|lines
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cursor_down
operator|&&
name|cursor_home
condition|)
block|{
name|tt_putp
argument_list|(
name|cursor_home
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|lines
condition|;
name|i
operator|++
control|)
name|tt_putp
argument_list|(
name|cursor_down
argument_list|)
expr_stmt|;
block|}
else|else
return|return;
name|char_count
operator|=
literal|0
expr_stmt|;
name|line_count
operator|=
name|lines
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|void
name|put_clear
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* clear the screen */
name|int
name|i
decl_stmt|;
if|if
condition|(
name|clear_screen
condition|)
name|tt_tputs
argument_list|(
name|clear_screen
argument_list|,
name|lines
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|clr_eos
operator|&&
name|can_go_home
condition|)
block|{
name|go_home
argument_list|()
expr_stmt|;
name|tt_tputs
argument_list|(
name|clr_eos
argument_list|,
name|lines
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scroll_forward
operator|&&
operator|!
name|over_strike
operator|&&
operator|(
name|can_go_home
operator|||
name|cursor_up
operator|)
condition|)
block|{
comment|/* clear the screen by scrolling */
name|put_cr
argument_list|()
expr_stmt|;
if|if
condition|(
name|cursor_to_ll
condition|)
block|{
name|tt_putp
argument_list|(
name|cursor_to_ll
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cursor_address
condition|)
block|{
name|tt_putparm
argument_list|(
name|cursor_address
argument_list|,
name|lines
argument_list|,
name|lines
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|row_address
condition|)
block|{
name|tt_putparm
argument_list|(
name|row_address
argument_list|,
literal|1
argument_list|,
name|lines
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|lines
condition|;
name|i
operator|++
control|)
block|{
name|tt_putp
argument_list|(
name|scroll_forward
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|lines
condition|;
name|i
operator|++
control|)
block|{
name|tt_putp
argument_list|(
name|scroll_forward
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|can_go_home
condition|)
block|{
name|go_home
argument_list|()
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|lines
condition|;
name|i
operator|++
control|)
block|{
name|tt_putp
argument_list|(
name|cursor_up
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|can_clear_screen
operator|=
name|FALSE
expr_stmt|;
return|return;
block|}
name|char_count
operator|=
name|line_count
operator|=
literal|0
expr_stmt|;
name|can_clear_screen
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **	wait_here() ** **	read one character from the input stream **	If the terminal is not in RAW mode then this function will **	wait for a<cr> or<lf>. */
end_comment

begin_function
name|int
name|wait_here
parameter_list|(
name|void
parameter_list|)
block|{
name|char
name|ch
decl_stmt|,
name|cc
index|[
literal|64
index|]
decl_stmt|;
name|char
name|message
index|[
literal|16
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|cc
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|cc
index|[
name|i
index|]
operator|=
name|ch
operator|=
name|getchp
argument_list|(
name|STRIP_PARITY
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'\r'
operator|||
name|ch
operator|==
literal|'\n'
condition|)
block|{
name|put_crlf
argument_list|()
expr_stmt|;
name|char_sent
operator|=
literal|0
expr_stmt|;
return|return
name|cc
index|[
name|i
condition|?
name|i
operator|-
literal|1
else|:
literal|0
index|]
return|;
block|}
if|if
condition|(
name|ch
operator|>=
literal|' '
condition|)
block|{
if|if
condition|(
name|stty_query
argument_list|(
name|TTY_CHAR_MODE
argument_list|)
condition|)
block|{
name|put_crlf
argument_list|()
expr_stmt|;
name|char_sent
operator|=
literal|0
expr_stmt|;
return|return
name|ch
return|;
block|}
continue|continue;
block|}
if|if
condition|(
name|ch
operator|==
literal|023
condition|)
block|{
comment|/* Control S */
comment|/* ignore control S, but tell me about it */
while|while
condition|(
name|ch
operator|==
literal|023
operator|||
name|ch
operator|==
literal|021
condition|)
block|{
name|ch
operator|=
name|getchp
argument_list|(
name|STRIP_PARITY
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|cc
argument_list|)
condition|)
name|cc
index|[
operator|++
name|i
index|]
operator|=
name|ch
expr_stmt|;
block|}
name|put_str
argument_list|(
literal|"\nThe terminal sent a ^S -"
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
name|i
condition|;
name|j
operator|++
control|)
block|{
name|sprintf
argument_list|(
name|message
argument_list|,
literal|" %02X"
argument_list|,
name|cc
index|[
name|j
index|]
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|put_str
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
name|put_crlf
argument_list|()
expr_stmt|;
name|i
operator|=
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|!=
literal|021
condition|)
block|{
comment|/* Not Control Q */
comment|/* could be abort character */
name|spin_flush
argument_list|()
expr_stmt|;
if|if
condition|(
name|tty_can_sync
operator|==
name|SYNC_TESTED
condition|)
block|{
operator|(
name|void
operator|)
name|tty_sync_error
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|put_str
argument_list|(
literal|"\n? "
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
literal|'?'
return|;
block|}
end_function

begin_comment
comment|/* **	read_string(buffer, length) ** **	Read a string of characters from the input stream. */
end_comment

begin_function
name|void
name|read_string
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|int
name|ch
decl_stmt|,
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
operator|-
literal|1
condition|;
control|)
block|{
name|ch
operator|=
name|getchp
argument_list|(
name|STRIP_PARITY
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'\r'
operator|||
name|ch
operator|==
literal|'\n'
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|ch
operator|==
literal|'\b'
operator|||
name|ch
operator|==
literal|127
condition|)
block|{
if|if
condition|(
name|i
condition|)
block|{
name|putchp
argument_list|(
literal|'\b'
argument_list|)
expr_stmt|;
name|putchp
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|putchp
argument_list|(
literal|'\b'
argument_list|)
expr_stmt|;
name|i
operator|--
expr_stmt|;
block|}
block|}
else|else
block|{
name|buf
index|[
name|i
operator|++
index|]
operator|=
name|ch
expr_stmt|;
name|putchp
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
block|}
name|buf
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|put_crlf
argument_list|()
expr_stmt|;
name|char_sent
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **	maybe_wait(lines) ** **	wait if near the end of the screen, then clear screen */
end_comment

begin_function
name|void
name|maybe_wait
parameter_list|(
name|int
name|n
parameter_list|)
block|{
if|if
condition|(
name|line_count
operator|+
name|n
operator|>=
name|lines
condition|)
block|{
if|if
condition|(
name|char_sent
operator|!=
literal|0
condition|)
block|{
name|ptext
argument_list|(
literal|"Go? "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|wait_here
argument_list|()
expr_stmt|;
block|}
name|put_clear
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|put_crlf
argument_list|()
expr_stmt|;
block|}
block|}
end_function

end_unit

