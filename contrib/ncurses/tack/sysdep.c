begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ** Copyright (C) 1991, 1997 Free Software Foundation, Inc. **  ** This file is part of TACK. **  ** TACK is free software; you can redistribute it and/or modify ** it under the terms of the GNU General Public License as published by ** the Free Software Foundation; either version 2, or (at your option) ** any later version. **  ** TACK is distributed in the hope that it will be useful, ** but WITHOUT ANY WARRANTY; without even the implied warranty of ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ** GNU General Public License for more details. **  ** You should have received a copy of the GNU General Public License ** along with TACK; see the file COPYING.  If not, write to ** the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, ** Boston, MA 02110-1301, USA */
end_comment

begin_comment
comment|/*  * Operating system dependent functions.  We assume the POSIX API.  * Note: on strict-POSIX systems (including BSD/OS) the select_delay_type  * global has no effect.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<ncurses_cfg.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_comment
comment|/* include before curses.h to work around glibc bug */
end_comment

begin_include
include|#
directive|include
file|<tack.h>
end_include

begin_include
include|#
directive|include
file|<term.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__BEOS__
argument_list|)
end_if

begin_undef
undef|#
directive|undef
name|false
end_undef

begin_undef
undef|#
directive|undef
name|true
end_undef

begin_include
include|#
directive|include
file|<OS.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_SELECT
end_if

begin_if
if|#
directive|if
name|HAVE_SYS_TIME_H
operator|&&
name|HAVE_SYS_TIME_SELECT
end_if

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_SYS_SELECT_H
end_if

begin_include
include|#
directive|include
file|<sys/select.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|MODULE_ID
argument_list|(
literal|"$Id: sysdep.c,v 1.15 2005/09/17 19:49:16 tom Exp $"
argument_list|)
end_macro

begin_if
if|#
directive|if
name|DECL_ERRNO
end_if

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|TERMIOS
end_ifdef

begin_define
define|#
directive|define
name|PUT_TTY
parameter_list|(
name|fd
parameter_list|,
name|buf
parameter_list|)
value|tcsetattr(fd, TCSAFLUSH, buf)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|PUT_TTY
parameter_list|(
name|fd
parameter_list|,
name|buf
parameter_list|)
value|stty(fd, buf)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* globals */
end_comment

begin_decl_stmt
name|int
name|tty_frame_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* asynch frame size times 2 */
end_comment

begin_decl_stmt
name|unsigned
name|tty_baud_rate
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* baud rate - bits per second */
end_comment

begin_decl_stmt
name|int
name|not_a_tty
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* TRUE if output is not a tty (i.e. pipe) */
end_comment

begin_decl_stmt
name|int
name|nodelay_read
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* TRUE if NDELAY is set */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TERMIOS
end_ifdef

begin_define
define|#
directive|define
name|TTY_IS_NOECHO
value|!(new_modes.c_lflag& ECHO)
end_define

begin_define
define|#
directive|define
name|TTY_IS_OUT_TRANS
value|(new_modes.c_oflag& OPOST)
end_define

begin_define
define|#
directive|define
name|TTY_IS_CHAR_MODE
value|!(new_modes.c_lflag& ICANON)
end_define

begin_define
define|#
directive|define
name|TTY_WAS_CS8
value|((old_modes.c_cflag& CSIZE) == CS8)
end_define

begin_define
define|#
directive|define
name|TTY_WAS_XON_XOFF
value|(old_modes.c_iflag& (IXON|IXOFF))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|TTY_IS_NOECHO
value|!(new_modes.sg_flags& (ECHO))
end_define

begin_define
define|#
directive|define
name|TTY_IS_OUT_TRANS
value|(new_modes.sg_flags& (CRMOD))
end_define

begin_define
define|#
directive|define
name|TTY_IS_CHAR_MODE
value|(new_modes.sg_flags& (RAW|CBREAK))
end_define

begin_define
define|#
directive|define
name|TTY_WAS_CS8
value|(old_modes.sg_flags& (PASS8))
end_define

begin_define
define|#
directive|define
name|TTY_WAS_XON_XOFF
value|(old_modes.sg_flags& (TANDEM|MDMBUF|DECCTQ))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|TTY
name|old_modes
decl_stmt|,
name|new_modes
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|catchsig
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * These are a sneaky way of conditionalizing bit unsets so strict-POSIX  * systems won't see them.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|XCASE
end_ifndef

begin_define
define|#
directive|define
name|XCASE
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|OLCUC
end_ifndef

begin_define
define|#
directive|define
name|OLCUC
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|IUCLC
end_ifndef

begin_define
define|#
directive|define
name|IUCLC
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TABDLY
end_ifndef

begin_define
define|#
directive|define
name|TABDLY
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|IXANY
end_ifndef

begin_define
define|#
directive|define
name|IXANY
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|tty_raw
parameter_list|(
name|int
name|minch
name|GCC_UNUSED
parameter_list|,
name|int
name|mask
parameter_list|)
block|{
comment|/* set tty to raw noecho */
name|new_modes
operator|=
name|old_modes
expr_stmt|;
ifdef|#
directive|ifdef
name|TERMIOS
if|#
directive|if
name|HAVE_SELECT
name|new_modes
operator|.
name|c_cc
index|[
name|VMIN
index|]
operator|=
literal|1
expr_stmt|;
else|#
directive|else
name|new_modes
operator|.
name|c_cc
index|[
name|VMIN
index|]
operator|=
name|minch
expr_stmt|;
endif|#
directive|endif
name|new_modes
operator|.
name|c_cc
index|[
name|VTIME
index|]
operator|=
literal|2
expr_stmt|;
name|new_modes
operator|.
name|c_lflag
operator|&=
operator|~
operator|(
name|ISIG
operator||
name|ICANON
operator||
name|XCASE
operator||
name|ECHO
operator||
name|ECHOE
operator||
name|ECHOK
operator||
name|ECHONL
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LOBLK
name|new_modes
operator|.
name|c_lflag
operator|&=
operator|~
name|LOBLK
expr_stmt|;
endif|#
directive|endif
name|new_modes
operator|.
name|c_oflag
operator|&=
operator|~
operator|(
name|OPOST
operator||
name|OLCUC
operator||
name|TABDLY
operator|)
expr_stmt|;
if|if
condition|(
name|mask
operator|==
name|ALLOW_PARITY
condition|)
block|{
name|new_modes
operator|.
name|c_cflag
operator|&=
operator|~
operator|(
name|CSIZE
operator||
name|PARENB
operator||
name|HUPCL
operator|)
expr_stmt|;
name|new_modes
operator|.
name|c_cflag
operator||=
name|CS8
expr_stmt|;
block|}
name|new_modes
operator|.
name|c_iflag
operator|&=
operator|~
operator|(
name|IGNBRK
operator||
name|BRKINT
operator||
name|IGNPAR
operator||
name|PARMRK
operator||
name|INPCK
operator||
name|ISTRIP
operator||
name|INLCR
operator||
name|IGNCR
operator||
name|ICRNL
operator||
name|IUCLC
operator||
name|IXON
operator||
name|IXANY
operator||
name|IXOFF
operator|)
expr_stmt|;
else|#
directive|else
name|new_modes
operator|.
name|sg_flags
operator||=
name|RAW
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|not_a_tty
condition|)
return|return;
name|PUT_TTY
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
operator|&
name|new_modes
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|tty_set
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* set tty to special modes */
name|new_modes
operator|=
name|old_modes
expr_stmt|;
ifdef|#
directive|ifdef
name|TERMIOS
name|new_modes
operator|.
name|c_cc
index|[
name|VMIN
index|]
operator|=
literal|1
expr_stmt|;
name|new_modes
operator|.
name|c_cc
index|[
name|VTIME
index|]
operator|=
literal|1
expr_stmt|;
name|new_modes
operator|.
name|c_lflag
operator|&=
operator|~
operator|(
name|ISIG
operator||
name|ICANON
operator||
name|ECHO
operator||
name|ECHOE
operator||
name|ECHOK
operator||
name|ECHONL
operator|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|ONLCR
argument_list|)
operator|&&
name|defined
argument_list|(
name|OCRNL
argument_list|)
operator|&&
name|defined
argument_list|(
name|ONLRET
argument_list|)
operator|&&
name|defined
argument_list|(
name|OFILL
argument_list|)
name|new_modes
operator|.
name|c_oflag
operator|&=
operator|~
operator|(
name|ONLCR
operator||
name|OCRNL
operator||
name|ONLRET
operator||
name|OFILL
operator|)
expr_stmt|;
else|#
directive|else
name|new_modes
operator|.
name|c_oflag
operator|&=
operator|~
operator|(
name|OPOST
operator|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|char_mask
operator|==
name|ALLOW_PARITY
condition|)
name|new_modes
operator|.
name|c_iflag
operator|&=
operator|~
name|ISTRIP
expr_stmt|;
switch|switch
condition|(
name|select_xon_xoff
condition|)
block|{
case|case
literal|0
case|:
name|new_modes
operator|.
name|c_iflag
operator|&=
operator|~
operator|(
name|IXON
operator||
name|IXOFF
operator|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
if|#
directive|if
name|defined
argument_list|(
name|sequent
argument_list|)
operator|&&
name|sequent
comment|/* the sequent System V emulation is broken */
name|new_modes
operator|=
name|old_modes
expr_stmt|;
name|new_modes
operator|.
name|c_cc
index|[
name|VEOL
index|]
operator|=
literal|6
expr_stmt|;
comment|/* control F  (ACK) */
endif|#
directive|endif
name|new_modes
operator|.
name|c_iflag
operator||=
name|IXON
operator||
name|IXOFF
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|select_delay_type
condition|)
block|{
case|case
literal|0
case|:
ifdef|#
directive|ifdef
name|NLDLY
name|new_modes
operator|.
name|c_oflag
operator|&=
operator|~
operator|(
name|NLDLY
operator||
name|CRDLY
operator||
name|TABDLY
operator||
name|BSDLY
operator||
name|VTDLY
operator||
name|FFDLY
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* NLDLY */
break|break;
case|case
literal|1
case|:
ifdef|#
directive|ifdef
name|NLDLY
name|new_modes
operator|.
name|c_oflag
operator|&=
operator|~
operator|(
name|NLDLY
operator||
name|CRDLY
operator||
name|TABDLY
operator||
name|BSDLY
operator||
name|VTDLY
operator||
name|FFDLY
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* NLDLY */
ifdef|#
directive|ifdef
name|NL1
name|new_modes
operator|.
name|c_oflag
operator||=
name|NL1
operator||
name|CR2
expr_stmt|;
endif|#
directive|endif
comment|/* NL1 */
break|break;
block|}
if|if
condition|(
operator|!
operator|(
name|new_modes
operator|.
name|c_oflag
operator|&
operator|(
name|unsigned
name|long
operator|)
operator|~
name|OPOST
operator|)
condition|)
name|new_modes
operator|.
name|c_oflag
operator|&=
operator|(
name|unsigned
name|long
operator|)
operator|~
name|OPOST
expr_stmt|;
else|#
directive|else
name|new_modes
operator|.
name|sg_flags
operator||=
name|RAW
expr_stmt|;
if|if
condition|(
name|not_a_tty
condition|)
return|return;
endif|#
directive|endif
name|PUT_TTY
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
operator|&
name|new_modes
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|tty_reset
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* reset the tty to the original modes */
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|not_a_tty
condition|)
return|return;
name|PUT_TTY
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
operator|&
name|old_modes
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|tty_init
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* ATT terminal init */
if|#
directive|if
name|defined
argument_list|(
name|F_GETFL
argument_list|)
operator|&&
name|defined
argument_list|(
name|O_NDELAY
argument_list|)
name|int
name|flags
decl_stmt|;
name|flags
operator|=
name|fcntl
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
name|F_GETFL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|nodelay_read
operator|=
name|flags
operator|&
name|O_NDELAY
expr_stmt|;
else|#
directive|else
name|nodelay_read
operator|=
name|FALSE
expr_stmt|;
endif|#
directive|endif
name|not_a_tty
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|GET_TTY
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
operator|&
name|old_modes
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOTTY
condition|)
block|{
name|tty_frame_size
operator|=
literal|20
expr_stmt|;
name|not_a_tty
operator|=
name|TRUE
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|"tcgetattr error: %d\n"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* if TAB3 is set then setterm() wipes out tabs (ht) */
name|new_modes
operator|=
name|old_modes
expr_stmt|;
ifdef|#
directive|ifdef
name|TERMIOS
ifdef|#
directive|ifdef
name|TABDLY
name|new_modes
operator|.
name|c_oflag
operator|&=
operator|~
name|TABDLY
expr_stmt|;
endif|#
directive|endif
comment|/* TABDLY */
endif|#
directive|endif
if|if
condition|(
name|PUT_TTY
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
operator|&
name|new_modes
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"tcsetattr error: %d\n"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|sequent
comment|/* the sequent ATT emulation is broken soooo. */
name|old_modes
operator|.
name|c_cflag
operator|&=
operator|~
operator|(
name|CSIZE
operator||
name|CSTOPB
operator|)
expr_stmt|;
name|old_modes
operator|.
name|c_cflag
operator||=
name|CS7
operator||
name|PARENB
expr_stmt|;
endif|#
directive|endif
name|catchsig
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|TERMIOS
switch|switch
condition|(
name|old_modes
operator|.
name|c_cflag
operator|&
name|CSIZE
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|CS5
argument_list|)
operator|&&
operator|(
name|CS5
operator|!=
literal|0
operator|)
case|case
name|CS5
case|:
name|tty_frame_size
operator|=
literal|10
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|CS6
argument_list|)
operator|&&
operator|(
name|CS6
operator|!=
literal|0
operator|)
case|case
name|CS6
case|:
name|tty_frame_size
operator|=
literal|12
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|CS7
argument_list|)
operator|&&
operator|(
name|CS7
operator|!=
literal|0
operator|)
case|case
name|CS7
case|:
name|tty_frame_size
operator|=
literal|14
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|CS8
argument_list|)
operator|&&
operator|(
name|CS8
operator|!=
literal|0
operator|)
case|case
name|CS8
case|:
name|tty_frame_size
operator|=
literal|16
expr_stmt|;
break|break;
endif|#
directive|endif
block|}
name|tty_frame_size
operator|+=
literal|2
operator|+
operator|(
operator|(
name|old_modes
operator|.
name|c_cflag
operator|&
name|PARENB
operator|)
condition|?
literal|2
else|:
literal|0
operator|)
operator|+
operator|(
operator|(
name|old_modes
operator|.
name|c_cflag
operator|&
name|CSTOPB
operator|)
condition|?
literal|4
else|:
literal|2
operator|)
expr_stmt|;
else|#
directive|else
name|tty_frame_size
operator|=
literal|6
operator|+
operator|(
name|old_modes
operator|.
name|sg_flags
operator|&
name|PASS8
operator|)
condition|?
literal|16
else|:
literal|14
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* **	stty_query(question) ** **	Does the current driver settings have this property? */
end_comment

begin_function
name|int
name|stty_query
parameter_list|(
name|int
name|q
parameter_list|)
block|{
switch|switch
condition|(
name|q
condition|)
block|{
case|case
name|TTY_NOECHO
case|:
return|return
name|TTY_IS_NOECHO
return|;
case|case
name|TTY_OUT_TRANS
case|:
return|return
name|TTY_IS_OUT_TRANS
return|;
case|case
name|TTY_CHAR_MODE
case|:
return|return
name|TTY_IS_CHAR_MODE
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* **	initial_stty_query(question) ** **	Did the initial driver settings have this property? */
end_comment

begin_function
name|int
name|initial_stty_query
parameter_list|(
name|int
name|q
parameter_list|)
block|{
switch|switch
condition|(
name|q
condition|)
block|{
case|case
name|TTY_8_BIT
case|:
return|return
name|TTY_WAS_CS8
return|;
case|case
name|TTY_XON_XOFF
case|:
return|return
name|TTY_WAS_XON_XOFF
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|HAVE_SELECT
operator|&&
name|defined
argument_list|(
name|FD_ZERO
argument_list|)
end_if

begin_function
specifier|static
name|int
name|char_ready
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
name|fd_set
name|ifds
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|ifds
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
operator|&
name|ifds
argument_list|)
expr_stmt|;
name|tv
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
literal|200000
expr_stmt|;
name|n
operator|=
name|select
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
operator|+
literal|1
argument_list|,
operator|&
name|ifds
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|tv
argument_list|)
expr_stmt|;
return|return
operator|(
name|n
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|FIONREAD
end_ifdef

begin_function
name|int
name|char_ready
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* the following loop has to be tuned for each computer */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|1000
condition|;
name|j
operator|++
control|)
block|{
name|ioctl
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
name|FIONREAD
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
return|return
name|i
return|;
block|}
return|return
name|i
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__BEOS__
argument_list|)
end_if

begin_function
name|int
name|char_ready
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|n
init|=
literal|0
decl_stmt|;
name|int
name|howmany
init|=
name|ioctl
argument_list|(
literal|0
argument_list|,
literal|'ichr'
argument_list|,
operator|&
name|n
argument_list|)
decl_stmt|;
return|return
operator|(
name|howmany
operator|>=
literal|0
operator|&&
name|n
operator|>
literal|0
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|char_ready
parameter_list|()
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* **	spin_flush() ** **	Wait for the input stream to stop. **	Throw away all input characters. */
end_comment

begin_function
name|void
name|spin_flush
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|char
name|buf
index|[
literal|64
index|]
decl_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|event_start
argument_list|(
name|TIME_FLUSH
argument_list|)
expr_stmt|;
comment|/* start the timer */
do|do
block|{
if|if
condition|(
name|char_ready
argument_list|()
condition|)
block|{
operator|(
name|void
operator|)
name|read
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
operator|&
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|event_time
argument_list|(
name|TIME_FLUSH
argument_list|)
operator|<
literal|400000
condition|)
do|;
block|}
end_function

begin_comment
comment|/* **	read_key(input-buffer, length-of-buffer) ** **	read one function key from the input stream. **	A null character is converted to 0x80. */
end_comment

begin_function
name|void
name|read_key
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|max
parameter_list|)
block|{
name|int
name|got
decl_stmt|,
name|ask
decl_stmt|,
name|i
decl_stmt|,
name|l
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
operator|*
name|buf
operator|=
literal|'\0'
expr_stmt|;
name|s
operator|=
name|buf
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
comment|/* ATT unix may return 0 or 1, Berkeley Unix should be 1 */
while|while
condition|(
name|read
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
name|s
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
condition|)
empty_stmt|;
operator|++
name|s
expr_stmt|;
operator|--
name|max
expr_stmt|;
while|while
condition|(
name|max
operator|>
literal|0
operator|&&
operator|(
name|ask
operator|=
name|char_ready
argument_list|()
operator|)
condition|)
block|{
if|if
condition|(
name|ask
operator|>
name|max
condition|)
block|{
name|ask
operator|=
name|max
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|got
operator|=
name|read
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
name|s
argument_list|,
operator|(
name|unsigned
operator|)
name|ask
argument_list|)
operator|)
condition|)
block|{
name|s
operator|+=
name|got
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
name|max
operator|-=
name|got
expr_stmt|;
block|}
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
name|l
operator|=
name|s
operator|-
name|buf
expr_stmt|;
for|for
control|(
name|s
operator|=
name|buf
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|l
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|s
operator|&
literal|0x7f
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* convert nulls to 0x80 */
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s
operator|=
literal|128
expr_stmt|;
block|}
else|else
block|{
comment|/* strip high order bits (if any) */
operator|*
name|s
operator|&=
name|char_mask
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|ignoresig
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* ignore signals */
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*     onintr( )    is the interrupt handling routine onintr turns off interrupts while doing     clean-up    onintr always exits fatally  */
end_comment

begin_function
specifier|static
name|RETSIGTYPE
name|onintr
parameter_list|(
name|int
name|sig
name|GCC_UNUSED
parameter_list|)
block|{
name|ignoresig
argument_list|()
expr_stmt|;
name|tty_reset
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*     catchsig( )    set up to field interrupts (via function onintr( )) so that if interrupted     we can restore the correct terminal modes    catchsig simply returns  */
end_comment

begin_function
name|void
name|catchsig
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|(
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
operator|)
operator|==
name|SIG_DFL
condition|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|onintr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
operator|)
operator|==
name|SIG_DFL
condition|)
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|onintr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
operator|)
operator|==
name|SIG_DFL
condition|)
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|onintr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|SIG_IGN
argument_list|)
operator|)
operator|==
name|SIG_DFL
condition|)
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|onintr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **	alarm_event(sig) ** **	Come here for an alarm event */
end_comment

begin_function
specifier|static
name|void
name|alarm_event
parameter_list|(
name|int
name|sig
name|GCC_UNUSED
parameter_list|)
block|{
name|no_alarm_event
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **	set_alarm_clock(seconds) ** **	Set the alarm clock to fire in<seconds> */
end_comment

begin_function
name|void
name|set_alarm_clock
parameter_list|(
name|int
name|seconds
parameter_list|)
block|{
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|alarm_event
argument_list|)
expr_stmt|;
name|no_alarm_event
operator|=
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|alarm
argument_list|(
operator|(
name|unsigned
operator|)
name|seconds
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

