begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ** Copyright (C) 1991, 1997 Free Software Foundation, Inc. **  ** This file is part of TACK. **  ** TACK is free software; you can redistribute it and/or modify ** it under the terms of the GNU General Public License as published by ** the Free Software Foundation; either version 2, or (at your option) ** any later version. **  ** TACK is distributed in the hope that it will be useful, ** but WITHOUT ANY WARRANTY; without even the implied warranty of ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ** GNU General Public License for more details. **  ** You should have received a copy of the GNU General Public License ** along with TACK; see the file COPYING.  If not, write to ** the Free Software Foundation, Inc., 59 Temple Place - Suite 330, ** Boston, MA 02111-1307, USA. */
end_comment

begin_include
include|#
directive|include
file|<tack.h>
end_include

begin_if
if|#
directive|if
name|HAVE_SYS_TIME_H
end_if

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|MODULE_ID
argument_list|(
literal|"$Id: control.c,v 1.3 2000/03/04 21:10:59 tom Exp $"
argument_list|)
end_macro

begin_comment
comment|/* terminfo test program control subroutines */
end_comment

begin_if
if|#
directive|if
name|HAVE_GETTIMEOFDAY
end_if

begin_define
define|#
directive|define
name|MY_TIMER
value|struct timeval
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|MY_TIMER
value|time_t
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* globals */
end_comment

begin_decl_stmt
name|int
name|test_complete
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* counts number of tests completed */
end_comment

begin_decl_stmt
name|char
name|txt_longer_test_time
index|[
literal|80
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* +) use longer time */
end_comment

begin_decl_stmt
name|char
name|txt_shorter_test_time
index|[
literal|80
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -) use shorter time */
end_comment

begin_decl_stmt
name|int
name|pad_test_duration
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of seconds for a pad test */
end_comment

begin_decl_stmt
name|int
name|auto_pad_mode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* run the time tests */
end_comment

begin_decl_stmt
name|int
name|no_alarm_event
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* TRUE if the alarm has not gone off yet */
end_comment

begin_decl_stmt
name|int
name|usec_run_time
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* length of last test in microseconds */
end_comment

begin_decl_stmt
name|MY_TIMER
name|stop_watch
index|[
name|MAX_TIMERS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Hold the start timers */
end_comment

begin_decl_stmt
name|char
name|txt_longer_augment
index|[
literal|80
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*>) use bigger augment */
end_comment

begin_decl_stmt
name|char
name|txt_shorter_augment
index|[
literal|80
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*<) use smaller augment */
end_comment

begin_comment
comment|/* caps under test data base */
end_comment

begin_decl_stmt
name|int
name|tt_delay_max
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* max number of milliseconds we can delay */
end_comment

begin_decl_stmt
name|int
name|tt_delay_used
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of milliseconds consumed in delay */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|tt_cap
index|[
name|TT_MAX
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* value of string */
end_comment

begin_decl_stmt
name|int
name|tt_affected
index|[
name|TT_MAX
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* lines or columns effected (repetition factor) */
end_comment

begin_decl_stmt
name|int
name|tt_count
index|[
name|TT_MAX
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of times sent */
end_comment

begin_decl_stmt
name|int
name|tt_delay
index|[
name|TT_MAX
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of milliseconds delay */
end_comment

begin_decl_stmt
name|int
name|ttp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of entries used */
end_comment

begin_comment
comment|/* Saved value of the above data base */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|tx_cap
index|[
name|TT_MAX
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* value of string */
end_comment

begin_decl_stmt
name|int
name|tx_affected
index|[
name|TT_MAX
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* lines or columns effected (repetition factor) */
end_comment

begin_decl_stmt
name|int
name|tx_count
index|[
name|TT_MAX
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of times sent */
end_comment

begin_decl_stmt
name|int
name|tx_index
index|[
name|TT_MAX
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* String index */
end_comment

begin_decl_stmt
name|int
name|tx_delay
index|[
name|TT_MAX
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of milliseconds delay */
end_comment

begin_decl_stmt
name|int
name|txp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of entries used */
end_comment

begin_decl_stmt
name|int
name|tx_characters
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* printing characters sent by test */
end_comment

begin_decl_stmt
name|int
name|tx_cps
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* characters per second */
end_comment

begin_decl_stmt
name|struct
name|test_list
modifier|*
name|tx_source
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The test that generated this data */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|test_menu
name|pad_menu
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pad menu structure */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|test_list
name|pad_test_list
index|[]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|RESULT_BLOCK
value|1024
end_define

begin_decl_stmt
specifier|static
name|int
name|blocks
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of result blocks available */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|test_results
modifier|*
name|results
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pointer to next available */
end_comment

begin_decl_stmt
name|struct
name|test_results
modifier|*
name|pads
index|[
name|STRCOUNT
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* save pad results here */
end_comment

begin_comment
comment|/* **	event_start(number) ** **	Begin the stopwatch at the current time-of-day. */
end_comment

begin_function
name|void
name|event_start
parameter_list|(
name|int
name|n
parameter_list|)
block|{
if|#
directive|if
name|HAVE_GETTIMEOFDAY
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|stop_watch
index|[
name|n
index|]
argument_list|,
operator|(
expr|struct
name|timezone
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|stop_watch
index|[
name|n
index|]
operator|=
name|time
argument_list|(
operator|(
name|time_t
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* **	event_time(number) ** **	Return the number of milliseconds since this stop watch began. */
end_comment

begin_function
name|long
name|event_time
parameter_list|(
name|int
name|n
parameter_list|)
block|{
if|#
directive|if
name|HAVE_GETTIMEOFDAY
name|MY_TIMER
name|current_time
decl_stmt|;
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|current_time
argument_list|,
operator|(
expr|struct
name|timezone
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|current_time
operator|.
name|tv_sec
operator|-
name|stop_watch
index|[
name|n
index|]
operator|.
name|tv_sec
operator|)
operator|*
literal|1000000
operator|)
operator|+
name|current_time
operator|.
name|tv_usec
operator|-
name|stop_watch
index|[
name|n
index|]
operator|.
name|tv_usec
return|;
else|#
directive|else
return|return
operator|(
name|time
argument_list|(
operator|(
name|time_t
operator|*
operator|)
literal|0
argument_list|)
operator|-
name|stop_watch
index|[
name|n
index|]
operator|)
operator|*
literal|1000
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*****************************************************************************  *  * Execution control for string capability tests  *  *****************************************************************************/
end_comment

begin_comment
comment|/* **	get_next_block() ** **	Get a results block for pad test data. */
end_comment

begin_function
specifier|static
name|struct
name|test_results
modifier|*
name|get_next_block
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|blocks
operator|<=
literal|0
condition|)
block|{
name|results
operator|=
operator|(
expr|struct
name|test_results
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|test_results
argument_list|)
operator|*
name|RESULT_BLOCK
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|results
condition|)
block|{
name|ptextln
argument_list|(
literal|"Malloc failed"
argument_list|)
expr_stmt|;
return|return
operator|(
expr|struct
name|test_results
operator|*
operator|)
literal|0
return|;
block|}
name|blocks
operator|=
name|RESULT_BLOCK
expr_stmt|;
block|}
name|blocks
operator|--
expr_stmt|;
return|return
name|results
operator|++
return|;
block|}
end_function

begin_comment
comment|/* **	set_augment_txt() ** **	Initialize the augment menu selections */
end_comment

begin_function
name|void
name|set_augment_txt
parameter_list|(
name|void
parameter_list|)
block|{
name|sprintf
argument_list|(
name|txt_longer_augment
argument_list|,
literal|">) Change lines/characters effected to %d"
argument_list|,
name|augment
operator|<<
literal|1
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|txt_shorter_augment
argument_list|,
literal|"<) Change lines/characters effected to %d"
argument_list|,
name|augment
operator|>>
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|control_init
parameter_list|(
name|void
parameter_list|)
block|{
name|sprintf
argument_list|(
name|txt_longer_test_time
argument_list|,
literal|"+) Change test time to %d seconds"
argument_list|,
name|pad_test_duration
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|txt_shorter_test_time
argument_list|,
literal|"-) Change test time to %d seconds"
argument_list|,
name|pad_test_duration
operator|-
literal|1
argument_list|)
expr_stmt|;
name|set_augment_txt
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **	msec_cost(cap, affected-count) ** **	Return the number of milliseconds delay needed by the cap. */
end_comment

begin_function
name|int
name|msec_cost
parameter_list|(
specifier|const
name|char
modifier|*
specifier|const
name|cap
parameter_list|,
name|int
name|affcnt
parameter_list|)
block|{
name|int
name|dec
decl_stmt|,
name|value
decl_stmt|,
name|total
decl_stmt|,
name|star
decl_stmt|,
name|ch
decl_stmt|;
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
operator|!
name|cap
condition|)
block|{
return|return
literal|0
return|;
block|}
name|total
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|cap
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'$'
operator|&&
name|cp
index|[
literal|1
index|]
operator|==
literal|'<'
condition|)
block|{
name|star
operator|=
literal|1
expr_stmt|;
name|value
operator|=
name|dec
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|cp
operator|+=
literal|2
init|;
operator|(
name|ch
operator|=
operator|*
name|cp
operator|)
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
name|ch
operator|>=
literal|'0'
operator|&&
name|ch
operator|<=
literal|'9'
condition|)
block|{
name|value
operator|=
name|value
operator|*
literal|10
operator|+
operator|(
name|ch
operator|-
literal|'0'
operator|)
expr_stmt|;
name|dec
operator|*=
literal|10
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'.'
condition|)
block|{
name|dec
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'*'
condition|)
block|{
name|star
operator|=
name|affcnt
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'>'
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|dec
operator|>
literal|1
condition|)
block|{
name|total
operator|+=
operator|(
name|value
operator|*
name|star
operator|)
operator|/
name|dec
expr_stmt|;
block|}
else|else
block|{
name|total
operator|+=
operator|(
name|value
operator|*
name|star
operator|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|total
return|;
block|}
end_function

begin_comment
comment|/* **	liberated(cap) ** **	Return the cap without padding */
end_comment

begin_function
name|char
modifier|*
name|liberated
parameter_list|(
name|char
modifier|*
name|cap
parameter_list|)
block|{
specifier|static
name|char
name|cb
index|[
literal|1024
index|]
decl_stmt|;
name|char
modifier|*
name|ts
decl_stmt|,
modifier|*
name|ls
decl_stmt|;
name|cb
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|ls
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|cap
condition|)
block|{
for|for
control|(
name|ts
operator|=
name|cb
init|;
operator|(
operator|*
name|ts
operator|=
operator|*
name|cap
operator|)
condition|;
operator|++
name|cap
control|)
block|{
if|if
condition|(
operator|*
name|cap
operator|==
literal|'$'
operator|&&
name|cap
index|[
literal|1
index|]
operator|==
literal|'<'
condition|)
block|{
name|ls
operator|=
name|ts
expr_stmt|;
block|}
operator|++
name|ts
expr_stmt|;
if|if
condition|(
operator|*
name|cap
operator|==
literal|'>'
condition|)
block|{
if|if
condition|(
name|ls
condition|)
block|{
name|ts
operator|=
name|ls
expr_stmt|;
name|ls
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|cb
return|;
block|}
end_function

begin_comment
comment|/* **	page_loop() ** **	send CR/LF or go home and bump letter */
end_comment

begin_function
name|void
name|page_loop
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|line_count
operator|+
literal|2
operator|>=
name|lines
condition|)
block|{
name|NEXT_LETTER
expr_stmt|;
name|go_home
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|put_crlf
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* **	skip_pad_test(test-list-entry, state, ch, text) ** **	Print the start test line.  Handle start up commands. **	Return TRUE if a return is requested. */
end_comment

begin_function
name|int
name|skip_pad_test
parameter_list|(
name|struct
name|test_list
modifier|*
name|test
parameter_list|,
name|int
modifier|*
name|state
parameter_list|,
name|int
modifier|*
name|ch
parameter_list|,
specifier|const
name|char
modifier|*
name|text
parameter_list|)
block|{
name|char
name|rep_text
index|[
literal|16
index|]
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|text
condition|)
block|{
name|ptext
argument_list|(
name|text
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|test
operator|->
name|flags
operator|&
name|MENU_LC_MASK
operator|)
condition|)
block|{
name|sprintf
argument_list|(
name|rep_text
argument_list|,
literal|" *%d"
argument_list|,
name|augment
argument_list|)
expr_stmt|;
name|ptext
argument_list|(
name|rep_text
argument_list|)
expr_stmt|;
block|}
name|ptext
argument_list|(
literal|" [n]> "
argument_list|)
expr_stmt|;
operator|*
name|ch
operator|=
name|wait_here
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|ch
operator|==
literal|'s'
condition|)
block|{
comment|/* Skip is converted to next */
operator|*
name|ch
operator|=
literal|'n'
expr_stmt|;
return|return
name|TRUE
return|;
block|}
if|if
condition|(
operator|*
name|ch
operator|==
literal|'q'
condition|)
block|{
comment|/* Quit is converted to help */
operator|*
name|ch
operator|=
literal|'?'
expr_stmt|;
return|return
name|TRUE
return|;
block|}
if|if
condition|(
operator|*
name|ch
operator|==
literal|'\r'
operator|||
operator|*
name|ch
operator|==
literal|'\n'
operator|||
operator|*
name|ch
operator|==
literal|'n'
operator|||
operator|*
name|ch
operator|==
literal|'r'
condition|)
block|{
comment|/* this is the only response that allows the test to run */
operator|*
name|ch
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|subtest_menu
argument_list|(
name|pad_test_list
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
condition|)
block|{
continue|continue;
block|}
return|return
operator|(
operator|*
name|ch
operator|!=
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* **	pad_done_message(test_list) ** **	Print the Done message and request input. */
end_comment

begin_function
name|void
name|pad_done_message
parameter_list|(
name|struct
name|test_list
modifier|*
name|test
parameter_list|,
name|int
modifier|*
name|state
parameter_list|,
name|int
modifier|*
name|ch
parameter_list|)
block|{
name|int
name|default_action
init|=
literal|0
decl_stmt|;
name|char
name|done_message
index|[
literal|128
index|]
decl_stmt|;
name|char
name|rep_text
index|[
literal|16
index|]
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|test
operator|->
name|flags
operator|&
name|MENU_LC_MASK
operator|)
condition|)
block|{
name|sprintf
argument_list|(
name|rep_text
argument_list|,
literal|"*%d"
argument_list|,
name|augment
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rep_text
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|test
operator|->
name|caps_done
condition|)
block|{
name|sprintf
argument_list|(
name|done_message
argument_list|,
literal|"(%s)%s Done "
argument_list|,
name|test
operator|->
name|caps_done
argument_list|,
name|rep_text
argument_list|)
expr_stmt|;
name|ptext
argument_list|(
name|done_message
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|rep_text
index|[
literal|0
index|]
condition|)
block|{
name|ptext
argument_list|(
name|rep_text
argument_list|)
expr_stmt|;
name|ptext
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
name|ptext
argument_list|(
literal|"Done "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|debug_level
operator|&
literal|2
condition|)
block|{
name|dump_test_stats
argument_list|(
name|test
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|ch
operator|=
name|wait_here
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|ch
operator|==
literal|'\r'
operator|||
operator|*
name|ch
operator|==
literal|'\n'
condition|)
block|{
operator|*
name|ch
operator|=
name|default_action
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|*
name|ch
operator|==
literal|'s'
operator|||
operator|*
name|ch
operator|==
literal|'n'
condition|)
block|{
operator|*
name|ch
operator|=
literal|0
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|strchr
argument_list|(
name|pad_repeat_test
argument_list|,
operator|*
name|ch
argument_list|)
condition|)
block|{
comment|/* default action is now repeat */
name|default_action
operator|=
literal|'r'
expr_stmt|;
block|}
if|if
condition|(
name|subtest_menu
argument_list|(
name|pad_test_list
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
condition|)
block|{
continue|continue;
block|}
return|return;
block|}
block|}
end_function

begin_comment
comment|/* **	sliding_scale(dividend, factor, divisor) ** **	Return (dividend * factor) / divisor */
end_comment

begin_function
name|int
name|sliding_scale
parameter_list|(
name|int
name|dividend
parameter_list|,
name|int
name|factor
parameter_list|,
name|int
name|divisor
parameter_list|)
block|{
name|double
name|d
init|=
name|dividend
decl_stmt|;
if|if
condition|(
name|divisor
condition|)
block|{
name|d
operator|=
operator|(
name|d
operator|*
operator|(
name|double
operator|)
name|factor
operator|)
operator|/
operator|(
name|double
operator|)
name|divisor
expr_stmt|;
return|return
call|(
name|int
call|)
argument_list|(
name|d
operator|+
literal|0.5
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* **	pad_test_startup() ** **	Do the stuff needed to begin a test. */
end_comment

begin_function
name|void
name|pad_test_startup
parameter_list|(
name|int
name|do_clear
parameter_list|)
block|{
if|if
condition|(
name|do_clear
condition|)
block|{
name|put_clear
argument_list|()
expr_stmt|;
block|}
name|repeats
operator|=
name|augment
expr_stmt|;
name|raw_characters_sent
operator|=
literal|0
expr_stmt|;
name|test_complete
operator|=
name|ttp
operator|=
name|char_count
operator|=
name|tt_delay_used
operator|=
literal|0
expr_stmt|;
name|letter
operator|=
name|letters
index|[
name|letter_number
operator|=
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|pad_test_duration
operator|<=
literal|0
condition|)
block|{
name|pad_test_duration
operator|=
literal|1
expr_stmt|;
block|}
name|tt_delay_max
operator|=
name|pad_test_duration
operator|*
literal|1000
expr_stmt|;
name|set_alarm_clock
argument_list|(
name|pad_test_duration
argument_list|)
expr_stmt|;
name|event_start
argument_list|(
name|TIME_TEST
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **	still_testing() ** **	This function is called to see if the test loop should be terminated. */
end_comment

begin_function
name|int
name|still_testing
parameter_list|(
name|void
parameter_list|)
block|{
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|test_complete
operator|++
expr_stmt|;
return|return
name|EXIT_CONDITION
return|;
block|}
end_function

begin_comment
comment|/* **	pad_test_shutdown() ** **	Do the stuff needed to end a test. */
end_comment

begin_function
name|void
name|pad_test_shutdown
parameter_list|(
name|struct
name|test_list
modifier|*
name|t
parameter_list|,
name|int
name|crlf
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|counts
decl_stmt|;
comment|/* total counts */
name|int
name|ss
decl_stmt|;
comment|/* Save string index */
name|int
name|cpo
decl_stmt|;
comment|/* characters per operation */
name|int
name|delta
decl_stmt|;
comment|/* difference in characters */
name|int
name|bogus
decl_stmt|;
comment|/* Time is inaccurate */
name|struct
name|test_results
modifier|*
name|r
decl_stmt|;
comment|/* Results of current test */
name|int
name|ss_index
index|[
name|TT_MAX
index|]
decl_stmt|;
comment|/* String index */
if|if
condition|(
name|tty_can_sync
operator|==
name|SYNC_TESTED
condition|)
block|{
name|bogus
operator|=
name|tty_sync_error
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|bogus
operator|=
literal|1
expr_stmt|;
block|}
name|usec_run_time
operator|=
name|event_time
argument_list|(
name|TIME_TEST
argument_list|)
expr_stmt|;
name|tx_source
operator|=
name|t
expr_stmt|;
name|tx_characters
operator|=
name|raw_characters_sent
expr_stmt|;
name|tx_cps
operator|=
name|sliding_scale
argument_list|(
name|tx_characters
argument_list|,
literal|1000000
argument_list|,
name|usec_run_time
argument_list|)
expr_stmt|;
comment|/* save the data base */
for|for
control|(
name|txp
operator|=
name|ss
operator|=
name|counts
operator|=
literal|0
init|;
name|txp
operator|<
name|ttp
condition|;
name|txp
operator|++
control|)
block|{
name|tx_cap
index|[
name|txp
index|]
operator|=
name|tt_cap
index|[
name|txp
index|]
expr_stmt|;
name|tx_count
index|[
name|txp
index|]
operator|=
name|tt_count
index|[
name|txp
index|]
expr_stmt|;
name|tx_delay
index|[
name|txp
index|]
operator|=
name|tt_delay
index|[
name|txp
index|]
expr_stmt|;
name|tx_affected
index|[
name|txp
index|]
operator|=
name|tt_affected
index|[
name|txp
index|]
expr_stmt|;
name|tx_index
index|[
name|txp
index|]
operator|=
name|get_string_cap_byvalue
argument_list|(
name|tt_cap
index|[
name|txp
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|tx_index
index|[
name|txp
index|]
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|cap_match
argument_list|(
name|t
operator|->
name|caps_done
argument_list|,
name|strnames
index|[
name|tx_index
index|[
name|txp
index|]
index|]
argument_list|)
condition|)
block|{
name|ss_index
index|[
name|ss
operator|++
index|]
operator|=
name|txp
expr_stmt|;
name|counts
operator|+=
name|tx_count
index|[
name|txp
index|]
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|crlf
condition|)
block|{
name|put_crlf
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|counts
operator|==
literal|0
operator|||
name|tty_cps
operator|==
literal|0
operator|||
name|bogus
condition|)
block|{
comment|/* nothing to do */
return|return;
block|}
comment|/* calculate the suggested pad times */
name|delta
operator|=
name|usec_run_time
operator|-
name|sliding_scale
argument_list|(
name|tx_characters
argument_list|,
literal|1000000
argument_list|,
name|tty_cps
argument_list|)
expr_stmt|;
if|if
condition|(
name|delta
operator|<
literal|0
condition|)
block|{
comment|/* probably should bump tx_characters */
name|delta
operator|=
literal|0
expr_stmt|;
block|}
name|cpo
operator|=
name|delta
operator|/
name|counts
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ss
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|r
operator|=
name|get_next_block
argument_list|()
operator|)
condition|)
block|{
return|return;
block|}
name|r
operator|->
name|next
operator|=
name|pads
index|[
name|tx_index
index|[
name|ss_index
index|[
name|i
index|]
index|]
index|]
expr_stmt|;
name|pads
index|[
name|tx_index
index|[
name|ss_index
index|[
name|i
index|]
index|]
index|]
operator|=
name|r
expr_stmt|;
name|r
operator|->
name|test
operator|=
name|t
expr_stmt|;
name|r
operator|->
name|reps
operator|=
name|tx_affected
index|[
name|ss_index
index|[
name|i
index|]
index|]
expr_stmt|;
name|r
operator|->
name|delay
operator|=
name|cpo
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* **	show_cap_results(index) ** **	Display the previous results */
end_comment

begin_function
specifier|static
name|void
name|show_cap_results
parameter_list|(
name|int
name|x
parameter_list|)
block|{
name|struct
name|test_results
modifier|*
name|r
decl_stmt|;
comment|/* a result */
name|int
name|delay
decl_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|pads
index|[
name|x
index|]
operator|)
condition|)
block|{
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"(%s)"
argument_list|,
name|strnames
index|[
name|x
index|]
argument_list|)
expr_stmt|;
name|ptext
argument_list|(
name|temp
argument_list|)
expr_stmt|;
while|while
condition|(
name|r
condition|)
block|{
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"$<%d>"
argument_list|,
name|r
operator|->
name|delay
operator|/
literal|1000
argument_list|)
expr_stmt|;
name|put_columns
argument_list|(
name|temp
argument_list|,
name|strlen
argument_list|(
name|temp
argument_list|)
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|r
operator|=
name|r
operator|->
name|next
expr_stmt|;
block|}
name|r
operator|=
name|pads
index|[
name|x
index|]
expr_stmt|;
while|while
condition|(
name|r
condition|)
block|{
if|if
condition|(
name|r
operator|->
name|reps
operator|>
literal|1
condition|)
block|{
name|delay
operator|=
name|r
operator|->
name|delay
operator|/
operator|(
name|r
operator|->
name|reps
operator|*
literal|100
operator|)
expr_stmt|;
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"$<%d.%d*>"
argument_list|,
name|delay
operator|/
literal|10
argument_list|,
name|delay
operator|%
literal|10
argument_list|)
expr_stmt|;
name|put_columns
argument_list|(
name|temp
argument_list|,
name|strlen
argument_list|(
name|temp
argument_list|)
argument_list|,
literal|10
argument_list|)
expr_stmt|;
block|}
name|r
operator|=
name|r
operator|->
name|next
expr_stmt|;
block|}
name|put_crlf
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* **	dump_test_stats(test_list, status, ch) ** **	Dump the statistics about the last test */
end_comment

begin_function
name|void
name|dump_test_stats
parameter_list|(
name|struct
name|test_list
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|state
parameter_list|,
name|int
modifier|*
name|ch
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|char
name|tbuf
index|[
literal|32
index|]
decl_stmt|;
name|int
name|x
index|[
literal|32
index|]
decl_stmt|;
name|put_crlf
argument_list|()
expr_stmt|;
if|if
condition|(
name|tx_source
operator|&&
name|tx_source
operator|->
name|caps_done
condition|)
block|{
name|cap_index
argument_list|(
name|tx_source
operator|->
name|caps_done
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
index|[
literal|0
index|]
operator|>=
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"Caps summary for (%s)"
argument_list|,
name|tx_source
operator|->
name|caps_done
argument_list|)
expr_stmt|;
name|ptextln
argument_list|(
name|temp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|x
index|[
name|i
index|]
operator|>=
literal|0
condition|;
name|i
operator|++
control|)
block|{
name|show_cap_results
argument_list|(
name|x
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|put_crlf
argument_list|()
expr_stmt|;
block|}
block|}
name|sprintf
argument_list|(
name|tbuf
argument_list|,
literal|"%011u"
argument_list|,
name|usec_run_time
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"Test time: %d.%s, characters per second %d, characters %d"
argument_list|,
name|usec_run_time
operator|/
literal|1000000
argument_list|,
operator|&
name|tbuf
index|[
literal|5
index|]
argument_list|,
name|tx_cps
argument_list|,
name|tx_characters
argument_list|)
expr_stmt|;
name|ptextln
argument_list|(
name|temp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|txp
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|j
operator|=
name|get_string_cap_byvalue
argument_list|(
name|tx_cap
index|[
name|i
index|]
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|tbuf
argument_list|,
literal|"(%s)"
argument_list|,
name|strnames
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strcpy
argument_list|(
name|tbuf
argument_list|,
literal|"(?)"
argument_list|)
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"%8d  %3d  $<%3d>  %8s %s"
argument_list|,
name|tx_count
index|[
name|i
index|]
argument_list|,
name|tx_affected
index|[
name|i
index|]
argument_list|,
name|tx_delay
index|[
name|i
index|]
argument_list|,
name|tbuf
argument_list|,
name|expand
argument_list|(
name|tx_cap
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|putln
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
name|generic_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **	longer_test_time(test_list, status, ch) ** **	Extend the number of seconds for each test. */
end_comment

begin_function
name|void
name|longer_test_time
parameter_list|(
name|struct
name|test_list
modifier|*
name|t
name|GCC_UNUSED
parameter_list|,
name|int
modifier|*
name|state
name|GCC_UNUSED
parameter_list|,
name|int
modifier|*
name|ch
parameter_list|)
block|{
name|pad_test_duration
operator|+=
literal|1
expr_stmt|;
name|sprintf
argument_list|(
name|txt_longer_test_time
argument_list|,
literal|"+) Change test time to %d seconds"
argument_list|,
name|pad_test_duration
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|txt_shorter_test_time
argument_list|,
literal|"-) Change test time to %d seconds"
argument_list|,
name|pad_test_duration
operator|-
literal|1
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"Tests will run for %d seconds"
argument_list|,
name|pad_test_duration
argument_list|)
expr_stmt|;
name|ptext
argument_list|(
name|temp
argument_list|)
expr_stmt|;
operator|*
name|ch
operator|=
name|REQUEST_PROMPT
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **	shorter_test_time(test_list, status, ch) ** **	Shorten the number of seconds for each test. */
end_comment

begin_function
name|void
name|shorter_test_time
parameter_list|(
name|struct
name|test_list
modifier|*
name|t
name|GCC_UNUSED
parameter_list|,
name|int
modifier|*
name|state
name|GCC_UNUSED
parameter_list|,
name|int
modifier|*
name|ch
parameter_list|)
block|{
if|if
condition|(
name|pad_test_duration
operator|>
literal|1
condition|)
block|{
name|pad_test_duration
operator|-=
literal|1
expr_stmt|;
name|sprintf
argument_list|(
name|txt_longer_test_time
argument_list|,
literal|"+) Change test time to %d seconds"
argument_list|,
name|pad_test_duration
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|txt_shorter_test_time
argument_list|,
literal|"-) Change test time to %d seconds"
argument_list|,
name|pad_test_duration
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"Tests will run for %d second%s"
argument_list|,
name|pad_test_duration
argument_list|,
name|pad_test_duration
operator|>
literal|1
condition|?
literal|"s"
else|:
literal|""
argument_list|)
expr_stmt|;
name|ptext
argument_list|(
name|temp
argument_list|)
expr_stmt|;
operator|*
name|ch
operator|=
name|REQUEST_PROMPT
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **	longer_augment(test_list, status, ch) ** **	Lengthen the number of lines/characters effected */
end_comment

begin_function
name|void
name|longer_augment
parameter_list|(
name|struct
name|test_list
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|state
name|GCC_UNUSED
parameter_list|,
name|int
modifier|*
name|ch
parameter_list|)
block|{
name|augment
operator|<<=
literal|1
expr_stmt|;
name|set_augment_txt
argument_list|()
expr_stmt|;
if|if
condition|(
name|augment_test
condition|)
block|{
name|t
operator|=
name|augment_test
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"The pad tests will effect %d %s."
argument_list|,
name|augment
argument_list|,
operator|(
operator|(
name|t
operator|->
name|flags
operator|&
name|MENU_LC_MASK
operator|)
operator|==
name|MENU_lines
operator|)
condition|?
literal|"lines"
else|:
literal|"characters"
argument_list|)
expr_stmt|;
name|ptextln
argument_list|(
name|temp
argument_list|)
expr_stmt|;
operator|*
name|ch
operator|=
name|REQUEST_PROMPT
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **	shorter_augment(test_list, status, ch) ** **	Shorten the number of lines/characters effected */
end_comment

begin_function
name|void
name|shorter_augment
parameter_list|(
name|struct
name|test_list
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|state
name|GCC_UNUSED
parameter_list|,
name|int
modifier|*
name|ch
parameter_list|)
block|{
if|if
condition|(
name|augment
operator|>
literal|1
condition|)
block|{
comment|/* don't let the augment go to zero */
name|augment
operator|>>=
literal|1
expr_stmt|;
block|}
name|set_augment_txt
argument_list|()
expr_stmt|;
if|if
condition|(
name|augment_test
condition|)
block|{
name|t
operator|=
name|augment_test
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"The pad tests will effect %d %s."
argument_list|,
name|augment
argument_list|,
operator|(
operator|(
name|t
operator|->
name|flags
operator|&
name|MENU_LC_MASK
operator|)
operator|==
name|MENU_lines
operator|)
condition|?
literal|"lines"
else|:
literal|"characters"
argument_list|)
expr_stmt|;
name|ptextln
argument_list|(
name|temp
argument_list|)
expr_stmt|;
operator|*
name|ch
operator|=
name|REQUEST_PROMPT
expr_stmt|;
block|}
end_function

end_unit

