begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ** Copyright (C) 1991, 1997 Free Software Foundation, Inc. **  ** This file is part of TACK. **  ** TACK is free software; you can redistribute it and/or modify ** it under the terms of the GNU General Public License as published by ** the Free Software Foundation; either version 2, or (at your option) ** any later version. **  ** TACK is distributed in the hope that it will be useful, ** but WITHOUT ANY WARRANTY; without even the implied warranty of ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ** GNU General Public License for more details. **  ** You should have received a copy of the GNU General Public License ** along with TACK; see the file COPYING.  If not, write to ** the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, ** Boston, MA 02110-1301, USA */
end_comment

begin_include
include|#
directive|include
file|<tack.h>
end_include

begin_macro
name|MODULE_ID
argument_list|(
literal|"$Id: modes.c,v 1.3 2006/11/26 00:16:21 tom Exp $"
argument_list|)
end_macro

begin_comment
comment|/*  * Tests boolean flags and terminal modes.  */
end_comment

begin_function_decl
specifier|static
name|void
name|subtest_os
parameter_list|(
name|struct
name|test_list
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|subtest_rmam
parameter_list|(
name|struct
name|test_list
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|subtest_smam
parameter_list|(
name|struct
name|test_list
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|subtest_am
parameter_list|(
name|struct
name|test_list
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|subtest_ul
parameter_list|(
name|struct
name|test_list
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|subtest_uc
parameter_list|(
name|struct
name|test_list
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|subtest_bw
parameter_list|(
name|struct
name|test_list
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|subtest_xenl
parameter_list|(
name|struct
name|test_list
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|subtest_eo
parameter_list|(
name|struct
name|test_list
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|subtest_xmc
parameter_list|(
name|struct
name|test_list
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|subtest_xhp
parameter_list|(
name|struct
name|test_list
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|subtest_mir
parameter_list|(
name|struct
name|test_list
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|subtest_msgr
parameter_list|(
name|struct
name|test_list
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|subtest_tbc
parameter_list|(
name|struct
name|test_list
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|subtest_xt
parameter_list|(
name|struct
name|test_list
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|subtest_hts
parameter_list|(
name|struct
name|test_list
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|subtest_cbt
parameter_list|(
name|struct
name|test_list
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|subtest_in
parameter_list|(
name|struct
name|test_list
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|subtest_dadb
parameter_list|(
name|struct
name|test_list
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|test_list
name|mode_test_list
index|[]
init|=
block|{
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|"e) edit terminfo"
block|,
literal|0
block|,
operator|&
name|edit_menu
block|}
block|,
block|{
name|MENU_NEXT
block|,
literal|3
block|,
literal|"os"
block|,
literal|0
block|,
literal|0
block|,
name|subtest_os
block|,
literal|0
block|}
block|,
block|{
name|MENU_NEXT
block|,
literal|1
block|,
literal|"rmam"
block|,
literal|0
block|,
literal|0
block|,
name|subtest_rmam
block|,
literal|0
block|}
block|,
block|{
name|MENU_NEXT
block|,
literal|1
block|,
literal|"smam"
block|,
literal|0
block|,
literal|0
block|,
name|subtest_smam
block|,
literal|0
block|}
block|,
block|{
name|MENU_NEXT
block|,
literal|1
block|,
literal|"am"
block|,
literal|0
block|,
literal|0
block|,
name|subtest_am
block|,
literal|0
block|}
block|,
block|{
name|MENU_NEXT
block|,
literal|3
block|,
literal|"ul"
block|,
literal|0
block|,
literal|0
block|,
name|subtest_ul
block|,
literal|0
block|}
block|,
block|{
name|MENU_NEXT
block|,
literal|3
block|,
literal|"uc"
block|,
literal|0
block|,
literal|0
block|,
name|subtest_uc
block|,
literal|0
block|}
block|,
block|{
name|MENU_NEXT
block|,
literal|3
block|,
literal|"bw"
block|,
literal|0
block|,
literal|0
block|,
name|subtest_bw
block|,
literal|0
block|}
block|,
block|{
name|MENU_NEXT
block|,
literal|4
block|,
literal|"xenl"
block|,
literal|0
block|,
literal|0
block|,
name|subtest_xenl
block|,
literal|0
block|}
block|,
block|{
name|MENU_NEXT
block|,
literal|3
block|,
literal|"eo"
block|,
literal|0
block|,
literal|0
block|,
name|subtest_eo
block|,
literal|0
block|}
block|,
block|{
name|MENU_NEXT
block|,
literal|3
block|,
literal|"xmc"
block|,
literal|0
block|,
literal|0
block|,
name|subtest_xmc
block|,
literal|0
block|}
block|,
block|{
name|MENU_NEXT
block|,
literal|3
block|,
literal|"xhp"
block|,
literal|0
block|,
literal|0
block|,
name|subtest_xhp
block|,
literal|0
block|}
block|,
block|{
name|MENU_NEXT
block|,
literal|6
block|,
literal|"mir"
block|,
literal|0
block|,
literal|0
block|,
name|subtest_mir
block|,
literal|0
block|}
block|,
block|{
name|MENU_NEXT
block|,
literal|6
block|,
literal|"msgr"
block|,
literal|0
block|,
literal|0
block|,
name|subtest_msgr
block|,
literal|0
block|}
block|,
block|{
name|MENU_NEXT
operator||
name|MENU_CLEAR
block|,
literal|0
block|,
literal|"tbc"
block|,
literal|"it"
block|,
literal|0
block|,
name|subtest_tbc
block|,
literal|0
block|}
block|,
block|{
name|MENU_NEXT
operator||
name|MENU_CLEAR
block|,
literal|0
block|,
literal|"hts"
block|,
literal|"it"
block|,
literal|0
block|,
name|subtest_hts
block|,
literal|0
block|}
block|,
block|{
name|MENU_NEXT
block|,
literal|4
block|,
literal|"xt"
block|,
literal|"it"
block|,
literal|0
block|,
name|subtest_xt
block|,
literal|0
block|}
block|,
block|{
name|MENU_NEXT
block|,
literal|1
block|,
literal|"cbt"
block|,
literal|"it"
block|,
literal|0
block|,
name|subtest_cbt
block|,
literal|0
block|}
block|,
block|{
name|MENU_NEXT
block|,
literal|6
block|,
literal|"in"
block|,
literal|0
block|,
literal|0
block|,
name|subtest_in
block|,
literal|0
block|}
block|,
block|{
name|MENU_NEXT
block|,
literal|1
block|,
literal|"da) (db"
block|,
literal|0
block|,
literal|0
block|,
name|subtest_dadb
block|,
literal|0
block|}
block|,
block|{
name|MENU_LAST
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* **	subtest_os(test_list, status, ch) ** **	test over strike mode (os) */
end_comment

begin_function
specifier|static
name|void
name|subtest_os
parameter_list|(
name|struct
name|test_list
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|state
parameter_list|,
name|int
modifier|*
name|ch
parameter_list|)
block|{
name|ptext
argument_list|(
literal|"(os) should be true, not false."
argument_list|)
expr_stmt|;
name|put_cr
argument_list|()
expr_stmt|;
name|ptextln
argument_list|(
literal|"(os) should be           false."
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"(os) over-strike is %s in the data base.  "
argument_list|,
name|over_strike
condition|?
literal|"true"
else|:
literal|"false"
argument_list|)
expr_stmt|;
name|ptext
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|generic_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **	subtest_rmam(test_list, status, ch) ** **	test exit automatic margins mode (rmam) */
end_comment

begin_function
specifier|static
name|void
name|subtest_rmam
parameter_list|(
name|struct
name|test_list
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|state
parameter_list|,
name|int
modifier|*
name|ch
parameter_list|)
block|{
name|int
name|j
decl_stmt|;
if|if
condition|(
operator|!
name|exit_am_mode
condition|)
block|{
name|ptext
argument_list|(
literal|"(rmam) not present.  "
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|can_go_home
condition|)
block|{
name|ptext
argument_list|(
literal|"(rmam) not tested, no way to home cursor.  "
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|over_strike
condition|)
block|{
name|put_clear
argument_list|()
expr_stmt|;
name|go_home
argument_list|()
expr_stmt|;
name|tc_putp
argument_list|(
name|exit_am_mode
argument_list|)
expr_stmt|;
name|ptext
argument_list|(
literal|"\n(rmam) will     reset (am)"
argument_list|)
expr_stmt|;
name|go_home
argument_list|()
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|columns
condition|;
name|j
operator|++
control|)
name|put_this
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|ptext
argument_list|(
literal|"(rmam) will not reset (am)"
argument_list|)
expr_stmt|;
name|go_home
argument_list|()
expr_stmt|;
name|put_newlines
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|put_clear
argument_list|()
expr_stmt|;
name|go_home
argument_list|()
expr_stmt|;
name|tc_putp
argument_list|(
name|exit_am_mode
argument_list|)
expr_stmt|;
name|ptext
argument_list|(
literal|"\n(rmam) will reset (am)"
argument_list|)
expr_stmt|;
name|go_home
argument_list|()
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|columns
condition|;
name|j
operator|++
control|)
name|put_this
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|ptext
argument_list|(
literal|"(rmam) will not reset (am) "
argument_list|)
expr_stmt|;
name|go_home
argument_list|()
expr_stmt|;
name|put_str
argument_list|(
literal|"                          "
argument_list|)
expr_stmt|;
name|go_home
argument_list|()
expr_stmt|;
name|put_newlines
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
name|ptext
argument_list|(
literal|"Exit-automatic-margins "
argument_list|)
expr_stmt|;
name|generic_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **	subtest_smam(test_list, status, ch) ** **	test enter automatic margins mode (smam) */
end_comment

begin_function
specifier|static
name|void
name|subtest_smam
parameter_list|(
name|struct
name|test_list
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|state
parameter_list|,
name|int
modifier|*
name|ch
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
operator|!
name|enter_am_mode
condition|)
block|{
name|ptext
argument_list|(
literal|"(smam) not present.  "
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|can_go_home
condition|)
block|{
name|ptext
argument_list|(
literal|"(smam) not tested, no way to home cursor.  "
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|over_strike
condition|)
block|{
name|put_clear
argument_list|()
expr_stmt|;
name|go_home
argument_list|()
expr_stmt|;
name|tc_putp
argument_list|(
name|enter_am_mode
argument_list|)
expr_stmt|;
name|ptext
argument_list|(
literal|"\n(smam) will "
argument_list|)
expr_stmt|;
name|i
operator|=
name|char_count
expr_stmt|;
name|ptext
argument_list|(
literal|"not set (am)"
argument_list|)
expr_stmt|;
name|go_home
argument_list|()
expr_stmt|;
for|for
control|(
name|j
operator|=
operator|-
name|i
init|;
name|j
operator|<
name|columns
condition|;
name|j
operator|++
control|)
name|put_this
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|put_str
argument_list|(
literal|"@@@"
argument_list|)
expr_stmt|;
name|put_newlines
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|put_clear
argument_list|()
expr_stmt|;
name|go_home
argument_list|()
expr_stmt|;
name|tc_putp
argument_list|(
name|enter_am_mode
argument_list|)
expr_stmt|;
name|ptext
argument_list|(
literal|"\n(smam) will not set (am)"
argument_list|)
expr_stmt|;
name|go_home
argument_list|()
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|columns
condition|;
name|j
operator|++
control|)
name|put_this
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|ptext
argument_list|(
literal|"(smam) will set (am)    "
argument_list|)
expr_stmt|;
name|go_home
argument_list|()
expr_stmt|;
name|put_str
argument_list|(
literal|"                          "
argument_list|)
expr_stmt|;
name|put_newlines
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
name|ptext
argument_list|(
literal|"Enter-automatic-margins "
argument_list|)
expr_stmt|;
name|generic_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **	subtest_am(test_list, status, ch) ** **	test automatic margins (am) */
end_comment

begin_function
specifier|static
name|void
name|subtest_am
parameter_list|(
name|struct
name|test_list
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|state
parameter_list|,
name|int
modifier|*
name|ch
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
operator|!
name|can_go_home
condition|)
block|{
name|ptextln
argument_list|(
literal|"(am) not tested, no way to home cursor.  "
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|over_strike
condition|)
block|{
name|put_clear
argument_list|()
expr_stmt|;
name|go_home
argument_list|()
expr_stmt|;
name|ptext
argument_list|(
literal|"\n(am) should "
argument_list|)
expr_stmt|;
name|i
operator|=
name|char_count
expr_stmt|;
name|ptext
argument_list|(
literal|"not be set"
argument_list|)
expr_stmt|;
name|go_home
argument_list|()
expr_stmt|;
for|for
control|(
name|j
operator|=
operator|-
name|i
init|;
name|j
operator|<
name|columns
condition|;
name|j
operator|++
control|)
name|put_this
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|put_str
argument_list|(
literal|"@@@"
argument_list|)
expr_stmt|;
name|go_home
argument_list|()
expr_stmt|;
name|put_newlines
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"(am) is %s in the data base"
argument_list|,
name|auto_right_margin
condition|?
literal|"true"
else|:
literal|"false"
argument_list|)
expr_stmt|;
name|ptextln
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|put_clear
argument_list|()
expr_stmt|;
name|go_home
argument_list|()
expr_stmt|;
name|ptext
argument_list|(
literal|"\n(am) should not be set"
argument_list|)
expr_stmt|;
name|go_home
argument_list|()
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|columns
condition|;
name|j
operator|++
control|)
name|put_this
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|ptext
argument_list|(
literal|"(am) should be set    "
argument_list|)
expr_stmt|;
name|go_home
argument_list|()
expr_stmt|;
name|put_str
argument_list|(
literal|"                       \n\n"
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"(am) is %s in the data base"
argument_list|,
name|auto_right_margin
condition|?
literal|"true"
else|:
literal|"false"
argument_list|)
expr_stmt|;
name|ptextln
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
name|ptext
argument_list|(
literal|"Automatic-right-margin "
argument_list|)
expr_stmt|;
name|generic_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Note: uprint() sends underscore back-space character, and         ucprint() sends character back-space underscore.  */
end_comment

begin_comment
comment|/* **	uprint(string) ** **	underline string for (ul) test */
end_comment

begin_function
specifier|static
name|void
name|uprint
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
if|if
condition|(
name|s
condition|)
block|{
while|while
condition|(
operator|*
name|s
condition|)
block|{
name|put_str
argument_list|(
literal|"_\b"
argument_list|)
expr_stmt|;
name|putchp
argument_list|(
operator|*
name|s
operator|++
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* **	ucprint(string) ** **	underline string for (uc) test */
end_comment

begin_function
specifier|static
name|void
name|ucprint
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
if|if
condition|(
name|s
condition|)
block|{
while|while
condition|(
operator|*
name|s
condition|)
block|{
name|putchp
argument_list|(
operator|*
name|s
operator|++
argument_list|)
expr_stmt|;
name|putchp
argument_list|(
literal|'\b'
argument_list|)
expr_stmt|;
name|tc_putp
argument_list|(
name|underline_char
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* **	subtest_ul(test_list, status, ch) ** **	test transparent underline (ul) */
end_comment

begin_function
specifier|static
name|void
name|subtest_ul
parameter_list|(
name|struct
name|test_list
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|state
parameter_list|,
name|int
modifier|*
name|ch
parameter_list|)
block|{
if|if
condition|(
operator|!
name|over_strike
condition|)
block|{
comment|/* (ul) is used only if (os) is reset */
name|put_crlf
argument_list|()
expr_stmt|;
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"This text should %sbe underlined."
argument_list|,
name|transparent_underline
condition|?
literal|""
else|:
literal|"not "
argument_list|)
expr_stmt|;
name|uprint
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|put_crlf
argument_list|()
expr_stmt|;
name|ptextln
argument_list|(
literal|"If the above line is not underlined the (ul) should be false."
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"(ul) Transparent-underline is %s in the data base"
argument_list|,
name|transparent_underline
condition|?
literal|"true"
else|:
literal|"false"
argument_list|)
expr_stmt|;
name|ptextln
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|generic_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* **	subtest_uc(test_list, status, ch) ** **	test underline character (uc) */
end_comment

begin_function
specifier|static
name|void
name|subtest_uc
parameter_list|(
name|struct
name|test_list
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|state
parameter_list|,
name|int
modifier|*
name|ch
parameter_list|)
block|{
if|if
condition|(
operator|!
name|over_strike
condition|)
block|{
if|if
condition|(
name|underline_char
condition|)
block|{
name|ucprint
argument_list|(
literal|"This text should be underlined."
argument_list|)
expr_stmt|;
name|put_crlf
argument_list|()
expr_stmt|;
name|ptextln
argument_list|(
literal|"If the above text is not underlined the (uc) has failed."
argument_list|)
expr_stmt|;
name|ptext
argument_list|(
literal|"Underline-character "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ptext
argument_list|(
literal|"(uc) underline-character is not defined.  "
argument_list|)
expr_stmt|;
block|}
name|generic_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* **	subtest_bw(test_list, status, ch) ** **	test auto left margin (bw) */
end_comment

begin_function
specifier|static
name|void
name|subtest_bw
parameter_list|(
name|struct
name|test_list
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|state
parameter_list|,
name|int
modifier|*
name|ch
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|over_strike
condition|)
block|{
comment|/* test (bw) */
name|ptext
argument_list|(
literal|"\n(bw) should "
argument_list|)
expr_stmt|;
name|i
operator|=
name|char_count
expr_stmt|;
name|ptextln
argument_list|(
literal|"not be set."
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|i
init|;
name|j
operator|<
name|columns
condition|;
name|j
operator|++
control|)
name|put_str
argument_list|(
literal|"\b"
argument_list|)
expr_stmt|;
name|put_str
argument_list|(
literal|"@@@"
argument_list|)
expr_stmt|;
name|put_crlf
argument_list|()
expr_stmt|;
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"(bw) Auto-left-margin is %s in the data base"
argument_list|,
name|auto_left_margin
condition|?
literal|"true"
else|:
literal|"false"
argument_list|)
expr_stmt|;
name|ptextln
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* test (bw) */
name|ptextln
argument_list|(
literal|"(bw) should not be set."
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|12
init|;
name|i
operator|<
name|columns
condition|;
name|i
operator|++
control|)
name|put_str
argument_list|(
literal|"\b"
argument_list|)
expr_stmt|;
if|if
condition|(
name|delete_character
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
name|tc_putp
argument_list|(
name|delete_character
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|put_str
argument_list|(
literal|"   "
argument_list|)
expr_stmt|;
block|}
name|put_crlf
argument_list|()
expr_stmt|;
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"(bw) Auto-left-margin is %s in the data base"
argument_list|,
name|auto_left_margin
condition|?
literal|"true"
else|:
literal|"false"
argument_list|)
expr_stmt|;
name|ptextln
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
name|generic_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **	subtest_tbc(test_list, status, ch) ** **	test clear tabs (tbc) */
end_comment

begin_function
specifier|static
name|void
name|subtest_tbc
parameter_list|(
name|struct
name|test_list
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|state
parameter_list|,
name|int
modifier|*
name|ch
parameter_list|)
block|{
name|int
name|tabat
decl_stmt|;
comment|/* the tab spacing we end up with */
name|int
name|i
decl_stmt|;
if|if
condition|(
name|clear_all_tabs
operator|&&
operator|!
name|set_tab
condition|)
block|{
name|ptext
argument_list|(
literal|"(tbc) Clear-all-tabs is defined but (hts) set-tab is not.  "
argument_list|)
expr_stmt|;
name|ptext
argument_list|(
literal|"Once the tabs are cleared there is no way to set them.  "
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|clear_all_tabs
condition|)
block|{
name|tabat
operator|=
name|set_tab
condition|?
literal|8
else|:
name|init_tabs
expr_stmt|;
name|tc_putp
argument_list|(
name|clear_all_tabs
argument_list|)
expr_stmt|;
name|ptext
argument_list|(
literal|"Clear tabs (tbc)"
argument_list|)
expr_stmt|;
name|go_home
argument_list|()
expr_stmt|;
name|put_crlf
argument_list|()
expr_stmt|;
name|putchp
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
name|putchp
argument_list|(
literal|'T'
argument_list|)
expr_stmt|;
name|go_home
argument_list|()
expr_stmt|;
name|put_newlines
argument_list|(
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|columns
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
name|tabat
condition|)
block|{
name|putchp
argument_list|(
literal|'T'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|putchp
argument_list|(
literal|'.'
argument_list|)
expr_stmt|;
block|}
block|}
name|go_home
argument_list|()
expr_stmt|;
name|ptext
argument_list|(
literal|"\n\n\nIf the above two lines have T's in the same column then (tbc) has failed.  "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ptext
argument_list|(
literal|"(tbc) Clear-all-tabs is not defined.  "
argument_list|)
expr_stmt|;
block|}
name|generic_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **	subtest_hts(test_list, status, ch) ** **	(ht) and set tabs with (hts) */
end_comment

begin_function
specifier|static
name|void
name|subtest_hts
parameter_list|(
name|struct
name|test_list
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|state
parameter_list|,
name|int
modifier|*
name|ch
parameter_list|)
block|{
name|int
name|tabat
decl_stmt|;
comment|/* the tab spacing we end up with */
name|int
name|i
decl_stmt|;
name|tabat
operator|=
name|init_tabs
expr_stmt|;
if|if
condition|(
name|set_tab
condition|)
block|{
name|ptext
argument_list|(
literal|"Tabs set with (hts)"
argument_list|)
expr_stmt|;
name|put_crlf
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|columns
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|%
literal|8
operator|==
literal|1
condition|)
block|{
name|tc_putp
argument_list|(
name|set_tab
argument_list|)
expr_stmt|;
block|}
name|putchp
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
name|tabat
operator|=
literal|8
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"(hts) Set-tabs not defined.  (it) Initial-tabs at %d"
argument_list|,
name|init_tabs
argument_list|)
expr_stmt|;
name|ptext
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
name|go_home
argument_list|()
expr_stmt|;
name|put_newlines
argument_list|(
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|tabat
operator|<=
literal|0
condition|)
block|{
name|tabat
operator|=
literal|8
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|tabat
init|;
name|i
operator|<
name|columns
condition|;
name|i
operator|+=
name|tabat
control|)
block|{
name|putchp
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
name|putchp
argument_list|(
literal|'T'
argument_list|)
expr_stmt|;
block|}
name|go_home
argument_list|()
expr_stmt|;
name|put_newlines
argument_list|(
literal|3
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|columns
condition|;
name|i
operator|++
control|)
block|{
name|putchp
argument_list|(
literal|'.'
argument_list|)
expr_stmt|;
block|}
name|go_home
argument_list|()
expr_stmt|;
name|put_newlines
argument_list|(
literal|3
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|tabat
init|;
name|i
operator|<
name|columns
condition|;
name|i
operator|+=
name|tabat
control|)
block|{
name|putchp
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
name|putchp
argument_list|(
literal|'T'
argument_list|)
expr_stmt|;
block|}
name|go_home
argument_list|()
expr_stmt|;
name|put_newlines
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|putchp
argument_list|(
literal|'.'
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|columns
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|%
name|tabat
operator|==
literal|1
condition|)
block|{
name|putchp
argument_list|(
literal|'T'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|putchp
argument_list|(
literal|'.'
argument_list|)
expr_stmt|;
block|}
block|}
name|go_home
argument_list|()
expr_stmt|;
name|put_newlines
argument_list|(
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
name|set_tab
condition|)
block|{
name|ptextln
argument_list|(
literal|"If the last two lines are not the same then (hts) has failed."
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|init_tabs
operator|>
literal|0
condition|)
block|{
name|ptextln
argument_list|(
literal|"If the last two lines are not the same then (it) is wrong."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ptextln
argument_list|(
literal|"If the last two lines are the same then maybe you do have tabs and (it) should be changed."
argument_list|)
expr_stmt|;
block|}
name|generic_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **	subtest_xt(test_list, status, ch) ** **	(xt) glitch */
end_comment

begin_function
specifier|static
name|void
name|subtest_xt
parameter_list|(
name|struct
name|test_list
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|state
parameter_list|,
name|int
modifier|*
name|ch
parameter_list|)
block|{
name|int
name|tabat
decl_stmt|;
comment|/* the tab spacing we end up with */
name|int
name|cc
decl_stmt|;
name|tabat
operator|=
name|set_tab
condition|?
literal|8
else|:
name|init_tabs
expr_stmt|;
if|if
condition|(
operator|!
name|over_strike
operator|&&
operator|(
name|tabat
operator|>
literal|0
operator|)
condition|)
block|{
name|ptext
argument_list|(
literal|"(xt) should not "
argument_list|)
expr_stmt|;
name|put_cr
argument_list|()
expr_stmt|;
name|ptext
argument_list|(
literal|"(xt) should"
argument_list|)
expr_stmt|;
name|cc
operator|=
name|char_count
expr_stmt|;
while|while
condition|(
name|cc
operator|<
literal|16
condition|)
block|{
name|putchp
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
name|cc
operator|=
operator|(
operator|(
name|cc
operator|/
name|tabat
operator|)
operator|+
literal|1
operator|)
operator|*
name|tabat
expr_stmt|;
block|}
name|putln
argument_list|(
literal|"be set."
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"(xt) Destructive-tab is %s in the data base."
argument_list|,
name|dest_tabs_magic_smso
condition|?
literal|"true"
else|:
literal|"false"
argument_list|)
expr_stmt|;
name|ptextln
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|generic_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* **	subtest_cbt(test_list, status, ch) ** **	(cbt) back tab */
end_comment

begin_function
specifier|static
name|void
name|subtest_cbt
parameter_list|(
name|struct
name|test_list
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|state
parameter_list|,
name|int
modifier|*
name|ch
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|back_tab
condition|)
block|{
name|put_clear
argument_list|()
expr_stmt|;
name|ptext
argument_list|(
literal|"Back-tab (cbt)"
argument_list|)
expr_stmt|;
name|go_home
argument_list|()
expr_stmt|;
name|put_crlf
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|columns
condition|;
name|i
operator|++
control|)
block|{
name|putchp
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|columns
condition|;
name|i
operator|+=
literal|8
control|)
block|{
name|tc_putp
argument_list|(
name|back_tab
argument_list|)
expr_stmt|;
name|putchp
argument_list|(
literal|'T'
argument_list|)
expr_stmt|;
name|tc_putp
argument_list|(
name|back_tab
argument_list|)
expr_stmt|;
block|}
name|go_home
argument_list|()
expr_stmt|;
name|put_newlines
argument_list|(
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|columns
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|%
literal|8
operator|==
literal|1
condition|)
block|{
name|putchp
argument_list|(
literal|'T'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|putchp
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
block|}
name|go_home
argument_list|()
expr_stmt|;
name|put_newlines
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|ptextln
argument_list|(
literal|"The preceding two lines should be the same."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ptextln
argument_list|(
literal|"(cbt) Back-tab not present"
argument_list|)
expr_stmt|;
block|}
name|generic_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **	subtest_xenl(test_list, status, ch) ** **	(xenl) eat newline glitch */
end_comment

begin_function
specifier|static
name|void
name|subtest_xenl
parameter_list|(
name|struct
name|test_list
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|state
parameter_list|,
name|int
modifier|*
name|ch
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
if|if
condition|(
name|over_strike
condition|)
block|{
comment|/* test (xenl) on overstrike terminals */
if|if
condition|(
operator|!
name|can_go_home
operator|||
operator|!
name|can_clear_screen
condition|)
block|{
name|ptextln
argument_list|(
literal|"(xenl) Newline-glitch not tested, can't home cursor and clear."
argument_list|)
expr_stmt|;
name|generic_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
return|return;
block|}
name|put_clear
argument_list|()
expr_stmt|;
comment|/* 		   this test must be done in raw mode.  Otherwise UNIX will 		   translate CR to CRLF. 		*/
if|if
condition|(
name|stty_query
argument_list|(
name|TTY_OUT_TRANS
argument_list|)
condition|)
name|tty_raw
argument_list|(
literal|1
argument_list|,
name|char_mask
argument_list|)
expr_stmt|;
name|ptext
argument_list|(
literal|"\nreset (xenl). Does "
argument_list|)
expr_stmt|;
name|i
operator|=
name|char_count
expr_stmt|;
name|put_str
argument_list|(
literal|"not ignore CR, does "
argument_list|)
expr_stmt|;
name|k
operator|=
name|char_count
expr_stmt|;
name|put_str
argument_list|(
literal|"not ignore LF"
argument_list|)
expr_stmt|;
name|go_home
argument_list|()
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|columns
condition|;
name|j
operator|++
control|)
name|put_this
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|put_cr
argument_list|()
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
name|putchp
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|put_str
argument_list|(
literal|"@@@\n@@"
argument_list|)
expr_stmt|;
name|go_home
argument_list|()
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|columns
condition|;
name|j
operator|++
control|)
name|put_this
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|put_lf
argument_list|()
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|k
condition|;
name|j
operator|++
control|)
name|putchp
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|put_str
argument_list|(
literal|"@@@\r@@"
argument_list|)
expr_stmt|;
name|tty_set
argument_list|()
expr_stmt|;
name|go_home
argument_list|()
expr_stmt|;
name|put_newlines
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"(xenl) Newline-glitch is %s in the data base"
argument_list|,
name|eat_newline_glitch
condition|?
literal|"true"
else|:
literal|"false"
argument_list|)
expr_stmt|;
name|ptextln
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* test (xenl) when (os) is reset */
if|if
condition|(
operator|!
name|can_go_home
condition|)
block|{
name|ptextln
argument_list|(
literal|"(xenl) Newline-glitch not tested, can't home cursor"
argument_list|)
expr_stmt|;
name|generic_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* (xenl) test */
name|put_clear
argument_list|()
expr_stmt|;
comment|/* 		   this test must be done in raw mode.  Otherwise 		   UNIX will translate CR to CRLF. 		*/
if|if
condition|(
name|stty_query
argument_list|(
name|TTY_OUT_TRANS
argument_list|)
condition|)
name|tty_raw
argument_list|(
literal|1
argument_list|,
name|char_mask
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|columns
condition|;
name|j
operator|++
control|)
name|put_this
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|put_cr
argument_list|()
expr_stmt|;
name|ptext
argument_list|(
literal|"(xenl) should be set. Does not ignore CR"
argument_list|)
expr_stmt|;
name|go_home
argument_list|()
expr_stmt|;
name|put_crlf
argument_list|()
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|columns
condition|;
name|j
operator|++
control|)
name|put_this
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|put_lf
argument_list|()
expr_stmt|;
comment|/* test (cud1) */
name|ptext
argument_list|(
literal|"(xenl) should be set. Ignores (cud1)"
argument_list|)
expr_stmt|;
name|go_home
argument_list|()
expr_stmt|;
name|put_newlines
argument_list|(
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|scroll_forward
operator|&&
name|cursor_down
operator|&&
name|strcmp
argument_list|(
name|scroll_forward
argument_list|,
name|cursor_down
argument_list|)
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|columns
condition|;
name|j
operator|++
control|)
name|put_this
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|put_ind
argument_list|()
expr_stmt|;
comment|/* test (ind) */
name|ptext
argument_list|(
literal|"(xenl) should be set. Ignores (ind)"
argument_list|)
expr_stmt|;
name|go_home
argument_list|()
expr_stmt|;
name|put_newlines
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
name|tty_set
argument_list|()
expr_stmt|;
name|ptextln
argument_list|(
literal|"If you don't see text above telling you to set it, (xenl) should be false"
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"(xenl) Newline-glitch is %s in the data base"
argument_list|,
name|eat_newline_glitch
condition|?
literal|"true"
else|:
literal|"false"
argument_list|)
expr_stmt|;
name|ptextln
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
name|generic_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **	subtest_eo(test_list, status, ch) ** **	(eo) erase overstrike */
end_comment

begin_function
specifier|static
name|void
name|subtest_eo
parameter_list|(
name|struct
name|test_list
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|state
parameter_list|,
name|int
modifier|*
name|ch
parameter_list|)
block|{
if|if
condition|(
name|transparent_underline
operator|||
name|over_strike
operator|||
name|underline_char
condition|)
block|{
name|ptext
argument_list|(
literal|"(eo) should "
argument_list|)
expr_stmt|;
if|if
condition|(
name|underline_char
condition|)
block|{
name|ucprint
argument_list|(
literal|"not"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|uprint
argument_list|(
literal|"not"
argument_list|)
expr_stmt|;
block|}
name|put_cr
argument_list|()
expr_stmt|;
name|ptextln
argument_list|(
literal|"(eo) should     be set"
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"\n(eo) Erase-overstrike is %s in the data base"
argument_list|,
name|erase_overstrike
condition|?
literal|"true"
else|:
literal|"false"
argument_list|)
expr_stmt|;
name|ptextln
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|generic_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* **	subtest_xmc(test_list, status, ch) ** **	(xmc) magic cookie glitch */
end_comment

begin_function
specifier|static
name|void
name|subtest_xmc
parameter_list|(
name|struct
name|test_list
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|state
parameter_list|,
name|int
modifier|*
name|ch
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|enter_standout_mode
condition|)
block|{
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"\n(xmc) Magic-cookie-glitch is %d in the data base"
argument_list|,
name|magic_cookie_glitch
argument_list|)
expr_stmt|;
name|ptextln
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|j
operator|=
name|magic_cookie_glitch
operator|*
literal|8
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|j
condition|;
name|i
operator|++
control|)
block|{
name|put_str
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
name|ptextln
argument_list|(
literal|"        These two lines should line up."
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|>
literal|0
condition|)
block|{
name|char_count
operator|+=
name|j
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|put_mode
argument_list|(
name|enter_standout_mode
argument_list|)
expr_stmt|;
name|putchp
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|put_mode
argument_list|(
name|exit_standout_mode
argument_list|)
expr_stmt|;
name|putchp
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
name|ptextln
argument_list|(
literal|"These two lines should line up."
argument_list|)
expr_stmt|;
name|ptext
argument_list|(
literal|"If they don't line up then (xmc) magic-cookie-glitch should be greater than zero.  "
argument_list|)
expr_stmt|;
name|generic_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* **	subtest_xhp(test_list, status, ch) ** **	(xhp) erase does not clear standout mode */
end_comment

begin_function
specifier|static
name|void
name|subtest_xhp
parameter_list|(
name|struct
name|test_list
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|state
parameter_list|,
name|int
modifier|*
name|ch
parameter_list|)
block|{
if|if
condition|(
name|enter_standout_mode
condition|)
block|{
name|put_crlf
argument_list|()
expr_stmt|;
name|put_mode
argument_list|(
name|enter_standout_mode
argument_list|)
expr_stmt|;
name|put_str
argument_list|(
literal|"Stand out"
argument_list|)
expr_stmt|;
name|put_mode
argument_list|(
name|exit_standout_mode
argument_list|)
expr_stmt|;
name|put_cr
argument_list|()
expr_stmt|;
name|ptextln
argument_list|(
literal|"If any part of this line is standout then (xhp) should be set."
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"(xhp) Erase-standout-glitch is %s in the data base"
argument_list|,
name|ceol_standout_glitch
condition|?
literal|"true"
else|:
literal|"false"
argument_list|)
expr_stmt|;
name|ptextln
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|generic_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* **	subtest_mir(test_list, status, ch) ** **	(mir) move in insert mode */
end_comment

begin_function
specifier|static
name|void
name|subtest_mir
parameter_list|(
name|struct
name|test_list
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|state
parameter_list|,
name|int
modifier|*
name|ch
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|enter_insert_mode
operator|&&
name|exit_insert_mode
operator|&&
name|cursor_address
condition|)
block|{
name|put_clear
argument_list|()
expr_stmt|;
name|i
operator|=
name|line_count
expr_stmt|;
name|put_str
argument_list|(
literal|"\nXXX\nXXX\nXXX\nXXX"
argument_list|)
expr_stmt|;
name|tc_putp
argument_list|(
name|enter_insert_mode
argument_list|)
expr_stmt|;
name|s
operator|=
name|TPARM_2
argument_list|(
name|cursor_address
argument_list|,
name|i
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tputs
argument_list|(
name|s
argument_list|,
name|lines
argument_list|,
name|tc_putch
argument_list|)
expr_stmt|;
name|putchp
argument_list|(
literal|'X'
argument_list|)
expr_stmt|;
name|s
operator|=
name|TPARM_2
argument_list|(
name|cursor_address
argument_list|,
name|i
operator|+
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tputs
argument_list|(
name|s
argument_list|,
name|lines
argument_list|,
name|tc_putch
argument_list|)
expr_stmt|;
name|putchp
argument_list|(
literal|'X'
argument_list|)
expr_stmt|;
name|s
operator|=
name|TPARM_2
argument_list|(
name|cursor_address
argument_list|,
name|i
operator|+
literal|3
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|tputs
argument_list|(
name|s
argument_list|,
name|lines
argument_list|,
name|tc_putch
argument_list|)
expr_stmt|;
name|putchp
argument_list|(
literal|'X'
argument_list|)
expr_stmt|;
name|s
operator|=
name|TPARM_2
argument_list|(
name|cursor_address
argument_list|,
name|i
operator|+
literal|4
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|tputs
argument_list|(
name|s
argument_list|,
name|lines
argument_list|,
name|tc_putch
argument_list|)
expr_stmt|;
name|putchp
argument_list|(
literal|'X'
argument_list|)
expr_stmt|;
name|tc_putp
argument_list|(
name|exit_insert_mode
argument_list|)
expr_stmt|;
name|put_newlines
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|ptextln
argument_list|(
literal|"If you see a 4 by 4 block of X's then (mir) should be true."
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"(mir) Move-in-insert-mode is %s in the data base"
argument_list|,
name|move_insert_mode
condition|?
literal|"true"
else|:
literal|"false"
argument_list|)
expr_stmt|;
name|ptextln
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ptext
argument_list|(
literal|"(mir) Move-in-insert-mode not tested, "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|enter_insert_mode
condition|)
block|{
name|ptext
argument_list|(
literal|"(smir) "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|exit_insert_mode
condition|)
block|{
name|ptext
argument_list|(
literal|"(rmir) "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|cursor_address
condition|)
block|{
name|ptext
argument_list|(
literal|"(cup) "
argument_list|)
expr_stmt|;
block|}
name|ptext
argument_list|(
literal|"not present.  "
argument_list|)
expr_stmt|;
block|}
name|generic_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **	subtest_msgr(test_list, status, ch) ** **	(msgr) move in sgr mode */
end_comment

begin_function
specifier|static
name|void
name|subtest_msgr
parameter_list|(
name|struct
name|test_list
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|state
parameter_list|,
name|int
modifier|*
name|ch
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|cursor_address
operator|&&
operator|(
operator|(
name|enter_standout_mode
operator|&&
name|exit_standout_mode
operator|)
operator|||
operator|(
name|enter_alt_charset_mode
operator|&&
name|exit_alt_charset_mode
operator|)
operator|)
condition|)
block|{
name|put_crlf
argument_list|()
expr_stmt|;
name|i
operator|=
name|line_count
operator|+
literal|1
expr_stmt|;
name|tputs
argument_list|(
name|TPARM_2
argument_list|(
name|cursor_address
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
argument_list|,
name|lines
argument_list|,
name|tc_putch
argument_list|)
expr_stmt|;
name|put_mode
argument_list|(
name|enter_alt_charset_mode
argument_list|)
expr_stmt|;
name|put_crlf
argument_list|()
expr_stmt|;
comment|/* 		   some versions of the wy-120 can not clear lines or 		   screen when in alt charset mode.  If (el) and (ed) 		   are defined then I can test them.  If they are not 		   defined then they can not break (msgr) 		*/
name|tc_putp
argument_list|(
name|clr_eos
argument_list|)
expr_stmt|;
name|tc_putp
argument_list|(
name|clr_eol
argument_list|)
expr_stmt|;
name|put_mode
argument_list|(
name|exit_alt_charset_mode
argument_list|)
expr_stmt|;
name|put_mode
argument_list|(
name|enter_standout_mode
argument_list|)
expr_stmt|;
name|putchp
argument_list|(
literal|'X'
argument_list|)
expr_stmt|;
name|tputs
argument_list|(
name|TPARM_2
argument_list|(
name|cursor_address
argument_list|,
name|i
operator|+
literal|2
argument_list|,
literal|1
argument_list|)
argument_list|,
name|lines
argument_list|,
name|tc_putch
argument_list|)
expr_stmt|;
name|putchp
argument_list|(
literal|'X'
argument_list|)
expr_stmt|;
name|tputs
argument_list|(
name|TPARM_2
argument_list|(
name|cursor_address
argument_list|,
name|i
operator|+
literal|3
argument_list|,
literal|2
argument_list|)
argument_list|,
name|lines
argument_list|,
name|tc_putch
argument_list|)
expr_stmt|;
name|putchp
argument_list|(
literal|'X'
argument_list|)
expr_stmt|;
name|tputs
argument_list|(
name|TPARM_2
argument_list|(
name|cursor_address
argument_list|,
name|i
operator|+
literal|4
argument_list|,
literal|3
argument_list|)
argument_list|,
name|lines
argument_list|,
name|tc_putch
argument_list|)
expr_stmt|;
name|putchp
argument_list|(
literal|'X'
argument_list|)
expr_stmt|;
name|put_mode
argument_list|(
name|exit_standout_mode
argument_list|)
expr_stmt|;
name|put_crlf
argument_list|()
expr_stmt|;
name|tc_putp
argument_list|(
name|clr_eos
argument_list|)
expr_stmt|;
comment|/* OK if missing */
name|put_crlf
argument_list|()
expr_stmt|;
name|ptextln
argument_list|(
literal|"If you see a diagonal line of standout X's then (msgr) should be true.  If any of the blanks are standout then (msgr) should be false."
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"(msgr) Move-in-SGR-mode is %s in the data base"
argument_list|,
name|move_standout_mode
condition|?
literal|"true"
else|:
literal|"false"
argument_list|)
expr_stmt|;
name|ptextln
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ptextln
argument_list|(
literal|"(smso) (rmso) (smacs) (rmacs) missing; (msgr) Move-in-SGR-mode not tested."
argument_list|)
expr_stmt|;
block|}
name|generic_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **	subtest_in(test_list, status, ch) ** **	(in) insert null glitch */
end_comment

begin_function
specifier|static
name|void
name|subtest_in
parameter_list|(
name|struct
name|test_list
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|state
parameter_list|,
name|int
modifier|*
name|ch
parameter_list|)
block|{
if|if
condition|(
name|enter_insert_mode
operator|&&
name|exit_insert_mode
condition|)
block|{
name|ptextln
argument_list|(
literal|"\nTesting (in) with (smir) and (rmir)"
argument_list|)
expr_stmt|;
name|putln
argument_list|(
literal|"\tIf these two lines line up ..."
argument_list|)
expr_stmt|;
name|put_str
argument_list|(
literal|"\tIf these two lines line up ..."
argument_list|)
expr_stmt|;
name|put_cr
argument_list|()
expr_stmt|;
name|tc_putp
argument_list|(
name|enter_insert_mode
argument_list|)
expr_stmt|;
name|putchp
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|tc_putp
argument_list|(
name|exit_insert_mode
argument_list|)
expr_stmt|;
name|ptext
argument_list|(
literal|"\nthen (in) should be set.  "
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"(in) Insert-null-glitch is %s in the data base."
argument_list|,
name|insert_null_glitch
condition|?
literal|"true"
else|:
literal|"false"
argument_list|)
expr_stmt|;
name|ptextln
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|generic_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* **	subtest_dadb(test_list, status, ch) ** **	(da) (db) data above, (db) data below */
end_comment

begin_function
specifier|static
name|void
name|subtest_dadb
parameter_list|(
name|struct
name|test_list
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|state
parameter_list|,
name|int
modifier|*
name|ch
parameter_list|)
block|{
if|if
condition|(
name|can_clear_screen
operator|&&
name|scroll_reverse
operator|&&
name|scroll_forward
condition|)
block|{
name|put_clear
argument_list|()
expr_stmt|;
if|if
condition|(
name|scroll_reverse
condition|)
name|ptext
argument_list|(
literal|"(da) Data-above should be set\r"
argument_list|)
expr_stmt|;
name|home_down
argument_list|()
expr_stmt|;
if|if
condition|(
name|scroll_forward
condition|)
name|ptext
argument_list|(
literal|"(db) Data-below should be set\r"
argument_list|)
expr_stmt|;
name|tc_putp
argument_list|(
name|scroll_forward
argument_list|)
expr_stmt|;
name|go_home
argument_list|()
expr_stmt|;
name|tc_putp
argument_list|(
name|scroll_reverse
argument_list|)
expr_stmt|;
name|tc_putp
argument_list|(
name|scroll_reverse
argument_list|)
expr_stmt|;
name|home_down
argument_list|()
expr_stmt|;
name|tc_putp
argument_list|(
name|scroll_forward
argument_list|)
expr_stmt|;
name|go_home
argument_list|()
expr_stmt|;
name|ptextln
argument_list|(
literal|"\n\n\n\n\nIf the top line is blank then (da) should be false."
argument_list|)
expr_stmt|;
name|ptextln
argument_list|(
literal|"If the bottom line is blank then (db) should be false."
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"\n(da) Data-above is %s, and (db) Data-below is %s, in the data base."
argument_list|,
name|memory_above
condition|?
literal|"true"
else|:
literal|"false"
argument_list|,
name|memory_below
condition|?
literal|"true"
else|:
literal|"false"
argument_list|)
expr_stmt|;
name|ptextln
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|line_count
operator|=
name|lines
expr_stmt|;
block|}
else|else
block|{
name|ptextln
argument_list|(
literal|"(da) Data-above, (db) Data-below not tested, scrolls or (clear) is missing."
argument_list|)
expr_stmt|;
block|}
name|generic_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

