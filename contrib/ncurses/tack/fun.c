begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ** Copyright (C) 1991, 1997 Free Software Foundation, Inc. ** ** This file is part of TACK. ** ** TACK is free software; you can redistribute it and/or modify ** it under the terms of the GNU General Public License as published by ** the Free Software Foundation; either version 2, or (at your option) ** any later version. ** ** TACK is distributed in the hope that it will be useful, ** but WITHOUT ANY WARRANTY; without even the implied warranty of ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ** GNU General Public License for more details. ** ** You should have received a copy of the GNU General Public License ** along with TACK; see the file COPYING.  If not, write to ** the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, ** Boston, MA 02110-1301, USA */
end_comment

begin_include
include|#
directive|include
file|<tack.h>
end_include

begin_macro
name|MODULE_ID
argument_list|(
literal|"$Id: fun.c,v 1.9 2006/11/26 00:15:53 tom Exp $"
argument_list|)
end_macro

begin_comment
comment|/*  * Test the function keys on the terminal.  The code for echo tests  * lives here too.  */
end_comment

begin_function_decl
specifier|static
name|void
name|funkey_keys
parameter_list|(
name|struct
name|test_list
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|funkey_meta
parameter_list|(
name|struct
name|test_list
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|funkey_label
parameter_list|(
name|struct
name|test_list
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|funkey_prog
parameter_list|(
name|struct
name|test_list
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|funkey_local
parameter_list|(
name|struct
name|test_list
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|test_list
name|funkey_test_list
index|[]
init|=
block|{
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|"e) edit terminfo"
block|,
literal|0
block|,
operator|&
name|edit_menu
block|}
block|,
block|{
name|MENU_CLEAR
operator|+
name|FLAG_FUNCTION_KEY
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|"f) show a list of function keys"
block|,
name|show_report
block|,
literal|0
block|}
block|,
block|{
name|MENU_NEXT
operator||
name|MENU_CLEAR
block|,
literal|0
block|,
literal|"smkx) (rmkx"
block|,
literal|0
block|,
literal|"k) test function keys"
block|,
name|funkey_keys
block|,
literal|0
block|}
block|,
block|{
name|MENU_NEXT
block|,
literal|10
block|,
literal|"km"
block|,
literal|"smm rmm"
block|,
literal|0
block|,
name|funkey_meta
block|,
literal|0
block|}
block|,
block|{
name|MENU_NEXT
block|,
literal|8
block|,
literal|"nlab) (smln) (pln) (rmln"
block|,
literal|"lw lh"
block|,
literal|0
block|,
name|funkey_label
block|,
literal|0
block|}
block|,
block|{
name|MENU_NEXT
block|,
literal|2
block|,
literal|"pfx"
block|,
literal|0
block|,
literal|0
block|,
name|funkey_prog
block|,
literal|0
block|}
block|,
block|{
name|MENU_NEXT
block|,
literal|2
block|,
literal|"pfloc"
block|,
literal|0
block|,
literal|0
block|,
name|funkey_local
block|,
literal|0
block|}
block|,
block|{
name|MENU_LAST
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|printer_on
parameter_list|(
name|struct
name|test_list
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|printer_mc0
parameter_list|(
name|struct
name|test_list
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|test_list
name|printer_test_list
index|[]
init|=
block|{
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|"e) edit terminfo"
block|,
literal|0
block|,
operator|&
name|edit_menu
block|}
block|,
block|{
name|MENU_NEXT
operator||
name|MENU_CLEAR
block|,
literal|0
block|,
literal|"mc4) (mc5) (mc5i"
block|,
literal|0
block|,
literal|0
block|,
name|printer_on
block|,
literal|0
block|}
block|,
block|{
name|MENU_NEXT
operator||
name|MENU_CLEAR
block|,
literal|0
block|,
literal|"mc0"
block|,
literal|0
block|,
literal|0
block|,
name|printer_mc0
block|,
literal|0
block|}
block|,
block|{
name|MENU_LAST
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* local definitions */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
modifier|*
name|fk_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|fkval
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|fk_label
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* function key labels (if any) */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|fk_tested
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|num_strings
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fkmax
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* length of longest key */
end_comment

begin_decl_stmt
specifier|static
name|int
name|got_labels
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* true if we have some labels */
end_comment

begin_decl_stmt
specifier|static
name|int
name|key_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|end_state
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* unknown function keys */
end_comment

begin_define
define|#
directive|define
name|MAX_FK_UNK
value|50
end_define

begin_decl_stmt
specifier|static
name|char
modifier|*
name|fk_unknown
index|[
name|MAX_FK_UNK
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fk_length
index|[
name|MAX_FK_UNK
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|funk
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Initialize arrays that depend on the actual number of strings.  */
end_comment

begin_function
specifier|static
name|void
name|alloc_strings
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|num_strings
operator|!=
name|MAX_STRINGS
condition|)
block|{
name|num_strings
operator|=
name|MAX_STRINGS
expr_stmt|;
name|fk_name
operator|=
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|calloc
argument_list|(
name|num_strings
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|fkval
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|calloc
argument_list|(
name|num_strings
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|fk_label
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|calloc
argument_list|(
name|num_strings
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|fk_tested
operator|=
operator|(
name|int
operator|*
operator|)
name|calloc
argument_list|(
name|num_strings
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* **	keys_tested(first-time, show-help, hex-output) ** **	Display a list of the keys not tested. */
end_comment

begin_function
specifier|static
name|void
name|keys_tested
parameter_list|(
name|int
name|first_time
parameter_list|,
name|int
name|show_help
parameter_list|,
name|int
name|hex_output
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|l
decl_stmt|;
name|char
name|outbuf
index|[
literal|256
index|]
decl_stmt|;
name|alloc_strings
argument_list|()
expr_stmt|;
name|put_clear
argument_list|()
expr_stmt|;
name|tty_set
argument_list|()
expr_stmt|;
name|flush_input
argument_list|()
expr_stmt|;
if|if
condition|(
name|got_labels
condition|)
block|{
name|putln
argument_list|(
literal|"Function key labels:"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|key_count
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|fk_label
index|[
name|i
index|]
condition|)
block|{
name|sprintf
argument_list|(
name|outbuf
argument_list|,
literal|"%s %s"
argument_list|,
name|fk_name
index|[
name|i
index|]
condition|?
name|fk_name
index|[
name|i
index|]
else|:
literal|"??"
argument_list|,
name|fk_label
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|put_columns
argument_list|(
name|outbuf
argument_list|,
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|outbuf
argument_list|)
argument_list|,
literal|16
argument_list|)
expr_stmt|;
block|}
block|}
name|put_newlines
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|funk
condition|)
block|{
name|putln
argument_list|(
literal|"The following keys are not defined:"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|funk
condition|;
operator|++
name|i
control|)
block|{
name|put_columns
argument_list|(
name|fk_unknown
index|[
name|i
index|]
argument_list|,
name|fk_length
index|[
name|i
index|]
argument_list|,
literal|16
argument_list|)
expr_stmt|;
block|}
name|put_mode
argument_list|(
name|exit_attribute_mode
argument_list|)
expr_stmt|;
name|put_newlines
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|first_time
condition|)
block|{
name|putln
argument_list|(
literal|"The following keys are defined:"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|putln
argument_list|(
literal|"The following keys have not been tested:"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|scan_mode
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|scan_down
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|scan_tested
index|[
name|i
index|]
condition|)
block|{
if|if
condition|(
name|hex_output
condition|)
block|{
name|strcpy
argument_list|(
name|outbuf
argument_list|,
name|hex_expand_to
argument_list|(
name|scan_down
index|[
name|i
index|]
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strcpy
argument_list|(
name|outbuf
argument_list|,
name|expand
argument_list|(
name|scan_down
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|l
operator|=
name|expand_chars
expr_stmt|;
if|if
condition|(
name|hex_output
condition|)
block|{
name|strcat
argument_list|(
name|outbuf
argument_list|,
name|hex_expand_to
argument_list|(
name|scan_up
index|[
name|i
index|]
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strcat
argument_list|(
name|outbuf
argument_list|,
name|expand
argument_list|(
name|scan_up
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|expand_chars
operator|+=
name|l
expr_stmt|;
name|l
operator|=
name|strlen
argument_list|(
name|scan_name
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|char_count
operator|+
literal|16
operator|)
operator|&
operator|~
literal|15
operator|)
operator|+
operator|(
operator|(
name|expand_chars
operator|+
literal|7
operator|)
operator|&
operator|~
literal|7
operator|)
operator|+
name|l
operator|>=
name|columns
condition|)
block|{
name|put_crlf
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|char_count
operator|+
literal|24
operator|>
name|columns
condition|)
block|{
name|put_crlf
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|char_count
condition|)
block|{
name|putchp
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
name|put_columns
argument_list|(
name|outbuf
argument_list|,
name|expand_chars
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|put_columns
argument_list|(
name|scan_name
index|[
name|i
index|]
argument_list|,
name|l
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|key_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|fk_tested
index|[
name|i
index|]
condition|)
block|{
if|if
condition|(
name|hex_output
condition|)
block|{
name|strcpy
argument_list|(
name|outbuf
argument_list|,
name|hex_expand_to
argument_list|(
name|fkval
index|[
name|i
index|]
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strcpy
argument_list|(
name|outbuf
argument_list|,
name|expand
argument_list|(
name|fkval
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|l
operator|=
name|strlen
argument_list|(
name|fk_name
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|char_count
operator|+
literal|16
operator|)
operator|&
operator|~
literal|15
operator|)
operator|+
operator|(
operator|(
name|expand_chars
operator|+
literal|7
operator|)
operator|&
operator|~
literal|7
operator|)
operator|+
name|l
operator|>=
name|columns
condition|)
block|{
name|put_crlf
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|char_count
operator|+
literal|24
operator|>
name|columns
condition|)
block|{
name|put_crlf
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|char_count
condition|)
block|{
name|putchp
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
name|put_columns
argument_list|(
name|outbuf
argument_list|,
name|expand_chars
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|put_columns
argument_list|(
name|fk_name
index|[
name|i
index|]
argument_list|,
name|l
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|put_newlines
argument_list|(
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|show_help
condition|)
block|{
name|ptextln
argument_list|(
literal|"Hit any function key.  Type 'end' to quit.  Type ? to update the display."
argument_list|)
expr_stmt|;
name|put_crlf
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* **	enter_key(name, value, label) ** **	Enter a function key into the data base */
end_comment

begin_function
name|void
name|enter_key
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|char
modifier|*
name|value
parameter_list|,
name|char
modifier|*
name|lab
parameter_list|)
block|{
name|int
name|j
decl_stmt|;
name|alloc_strings
argument_list|()
expr_stmt|;
if|if
condition|(
name|value
condition|)
block|{
name|j
operator|=
name|strlen
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|fkmax
operator|=
name|fkmax
operator|>
name|j
condition|?
name|fkmax
else|:
name|j
expr_stmt|;
comment|/* do not permit duplicates */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|key_count
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|fk_name
index|[
name|j
index|]
argument_list|,
name|name
argument_list|)
condition|)
block|{
return|return;
block|}
block|}
name|fkval
index|[
name|key_count
index|]
operator|=
name|value
expr_stmt|;
name|fk_tested
index|[
name|key_count
index|]
operator|=
literal|0
expr_stmt|;
name|fk_label
index|[
name|key_count
index|]
operator|=
name|lab
expr_stmt|;
name|fk_name
index|[
name|key_count
operator|++
index|]
operator|=
name|name
expr_stmt|;
if|if
condition|(
name|lab
condition|)
block|{
name|got_labels
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|fresh_line
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* clear the line for a new function key line */
if|if
condition|(
name|over_strike
condition|)
block|{
name|put_crlf
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|put_cr
argument_list|()
expr_stmt|;
if|if
condition|(
name|clr_eol
condition|)
block|{
name|tc_putp
argument_list|(
name|clr_eol
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|put_str
argument_list|(
literal|"                    \r"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|end_funky
parameter_list|(
name|int
name|ch
parameter_list|)
block|{
comment|/* return true if this is the end */
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'e'
case|:
case|case
literal|'E'
case|:
name|end_state
operator|=
literal|'e'
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
case|case
literal|'N'
case|:
if|if
condition|(
name|end_state
operator|==
literal|'e'
condition|)
block|{
name|end_state
operator|=
literal|'n'
expr_stmt|;
block|}
else|else
block|{
name|end_state
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
literal|'d'
case|:
case|case
literal|'D'
case|:
if|if
condition|(
name|end_state
operator|==
literal|'n'
condition|)
block|{
name|end_state
operator|=
literal|'d'
expr_stmt|;
block|}
else|else
block|{
name|end_state
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
literal|'l'
case|:
case|case
literal|'L'
case|:
if|if
condition|(
name|end_state
operator|==
literal|'l'
condition|)
block|{
name|end_state
operator|=
literal|'?'
expr_stmt|;
block|}
else|else
block|{
name|end_state
operator|=
literal|'l'
expr_stmt|;
block|}
break|break;
default|default:
name|end_state
operator|=
literal|0
expr_stmt|;
break|break;
block|}
return|return
name|end_state
operator|==
literal|'d'
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|found_match
parameter_list|(
name|char
modifier|*
name|s
parameter_list|,
name|int
name|hx
parameter_list|,
name|int
name|cc
parameter_list|)
block|{
comment|/* return true if this string is a match */
name|int
name|j
decl_stmt|,
name|f
decl_stmt|;
name|char
name|outbuf
index|[
literal|256
index|]
decl_stmt|;
name|alloc_strings
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|s
condition|)
block|{
return|return
literal|0
return|;
block|}
if|if
condition|(
name|scan_mode
condition|)
block|{
for|for
control|(
name|j
operator|=
name|f
operator|=
literal|0
init|;
name|scan_down
index|[
name|j
index|]
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|scan_length
index|[
name|j
index|]
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|s
argument_list|,
name|scan_down
index|[
name|j
index|]
argument_list|,
name|scan_length
index|[
name|j
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|f
condition|)
block|{
comment|/* first match */
name|put_cr
argument_list|()
expr_stmt|;
if|if
condition|(
name|hx
condition|)
block|{
name|put_str
argument_list|(
name|hex_expand_to
argument_list|(
name|s
argument_list|,
literal|10
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|put_str
argument_list|(
name|expand_to
argument_list|(
name|s
argument_list|,
literal|10
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|f
operator|=
literal|1
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|end_funky
argument_list|(
name|scan_name
index|[
name|j
index|]
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|put_str
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|put_str
argument_list|(
name|scan_name
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|scan_tested
index|[
name|j
index|]
operator|=
literal|1
expr_stmt|;
name|s
operator|+=
name|scan_length
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|s
argument_list|,
name|scan_up
index|[
name|j
index|]
argument_list|,
name|scan_length
index|[
name|j
index|]
argument_list|)
condition|)
block|{
name|put_str
argument_list|(
literal|" scan down"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|s
operator|+=
name|scan_length
index|[
name|j
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|*
name|s
condition|)
block|{
break|break;
block|}
name|j
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|s
argument_list|,
name|scan_up
index|[
name|j
index|]
argument_list|,
name|scan_length
index|[
name|j
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|f
condition|)
block|{
comment|/* first match */
name|put_cr
argument_list|()
expr_stmt|;
if|if
condition|(
name|hx
condition|)
block|{
name|put_str
argument_list|(
name|hex_expand_to
argument_list|(
name|s
argument_list|,
literal|10
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|put_str
argument_list|(
name|expand_to
argument_list|(
name|s
argument_list|,
literal|10
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|f
operator|=
literal|1
expr_stmt|;
block|}
name|put_str
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|put_str
argument_list|(
name|scan_name
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|put_str
argument_list|(
literal|" scan up"
argument_list|)
expr_stmt|;
name|s
operator|+=
name|scan_length
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|s
condition|)
block|{
break|break;
block|}
name|j
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
for|for
control|(
name|j
operator|=
name|f
operator|=
literal|0
init|;
name|j
operator|<
name|key_count
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|s
argument_list|,
name|fkval
index|[
name|j
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|f
condition|)
block|{
comment|/* first match */
name|put_cr
argument_list|()
expr_stmt|;
if|if
condition|(
name|hx
condition|)
block|{
name|put_str
argument_list|(
name|hex_expand_to
argument_list|(
name|s
argument_list|,
literal|10
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|put_str
argument_list|(
name|expand_to
argument_list|(
name|s
argument_list|,
literal|10
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|f
operator|=
literal|1
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|outbuf
argument_list|,
literal|" (%s)"
argument_list|,
name|fk_name
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|put_str
argument_list|(
name|outbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|fk_label
index|[
name|j
index|]
condition|)
block|{
name|sprintf
argument_list|(
name|outbuf
argument_list|,
literal|"<%s>"
argument_list|,
name|fk_label
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|put_str
argument_list|(
name|outbuf
argument_list|)
expr_stmt|;
block|}
name|fk_tested
index|[
name|j
index|]
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|end_state
operator|==
literal|'?'
condition|)
block|{
name|keys_tested
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
name|hx
argument_list|)
expr_stmt|;
name|tty_raw
argument_list|(
name|cc
argument_list|,
name|char_mask
argument_list|)
expr_stmt|;
name|end_state
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|f
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|found_exit
parameter_list|(
name|char
modifier|*
name|keybuf
parameter_list|,
name|int
name|hx
parameter_list|,
name|int
name|cc
parameter_list|)
block|{
comment|/* return true if the user wants to exit */
name|int
name|j
decl_stmt|,
name|k
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|scan_mode
condition|)
block|{
if|if
condition|(
operator|*
name|keybuf
operator|==
literal|'\0'
condition|)
block|{
return|return
name|TRUE
return|;
block|}
block|}
else|else
block|{
comment|/* break is a special case */
if|if
condition|(
operator|*
name|keybuf
operator|==
literal|'\0'
condition|)
block|{
name|fresh_line
argument_list|()
expr_stmt|;
name|tty_set
argument_list|()
expr_stmt|;
name|ptext
argument_list|(
literal|"Hit X to exit: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|wait_here
argument_list|()
operator|==
literal|'X'
condition|)
block|{
return|return
name|TRUE
return|;
block|}
name|keys_tested
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
name|hx
argument_list|)
expr_stmt|;
name|tty_raw
argument_list|(
name|cc
argument_list|,
name|char_mask
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* is this the end? */
for|for
control|(
name|k
operator|=
literal|0
init|;
operator|(
name|j
operator|=
operator|(
name|keybuf
index|[
name|k
index|]
operator|&
name|STRIP_PARITY
operator|)
operator|)
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|end_funky
argument_list|(
name|j
argument_list|)
condition|)
block|{
return|return
name|TRUE
return|;
block|}
block|}
name|j
operator|=
name|TRUE
expr_stmt|;
comment|/* does he need an updated list? */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|keybuf
index|[
name|k
index|]
condition|;
name|k
operator|++
control|)
block|{
name|j
operator|&=
operator|(
name|keybuf
index|[
name|k
index|]
operator|&
name|STRIP_PARITY
operator|)
operator|==
literal|'?'
expr_stmt|;
block|}
if|if
condition|(
name|j
operator|||
name|end_state
operator|==
literal|'?'
condition|)
block|{
name|keys_tested
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
name|hx
argument_list|)
expr_stmt|;
name|tty_raw
argument_list|(
name|cc
argument_list|,
name|char_mask
argument_list|)
expr_stmt|;
name|end_state
operator|=
literal|0
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
name|put_cr
argument_list|()
expr_stmt|;
if|if
condition|(
name|hx
condition|)
block|{
name|s
operator|=
name|hex_expand_to
argument_list|(
name|keybuf
argument_list|,
literal|10
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|s
operator|=
name|expand_to
argument_list|(
name|keybuf
argument_list|,
literal|10
argument_list|)
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"%s Unknown"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|put_str
argument_list|(
name|temp
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|MAX_FK_UNK
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|j
operator|==
name|funk
condition|)
block|{
name|fk_length
index|[
name|funk
index|]
operator|=
name|expand_chars
expr_stmt|;
if|if
condition|(
operator|(
name|fk_unknown
index|[
name|funk
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
argument_list|)
operator|)
condition|)
block|{
name|strcpy
argument_list|(
name|fk_unknown
index|[
name|funk
operator|++
index|]
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|fk_length
index|[
name|j
index|]
operator|==
name|expand_chars
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|fk_unknown
index|[
name|j
index|]
argument_list|,
name|s
argument_list|)
condition|)
block|{
break|break;
block|}
block|}
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* **	funkey_keys(test_list, status, ch) ** **	Test function keys */
end_comment

begin_function
specifier|static
name|void
name|funkey_keys
parameter_list|(
name|struct
name|test_list
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|state
parameter_list|,
name|int
modifier|*
name|ch
parameter_list|)
block|{
name|char
name|keybuf
index|[
literal|256
index|]
decl_stmt|;
if|if
condition|(
name|keypad_xmit
condition|)
block|{
name|tc_putp
argument_list|(
name|keypad_xmit
argument_list|)
expr_stmt|;
block|}
name|keys_tested
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|,
name|hex_out
argument_list|)
expr_stmt|;
comment|/* also clears screen */
name|keybuf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|end_state
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|scan_mode
condition|)
block|{
name|fkmax
operator|=
name|scan_max
expr_stmt|;
block|}
name|tty_raw
argument_list|(
literal|0
argument_list|,
name|char_mask
argument_list|)
expr_stmt|;
while|while
condition|(
name|end_state
operator|!=
literal|'d'
condition|)
block|{
name|read_key
argument_list|(
name|keybuf
argument_list|,
sizeof|sizeof
argument_list|(
name|keybuf
argument_list|)
argument_list|)
expr_stmt|;
name|fresh_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|found_match
argument_list|(
name|keybuf
argument_list|,
name|hex_out
argument_list|,
literal|0
argument_list|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|found_exit
argument_list|(
name|keybuf
argument_list|,
name|hex_out
argument_list|,
literal|0
argument_list|)
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|keypad_local
condition|)
block|{
name|tc_putp
argument_list|(
name|keypad_local
argument_list|)
expr_stmt|;
block|}
name|keys_tested
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|hex_out
argument_list|)
expr_stmt|;
name|ptext
argument_list|(
literal|"Function key test "
argument_list|)
expr_stmt|;
name|generic_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|tty_meta_prep
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* print a warning before the meta key test */
if|if
condition|(
name|not_a_tty
condition|)
block|{
return|return
literal|0
return|;
block|}
if|if
condition|(
name|initial_stty_query
argument_list|(
name|TTY_8_BIT
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
name|ptext
argument_list|(
literal|"The meta key test must be run with the"
argument_list|)
expr_stmt|;
name|ptext
argument_list|(
literal|" terminal set for 8 data bits.  Two stop bits"
argument_list|)
expr_stmt|;
name|ptext
argument_list|(
literal|" may also be needed for correct display.  I will"
argument_list|)
expr_stmt|;
name|ptext
argument_list|(
literal|" transmit 8 bit data but if the terminal is set for"
argument_list|)
expr_stmt|;
name|ptextln
argument_list|(
literal|" 7 bit data, garbage may appear on the screen."
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* **	funkey_meta(test_list, status, ch) ** **	Test meta key (km) (smm) (rmm) */
end_comment

begin_function
specifier|static
name|void
name|funkey_meta
parameter_list|(
name|struct
name|test_list
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|state
parameter_list|,
name|int
modifier|*
name|ch
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|len
decl_stmt|;
name|char
name|outbuf
index|[
literal|256
index|]
decl_stmt|;
if|if
condition|(
name|has_meta_key
condition|)
block|{
name|put_crlf
argument_list|()
expr_stmt|;
if|if
condition|(
name|char_mask
operator|!=
name|ALLOW_PARITY
condition|)
block|{
if|if
condition|(
name|tty_meta_prep
argument_list|()
condition|)
block|{
name|ptext
argument_list|(
literal|"\nHit any key to continue> "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|wait_here
argument_list|()
expr_stmt|;
name|put_crlf
argument_list|()
expr_stmt|;
block|}
block|}
name|ptext
argument_list|(
literal|"Begin meta key test. (km) (smm) (rmm)  Hit any key"
argument_list|)
expr_stmt|;
name|ptext
argument_list|(
literal|" with the meta key.  The character will be"
argument_list|)
expr_stmt|;
name|ptext
argument_list|(
literal|" displayed in hex.  If the meta key is working"
argument_list|)
expr_stmt|;
name|ptext
argument_list|(
literal|" then the most significant bit will be set.  Type"
argument_list|)
expr_stmt|;
name|ptextln
argument_list|(
literal|" 'end' to exit."
argument_list|)
expr_stmt|;
name|tty_raw
argument_list|(
literal|1
argument_list|,
name|ALLOW_PARITY
argument_list|)
expr_stmt|;
name|tc_putp
argument_list|(
name|meta_on
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|j
operator|=
name|k
operator|=
name|len
operator|=
literal|0
init|;
name|i
operator|!=
literal|'e'
operator|||
name|j
operator|!=
literal|'n'
operator|||
name|k
operator|!=
literal|'d'
condition|;
control|)
block|{
name|i
operator|=
name|j
expr_stmt|;
name|j
operator|=
name|k
expr_stmt|;
name|k
operator|=
name|getchp
argument_list|(
name|ALLOW_PARITY
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|==
name|EOF
condition|)
block|{
break|break;
block|}
if|if
condition|(
operator|(
name|len
operator|+=
literal|3
operator|)
operator|>=
name|columns
condition|)
block|{
name|put_crlf
argument_list|()
expr_stmt|;
name|len
operator|=
literal|3
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|outbuf
argument_list|,
literal|"%02X "
argument_list|,
name|k
argument_list|)
expr_stmt|;
name|put_str
argument_list|(
name|outbuf
argument_list|)
expr_stmt|;
name|k
operator|&=
name|STRIP_PARITY
expr_stmt|;
block|}
name|tc_putp
argument_list|(
name|meta_off
argument_list|)
expr_stmt|;
name|put_crlf
argument_list|()
expr_stmt|;
name|tty_set
argument_list|()
expr_stmt|;
name|put_crlf
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|ptext
argument_list|(
literal|"(km) Has-meta-key is not set.  "
argument_list|)
expr_stmt|;
block|}
name|generic_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **	funkey_label(test_list, status, ch) ** **	Test labels (nlab) (smln) (pln) (rmln) (lw) (lh) */
end_comment

begin_function
specifier|static
name|void
name|funkey_label
parameter_list|(
name|struct
name|test_list
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|state
parameter_list|,
name|int
modifier|*
name|ch
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|char
name|outbuf
index|[
literal|256
index|]
decl_stmt|;
if|if
condition|(
name|num_labels
operator|==
operator|-
literal|1
condition|)
block|{
name|ptextln
argument_list|(
literal|"Your terminal has no labels. (nlab)"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"Your terminal has %d labels (nlab) that are %d characters wide (lw) and %d lines high (lh)"
argument_list|,
name|num_labels
argument_list|,
name|label_width
argument_list|,
name|label_height
argument_list|)
expr_stmt|;
name|ptext
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|ptextln
argument_list|(
literal|" Testing (smln) (pln) (rmln)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|label_on
condition|)
block|{
name|tc_putp
argument_list|(
name|label_on
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|label_width
operator|<=
literal|0
condition|)
block|{
name|label_width
operator|=
sizeof|sizeof
argument_list|(
name|outbuf
argument_list|)
operator|-
literal|1
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|num_labels
condition|;
name|i
operator|++
control|)
block|{
name|sprintf
argument_list|(
name|outbuf
argument_list|,
literal|"L%d.............................."
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|outbuf
index|[
name|label_width
index|]
operator|=
literal|'\0'
expr_stmt|;
name|tc_putp
argument_list|(
name|TPARM_2
argument_list|(
name|plab_norm
argument_list|,
name|i
argument_list|,
name|outbuf
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|label_off
condition|)
block|{
name|ptext
argument_list|(
literal|"Hit any key to remove the labels: "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|wait_here
argument_list|()
expr_stmt|;
name|tc_putp
argument_list|(
name|label_off
argument_list|)
expr_stmt|;
block|}
block|}
name|generic_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **	funkey_prog(test_list, status, ch) ** **	Test program function keys (pfx) */
end_comment

begin_function
specifier|static
name|void
name|funkey_prog
parameter_list|(
name|struct
name|test_list
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|state
parameter_list|,
name|int
modifier|*
name|ch
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|fk
decl_stmt|;
name|char
name|mm
index|[
literal|256
index|]
decl_stmt|;
name|fk
operator|=
literal|1
expr_stmt|;
comment|/* use function key 1 for now */
if|if
condition|(
name|pkey_xmit
condition|)
block|{
comment|/* test program function key */
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"(pfx) Set function key %d to transmit abc\\n"
argument_list|,
name|fk
argument_list|)
expr_stmt|;
name|ptextln
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|tc_putp
argument_list|(
name|TPARM_2
argument_list|(
name|pkey_xmit
argument_list|,
name|fk
argument_list|,
literal|"abc\n"
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"Hit function key %d\n"
argument_list|,
name|fk
argument_list|)
expr_stmt|;
name|ptextln
argument_list|(
name|temp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
operator|++
name|i
control|)
name|mm
index|[
name|i
index|]
operator|=
name|getchp
argument_list|(
name|STRIP_PARITY
argument_list|)
expr_stmt|;
name|mm
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|put_crlf
argument_list|()
expr_stmt|;
if|if
condition|(
name|mm
index|[
literal|0
index|]
operator|!=
literal|'a'
operator|||
name|mm
index|[
literal|1
index|]
operator|!=
literal|'b'
operator|||
name|mm
index|[
literal|2
index|]
operator|!=
literal|'c'
condition|)
block|{
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"Error string received was: %s"
argument_list|,
name|expand
argument_list|(
name|mm
argument_list|)
argument_list|)
expr_stmt|;
name|ptextln
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|putln
argument_list|(
literal|"Thank you\n"
argument_list|)
expr_stmt|;
block|}
name|flush_input
argument_list|()
expr_stmt|;
if|if
condition|(
name|key_f1
condition|)
block|{
name|tc_putp
argument_list|(
name|TPARM_2
argument_list|(
name|pkey_xmit
argument_list|,
name|fk
argument_list|,
name|key_f1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|ptextln
argument_list|(
literal|"Function key transmit (pfx), not present."
argument_list|)
expr_stmt|;
block|}
name|generic_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **	funkey_local(test_list, status, ch) ** **	Test program local function keys (pfloc) */
end_comment

begin_function
specifier|static
name|void
name|funkey_local
parameter_list|(
name|struct
name|test_list
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|state
parameter_list|,
name|int
modifier|*
name|ch
parameter_list|)
block|{
name|int
name|fk
decl_stmt|;
name|fk
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|pkey_local
condition|)
block|{
comment|/* test local function key */
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"(pfloc) Set function key %d to execute a clear and print \"Done!\""
argument_list|,
name|fk
argument_list|)
expr_stmt|;
name|ptextln
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"%sDone!"
argument_list|,
name|liberated
argument_list|(
name|clear_screen
argument_list|)
argument_list|)
expr_stmt|;
name|tc_putp
argument_list|(
name|TPARM_2
argument_list|(
name|pkey_local
argument_list|,
name|fk
argument_list|,
name|temp
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"Hit function key %d.  Then hit return."
argument_list|,
name|fk
argument_list|)
expr_stmt|;
name|ptextln
argument_list|(
name|temp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|wait_here
argument_list|()
expr_stmt|;
name|flush_input
argument_list|()
expr_stmt|;
if|if
condition|(
name|key_f1
operator|&&
name|pkey_xmit
condition|)
block|{
name|tc_putp
argument_list|(
name|TPARM_2
argument_list|(
name|pkey_xmit
argument_list|,
name|fk
argument_list|,
name|key_f1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|ptextln
argument_list|(
literal|"Function key execute local (pfloc), not present."
argument_list|)
expr_stmt|;
block|}
name|generic_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **	printer_on(test_list, status, ch) ** **	Test printer on/off (mc4) (mc5) (mc5i) */
end_comment

begin_function
specifier|static
name|void
name|printer_on
parameter_list|(
name|struct
name|test_list
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|state
parameter_list|,
name|int
modifier|*
name|ch
parameter_list|)
block|{
if|if
condition|(
operator|!
name|prtr_on
operator|||
operator|!
name|prtr_off
condition|)
block|{
name|ptextln
argument_list|(
literal|"Printer on/off missing. (mc5) (mc4)"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|prtr_silent
condition|)
block|{
name|ptextln
argument_list|(
literal|"Your printer is silent. (mc5i) is set."
argument_list|)
expr_stmt|;
name|tc_putp
argument_list|(
name|prtr_on
argument_list|)
expr_stmt|;
name|ptextln
argument_list|(
literal|"This line should be on the printer but not your screen. (mc5)"
argument_list|)
expr_stmt|;
name|tc_putp
argument_list|(
name|prtr_off
argument_list|)
expr_stmt|;
name|ptextln
argument_list|(
literal|"This line should be only on the screen. (mc4)"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ptextln
argument_list|(
literal|"Your printer is not silent. (mc5i) is reset."
argument_list|)
expr_stmt|;
name|tc_putp
argument_list|(
name|prtr_on
argument_list|)
expr_stmt|;
name|ptextln
argument_list|(
literal|"This line should be on the printer and the screen. (mc5)"
argument_list|)
expr_stmt|;
name|tc_putp
argument_list|(
name|prtr_off
argument_list|)
expr_stmt|;
name|ptextln
argument_list|(
literal|"This line should only be on the screen. (mc4)"
argument_list|)
expr_stmt|;
block|}
name|generic_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **	printer_mc0(test_list, status, ch) ** **	Test screen print (mc0) */
end_comment

begin_function
specifier|static
name|void
name|printer_mc0
parameter_list|(
name|struct
name|test_list
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|state
parameter_list|,
name|int
modifier|*
name|ch
parameter_list|)
block|{
if|if
condition|(
name|print_screen
condition|)
block|{
name|ptext
argument_list|(
literal|"I am going to send the contents of the screen to"
argument_list|)
expr_stmt|;
name|ptext
argument_list|(
literal|" the printer, then wait for a keystroke from you."
argument_list|)
expr_stmt|;
name|ptext
argument_list|(
literal|"  All of the text that appears on the screen"
argument_list|)
expr_stmt|;
name|ptextln
argument_list|(
literal|" should be printed. (mc0)"
argument_list|)
expr_stmt|;
name|tc_putp
argument_list|(
name|print_screen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ptext
argument_list|(
literal|"(mc0) Print-screen is not present.  "
argument_list|)
expr_stmt|;
block|}
name|generic_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|line_pattern
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* put up a pattern that will help count the 				   number of lines */
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|put_clear
argument_list|()
expr_stmt|;
if|if
condition|(
name|over_strike
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|100
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
condition|)
block|{
name|put_crlf
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
name|i
operator|/
literal|10
init|;
name|j
condition|;
name|j
operator|--
control|)
block|{
name|put_this
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
name|put_this
argument_list|(
literal|'0'
operator|+
operator|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|%
literal|10
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
comment|/* I assume it will scroll */
block|{
for|for
control|(
name|i
operator|=
literal|100
init|;
name|i
condition|;
name|i
operator|--
control|)
block|{
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"\r\n%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|put_str
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|column_pattern
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* put up a pattern that will help count the 				   number of columns */
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|put_clear
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|20
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
literal|10
condition|;
name|j
operator|++
control|)
block|{
name|put_this
argument_list|(
literal|'0'
operator|+
name|j
argument_list|)
expr_stmt|;
block|}
name|put_this
argument_list|(
literal|'.'
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* **	report_help() ** **	Print the help text for the echo tests */
end_comment

begin_function
specifier|static
name|void
name|report_help
parameter_list|(
name|int
name|crx
parameter_list|)
block|{
name|ptextln
argument_list|(
literal|"The following commands may also be entered:"
argument_list|)
expr_stmt|;
name|ptextln
argument_list|(
literal|" clear   clear screen."
argument_list|)
expr_stmt|;
name|ptextln
argument_list|(
literal|" columns print a test pattern to help count screen width."
argument_list|)
expr_stmt|;
name|ptextln
argument_list|(
literal|" lines   print a test pattern to help count screen length."
argument_list|)
expr_stmt|;
name|ptextln
argument_list|(
literal|" end     exit."
argument_list|)
expr_stmt|;
name|ptextln
argument_list|(
literal|" echo    redisplay last report."
argument_list|)
expr_stmt|;
if|if
condition|(
name|crx
condition|)
block|{
name|ptextln
argument_list|(
literal|" hex     redisplay last report in hex."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ptextln
argument_list|(
literal|" hex     toggle hex display mode."
argument_list|)
expr_stmt|;
block|}
name|ptextln
argument_list|(
literal|" help    display this list."
argument_list|)
expr_stmt|;
name|ptextln
argument_list|(
literal|" high    toggle forced high bit (0x80)."
argument_list|)
expr_stmt|;
name|ptextln
argument_list|(
literal|" scan    toggle scan mode."
argument_list|)
expr_stmt|;
name|ptextln
argument_list|(
literal|" one     echo one character after<cr> or<lf> as is. (report mode)"
argument_list|)
expr_stmt|;
name|ptextln
argument_list|(
literal|" two     echo two characters after<cr> or<lf> as is."
argument_list|)
expr_stmt|;
name|ptextln
argument_list|(
literal|" all     echo all characters after<cr> or<lf> as is. (echo mode)"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **	tools_report(testlist, state, ch) ** **	Run the echo tool and report tool */
end_comment

begin_function
name|void
name|tools_report
parameter_list|(
name|struct
name|test_list
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|state
name|GCC_UNUSED
parameter_list|,
name|int
modifier|*
name|pch
name|GCC_UNUSED
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|ch
decl_stmt|,
name|crp
decl_stmt|,
name|crx
decl_stmt|,
name|high_bit
decl_stmt|,
name|save_scan_mode
decl_stmt|,
name|hex_display
decl_stmt|;
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
name|char
name|txt
index|[
literal|8
index|]
decl_stmt|;
name|hex_display
operator|=
name|hex_out
expr_stmt|;
name|put_clear
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|crx
operator|=
operator|(
name|t
operator|->
name|flags
operator|&
literal|255
operator|)
operator|)
operator|==
literal|1
condition|)
block|{
name|ptext
argument_list|(
literal|"Characters after a CR or LF will be echoed as"
argument_list|)
expr_stmt|;
name|ptextln
argument_list|(
literal|" is.  All other characters will be expanded."
argument_list|)
expr_stmt|;
name|report_help
argument_list|(
name|crx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* echo test */
name|ptextln
argument_list|(
literal|"Begin echo test."
argument_list|)
expr_stmt|;
name|report_help
argument_list|(
name|crx
argument_list|)
expr_stmt|;
block|}
name|memset
argument_list|(
name|txt
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|txt
argument_list|)
argument_list|)
expr_stmt|;
name|save_scan_mode
operator|=
name|scan_mode
expr_stmt|;
name|tty_raw
argument_list|(
literal|1
argument_list|,
name|char_mask
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|crp
operator|=
name|high_bit
operator|=
literal|0
init|;
condition|;
control|)
block|{
name|ch
operator|=
name|getchp
argument_list|(
name|char_mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|EOF
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|i
operator|>=
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
condition|)
block|{
name|i
operator|=
literal|0
expr_stmt|;
block|}
name|buf
index|[
name|i
operator|++
index|]
operator|=
name|ch
expr_stmt|;
name|buf
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|txt
argument_list|)
operator|-
literal|1
condition|;
name|j
operator|++
control|)
block|{
name|txt
index|[
name|j
index|]
operator|=
name|txt
index|[
name|j
operator|+
literal|1
index|]
expr_stmt|;
block|}
name|txt
index|[
sizeof|sizeof
argument_list|(
name|txt
argument_list|)
operator|-
literal|1
index|]
operator|=
name|ch
operator|&
name|STRIP_PARITY
expr_stmt|;
if|if
condition|(
name|crx
operator|==
literal|0
condition|)
block|{
comment|/* echo test */
if|if
condition|(
name|hex_display
condition|)
block|{
name|ptext
argument_list|(
name|hex_expand_to
argument_list|(
operator|&
name|buf
index|[
name|i
operator|-
literal|1
index|]
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tc_putch
argument_list|(
name|ch
operator||
name|high_bit
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
comment|/* status report test */
if|if
condition|(
name|ch
operator|==
literal|'\n'
operator|||
name|ch
operator|==
literal|'\r'
condition|)
block|{
name|put_crlf
argument_list|()
expr_stmt|;
name|crp
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|crp
operator|++
operator|<
name|crx
condition|)
block|{
name|tc_putch
argument_list|(
name|ch
operator||
name|high_bit
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|put_str
argument_list|(
name|expand
argument_list|(
operator|&
name|buf
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|strncmp
argument_list|(
operator|&
name|txt
index|[
sizeof|sizeof
argument_list|(
name|txt
argument_list|)
operator|-
literal|7
index|]
argument_list|,
literal|"columns"
argument_list|,
literal|7
argument_list|)
condition|)
block|{
name|column_pattern
argument_list|()
expr_stmt|;
name|buf
index|[
name|i
operator|=
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|crp
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|strncmp
argument_list|(
operator|&
name|txt
index|[
sizeof|sizeof
argument_list|(
name|txt
argument_list|)
operator|-
literal|5
index|]
argument_list|,
literal|"lines"
argument_list|,
literal|5
argument_list|)
condition|)
block|{
name|line_pattern
argument_list|()
expr_stmt|;
name|buf
index|[
name|i
operator|=
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|crp
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|strncmp
argument_list|(
operator|&
name|txt
index|[
sizeof|sizeof
argument_list|(
name|txt
argument_list|)
operator|-
literal|5
index|]
argument_list|,
literal|"clear"
argument_list|,
literal|5
argument_list|)
condition|)
block|{
name|put_clear
argument_list|()
expr_stmt|;
name|buf
index|[
name|i
operator|=
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|crp
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|strncmp
argument_list|(
operator|&
name|txt
index|[
sizeof|sizeof
argument_list|(
name|txt
argument_list|)
operator|-
literal|4
index|]
argument_list|,
literal|"high"
argument_list|,
literal|4
argument_list|)
condition|)
block|{
name|high_bit
operator|^=
literal|0x80
expr_stmt|;
if|if
condition|(
name|high_bit
condition|)
block|{
name|ptextln
argument_list|(
literal|"\nParity bit set"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ptextln
argument_list|(
literal|"\nParity bit reset"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|strncmp
argument_list|(
operator|&
name|txt
index|[
sizeof|sizeof
argument_list|(
name|txt
argument_list|)
operator|-
literal|4
index|]
argument_list|,
literal|"help"
argument_list|,
literal|4
argument_list|)
condition|)
block|{
name|put_crlf
argument_list|()
expr_stmt|;
name|report_help
argument_list|(
name|crx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|strncmp
argument_list|(
operator|&
name|txt
index|[
sizeof|sizeof
argument_list|(
name|txt
argument_list|)
operator|-
literal|4
index|]
argument_list|,
literal|"echo"
argument_list|,
literal|4
argument_list|)
condition|)
block|{
comment|/* display the last status report */
comment|/* clear bypass condition on Tek terminals */
name|put_crlf
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|4
condition|)
block|{
name|buf
index|[
name|i
operator|-=
literal|4
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|put_str
argument_list|(
name|expand
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|save_scan_mode
operator|&&
operator|!
name|strncmp
argument_list|(
operator|&
name|txt
index|[
sizeof|sizeof
argument_list|(
name|txt
argument_list|)
operator|-
literal|4
index|]
argument_list|,
literal|"scan"
argument_list|,
literal|4
argument_list|)
condition|)
block|{
comment|/* toggle scan mode */
name|scan_mode
operator|=
operator|!
name|scan_mode
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|strncmp
argument_list|(
operator|&
name|txt
index|[
sizeof|sizeof
argument_list|(
name|txt
argument_list|)
operator|-
literal|3
index|]
argument_list|,
literal|"end"
argument_list|,
literal|3
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
operator|&
name|txt
index|[
sizeof|sizeof
argument_list|(
name|txt
argument_list|)
operator|-
literal|3
index|]
argument_list|,
literal|"hex"
argument_list|,
literal|3
argument_list|)
condition|)
block|{
if|if
condition|(
name|crx
condition|)
block|{
comment|/* display the last status report in hex */
comment|/* clear bypass condition on Tek terminals */
name|put_crlf
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|3
condition|)
block|{
name|buf
index|[
name|i
operator|-=
literal|3
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|put_str
argument_list|(
name|hex_expand_to
argument_list|(
name|buf
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|hex_display
operator|=
operator|!
name|hex_display
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|strncmp
argument_list|(
operator|&
name|txt
index|[
sizeof|sizeof
argument_list|(
name|txt
argument_list|)
operator|-
literal|3
index|]
argument_list|,
literal|"two"
argument_list|,
literal|3
argument_list|)
condition|)
name|crx
operator|=
literal|2
expr_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
operator|&
name|txt
index|[
sizeof|sizeof
argument_list|(
name|txt
argument_list|)
operator|-
literal|3
index|]
argument_list|,
literal|"one"
argument_list|,
literal|3
argument_list|)
condition|)
name|crx
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
operator|&
name|txt
index|[
sizeof|sizeof
argument_list|(
name|txt
argument_list|)
operator|-
literal|3
index|]
argument_list|,
literal|"all"
argument_list|,
literal|3
argument_list|)
condition|)
name|crx
operator|=
literal|0
expr_stmt|;
block|}
name|scan_mode
operator|=
name|save_scan_mode
expr_stmt|;
name|put_crlf
argument_list|()
expr_stmt|;
name|tty_set
argument_list|()
expr_stmt|;
if|if
condition|(
name|crx
condition|)
block|{
name|ptextln
argument_list|(
literal|"End of status report test."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ptextln
argument_list|(
literal|"End of echo test."
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

