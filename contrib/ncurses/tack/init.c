begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ** Copyright (C) 1991, 1997 Free Software Foundation, Inc. ** ** This file is part of TACK. ** ** TACK is free software; you can redistribute it and/or modify ** it under the terms of the GNU General Public License as published by ** the Free Software Foundation; either version 2, or (at your option) ** any later version. ** ** TACK is distributed in the hope that it will be useful, ** but WITHOUT ANY WARRANTY; without even the implied warranty of ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ** GNU General Public License for more details. ** ** You should have received a copy of the GNU General Public License ** along with TACK; see the file COPYING.  If not, write to ** the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, ** Boston, MA 02110-1301, USA */
end_comment

begin_comment
comment|/* initialization and wrapup code */
end_comment

begin_include
include|#
directive|include
file|<tack.h>
end_include

begin_macro
name|MODULE_ID
argument_list|(
literal|"$Id: init.c,v 1.7 2006/11/26 00:16:01 tom Exp $"
argument_list|)
end_macro

begin_if
if|#
directive|if
name|NCURSES_VERSION_MAJOR
operator|>=
literal|5
operator|||
name|NCURSES_VERSION_PATCH
operator|>=
literal|981219
end_if

begin_define
define|#
directive|define
name|_nc_get_curterm
parameter_list|(
name|p
parameter_list|)
value|_nc_get_tty_mode(p)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|FILE
modifier|*
name|debug_fp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|temp
index|[
literal|1024
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|tty_basename
index|[
literal|64
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|put_name
parameter_list|(
specifier|const
name|char
modifier|*
name|cap
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
comment|/* send the cap name followed by the cap */
if|if
condition|(
name|cap
condition|)
block|{
name|ptext
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|tc_putp
argument_list|(
name|cap
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|report_cap
parameter_list|(
specifier|const
name|char
modifier|*
name|tag
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
comment|/* expand the cap or print *** missing *** */
name|int
name|i
decl_stmt|;
name|ptext
argument_list|(
name|tag
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|char_count
init|;
name|i
operator|<
literal|13
condition|;
name|i
operator|++
control|)
block|{
name|putchp
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
name|put_str
argument_list|(
literal|" = "
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
condition|)
block|{
name|putln
argument_list|(
name|expand
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|putln
argument_list|(
literal|"*** missing ***"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|reset_init
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* send the reset and init strings */
name|int
name|i
decl_stmt|;
name|ptext
argument_list|(
literal|"Terminal reset"
argument_list|)
expr_stmt|;
name|i
operator|=
name|char_count
expr_stmt|;
name|put_name
argument_list|(
name|reset_1string
argument_list|,
literal|" (rs1)"
argument_list|)
expr_stmt|;
name|put_name
argument_list|(
name|reset_2string
argument_list|,
literal|" (rs2)"
argument_list|)
expr_stmt|;
comment|/* run the reset file */
if|if
condition|(
name|reset_file
operator|&&
name|reset_file
index|[
literal|0
index|]
condition|)
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|int
name|ch
decl_stmt|;
name|can_test
argument_list|(
literal|"rf"
argument_list|,
name|FLAG_TESTED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|reset_file
argument_list|,
literal|"r"
argument_list|)
operator|)
condition|)
block|{
comment|/* send the reset file */
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|" (rf) %s"
argument_list|,
name|reset_file
argument_list|)
expr_stmt|;
name|ptextln
argument_list|(
name|temp
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|ch
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|EOF
condition|)
break|break;
name|put_this
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"\nCannot open reset file (rf) %s"
argument_list|,
name|reset_file
argument_list|)
expr_stmt|;
name|ptextln
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
block|}
name|put_name
argument_list|(
name|reset_3string
argument_list|,
literal|" (rs3)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|char_count
condition|)
block|{
name|put_crlf
argument_list|()
expr_stmt|;
block|}
name|ptext
argument_list|(
literal|" init"
argument_list|)
expr_stmt|;
name|put_name
argument_list|(
name|init_1string
argument_list|,
literal|" (is1)"
argument_list|)
expr_stmt|;
name|put_name
argument_list|(
name|init_2string
argument_list|,
literal|" (is2)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|set_tab
operator|&&
name|clear_all_tabs
operator|&&
name|init_tabs
operator|!=
literal|8
condition|)
block|{
name|put_crlf
argument_list|()
expr_stmt|;
name|tc_putp
argument_list|(
name|clear_all_tabs
argument_list|)
expr_stmt|;
for|for
control|(
name|char_count
operator|=
literal|0
init|;
name|char_count
operator|<
name|columns
condition|;
name|char_count
operator|++
control|)
block|{
name|put_this
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|char_count
operator|&
literal|7
operator|)
operator|==
literal|7
condition|)
block|{
name|tc_putp
argument_list|(
name|set_tab
argument_list|)
expr_stmt|;
block|}
block|}
name|put_cr
argument_list|()
expr_stmt|;
block|}
comment|/* run the initialization file */
if|if
condition|(
name|init_file
operator|&&
name|init_file
index|[
literal|0
index|]
condition|)
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|int
name|ch
decl_stmt|;
name|can_test
argument_list|(
literal|"if"
argument_list|,
name|FLAG_TESTED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|init_file
argument_list|,
literal|"r"
argument_list|)
operator|)
condition|)
block|{
comment|/* send the init file */
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|" (if) %s"
argument_list|,
name|init_file
argument_list|)
expr_stmt|;
name|ptextln
argument_list|(
name|temp
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|ch
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|EOF
condition|)
break|break;
name|put_this
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"\nCannot open init file (if) %s"
argument_list|,
name|init_file
argument_list|)
expr_stmt|;
name|ptextln
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|init_prog
condition|)
block|{
name|can_test
argument_list|(
literal|"iprog"
argument_list|,
name|FLAG_TESTED
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|system
argument_list|(
name|init_prog
argument_list|)
expr_stmt|;
block|}
name|put_name
argument_list|(
name|init_3string
argument_list|,
literal|" (is3)"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **	display_basic() ** **	display the basic terminal definitions */
end_comment

begin_function
name|void
name|display_basic
parameter_list|(
name|void
parameter_list|)
block|{
name|put_str
argument_list|(
literal|"Name: "
argument_list|)
expr_stmt|;
name|putln
argument_list|(
name|ttytype
argument_list|)
expr_stmt|;
name|report_cap
argument_list|(
literal|"\\r ^M (cr)"
argument_list|,
name|carriage_return
argument_list|)
expr_stmt|;
name|report_cap
argument_list|(
literal|"\\n ^J (ind)"
argument_list|,
name|scroll_forward
argument_list|)
expr_stmt|;
name|report_cap
argument_list|(
literal|"\\b ^H (cub1)"
argument_list|,
name|cursor_left
argument_list|)
expr_stmt|;
name|report_cap
argument_list|(
literal|"\\t ^I (ht)"
argument_list|,
name|tab
argument_list|)
expr_stmt|;
comment|/*      report_cap("\\f ^L (ff)", form_feed);	*/
if|if
condition|(
name|newline
condition|)
block|{
comment|/* OK if missing */
name|report_cap
argument_list|(
literal|"      (nel)"
argument_list|,
name|newline
argument_list|)
expr_stmt|;
block|}
name|report_cap
argument_list|(
literal|"      (clear)"
argument_list|,
name|clear_screen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cursor_home
operator|&&
name|cursor_address
condition|)
block|{
name|report_cap
argument_list|(
literal|"(cup) (home)"
argument_list|,
name|TPARM_2
argument_list|(
name|cursor_address
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|report_cap
argument_list|(
literal|"      (home)"
argument_list|,
name|cursor_home
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|user9
name|report_cap
argument_list|(
literal|"ENQ   (u9)"
argument_list|,
name|user9
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|user8
name|report_cap
argument_list|(
literal|"ACK   (u8)"
argument_list|,
name|user8
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"\nTerminal size: %d x %d.  Baud rate: %u.  Frame size: %d.%d"
argument_list|,
name|columns
argument_list|,
name|lines
argument_list|,
name|tty_baud_rate
argument_list|,
name|tty_frame_size
operator|>>
literal|1
argument_list|,
operator|(
name|tty_frame_size
operator|&
literal|1
operator|)
operator|*
literal|5
argument_list|)
expr_stmt|;
name|putln
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **	curses_setup(exec_name) ** **	Startup ncurses */
end_comment

begin_function
name|void
name|curses_setup
parameter_list|(
name|char
modifier|*
name|exec_name
parameter_list|)
block|{
name|int
name|status
decl_stmt|;
specifier|static
name|TERMTYPE
name|term
decl_stmt|;
name|char
name|tty_filename
index|[
literal|2048
index|]
decl_stmt|;
name|tty_init
argument_list|()
expr_stmt|;
comment|/** 	   See if the terminal is in the terminfo data base.  This call has 	two useful benefits, 1) it returns the filename of the terminfo entry, 	and 2) it searches only terminfo's.  This allows us to abort before 	ncurses starts scanning the termcap file. 	**/
if|if
condition|(
operator|(
name|status
operator|=
name|_nc_read_entry
argument_list|(
name|tty_basename
argument_list|,
name|tty_filename
argument_list|,
operator|&
name|term
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
specifier|const
name|TERMTYPE
modifier|*
name|fallback
init|=
name|_nc_fallback
argument_list|(
name|tty_basename
argument_list|)
decl_stmt|;
if|if
condition|(
name|fallback
condition|)
block|{
name|term
operator|=
operator|*
name|fallback
expr_stmt|;
name|sprintf
argument_list|(
name|tty_filename
argument_list|,
literal|"(fallback)%s"
argument_list|,
name|tty_basename
argument_list|)
expr_stmt|;
name|status
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Terminal not found: TERM=%s\n"
argument_list|,
name|tty_basename
argument_list|)
expr_stmt|;
name|show_usage
argument_list|(
name|exec_name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|status
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Terminfo database is inaccessible\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/** 	   This call will load the terminfo data base and set the cur-term 	variable.  Only terminals that actually exist will get here so its 	OK to ignore errors.  This is a good thing since ncurses does not 	permit (os) or (gn) to be set. 	**/
name|setupterm
argument_list|(
name|tty_basename
argument_list|,
literal|1
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
comment|/** 	   Get the current terminal definitions.  This must be done before 	getting the baudrate. 	**/
name|_nc_get_curterm
argument_list|(
operator|&
name|cur_term
operator|->
name|Nttyb
argument_list|)
expr_stmt|;
name|tty_baud_rate
operator|=
name|baudrate
argument_list|()
expr_stmt|;
name|tty_cps
operator|=
operator|(
name|tty_baud_rate
operator|<<
literal|1
operator|)
operator|/
name|tty_frame_size
expr_stmt|;
comment|/* set up the defaults */
name|replace_mode
operator|=
name|TRUE
expr_stmt|;
name|scan_mode
operator|=
literal|0
expr_stmt|;
name|char_count
operator|=
literal|0
expr_stmt|;
name|select_delay_type
operator|=
name|debug_level
operator|=
literal|0
expr_stmt|;
name|char_mask
operator|=
operator|(
name|meta_on
operator|&&
name|meta_on
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|)
condition|?
name|ALLOW_PARITY
else|:
name|STRIP_PARITY
expr_stmt|;
comment|/* Don't change the XON/XOFF modes yet. */
name|select_xon_xoff
operator|=
name|initial_stty_query
argument_list|(
name|TTY_XON_XOFF
argument_list|)
condition|?
literal|1
else|:
name|needs_xon_xoff
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
comment|/* flush any output */
name|tty_set
argument_list|()
expr_stmt|;
name|go_home
argument_list|()
expr_stmt|;
comment|/* set can_go_home */
name|put_clear
argument_list|()
expr_stmt|;
comment|/* set can_clear_screen */
if|if
condition|(
name|send_reset_init
condition|)
block|{
name|reset_init
argument_list|()
expr_stmt|;
block|}
comment|/* 	   I assume that the reset and init strings may not have the correct 	   pads.  (Because that part of the test comes much later.)  Because 	   of this, I allow the terminal some time to catch up. 	*/
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
comment|/* waste some time */
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* waste more time */
name|charset_can_test
argument_list|()
expr_stmt|;
name|can_test
argument_list|(
literal|"lines cols cr nxon rf if iprog rmp smcup rmcup"
argument_list|,
name|FLAG_CAN_TEST
argument_list|)
expr_stmt|;
name|edit_init
argument_list|()
expr_stmt|;
comment|/* initialize the edit data base */
if|if
condition|(
name|send_reset_init
operator|&&
name|enter_ca_mode
condition|)
block|{
name|tc_putp
argument_list|(
name|enter_ca_mode
argument_list|)
expr_stmt|;
name|put_clear
argument_list|()
expr_stmt|;
comment|/* just in case we switched pages */
block|}
name|put_crlf
argument_list|()
expr_stmt|;
name|ptext
argument_list|(
literal|"Using terminfo from: "
argument_list|)
expr_stmt|;
name|ptextln
argument_list|(
name|tty_filename
argument_list|)
expr_stmt|;
name|put_crlf
argument_list|()
expr_stmt|;
if|if
condition|(
name|tty_can_sync
operator|==
name|SYNC_NEEDED
condition|)
block|{
name|verify_time
argument_list|()
expr_stmt|;
block|}
name|display_basic
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **	bye_kids(exit-condition) ** **	Shutdown the terminal, clear the signals, and exit */
end_comment

begin_function
name|void
name|bye_kids
parameter_list|(
name|int
name|n
parameter_list|)
block|{
comment|/* reset the tty and exit */
name|ignoresig
argument_list|()
expr_stmt|;
if|if
condition|(
name|send_reset_init
condition|)
block|{
if|if
condition|(
name|exit_ca_mode
condition|)
block|{
name|tc_putp
argument_list|(
name|exit_ca_mode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|initial_stty_query
argument_list|(
name|TTY_XON_XOFF
argument_list|)
condition|)
block|{
if|if
condition|(
name|enter_xon_mode
condition|)
block|{
name|tc_putp
argument_list|(
name|enter_xon_mode
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|exit_xon_mode
condition|)
block|{
name|tc_putp
argument_list|(
name|exit_xon_mode
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|debug_fp
condition|)
block|{
name|fclose
argument_list|(
name|debug_fp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|log_fp
condition|)
block|{
name|fclose
argument_list|(
name|log_fp
argument_list|)
expr_stmt|;
block|}
name|tty_reset
argument_list|()
expr_stmt|;
name|fclose
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|not_a_tty
condition|)
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

