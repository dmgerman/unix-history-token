begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ** Copyright (C) 1991, 1997 Free Software Foundation, Inc. **  ** This file is part of TACK. **  ** TACK is free software; you can redistribute it and/or modify ** it under the terms of the GNU General Public License as published by ** the Free Software Foundation; either version 2, or (at your option) ** any later version. **  ** TACK is distributed in the hope that it will be useful, ** but WITHOUT ANY WARRANTY; without even the implied warranty of ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ** GNU General Public License for more details. **  ** You should have received a copy of the GNU General Public License ** along with TACK; see the file COPYING.  If not, write to ** the Free Software Foundation, Inc., 59 Temple Place - Suite 330, ** Boston, MA 02111-1307, USA. */
end_comment

begin_include
include|#
directive|include
file|<tack.h>
end_include

begin_macro
name|MODULE_ID
argument_list|(
literal|"$Id: crum.c,v 1.3 2000/03/04 21:09:18 tom Exp $"
argument_list|)
end_macro

begin_comment
comment|/*  * Test cursor movement.  */
end_comment

begin_function_decl
specifier|static
name|void
name|crum_clear
parameter_list|(
name|struct
name|test_list
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|state
parameter_list|,
name|int
modifier|*
name|ch
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|crum_home
parameter_list|(
name|struct
name|test_list
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|state
parameter_list|,
name|int
modifier|*
name|ch
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|crum_ll
parameter_list|(
name|struct
name|test_list
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|state
parameter_list|,
name|int
modifier|*
name|ch
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|crum_move
parameter_list|(
name|struct
name|test_list
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|state
parameter_list|,
name|int
modifier|*
name|ch
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|crum_os
parameter_list|(
name|struct
name|test_list
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|state
parameter_list|,
name|int
modifier|*
name|ch
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|char
name|crum_text
index|[
literal|5
index|]
index|[
literal|80
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|test_list
name|crum_test_list
index|[]
init|=
block|{
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|"e) edit terminfo"
block|,
literal|0
block|,
operator|&
name|edit_menu
block|}
block|,
block|{
name|MENU_NEXT
block|,
literal|0
block|,
literal|"clear"
block|,
literal|0
block|,
literal|0
block|,
name|crum_clear
block|,
literal|0
block|}
block|,
block|{
name|MENU_NEXT
block|,
literal|0
block|,
literal|"home"
block|,
literal|0
block|,
literal|0
block|,
name|crum_home
block|,
literal|0
block|}
block|,
block|{
name|MENU_NEXT
block|,
literal|0
block|,
literal|"ll"
block|,
literal|0
block|,
literal|0
block|,
name|crum_ll
block|,
literal|0
block|}
block|,
block|{
name|MENU_NEXT
block|,
literal|0
block|,
name|crum_text
index|[
literal|0
index|]
block|,
literal|"home cuu1"
block|,
literal|0
block|,
name|crum_move
block|,
literal|0
block|}
block|,
block|{
name|MENU_NEXT
operator|+
literal|1
block|,
literal|0
block|,
name|crum_text
index|[
literal|1
index|]
block|,
literal|"cub1 cud1 cuf1 cuu1"
block|,
literal|0
block|,
name|crum_move
block|,
literal|0
block|}
block|,
block|{
name|MENU_NEXT
operator|+
literal|2
block|,
literal|0
block|,
name|crum_text
index|[
literal|2
index|]
block|,
literal|"cub cud cuf cuu"
block|,
literal|0
block|,
name|crum_move
block|,
literal|0
block|}
block|,
block|{
name|MENU_NEXT
operator|+
literal|3
block|,
literal|0
block|,
name|crum_text
index|[
literal|3
index|]
block|,
literal|"vpa hpa"
block|,
literal|0
block|,
name|crum_move
block|,
literal|0
block|}
block|,
block|{
name|MENU_NEXT
operator|+
literal|4
block|,
literal|0
block|,
name|crum_text
index|[
literal|4
index|]
block|,
literal|"cup"
block|,
literal|0
block|,
name|crum_move
block|,
literal|0
block|}
block|,
block|{
name|MENU_NEXT
block|,
literal|0
block|,
literal|"cup"
block|,
literal|"os"
block|,
literal|0
block|,
name|crum_os
block|,
literal|0
block|}
block|,
block|{
name|MENU_LAST
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* **	move_to(from-row, from-column, to-row, to-column, selection) ** **	move the cursor from (rf, cf) to (rt, ct) using sel */
end_comment

begin_function
specifier|static
name|void
name|move_to
parameter_list|(
name|int
name|rf
parameter_list|,
name|int
name|cf
parameter_list|,
name|int
name|rt
parameter_list|,
name|int
name|ct
parameter_list|,
name|int
name|sel
parameter_list|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|sel
operator|&
literal|16
condition|)
block|{
comment|/* use (cup) */
name|s
operator|=
name|tparm
argument_list|(
name|cursor_address
argument_list|,
name|rt
argument_list|,
name|ct
argument_list|)
expr_stmt|;
name|tputs
argument_list|(
name|s
argument_list|,
name|lines
argument_list|,
name|tc_putch
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|sel
operator|&
literal|8
condition|)
block|{
comment|/* use (hpa) (vpa) */
if|if
condition|(
name|column_address
condition|)
block|{
name|s
operator|=
name|tparm
argument_list|(
name|column_address
argument_list|,
name|ct
argument_list|)
expr_stmt|;
name|tputs
argument_list|(
name|s
argument_list|,
literal|1
argument_list|,
name|tc_putch
argument_list|)
expr_stmt|;
name|cf
operator|=
name|ct
expr_stmt|;
block|}
if|if
condition|(
name|row_address
condition|)
block|{
name|s
operator|=
name|tparm
argument_list|(
name|row_address
argument_list|,
name|rt
argument_list|)
expr_stmt|;
name|tputs
argument_list|(
name|s
argument_list|,
literal|1
argument_list|,
name|tc_putch
argument_list|)
expr_stmt|;
name|rf
operator|=
name|rt
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sel
operator|&
literal|4
condition|)
block|{
comment|/* parameterized relative cursor movement */
if|if
condition|(
name|parm_right_cursor
condition|)
if|if
condition|(
name|cf
operator|<
name|ct
condition|)
block|{
name|s
operator|=
name|tparm
argument_list|(
name|parm_right_cursor
argument_list|,
name|ct
operator|-
name|cf
argument_list|)
expr_stmt|;
name|tputs
argument_list|(
name|s
argument_list|,
name|ct
operator|-
name|cf
argument_list|,
name|tc_putch
argument_list|)
expr_stmt|;
name|cf
operator|=
name|ct
expr_stmt|;
block|}
if|if
condition|(
name|parm_left_cursor
condition|)
if|if
condition|(
name|cf
operator|>
name|ct
condition|)
block|{
name|s
operator|=
name|tparm
argument_list|(
name|parm_left_cursor
argument_list|,
name|cf
operator|-
name|ct
argument_list|)
expr_stmt|;
name|tputs
argument_list|(
name|s
argument_list|,
name|cf
operator|-
name|ct
argument_list|,
name|tc_putch
argument_list|)
expr_stmt|;
name|cf
operator|=
name|ct
expr_stmt|;
block|}
if|if
condition|(
name|parm_down_cursor
condition|)
if|if
condition|(
name|rf
operator|<
name|rt
condition|)
block|{
name|s
operator|=
name|tparm
argument_list|(
name|parm_down_cursor
argument_list|,
name|rt
operator|-
name|rf
argument_list|)
expr_stmt|;
name|tputs
argument_list|(
name|s
argument_list|,
name|rt
operator|-
name|rf
argument_list|,
name|tc_putch
argument_list|)
expr_stmt|;
name|rf
operator|=
name|rt
expr_stmt|;
block|}
if|if
condition|(
name|parm_up_cursor
condition|)
if|if
condition|(
name|rf
operator|>
name|rt
condition|)
block|{
name|s
operator|=
name|tparm
argument_list|(
name|parm_up_cursor
argument_list|,
name|rf
operator|-
name|rt
argument_list|)
expr_stmt|;
name|tputs
argument_list|(
name|s
argument_list|,
name|rf
operator|-
name|rt
argument_list|,
name|tc_putch
argument_list|)
expr_stmt|;
name|rf
operator|=
name|rt
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sel
operator|&
literal|2
condition|)
block|{
if|if
condition|(
name|cursor_left
condition|)
while|while
condition|(
name|cf
operator|>
name|ct
condition|)
block|{
name|tc_putp
argument_list|(
name|cursor_left
argument_list|)
expr_stmt|;
name|cf
operator|--
expr_stmt|;
block|}
comment|/* 		   do vertical motion next.  Just in case cursor_down has a 		   side effect of changing the column.  This could happen if 		   the tty handler translates NL to CRNL. 		*/
if|if
condition|(
name|cursor_down
condition|)
while|while
condition|(
name|rf
operator|<
name|rt
condition|)
block|{
name|tc_putp
argument_list|(
name|cursor_down
argument_list|)
expr_stmt|;
name|rf
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|cursor_up
condition|)
while|while
condition|(
name|rf
operator|>
name|rt
condition|)
block|{
name|tc_putp
argument_list|(
name|cursor_up
argument_list|)
expr_stmt|;
name|rf
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|cursor_right
condition|)
while|while
condition|(
name|cf
operator|<
name|ct
condition|)
block|{
name|tc_putp
argument_list|(
name|cursor_right
argument_list|)
expr_stmt|;
name|cf
operator|++
expr_stmt|;
block|}
block|}
comment|/* last chance */
if|if
condition|(
name|rf
operator|>
name|rt
condition|)
block|{
if|if
condition|(
name|can_go_home
condition|)
block|{
comment|/* a bit drastic but ... */
name|go_home
argument_list|()
expr_stmt|;
name|cf
operator|=
literal|0
expr_stmt|;
name|rf
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cursor_up
condition|)
block|{
while|while
condition|(
name|rf
operator|>
name|rt
condition|)
block|{
name|tc_putp
argument_list|(
name|cursor_up
argument_list|)
expr_stmt|;
name|rf
operator|--
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|ct
operator|==
literal|0
operator|&&
name|rt
operator|>
name|rf
condition|)
block|{
name|put_crlf
argument_list|()
expr_stmt|;
name|cf
operator|=
literal|0
expr_stmt|;
name|rf
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|ct
operator|==
literal|0
operator|&&
name|cf
operator|!=
literal|0
condition|)
block|{
name|put_cr
argument_list|()
expr_stmt|;
name|cf
operator|=
literal|0
expr_stmt|;
block|}
while|while
condition|(
name|rf
operator|<
name|rt
condition|)
block|{
name|put_lf
argument_list|()
expr_stmt|;
name|rf
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|cf
operator|>
name|ct
condition|)
block|{
name|put_str
argument_list|(
literal|"\b"
argument_list|)
expr_stmt|;
name|cf
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|cursor_right
condition|)
block|{
while|while
condition|(
name|cf
operator|<
name|ct
condition|)
block|{
name|tc_putp
argument_list|(
name|cursor_right
argument_list|)
expr_stmt|;
name|cf
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* go ahead and trash my display */
while|while
condition|(
name|cf
operator|<
name|ct
condition|)
block|{
name|putchp
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|cf
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* **	display_it(selection, text) ** **	print the display using sel */
end_comment

begin_function
specifier|static
name|void
name|display_it
parameter_list|(
name|int
name|sel
parameter_list|,
name|char
modifier|*
name|txt
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|done_line
decl_stmt|;
name|put_clear
argument_list|()
expr_stmt|;
name|go_home
argument_list|()
expr_stmt|;
name|put_newlines
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|ptextln
argument_list|(
literal|"    The top line should be alternating<'s and>'s"
argument_list|)
expr_stmt|;
name|ptextln
argument_list|(
literal|"    The left side should be alternating A's and V's"
argument_list|)
expr_stmt|;
name|ptext
argument_list|(
literal|"    Testing "
argument_list|)
expr_stmt|;
name|ptext
argument_list|(
name|txt
argument_list|)
expr_stmt|;
name|put_cr
argument_list|()
expr_stmt|;
comment|/* horizontal */
name|move_to
argument_list|(
name|done_line
operator|=
name|line_count
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
name|sel
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|4
init|;
name|i
operator|<
name|columns
operator|-
literal|2
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|putchp
argument_list|(
literal|'>'
argument_list|)
expr_stmt|;
name|move_to
argument_list|(
literal|0
argument_list|,
name|i
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
name|i
argument_list|,
name|sel
argument_list|)
expr_stmt|;
block|}
name|putchp
argument_list|(
literal|'>'
argument_list|)
expr_stmt|;
name|i
operator|-=
literal|2
expr_stmt|;
name|move_to
argument_list|(
literal|0
argument_list|,
name|i
operator|+
literal|1
argument_list|,
literal|0
argument_list|,
name|i
operator|-
literal|1
argument_list|,
name|sel
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|i
operator|>
literal|2
condition|;
name|i
operator|-=
literal|2
control|)
block|{
name|putchp
argument_list|(
literal|'<'
argument_list|)
expr_stmt|;
name|move_to
argument_list|(
literal|0
argument_list|,
name|i
argument_list|,
literal|0
argument_list|,
name|i
operator|-
literal|3
argument_list|,
name|sel
argument_list|)
expr_stmt|;
block|}
name|putchp
argument_list|(
literal|'<'
argument_list|)
expr_stmt|;
comment|/* vertical */
name|move_to
argument_list|(
literal|0
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|sel
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|lines
operator|-
literal|1
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|putchp
argument_list|(
literal|'V'
argument_list|)
expr_stmt|;
name|move_to
argument_list|(
name|i
operator|-
literal|2
argument_list|,
literal|1
argument_list|,
name|i
argument_list|,
literal|0
argument_list|,
name|sel
argument_list|)
expr_stmt|;
block|}
name|putchp
argument_list|(
literal|'V'
argument_list|)
expr_stmt|;
name|i
operator|-=
literal|2
expr_stmt|;
name|move_to
argument_list|(
name|i
argument_list|,
literal|1
argument_list|,
name|i
operator|+
literal|1
argument_list|,
literal|0
argument_list|,
name|sel
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|-=
literal|2
control|)
block|{
name|putchp
argument_list|(
literal|'A'
argument_list|)
expr_stmt|;
name|move_to
argument_list|(
name|i
operator|+
literal|1
argument_list|,
literal|1
argument_list|,
name|i
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
name|sel
argument_list|)
expr_stmt|;
block|}
name|putchp
argument_list|(
literal|'A'
argument_list|)
expr_stmt|;
name|move_to
argument_list|(
name|i
operator|+
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|sel
argument_list|)
expr_stmt|;
comment|/* go home first */
name|move_to
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|done_line
operator|+
literal|1
argument_list|,
literal|3
argument_list|,
name|sel
argument_list|)
expr_stmt|;
name|put_str
argument_list|(
name|txt
argument_list|)
expr_stmt|;
name|put_str
argument_list|(
literal|" Done. "
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **	crum_clear(test_list, status, ch) ** **	(clear) test Clear screen */
end_comment

begin_function
specifier|static
name|void
name|crum_clear
parameter_list|(
name|struct
name|test_list
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|state
parameter_list|,
name|int
modifier|*
name|ch
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|clear_screen
condition|)
block|{
for|for
control|(
name|i
operator|=
name|lines
init|;
name|i
operator|>
literal|1
condition|;
name|i
operator|--
control|)
block|{
name|putln
argument_list|(
literal|"garbage"
argument_list|)
expr_stmt|;
block|}
name|put_clear
argument_list|()
expr_stmt|;
name|ptextln
argument_list|(
literal|"This line should start in the home position."
argument_list|)
expr_stmt|;
name|ptext
argument_list|(
literal|"The rest of the screen should be clear.  "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ptextln
argument_list|(
literal|"(clear) Clear screen is not defined.  "
argument_list|)
expr_stmt|;
block|}
name|generic_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **	crum_home(test_list, status, ch) ** **	(home) test Home cursor */
end_comment

begin_function
specifier|static
name|void
name|crum_home
parameter_list|(
name|struct
name|test_list
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|state
parameter_list|,
name|int
modifier|*
name|ch
parameter_list|)
block|{
if|if
condition|(
name|cursor_home
condition|)
block|{
name|put_clear
argument_list|()
expr_stmt|;
name|put_newlines
argument_list|(
name|lines
operator|/
literal|2
argument_list|)
expr_stmt|;
name|go_home
argument_list|()
expr_stmt|;
name|put_crlf
argument_list|()
expr_stmt|;
name|ptext
argument_list|(
literal|"The bottom line should have text."
argument_list|)
expr_stmt|;
name|go_home
argument_list|()
expr_stmt|;
name|put_newlines
argument_list|(
name|lines
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ptext
argument_list|(
literal|"This line is on the bottom."
argument_list|)
expr_stmt|;
name|go_home
argument_list|()
expr_stmt|;
name|ptextln
argument_list|(
literal|"This line starts in the home position."
argument_list|)
expr_stmt|;
name|put_crlf
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|ptextln
argument_list|(
literal|"(home) Home cursor is not defined.  "
argument_list|)
expr_stmt|;
block|}
name|generic_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **	crum_ll(test_list, status, ch) ** **	(ll) test Last line */
end_comment

begin_function
specifier|static
name|void
name|crum_ll
parameter_list|(
name|struct
name|test_list
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|state
parameter_list|,
name|int
modifier|*
name|ch
parameter_list|)
block|{
comment|/* 	   (ll) may be simulated with (cup).  Don't complain if (cup) is present. 	*/
if|if
condition|(
name|cursor_to_ll
condition|)
block|{
name|put_clear
argument_list|()
expr_stmt|;
name|put_str
argument_list|(
literal|"This line could be anywhere."
argument_list|)
expr_stmt|;
name|tc_putp
argument_list|(
name|cursor_to_ll
argument_list|)
expr_stmt|;
name|ptext
argument_list|(
literal|"This line should be on the bottom"
argument_list|)
expr_stmt|;
name|go_home
argument_list|()
expr_stmt|;
name|put_crlf
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cursor_address
condition|)
block|{
return|return;
block|}
else|else
block|{
name|ptextln
argument_list|(
literal|"(ll) Move to last line is not defined.  "
argument_list|)
expr_stmt|;
block|}
name|generic_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **	crum_move(test_list, status, ch) ** **	(*) test all cursor move commands */
end_comment

begin_function
specifier|static
name|void
name|crum_move
parameter_list|(
name|struct
name|test_list
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|state
parameter_list|,
name|int
modifier|*
name|ch
parameter_list|)
block|{
name|char
name|buf
index|[
literal|80
index|]
decl_stmt|;
name|int
name|n
decl_stmt|;
switch|switch
condition|(
name|n
operator|=
operator|(
name|t
operator|->
name|flags
operator|&
literal|15
operator|)
condition|)
block|{
case|case
literal|0
case|:
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|" (cr) (nel) (cub1)%s"
argument_list|,
name|cursor_home
condition|?
literal|" (home)"
else|:
operator|(
name|cursor_up
condition|?
literal|" (cuu1)"
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s%s%s%s"
argument_list|,
name|cursor_left
condition|?
literal|" (cub1)"
else|:
literal|""
argument_list|,
name|cursor_down
condition|?
literal|" (cud1)"
else|:
literal|""
argument_list|,
name|cursor_right
condition|?
literal|" (cuf1)"
else|:
literal|""
argument_list|,
name|cursor_up
condition|?
literal|" (cuu1)"
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|ptext
argument_list|(
literal|"    (cub1) (cud1) (cuf1) (cuu1) not defined."
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|2
case|:
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s%s%s%s"
argument_list|,
name|parm_left_cursor
condition|?
literal|" (cub)"
else|:
literal|""
argument_list|,
name|parm_down_cursor
condition|?
literal|" (cud)"
else|:
literal|""
argument_list|,
name|parm_right_cursor
condition|?
literal|" (cuf)"
else|:
literal|""
argument_list|,
name|parm_up_cursor
condition|?
literal|" (cuu)"
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|ptext
argument_list|(
literal|"    (cub) (cud) (cuf) (cuu) not defined."
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|3
case|:
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s%s"
argument_list|,
name|row_address
condition|?
literal|" (vpa)"
else|:
literal|""
argument_list|,
name|column_address
condition|?
literal|" (hpa)"
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|ptext
argument_list|(
literal|"    (vpa) (hpa) not defined."
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|4
case|:
if|if
condition|(
operator|!
name|cursor_address
condition|)
block|{
name|ptext
argument_list|(
literal|"    (cup) not defined.  "
argument_list|)
expr_stmt|;
name|generic_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
return|return;
block|}
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|" (cup)"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|put_str
argument_list|(
literal|"  Done. "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|can_test
argument_list|(
name|buf
argument_list|,
name|FLAG_TESTED
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|crum_text
index|[
name|n
index|]
argument_list|,
operator|&
name|buf
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|crum_text
index|[
name|n
index|]
index|[
name|strlen
argument_list|(
name|buf
argument_list|)
operator|-
literal|3
index|]
operator|=
literal|'\0'
expr_stmt|;
name|display_it
argument_list|(
literal|1
operator|<<
name|n
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
operator|*
name|ch
operator|=
name|wait_here
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|ch
operator|!=
literal|'r'
condition|)
block|{
name|put_clear
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* **	crum_os(test_list, status, ch) ** **	(cup) test Cursor position on overstrike terminals */
end_comment

begin_function
specifier|static
name|void
name|crum_os
parameter_list|(
name|struct
name|test_list
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|state
parameter_list|,
name|int
modifier|*
name|ch
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|cursor_address
operator|&&
name|over_strike
condition|)
block|{
name|put_clear
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|columns
operator|-
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|tc_putch
argument_list|(
literal|'|'
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|lines
operator|-
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|put_crlf
argument_list|()
expr_stmt|;
name|tc_putch
argument_list|(
literal|'_'
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|columns
operator|-
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|tputs
argument_list|(
name|tparm
argument_list|(
name|cursor_address
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|lines
argument_list|,
name|tc_putch
argument_list|)
expr_stmt|;
name|tc_putch
argument_list|(
literal|'+'
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lines
operator|-
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|tputs
argument_list|(
name|tparm
argument_list|(
name|cursor_address
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
argument_list|,
name|lines
argument_list|,
name|tc_putch
argument_list|)
expr_stmt|;
name|tc_putch
argument_list|(
literal|']'
argument_list|)
expr_stmt|;
name|tc_putch
argument_list|(
literal|'_'
argument_list|)
expr_stmt|;
block|}
name|go_home
argument_list|()
expr_stmt|;
name|put_newlines
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|ptext
argument_list|(
literal|"    All the characters should look the same.  "
argument_list|)
expr_stmt|;
name|generic_done_message
argument_list|(
name|t
argument_list|,
name|state
argument_list|,
name|ch
argument_list|)
expr_stmt|;
name|put_clear
argument_list|()
expr_stmt|;
block|}
block|}
end_function

end_unit

