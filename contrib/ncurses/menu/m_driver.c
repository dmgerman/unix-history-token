begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/****************************************************************************  * Copyright (c) 1998-2004,2005 Free Software Foundation, Inc.              *  *                                                                          *  * Permission is hereby granted, free of charge, to any person obtaining a  *  * copy of this software and associated documentation files (the            *  * "Software"), to deal in the Software without restriction, including      *  * without limitation the rights to use, copy, modify, merge, publish,      *  * distribute, distribute with modifications, sublicense, and/or sell       *  * copies of the Software, and to permit persons to whom the Software is    *  * furnished to do so, subject to the following conditions:                 *  *                                                                          *  * The above copyright notice and this permission notice shall be included  *  * in all copies or substantial portions of the Software.                   *  *                                                                          *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *  * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *  * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *  * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *  * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *  * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *  *                                                                          *  * Except as contained in this notice, the name(s) of the above copyright   *  * holders shall not be used in advertising or otherwise to promote the     *  * sale, use or other dealings in this Software without prior written       *  * authorization.                                                           *  ****************************************************************************/
end_comment

begin_comment
comment|/****************************************************************************  *   Author:  Juergen Pfeifer, 1995,1997                                    *  ****************************************************************************/
end_comment

begin_comment
comment|/*************************************************************************** * Module m_driver                                                          * * Central dispatching routine                                              * ***************************************************************************/
end_comment

begin_include
include|#
directive|include
file|"menu.priv.h"
end_include

begin_macro
name|MODULE_ID
argument_list|(
literal|"$Id: m_driver.c,v 1.25 2005/11/26 20:46:59 tom Exp $"
argument_list|)
end_macro

begin_comment
comment|/* Macros */
end_comment

begin_comment
comment|/* Remove the last character from the match pattern buffer */
end_comment

begin_define
define|#
directive|define
name|Remove_Character_From_Pattern
parameter_list|(
name|menu
parameter_list|)
define|\
value|(menu)->pattern[--((menu)->pindex)] = '\0'
end_define

begin_comment
comment|/* Add a new character to the match pattern buffer */
end_comment

begin_define
define|#
directive|define
name|Add_Character_To_Pattern
parameter_list|(
name|menu
parameter_list|,
name|ch
parameter_list|)
define|\
value|{ (menu)->pattern[((menu)->pindex)++] = (ch);\     (menu)->pattern[(menu)->pindex] = '\0'; }
end_define

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnmenu |   Function      :  static bool Is_Sub_String( |                           bool IgnoreCaseFlag, |                           const char *part, |                           const char *string) | |   Description   :  Checks whether or not part is a substring of string. | |   Return Values :  TRUE   - if it is a substring |                    FALSE  - if it is not a substring +--------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|bool
name|Is_Sub_String
parameter_list|(
name|bool
name|IgnoreCaseFlag
parameter_list|,
specifier|const
name|char
modifier|*
name|part
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
name|assert
argument_list|(
name|part
operator|&&
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|IgnoreCaseFlag
condition|)
block|{
while|while
condition|(
operator|*
name|string
operator|&&
operator|*
name|part
condition|)
block|{
if|if
condition|(
name|toupper
argument_list|(
operator|*
name|string
operator|++
argument_list|)
operator|!=
name|toupper
argument_list|(
operator|*
name|part
argument_list|)
condition|)
break|break;
name|part
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
while|while
condition|(
operator|*
name|string
operator|&&
operator|*
name|part
condition|)
if|if
condition|(
operator|*
name|part
operator|!=
operator|*
name|string
operator|++
condition|)
break|break;
name|part
operator|++
expr_stmt|;
block|}
return|return
operator|(
operator|(
operator|*
name|part
operator|)
condition|?
name|FALSE
else|:
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnmenu |   Function      :  int _nc_Match_Next_Character_In_Item_Name( |                           MENU *menu, |                           int  ch, |                           ITEM **item) | |   Description   :  This internal routine is called for a menu positioned |                    at an item with three different classes of characters: |                       - a printable character; the character is added to |                         the current pattern and the next item matching |                         this pattern is searched. |                       - NUL; the pattern stays as it is and the next item |                         matching the pattern is searched |                       - BS; the pattern stays as it is and the previous |                         item matching the pattern is searched | |                       The item parameter contains on call a pointer to |                       the item where the search starts. On return - if |                       a match was found - it contains a pointer to the |                       matching item. | |   Return Values :  E_OK        - an item matching the pattern was found |                    E_NO_MATCH  - nothing found +--------------------------------------------------------------------------*/
end_comment

begin_macro
name|NCURSES_EXPORT
argument_list|(
argument|int
argument_list|)
end_macro

begin_macro
name|_nc_Match_Next_Character_In_Item_Name
argument_list|(
argument|MENU * menu
argument_list|,
argument|int ch
argument_list|,
argument|ITEM ** item
argument_list|)
end_macro

begin_block
block|{
name|bool
name|found
init|=
name|FALSE
decl_stmt|,
name|passed
init|=
name|FALSE
decl_stmt|;
name|int
name|idx
decl_stmt|,
name|last
decl_stmt|;
name|T
argument_list|(
operator|(
name|T_CALLED
argument_list|(
literal|"_nc_Match_Next_Character(%p,%d,%p)"
argument_list|)
operator|,
name|menu
operator|,
name|ch
operator|,
name|item
operator|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|menu
operator|&&
name|item
operator|&&
operator|*
name|item
argument_list|)
expr_stmt|;
name|idx
operator|=
operator|(
operator|*
name|item
operator|)
operator|->
name|index
expr_stmt|;
if|if
condition|(
name|ch
operator|&&
name|ch
operator|!=
name|BS
condition|)
block|{
comment|/* if we become to long, we need no further checking : there can't be          a match ! */
if|if
condition|(
operator|(
name|menu
operator|->
name|pindex
operator|+
literal|1
operator|)
operator|>
name|menu
operator|->
name|namelen
condition|)
name|RETURN
argument_list|(
name|E_NO_MATCH
argument_list|)
expr_stmt|;
name|Add_Character_To_Pattern
argument_list|(
name|menu
argument_list|,
name|ch
argument_list|)
expr_stmt|;
comment|/* we artificially position one item back, because in the do...while          loop we start with the next item. This means, that with a new          pattern search we always start the scan with the actual item. If          we do a NEXT_PATTERN oder PREV_PATTERN search, we start with the          one after or before the actual item. */
if|if
condition|(
operator|--
name|idx
operator|<
literal|0
condition|)
name|idx
operator|=
name|menu
operator|->
name|nitems
operator|-
literal|1
expr_stmt|;
block|}
name|last
operator|=
name|idx
expr_stmt|;
comment|/* this closes the cycle */
do|do
block|{
if|if
condition|(
name|ch
operator|==
name|BS
condition|)
block|{
comment|/* we have to go backward */
if|if
condition|(
operator|--
name|idx
operator|<
literal|0
condition|)
name|idx
operator|=
name|menu
operator|->
name|nitems
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* otherwise we always go forward */
if|if
condition|(
operator|++
name|idx
operator|>=
name|menu
operator|->
name|nitems
condition|)
name|idx
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|Is_Sub_String
argument_list|(
call|(
name|bool
call|)
argument_list|(
operator|(
name|menu
operator|->
name|opt
operator|&
name|O_IGNORECASE
operator|)
operator|!=
literal|0
argument_list|)
argument_list|,
name|menu
operator|->
name|pattern
argument_list|,
name|menu
operator|->
name|items
index|[
name|idx
index|]
operator|->
name|name
operator|.
name|str
argument_list|)
condition|)
name|found
operator|=
name|TRUE
expr_stmt|;
else|else
name|passed
operator|=
name|TRUE
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|found
operator|&&
operator|(
name|idx
operator|!=
name|last
operator|)
condition|)
do|;
if|if
condition|(
name|found
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|idx
operator|==
operator|(
operator|*
name|item
operator|)
operator|->
name|index
operator|)
operator|&&
name|passed
operator|)
condition|)
block|{
operator|*
name|item
operator|=
name|menu
operator|->
name|items
index|[
name|idx
index|]
expr_stmt|;
name|RETURN
argument_list|(
name|E_OK
argument_list|)
expr_stmt|;
block|}
comment|/* This point is reached, if we fully cycled through the item list          and the only match we found is the starting item. With a NEXT_PATTERN          or PREV_PATTERN scan this means, that there was no additional match.          If we searched with an expanded new pattern, we should never reach          this point, because if the expanded pattern matches also the actual          item we will find it in the first attempt (passed==FALSE) and we          will never cycle through the whole item array.        */
name|assert
argument_list|(
name|ch
operator|==
literal|0
operator|||
name|ch
operator|==
name|BS
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ch
operator|&&
name|ch
operator|!=
name|BS
operator|&&
name|menu
operator|->
name|pindex
operator|>
literal|0
condition|)
block|{
comment|/* if we had no match with a new pattern, we have to restore it */
name|Remove_Character_From_Pattern
argument_list|(
name|menu
argument_list|)
expr_stmt|;
block|}
block|}
name|RETURN
argument_list|(
name|E_NO_MATCH
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnmenu |   Function      :  int menu_driver(MENU *menu, int c) | |   Description   :  Central dispatcher for the menu. Translates the logical |                    request 'c' into a menu action. | |   Return Values :  E_OK            - success |                    E_BAD_ARGUMENT  - invalid menu pointer |                    E_BAD_STATE     - menu is in user hook routine |                    E_NOT_POSTED    - menu is not posted +--------------------------------------------------------------------------*/
end_comment

begin_macro
name|NCURSES_EXPORT
argument_list|(
argument|int
argument_list|)
end_macro

begin_macro
name|menu_driver
argument_list|(
argument|MENU * menu
argument_list|,
argument|int c
argument_list|)
end_macro

begin_block
block|{
define|#
directive|define
name|NAVIGATE
parameter_list|(
name|dir
parameter_list|)
define|\
value|if (!item->dir)\      result = E_REQUEST_DENIED;\   else\      item = item->dir
name|int
name|result
init|=
name|E_OK
decl_stmt|;
name|ITEM
modifier|*
name|item
decl_stmt|;
name|int
name|my_top_row
decl_stmt|,
name|rdiff
decl_stmt|;
name|T
argument_list|(
operator|(
name|T_CALLED
argument_list|(
literal|"menu_driver(%p,%d)"
argument_list|)
operator|,
name|menu
operator|,
name|c
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|menu
condition|)
name|RETURN
argument_list|(
name|E_BAD_ARGUMENT
argument_list|)
expr_stmt|;
if|if
condition|(
name|menu
operator|->
name|status
operator|&
name|_IN_DRIVER
condition|)
name|RETURN
argument_list|(
name|E_BAD_STATE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|menu
operator|->
name|status
operator|&
name|_POSTED
operator|)
condition|)
name|RETURN
argument_list|(
name|E_NOT_POSTED
argument_list|)
expr_stmt|;
name|item
operator|=
name|menu
operator|->
name|curitem
expr_stmt|;
name|my_top_row
operator|=
name|menu
operator|->
name|toprow
expr_stmt|;
name|assert
argument_list|(
name|item
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|>
name|KEY_MAX
operator|)
operator|&&
operator|(
name|c
operator|<=
name|MAX_MENU_COMMAND
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|c
operator|==
name|REQ_BACK_PATTERN
operator|)
operator|||
operator|(
name|c
operator|==
name|REQ_NEXT_MATCH
operator|)
operator|||
operator|(
name|c
operator|==
name|REQ_PREV_MATCH
operator|)
operator|)
condition|)
block|{
name|assert
argument_list|(
name|menu
operator|->
name|pattern
argument_list|)
expr_stmt|;
name|Reset_Pattern
argument_list|(
name|menu
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|REQ_LEFT_ITEM
case|:
comment|/*=================*/
name|NAVIGATE
argument_list|(
name|left
argument_list|)
expr_stmt|;
break|break;
case|case
name|REQ_RIGHT_ITEM
case|:
comment|/*==================*/
name|NAVIGATE
argument_list|(
name|right
argument_list|)
expr_stmt|;
break|break;
case|case
name|REQ_UP_ITEM
case|:
comment|/*===============*/
name|NAVIGATE
argument_list|(
name|up
argument_list|)
expr_stmt|;
break|break;
case|case
name|REQ_DOWN_ITEM
case|:
comment|/*=================*/
name|NAVIGATE
argument_list|(
name|down
argument_list|)
expr_stmt|;
break|break;
case|case
name|REQ_SCR_ULINE
case|:
comment|/*=================*/
if|if
condition|(
name|my_top_row
operator|==
literal|0
operator|||
operator|!
operator|(
name|item
operator|->
name|up
operator|)
condition|)
name|result
operator|=
name|E_REQUEST_DENIED
expr_stmt|;
else|else
block|{
operator|--
name|my_top_row
expr_stmt|;
name|item
operator|=
name|item
operator|->
name|up
expr_stmt|;
block|}
break|break;
case|case
name|REQ_SCR_DLINE
case|:
comment|/*=================*/
if|if
condition|(
operator|(
name|my_top_row
operator|+
name|menu
operator|->
name|arows
operator|>=
name|menu
operator|->
name|rows
operator|)
operator|||
operator|!
operator|(
name|item
operator|->
name|down
operator|)
condition|)
block|{
comment|/* only if the menu has less items than rows, we can deny the 	         request. Otherwise the epilogue of this routine adjusts the 	         top row if necessary */
name|result
operator|=
name|E_REQUEST_DENIED
expr_stmt|;
block|}
else|else
block|{
name|my_top_row
operator|++
expr_stmt|;
name|item
operator|=
name|item
operator|->
name|down
expr_stmt|;
block|}
break|break;
case|case
name|REQ_SCR_DPAGE
case|:
comment|/*=================*/
name|rdiff
operator|=
name|menu
operator|->
name|rows
operator|-
operator|(
name|menu
operator|->
name|arows
operator|+
name|my_top_row
operator|)
expr_stmt|;
if|if
condition|(
name|rdiff
operator|>
name|menu
operator|->
name|arows
condition|)
name|rdiff
operator|=
name|menu
operator|->
name|arows
expr_stmt|;
if|if
condition|(
name|rdiff
operator|<=
literal|0
condition|)
name|result
operator|=
name|E_REQUEST_DENIED
expr_stmt|;
else|else
block|{
name|my_top_row
operator|+=
name|rdiff
expr_stmt|;
while|while
condition|(
name|rdiff
operator|--
operator|>
literal|0
operator|&&
name|item
operator|!=
operator|(
name|ITEM
operator|*
operator|)
literal|0
condition|)
name|item
operator|=
name|item
operator|->
name|down
expr_stmt|;
block|}
break|break;
case|case
name|REQ_SCR_UPAGE
case|:
comment|/*=================*/
name|rdiff
operator|=
operator|(
name|menu
operator|->
name|arows
operator|<
name|my_top_row
operator|)
condition|?
name|menu
operator|->
name|arows
else|:
name|my_top_row
expr_stmt|;
if|if
condition|(
name|rdiff
operator|<=
literal|0
condition|)
name|result
operator|=
name|E_REQUEST_DENIED
expr_stmt|;
else|else
block|{
name|my_top_row
operator|-=
name|rdiff
expr_stmt|;
while|while
condition|(
name|rdiff
operator|--
operator|&&
name|item
operator|!=
operator|(
name|ITEM
operator|*
operator|)
literal|0
condition|)
name|item
operator|=
name|item
operator|->
name|up
expr_stmt|;
block|}
break|break;
case|case
name|REQ_FIRST_ITEM
case|:
comment|/*==================*/
name|item
operator|=
name|menu
operator|->
name|items
index|[
literal|0
index|]
expr_stmt|;
break|break;
case|case
name|REQ_LAST_ITEM
case|:
comment|/*=================*/
name|item
operator|=
name|menu
operator|->
name|items
index|[
name|menu
operator|->
name|nitems
operator|-
literal|1
index|]
expr_stmt|;
break|break;
case|case
name|REQ_NEXT_ITEM
case|:
comment|/*=================*/
if|if
condition|(
operator|(
name|item
operator|->
name|index
operator|+
literal|1
operator|)
operator|>=
name|menu
operator|->
name|nitems
condition|)
block|{
if|if
condition|(
name|menu
operator|->
name|opt
operator|&
name|O_NONCYCLIC
condition|)
name|result
operator|=
name|E_REQUEST_DENIED
expr_stmt|;
else|else
name|item
operator|=
name|menu
operator|->
name|items
index|[
literal|0
index|]
expr_stmt|;
block|}
else|else
name|item
operator|=
name|menu
operator|->
name|items
index|[
name|item
operator|->
name|index
operator|+
literal|1
index|]
expr_stmt|;
break|break;
case|case
name|REQ_PREV_ITEM
case|:
comment|/*=================*/
if|if
condition|(
name|item
operator|->
name|index
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|menu
operator|->
name|opt
operator|&
name|O_NONCYCLIC
condition|)
name|result
operator|=
name|E_REQUEST_DENIED
expr_stmt|;
else|else
name|item
operator|=
name|menu
operator|->
name|items
index|[
name|menu
operator|->
name|nitems
operator|-
literal|1
index|]
expr_stmt|;
block|}
else|else
name|item
operator|=
name|menu
operator|->
name|items
index|[
name|item
operator|->
name|index
operator|-
literal|1
index|]
expr_stmt|;
break|break;
case|case
name|REQ_TOGGLE_ITEM
case|:
comment|/*===================*/
if|if
condition|(
name|menu
operator|->
name|opt
operator|&
name|O_ONEVALUE
condition|)
block|{
name|result
operator|=
name|E_REQUEST_DENIED
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|menu
operator|->
name|curitem
operator|->
name|opt
operator|&
name|O_SELECTABLE
condition|)
block|{
name|menu
operator|->
name|curitem
operator|->
name|value
operator|=
operator|!
name|menu
operator|->
name|curitem
operator|->
name|value
expr_stmt|;
name|Move_And_Post_Item
argument_list|(
name|menu
argument_list|,
name|menu
operator|->
name|curitem
argument_list|)
expr_stmt|;
name|_nc_Show_Menu
argument_list|(
name|menu
argument_list|)
expr_stmt|;
block|}
else|else
name|result
operator|=
name|E_NOT_SELECTABLE
expr_stmt|;
block|}
break|break;
case|case
name|REQ_CLEAR_PATTERN
case|:
comment|/*=====================*/
comment|/* already cleared in prologue */
break|break;
case|case
name|REQ_BACK_PATTERN
case|:
comment|/*====================*/
if|if
condition|(
name|menu
operator|->
name|pindex
operator|>
literal|0
condition|)
block|{
name|assert
argument_list|(
name|menu
operator|->
name|pattern
argument_list|)
expr_stmt|;
name|Remove_Character_From_Pattern
argument_list|(
name|menu
argument_list|)
expr_stmt|;
name|pos_menu_cursor
argument_list|(
name|menu
argument_list|)
expr_stmt|;
block|}
else|else
name|result
operator|=
name|E_REQUEST_DENIED
expr_stmt|;
break|break;
case|case
name|REQ_NEXT_MATCH
case|:
comment|/*==================*/
name|assert
argument_list|(
name|menu
operator|->
name|pattern
argument_list|)
expr_stmt|;
if|if
condition|(
name|menu
operator|->
name|pattern
index|[
literal|0
index|]
condition|)
name|result
operator|=
name|_nc_Match_Next_Character_In_Item_Name
argument_list|(
name|menu
argument_list|,
literal|0
argument_list|,
operator|&
name|item
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|(
name|item
operator|->
name|index
operator|+
literal|1
operator|)
operator|<
name|menu
operator|->
name|nitems
condition|)
name|item
operator|=
name|menu
operator|->
name|items
index|[
name|item
operator|->
name|index
operator|+
literal|1
index|]
expr_stmt|;
else|else
block|{
if|if
condition|(
name|menu
operator|->
name|opt
operator|&
name|O_NONCYCLIC
condition|)
name|result
operator|=
name|E_REQUEST_DENIED
expr_stmt|;
else|else
name|item
operator|=
name|menu
operator|->
name|items
index|[
literal|0
index|]
expr_stmt|;
block|}
block|}
break|break;
case|case
name|REQ_PREV_MATCH
case|:
comment|/*==================*/
name|assert
argument_list|(
name|menu
operator|->
name|pattern
argument_list|)
expr_stmt|;
if|if
condition|(
name|menu
operator|->
name|pattern
index|[
literal|0
index|]
condition|)
name|result
operator|=
name|_nc_Match_Next_Character_In_Item_Name
argument_list|(
name|menu
argument_list|,
name|BS
argument_list|,
operator|&
name|item
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|item
operator|->
name|index
condition|)
name|item
operator|=
name|menu
operator|->
name|items
index|[
name|item
operator|->
name|index
operator|-
literal|1
index|]
expr_stmt|;
else|else
block|{
if|if
condition|(
name|menu
operator|->
name|opt
operator|&
name|O_NONCYCLIC
condition|)
name|result
operator|=
name|E_REQUEST_DENIED
expr_stmt|;
else|else
name|item
operator|=
name|menu
operator|->
name|items
index|[
name|menu
operator|->
name|nitems
operator|-
literal|1
index|]
expr_stmt|;
block|}
block|}
break|break;
default|default:
comment|/*======*/
name|result
operator|=
name|E_UNKNOWN_COMMAND
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
comment|/* not a command */
if|if
condition|(
operator|!
operator|(
name|c
operator|&
operator|~
operator|(
operator|(
name|int
operator|)
name|MAX_REGULAR_CHARACTER
operator|)
operator|)
operator|&&
name|isprint
argument_list|(
name|UChar
argument_list|(
name|c
argument_list|)
argument_list|)
condition|)
name|result
operator|=
name|_nc_Match_Next_Character_In_Item_Name
argument_list|(
name|menu
argument_list|,
name|c
argument_list|,
operator|&
name|item
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NCURSES_MOUSE_VERSION
elseif|else
if|if
condition|(
name|KEY_MOUSE
operator|==
name|c
condition|)
block|{
name|MEVENT
name|event
decl_stmt|;
name|WINDOW
modifier|*
name|uwin
init|=
name|Get_Menu_UserWin
argument_list|(
name|menu
argument_list|)
decl_stmt|;
name|getmouse
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|event
operator|.
name|bstate
operator|&
operator|(
name|BUTTON1_CLICKED
operator||
name|BUTTON1_DOUBLE_CLICKED
operator||
name|BUTTON1_TRIPLE_CLICKED
operator|)
operator|)
operator|&&
name|wenclose
argument_list|(
name|uwin
argument_list|,
name|event
operator|.
name|y
argument_list|,
name|event
operator|.
name|x
argument_list|)
condition|)
block|{
comment|/* we react only if the click was in the userwin, that means 				 * inside the menu display area or at the decoration window. 				 */
name|WINDOW
modifier|*
name|sub
init|=
name|Get_Menu_Window
argument_list|(
name|menu
argument_list|)
decl_stmt|;
name|int
name|ry
init|=
name|event
operator|.
name|y
decl_stmt|,
name|rx
init|=
name|event
operator|.
name|x
decl_stmt|;
comment|/* screen coordinates */
name|result
operator|=
name|E_REQUEST_DENIED
expr_stmt|;
if|if
condition|(
name|mouse_trafo
argument_list|(
operator|&
name|ry
argument_list|,
operator|&
name|rx
argument_list|,
name|FALSE
argument_list|)
condition|)
block|{
comment|/* rx, ry are now "curses" coordinates */
if|if
condition|(
name|ry
operator|<
name|sub
operator|->
name|_begy
condition|)
block|{
comment|/* we clicked above the display region; this is 				 * interpreted as "scroll up" request 				 */
if|if
condition|(
name|event
operator|.
name|bstate
operator|&
name|BUTTON1_CLICKED
condition|)
name|result
operator|=
name|menu_driver
argument_list|(
name|menu
argument_list|,
name|REQ_SCR_ULINE
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|event
operator|.
name|bstate
operator|&
name|BUTTON1_DOUBLE_CLICKED
condition|)
name|result
operator|=
name|menu_driver
argument_list|(
name|menu
argument_list|,
name|REQ_SCR_UPAGE
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|event
operator|.
name|bstate
operator|&
name|BUTTON1_TRIPLE_CLICKED
condition|)
name|result
operator|=
name|menu_driver
argument_list|(
name|menu
argument_list|,
name|REQ_FIRST_ITEM
argument_list|)
expr_stmt|;
name|RETURN
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ry
operator|>
name|sub
operator|->
name|_begy
operator|+
name|sub
operator|->
name|_maxy
condition|)
block|{
comment|/* we clicked below the display region; this is 				 * interpreted as "scroll down" request 				 */
if|if
condition|(
name|event
operator|.
name|bstate
operator|&
name|BUTTON1_CLICKED
condition|)
name|result
operator|=
name|menu_driver
argument_list|(
name|menu
argument_list|,
name|REQ_SCR_DLINE
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|event
operator|.
name|bstate
operator|&
name|BUTTON1_DOUBLE_CLICKED
condition|)
name|result
operator|=
name|menu_driver
argument_list|(
name|menu
argument_list|,
name|REQ_SCR_DPAGE
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|event
operator|.
name|bstate
operator|&
name|BUTTON1_TRIPLE_CLICKED
condition|)
name|result
operator|=
name|menu_driver
argument_list|(
name|menu
argument_list|,
name|REQ_LAST_ITEM
argument_list|)
expr_stmt|;
name|RETURN
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|wenclose
argument_list|(
name|sub
argument_list|,
name|event
operator|.
name|y
argument_list|,
name|event
operator|.
name|x
argument_list|)
condition|)
block|{
comment|/* Inside the area we try to find the hit item */
name|int
name|i
decl_stmt|,
name|x
decl_stmt|,
name|y
decl_stmt|,
name|err
decl_stmt|;
name|ry
operator|=
name|event
operator|.
name|y
expr_stmt|;
name|rx
operator|=
name|event
operator|.
name|x
expr_stmt|;
if|if
condition|(
name|wmouse_trafo
argument_list|(
name|sub
argument_list|,
operator|&
name|ry
argument_list|,
operator|&
name|rx
argument_list|,
name|FALSE
argument_list|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|menu
operator|->
name|nitems
condition|;
name|i
operator|++
control|)
block|{
name|err
operator|=
name|_nc_menu_cursor_pos
argument_list|(
name|menu
argument_list|,
name|menu
operator|->
name|items
index|[
name|i
index|]
argument_list|,
operator|&
name|y
argument_list|,
operator|&
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|E_OK
operator|==
name|err
condition|)
block|{
if|if
condition|(
operator|(
name|ry
operator|==
name|y
operator|)
operator|&&
operator|(
name|rx
operator|>=
name|x
operator|)
operator|&&
operator|(
name|rx
operator|<
name|x
operator|+
name|menu
operator|->
name|itemlen
operator|)
condition|)
block|{
name|item
operator|=
name|menu
operator|->
name|items
index|[
name|i
index|]
expr_stmt|;
name|result
operator|=
name|E_OK
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|E_OK
operator|==
name|result
condition|)
block|{
comment|/* We found an item, now we can handle the click. 				 * A single click just positions the menu cursor 				 * to the clicked item. A double click toggles 				 * the item. 				 */
if|if
condition|(
name|event
operator|.
name|bstate
operator|&
name|BUTTON1_DOUBLE_CLICKED
condition|)
block|{
name|_nc_New_TopRow_and_CurrentItem
argument_list|(
name|menu
argument_list|,
name|my_top_row
argument_list|,
name|item
argument_list|)
expr_stmt|;
name|menu_driver
argument_list|(
name|menu
argument_list|,
name|REQ_TOGGLE_ITEM
argument_list|)
expr_stmt|;
name|result
operator|=
name|E_UNKNOWN_COMMAND
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
else|else
name|result
operator|=
name|E_REQUEST_DENIED
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* NCURSES_MOUSE_VERSION */
else|else
name|result
operator|=
name|E_UNKNOWN_COMMAND
expr_stmt|;
block|}
if|if
condition|(
name|E_OK
operator|==
name|result
condition|)
block|{
comment|/* Adjust the top row if it turns out that the current item unfortunately          doesn't appear in the menu window */
if|if
condition|(
name|item
operator|->
name|y
operator|<
name|my_top_row
condition|)
name|my_top_row
operator|=
name|item
operator|->
name|y
expr_stmt|;
elseif|else
if|if
condition|(
name|item
operator|->
name|y
operator|>=
operator|(
name|my_top_row
operator|+
name|menu
operator|->
name|arows
operator|)
condition|)
name|my_top_row
operator|=
name|item
operator|->
name|y
operator|-
name|menu
operator|->
name|arows
operator|+
literal|1
expr_stmt|;
name|_nc_New_TopRow_and_CurrentItem
argument_list|(
name|menu
argument_list|,
name|my_top_row
argument_list|,
name|item
argument_list|)
expr_stmt|;
block|}
name|RETURN
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* m_driver.c ends here */
end_comment

end_unit

