begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/****************************************************************************  * Copyright (c) 2008-2009,2010 Free Software Foundation, Inc.              *  *                                                                          *  * Permission is hereby granted, free of charge, to any person obtaining a  *  * copy of this software and associated documentation files (the            *  * "Software"), to deal in the Software without restriction, including      *  * without limitation the rights to use, copy, modify, merge, publish,      *  * distribute, distribute with modifications, sublicense, and/or sell       *  * copies of the Software, and to permit persons to whom the Software is    *  * furnished to do so, subject to the following conditions:                 *  *                                                                          *  * The above copyright notice and this permission notice shall be included  *  * in all copies or substantial portions of the Software.                   *  *                                                                          *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *  * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *  * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *  * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *  * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *  * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *  *                                                                          *  * Except as contained in this notice, the name(s) of the above copyright   *  * holders shall not be used in advertising or otherwise to promote the     *  * sale, use or other dealings in this Software without prior written       *  * authorization.                                                           *  ****************************************************************************/
end_comment

begin_comment
comment|/*************************************************************************** *                                                                          * *  Author : Juergen Pfeifer                                                * *                                                                          * ***************************************************************************/
end_comment

begin_include
include|#
directive|include
file|"form.priv.h"
end_include

begin_macro
name|MODULE_ID
argument_list|(
literal|"$Id: fty_generic.c,v 1.5 2010/01/23 21:14:36 tom Exp $"
argument_list|)
end_macro

begin_comment
comment|/*  * This is not a full implementation of a field type, but adds some  * support for higher level languages with some restrictions to interop  * with C language. Especially the collection of arguments for the  * various fieldtypes is not based on the vararg C mechanism, but on a  * iterator based callback mechanism that allowes the high level language  * to provide the arguments as a structure. Most languages have mechanisms  * to layout structures so that they can be passed to C.  * The languages can register a new generic fieldtype dynamically and store  * a handle (key) to the calling object as an argument. Together with that  * it can register a freearg callback, so that the high level language  * remains in control of the memory management of the arguments they pass.  * The design idea is, that the high-level language - typically a OO  * language like C# or Java, uses it's own dispatching mechanisms  * (polymorphism) to call the proper check routines responsible for the  * argument type. So these language implement typically only one generic  * fieldtype they register with the forms library using this call.  *  * For that purpose we have extended the fieldtype struc by a new element  * that gets the arguments from a single struct passed by the caller.   *   */
end_comment

begin_if
if|#
directive|if
name|NCURSES_INTEROP_FUNCS
end_if

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform   |   Function      :  static void *Generic_This_Type( void * arg ) |    |   Description   :  We interpret the passed arg just as a handle the |                    calling language uses to keep track of its allocated |                    argument structures. We can simply copy it back. | |   Return Values :  Pointer to argument structure +--------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
modifier|*
name|Generic_This_Type
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
return|return
operator|(
name|arg
operator|)
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform |   Function      :  FIELDTYPE *_nc_generic_fieldtype( |                       bool (* const field_check)(FIELD *,const void *), |                       bool (* const char_check) (int, const void *), |   		        bool (*const next)(FORM*,FIELD*,const void*), |		        bool (*const prev)(FORM*,FIELD*,const void*), |                       void (*freecallback)(void*)) | |   Description   :  Create a new fieldtype. The application programmer must |                    write a field_check and a char_check function and give |                    them as input to this call. A callback to allow the |                    release of the allocated memory must also be provided. |                    For generic field types, we provide some more  |                    information about the field as parameters. | |                    If an error occurs, errno is set to |                       E_BAD_ARGUMENT  - invalid arguments |                       E_SYSTEM_ERROR  - system error (no memory) | |   Return Values :  Fieldtype pointer or NULL if error occurred +--------------------------------------------------------------------------*/
end_comment

begin_macro
name|NCURSES_EXPORT
argument_list|(
argument|FIELDTYPE *
argument_list|)
end_macro

begin_macro
name|_nc_generic_fieldtype
argument_list|(
argument|bool (*const field_check) (FORM *, FIELD *, const void *)
argument_list|,
argument|bool (*const char_check) (int, FORM *, FIELD *, const 						void *)
argument_list|,
argument|bool (*const next) (FORM *, FIELD *, const void *)
argument_list|,
argument|bool (*const prev) (FORM *, FIELD *, const void *)
argument_list|,
argument|void (*freecallback) (void *)
argument_list|)
end_macro

begin_block
block|{
name|int
name|code
init|=
name|E_SYSTEM_ERROR
decl_stmt|;
name|FIELDTYPE
modifier|*
name|res
init|=
operator|(
name|FIELDTYPE
operator|*
operator|)
literal|0
decl_stmt|;
name|T
argument_list|(
operator|(
name|T_CALLED
argument_list|(
literal|"_nc_generic_fieldtype(%p,%p,%p,%p,%p)"
argument_list|)
operator|,
name|field_check
operator|,
name|char_check
operator|,
name|next
operator|,
name|prev
operator|,
name|freecallback
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|field_check
operator|||
name|char_check
condition|)
block|{
name|res
operator|=
name|typeMalloc
argument_list|(
name|FIELDTYPE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
condition|)
block|{
operator|*
name|res
operator|=
operator|*
name|_nc_Default_FieldType
expr_stmt|;
name|res
operator|->
name|status
operator||=
operator|(
name|_HAS_ARGS
operator||
name|_GENERIC
operator|)
expr_stmt|;
name|res
operator|->
name|fieldcheck
operator|.
name|gfcheck
operator|=
name|field_check
expr_stmt|;
name|res
operator|->
name|charcheck
operator|.
name|gccheck
operator|=
name|char_check
expr_stmt|;
name|res
operator|->
name|genericarg
operator|=
name|Generic_This_Type
expr_stmt|;
name|res
operator|->
name|freearg
operator|=
name|freecallback
expr_stmt|;
name|res
operator|->
name|enum_next
operator|.
name|gnext
operator|=
name|next
expr_stmt|;
name|res
operator|->
name|enum_prev
operator|.
name|gprev
operator|=
name|prev
expr_stmt|;
name|code
operator|=
name|E_OK
expr_stmt|;
block|}
block|}
else|else
name|code
operator|=
name|E_BAD_ARGUMENT
expr_stmt|;
if|if
condition|(
name|E_OK
operator|!=
name|code
condition|)
name|SET_ERROR
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|returnFieldType
argument_list|(
name|res
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform   |   Function      :  static TypeArgument *GenericArgument( |                      const FIELDTYPE* typ, |                      int (*argiterator)(void**), |                      int* err) |    |   Description   :  The iterator callback must browse through all fieldtype |                    parameters that have an argument associated with the |                    type. The iterator returns 1 if the operation to get |                    the next element was successfull, 0 otherwise. If the |                    iterator could move to the next argument, it fills |                    the void* pointer representing the argument into the |                    location provided as argument to the iterator. |                    The err reference is used to keep track of errors. | |   Return Values :  Pointer to argument structure +--------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|TypeArgument
modifier|*
name|GenericArgument
parameter_list|(
specifier|const
name|FIELDTYPE
modifier|*
name|typ
parameter_list|,
name|int
function_decl|(
modifier|*
name|argiterator
function_decl|)
parameter_list|(
name|void
modifier|*
modifier|*
parameter_list|)
parameter_list|,
name|int
modifier|*
name|err
parameter_list|)
block|{
name|TypeArgument
modifier|*
name|res
init|=
operator|(
name|TypeArgument
operator|*
operator|)
literal|0
decl_stmt|;
if|if
condition|(
name|typ
operator|!=
literal|0
operator|&&
operator|(
name|typ
operator|->
name|status
operator|&
name|_HAS_ARGS
operator|)
operator|!=
literal|0
operator|&&
name|err
operator|!=
literal|0
operator|&&
name|argiterator
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|typ
operator|->
name|status
operator|&
name|_LINKED_TYPE
condition|)
block|{
comment|/* Composite fieldtypes keep track internally of their own memory */
name|TypeArgument
modifier|*
name|p
init|=
name|typeMalloc
argument_list|(
name|TypeArgument
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
condition|)
block|{
name|p
operator|->
name|left
operator|=
name|GenericArgument
argument_list|(
name|typ
operator|->
name|left
argument_list|,
name|argiterator
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|p
operator|->
name|right
operator|=
name|GenericArgument
argument_list|(
name|typ
operator|->
name|right
argument_list|,
name|argiterator
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
else|else
operator|*
name|err
operator|+=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|assert
argument_list|(
name|typ
operator|->
name|genericarg
operator|!=
operator|(
name|void
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|typ
operator|->
name|genericarg
operator|==
literal|0
condition|)
operator|*
name|err
operator|+=
literal|1
expr_stmt|;
else|else
block|{
name|void
modifier|*
name|argp
decl_stmt|;
name|int
name|valid
init|=
name|argiterator
argument_list|(
operator|&
name|argp
argument_list|)
decl_stmt|;
if|if
condition|(
name|valid
operator|==
literal|0
operator|||
name|argp
operator|==
literal|0
operator|||
operator|!
operator|(
name|res
operator|=
operator|(
name|TypeArgument
operator|*
operator|)
name|typ
operator|->
name|genericarg
argument_list|(
name|argp
argument_list|)
operator|)
condition|)
block|{
operator|*
name|err
operator|+=
literal|1
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform   |   Function      :  int _nc_set_generic_fieldtype( |                      FIELD* field, |                      FIELDTYPE* ftyp, |                      int (*argiterator)(void**)) |    |   Description   :  Assign the fieldtype to the field and use the iterator |                    mechanism to get the arguments when a check is  |                    performed. | |   Return Values :  E_OK if all went well |                    E_SYSTEM_ERROR if an error occurred +--------------------------------------------------------------------------*/
end_comment

begin_macro
name|NCURSES_EXPORT
argument_list|(
argument|int
argument_list|)
end_macro

begin_macro
name|_nc_set_generic_fieldtype
argument_list|(
argument|FIELD *field
argument_list|,
argument|FIELDTYPE *ftyp
argument_list|,
argument|int (*argiterator) (void **)
argument_list|)
end_macro

begin_block
block|{
name|int
name|code
init|=
name|E_SYSTEM_ERROR
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|field
condition|)
block|{
if|if
condition|(
name|field
operator|&&
name|field
operator|->
name|type
condition|)
name|_nc_Free_Type
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|field
operator|->
name|type
operator|=
name|ftyp
expr_stmt|;
if|if
condition|(
name|ftyp
condition|)
block|{
if|if
condition|(
name|argiterator
condition|)
block|{
comment|/* The precondition is that the iterator is reset */
name|field
operator|->
name|arg
operator|=
operator|(
name|void
operator|*
operator|)
name|GenericArgument
argument_list|(
name|field
operator|->
name|type
argument_list|,
name|argiterator
argument_list|,
operator|&
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|_nc_Free_Argument
argument_list|(
name|field
operator|->
name|type
argument_list|,
operator|(
name|TypeArgument
operator|*
operator|)
operator|(
name|field
operator|->
name|arg
operator|)
argument_list|)
expr_stmt|;
name|field
operator|->
name|type
operator|=
operator|(
name|FIELDTYPE
operator|*
operator|)
literal|0
expr_stmt|;
name|field
operator|->
name|arg
operator|=
operator|(
name|void
operator|*
operator|)
literal|0
expr_stmt|;
block|}
else|else
block|{
name|code
operator|=
name|E_OK
expr_stmt|;
if|if
condition|(
name|field
operator|->
name|type
condition|)
name|field
operator|->
name|type
operator|->
name|ref
operator|++
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|field
operator|->
name|arg
operator|=
operator|(
name|void
operator|*
operator|)
literal|0
expr_stmt|;
name|code
operator|=
name|E_OK
expr_stmt|;
block|}
block|}
return|return
name|code
return|;
block|}
end_block

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform   |   Function      :  WINDOW* _nc_form_cursor( |                      FORM* form, |                      int *pRow, int *pCol) |    |   Description   :  Get the current position of the form cursor position |                    We also return the field window | |   Return Values :  The fields Window or NULL on error +--------------------------------------------------------------------------*/
end_comment

begin_macro
name|NCURSES_EXPORT
argument_list|(
argument|WINDOW *
argument_list|)
end_macro

begin_macro
name|_nc_form_cursor
argument_list|(
argument|const FORM *form
argument_list|,
argument|int *pRow
argument_list|,
argument|int *pCol
argument_list|)
end_macro

begin_block
block|{
name|int
name|code
init|=
name|E_SYSTEM_ERROR
decl_stmt|;
name|WINDOW
modifier|*
name|res
init|=
operator|(
name|WINDOW
operator|*
operator|)
literal|0
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|form
operator|==
literal|0
operator|||
name|pRow
operator|==
literal|0
operator|||
name|pCol
operator|==
literal|0
operator|)
condition|)
block|{
operator|*
name|pRow
operator|=
name|form
operator|->
name|currow
expr_stmt|;
operator|*
name|pCol
operator|=
name|form
operator|->
name|curcol
expr_stmt|;
name|res
operator|=
name|form
operator|->
name|w
expr_stmt|;
name|code
operator|=
name|E_OK
expr_stmt|;
block|}
if|if
condition|(
name|code
operator|!=
name|E_OK
condition|)
name|SET_ERROR
argument_list|(
name|code
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_block

begin_else
else|#
directive|else
end_else

begin_function_decl
specifier|extern
name|void
name|_nc_fty_generic
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|_nc_fty_generic
parameter_list|(
name|void
parameter_list|)
block|{ }
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* fty_generic.c ends here */
end_comment

end_unit

